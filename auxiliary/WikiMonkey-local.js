/**
 * Modules in this bundle
 * @license
 *
 * @kynikos/wiki-monkey:
 *   license: GPL-3.0 (http://opensource.org/licenses/GPL-3.0)
 *   author: Dario Giovannetti
 *   version: 4.1.0
 *
 * @kynikos/misc:
 *   license: MIT (http://opensource.org/licenses/MIT)
 *   author: Dario Giovannetti
 *   homepage: https://github.com/kynikos/lib.js.misc#readme
 *   version: 0.1.3
 *
 * babel-polyfill:
 *   license: MIT (http://opensource.org/licenses/MIT)
 *   author: Sebastian McKenzie <sebmck@gmail.com>
 *   homepage: https://babeljs.io/
 *   version: 6.26.0
 *
 * browser-split:
 *   license: MIT (http://opensource.org/licenses/MIT)
 *   author: Julian Gruber <mail@juliangruber.com>
 *   homepage: https://github.com/juliangruber/browser-split
 *   version: 0.0.0
 *
 * class-list:
 *   licenses: MIT (http://opensource.org/licenses/MIT)
 *   author: Raynos <raynos2@gmail.com>
 *   contributors: Jake Verbaten
 *   homepage: https://github.com/Raynos/class-list
 *   version: 0.1.1
 *
 * core-js:
 *   license: MIT (http://opensource.org/licenses/MIT)
 *   homepage: https://github.com/zloirock/core-js#readme
 *   version: 2.5.1
 *
 * css-vendor:
 *   license: MIT (http://opensource.org/licenses/MIT)
 *   author: Oleg Slobodskoi <oleg008@gmail.com>
 *   homepage: https://github.com/cssinjs/css-vendor#readme
 *   version: 0.3.8
 *
 * hyperscript:
 *   license: MIT (http://opensource.org/licenses/MIT)
 *   author: 'Dominic Tarr' <dominic.tarr@gmail.com>
 *   homepage: https://github.com/dominictarr/hyperscript
 *   version: 2.0.2
 *
 * hyperscript-helpers:
 *   license: MIT (http://opensource.org/licenses/MIT)
 *   author: ohanhi
 *   homepage: https://github.com/ohanhi/hyperscript-helpers#readme
 *   version: 3.0.3
 *
 * indexof:
 *   version: 0.0.1
 *
 * is-in-browser:
 *   license: MIT (http://opensource.org/licenses/MIT)
 *   author: Jared Anderson
 *   homepage: https://github.com/tuxsudo/is-in-browser#readme
 *   version: 1.1.3
 *
 * jss:
 *   license: MIT (http://opensource.org/licenses/MIT)
 *   author: Oleg Slobodskoi <oleg008@gmail.com>
 *   homepage: https://github.com/cssinjs/jss#readme
 *   version: 9.5.1
 *
 * jss-camel-case:
 *   license: MIT (http://opensource.org/licenses/MIT)
 *   author: Oleg Slobodskoi <oleg008@gmail.com>
 *   homepage: https://github.com/cssinjs/jss-camel-case#readme
 *   version: 6.0.0
 *
 * jss-compose:
 *   license: MIT (http://opensource.org/licenses/MIT)
 *   author: Pavel Davydov <typical000@gmail.com>
 *   homepage: https://github.com/cssinjs/jss-compose#readme
 *   version: 5.0.0
 *
 * jss-default-unit:
 *   license: MIT (http://opensource.org/licenses/MIT)
 *   author: Oleg Slobodskoi <oleg008@gmail.com>
 *   homepage: https://github.com/cssinjs/jss-default-unit#readme
 *   version: 8.0.2
 *
 * jss-expand:
 *   license: MIT (http://opensource.org/licenses/MIT)
 *   author: Pavel Davydov <typical000@gmail.com>
 *   homepage: https://github.com/cssinjs/jss-expand#readme
 *   version: 5.1.0
 *
 * jss-extend:
 *   license: MIT (http://opensource.org/licenses/MIT)
 *   author: Oleg Slobodskoi <oleg008@gmail.com>
 *   homepage: https://github.com/cssinjs/jss-extend#readme
 *   version: 6.1.0
 *
 * jss-global:
 *   license: MIT (http://opensource.org/licenses/MIT)
 *   author: Oleg Slobodskoi <oleg008@gmail.com>
 *   homepage: https://github.com/cssinjs/jss-global
 *   version: 3.0.0
 *
 * jss-nested:
 *   license: MIT (http://opensource.org/licenses/MIT)
 *   author: Oleg Slobodskoi <oleg008@gmail.com>
 *   homepage: https://github.com/cssinjs/jss-nested#readme
 *   version: 6.0.1
 *
 * jss-preset-default:
 *   license: MIT (http://opensource.org/licenses/MIT)
 *   author: Oleg Slobodskoi <oleg008@gmail.com>
 *   homepage: https://github.com/cssinjs/jss-preset-default#readme
 *   version: 4.1.0
 *
 * jss-props-sort:
 *   license: MIT (http://opensource.org/licenses/MIT)
 *   author: Oleg Slobodskoi <oleg008@gmail.com>
 *   homepage: https://github.com/cssinjs/jss-props-sort#readme
 *   version: 6.0.0
 *
 * jss-template:
 *   license: MIT (http://opensource.org/licenses/MIT)
 *   author: Oleg Slobodskoi <oleg008@gmail.com>
 *   homepage: https://github.com/cssinjs/jss-template#readme
 *   version: 1.0.1
 *
 * jss-vendor-prefixer:
 *   license: MIT (http://opensource.org/licenses/MIT)
 *   author: Oleg Slobodskoi <oleg008@gmail.com>
 *   homepage: https://github.com/cssinjs/jss-vendor-prefixer#readme
 *   version: 7.0.0
 *
 * moment:
 *   license: MIT (http://opensource.org/licenses/MIT)
 *   author: Iskren Ivov Chernev <iskren.chernev@gmail.com>
 *   contributors: Tim Wood <washwithcare@gmail.com>, Rocky Meza, Matt Johnson <mj1856@hotmail.com>, Isaac Cambron <isaac@isaaccambron.com>, Andre Polykanine <andre@oire.org>
 *   homepage: http://momentjs.com
 *   version: 2.20.1
 *
 * process:
 *   license: MIT (http://opensource.org/licenses/MIT)
 *   author: Roman Shtylman <shtylman@gmail.com>
 *   homepage: https://github.com/shtylman/node-process#readme
 *   version: 0.11.10
 *
 * regenerator-runtime:
 *   license: MIT (http://opensource.org/licenses/MIT)
 *   author: Ben Newman <bn@cs.stanford.edu>
 *   version: 0.10.5
 *
 * symbol-observable:
 *   license: MIT (http://opensource.org/licenses/MIT)
 *   author: Ben Lesh <ben@benlesh.com>
 *   homepage: https://github.com/blesh/symbol-observable#readme
 *   version: 1.1.0
 *
 * vue:
 *   license: MIT (http://opensource.org/licenses/MIT)
 *   author: Evan You
 *   homepage: https://github.com/vuejs/vue#readme
 *   version: 2.5.13
 *
 * warning:
 *   license: BSD-3-Clause (http://opensource.org/licenses/BSD-3-Clause)
 *   author: Berkeley Martinez <berkeley@r3dm.com>
 *   homepage: https://github.com/BerkeleyTrue/warning
 *   version: 3.0.0
 *
 * This header is generated by licensify (https://github.com/twada/licensify)
 */
(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
"use strict";

// Generated by CoffeeScript 2.1.1
// JavaScript auxiliary library
// Copyright (C) 2012 Dario Giovannetti <dev@dariogiovannetti.net>

// This file is part of JavaScript auxiliary library.

// JavaScript auxiliary library is free software: you can redistribute it
// and/or modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation, either version 3
// of the License, or (at your option) any later version.

// JavaScript auxiliary library is distributed in the hope that it will be
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with JavaScript auxiliary library.
// If not, see <http://www.gnu.org/licenses/>.
module.exports.executeAsync = function (functions, id) {
  var _this = this;

  var callContinue, fid;
  id++;
  if (functions[id]) {
    fid = functions[id];
    callContinue = function callContinue() {
      return _this.executeAsync(functions, id);
    };
    return fid[0](fid[1], callContinue);
  }
};

module.exports.recurseTreeAsync = function (params) {
  var parent;
  // params = {
  //   node: ,
  //   parentIndex: ,
  //   siblingIndex: ,
  //   ancestors: ,
  //   children: ,
  //   callChildren: ,
  //   callNode: ,
  //   callEnd: ,
  //   callArgs: ,
  //   stage: ,
  //   nodesList:
  // }

  // nodesList: [
  //   {
  //     node: ,
  //     parentIndex: ,
  //     siblingIndex: ,
  //     ancestors: [...],
  //     children: [...]
  //   },
  //   {...}
  // ]

  // Example:

  // recurseTreeAsync({
  //   node: ,
  //   callChildren: ,
  //   callNode: ,
  //   callEnd: ,
  //   callArgs:
  // });

  // callChildren(params) {
  //   params.children = ;
  //   recurseTreeAsync(params);
  // }

  // callNode(params) {
  //   recurseTreeAsync(params);
  // }

  // callEnd(params) {}
  switch (params.stage) {
    case void 0:
      params.parentIndex = null;
      params.siblingIndex = 0;
      params.ancestors = [];
      params.children = [];
      params.nodesList = [];
      params.stage = 1;
      return this.recurseTreeAsync(params);
    case 1:
      params.stage = 2;
      // Prevent infinite loops
      if (params.ancestors.indexOf(params.node) === -1) {
        return params.callChildren(params);
      } else {
        params.children = "loop";
        return this.recurseTreeAsync(params);
      }
      break;
    case 2:
      params.nodesList.push({
        node: params.node,
        parentIndex: params.parentIndex,
        siblingIndex: params.siblingIndex,
        ancestors: params.ancestors.slice(0),
        children: params.children.slice(0)
      });
      params.stage = 3;
      return params.callNode(params);
    case 3:
      if (params.children.length && params.children !== "loop") {
        // Go to the first child
        params.ancestors.push(params.node);
        params.node = params.children[0];
        params.parentIndex = params.nodesList.length - 1;
        params.siblingIndex = 0;
        params.children = [];
        params.stage = 1;
        return this.recurseTreeAsync(params);
      } else if (params.parentIndex !== null) {
        // Go to the next sibling
        parent = params.nodesList[params.parentIndex];
        params.siblingIndex++;
        params.node = parent.children[params.siblingIndex];
        params.children = [];
        if (params.node) {
          params.stage = 1;
        } else {
          // There are no more siblings
          params.node = parent.node;
          params.parentIndex = parent.parentIndex;
          params.siblingIndex = parent.siblingIndex;
          params.ancestors = parent.ancestors.slice(0);
          params.stage = 3;
        }
        return this.recurseTreeAsync(params);
      } else {
        // End of recursion
        return params.callEnd(params);
      }
  }
};
},{}],2:[function(require,module,exports){
"use strict";

// Generated by CoffeeScript 2.1.1
// JavaScript auxiliary library
// Copyright (C) 2012 Dario Giovannetti <dev@dariogiovannetti.net>

// This file is part of JavaScript auxiliary library.

// JavaScript auxiliary library is free software: you can redistribute it
// and/or modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation, either version 3
// of the License, or (at your option) any later version.

// JavaScript auxiliary library is distributed in the hope that it will be
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with JavaScript auxiliary library.
// If not, see <http://www.gnu.org/licenses/>.
module.exports.escapePattern = function (string) {
  // Escaping any other characters is not necessary, references:
  // - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions
  // - http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
  // - http://stackoverflow.com/questions/2593637/how-to-escape-regular-expression-in-javascript
  // - http://stackoverflow.com/questions/494035/how-do-you-pass-a-variable-to-a-regular-expression-javascript
  // - http://stackoverflow.com/questions/3446170/escape-string-for-use-in-javascript-regex
  // - http://stackoverflow.com/questions/399078/what-special-characters-must-be-escaped-in-regular-expressions

  // Note for Wiki Monkey: do *not* escape '\s' here so that it will be
  // safe to use prepareRegexpWhitespace in WM.Parser
  return string.replace(/[-[\]{}()^$*+?.|\\]/g, "\\$&");
};

module.exports.matchAll = function (source, regExp) {
  var L, match, result;
  result = [];
  while (true) {
    match = regExp.exec(source);
    if (match) {
      L = match[0].length;
      result.push({
        "match": match,
        "index": regExp.lastIndex - L,
        "length": L
      });
    } else {
      break;
    }
  }
  return result;
};

module.exports.matchAllConditional = function (source, regExp, test) {
  var L, match, result;
  result = [];
  while (true) {
    match = regExp.exec(source);
    if (match && test(match)) {
      L = match[0].length;
      result.push({
        "match": match,
        "index": regExp.lastIndex - L,
        "length": L
      });
    } else {
      break;
    }
  }
  return result;
};
},{}],3:[function(require,module,exports){
"use strict";

// Generated by CoffeeScript 2.1.1
// JavaScript auxiliary library
// Copyright (C) 2012 Dario Giovannetti <dev@dariogiovannetti.net>

// This file is part of JavaScript auxiliary library.

// JavaScript auxiliary library is free software: you can redistribute it
// and/or modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation, either version 3
// of the License, or (at your option) any later version.

// JavaScript auxiliary library is distributed in the hope that it will be
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with JavaScript auxiliary library.
// If not, see <http://www.gnu.org/licenses/>.
module.exports.insert = function (string, newString, id) {
  if (id == null) {
    id = 0;
  }
  return string.substring(0, id) + newString + string.substr(id);
};

module.exports.overwriteFor = function (string, newString, id, length) {
  if (id == null) {
    id = 0;
  }
  if (!length || length < 0) {
    length = 0;
  }
  return string.substring(0, id) + newString + string.substr(id + length);
};

module.exports.overwriteAt = function (string, newString, id) {
  return module.exports.overwriteFor(string, newString, id, newString.length);
};

module.exports.overwriteBetween = function (string, newString, id1, id2) {
  var tempid;
  if (id1 == null) {
    id1 = 0;
  }
  if (id2 == null) {
    id2 = id1;
  }
  if (id1 > id2) {
    tempid = id2;
    id2 = id1;
    id1 = tempid;
  }
  return string.substring(0, id1) + newString + string.substr(id2);
};

module.exports.removeFor = function (string, id, length) {
  return module.exports.overwriteFor(string, "", id, length);
};

module.exports.removeBetween = function (string, id1, id2) {
  return module.exports.overwriteBetween(string, "", id1, id2);
};

module.exports.padLeft = function (string, filler, length) {
  while (string.length < length) {
    string = filler + string;
  }
  return string;
};

module.exports.padRight = function (string, filler, length) {
  while (string.length < length) {
    string += filler;
  }
  return string;
};

module.exports.findSimpleEnclosures = function (string, openTag, openLength, closeTag, closeLength) {
  var cIndex, cIndexRel, oIndex, oIndexRel, results, searchIndex;
  // openTag and closeTag can be strings or regular expressions
  // If the string is "<<>>" and the tags are "<" and ">", the result is
  //   [[0, 2], ]
  // Results are guaranteed to be in order of appearance in the original
  //   text
  results = [];
  searchIndex = 0;
  oIndexRel = string.search(openTag);
  while (true) {
    if (oIndexRel > -1) {
      oIndex = searchIndex + oIndexRel;
      cIndexRel = string.substr(oIndex + openLength).search(closeTag);
      if (cIndexRel > -1) {
        cIndex = oIndex + openLength + cIndexRel;
        results.push([oIndex, cIndex]);
        searchIndex = cIndex + closeLength;
        if (searchIndex < string.length) {
          oIndexRel = string.substr(searchIndex).search(openTag);
          continue;
        } else {
          break;
        }
      } else {
        // A tag is left open (no closing tag is found)
        // Let each implementation decide what to do in this case
        //   (either consider the tag working until the end of text
        //   or not)
        results.push([oIndex, false]);
        break;
      }
    } else {
      break;
    }
  }
  return results;
};

module.exports.findNestedEnclosures = function (string, openTag, closeTag, maskChar) {
  var cIndex, cIndexRel, closeLength, maskLength, maskedString, maskedString1, maskedString2, maskedString3, oIndex, oIndexRel, openLength, results, searchIndex;
  // openTag and closeTag must be strings, *not* regular expressions,
  //   unlike this.findSimpleEnclosures
  // maskChar must be a *1*-character string and must *not* be part of
  //   neither openTag nor closeTag
  // If the string is "<<>>" and the tags are "<" and ">", the result is
  //   [[1, 2], [0, 3]]
  openLength = openTag.length;
  closeLength = closeTag.length;
  results = [];
  searchIndex = 0;
  cIndexRel = string.indexOf(closeTag);
  maskedString = string;
  while (true) {
    if (cIndexRel > -1) {
      cIndex = searchIndex + cIndexRel;
      oIndexRel = maskedString.substring(searchIndex, cIndex).lastIndexOf(openTag);
      if (oIndexRel > -1) {
        oIndex = searchIndex + oIndexRel;
        results.push([oIndex, cIndex]);
        maskedString1 = maskedString.substring(0, oIndex);
        maskLength = cIndex - oIndex + closeLength;
        maskedString2 = module.exports.padRight("", maskChar, maskLength);
        maskedString3 = maskedString.substring(cIndex + closeLength);
        maskedString = maskedString1 + maskedString2 + maskedString3;
      } else {
        // Do *not* increment searchIndex in this case, in fact in
        //   we don't know yet whether there are more openTags
        //   before the one found
        searchIndex = cIndex + closeLength;
      }
      cIndexRel = maskedString.substring(searchIndex).indexOf(closeTag);
      continue;
    } else {
      break;
    }
  }
  return [results, maskedString];
};

module.exports.findInnermostEnclosures = function (string, openTag, closeTag) {
  var cIndex, cIndexRel, closeLength, oIndex, oIndexRel, openLength, results, searchIndex;
  // openTag and closeTag must be strings, *not* regular expressions,
  //   unlike this.findSimpleEnclosures
  // If the string is "<<>>" and the tags are "<" and ">", the result is
  //   [[1, 2], ]
  openLength = openTag.length;
  closeLength = closeTag.length;
  results = [];
  searchIndex = 0;
  while (true) {
    cIndexRel = string.substring(searchIndex).indexOf(closeTag);
    if (cIndexRel > -1) {
      cIndex = searchIndex + cIndexRel;
      oIndexRel = string.substring(searchIndex, cIndex).lastIndexOf(openTag);
      if (oIndexRel > -1) {
        oIndex = searchIndex + oIndexRel;
        results.push([oIndex, cIndex]);
      }
      searchIndex = cIndex + closeLength;
      continue;
    } else {
      break;
    }
  }
  return results;
};
},{}],4:[function(require,module,exports){
(function (global){
"use strict";

require("core-js/shim");

require("regenerator-runtime/runtime");

require("core-js/fn/regexp/escape");

if (global._babelPolyfill) {
  throw new Error("only one instance of babel-polyfill is allowed");
}
global._babelPolyfill = true;

var DEFINE_PROPERTY = "defineProperty";
function define(O, key, value) {
  O[key] || Object[DEFINE_PROPERTY](O, key, {
    writable: true,
    configurable: true,
    value: value
  });
}

define(String.prototype, "padLeft", "".padStart);
define(String.prototype, "padRight", "".padEnd);

"pop,reverse,shift,keys,values,entries,indexOf,every,some,forEach,map,filter,find,findIndex,includes,join,slice,concat,push,splice,unshift,sort,lastIndexOf,reduce,reduceRight,copyWithin,fill".split(",").forEach(function (key) {
  [][key] && define(Array, key, Function.call.bind([][key]));
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"core-js/fn/regexp/escape":9,"core-js/shim":331,"regenerator-runtime/runtime":5}],5:[function(require,module,exports){
(function (global){
/**
 * Copyright (c) 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
 * additional grant of patent rights can be found in the PATENTS file in
 * the same directory.
 */

!(function(global) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  var inModule = typeof module === "object";
  var runtime = global.regeneratorRuntime;
  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    }
    // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.
    return;
  }

  // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.
  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  runtime.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  runtime.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  runtime.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  runtime.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration. If the Promise is rejected, however, the
          // result for this iteration will be rejected with the same
          // reason. Note that rejections of yielded Promises are not
          // thrown back into the generator function, as is the case
          // when an awaited Promise is rejected. This difference in
          // behavior between yield and await is important, because it
          // allows the consumer to decide what to do with the yielded
          // rejection (swallow it and continue, manually .throw it back
          // into the generator, abandon iteration, whatever). With
          // await, by contrast, there is no opportunity to examine the
          // rejection reason outside the generator function, so the
          // only option is to throw it from the await expression, and
          // let the generator function handle the exception.
          result.value = unwrapped;
          resolve(result);
        }, reject);
      }
    }

    if (typeof global.process === "object" && global.process.domain) {
      invoke = global.process.domain.bind(invoke);
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  runtime.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList)
    );

    return runtime.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        if (delegate.iterator.return) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  runtime.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  runtime.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };
})(
  // Among the various tricks for obtaining a reference to the global
  // object, this seems to be the most reliable technique that does not
  // use indirect eval (which violates Content Security Policy).
  typeof global === "object" ? global :
  typeof window === "object" ? window :
  typeof self === "object" ? self : this
);

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],6:[function(require,module,exports){

},{}],7:[function(require,module,exports){
/*!
 * Cross-Browser Split 1.1.1
 * Copyright 2007-2012 Steven Levithan <stevenlevithan.com>
 * Available under the MIT License
 * ECMAScript compliant, uniform cross-browser split method
 */

/**
 * Splits a string into an array of strings using a regex or string separator. Matches of the
 * separator are not included in the result array. However, if `separator` is a regex that contains
 * capturing groups, backreferences are spliced into the result each time `separator` is matched.
 * Fixes browser bugs compared to the native `String.prototype.split` and can be used reliably
 * cross-browser.
 * @param {String} str String to split.
 * @param {RegExp|String} separator Regex or string to use for separating the string.
 * @param {Number} [limit] Maximum number of items to include in the result array.
 * @returns {Array} Array of substrings.
 * @example
 *
 * // Basic use
 * split('a b c d', ' ');
 * // -> ['a', 'b', 'c', 'd']
 *
 * // With limit
 * split('a b c d', ' ', 2);
 * // -> ['a', 'b']
 *
 * // Backreferences in result array
 * split('..word1 word2..', /([a-z]+)(\d+)/i);
 * // -> ['..', 'word', '1', ' ', 'word', '2', '..']
 */
module.exports = (function split(undef) {

  var nativeSplit = String.prototype.split,
    compliantExecNpcg = /()??/.exec("")[1] === undef,
    // NPCG: nonparticipating capturing group
    self;

  self = function(str, separator, limit) {
    // If `separator` is not a regex, use `nativeSplit`
    if (Object.prototype.toString.call(separator) !== "[object RegExp]") {
      return nativeSplit.call(str, separator, limit);
    }
    var output = [],
      flags = (separator.ignoreCase ? "i" : "") + (separator.multiline ? "m" : "") + (separator.extended ? "x" : "") + // Proposed for ES6
      (separator.sticky ? "y" : ""),
      // Firefox 3+
      lastLastIndex = 0,
      // Make `global` and avoid `lastIndex` issues by working with a copy
      separator = new RegExp(separator.source, flags + "g"),
      separator2, match, lastIndex, lastLength;
    str += ""; // Type-convert
    if (!compliantExecNpcg) {
      // Doesn't need flags gy, but they don't hurt
      separator2 = new RegExp("^" + separator.source + "$(?!\\s)", flags);
    }
    /* Values for `limit`, per the spec:
     * If undefined: 4294967295 // Math.pow(2, 32) - 1
     * If 0, Infinity, or NaN: 0
     * If positive number: limit = Math.floor(limit); if (limit > 4294967295) limit -= 4294967296;
     * If negative number: 4294967296 - Math.floor(Math.abs(limit))
     * If other: Type-convert, then use the above rules
     */
    limit = limit === undef ? -1 >>> 0 : // Math.pow(2, 32) - 1
    limit >>> 0; // ToUint32(limit)
    while (match = separator.exec(str)) {
      // `separator.lastIndex` is not reliable cross-browser
      lastIndex = match.index + match[0].length;
      if (lastIndex > lastLastIndex) {
        output.push(str.slice(lastLastIndex, match.index));
        // Fix browsers whose `exec` methods don't consistently return `undefined` for
        // nonparticipating capturing groups
        if (!compliantExecNpcg && match.length > 1) {
          match[0].replace(separator2, function() {
            for (var i = 1; i < arguments.length - 2; i++) {
              if (arguments[i] === undef) {
                match[i] = undef;
              }
            }
          });
        }
        if (match.length > 1 && match.index < str.length) {
          Array.prototype.push.apply(output, match.slice(1));
        }
        lastLength = match[0].length;
        lastLastIndex = lastIndex;
        if (output.length >= limit) {
          break;
        }
      }
      if (separator.lastIndex === match.index) {
        separator.lastIndex++; // Avoid an infinite loop
      }
    }
    if (lastLastIndex === str.length) {
      if (lastLength || !separator.test("")) {
        output.push("");
      }
    } else {
      output.push(str.slice(lastLastIndex));
    }
    return output.length > limit ? output.slice(0, limit) : output;
  };

  return self;
})();

},{}],8:[function(require,module,exports){
// contains, add, remove, toggle
var indexof = require('indexof')

module.exports = ClassList

function ClassList(elem) {
    var cl = elem.classList

    if (cl) {
        return cl
    }

    var classList = {
        add: add
        , remove: remove
        , contains: contains
        , toggle: toggle
        , toString: $toString
        , length: 0
        , item: item
    }

    return classList

    function add(token) {
        var list = getTokens()
        if (indexof(list, token) > -1) {
            return
        }
        list.push(token)
        setTokens(list)
    }

    function remove(token) {
        var list = getTokens()
            , index = indexof(list, token)

        if (index === -1) {
            return
        }

        list.splice(index, 1)
        setTokens(list)
    }

    function contains(token) {
        return indexof(getTokens(), token) > -1
    }

    function toggle(token) {
        if (contains(token)) {
            remove(token)
            return false
        } else {
            add(token)
            return true
        }
    }

    function $toString() {
        return elem.className
    }

    function item(index) {
        var tokens = getTokens()
        return tokens[index] || null
    }

    function getTokens() {
        var className = elem.className

        return filter(className.split(" "), isTruthy)
    }

    function setTokens(list) {
        var length = list.length

        elem.className = list.join(" ")
        classList.length = length

        for (var i = 0; i < list.length; i++) {
            classList[i] = list[i]
        }

        delete list[length]
    }
}

function filter (arr, fn) {
    var ret = []
    for (var i = 0; i < arr.length; i++) {
        if (fn(arr[i])) ret.push(arr[i])
    }
    return ret
}

function isTruthy(value) {
    return !!value
}

},{"indexof":339}],9:[function(require,module,exports){
require('../../modules/core.regexp.escape');
module.exports = require('../../modules/_core').RegExp.escape;

},{"../../modules/_core":30,"../../modules/core.regexp.escape":134}],10:[function(require,module,exports){
module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};

},{}],11:[function(require,module,exports){
var cof = require('./_cof');
module.exports = function (it, msg) {
  if (typeof it != 'number' && cof(it) != 'Number') throw TypeError(msg);
  return +it;
};

},{"./_cof":25}],12:[function(require,module,exports){
// 22.1.3.31 Array.prototype[@@unscopables]
var UNSCOPABLES = require('./_wks')('unscopables');
var ArrayProto = Array.prototype;
if (ArrayProto[UNSCOPABLES] == undefined) require('./_hide')(ArrayProto, UNSCOPABLES, {});
module.exports = function (key) {
  ArrayProto[UNSCOPABLES][key] = true;
};

},{"./_hide":49,"./_wks":132}],13:[function(require,module,exports){
module.exports = function (it, Constructor, name, forbiddenField) {
  if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {
    throw TypeError(name + ': incorrect invocation!');
  } return it;
};

},{}],14:[function(require,module,exports){
var isObject = require('./_is-object');
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};

},{"./_is-object":58}],15:[function(require,module,exports){
// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
'use strict';
var toObject = require('./_to-object');
var toAbsoluteIndex = require('./_to-absolute-index');
var toLength = require('./_to-length');

module.exports = [].copyWithin || function copyWithin(target /* = 0 */, start /* = 0, end = @length */) {
  var O = toObject(this);
  var len = toLength(O.length);
  var to = toAbsoluteIndex(target, len);
  var from = toAbsoluteIndex(start, len);
  var end = arguments.length > 2 ? arguments[2] : undefined;
  var count = Math.min((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to);
  var inc = 1;
  if (from < to && to < from + count) {
    inc = -1;
    from += count - 1;
    to += count - 1;
  }
  while (count-- > 0) {
    if (from in O) O[to] = O[from];
    else delete O[to];
    to += inc;
    from += inc;
  } return O;
};

},{"./_to-absolute-index":118,"./_to-length":122,"./_to-object":123}],16:[function(require,module,exports){
// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
'use strict';
var toObject = require('./_to-object');
var toAbsoluteIndex = require('./_to-absolute-index');
var toLength = require('./_to-length');
module.exports = function fill(value /* , start = 0, end = @length */) {
  var O = toObject(this);
  var length = toLength(O.length);
  var aLen = arguments.length;
  var index = toAbsoluteIndex(aLen > 1 ? arguments[1] : undefined, length);
  var end = aLen > 2 ? arguments[2] : undefined;
  var endPos = end === undefined ? length : toAbsoluteIndex(end, length);
  while (endPos > index) O[index++] = value;
  return O;
};

},{"./_to-absolute-index":118,"./_to-length":122,"./_to-object":123}],17:[function(require,module,exports){
var forOf = require('./_for-of');

module.exports = function (iter, ITERATOR) {
  var result = [];
  forOf(iter, false, result.push, result, ITERATOR);
  return result;
};

},{"./_for-of":46}],18:[function(require,module,exports){
// false -> Array#indexOf
// true  -> Array#includes
var toIObject = require('./_to-iobject');
var toLength = require('./_to-length');
var toAbsoluteIndex = require('./_to-absolute-index');
module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

},{"./_to-absolute-index":118,"./_to-iobject":121,"./_to-length":122}],19:[function(require,module,exports){
// 0 -> Array#forEach
// 1 -> Array#map
// 2 -> Array#filter
// 3 -> Array#some
// 4 -> Array#every
// 5 -> Array#find
// 6 -> Array#findIndex
var ctx = require('./_ctx');
var IObject = require('./_iobject');
var toObject = require('./_to-object');
var toLength = require('./_to-length');
var asc = require('./_array-species-create');
module.exports = function (TYPE, $create) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  var create = $create || asc;
  return function ($this, callbackfn, that) {
    var O = toObject($this);
    var self = IObject(O);
    var f = ctx(callbackfn, that, 3);
    var length = toLength(self.length);
    var index = 0;
    var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
    var val, res;
    for (;length > index; index++) if (NO_HOLES || index in self) {
      val = self[index];
      res = f(val, index, O);
      if (TYPE) {
        if (IS_MAP) result[index] = res;   // map
        else if (res) switch (TYPE) {
          case 3: return true;             // some
          case 5: return val;              // find
          case 6: return index;            // findIndex
          case 2: result.push(val);        // filter
        } else if (IS_EVERY) return false; // every
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
  };
};

},{"./_array-species-create":22,"./_ctx":32,"./_iobject":54,"./_to-length":122,"./_to-object":123}],20:[function(require,module,exports){
var aFunction = require('./_a-function');
var toObject = require('./_to-object');
var IObject = require('./_iobject');
var toLength = require('./_to-length');

module.exports = function (that, callbackfn, aLen, memo, isRight) {
  aFunction(callbackfn);
  var O = toObject(that);
  var self = IObject(O);
  var length = toLength(O.length);
  var index = isRight ? length - 1 : 0;
  var i = isRight ? -1 : 1;
  if (aLen < 2) for (;;) {
    if (index in self) {
      memo = self[index];
      index += i;
      break;
    }
    index += i;
    if (isRight ? index < 0 : length <= index) {
      throw TypeError('Reduce of empty array with no initial value');
    }
  }
  for (;isRight ? index >= 0 : length > index; index += i) if (index in self) {
    memo = callbackfn(memo, self[index], index, O);
  }
  return memo;
};

},{"./_a-function":10,"./_iobject":54,"./_to-length":122,"./_to-object":123}],21:[function(require,module,exports){
var isObject = require('./_is-object');
var isArray = require('./_is-array');
var SPECIES = require('./_wks')('species');

module.exports = function (original) {
  var C;
  if (isArray(original)) {
    C = original.constructor;
    // cross-realm fallback
    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
    if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  } return C === undefined ? Array : C;
};

},{"./_is-array":56,"./_is-object":58,"./_wks":132}],22:[function(require,module,exports){
// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
var speciesConstructor = require('./_array-species-constructor');

module.exports = function (original, length) {
  return new (speciesConstructor(original))(length);
};

},{"./_array-species-constructor":21}],23:[function(require,module,exports){
'use strict';
var aFunction = require('./_a-function');
var isObject = require('./_is-object');
var invoke = require('./_invoke');
var arraySlice = [].slice;
var factories = {};

var construct = function (F, len, args) {
  if (!(len in factories)) {
    for (var n = [], i = 0; i < len; i++) n[i] = 'a[' + i + ']';
    // eslint-disable-next-line no-new-func
    factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');
  } return factories[len](F, args);
};

module.exports = Function.bind || function bind(that /* , ...args */) {
  var fn = aFunction(this);
  var partArgs = arraySlice.call(arguments, 1);
  var bound = function (/* args... */) {
    var args = partArgs.concat(arraySlice.call(arguments));
    return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that);
  };
  if (isObject(fn.prototype)) bound.prototype = fn.prototype;
  return bound;
};

},{"./_a-function":10,"./_invoke":53,"./_is-object":58}],24:[function(require,module,exports){
// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = require('./_cof');
var TAG = require('./_wks')('toStringTag');
// ES3 wrong here
var ARG = cof(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (e) { /* empty */ }
};

module.exports = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};

},{"./_cof":25,"./_wks":132}],25:[function(require,module,exports){
var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};

},{}],26:[function(require,module,exports){
'use strict';
var dP = require('./_object-dp').f;
var create = require('./_object-create');
var redefineAll = require('./_redefine-all');
var ctx = require('./_ctx');
var anInstance = require('./_an-instance');
var forOf = require('./_for-of');
var $iterDefine = require('./_iter-define');
var step = require('./_iter-step');
var setSpecies = require('./_set-species');
var DESCRIPTORS = require('./_descriptors');
var fastKey = require('./_meta').fastKey;
var validate = require('./_validate-collection');
var SIZE = DESCRIPTORS ? '_s' : 'size';

var getEntry = function (that, key) {
  // fast case
  var index = fastKey(key);
  var entry;
  if (index !== 'F') return that._i[index];
  // frozen object case
  for (entry = that._f; entry; entry = entry.n) {
    if (entry.k == key) return entry;
  }
};

module.exports = {
  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME;         // collection type
      that._i = create(null); // index
      that._f = undefined;    // first entry
      that._l = undefined;    // last entry
      that[SIZE] = 0;         // size
      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear() {
        for (var that = validate(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {
          entry.r = true;
          if (entry.p) entry.p = entry.p.n = undefined;
          delete data[entry.i];
        }
        that._f = that._l = undefined;
        that[SIZE] = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function (key) {
        var that = validate(this, NAME);
        var entry = getEntry(that, key);
        if (entry) {
          var next = entry.n;
          var prev = entry.p;
          delete that._i[entry.i];
          entry.r = true;
          if (prev) prev.n = next;
          if (next) next.p = prev;
          if (that._f == entry) that._f = next;
          if (that._l == entry) that._l = prev;
          that[SIZE]--;
        } return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn /* , that = undefined */) {
        validate(this, NAME);
        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
        var entry;
        while (entry = entry ? entry.n : this._f) {
          f(entry.v, entry.k, this);
          // revert to the last existing entry
          while (entry && entry.r) entry = entry.p;
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key) {
        return !!getEntry(validate(this, NAME), key);
      }
    });
    if (DESCRIPTORS) dP(C.prototype, 'size', {
      get: function () {
        return validate(this, NAME)[SIZE];
      }
    });
    return C;
  },
  def: function (that, key, value) {
    var entry = getEntry(that, key);
    var prev, index;
    // change existing entry
    if (entry) {
      entry.v = value;
    // create new entry
    } else {
      that._l = entry = {
        i: index = fastKey(key, true), // <- index
        k: key,                        // <- key
        v: value,                      // <- value
        p: prev = that._l,             // <- previous entry
        n: undefined,                  // <- next entry
        r: false                       // <- removed
      };
      if (!that._f) that._f = entry;
      if (prev) prev.n = entry;
      that[SIZE]++;
      // add to index
      if (index !== 'F') that._i[index] = entry;
    } return that;
  },
  getEntry: getEntry,
  setStrong: function (C, NAME, IS_MAP) {
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    $iterDefine(C, NAME, function (iterated, kind) {
      this._t = validate(iterated, NAME); // target
      this._k = kind;                     // kind
      this._l = undefined;                // previous
    }, function () {
      var that = this;
      var kind = that._k;
      var entry = that._l;
      // revert to the last existing entry
      while (entry && entry.r) entry = entry.p;
      // get next entry
      if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
        // or finish the iteration
        that._t = undefined;
        return step(1);
      }
      // return step by kind
      if (kind == 'keys') return step(0, entry.k);
      if (kind == 'values') return step(0, entry.v);
      return step(0, [entry.k, entry.v]);
    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);

    // add [@@species], 23.1.2.2, 23.2.2.2
    setSpecies(NAME);
  }
};

},{"./_an-instance":13,"./_ctx":32,"./_descriptors":36,"./_for-of":46,"./_iter-define":62,"./_iter-step":64,"./_meta":72,"./_object-create":77,"./_object-dp":78,"./_redefine-all":97,"./_set-species":104,"./_validate-collection":129}],27:[function(require,module,exports){
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var classof = require('./_classof');
var from = require('./_array-from-iterable');
module.exports = function (NAME) {
  return function toJSON() {
    if (classof(this) != NAME) throw TypeError(NAME + "#toJSON isn't generic");
    return from(this);
  };
};

},{"./_array-from-iterable":17,"./_classof":24}],28:[function(require,module,exports){
'use strict';
var redefineAll = require('./_redefine-all');
var getWeak = require('./_meta').getWeak;
var anObject = require('./_an-object');
var isObject = require('./_is-object');
var anInstance = require('./_an-instance');
var forOf = require('./_for-of');
var createArrayMethod = require('./_array-methods');
var $has = require('./_has');
var validate = require('./_validate-collection');
var arrayFind = createArrayMethod(5);
var arrayFindIndex = createArrayMethod(6);
var id = 0;

// fallback for uncaught frozen keys
var uncaughtFrozenStore = function (that) {
  return that._l || (that._l = new UncaughtFrozenStore());
};
var UncaughtFrozenStore = function () {
  this.a = [];
};
var findUncaughtFrozen = function (store, key) {
  return arrayFind(store.a, function (it) {
    return it[0] === key;
  });
};
UncaughtFrozenStore.prototype = {
  get: function (key) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) return entry[1];
  },
  has: function (key) {
    return !!findUncaughtFrozen(this, key);
  },
  set: function (key, value) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) entry[1] = value;
    else this.a.push([key, value]);
  },
  'delete': function (key) {
    var index = arrayFindIndex(this.a, function (it) {
      return it[0] === key;
    });
    if (~index) this.a.splice(index, 1);
    return !!~index;
  }
};

module.exports = {
  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME;      // collection type
      that._i = id++;      // collection id
      that._l = undefined; // leak store for uncaught frozen objects
      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.3.3.2 WeakMap.prototype.delete(key)
      // 23.4.3.3 WeakSet.prototype.delete(value)
      'delete': function (key) {
        if (!isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(validate(this, NAME))['delete'](key);
        return data && $has(data, this._i) && delete data[this._i];
      },
      // 23.3.3.4 WeakMap.prototype.has(key)
      // 23.4.3.4 WeakSet.prototype.has(value)
      has: function has(key) {
        if (!isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(validate(this, NAME)).has(key);
        return data && $has(data, this._i);
      }
    });
    return C;
  },
  def: function (that, key, value) {
    var data = getWeak(anObject(key), true);
    if (data === true) uncaughtFrozenStore(that).set(key, value);
    else data[that._i] = value;
    return that;
  },
  ufstore: uncaughtFrozenStore
};

},{"./_an-instance":13,"./_an-object":14,"./_array-methods":19,"./_for-of":46,"./_has":48,"./_is-object":58,"./_meta":72,"./_redefine-all":97,"./_validate-collection":129}],29:[function(require,module,exports){
'use strict';
var global = require('./_global');
var $export = require('./_export');
var redefine = require('./_redefine');
var redefineAll = require('./_redefine-all');
var meta = require('./_meta');
var forOf = require('./_for-of');
var anInstance = require('./_an-instance');
var isObject = require('./_is-object');
var fails = require('./_fails');
var $iterDetect = require('./_iter-detect');
var setToStringTag = require('./_set-to-string-tag');
var inheritIfRequired = require('./_inherit-if-required');

module.exports = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
  var Base = global[NAME];
  var C = Base;
  var ADDER = IS_MAP ? 'set' : 'add';
  var proto = C && C.prototype;
  var O = {};
  var fixMethod = function (KEY) {
    var fn = proto[KEY];
    redefine(proto, KEY,
      KEY == 'delete' ? function (a) {
        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'has' ? function has(a) {
        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'get' ? function get(a) {
        return IS_WEAK && !isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'add' ? function add(a) { fn.call(this, a === 0 ? 0 : a); return this; }
        : function set(a, b) { fn.call(this, a === 0 ? 0 : a, b); return this; }
    );
  };
  if (typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function () {
    new C().entries().next();
  }))) {
    // create collection constructor
    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
    redefineAll(C.prototype, methods);
    meta.NEED = true;
  } else {
    var instance = new C();
    // early implementations not supports chaining
    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;
    // V8 ~  Chromium 40- weak-collections throws on primitives, but should return false
    var THROWS_ON_PRIMITIVES = fails(function () { instance.has(1); });
    // most early implementations doesn't supports iterables, most modern - not close it correctly
    var ACCEPT_ITERABLES = $iterDetect(function (iter) { new C(iter); }); // eslint-disable-line no-new
    // for early implementations -0 and +0 not the same
    var BUGGY_ZERO = !IS_WEAK && fails(function () {
      // V8 ~ Chromium 42- fails only with 5+ elements
      var $instance = new C();
      var index = 5;
      while (index--) $instance[ADDER](index, index);
      return !$instance.has(-0);
    });
    if (!ACCEPT_ITERABLES) {
      C = wrapper(function (target, iterable) {
        anInstance(target, C, NAME);
        var that = inheritIfRequired(new Base(), target, C);
        if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
        return that;
      });
      C.prototype = proto;
      proto.constructor = C;
    }
    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
      fixMethod('delete');
      fixMethod('has');
      IS_MAP && fixMethod('get');
    }
    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);
    // weak collections should not contains .clear method
    if (IS_WEAK && proto.clear) delete proto.clear;
  }

  setToStringTag(C, NAME);

  O[NAME] = C;
  $export($export.G + $export.W + $export.F * (C != Base), O);

  if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);

  return C;
};

},{"./_an-instance":13,"./_export":40,"./_fails":42,"./_for-of":46,"./_global":47,"./_inherit-if-required":52,"./_is-object":58,"./_iter-detect":63,"./_meta":72,"./_redefine":98,"./_redefine-all":97,"./_set-to-string-tag":105}],30:[function(require,module,exports){
var core = module.exports = { version: '2.5.1' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef

},{}],31:[function(require,module,exports){
'use strict';
var $defineProperty = require('./_object-dp');
var createDesc = require('./_property-desc');

module.exports = function (object, index, value) {
  if (index in object) $defineProperty.f(object, index, createDesc(0, value));
  else object[index] = value;
};

},{"./_object-dp":78,"./_property-desc":96}],32:[function(require,module,exports){
// optional / simple context binding
var aFunction = require('./_a-function');
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};

},{"./_a-function":10}],33:[function(require,module,exports){
'use strict';
// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()
var fails = require('./_fails');
var getTime = Date.prototype.getTime;
var $toISOString = Date.prototype.toISOString;

var lz = function (num) {
  return num > 9 ? num : '0' + num;
};

// PhantomJS / old WebKit has a broken implementations
module.exports = (fails(function () {
  return $toISOString.call(new Date(-5e13 - 1)) != '0385-07-25T07:06:39.999Z';
}) || !fails(function () {
  $toISOString.call(new Date(NaN));
})) ? function toISOString() {
  if (!isFinite(getTime.call(this))) throw RangeError('Invalid time value');
  var d = this;
  var y = d.getUTCFullYear();
  var m = d.getUTCMilliseconds();
  var s = y < 0 ? '-' : y > 9999 ? '+' : '';
  return s + ('00000' + Math.abs(y)).slice(s ? -6 : -4) +
    '-' + lz(d.getUTCMonth() + 1) + '-' + lz(d.getUTCDate()) +
    'T' + lz(d.getUTCHours()) + ':' + lz(d.getUTCMinutes()) +
    ':' + lz(d.getUTCSeconds()) + '.' + (m > 99 ? m : '0' + lz(m)) + 'Z';
} : $toISOString;

},{"./_fails":42}],34:[function(require,module,exports){
'use strict';
var anObject = require('./_an-object');
var toPrimitive = require('./_to-primitive');
var NUMBER = 'number';

module.exports = function (hint) {
  if (hint !== 'string' && hint !== NUMBER && hint !== 'default') throw TypeError('Incorrect hint');
  return toPrimitive(anObject(this), hint != NUMBER);
};

},{"./_an-object":14,"./_to-primitive":124}],35:[function(require,module,exports){
// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};

},{}],36:[function(require,module,exports){
// Thank's IE8 for his funny defineProperty
module.exports = !require('./_fails')(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});

},{"./_fails":42}],37:[function(require,module,exports){
var isObject = require('./_is-object');
var document = require('./_global').document;
// typeof document.createElement is 'object' in old IE
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};

},{"./_global":47,"./_is-object":58}],38:[function(require,module,exports){
// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');

},{}],39:[function(require,module,exports){
// all enumerable object keys, includes symbols
var getKeys = require('./_object-keys');
var gOPS = require('./_object-gops');
var pIE = require('./_object-pie');
module.exports = function (it) {
  var result = getKeys(it);
  var getSymbols = gOPS.f;
  if (getSymbols) {
    var symbols = getSymbols(it);
    var isEnum = pIE.f;
    var i = 0;
    var key;
    while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);
  } return result;
};

},{"./_object-gops":84,"./_object-keys":87,"./_object-pie":88}],40:[function(require,module,exports){
var global = require('./_global');
var core = require('./_core');
var hide = require('./_hide');
var redefine = require('./_redefine');
var ctx = require('./_ctx');
var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE];
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});
  var key, own, out, exp;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    // export native or passed
    out = (own ? target : source)[key];
    // bind timers to global for call from export context
    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // extend global
    if (target) redefine(target, key, out, type & $export.U);
    // export
    if (exports[key] != out) hide(exports, key, exp);
    if (IS_PROTO && expProto[key] != out) expProto[key] = out;
  }
};
global.core = core;
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;

},{"./_core":30,"./_ctx":32,"./_global":47,"./_hide":49,"./_redefine":98}],41:[function(require,module,exports){
var MATCH = require('./_wks')('match');
module.exports = function (KEY) {
  var re = /./;
  try {
    '/./'[KEY](re);
  } catch (e) {
    try {
      re[MATCH] = false;
      return !'/./'[KEY](re);
    } catch (f) { /* empty */ }
  } return true;
};

},{"./_wks":132}],42:[function(require,module,exports){
module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};

},{}],43:[function(require,module,exports){
'use strict';
var hide = require('./_hide');
var redefine = require('./_redefine');
var fails = require('./_fails');
var defined = require('./_defined');
var wks = require('./_wks');

module.exports = function (KEY, length, exec) {
  var SYMBOL = wks(KEY);
  var fns = exec(defined, SYMBOL, ''[KEY]);
  var strfn = fns[0];
  var rxfn = fns[1];
  if (fails(function () {
    var O = {};
    O[SYMBOL] = function () { return 7; };
    return ''[KEY](O) != 7;
  })) {
    redefine(String.prototype, KEY, strfn);
    hide(RegExp.prototype, SYMBOL, length == 2
      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
      // 21.2.5.11 RegExp.prototype[@@split](string, limit)
      ? function (string, arg) { return rxfn.call(string, this, arg); }
      // 21.2.5.6 RegExp.prototype[@@match](string)
      // 21.2.5.9 RegExp.prototype[@@search](string)
      : function (string) { return rxfn.call(string, this); }
    );
  }
};

},{"./_defined":35,"./_fails":42,"./_hide":49,"./_redefine":98,"./_wks":132}],44:[function(require,module,exports){
'use strict';
// 21.2.5.3 get RegExp.prototype.flags
var anObject = require('./_an-object');
module.exports = function () {
  var that = anObject(this);
  var result = '';
  if (that.global) result += 'g';
  if (that.ignoreCase) result += 'i';
  if (that.multiline) result += 'm';
  if (that.unicode) result += 'u';
  if (that.sticky) result += 'y';
  return result;
};

},{"./_an-object":14}],45:[function(require,module,exports){
'use strict';
// https://tc39.github.io/proposal-flatMap/#sec-FlattenIntoArray
var isArray = require('./_is-array');
var isObject = require('./_is-object');
var toLength = require('./_to-length');
var ctx = require('./_ctx');
var IS_CONCAT_SPREADABLE = require('./_wks')('isConcatSpreadable');

function flattenIntoArray(target, original, source, sourceLen, start, depth, mapper, thisArg) {
  var targetIndex = start;
  var sourceIndex = 0;
  var mapFn = mapper ? ctx(mapper, thisArg, 3) : false;
  var element, spreadable;

  while (sourceIndex < sourceLen) {
    if (sourceIndex in source) {
      element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];

      spreadable = false;
      if (isObject(element)) {
        spreadable = element[IS_CONCAT_SPREADABLE];
        spreadable = spreadable !== undefined ? !!spreadable : isArray(element);
      }

      if (spreadable && depth > 0) {
        targetIndex = flattenIntoArray(target, original, element, toLength(element.length), targetIndex, depth - 1) - 1;
      } else {
        if (targetIndex >= 0x1fffffffffffff) throw TypeError();
        target[targetIndex] = element;
      }

      targetIndex++;
    }
    sourceIndex++;
  }
  return targetIndex;
}

module.exports = flattenIntoArray;

},{"./_ctx":32,"./_is-array":56,"./_is-object":58,"./_to-length":122,"./_wks":132}],46:[function(require,module,exports){
var ctx = require('./_ctx');
var call = require('./_iter-call');
var isArrayIter = require('./_is-array-iter');
var anObject = require('./_an-object');
var toLength = require('./_to-length');
var getIterFn = require('./core.get-iterator-method');
var BREAK = {};
var RETURN = {};
var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
  var iterFn = ITERATOR ? function () { return iterable; } : getIterFn(iterable);
  var f = ctx(fn, that, entries ? 2 : 1);
  var index = 0;
  var length, step, iterator, result;
  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
  // fast case for arrays with default iterator
  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
    if (result === BREAK || result === RETURN) return result;
  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
    result = call(iterator, f, step.value, entries);
    if (result === BREAK || result === RETURN) return result;
  }
};
exports.BREAK = BREAK;
exports.RETURN = RETURN;

},{"./_an-object":14,"./_ctx":32,"./_is-array-iter":55,"./_iter-call":60,"./_to-length":122,"./core.get-iterator-method":133}],47:[function(require,module,exports){
// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef

},{}],48:[function(require,module,exports){
var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};

},{}],49:[function(require,module,exports){
var dP = require('./_object-dp');
var createDesc = require('./_property-desc');
module.exports = require('./_descriptors') ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};

},{"./_descriptors":36,"./_object-dp":78,"./_property-desc":96}],50:[function(require,module,exports){
var document = require('./_global').document;
module.exports = document && document.documentElement;

},{"./_global":47}],51:[function(require,module,exports){
module.exports = !require('./_descriptors') && !require('./_fails')(function () {
  return Object.defineProperty(require('./_dom-create')('div'), 'a', { get: function () { return 7; } }).a != 7;
});

},{"./_descriptors":36,"./_dom-create":37,"./_fails":42}],52:[function(require,module,exports){
var isObject = require('./_is-object');
var setPrototypeOf = require('./_set-proto').set;
module.exports = function (that, target, C) {
  var S = target.constructor;
  var P;
  if (S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf) {
    setPrototypeOf(that, P);
  } return that;
};

},{"./_is-object":58,"./_set-proto":103}],53:[function(require,module,exports){
// fast apply, http://jsperf.lnkit.com/fast-apply/5
module.exports = function (fn, args, that) {
  var un = that === undefined;
  switch (args.length) {
    case 0: return un ? fn()
                      : fn.call(that);
    case 1: return un ? fn(args[0])
                      : fn.call(that, args[0]);
    case 2: return un ? fn(args[0], args[1])
                      : fn.call(that, args[0], args[1]);
    case 3: return un ? fn(args[0], args[1], args[2])
                      : fn.call(that, args[0], args[1], args[2]);
    case 4: return un ? fn(args[0], args[1], args[2], args[3])
                      : fn.call(that, args[0], args[1], args[2], args[3]);
  } return fn.apply(that, args);
};

},{}],54:[function(require,module,exports){
// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = require('./_cof');
// eslint-disable-next-line no-prototype-builtins
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};

},{"./_cof":25}],55:[function(require,module,exports){
// check on default Array iterator
var Iterators = require('./_iterators');
var ITERATOR = require('./_wks')('iterator');
var ArrayProto = Array.prototype;

module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};

},{"./_iterators":65,"./_wks":132}],56:[function(require,module,exports){
// 7.2.2 IsArray(argument)
var cof = require('./_cof');
module.exports = Array.isArray || function isArray(arg) {
  return cof(arg) == 'Array';
};

},{"./_cof":25}],57:[function(require,module,exports){
// 20.1.2.3 Number.isInteger(number)
var isObject = require('./_is-object');
var floor = Math.floor;
module.exports = function isInteger(it) {
  return !isObject(it) && isFinite(it) && floor(it) === it;
};

},{"./_is-object":58}],58:[function(require,module,exports){
module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};

},{}],59:[function(require,module,exports){
// 7.2.8 IsRegExp(argument)
var isObject = require('./_is-object');
var cof = require('./_cof');
var MATCH = require('./_wks')('match');
module.exports = function (it) {
  var isRegExp;
  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');
};

},{"./_cof":25,"./_is-object":58,"./_wks":132}],60:[function(require,module,exports){
// call something on iterator step with safe closing on error
var anObject = require('./_an-object');
module.exports = function (iterator, fn, value, entries) {
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch (e) {
    var ret = iterator['return'];
    if (ret !== undefined) anObject(ret.call(iterator));
    throw e;
  }
};

},{"./_an-object":14}],61:[function(require,module,exports){
'use strict';
var create = require('./_object-create');
var descriptor = require('./_property-desc');
var setToStringTag = require('./_set-to-string-tag');
var IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
require('./_hide')(IteratorPrototype, require('./_wks')('iterator'), function () { return this; });

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
  setToStringTag(Constructor, NAME + ' Iterator');
};

},{"./_hide":49,"./_object-create":77,"./_property-desc":96,"./_set-to-string-tag":105,"./_wks":132}],62:[function(require,module,exports){
'use strict';
var LIBRARY = require('./_library');
var $export = require('./_export');
var redefine = require('./_redefine');
var hide = require('./_hide');
var has = require('./_has');
var Iterators = require('./_iterators');
var $iterCreate = require('./_iter-create');
var setToStringTag = require('./_set-to-string-tag');
var getPrototypeOf = require('./_object-gpo');
var ITERATOR = require('./_wks')('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function () { return this; };

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);
  var getMethod = function (kind) {
    if (!BUGGY && kind in proto) return proto[kind];
    switch (kind) {
      case KEYS: return function keys() { return new Constructor(this, kind); };
      case VALUES: return function values() { return new Constructor(this, kind); };
    } return function entries() { return new Constructor(this, kind); };
  };
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  // Fix native
  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if (!LIBRARY && !has(IteratorPrototype, ITERATOR)) hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;
    $default = function values() { return $native.call(this); };
  }
  // Define iterator
  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;
  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};

},{"./_export":40,"./_has":48,"./_hide":49,"./_iter-create":61,"./_iterators":65,"./_library":66,"./_object-gpo":85,"./_redefine":98,"./_set-to-string-tag":105,"./_wks":132}],63:[function(require,module,exports){
var ITERATOR = require('./_wks')('iterator');
var SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();
  riter['return'] = function () { SAFE_CLOSING = true; };
  // eslint-disable-next-line no-throw-literal
  Array.from(riter, function () { throw 2; });
} catch (e) { /* empty */ }

module.exports = function (exec, skipClosing) {
  if (!skipClosing && !SAFE_CLOSING) return false;
  var safe = false;
  try {
    var arr = [7];
    var iter = arr[ITERATOR]();
    iter.next = function () { return { done: safe = true }; };
    arr[ITERATOR] = function () { return iter; };
    exec(arr);
  } catch (e) { /* empty */ }
  return safe;
};

},{"./_wks":132}],64:[function(require,module,exports){
module.exports = function (done, value) {
  return { value: value, done: !!done };
};

},{}],65:[function(require,module,exports){
module.exports = {};

},{}],66:[function(require,module,exports){
module.exports = false;

},{}],67:[function(require,module,exports){
// 20.2.2.14 Math.expm1(x)
var $expm1 = Math.expm1;
module.exports = (!$expm1
  // Old FF bug
  || $expm1(10) > 22025.465794806719 || $expm1(10) < 22025.4657948067165168
  // Tor Browser bug
  || $expm1(-2e-17) != -2e-17
) ? function expm1(x) {
  return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : Math.exp(x) - 1;
} : $expm1;

},{}],68:[function(require,module,exports){
// 20.2.2.16 Math.fround(x)
var sign = require('./_math-sign');
var pow = Math.pow;
var EPSILON = pow(2, -52);
var EPSILON32 = pow(2, -23);
var MAX32 = pow(2, 127) * (2 - EPSILON32);
var MIN32 = pow(2, -126);

var roundTiesToEven = function (n) {
  return n + 1 / EPSILON - 1 / EPSILON;
};

module.exports = Math.fround || function fround(x) {
  var $abs = Math.abs(x);
  var $sign = sign(x);
  var a, result;
  if ($abs < MIN32) return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
  a = (1 + EPSILON32 / EPSILON) * $abs;
  result = a - (a - $abs);
  // eslint-disable-next-line no-self-compare
  if (result > MAX32 || result != result) return $sign * Infinity;
  return $sign * result;
};

},{"./_math-sign":71}],69:[function(require,module,exports){
// 20.2.2.20 Math.log1p(x)
module.exports = Math.log1p || function log1p(x) {
  return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : Math.log(1 + x);
};

},{}],70:[function(require,module,exports){
// https://rwaldron.github.io/proposal-math-extensions/
module.exports = Math.scale || function scale(x, inLow, inHigh, outLow, outHigh) {
  if (
    arguments.length === 0
      // eslint-disable-next-line no-self-compare
      || x != x
      // eslint-disable-next-line no-self-compare
      || inLow != inLow
      // eslint-disable-next-line no-self-compare
      || inHigh != inHigh
      // eslint-disable-next-line no-self-compare
      || outLow != outLow
      // eslint-disable-next-line no-self-compare
      || outHigh != outHigh
  ) return NaN;
  if (x === Infinity || x === -Infinity) return x;
  return (x - inLow) * (outHigh - outLow) / (inHigh - inLow) + outLow;
};

},{}],71:[function(require,module,exports){
// 20.2.2.28 Math.sign(x)
module.exports = Math.sign || function sign(x) {
  // eslint-disable-next-line no-self-compare
  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
};

},{}],72:[function(require,module,exports){
var META = require('./_uid')('meta');
var isObject = require('./_is-object');
var has = require('./_has');
var setDesc = require('./_object-dp').f;
var id = 0;
var isExtensible = Object.isExtensible || function () {
  return true;
};
var FREEZE = !require('./_fails')(function () {
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function (it) {
  setDesc(it, META, { value: {
    i: 'O' + ++id, // object ID
    w: {}          // weak collections IDs
  } });
};
var fastKey = function (it, create) {
  // return primitive with prefix
  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F';
    // not necessary to add metadata
    if (!create) return 'E';
    // add missing metadata
    setMeta(it);
  // return object ID
  } return it[META].i;
};
var getWeak = function (it, create) {
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true;
    // not necessary to add metadata
    if (!create) return false;
    // add missing metadata
    setMeta(it);
  // return hash weak collections IDs
  } return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function (it) {
  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY: META,
  NEED: false,
  fastKey: fastKey,
  getWeak: getWeak,
  onFreeze: onFreeze
};

},{"./_fails":42,"./_has":48,"./_is-object":58,"./_object-dp":78,"./_uid":128}],73:[function(require,module,exports){
var Map = require('./es6.map');
var $export = require('./_export');
var shared = require('./_shared')('metadata');
var store = shared.store || (shared.store = new (require('./es6.weak-map'))());

var getOrCreateMetadataMap = function (target, targetKey, create) {
  var targetMetadata = store.get(target);
  if (!targetMetadata) {
    if (!create) return undefined;
    store.set(target, targetMetadata = new Map());
  }
  var keyMetadata = targetMetadata.get(targetKey);
  if (!keyMetadata) {
    if (!create) return undefined;
    targetMetadata.set(targetKey, keyMetadata = new Map());
  } return keyMetadata;
};
var ordinaryHasOwnMetadata = function (MetadataKey, O, P) {
  var metadataMap = getOrCreateMetadataMap(O, P, false);
  return metadataMap === undefined ? false : metadataMap.has(MetadataKey);
};
var ordinaryGetOwnMetadata = function (MetadataKey, O, P) {
  var metadataMap = getOrCreateMetadataMap(O, P, false);
  return metadataMap === undefined ? undefined : metadataMap.get(MetadataKey);
};
var ordinaryDefineOwnMetadata = function (MetadataKey, MetadataValue, O, P) {
  getOrCreateMetadataMap(O, P, true).set(MetadataKey, MetadataValue);
};
var ordinaryOwnMetadataKeys = function (target, targetKey) {
  var metadataMap = getOrCreateMetadataMap(target, targetKey, false);
  var keys = [];
  if (metadataMap) metadataMap.forEach(function (_, key) { keys.push(key); });
  return keys;
};
var toMetaKey = function (it) {
  return it === undefined || typeof it == 'symbol' ? it : String(it);
};
var exp = function (O) {
  $export($export.S, 'Reflect', O);
};

module.exports = {
  store: store,
  map: getOrCreateMetadataMap,
  has: ordinaryHasOwnMetadata,
  get: ordinaryGetOwnMetadata,
  set: ordinaryDefineOwnMetadata,
  keys: ordinaryOwnMetadataKeys,
  key: toMetaKey,
  exp: exp
};

},{"./_export":40,"./_shared":107,"./es6.map":164,"./es6.weak-map":270}],74:[function(require,module,exports){
var global = require('./_global');
var macrotask = require('./_task').set;
var Observer = global.MutationObserver || global.WebKitMutationObserver;
var process = global.process;
var Promise = global.Promise;
var isNode = require('./_cof')(process) == 'process';

module.exports = function () {
  var head, last, notify;

  var flush = function () {
    var parent, fn;
    if (isNode && (parent = process.domain)) parent.exit();
    while (head) {
      fn = head.fn;
      head = head.next;
      try {
        fn();
      } catch (e) {
        if (head) notify();
        else last = undefined;
        throw e;
      }
    } last = undefined;
    if (parent) parent.enter();
  };

  // Node.js
  if (isNode) {
    notify = function () {
      process.nextTick(flush);
    };
  // browsers with MutationObserver
  } else if (Observer) {
    var toggle = true;
    var node = document.createTextNode('');
    new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new
    notify = function () {
      node.data = toggle = !toggle;
    };
  // environments with maybe non-completely correct, but existent Promise
  } else if (Promise && Promise.resolve) {
    var promise = Promise.resolve();
    notify = function () {
      promise.then(flush);
    };
  // for other environments - macrotask based on:
  // - setImmediate
  // - MessageChannel
  // - window.postMessag
  // - onreadystatechange
  // - setTimeout
  } else {
    notify = function () {
      // strange IE + webpack dev server bug - use .call(global)
      macrotask.call(global, flush);
    };
  }

  return function (fn) {
    var task = { fn: fn, next: undefined };
    if (last) last.next = task;
    if (!head) {
      head = task;
      notify();
    } last = task;
  };
};

},{"./_cof":25,"./_global":47,"./_task":117}],75:[function(require,module,exports){
'use strict';
// 25.4.1.5 NewPromiseCapability(C)
var aFunction = require('./_a-function');

function PromiseCapability(C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject = $$reject;
  });
  this.resolve = aFunction(resolve);
  this.reject = aFunction(reject);
}

module.exports.f = function (C) {
  return new PromiseCapability(C);
};

},{"./_a-function":10}],76:[function(require,module,exports){
'use strict';
// 19.1.2.1 Object.assign(target, source, ...)
var getKeys = require('./_object-keys');
var gOPS = require('./_object-gops');
var pIE = require('./_object-pie');
var toObject = require('./_to-object');
var IObject = require('./_iobject');
var $assign = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = !$assign || require('./_fails')(function () {
  var A = {};
  var B = {};
  // eslint-disable-next-line no-undef
  var S = Symbol();
  var K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function (k) { B[k] = k; });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source) { // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var aLen = arguments.length;
  var index = 1;
  var getSymbols = gOPS.f;
  var isEnum = pIE.f;
  while (aLen > index) {
    var S = IObject(arguments[index++]);
    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) if (isEnum.call(S, key = keys[j++])) T[key] = S[key];
  } return T;
} : $assign;

},{"./_fails":42,"./_iobject":54,"./_object-gops":84,"./_object-keys":87,"./_object-pie":88,"./_to-object":123}],77:[function(require,module,exports){
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = require('./_an-object');
var dPs = require('./_object-dps');
var enumBugKeys = require('./_enum-bug-keys');
var IE_PROTO = require('./_shared-key')('IE_PROTO');
var Empty = function () { /* empty */ };
var PROTOTYPE = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = require('./_dom-create')('iframe');
  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';
  require('./_html').appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};

},{"./_an-object":14,"./_dom-create":37,"./_enum-bug-keys":38,"./_html":50,"./_object-dps":79,"./_shared-key":106}],78:[function(require,module,exports){
var anObject = require('./_an-object');
var IE8_DOM_DEFINE = require('./_ie8-dom-define');
var toPrimitive = require('./_to-primitive');
var dP = Object.defineProperty;

exports.f = require('./_descriptors') ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};

},{"./_an-object":14,"./_descriptors":36,"./_ie8-dom-define":51,"./_to-primitive":124}],79:[function(require,module,exports){
var dP = require('./_object-dp');
var anObject = require('./_an-object');
var getKeys = require('./_object-keys');

module.exports = require('./_descriptors') ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;
  while (length > i) dP.f(O, P = keys[i++], Properties[P]);
  return O;
};

},{"./_an-object":14,"./_descriptors":36,"./_object-dp":78,"./_object-keys":87}],80:[function(require,module,exports){
'use strict';
// Forced replacement prototype accessors methods
module.exports = require('./_library') || !require('./_fails')(function () {
  var K = Math.random();
  // In FF throws only define methods
  // eslint-disable-next-line no-undef, no-useless-call
  __defineSetter__.call(null, K, function () { /* empty */ });
  delete require('./_global')[K];
});

},{"./_fails":42,"./_global":47,"./_library":66}],81:[function(require,module,exports){
var pIE = require('./_object-pie');
var createDesc = require('./_property-desc');
var toIObject = require('./_to-iobject');
var toPrimitive = require('./_to-primitive');
var has = require('./_has');
var IE8_DOM_DEFINE = require('./_ie8-dom-define');
var gOPD = Object.getOwnPropertyDescriptor;

exports.f = require('./_descriptors') ? gOPD : function getOwnPropertyDescriptor(O, P) {
  O = toIObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return gOPD(O, P);
  } catch (e) { /* empty */ }
  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
};

},{"./_descriptors":36,"./_has":48,"./_ie8-dom-define":51,"./_object-pie":88,"./_property-desc":96,"./_to-iobject":121,"./_to-primitive":124}],82:[function(require,module,exports){
// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = require('./_to-iobject');
var gOPN = require('./_object-gopn').f;
var toString = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return gOPN(it);
  } catch (e) {
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};

},{"./_object-gopn":83,"./_to-iobject":121}],83:[function(require,module,exports){
// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys = require('./_object-keys-internal');
var hiddenKeys = require('./_enum-bug-keys').concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return $keys(O, hiddenKeys);
};

},{"./_enum-bug-keys":38,"./_object-keys-internal":86}],84:[function(require,module,exports){
exports.f = Object.getOwnPropertySymbols;

},{}],85:[function(require,module,exports){
// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = require('./_has');
var toObject = require('./_to-object');
var IE_PROTO = require('./_shared-key')('IE_PROTO');
var ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};

},{"./_has":48,"./_shared-key":106,"./_to-object":123}],86:[function(require,module,exports){
var has = require('./_has');
var toIObject = require('./_to-iobject');
var arrayIndexOf = require('./_array-includes')(false);
var IE_PROTO = require('./_shared-key')('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};

},{"./_array-includes":18,"./_has":48,"./_shared-key":106,"./_to-iobject":121}],87:[function(require,module,exports){
// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = require('./_object-keys-internal');
var enumBugKeys = require('./_enum-bug-keys');

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};

},{"./_enum-bug-keys":38,"./_object-keys-internal":86}],88:[function(require,module,exports){
exports.f = {}.propertyIsEnumerable;

},{}],89:[function(require,module,exports){
// most Object methods by ES6 should accept primitives
var $export = require('./_export');
var core = require('./_core');
var fails = require('./_fails');
module.exports = function (KEY, exec) {
  var fn = (core.Object || {})[KEY] || Object[KEY];
  var exp = {};
  exp[KEY] = exec(fn);
  $export($export.S + $export.F * fails(function () { fn(1); }), 'Object', exp);
};

},{"./_core":30,"./_export":40,"./_fails":42}],90:[function(require,module,exports){
var getKeys = require('./_object-keys');
var toIObject = require('./_to-iobject');
var isEnum = require('./_object-pie').f;
module.exports = function (isEntries) {
  return function (it) {
    var O = toIObject(it);
    var keys = getKeys(O);
    var length = keys.length;
    var i = 0;
    var result = [];
    var key;
    while (length > i) if (isEnum.call(O, key = keys[i++])) {
      result.push(isEntries ? [key, O[key]] : O[key]);
    } return result;
  };
};

},{"./_object-keys":87,"./_object-pie":88,"./_to-iobject":121}],91:[function(require,module,exports){
// all object keys, includes non-enumerable and symbols
var gOPN = require('./_object-gopn');
var gOPS = require('./_object-gops');
var anObject = require('./_an-object');
var Reflect = require('./_global').Reflect;
module.exports = Reflect && Reflect.ownKeys || function ownKeys(it) {
  var keys = gOPN.f(anObject(it));
  var getSymbols = gOPS.f;
  return getSymbols ? keys.concat(getSymbols(it)) : keys;
};

},{"./_an-object":14,"./_global":47,"./_object-gopn":83,"./_object-gops":84}],92:[function(require,module,exports){
var $parseFloat = require('./_global').parseFloat;
var $trim = require('./_string-trim').trim;

module.exports = 1 / $parseFloat(require('./_string-ws') + '-0') !== -Infinity ? function parseFloat(str) {
  var string = $trim(String(str), 3);
  var result = $parseFloat(string);
  return result === 0 && string.charAt(0) == '-' ? -0 : result;
} : $parseFloat;

},{"./_global":47,"./_string-trim":115,"./_string-ws":116}],93:[function(require,module,exports){
var $parseInt = require('./_global').parseInt;
var $trim = require('./_string-trim').trim;
var ws = require('./_string-ws');
var hex = /^[-+]?0[xX]/;

module.exports = $parseInt(ws + '08') !== 8 || $parseInt(ws + '0x16') !== 22 ? function parseInt(str, radix) {
  var string = $trim(String(str), 3);
  return $parseInt(string, (radix >>> 0) || (hex.test(string) ? 16 : 10));
} : $parseInt;

},{"./_global":47,"./_string-trim":115,"./_string-ws":116}],94:[function(require,module,exports){
module.exports = function (exec) {
  try {
    return { e: false, v: exec() };
  } catch (e) {
    return { e: true, v: e };
  }
};

},{}],95:[function(require,module,exports){
var anObject = require('./_an-object');
var isObject = require('./_is-object');
var newPromiseCapability = require('./_new-promise-capability');

module.exports = function (C, x) {
  anObject(C);
  if (isObject(x) && x.constructor === C) return x;
  var promiseCapability = newPromiseCapability.f(C);
  var resolve = promiseCapability.resolve;
  resolve(x);
  return promiseCapability.promise;
};

},{"./_an-object":14,"./_is-object":58,"./_new-promise-capability":75}],96:[function(require,module,exports){
module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};

},{}],97:[function(require,module,exports){
var redefine = require('./_redefine');
module.exports = function (target, src, safe) {
  for (var key in src) redefine(target, key, src[key], safe);
  return target;
};

},{"./_redefine":98}],98:[function(require,module,exports){
var global = require('./_global');
var hide = require('./_hide');
var has = require('./_has');
var SRC = require('./_uid')('src');
var TO_STRING = 'toString';
var $toString = Function[TO_STRING];
var TPL = ('' + $toString).split(TO_STRING);

require('./_core').inspectSource = function (it) {
  return $toString.call(it);
};

(module.exports = function (O, key, val, safe) {
  var isFunction = typeof val == 'function';
  if (isFunction) has(val, 'name') || hide(val, 'name', key);
  if (O[key] === val) return;
  if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
  if (O === global) {
    O[key] = val;
  } else if (!safe) {
    delete O[key];
    hide(O, key, val);
  } else if (O[key]) {
    O[key] = val;
  } else {
    hide(O, key, val);
  }
// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, TO_STRING, function toString() {
  return typeof this == 'function' && this[SRC] || $toString.call(this);
});

},{"./_core":30,"./_global":47,"./_has":48,"./_hide":49,"./_uid":128}],99:[function(require,module,exports){
module.exports = function (regExp, replace) {
  var replacer = replace === Object(replace) ? function (part) {
    return replace[part];
  } : replace;
  return function (it) {
    return String(it).replace(regExp, replacer);
  };
};

},{}],100:[function(require,module,exports){
// 7.2.9 SameValue(x, y)
module.exports = Object.is || function is(x, y) {
  // eslint-disable-next-line no-self-compare
  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
};

},{}],101:[function(require,module,exports){
'use strict';
// https://tc39.github.io/proposal-setmap-offrom/
var $export = require('./_export');
var aFunction = require('./_a-function');
var ctx = require('./_ctx');
var forOf = require('./_for-of');

module.exports = function (COLLECTION) {
  $export($export.S, COLLECTION, { from: function from(source /* , mapFn, thisArg */) {
    var mapFn = arguments[1];
    var mapping, A, n, cb;
    aFunction(this);
    mapping = mapFn !== undefined;
    if (mapping) aFunction(mapFn);
    if (source == undefined) return new this();
    A = [];
    if (mapping) {
      n = 0;
      cb = ctx(mapFn, arguments[2], 2);
      forOf(source, false, function (nextItem) {
        A.push(cb(nextItem, n++));
      });
    } else {
      forOf(source, false, A.push, A);
    }
    return new this(A);
  } });
};

},{"./_a-function":10,"./_ctx":32,"./_export":40,"./_for-of":46}],102:[function(require,module,exports){
'use strict';
// https://tc39.github.io/proposal-setmap-offrom/
var $export = require('./_export');

module.exports = function (COLLECTION) {
  $export($export.S, COLLECTION, { of: function of() {
    var length = arguments.length;
    var A = Array(length);
    while (length--) A[length] = arguments[length];
    return new this(A);
  } });
};

},{"./_export":40}],103:[function(require,module,exports){
// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var isObject = require('./_is-object');
var anObject = require('./_an-object');
var check = function (O, proto) {
  anObject(O);
  if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
};
module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
    function (test, buggy, set) {
      try {
        set = require('./_ctx')(Function.call, require('./_object-gopd').f(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch (e) { buggy = true; }
      return function setPrototypeOf(O, proto) {
        check(O, proto);
        if (buggy) O.__proto__ = proto;
        else set(O, proto);
        return O;
      };
    }({}, false) : undefined),
  check: check
};

},{"./_an-object":14,"./_ctx":32,"./_is-object":58,"./_object-gopd":81}],104:[function(require,module,exports){
'use strict';
var global = require('./_global');
var dP = require('./_object-dp');
var DESCRIPTORS = require('./_descriptors');
var SPECIES = require('./_wks')('species');

module.exports = function (KEY) {
  var C = global[KEY];
  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
    configurable: true,
    get: function () { return this; }
  });
};

},{"./_descriptors":36,"./_global":47,"./_object-dp":78,"./_wks":132}],105:[function(require,module,exports){
var def = require('./_object-dp').f;
var has = require('./_has');
var TAG = require('./_wks')('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
};

},{"./_has":48,"./_object-dp":78,"./_wks":132}],106:[function(require,module,exports){
var shared = require('./_shared')('keys');
var uid = require('./_uid');
module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};

},{"./_shared":107,"./_uid":128}],107:[function(require,module,exports){
var global = require('./_global');
var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});
module.exports = function (key) {
  return store[key] || (store[key] = {});
};

},{"./_global":47}],108:[function(require,module,exports){
// 7.3.20 SpeciesConstructor(O, defaultConstructor)
var anObject = require('./_an-object');
var aFunction = require('./_a-function');
var SPECIES = require('./_wks')('species');
module.exports = function (O, D) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
};

},{"./_a-function":10,"./_an-object":14,"./_wks":132}],109:[function(require,module,exports){
'use strict';
var fails = require('./_fails');

module.exports = function (method, arg) {
  return !!method && fails(function () {
    // eslint-disable-next-line no-useless-call
    arg ? method.call(null, function () { /* empty */ }, 1) : method.call(null);
  });
};

},{"./_fails":42}],110:[function(require,module,exports){
var toInteger = require('./_to-integer');
var defined = require('./_defined');
// true  -> String#at
// false -> String#codePointAt
module.exports = function (TO_STRING) {
  return function (that, pos) {
    var s = String(defined(that));
    var i = toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};

},{"./_defined":35,"./_to-integer":120}],111:[function(require,module,exports){
// helper for String#{startsWith, endsWith, includes}
var isRegExp = require('./_is-regexp');
var defined = require('./_defined');

module.exports = function (that, searchString, NAME) {
  if (isRegExp(searchString)) throw TypeError('String#' + NAME + " doesn't accept regex!");
  return String(defined(that));
};

},{"./_defined":35,"./_is-regexp":59}],112:[function(require,module,exports){
var $export = require('./_export');
var fails = require('./_fails');
var defined = require('./_defined');
var quot = /"/g;
// B.2.3.2.1 CreateHTML(string, tag, attribute, value)
var createHTML = function (string, tag, attribute, value) {
  var S = String(defined(string));
  var p1 = '<' + tag;
  if (attribute !== '') p1 += ' ' + attribute + '="' + String(value).replace(quot, '&quot;') + '"';
  return p1 + '>' + S + '</' + tag + '>';
};
module.exports = function (NAME, exec) {
  var O = {};
  O[NAME] = exec(createHTML);
  $export($export.P + $export.F * fails(function () {
    var test = ''[NAME]('"');
    return test !== test.toLowerCase() || test.split('"').length > 3;
  }), 'String', O);
};

},{"./_defined":35,"./_export":40,"./_fails":42}],113:[function(require,module,exports){
// https://github.com/tc39/proposal-string-pad-start-end
var toLength = require('./_to-length');
var repeat = require('./_string-repeat');
var defined = require('./_defined');

module.exports = function (that, maxLength, fillString, left) {
  var S = String(defined(that));
  var stringLength = S.length;
  var fillStr = fillString === undefined ? ' ' : String(fillString);
  var intMaxLength = toLength(maxLength);
  if (intMaxLength <= stringLength || fillStr == '') return S;
  var fillLen = intMaxLength - stringLength;
  var stringFiller = repeat.call(fillStr, Math.ceil(fillLen / fillStr.length));
  if (stringFiller.length > fillLen) stringFiller = stringFiller.slice(0, fillLen);
  return left ? stringFiller + S : S + stringFiller;
};

},{"./_defined":35,"./_string-repeat":114,"./_to-length":122}],114:[function(require,module,exports){
'use strict';
var toInteger = require('./_to-integer');
var defined = require('./_defined');

module.exports = function repeat(count) {
  var str = String(defined(this));
  var res = '';
  var n = toInteger(count);
  if (n < 0 || n == Infinity) throw RangeError("Count can't be negative");
  for (;n > 0; (n >>>= 1) && (str += str)) if (n & 1) res += str;
  return res;
};

},{"./_defined":35,"./_to-integer":120}],115:[function(require,module,exports){
var $export = require('./_export');
var defined = require('./_defined');
var fails = require('./_fails');
var spaces = require('./_string-ws');
var space = '[' + spaces + ']';
var non = '\u200b\u0085';
var ltrim = RegExp('^' + space + space + '*');
var rtrim = RegExp(space + space + '*$');

var exporter = function (KEY, exec, ALIAS) {
  var exp = {};
  var FORCE = fails(function () {
    return !!spaces[KEY]() || non[KEY]() != non;
  });
  var fn = exp[KEY] = FORCE ? exec(trim) : spaces[KEY];
  if (ALIAS) exp[ALIAS] = fn;
  $export($export.P + $export.F * FORCE, 'String', exp);
};

// 1 -> String#trimLeft
// 2 -> String#trimRight
// 3 -> String#trim
var trim = exporter.trim = function (string, TYPE) {
  string = String(defined(string));
  if (TYPE & 1) string = string.replace(ltrim, '');
  if (TYPE & 2) string = string.replace(rtrim, '');
  return string;
};

module.exports = exporter;

},{"./_defined":35,"./_export":40,"./_fails":42,"./_string-ws":116}],116:[function(require,module,exports){
module.exports = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' +
  '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';

},{}],117:[function(require,module,exports){
var ctx = require('./_ctx');
var invoke = require('./_invoke');
var html = require('./_html');
var cel = require('./_dom-create');
var global = require('./_global');
var process = global.process;
var setTask = global.setImmediate;
var clearTask = global.clearImmediate;
var MessageChannel = global.MessageChannel;
var Dispatch = global.Dispatch;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var defer, channel, port;
var run = function () {
  var id = +this;
  // eslint-disable-next-line no-prototype-builtins
  if (queue.hasOwnProperty(id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};
var listener = function (event) {
  run.call(event.data);
};
// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if (!setTask || !clearTask) {
  setTask = function setImmediate(fn) {
    var args = [];
    var i = 1;
    while (arguments.length > i) args.push(arguments[i++]);
    queue[++counter] = function () {
      // eslint-disable-next-line no-new-func
      invoke(typeof fn == 'function' ? fn : Function(fn), args);
    };
    defer(counter);
    return counter;
  };
  clearTask = function clearImmediate(id) {
    delete queue[id];
  };
  // Node.js 0.8-
  if (require('./_cof')(process) == 'process') {
    defer = function (id) {
      process.nextTick(ctx(run, id, 1));
    };
  // Sphere (JS game engine) Dispatch API
  } else if (Dispatch && Dispatch.now) {
    defer = function (id) {
      Dispatch.now(ctx(run, id, 1));
    };
  // Browsers with MessageChannel, includes WebWorkers
  } else if (MessageChannel) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = ctx(port.postMessage, port, 1);
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
    defer = function (id) {
      global.postMessage(id + '', '*');
    };
    global.addEventListener('message', listener, false);
  // IE8-
  } else if (ONREADYSTATECHANGE in cel('script')) {
    defer = function (id) {
      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {
        html.removeChild(this);
        run.call(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function (id) {
      setTimeout(ctx(run, id, 1), 0);
    };
  }
}
module.exports = {
  set: setTask,
  clear: clearTask
};

},{"./_cof":25,"./_ctx":32,"./_dom-create":37,"./_global":47,"./_html":50,"./_invoke":53}],118:[function(require,module,exports){
var toInteger = require('./_to-integer');
var max = Math.max;
var min = Math.min;
module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};

},{"./_to-integer":120}],119:[function(require,module,exports){
// https://tc39.github.io/ecma262/#sec-toindex
var toInteger = require('./_to-integer');
var toLength = require('./_to-length');
module.exports = function (it) {
  if (it === undefined) return 0;
  var number = toInteger(it);
  var length = toLength(number);
  if (number !== length) throw RangeError('Wrong length!');
  return length;
};

},{"./_to-integer":120,"./_to-length":122}],120:[function(require,module,exports){
// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};

},{}],121:[function(require,module,exports){
// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = require('./_iobject');
var defined = require('./_defined');
module.exports = function (it) {
  return IObject(defined(it));
};

},{"./_defined":35,"./_iobject":54}],122:[function(require,module,exports){
// 7.1.15 ToLength
var toInteger = require('./_to-integer');
var min = Math.min;
module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};

},{"./_to-integer":120}],123:[function(require,module,exports){
// 7.1.13 ToObject(argument)
var defined = require('./_defined');
module.exports = function (it) {
  return Object(defined(it));
};

},{"./_defined":35}],124:[function(require,module,exports){
// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = require('./_is-object');
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};

},{"./_is-object":58}],125:[function(require,module,exports){
'use strict';
if (require('./_descriptors')) {
  var LIBRARY = require('./_library');
  var global = require('./_global');
  var fails = require('./_fails');
  var $export = require('./_export');
  var $typed = require('./_typed');
  var $buffer = require('./_typed-buffer');
  var ctx = require('./_ctx');
  var anInstance = require('./_an-instance');
  var propertyDesc = require('./_property-desc');
  var hide = require('./_hide');
  var redefineAll = require('./_redefine-all');
  var toInteger = require('./_to-integer');
  var toLength = require('./_to-length');
  var toIndex = require('./_to-index');
  var toAbsoluteIndex = require('./_to-absolute-index');
  var toPrimitive = require('./_to-primitive');
  var has = require('./_has');
  var classof = require('./_classof');
  var isObject = require('./_is-object');
  var toObject = require('./_to-object');
  var isArrayIter = require('./_is-array-iter');
  var create = require('./_object-create');
  var getPrototypeOf = require('./_object-gpo');
  var gOPN = require('./_object-gopn').f;
  var getIterFn = require('./core.get-iterator-method');
  var uid = require('./_uid');
  var wks = require('./_wks');
  var createArrayMethod = require('./_array-methods');
  var createArrayIncludes = require('./_array-includes');
  var speciesConstructor = require('./_species-constructor');
  var ArrayIterators = require('./es6.array.iterator');
  var Iterators = require('./_iterators');
  var $iterDetect = require('./_iter-detect');
  var setSpecies = require('./_set-species');
  var arrayFill = require('./_array-fill');
  var arrayCopyWithin = require('./_array-copy-within');
  var $DP = require('./_object-dp');
  var $GOPD = require('./_object-gopd');
  var dP = $DP.f;
  var gOPD = $GOPD.f;
  var RangeError = global.RangeError;
  var TypeError = global.TypeError;
  var Uint8Array = global.Uint8Array;
  var ARRAY_BUFFER = 'ArrayBuffer';
  var SHARED_BUFFER = 'Shared' + ARRAY_BUFFER;
  var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
  var PROTOTYPE = 'prototype';
  var ArrayProto = Array[PROTOTYPE];
  var $ArrayBuffer = $buffer.ArrayBuffer;
  var $DataView = $buffer.DataView;
  var arrayForEach = createArrayMethod(0);
  var arrayFilter = createArrayMethod(2);
  var arraySome = createArrayMethod(3);
  var arrayEvery = createArrayMethod(4);
  var arrayFind = createArrayMethod(5);
  var arrayFindIndex = createArrayMethod(6);
  var arrayIncludes = createArrayIncludes(true);
  var arrayIndexOf = createArrayIncludes(false);
  var arrayValues = ArrayIterators.values;
  var arrayKeys = ArrayIterators.keys;
  var arrayEntries = ArrayIterators.entries;
  var arrayLastIndexOf = ArrayProto.lastIndexOf;
  var arrayReduce = ArrayProto.reduce;
  var arrayReduceRight = ArrayProto.reduceRight;
  var arrayJoin = ArrayProto.join;
  var arraySort = ArrayProto.sort;
  var arraySlice = ArrayProto.slice;
  var arrayToString = ArrayProto.toString;
  var arrayToLocaleString = ArrayProto.toLocaleString;
  var ITERATOR = wks('iterator');
  var TAG = wks('toStringTag');
  var TYPED_CONSTRUCTOR = uid('typed_constructor');
  var DEF_CONSTRUCTOR = uid('def_constructor');
  var ALL_CONSTRUCTORS = $typed.CONSTR;
  var TYPED_ARRAY = $typed.TYPED;
  var VIEW = $typed.VIEW;
  var WRONG_LENGTH = 'Wrong length!';

  var $map = createArrayMethod(1, function (O, length) {
    return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length);
  });

  var LITTLE_ENDIAN = fails(function () {
    // eslint-disable-next-line no-undef
    return new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;
  });

  var FORCED_SET = !!Uint8Array && !!Uint8Array[PROTOTYPE].set && fails(function () {
    new Uint8Array(1).set({});
  });

  var toOffset = function (it, BYTES) {
    var offset = toInteger(it);
    if (offset < 0 || offset % BYTES) throw RangeError('Wrong offset!');
    return offset;
  };

  var validate = function (it) {
    if (isObject(it) && TYPED_ARRAY in it) return it;
    throw TypeError(it + ' is not a typed array!');
  };

  var allocate = function (C, length) {
    if (!(isObject(C) && TYPED_CONSTRUCTOR in C)) {
      throw TypeError('It is not a typed array constructor!');
    } return new C(length);
  };

  var speciesFromList = function (O, list) {
    return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list);
  };

  var fromList = function (C, list) {
    var index = 0;
    var length = list.length;
    var result = allocate(C, length);
    while (length > index) result[index] = list[index++];
    return result;
  };

  var addGetter = function (it, key, internal) {
    dP(it, key, { get: function () { return this._d[internal]; } });
  };

  var $from = function from(source /* , mapfn, thisArg */) {
    var O = toObject(source);
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var iterFn = getIterFn(O);
    var i, length, values, result, step, iterator;
    if (iterFn != undefined && !isArrayIter(iterFn)) {
      for (iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++) {
        values.push(step.value);
      } O = values;
    }
    if (mapping && aLen > 2) mapfn = ctx(mapfn, arguments[2], 2);
    for (i = 0, length = toLength(O.length), result = allocate(this, length); length > i; i++) {
      result[i] = mapping ? mapfn(O[i], i) : O[i];
    }
    return result;
  };

  var $of = function of(/* ...items */) {
    var index = 0;
    var length = arguments.length;
    var result = allocate(this, length);
    while (length > index) result[index] = arguments[index++];
    return result;
  };

  // iOS Safari 6.x fails here
  var TO_LOCALE_BUG = !!Uint8Array && fails(function () { arrayToLocaleString.call(new Uint8Array(1)); });

  var $toLocaleString = function toLocaleString() {
    return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments);
  };

  var proto = {
    copyWithin: function copyWithin(target, start /* , end */) {
      return arrayCopyWithin.call(validate(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
    },
    every: function every(callbackfn /* , thisArg */) {
      return arrayEvery(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    fill: function fill(value /* , start, end */) { // eslint-disable-line no-unused-vars
      return arrayFill.apply(validate(this), arguments);
    },
    filter: function filter(callbackfn /* , thisArg */) {
      return speciesFromList(this, arrayFilter(validate(this), callbackfn,
        arguments.length > 1 ? arguments[1] : undefined));
    },
    find: function find(predicate /* , thisArg */) {
      return arrayFind(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    findIndex: function findIndex(predicate /* , thisArg */) {
      return arrayFindIndex(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    forEach: function forEach(callbackfn /* , thisArg */) {
      arrayForEach(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    indexOf: function indexOf(searchElement /* , fromIndex */) {
      return arrayIndexOf(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    includes: function includes(searchElement /* , fromIndex */) {
      return arrayIncludes(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    join: function join(separator) { // eslint-disable-line no-unused-vars
      return arrayJoin.apply(validate(this), arguments);
    },
    lastIndexOf: function lastIndexOf(searchElement /* , fromIndex */) { // eslint-disable-line no-unused-vars
      return arrayLastIndexOf.apply(validate(this), arguments);
    },
    map: function map(mapfn /* , thisArg */) {
      return $map(validate(this), mapfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    reduce: function reduce(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars
      return arrayReduce.apply(validate(this), arguments);
    },
    reduceRight: function reduceRight(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars
      return arrayReduceRight.apply(validate(this), arguments);
    },
    reverse: function reverse() {
      var that = this;
      var length = validate(that).length;
      var middle = Math.floor(length / 2);
      var index = 0;
      var value;
      while (index < middle) {
        value = that[index];
        that[index++] = that[--length];
        that[length] = value;
      } return that;
    },
    some: function some(callbackfn /* , thisArg */) {
      return arraySome(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    sort: function sort(comparefn) {
      return arraySort.call(validate(this), comparefn);
    },
    subarray: function subarray(begin, end) {
      var O = validate(this);
      var length = O.length;
      var $begin = toAbsoluteIndex(begin, length);
      return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))(
        O.buffer,
        O.byteOffset + $begin * O.BYTES_PER_ELEMENT,
        toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - $begin)
      );
    }
  };

  var $slice = function slice(start, end) {
    return speciesFromList(this, arraySlice.call(validate(this), start, end));
  };

  var $set = function set(arrayLike /* , offset */) {
    validate(this);
    var offset = toOffset(arguments[1], 1);
    var length = this.length;
    var src = toObject(arrayLike);
    var len = toLength(src.length);
    var index = 0;
    if (len + offset > length) throw RangeError(WRONG_LENGTH);
    while (index < len) this[offset + index] = src[index++];
  };

  var $iterators = {
    entries: function entries() {
      return arrayEntries.call(validate(this));
    },
    keys: function keys() {
      return arrayKeys.call(validate(this));
    },
    values: function values() {
      return arrayValues.call(validate(this));
    }
  };

  var isTAIndex = function (target, key) {
    return isObject(target)
      && target[TYPED_ARRAY]
      && typeof key != 'symbol'
      && key in target
      && String(+key) == String(key);
  };
  var $getDesc = function getOwnPropertyDescriptor(target, key) {
    return isTAIndex(target, key = toPrimitive(key, true))
      ? propertyDesc(2, target[key])
      : gOPD(target, key);
  };
  var $setDesc = function defineProperty(target, key, desc) {
    if (isTAIndex(target, key = toPrimitive(key, true))
      && isObject(desc)
      && has(desc, 'value')
      && !has(desc, 'get')
      && !has(desc, 'set')
      // TODO: add validation descriptor w/o calling accessors
      && !desc.configurable
      && (!has(desc, 'writable') || desc.writable)
      && (!has(desc, 'enumerable') || desc.enumerable)
    ) {
      target[key] = desc.value;
      return target;
    } return dP(target, key, desc);
  };

  if (!ALL_CONSTRUCTORS) {
    $GOPD.f = $getDesc;
    $DP.f = $setDesc;
  }

  $export($export.S + $export.F * !ALL_CONSTRUCTORS, 'Object', {
    getOwnPropertyDescriptor: $getDesc,
    defineProperty: $setDesc
  });

  if (fails(function () { arrayToString.call({}); })) {
    arrayToString = arrayToLocaleString = function toString() {
      return arrayJoin.call(this);
    };
  }

  var $TypedArrayPrototype$ = redefineAll({}, proto);
  redefineAll($TypedArrayPrototype$, $iterators);
  hide($TypedArrayPrototype$, ITERATOR, $iterators.values);
  redefineAll($TypedArrayPrototype$, {
    slice: $slice,
    set: $set,
    constructor: function () { /* noop */ },
    toString: arrayToString,
    toLocaleString: $toLocaleString
  });
  addGetter($TypedArrayPrototype$, 'buffer', 'b');
  addGetter($TypedArrayPrototype$, 'byteOffset', 'o');
  addGetter($TypedArrayPrototype$, 'byteLength', 'l');
  addGetter($TypedArrayPrototype$, 'length', 'e');
  dP($TypedArrayPrototype$, TAG, {
    get: function () { return this[TYPED_ARRAY]; }
  });

  // eslint-disable-next-line max-statements
  module.exports = function (KEY, BYTES, wrapper, CLAMPED) {
    CLAMPED = !!CLAMPED;
    var NAME = KEY + (CLAMPED ? 'Clamped' : '') + 'Array';
    var GETTER = 'get' + KEY;
    var SETTER = 'set' + KEY;
    var TypedArray = global[NAME];
    var Base = TypedArray || {};
    var TAC = TypedArray && getPrototypeOf(TypedArray);
    var FORCED = !TypedArray || !$typed.ABV;
    var O = {};
    var TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE];
    var getter = function (that, index) {
      var data = that._d;
      return data.v[GETTER](index * BYTES + data.o, LITTLE_ENDIAN);
    };
    var setter = function (that, index, value) {
      var data = that._d;
      if (CLAMPED) value = (value = Math.round(value)) < 0 ? 0 : value > 0xff ? 0xff : value & 0xff;
      data.v[SETTER](index * BYTES + data.o, value, LITTLE_ENDIAN);
    };
    var addElement = function (that, index) {
      dP(that, index, {
        get: function () {
          return getter(this, index);
        },
        set: function (value) {
          return setter(this, index, value);
        },
        enumerable: true
      });
    };
    if (FORCED) {
      TypedArray = wrapper(function (that, data, $offset, $length) {
        anInstance(that, TypedArray, NAME, '_d');
        var index = 0;
        var offset = 0;
        var buffer, byteLength, length, klass;
        if (!isObject(data)) {
          length = toIndex(data);
          byteLength = length * BYTES;
          buffer = new $ArrayBuffer(byteLength);
        } else if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
          buffer = data;
          offset = toOffset($offset, BYTES);
          var $len = data.byteLength;
          if ($length === undefined) {
            if ($len % BYTES) throw RangeError(WRONG_LENGTH);
            byteLength = $len - offset;
            if (byteLength < 0) throw RangeError(WRONG_LENGTH);
          } else {
            byteLength = toLength($length) * BYTES;
            if (byteLength + offset > $len) throw RangeError(WRONG_LENGTH);
          }
          length = byteLength / BYTES;
        } else if (TYPED_ARRAY in data) {
          return fromList(TypedArray, data);
        } else {
          return $from.call(TypedArray, data);
        }
        hide(that, '_d', {
          b: buffer,
          o: offset,
          l: byteLength,
          e: length,
          v: new $DataView(buffer)
        });
        while (index < length) addElement(that, index++);
      });
      TypedArrayPrototype = TypedArray[PROTOTYPE] = create($TypedArrayPrototype$);
      hide(TypedArrayPrototype, 'constructor', TypedArray);
    } else if (!fails(function () {
      TypedArray(1);
    }) || !fails(function () {
      new TypedArray(-1); // eslint-disable-line no-new
    }) || !$iterDetect(function (iter) {
      new TypedArray(); // eslint-disable-line no-new
      new TypedArray(null); // eslint-disable-line no-new
      new TypedArray(1.5); // eslint-disable-line no-new
      new TypedArray(iter); // eslint-disable-line no-new
    }, true)) {
      TypedArray = wrapper(function (that, data, $offset, $length) {
        anInstance(that, TypedArray, NAME);
        var klass;
        // `ws` module bug, temporarily remove validation length for Uint8Array
        // https://github.com/websockets/ws/pull/645
        if (!isObject(data)) return new Base(toIndex(data));
        if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
          return $length !== undefined
            ? new Base(data, toOffset($offset, BYTES), $length)
            : $offset !== undefined
              ? new Base(data, toOffset($offset, BYTES))
              : new Base(data);
        }
        if (TYPED_ARRAY in data) return fromList(TypedArray, data);
        return $from.call(TypedArray, data);
      });
      arrayForEach(TAC !== Function.prototype ? gOPN(Base).concat(gOPN(TAC)) : gOPN(Base), function (key) {
        if (!(key in TypedArray)) hide(TypedArray, key, Base[key]);
      });
      TypedArray[PROTOTYPE] = TypedArrayPrototype;
      if (!LIBRARY) TypedArrayPrototype.constructor = TypedArray;
    }
    var $nativeIterator = TypedArrayPrototype[ITERATOR];
    var CORRECT_ITER_NAME = !!$nativeIterator
      && ($nativeIterator.name == 'values' || $nativeIterator.name == undefined);
    var $iterator = $iterators.values;
    hide(TypedArray, TYPED_CONSTRUCTOR, true);
    hide(TypedArrayPrototype, TYPED_ARRAY, NAME);
    hide(TypedArrayPrototype, VIEW, true);
    hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray);

    if (CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)) {
      dP(TypedArrayPrototype, TAG, {
        get: function () { return NAME; }
      });
    }

    O[NAME] = TypedArray;

    $export($export.G + $export.W + $export.F * (TypedArray != Base), O);

    $export($export.S, NAME, {
      BYTES_PER_ELEMENT: BYTES
    });

    $export($export.S + $export.F * fails(function () { Base.of.call(TypedArray, 1); }), NAME, {
      from: $from,
      of: $of
    });

    if (!(BYTES_PER_ELEMENT in TypedArrayPrototype)) hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES);

    $export($export.P, NAME, proto);

    setSpecies(NAME);

    $export($export.P + $export.F * FORCED_SET, NAME, { set: $set });

    $export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators);

    if (!LIBRARY && TypedArrayPrototype.toString != arrayToString) TypedArrayPrototype.toString = arrayToString;

    $export($export.P + $export.F * fails(function () {
      new TypedArray(1).slice();
    }), NAME, { slice: $slice });

    $export($export.P + $export.F * (fails(function () {
      return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString();
    }) || !fails(function () {
      TypedArrayPrototype.toLocaleString.call([1, 2]);
    })), NAME, { toLocaleString: $toLocaleString });

    Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator;
    if (!LIBRARY && !CORRECT_ITER_NAME) hide(TypedArrayPrototype, ITERATOR, $iterator);
  };
} else module.exports = function () { /* empty */ };

},{"./_an-instance":13,"./_array-copy-within":15,"./_array-fill":16,"./_array-includes":18,"./_array-methods":19,"./_classof":24,"./_ctx":32,"./_descriptors":36,"./_export":40,"./_fails":42,"./_global":47,"./_has":48,"./_hide":49,"./_is-array-iter":55,"./_is-object":58,"./_iter-detect":63,"./_iterators":65,"./_library":66,"./_object-create":77,"./_object-dp":78,"./_object-gopd":81,"./_object-gopn":83,"./_object-gpo":85,"./_property-desc":96,"./_redefine-all":97,"./_set-species":104,"./_species-constructor":108,"./_to-absolute-index":118,"./_to-index":119,"./_to-integer":120,"./_to-length":122,"./_to-object":123,"./_to-primitive":124,"./_typed":127,"./_typed-buffer":126,"./_uid":128,"./_wks":132,"./core.get-iterator-method":133,"./es6.array.iterator":145}],126:[function(require,module,exports){
'use strict';
var global = require('./_global');
var DESCRIPTORS = require('./_descriptors');
var LIBRARY = require('./_library');
var $typed = require('./_typed');
var hide = require('./_hide');
var redefineAll = require('./_redefine-all');
var fails = require('./_fails');
var anInstance = require('./_an-instance');
var toInteger = require('./_to-integer');
var toLength = require('./_to-length');
var toIndex = require('./_to-index');
var gOPN = require('./_object-gopn').f;
var dP = require('./_object-dp').f;
var arrayFill = require('./_array-fill');
var setToStringTag = require('./_set-to-string-tag');
var ARRAY_BUFFER = 'ArrayBuffer';
var DATA_VIEW = 'DataView';
var PROTOTYPE = 'prototype';
var WRONG_LENGTH = 'Wrong length!';
var WRONG_INDEX = 'Wrong index!';
var $ArrayBuffer = global[ARRAY_BUFFER];
var $DataView = global[DATA_VIEW];
var Math = global.Math;
var RangeError = global.RangeError;
// eslint-disable-next-line no-shadow-restricted-names
var Infinity = global.Infinity;
var BaseBuffer = $ArrayBuffer;
var abs = Math.abs;
var pow = Math.pow;
var floor = Math.floor;
var log = Math.log;
var LN2 = Math.LN2;
var BUFFER = 'buffer';
var BYTE_LENGTH = 'byteLength';
var BYTE_OFFSET = 'byteOffset';
var $BUFFER = DESCRIPTORS ? '_b' : BUFFER;
var $LENGTH = DESCRIPTORS ? '_l' : BYTE_LENGTH;
var $OFFSET = DESCRIPTORS ? '_o' : BYTE_OFFSET;

// IEEE754 conversions based on https://github.com/feross/ieee754
function packIEEE754(value, mLen, nBytes) {
  var buffer = Array(nBytes);
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0;
  var i = 0;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  var e, m, c;
  value = abs(value);
  // eslint-disable-next-line no-self-compare
  if (value != value || value === Infinity) {
    // eslint-disable-next-line no-self-compare
    m = value != value ? 1 : 0;
    e = eMax;
  } else {
    e = floor(log(value) / LN2);
    if (value * (c = pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }
    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * pow(2, eBias - 1) * pow(2, mLen);
      e = 0;
    }
  }
  for (; mLen >= 8; buffer[i++] = m & 255, m /= 256, mLen -= 8);
  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer[i++] = e & 255, e /= 256, eLen -= 8);
  buffer[--i] |= s * 128;
  return buffer;
}
function unpackIEEE754(buffer, mLen, nBytes) {
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = eLen - 7;
  var i = nBytes - 1;
  var s = buffer[i--];
  var e = s & 127;
  var m;
  s >>= 7;
  for (; nBits > 0; e = e * 256 + buffer[i], i--, nBits -= 8);
  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[i], i--, nBits -= 8);
  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : s ? -Infinity : Infinity;
  } else {
    m = m + pow(2, mLen);
    e = e - eBias;
  } return (s ? -1 : 1) * m * pow(2, e - mLen);
}

function unpackI32(bytes) {
  return bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0];
}
function packI8(it) {
  return [it & 0xff];
}
function packI16(it) {
  return [it & 0xff, it >> 8 & 0xff];
}
function packI32(it) {
  return [it & 0xff, it >> 8 & 0xff, it >> 16 & 0xff, it >> 24 & 0xff];
}
function packF64(it) {
  return packIEEE754(it, 52, 8);
}
function packF32(it) {
  return packIEEE754(it, 23, 4);
}

function addGetter(C, key, internal) {
  dP(C[PROTOTYPE], key, { get: function () { return this[internal]; } });
}

function get(view, bytes, index, isLittleEndian) {
  var numIndex = +index;
  var intIndex = toIndex(numIndex);
  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b;
  var start = intIndex + view[$OFFSET];
  var pack = store.slice(start, start + bytes);
  return isLittleEndian ? pack : pack.reverse();
}
function set(view, bytes, index, conversion, value, isLittleEndian) {
  var numIndex = +index;
  var intIndex = toIndex(numIndex);
  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b;
  var start = intIndex + view[$OFFSET];
  var pack = conversion(+value);
  for (var i = 0; i < bytes; i++) store[start + i] = pack[isLittleEndian ? i : bytes - i - 1];
}

if (!$typed.ABV) {
  $ArrayBuffer = function ArrayBuffer(length) {
    anInstance(this, $ArrayBuffer, ARRAY_BUFFER);
    var byteLength = toIndex(length);
    this._b = arrayFill.call(Array(byteLength), 0);
    this[$LENGTH] = byteLength;
  };

  $DataView = function DataView(buffer, byteOffset, byteLength) {
    anInstance(this, $DataView, DATA_VIEW);
    anInstance(buffer, $ArrayBuffer, DATA_VIEW);
    var bufferLength = buffer[$LENGTH];
    var offset = toInteger(byteOffset);
    if (offset < 0 || offset > bufferLength) throw RangeError('Wrong offset!');
    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
    if (offset + byteLength > bufferLength) throw RangeError(WRONG_LENGTH);
    this[$BUFFER] = buffer;
    this[$OFFSET] = offset;
    this[$LENGTH] = byteLength;
  };

  if (DESCRIPTORS) {
    addGetter($ArrayBuffer, BYTE_LENGTH, '_l');
    addGetter($DataView, BUFFER, '_b');
    addGetter($DataView, BYTE_LENGTH, '_l');
    addGetter($DataView, BYTE_OFFSET, '_o');
  }

  redefineAll($DataView[PROTOTYPE], {
    getInt8: function getInt8(byteOffset) {
      return get(this, 1, byteOffset)[0] << 24 >> 24;
    },
    getUint8: function getUint8(byteOffset) {
      return get(this, 1, byteOffset)[0];
    },
    getInt16: function getInt16(byteOffset /* , littleEndian */) {
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
    },
    getUint16: function getUint16(byteOffset /* , littleEndian */) {
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return bytes[1] << 8 | bytes[0];
    },
    getInt32: function getInt32(byteOffset /* , littleEndian */) {
      return unpackI32(get(this, 4, byteOffset, arguments[1]));
    },
    getUint32: function getUint32(byteOffset /* , littleEndian */) {
      return unpackI32(get(this, 4, byteOffset, arguments[1])) >>> 0;
    },
    getFloat32: function getFloat32(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4);
    },
    getFloat64: function getFloat64(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8);
    },
    setInt8: function setInt8(byteOffset, value) {
      set(this, 1, byteOffset, packI8, value);
    },
    setUint8: function setUint8(byteOffset, value) {
      set(this, 1, byteOffset, packI8, value);
    },
    setInt16: function setInt16(byteOffset, value /* , littleEndian */) {
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setUint16: function setUint16(byteOffset, value /* , littleEndian */) {
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setInt32: function setInt32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setUint32: function setUint32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setFloat32: function setFloat32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packF32, value, arguments[2]);
    },
    setFloat64: function setFloat64(byteOffset, value /* , littleEndian */) {
      set(this, 8, byteOffset, packF64, value, arguments[2]);
    }
  });
} else {
  if (!fails(function () {
    $ArrayBuffer(1);
  }) || !fails(function () {
    new $ArrayBuffer(-1); // eslint-disable-line no-new
  }) || fails(function () {
    new $ArrayBuffer(); // eslint-disable-line no-new
    new $ArrayBuffer(1.5); // eslint-disable-line no-new
    new $ArrayBuffer(NaN); // eslint-disable-line no-new
    return $ArrayBuffer.name != ARRAY_BUFFER;
  })) {
    $ArrayBuffer = function ArrayBuffer(length) {
      anInstance(this, $ArrayBuffer);
      return new BaseBuffer(toIndex(length));
    };
    var ArrayBufferProto = $ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE];
    for (var keys = gOPN(BaseBuffer), j = 0, key; keys.length > j;) {
      if (!((key = keys[j++]) in $ArrayBuffer)) hide($ArrayBuffer, key, BaseBuffer[key]);
    }
    if (!LIBRARY) ArrayBufferProto.constructor = $ArrayBuffer;
  }
  // iOS Safari 7.x bug
  var view = new $DataView(new $ArrayBuffer(2));
  var $setInt8 = $DataView[PROTOTYPE].setInt8;
  view.setInt8(0, 2147483648);
  view.setInt8(1, 2147483649);
  if (view.getInt8(0) || !view.getInt8(1)) redefineAll($DataView[PROTOTYPE], {
    setInt8: function setInt8(byteOffset, value) {
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    },
    setUint8: function setUint8(byteOffset, value) {
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    }
  }, true);
}
setToStringTag($ArrayBuffer, ARRAY_BUFFER);
setToStringTag($DataView, DATA_VIEW);
hide($DataView[PROTOTYPE], $typed.VIEW, true);
exports[ARRAY_BUFFER] = $ArrayBuffer;
exports[DATA_VIEW] = $DataView;

},{"./_an-instance":13,"./_array-fill":16,"./_descriptors":36,"./_fails":42,"./_global":47,"./_hide":49,"./_library":66,"./_object-dp":78,"./_object-gopn":83,"./_redefine-all":97,"./_set-to-string-tag":105,"./_to-index":119,"./_to-integer":120,"./_to-length":122,"./_typed":127}],127:[function(require,module,exports){
var global = require('./_global');
var hide = require('./_hide');
var uid = require('./_uid');
var TYPED = uid('typed_array');
var VIEW = uid('view');
var ABV = !!(global.ArrayBuffer && global.DataView);
var CONSTR = ABV;
var i = 0;
var l = 9;
var Typed;

var TypedArrayConstructors = (
  'Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array'
).split(',');

while (i < l) {
  if (Typed = global[TypedArrayConstructors[i++]]) {
    hide(Typed.prototype, TYPED, true);
    hide(Typed.prototype, VIEW, true);
  } else CONSTR = false;
}

module.exports = {
  ABV: ABV,
  CONSTR: CONSTR,
  TYPED: TYPED,
  VIEW: VIEW
};

},{"./_global":47,"./_hide":49,"./_uid":128}],128:[function(require,module,exports){
var id = 0;
var px = Math.random();
module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};

},{}],129:[function(require,module,exports){
var isObject = require('./_is-object');
module.exports = function (it, TYPE) {
  if (!isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');
  return it;
};

},{"./_is-object":58}],130:[function(require,module,exports){
var global = require('./_global');
var core = require('./_core');
var LIBRARY = require('./_library');
var wksExt = require('./_wks-ext');
var defineProperty = require('./_object-dp').f;
module.exports = function (name) {
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });
};

},{"./_core":30,"./_global":47,"./_library":66,"./_object-dp":78,"./_wks-ext":131}],131:[function(require,module,exports){
exports.f = require('./_wks');

},{"./_wks":132}],132:[function(require,module,exports){
var store = require('./_shared')('wks');
var uid = require('./_uid');
var Symbol = require('./_global').Symbol;
var USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;

},{"./_global":47,"./_shared":107,"./_uid":128}],133:[function(require,module,exports){
var classof = require('./_classof');
var ITERATOR = require('./_wks')('iterator');
var Iterators = require('./_iterators');
module.exports = require('./_core').getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};

},{"./_classof":24,"./_core":30,"./_iterators":65,"./_wks":132}],134:[function(require,module,exports){
// https://github.com/benjamingr/RexExp.escape
var $export = require('./_export');
var $re = require('./_replacer')(/[\\^$*+?.()|[\]{}]/g, '\\$&');

$export($export.S, 'RegExp', { escape: function escape(it) { return $re(it); } });

},{"./_export":40,"./_replacer":99}],135:[function(require,module,exports){
// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
var $export = require('./_export');

$export($export.P, 'Array', { copyWithin: require('./_array-copy-within') });

require('./_add-to-unscopables')('copyWithin');

},{"./_add-to-unscopables":12,"./_array-copy-within":15,"./_export":40}],136:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var $every = require('./_array-methods')(4);

$export($export.P + $export.F * !require('./_strict-method')([].every, true), 'Array', {
  // 22.1.3.5 / 15.4.4.16 Array.prototype.every(callbackfn [, thisArg])
  every: function every(callbackfn /* , thisArg */) {
    return $every(this, callbackfn, arguments[1]);
  }
});

},{"./_array-methods":19,"./_export":40,"./_strict-method":109}],137:[function(require,module,exports){
// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
var $export = require('./_export');

$export($export.P, 'Array', { fill: require('./_array-fill') });

require('./_add-to-unscopables')('fill');

},{"./_add-to-unscopables":12,"./_array-fill":16,"./_export":40}],138:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var $filter = require('./_array-methods')(2);

$export($export.P + $export.F * !require('./_strict-method')([].filter, true), 'Array', {
  // 22.1.3.7 / 15.4.4.20 Array.prototype.filter(callbackfn [, thisArg])
  filter: function filter(callbackfn /* , thisArg */) {
    return $filter(this, callbackfn, arguments[1]);
  }
});

},{"./_array-methods":19,"./_export":40,"./_strict-method":109}],139:[function(require,module,exports){
'use strict';
// 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)
var $export = require('./_export');
var $find = require('./_array-methods')(6);
var KEY = 'findIndex';
var forced = true;
// Shouldn't skip holes
if (KEY in []) Array(1)[KEY](function () { forced = false; });
$export($export.P + $export.F * forced, 'Array', {
  findIndex: function findIndex(callbackfn /* , that = undefined */) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});
require('./_add-to-unscopables')(KEY);

},{"./_add-to-unscopables":12,"./_array-methods":19,"./_export":40}],140:[function(require,module,exports){
'use strict';
// 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)
var $export = require('./_export');
var $find = require('./_array-methods')(5);
var KEY = 'find';
var forced = true;
// Shouldn't skip holes
if (KEY in []) Array(1)[KEY](function () { forced = false; });
$export($export.P + $export.F * forced, 'Array', {
  find: function find(callbackfn /* , that = undefined */) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});
require('./_add-to-unscopables')(KEY);

},{"./_add-to-unscopables":12,"./_array-methods":19,"./_export":40}],141:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var $forEach = require('./_array-methods')(0);
var STRICT = require('./_strict-method')([].forEach, true);

$export($export.P + $export.F * !STRICT, 'Array', {
  // 22.1.3.10 / 15.4.4.18 Array.prototype.forEach(callbackfn [, thisArg])
  forEach: function forEach(callbackfn /* , thisArg */) {
    return $forEach(this, callbackfn, arguments[1]);
  }
});

},{"./_array-methods":19,"./_export":40,"./_strict-method":109}],142:[function(require,module,exports){
'use strict';
var ctx = require('./_ctx');
var $export = require('./_export');
var toObject = require('./_to-object');
var call = require('./_iter-call');
var isArrayIter = require('./_is-array-iter');
var toLength = require('./_to-length');
var createProperty = require('./_create-property');
var getIterFn = require('./core.get-iterator-method');

$export($export.S + $export.F * !require('./_iter-detect')(function (iter) { Array.from(iter); }), 'Array', {
  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
  from: function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
    var O = toObject(arrayLike);
    var C = typeof this == 'function' ? this : Array;
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var index = 0;
    var iterFn = getIterFn(O);
    var length, result, step, iterator;
    if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
    // if object isn't iterable or it's array with default iterator - use simple case
    if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {
      for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
      }
    } else {
      length = toLength(O.length);
      for (result = new C(length); length > index; index++) {
        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
      }
    }
    result.length = index;
    return result;
  }
});

},{"./_create-property":31,"./_ctx":32,"./_export":40,"./_is-array-iter":55,"./_iter-call":60,"./_iter-detect":63,"./_to-length":122,"./_to-object":123,"./core.get-iterator-method":133}],143:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var $indexOf = require('./_array-includes')(false);
var $native = [].indexOf;
var NEGATIVE_ZERO = !!$native && 1 / [1].indexOf(1, -0) < 0;

$export($export.P + $export.F * (NEGATIVE_ZERO || !require('./_strict-method')($native)), 'Array', {
  // 22.1.3.11 / 15.4.4.14 Array.prototype.indexOf(searchElement [, fromIndex])
  indexOf: function indexOf(searchElement /* , fromIndex = 0 */) {
    return NEGATIVE_ZERO
      // convert -0 to +0
      ? $native.apply(this, arguments) || 0
      : $indexOf(this, searchElement, arguments[1]);
  }
});

},{"./_array-includes":18,"./_export":40,"./_strict-method":109}],144:[function(require,module,exports){
// 22.1.2.2 / 15.4.3.2 Array.isArray(arg)
var $export = require('./_export');

$export($export.S, 'Array', { isArray: require('./_is-array') });

},{"./_export":40,"./_is-array":56}],145:[function(require,module,exports){
'use strict';
var addToUnscopables = require('./_add-to-unscopables');
var step = require('./_iter-step');
var Iterators = require('./_iterators');
var toIObject = require('./_to-iobject');

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = require('./_iter-define')(Array, 'Array', function (iterated, kind) {
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;
  if (!O || index >= O.length) {
    this._t = undefined;
    return step(1);
  }
  if (kind == 'keys') return step(0, index);
  if (kind == 'values') return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');

},{"./_add-to-unscopables":12,"./_iter-define":62,"./_iter-step":64,"./_iterators":65,"./_to-iobject":121}],146:[function(require,module,exports){
'use strict';
// 22.1.3.13 Array.prototype.join(separator)
var $export = require('./_export');
var toIObject = require('./_to-iobject');
var arrayJoin = [].join;

// fallback for not array-like strings
$export($export.P + $export.F * (require('./_iobject') != Object || !require('./_strict-method')(arrayJoin)), 'Array', {
  join: function join(separator) {
    return arrayJoin.call(toIObject(this), separator === undefined ? ',' : separator);
  }
});

},{"./_export":40,"./_iobject":54,"./_strict-method":109,"./_to-iobject":121}],147:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var toIObject = require('./_to-iobject');
var toInteger = require('./_to-integer');
var toLength = require('./_to-length');
var $native = [].lastIndexOf;
var NEGATIVE_ZERO = !!$native && 1 / [1].lastIndexOf(1, -0) < 0;

$export($export.P + $export.F * (NEGATIVE_ZERO || !require('./_strict-method')($native)), 'Array', {
  // 22.1.3.14 / 15.4.4.15 Array.prototype.lastIndexOf(searchElement [, fromIndex])
  lastIndexOf: function lastIndexOf(searchElement /* , fromIndex = @[*-1] */) {
    // convert -0 to +0
    if (NEGATIVE_ZERO) return $native.apply(this, arguments) || 0;
    var O = toIObject(this);
    var length = toLength(O.length);
    var index = length - 1;
    if (arguments.length > 1) index = Math.min(index, toInteger(arguments[1]));
    if (index < 0) index = length + index;
    for (;index >= 0; index--) if (index in O) if (O[index] === searchElement) return index || 0;
    return -1;
  }
});

},{"./_export":40,"./_strict-method":109,"./_to-integer":120,"./_to-iobject":121,"./_to-length":122}],148:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var $map = require('./_array-methods')(1);

$export($export.P + $export.F * !require('./_strict-method')([].map, true), 'Array', {
  // 22.1.3.15 / 15.4.4.19 Array.prototype.map(callbackfn [, thisArg])
  map: function map(callbackfn /* , thisArg */) {
    return $map(this, callbackfn, arguments[1]);
  }
});

},{"./_array-methods":19,"./_export":40,"./_strict-method":109}],149:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var createProperty = require('./_create-property');

// WebKit Array.of isn't generic
$export($export.S + $export.F * require('./_fails')(function () {
  function F() { /* empty */ }
  return !(Array.of.call(F) instanceof F);
}), 'Array', {
  // 22.1.2.3 Array.of( ...items)
  of: function of(/* ...args */) {
    var index = 0;
    var aLen = arguments.length;
    var result = new (typeof this == 'function' ? this : Array)(aLen);
    while (aLen > index) createProperty(result, index, arguments[index++]);
    result.length = aLen;
    return result;
  }
});

},{"./_create-property":31,"./_export":40,"./_fails":42}],150:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var $reduce = require('./_array-reduce');

$export($export.P + $export.F * !require('./_strict-method')([].reduceRight, true), 'Array', {
  // 22.1.3.19 / 15.4.4.22 Array.prototype.reduceRight(callbackfn [, initialValue])
  reduceRight: function reduceRight(callbackfn /* , initialValue */) {
    return $reduce(this, callbackfn, arguments.length, arguments[1], true);
  }
});

},{"./_array-reduce":20,"./_export":40,"./_strict-method":109}],151:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var $reduce = require('./_array-reduce');

$export($export.P + $export.F * !require('./_strict-method')([].reduce, true), 'Array', {
  // 22.1.3.18 / 15.4.4.21 Array.prototype.reduce(callbackfn [, initialValue])
  reduce: function reduce(callbackfn /* , initialValue */) {
    return $reduce(this, callbackfn, arguments.length, arguments[1], false);
  }
});

},{"./_array-reduce":20,"./_export":40,"./_strict-method":109}],152:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var html = require('./_html');
var cof = require('./_cof');
var toAbsoluteIndex = require('./_to-absolute-index');
var toLength = require('./_to-length');
var arraySlice = [].slice;

// fallback for not array-like ES3 strings and DOM objects
$export($export.P + $export.F * require('./_fails')(function () {
  if (html) arraySlice.call(html);
}), 'Array', {
  slice: function slice(begin, end) {
    var len = toLength(this.length);
    var klass = cof(this);
    end = end === undefined ? len : end;
    if (klass == 'Array') return arraySlice.call(this, begin, end);
    var start = toAbsoluteIndex(begin, len);
    var upTo = toAbsoluteIndex(end, len);
    var size = toLength(upTo - start);
    var cloned = Array(size);
    var i = 0;
    for (; i < size; i++) cloned[i] = klass == 'String'
      ? this.charAt(start + i)
      : this[start + i];
    return cloned;
  }
});

},{"./_cof":25,"./_export":40,"./_fails":42,"./_html":50,"./_to-absolute-index":118,"./_to-length":122}],153:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var $some = require('./_array-methods')(3);

$export($export.P + $export.F * !require('./_strict-method')([].some, true), 'Array', {
  // 22.1.3.23 / 15.4.4.17 Array.prototype.some(callbackfn [, thisArg])
  some: function some(callbackfn /* , thisArg */) {
    return $some(this, callbackfn, arguments[1]);
  }
});

},{"./_array-methods":19,"./_export":40,"./_strict-method":109}],154:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var aFunction = require('./_a-function');
var toObject = require('./_to-object');
var fails = require('./_fails');
var $sort = [].sort;
var test = [1, 2, 3];

$export($export.P + $export.F * (fails(function () {
  // IE8-
  test.sort(undefined);
}) || !fails(function () {
  // V8 bug
  test.sort(null);
  // Old WebKit
}) || !require('./_strict-method')($sort)), 'Array', {
  // 22.1.3.25 Array.prototype.sort(comparefn)
  sort: function sort(comparefn) {
    return comparefn === undefined
      ? $sort.call(toObject(this))
      : $sort.call(toObject(this), aFunction(comparefn));
  }
});

},{"./_a-function":10,"./_export":40,"./_fails":42,"./_strict-method":109,"./_to-object":123}],155:[function(require,module,exports){
require('./_set-species')('Array');

},{"./_set-species":104}],156:[function(require,module,exports){
// 20.3.3.1 / 15.9.4.4 Date.now()
var $export = require('./_export');

$export($export.S, 'Date', { now: function () { return new Date().getTime(); } });

},{"./_export":40}],157:[function(require,module,exports){
// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()
var $export = require('./_export');
var toISOString = require('./_date-to-iso-string');

// PhantomJS / old WebKit has a broken implementations
$export($export.P + $export.F * (Date.prototype.toISOString !== toISOString), 'Date', {
  toISOString: toISOString
});

},{"./_date-to-iso-string":33,"./_export":40}],158:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var toObject = require('./_to-object');
var toPrimitive = require('./_to-primitive');

$export($export.P + $export.F * require('./_fails')(function () {
  return new Date(NaN).toJSON() !== null
    || Date.prototype.toJSON.call({ toISOString: function () { return 1; } }) !== 1;
}), 'Date', {
  // eslint-disable-next-line no-unused-vars
  toJSON: function toJSON(key) {
    var O = toObject(this);
    var pv = toPrimitive(O);
    return typeof pv == 'number' && !isFinite(pv) ? null : O.toISOString();
  }
});

},{"./_export":40,"./_fails":42,"./_to-object":123,"./_to-primitive":124}],159:[function(require,module,exports){
var TO_PRIMITIVE = require('./_wks')('toPrimitive');
var proto = Date.prototype;

if (!(TO_PRIMITIVE in proto)) require('./_hide')(proto, TO_PRIMITIVE, require('./_date-to-primitive'));

},{"./_date-to-primitive":34,"./_hide":49,"./_wks":132}],160:[function(require,module,exports){
var DateProto = Date.prototype;
var INVALID_DATE = 'Invalid Date';
var TO_STRING = 'toString';
var $toString = DateProto[TO_STRING];
var getTime = DateProto.getTime;
if (new Date(NaN) + '' != INVALID_DATE) {
  require('./_redefine')(DateProto, TO_STRING, function toString() {
    var value = getTime.call(this);
    // eslint-disable-next-line no-self-compare
    return value === value ? $toString.call(this) : INVALID_DATE;
  });
}

},{"./_redefine":98}],161:[function(require,module,exports){
// 19.2.3.2 / 15.3.4.5 Function.prototype.bind(thisArg, args...)
var $export = require('./_export');

$export($export.P, 'Function', { bind: require('./_bind') });

},{"./_bind":23,"./_export":40}],162:[function(require,module,exports){
'use strict';
var isObject = require('./_is-object');
var getPrototypeOf = require('./_object-gpo');
var HAS_INSTANCE = require('./_wks')('hasInstance');
var FunctionProto = Function.prototype;
// 19.2.3.6 Function.prototype[@@hasInstance](V)
if (!(HAS_INSTANCE in FunctionProto)) require('./_object-dp').f(FunctionProto, HAS_INSTANCE, { value: function (O) {
  if (typeof this != 'function' || !isObject(O)) return false;
  if (!isObject(this.prototype)) return O instanceof this;
  // for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this:
  while (O = getPrototypeOf(O)) if (this.prototype === O) return true;
  return false;
} });

},{"./_is-object":58,"./_object-dp":78,"./_object-gpo":85,"./_wks":132}],163:[function(require,module,exports){
var dP = require('./_object-dp').f;
var FProto = Function.prototype;
var nameRE = /^\s*function ([^ (]*)/;
var NAME = 'name';

// 19.2.4.2 name
NAME in FProto || require('./_descriptors') && dP(FProto, NAME, {
  configurable: true,
  get: function () {
    try {
      return ('' + this).match(nameRE)[1];
    } catch (e) {
      return '';
    }
  }
});

},{"./_descriptors":36,"./_object-dp":78}],164:[function(require,module,exports){
'use strict';
var strong = require('./_collection-strong');
var validate = require('./_validate-collection');
var MAP = 'Map';

// 23.1 Map Objects
module.exports = require('./_collection')(MAP, function (get) {
  return function Map() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.1.3.6 Map.prototype.get(key)
  get: function get(key) {
    var entry = strong.getEntry(validate(this, MAP), key);
    return entry && entry.v;
  },
  // 23.1.3.9 Map.prototype.set(key, value)
  set: function set(key, value) {
    return strong.def(validate(this, MAP), key === 0 ? 0 : key, value);
  }
}, strong, true);

},{"./_collection":29,"./_collection-strong":26,"./_validate-collection":129}],165:[function(require,module,exports){
// 20.2.2.3 Math.acosh(x)
var $export = require('./_export');
var log1p = require('./_math-log1p');
var sqrt = Math.sqrt;
var $acosh = Math.acosh;

$export($export.S + $export.F * !($acosh
  // V8 bug: https://code.google.com/p/v8/issues/detail?id=3509
  && Math.floor($acosh(Number.MAX_VALUE)) == 710
  // Tor Browser bug: Math.acosh(Infinity) -> NaN
  && $acosh(Infinity) == Infinity
), 'Math', {
  acosh: function acosh(x) {
    return (x = +x) < 1 ? NaN : x > 94906265.62425156
      ? Math.log(x) + Math.LN2
      : log1p(x - 1 + sqrt(x - 1) * sqrt(x + 1));
  }
});

},{"./_export":40,"./_math-log1p":69}],166:[function(require,module,exports){
// 20.2.2.5 Math.asinh(x)
var $export = require('./_export');
var $asinh = Math.asinh;

function asinh(x) {
  return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : Math.log(x + Math.sqrt(x * x + 1));
}

// Tor Browser bug: Math.asinh(0) -> -0
$export($export.S + $export.F * !($asinh && 1 / $asinh(0) > 0), 'Math', { asinh: asinh });

},{"./_export":40}],167:[function(require,module,exports){
// 20.2.2.7 Math.atanh(x)
var $export = require('./_export');
var $atanh = Math.atanh;

// Tor Browser bug: Math.atanh(-0) -> 0
$export($export.S + $export.F * !($atanh && 1 / $atanh(-0) < 0), 'Math', {
  atanh: function atanh(x) {
    return (x = +x) == 0 ? x : Math.log((1 + x) / (1 - x)) / 2;
  }
});

},{"./_export":40}],168:[function(require,module,exports){
// 20.2.2.9 Math.cbrt(x)
var $export = require('./_export');
var sign = require('./_math-sign');

$export($export.S, 'Math', {
  cbrt: function cbrt(x) {
    return sign(x = +x) * Math.pow(Math.abs(x), 1 / 3);
  }
});

},{"./_export":40,"./_math-sign":71}],169:[function(require,module,exports){
// 20.2.2.11 Math.clz32(x)
var $export = require('./_export');

$export($export.S, 'Math', {
  clz32: function clz32(x) {
    return (x >>>= 0) ? 31 - Math.floor(Math.log(x + 0.5) * Math.LOG2E) : 32;
  }
});

},{"./_export":40}],170:[function(require,module,exports){
// 20.2.2.12 Math.cosh(x)
var $export = require('./_export');
var exp = Math.exp;

$export($export.S, 'Math', {
  cosh: function cosh(x) {
    return (exp(x = +x) + exp(-x)) / 2;
  }
});

},{"./_export":40}],171:[function(require,module,exports){
// 20.2.2.14 Math.expm1(x)
var $export = require('./_export');
var $expm1 = require('./_math-expm1');

$export($export.S + $export.F * ($expm1 != Math.expm1), 'Math', { expm1: $expm1 });

},{"./_export":40,"./_math-expm1":67}],172:[function(require,module,exports){
// 20.2.2.16 Math.fround(x)
var $export = require('./_export');

$export($export.S, 'Math', { fround: require('./_math-fround') });

},{"./_export":40,"./_math-fround":68}],173:[function(require,module,exports){
// 20.2.2.17 Math.hypot([value1[, value2[, … ]]])
var $export = require('./_export');
var abs = Math.abs;

$export($export.S, 'Math', {
  hypot: function hypot(value1, value2) { // eslint-disable-line no-unused-vars
    var sum = 0;
    var i = 0;
    var aLen = arguments.length;
    var larg = 0;
    var arg, div;
    while (i < aLen) {
      arg = abs(arguments[i++]);
      if (larg < arg) {
        div = larg / arg;
        sum = sum * div * div + 1;
        larg = arg;
      } else if (arg > 0) {
        div = arg / larg;
        sum += div * div;
      } else sum += arg;
    }
    return larg === Infinity ? Infinity : larg * Math.sqrt(sum);
  }
});

},{"./_export":40}],174:[function(require,module,exports){
// 20.2.2.18 Math.imul(x, y)
var $export = require('./_export');
var $imul = Math.imul;

// some WebKit versions fails with big numbers, some has wrong arity
$export($export.S + $export.F * require('./_fails')(function () {
  return $imul(0xffffffff, 5) != -5 || $imul.length != 2;
}), 'Math', {
  imul: function imul(x, y) {
    var UINT16 = 0xffff;
    var xn = +x;
    var yn = +y;
    var xl = UINT16 & xn;
    var yl = UINT16 & yn;
    return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);
  }
});

},{"./_export":40,"./_fails":42}],175:[function(require,module,exports){
// 20.2.2.21 Math.log10(x)
var $export = require('./_export');

$export($export.S, 'Math', {
  log10: function log10(x) {
    return Math.log(x) * Math.LOG10E;
  }
});

},{"./_export":40}],176:[function(require,module,exports){
// 20.2.2.20 Math.log1p(x)
var $export = require('./_export');

$export($export.S, 'Math', { log1p: require('./_math-log1p') });

},{"./_export":40,"./_math-log1p":69}],177:[function(require,module,exports){
// 20.2.2.22 Math.log2(x)
var $export = require('./_export');

$export($export.S, 'Math', {
  log2: function log2(x) {
    return Math.log(x) / Math.LN2;
  }
});

},{"./_export":40}],178:[function(require,module,exports){
// 20.2.2.28 Math.sign(x)
var $export = require('./_export');

$export($export.S, 'Math', { sign: require('./_math-sign') });

},{"./_export":40,"./_math-sign":71}],179:[function(require,module,exports){
// 20.2.2.30 Math.sinh(x)
var $export = require('./_export');
var expm1 = require('./_math-expm1');
var exp = Math.exp;

// V8 near Chromium 38 has a problem with very small numbers
$export($export.S + $export.F * require('./_fails')(function () {
  return !Math.sinh(-2e-17) != -2e-17;
}), 'Math', {
  sinh: function sinh(x) {
    return Math.abs(x = +x) < 1
      ? (expm1(x) - expm1(-x)) / 2
      : (exp(x - 1) - exp(-x - 1)) * (Math.E / 2);
  }
});

},{"./_export":40,"./_fails":42,"./_math-expm1":67}],180:[function(require,module,exports){
// 20.2.2.33 Math.tanh(x)
var $export = require('./_export');
var expm1 = require('./_math-expm1');
var exp = Math.exp;

$export($export.S, 'Math', {
  tanh: function tanh(x) {
    var a = expm1(x = +x);
    var b = expm1(-x);
    return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));
  }
});

},{"./_export":40,"./_math-expm1":67}],181:[function(require,module,exports){
// 20.2.2.34 Math.trunc(x)
var $export = require('./_export');

$export($export.S, 'Math', {
  trunc: function trunc(it) {
    return (it > 0 ? Math.floor : Math.ceil)(it);
  }
});

},{"./_export":40}],182:[function(require,module,exports){
'use strict';
var global = require('./_global');
var has = require('./_has');
var cof = require('./_cof');
var inheritIfRequired = require('./_inherit-if-required');
var toPrimitive = require('./_to-primitive');
var fails = require('./_fails');
var gOPN = require('./_object-gopn').f;
var gOPD = require('./_object-gopd').f;
var dP = require('./_object-dp').f;
var $trim = require('./_string-trim').trim;
var NUMBER = 'Number';
var $Number = global[NUMBER];
var Base = $Number;
var proto = $Number.prototype;
// Opera ~12 has broken Object#toString
var BROKEN_COF = cof(require('./_object-create')(proto)) == NUMBER;
var TRIM = 'trim' in String.prototype;

// 7.1.3 ToNumber(argument)
var toNumber = function (argument) {
  var it = toPrimitive(argument, false);
  if (typeof it == 'string' && it.length > 2) {
    it = TRIM ? it.trim() : $trim(it, 3);
    var first = it.charCodeAt(0);
    var third, radix, maxCode;
    if (first === 43 || first === 45) {
      third = it.charCodeAt(2);
      if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
    } else if (first === 48) {
      switch (it.charCodeAt(1)) {
        case 66: case 98: radix = 2; maxCode = 49; break; // fast equal /^0b[01]+$/i
        case 79: case 111: radix = 8; maxCode = 55; break; // fast equal /^0o[0-7]+$/i
        default: return +it;
      }
      for (var digits = it.slice(2), i = 0, l = digits.length, code; i < l; i++) {
        code = digits.charCodeAt(i);
        // parseInt parses a string to a first unavailable symbol
        // but ToNumber should return NaN if a string contains unavailable symbols
        if (code < 48 || code > maxCode) return NaN;
      } return parseInt(digits, radix);
    }
  } return +it;
};

if (!$Number(' 0o1') || !$Number('0b1') || $Number('+0x1')) {
  $Number = function Number(value) {
    var it = arguments.length < 1 ? 0 : value;
    var that = this;
    return that instanceof $Number
      // check on 1..constructor(foo) case
      && (BROKEN_COF ? fails(function () { proto.valueOf.call(that); }) : cof(that) != NUMBER)
        ? inheritIfRequired(new Base(toNumber(it)), that, $Number) : toNumber(it);
  };
  for (var keys = require('./_descriptors') ? gOPN(Base) : (
    // ES3:
    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
    // ES6 (in case, if modules with ES6 Number statics required before):
    'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' +
    'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger'
  ).split(','), j = 0, key; keys.length > j; j++) {
    if (has(Base, key = keys[j]) && !has($Number, key)) {
      dP($Number, key, gOPD(Base, key));
    }
  }
  $Number.prototype = proto;
  proto.constructor = $Number;
  require('./_redefine')(global, NUMBER, $Number);
}

},{"./_cof":25,"./_descriptors":36,"./_fails":42,"./_global":47,"./_has":48,"./_inherit-if-required":52,"./_object-create":77,"./_object-dp":78,"./_object-gopd":81,"./_object-gopn":83,"./_redefine":98,"./_string-trim":115,"./_to-primitive":124}],183:[function(require,module,exports){
// 20.1.2.1 Number.EPSILON
var $export = require('./_export');

$export($export.S, 'Number', { EPSILON: Math.pow(2, -52) });

},{"./_export":40}],184:[function(require,module,exports){
// 20.1.2.2 Number.isFinite(number)
var $export = require('./_export');
var _isFinite = require('./_global').isFinite;

$export($export.S, 'Number', {
  isFinite: function isFinite(it) {
    return typeof it == 'number' && _isFinite(it);
  }
});

},{"./_export":40,"./_global":47}],185:[function(require,module,exports){
// 20.1.2.3 Number.isInteger(number)
var $export = require('./_export');

$export($export.S, 'Number', { isInteger: require('./_is-integer') });

},{"./_export":40,"./_is-integer":57}],186:[function(require,module,exports){
// 20.1.2.4 Number.isNaN(number)
var $export = require('./_export');

$export($export.S, 'Number', {
  isNaN: function isNaN(number) {
    // eslint-disable-next-line no-self-compare
    return number != number;
  }
});

},{"./_export":40}],187:[function(require,module,exports){
// 20.1.2.5 Number.isSafeInteger(number)
var $export = require('./_export');
var isInteger = require('./_is-integer');
var abs = Math.abs;

$export($export.S, 'Number', {
  isSafeInteger: function isSafeInteger(number) {
    return isInteger(number) && abs(number) <= 0x1fffffffffffff;
  }
});

},{"./_export":40,"./_is-integer":57}],188:[function(require,module,exports){
// 20.1.2.6 Number.MAX_SAFE_INTEGER
var $export = require('./_export');

$export($export.S, 'Number', { MAX_SAFE_INTEGER: 0x1fffffffffffff });

},{"./_export":40}],189:[function(require,module,exports){
// 20.1.2.10 Number.MIN_SAFE_INTEGER
var $export = require('./_export');

$export($export.S, 'Number', { MIN_SAFE_INTEGER: -0x1fffffffffffff });

},{"./_export":40}],190:[function(require,module,exports){
var $export = require('./_export');
var $parseFloat = require('./_parse-float');
// 20.1.2.12 Number.parseFloat(string)
$export($export.S + $export.F * (Number.parseFloat != $parseFloat), 'Number', { parseFloat: $parseFloat });

},{"./_export":40,"./_parse-float":92}],191:[function(require,module,exports){
var $export = require('./_export');
var $parseInt = require('./_parse-int');
// 20.1.2.13 Number.parseInt(string, radix)
$export($export.S + $export.F * (Number.parseInt != $parseInt), 'Number', { parseInt: $parseInt });

},{"./_export":40,"./_parse-int":93}],192:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var toInteger = require('./_to-integer');
var aNumberValue = require('./_a-number-value');
var repeat = require('./_string-repeat');
var $toFixed = 1.0.toFixed;
var floor = Math.floor;
var data = [0, 0, 0, 0, 0, 0];
var ERROR = 'Number.toFixed: incorrect invocation!';
var ZERO = '0';

var multiply = function (n, c) {
  var i = -1;
  var c2 = c;
  while (++i < 6) {
    c2 += n * data[i];
    data[i] = c2 % 1e7;
    c2 = floor(c2 / 1e7);
  }
};
var divide = function (n) {
  var i = 6;
  var c = 0;
  while (--i >= 0) {
    c += data[i];
    data[i] = floor(c / n);
    c = (c % n) * 1e7;
  }
};
var numToString = function () {
  var i = 6;
  var s = '';
  while (--i >= 0) {
    if (s !== '' || i === 0 || data[i] !== 0) {
      var t = String(data[i]);
      s = s === '' ? t : s + repeat.call(ZERO, 7 - t.length) + t;
    }
  } return s;
};
var pow = function (x, n, acc) {
  return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);
};
var log = function (x) {
  var n = 0;
  var x2 = x;
  while (x2 >= 4096) {
    n += 12;
    x2 /= 4096;
  }
  while (x2 >= 2) {
    n += 1;
    x2 /= 2;
  } return n;
};

$export($export.P + $export.F * (!!$toFixed && (
  0.00008.toFixed(3) !== '0.000' ||
  0.9.toFixed(0) !== '1' ||
  1.255.toFixed(2) !== '1.25' ||
  1000000000000000128.0.toFixed(0) !== '1000000000000000128'
) || !require('./_fails')(function () {
  // V8 ~ Android 4.3-
  $toFixed.call({});
})), 'Number', {
  toFixed: function toFixed(fractionDigits) {
    var x = aNumberValue(this, ERROR);
    var f = toInteger(fractionDigits);
    var s = '';
    var m = ZERO;
    var e, z, j, k;
    if (f < 0 || f > 20) throw RangeError(ERROR);
    // eslint-disable-next-line no-self-compare
    if (x != x) return 'NaN';
    if (x <= -1e21 || x >= 1e21) return String(x);
    if (x < 0) {
      s = '-';
      x = -x;
    }
    if (x > 1e-21) {
      e = log(x * pow(2, 69, 1)) - 69;
      z = e < 0 ? x * pow(2, -e, 1) : x / pow(2, e, 1);
      z *= 0x10000000000000;
      e = 52 - e;
      if (e > 0) {
        multiply(0, z);
        j = f;
        while (j >= 7) {
          multiply(1e7, 0);
          j -= 7;
        }
        multiply(pow(10, j, 1), 0);
        j = e - 1;
        while (j >= 23) {
          divide(1 << 23);
          j -= 23;
        }
        divide(1 << j);
        multiply(1, 1);
        divide(2);
        m = numToString();
      } else {
        multiply(0, z);
        multiply(1 << -e, 0);
        m = numToString() + repeat.call(ZERO, f);
      }
    }
    if (f > 0) {
      k = m.length;
      m = s + (k <= f ? '0.' + repeat.call(ZERO, f - k) + m : m.slice(0, k - f) + '.' + m.slice(k - f));
    } else {
      m = s + m;
    } return m;
  }
});

},{"./_a-number-value":11,"./_export":40,"./_fails":42,"./_string-repeat":114,"./_to-integer":120}],193:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var $fails = require('./_fails');
var aNumberValue = require('./_a-number-value');
var $toPrecision = 1.0.toPrecision;

$export($export.P + $export.F * ($fails(function () {
  // IE7-
  return $toPrecision.call(1, undefined) !== '1';
}) || !$fails(function () {
  // V8 ~ Android 4.3-
  $toPrecision.call({});
})), 'Number', {
  toPrecision: function toPrecision(precision) {
    var that = aNumberValue(this, 'Number#toPrecision: incorrect invocation!');
    return precision === undefined ? $toPrecision.call(that) : $toPrecision.call(that, precision);
  }
});

},{"./_a-number-value":11,"./_export":40,"./_fails":42}],194:[function(require,module,exports){
// 19.1.3.1 Object.assign(target, source)
var $export = require('./_export');

$export($export.S + $export.F, 'Object', { assign: require('./_object-assign') });

},{"./_export":40,"./_object-assign":76}],195:[function(require,module,exports){
var $export = require('./_export');
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
$export($export.S, 'Object', { create: require('./_object-create') });

},{"./_export":40,"./_object-create":77}],196:[function(require,module,exports){
var $export = require('./_export');
// 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)
$export($export.S + $export.F * !require('./_descriptors'), 'Object', { defineProperties: require('./_object-dps') });

},{"./_descriptors":36,"./_export":40,"./_object-dps":79}],197:[function(require,module,exports){
var $export = require('./_export');
// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
$export($export.S + $export.F * !require('./_descriptors'), 'Object', { defineProperty: require('./_object-dp').f });

},{"./_descriptors":36,"./_export":40,"./_object-dp":78}],198:[function(require,module,exports){
// 19.1.2.5 Object.freeze(O)
var isObject = require('./_is-object');
var meta = require('./_meta').onFreeze;

require('./_object-sap')('freeze', function ($freeze) {
  return function freeze(it) {
    return $freeze && isObject(it) ? $freeze(meta(it)) : it;
  };
});

},{"./_is-object":58,"./_meta":72,"./_object-sap":89}],199:[function(require,module,exports){
// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
var toIObject = require('./_to-iobject');
var $getOwnPropertyDescriptor = require('./_object-gopd').f;

require('./_object-sap')('getOwnPropertyDescriptor', function () {
  return function getOwnPropertyDescriptor(it, key) {
    return $getOwnPropertyDescriptor(toIObject(it), key);
  };
});

},{"./_object-gopd":81,"./_object-sap":89,"./_to-iobject":121}],200:[function(require,module,exports){
// 19.1.2.7 Object.getOwnPropertyNames(O)
require('./_object-sap')('getOwnPropertyNames', function () {
  return require('./_object-gopn-ext').f;
});

},{"./_object-gopn-ext":82,"./_object-sap":89}],201:[function(require,module,exports){
// 19.1.2.9 Object.getPrototypeOf(O)
var toObject = require('./_to-object');
var $getPrototypeOf = require('./_object-gpo');

require('./_object-sap')('getPrototypeOf', function () {
  return function getPrototypeOf(it) {
    return $getPrototypeOf(toObject(it));
  };
});

},{"./_object-gpo":85,"./_object-sap":89,"./_to-object":123}],202:[function(require,module,exports){
// 19.1.2.11 Object.isExtensible(O)
var isObject = require('./_is-object');

require('./_object-sap')('isExtensible', function ($isExtensible) {
  return function isExtensible(it) {
    return isObject(it) ? $isExtensible ? $isExtensible(it) : true : false;
  };
});

},{"./_is-object":58,"./_object-sap":89}],203:[function(require,module,exports){
// 19.1.2.12 Object.isFrozen(O)
var isObject = require('./_is-object');

require('./_object-sap')('isFrozen', function ($isFrozen) {
  return function isFrozen(it) {
    return isObject(it) ? $isFrozen ? $isFrozen(it) : false : true;
  };
});

},{"./_is-object":58,"./_object-sap":89}],204:[function(require,module,exports){
// 19.1.2.13 Object.isSealed(O)
var isObject = require('./_is-object');

require('./_object-sap')('isSealed', function ($isSealed) {
  return function isSealed(it) {
    return isObject(it) ? $isSealed ? $isSealed(it) : false : true;
  };
});

},{"./_is-object":58,"./_object-sap":89}],205:[function(require,module,exports){
// 19.1.3.10 Object.is(value1, value2)
var $export = require('./_export');
$export($export.S, 'Object', { is: require('./_same-value') });

},{"./_export":40,"./_same-value":100}],206:[function(require,module,exports){
// 19.1.2.14 Object.keys(O)
var toObject = require('./_to-object');
var $keys = require('./_object-keys');

require('./_object-sap')('keys', function () {
  return function keys(it) {
    return $keys(toObject(it));
  };
});

},{"./_object-keys":87,"./_object-sap":89,"./_to-object":123}],207:[function(require,module,exports){
// 19.1.2.15 Object.preventExtensions(O)
var isObject = require('./_is-object');
var meta = require('./_meta').onFreeze;

require('./_object-sap')('preventExtensions', function ($preventExtensions) {
  return function preventExtensions(it) {
    return $preventExtensions && isObject(it) ? $preventExtensions(meta(it)) : it;
  };
});

},{"./_is-object":58,"./_meta":72,"./_object-sap":89}],208:[function(require,module,exports){
// 19.1.2.17 Object.seal(O)
var isObject = require('./_is-object');
var meta = require('./_meta').onFreeze;

require('./_object-sap')('seal', function ($seal) {
  return function seal(it) {
    return $seal && isObject(it) ? $seal(meta(it)) : it;
  };
});

},{"./_is-object":58,"./_meta":72,"./_object-sap":89}],209:[function(require,module,exports){
// 19.1.3.19 Object.setPrototypeOf(O, proto)
var $export = require('./_export');
$export($export.S, 'Object', { setPrototypeOf: require('./_set-proto').set });

},{"./_export":40,"./_set-proto":103}],210:[function(require,module,exports){
'use strict';
// 19.1.3.6 Object.prototype.toString()
var classof = require('./_classof');
var test = {};
test[require('./_wks')('toStringTag')] = 'z';
if (test + '' != '[object z]') {
  require('./_redefine')(Object.prototype, 'toString', function toString() {
    return '[object ' + classof(this) + ']';
  }, true);
}

},{"./_classof":24,"./_redefine":98,"./_wks":132}],211:[function(require,module,exports){
var $export = require('./_export');
var $parseFloat = require('./_parse-float');
// 18.2.4 parseFloat(string)
$export($export.G + $export.F * (parseFloat != $parseFloat), { parseFloat: $parseFloat });

},{"./_export":40,"./_parse-float":92}],212:[function(require,module,exports){
var $export = require('./_export');
var $parseInt = require('./_parse-int');
// 18.2.5 parseInt(string, radix)
$export($export.G + $export.F * (parseInt != $parseInt), { parseInt: $parseInt });

},{"./_export":40,"./_parse-int":93}],213:[function(require,module,exports){
'use strict';
var LIBRARY = require('./_library');
var global = require('./_global');
var ctx = require('./_ctx');
var classof = require('./_classof');
var $export = require('./_export');
var isObject = require('./_is-object');
var aFunction = require('./_a-function');
var anInstance = require('./_an-instance');
var forOf = require('./_for-of');
var speciesConstructor = require('./_species-constructor');
var task = require('./_task').set;
var microtask = require('./_microtask')();
var newPromiseCapabilityModule = require('./_new-promise-capability');
var perform = require('./_perform');
var promiseResolve = require('./_promise-resolve');
var PROMISE = 'Promise';
var TypeError = global.TypeError;
var process = global.process;
var $Promise = global[PROMISE];
var isNode = classof(process) == 'process';
var empty = function () { /* empty */ };
var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
var newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;

var USE_NATIVE = !!function () {
  try {
    // correct subclassing with @@species support
    var promise = $Promise.resolve(1);
    var FakePromise = (promise.constructor = {})[require('./_wks')('species')] = function (exec) {
      exec(empty, empty);
    };
    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
    return (isNode || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise;
  } catch (e) { /* empty */ }
}();

// helpers
var isThenable = function (it) {
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};
var notify = function (promise, isReject) {
  if (promise._n) return;
  promise._n = true;
  var chain = promise._c;
  microtask(function () {
    var value = promise._v;
    var ok = promise._s == 1;
    var i = 0;
    var run = function (reaction) {
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve = reaction.resolve;
      var reject = reaction.reject;
      var domain = reaction.domain;
      var result, then;
      try {
        if (handler) {
          if (!ok) {
            if (promise._h == 2) onHandleUnhandled(promise);
            promise._h = 1;
          }
          if (handler === true) result = value;
          else {
            if (domain) domain.enter();
            result = handler(value);
            if (domain) domain.exit();
          }
          if (result === reaction.promise) {
            reject(TypeError('Promise-chain cycle'));
          } else if (then = isThenable(result)) {
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch (e) {
        reject(e);
      }
    };
    while (chain.length > i) run(chain[i++]); // variable length - can't use forEach
    promise._c = [];
    promise._n = false;
    if (isReject && !promise._h) onUnhandled(promise);
  });
};
var onUnhandled = function (promise) {
  task.call(global, function () {
    var value = promise._v;
    var unhandled = isUnhandled(promise);
    var result, handler, console;
    if (unhandled) {
      result = perform(function () {
        if (isNode) {
          process.emit('unhandledRejection', value, promise);
        } else if (handler = global.onunhandledrejection) {
          handler({ promise: promise, reason: value });
        } else if ((console = global.console) && console.error) {
          console.error('Unhandled promise rejection', value);
        }
      });
      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
    } promise._a = undefined;
    if (unhandled && result.e) throw result.v;
  });
};
var isUnhandled = function (promise) {
  if (promise._h == 1) return false;
  var chain = promise._a || promise._c;
  var i = 0;
  var reaction;
  while (chain.length > i) {
    reaction = chain[i++];
    if (reaction.fail || !isUnhandled(reaction.promise)) return false;
  } return true;
};
var onHandleUnhandled = function (promise) {
  task.call(global, function () {
    var handler;
    if (isNode) {
      process.emit('rejectionHandled', promise);
    } else if (handler = global.onrejectionhandled) {
      handler({ promise: promise, reason: promise._v });
    }
  });
};
var $reject = function (value) {
  var promise = this;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  promise._v = value;
  promise._s = 2;
  if (!promise._a) promise._a = promise._c.slice();
  notify(promise, true);
};
var $resolve = function (value) {
  var promise = this;
  var then;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  try {
    if (promise === value) throw TypeError("Promise can't be resolved itself");
    if (then = isThenable(value)) {
      microtask(function () {
        var wrapper = { _w: promise, _d: false }; // wrap
        try {
          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
        } catch (e) {
          $reject.call(wrapper, e);
        }
      });
    } else {
      promise._v = value;
      promise._s = 1;
      notify(promise, false);
    }
  } catch (e) {
    $reject.call({ _w: promise, _d: false }, e); // wrap
  }
};

// constructor polyfill
if (!USE_NATIVE) {
  // 25.4.3.1 Promise(executor)
  $Promise = function Promise(executor) {
    anInstance(this, $Promise, PROMISE, '_h');
    aFunction(executor);
    Internal.call(this);
    try {
      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
    } catch (err) {
      $reject.call(this, err);
    }
  };
  // eslint-disable-next-line no-unused-vars
  Internal = function Promise(executor) {
    this._c = [];             // <- awaiting reactions
    this._a = undefined;      // <- checked in isUnhandled reactions
    this._s = 0;              // <- state
    this._d = false;          // <- done
    this._v = undefined;      // <- value
    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
    this._n = false;          // <- notify
  };
  Internal.prototype = require('./_redefine-all')($Promise.prototype, {
    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
    then: function then(onFulfilled, onRejected) {
      var reaction = newPromiseCapability(speciesConstructor(this, $Promise));
      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail = typeof onRejected == 'function' && onRejected;
      reaction.domain = isNode ? process.domain : undefined;
      this._c.push(reaction);
      if (this._a) this._a.push(reaction);
      if (this._s) notify(this, false);
      return reaction.promise;
    },
    // 25.4.5.1 Promise.prototype.catch(onRejected)
    'catch': function (onRejected) {
      return this.then(undefined, onRejected);
    }
  });
  OwnPromiseCapability = function () {
    var promise = new Internal();
    this.promise = promise;
    this.resolve = ctx($resolve, promise, 1);
    this.reject = ctx($reject, promise, 1);
  };
  newPromiseCapabilityModule.f = newPromiseCapability = function (C) {
    return C === $Promise || C === Wrapper
      ? new OwnPromiseCapability(C)
      : newGenericPromiseCapability(C);
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Promise: $Promise });
require('./_set-to-string-tag')($Promise, PROMISE);
require('./_set-species')(PROMISE);
Wrapper = require('./_core')[PROMISE];

// statics
$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
  // 25.4.4.5 Promise.reject(r)
  reject: function reject(r) {
    var capability = newPromiseCapability(this);
    var $$reject = capability.reject;
    $$reject(r);
    return capability.promise;
  }
});
$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
  // 25.4.4.6 Promise.resolve(x)
  resolve: function resolve(x) {
    return promiseResolve(LIBRARY && this === Wrapper ? $Promise : this, x);
  }
});
$export($export.S + $export.F * !(USE_NATIVE && require('./_iter-detect')(function (iter) {
  $Promise.all(iter)['catch'](empty);
})), PROMISE, {
  // 25.4.4.1 Promise.all(iterable)
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var values = [];
      var index = 0;
      var remaining = 1;
      forOf(iterable, false, function (promise) {
        var $index = index++;
        var alreadyCalled = false;
        values.push(undefined);
        remaining++;
        C.resolve(promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[$index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if (result.e) reject(result.v);
    return capability.promise;
  },
  // 25.4.4.4 Promise.race(iterable)
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var reject = capability.reject;
    var result = perform(function () {
      forOf(iterable, false, function (promise) {
        C.resolve(promise).then(capability.resolve, reject);
      });
    });
    if (result.e) reject(result.v);
    return capability.promise;
  }
});

},{"./_a-function":10,"./_an-instance":13,"./_classof":24,"./_core":30,"./_ctx":32,"./_export":40,"./_for-of":46,"./_global":47,"./_is-object":58,"./_iter-detect":63,"./_library":66,"./_microtask":74,"./_new-promise-capability":75,"./_perform":94,"./_promise-resolve":95,"./_redefine-all":97,"./_set-species":104,"./_set-to-string-tag":105,"./_species-constructor":108,"./_task":117,"./_wks":132}],214:[function(require,module,exports){
// 26.1.1 Reflect.apply(target, thisArgument, argumentsList)
var $export = require('./_export');
var aFunction = require('./_a-function');
var anObject = require('./_an-object');
var rApply = (require('./_global').Reflect || {}).apply;
var fApply = Function.apply;
// MS Edge argumentsList argument is optional
$export($export.S + $export.F * !require('./_fails')(function () {
  rApply(function () { /* empty */ });
}), 'Reflect', {
  apply: function apply(target, thisArgument, argumentsList) {
    var T = aFunction(target);
    var L = anObject(argumentsList);
    return rApply ? rApply(T, thisArgument, L) : fApply.call(T, thisArgument, L);
  }
});

},{"./_a-function":10,"./_an-object":14,"./_export":40,"./_fails":42,"./_global":47}],215:[function(require,module,exports){
// 26.1.2 Reflect.construct(target, argumentsList [, newTarget])
var $export = require('./_export');
var create = require('./_object-create');
var aFunction = require('./_a-function');
var anObject = require('./_an-object');
var isObject = require('./_is-object');
var fails = require('./_fails');
var bind = require('./_bind');
var rConstruct = (require('./_global').Reflect || {}).construct;

// MS Edge supports only 2 arguments and argumentsList argument is optional
// FF Nightly sets third argument as `new.target`, but does not create `this` from it
var NEW_TARGET_BUG = fails(function () {
  function F() { /* empty */ }
  return !(rConstruct(function () { /* empty */ }, [], F) instanceof F);
});
var ARGS_BUG = !fails(function () {
  rConstruct(function () { /* empty */ });
});

$export($export.S + $export.F * (NEW_TARGET_BUG || ARGS_BUG), 'Reflect', {
  construct: function construct(Target, args /* , newTarget */) {
    aFunction(Target);
    anObject(args);
    var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);
    if (ARGS_BUG && !NEW_TARGET_BUG) return rConstruct(Target, args, newTarget);
    if (Target == newTarget) {
      // w/o altered newTarget, optimization for 0-4 arguments
      switch (args.length) {
        case 0: return new Target();
        case 1: return new Target(args[0]);
        case 2: return new Target(args[0], args[1]);
        case 3: return new Target(args[0], args[1], args[2]);
        case 4: return new Target(args[0], args[1], args[2], args[3]);
      }
      // w/o altered newTarget, lot of arguments case
      var $args = [null];
      $args.push.apply($args, args);
      return new (bind.apply(Target, $args))();
    }
    // with altered newTarget, not support built-in constructors
    var proto = newTarget.prototype;
    var instance = create(isObject(proto) ? proto : Object.prototype);
    var result = Function.apply.call(Target, instance, args);
    return isObject(result) ? result : instance;
  }
});

},{"./_a-function":10,"./_an-object":14,"./_bind":23,"./_export":40,"./_fails":42,"./_global":47,"./_is-object":58,"./_object-create":77}],216:[function(require,module,exports){
// 26.1.3 Reflect.defineProperty(target, propertyKey, attributes)
var dP = require('./_object-dp');
var $export = require('./_export');
var anObject = require('./_an-object');
var toPrimitive = require('./_to-primitive');

// MS Edge has broken Reflect.defineProperty - throwing instead of returning false
$export($export.S + $export.F * require('./_fails')(function () {
  // eslint-disable-next-line no-undef
  Reflect.defineProperty(dP.f({}, 1, { value: 1 }), 1, { value: 2 });
}), 'Reflect', {
  defineProperty: function defineProperty(target, propertyKey, attributes) {
    anObject(target);
    propertyKey = toPrimitive(propertyKey, true);
    anObject(attributes);
    try {
      dP.f(target, propertyKey, attributes);
      return true;
    } catch (e) {
      return false;
    }
  }
});

},{"./_an-object":14,"./_export":40,"./_fails":42,"./_object-dp":78,"./_to-primitive":124}],217:[function(require,module,exports){
// 26.1.4 Reflect.deleteProperty(target, propertyKey)
var $export = require('./_export');
var gOPD = require('./_object-gopd').f;
var anObject = require('./_an-object');

$export($export.S, 'Reflect', {
  deleteProperty: function deleteProperty(target, propertyKey) {
    var desc = gOPD(anObject(target), propertyKey);
    return desc && !desc.configurable ? false : delete target[propertyKey];
  }
});

},{"./_an-object":14,"./_export":40,"./_object-gopd":81}],218:[function(require,module,exports){
'use strict';
// 26.1.5 Reflect.enumerate(target)
var $export = require('./_export');
var anObject = require('./_an-object');
var Enumerate = function (iterated) {
  this._t = anObject(iterated); // target
  this._i = 0;                  // next index
  var keys = this._k = [];      // keys
  var key;
  for (key in iterated) keys.push(key);
};
require('./_iter-create')(Enumerate, 'Object', function () {
  var that = this;
  var keys = that._k;
  var key;
  do {
    if (that._i >= keys.length) return { value: undefined, done: true };
  } while (!((key = keys[that._i++]) in that._t));
  return { value: key, done: false };
});

$export($export.S, 'Reflect', {
  enumerate: function enumerate(target) {
    return new Enumerate(target);
  }
});

},{"./_an-object":14,"./_export":40,"./_iter-create":61}],219:[function(require,module,exports){
// 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey)
var gOPD = require('./_object-gopd');
var $export = require('./_export');
var anObject = require('./_an-object');

$export($export.S, 'Reflect', {
  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) {
    return gOPD.f(anObject(target), propertyKey);
  }
});

},{"./_an-object":14,"./_export":40,"./_object-gopd":81}],220:[function(require,module,exports){
// 26.1.8 Reflect.getPrototypeOf(target)
var $export = require('./_export');
var getProto = require('./_object-gpo');
var anObject = require('./_an-object');

$export($export.S, 'Reflect', {
  getPrototypeOf: function getPrototypeOf(target) {
    return getProto(anObject(target));
  }
});

},{"./_an-object":14,"./_export":40,"./_object-gpo":85}],221:[function(require,module,exports){
// 26.1.6 Reflect.get(target, propertyKey [, receiver])
var gOPD = require('./_object-gopd');
var getPrototypeOf = require('./_object-gpo');
var has = require('./_has');
var $export = require('./_export');
var isObject = require('./_is-object');
var anObject = require('./_an-object');

function get(target, propertyKey /* , receiver */) {
  var receiver = arguments.length < 3 ? target : arguments[2];
  var desc, proto;
  if (anObject(target) === receiver) return target[propertyKey];
  if (desc = gOPD.f(target, propertyKey)) return has(desc, 'value')
    ? desc.value
    : desc.get !== undefined
      ? desc.get.call(receiver)
      : undefined;
  if (isObject(proto = getPrototypeOf(target))) return get(proto, propertyKey, receiver);
}

$export($export.S, 'Reflect', { get: get });

},{"./_an-object":14,"./_export":40,"./_has":48,"./_is-object":58,"./_object-gopd":81,"./_object-gpo":85}],222:[function(require,module,exports){
// 26.1.9 Reflect.has(target, propertyKey)
var $export = require('./_export');

$export($export.S, 'Reflect', {
  has: function has(target, propertyKey) {
    return propertyKey in target;
  }
});

},{"./_export":40}],223:[function(require,module,exports){
// 26.1.10 Reflect.isExtensible(target)
var $export = require('./_export');
var anObject = require('./_an-object');
var $isExtensible = Object.isExtensible;

$export($export.S, 'Reflect', {
  isExtensible: function isExtensible(target) {
    anObject(target);
    return $isExtensible ? $isExtensible(target) : true;
  }
});

},{"./_an-object":14,"./_export":40}],224:[function(require,module,exports){
// 26.1.11 Reflect.ownKeys(target)
var $export = require('./_export');

$export($export.S, 'Reflect', { ownKeys: require('./_own-keys') });

},{"./_export":40,"./_own-keys":91}],225:[function(require,module,exports){
// 26.1.12 Reflect.preventExtensions(target)
var $export = require('./_export');
var anObject = require('./_an-object');
var $preventExtensions = Object.preventExtensions;

$export($export.S, 'Reflect', {
  preventExtensions: function preventExtensions(target) {
    anObject(target);
    try {
      if ($preventExtensions) $preventExtensions(target);
      return true;
    } catch (e) {
      return false;
    }
  }
});

},{"./_an-object":14,"./_export":40}],226:[function(require,module,exports){
// 26.1.14 Reflect.setPrototypeOf(target, proto)
var $export = require('./_export');
var setProto = require('./_set-proto');

if (setProto) $export($export.S, 'Reflect', {
  setPrototypeOf: function setPrototypeOf(target, proto) {
    setProto.check(target, proto);
    try {
      setProto.set(target, proto);
      return true;
    } catch (e) {
      return false;
    }
  }
});

},{"./_export":40,"./_set-proto":103}],227:[function(require,module,exports){
// 26.1.13 Reflect.set(target, propertyKey, V [, receiver])
var dP = require('./_object-dp');
var gOPD = require('./_object-gopd');
var getPrototypeOf = require('./_object-gpo');
var has = require('./_has');
var $export = require('./_export');
var createDesc = require('./_property-desc');
var anObject = require('./_an-object');
var isObject = require('./_is-object');

function set(target, propertyKey, V /* , receiver */) {
  var receiver = arguments.length < 4 ? target : arguments[3];
  var ownDesc = gOPD.f(anObject(target), propertyKey);
  var existingDescriptor, proto;
  if (!ownDesc) {
    if (isObject(proto = getPrototypeOf(target))) {
      return set(proto, propertyKey, V, receiver);
    }
    ownDesc = createDesc(0);
  }
  if (has(ownDesc, 'value')) {
    if (ownDesc.writable === false || !isObject(receiver)) return false;
    existingDescriptor = gOPD.f(receiver, propertyKey) || createDesc(0);
    existingDescriptor.value = V;
    dP.f(receiver, propertyKey, existingDescriptor);
    return true;
  }
  return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true);
}

$export($export.S, 'Reflect', { set: set });

},{"./_an-object":14,"./_export":40,"./_has":48,"./_is-object":58,"./_object-dp":78,"./_object-gopd":81,"./_object-gpo":85,"./_property-desc":96}],228:[function(require,module,exports){
var global = require('./_global');
var inheritIfRequired = require('./_inherit-if-required');
var dP = require('./_object-dp').f;
var gOPN = require('./_object-gopn').f;
var isRegExp = require('./_is-regexp');
var $flags = require('./_flags');
var $RegExp = global.RegExp;
var Base = $RegExp;
var proto = $RegExp.prototype;
var re1 = /a/g;
var re2 = /a/g;
// "new" creates a new object, old webkit buggy here
var CORRECT_NEW = new $RegExp(re1) !== re1;

if (require('./_descriptors') && (!CORRECT_NEW || require('./_fails')(function () {
  re2[require('./_wks')('match')] = false;
  // RegExp constructor can alter flags and IsRegExp works correct with @@match
  return $RegExp(re1) != re1 || $RegExp(re2) == re2 || $RegExp(re1, 'i') != '/a/i';
}))) {
  $RegExp = function RegExp(p, f) {
    var tiRE = this instanceof $RegExp;
    var piRE = isRegExp(p);
    var fiU = f === undefined;
    return !tiRE && piRE && p.constructor === $RegExp && fiU ? p
      : inheritIfRequired(CORRECT_NEW
        ? new Base(piRE && !fiU ? p.source : p, f)
        : Base((piRE = p instanceof $RegExp) ? p.source : p, piRE && fiU ? $flags.call(p) : f)
      , tiRE ? this : proto, $RegExp);
  };
  var proxy = function (key) {
    key in $RegExp || dP($RegExp, key, {
      configurable: true,
      get: function () { return Base[key]; },
      set: function (it) { Base[key] = it; }
    });
  };
  for (var keys = gOPN(Base), i = 0; keys.length > i;) proxy(keys[i++]);
  proto.constructor = $RegExp;
  $RegExp.prototype = proto;
  require('./_redefine')(global, 'RegExp', $RegExp);
}

require('./_set-species')('RegExp');

},{"./_descriptors":36,"./_fails":42,"./_flags":44,"./_global":47,"./_inherit-if-required":52,"./_is-regexp":59,"./_object-dp":78,"./_object-gopn":83,"./_redefine":98,"./_set-species":104,"./_wks":132}],229:[function(require,module,exports){
// 21.2.5.3 get RegExp.prototype.flags()
if (require('./_descriptors') && /./g.flags != 'g') require('./_object-dp').f(RegExp.prototype, 'flags', {
  configurable: true,
  get: require('./_flags')
});

},{"./_descriptors":36,"./_flags":44,"./_object-dp":78}],230:[function(require,module,exports){
// @@match logic
require('./_fix-re-wks')('match', 1, function (defined, MATCH, $match) {
  // 21.1.3.11 String.prototype.match(regexp)
  return [function match(regexp) {
    'use strict';
    var O = defined(this);
    var fn = regexp == undefined ? undefined : regexp[MATCH];
    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
  }, $match];
});

},{"./_fix-re-wks":43}],231:[function(require,module,exports){
// @@replace logic
require('./_fix-re-wks')('replace', 2, function (defined, REPLACE, $replace) {
  // 21.1.3.14 String.prototype.replace(searchValue, replaceValue)
  return [function replace(searchValue, replaceValue) {
    'use strict';
    var O = defined(this);
    var fn = searchValue == undefined ? undefined : searchValue[REPLACE];
    return fn !== undefined
      ? fn.call(searchValue, O, replaceValue)
      : $replace.call(String(O), searchValue, replaceValue);
  }, $replace];
});

},{"./_fix-re-wks":43}],232:[function(require,module,exports){
// @@search logic
require('./_fix-re-wks')('search', 1, function (defined, SEARCH, $search) {
  // 21.1.3.15 String.prototype.search(regexp)
  return [function search(regexp) {
    'use strict';
    var O = defined(this);
    var fn = regexp == undefined ? undefined : regexp[SEARCH];
    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
  }, $search];
});

},{"./_fix-re-wks":43}],233:[function(require,module,exports){
// @@split logic
require('./_fix-re-wks')('split', 2, function (defined, SPLIT, $split) {
  'use strict';
  var isRegExp = require('./_is-regexp');
  var _split = $split;
  var $push = [].push;
  var $SPLIT = 'split';
  var LENGTH = 'length';
  var LAST_INDEX = 'lastIndex';
  if (
    'abbc'[$SPLIT](/(b)*/)[1] == 'c' ||
    'test'[$SPLIT](/(?:)/, -1)[LENGTH] != 4 ||
    'ab'[$SPLIT](/(?:ab)*/)[LENGTH] != 2 ||
    '.'[$SPLIT](/(.?)(.?)/)[LENGTH] != 4 ||
    '.'[$SPLIT](/()()/)[LENGTH] > 1 ||
    ''[$SPLIT](/.?/)[LENGTH]
  ) {
    var NPCG = /()??/.exec('')[1] === undefined; // nonparticipating capturing group
    // based on es5-shim implementation, need to rework it
    $split = function (separator, limit) {
      var string = String(this);
      if (separator === undefined && limit === 0) return [];
      // If `separator` is not a regex, use native split
      if (!isRegExp(separator)) return _split.call(string, separator, limit);
      var output = [];
      var flags = (separator.ignoreCase ? 'i' : '') +
                  (separator.multiline ? 'm' : '') +
                  (separator.unicode ? 'u' : '') +
                  (separator.sticky ? 'y' : '');
      var lastLastIndex = 0;
      var splitLimit = limit === undefined ? 4294967295 : limit >>> 0;
      // Make `global` and avoid `lastIndex` issues by working with a copy
      var separatorCopy = new RegExp(separator.source, flags + 'g');
      var separator2, match, lastIndex, lastLength, i;
      // Doesn't need flags gy, but they don't hurt
      if (!NPCG) separator2 = new RegExp('^' + separatorCopy.source + '$(?!\\s)', flags);
      while (match = separatorCopy.exec(string)) {
        // `separatorCopy.lastIndex` is not reliable cross-browser
        lastIndex = match.index + match[0][LENGTH];
        if (lastIndex > lastLastIndex) {
          output.push(string.slice(lastLastIndex, match.index));
          // Fix browsers whose `exec` methods don't consistently return `undefined` for NPCG
          // eslint-disable-next-line no-loop-func
          if (!NPCG && match[LENGTH] > 1) match[0].replace(separator2, function () {
            for (i = 1; i < arguments[LENGTH] - 2; i++) if (arguments[i] === undefined) match[i] = undefined;
          });
          if (match[LENGTH] > 1 && match.index < string[LENGTH]) $push.apply(output, match.slice(1));
          lastLength = match[0][LENGTH];
          lastLastIndex = lastIndex;
          if (output[LENGTH] >= splitLimit) break;
        }
        if (separatorCopy[LAST_INDEX] === match.index) separatorCopy[LAST_INDEX]++; // Avoid an infinite loop
      }
      if (lastLastIndex === string[LENGTH]) {
        if (lastLength || !separatorCopy.test('')) output.push('');
      } else output.push(string.slice(lastLastIndex));
      return output[LENGTH] > splitLimit ? output.slice(0, splitLimit) : output;
    };
  // Chakra, V8
  } else if ('0'[$SPLIT](undefined, 0)[LENGTH]) {
    $split = function (separator, limit) {
      return separator === undefined && limit === 0 ? [] : _split.call(this, separator, limit);
    };
  }
  // 21.1.3.17 String.prototype.split(separator, limit)
  return [function split(separator, limit) {
    var O = defined(this);
    var fn = separator == undefined ? undefined : separator[SPLIT];
    return fn !== undefined ? fn.call(separator, O, limit) : $split.call(String(O), separator, limit);
  }, $split];
});

},{"./_fix-re-wks":43,"./_is-regexp":59}],234:[function(require,module,exports){
'use strict';
require('./es6.regexp.flags');
var anObject = require('./_an-object');
var $flags = require('./_flags');
var DESCRIPTORS = require('./_descriptors');
var TO_STRING = 'toString';
var $toString = /./[TO_STRING];

var define = function (fn) {
  require('./_redefine')(RegExp.prototype, TO_STRING, fn, true);
};

// 21.2.5.14 RegExp.prototype.toString()
if (require('./_fails')(function () { return $toString.call({ source: 'a', flags: 'b' }) != '/a/b'; })) {
  define(function toString() {
    var R = anObject(this);
    return '/'.concat(R.source, '/',
      'flags' in R ? R.flags : !DESCRIPTORS && R instanceof RegExp ? $flags.call(R) : undefined);
  });
// FF44- RegExp#toString has a wrong name
} else if ($toString.name != TO_STRING) {
  define(function toString() {
    return $toString.call(this);
  });
}

},{"./_an-object":14,"./_descriptors":36,"./_fails":42,"./_flags":44,"./_redefine":98,"./es6.regexp.flags":229}],235:[function(require,module,exports){
'use strict';
var strong = require('./_collection-strong');
var validate = require('./_validate-collection');
var SET = 'Set';

// 23.2 Set Objects
module.exports = require('./_collection')(SET, function (get) {
  return function Set() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.2.3.1 Set.prototype.add(value)
  add: function add(value) {
    return strong.def(validate(this, SET), value = value === 0 ? 0 : value, value);
  }
}, strong);

},{"./_collection":29,"./_collection-strong":26,"./_validate-collection":129}],236:[function(require,module,exports){
'use strict';
// B.2.3.2 String.prototype.anchor(name)
require('./_string-html')('anchor', function (createHTML) {
  return function anchor(name) {
    return createHTML(this, 'a', 'name', name);
  };
});

},{"./_string-html":112}],237:[function(require,module,exports){
'use strict';
// B.2.3.3 String.prototype.big()
require('./_string-html')('big', function (createHTML) {
  return function big() {
    return createHTML(this, 'big', '', '');
  };
});

},{"./_string-html":112}],238:[function(require,module,exports){
'use strict';
// B.2.3.4 String.prototype.blink()
require('./_string-html')('blink', function (createHTML) {
  return function blink() {
    return createHTML(this, 'blink', '', '');
  };
});

},{"./_string-html":112}],239:[function(require,module,exports){
'use strict';
// B.2.3.5 String.prototype.bold()
require('./_string-html')('bold', function (createHTML) {
  return function bold() {
    return createHTML(this, 'b', '', '');
  };
});

},{"./_string-html":112}],240:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var $at = require('./_string-at')(false);
$export($export.P, 'String', {
  // 21.1.3.3 String.prototype.codePointAt(pos)
  codePointAt: function codePointAt(pos) {
    return $at(this, pos);
  }
});

},{"./_export":40,"./_string-at":110}],241:[function(require,module,exports){
// 21.1.3.6 String.prototype.endsWith(searchString [, endPosition])
'use strict';
var $export = require('./_export');
var toLength = require('./_to-length');
var context = require('./_string-context');
var ENDS_WITH = 'endsWith';
var $endsWith = ''[ENDS_WITH];

$export($export.P + $export.F * require('./_fails-is-regexp')(ENDS_WITH), 'String', {
  endsWith: function endsWith(searchString /* , endPosition = @length */) {
    var that = context(this, searchString, ENDS_WITH);
    var endPosition = arguments.length > 1 ? arguments[1] : undefined;
    var len = toLength(that.length);
    var end = endPosition === undefined ? len : Math.min(toLength(endPosition), len);
    var search = String(searchString);
    return $endsWith
      ? $endsWith.call(that, search, end)
      : that.slice(end - search.length, end) === search;
  }
});

},{"./_export":40,"./_fails-is-regexp":41,"./_string-context":111,"./_to-length":122}],242:[function(require,module,exports){
'use strict';
// B.2.3.6 String.prototype.fixed()
require('./_string-html')('fixed', function (createHTML) {
  return function fixed() {
    return createHTML(this, 'tt', '', '');
  };
});

},{"./_string-html":112}],243:[function(require,module,exports){
'use strict';
// B.2.3.7 String.prototype.fontcolor(color)
require('./_string-html')('fontcolor', function (createHTML) {
  return function fontcolor(color) {
    return createHTML(this, 'font', 'color', color);
  };
});

},{"./_string-html":112}],244:[function(require,module,exports){
'use strict';
// B.2.3.8 String.prototype.fontsize(size)
require('./_string-html')('fontsize', function (createHTML) {
  return function fontsize(size) {
    return createHTML(this, 'font', 'size', size);
  };
});

},{"./_string-html":112}],245:[function(require,module,exports){
var $export = require('./_export');
var toAbsoluteIndex = require('./_to-absolute-index');
var fromCharCode = String.fromCharCode;
var $fromCodePoint = String.fromCodePoint;

// length should be 1, old FF problem
$export($export.S + $export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {
  // 21.1.2.2 String.fromCodePoint(...codePoints)
  fromCodePoint: function fromCodePoint(x) { // eslint-disable-line no-unused-vars
    var res = [];
    var aLen = arguments.length;
    var i = 0;
    var code;
    while (aLen > i) {
      code = +arguments[i++];
      if (toAbsoluteIndex(code, 0x10ffff) !== code) throw RangeError(code + ' is not a valid code point');
      res.push(code < 0x10000
        ? fromCharCode(code)
        : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00)
      );
    } return res.join('');
  }
});

},{"./_export":40,"./_to-absolute-index":118}],246:[function(require,module,exports){
// 21.1.3.7 String.prototype.includes(searchString, position = 0)
'use strict';
var $export = require('./_export');
var context = require('./_string-context');
var INCLUDES = 'includes';

$export($export.P + $export.F * require('./_fails-is-regexp')(INCLUDES), 'String', {
  includes: function includes(searchString /* , position = 0 */) {
    return !!~context(this, searchString, INCLUDES)
      .indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);
  }
});

},{"./_export":40,"./_fails-is-regexp":41,"./_string-context":111}],247:[function(require,module,exports){
'use strict';
// B.2.3.9 String.prototype.italics()
require('./_string-html')('italics', function (createHTML) {
  return function italics() {
    return createHTML(this, 'i', '', '');
  };
});

},{"./_string-html":112}],248:[function(require,module,exports){
'use strict';
var $at = require('./_string-at')(true);

// 21.1.3.27 String.prototype[@@iterator]()
require('./_iter-define')(String, 'String', function (iterated) {
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var index = this._i;
  var point;
  if (index >= O.length) return { value: undefined, done: true };
  point = $at(O, index);
  this._i += point.length;
  return { value: point, done: false };
});

},{"./_iter-define":62,"./_string-at":110}],249:[function(require,module,exports){
'use strict';
// B.2.3.10 String.prototype.link(url)
require('./_string-html')('link', function (createHTML) {
  return function link(url) {
    return createHTML(this, 'a', 'href', url);
  };
});

},{"./_string-html":112}],250:[function(require,module,exports){
var $export = require('./_export');
var toIObject = require('./_to-iobject');
var toLength = require('./_to-length');

$export($export.S, 'String', {
  // 21.1.2.4 String.raw(callSite, ...substitutions)
  raw: function raw(callSite) {
    var tpl = toIObject(callSite.raw);
    var len = toLength(tpl.length);
    var aLen = arguments.length;
    var res = [];
    var i = 0;
    while (len > i) {
      res.push(String(tpl[i++]));
      if (i < aLen) res.push(String(arguments[i]));
    } return res.join('');
  }
});

},{"./_export":40,"./_to-iobject":121,"./_to-length":122}],251:[function(require,module,exports){
var $export = require('./_export');

$export($export.P, 'String', {
  // 21.1.3.13 String.prototype.repeat(count)
  repeat: require('./_string-repeat')
});

},{"./_export":40,"./_string-repeat":114}],252:[function(require,module,exports){
'use strict';
// B.2.3.11 String.prototype.small()
require('./_string-html')('small', function (createHTML) {
  return function small() {
    return createHTML(this, 'small', '', '');
  };
});

},{"./_string-html":112}],253:[function(require,module,exports){
// 21.1.3.18 String.prototype.startsWith(searchString [, position ])
'use strict';
var $export = require('./_export');
var toLength = require('./_to-length');
var context = require('./_string-context');
var STARTS_WITH = 'startsWith';
var $startsWith = ''[STARTS_WITH];

$export($export.P + $export.F * require('./_fails-is-regexp')(STARTS_WITH), 'String', {
  startsWith: function startsWith(searchString /* , position = 0 */) {
    var that = context(this, searchString, STARTS_WITH);
    var index = toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length));
    var search = String(searchString);
    return $startsWith
      ? $startsWith.call(that, search, index)
      : that.slice(index, index + search.length) === search;
  }
});

},{"./_export":40,"./_fails-is-regexp":41,"./_string-context":111,"./_to-length":122}],254:[function(require,module,exports){
'use strict';
// B.2.3.12 String.prototype.strike()
require('./_string-html')('strike', function (createHTML) {
  return function strike() {
    return createHTML(this, 'strike', '', '');
  };
});

},{"./_string-html":112}],255:[function(require,module,exports){
'use strict';
// B.2.3.13 String.prototype.sub()
require('./_string-html')('sub', function (createHTML) {
  return function sub() {
    return createHTML(this, 'sub', '', '');
  };
});

},{"./_string-html":112}],256:[function(require,module,exports){
'use strict';
// B.2.3.14 String.prototype.sup()
require('./_string-html')('sup', function (createHTML) {
  return function sup() {
    return createHTML(this, 'sup', '', '');
  };
});

},{"./_string-html":112}],257:[function(require,module,exports){
'use strict';
// 21.1.3.25 String.prototype.trim()
require('./_string-trim')('trim', function ($trim) {
  return function trim() {
    return $trim(this, 3);
  };
});

},{"./_string-trim":115}],258:[function(require,module,exports){
'use strict';
// ECMAScript 6 symbols shim
var global = require('./_global');
var has = require('./_has');
var DESCRIPTORS = require('./_descriptors');
var $export = require('./_export');
var redefine = require('./_redefine');
var META = require('./_meta').KEY;
var $fails = require('./_fails');
var shared = require('./_shared');
var setToStringTag = require('./_set-to-string-tag');
var uid = require('./_uid');
var wks = require('./_wks');
var wksExt = require('./_wks-ext');
var wksDefine = require('./_wks-define');
var enumKeys = require('./_enum-keys');
var isArray = require('./_is-array');
var anObject = require('./_an-object');
var toIObject = require('./_to-iobject');
var toPrimitive = require('./_to-primitive');
var createDesc = require('./_property-desc');
var _create = require('./_object-create');
var gOPNExt = require('./_object-gopn-ext');
var $GOPD = require('./_object-gopd');
var $DP = require('./_object-dp');
var $keys = require('./_object-keys');
var gOPD = $GOPD.f;
var dP = $DP.f;
var gOPN = gOPNExt.f;
var $Symbol = global.Symbol;
var $JSON = global.JSON;
var _stringify = $JSON && $JSON.stringify;
var PROTOTYPE = 'prototype';
var HIDDEN = wks('_hidden');
var TO_PRIMITIVE = wks('toPrimitive');
var isEnum = {}.propertyIsEnumerable;
var SymbolRegistry = shared('symbol-registry');
var AllSymbols = shared('symbols');
var OPSymbols = shared('op-symbols');
var ObjectProto = Object[PROTOTYPE];
var USE_NATIVE = typeof $Symbol == 'function';
var QObject = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = DESCRIPTORS && $fails(function () {
  return _create(dP({}, 'a', {
    get: function () { return dP(this, 'a', { value: 7 }).a; }
  })).a != 7;
}) ? function (it, key, D) {
  var protoDesc = gOPD(ObjectProto, key);
  if (protoDesc) delete ObjectProto[key];
  dP(it, key, D);
  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function (tag) {
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D) {
  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);
  if (has(AllSymbols, key)) {
    if (!D.enumerable) {
      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
      D = _create(D, { enumerable: createDesc(0, false) });
    } return setSymbolDesc(it, key, D);
  } return dP(it, key, D);
};
var $defineProperties = function defineProperties(it, P) {
  anObject(it);
  var keys = enumKeys(P = toIObject(P));
  var i = 0;
  var l = keys.length;
  var key;
  while (l > i) $defineProperty(it, key = keys[i++], P[key]);
  return it;
};
var $create = function create(it, P) {
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key) {
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
  it = toIObject(it);
  key = toPrimitive(key, true);
  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
  var D = gOPD(it, key);
  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it) {
  var names = gOPN(toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
  } return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
  var IS_OP = it === ObjectProto;
  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
  } return result;
};

// 19.4.1.1 Symbol([description])
if (!USE_NATIVE) {
  $Symbol = function Symbol() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
    var $set = function (value) {
      if (this === ObjectProto) $set.call(OPSymbols, value);
      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };
    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
    return wrap(tag);
  };
  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
    return this._k;
  });

  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f = $defineProperty;
  require('./_object-gopn').f = gOPNExt.f = $getOwnPropertyNames;
  require('./_object-pie').f = $propertyIsEnumerable;
  require('./_object-gops').f = $getOwnPropertySymbols;

  if (DESCRIPTORS && !require('./_library')) {
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function (name) {
    return wrap(wks(name));
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });

for (var es6Symbols = (
  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
).split(','), j = 0; es6Symbols.length > j;)wks(es6Symbols[j++]);

for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);

$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function (key) {
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');
    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
  },
  useSetter: function () { setter = true; },
  useSimple: function () { setter = false; }
});

$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it) {
    if (it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
    var args = [it];
    var i = 1;
    var replacer, $replacer;
    while (arguments.length > i) args.push(arguments[i++]);
    replacer = args[1];
    if (typeof replacer == 'function') $replacer = replacer;
    if ($replacer || !isArray(replacer)) replacer = function (key, value) {
      if ($replacer) value = $replacer.call(this, key, value);
      if (!isSymbol(value)) return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
});

// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
$Symbol[PROTOTYPE][TO_PRIMITIVE] || require('./_hide')($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setToStringTag(global.JSON, 'JSON', true);

},{"./_an-object":14,"./_descriptors":36,"./_enum-keys":39,"./_export":40,"./_fails":42,"./_global":47,"./_has":48,"./_hide":49,"./_is-array":56,"./_library":66,"./_meta":72,"./_object-create":77,"./_object-dp":78,"./_object-gopd":81,"./_object-gopn":83,"./_object-gopn-ext":82,"./_object-gops":84,"./_object-keys":87,"./_object-pie":88,"./_property-desc":96,"./_redefine":98,"./_set-to-string-tag":105,"./_shared":107,"./_to-iobject":121,"./_to-primitive":124,"./_uid":128,"./_wks":132,"./_wks-define":130,"./_wks-ext":131}],259:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var $typed = require('./_typed');
var buffer = require('./_typed-buffer');
var anObject = require('./_an-object');
var toAbsoluteIndex = require('./_to-absolute-index');
var toLength = require('./_to-length');
var isObject = require('./_is-object');
var ArrayBuffer = require('./_global').ArrayBuffer;
var speciesConstructor = require('./_species-constructor');
var $ArrayBuffer = buffer.ArrayBuffer;
var $DataView = buffer.DataView;
var $isView = $typed.ABV && ArrayBuffer.isView;
var $slice = $ArrayBuffer.prototype.slice;
var VIEW = $typed.VIEW;
var ARRAY_BUFFER = 'ArrayBuffer';

$export($export.G + $export.W + $export.F * (ArrayBuffer !== $ArrayBuffer), { ArrayBuffer: $ArrayBuffer });

$export($export.S + $export.F * !$typed.CONSTR, ARRAY_BUFFER, {
  // 24.1.3.1 ArrayBuffer.isView(arg)
  isView: function isView(it) {
    return $isView && $isView(it) || isObject(it) && VIEW in it;
  }
});

$export($export.P + $export.U + $export.F * require('./_fails')(function () {
  return !new $ArrayBuffer(2).slice(1, undefined).byteLength;
}), ARRAY_BUFFER, {
  // 24.1.4.3 ArrayBuffer.prototype.slice(start, end)
  slice: function slice(start, end) {
    if ($slice !== undefined && end === undefined) return $slice.call(anObject(this), start); // FF fix
    var len = anObject(this).byteLength;
    var first = toAbsoluteIndex(start, len);
    var final = toAbsoluteIndex(end === undefined ? len : end, len);
    var result = new (speciesConstructor(this, $ArrayBuffer))(toLength(final - first));
    var viewS = new $DataView(this);
    var viewT = new $DataView(result);
    var index = 0;
    while (first < final) {
      viewT.setUint8(index++, viewS.getUint8(first++));
    } return result;
  }
});

require('./_set-species')(ARRAY_BUFFER);

},{"./_an-object":14,"./_export":40,"./_fails":42,"./_global":47,"./_is-object":58,"./_set-species":104,"./_species-constructor":108,"./_to-absolute-index":118,"./_to-length":122,"./_typed":127,"./_typed-buffer":126}],260:[function(require,module,exports){
var $export = require('./_export');
$export($export.G + $export.W + $export.F * !require('./_typed').ABV, {
  DataView: require('./_typed-buffer').DataView
});

},{"./_export":40,"./_typed":127,"./_typed-buffer":126}],261:[function(require,module,exports){
require('./_typed-array')('Float32', 4, function (init) {
  return function Float32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":125}],262:[function(require,module,exports){
require('./_typed-array')('Float64', 8, function (init) {
  return function Float64Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":125}],263:[function(require,module,exports){
require('./_typed-array')('Int16', 2, function (init) {
  return function Int16Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":125}],264:[function(require,module,exports){
require('./_typed-array')('Int32', 4, function (init) {
  return function Int32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":125}],265:[function(require,module,exports){
require('./_typed-array')('Int8', 1, function (init) {
  return function Int8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":125}],266:[function(require,module,exports){
require('./_typed-array')('Uint16', 2, function (init) {
  return function Uint16Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":125}],267:[function(require,module,exports){
require('./_typed-array')('Uint32', 4, function (init) {
  return function Uint32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":125}],268:[function(require,module,exports){
require('./_typed-array')('Uint8', 1, function (init) {
  return function Uint8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":125}],269:[function(require,module,exports){
require('./_typed-array')('Uint8', 1, function (init) {
  return function Uint8ClampedArray(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
}, true);

},{"./_typed-array":125}],270:[function(require,module,exports){
'use strict';
var each = require('./_array-methods')(0);
var redefine = require('./_redefine');
var meta = require('./_meta');
var assign = require('./_object-assign');
var weak = require('./_collection-weak');
var isObject = require('./_is-object');
var fails = require('./_fails');
var validate = require('./_validate-collection');
var WEAK_MAP = 'WeakMap';
var getWeak = meta.getWeak;
var isExtensible = Object.isExtensible;
var uncaughtFrozenStore = weak.ufstore;
var tmp = {};
var InternalMap;

var wrapper = function (get) {
  return function WeakMap() {
    return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
};

var methods = {
  // 23.3.3.3 WeakMap.prototype.get(key)
  get: function get(key) {
    if (isObject(key)) {
      var data = getWeak(key);
      if (data === true) return uncaughtFrozenStore(validate(this, WEAK_MAP)).get(key);
      return data ? data[this._i] : undefined;
    }
  },
  // 23.3.3.5 WeakMap.prototype.set(key, value)
  set: function set(key, value) {
    return weak.def(validate(this, WEAK_MAP), key, value);
  }
};

// 23.3 WeakMap Objects
var $WeakMap = module.exports = require('./_collection')(WEAK_MAP, wrapper, methods, weak, true, true);

// IE11 WeakMap frozen keys fix
if (fails(function () { return new $WeakMap().set((Object.freeze || Object)(tmp), 7).get(tmp) != 7; })) {
  InternalMap = weak.getConstructor(wrapper, WEAK_MAP);
  assign(InternalMap.prototype, methods);
  meta.NEED = true;
  each(['delete', 'has', 'get', 'set'], function (key) {
    var proto = $WeakMap.prototype;
    var method = proto[key];
    redefine(proto, key, function (a, b) {
      // store frozen objects on internal weakmap shim
      if (isObject(a) && !isExtensible(a)) {
        if (!this._f) this._f = new InternalMap();
        var result = this._f[key](a, b);
        return key == 'set' ? this : result;
      // store all the rest on native weakmap
      } return method.call(this, a, b);
    });
  });
}

},{"./_array-methods":19,"./_collection":29,"./_collection-weak":28,"./_fails":42,"./_is-object":58,"./_meta":72,"./_object-assign":76,"./_redefine":98,"./_validate-collection":129}],271:[function(require,module,exports){
'use strict';
var weak = require('./_collection-weak');
var validate = require('./_validate-collection');
var WEAK_SET = 'WeakSet';

// 23.4 WeakSet Objects
require('./_collection')(WEAK_SET, function (get) {
  return function WeakSet() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.4.3.1 WeakSet.prototype.add(value)
  add: function add(value) {
    return weak.def(validate(this, WEAK_SET), value, true);
  }
}, weak, false, true);

},{"./_collection":29,"./_collection-weak":28,"./_validate-collection":129}],272:[function(require,module,exports){
'use strict';
// https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatMap
var $export = require('./_export');
var flattenIntoArray = require('./_flatten-into-array');
var toObject = require('./_to-object');
var toLength = require('./_to-length');
var aFunction = require('./_a-function');
var arraySpeciesCreate = require('./_array-species-create');

$export($export.P, 'Array', {
  flatMap: function flatMap(callbackfn /* , thisArg */) {
    var O = toObject(this);
    var sourceLen, A;
    aFunction(callbackfn);
    sourceLen = toLength(O.length);
    A = arraySpeciesCreate(O, 0);
    flattenIntoArray(A, O, O, sourceLen, 0, 1, callbackfn, arguments[1]);
    return A;
  }
});

require('./_add-to-unscopables')('flatMap');

},{"./_a-function":10,"./_add-to-unscopables":12,"./_array-species-create":22,"./_export":40,"./_flatten-into-array":45,"./_to-length":122,"./_to-object":123}],273:[function(require,module,exports){
'use strict';
// https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatten
var $export = require('./_export');
var flattenIntoArray = require('./_flatten-into-array');
var toObject = require('./_to-object');
var toLength = require('./_to-length');
var toInteger = require('./_to-integer');
var arraySpeciesCreate = require('./_array-species-create');

$export($export.P, 'Array', {
  flatten: function flatten(/* depthArg = 1 */) {
    var depthArg = arguments[0];
    var O = toObject(this);
    var sourceLen = toLength(O.length);
    var A = arraySpeciesCreate(O, 0);
    flattenIntoArray(A, O, O, sourceLen, 0, depthArg === undefined ? 1 : toInteger(depthArg));
    return A;
  }
});

require('./_add-to-unscopables')('flatten');

},{"./_add-to-unscopables":12,"./_array-species-create":22,"./_export":40,"./_flatten-into-array":45,"./_to-integer":120,"./_to-length":122,"./_to-object":123}],274:[function(require,module,exports){
'use strict';
// https://github.com/tc39/Array.prototype.includes
var $export = require('./_export');
var $includes = require('./_array-includes')(true);

$export($export.P, 'Array', {
  includes: function includes(el /* , fromIndex = 0 */) {
    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
  }
});

require('./_add-to-unscopables')('includes');

},{"./_add-to-unscopables":12,"./_array-includes":18,"./_export":40}],275:[function(require,module,exports){
// https://github.com/rwaldron/tc39-notes/blob/master/es6/2014-09/sept-25.md#510-globalasap-for-enqueuing-a-microtask
var $export = require('./_export');
var microtask = require('./_microtask')();
var process = require('./_global').process;
var isNode = require('./_cof')(process) == 'process';

$export($export.G, {
  asap: function asap(fn) {
    var domain = isNode && process.domain;
    microtask(domain ? domain.bind(fn) : fn);
  }
});

},{"./_cof":25,"./_export":40,"./_global":47,"./_microtask":74}],276:[function(require,module,exports){
// https://github.com/ljharb/proposal-is-error
var $export = require('./_export');
var cof = require('./_cof');

$export($export.S, 'Error', {
  isError: function isError(it) {
    return cof(it) === 'Error';
  }
});

},{"./_cof":25,"./_export":40}],277:[function(require,module,exports){
// https://github.com/tc39/proposal-global
var $export = require('./_export');

$export($export.G, { global: require('./_global') });

},{"./_export":40,"./_global":47}],278:[function(require,module,exports){
// https://tc39.github.io/proposal-setmap-offrom/#sec-map.from
require('./_set-collection-from')('Map');

},{"./_set-collection-from":101}],279:[function(require,module,exports){
// https://tc39.github.io/proposal-setmap-offrom/#sec-map.of
require('./_set-collection-of')('Map');

},{"./_set-collection-of":102}],280:[function(require,module,exports){
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export = require('./_export');

$export($export.P + $export.R, 'Map', { toJSON: require('./_collection-to-json')('Map') });

},{"./_collection-to-json":27,"./_export":40}],281:[function(require,module,exports){
// https://rwaldron.github.io/proposal-math-extensions/
var $export = require('./_export');

$export($export.S, 'Math', {
  clamp: function clamp(x, lower, upper) {
    return Math.min(upper, Math.max(lower, x));
  }
});

},{"./_export":40}],282:[function(require,module,exports){
// https://rwaldron.github.io/proposal-math-extensions/
var $export = require('./_export');

$export($export.S, 'Math', { DEG_PER_RAD: Math.PI / 180 });

},{"./_export":40}],283:[function(require,module,exports){
// https://rwaldron.github.io/proposal-math-extensions/
var $export = require('./_export');
var RAD_PER_DEG = 180 / Math.PI;

$export($export.S, 'Math', {
  degrees: function degrees(radians) {
    return radians * RAD_PER_DEG;
  }
});

},{"./_export":40}],284:[function(require,module,exports){
// https://rwaldron.github.io/proposal-math-extensions/
var $export = require('./_export');
var scale = require('./_math-scale');
var fround = require('./_math-fround');

$export($export.S, 'Math', {
  fscale: function fscale(x, inLow, inHigh, outLow, outHigh) {
    return fround(scale(x, inLow, inHigh, outLow, outHigh));
  }
});

},{"./_export":40,"./_math-fround":68,"./_math-scale":70}],285:[function(require,module,exports){
// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = require('./_export');

$export($export.S, 'Math', {
  iaddh: function iaddh(x0, x1, y0, y1) {
    var $x0 = x0 >>> 0;
    var $x1 = x1 >>> 0;
    var $y0 = y0 >>> 0;
    return $x1 + (y1 >>> 0) + (($x0 & $y0 | ($x0 | $y0) & ~($x0 + $y0 >>> 0)) >>> 31) | 0;
  }
});

},{"./_export":40}],286:[function(require,module,exports){
// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = require('./_export');

$export($export.S, 'Math', {
  imulh: function imulh(u, v) {
    var UINT16 = 0xffff;
    var $u = +u;
    var $v = +v;
    var u0 = $u & UINT16;
    var v0 = $v & UINT16;
    var u1 = $u >> 16;
    var v1 = $v >> 16;
    var t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
    return u1 * v1 + (t >> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >> 16);
  }
});

},{"./_export":40}],287:[function(require,module,exports){
// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = require('./_export');

$export($export.S, 'Math', {
  isubh: function isubh(x0, x1, y0, y1) {
    var $x0 = x0 >>> 0;
    var $x1 = x1 >>> 0;
    var $y0 = y0 >>> 0;
    return $x1 - (y1 >>> 0) - ((~$x0 & $y0 | ~($x0 ^ $y0) & $x0 - $y0 >>> 0) >>> 31) | 0;
  }
});

},{"./_export":40}],288:[function(require,module,exports){
// https://rwaldron.github.io/proposal-math-extensions/
var $export = require('./_export');

$export($export.S, 'Math', { RAD_PER_DEG: 180 / Math.PI });

},{"./_export":40}],289:[function(require,module,exports){
// https://rwaldron.github.io/proposal-math-extensions/
var $export = require('./_export');
var DEG_PER_RAD = Math.PI / 180;

$export($export.S, 'Math', {
  radians: function radians(degrees) {
    return degrees * DEG_PER_RAD;
  }
});

},{"./_export":40}],290:[function(require,module,exports){
// https://rwaldron.github.io/proposal-math-extensions/
var $export = require('./_export');

$export($export.S, 'Math', { scale: require('./_math-scale') });

},{"./_export":40,"./_math-scale":70}],291:[function(require,module,exports){
// http://jfbastien.github.io/papers/Math.signbit.html
var $export = require('./_export');

$export($export.S, 'Math', { signbit: function signbit(x) {
  // eslint-disable-next-line no-self-compare
  return (x = +x) != x ? x : x == 0 ? 1 / x == Infinity : x > 0;
} });

},{"./_export":40}],292:[function(require,module,exports){
// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = require('./_export');

$export($export.S, 'Math', {
  umulh: function umulh(u, v) {
    var UINT16 = 0xffff;
    var $u = +u;
    var $v = +v;
    var u0 = $u & UINT16;
    var v0 = $v & UINT16;
    var u1 = $u >>> 16;
    var v1 = $v >>> 16;
    var t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
    return u1 * v1 + (t >>> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >>> 16);
  }
});

},{"./_export":40}],293:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var toObject = require('./_to-object');
var aFunction = require('./_a-function');
var $defineProperty = require('./_object-dp');

// B.2.2.2 Object.prototype.__defineGetter__(P, getter)
require('./_descriptors') && $export($export.P + require('./_object-forced-pam'), 'Object', {
  __defineGetter__: function __defineGetter__(P, getter) {
    $defineProperty.f(toObject(this), P, { get: aFunction(getter), enumerable: true, configurable: true });
  }
});

},{"./_a-function":10,"./_descriptors":36,"./_export":40,"./_object-dp":78,"./_object-forced-pam":80,"./_to-object":123}],294:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var toObject = require('./_to-object');
var aFunction = require('./_a-function');
var $defineProperty = require('./_object-dp');

// B.2.2.3 Object.prototype.__defineSetter__(P, setter)
require('./_descriptors') && $export($export.P + require('./_object-forced-pam'), 'Object', {
  __defineSetter__: function __defineSetter__(P, setter) {
    $defineProperty.f(toObject(this), P, { set: aFunction(setter), enumerable: true, configurable: true });
  }
});

},{"./_a-function":10,"./_descriptors":36,"./_export":40,"./_object-dp":78,"./_object-forced-pam":80,"./_to-object":123}],295:[function(require,module,exports){
// https://github.com/tc39/proposal-object-values-entries
var $export = require('./_export');
var $entries = require('./_object-to-array')(true);

$export($export.S, 'Object', {
  entries: function entries(it) {
    return $entries(it);
  }
});

},{"./_export":40,"./_object-to-array":90}],296:[function(require,module,exports){
// https://github.com/tc39/proposal-object-getownpropertydescriptors
var $export = require('./_export');
var ownKeys = require('./_own-keys');
var toIObject = require('./_to-iobject');
var gOPD = require('./_object-gopd');
var createProperty = require('./_create-property');

$export($export.S, 'Object', {
  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
    var O = toIObject(object);
    var getDesc = gOPD.f;
    var keys = ownKeys(O);
    var result = {};
    var i = 0;
    var key, desc;
    while (keys.length > i) {
      desc = getDesc(O, key = keys[i++]);
      if (desc !== undefined) createProperty(result, key, desc);
    }
    return result;
  }
});

},{"./_create-property":31,"./_export":40,"./_object-gopd":81,"./_own-keys":91,"./_to-iobject":121}],297:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var toObject = require('./_to-object');
var toPrimitive = require('./_to-primitive');
var getPrototypeOf = require('./_object-gpo');
var getOwnPropertyDescriptor = require('./_object-gopd').f;

// B.2.2.4 Object.prototype.__lookupGetter__(P)
require('./_descriptors') && $export($export.P + require('./_object-forced-pam'), 'Object', {
  __lookupGetter__: function __lookupGetter__(P) {
    var O = toObject(this);
    var K = toPrimitive(P, true);
    var D;
    do {
      if (D = getOwnPropertyDescriptor(O, K)) return D.get;
    } while (O = getPrototypeOf(O));
  }
});

},{"./_descriptors":36,"./_export":40,"./_object-forced-pam":80,"./_object-gopd":81,"./_object-gpo":85,"./_to-object":123,"./_to-primitive":124}],298:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var toObject = require('./_to-object');
var toPrimitive = require('./_to-primitive');
var getPrototypeOf = require('./_object-gpo');
var getOwnPropertyDescriptor = require('./_object-gopd').f;

// B.2.2.5 Object.prototype.__lookupSetter__(P)
require('./_descriptors') && $export($export.P + require('./_object-forced-pam'), 'Object', {
  __lookupSetter__: function __lookupSetter__(P) {
    var O = toObject(this);
    var K = toPrimitive(P, true);
    var D;
    do {
      if (D = getOwnPropertyDescriptor(O, K)) return D.set;
    } while (O = getPrototypeOf(O));
  }
});

},{"./_descriptors":36,"./_export":40,"./_object-forced-pam":80,"./_object-gopd":81,"./_object-gpo":85,"./_to-object":123,"./_to-primitive":124}],299:[function(require,module,exports){
// https://github.com/tc39/proposal-object-values-entries
var $export = require('./_export');
var $values = require('./_object-to-array')(false);

$export($export.S, 'Object', {
  values: function values(it) {
    return $values(it);
  }
});

},{"./_export":40,"./_object-to-array":90}],300:[function(require,module,exports){
'use strict';
// https://github.com/zenparsing/es-observable
var $export = require('./_export');
var global = require('./_global');
var core = require('./_core');
var microtask = require('./_microtask')();
var OBSERVABLE = require('./_wks')('observable');
var aFunction = require('./_a-function');
var anObject = require('./_an-object');
var anInstance = require('./_an-instance');
var redefineAll = require('./_redefine-all');
var hide = require('./_hide');
var forOf = require('./_for-of');
var RETURN = forOf.RETURN;

var getMethod = function (fn) {
  return fn == null ? undefined : aFunction(fn);
};

var cleanupSubscription = function (subscription) {
  var cleanup = subscription._c;
  if (cleanup) {
    subscription._c = undefined;
    cleanup();
  }
};

var subscriptionClosed = function (subscription) {
  return subscription._o === undefined;
};

var closeSubscription = function (subscription) {
  if (!subscriptionClosed(subscription)) {
    subscription._o = undefined;
    cleanupSubscription(subscription);
  }
};

var Subscription = function (observer, subscriber) {
  anObject(observer);
  this._c = undefined;
  this._o = observer;
  observer = new SubscriptionObserver(this);
  try {
    var cleanup = subscriber(observer);
    var subscription = cleanup;
    if (cleanup != null) {
      if (typeof cleanup.unsubscribe === 'function') cleanup = function () { subscription.unsubscribe(); };
      else aFunction(cleanup);
      this._c = cleanup;
    }
  } catch (e) {
    observer.error(e);
    return;
  } if (subscriptionClosed(this)) cleanupSubscription(this);
};

Subscription.prototype = redefineAll({}, {
  unsubscribe: function unsubscribe() { closeSubscription(this); }
});

var SubscriptionObserver = function (subscription) {
  this._s = subscription;
};

SubscriptionObserver.prototype = redefineAll({}, {
  next: function next(value) {
    var subscription = this._s;
    if (!subscriptionClosed(subscription)) {
      var observer = subscription._o;
      try {
        var m = getMethod(observer.next);
        if (m) return m.call(observer, value);
      } catch (e) {
        try {
          closeSubscription(subscription);
        } finally {
          throw e;
        }
      }
    }
  },
  error: function error(value) {
    var subscription = this._s;
    if (subscriptionClosed(subscription)) throw value;
    var observer = subscription._o;
    subscription._o = undefined;
    try {
      var m = getMethod(observer.error);
      if (!m) throw value;
      value = m.call(observer, value);
    } catch (e) {
      try {
        cleanupSubscription(subscription);
      } finally {
        throw e;
      }
    } cleanupSubscription(subscription);
    return value;
  },
  complete: function complete(value) {
    var subscription = this._s;
    if (!subscriptionClosed(subscription)) {
      var observer = subscription._o;
      subscription._o = undefined;
      try {
        var m = getMethod(observer.complete);
        value = m ? m.call(observer, value) : undefined;
      } catch (e) {
        try {
          cleanupSubscription(subscription);
        } finally {
          throw e;
        }
      } cleanupSubscription(subscription);
      return value;
    }
  }
});

var $Observable = function Observable(subscriber) {
  anInstance(this, $Observable, 'Observable', '_f')._f = aFunction(subscriber);
};

redefineAll($Observable.prototype, {
  subscribe: function subscribe(observer) {
    return new Subscription(observer, this._f);
  },
  forEach: function forEach(fn) {
    var that = this;
    return new (core.Promise || global.Promise)(function (resolve, reject) {
      aFunction(fn);
      var subscription = that.subscribe({
        next: function (value) {
          try {
            return fn(value);
          } catch (e) {
            reject(e);
            subscription.unsubscribe();
          }
        },
        error: reject,
        complete: resolve
      });
    });
  }
});

redefineAll($Observable, {
  from: function from(x) {
    var C = typeof this === 'function' ? this : $Observable;
    var method = getMethod(anObject(x)[OBSERVABLE]);
    if (method) {
      var observable = anObject(method.call(x));
      return observable.constructor === C ? observable : new C(function (observer) {
        return observable.subscribe(observer);
      });
    }
    return new C(function (observer) {
      var done = false;
      microtask(function () {
        if (!done) {
          try {
            if (forOf(x, false, function (it) {
              observer.next(it);
              if (done) return RETURN;
            }) === RETURN) return;
          } catch (e) {
            if (done) throw e;
            observer.error(e);
            return;
          } observer.complete();
        }
      });
      return function () { done = true; };
    });
  },
  of: function of() {
    for (var i = 0, l = arguments.length, items = Array(l); i < l;) items[i] = arguments[i++];
    return new (typeof this === 'function' ? this : $Observable)(function (observer) {
      var done = false;
      microtask(function () {
        if (!done) {
          for (var j = 0; j < items.length; ++j) {
            observer.next(items[j]);
            if (done) return;
          } observer.complete();
        }
      });
      return function () { done = true; };
    });
  }
});

hide($Observable.prototype, OBSERVABLE, function () { return this; });

$export($export.G, { Observable: $Observable });

require('./_set-species')('Observable');

},{"./_a-function":10,"./_an-instance":13,"./_an-object":14,"./_core":30,"./_export":40,"./_for-of":46,"./_global":47,"./_hide":49,"./_microtask":74,"./_redefine-all":97,"./_set-species":104,"./_wks":132}],301:[function(require,module,exports){
// https://github.com/tc39/proposal-promise-finally
'use strict';
var $export = require('./_export');
var core = require('./_core');
var global = require('./_global');
var speciesConstructor = require('./_species-constructor');
var promiseResolve = require('./_promise-resolve');

$export($export.P + $export.R, 'Promise', { 'finally': function (onFinally) {
  var C = speciesConstructor(this, core.Promise || global.Promise);
  var isFunction = typeof onFinally == 'function';
  return this.then(
    isFunction ? function (x) {
      return promiseResolve(C, onFinally()).then(function () { return x; });
    } : onFinally,
    isFunction ? function (e) {
      return promiseResolve(C, onFinally()).then(function () { throw e; });
    } : onFinally
  );
} });

},{"./_core":30,"./_export":40,"./_global":47,"./_promise-resolve":95,"./_species-constructor":108}],302:[function(require,module,exports){
'use strict';
// https://github.com/tc39/proposal-promise-try
var $export = require('./_export');
var newPromiseCapability = require('./_new-promise-capability');
var perform = require('./_perform');

$export($export.S, 'Promise', { 'try': function (callbackfn) {
  var promiseCapability = newPromiseCapability.f(this);
  var result = perform(callbackfn);
  (result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v);
  return promiseCapability.promise;
} });

},{"./_export":40,"./_new-promise-capability":75,"./_perform":94}],303:[function(require,module,exports){
var metadata = require('./_metadata');
var anObject = require('./_an-object');
var toMetaKey = metadata.key;
var ordinaryDefineOwnMetadata = metadata.set;

metadata.exp({ defineMetadata: function defineMetadata(metadataKey, metadataValue, target, targetKey) {
  ordinaryDefineOwnMetadata(metadataKey, metadataValue, anObject(target), toMetaKey(targetKey));
} });

},{"./_an-object":14,"./_metadata":73}],304:[function(require,module,exports){
var metadata = require('./_metadata');
var anObject = require('./_an-object');
var toMetaKey = metadata.key;
var getOrCreateMetadataMap = metadata.map;
var store = metadata.store;

metadata.exp({ deleteMetadata: function deleteMetadata(metadataKey, target /* , targetKey */) {
  var targetKey = arguments.length < 3 ? undefined : toMetaKey(arguments[2]);
  var metadataMap = getOrCreateMetadataMap(anObject(target), targetKey, false);
  if (metadataMap === undefined || !metadataMap['delete'](metadataKey)) return false;
  if (metadataMap.size) return true;
  var targetMetadata = store.get(target);
  targetMetadata['delete'](targetKey);
  return !!targetMetadata.size || store['delete'](target);
} });

},{"./_an-object":14,"./_metadata":73}],305:[function(require,module,exports){
var Set = require('./es6.set');
var from = require('./_array-from-iterable');
var metadata = require('./_metadata');
var anObject = require('./_an-object');
var getPrototypeOf = require('./_object-gpo');
var ordinaryOwnMetadataKeys = metadata.keys;
var toMetaKey = metadata.key;

var ordinaryMetadataKeys = function (O, P) {
  var oKeys = ordinaryOwnMetadataKeys(O, P);
  var parent = getPrototypeOf(O);
  if (parent === null) return oKeys;
  var pKeys = ordinaryMetadataKeys(parent, P);
  return pKeys.length ? oKeys.length ? from(new Set(oKeys.concat(pKeys))) : pKeys : oKeys;
};

metadata.exp({ getMetadataKeys: function getMetadataKeys(target /* , targetKey */) {
  return ordinaryMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));
} });

},{"./_an-object":14,"./_array-from-iterable":17,"./_metadata":73,"./_object-gpo":85,"./es6.set":235}],306:[function(require,module,exports){
var metadata = require('./_metadata');
var anObject = require('./_an-object');
var getPrototypeOf = require('./_object-gpo');
var ordinaryHasOwnMetadata = metadata.has;
var ordinaryGetOwnMetadata = metadata.get;
var toMetaKey = metadata.key;

var ordinaryGetMetadata = function (MetadataKey, O, P) {
  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
  if (hasOwn) return ordinaryGetOwnMetadata(MetadataKey, O, P);
  var parent = getPrototypeOf(O);
  return parent !== null ? ordinaryGetMetadata(MetadataKey, parent, P) : undefined;
};

metadata.exp({ getMetadata: function getMetadata(metadataKey, target /* , targetKey */) {
  return ordinaryGetMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
} });

},{"./_an-object":14,"./_metadata":73,"./_object-gpo":85}],307:[function(require,module,exports){
var metadata = require('./_metadata');
var anObject = require('./_an-object');
var ordinaryOwnMetadataKeys = metadata.keys;
var toMetaKey = metadata.key;

metadata.exp({ getOwnMetadataKeys: function getOwnMetadataKeys(target /* , targetKey */) {
  return ordinaryOwnMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));
} });

},{"./_an-object":14,"./_metadata":73}],308:[function(require,module,exports){
var metadata = require('./_metadata');
var anObject = require('./_an-object');
var ordinaryGetOwnMetadata = metadata.get;
var toMetaKey = metadata.key;

metadata.exp({ getOwnMetadata: function getOwnMetadata(metadataKey, target /* , targetKey */) {
  return ordinaryGetOwnMetadata(metadataKey, anObject(target)
    , arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
} });

},{"./_an-object":14,"./_metadata":73}],309:[function(require,module,exports){
var metadata = require('./_metadata');
var anObject = require('./_an-object');
var getPrototypeOf = require('./_object-gpo');
var ordinaryHasOwnMetadata = metadata.has;
var toMetaKey = metadata.key;

var ordinaryHasMetadata = function (MetadataKey, O, P) {
  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
  if (hasOwn) return true;
  var parent = getPrototypeOf(O);
  return parent !== null ? ordinaryHasMetadata(MetadataKey, parent, P) : false;
};

metadata.exp({ hasMetadata: function hasMetadata(metadataKey, target /* , targetKey */) {
  return ordinaryHasMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
} });

},{"./_an-object":14,"./_metadata":73,"./_object-gpo":85}],310:[function(require,module,exports){
var metadata = require('./_metadata');
var anObject = require('./_an-object');
var ordinaryHasOwnMetadata = metadata.has;
var toMetaKey = metadata.key;

metadata.exp({ hasOwnMetadata: function hasOwnMetadata(metadataKey, target /* , targetKey */) {
  return ordinaryHasOwnMetadata(metadataKey, anObject(target)
    , arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
} });

},{"./_an-object":14,"./_metadata":73}],311:[function(require,module,exports){
var $metadata = require('./_metadata');
var anObject = require('./_an-object');
var aFunction = require('./_a-function');
var toMetaKey = $metadata.key;
var ordinaryDefineOwnMetadata = $metadata.set;

$metadata.exp({ metadata: function metadata(metadataKey, metadataValue) {
  return function decorator(target, targetKey) {
    ordinaryDefineOwnMetadata(
      metadataKey, metadataValue,
      (targetKey !== undefined ? anObject : aFunction)(target),
      toMetaKey(targetKey)
    );
  };
} });

},{"./_a-function":10,"./_an-object":14,"./_metadata":73}],312:[function(require,module,exports){
// https://tc39.github.io/proposal-setmap-offrom/#sec-set.from
require('./_set-collection-from')('Set');

},{"./_set-collection-from":101}],313:[function(require,module,exports){
// https://tc39.github.io/proposal-setmap-offrom/#sec-set.of
require('./_set-collection-of')('Set');

},{"./_set-collection-of":102}],314:[function(require,module,exports){
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export = require('./_export');

$export($export.P + $export.R, 'Set', { toJSON: require('./_collection-to-json')('Set') });

},{"./_collection-to-json":27,"./_export":40}],315:[function(require,module,exports){
'use strict';
// https://github.com/mathiasbynens/String.prototype.at
var $export = require('./_export');
var $at = require('./_string-at')(true);

$export($export.P, 'String', {
  at: function at(pos) {
    return $at(this, pos);
  }
});

},{"./_export":40,"./_string-at":110}],316:[function(require,module,exports){
'use strict';
// https://tc39.github.io/String.prototype.matchAll/
var $export = require('./_export');
var defined = require('./_defined');
var toLength = require('./_to-length');
var isRegExp = require('./_is-regexp');
var getFlags = require('./_flags');
var RegExpProto = RegExp.prototype;

var $RegExpStringIterator = function (regexp, string) {
  this._r = regexp;
  this._s = string;
};

require('./_iter-create')($RegExpStringIterator, 'RegExp String', function next() {
  var match = this._r.exec(this._s);
  return { value: match, done: match === null };
});

$export($export.P, 'String', {
  matchAll: function matchAll(regexp) {
    defined(this);
    if (!isRegExp(regexp)) throw TypeError(regexp + ' is not a regexp!');
    var S = String(this);
    var flags = 'flags' in RegExpProto ? String(regexp.flags) : getFlags.call(regexp);
    var rx = new RegExp(regexp.source, ~flags.indexOf('g') ? flags : 'g' + flags);
    rx.lastIndex = toLength(regexp.lastIndex);
    return new $RegExpStringIterator(rx, S);
  }
});

},{"./_defined":35,"./_export":40,"./_flags":44,"./_is-regexp":59,"./_iter-create":61,"./_to-length":122}],317:[function(require,module,exports){
'use strict';
// https://github.com/tc39/proposal-string-pad-start-end
var $export = require('./_export');
var $pad = require('./_string-pad');

$export($export.P, 'String', {
  padEnd: function padEnd(maxLength /* , fillString = ' ' */) {
    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, false);
  }
});

},{"./_export":40,"./_string-pad":113}],318:[function(require,module,exports){
'use strict';
// https://github.com/tc39/proposal-string-pad-start-end
var $export = require('./_export');
var $pad = require('./_string-pad');

$export($export.P, 'String', {
  padStart: function padStart(maxLength /* , fillString = ' ' */) {
    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, true);
  }
});

},{"./_export":40,"./_string-pad":113}],319:[function(require,module,exports){
'use strict';
// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
require('./_string-trim')('trimLeft', function ($trim) {
  return function trimLeft() {
    return $trim(this, 1);
  };
}, 'trimStart');

},{"./_string-trim":115}],320:[function(require,module,exports){
'use strict';
// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
require('./_string-trim')('trimRight', function ($trim) {
  return function trimRight() {
    return $trim(this, 2);
  };
}, 'trimEnd');

},{"./_string-trim":115}],321:[function(require,module,exports){
require('./_wks-define')('asyncIterator');

},{"./_wks-define":130}],322:[function(require,module,exports){
require('./_wks-define')('observable');

},{"./_wks-define":130}],323:[function(require,module,exports){
// https://github.com/tc39/proposal-global
var $export = require('./_export');

$export($export.S, 'System', { global: require('./_global') });

},{"./_export":40,"./_global":47}],324:[function(require,module,exports){
// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.from
require('./_set-collection-from')('WeakMap');

},{"./_set-collection-from":101}],325:[function(require,module,exports){
// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.of
require('./_set-collection-of')('WeakMap');

},{"./_set-collection-of":102}],326:[function(require,module,exports){
// https://tc39.github.io/proposal-setmap-offrom/#sec-weakset.from
require('./_set-collection-from')('WeakSet');

},{"./_set-collection-from":101}],327:[function(require,module,exports){
// https://tc39.github.io/proposal-setmap-offrom/#sec-weakset.of
require('./_set-collection-of')('WeakSet');

},{"./_set-collection-of":102}],328:[function(require,module,exports){
var $iterators = require('./es6.array.iterator');
var getKeys = require('./_object-keys');
var redefine = require('./_redefine');
var global = require('./_global');
var hide = require('./_hide');
var Iterators = require('./_iterators');
var wks = require('./_wks');
var ITERATOR = wks('iterator');
var TO_STRING_TAG = wks('toStringTag');
var ArrayValues = Iterators.Array;

var DOMIterables = {
  CSSRuleList: true, // TODO: Not spec compliant, should be false.
  CSSStyleDeclaration: false,
  CSSValueList: false,
  ClientRectList: false,
  DOMRectList: false,
  DOMStringList: false,
  DOMTokenList: true,
  DataTransferItemList: false,
  FileList: false,
  HTMLAllCollection: false,
  HTMLCollection: false,
  HTMLFormElement: false,
  HTMLSelectElement: false,
  MediaList: true, // TODO: Not spec compliant, should be false.
  MimeTypeArray: false,
  NamedNodeMap: false,
  NodeList: true,
  PaintRequestList: false,
  Plugin: false,
  PluginArray: false,
  SVGLengthList: false,
  SVGNumberList: false,
  SVGPathSegList: false,
  SVGPointList: false,
  SVGStringList: false,
  SVGTransformList: false,
  SourceBufferList: false,
  StyleSheetList: true, // TODO: Not spec compliant, should be false.
  TextTrackCueList: false,
  TextTrackList: false,
  TouchList: false
};

for (var collections = getKeys(DOMIterables), i = 0; i < collections.length; i++) {
  var NAME = collections[i];
  var explicit = DOMIterables[NAME];
  var Collection = global[NAME];
  var proto = Collection && Collection.prototype;
  var key;
  if (proto) {
    if (!proto[ITERATOR]) hide(proto, ITERATOR, ArrayValues);
    if (!proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
    Iterators[NAME] = ArrayValues;
    if (explicit) for (key in $iterators) if (!proto[key]) redefine(proto, key, $iterators[key], true);
  }
}

},{"./_global":47,"./_hide":49,"./_iterators":65,"./_object-keys":87,"./_redefine":98,"./_wks":132,"./es6.array.iterator":145}],329:[function(require,module,exports){
var $export = require('./_export');
var $task = require('./_task');
$export($export.G + $export.B, {
  setImmediate: $task.set,
  clearImmediate: $task.clear
});

},{"./_export":40,"./_task":117}],330:[function(require,module,exports){
// ie9- setTimeout & setInterval additional parameters fix
var global = require('./_global');
var $export = require('./_export');
var navigator = global.navigator;
var slice = [].slice;
var MSIE = !!navigator && /MSIE .\./.test(navigator.userAgent); // <- dirty ie9- check
var wrap = function (set) {
  return function (fn, time /* , ...args */) {
    var boundArgs = arguments.length > 2;
    var args = boundArgs ? slice.call(arguments, 2) : false;
    return set(boundArgs ? function () {
      // eslint-disable-next-line no-new-func
      (typeof fn == 'function' ? fn : Function(fn)).apply(this, args);
    } : fn, time);
  };
};
$export($export.G + $export.B + $export.F * MSIE, {
  setTimeout: wrap(global.setTimeout),
  setInterval: wrap(global.setInterval)
});

},{"./_export":40,"./_global":47}],331:[function(require,module,exports){
require('./modules/es6.symbol');
require('./modules/es6.object.create');
require('./modules/es6.object.define-property');
require('./modules/es6.object.define-properties');
require('./modules/es6.object.get-own-property-descriptor');
require('./modules/es6.object.get-prototype-of');
require('./modules/es6.object.keys');
require('./modules/es6.object.get-own-property-names');
require('./modules/es6.object.freeze');
require('./modules/es6.object.seal');
require('./modules/es6.object.prevent-extensions');
require('./modules/es6.object.is-frozen');
require('./modules/es6.object.is-sealed');
require('./modules/es6.object.is-extensible');
require('./modules/es6.object.assign');
require('./modules/es6.object.is');
require('./modules/es6.object.set-prototype-of');
require('./modules/es6.object.to-string');
require('./modules/es6.function.bind');
require('./modules/es6.function.name');
require('./modules/es6.function.has-instance');
require('./modules/es6.parse-int');
require('./modules/es6.parse-float');
require('./modules/es6.number.constructor');
require('./modules/es6.number.to-fixed');
require('./modules/es6.number.to-precision');
require('./modules/es6.number.epsilon');
require('./modules/es6.number.is-finite');
require('./modules/es6.number.is-integer');
require('./modules/es6.number.is-nan');
require('./modules/es6.number.is-safe-integer');
require('./modules/es6.number.max-safe-integer');
require('./modules/es6.number.min-safe-integer');
require('./modules/es6.number.parse-float');
require('./modules/es6.number.parse-int');
require('./modules/es6.math.acosh');
require('./modules/es6.math.asinh');
require('./modules/es6.math.atanh');
require('./modules/es6.math.cbrt');
require('./modules/es6.math.clz32');
require('./modules/es6.math.cosh');
require('./modules/es6.math.expm1');
require('./modules/es6.math.fround');
require('./modules/es6.math.hypot');
require('./modules/es6.math.imul');
require('./modules/es6.math.log10');
require('./modules/es6.math.log1p');
require('./modules/es6.math.log2');
require('./modules/es6.math.sign');
require('./modules/es6.math.sinh');
require('./modules/es6.math.tanh');
require('./modules/es6.math.trunc');
require('./modules/es6.string.from-code-point');
require('./modules/es6.string.raw');
require('./modules/es6.string.trim');
require('./modules/es6.string.iterator');
require('./modules/es6.string.code-point-at');
require('./modules/es6.string.ends-with');
require('./modules/es6.string.includes');
require('./modules/es6.string.repeat');
require('./modules/es6.string.starts-with');
require('./modules/es6.string.anchor');
require('./modules/es6.string.big');
require('./modules/es6.string.blink');
require('./modules/es6.string.bold');
require('./modules/es6.string.fixed');
require('./modules/es6.string.fontcolor');
require('./modules/es6.string.fontsize');
require('./modules/es6.string.italics');
require('./modules/es6.string.link');
require('./modules/es6.string.small');
require('./modules/es6.string.strike');
require('./modules/es6.string.sub');
require('./modules/es6.string.sup');
require('./modules/es6.date.now');
require('./modules/es6.date.to-json');
require('./modules/es6.date.to-iso-string');
require('./modules/es6.date.to-string');
require('./modules/es6.date.to-primitive');
require('./modules/es6.array.is-array');
require('./modules/es6.array.from');
require('./modules/es6.array.of');
require('./modules/es6.array.join');
require('./modules/es6.array.slice');
require('./modules/es6.array.sort');
require('./modules/es6.array.for-each');
require('./modules/es6.array.map');
require('./modules/es6.array.filter');
require('./modules/es6.array.some');
require('./modules/es6.array.every');
require('./modules/es6.array.reduce');
require('./modules/es6.array.reduce-right');
require('./modules/es6.array.index-of');
require('./modules/es6.array.last-index-of');
require('./modules/es6.array.copy-within');
require('./modules/es6.array.fill');
require('./modules/es6.array.find');
require('./modules/es6.array.find-index');
require('./modules/es6.array.species');
require('./modules/es6.array.iterator');
require('./modules/es6.regexp.constructor');
require('./modules/es6.regexp.to-string');
require('./modules/es6.regexp.flags');
require('./modules/es6.regexp.match');
require('./modules/es6.regexp.replace');
require('./modules/es6.regexp.search');
require('./modules/es6.regexp.split');
require('./modules/es6.promise');
require('./modules/es6.map');
require('./modules/es6.set');
require('./modules/es6.weak-map');
require('./modules/es6.weak-set');
require('./modules/es6.typed.array-buffer');
require('./modules/es6.typed.data-view');
require('./modules/es6.typed.int8-array');
require('./modules/es6.typed.uint8-array');
require('./modules/es6.typed.uint8-clamped-array');
require('./modules/es6.typed.int16-array');
require('./modules/es6.typed.uint16-array');
require('./modules/es6.typed.int32-array');
require('./modules/es6.typed.uint32-array');
require('./modules/es6.typed.float32-array');
require('./modules/es6.typed.float64-array');
require('./modules/es6.reflect.apply');
require('./modules/es6.reflect.construct');
require('./modules/es6.reflect.define-property');
require('./modules/es6.reflect.delete-property');
require('./modules/es6.reflect.enumerate');
require('./modules/es6.reflect.get');
require('./modules/es6.reflect.get-own-property-descriptor');
require('./modules/es6.reflect.get-prototype-of');
require('./modules/es6.reflect.has');
require('./modules/es6.reflect.is-extensible');
require('./modules/es6.reflect.own-keys');
require('./modules/es6.reflect.prevent-extensions');
require('./modules/es6.reflect.set');
require('./modules/es6.reflect.set-prototype-of');
require('./modules/es7.array.includes');
require('./modules/es7.array.flat-map');
require('./modules/es7.array.flatten');
require('./modules/es7.string.at');
require('./modules/es7.string.pad-start');
require('./modules/es7.string.pad-end');
require('./modules/es7.string.trim-left');
require('./modules/es7.string.trim-right');
require('./modules/es7.string.match-all');
require('./modules/es7.symbol.async-iterator');
require('./modules/es7.symbol.observable');
require('./modules/es7.object.get-own-property-descriptors');
require('./modules/es7.object.values');
require('./modules/es7.object.entries');
require('./modules/es7.object.define-getter');
require('./modules/es7.object.define-setter');
require('./modules/es7.object.lookup-getter');
require('./modules/es7.object.lookup-setter');
require('./modules/es7.map.to-json');
require('./modules/es7.set.to-json');
require('./modules/es7.map.of');
require('./modules/es7.set.of');
require('./modules/es7.weak-map.of');
require('./modules/es7.weak-set.of');
require('./modules/es7.map.from');
require('./modules/es7.set.from');
require('./modules/es7.weak-map.from');
require('./modules/es7.weak-set.from');
require('./modules/es7.global');
require('./modules/es7.system.global');
require('./modules/es7.error.is-error');
require('./modules/es7.math.clamp');
require('./modules/es7.math.deg-per-rad');
require('./modules/es7.math.degrees');
require('./modules/es7.math.fscale');
require('./modules/es7.math.iaddh');
require('./modules/es7.math.isubh');
require('./modules/es7.math.imulh');
require('./modules/es7.math.rad-per-deg');
require('./modules/es7.math.radians');
require('./modules/es7.math.scale');
require('./modules/es7.math.umulh');
require('./modules/es7.math.signbit');
require('./modules/es7.promise.finally');
require('./modules/es7.promise.try');
require('./modules/es7.reflect.define-metadata');
require('./modules/es7.reflect.delete-metadata');
require('./modules/es7.reflect.get-metadata');
require('./modules/es7.reflect.get-metadata-keys');
require('./modules/es7.reflect.get-own-metadata');
require('./modules/es7.reflect.get-own-metadata-keys');
require('./modules/es7.reflect.has-metadata');
require('./modules/es7.reflect.has-own-metadata');
require('./modules/es7.reflect.metadata');
require('./modules/es7.asap');
require('./modules/es7.observable');
require('./modules/web.timers');
require('./modules/web.immediate');
require('./modules/web.dom.iterable');
module.exports = require('./modules/_core');

},{"./modules/_core":30,"./modules/es6.array.copy-within":135,"./modules/es6.array.every":136,"./modules/es6.array.fill":137,"./modules/es6.array.filter":138,"./modules/es6.array.find":140,"./modules/es6.array.find-index":139,"./modules/es6.array.for-each":141,"./modules/es6.array.from":142,"./modules/es6.array.index-of":143,"./modules/es6.array.is-array":144,"./modules/es6.array.iterator":145,"./modules/es6.array.join":146,"./modules/es6.array.last-index-of":147,"./modules/es6.array.map":148,"./modules/es6.array.of":149,"./modules/es6.array.reduce":151,"./modules/es6.array.reduce-right":150,"./modules/es6.array.slice":152,"./modules/es6.array.some":153,"./modules/es6.array.sort":154,"./modules/es6.array.species":155,"./modules/es6.date.now":156,"./modules/es6.date.to-iso-string":157,"./modules/es6.date.to-json":158,"./modules/es6.date.to-primitive":159,"./modules/es6.date.to-string":160,"./modules/es6.function.bind":161,"./modules/es6.function.has-instance":162,"./modules/es6.function.name":163,"./modules/es6.map":164,"./modules/es6.math.acosh":165,"./modules/es6.math.asinh":166,"./modules/es6.math.atanh":167,"./modules/es6.math.cbrt":168,"./modules/es6.math.clz32":169,"./modules/es6.math.cosh":170,"./modules/es6.math.expm1":171,"./modules/es6.math.fround":172,"./modules/es6.math.hypot":173,"./modules/es6.math.imul":174,"./modules/es6.math.log10":175,"./modules/es6.math.log1p":176,"./modules/es6.math.log2":177,"./modules/es6.math.sign":178,"./modules/es6.math.sinh":179,"./modules/es6.math.tanh":180,"./modules/es6.math.trunc":181,"./modules/es6.number.constructor":182,"./modules/es6.number.epsilon":183,"./modules/es6.number.is-finite":184,"./modules/es6.number.is-integer":185,"./modules/es6.number.is-nan":186,"./modules/es6.number.is-safe-integer":187,"./modules/es6.number.max-safe-integer":188,"./modules/es6.number.min-safe-integer":189,"./modules/es6.number.parse-float":190,"./modules/es6.number.parse-int":191,"./modules/es6.number.to-fixed":192,"./modules/es6.number.to-precision":193,"./modules/es6.object.assign":194,"./modules/es6.object.create":195,"./modules/es6.object.define-properties":196,"./modules/es6.object.define-property":197,"./modules/es6.object.freeze":198,"./modules/es6.object.get-own-property-descriptor":199,"./modules/es6.object.get-own-property-names":200,"./modules/es6.object.get-prototype-of":201,"./modules/es6.object.is":205,"./modules/es6.object.is-extensible":202,"./modules/es6.object.is-frozen":203,"./modules/es6.object.is-sealed":204,"./modules/es6.object.keys":206,"./modules/es6.object.prevent-extensions":207,"./modules/es6.object.seal":208,"./modules/es6.object.set-prototype-of":209,"./modules/es6.object.to-string":210,"./modules/es6.parse-float":211,"./modules/es6.parse-int":212,"./modules/es6.promise":213,"./modules/es6.reflect.apply":214,"./modules/es6.reflect.construct":215,"./modules/es6.reflect.define-property":216,"./modules/es6.reflect.delete-property":217,"./modules/es6.reflect.enumerate":218,"./modules/es6.reflect.get":221,"./modules/es6.reflect.get-own-property-descriptor":219,"./modules/es6.reflect.get-prototype-of":220,"./modules/es6.reflect.has":222,"./modules/es6.reflect.is-extensible":223,"./modules/es6.reflect.own-keys":224,"./modules/es6.reflect.prevent-extensions":225,"./modules/es6.reflect.set":227,"./modules/es6.reflect.set-prototype-of":226,"./modules/es6.regexp.constructor":228,"./modules/es6.regexp.flags":229,"./modules/es6.regexp.match":230,"./modules/es6.regexp.replace":231,"./modules/es6.regexp.search":232,"./modules/es6.regexp.split":233,"./modules/es6.regexp.to-string":234,"./modules/es6.set":235,"./modules/es6.string.anchor":236,"./modules/es6.string.big":237,"./modules/es6.string.blink":238,"./modules/es6.string.bold":239,"./modules/es6.string.code-point-at":240,"./modules/es6.string.ends-with":241,"./modules/es6.string.fixed":242,"./modules/es6.string.fontcolor":243,"./modules/es6.string.fontsize":244,"./modules/es6.string.from-code-point":245,"./modules/es6.string.includes":246,"./modules/es6.string.italics":247,"./modules/es6.string.iterator":248,"./modules/es6.string.link":249,"./modules/es6.string.raw":250,"./modules/es6.string.repeat":251,"./modules/es6.string.small":252,"./modules/es6.string.starts-with":253,"./modules/es6.string.strike":254,"./modules/es6.string.sub":255,"./modules/es6.string.sup":256,"./modules/es6.string.trim":257,"./modules/es6.symbol":258,"./modules/es6.typed.array-buffer":259,"./modules/es6.typed.data-view":260,"./modules/es6.typed.float32-array":261,"./modules/es6.typed.float64-array":262,"./modules/es6.typed.int16-array":263,"./modules/es6.typed.int32-array":264,"./modules/es6.typed.int8-array":265,"./modules/es6.typed.uint16-array":266,"./modules/es6.typed.uint32-array":267,"./modules/es6.typed.uint8-array":268,"./modules/es6.typed.uint8-clamped-array":269,"./modules/es6.weak-map":270,"./modules/es6.weak-set":271,"./modules/es7.array.flat-map":272,"./modules/es7.array.flatten":273,"./modules/es7.array.includes":274,"./modules/es7.asap":275,"./modules/es7.error.is-error":276,"./modules/es7.global":277,"./modules/es7.map.from":278,"./modules/es7.map.of":279,"./modules/es7.map.to-json":280,"./modules/es7.math.clamp":281,"./modules/es7.math.deg-per-rad":282,"./modules/es7.math.degrees":283,"./modules/es7.math.fscale":284,"./modules/es7.math.iaddh":285,"./modules/es7.math.imulh":286,"./modules/es7.math.isubh":287,"./modules/es7.math.rad-per-deg":288,"./modules/es7.math.radians":289,"./modules/es7.math.scale":290,"./modules/es7.math.signbit":291,"./modules/es7.math.umulh":292,"./modules/es7.object.define-getter":293,"./modules/es7.object.define-setter":294,"./modules/es7.object.entries":295,"./modules/es7.object.get-own-property-descriptors":296,"./modules/es7.object.lookup-getter":297,"./modules/es7.object.lookup-setter":298,"./modules/es7.object.values":299,"./modules/es7.observable":300,"./modules/es7.promise.finally":301,"./modules/es7.promise.try":302,"./modules/es7.reflect.define-metadata":303,"./modules/es7.reflect.delete-metadata":304,"./modules/es7.reflect.get-metadata":306,"./modules/es7.reflect.get-metadata-keys":305,"./modules/es7.reflect.get-own-metadata":308,"./modules/es7.reflect.get-own-metadata-keys":307,"./modules/es7.reflect.has-metadata":309,"./modules/es7.reflect.has-own-metadata":310,"./modules/es7.reflect.metadata":311,"./modules/es7.set.from":312,"./modules/es7.set.of":313,"./modules/es7.set.to-json":314,"./modules/es7.string.at":315,"./modules/es7.string.match-all":316,"./modules/es7.string.pad-end":317,"./modules/es7.string.pad-start":318,"./modules/es7.string.trim-left":319,"./modules/es7.string.trim-right":320,"./modules/es7.symbol.async-iterator":321,"./modules/es7.symbol.observable":322,"./modules/es7.system.global":323,"./modules/es7.weak-map.from":324,"./modules/es7.weak-map.of":325,"./modules/es7.weak-set.from":326,"./modules/es7.weak-set.of":327,"./modules/web.dom.iterable":328,"./modules/web.immediate":329,"./modules/web.timers":330}],332:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports['default'] = camelize;
var regExp = /[-\s]+(.)?/g;

/**
 * Convert dash separated strings to camel cased.
 *
 * @param {String} str
 * @return {String}
 */
function camelize(str) {
  return str.replace(regExp, toUpper);
}

function toUpper(match, c) {
  return c ? c.toUpperCase() : '';
}
},{}],333:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.supportedValue = exports.supportedProperty = exports.prefix = undefined;

var _prefix = require('./prefix');

var _prefix2 = _interopRequireDefault(_prefix);

var _supportedProperty = require('./supported-property');

var _supportedProperty2 = _interopRequireDefault(_supportedProperty);

var _supportedValue = require('./supported-value');

var _supportedValue2 = _interopRequireDefault(_supportedValue);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

exports['default'] = {
  prefix: _prefix2['default'],
  supportedProperty: _supportedProperty2['default'],
  supportedValue: _supportedValue2['default']
}; /**
    * CSS Vendor prefix detection and property feature testing.
    *
    * @copyright Oleg Slobodskoi 2015
    * @website https://github.com/jsstyles/css-vendor
    * @license MIT
    */

exports.prefix = _prefix2['default'];
exports.supportedProperty = _supportedProperty2['default'];
exports.supportedValue = _supportedValue2['default'];
},{"./prefix":334,"./supported-property":335,"./supported-value":336}],334:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _isInBrowser = require('is-in-browser');

var _isInBrowser2 = _interopRequireDefault(_isInBrowser);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var js = ''; /**
              * Export javascript style and css style vendor prefixes.
              * Based on "transform" support test.
              */

var css = '';

// We should not do anything if required serverside.
if (_isInBrowser2['default']) {
  // Order matters. We need to check Webkit the last one because
  // other vendors use to add Webkit prefixes to some properties
  var jsCssMap = {
    Moz: '-moz-',
    // IE did it wrong again ...
    ms: '-ms-',
    O: '-o-',
    Webkit: '-webkit-'
  };
  var style = document.createElement('p').style;
  var testProp = 'Transform';

  for (var key in jsCssMap) {
    if (key + testProp in style) {
      js = key;
      css = jsCssMap[key];
      break;
    }
  }
}

/**
 * Vendor prefix string for the current browser.
 *
 * @type {{js: String, css: String}}
 * @api public
 */
exports['default'] = { js: js, css: css };
},{"is-in-browser":340}],335:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports['default'] = supportedProperty;

var _isInBrowser = require('is-in-browser');

var _isInBrowser2 = _interopRequireDefault(_isInBrowser);

var _prefix = require('./prefix');

var _prefix2 = _interopRequireDefault(_prefix);

var _camelize = require('./camelize');

var _camelize2 = _interopRequireDefault(_camelize);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var el = void 0;
var cache = {};

if (_isInBrowser2['default']) {
  el = document.createElement('p');

  /**
   * We test every property on vendor prefix requirement.
   * Once tested, result is cached. It gives us up to 70% perf boost.
   * http://jsperf.com/element-style-object-access-vs-plain-object
   *
   * Prefill cache with known css properties to reduce amount of
   * properties we need to feature test at runtime.
   * http://davidwalsh.name/vendor-prefix
   */
  var computed = window.getComputedStyle(document.documentElement, '');
  for (var key in computed) {
    if (!isNaN(key)) cache[computed[key]] = computed[key];
  }
}

/**
 * Test if a property is supported, returns supported property with vendor
 * prefix if required. Returns `false` if not supported.
 *
 * @param {String} prop dash separated
 * @return {String|Boolean}
 * @api public
 */
function supportedProperty(prop) {
  // For server-side rendering.
  if (!el) return prop;

  // We have not tested this prop yet, lets do the test.
  if (cache[prop] != null) return cache[prop];

  // Camelization is required because we can't test using
  // css syntax for e.g. in FF.
  // Test if property is supported as it is.
  if ((0, _camelize2['default'])(prop) in el.style) {
    cache[prop] = prop;
  }
  // Test if property is supported with vendor prefix.
  else if (_prefix2['default'].js + (0, _camelize2['default'])('-' + prop) in el.style) {
      cache[prop] = _prefix2['default'].css + prop;
    } else {
      cache[prop] = false;
    }

  return cache[prop];
}
},{"./camelize":332,"./prefix":334,"is-in-browser":340}],336:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports['default'] = supportedValue;

var _isInBrowser = require('is-in-browser');

var _isInBrowser2 = _interopRequireDefault(_isInBrowser);

var _prefix = require('./prefix');

var _prefix2 = _interopRequireDefault(_prefix);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var cache = {};
var el = void 0;

if (_isInBrowser2['default']) el = document.createElement('p');

/**
 * Returns prefixed value if needed. Returns `false` if value is not supported.
 *
 * @param {String} property
 * @param {String} value
 * @return {String|Boolean}
 * @api public
 */
function supportedValue(property, value) {
  // For server-side rendering.
  if (!el) return value;

  // It is a string or a number as a string like '1'.
  // We want only prefixable values here.
  if (typeof value !== 'string' || !isNaN(parseInt(value, 10))) return value;

  var cacheKey = property + value;

  if (cache[cacheKey] != null) return cache[cacheKey];

  // IE can even throw an error in some cases, for e.g. style.content = 'bar'
  try {
    // Test value as it is.
    el.style[property] = value;
  } catch (err) {
    cache[cacheKey] = false;
    return false;
  }

  // Value is supported as it is.
  if (el.style[property] !== '') {
    cache[cacheKey] = value;
  } else {
    // Test value with vendor prefix.
    value = _prefix2['default'].css + value;

    // Hardcode test to convert "flex" to "-ms-flexbox" for IE10.
    if (value === '-ms-flex') value = '-ms-flexbox';

    el.style[property] = value;

    // Value is supported with vendor prefix.
    if (el.style[property] !== '') cache[cacheKey] = value;
  }

  if (!cache[cacheKey]) cache[cacheKey] = false;

  // Reset style value.
  el.style[property] = '';

  return cache[cacheKey];
}
},{"./prefix":334,"is-in-browser":340}],337:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
var isValidString = function isValidString(param) {
  return typeof param === 'string' && param.length > 0;
};

var startsWith = function startsWith(string, start) {
  return string[0] === start;
};

var isSelector = function isSelector(param) {
  return isValidString(param) && (startsWith(param, '.') || startsWith(param, '#'));
};

var node = function node(h) {
  return function (tagName) {
    return function (first) {
      for (var _len = arguments.length, rest = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        rest[_key - 1] = arguments[_key];
      }

      if (isSelector(first)) {
        return h.apply(undefined, [tagName + first].concat(rest));
      } else if (typeof first === 'undefined') {
        return h(tagName);
      } else {
        return h.apply(undefined, [tagName, first].concat(rest));
      }
    };
  };
};

var TAG_NAMES = ['a', 'abbr', 'acronym', 'address', 'applet', 'area', 'article', 'aside', 'audio', 'b', 'base', 'basefont', 'bdi', 'bdo', 'bgsound', 'big', 'blink', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'center', 'cite', 'code', 'col', 'colgroup', 'command', 'content', 'data', 'datalist', 'dd', 'del', 'details', 'dfn', 'dialog', 'dir', 'div', 'dl', 'dt', 'element', 'em', 'embed', 'fieldset', 'figcaption', 'figure', 'font', 'footer', 'form', 'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'iframe', 'image', 'img', 'input', 'ins', 'isindex', 'kbd', 'keygen', 'label', 'legend', 'li', 'link', 'listing', 'main', 'map', 'mark', 'marquee', 'math', 'menu', 'menuitem', 'meta', 'meter', 'multicol', 'nav', 'nextid', 'nobr', 'noembed', 'noframes', 'noscript', 'object', 'ol', 'optgroup', 'option', 'output', 'p', 'param', 'picture', 'plaintext', 'pre', 'progress', 'q', 'rb', 'rbc', 'rp', 'rt', 'rtc', 'ruby', 's', 'samp', 'script', 'section', 'select', 'shadow', 'slot', 'small', 'source', 'spacer', 'span', 'strike', 'strong', 'style', 'sub', 'summary', 'sup', 'svg', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'time', 'title', 'tr', 'track', 'tt', 'u', 'ul', 'var', 'video', 'wbr', 'xmp'];

exports['default'] = function (h) {
  var createTag = node(h);
  var exported = { TAG_NAMES: TAG_NAMES, isSelector: isSelector, createTag: createTag };
  TAG_NAMES.forEach(function (n) {
    exported[n] = createTag(n);
  });
  return exported;
};

module.exports = exports['default'];
},{}],338:[function(require,module,exports){
var split = require('browser-split')
var ClassList = require('class-list')

var w = typeof window === 'undefined' ? require('html-element') : window
var document = w.document
var Text = w.Text

function context () {

  var cleanupFuncs = []

  function h() {
    var args = [].slice.call(arguments), e = null
    function item (l) {
      var r
      function parseClass (string) {
        // Our minimal parser doesn’t understand escaping CSS special
        // characters like `#`. Don’t use them. More reading:
        // https://mathiasbynens.be/notes/css-escapes .

        var m = split(string, /([\.#]?[^\s#.]+)/)
        if(/^\.|#/.test(m[1]))
          e = document.createElement('div')
        forEach(m, function (v) {
          var s = v.substring(1,v.length)
          if(!v) return
          if(!e)
            e = document.createElement(v)
          else if (v[0] === '.')
            ClassList(e).add(s)
          else if (v[0] === '#')
            e.setAttribute('id', s)
        })
      }

      if(l == null)
        ;
      else if('string' === typeof l) {
        if(!e)
          parseClass(l)
        else
          e.appendChild(r = document.createTextNode(l))
      }
      else if('number' === typeof l
        || 'boolean' === typeof l
        || l instanceof Date
        || l instanceof RegExp ) {
          e.appendChild(r = document.createTextNode(l.toString()))
      }
      //there might be a better way to handle this...
      else if (isArray(l))
        forEach(l, item)
      else if(isNode(l))
        e.appendChild(r = l)
      else if(l instanceof Text)
        e.appendChild(r = l)
      else if ('object' === typeof l) {
        for (var k in l) {
          if('function' === typeof l[k]) {
            if(/^on\w+/.test(k)) {
              (function (k, l) { // capture k, l in the closure
                if (e.addEventListener){
                  e.addEventListener(k.substring(2), l[k], false)
                  cleanupFuncs.push(function(){
                    e.removeEventListener(k.substring(2), l[k], false)
                  })
                }else{
                  e.attachEvent(k, l[k])
                  cleanupFuncs.push(function(){
                    e.detachEvent(k, l[k])
                  })
                }
              })(k, l)
            } else {
              // observable
              e[k] = l[k]()
              cleanupFuncs.push(l[k](function (v) {
                e[k] = v
              }))
            }
          }
          else if(k === 'style') {
            if('string' === typeof l[k]) {
              e.style.cssText = l[k]
            }else{
              for (var s in l[k]) (function(s, v) {
                if('function' === typeof v) {
                  // observable
                  e.style.setProperty(s, v())
                  cleanupFuncs.push(v(function (val) {
                    e.style.setProperty(s, val)
                  }))
                } else
                  var match = l[k][s].match(/(.*)\W+!important\W*$/);
                  if (match) {
                    e.style.setProperty(s, match[1], 'important')
                  } else {
                    e.style.setProperty(s, l[k][s])
                  }
              })(s, l[k][s])
            }
          } else if(k === 'attrs') {
            for (var v in l[k]) {
              e.setAttribute(v, l[k][v])
            }
          }
          else if (k.substr(0, 5) === "data-") {
            e.setAttribute(k, l[k])
          } else {
            e[k] = l[k]
          }
        }
      } else if ('function' === typeof l) {
        //assume it's an observable!
        var v = l()
        e.appendChild(r = isNode(v) ? v : document.createTextNode(v))

        cleanupFuncs.push(l(function (v) {
          if(isNode(v) && r.parentElement)
            r.parentElement.replaceChild(v, r), r = v
          else
            r.textContent = v
        }))
      }

      return r
    }
    while(args.length)
      item(args.shift())

    return e
  }

  h.cleanup = function () {
    for (var i = 0; i < cleanupFuncs.length; i++){
      cleanupFuncs[i]()
    }
    cleanupFuncs.length = 0
  }

  return h
}

var h = module.exports = context()
h.context = context

function isNode (el) {
  return el && el.nodeName && el.nodeType
}

function forEach (arr, fn) {
  if (arr.forEach) return arr.forEach(fn)
  for (var i = 0; i < arr.length; i++) fn(arr[i], i)
}

function isArray (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]'
}



},{"browser-split":7,"class-list":8,"html-element":6}],339:[function(require,module,exports){

var indexOf = [].indexOf;

module.exports = function(arr, obj){
  if (indexOf) return arr.indexOf(obj);
  for (var i = 0; i < arr.length; ++i) {
    if (arr[i] === obj) return i;
  }
  return -1;
};
},{}],340:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var isBrowser = exports.isBrowser = (typeof window === "undefined" ? "undefined" : _typeof(window)) === "object" && (typeof document === "undefined" ? "undefined" : _typeof(document)) === 'object' && document.nodeType === 9;

exports.default = isBrowser;
},{}],341:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = camelCase;
var regExp = /([A-Z])/g;

/**
 * Replace a string passed from String#replace.
 * @param {String} str
 * @return {String}
 */
function replace(str) {
  return "-" + str.toLowerCase();
}

/**
 * Convert camel cased property names to dash separated.
 *
 * @param {Object} style
 * @return {Object}
 */
function convertCase(style) {
  var converted = {};

  for (var prop in style) {
    converted[prop.replace(regExp, replace)] = style[prop];
  }

  if (style.fallbacks) {
    if (Array.isArray(style.fallbacks)) converted.fallbacks = style.fallbacks.map(convertCase);else converted.fallbacks = convertCase(style.fallbacks);
  }

  return converted;
}

/**
 * Allow camel cased property names by converting them back to dasherized.
 *
 * @param {Rule} rule
 */
function camelCase() {
  function onProcessStyle(style) {
    if (Array.isArray(style)) {
      // Handle rules like @font-face, which can have multiple styles in an array
      for (var index = 0; index < style.length; index++) {
        style[index] = convertCase(style[index]);
      }
      return style;
    }

    return convertCase(style);
  }

  return { onProcessStyle: onProcessStyle };
}
},{}],342:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = jssCompose;

var _warning = require('warning');

var _warning2 = _interopRequireDefault(_warning);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Set selector.
 *
 * @param {Object} original rule
 * @param {String} className class string
 * @return {Boolean} flag, indicating function was successfull or not
 */
function registerClass(rule, className) {
  // Skip falsy values
  if (!className) return true;

  // Support array of class names `{composes: ['foo', 'bar']}`
  if (Array.isArray(className)) {
    for (var index = 0; index < className.length; index++) {
      var isSetted = registerClass(rule, className[index]);
      if (!isSetted) return false;
    }

    return true;
  }

  // Support space separated class names `{composes: 'foo bar'}`
  if (className.indexOf(' ') > -1) {
    return registerClass(rule, className.split(' '));
  }

  var parent = rule.options.parent;

  // It is a ref to a local rule.

  if (className[0] === '$') {
    var refRule = parent.getRule(className.substr(1));

    if (!refRule) {
      (0, _warning2.default)(false, '[JSS] Referenced rule is not defined. \r\n%s', rule);
      return false;
    }

    if (refRule === rule) {
      (0, _warning2.default)(false, '[JSS] Cyclic composition detected. \r\n%s', rule);
      return false;
    }

    parent.classes[rule.key] += ' ' + parent.classes[refRule.key];

    return true;
  }

  rule.options.parent.classes[rule.key] += ' ' + className;

  return true;
}

/**
 * Convert compose property to additional class, remove property from original styles.
 *
 * @param {Rule} rule
 * @api public
 */
function jssCompose() {
  function onProcessStyle(style, rule) {
    if (!style.composes) return style;
    registerClass(rule, style.composes);
    // Remove composes property to prevent infinite loop.
    delete style.composes;
    return style;
  }
  return { onProcessStyle: onProcessStyle };
}
},{"warning":391}],343:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Generated jss-default-unit CSS property units
 *
 * @type object
 */
exports['default'] = {
  'animation-delay': 'ms',
  'animation-duration': 'ms',
  'background-position': 'px',
  'background-position-x': 'px',
  'background-position-y': 'px',
  'background-size': 'px',
  border: 'px',
  'border-bottom': 'px',
  'border-bottom-left-radius': 'px',
  'border-bottom-right-radius': 'px',
  'border-bottom-width': 'px',
  'border-left': 'px',
  'border-left-width': 'px',
  'border-radius': 'px',
  'border-right': 'px',
  'border-right-width': 'px',
  'border-spacing': 'px',
  'border-top': 'px',
  'border-top-left-radius': 'px',
  'border-top-right-radius': 'px',
  'border-top-width': 'px',
  'border-width': 'px',
  'border-after-width': 'px',
  'border-before-width': 'px',
  'border-end-width': 'px',
  'border-horizontal-spacing': 'px',
  'border-start-width': 'px',
  'border-vertical-spacing': 'px',
  bottom: 'px',
  'box-shadow': 'px',
  'column-gap': 'px',
  'column-rule': 'px',
  'column-rule-width': 'px',
  'column-width': 'px',
  'flex-basis': 'px',
  'font-size': 'px',
  'font-size-delta': 'px',
  height: 'px',
  left: 'px',
  'letter-spacing': 'px',
  'logical-height': 'px',
  'logical-width': 'px',
  margin: 'px',
  'margin-after': 'px',
  'margin-before': 'px',
  'margin-bottom': 'px',
  'margin-left': 'px',
  'margin-right': 'px',
  'margin-top': 'px',
  'max-height': 'px',
  'max-width': 'px',
  'margin-end': 'px',
  'margin-start': 'px',
  'mask-position-x': 'px',
  'mask-position-y': 'px',
  'mask-size': 'px',
  'max-logical-height': 'px',
  'max-logical-width': 'px',
  'min-height': 'px',
  'min-width': 'px',
  'min-logical-height': 'px',
  'min-logical-width': 'px',
  motion: 'px',
  'motion-offset': 'px',
  outline: 'px',
  'outline-offset': 'px',
  'outline-width': 'px',
  padding: 'px',
  'padding-bottom': 'px',
  'padding-left': 'px',
  'padding-right': 'px',
  'padding-top': 'px',
  'padding-after': 'px',
  'padding-before': 'px',
  'padding-end': 'px',
  'padding-start': 'px',
  'perspective-origin-x': '%',
  'perspective-origin-y': '%',
  perspective: 'px',
  right: 'px',
  'shape-margin': 'px',
  size: 'px',
  'text-indent': 'px',
  'text-stroke': 'px',
  'text-stroke-width': 'px',
  top: 'px',
  'transform-origin': '%',
  'transform-origin-x': '%',
  'transform-origin-y': '%',
  'transform-origin-z': '%',
  'transition-delay': 'ms',
  'transition-duration': 'ms',
  'vertical-align': 'px',
  width: 'px',
  'word-spacing': 'px',
  // Not existing properties.
  // Used to avoid issues with jss-expand intergration.
  'box-shadow-x': 'px',
  'box-shadow-y': 'px',
  'box-shadow-blur': 'px',
  'box-shadow-spread': 'px',
  'font-line-height': 'px',
  'text-shadow-x': 'px',
  'text-shadow-y': 'px',
  'text-shadow-blur': 'px'
};
},{}],344:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports['default'] = defaultUnit;

var _defaultUnits = require('./defaultUnits');

var _defaultUnits2 = _interopRequireDefault(_defaultUnits);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/**
 * Clones the object and adds a camel cased property version.
 */
function addCamelCasedVersion(obj) {
  var regExp = /(-[a-z])/g;
  var replace = function replace(str) {
    return str[1].toUpperCase();
  };
  var newObj = {};
  for (var key in obj) {
    newObj[key] = obj[key];
    newObj[key.replace(regExp, replace)] = obj[key];
  }
  return newObj;
}

var units = addCamelCasedVersion(_defaultUnits2['default']);

/**
 * Recursive deep style passing function
 *
 * @param {String} current property
 * @param {(Object|Array|Number|String)} property value
 * @param {Object} options
 * @return {(Object|Array|Number|String)} resulting value
 */
function iterate(prop, value, options) {
  if (!value) return value;

  var convertedValue = value;

  var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);
  if (type === 'object' && Array.isArray(value)) type = 'array';

  switch (type) {
    case 'object':
      if (prop === 'fallbacks') {
        for (var innerProp in value) {
          value[innerProp] = iterate(innerProp, value[innerProp], options);
        }
        break;
      }
      for (var _innerProp in value) {
        value[_innerProp] = iterate(prop + '-' + _innerProp, value[_innerProp], options);
      }
      break;
    case 'array':
      for (var i = 0; i < value.length; i++) {
        value[i] = iterate(prop, value[i], options);
      }
      break;
    case 'number':
      if (value !== 0) {
        convertedValue = value + (options[prop] || units[prop] || '');
      }
      break;
    default:
      break;
  }

  return convertedValue;
}

/**
 * Add unit to numeric values.
 */
function defaultUnit() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var camelCasedOptions = addCamelCasedVersion(options);

  function onProcessStyle(style, rule) {
    if (rule.type !== 'style') return style;

    for (var prop in style) {
      style[prop] = iterate(prop, style[prop], camelCasedOptions);
    }

    return style;
  }

  function onChangeValue(value, prop) {
    return iterate(prop, value, camelCasedOptions);
  }

  return { onProcessStyle: onProcessStyle, onChangeValue: onChangeValue };
}
},{"./defaultUnits":343}],345:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.default = jssExpand;

var _props = require('./props');

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Map values by given prop.
 *
 * @param {Array} array of values
 * @param {String} original property
 * @param {String} original rule
 * @return {String} mapped values
 */
function mapValuesByProp(value, prop, rule) {
  return value.map(function (item) {
    return objectToString(item, prop, rule);
  });
}

/**
 * Convert array to string.
 *
 * @param {Array} array of values
 * @param {String} original property
 * @param {Object} sheme, for converting arrays in strings
 * @param {Object} original rule
 * @return {String} converted string
 */
function arrayToString(value, prop, scheme, rule) {
  if (scheme[prop] == null) return value.join(',');
  if (value.length === 0) return '';
  if (Array.isArray(value[0])) return arrayToString(value[0], prop, scheme);
  if (_typeof(value[0]) === 'object') {
    return mapValuesByProp(value, prop, rule);
  }
  return value.join(' ');
}

/**
 * Convert object to string.
 *
 * @param {Object} object of values
 * @param {String} original property
 * @param {Object} original rule
 * @param {Boolean} is fallback prop
 * @return {String} converted string
 */
function objectToString(value, prop, rule, isFallback) {
  if (!(_props.propObj[prop] || _props.customPropObj[prop])) return '';

  var result = [];

  // Check if exists any non-standart property
  if (_props.customPropObj[prop]) {
    value = customPropsToStyle(value, rule, _props.customPropObj[prop], isFallback);
  }

  // Pass throught all standart props
  if (Object.keys(value).length) {
    for (var baseProp in _props.propObj[prop]) {
      if (value[baseProp]) {
        if (Array.isArray(value[baseProp])) {
          result.push(arrayToString(value[baseProp], baseProp, _props.propArrayInObj));
        } else result.push(value[baseProp]);
        continue;
      }

      // Add default value from props config.
      if (_props.propObj[prop][baseProp] != null) {
        result.push(_props.propObj[prop][baseProp]);
      }
    }
  }

  return result.join(' ');
}

/**
 * Convert custom properties values to styles adding them to rule directly
 *
 * @param {Object} object of values
 * @param {Object} original rule
 * @param {String} property, that contain partial custom properties
 * @param {Boolean} is fallback prop
 * @return {Object} value without custom properties, that was already added to rule
 */
function customPropsToStyle(value, rule, customProps, isFallback) {
  for (var prop in customProps) {
    var propName = customProps[prop];

    // If current property doesn't exist already in rule - add new one
    if (typeof value[prop] !== 'undefined' && (isFallback || !rule.prop(propName))) {
      var appendedValue = styleDetector(_defineProperty({}, propName, value[prop]), rule)[propName];

      // Add style directly in rule
      if (isFallback) rule.style.fallbacks[propName] = appendedValue;else rule.style[propName] = appendedValue;
    }
    // Delete converted property to avoid double converting
    delete value[prop];
  }

  return value;
}

/**
 * Detect if a style needs to be converted.
 *
 * @param {Object} style
 * @param {Object} rule
 * @param {Boolean} is fallback prop
 * @return {Object} convertedStyle
 */
function styleDetector(style, rule, isFallback) {
  for (var prop in style) {
    var value = style[prop];

    if (Array.isArray(value)) {
      // Check double arrays to avoid recursion.
      if (!Array.isArray(value[0])) {
        if (prop === 'fallbacks') {
          for (var index = 0; index < style.fallbacks.length; index++) {
            style.fallbacks[index] = styleDetector(style.fallbacks[index], rule, true);
          }
          continue;
        }

        style[prop] = arrayToString(value, prop, _props.propArray);
        // Avoid creating properties with empty values
        if (!style[prop]) delete style[prop];
      }
    } else if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {
      if (prop === 'fallbacks') {
        style.fallbacks = styleDetector(style.fallbacks, rule, true);
        continue;
      }

      style[prop] = objectToString(value, prop, rule, isFallback);
      // Avoid creating properties with empty values
      if (!style[prop]) delete style[prop];
    }

    // Maybe a computed value resulting in an empty string
    else if (style[prop] === '') delete style[prop];
  }

  return style;
}

/**
 * Adds possibility to write expanded styles.
 *
 * @param {Rule} rule
 * @api public
 */
function jssExpand() {
  function onProcessStyle(style, rule) {
    if (!style || rule.type !== 'style') return style;

    if (Array.isArray(style)) {
      // Pass rules one by one and reformat them
      for (var index = 0; index < style.length; index++) {
        style[index] = styleDetector(style[index], rule);
      }
      return style;
    }

    return styleDetector(style, rule);
  }

  return { onProcessStyle: onProcessStyle };
}
},{"./props":346}],346:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * A scheme for converting properties from array to regular style.
 * All properties listed below will be transformed to a string separated by space.
 */
var propArray = exports.propArray = {
  'background-size': true,
  'background-position': true,
  border: true,
  'border-bottom': true,
  'border-left': true,
  'border-top': true,
  'border-right': true,
  'border-radius': true,
  'border-image': true,
  'box-shadow': true,
  flex: true,
  margin: true,
  padding: true,
  outline: true,
  'transform-origin': true,
  transform: true,
  transition: true

  /**
   * A scheme for converting arrays to regular styles inside of objects.
   * For e.g.: "{position: [0, 0]}" => "background-position: 0 0;".
   */
};var propArrayInObj = exports.propArrayInObj = {
  position: true, // background-position
  size: true // background-size


  /**
   * A scheme for parsing and building correct styles from passed objects.
   */
};var propObj = exports.propObj = {
  padding: {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  },
  margin: {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  },
  background: {
    attachment: null,
    color: null,
    image: null,
    position: null,
    repeat: null
  },
  border: {
    width: null,
    style: null,
    color: null
  },
  'border-top': {
    width: null,
    style: null,
    color: null
  },
  'border-right': {
    width: null,
    style: null,
    color: null
  },
  'border-bottom': {
    width: null,
    style: null,
    color: null
  },
  'border-left': {
    width: null,
    style: null,
    color: null
  },
  outline: {
    width: null,
    style: null,
    color: null
  },
  'list-style': {
    type: null,
    position: null,
    image: null
  },
  transition: {
    property: null,
    duration: null,
    'timing-function': null,
    timingFunction: null, // Needed for avoiding comilation issues with jss-camel-case
    delay: null
  },
  animation: {
    name: null,
    duration: null,
    'timing-function': null,
    timingFunction: null, // Needed to avoid compilation issues with jss-camel-case
    delay: null,
    'iteration-count': null,
    iterationCount: null, // Needed to avoid compilation issues with jss-camel-case
    direction: null,
    'fill-mode': null,
    fillMode: null, // Needed to avoid compilation issues with jss-camel-case
    'play-state': null,
    playState: null // Needed to avoid compilation issues with jss-camel-case
  },
  'box-shadow': {
    x: 0,
    y: 0,
    blur: 0,
    spread: 0,
    color: null,
    inset: null
  },
  'text-shadow': {
    x: 0,
    y: 0,
    blur: null,
    color: null
  }

  /**
   * A scheme for converting non-standart properties inside object.
   * For e.g.: include 'border-radius' property inside 'border' object.
   */
};var customPropObj = exports.customPropObj = {
  border: {
    radius: 'border-radius',
    image: 'border-image'
  },
  background: {
    size: 'background-size',
    image: 'background-image'
  },
  font: {
    style: 'font-style',
    variant: 'font-variant',
    weight: 'font-weight',
    stretch: 'font-stretch',
    size: 'font-size',
    family: 'font-family',
    lineHeight: 'line-height', // Needed to avoid compilation issues with jss-camel-case
    'line-height': 'line-height'
  },
  flex: {
    grow: 'flex-grow',
    basis: 'flex-basis',
    direction: 'flex-direction',
    wrap: 'flex-wrap',
    flow: 'flex-flow',
    shrink: 'flex-shrink'
  },
  align: {
    self: 'align-self',
    items: 'align-items',
    content: 'align-content'
  }
};
},{}],347:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports['default'] = jssExtend;

var _warning = require('warning');

var _warning2 = _interopRequireDefault(_warning);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var isObject = function isObject(obj) {
  return obj && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' && !Array.isArray(obj);
};

/**
 * Recursively extend styles.
 */
function extend(style, rule, sheet) {
  var newStyle = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

  if (typeof style.extend === 'string') {
    if (sheet) {
      var refRule = sheet.getRule(style.extend);
      if (refRule) {
        if (refRule === rule) (0, _warning2['default'])(false, '[JSS] A rule tries to extend itself \r\n%s', rule);else if (refRule.options.parent) {
          var originalStyle = refRule.options.parent.rules.raw[style.extend];
          extend(originalStyle, rule, sheet, newStyle);
        }
      }
    }
  } else if (Array.isArray(style.extend)) {
    for (var index = 0; index < style.extend.length; index++) {
      extend(style.extend[index], rule, sheet, newStyle);
    }
  } else {
    for (var prop in style.extend) {
      if (prop === 'extend') {
        extend(style.extend.extend, rule, sheet, newStyle);
      } else if (isObject(style.extend[prop])) {
        if (!newStyle[prop]) newStyle[prop] = {};
        extend(style.extend[prop], rule, sheet, newStyle[prop]);
      } else {
        newStyle[prop] = style.extend[prop];
      }
    }
  }
  // Copy base style.
  for (var _prop in style) {
    if (_prop === 'extend') continue;
    if (isObject(newStyle[_prop]) && isObject(style[_prop])) {
      extend(style[_prop], rule, sheet, newStyle[_prop]);
    } else if (isObject(style[_prop])) {
      newStyle[_prop] = extend(style[_prop], rule, sheet);
    } else {
      newStyle[_prop] = style[_prop];
    }
  }

  return newStyle;
}

/**
 * Handle `extend` property.
 *
 * @param {Rule} rule
 * @api public
 */
function jssExtend() {
  function onProcessStyle(style, rule, sheet) {
    return style.extend ? extend(style, rule, sheet) : style;
  }

  return { onProcessStyle: onProcessStyle };
}
},{"warning":391}],348:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports['default'] = jssGlobal;

var _jss = require('jss');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var propKey = '@global';
var prefixKey = '@global ';

var GlobalContainerRule = function () {
  function GlobalContainerRule(key, styles, options) {
    _classCallCheck(this, GlobalContainerRule);

    this.type = 'global';

    this.key = key;
    this.options = options;
    this.rules = new _jss.RuleList(_extends({}, options, {
      parent: this
    }));

    for (var selector in styles) {
      this.rules.add(selector, styles[selector], { selector: selector });
    }

    this.rules.process();
  }

  /**
   * Get a rule.
   */


  _createClass(GlobalContainerRule, [{
    key: 'getRule',
    value: function getRule(name) {
      return this.rules.get(name);
    }

    /**
     * Create and register rule, run plugins.
     */

  }, {
    key: 'addRule',
    value: function addRule(name, style, options) {
      var rule = this.rules.add(name, style, options);
      this.options.jss.plugins.onProcessRule(rule);
      return rule;
    }

    /**
     * Get index of a rule.
     */

  }, {
    key: 'indexOf',
    value: function indexOf(rule) {
      return this.rules.indexOf(rule);
    }

    /**
     * Generates a CSS string.
     */

  }, {
    key: 'toString',
    value: function toString() {
      return this.rules.toString();
    }
  }]);

  return GlobalContainerRule;
}();

var GlobalPrefixedRule = function () {
  function GlobalPrefixedRule(name, style, options) {
    _classCallCheck(this, GlobalPrefixedRule);

    this.name = name;
    this.options = options;
    var selector = name.substr(prefixKey.length);
    this.rule = options.jss.createRule(selector, style, _extends({}, options, {
      parent: this,
      selector: selector
    }));
  }

  _createClass(GlobalPrefixedRule, [{
    key: 'toString',
    value: function toString(options) {
      return this.rule.toString(options);
    }
  }]);

  return GlobalPrefixedRule;
}();

var separatorRegExp = /\s*,\s*/g;

function addScope(selector, scope) {
  var parts = selector.split(separatorRegExp);
  var scoped = '';
  for (var i = 0; i < parts.length; i++) {
    scoped += scope + ' ' + parts[i].trim();
    if (parts[i + 1]) scoped += ', ';
  }
  return scoped;
}

function handleNestedGlobalContainerRule(rule) {
  var options = rule.options,
      style = rule.style;

  var rules = style[propKey];

  if (!rules) return;

  for (var name in rules) {
    options.sheet.addRule(name, rules[name], _extends({}, options, {
      selector: addScope(name, rule.selector)
    }));
  }

  delete style[propKey];
}

function handlePrefixedGlobalRule(rule) {
  var options = rule.options,
      style = rule.style;

  for (var prop in style) {
    if (prop.substr(0, propKey.length) !== propKey) continue;

    var selector = addScope(prop.substr(propKey.length), rule.selector);
    options.sheet.addRule(selector, style[prop], _extends({}, options, {
      selector: selector
    }));
    delete style[prop];
  }
}

/**
 * Convert nested rules to separate, remove them from original styles.
 *
 * @param {Rule} rule
 * @api public
 */
function jssGlobal() {
  function onCreateRule(name, styles, options) {
    if (name === propKey) {
      return new GlobalContainerRule(name, styles, options);
    }

    if (name[0] === '@' && name.substr(0, prefixKey.length) === prefixKey) {
      return new GlobalPrefixedRule(name, styles, options);
    }

    var parent = options.parent;


    if (parent) {
      if (parent.type === 'global' || parent.options.parent.type === 'global') {
        options.global = true;
      }
    }

    if (options.global) options.selector = name;

    return null;
  }

  function onProcessRule(rule) {
    if (rule.type !== 'style') return;

    handleNestedGlobalContainerRule(rule);
    handlePrefixedGlobalRule(rule);
  }

  return { onCreateRule: onCreateRule, onProcessRule: onProcessRule };
}
},{"jss":361}],349:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = jssNested;

var _warning = require('warning');

var _warning2 = _interopRequireDefault(_warning);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var separatorRegExp = /\s*,\s*/g;
var parentRegExp = /&/g;
var refRegExp = /\$([\w-]+)/g;

/**
 * Convert nested rules to separate, remove them from original styles.
 *
 * @param {Rule} rule
 * @api public
 */
function jssNested() {
  // Get a function to be used for $ref replacement.
  function getReplaceRef(container) {
    return function (match, key) {
      var rule = container.getRule(key);
      if (rule) return rule.selector;
      (0, _warning2.default)(false, '[JSS] Could not find the referenced rule %s in %s.', key, container.options.meta || container);
      return key;
    };
  }

  var hasAnd = function hasAnd(str) {
    return str.indexOf('&') !== -1;
  };

  function replaceParentRefs(nestedProp, parentProp) {
    var parentSelectors = parentProp.split(separatorRegExp);
    var nestedSelectors = nestedProp.split(separatorRegExp);

    var result = '';

    for (var i = 0; i < parentSelectors.length; i++) {
      var parent = parentSelectors[i];

      for (var j = 0; j < nestedSelectors.length; j++) {
        var nested = nestedSelectors[j];
        if (result) result += ', ';
        // Replace all & by the parent or prefix & with the parent.
        result += hasAnd(nested) ? nested.replace(parentRegExp, parent) : parent + ' ' + nested;
      }
    }

    return result;
  }

  function getOptions(rule, container, options) {
    // Options has been already created, now we only increase index.
    if (options) return _extends({}, options, { index: options.index + 1 });

    var nestingLevel = rule.options.nestingLevel;

    nestingLevel = nestingLevel === undefined ? 1 : nestingLevel + 1;

    return _extends({}, rule.options, {
      nestingLevel: nestingLevel,
      index: container.indexOf(rule) + 1
    });
  }

  function onProcessStyle(style, rule) {
    if (rule.type !== 'style') return style;
    var container = rule.options.parent;
    var options = void 0;
    var replaceRef = void 0;
    for (var prop in style) {
      var isNested = hasAnd(prop);
      var isNestedConditional = prop[0] === '@';

      if (!isNested && !isNestedConditional) continue;

      options = getOptions(rule, container, options);

      if (isNested) {
        var selector = replaceParentRefs(prop, rule.selector
        // Lazily create the ref replacer function just once for
        // all nested rules within the sheet.
        );if (!replaceRef) replaceRef = getReplaceRef(container
        // Replace all $refs.
        );selector = selector.replace(refRegExp, replaceRef);

        container.addRule(selector, style[prop], _extends({}, options, { selector: selector }));
      } else if (isNestedConditional) {
        container
        // Place conditional right after the parent rule to ensure right ordering.
        .addRule(prop, null, options).addRule(rule.key, style[prop], { selector: rule.selector });
      }

      delete style[prop];
    }

    return style;
  }

  return { onProcessStyle: onProcessStyle };
}
},{"warning":391}],350:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _jssTemplate = require('jss-template');

var _jssTemplate2 = _interopRequireDefault(_jssTemplate);

var _jssGlobal = require('jss-global');

var _jssGlobal2 = _interopRequireDefault(_jssGlobal);

var _jssExtend = require('jss-extend');

var _jssExtend2 = _interopRequireDefault(_jssExtend);

var _jssNested = require('jss-nested');

var _jssNested2 = _interopRequireDefault(_jssNested);

var _jssCompose = require('jss-compose');

var _jssCompose2 = _interopRequireDefault(_jssCompose);

var _jssCamelCase = require('jss-camel-case');

var _jssCamelCase2 = _interopRequireDefault(_jssCamelCase);

var _jssDefaultUnit = require('jss-default-unit');

var _jssDefaultUnit2 = _interopRequireDefault(_jssDefaultUnit);

var _jssExpand = require('jss-expand');

var _jssExpand2 = _interopRequireDefault(_jssExpand);

var _jssVendorPrefixer = require('jss-vendor-prefixer');

var _jssVendorPrefixer2 = _interopRequireDefault(_jssVendorPrefixer);

var _jssPropsSort = require('jss-props-sort');

var _jssPropsSort2 = _interopRequireDefault(_jssPropsSort);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function () {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return {
    plugins: [(0, _jssTemplate2.default)(options.template), (0, _jssGlobal2.default)(options.global), (0, _jssExtend2.default)(options.extend), (0, _jssNested2.default)(options.nested), (0, _jssCompose2.default)(options.compose), (0, _jssCamelCase2.default)(options.camelCase), (0, _jssDefaultUnit2.default)(options.defaultUnit), (0, _jssExpand2.default)(options.expand), (0, _jssVendorPrefixer2.default)(options.vendorPrefixer), (0, _jssPropsSort2.default)(options.propsSort)]
  };
};
},{"jss-camel-case":341,"jss-compose":342,"jss-default-unit":344,"jss-expand":345,"jss-extend":347,"jss-global":348,"jss-nested":349,"jss-props-sort":351,"jss-template":352,"jss-vendor-prefixer":354}],351:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports['default'] = jssPropsSort;
/**
 * Sort props by length.
 */
function jssPropsSort() {
  function sort(prop0, prop1) {
    return prop0.length - prop1.length;
  }

  function onProcessStyle(style, rule) {
    if (rule.type !== 'style') return style;

    var newStyle = {};
    var props = Object.keys(style).sort(sort);
    for (var prop in props) {
      newStyle[props[prop]] = style[props[prop]];
    }
    return newStyle;
  }

  return { onProcessStyle: onProcessStyle };
}
},{}],352:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _parse = require('./parse');

var _parse2 = _interopRequireDefault(_parse);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var onProcessRule = function onProcessRule(rule) {
  if (typeof rule.style === 'string') {
    rule.style = (0, _parse2['default'])(rule.style);
  }
};

exports['default'] = function () {
  return { onProcessRule: onProcessRule };
};
},{"./parse":353}],353:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _warning = require('warning');

var _warning2 = _interopRequireDefault(_warning);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var semiWithNl = /;\n/;

/**
 * Naive CSS parser.
 * - Supports only rule body (no selectors)
 * - Requires semicolon and new line after the value (except of last line)
 * - No nested rules support
 */

exports['default'] = function (cssText) {
  var style = {};
  var split = cssText.split(semiWithNl);
  for (var i = 0; i < split.length; i++) {
    var decl = (split[i] || '').trim();

    if (!decl) continue;
    var colonIndex = decl.indexOf(':');
    if (colonIndex === -1) {
      (0, _warning2['default'])(false, 'Malformed CSS string "%s"', decl);
      continue;
    }
    var prop = decl.substr(0, colonIndex).trim();
    var value = decl.substr(colonIndex + 1).trim();
    style[prop] = value;
  }
  return style;
};
},{"warning":391}],354:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports['default'] = jssVendorPrefixer;

var _cssVendor = require('css-vendor');

var vendor = _interopRequireWildcard(_cssVendor);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

/**
 * Add vendor prefix to a property name when needed.
 *
 * @param {Rule} rule
 * @api public
 */
function jssVendorPrefixer() {
  function onProcessRule(rule) {
    if (rule.type === 'keyframes') {
      rule.key = '@' + vendor.prefix.css + rule.key.substr(1);
    }
  }

  function onProcessStyle(style, rule) {
    if (rule.type !== 'style') return style;

    for (var prop in style) {
      var value = style[prop];

      var changeProp = false;
      var supportedProp = vendor.supportedProperty(prop);
      if (supportedProp && supportedProp !== prop) changeProp = true;

      var changeValue = false;
      var supportedValue = vendor.supportedValue(supportedProp, value);
      if (supportedValue && supportedValue !== value) changeValue = true;

      if (changeProp || changeValue) {
        if (changeProp) delete style[prop];
        style[supportedProp || prop] = supportedValue || value;
      }
    }

    return style;
  }

  function onChangeValue(value, prop) {
    return vendor.supportedValue(prop, value);
  }

  return { onProcessRule: onProcessRule, onProcessStyle: onProcessStyle, onChangeValue: onChangeValue };
}
},{"css-vendor":333}],355:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _isInBrowser = require('is-in-browser');

var _isInBrowser2 = _interopRequireDefault(_isInBrowser);

var _StyleSheet = require('./StyleSheet');

var _StyleSheet2 = _interopRequireDefault(_StyleSheet);

var _PluginsRegistry = require('./PluginsRegistry');

var _PluginsRegistry2 = _interopRequireDefault(_PluginsRegistry);

var _rules = require('./plugins/rules');

var _rules2 = _interopRequireDefault(_rules);

var _observables = require('./plugins/observables');

var _observables2 = _interopRequireDefault(_observables);

var _functions = require('./plugins/functions');

var _functions2 = _interopRequireDefault(_functions);

var _sheets = require('./sheets');

var _sheets2 = _interopRequireDefault(_sheets);

var _StyleRule = require('./rules/StyleRule');

var _StyleRule2 = _interopRequireDefault(_StyleRule);

var _createGenerateClassName = require('./utils/createGenerateClassName');

var _createGenerateClassName2 = _interopRequireDefault(_createGenerateClassName);

var _createRule2 = require('./utils/createRule');

var _createRule3 = _interopRequireDefault(_createRule2);

var _DomRenderer = require('./renderers/DomRenderer');

var _DomRenderer2 = _interopRequireDefault(_DomRenderer);

var _VirtualRenderer = require('./renderers/VirtualRenderer');

var _VirtualRenderer2 = _interopRequireDefault(_VirtualRenderer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var defaultPlugins = _rules2['default'].concat([_observables2['default'], _functions2['default']]);

var instanceCounter = 0;

var Jss = function () {
  function Jss(options) {
    _classCallCheck(this, Jss);

    this.id = instanceCounter++;
    this.version = "9.5.1";
    this.plugins = new _PluginsRegistry2['default']();
    this.options = {
      createGenerateClassName: _createGenerateClassName2['default'],
      Renderer: _isInBrowser2['default'] ? _DomRenderer2['default'] : _VirtualRenderer2['default'],
      plugins: []
    };
    this.generateClassName = (0, _createGenerateClassName2['default'])();

    // eslint-disable-next-line prefer-spread
    this.use.apply(this, defaultPlugins);
    this.setup(options);
  }

  _createClass(Jss, [{
    key: 'setup',
    value: function setup() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (options.createGenerateClassName) {
        this.options.createGenerateClassName = options.createGenerateClassName;
        // $FlowFixMe
        this.generateClassName = options.createGenerateClassName();
      }

      if (options.insertionPoint != null) this.options.insertionPoint = options.insertionPoint;
      if (options.virtual || options.Renderer) {
        this.options.Renderer = options.Renderer || (options.virtual ? _VirtualRenderer2['default'] : _DomRenderer2['default']);
      }

      // eslint-disable-next-line prefer-spread
      if (options.plugins) this.use.apply(this, options.plugins);

      return this;
    }

    /**
     * Create a Style Sheet.
     */

  }, {
    key: 'createStyleSheet',
    value: function createStyleSheet(styles) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var index = options.index;
      if (typeof index !== 'number') {
        index = _sheets2['default'].index === 0 ? 0 : _sheets2['default'].index + 1;
      }
      var sheet = new _StyleSheet2['default'](styles, _extends({}, options, {
        jss: this,
        generateClassName: options.generateClassName || this.generateClassName,
        insertionPoint: this.options.insertionPoint,
        Renderer: this.options.Renderer,
        index: index
      }));
      this.plugins.onProcessSheet(sheet);

      return sheet;
    }

    /**
     * Detach the Style Sheet and remove it from the registry.
     */

  }, {
    key: 'removeStyleSheet',
    value: function removeStyleSheet(sheet) {
      sheet.detach();
      _sheets2['default'].remove(sheet);
      return this;
    }

    /**
     * Create a rule without a Style Sheet.
     */

  }, {
    key: 'createRule',
    value: function createRule(name) {
      var style = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      // Enable rule without name for inline styles.
      if ((typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {
        options = style;
        style = name;
        name = undefined;
      }

      // Cast from RuleFactoryOptions to RuleOptions
      // https://stackoverflow.com/questions/41328728/force-casting-in-flow
      var ruleOptions = options;

      ruleOptions.jss = this;
      ruleOptions.Renderer = this.options.Renderer;
      if (!ruleOptions.generateClassName) ruleOptions.generateClassName = this.generateClassName;
      if (!ruleOptions.classes) ruleOptions.classes = {};
      var rule = (0, _createRule3['default'])(name, style, ruleOptions);

      if (!ruleOptions.selector && rule instanceof _StyleRule2['default']) {
        rule.selector = '.' + ruleOptions.generateClassName(rule);
      }

      this.plugins.onProcessRule(rule);

      return rule;
    }

    /**
     * Register plugin. Passed function will be invoked with a rule instance.
     */

  }, {
    key: 'use',
    value: function use() {
      var _this = this;

      for (var _len = arguments.length, plugins = Array(_len), _key = 0; _key < _len; _key++) {
        plugins[_key] = arguments[_key];
      }

      plugins.forEach(function (plugin) {
        // Avoids applying same plugin twice, at least based on ref.
        if (_this.options.plugins.indexOf(plugin) === -1) {
          _this.options.plugins.push(plugin);
          _this.plugins.use(plugin);
        }
      });

      return this;
    }
  }]);

  return Jss;
}();

exports['default'] = Jss;
},{"./PluginsRegistry":356,"./StyleSheet":360,"./plugins/functions":362,"./plugins/observables":363,"./plugins/rules":364,"./renderers/DomRenderer":365,"./renderers/VirtualRenderer":366,"./rules/StyleRule":371,"./sheets":373,"./utils/createGenerateClassName":375,"./utils/createRule":376,"is-in-browser":340}],356:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _warning = require('warning');

var _warning2 = _interopRequireDefault(_warning);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var PluginsRegistry = function () {
  function PluginsRegistry() {
    _classCallCheck(this, PluginsRegistry);

    this.hooks = {
      onCreateRule: [],
      onProcessRule: [],
      onProcessStyle: [],
      onProcessSheet: [],
      onChangeValue: [],
      onUpdate: []

      /**
       * Call `onCreateRule` hooks and return an object if returned by a hook.
       */
    };
  }

  _createClass(PluginsRegistry, [{
    key: 'onCreateRule',
    value: function onCreateRule(name, decl, options) {
      for (var i = 0; i < this.hooks.onCreateRule.length; i++) {
        var rule = this.hooks.onCreateRule[i](name, decl, options);
        if (rule) return rule;
      }
      return null;
    }

    /**
     * Call `onProcessRule` hooks.
     */

  }, {
    key: 'onProcessRule',
    value: function onProcessRule(rule) {
      if (rule.isProcessed) return;
      var sheet = rule.options.sheet;

      for (var i = 0; i < this.hooks.onProcessRule.length; i++) {
        this.hooks.onProcessRule[i](rule, sheet);
      }

      // $FlowFixMe
      if (rule.style) this.onProcessStyle(rule.style, rule, sheet);

      rule.isProcessed = true;
    }

    /**
     * Call `onProcessStyle` hooks.
     */

  }, {
    key: 'onProcessStyle',
    value: function onProcessStyle(style, rule, sheet) {
      var nextStyle = style;

      for (var i = 0; i < this.hooks.onProcessStyle.length; i++) {
        nextStyle = this.hooks.onProcessStyle[i](nextStyle, rule, sheet);
        // $FlowFixMe
        rule.style = nextStyle;
      }
    }

    /**
     * Call `onProcessSheet` hooks.
     */

  }, {
    key: 'onProcessSheet',
    value: function onProcessSheet(sheet) {
      for (var i = 0; i < this.hooks.onProcessSheet.length; i++) {
        this.hooks.onProcessSheet[i](sheet);
      }
    }

    /**
     * Call `onUpdate` hooks.
     */

  }, {
    key: 'onUpdate',
    value: function onUpdate(data, rule, sheet) {
      for (var i = 0; i < this.hooks.onUpdate.length; i++) {
        this.hooks.onUpdate[i](data, rule, sheet);
      }
    }

    /**
     * Call `onChangeValue` hooks.
     */

  }, {
    key: 'onChangeValue',
    value: function onChangeValue(value, prop, rule) {
      var processedValue = value;
      for (var i = 0; i < this.hooks.onChangeValue.length; i++) {
        processedValue = this.hooks.onChangeValue[i](processedValue, prop, rule);
      }
      return processedValue;
    }

    /**
     * Register a plugin.
     * If function is passed, it is a shortcut for `{onProcessRule}`.
     */

  }, {
    key: 'use',
    value: function use(plugin) {
      for (var name in plugin) {
        if (this.hooks[name]) this.hooks[name].push(plugin[name]);else (0, _warning2['default'])(false, '[JSS] Unknown hook "%s".', name);
      }
    }
  }]);

  return PluginsRegistry;
}();

exports['default'] = PluginsRegistry;
},{"warning":391}],357:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _createRule = require('./utils/createRule');

var _createRule2 = _interopRequireDefault(_createRule);

var _linkRule = require('./utils/linkRule');

var _linkRule2 = _interopRequireDefault(_linkRule);

var _StyleRule = require('./rules/StyleRule');

var _StyleRule2 = _interopRequireDefault(_StyleRule);

var _escape = require('./utils/escape');

var _escape2 = _interopRequireDefault(_escape);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Contains rules objects and allows adding/removing etc.
 * Is used for e.g. by `StyleSheet` or `ConditionalRule`.
 */
var RuleList = function () {

  // Original styles object.
  function RuleList(options) {
    _classCallCheck(this, RuleList);

    this.map = {};
    this.raw = {};
    this.index = [];

    this.options = options;
    this.classes = options.classes;
  }

  /**
   * Create and register rule.
   *
   * Will not render after Style Sheet was rendered the first time.
   */


  // Used to ensure correct rules order.

  // Rules registry for access by .get() method.
  // It contains the same rule registered by name and by selector.


  _createClass(RuleList, [{
    key: 'add',
    value: function add(name, decl, options) {
      var _options = this.options,
          parent = _options.parent,
          sheet = _options.sheet,
          jss = _options.jss,
          Renderer = _options.Renderer,
          generateClassName = _options.generateClassName;


      options = _extends({
        classes: this.classes,
        parent: parent,
        sheet: sheet,
        jss: jss,
        Renderer: Renderer,
        generateClassName: generateClassName
      }, options);

      if (!options.selector && this.classes[name]) {
        options.selector = '.' + (0, _escape2['default'])(this.classes[name]);
      }

      this.raw[name] = decl;

      var rule = (0, _createRule2['default'])(name, decl, options);

      var className = void 0;

      if (!options.selector && rule instanceof _StyleRule2['default']) {
        className = generateClassName(rule, sheet);
        rule.selector = '.' + (0, _escape2['default'])(className);
      }

      this.register(rule, className);

      var index = options.index === undefined ? this.index.length : options.index;
      this.index.splice(index, 0, rule);

      return rule;
    }

    /**
     * Get a rule.
     */

  }, {
    key: 'get',
    value: function get(name) {
      return this.map[name];
    }

    /**
     * Delete a rule.
     */

  }, {
    key: 'remove',
    value: function remove(rule) {
      this.unregister(rule);
      this.index.splice(this.indexOf(rule), 1);
    }

    /**
     * Get index of a rule.
     */

  }, {
    key: 'indexOf',
    value: function indexOf(rule) {
      return this.index.indexOf(rule);
    }

    /**
     * Run `onProcessRule()` plugins on every rule.
     */

  }, {
    key: 'process',
    value: function process() {
      var plugins = this.options.jss.plugins;
      // We need to clone array because if we modify the index somewhere else during a loop
      // we end up with very hard-to-track-down side effects.

      this.index.slice(0).forEach(plugins.onProcessRule, plugins);
    }

    /**
     * Register a rule in `.map` and `.classes` maps.
     */

  }, {
    key: 'register',
    value: function register(rule, className) {
      this.map[rule.key] = rule;
      if (rule instanceof _StyleRule2['default']) {
        this.map[rule.selector] = rule;
        if (className) this.classes[rule.key] = className;
      }
    }

    /**
     * Unregister a rule.
     */

  }, {
    key: 'unregister',
    value: function unregister(rule) {
      delete this.map[rule.key];
      if (rule instanceof _StyleRule2['default']) {
        delete this.map[rule.selector];
        delete this.classes[rule.key];
      }
    }

    /**
     * Update the function values with a new data.
     */

  }, {
    key: 'update',
    value: function update(name, data) {
      var _options2 = this.options,
          plugins = _options2.jss.plugins,
          sheet = _options2.sheet;

      if (typeof name === 'string') {
        plugins.onUpdate(data, this.get(name), sheet);
        return;
      }

      for (var index = 0; index < this.index.length; index++) {
        plugins.onUpdate(name, this.index[index], sheet);
      }
    }

    /**
     * Link renderable rules with CSSRuleList.
     */

  }, {
    key: 'link',
    value: function link(cssRules) {
      var map = this.options.sheet.renderer.getUnescapedKeysMap(this.index);

      for (var i = 0; i < cssRules.length; i++) {
        var cssRule = cssRules[i];
        var _key = this.options.sheet.renderer.getKey(cssRule);
        if (map[_key]) _key = map[_key];
        var rule = this.map[_key];
        if (rule) (0, _linkRule2['default'])(rule, cssRule);
      }
    }

    /**
     * Convert rules to a CSS string.
     */

  }, {
    key: 'toString',
    value: function toString(options) {
      var str = '';
      var sheet = this.options.sheet;

      var link = sheet ? sheet.options.link : false;

      for (var index = 0; index < this.index.length; index++) {
        var rule = this.index[index];
        var css = rule.toString(options);

        // No need to render an empty rule.
        if (!css && !link) continue;

        if (str) str += '\n';
        str += css;
      }

      return str;
    }
  }]);

  return RuleList;
}();

exports['default'] = RuleList;
},{"./rules/StyleRule":371,"./utils/createRule":376,"./utils/escape":377,"./utils/linkRule":381}],358:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _warning = require('warning');

var _warning2 = _interopRequireDefault(_warning);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * SheetsManager is like a WeakMap which is designed to count StyleSheet
 * instances and attach/detach automatically.
 */
var SheetsManager = function () {
  function SheetsManager() {
    _classCallCheck(this, SheetsManager);

    this.sheets = [];
    this.refs = [];
    this.keys = [];
  }

  _createClass(SheetsManager, [{
    key: 'get',
    value: function get(key) {
      var index = this.keys.indexOf(key);
      return this.sheets[index];
    }
  }, {
    key: 'add',
    value: function add(key, sheet) {
      var sheets = this.sheets,
          refs = this.refs,
          keys = this.keys;

      var index = sheets.indexOf(sheet);

      if (index !== -1) return index;

      sheets.push(sheet);
      refs.push(0);
      keys.push(key);

      return sheets.length - 1;
    }
  }, {
    key: 'manage',
    value: function manage(key) {
      var index = this.keys.indexOf(key);
      var sheet = this.sheets[index];
      if (this.refs[index] === 0) sheet.attach();
      this.refs[index]++;
      if (!this.keys[index]) this.keys.splice(index, 0, key);
      return sheet;
    }
  }, {
    key: 'unmanage',
    value: function unmanage(key) {
      var index = this.keys.indexOf(key);
      if (index === -1) {
        // eslint-ignore-next-line no-console
        (0, _warning2['default'])(false, 'SheetsManager: can\'t find sheet to unmanage');
        return;
      }
      if (this.refs[index] > 0) {
        this.refs[index]--;
        if (this.refs[index] === 0) this.sheets[index].detach();
      }
    }
  }, {
    key: 'size',
    get: function get() {
      return this.keys.length;
    }
  }]);

  return SheetsManager;
}();

exports['default'] = SheetsManager;
},{"warning":391}],359:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Sheets registry to access them all at one place.
 */
var SheetsRegistry = function () {
  function SheetsRegistry() {
    _classCallCheck(this, SheetsRegistry);

    this.registry = [];
  }

  _createClass(SheetsRegistry, [{
    key: 'add',


    /**
     * Register a Style Sheet.
     */
    value: function add(sheet) {
      var registry = this.registry;
      var index = sheet.options.index;


      if (registry.indexOf(sheet) !== -1) return;

      if (registry.length === 0 || index >= this.index) {
        registry.push(sheet);
        return;
      }

      // Find a position.
      for (var i = 0; i < registry.length; i++) {
        if (registry[i].options.index > index) {
          registry.splice(i, 0, sheet);
          return;
        }
      }
    }

    /**
     * Reset the registry.
     */

  }, {
    key: 'reset',
    value: function reset() {
      this.registry = [];
    }

    /**
     * Remove a Style Sheet.
     */

  }, {
    key: 'remove',
    value: function remove(sheet) {
      var index = this.registry.indexOf(sheet);
      this.registry.splice(index, 1);
    }

    /**
     * Convert all attached sheets to a CSS string.
     */

  }, {
    key: 'toString',
    value: function toString(options) {
      return this.registry.filter(function (sheet) {
        return sheet.attached;
      }).map(function (sheet) {
        return sheet.toString(options);
      }).join('\n');
    }
  }, {
    key: 'index',


    /**
     * Current highest index number.
     */
    get: function get() {
      return this.registry.length === 0 ? 0 : this.registry[this.registry.length - 1].options.index;
    }
  }]);

  return SheetsRegistry;
}();

exports['default'] = SheetsRegistry;
},{}],360:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _linkRule = require('./utils/linkRule');

var _linkRule2 = _interopRequireDefault(_linkRule);

var _RuleList = require('./RuleList');

var _RuleList2 = _interopRequireDefault(_RuleList);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var StyleSheet = function () {
  function StyleSheet(styles, options) {
    _classCallCheck(this, StyleSheet);

    this.attached = false;
    this.deployed = false;
    this.linked = false;
    this.classes = {};
    this.options = _extends({}, options, {
      sheet: this,
      parent: this,
      classes: this.classes
    });
    this.renderer = new options.Renderer(this);
    this.rules = new _RuleList2['default'](this.options);

    for (var name in styles) {
      this.rules.add(name, styles[name]);
    }

    this.rules.process();
  }

  /**
   * Attach renderable to the render tree.
   */


  _createClass(StyleSheet, [{
    key: 'attach',
    value: function attach() {
      if (this.attached) return this;
      if (!this.deployed) this.deploy();
      this.renderer.attach();
      if (!this.linked && this.options.link) this.link();
      this.attached = true;
      return this;
    }

    /**
     * Remove renderable from render tree.
     */

  }, {
    key: 'detach',
    value: function detach() {
      if (!this.attached) return this;
      this.renderer.detach();
      this.attached = false;
      return this;
    }

    /**
     * Add a rule to the current stylesheet.
     * Will insert a rule also after the stylesheet has been rendered first time.
     */

  }, {
    key: 'addRule',
    value: function addRule(name, decl, options) {
      var queue = this.queue;

      // Plugins can create rules.
      // In order to preserve the right order, we need to queue all `.addRule` calls,
      // which happen after the first `rules.add()` call.

      if (this.attached && !queue) this.queue = [];

      var rule = this.rules.add(name, decl, options);
      this.options.jss.plugins.onProcessRule(rule);

      if (this.attached) {
        if (!this.deployed) return rule;
        // Don't insert rule directly if there is no stringified version yet.
        // It will be inserted all together when .attach is called.
        if (queue) queue.push(rule);else {
          this.insertRule(rule);
          if (this.queue) {
            this.queue.forEach(this.insertRule, this);
            this.queue = undefined;
          }
        }
        return rule;
      }

      // We can't add rules to a detached style node.
      // We will redeploy the sheet once user will attach it.
      this.deployed = false;

      return rule;
    }

    /**
     * Insert rule into the StyleSheet
     */

  }, {
    key: 'insertRule',
    value: function insertRule(rule) {
      var renderable = this.renderer.insertRule(rule);
      if (renderable && this.options.link) (0, _linkRule2['default'])(rule, renderable);
    }

    /**
     * Create and add rules.
     * Will render also after Style Sheet was rendered the first time.
     */

  }, {
    key: 'addRules',
    value: function addRules(styles, options) {
      var added = [];
      for (var name in styles) {
        added.push(this.addRule(name, styles[name], options));
      }
      return added;
    }

    /**
     * Get a rule by name.
     */

  }, {
    key: 'getRule',
    value: function getRule(name) {
      return this.rules.get(name);
    }

    /**
     * Delete a rule by name.
     * Returns `true`: if rule has been deleted from the DOM.
     */

  }, {
    key: 'deleteRule',
    value: function deleteRule(name) {
      var rule = this.rules.get(name);

      if (!rule) return false;

      this.rules.remove(rule);

      if (this.attached && rule.renderable) {
        return this.renderer.deleteRule(rule.renderable);
      }

      return true;
    }

    /**
     * Get index of a rule.
     */

  }, {
    key: 'indexOf',
    value: function indexOf(rule) {
      return this.rules.indexOf(rule);
    }

    /**
     * Deploy pure CSS string to a renderable.
     */

  }, {
    key: 'deploy',
    value: function deploy() {
      this.renderer.deploy();
      this.deployed = true;
      return this;
    }

    /**
     * Link renderable CSS rules from sheet with their corresponding models.
     */

  }, {
    key: 'link',
    value: function link() {
      var cssRules = this.renderer.getRules();

      // Is undefined when VirtualRenderer is used.
      if (cssRules) this.rules.link(cssRules);
      this.linked = true;
      return this;
    }

    /**
     * Update the function values with a new data.
     */

  }, {
    key: 'update',
    value: function update(name, data) {
      this.rules.update(name, data);
      return this;
    }

    /**
     * Convert rules to a CSS string.
     */

  }, {
    key: 'toString',
    value: function toString(options) {
      return this.rules.toString(options);
    }
  }]);

  return StyleSheet;
}();

exports['default'] = StyleSheet;
},{"./RuleList":357,"./utils/linkRule":381}],361:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.create = exports.createGenerateClassName = exports.sheets = exports.RuleList = exports.SheetsManager = exports.SheetsRegistry = exports.toCssValue = exports.getDynamicStyles = undefined;

var _getDynamicStyles = require('./utils/getDynamicStyles');

Object.defineProperty(exports, 'getDynamicStyles', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_getDynamicStyles)['default'];
  }
});

var _toCssValue = require('./utils/toCssValue');

Object.defineProperty(exports, 'toCssValue', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_toCssValue)['default'];
  }
});

var _SheetsRegistry = require('./SheetsRegistry');

Object.defineProperty(exports, 'SheetsRegistry', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_SheetsRegistry)['default'];
  }
});

var _SheetsManager = require('./SheetsManager');

Object.defineProperty(exports, 'SheetsManager', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_SheetsManager)['default'];
  }
});

var _RuleList = require('./RuleList');

Object.defineProperty(exports, 'RuleList', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_RuleList)['default'];
  }
});

var _sheets = require('./sheets');

Object.defineProperty(exports, 'sheets', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_sheets)['default'];
  }
});

var _createGenerateClassName = require('./utils/createGenerateClassName');

Object.defineProperty(exports, 'createGenerateClassName', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_createGenerateClassName)['default'];
  }
});

var _Jss = require('./Jss');

var _Jss2 = _interopRequireDefault(_Jss);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/**
 * Creates a new instance of Jss.
 */
var create = exports.create = function create(options) {
  return new _Jss2['default'](options);
};

/**
 * A global Jss instance.
 */
exports['default'] = create();
},{"./Jss":355,"./RuleList":357,"./SheetsManager":358,"./SheetsRegistry":359,"./sheets":373,"./utils/createGenerateClassName":375,"./utils/getDynamicStyles":378,"./utils/toCssValue":384}],362:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _RuleList = require('../RuleList');

var _RuleList2 = _interopRequireDefault(_RuleList);

var _StyleRule = require('../rules/StyleRule');

var _StyleRule2 = _interopRequireDefault(_StyleRule);

var _kebabCase = require('../utils/kebabCase');

var _kebabCase2 = _interopRequireDefault(_kebabCase);

var _createRule = require('../utils/createRule');

var _createRule2 = _interopRequireDefault(_createRule);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

// A symbol replacement.
var now = Date.now();
var fnValuesNs = 'fnValues' + now;
var fnStyleNs = 'fnStyle' + ++now;

exports['default'] = {
  onCreateRule: function onCreateRule(name, decl, options) {
    if (typeof decl !== 'function') return null;
    var rule = (0, _createRule2['default'])(name, {}, options);
    rule[fnStyleNs] = decl;
    return rule;
  },
  onProcessStyle: function onProcessStyle(style, rule) {
    var fn = {};
    for (var prop in style) {
      var value = style[prop];
      if (typeof value !== 'function') continue;
      delete style[prop];
      fn[(0, _kebabCase2['default'])(prop)] = value;
    }
    rule = rule;
    rule[fnValuesNs] = fn;
    return style;
  },
  onUpdate: function onUpdate(data, rule) {
    // It is a rules container like for e.g. ConditionalRule.
    if (rule.rules instanceof _RuleList2['default']) {
      rule.rules.update(data);
      return;
    }
    if (!(rule instanceof _StyleRule2['default'])) return;

    rule = rule;

    // If we have a fn values map, it is a rule with function values.
    if (rule[fnValuesNs]) {
      for (var prop in rule[fnValuesNs]) {
        rule.prop(prop, rule[fnValuesNs][prop](data));
      }
    }

    rule = rule;

    var fnStyle = rule[fnStyleNs];

    // If we have a style function, the entire rule is dynamic and style object
    // will be returned from that function.
    if (fnStyle) {
      var style = fnStyle(data);
      for (var _prop in style) {
        rule.prop(_prop, style[_prop]);
      }
    }
  }
};
},{"../RuleList":357,"../rules/StyleRule":371,"../utils/createRule":376,"../utils/kebabCase":380}],363:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _StyleRule = require('../rules/StyleRule');

var _StyleRule2 = _interopRequireDefault(_StyleRule);

var _createRule = require('../utils/createRule');

var _createRule2 = _interopRequireDefault(_createRule);

var _isObservable = require('../utils/isObservable');

var _isObservable2 = _interopRequireDefault(_isObservable);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

exports['default'] = {
  onCreateRule: function onCreateRule(name, decl, options) {
    if (!(0, _isObservable2['default'])(decl)) return null;

    // Cast `decl` to `Observable`, since it passed the type guard.
    var style$ = decl;

    var rule = (0, _createRule2['default'])(name, {}, options);

    // TODO
    // Call `stream.subscribe()` returns a subscription, which should be explicitly
    // unsubscribed from when we know this sheet is no longer needed.
    style$.subscribe(function (style) {
      for (var prop in style) {
        rule.prop(prop, style[prop]);
      }
    });

    return rule;
  },
  onProcessRule: function onProcessRule(rule) {
    if (!(rule instanceof _StyleRule2['default'])) return;
    var styleRule = rule;
    var style = styleRule.style;

    var _loop = function _loop(prop) {
      var value = style[prop];
      if (!(0, _isObservable2['default'])(value)) return 'continue';
      delete style[prop];
      value.subscribe({
        next: function next(nextValue) {
          styleRule.prop(prop, nextValue);
        }
      });
    };

    for (var prop in style) {
      var _ret = _loop(prop);

      if (_ret === 'continue') continue;
    }
  }
};
},{"../rules/StyleRule":371,"../utils/createRule":376,"../utils/isObservable":379}],364:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _SimpleRule = require('../rules/SimpleRule');

var _SimpleRule2 = _interopRequireDefault(_SimpleRule);

var _KeyframesRule = require('../rules/KeyframesRule');

var _KeyframesRule2 = _interopRequireDefault(_KeyframesRule);

var _ConditionalRule = require('../rules/ConditionalRule');

var _ConditionalRule2 = _interopRequireDefault(_ConditionalRule);

var _FontFaceRule = require('../rules/FontFaceRule');

var _FontFaceRule2 = _interopRequireDefault(_FontFaceRule);

var _ViewportRule = require('../rules/ViewportRule');

var _ViewportRule2 = _interopRequireDefault(_ViewportRule);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var classes = {
  '@charset': _SimpleRule2['default'],
  '@import': _SimpleRule2['default'],
  '@namespace': _SimpleRule2['default'],
  '@keyframes': _KeyframesRule2['default'],
  '@media': _ConditionalRule2['default'],
  '@supports': _ConditionalRule2['default'],
  '@font-face': _FontFaceRule2['default'],
  '@viewport': _ViewportRule2['default'],
  '@-ms-viewport': _ViewportRule2['default']

  /**
   * Generate plugins which will register all rules.
   */
};
exports['default'] = Object.keys(classes).map(function (key) {
  // https://jsperf.com/indexof-vs-substr-vs-regex-at-the-beginning-3
  var re = new RegExp('^' + key);
  var onCreateRule = function onCreateRule(name, decl, options) {
    return re.test(name) ? new classes[key](name, decl, options) : null;
  };
  return { onCreateRule: onCreateRule };
});
},{"../rules/ConditionalRule":367,"../rules/FontFaceRule":368,"../rules/KeyframesRule":369,"../rules/SimpleRule":370,"../rules/ViewportRule":372}],365:[function(require,module,exports){
(function (global){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _warning = require('warning');

var _warning2 = _interopRequireDefault(_warning);

var _sheets = require('../sheets');

var _sheets2 = _interopRequireDefault(_sheets);

var _StyleRule = require('../rules/StyleRule');

var _StyleRule2 = _interopRequireDefault(_StyleRule);

var _toCssValue = require('../utils/toCssValue');

var _toCssValue2 = _interopRequireDefault(_toCssValue);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Get a style property.
 */
function getStyle(cssRule, prop) {
  try {
    return cssRule.style.getPropertyValue(prop);
  } catch (err) {
    // IE may throw if property is unknown.
    return '';
  }
}

/**
 * Set a style property.
 */
function setStyle(cssRule, prop, value) {
  try {
    var cssValue = value;

    if (Array.isArray(value)) {
      cssValue = (0, _toCssValue2['default'])(value, true);

      if (value[value.length - 1] === '!important') {
        cssRule.style.setProperty(prop, cssValue, 'important');
        return true;
      }
    }

    cssRule.style.setProperty(prop, cssValue);
  } catch (err) {
    // IE may throw if property is unknown.
    return false;
  }
  return true;
}

var CSSRuleTypes = {
  STYLE_RULE: 1,
  KEYFRAMES_RULE: 7

  /**
   * Get the CSS Rule key.
   */

};var getKey = function () {
  var extractKey = function extractKey(cssText) {
    var from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    return cssText.substr(from, cssText.indexOf('{') - 1);
  };

  return function (cssRule) {
    if (cssRule.type === CSSRuleTypes.STYLE_RULE) return cssRule.selectorText;
    if (cssRule.type === CSSRuleTypes.KEYFRAMES_RULE) {
      var name = cssRule.name;

      if (name) return '@keyframes ' + name;

      // There is no rule.name in the following browsers:
      // - IE 9
      // - Safari 7.1.8
      // - Mobile Safari 9.0.0
      var cssText = cssRule.cssText;

      return '@' + extractKey(cssText, cssText.indexOf('keyframes'));
    }

    // Conditionals.
    return extractKey(cssRule.cssText);
  };
}();

/**
 * Set the selector.
 */
function setSelector(cssRule, selectorText) {
  cssRule.selectorText = selectorText;

  // Return false if setter was not successful.
  // Currently works in chrome only.
  return cssRule.selectorText === selectorText;
}

/**
 * Gets the `head` element upon the first call and caches it.
 */
var getHead = function () {
  var head = void 0;
  return function () {
    if (!head) head = document.head || document.getElementsByTagName('head')[0];
    return head;
  };
}();

/**
 * Gets a map of rule keys, where the property is an unescaped key and value
 * is a potentially escaped one.
 * It is used to identify CSS rules and the corresponding JSS rules. As an identifier
 * for CSSStyleRule we normally use `selectorText`. Though if original selector text
 * contains escaped code points e.g. `:not(#\\20)`, CSSOM will compile it to `:not(# )`
 * and so CSS rule's `selectorText` won't match JSS rule selector.
 *
 * https://www.w3.org/International/questions/qa-escapes#cssescapes
 */
var getUnescapedKeysMap = function () {
  var style = void 0;
  var isAttached = false;

  return function (rules) {
    var map = {};
    // https://github.com/facebook/flow/issues/2696
    if (!style) style = document.createElement('style');
    for (var i = 0; i < rules.length; i++) {
      var rule = rules[i];
      if (!(rule instanceof _StyleRule2['default'])) continue;
      var selector = rule.selector;
      // Only unescape selector over CSSOM if it contains a back slash.

      if (selector && selector.indexOf('\\') !== -1) {
        // Lazilly attach when needed.
        if (!isAttached) {
          getHead().appendChild(style);
          isAttached = true;
        }
        style.textContent = selector + ' {}';
        var _style = style,
            sheet = _style.sheet;

        if (sheet) {
          var cssRules = sheet.cssRules;

          if (cssRules) map[cssRules[0].selectorText] = rule.key;
        }
      }
    }
    if (isAttached) {
      getHead().removeChild(style);
      isAttached = false;
    }
    return map;
  };
}();

/**
 * Find attached sheet with an index higher than the passed one.
 */
function findHigherSheet(registry, options) {
  for (var i = 0; i < registry.length; i++) {
    var sheet = registry[i];
    if (sheet.attached && sheet.options.index > options.index && sheet.options.insertionPoint === options.insertionPoint) {
      return sheet;
    }
  }
  return null;
}

/**
 * Find attached sheet with the highest index.
 */
function findHighestSheet(registry, options) {
  for (var i = registry.length - 1; i >= 0; i--) {
    var sheet = registry[i];
    if (sheet.attached && sheet.options.insertionPoint === options.insertionPoint) {
      return sheet;
    }
  }
  return null;
}

/**
 * Find a comment with "jss" inside.
 */
function findCommentNode(text) {
  var head = getHead();
  for (var i = 0; i < head.childNodes.length; i++) {
    var node = head.childNodes[i];
    if (node.nodeType === 8 && node.nodeValue.trim() === text) {
      return node;
    }
  }
  return null;
}

/**
 * Find a node before which we can insert the sheet.
 */
function findPrevNode(options) {
  var registry = _sheets2['default'].registry;


  if (registry.length > 0) {
    // Try to insert before the next higher sheet.
    var sheet = findHigherSheet(registry, options);
    if (sheet) return sheet.renderer.element;

    // Otherwise insert after the last attached.
    sheet = findHighestSheet(registry, options);
    if (sheet) return sheet.renderer.element.nextElementSibling;
  }

  // Try to find a comment placeholder if registry is empty.
  var insertionPoint = options.insertionPoint;

  if (insertionPoint && typeof insertionPoint === 'string') {
    var comment = findCommentNode(insertionPoint);
    if (comment) return comment.nextSibling;
    // If user specifies an insertion point and it can't be found in the document -
    // bad specificity issues may appear.
    (0, _warning2['default'])(insertionPoint === 'jss', '[JSS] Insertion point "%s" not found.', insertionPoint);
  }

  return null;
}

/**
 * Insert style element into the DOM.
 */
function insertStyle(style, options) {
  var insertionPoint = options.insertionPoint;

  var prevNode = findPrevNode(options);

  if (prevNode) {
    var parentNode = prevNode.parentNode;

    if (parentNode) parentNode.insertBefore(style, prevNode);
    return;
  }

  // Works with iframes and any node types.
  if (insertionPoint && typeof insertionPoint.nodeType === 'number') {
    // https://stackoverflow.com/questions/41328728/force-casting-in-flow
    var insertionPointElement = insertionPoint;
    var _parentNode = insertionPointElement.parentNode;

    if (_parentNode) _parentNode.insertBefore(style, insertionPointElement.nextSibling);else (0, _warning2['default'])(false, '[JSS] Insertion point is not in the DOM.');
    return;
  }

  getHead().insertBefore(style, prevNode);
}

var DomRenderer = function () {
  function DomRenderer(sheet) {
    _classCallCheck(this, DomRenderer);

    this.getStyle = getStyle;
    this.setStyle = setStyle;
    this.setSelector = setSelector;
    this.getKey = getKey;
    this.getUnescapedKeysMap = getUnescapedKeysMap;
    this.hasInsertedRules = false;

    // There is no sheet when the renderer is used from a standalone StyleRule.
    if (sheet) _sheets2['default'].add(sheet);

    this.sheet = sheet;

    var _ref = this.sheet ? this.sheet.options : {},
        media = _ref.media,
        meta = _ref.meta,
        element = _ref.element;

    this.element = element || document.createElement('style');
    this.element.type = 'text/css';
    this.element.setAttribute('data-jss', '');
    if (media) this.element.setAttribute('media', media);
    if (meta) this.element.setAttribute('data-meta', meta);
    // eslint-disable-next-line no-underscore-dangle
    var nonce = global.__webpack_nonce__;
    if (nonce) this.element.setAttribute('nonce', nonce);
  }

  /**
   * Insert style element into render tree.
   */


  // HTMLStyleElement needs fixing https://github.com/facebook/flow/issues/2696


  _createClass(DomRenderer, [{
    key: 'attach',
    value: function attach() {
      // In the case the element node is external and it is already in the DOM.
      if (this.element.parentNode || !this.sheet) return;

      // When rules are inserted using `insertRule` API, after `sheet.detach().attach()`
      // browsers remove those rules.
      // TODO figure out if its a bug and if it is known.
      // Workaround is to redeploy the sheet before attaching as a string.
      if (this.hasInsertedRules) {
        this.deploy();
        this.hasInsertedRules = false;
      }

      insertStyle(this.element, this.sheet.options);
    }

    /**
     * Remove style element from render tree.
     */

  }, {
    key: 'detach',
    value: function detach() {
      this.element.parentNode.removeChild(this.element);
    }

    /**
     * Inject CSS string into element.
     */

  }, {
    key: 'deploy',
    value: function deploy() {
      if (!this.sheet) return;
      this.element.textContent = '\n' + this.sheet.toString() + '\n';
    }

    /**
     * Insert a rule into element.
     */

  }, {
    key: 'insertRule',
    value: function insertRule(rule, index) {
      var sheet = this.element.sheet;
      var cssRules = sheet.cssRules;

      var str = rule.toString();
      if (!index) index = cssRules.length;

      if (!str) return false;

      try {
        sheet.insertRule(str, index);
      } catch (err) {
        (0, _warning2['default'])(false, '[JSS] Can not insert an unsupported rule \n\r%s', rule);
        return false;
      }
      this.hasInsertedRules = true;

      return cssRules[index];
    }

    /**
     * Delete a rule.
     */

  }, {
    key: 'deleteRule',
    value: function deleteRule(cssRule) {
      var sheet = this.element.sheet;

      var index = this.indexOf(cssRule);
      if (index === -1) return false;
      sheet.deleteRule(index);
      return true;
    }

    /**
     * Get index of a CSS Rule.
     */

  }, {
    key: 'indexOf',
    value: function indexOf(cssRule) {
      var cssRules = this.element.sheet.cssRules;

      for (var _index = 0; _index < cssRules.length; _index++) {
        if (cssRule === cssRules[_index]) return _index;
      }
      return -1;
    }

    /**
     * Generate a new CSS rule and replace the existing one.
     */

  }, {
    key: 'replaceRule',
    value: function replaceRule(cssRule, rule) {
      var index = this.indexOf(cssRule);
      var newCssRule = this.insertRule(rule, index);
      this.element.sheet.deleteRule(index);
      return newCssRule;
    }

    /**
     * Get all rules elements.
     */

  }, {
    key: 'getRules',
    value: function getRules() {
      return this.element.sheet.cssRules;
    }
  }]);

  return DomRenderer;
}();

exports['default'] = DomRenderer;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../rules/StyleRule":371,"../sheets":373,"../utils/toCssValue":384,"warning":391}],366:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/* eslint-disable class-methods-use-this */

/**
 * Rendering backend to do nothing in nodejs.
 */
var VirtualRenderer = function () {
  function VirtualRenderer() {
    _classCallCheck(this, VirtualRenderer);
  }

  _createClass(VirtualRenderer, [{
    key: 'setStyle',
    value: function setStyle() {
      return true;
    }
  }, {
    key: 'getStyle',
    value: function getStyle() {
      return '';
    }
  }, {
    key: 'setSelector',
    value: function setSelector() {
      return true;
    }
  }, {
    key: 'getKey',
    value: function getKey() {
      return '';
    }
  }, {
    key: 'attach',
    value: function attach() {}
  }, {
    key: 'detach',
    value: function detach() {}
  }, {
    key: 'deploy',
    value: function deploy() {}
  }, {
    key: 'insertRule',
    value: function insertRule() {
      return false;
    }
  }, {
    key: 'deleteRule',
    value: function deleteRule() {
      return true;
    }
  }, {
    key: 'replaceRule',
    value: function replaceRule() {
      return false;
    }
  }, {
    key: 'getRules',
    value: function getRules() {}
  }, {
    key: 'indexOf',
    value: function indexOf() {
      return -1;
    }
  }]);

  return VirtualRenderer;
}();

exports['default'] = VirtualRenderer;
},{}],367:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _RuleList = require('../RuleList');

var _RuleList2 = _interopRequireDefault(_RuleList);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Conditional rule for @media, @supports
 */
var ConditionalRule = function () {
  function ConditionalRule(key, styles, options) {
    _classCallCheck(this, ConditionalRule);

    this.type = 'conditional';
    this.isProcessed = false;

    this.key = key;
    this.options = options;
    this.rules = new _RuleList2['default'](_extends({}, options, { parent: this }));

    for (var name in styles) {
      this.rules.add(name, styles[name]);
    }

    this.rules.process();
  }

  /**
   * Get a rule.
   */


  _createClass(ConditionalRule, [{
    key: 'getRule',
    value: function getRule(name) {
      return this.rules.get(name);
    }

    /**
     * Get index of a rule.
     */

  }, {
    key: 'indexOf',
    value: function indexOf(rule) {
      return this.rules.indexOf(rule);
    }

    /**
     * Create and register rule, run plugins.
     */

  }, {
    key: 'addRule',
    value: function addRule(name, style, options) {
      var rule = this.rules.add(name, style, options);
      this.options.jss.plugins.onProcessRule(rule);
      return rule;
    }

    /**
     * Generates a CSS string.
     */

  }, {
    key: 'toString',
    value: function toString() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { indent: 1 };

      var inner = this.rules.toString(options);
      return inner ? this.key + ' {\n' + inner + '\n}' : '';
    }
  }]);

  return ConditionalRule;
}();

exports['default'] = ConditionalRule;
},{"../RuleList":357}],368:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _toCss = require('../utils/toCss');

var _toCss2 = _interopRequireDefault(_toCss);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var FontFaceRule = function () {
  function FontFaceRule(key, style, options) {
    _classCallCheck(this, FontFaceRule);

    this.type = 'font-face';
    this.isProcessed = false;

    this.key = key;
    this.style = style;
    this.options = options;
  }

  /**
   * Generates a CSS string.
   */


  _createClass(FontFaceRule, [{
    key: 'toString',
    value: function toString(options) {
      if (Array.isArray(this.style)) {
        var str = '';
        for (var index = 0; index < this.style.length; index++) {
          str += (0, _toCss2['default'])(this.key, this.style[index]);
          if (this.style[index + 1]) str += '\n';
        }
        return str;
      }

      return (0, _toCss2['default'])(this.key, this.style, options);
    }
  }]);

  return FontFaceRule;
}();

exports['default'] = FontFaceRule;
},{"../utils/toCss":383}],369:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _RuleList = require('../RuleList');

var _RuleList2 = _interopRequireDefault(_RuleList);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Rule for @keyframes
 */
var KeyframesRule = function () {
  function KeyframesRule(key, frames, options) {
    _classCallCheck(this, KeyframesRule);

    this.type = 'keyframes';
    this.isProcessed = false;

    this.key = key;
    this.options = options;
    this.rules = new _RuleList2['default'](_extends({}, options, { parent: this }));

    for (var name in frames) {
      this.rules.add(name, frames[name], _extends({}, this.options, {
        parent: this,
        selector: name
      }));
    }

    this.rules.process();
  }

  /**
   * Generates a CSS string.
   */


  _createClass(KeyframesRule, [{
    key: 'toString',
    value: function toString() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { indent: 1 };

      var inner = this.rules.toString(options);
      if (inner) inner += '\n';
      return this.key + ' {\n' + inner + '}';
    }
  }]);

  return KeyframesRule;
}();

exports['default'] = KeyframesRule;
},{"../RuleList":357}],370:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var SimpleRule = function () {
  function SimpleRule(key, value, options) {
    _classCallCheck(this, SimpleRule);

    this.type = 'simple';
    this.isProcessed = false;

    this.key = key;
    this.value = value;
    this.options = options;
  }

  /**
   * Generates a CSS string.
   */
  // eslint-disable-next-line no-unused-vars


  _createClass(SimpleRule, [{
    key: 'toString',
    value: function toString(options) {
      if (Array.isArray(this.value)) {
        var str = '';
        for (var index = 0; index < this.value.length; index++) {
          str += this.key + ' ' + this.value[index] + ';';
          if (this.value[index + 1]) str += '\n';
        }
        return str;
      }

      return this.key + ' ' + this.value + ';';
    }
  }]);

  return SimpleRule;
}();

exports['default'] = SimpleRule;
},{}],371:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _warning = require('warning');

var _warning2 = _interopRequireDefault(_warning);

var _toCss = require('../utils/toCss');

var _toCss2 = _interopRequireDefault(_toCss);

var _toCssValue = require('../utils/toCssValue');

var _toCssValue2 = _interopRequireDefault(_toCssValue);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var StyleRule = function () {
  function StyleRule(key, style, options) {
    _classCallCheck(this, StyleRule);

    this.type = 'style';
    this.isProcessed = false;
    var sheet = options.sheet,
        Renderer = options.Renderer,
        selector = options.selector;

    this.key = key;
    this.options = options;
    this.style = style;
    if (selector) this.selectorText = selector;
    this.renderer = sheet ? sheet.renderer : new Renderer();
  }

  /**
   * Set selector string.
   * Attention: use this with caution. Most browsers didn't implement
   * selectorText setter, so this may result in rerendering of entire Style Sheet.
   */


  _createClass(StyleRule, [{
    key: 'prop',


    /**
     * Get or set a style property.
     */
    value: function prop(name, nextValue) {
      // It's a setter.
      if (nextValue != null) {
        // Don't do anything if the value has not changed.
        if (this.style[name] !== nextValue) {
          nextValue = this.options.jss.plugins.onChangeValue(nextValue, name, this);
          this.style[name] = nextValue;

          // Renderable is defined if StyleSheet option `link` is true.
          if (this.renderable) this.renderer.setStyle(this.renderable, name, nextValue);else {
            var sheet = this.options.sheet;

            if (sheet && sheet.attached) {
              (0, _warning2['default'])(false, 'Rule is not linked. Missing sheet option "link: true".');
            }
          }
        }
        return this;
      }

      return this.style[name];
    }

    /**
     * Apply rule to an element inline.
     */

  }, {
    key: 'applyTo',
    value: function applyTo(renderable) {
      var json = this.toJSON();
      for (var prop in json) {
        this.renderer.setStyle(renderable, prop, json[prop]);
      }return this;
    }

    /**
     * Returns JSON representation of the rule.
     * Fallbacks are not supported.
     * Useful for inline styles.
     */

  }, {
    key: 'toJSON',
    value: function toJSON() {
      var json = {};
      for (var prop in this.style) {
        var value = this.style[prop];
        if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) !== 'object') json[prop] = value;else if (Array.isArray(value)) json[prop] = (0, _toCssValue2['default'])(value);
      }
      return json;
    }

    /**
     * Generates a CSS string.
     */

  }, {
    key: 'toString',
    value: function toString(options) {
      var sheet = this.options.sheet;

      var link = sheet ? sheet.options.link : false;
      var opts = link ? _extends({}, options, { allowEmpty: true }) : options;
      return (0, _toCss2['default'])(this.selector, this.style, opts);
    }
  }, {
    key: 'selector',
    set: function set(selector) {
      if (selector === this.selectorText) return;

      this.selectorText = selector;

      if (this.renderable) {
        var hasChanged = this.renderer.setSelector(this.renderable, selector);

        // If selector setter is not implemented, rerender the rule.
        if (!hasChanged && this.renderable) {
          var renderable = this.renderer.replaceRule(this.renderable, this);
          if (renderable) this.renderable = renderable;
        }
      }
    }

    /**
     * Get selector string.
     */
    ,
    get: function get() {
      return this.selectorText;
    }
  }]);

  return StyleRule;
}();

exports['default'] = StyleRule;
},{"../utils/toCss":383,"../utils/toCssValue":384,"warning":391}],372:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _toCss = require('../utils/toCss');

var _toCss2 = _interopRequireDefault(_toCss);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ViewportRule = function () {
  function ViewportRule(key, style, options) {
    _classCallCheck(this, ViewportRule);

    this.type = 'viewport';
    this.isProcessed = false;

    this.key = key;
    this.style = style;
    this.options = options;
  }

  /**
   * Generates a CSS string.
   */


  _createClass(ViewportRule, [{
    key: 'toString',
    value: function toString(options) {
      return (0, _toCss2['default'])(this.key, this.style, options);
    }
  }]);

  return ViewportRule;
}();

exports['default'] = ViewportRule;
},{"../utils/toCss":383}],373:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _SheetsRegistry = require('./SheetsRegistry');

var _SheetsRegistry2 = _interopRequireDefault(_SheetsRegistry);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/**
 * This is a global sheets registry. Only DomRenderer will add sheets to it.
 * On the server one should use an own SheetsRegistry instance and add the
 * sheets to it, because you need to make sure to create a new registry for
 * each request in order to not leak sheets across requests.
 */
exports['default'] = new _SheetsRegistry2['default']();
},{"./SheetsRegistry":359}],374:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports['default'] = cloneStyle;

var _isObservable = require('./isObservable');

var _isObservable2 = _interopRequireDefault(_isObservable);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var isArray = Array.isArray;
function cloneStyle(style) {
  // Support empty values in case user ends up with them by accident.
  if (style == null) return style;

  // Support string value for SimpleRule.
  var typeOfStyle = typeof style === 'undefined' ? 'undefined' : _typeof(style);

  if (typeOfStyle === 'string' || typeOfStyle === 'number' || typeOfStyle === 'function') {
    return style;
  }

  // Support array for FontFaceRule.
  if (isArray(style)) return style.map(cloneStyle);

  // Support Observable styles.  Observables are immutable, so we don't need to
  // copy them.
  if ((0, _isObservable2['default'])(style)) return style;

  var newStyle = {};
  for (var name in style) {
    var value = style[name];
    if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {
      newStyle[name] = cloneStyle(value);
      continue;
    }
    newStyle[name] = value;
  }

  return newStyle;
}
},{"./isObservable":379}],375:[function(require,module,exports){
(function (process){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _warning = require('warning');

var _warning2 = _interopRequireDefault(_warning);

var _StyleSheet = require('../StyleSheet');

var _StyleSheet2 = _interopRequireDefault(_StyleSheet);

var _moduleId = require('./moduleId');

var _moduleId2 = _interopRequireDefault(_moduleId);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var maxRules = 1e10;


var env = process.env.NODE_ENV;

/**
 * Returns a function which generates unique class names based on counters.
 * When new generator function is created, rule counter is reseted.
 * We need to reset the rule counter for SSR for each request.
 */

exports['default'] = function () {
  var ruleCounter = 0;
  var defaultPrefix = env === 'production' ? 'c' : '';

  return function (rule, sheet) {
    ruleCounter += 1;

    if (ruleCounter > maxRules) {
      (0, _warning2['default'])(false, '[JSS] You might have a memory leak. Rule counter is at %s.', ruleCounter);
    }

    var prefix = defaultPrefix;
    var jssId = '';

    if (sheet) {
      prefix = sheet.options.classNamePrefix || defaultPrefix;
      if (sheet.options.jss.id != null) jssId += sheet.options.jss.id;
    }

    if (env === 'production') {
      return '' + prefix + _moduleId2['default'] + jssId + ruleCounter;
    }

    return prefix + rule.key + '-' + _moduleId2['default'] + (jssId && '-' + jssId) + '-' + ruleCounter;
  };
};
}).call(this,require('_process'))

},{"../StyleSheet":360,"./moduleId":382,"_process":386,"warning":391}],376:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports['default'] = createRule;

var _warning = require('warning');

var _warning2 = _interopRequireDefault(_warning);

var _StyleRule = require('../rules/StyleRule');

var _StyleRule2 = _interopRequireDefault(_StyleRule);

var _cloneStyle = require('../utils/cloneStyle');

var _cloneStyle2 = _interopRequireDefault(_cloneStyle);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/**
 * Create a rule instance.
 */
function createRule() {
  var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'unnamed';
  var decl = arguments[1];
  var options = arguments[2];
  var jss = options.jss;

  var declCopy = (0, _cloneStyle2['default'])(decl);

  var rule = jss.plugins.onCreateRule(name, declCopy, options);
  if (rule) return rule;

  // It is an at-rule and it has no instance.
  if (name[0] === '@') {
    (0, _warning2['default'])(false, '[JSS] Unknown at-rule %s', name);
  }

  return new _StyleRule2['default'](name, declCopy, options);
}
},{"../rules/StyleRule":371,"../utils/cloneStyle":374,"warning":391}],377:[function(require,module,exports){
(function (process,global){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var CSS = global.CSS;

var env = process.env.NODE_ENV;

var escapeRegex = /([[\].#*$><+~=|^:(),"'`])/g;

exports['default'] = function (str) {
  // We don't need to escape it in production, because we are not using user's
  // input for selectors, we are generating a valid selector.
  if (env === 'production') return str;

  if (!CSS || !CSS.escape) {
    return str.replace(escapeRegex, '\\$1');
  }

  return CSS.escape(str);
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"_process":386}],378:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
 * Extracts a styles object with only props that contain function values.
 */
exports['default'] = function (styles) {
  // eslint-disable-next-line no-shadow
  function extract(styles) {
    var to = null;

    for (var key in styles) {
      var value = styles[key];
      var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);

      if (type === 'function') {
        if (!to) to = {};
        to[key] = value;
      } else if (type === 'object' && value !== null && !Array.isArray(value)) {
        var extracted = extract(value);
        if (extracted) {
          if (!to) to = {};
          to[key] = extracted;
        }
      }
    }

    return to;
  }

  return extract(styles);
};
},{}],379:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _symbolObservable = require('symbol-observable');

var _symbolObservable2 = _interopRequireDefault(_symbolObservable);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

exports['default'] = function (value) {
  return value && value[_symbolObservable2['default']] && value === value[_symbolObservable2['default']]();
};
},{"symbol-observable":387}],380:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var regExp = /([A-Z])/g;
var replace = function replace(str) {
  return "-" + str.toLowerCase();
};

exports["default"] = function (str) {
  return str.replace(regExp, replace);
};
},{}],381:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = linkRule;
/**
 * Link rule with CSSStyleRule and nested rules with corresponding nested cssRules if both exists.
 */
function linkRule(rule, cssRule) {
  rule.renderable = cssRule;
  if (rule.rules && cssRule.cssRules) rule.rules.link(cssRule.cssRules);
}
},{}],382:[function(require,module,exports){
(function (global){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var ns = '2f1acc6c3a606b082e5eef5e54414ffb';
if (global[ns] == null) global[ns] = 0;

// Bundle may contain multiple JSS versions at the same time. In order to identify
// the current version with just one short number and use it for classes generation
// we use a counter. Also it is more accurate, because user can manually reevaluate
// the module.
exports['default'] = global[ns]++;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],383:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports['default'] = toCss;

var _toCssValue = require('./toCssValue');

var _toCssValue2 = _interopRequireDefault(_toCssValue);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/**
 * Indent a string.
 * http://jsperf.com/array-join-vs-for
 */
function indentStr(str, indent) {
  var result = '';
  for (var index = 0; index < indent; index++) {
    result += '  ';
  }return result + str;
}

/**
 * Converts a Rule to CSS string.
 */

function toCss(selector, style) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  var result = '';

  if (!style) return result;

  var _options$indent = options.indent,
      indent = _options$indent === undefined ? 0 : _options$indent;
  var fallbacks = style.fallbacks;


  indent++;

  // Apply fallbacks first.
  if (fallbacks) {
    // Array syntax {fallbacks: [{prop: value}]}
    if (Array.isArray(fallbacks)) {
      for (var index = 0; index < fallbacks.length; index++) {
        var fallback = fallbacks[index];
        for (var prop in fallback) {
          var value = fallback[prop];
          if (value != null) {
            result += '\n' + indentStr(prop + ': ' + (0, _toCssValue2['default'])(value) + ';', indent);
          }
        }
      }
    }
    // Object syntax {fallbacks: {prop: value}}
    else {
        for (var _prop in fallbacks) {
          var _value = fallbacks[_prop];
          if (_value != null) {
            result += '\n' + indentStr(_prop + ': ' + (0, _toCssValue2['default'])(_value) + ';', indent);
          }
        }
      }
  }

  for (var _prop2 in style) {
    var _value2 = style[_prop2];
    if (_value2 != null && _prop2 !== 'fallbacks') {
      result += '\n' + indentStr(_prop2 + ': ' + (0, _toCssValue2['default'])(_value2) + ';', indent);
    }
  }

  // Allow empty style in this case, because properties will be added dynamically.
  if (!result && !options.allowEmpty) return result;

  indent--;
  result = indentStr(selector + ' {' + result + '\n', indent) + indentStr('}', indent);

  return result;
}
},{"./toCssValue":384}],384:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports['default'] = toCssValue;
var join = function join(value, by) {
  var result = '';
  for (var i = 0; i < value.length; i++) {
    // Remove !important from the value, it will be readded later.
    if (value[i] === '!important') break;
    if (result) result += by;
    result += value[i];
  }
  return result;
};

/**
 * Converts array values to string.
 *
 * `margin: [['5px', '10px']]` > `margin: 5px 10px;`
 * `border: ['1px', '2px']` > `border: 1px, 2px;`
 * `margin: [['5px', '10px'], '!important']` > `margin: 5px 10px !important;`
 * `color: ['red', !important]` > `color: red !important;`
 */
function toCssValue(value) {
  var ignoreImportant = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  if (!Array.isArray(value)) return value;

  var cssValue = '';

  // Support space separated values via `[['5px', '10px']]`.
  if (Array.isArray(value[0])) {
    for (var i = 0; i < value.length; i++) {
      if (value[i] === '!important') break;
      if (cssValue) cssValue += ', ';
      cssValue += join(value[i], ' ');
    }
  } else cssValue = join(value, ', ');

  // Add !important, because it was ignored.
  if (!ignoreImportant && value[value.length - 1] === '!important') {
    cssValue += ' !important';
  }

  return cssValue;
}
},{}],385:[function(require,module,exports){
//! moment.js
//! version : 2.20.1
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com

;(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    global.moment = factory()
}(this, (function () { 'use strict';

var hookCallback;

function hooks () {
    return hookCallback.apply(null, arguments);
}

// This is done to register the method called with moment()
// without creating circular dependencies.
function setHookCallback (callback) {
    hookCallback = callback;
}

function isArray(input) {
    return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
}

function isObject(input) {
    // IE8 will treat undefined and null as object if it wasn't for
    // input != null
    return input != null && Object.prototype.toString.call(input) === '[object Object]';
}

function isObjectEmpty(obj) {
    if (Object.getOwnPropertyNames) {
        return (Object.getOwnPropertyNames(obj).length === 0);
    } else {
        var k;
        for (k in obj) {
            if (obj.hasOwnProperty(k)) {
                return false;
            }
        }
        return true;
    }
}

function isUndefined(input) {
    return input === void 0;
}

function isNumber(input) {
    return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';
}

function isDate(input) {
    return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
}

function map(arr, fn) {
    var res = [], i;
    for (i = 0; i < arr.length; ++i) {
        res.push(fn(arr[i], i));
    }
    return res;
}

function hasOwnProp(a, b) {
    return Object.prototype.hasOwnProperty.call(a, b);
}

function extend(a, b) {
    for (var i in b) {
        if (hasOwnProp(b, i)) {
            a[i] = b[i];
        }
    }

    if (hasOwnProp(b, 'toString')) {
        a.toString = b.toString;
    }

    if (hasOwnProp(b, 'valueOf')) {
        a.valueOf = b.valueOf;
    }

    return a;
}

function createUTC (input, format, locale, strict) {
    return createLocalOrUTC(input, format, locale, strict, true).utc();
}

function defaultParsingFlags() {
    // We need to deep clone this object.
    return {
        empty           : false,
        unusedTokens    : [],
        unusedInput     : [],
        overflow        : -2,
        charsLeftOver   : 0,
        nullInput       : false,
        invalidMonth    : null,
        invalidFormat   : false,
        userInvalidated : false,
        iso             : false,
        parsedDateParts : [],
        meridiem        : null,
        rfc2822         : false,
        weekdayMismatch : false
    };
}

function getParsingFlags(m) {
    if (m._pf == null) {
        m._pf = defaultParsingFlags();
    }
    return m._pf;
}

var some;
if (Array.prototype.some) {
    some = Array.prototype.some;
} else {
    some = function (fun) {
        var t = Object(this);
        var len = t.length >>> 0;

        for (var i = 0; i < len; i++) {
            if (i in t && fun.call(this, t[i], i, t)) {
                return true;
            }
        }

        return false;
    };
}

function isValid(m) {
    if (m._isValid == null) {
        var flags = getParsingFlags(m);
        var parsedParts = some.call(flags.parsedDateParts, function (i) {
            return i != null;
        });
        var isNowValid = !isNaN(m._d.getTime()) &&
            flags.overflow < 0 &&
            !flags.empty &&
            !flags.invalidMonth &&
            !flags.invalidWeekday &&
            !flags.weekdayMismatch &&
            !flags.nullInput &&
            !flags.invalidFormat &&
            !flags.userInvalidated &&
            (!flags.meridiem || (flags.meridiem && parsedParts));

        if (m._strict) {
            isNowValid = isNowValid &&
                flags.charsLeftOver === 0 &&
                flags.unusedTokens.length === 0 &&
                flags.bigHour === undefined;
        }

        if (Object.isFrozen == null || !Object.isFrozen(m)) {
            m._isValid = isNowValid;
        }
        else {
            return isNowValid;
        }
    }
    return m._isValid;
}

function createInvalid (flags) {
    var m = createUTC(NaN);
    if (flags != null) {
        extend(getParsingFlags(m), flags);
    }
    else {
        getParsingFlags(m).userInvalidated = true;
    }

    return m;
}

// Plugins that add properties should also add the key here (null value),
// so we can properly clone ourselves.
var momentProperties = hooks.momentProperties = [];

function copyConfig(to, from) {
    var i, prop, val;

    if (!isUndefined(from._isAMomentObject)) {
        to._isAMomentObject = from._isAMomentObject;
    }
    if (!isUndefined(from._i)) {
        to._i = from._i;
    }
    if (!isUndefined(from._f)) {
        to._f = from._f;
    }
    if (!isUndefined(from._l)) {
        to._l = from._l;
    }
    if (!isUndefined(from._strict)) {
        to._strict = from._strict;
    }
    if (!isUndefined(from._tzm)) {
        to._tzm = from._tzm;
    }
    if (!isUndefined(from._isUTC)) {
        to._isUTC = from._isUTC;
    }
    if (!isUndefined(from._offset)) {
        to._offset = from._offset;
    }
    if (!isUndefined(from._pf)) {
        to._pf = getParsingFlags(from);
    }
    if (!isUndefined(from._locale)) {
        to._locale = from._locale;
    }

    if (momentProperties.length > 0) {
        for (i = 0; i < momentProperties.length; i++) {
            prop = momentProperties[i];
            val = from[prop];
            if (!isUndefined(val)) {
                to[prop] = val;
            }
        }
    }

    return to;
}

var updateInProgress = false;

// Moment prototype object
function Moment(config) {
    copyConfig(this, config);
    this._d = new Date(config._d != null ? config._d.getTime() : NaN);
    if (!this.isValid()) {
        this._d = new Date(NaN);
    }
    // Prevent infinite loop in case updateOffset creates new moment
    // objects.
    if (updateInProgress === false) {
        updateInProgress = true;
        hooks.updateOffset(this);
        updateInProgress = false;
    }
}

function isMoment (obj) {
    return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
}

function absFloor (number) {
    if (number < 0) {
        // -0 -> 0
        return Math.ceil(number) || 0;
    } else {
        return Math.floor(number);
    }
}

function toInt(argumentForCoercion) {
    var coercedNumber = +argumentForCoercion,
        value = 0;

    if (coercedNumber !== 0 && isFinite(coercedNumber)) {
        value = absFloor(coercedNumber);
    }

    return value;
}

// compare two arrays, return the number of differences
function compareArrays(array1, array2, dontConvert) {
    var len = Math.min(array1.length, array2.length),
        lengthDiff = Math.abs(array1.length - array2.length),
        diffs = 0,
        i;
    for (i = 0; i < len; i++) {
        if ((dontConvert && array1[i] !== array2[i]) ||
            (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
            diffs++;
        }
    }
    return diffs + lengthDiff;
}

function warn(msg) {
    if (hooks.suppressDeprecationWarnings === false &&
            (typeof console !==  'undefined') && console.warn) {
        console.warn('Deprecation warning: ' + msg);
    }
}

function deprecate(msg, fn) {
    var firstTime = true;

    return extend(function () {
        if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(null, msg);
        }
        if (firstTime) {
            var args = [];
            var arg;
            for (var i = 0; i < arguments.length; i++) {
                arg = '';
                if (typeof arguments[i] === 'object') {
                    arg += '\n[' + i + '] ';
                    for (var key in arguments[0]) {
                        arg += key + ': ' + arguments[0][key] + ', ';
                    }
                    arg = arg.slice(0, -2); // Remove trailing comma and space
                } else {
                    arg = arguments[i];
                }
                args.push(arg);
            }
            warn(msg + '\nArguments: ' + Array.prototype.slice.call(args).join('') + '\n' + (new Error()).stack);
            firstTime = false;
        }
        return fn.apply(this, arguments);
    }, fn);
}

var deprecations = {};

function deprecateSimple(name, msg) {
    if (hooks.deprecationHandler != null) {
        hooks.deprecationHandler(name, msg);
    }
    if (!deprecations[name]) {
        warn(msg);
        deprecations[name] = true;
    }
}

hooks.suppressDeprecationWarnings = false;
hooks.deprecationHandler = null;

function isFunction(input) {
    return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
}

function set (config) {
    var prop, i;
    for (i in config) {
        prop = config[i];
        if (isFunction(prop)) {
            this[i] = prop;
        } else {
            this['_' + i] = prop;
        }
    }
    this._config = config;
    // Lenient ordinal parsing accepts just a number in addition to
    // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
    // TODO: Remove "ordinalParse" fallback in next major release.
    this._dayOfMonthOrdinalParseLenient = new RegExp(
        (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +
            '|' + (/\d{1,2}/).source);
}

function mergeConfigs(parentConfig, childConfig) {
    var res = extend({}, parentConfig), prop;
    for (prop in childConfig) {
        if (hasOwnProp(childConfig, prop)) {
            if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
                res[prop] = {};
                extend(res[prop], parentConfig[prop]);
                extend(res[prop], childConfig[prop]);
            } else if (childConfig[prop] != null) {
                res[prop] = childConfig[prop];
            } else {
                delete res[prop];
            }
        }
    }
    for (prop in parentConfig) {
        if (hasOwnProp(parentConfig, prop) &&
                !hasOwnProp(childConfig, prop) &&
                isObject(parentConfig[prop])) {
            // make sure changes to properties don't modify parent config
            res[prop] = extend({}, res[prop]);
        }
    }
    return res;
}

function Locale(config) {
    if (config != null) {
        this.set(config);
    }
}

var keys;

if (Object.keys) {
    keys = Object.keys;
} else {
    keys = function (obj) {
        var i, res = [];
        for (i in obj) {
            if (hasOwnProp(obj, i)) {
                res.push(i);
            }
        }
        return res;
    };
}

var defaultCalendar = {
    sameDay : '[Today at] LT',
    nextDay : '[Tomorrow at] LT',
    nextWeek : 'dddd [at] LT',
    lastDay : '[Yesterday at] LT',
    lastWeek : '[Last] dddd [at] LT',
    sameElse : 'L'
};

function calendar (key, mom, now) {
    var output = this._calendar[key] || this._calendar['sameElse'];
    return isFunction(output) ? output.call(mom, now) : output;
}

var defaultLongDateFormat = {
    LTS  : 'h:mm:ss A',
    LT   : 'h:mm A',
    L    : 'MM/DD/YYYY',
    LL   : 'MMMM D, YYYY',
    LLL  : 'MMMM D, YYYY h:mm A',
    LLLL : 'dddd, MMMM D, YYYY h:mm A'
};

function longDateFormat (key) {
    var format = this._longDateFormat[key],
        formatUpper = this._longDateFormat[key.toUpperCase()];

    if (format || !formatUpper) {
        return format;
    }

    this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
        return val.slice(1);
    });

    return this._longDateFormat[key];
}

var defaultInvalidDate = 'Invalid date';

function invalidDate () {
    return this._invalidDate;
}

var defaultOrdinal = '%d';
var defaultDayOfMonthOrdinalParse = /\d{1,2}/;

function ordinal (number) {
    return this._ordinal.replace('%d', number);
}

var defaultRelativeTime = {
    future : 'in %s',
    past   : '%s ago',
    s  : 'a few seconds',
    ss : '%d seconds',
    m  : 'a minute',
    mm : '%d minutes',
    h  : 'an hour',
    hh : '%d hours',
    d  : 'a day',
    dd : '%d days',
    M  : 'a month',
    MM : '%d months',
    y  : 'a year',
    yy : '%d years'
};

function relativeTime (number, withoutSuffix, string, isFuture) {
    var output = this._relativeTime[string];
    return (isFunction(output)) ?
        output(number, withoutSuffix, string, isFuture) :
        output.replace(/%d/i, number);
}

function pastFuture (diff, output) {
    var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
    return isFunction(format) ? format(output) : format.replace(/%s/i, output);
}

var aliases = {};

function addUnitAlias (unit, shorthand) {
    var lowerCase = unit.toLowerCase();
    aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
}

function normalizeUnits(units) {
    return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
}

function normalizeObjectUnits(inputObject) {
    var normalizedInput = {},
        normalizedProp,
        prop;

    for (prop in inputObject) {
        if (hasOwnProp(inputObject, prop)) {
            normalizedProp = normalizeUnits(prop);
            if (normalizedProp) {
                normalizedInput[normalizedProp] = inputObject[prop];
            }
        }
    }

    return normalizedInput;
}

var priorities = {};

function addUnitPriority(unit, priority) {
    priorities[unit] = priority;
}

function getPrioritizedUnits(unitsObj) {
    var units = [];
    for (var u in unitsObj) {
        units.push({unit: u, priority: priorities[u]});
    }
    units.sort(function (a, b) {
        return a.priority - b.priority;
    });
    return units;
}

function zeroFill(number, targetLength, forceSign) {
    var absNumber = '' + Math.abs(number),
        zerosToFill = targetLength - absNumber.length,
        sign = number >= 0;
    return (sign ? (forceSign ? '+' : '') : '-') +
        Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
}

var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;

var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;

var formatFunctions = {};

var formatTokenFunctions = {};

// token:    'M'
// padded:   ['MM', 2]
// ordinal:  'Mo'
// callback: function () { this.month() + 1 }
function addFormatToken (token, padded, ordinal, callback) {
    var func = callback;
    if (typeof callback === 'string') {
        func = function () {
            return this[callback]();
        };
    }
    if (token) {
        formatTokenFunctions[token] = func;
    }
    if (padded) {
        formatTokenFunctions[padded[0]] = function () {
            return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
        };
    }
    if (ordinal) {
        formatTokenFunctions[ordinal] = function () {
            return this.localeData().ordinal(func.apply(this, arguments), token);
        };
    }
}

function removeFormattingTokens(input) {
    if (input.match(/\[[\s\S]/)) {
        return input.replace(/^\[|\]$/g, '');
    }
    return input.replace(/\\/g, '');
}

function makeFormatFunction(format) {
    var array = format.match(formattingTokens), i, length;

    for (i = 0, length = array.length; i < length; i++) {
        if (formatTokenFunctions[array[i]]) {
            array[i] = formatTokenFunctions[array[i]];
        } else {
            array[i] = removeFormattingTokens(array[i]);
        }
    }

    return function (mom) {
        var output = '', i;
        for (i = 0; i < length; i++) {
            output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];
        }
        return output;
    };
}

// format date using native date object
function formatMoment(m, format) {
    if (!m.isValid()) {
        return m.localeData().invalidDate();
    }

    format = expandFormat(format, m.localeData());
    formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);

    return formatFunctions[format](m);
}

function expandFormat(format, locale) {
    var i = 5;

    function replaceLongDateFormatTokens(input) {
        return locale.longDateFormat(input) || input;
    }

    localFormattingTokens.lastIndex = 0;
    while (i >= 0 && localFormattingTokens.test(format)) {
        format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
        localFormattingTokens.lastIndex = 0;
        i -= 1;
    }

    return format;
}

var match1         = /\d/;            //       0 - 9
var match2         = /\d\d/;          //      00 - 99
var match3         = /\d{3}/;         //     000 - 999
var match4         = /\d{4}/;         //    0000 - 9999
var match6         = /[+-]?\d{6}/;    // -999999 - 999999
var match1to2      = /\d\d?/;         //       0 - 99
var match3to4      = /\d\d\d\d?/;     //     999 - 9999
var match5to6      = /\d\d\d\d\d\d?/; //   99999 - 999999
var match1to3      = /\d{1,3}/;       //       0 - 999
var match1to4      = /\d{1,4}/;       //       0 - 9999
var match1to6      = /[+-]?\d{1,6}/;  // -999999 - 999999

var matchUnsigned  = /\d+/;           //       0 - inf
var matchSigned    = /[+-]?\d+/;      //    -inf - inf

var matchOffset    = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z
var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z

var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123

// any word (or two) characters or numbers including two/three word month in arabic.
// includes scottish gaelic two word and hyphenated months
var matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i;


var regexes = {};

function addRegexToken (token, regex, strictRegex) {
    regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
        return (isStrict && strictRegex) ? strictRegex : regex;
    };
}

function getParseRegexForToken (token, config) {
    if (!hasOwnProp(regexes, token)) {
        return new RegExp(unescapeFormat(token));
    }

    return regexes[token](config._strict, config._locale);
}

// Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
function unescapeFormat(s) {
    return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
        return p1 || p2 || p3 || p4;
    }));
}

function regexEscape(s) {
    return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
}

var tokens = {};

function addParseToken (token, callback) {
    var i, func = callback;
    if (typeof token === 'string') {
        token = [token];
    }
    if (isNumber(callback)) {
        func = function (input, array) {
            array[callback] = toInt(input);
        };
    }
    for (i = 0; i < token.length; i++) {
        tokens[token[i]] = func;
    }
}

function addWeekParseToken (token, callback) {
    addParseToken(token, function (input, array, config, token) {
        config._w = config._w || {};
        callback(input, config._w, config, token);
    });
}

function addTimeToArrayFromToken(token, input, config) {
    if (input != null && hasOwnProp(tokens, token)) {
        tokens[token](input, config._a, config, token);
    }
}

var YEAR = 0;
var MONTH = 1;
var DATE = 2;
var HOUR = 3;
var MINUTE = 4;
var SECOND = 5;
var MILLISECOND = 6;
var WEEK = 7;
var WEEKDAY = 8;

// FORMATTING

addFormatToken('Y', 0, 0, function () {
    var y = this.year();
    return y <= 9999 ? '' + y : '+' + y;
});

addFormatToken(0, ['YY', 2], 0, function () {
    return this.year() % 100;
});

addFormatToken(0, ['YYYY',   4],       0, 'year');
addFormatToken(0, ['YYYYY',  5],       0, 'year');
addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

// ALIASES

addUnitAlias('year', 'y');

// PRIORITIES

addUnitPriority('year', 1);

// PARSING

addRegexToken('Y',      matchSigned);
addRegexToken('YY',     match1to2, match2);
addRegexToken('YYYY',   match1to4, match4);
addRegexToken('YYYYY',  match1to6, match6);
addRegexToken('YYYYYY', match1to6, match6);

addParseToken(['YYYYY', 'YYYYYY'], YEAR);
addParseToken('YYYY', function (input, array) {
    array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
});
addParseToken('YY', function (input, array) {
    array[YEAR] = hooks.parseTwoDigitYear(input);
});
addParseToken('Y', function (input, array) {
    array[YEAR] = parseInt(input, 10);
});

// HELPERS

function daysInYear(year) {
    return isLeapYear(year) ? 366 : 365;
}

function isLeapYear(year) {
    return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
}

// HOOKS

hooks.parseTwoDigitYear = function (input) {
    return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
};

// MOMENTS

var getSetYear = makeGetSet('FullYear', true);

function getIsLeapYear () {
    return isLeapYear(this.year());
}

function makeGetSet (unit, keepTime) {
    return function (value) {
        if (value != null) {
            set$1(this, unit, value);
            hooks.updateOffset(this, keepTime);
            return this;
        } else {
            return get(this, unit);
        }
    };
}

function get (mom, unit) {
    return mom.isValid() ?
        mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
}

function set$1 (mom, unit, value) {
    if (mom.isValid() && !isNaN(value)) {
        if (unit === 'FullYear' && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
            mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value, mom.month(), daysInMonth(value, mom.month()));
        }
        else {
            mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
        }
    }
}

// MOMENTS

function stringGet (units) {
    units = normalizeUnits(units);
    if (isFunction(this[units])) {
        return this[units]();
    }
    return this;
}


function stringSet (units, value) {
    if (typeof units === 'object') {
        units = normalizeObjectUnits(units);
        var prioritized = getPrioritizedUnits(units);
        for (var i = 0; i < prioritized.length; i++) {
            this[prioritized[i].unit](units[prioritized[i].unit]);
        }
    } else {
        units = normalizeUnits(units);
        if (isFunction(this[units])) {
            return this[units](value);
        }
    }
    return this;
}

function mod(n, x) {
    return ((n % x) + x) % x;
}

var indexOf;

if (Array.prototype.indexOf) {
    indexOf = Array.prototype.indexOf;
} else {
    indexOf = function (o) {
        // I know
        var i;
        for (i = 0; i < this.length; ++i) {
            if (this[i] === o) {
                return i;
            }
        }
        return -1;
    };
}

function daysInMonth(year, month) {
    if (isNaN(year) || isNaN(month)) {
        return NaN;
    }
    var modMonth = mod(month, 12);
    year += (month - modMonth) / 12;
    return modMonth === 1 ? (isLeapYear(year) ? 29 : 28) : (31 - modMonth % 7 % 2);
}

// FORMATTING

addFormatToken('M', ['MM', 2], 'Mo', function () {
    return this.month() + 1;
});

addFormatToken('MMM', 0, 0, function (format) {
    return this.localeData().monthsShort(this, format);
});

addFormatToken('MMMM', 0, 0, function (format) {
    return this.localeData().months(this, format);
});

// ALIASES

addUnitAlias('month', 'M');

// PRIORITY

addUnitPriority('month', 8);

// PARSING

addRegexToken('M',    match1to2);
addRegexToken('MM',   match1to2, match2);
addRegexToken('MMM',  function (isStrict, locale) {
    return locale.monthsShortRegex(isStrict);
});
addRegexToken('MMMM', function (isStrict, locale) {
    return locale.monthsRegex(isStrict);
});

addParseToken(['M', 'MM'], function (input, array) {
    array[MONTH] = toInt(input) - 1;
});

addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
    var month = config._locale.monthsParse(input, token, config._strict);
    // if we didn't find a month name, mark the date as invalid.
    if (month != null) {
        array[MONTH] = month;
    } else {
        getParsingFlags(config).invalidMonth = input;
    }
});

// LOCALES

var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
function localeMonths (m, format) {
    if (!m) {
        return isArray(this._months) ? this._months :
            this._months['standalone'];
    }
    return isArray(this._months) ? this._months[m.month()] :
        this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
}

var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
function localeMonthsShort (m, format) {
    if (!m) {
        return isArray(this._monthsShort) ? this._monthsShort :
            this._monthsShort['standalone'];
    }
    return isArray(this._monthsShort) ? this._monthsShort[m.month()] :
        this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
}

function handleStrictParse(monthName, format, strict) {
    var i, ii, mom, llc = monthName.toLocaleLowerCase();
    if (!this._monthsParse) {
        // this is not used
        this._monthsParse = [];
        this._longMonthsParse = [];
        this._shortMonthsParse = [];
        for (i = 0; i < 12; ++i) {
            mom = createUTC([2000, i]);
            this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
            this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
        }
    }

    if (strict) {
        if (format === 'MMM') {
            ii = indexOf.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
        } else {
            ii = indexOf.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
        }
    } else {
        if (format === 'MMM') {
            ii = indexOf.call(this._shortMonthsParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
        } else {
            ii = indexOf.call(this._longMonthsParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
        }
    }
}

function localeMonthsParse (monthName, format, strict) {
    var i, mom, regex;

    if (this._monthsParseExact) {
        return handleStrictParse.call(this, monthName, format, strict);
    }

    if (!this._monthsParse) {
        this._monthsParse = [];
        this._longMonthsParse = [];
        this._shortMonthsParse = [];
    }

    // TODO: add sorting
    // Sorting makes sure if one month (or abbr) is a prefix of another
    // see sorting in computeMonthsParse
    for (i = 0; i < 12; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, i]);
        if (strict && !this._longMonthsParse[i]) {
            this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
            this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
        }
        if (!strict && !this._monthsParse[i]) {
            regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
            this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
        }
        // test the regex
        if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
            return i;
        } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
            return i;
        } else if (!strict && this._monthsParse[i].test(monthName)) {
            return i;
        }
    }
}

// MOMENTS

function setMonth (mom, value) {
    var dayOfMonth;

    if (!mom.isValid()) {
        // No op
        return mom;
    }

    if (typeof value === 'string') {
        if (/^\d+$/.test(value)) {
            value = toInt(value);
        } else {
            value = mom.localeData().monthsParse(value);
            // TODO: Another silent failure?
            if (!isNumber(value)) {
                return mom;
            }
        }
    }

    dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
    mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
    return mom;
}

function getSetMonth (value) {
    if (value != null) {
        setMonth(this, value);
        hooks.updateOffset(this, true);
        return this;
    } else {
        return get(this, 'Month');
    }
}

function getDaysInMonth () {
    return daysInMonth(this.year(), this.month());
}

var defaultMonthsShortRegex = matchWord;
function monthsShortRegex (isStrict) {
    if (this._monthsParseExact) {
        if (!hasOwnProp(this, '_monthsRegex')) {
            computeMonthsParse.call(this);
        }
        if (isStrict) {
            return this._monthsShortStrictRegex;
        } else {
            return this._monthsShortRegex;
        }
    } else {
        if (!hasOwnProp(this, '_monthsShortRegex')) {
            this._monthsShortRegex = defaultMonthsShortRegex;
        }
        return this._monthsShortStrictRegex && isStrict ?
            this._monthsShortStrictRegex : this._monthsShortRegex;
    }
}

var defaultMonthsRegex = matchWord;
function monthsRegex (isStrict) {
    if (this._monthsParseExact) {
        if (!hasOwnProp(this, '_monthsRegex')) {
            computeMonthsParse.call(this);
        }
        if (isStrict) {
            return this._monthsStrictRegex;
        } else {
            return this._monthsRegex;
        }
    } else {
        if (!hasOwnProp(this, '_monthsRegex')) {
            this._monthsRegex = defaultMonthsRegex;
        }
        return this._monthsStrictRegex && isStrict ?
            this._monthsStrictRegex : this._monthsRegex;
    }
}

function computeMonthsParse () {
    function cmpLenRev(a, b) {
        return b.length - a.length;
    }

    var shortPieces = [], longPieces = [], mixedPieces = [],
        i, mom;
    for (i = 0; i < 12; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, i]);
        shortPieces.push(this.monthsShort(mom, ''));
        longPieces.push(this.months(mom, ''));
        mixedPieces.push(this.months(mom, ''));
        mixedPieces.push(this.monthsShort(mom, ''));
    }
    // Sorting makes sure if one month (or abbr) is a prefix of another it
    // will match the longer piece.
    shortPieces.sort(cmpLenRev);
    longPieces.sort(cmpLenRev);
    mixedPieces.sort(cmpLenRev);
    for (i = 0; i < 12; i++) {
        shortPieces[i] = regexEscape(shortPieces[i]);
        longPieces[i] = regexEscape(longPieces[i]);
    }
    for (i = 0; i < 24; i++) {
        mixedPieces[i] = regexEscape(mixedPieces[i]);
    }

    this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
    this._monthsShortRegex = this._monthsRegex;
    this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
    this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
}

function createDate (y, m, d, h, M, s, ms) {
    // can't just apply() to create a date:
    // https://stackoverflow.com/q/181348
    var date = new Date(y, m, d, h, M, s, ms);

    // the date constructor remaps years 0-99 to 1900-1999
    if (y < 100 && y >= 0 && isFinite(date.getFullYear())) {
        date.setFullYear(y);
    }
    return date;
}

function createUTCDate (y) {
    var date = new Date(Date.UTC.apply(null, arguments));

    // the Date.UTC function remaps years 0-99 to 1900-1999
    if (y < 100 && y >= 0 && isFinite(date.getUTCFullYear())) {
        date.setUTCFullYear(y);
    }
    return date;
}

// start-of-first-week - start-of-year
function firstWeekOffset(year, dow, doy) {
    var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
        fwd = 7 + dow - doy,
        // first-week day local weekday -- which local weekday is fwd
        fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

    return -fwdlw + fwd - 1;
}

// https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
    var localWeekday = (7 + weekday - dow) % 7,
        weekOffset = firstWeekOffset(year, dow, doy),
        dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
        resYear, resDayOfYear;

    if (dayOfYear <= 0) {
        resYear = year - 1;
        resDayOfYear = daysInYear(resYear) + dayOfYear;
    } else if (dayOfYear > daysInYear(year)) {
        resYear = year + 1;
        resDayOfYear = dayOfYear - daysInYear(year);
    } else {
        resYear = year;
        resDayOfYear = dayOfYear;
    }

    return {
        year: resYear,
        dayOfYear: resDayOfYear
    };
}

function weekOfYear(mom, dow, doy) {
    var weekOffset = firstWeekOffset(mom.year(), dow, doy),
        week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
        resWeek, resYear;

    if (week < 1) {
        resYear = mom.year() - 1;
        resWeek = week + weeksInYear(resYear, dow, doy);
    } else if (week > weeksInYear(mom.year(), dow, doy)) {
        resWeek = week - weeksInYear(mom.year(), dow, doy);
        resYear = mom.year() + 1;
    } else {
        resYear = mom.year();
        resWeek = week;
    }

    return {
        week: resWeek,
        year: resYear
    };
}

function weeksInYear(year, dow, doy) {
    var weekOffset = firstWeekOffset(year, dow, doy),
        weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
    return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
}

// FORMATTING

addFormatToken('w', ['ww', 2], 'wo', 'week');
addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

// ALIASES

addUnitAlias('week', 'w');
addUnitAlias('isoWeek', 'W');

// PRIORITIES

addUnitPriority('week', 5);
addUnitPriority('isoWeek', 5);

// PARSING

addRegexToken('w',  match1to2);
addRegexToken('ww', match1to2, match2);
addRegexToken('W',  match1to2);
addRegexToken('WW', match1to2, match2);

addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
    week[token.substr(0, 1)] = toInt(input);
});

// HELPERS

// LOCALES

function localeWeek (mom) {
    return weekOfYear(mom, this._week.dow, this._week.doy).week;
}

var defaultLocaleWeek = {
    dow : 0, // Sunday is the first day of the week.
    doy : 6  // The week that contains Jan 1st is the first week of the year.
};

function localeFirstDayOfWeek () {
    return this._week.dow;
}

function localeFirstDayOfYear () {
    return this._week.doy;
}

// MOMENTS

function getSetWeek (input) {
    var week = this.localeData().week(this);
    return input == null ? week : this.add((input - week) * 7, 'd');
}

function getSetISOWeek (input) {
    var week = weekOfYear(this, 1, 4).week;
    return input == null ? week : this.add((input - week) * 7, 'd');
}

// FORMATTING

addFormatToken('d', 0, 'do', 'day');

addFormatToken('dd', 0, 0, function (format) {
    return this.localeData().weekdaysMin(this, format);
});

addFormatToken('ddd', 0, 0, function (format) {
    return this.localeData().weekdaysShort(this, format);
});

addFormatToken('dddd', 0, 0, function (format) {
    return this.localeData().weekdays(this, format);
});

addFormatToken('e', 0, 0, 'weekday');
addFormatToken('E', 0, 0, 'isoWeekday');

// ALIASES

addUnitAlias('day', 'd');
addUnitAlias('weekday', 'e');
addUnitAlias('isoWeekday', 'E');

// PRIORITY
addUnitPriority('day', 11);
addUnitPriority('weekday', 11);
addUnitPriority('isoWeekday', 11);

// PARSING

addRegexToken('d',    match1to2);
addRegexToken('e',    match1to2);
addRegexToken('E',    match1to2);
addRegexToken('dd',   function (isStrict, locale) {
    return locale.weekdaysMinRegex(isStrict);
});
addRegexToken('ddd',   function (isStrict, locale) {
    return locale.weekdaysShortRegex(isStrict);
});
addRegexToken('dddd',   function (isStrict, locale) {
    return locale.weekdaysRegex(isStrict);
});

addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
    var weekday = config._locale.weekdaysParse(input, token, config._strict);
    // if we didn't get a weekday name, mark the date as invalid
    if (weekday != null) {
        week.d = weekday;
    } else {
        getParsingFlags(config).invalidWeekday = input;
    }
});

addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
    week[token] = toInt(input);
});

// HELPERS

function parseWeekday(input, locale) {
    if (typeof input !== 'string') {
        return input;
    }

    if (!isNaN(input)) {
        return parseInt(input, 10);
    }

    input = locale.weekdaysParse(input);
    if (typeof input === 'number') {
        return input;
    }

    return null;
}

function parseIsoWeekday(input, locale) {
    if (typeof input === 'string') {
        return locale.weekdaysParse(input) % 7 || 7;
    }
    return isNaN(input) ? null : input;
}

// LOCALES

var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
function localeWeekdays (m, format) {
    if (!m) {
        return isArray(this._weekdays) ? this._weekdays :
            this._weekdays['standalone'];
    }
    return isArray(this._weekdays) ? this._weekdays[m.day()] :
        this._weekdays[this._weekdays.isFormat.test(format) ? 'format' : 'standalone'][m.day()];
}

var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
function localeWeekdaysShort (m) {
    return (m) ? this._weekdaysShort[m.day()] : this._weekdaysShort;
}

var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
function localeWeekdaysMin (m) {
    return (m) ? this._weekdaysMin[m.day()] : this._weekdaysMin;
}

function handleStrictParse$1(weekdayName, format, strict) {
    var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
    if (!this._weekdaysParse) {
        this._weekdaysParse = [];
        this._shortWeekdaysParse = [];
        this._minWeekdaysParse = [];

        for (i = 0; i < 7; ++i) {
            mom = createUTC([2000, 1]).day(i);
            this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
            this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
            this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
        }
    }

    if (strict) {
        if (format === 'dddd') {
            ii = indexOf.call(this._weekdaysParse, llc);
            return ii !== -1 ? ii : null;
        } else if (format === 'ddd') {
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        } else {
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        }
    } else {
        if (format === 'dddd') {
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        } else if (format === 'ddd') {
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        } else {
            ii = indexOf.call(this._minWeekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        }
    }
}

function localeWeekdaysParse (weekdayName, format, strict) {
    var i, mom, regex;

    if (this._weekdaysParseExact) {
        return handleStrictParse$1.call(this, weekdayName, format, strict);
    }

    if (!this._weekdaysParse) {
        this._weekdaysParse = [];
        this._minWeekdaysParse = [];
        this._shortWeekdaysParse = [];
        this._fullWeekdaysParse = [];
    }

    for (i = 0; i < 7; i++) {
        // make the regex if we don't have it already

        mom = createUTC([2000, 1]).day(i);
        if (strict && !this._fullWeekdaysParse[i]) {
            this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\.?') + '$', 'i');
            this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\.?') + '$', 'i');
            this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\.?') + '$', 'i');
        }
        if (!this._weekdaysParse[i]) {
            regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
            this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
        }
        // test the regex
        if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
            return i;
        } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
            return i;
        } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
            return i;
        } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
            return i;
        }
    }
}

// MOMENTS

function getSetDayOfWeek (input) {
    if (!this.isValid()) {
        return input != null ? this : NaN;
    }
    var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
    if (input != null) {
        input = parseWeekday(input, this.localeData());
        return this.add(input - day, 'd');
    } else {
        return day;
    }
}

function getSetLocaleDayOfWeek (input) {
    if (!this.isValid()) {
        return input != null ? this : NaN;
    }
    var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
    return input == null ? weekday : this.add(input - weekday, 'd');
}

function getSetISODayOfWeek (input) {
    if (!this.isValid()) {
        return input != null ? this : NaN;
    }

    // behaves the same as moment#day except
    // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
    // as a setter, sunday should belong to the previous week.

    if (input != null) {
        var weekday = parseIsoWeekday(input, this.localeData());
        return this.day(this.day() % 7 ? weekday : weekday - 7);
    } else {
        return this.day() || 7;
    }
}

var defaultWeekdaysRegex = matchWord;
function weekdaysRegex (isStrict) {
    if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
            computeWeekdaysParse.call(this);
        }
        if (isStrict) {
            return this._weekdaysStrictRegex;
        } else {
            return this._weekdaysRegex;
        }
    } else {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
            this._weekdaysRegex = defaultWeekdaysRegex;
        }
        return this._weekdaysStrictRegex && isStrict ?
            this._weekdaysStrictRegex : this._weekdaysRegex;
    }
}

var defaultWeekdaysShortRegex = matchWord;
function weekdaysShortRegex (isStrict) {
    if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
            computeWeekdaysParse.call(this);
        }
        if (isStrict) {
            return this._weekdaysShortStrictRegex;
        } else {
            return this._weekdaysShortRegex;
        }
    } else {
        if (!hasOwnProp(this, '_weekdaysShortRegex')) {
            this._weekdaysShortRegex = defaultWeekdaysShortRegex;
        }
        return this._weekdaysShortStrictRegex && isStrict ?
            this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
    }
}

var defaultWeekdaysMinRegex = matchWord;
function weekdaysMinRegex (isStrict) {
    if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
            computeWeekdaysParse.call(this);
        }
        if (isStrict) {
            return this._weekdaysMinStrictRegex;
        } else {
            return this._weekdaysMinRegex;
        }
    } else {
        if (!hasOwnProp(this, '_weekdaysMinRegex')) {
            this._weekdaysMinRegex = defaultWeekdaysMinRegex;
        }
        return this._weekdaysMinStrictRegex && isStrict ?
            this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
    }
}


function computeWeekdaysParse () {
    function cmpLenRev(a, b) {
        return b.length - a.length;
    }

    var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [],
        i, mom, minp, shortp, longp;
    for (i = 0; i < 7; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, 1]).day(i);
        minp = this.weekdaysMin(mom, '');
        shortp = this.weekdaysShort(mom, '');
        longp = this.weekdays(mom, '');
        minPieces.push(minp);
        shortPieces.push(shortp);
        longPieces.push(longp);
        mixedPieces.push(minp);
        mixedPieces.push(shortp);
        mixedPieces.push(longp);
    }
    // Sorting makes sure if one weekday (or abbr) is a prefix of another it
    // will match the longer piece.
    minPieces.sort(cmpLenRev);
    shortPieces.sort(cmpLenRev);
    longPieces.sort(cmpLenRev);
    mixedPieces.sort(cmpLenRev);
    for (i = 0; i < 7; i++) {
        shortPieces[i] = regexEscape(shortPieces[i]);
        longPieces[i] = regexEscape(longPieces[i]);
        mixedPieces[i] = regexEscape(mixedPieces[i]);
    }

    this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
    this._weekdaysShortRegex = this._weekdaysRegex;
    this._weekdaysMinRegex = this._weekdaysRegex;

    this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
    this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
    this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
}

// FORMATTING

function hFormat() {
    return this.hours() % 12 || 12;
}

function kFormat() {
    return this.hours() || 24;
}

addFormatToken('H', ['HH', 2], 0, 'hour');
addFormatToken('h', ['hh', 2], 0, hFormat);
addFormatToken('k', ['kk', 2], 0, kFormat);

addFormatToken('hmm', 0, 0, function () {
    return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
});

addFormatToken('hmmss', 0, 0, function () {
    return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) +
        zeroFill(this.seconds(), 2);
});

addFormatToken('Hmm', 0, 0, function () {
    return '' + this.hours() + zeroFill(this.minutes(), 2);
});

addFormatToken('Hmmss', 0, 0, function () {
    return '' + this.hours() + zeroFill(this.minutes(), 2) +
        zeroFill(this.seconds(), 2);
});

function meridiem (token, lowercase) {
    addFormatToken(token, 0, 0, function () {
        return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
    });
}

meridiem('a', true);
meridiem('A', false);

// ALIASES

addUnitAlias('hour', 'h');

// PRIORITY
addUnitPriority('hour', 13);

// PARSING

function matchMeridiem (isStrict, locale) {
    return locale._meridiemParse;
}

addRegexToken('a',  matchMeridiem);
addRegexToken('A',  matchMeridiem);
addRegexToken('H',  match1to2);
addRegexToken('h',  match1to2);
addRegexToken('k',  match1to2);
addRegexToken('HH', match1to2, match2);
addRegexToken('hh', match1to2, match2);
addRegexToken('kk', match1to2, match2);

addRegexToken('hmm', match3to4);
addRegexToken('hmmss', match5to6);
addRegexToken('Hmm', match3to4);
addRegexToken('Hmmss', match5to6);

addParseToken(['H', 'HH'], HOUR);
addParseToken(['k', 'kk'], function (input, array, config) {
    var kInput = toInt(input);
    array[HOUR] = kInput === 24 ? 0 : kInput;
});
addParseToken(['a', 'A'], function (input, array, config) {
    config._isPm = config._locale.isPM(input);
    config._meridiem = input;
});
addParseToken(['h', 'hh'], function (input, array, config) {
    array[HOUR] = toInt(input);
    getParsingFlags(config).bigHour = true;
});
addParseToken('hmm', function (input, array, config) {
    var pos = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos));
    array[MINUTE] = toInt(input.substr(pos));
    getParsingFlags(config).bigHour = true;
});
addParseToken('hmmss', function (input, array, config) {
    var pos1 = input.length - 4;
    var pos2 = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos1));
    array[MINUTE] = toInt(input.substr(pos1, 2));
    array[SECOND] = toInt(input.substr(pos2));
    getParsingFlags(config).bigHour = true;
});
addParseToken('Hmm', function (input, array, config) {
    var pos = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos));
    array[MINUTE] = toInt(input.substr(pos));
});
addParseToken('Hmmss', function (input, array, config) {
    var pos1 = input.length - 4;
    var pos2 = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos1));
    array[MINUTE] = toInt(input.substr(pos1, 2));
    array[SECOND] = toInt(input.substr(pos2));
});

// LOCALES

function localeIsPM (input) {
    // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
    // Using charAt should be more compatible.
    return ((input + '').toLowerCase().charAt(0) === 'p');
}

var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
function localeMeridiem (hours, minutes, isLower) {
    if (hours > 11) {
        return isLower ? 'pm' : 'PM';
    } else {
        return isLower ? 'am' : 'AM';
    }
}


// MOMENTS

// Setting the hour should keep the time, because the user explicitly
// specified which hour he wants. So trying to maintain the same hour (in
// a new timezone) makes sense. Adding/subtracting hours does not follow
// this rule.
var getSetHour = makeGetSet('Hours', true);

// months
// week
// weekdays
// meridiem
var baseConfig = {
    calendar: defaultCalendar,
    longDateFormat: defaultLongDateFormat,
    invalidDate: defaultInvalidDate,
    ordinal: defaultOrdinal,
    dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
    relativeTime: defaultRelativeTime,

    months: defaultLocaleMonths,
    monthsShort: defaultLocaleMonthsShort,

    week: defaultLocaleWeek,

    weekdays: defaultLocaleWeekdays,
    weekdaysMin: defaultLocaleWeekdaysMin,
    weekdaysShort: defaultLocaleWeekdaysShort,

    meridiemParse: defaultLocaleMeridiemParse
};

// internal storage for locale config files
var locales = {};
var localeFamilies = {};
var globalLocale;

function normalizeLocale(key) {
    return key ? key.toLowerCase().replace('_', '-') : key;
}

// pick the locale from the array
// try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
// substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
function chooseLocale(names) {
    var i = 0, j, next, locale, split;

    while (i < names.length) {
        split = normalizeLocale(names[i]).split('-');
        j = split.length;
        next = normalizeLocale(names[i + 1]);
        next = next ? next.split('-') : null;
        while (j > 0) {
            locale = loadLocale(split.slice(0, j).join('-'));
            if (locale) {
                return locale;
            }
            if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                //the next array item is better than a shallower substring of this one
                break;
            }
            j--;
        }
        i++;
    }
    return null;
}

function loadLocale(name) {
    var oldLocale = null;
    // TODO: Find a better way to register and load all the locales in Node
    if (!locales[name] && (typeof module !== 'undefined') &&
            module && module.exports) {
        try {
            oldLocale = globalLocale._abbr;
            var aliasedRequire = require;
            aliasedRequire('./locale/' + name);
            getSetGlobalLocale(oldLocale);
        } catch (e) {}
    }
    return locales[name];
}

// This function will load locale and then set the global locale.  If
// no arguments are passed in, it will simply return the current global
// locale key.
function getSetGlobalLocale (key, values) {
    var data;
    if (key) {
        if (isUndefined(values)) {
            data = getLocale(key);
        }
        else {
            data = defineLocale(key, values);
        }

        if (data) {
            // moment.duration._locale = moment._locale = data;
            globalLocale = data;
        }
    }

    return globalLocale._abbr;
}

function defineLocale (name, config) {
    if (config !== null) {
        var parentConfig = baseConfig;
        config.abbr = name;
        if (locales[name] != null) {
            deprecateSimple('defineLocaleOverride',
                    'use moment.updateLocale(localeName, config) to change ' +
                    'an existing locale. moment.defineLocale(localeName, ' +
                    'config) should only be used for creating a new locale ' +
                    'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');
            parentConfig = locales[name]._config;
        } else if (config.parentLocale != null) {
            if (locales[config.parentLocale] != null) {
                parentConfig = locales[config.parentLocale]._config;
            } else {
                if (!localeFamilies[config.parentLocale]) {
                    localeFamilies[config.parentLocale] = [];
                }
                localeFamilies[config.parentLocale].push({
                    name: name,
                    config: config
                });
                return null;
            }
        }
        locales[name] = new Locale(mergeConfigs(parentConfig, config));

        if (localeFamilies[name]) {
            localeFamilies[name].forEach(function (x) {
                defineLocale(x.name, x.config);
            });
        }

        // backwards compat for now: also set the locale
        // make sure we set the locale AFTER all child locales have been
        // created, so we won't end up with the child locale set.
        getSetGlobalLocale(name);


        return locales[name];
    } else {
        // useful for testing
        delete locales[name];
        return null;
    }
}

function updateLocale(name, config) {
    if (config != null) {
        var locale, tmpLocale, parentConfig = baseConfig;
        // MERGE
        tmpLocale = loadLocale(name);
        if (tmpLocale != null) {
            parentConfig = tmpLocale._config;
        }
        config = mergeConfigs(parentConfig, config);
        locale = new Locale(config);
        locale.parentLocale = locales[name];
        locales[name] = locale;

        // backwards compat for now: also set the locale
        getSetGlobalLocale(name);
    } else {
        // pass null for config to unupdate, useful for tests
        if (locales[name] != null) {
            if (locales[name].parentLocale != null) {
                locales[name] = locales[name].parentLocale;
            } else if (locales[name] != null) {
                delete locales[name];
            }
        }
    }
    return locales[name];
}

// returns locale data
function getLocale (key) {
    var locale;

    if (key && key._locale && key._locale._abbr) {
        key = key._locale._abbr;
    }

    if (!key) {
        return globalLocale;
    }

    if (!isArray(key)) {
        //short-circuit everything else
        locale = loadLocale(key);
        if (locale) {
            return locale;
        }
        key = [key];
    }

    return chooseLocale(key);
}

function listLocales() {
    return keys(locales);
}

function checkOverflow (m) {
    var overflow;
    var a = m._a;

    if (a && getParsingFlags(m).overflow === -2) {
        overflow =
            a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :
            a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :
            a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :
            a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :
            a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :
            a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :
            -1;

        if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
            overflow = DATE;
        }
        if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
            overflow = WEEK;
        }
        if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
            overflow = WEEKDAY;
        }

        getParsingFlags(m).overflow = overflow;
    }

    return m;
}

// Pick the first defined of two or three arguments.
function defaults(a, b, c) {
    if (a != null) {
        return a;
    }
    if (b != null) {
        return b;
    }
    return c;
}

function currentDateArray(config) {
    // hooks is actually the exported moment object
    var nowValue = new Date(hooks.now());
    if (config._useUTC) {
        return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
    }
    return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
}

// convert an array to a date.
// the array should mirror the parameters below
// note: all values past the year are optional and will default to the lowest possible value.
// [year, month, day , hour, minute, second, millisecond]
function configFromArray (config) {
    var i, date, input = [], currentDate, expectedWeekday, yearToUse;

    if (config._d) {
        return;
    }

    currentDate = currentDateArray(config);

    //compute day of the year from weeks and weekdays
    if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
        dayOfYearFromWeekInfo(config);
    }

    //if the day of the year is set, figure out what it is
    if (config._dayOfYear != null) {
        yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

        if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
            getParsingFlags(config)._overflowDayOfYear = true;
        }

        date = createUTCDate(yearToUse, 0, config._dayOfYear);
        config._a[MONTH] = date.getUTCMonth();
        config._a[DATE] = date.getUTCDate();
    }

    // Default to current date.
    // * if no year, month, day of month are given, default to today
    // * if day of month is given, default month and year
    // * if month is given, default only year
    // * if year is given, don't default anything
    for (i = 0; i < 3 && config._a[i] == null; ++i) {
        config._a[i] = input[i] = currentDate[i];
    }

    // Zero out whatever was not defaulted, including time
    for (; i < 7; i++) {
        config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
    }

    // Check for 24:00:00.000
    if (config._a[HOUR] === 24 &&
            config._a[MINUTE] === 0 &&
            config._a[SECOND] === 0 &&
            config._a[MILLISECOND] === 0) {
        config._nextDay = true;
        config._a[HOUR] = 0;
    }

    config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
    expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();

    // Apply timezone offset from input. The actual utcOffset can be changed
    // with parseZone.
    if (config._tzm != null) {
        config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
    }

    if (config._nextDay) {
        config._a[HOUR] = 24;
    }

    // check for mismatching day of week
    if (config._w && typeof config._w.d !== 'undefined' && config._w.d !== expectedWeekday) {
        getParsingFlags(config).weekdayMismatch = true;
    }
}

function dayOfYearFromWeekInfo(config) {
    var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;

    w = config._w;
    if (w.GG != null || w.W != null || w.E != null) {
        dow = 1;
        doy = 4;

        // TODO: We need to take the current isoWeekYear, but that depends on
        // how we interpret now (local, utc, fixed offset). So create
        // a now version of current config (take local/utc/offset flags, and
        // create now).
        weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
        week = defaults(w.W, 1);
        weekday = defaults(w.E, 1);
        if (weekday < 1 || weekday > 7) {
            weekdayOverflow = true;
        }
    } else {
        dow = config._locale._week.dow;
        doy = config._locale._week.doy;

        var curWeek = weekOfYear(createLocal(), dow, doy);

        weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);

        // Default to current week.
        week = defaults(w.w, curWeek.week);

        if (w.d != null) {
            // weekday -- low day numbers are considered next week
            weekday = w.d;
            if (weekday < 0 || weekday > 6) {
                weekdayOverflow = true;
            }
        } else if (w.e != null) {
            // local weekday -- counting starts from begining of week
            weekday = w.e + dow;
            if (w.e < 0 || w.e > 6) {
                weekdayOverflow = true;
            }
        } else {
            // default to begining of week
            weekday = dow;
        }
    }
    if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
        getParsingFlags(config)._overflowWeeks = true;
    } else if (weekdayOverflow != null) {
        getParsingFlags(config)._overflowWeekday = true;
    } else {
        temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
        config._a[YEAR] = temp.year;
        config._dayOfYear = temp.dayOfYear;
    }
}

// iso 8601 regex
// 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;

var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;

var isoDates = [
    ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
    ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
    ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
    ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
    ['YYYY-DDD', /\d{4}-\d{3}/],
    ['YYYY-MM', /\d{4}-\d\d/, false],
    ['YYYYYYMMDD', /[+-]\d{10}/],
    ['YYYYMMDD', /\d{8}/],
    // YYYYMM is NOT allowed by the standard
    ['GGGG[W]WWE', /\d{4}W\d{3}/],
    ['GGGG[W]WW', /\d{4}W\d{2}/, false],
    ['YYYYDDD', /\d{7}/]
];

// iso time formats and regexes
var isoTimes = [
    ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
    ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
    ['HH:mm:ss', /\d\d:\d\d:\d\d/],
    ['HH:mm', /\d\d:\d\d/],
    ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
    ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
    ['HHmmss', /\d\d\d\d\d\d/],
    ['HHmm', /\d\d\d\d/],
    ['HH', /\d\d/]
];

var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;

// date from iso format
function configFromISO(config) {
    var i, l,
        string = config._i,
        match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
        allowTime, dateFormat, timeFormat, tzFormat;

    if (match) {
        getParsingFlags(config).iso = true;

        for (i = 0, l = isoDates.length; i < l; i++) {
            if (isoDates[i][1].exec(match[1])) {
                dateFormat = isoDates[i][0];
                allowTime = isoDates[i][2] !== false;
                break;
            }
        }
        if (dateFormat == null) {
            config._isValid = false;
            return;
        }
        if (match[3]) {
            for (i = 0, l = isoTimes.length; i < l; i++) {
                if (isoTimes[i][1].exec(match[3])) {
                    // match[2] should be 'T' or space
                    timeFormat = (match[2] || ' ') + isoTimes[i][0];
                    break;
                }
            }
            if (timeFormat == null) {
                config._isValid = false;
                return;
            }
        }
        if (!allowTime && timeFormat != null) {
            config._isValid = false;
            return;
        }
        if (match[4]) {
            if (tzRegex.exec(match[4])) {
                tzFormat = 'Z';
            } else {
                config._isValid = false;
                return;
            }
        }
        config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
        configFromStringAndFormat(config);
    } else {
        config._isValid = false;
    }
}

// RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3
var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/;

function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
    var result = [
        untruncateYear(yearStr),
        defaultLocaleMonthsShort.indexOf(monthStr),
        parseInt(dayStr, 10),
        parseInt(hourStr, 10),
        parseInt(minuteStr, 10)
    ];

    if (secondStr) {
        result.push(parseInt(secondStr, 10));
    }

    return result;
}

function untruncateYear(yearStr) {
    var year = parseInt(yearStr, 10);
    if (year <= 49) {
        return 2000 + year;
    } else if (year <= 999) {
        return 1900 + year;
    }
    return year;
}

function preprocessRFC2822(s) {
    // Remove comments and folding whitespace and replace multiple-spaces with a single space
    return s.replace(/\([^)]*\)|[\n\t]/g, ' ').replace(/(\s\s+)/g, ' ').trim();
}

function checkWeekday(weekdayStr, parsedInput, config) {
    if (weekdayStr) {
        // TODO: Replace the vanilla JS Date object with an indepentent day-of-week check.
        var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),
            weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();
        if (weekdayProvided !== weekdayActual) {
            getParsingFlags(config).weekdayMismatch = true;
            config._isValid = false;
            return false;
        }
    }
    return true;
}

var obsOffsets = {
    UT: 0,
    GMT: 0,
    EDT: -4 * 60,
    EST: -5 * 60,
    CDT: -5 * 60,
    CST: -6 * 60,
    MDT: -6 * 60,
    MST: -7 * 60,
    PDT: -7 * 60,
    PST: -8 * 60
};

function calculateOffset(obsOffset, militaryOffset, numOffset) {
    if (obsOffset) {
        return obsOffsets[obsOffset];
    } else if (militaryOffset) {
        // the only allowed military tz is Z
        return 0;
    } else {
        var hm = parseInt(numOffset, 10);
        var m = hm % 100, h = (hm - m) / 100;
        return h * 60 + m;
    }
}

// date and time from ref 2822 format
function configFromRFC2822(config) {
    var match = rfc2822.exec(preprocessRFC2822(config._i));
    if (match) {
        var parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);
        if (!checkWeekday(match[1], parsedArray, config)) {
            return;
        }

        config._a = parsedArray;
        config._tzm = calculateOffset(match[8], match[9], match[10]);

        config._d = createUTCDate.apply(null, config._a);
        config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);

        getParsingFlags(config).rfc2822 = true;
    } else {
        config._isValid = false;
    }
}

// date from iso format or fallback
function configFromString(config) {
    var matched = aspNetJsonRegex.exec(config._i);

    if (matched !== null) {
        config._d = new Date(+matched[1]);
        return;
    }

    configFromISO(config);
    if (config._isValid === false) {
        delete config._isValid;
    } else {
        return;
    }

    configFromRFC2822(config);
    if (config._isValid === false) {
        delete config._isValid;
    } else {
        return;
    }

    // Final attempt, use Input Fallback
    hooks.createFromInputFallback(config);
}

hooks.createFromInputFallback = deprecate(
    'value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' +
    'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' +
    'discouraged and will be removed in an upcoming major release. Please refer to ' +
    'http://momentjs.com/guides/#/warnings/js-date/ for more info.',
    function (config) {
        config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
    }
);

// constant that refers to the ISO standard
hooks.ISO_8601 = function () {};

// constant that refers to the RFC 2822 form
hooks.RFC_2822 = function () {};

// date from string and format string
function configFromStringAndFormat(config) {
    // TODO: Move this to another part of the creation flow to prevent circular deps
    if (config._f === hooks.ISO_8601) {
        configFromISO(config);
        return;
    }
    if (config._f === hooks.RFC_2822) {
        configFromRFC2822(config);
        return;
    }
    config._a = [];
    getParsingFlags(config).empty = true;

    // This array is used to make a Date, either with `new Date` or `Date.UTC`
    var string = '' + config._i,
        i, parsedInput, tokens, token, skipped,
        stringLength = string.length,
        totalParsedInputLength = 0;

    tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

    for (i = 0; i < tokens.length; i++) {
        token = tokens[i];
        parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
        // console.log('token', token, 'parsedInput', parsedInput,
        //         'regex', getParseRegexForToken(token, config));
        if (parsedInput) {
            skipped = string.substr(0, string.indexOf(parsedInput));
            if (skipped.length > 0) {
                getParsingFlags(config).unusedInput.push(skipped);
            }
            string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
            totalParsedInputLength += parsedInput.length;
        }
        // don't parse if it's not a known token
        if (formatTokenFunctions[token]) {
            if (parsedInput) {
                getParsingFlags(config).empty = false;
            }
            else {
                getParsingFlags(config).unusedTokens.push(token);
            }
            addTimeToArrayFromToken(token, parsedInput, config);
        }
        else if (config._strict && !parsedInput) {
            getParsingFlags(config).unusedTokens.push(token);
        }
    }

    // add remaining unparsed input length to the string
    getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
    if (string.length > 0) {
        getParsingFlags(config).unusedInput.push(string);
    }

    // clear _12h flag if hour is <= 12
    if (config._a[HOUR] <= 12 &&
        getParsingFlags(config).bigHour === true &&
        config._a[HOUR] > 0) {
        getParsingFlags(config).bigHour = undefined;
    }

    getParsingFlags(config).parsedDateParts = config._a.slice(0);
    getParsingFlags(config).meridiem = config._meridiem;
    // handle meridiem
    config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);

    configFromArray(config);
    checkOverflow(config);
}


function meridiemFixWrap (locale, hour, meridiem) {
    var isPm;

    if (meridiem == null) {
        // nothing to do
        return hour;
    }
    if (locale.meridiemHour != null) {
        return locale.meridiemHour(hour, meridiem);
    } else if (locale.isPM != null) {
        // Fallback
        isPm = locale.isPM(meridiem);
        if (isPm && hour < 12) {
            hour += 12;
        }
        if (!isPm && hour === 12) {
            hour = 0;
        }
        return hour;
    } else {
        // this is not supposed to happen
        return hour;
    }
}

// date from string and array of format strings
function configFromStringAndArray(config) {
    var tempConfig,
        bestMoment,

        scoreToBeat,
        i,
        currentScore;

    if (config._f.length === 0) {
        getParsingFlags(config).invalidFormat = true;
        config._d = new Date(NaN);
        return;
    }

    for (i = 0; i < config._f.length; i++) {
        currentScore = 0;
        tempConfig = copyConfig({}, config);
        if (config._useUTC != null) {
            tempConfig._useUTC = config._useUTC;
        }
        tempConfig._f = config._f[i];
        configFromStringAndFormat(tempConfig);

        if (!isValid(tempConfig)) {
            continue;
        }

        // if there is any input that was not parsed add a penalty for that format
        currentScore += getParsingFlags(tempConfig).charsLeftOver;

        //or tokens
        currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

        getParsingFlags(tempConfig).score = currentScore;

        if (scoreToBeat == null || currentScore < scoreToBeat) {
            scoreToBeat = currentScore;
            bestMoment = tempConfig;
        }
    }

    extend(config, bestMoment || tempConfig);
}

function configFromObject(config) {
    if (config._d) {
        return;
    }

    var i = normalizeObjectUnits(config._i);
    config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {
        return obj && parseInt(obj, 10);
    });

    configFromArray(config);
}

function createFromConfig (config) {
    var res = new Moment(checkOverflow(prepareConfig(config)));
    if (res._nextDay) {
        // Adding is smart enough around DST
        res.add(1, 'd');
        res._nextDay = undefined;
    }

    return res;
}

function prepareConfig (config) {
    var input = config._i,
        format = config._f;

    config._locale = config._locale || getLocale(config._l);

    if (input === null || (format === undefined && input === '')) {
        return createInvalid({nullInput: true});
    }

    if (typeof input === 'string') {
        config._i = input = config._locale.preparse(input);
    }

    if (isMoment(input)) {
        return new Moment(checkOverflow(input));
    } else if (isDate(input)) {
        config._d = input;
    } else if (isArray(format)) {
        configFromStringAndArray(config);
    } else if (format) {
        configFromStringAndFormat(config);
    }  else {
        configFromInput(config);
    }

    if (!isValid(config)) {
        config._d = null;
    }

    return config;
}

function configFromInput(config) {
    var input = config._i;
    if (isUndefined(input)) {
        config._d = new Date(hooks.now());
    } else if (isDate(input)) {
        config._d = new Date(input.valueOf());
    } else if (typeof input === 'string') {
        configFromString(config);
    } else if (isArray(input)) {
        config._a = map(input.slice(0), function (obj) {
            return parseInt(obj, 10);
        });
        configFromArray(config);
    } else if (isObject(input)) {
        configFromObject(config);
    } else if (isNumber(input)) {
        // from milliseconds
        config._d = new Date(input);
    } else {
        hooks.createFromInputFallback(config);
    }
}

function createLocalOrUTC (input, format, locale, strict, isUTC) {
    var c = {};

    if (locale === true || locale === false) {
        strict = locale;
        locale = undefined;
    }

    if ((isObject(input) && isObjectEmpty(input)) ||
            (isArray(input) && input.length === 0)) {
        input = undefined;
    }
    // object construction must be done this way.
    // https://github.com/moment/moment/issues/1423
    c._isAMomentObject = true;
    c._useUTC = c._isUTC = isUTC;
    c._l = locale;
    c._i = input;
    c._f = format;
    c._strict = strict;

    return createFromConfig(c);
}

function createLocal (input, format, locale, strict) {
    return createLocalOrUTC(input, format, locale, strict, false);
}

var prototypeMin = deprecate(
    'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',
    function () {
        var other = createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
            return other < this ? this : other;
        } else {
            return createInvalid();
        }
    }
);

var prototypeMax = deprecate(
    'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',
    function () {
        var other = createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
            return other > this ? this : other;
        } else {
            return createInvalid();
        }
    }
);

// Pick a moment m from moments so that m[fn](other) is true for all
// other. This relies on the function fn to be transitive.
//
// moments should either be an array of moment objects or an array, whose
// first element is an array of moment objects.
function pickBy(fn, moments) {
    var res, i;
    if (moments.length === 1 && isArray(moments[0])) {
        moments = moments[0];
    }
    if (!moments.length) {
        return createLocal();
    }
    res = moments[0];
    for (i = 1; i < moments.length; ++i) {
        if (!moments[i].isValid() || moments[i][fn](res)) {
            res = moments[i];
        }
    }
    return res;
}

// TODO: Use [].sort instead?
function min () {
    var args = [].slice.call(arguments, 0);

    return pickBy('isBefore', args);
}

function max () {
    var args = [].slice.call(arguments, 0);

    return pickBy('isAfter', args);
}

var now = function () {
    return Date.now ? Date.now() : +(new Date());
};

var ordering = ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'];

function isDurationValid(m) {
    for (var key in m) {
        if (!(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
            return false;
        }
    }

    var unitHasDecimal = false;
    for (var i = 0; i < ordering.length; ++i) {
        if (m[ordering[i]]) {
            if (unitHasDecimal) {
                return false; // only allow non-integers for smallest unit
            }
            if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
                unitHasDecimal = true;
            }
        }
    }

    return true;
}

function isValid$1() {
    return this._isValid;
}

function createInvalid$1() {
    return createDuration(NaN);
}

function Duration (duration) {
    var normalizedInput = normalizeObjectUnits(duration),
        years = normalizedInput.year || 0,
        quarters = normalizedInput.quarter || 0,
        months = normalizedInput.month || 0,
        weeks = normalizedInput.week || 0,
        days = normalizedInput.day || 0,
        hours = normalizedInput.hour || 0,
        minutes = normalizedInput.minute || 0,
        seconds = normalizedInput.second || 0,
        milliseconds = normalizedInput.millisecond || 0;

    this._isValid = isDurationValid(normalizedInput);

    // representation for dateAddRemove
    this._milliseconds = +milliseconds +
        seconds * 1e3 + // 1000
        minutes * 6e4 + // 1000 * 60
        hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
    // Because of dateAddRemove treats 24 hours as different from a
    // day when working around DST, we need to store them separately
    this._days = +days +
        weeks * 7;
    // It is impossible to translate months into days without knowing
    // which months you are are talking about, so we have to store
    // it separately.
    this._months = +months +
        quarters * 3 +
        years * 12;

    this._data = {};

    this._locale = getLocale();

    this._bubble();
}

function isDuration (obj) {
    return obj instanceof Duration;
}

function absRound (number) {
    if (number < 0) {
        return Math.round(-1 * number) * -1;
    } else {
        return Math.round(number);
    }
}

// FORMATTING

function offset (token, separator) {
    addFormatToken(token, 0, 0, function () {
        var offset = this.utcOffset();
        var sign = '+';
        if (offset < 0) {
            offset = -offset;
            sign = '-';
        }
        return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
    });
}

offset('Z', ':');
offset('ZZ', '');

// PARSING

addRegexToken('Z',  matchShortOffset);
addRegexToken('ZZ', matchShortOffset);
addParseToken(['Z', 'ZZ'], function (input, array, config) {
    config._useUTC = true;
    config._tzm = offsetFromString(matchShortOffset, input);
});

// HELPERS

// timezone chunker
// '+10:00' > ['10',  '00']
// '-1530'  > ['-15', '30']
var chunkOffset = /([\+\-]|\d\d)/gi;

function offsetFromString(matcher, string) {
    var matches = (string || '').match(matcher);

    if (matches === null) {
        return null;
    }

    var chunk   = matches[matches.length - 1] || [];
    var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];
    var minutes = +(parts[1] * 60) + toInt(parts[2]);

    return minutes === 0 ?
      0 :
      parts[0] === '+' ? minutes : -minutes;
}

// Return a moment from input, that is local/utc/zone equivalent to model.
function cloneWithOffset(input, model) {
    var res, diff;
    if (model._isUTC) {
        res = model.clone();
        diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
        // Use low-level api, because this fn is low-level api.
        res._d.setTime(res._d.valueOf() + diff);
        hooks.updateOffset(res, false);
        return res;
    } else {
        return createLocal(input).local();
    }
}

function getDateOffset (m) {
    // On Firefox.24 Date#getTimezoneOffset returns a floating point.
    // https://github.com/moment/moment/pull/1871
    return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
}

// HOOKS

// This function will be called whenever a moment is mutated.
// It is intended to keep the offset in sync with the timezone.
hooks.updateOffset = function () {};

// MOMENTS

// keepLocalTime = true means only change the timezone, without
// affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
// 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
// +0200, so we adjust the time as needed, to be valid.
//
// Keeping the time actually adds/subtracts (one hour)
// from the actual represented time. That is why we call updateOffset
// a second time. In case it wants us to change the offset again
// _changeInProgress == true case, then we have to adjust, because
// there is no such time in the given timezone.
function getSetOffset (input, keepLocalTime, keepMinutes) {
    var offset = this._offset || 0,
        localAdjust;
    if (!this.isValid()) {
        return input != null ? this : NaN;
    }
    if (input != null) {
        if (typeof input === 'string') {
            input = offsetFromString(matchShortOffset, input);
            if (input === null) {
                return this;
            }
        } else if (Math.abs(input) < 16 && !keepMinutes) {
            input = input * 60;
        }
        if (!this._isUTC && keepLocalTime) {
            localAdjust = getDateOffset(this);
        }
        this._offset = input;
        this._isUTC = true;
        if (localAdjust != null) {
            this.add(localAdjust, 'm');
        }
        if (offset !== input) {
            if (!keepLocalTime || this._changeInProgress) {
                addSubtract(this, createDuration(input - offset, 'm'), 1, false);
            } else if (!this._changeInProgress) {
                this._changeInProgress = true;
                hooks.updateOffset(this, true);
                this._changeInProgress = null;
            }
        }
        return this;
    } else {
        return this._isUTC ? offset : getDateOffset(this);
    }
}

function getSetZone (input, keepLocalTime) {
    if (input != null) {
        if (typeof input !== 'string') {
            input = -input;
        }

        this.utcOffset(input, keepLocalTime);

        return this;
    } else {
        return -this.utcOffset();
    }
}

function setOffsetToUTC (keepLocalTime) {
    return this.utcOffset(0, keepLocalTime);
}

function setOffsetToLocal (keepLocalTime) {
    if (this._isUTC) {
        this.utcOffset(0, keepLocalTime);
        this._isUTC = false;

        if (keepLocalTime) {
            this.subtract(getDateOffset(this), 'm');
        }
    }
    return this;
}

function setOffsetToParsedOffset () {
    if (this._tzm != null) {
        this.utcOffset(this._tzm, false, true);
    } else if (typeof this._i === 'string') {
        var tZone = offsetFromString(matchOffset, this._i);
        if (tZone != null) {
            this.utcOffset(tZone);
        }
        else {
            this.utcOffset(0, true);
        }
    }
    return this;
}

function hasAlignedHourOffset (input) {
    if (!this.isValid()) {
        return false;
    }
    input = input ? createLocal(input).utcOffset() : 0;

    return (this.utcOffset() - input) % 60 === 0;
}

function isDaylightSavingTime () {
    return (
        this.utcOffset() > this.clone().month(0).utcOffset() ||
        this.utcOffset() > this.clone().month(5).utcOffset()
    );
}

function isDaylightSavingTimeShifted () {
    if (!isUndefined(this._isDSTShifted)) {
        return this._isDSTShifted;
    }

    var c = {};

    copyConfig(c, this);
    c = prepareConfig(c);

    if (c._a) {
        var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
        this._isDSTShifted = this.isValid() &&
            compareArrays(c._a, other.toArray()) > 0;
    } else {
        this._isDSTShifted = false;
    }

    return this._isDSTShifted;
}

function isLocal () {
    return this.isValid() ? !this._isUTC : false;
}

function isUtcOffset () {
    return this.isValid() ? this._isUTC : false;
}

function isUtc () {
    return this.isValid() ? this._isUTC && this._offset === 0 : false;
}

// ASP.NET json date format regex
var aspNetRegex = /^(\-|\+)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/;

// from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
// somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
// and further modified to allow for strings containing both week and day
var isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;

function createDuration (input, key) {
    var duration = input,
        // matching against regexp is expensive, do it on demand
        match = null,
        sign,
        ret,
        diffRes;

    if (isDuration(input)) {
        duration = {
            ms : input._milliseconds,
            d  : input._days,
            M  : input._months
        };
    } else if (isNumber(input)) {
        duration = {};
        if (key) {
            duration[key] = input;
        } else {
            duration.milliseconds = input;
        }
    } else if (!!(match = aspNetRegex.exec(input))) {
        sign = (match[1] === '-') ? -1 : 1;
        duration = {
            y  : 0,
            d  : toInt(match[DATE])                         * sign,
            h  : toInt(match[HOUR])                         * sign,
            m  : toInt(match[MINUTE])                       * sign,
            s  : toInt(match[SECOND])                       * sign,
            ms : toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match
        };
    } else if (!!(match = isoRegex.exec(input))) {
        sign = (match[1] === '-') ? -1 : (match[1] === '+') ? 1 : 1;
        duration = {
            y : parseIso(match[2], sign),
            M : parseIso(match[3], sign),
            w : parseIso(match[4], sign),
            d : parseIso(match[5], sign),
            h : parseIso(match[6], sign),
            m : parseIso(match[7], sign),
            s : parseIso(match[8], sign)
        };
    } else if (duration == null) {// checks for null or undefined
        duration = {};
    } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
        diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));

        duration = {};
        duration.ms = diffRes.milliseconds;
        duration.M = diffRes.months;
    }

    ret = new Duration(duration);

    if (isDuration(input) && hasOwnProp(input, '_locale')) {
        ret._locale = input._locale;
    }

    return ret;
}

createDuration.fn = Duration.prototype;
createDuration.invalid = createInvalid$1;

function parseIso (inp, sign) {
    // We'd normally use ~~inp for this, but unfortunately it also
    // converts floats to ints.
    // inp may be undefined, so careful calling replace on it.
    var res = inp && parseFloat(inp.replace(',', '.'));
    // apply sign while we're at it
    return (isNaN(res) ? 0 : res) * sign;
}

function positiveMomentsDifference(base, other) {
    var res = {milliseconds: 0, months: 0};

    res.months = other.month() - base.month() +
        (other.year() - base.year()) * 12;
    if (base.clone().add(res.months, 'M').isAfter(other)) {
        --res.months;
    }

    res.milliseconds = +other - +(base.clone().add(res.months, 'M'));

    return res;
}

function momentsDifference(base, other) {
    var res;
    if (!(base.isValid() && other.isValid())) {
        return {milliseconds: 0, months: 0};
    }

    other = cloneWithOffset(other, base);
    if (base.isBefore(other)) {
        res = positiveMomentsDifference(base, other);
    } else {
        res = positiveMomentsDifference(other, base);
        res.milliseconds = -res.milliseconds;
        res.months = -res.months;
    }

    return res;
}

// TODO: remove 'name' arg after deprecation is removed
function createAdder(direction, name) {
    return function (val, period) {
        var dur, tmp;
        //invert the arguments, but complain about it
        if (period !== null && !isNaN(+period)) {
            deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' +
            'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');
            tmp = val; val = period; period = tmp;
        }

        val = typeof val === 'string' ? +val : val;
        dur = createDuration(val, period);
        addSubtract(this, dur, direction);
        return this;
    };
}

function addSubtract (mom, duration, isAdding, updateOffset) {
    var milliseconds = duration._milliseconds,
        days = absRound(duration._days),
        months = absRound(duration._months);

    if (!mom.isValid()) {
        // No op
        return;
    }

    updateOffset = updateOffset == null ? true : updateOffset;

    if (months) {
        setMonth(mom, get(mom, 'Month') + months * isAdding);
    }
    if (days) {
        set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
    }
    if (milliseconds) {
        mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
    }
    if (updateOffset) {
        hooks.updateOffset(mom, days || months);
    }
}

var add      = createAdder(1, 'add');
var subtract = createAdder(-1, 'subtract');

function getCalendarFormat(myMoment, now) {
    var diff = myMoment.diff(now, 'days', true);
    return diff < -6 ? 'sameElse' :
            diff < -1 ? 'lastWeek' :
            diff < 0 ? 'lastDay' :
            diff < 1 ? 'sameDay' :
            diff < 2 ? 'nextDay' :
            diff < 7 ? 'nextWeek' : 'sameElse';
}

function calendar$1 (time, formats) {
    // We want to compare the start of today, vs this.
    // Getting start-of-today depends on whether we're local/utc/offset or not.
    var now = time || createLocal(),
        sod = cloneWithOffset(now, this).startOf('day'),
        format = hooks.calendarFormat(this, sod) || 'sameElse';

    var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);

    return this.format(output || this.localeData().calendar(format, this, createLocal(now)));
}

function clone () {
    return new Moment(this);
}

function isAfter (input, units) {
    var localInput = isMoment(input) ? input : createLocal(input);
    if (!(this.isValid() && localInput.isValid())) {
        return false;
    }
    units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
    if (units === 'millisecond') {
        return this.valueOf() > localInput.valueOf();
    } else {
        return localInput.valueOf() < this.clone().startOf(units).valueOf();
    }
}

function isBefore (input, units) {
    var localInput = isMoment(input) ? input : createLocal(input);
    if (!(this.isValid() && localInput.isValid())) {
        return false;
    }
    units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
    if (units === 'millisecond') {
        return this.valueOf() < localInput.valueOf();
    } else {
        return this.clone().endOf(units).valueOf() < localInput.valueOf();
    }
}

function isBetween (from, to, units, inclusivity) {
    inclusivity = inclusivity || '()';
    return (inclusivity[0] === '(' ? this.isAfter(from, units) : !this.isBefore(from, units)) &&
        (inclusivity[1] === ')' ? this.isBefore(to, units) : !this.isAfter(to, units));
}

function isSame (input, units) {
    var localInput = isMoment(input) ? input : createLocal(input),
        inputMs;
    if (!(this.isValid() && localInput.isValid())) {
        return false;
    }
    units = normalizeUnits(units || 'millisecond');
    if (units === 'millisecond') {
        return this.valueOf() === localInput.valueOf();
    } else {
        inputMs = localInput.valueOf();
        return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
    }
}

function isSameOrAfter (input, units) {
    return this.isSame(input, units) || this.isAfter(input,units);
}

function isSameOrBefore (input, units) {
    return this.isSame(input, units) || this.isBefore(input,units);
}

function diff (input, units, asFloat) {
    var that,
        zoneDelta,
        delta, output;

    if (!this.isValid()) {
        return NaN;
    }

    that = cloneWithOffset(input, this);

    if (!that.isValid()) {
        return NaN;
    }

    zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

    units = normalizeUnits(units);

    switch (units) {
        case 'year': output = monthDiff(this, that) / 12; break;
        case 'month': output = monthDiff(this, that); break;
        case 'quarter': output = monthDiff(this, that) / 3; break;
        case 'second': output = (this - that) / 1e3; break; // 1000
        case 'minute': output = (this - that) / 6e4; break; // 1000 * 60
        case 'hour': output = (this - that) / 36e5; break; // 1000 * 60 * 60
        case 'day': output = (this - that - zoneDelta) / 864e5; break; // 1000 * 60 * 60 * 24, negate dst
        case 'week': output = (this - that - zoneDelta) / 6048e5; break; // 1000 * 60 * 60 * 24 * 7, negate dst
        default: output = this - that;
    }

    return asFloat ? output : absFloor(output);
}

function monthDiff (a, b) {
    // difference in months
    var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
        // b is in (anchor - 1 month, anchor + 1 month)
        anchor = a.clone().add(wholeMonthDiff, 'months'),
        anchor2, adjust;

    if (b - anchor < 0) {
        anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
        // linear across the month
        adjust = (b - anchor) / (anchor - anchor2);
    } else {
        anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
        // linear across the month
        adjust = (b - anchor) / (anchor2 - anchor);
    }

    //check for negative zero, return zero if negative zero
    return -(wholeMonthDiff + adjust) || 0;
}

hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

function toString () {
    return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
}

function toISOString(keepOffset) {
    if (!this.isValid()) {
        return null;
    }
    var utc = keepOffset !== true;
    var m = utc ? this.clone().utc() : this;
    if (m.year() < 0 || m.year() > 9999) {
        return formatMoment(m, utc ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ');
    }
    if (isFunction(Date.prototype.toISOString)) {
        // native implementation is ~50x faster, use it when we can
        if (utc) {
            return this.toDate().toISOString();
        } else {
            return new Date(this._d.valueOf()).toISOString().replace('Z', formatMoment(m, 'Z'));
        }
    }
    return formatMoment(m, utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ');
}

/**
 * Return a human readable representation of a moment that can
 * also be evaluated to get a new moment which is the same
 *
 * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
 */
function inspect () {
    if (!this.isValid()) {
        return 'moment.invalid(/* ' + this._i + ' */)';
    }
    var func = 'moment';
    var zone = '';
    if (!this.isLocal()) {
        func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
        zone = 'Z';
    }
    var prefix = '[' + func + '("]';
    var year = (0 <= this.year() && this.year() <= 9999) ? 'YYYY' : 'YYYYYY';
    var datetime = '-MM-DD[T]HH:mm:ss.SSS';
    var suffix = zone + '[")]';

    return this.format(prefix + year + datetime + suffix);
}

function format (inputString) {
    if (!inputString) {
        inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
    }
    var output = formatMoment(this, inputString);
    return this.localeData().postformat(output);
}

function from (time, withoutSuffix) {
    if (this.isValid() &&
            ((isMoment(time) && time.isValid()) ||
             createLocal(time).isValid())) {
        return createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
    } else {
        return this.localeData().invalidDate();
    }
}

function fromNow (withoutSuffix) {
    return this.from(createLocal(), withoutSuffix);
}

function to (time, withoutSuffix) {
    if (this.isValid() &&
            ((isMoment(time) && time.isValid()) ||
             createLocal(time).isValid())) {
        return createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);
    } else {
        return this.localeData().invalidDate();
    }
}

function toNow (withoutSuffix) {
    return this.to(createLocal(), withoutSuffix);
}

// If passed a locale key, it will set the locale for this
// instance.  Otherwise, it will return the locale configuration
// variables for this instance.
function locale (key) {
    var newLocaleData;

    if (key === undefined) {
        return this._locale._abbr;
    } else {
        newLocaleData = getLocale(key);
        if (newLocaleData != null) {
            this._locale = newLocaleData;
        }
        return this;
    }
}

var lang = deprecate(
    'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
    function (key) {
        if (key === undefined) {
            return this.localeData();
        } else {
            return this.locale(key);
        }
    }
);

function localeData () {
    return this._locale;
}

function startOf (units) {
    units = normalizeUnits(units);
    // the following switch intentionally omits break keywords
    // to utilize falling through the cases.
    switch (units) {
        case 'year':
            this.month(0);
            /* falls through */
        case 'quarter':
        case 'month':
            this.date(1);
            /* falls through */
        case 'week':
        case 'isoWeek':
        case 'day':
        case 'date':
            this.hours(0);
            /* falls through */
        case 'hour':
            this.minutes(0);
            /* falls through */
        case 'minute':
            this.seconds(0);
            /* falls through */
        case 'second':
            this.milliseconds(0);
    }

    // weeks are a special case
    if (units === 'week') {
        this.weekday(0);
    }
    if (units === 'isoWeek') {
        this.isoWeekday(1);
    }

    // quarters are also special
    if (units === 'quarter') {
        this.month(Math.floor(this.month() / 3) * 3);
    }

    return this;
}

function endOf (units) {
    units = normalizeUnits(units);
    if (units === undefined || units === 'millisecond') {
        return this;
    }

    // 'date' is an alias for 'day', so it should be considered as such.
    if (units === 'date') {
        units = 'day';
    }

    return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
}

function valueOf () {
    return this._d.valueOf() - ((this._offset || 0) * 60000);
}

function unix () {
    return Math.floor(this.valueOf() / 1000);
}

function toDate () {
    return new Date(this.valueOf());
}

function toArray () {
    var m = this;
    return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
}

function toObject () {
    var m = this;
    return {
        years: m.year(),
        months: m.month(),
        date: m.date(),
        hours: m.hours(),
        minutes: m.minutes(),
        seconds: m.seconds(),
        milliseconds: m.milliseconds()
    };
}

function toJSON () {
    // new Date(NaN).toJSON() === null
    return this.isValid() ? this.toISOString() : null;
}

function isValid$2 () {
    return isValid(this);
}

function parsingFlags () {
    return extend({}, getParsingFlags(this));
}

function invalidAt () {
    return getParsingFlags(this).overflow;
}

function creationData() {
    return {
        input: this._i,
        format: this._f,
        locale: this._locale,
        isUTC: this._isUTC,
        strict: this._strict
    };
}

// FORMATTING

addFormatToken(0, ['gg', 2], 0, function () {
    return this.weekYear() % 100;
});

addFormatToken(0, ['GG', 2], 0, function () {
    return this.isoWeekYear() % 100;
});

function addWeekYearFormatToken (token, getter) {
    addFormatToken(0, [token, token.length], 0, getter);
}

addWeekYearFormatToken('gggg',     'weekYear');
addWeekYearFormatToken('ggggg',    'weekYear');
addWeekYearFormatToken('GGGG',  'isoWeekYear');
addWeekYearFormatToken('GGGGG', 'isoWeekYear');

// ALIASES

addUnitAlias('weekYear', 'gg');
addUnitAlias('isoWeekYear', 'GG');

// PRIORITY

addUnitPriority('weekYear', 1);
addUnitPriority('isoWeekYear', 1);


// PARSING

addRegexToken('G',      matchSigned);
addRegexToken('g',      matchSigned);
addRegexToken('GG',     match1to2, match2);
addRegexToken('gg',     match1to2, match2);
addRegexToken('GGGG',   match1to4, match4);
addRegexToken('gggg',   match1to4, match4);
addRegexToken('GGGGG',  match1to6, match6);
addRegexToken('ggggg',  match1to6, match6);

addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
    week[token.substr(0, 2)] = toInt(input);
});

addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
    week[token] = hooks.parseTwoDigitYear(input);
});

// MOMENTS

function getSetWeekYear (input) {
    return getSetWeekYearHelper.call(this,
            input,
            this.week(),
            this.weekday(),
            this.localeData()._week.dow,
            this.localeData()._week.doy);
}

function getSetISOWeekYear (input) {
    return getSetWeekYearHelper.call(this,
            input, this.isoWeek(), this.isoWeekday(), 1, 4);
}

function getISOWeeksInYear () {
    return weeksInYear(this.year(), 1, 4);
}

function getWeeksInYear () {
    var weekInfo = this.localeData()._week;
    return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
}

function getSetWeekYearHelper(input, week, weekday, dow, doy) {
    var weeksTarget;
    if (input == null) {
        return weekOfYear(this, dow, doy).year;
    } else {
        weeksTarget = weeksInYear(input, dow, doy);
        if (week > weeksTarget) {
            week = weeksTarget;
        }
        return setWeekAll.call(this, input, week, weekday, dow, doy);
    }
}

function setWeekAll(weekYear, week, weekday, dow, doy) {
    var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
        date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

    this.year(date.getUTCFullYear());
    this.month(date.getUTCMonth());
    this.date(date.getUTCDate());
    return this;
}

// FORMATTING

addFormatToken('Q', 0, 'Qo', 'quarter');

// ALIASES

addUnitAlias('quarter', 'Q');

// PRIORITY

addUnitPriority('quarter', 7);

// PARSING

addRegexToken('Q', match1);
addParseToken('Q', function (input, array) {
    array[MONTH] = (toInt(input) - 1) * 3;
});

// MOMENTS

function getSetQuarter (input) {
    return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
}

// FORMATTING

addFormatToken('D', ['DD', 2], 'Do', 'date');

// ALIASES

addUnitAlias('date', 'D');

// PRIOROITY
addUnitPriority('date', 9);

// PARSING

addRegexToken('D',  match1to2);
addRegexToken('DD', match1to2, match2);
addRegexToken('Do', function (isStrict, locale) {
    // TODO: Remove "ordinalParse" fallback in next major release.
    return isStrict ?
      (locale._dayOfMonthOrdinalParse || locale._ordinalParse) :
      locale._dayOfMonthOrdinalParseLenient;
});

addParseToken(['D', 'DD'], DATE);
addParseToken('Do', function (input, array) {
    array[DATE] = toInt(input.match(match1to2)[0]);
});

// MOMENTS

var getSetDayOfMonth = makeGetSet('Date', true);

// FORMATTING

addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

// ALIASES

addUnitAlias('dayOfYear', 'DDD');

// PRIORITY
addUnitPriority('dayOfYear', 4);

// PARSING

addRegexToken('DDD',  match1to3);
addRegexToken('DDDD', match3);
addParseToken(['DDD', 'DDDD'], function (input, array, config) {
    config._dayOfYear = toInt(input);
});

// HELPERS

// MOMENTS

function getSetDayOfYear (input) {
    var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
    return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
}

// FORMATTING

addFormatToken('m', ['mm', 2], 0, 'minute');

// ALIASES

addUnitAlias('minute', 'm');

// PRIORITY

addUnitPriority('minute', 14);

// PARSING

addRegexToken('m',  match1to2);
addRegexToken('mm', match1to2, match2);
addParseToken(['m', 'mm'], MINUTE);

// MOMENTS

var getSetMinute = makeGetSet('Minutes', false);

// FORMATTING

addFormatToken('s', ['ss', 2], 0, 'second');

// ALIASES

addUnitAlias('second', 's');

// PRIORITY

addUnitPriority('second', 15);

// PARSING

addRegexToken('s',  match1to2);
addRegexToken('ss', match1to2, match2);
addParseToken(['s', 'ss'], SECOND);

// MOMENTS

var getSetSecond = makeGetSet('Seconds', false);

// FORMATTING

addFormatToken('S', 0, 0, function () {
    return ~~(this.millisecond() / 100);
});

addFormatToken(0, ['SS', 2], 0, function () {
    return ~~(this.millisecond() / 10);
});

addFormatToken(0, ['SSS', 3], 0, 'millisecond');
addFormatToken(0, ['SSSS', 4], 0, function () {
    return this.millisecond() * 10;
});
addFormatToken(0, ['SSSSS', 5], 0, function () {
    return this.millisecond() * 100;
});
addFormatToken(0, ['SSSSSS', 6], 0, function () {
    return this.millisecond() * 1000;
});
addFormatToken(0, ['SSSSSSS', 7], 0, function () {
    return this.millisecond() * 10000;
});
addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
    return this.millisecond() * 100000;
});
addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
    return this.millisecond() * 1000000;
});


// ALIASES

addUnitAlias('millisecond', 'ms');

// PRIORITY

addUnitPriority('millisecond', 16);

// PARSING

addRegexToken('S',    match1to3, match1);
addRegexToken('SS',   match1to3, match2);
addRegexToken('SSS',  match1to3, match3);

var token;
for (token = 'SSSS'; token.length <= 9; token += 'S') {
    addRegexToken(token, matchUnsigned);
}

function parseMs(input, array) {
    array[MILLISECOND] = toInt(('0.' + input) * 1000);
}

for (token = 'S'; token.length <= 9; token += 'S') {
    addParseToken(token, parseMs);
}
// MOMENTS

var getSetMillisecond = makeGetSet('Milliseconds', false);

// FORMATTING

addFormatToken('z',  0, 0, 'zoneAbbr');
addFormatToken('zz', 0, 0, 'zoneName');

// MOMENTS

function getZoneAbbr () {
    return this._isUTC ? 'UTC' : '';
}

function getZoneName () {
    return this._isUTC ? 'Coordinated Universal Time' : '';
}

var proto = Moment.prototype;

proto.add               = add;
proto.calendar          = calendar$1;
proto.clone             = clone;
proto.diff              = diff;
proto.endOf             = endOf;
proto.format            = format;
proto.from              = from;
proto.fromNow           = fromNow;
proto.to                = to;
proto.toNow             = toNow;
proto.get               = stringGet;
proto.invalidAt         = invalidAt;
proto.isAfter           = isAfter;
proto.isBefore          = isBefore;
proto.isBetween         = isBetween;
proto.isSame            = isSame;
proto.isSameOrAfter     = isSameOrAfter;
proto.isSameOrBefore    = isSameOrBefore;
proto.isValid           = isValid$2;
proto.lang              = lang;
proto.locale            = locale;
proto.localeData        = localeData;
proto.max               = prototypeMax;
proto.min               = prototypeMin;
proto.parsingFlags      = parsingFlags;
proto.set               = stringSet;
proto.startOf           = startOf;
proto.subtract          = subtract;
proto.toArray           = toArray;
proto.toObject          = toObject;
proto.toDate            = toDate;
proto.toISOString       = toISOString;
proto.inspect           = inspect;
proto.toJSON            = toJSON;
proto.toString          = toString;
proto.unix              = unix;
proto.valueOf           = valueOf;
proto.creationData      = creationData;

// Year
proto.year       = getSetYear;
proto.isLeapYear = getIsLeapYear;

// Week Year
proto.weekYear    = getSetWeekYear;
proto.isoWeekYear = getSetISOWeekYear;

// Quarter
proto.quarter = proto.quarters = getSetQuarter;

// Month
proto.month       = getSetMonth;
proto.daysInMonth = getDaysInMonth;

// Week
proto.week           = proto.weeks        = getSetWeek;
proto.isoWeek        = proto.isoWeeks     = getSetISOWeek;
proto.weeksInYear    = getWeeksInYear;
proto.isoWeeksInYear = getISOWeeksInYear;

// Day
proto.date       = getSetDayOfMonth;
proto.day        = proto.days             = getSetDayOfWeek;
proto.weekday    = getSetLocaleDayOfWeek;
proto.isoWeekday = getSetISODayOfWeek;
proto.dayOfYear  = getSetDayOfYear;

// Hour
proto.hour = proto.hours = getSetHour;

// Minute
proto.minute = proto.minutes = getSetMinute;

// Second
proto.second = proto.seconds = getSetSecond;

// Millisecond
proto.millisecond = proto.milliseconds = getSetMillisecond;

// Offset
proto.utcOffset            = getSetOffset;
proto.utc                  = setOffsetToUTC;
proto.local                = setOffsetToLocal;
proto.parseZone            = setOffsetToParsedOffset;
proto.hasAlignedHourOffset = hasAlignedHourOffset;
proto.isDST                = isDaylightSavingTime;
proto.isLocal              = isLocal;
proto.isUtcOffset          = isUtcOffset;
proto.isUtc                = isUtc;
proto.isUTC                = isUtc;

// Timezone
proto.zoneAbbr = getZoneAbbr;
proto.zoneName = getZoneName;

// Deprecations
proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);
proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);

function createUnix (input) {
    return createLocal(input * 1000);
}

function createInZone () {
    return createLocal.apply(null, arguments).parseZone();
}

function preParsePostFormat (string) {
    return string;
}

var proto$1 = Locale.prototype;

proto$1.calendar        = calendar;
proto$1.longDateFormat  = longDateFormat;
proto$1.invalidDate     = invalidDate;
proto$1.ordinal         = ordinal;
proto$1.preparse        = preParsePostFormat;
proto$1.postformat      = preParsePostFormat;
proto$1.relativeTime    = relativeTime;
proto$1.pastFuture      = pastFuture;
proto$1.set             = set;

// Month
proto$1.months            =        localeMonths;
proto$1.monthsShort       =        localeMonthsShort;
proto$1.monthsParse       =        localeMonthsParse;
proto$1.monthsRegex       = monthsRegex;
proto$1.monthsShortRegex  = monthsShortRegex;

// Week
proto$1.week = localeWeek;
proto$1.firstDayOfYear = localeFirstDayOfYear;
proto$1.firstDayOfWeek = localeFirstDayOfWeek;

// Day of Week
proto$1.weekdays       =        localeWeekdays;
proto$1.weekdaysMin    =        localeWeekdaysMin;
proto$1.weekdaysShort  =        localeWeekdaysShort;
proto$1.weekdaysParse  =        localeWeekdaysParse;

proto$1.weekdaysRegex       =        weekdaysRegex;
proto$1.weekdaysShortRegex  =        weekdaysShortRegex;
proto$1.weekdaysMinRegex    =        weekdaysMinRegex;

// Hours
proto$1.isPM = localeIsPM;
proto$1.meridiem = localeMeridiem;

function get$1 (format, index, field, setter) {
    var locale = getLocale();
    var utc = createUTC().set(setter, index);
    return locale[field](utc, format);
}

function listMonthsImpl (format, index, field) {
    if (isNumber(format)) {
        index = format;
        format = undefined;
    }

    format = format || '';

    if (index != null) {
        return get$1(format, index, field, 'month');
    }

    var i;
    var out = [];
    for (i = 0; i < 12; i++) {
        out[i] = get$1(format, i, field, 'month');
    }
    return out;
}

// ()
// (5)
// (fmt, 5)
// (fmt)
// (true)
// (true, 5)
// (true, fmt, 5)
// (true, fmt)
function listWeekdaysImpl (localeSorted, format, index, field) {
    if (typeof localeSorted === 'boolean') {
        if (isNumber(format)) {
            index = format;
            format = undefined;
        }

        format = format || '';
    } else {
        format = localeSorted;
        index = format;
        localeSorted = false;

        if (isNumber(format)) {
            index = format;
            format = undefined;
        }

        format = format || '';
    }

    var locale = getLocale(),
        shift = localeSorted ? locale._week.dow : 0;

    if (index != null) {
        return get$1(format, (index + shift) % 7, field, 'day');
    }

    var i;
    var out = [];
    for (i = 0; i < 7; i++) {
        out[i] = get$1(format, (i + shift) % 7, field, 'day');
    }
    return out;
}

function listMonths (format, index) {
    return listMonthsImpl(format, index, 'months');
}

function listMonthsShort (format, index) {
    return listMonthsImpl(format, index, 'monthsShort');
}

function listWeekdays (localeSorted, format, index) {
    return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
}

function listWeekdaysShort (localeSorted, format, index) {
    return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
}

function listWeekdaysMin (localeSorted, format, index) {
    return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
}

getSetGlobalLocale('en', {
    dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
    ordinal : function (number) {
        var b = number % 10,
            output = (toInt(number % 100 / 10) === 1) ? 'th' :
            (b === 1) ? 'st' :
            (b === 2) ? 'nd' :
            (b === 3) ? 'rd' : 'th';
        return number + output;
    }
});

// Side effect imports
hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);
hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);

var mathAbs = Math.abs;

function abs () {
    var data           = this._data;

    this._milliseconds = mathAbs(this._milliseconds);
    this._days         = mathAbs(this._days);
    this._months       = mathAbs(this._months);

    data.milliseconds  = mathAbs(data.milliseconds);
    data.seconds       = mathAbs(data.seconds);
    data.minutes       = mathAbs(data.minutes);
    data.hours         = mathAbs(data.hours);
    data.months        = mathAbs(data.months);
    data.years         = mathAbs(data.years);

    return this;
}

function addSubtract$1 (duration, input, value, direction) {
    var other = createDuration(input, value);

    duration._milliseconds += direction * other._milliseconds;
    duration._days         += direction * other._days;
    duration._months       += direction * other._months;

    return duration._bubble();
}

// supports only 2.0-style add(1, 's') or add(duration)
function add$1 (input, value) {
    return addSubtract$1(this, input, value, 1);
}

// supports only 2.0-style subtract(1, 's') or subtract(duration)
function subtract$1 (input, value) {
    return addSubtract$1(this, input, value, -1);
}

function absCeil (number) {
    if (number < 0) {
        return Math.floor(number);
    } else {
        return Math.ceil(number);
    }
}

function bubble () {
    var milliseconds = this._milliseconds;
    var days         = this._days;
    var months       = this._months;
    var data         = this._data;
    var seconds, minutes, hours, years, monthsFromDays;

    // if we have a mix of positive and negative values, bubble down first
    // check: https://github.com/moment/moment/issues/2166
    if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||
            (milliseconds <= 0 && days <= 0 && months <= 0))) {
        milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
        days = 0;
        months = 0;
    }

    // The following code bubbles up values, see the tests for
    // examples of what that means.
    data.milliseconds = milliseconds % 1000;

    seconds           = absFloor(milliseconds / 1000);
    data.seconds      = seconds % 60;

    minutes           = absFloor(seconds / 60);
    data.minutes      = minutes % 60;

    hours             = absFloor(minutes / 60);
    data.hours        = hours % 24;

    days += absFloor(hours / 24);

    // convert days to months
    monthsFromDays = absFloor(daysToMonths(days));
    months += monthsFromDays;
    days -= absCeil(monthsToDays(monthsFromDays));

    // 12 months -> 1 year
    years = absFloor(months / 12);
    months %= 12;

    data.days   = days;
    data.months = months;
    data.years  = years;

    return this;
}

function daysToMonths (days) {
    // 400 years have 146097 days (taking into account leap year rules)
    // 400 years have 12 months === 4800
    return days * 4800 / 146097;
}

function monthsToDays (months) {
    // the reverse of daysToMonths
    return months * 146097 / 4800;
}

function as (units) {
    if (!this.isValid()) {
        return NaN;
    }
    var days;
    var months;
    var milliseconds = this._milliseconds;

    units = normalizeUnits(units);

    if (units === 'month' || units === 'year') {
        days   = this._days   + milliseconds / 864e5;
        months = this._months + daysToMonths(days);
        return units === 'month' ? months : months / 12;
    } else {
        // handle milliseconds separately because of floating point math errors (issue #1867)
        days = this._days + Math.round(monthsToDays(this._months));
        switch (units) {
            case 'week'   : return days / 7     + milliseconds / 6048e5;
            case 'day'    : return days         + milliseconds / 864e5;
            case 'hour'   : return days * 24    + milliseconds / 36e5;
            case 'minute' : return days * 1440  + milliseconds / 6e4;
            case 'second' : return days * 86400 + milliseconds / 1000;
            // Math.floor prevents floating point math errors here
            case 'millisecond': return Math.floor(days * 864e5) + milliseconds;
            default: throw new Error('Unknown unit ' + units);
        }
    }
}

// TODO: Use this.as('ms')?
function valueOf$1 () {
    if (!this.isValid()) {
        return NaN;
    }
    return (
        this._milliseconds +
        this._days * 864e5 +
        (this._months % 12) * 2592e6 +
        toInt(this._months / 12) * 31536e6
    );
}

function makeAs (alias) {
    return function () {
        return this.as(alias);
    };
}

var asMilliseconds = makeAs('ms');
var asSeconds      = makeAs('s');
var asMinutes      = makeAs('m');
var asHours        = makeAs('h');
var asDays         = makeAs('d');
var asWeeks        = makeAs('w');
var asMonths       = makeAs('M');
var asYears        = makeAs('y');

function clone$1 () {
    return createDuration(this);
}

function get$2 (units) {
    units = normalizeUnits(units);
    return this.isValid() ? this[units + 's']() : NaN;
}

function makeGetter(name) {
    return function () {
        return this.isValid() ? this._data[name] : NaN;
    };
}

var milliseconds = makeGetter('milliseconds');
var seconds      = makeGetter('seconds');
var minutes      = makeGetter('minutes');
var hours        = makeGetter('hours');
var days         = makeGetter('days');
var months       = makeGetter('months');
var years        = makeGetter('years');

function weeks () {
    return absFloor(this.days() / 7);
}

var round = Math.round;
var thresholds = {
    ss: 44,         // a few seconds to seconds
    s : 45,         // seconds to minute
    m : 45,         // minutes to hour
    h : 22,         // hours to day
    d : 26,         // days to month
    M : 11          // months to year
};

// helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
    return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
}

function relativeTime$1 (posNegDuration, withoutSuffix, locale) {
    var duration = createDuration(posNegDuration).abs();
    var seconds  = round(duration.as('s'));
    var minutes  = round(duration.as('m'));
    var hours    = round(duration.as('h'));
    var days     = round(duration.as('d'));
    var months   = round(duration.as('M'));
    var years    = round(duration.as('y'));

    var a = seconds <= thresholds.ss && ['s', seconds]  ||
            seconds < thresholds.s   && ['ss', seconds] ||
            minutes <= 1             && ['m']           ||
            minutes < thresholds.m   && ['mm', minutes] ||
            hours   <= 1             && ['h']           ||
            hours   < thresholds.h   && ['hh', hours]   ||
            days    <= 1             && ['d']           ||
            days    < thresholds.d   && ['dd', days]    ||
            months  <= 1             && ['M']           ||
            months  < thresholds.M   && ['MM', months]  ||
            years   <= 1             && ['y']           || ['yy', years];

    a[2] = withoutSuffix;
    a[3] = +posNegDuration > 0;
    a[4] = locale;
    return substituteTimeAgo.apply(null, a);
}

// This function allows you to set the rounding function for relative time strings
function getSetRelativeTimeRounding (roundingFunction) {
    if (roundingFunction === undefined) {
        return round;
    }
    if (typeof(roundingFunction) === 'function') {
        round = roundingFunction;
        return true;
    }
    return false;
}

// This function allows you to set a threshold for relative time strings
function getSetRelativeTimeThreshold (threshold, limit) {
    if (thresholds[threshold] === undefined) {
        return false;
    }
    if (limit === undefined) {
        return thresholds[threshold];
    }
    thresholds[threshold] = limit;
    if (threshold === 's') {
        thresholds.ss = limit - 1;
    }
    return true;
}

function humanize (withSuffix) {
    if (!this.isValid()) {
        return this.localeData().invalidDate();
    }

    var locale = this.localeData();
    var output = relativeTime$1(this, !withSuffix, locale);

    if (withSuffix) {
        output = locale.pastFuture(+this, output);
    }

    return locale.postformat(output);
}

var abs$1 = Math.abs;

function sign(x) {
    return ((x > 0) - (x < 0)) || +x;
}

function toISOString$1() {
    // for ISO strings we do not use the normal bubbling rules:
    //  * milliseconds bubble up until they become hours
    //  * days do not bubble at all
    //  * months bubble up until they become years
    // This is because there is no context-free conversion between hours and days
    // (think of clock changes)
    // and also not between days and months (28-31 days per month)
    if (!this.isValid()) {
        return this.localeData().invalidDate();
    }

    var seconds = abs$1(this._milliseconds) / 1000;
    var days         = abs$1(this._days);
    var months       = abs$1(this._months);
    var minutes, hours, years;

    // 3600 seconds -> 60 minutes -> 1 hour
    minutes           = absFloor(seconds / 60);
    hours             = absFloor(minutes / 60);
    seconds %= 60;
    minutes %= 60;

    // 12 months -> 1 year
    years  = absFloor(months / 12);
    months %= 12;


    // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
    var Y = years;
    var M = months;
    var D = days;
    var h = hours;
    var m = minutes;
    var s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, '') : '';
    var total = this.asSeconds();

    if (!total) {
        // this is the same as C#'s (Noda) and python (isodate)...
        // but not other JS (goog.date)
        return 'P0D';
    }

    var totalSign = total < 0 ? '-' : '';
    var ymSign = sign(this._months) !== sign(total) ? '-' : '';
    var daysSign = sign(this._days) !== sign(total) ? '-' : '';
    var hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';

    return totalSign + 'P' +
        (Y ? ymSign + Y + 'Y' : '') +
        (M ? ymSign + M + 'M' : '') +
        (D ? daysSign + D + 'D' : '') +
        ((h || m || s) ? 'T' : '') +
        (h ? hmsSign + h + 'H' : '') +
        (m ? hmsSign + m + 'M' : '') +
        (s ? hmsSign + s + 'S' : '');
}

var proto$2 = Duration.prototype;

proto$2.isValid        = isValid$1;
proto$2.abs            = abs;
proto$2.add            = add$1;
proto$2.subtract       = subtract$1;
proto$2.as             = as;
proto$2.asMilliseconds = asMilliseconds;
proto$2.asSeconds      = asSeconds;
proto$2.asMinutes      = asMinutes;
proto$2.asHours        = asHours;
proto$2.asDays         = asDays;
proto$2.asWeeks        = asWeeks;
proto$2.asMonths       = asMonths;
proto$2.asYears        = asYears;
proto$2.valueOf        = valueOf$1;
proto$2._bubble        = bubble;
proto$2.clone          = clone$1;
proto$2.get            = get$2;
proto$2.milliseconds   = milliseconds;
proto$2.seconds        = seconds;
proto$2.minutes        = minutes;
proto$2.hours          = hours;
proto$2.days           = days;
proto$2.weeks          = weeks;
proto$2.months         = months;
proto$2.years          = years;
proto$2.humanize       = humanize;
proto$2.toISOString    = toISOString$1;
proto$2.toString       = toISOString$1;
proto$2.toJSON         = toISOString$1;
proto$2.locale         = locale;
proto$2.localeData     = localeData;

// Deprecations
proto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);
proto$2.lang = lang;

// Side effect imports

// FORMATTING

addFormatToken('X', 0, 0, 'unix');
addFormatToken('x', 0, 0, 'valueOf');

// PARSING

addRegexToken('x', matchSigned);
addRegexToken('X', matchTimestamp);
addParseToken('X', function (input, array, config) {
    config._d = new Date(parseFloat(input, 10) * 1000);
});
addParseToken('x', function (input, array, config) {
    config._d = new Date(toInt(input));
});

// Side effect imports


hooks.version = '2.20.1';

setHookCallback(createLocal);

hooks.fn                    = proto;
hooks.min                   = min;
hooks.max                   = max;
hooks.now                   = now;
hooks.utc                   = createUTC;
hooks.unix                  = createUnix;
hooks.months                = listMonths;
hooks.isDate                = isDate;
hooks.locale                = getSetGlobalLocale;
hooks.invalid               = createInvalid;
hooks.duration              = createDuration;
hooks.isMoment              = isMoment;
hooks.weekdays              = listWeekdays;
hooks.parseZone             = createInZone;
hooks.localeData            = getLocale;
hooks.isDuration            = isDuration;
hooks.monthsShort           = listMonthsShort;
hooks.weekdaysMin           = listWeekdaysMin;
hooks.defineLocale          = defineLocale;
hooks.updateLocale          = updateLocale;
hooks.locales               = listLocales;
hooks.weekdaysShort         = listWeekdaysShort;
hooks.normalizeUnits        = normalizeUnits;
hooks.relativeTimeRounding  = getSetRelativeTimeRounding;
hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
hooks.calendarFormat        = getCalendarFormat;
hooks.prototype             = proto;

// currently HTML5 input type only supports 24-hour formats
hooks.HTML5_FMT = {
    DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm',             // <input type="datetime-local" />
    DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss',  // <input type="datetime-local" step="1" />
    DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS',   // <input type="datetime-local" step="0.001" />
    DATE: 'YYYY-MM-DD',                             // <input type="date" />
    TIME: 'HH:mm',                                  // <input type="time" />
    TIME_SECONDS: 'HH:mm:ss',                       // <input type="time" step="1" />
    TIME_MS: 'HH:mm:ss.SSS',                        // <input type="time" step="0.001" />
    WEEK: 'YYYY-[W]WW',                             // <input type="week" />
    MONTH: 'YYYY-MM'                                // <input type="month" />
};

return hooks;

})));

},{}],386:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],387:[function(require,module,exports){
module.exports = require('./lib/index');

},{"./lib/index":388}],388:[function(require,module,exports){
(function (global){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _ponyfill = require('./ponyfill.js');

var _ponyfill2 = _interopRequireDefault(_ponyfill);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var root; /* global window */


if (typeof self !== 'undefined') {
  root = self;
} else if (typeof window !== 'undefined') {
  root = window;
} else if (typeof global !== 'undefined') {
  root = global;
} else if (typeof module !== 'undefined') {
  root = module;
} else {
  root = Function('return this')();
}

var result = (0, _ponyfill2['default'])(root);
exports['default'] = result;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./ponyfill.js":389}],389:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports['default'] = symbolObservablePonyfill;
function symbolObservablePonyfill(root) {
	var result;
	var _Symbol = root.Symbol;

	if (typeof _Symbol === 'function') {
		if (_Symbol.observable) {
			result = _Symbol.observable;
		} else {
			result = _Symbol('observable');
			_Symbol.observable = result;
		}
	} else {
		result = '@@observable';
	}

	return result;
};
},{}],390:[function(require,module,exports){
(function (process,global){
/*!
 * Vue.js v2.5.13
 * (c) 2014-2017 Evan You
 * Released under the MIT License.
 */
'use strict';

/*  */

var emptyObject = Object.freeze({});

// these helpers produces better vm code in JS engines due to their
// explicitness and function inlining
function isUndef (v) {
  return v === undefined || v === null
}

function isDef (v) {
  return v !== undefined && v !== null
}

function isTrue (v) {
  return v === true
}

function isFalse (v) {
  return v === false
}

/**
 * Check if value is primitive
 */
function isPrimitive (value) {
  return (
    typeof value === 'string' ||
    typeof value === 'number' ||
    // $flow-disable-line
    typeof value === 'symbol' ||
    typeof value === 'boolean'
  )
}

/**
 * Quick object check - this is primarily used to tell
 * Objects from primitive values when we know the value
 * is a JSON-compliant type.
 */
function isObject (obj) {
  return obj !== null && typeof obj === 'object'
}

/**
 * Get the raw type string of a value e.g. [object Object]
 */
var _toString = Object.prototype.toString;

function toRawType (value) {
  return _toString.call(value).slice(8, -1)
}

/**
 * Strict object type check. Only returns true
 * for plain JavaScript objects.
 */
function isPlainObject (obj) {
  return _toString.call(obj) === '[object Object]'
}

function isRegExp (v) {
  return _toString.call(v) === '[object RegExp]'
}

/**
 * Check if val is a valid array index.
 */
function isValidArrayIndex (val) {
  var n = parseFloat(String(val));
  return n >= 0 && Math.floor(n) === n && isFinite(val)
}

/**
 * Convert a value to a string that is actually rendered.
 */
function toString (val) {
  return val == null
    ? ''
    : typeof val === 'object'
      ? JSON.stringify(val, null, 2)
      : String(val)
}

/**
 * Convert a input value to a number for persistence.
 * If the conversion fails, return original string.
 */
function toNumber (val) {
  var n = parseFloat(val);
  return isNaN(n) ? val : n
}

/**
 * Make a map and return a function for checking if a key
 * is in that map.
 */
function makeMap (
  str,
  expectsLowerCase
) {
  var map = Object.create(null);
  var list = str.split(',');
  for (var i = 0; i < list.length; i++) {
    map[list[i]] = true;
  }
  return expectsLowerCase
    ? function (val) { return map[val.toLowerCase()]; }
    : function (val) { return map[val]; }
}

/**
 * Check if a tag is a built-in tag.
 */
var isBuiltInTag = makeMap('slot,component', true);

/**
 * Check if a attribute is a reserved attribute.
 */
var isReservedAttribute = makeMap('key,ref,slot,slot-scope,is');

/**
 * Remove an item from an array
 */
function remove (arr, item) {
  if (arr.length) {
    var index = arr.indexOf(item);
    if (index > -1) {
      return arr.splice(index, 1)
    }
  }
}

/**
 * Check whether the object has the property.
 */
var hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwn (obj, key) {
  return hasOwnProperty.call(obj, key)
}

/**
 * Create a cached version of a pure function.
 */
function cached (fn) {
  var cache = Object.create(null);
  return (function cachedFn (str) {
    var hit = cache[str];
    return hit || (cache[str] = fn(str))
  })
}

/**
 * Camelize a hyphen-delimited string.
 */
var camelizeRE = /-(\w)/g;
var camelize = cached(function (str) {
  return str.replace(camelizeRE, function (_, c) { return c ? c.toUpperCase() : ''; })
});

/**
 * Capitalize a string.
 */
var capitalize = cached(function (str) {
  return str.charAt(0).toUpperCase() + str.slice(1)
});

/**
 * Hyphenate a camelCase string.
 */
var hyphenateRE = /\B([A-Z])/g;
var hyphenate = cached(function (str) {
  return str.replace(hyphenateRE, '-$1').toLowerCase()
});

/**
 * Simple bind, faster than native
 */
function bind (fn, ctx) {
  function boundFn (a) {
    var l = arguments.length;
    return l
      ? l > 1
        ? fn.apply(ctx, arguments)
        : fn.call(ctx, a)
      : fn.call(ctx)
  }
  // record original fn length
  boundFn._length = fn.length;
  return boundFn
}

/**
 * Convert an Array-like object to a real Array.
 */
function toArray (list, start) {
  start = start || 0;
  var i = list.length - start;
  var ret = new Array(i);
  while (i--) {
    ret[i] = list[i + start];
  }
  return ret
}

/**
 * Mix properties into target object.
 */
function extend (to, _from) {
  for (var key in _from) {
    to[key] = _from[key];
  }
  return to
}

/**
 * Merge an Array of Objects into a single Object.
 */
function toObject (arr) {
  var res = {};
  for (var i = 0; i < arr.length; i++) {
    if (arr[i]) {
      extend(res, arr[i]);
    }
  }
  return res
}

/**
 * Perform no operation.
 * Stubbing args to make Flow happy without leaving useless transpiled code
 * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/)
 */
function noop (a, b, c) {}

/**
 * Always return false.
 */
var no = function (a, b, c) { return false; };

/**
 * Return same value
 */
var identity = function (_) { return _; };

/**
 * Generate a static keys string from compiler modules.
 */


/**
 * Check if two values are loosely equal - that is,
 * if they are plain objects, do they have the same shape?
 */
function looseEqual (a, b) {
  if (a === b) { return true }
  var isObjectA = isObject(a);
  var isObjectB = isObject(b);
  if (isObjectA && isObjectB) {
    try {
      var isArrayA = Array.isArray(a);
      var isArrayB = Array.isArray(b);
      if (isArrayA && isArrayB) {
        return a.length === b.length && a.every(function (e, i) {
          return looseEqual(e, b[i])
        })
      } else if (!isArrayA && !isArrayB) {
        var keysA = Object.keys(a);
        var keysB = Object.keys(b);
        return keysA.length === keysB.length && keysA.every(function (key) {
          return looseEqual(a[key], b[key])
        })
      } else {
        /* istanbul ignore next */
        return false
      }
    } catch (e) {
      /* istanbul ignore next */
      return false
    }
  } else if (!isObjectA && !isObjectB) {
    return String(a) === String(b)
  } else {
    return false
  }
}

function looseIndexOf (arr, val) {
  for (var i = 0; i < arr.length; i++) {
    if (looseEqual(arr[i], val)) { return i }
  }
  return -1
}

/**
 * Ensure a function is called only once.
 */
function once (fn) {
  var called = false;
  return function () {
    if (!called) {
      called = true;
      fn.apply(this, arguments);
    }
  }
}

var SSR_ATTR = 'data-server-rendered';

var ASSET_TYPES = [
  'component',
  'directive',
  'filter'
];

var LIFECYCLE_HOOKS = [
  'beforeCreate',
  'created',
  'beforeMount',
  'mounted',
  'beforeUpdate',
  'updated',
  'beforeDestroy',
  'destroyed',
  'activated',
  'deactivated',
  'errorCaptured'
];

/*  */

var config = ({
  /**
   * Option merge strategies (used in core/util/options)
   */
  // $flow-disable-line
  optionMergeStrategies: Object.create(null),

  /**
   * Whether to suppress warnings.
   */
  silent: false,

  /**
   * Show production mode tip message on boot?
   */
  productionTip: process.env.NODE_ENV !== 'production',

  /**
   * Whether to enable devtools
   */
  devtools: process.env.NODE_ENV !== 'production',

  /**
   * Whether to record perf
   */
  performance: false,

  /**
   * Error handler for watcher errors
   */
  errorHandler: null,

  /**
   * Warn handler for watcher warns
   */
  warnHandler: null,

  /**
   * Ignore certain custom elements
   */
  ignoredElements: [],

  /**
   * Custom user key aliases for v-on
   */
  // $flow-disable-line
  keyCodes: Object.create(null),

  /**
   * Check if a tag is reserved so that it cannot be registered as a
   * component. This is platform-dependent and may be overwritten.
   */
  isReservedTag: no,

  /**
   * Check if an attribute is reserved so that it cannot be used as a component
   * prop. This is platform-dependent and may be overwritten.
   */
  isReservedAttr: no,

  /**
   * Check if a tag is an unknown element.
   * Platform-dependent.
   */
  isUnknownElement: no,

  /**
   * Get the namespace of an element
   */
  getTagNamespace: noop,

  /**
   * Parse the real tag name for the specific platform.
   */
  parsePlatformTagName: identity,

  /**
   * Check if an attribute must be bound using property, e.g. value
   * Platform-dependent.
   */
  mustUseProp: no,

  /**
   * Exposed for legacy reasons
   */
  _lifecycleHooks: LIFECYCLE_HOOKS
});

/*  */

/**
 * Check if a string starts with $ or _
 */
function isReserved (str) {
  var c = (str + '').charCodeAt(0);
  return c === 0x24 || c === 0x5F
}

/**
 * Define a property.
 */
function def (obj, key, val, enumerable) {
  Object.defineProperty(obj, key, {
    value: val,
    enumerable: !!enumerable,
    writable: true,
    configurable: true
  });
}

/**
 * Parse simple path.
 */
var bailRE = /[^\w.$]/;
function parsePath (path) {
  if (bailRE.test(path)) {
    return
  }
  var segments = path.split('.');
  return function (obj) {
    for (var i = 0; i < segments.length; i++) {
      if (!obj) { return }
      obj = obj[segments[i]];
    }
    return obj
  }
}

/*  */


// can we use __proto__?
var hasProto = '__proto__' in {};

// Browser environment sniffing
var inBrowser = typeof window !== 'undefined';
var inWeex = typeof WXEnvironment !== 'undefined' && !!WXEnvironment.platform;
var weexPlatform = inWeex && WXEnvironment.platform.toLowerCase();
var UA = inBrowser && window.navigator.userAgent.toLowerCase();
var isIE = UA && /msie|trident/.test(UA);
var isIE9 = UA && UA.indexOf('msie 9.0') > 0;
var isEdge = UA && UA.indexOf('edge/') > 0;
var isAndroid = (UA && UA.indexOf('android') > 0) || (weexPlatform === 'android');
var isIOS = (UA && /iphone|ipad|ipod|ios/.test(UA)) || (weexPlatform === 'ios');
var isChrome = UA && /chrome\/\d+/.test(UA) && !isEdge;

// Firefox has a "watch" function on Object.prototype...
var nativeWatch = ({}).watch;

var supportsPassive = false;
if (inBrowser) {
  try {
    var opts = {};
    Object.defineProperty(opts, 'passive', ({
      get: function get () {
        /* istanbul ignore next */
        supportsPassive = true;
      }
    })); // https://github.com/facebook/flow/issues/285
    window.addEventListener('test-passive', null, opts);
  } catch (e) {}
}

// this needs to be lazy-evaled because vue may be required before
// vue-server-renderer can set VUE_ENV
var _isServer;
var isServerRendering = function () {
  if (_isServer === undefined) {
    /* istanbul ignore if */
    if (!inBrowser && typeof global !== 'undefined') {
      // detect presence of vue-server-renderer and avoid
      // Webpack shimming the process
      _isServer = global['process'].env.VUE_ENV === 'server';
    } else {
      _isServer = false;
    }
  }
  return _isServer
};

// detect devtools
var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;

/* istanbul ignore next */
function isNative (Ctor) {
  return typeof Ctor === 'function' && /native code/.test(Ctor.toString())
}

var hasSymbol =
  typeof Symbol !== 'undefined' && isNative(Symbol) &&
  typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);

var _Set;
/* istanbul ignore if */ // $flow-disable-line
if (typeof Set !== 'undefined' && isNative(Set)) {
  // use native Set when available.
  _Set = Set;
} else {
  // a non-standard Set polyfill that only works with primitive keys.
  _Set = (function () {
    function Set () {
      this.set = Object.create(null);
    }
    Set.prototype.has = function has (key) {
      return this.set[key] === true
    };
    Set.prototype.add = function add (key) {
      this.set[key] = true;
    };
    Set.prototype.clear = function clear () {
      this.set = Object.create(null);
    };

    return Set;
  }());
}

/*  */

var warn = noop;
var tip = noop;
var generateComponentTrace = (noop); // work around flow check
var formatComponentName = (noop);

if (process.env.NODE_ENV !== 'production') {
  var hasConsole = typeof console !== 'undefined';
  var classifyRE = /(?:^|[-_])(\w)/g;
  var classify = function (str) { return str
    .replace(classifyRE, function (c) { return c.toUpperCase(); })
    .replace(/[-_]/g, ''); };

  warn = function (msg, vm) {
    var trace = vm ? generateComponentTrace(vm) : '';

    if (config.warnHandler) {
      config.warnHandler.call(null, msg, vm, trace);
    } else if (hasConsole && (!config.silent)) {
      console.error(("[Vue warn]: " + msg + trace));
    }
  };

  tip = function (msg, vm) {
    if (hasConsole && (!config.silent)) {
      console.warn("[Vue tip]: " + msg + (
        vm ? generateComponentTrace(vm) : ''
      ));
    }
  };

  formatComponentName = function (vm, includeFile) {
    if (vm.$root === vm) {
      return '<Root>'
    }
    var options = typeof vm === 'function' && vm.cid != null
      ? vm.options
      : vm._isVue
        ? vm.$options || vm.constructor.options
        : vm || {};
    var name = options.name || options._componentTag;
    var file = options.__file;
    if (!name && file) {
      var match = file.match(/([^/\\]+)\.vue$/);
      name = match && match[1];
    }

    return (
      (name ? ("<" + (classify(name)) + ">") : "<Anonymous>") +
      (file && includeFile !== false ? (" at " + file) : '')
    )
  };

  var repeat = function (str, n) {
    var res = '';
    while (n) {
      if (n % 2 === 1) { res += str; }
      if (n > 1) { str += str; }
      n >>= 1;
    }
    return res
  };

  generateComponentTrace = function (vm) {
    if (vm._isVue && vm.$parent) {
      var tree = [];
      var currentRecursiveSequence = 0;
      while (vm) {
        if (tree.length > 0) {
          var last = tree[tree.length - 1];
          if (last.constructor === vm.constructor) {
            currentRecursiveSequence++;
            vm = vm.$parent;
            continue
          } else if (currentRecursiveSequence > 0) {
            tree[tree.length - 1] = [last, currentRecursiveSequence];
            currentRecursiveSequence = 0;
          }
        }
        tree.push(vm);
        vm = vm.$parent;
      }
      return '\n\nfound in\n\n' + tree
        .map(function (vm, i) { return ("" + (i === 0 ? '---> ' : repeat(' ', 5 + i * 2)) + (Array.isArray(vm)
            ? ((formatComponentName(vm[0])) + "... (" + (vm[1]) + " recursive calls)")
            : formatComponentName(vm))); })
        .join('\n')
    } else {
      return ("\n\n(found in " + (formatComponentName(vm)) + ")")
    }
  };
}

/*  */


var uid$1 = 0;

/**
 * A dep is an observable that can have multiple
 * directives subscribing to it.
 */
var Dep = function Dep () {
  this.id = uid$1++;
  this.subs = [];
};

Dep.prototype.addSub = function addSub (sub) {
  this.subs.push(sub);
};

Dep.prototype.removeSub = function removeSub (sub) {
  remove(this.subs, sub);
};

Dep.prototype.depend = function depend () {
  if (Dep.target) {
    Dep.target.addDep(this);
  }
};

Dep.prototype.notify = function notify () {
  // stabilize the subscriber list first
  var subs = this.subs.slice();
  for (var i = 0, l = subs.length; i < l; i++) {
    subs[i].update();
  }
};

// the current target watcher being evaluated.
// this is globally unique because there could be only one
// watcher being evaluated at any time.
Dep.target = null;
var targetStack = [];

function pushTarget (_target) {
  if (Dep.target) { targetStack.push(Dep.target); }
  Dep.target = _target;
}

function popTarget () {
  Dep.target = targetStack.pop();
}

/*  */

var VNode = function VNode (
  tag,
  data,
  children,
  text,
  elm,
  context,
  componentOptions,
  asyncFactory
) {
  this.tag = tag;
  this.data = data;
  this.children = children;
  this.text = text;
  this.elm = elm;
  this.ns = undefined;
  this.context = context;
  this.fnContext = undefined;
  this.fnOptions = undefined;
  this.fnScopeId = undefined;
  this.key = data && data.key;
  this.componentOptions = componentOptions;
  this.componentInstance = undefined;
  this.parent = undefined;
  this.raw = false;
  this.isStatic = false;
  this.isRootInsert = true;
  this.isComment = false;
  this.isCloned = false;
  this.isOnce = false;
  this.asyncFactory = asyncFactory;
  this.asyncMeta = undefined;
  this.isAsyncPlaceholder = false;
};

var prototypeAccessors = { child: { configurable: true } };

// DEPRECATED: alias for componentInstance for backwards compat.
/* istanbul ignore next */
prototypeAccessors.child.get = function () {
  return this.componentInstance
};

Object.defineProperties( VNode.prototype, prototypeAccessors );

var createEmptyVNode = function (text) {
  if ( text === void 0 ) text = '';

  var node = new VNode();
  node.text = text;
  node.isComment = true;
  return node
};

function createTextVNode (val) {
  return new VNode(undefined, undefined, undefined, String(val))
}

// optimized shallow clone
// used for static nodes and slot nodes because they may be reused across
// multiple renders, cloning them avoids errors when DOM manipulations rely
// on their elm reference.
function cloneVNode (vnode, deep) {
  var componentOptions = vnode.componentOptions;
  var cloned = new VNode(
    vnode.tag,
    vnode.data,
    vnode.children,
    vnode.text,
    vnode.elm,
    vnode.context,
    componentOptions,
    vnode.asyncFactory
  );
  cloned.ns = vnode.ns;
  cloned.isStatic = vnode.isStatic;
  cloned.key = vnode.key;
  cloned.isComment = vnode.isComment;
  cloned.fnContext = vnode.fnContext;
  cloned.fnOptions = vnode.fnOptions;
  cloned.fnScopeId = vnode.fnScopeId;
  cloned.isCloned = true;
  if (deep) {
    if (vnode.children) {
      cloned.children = cloneVNodes(vnode.children, true);
    }
    if (componentOptions && componentOptions.children) {
      componentOptions.children = cloneVNodes(componentOptions.children, true);
    }
  }
  return cloned
}

function cloneVNodes (vnodes, deep) {
  var len = vnodes.length;
  var res = new Array(len);
  for (var i = 0; i < len; i++) {
    res[i] = cloneVNode(vnodes[i], deep);
  }
  return res
}

/*
 * not type checking this file because flow doesn't play well with
 * dynamically accessing methods on Array prototype
 */

var arrayProto = Array.prototype;
var arrayMethods = Object.create(arrayProto);[
  'push',
  'pop',
  'shift',
  'unshift',
  'splice',
  'sort',
  'reverse'
].forEach(function (method) {
  // cache original method
  var original = arrayProto[method];
  def(arrayMethods, method, function mutator () {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

    var result = original.apply(this, args);
    var ob = this.__ob__;
    var inserted;
    switch (method) {
      case 'push':
      case 'unshift':
        inserted = args;
        break
      case 'splice':
        inserted = args.slice(2);
        break
    }
    if (inserted) { ob.observeArray(inserted); }
    // notify change
    ob.dep.notify();
    return result
  });
});

/*  */

var arrayKeys = Object.getOwnPropertyNames(arrayMethods);

/**
 * By default, when a reactive property is set, the new value is
 * also converted to become reactive. However when passing down props,
 * we don't want to force conversion because the value may be a nested value
 * under a frozen data structure. Converting it would defeat the optimization.
 */
var observerState = {
  shouldConvert: true
};

/**
 * Observer class that are attached to each observed
 * object. Once attached, the observer converts target
 * object's property keys into getter/setters that
 * collect dependencies and dispatches updates.
 */
var Observer = function Observer (value) {
  this.value = value;
  this.dep = new Dep();
  this.vmCount = 0;
  def(value, '__ob__', this);
  if (Array.isArray(value)) {
    var augment = hasProto
      ? protoAugment
      : copyAugment;
    augment(value, arrayMethods, arrayKeys);
    this.observeArray(value);
  } else {
    this.walk(value);
  }
};

/**
 * Walk through each property and convert them into
 * getter/setters. This method should only be called when
 * value type is Object.
 */
Observer.prototype.walk = function walk (obj) {
  var keys = Object.keys(obj);
  for (var i = 0; i < keys.length; i++) {
    defineReactive(obj, keys[i], obj[keys[i]]);
  }
};

/**
 * Observe a list of Array items.
 */
Observer.prototype.observeArray = function observeArray (items) {
  for (var i = 0, l = items.length; i < l; i++) {
    observe(items[i]);
  }
};

// helpers

/**
 * Augment an target Object or Array by intercepting
 * the prototype chain using __proto__
 */
function protoAugment (target, src, keys) {
  /* eslint-disable no-proto */
  target.__proto__ = src;
  /* eslint-enable no-proto */
}

/**
 * Augment an target Object or Array by defining
 * hidden properties.
 */
/* istanbul ignore next */
function copyAugment (target, src, keys) {
  for (var i = 0, l = keys.length; i < l; i++) {
    var key = keys[i];
    def(target, key, src[key]);
  }
}

/**
 * Attempt to create an observer instance for a value,
 * returns the new observer if successfully observed,
 * or the existing observer if the value already has one.
 */
function observe (value, asRootData) {
  if (!isObject(value) || value instanceof VNode) {
    return
  }
  var ob;
  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
    ob = value.__ob__;
  } else if (
    observerState.shouldConvert &&
    !isServerRendering() &&
    (Array.isArray(value) || isPlainObject(value)) &&
    Object.isExtensible(value) &&
    !value._isVue
  ) {
    ob = new Observer(value);
  }
  if (asRootData && ob) {
    ob.vmCount++;
  }
  return ob
}

/**
 * Define a reactive property on an Object.
 */
function defineReactive (
  obj,
  key,
  val,
  customSetter,
  shallow
) {
  var dep = new Dep();

  var property = Object.getOwnPropertyDescriptor(obj, key);
  if (property && property.configurable === false) {
    return
  }

  // cater for pre-defined getter/setters
  var getter = property && property.get;
  var setter = property && property.set;

  var childOb = !shallow && observe(val);
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter () {
      var value = getter ? getter.call(obj) : val;
      if (Dep.target) {
        dep.depend();
        if (childOb) {
          childOb.dep.depend();
          if (Array.isArray(value)) {
            dependArray(value);
          }
        }
      }
      return value
    },
    set: function reactiveSetter (newVal) {
      var value = getter ? getter.call(obj) : val;
      /* eslint-disable no-self-compare */
      if (newVal === value || (newVal !== newVal && value !== value)) {
        return
      }
      /* eslint-enable no-self-compare */
      if (process.env.NODE_ENV !== 'production' && customSetter) {
        customSetter();
      }
      if (setter) {
        setter.call(obj, newVal);
      } else {
        val = newVal;
      }
      childOb = !shallow && observe(newVal);
      dep.notify();
    }
  });
}

/**
 * Set a property on an object. Adds the new property and
 * triggers change notification if the property doesn't
 * already exist.
 */
function set (target, key, val) {
  if (Array.isArray(target) && isValidArrayIndex(key)) {
    target.length = Math.max(target.length, key);
    target.splice(key, 1, val);
    return val
  }
  if (key in target && !(key in Object.prototype)) {
    target[key] = val;
    return val
  }
  var ob = (target).__ob__;
  if (target._isVue || (ob && ob.vmCount)) {
    process.env.NODE_ENV !== 'production' && warn(
      'Avoid adding reactive properties to a Vue instance or its root $data ' +
      'at runtime - declare it upfront in the data option.'
    );
    return val
  }
  if (!ob) {
    target[key] = val;
    return val
  }
  defineReactive(ob.value, key, val);
  ob.dep.notify();
  return val
}

/**
 * Delete a property and trigger change if necessary.
 */
function del (target, key) {
  if (Array.isArray(target) && isValidArrayIndex(key)) {
    target.splice(key, 1);
    return
  }
  var ob = (target).__ob__;
  if (target._isVue || (ob && ob.vmCount)) {
    process.env.NODE_ENV !== 'production' && warn(
      'Avoid deleting properties on a Vue instance or its root $data ' +
      '- just set it to null.'
    );
    return
  }
  if (!hasOwn(target, key)) {
    return
  }
  delete target[key];
  if (!ob) {
    return
  }
  ob.dep.notify();
}

/**
 * Collect dependencies on array elements when the array is touched, since
 * we cannot intercept array element access like property getters.
 */
function dependArray (value) {
  for (var e = (void 0), i = 0, l = value.length; i < l; i++) {
    e = value[i];
    e && e.__ob__ && e.__ob__.dep.depend();
    if (Array.isArray(e)) {
      dependArray(e);
    }
  }
}

/*  */

/**
 * Option overwriting strategies are functions that handle
 * how to merge a parent option value and a child option
 * value into the final value.
 */
var strats = config.optionMergeStrategies;

/**
 * Options with restrictions
 */
if (process.env.NODE_ENV !== 'production') {
  strats.el = strats.propsData = function (parent, child, vm, key) {
    if (!vm) {
      warn(
        "option \"" + key + "\" can only be used during instance " +
        'creation with the `new` keyword.'
      );
    }
    return defaultStrat(parent, child)
  };
}

/**
 * Helper that recursively merges two data objects together.
 */
function mergeData (to, from) {
  if (!from) { return to }
  var key, toVal, fromVal;
  var keys = Object.keys(from);
  for (var i = 0; i < keys.length; i++) {
    key = keys[i];
    toVal = to[key];
    fromVal = from[key];
    if (!hasOwn(to, key)) {
      set(to, key, fromVal);
    } else if (isPlainObject(toVal) && isPlainObject(fromVal)) {
      mergeData(toVal, fromVal);
    }
  }
  return to
}

/**
 * Data
 */
function mergeDataOrFn (
  parentVal,
  childVal,
  vm
) {
  if (!vm) {
    // in a Vue.extend merge, both should be functions
    if (!childVal) {
      return parentVal
    }
    if (!parentVal) {
      return childVal
    }
    // when parentVal & childVal are both present,
    // we need to return a function that returns the
    // merged result of both functions... no need to
    // check if parentVal is a function here because
    // it has to be a function to pass previous merges.
    return function mergedDataFn () {
      return mergeData(
        typeof childVal === 'function' ? childVal.call(this, this) : childVal,
        typeof parentVal === 'function' ? parentVal.call(this, this) : parentVal
      )
    }
  } else {
    return function mergedInstanceDataFn () {
      // instance merge
      var instanceData = typeof childVal === 'function'
        ? childVal.call(vm, vm)
        : childVal;
      var defaultData = typeof parentVal === 'function'
        ? parentVal.call(vm, vm)
        : parentVal;
      if (instanceData) {
        return mergeData(instanceData, defaultData)
      } else {
        return defaultData
      }
    }
  }
}

strats.data = function (
  parentVal,
  childVal,
  vm
) {
  if (!vm) {
    if (childVal && typeof childVal !== 'function') {
      process.env.NODE_ENV !== 'production' && warn(
        'The "data" option should be a function ' +
        'that returns a per-instance value in component ' +
        'definitions.',
        vm
      );

      return parentVal
    }
    return mergeDataOrFn(parentVal, childVal)
  }

  return mergeDataOrFn(parentVal, childVal, vm)
};

/**
 * Hooks and props are merged as arrays.
 */
function mergeHook (
  parentVal,
  childVal
) {
  return childVal
    ? parentVal
      ? parentVal.concat(childVal)
      : Array.isArray(childVal)
        ? childVal
        : [childVal]
    : parentVal
}

LIFECYCLE_HOOKS.forEach(function (hook) {
  strats[hook] = mergeHook;
});

/**
 * Assets
 *
 * When a vm is present (instance creation), we need to do
 * a three-way merge between constructor options, instance
 * options and parent options.
 */
function mergeAssets (
  parentVal,
  childVal,
  vm,
  key
) {
  var res = Object.create(parentVal || null);
  if (childVal) {
    process.env.NODE_ENV !== 'production' && assertObjectType(key, childVal, vm);
    return extend(res, childVal)
  } else {
    return res
  }
}

ASSET_TYPES.forEach(function (type) {
  strats[type + 's'] = mergeAssets;
});

/**
 * Watchers.
 *
 * Watchers hashes should not overwrite one
 * another, so we merge them as arrays.
 */
strats.watch = function (
  parentVal,
  childVal,
  vm,
  key
) {
  // work around Firefox's Object.prototype.watch...
  if (parentVal === nativeWatch) { parentVal = undefined; }
  if (childVal === nativeWatch) { childVal = undefined; }
  /* istanbul ignore if */
  if (!childVal) { return Object.create(parentVal || null) }
  if (process.env.NODE_ENV !== 'production') {
    assertObjectType(key, childVal, vm);
  }
  if (!parentVal) { return childVal }
  var ret = {};
  extend(ret, parentVal);
  for (var key$1 in childVal) {
    var parent = ret[key$1];
    var child = childVal[key$1];
    if (parent && !Array.isArray(parent)) {
      parent = [parent];
    }
    ret[key$1] = parent
      ? parent.concat(child)
      : Array.isArray(child) ? child : [child];
  }
  return ret
};

/**
 * Other object hashes.
 */
strats.props =
strats.methods =
strats.inject =
strats.computed = function (
  parentVal,
  childVal,
  vm,
  key
) {
  if (childVal && process.env.NODE_ENV !== 'production') {
    assertObjectType(key, childVal, vm);
  }
  if (!parentVal) { return childVal }
  var ret = Object.create(null);
  extend(ret, parentVal);
  if (childVal) { extend(ret, childVal); }
  return ret
};
strats.provide = mergeDataOrFn;

/**
 * Default strategy.
 */
var defaultStrat = function (parentVal, childVal) {
  return childVal === undefined
    ? parentVal
    : childVal
};

/**
 * Validate component names
 */
function checkComponents (options) {
  for (var key in options.components) {
    validateComponentName(key);
  }
}

function validateComponentName (name) {
  if (!/^[a-zA-Z][\w-]*$/.test(name)) {
    warn(
      'Invalid component name: "' + name + '". Component names ' +
      'can only contain alphanumeric characters and the hyphen, ' +
      'and must start with a letter.'
    );
  }
  if (isBuiltInTag(name) || config.isReservedTag(name)) {
    warn(
      'Do not use built-in or reserved HTML elements as component ' +
      'id: ' + name
    );
  }
}

/**
 * Ensure all props option syntax are normalized into the
 * Object-based format.
 */
function normalizeProps (options, vm) {
  var props = options.props;
  if (!props) { return }
  var res = {};
  var i, val, name;
  if (Array.isArray(props)) {
    i = props.length;
    while (i--) {
      val = props[i];
      if (typeof val === 'string') {
        name = camelize(val);
        res[name] = { type: null };
      } else if (process.env.NODE_ENV !== 'production') {
        warn('props must be strings when using array syntax.');
      }
    }
  } else if (isPlainObject(props)) {
    for (var key in props) {
      val = props[key];
      name = camelize(key);
      res[name] = isPlainObject(val)
        ? val
        : { type: val };
    }
  } else if (process.env.NODE_ENV !== 'production') {
    warn(
      "Invalid value for option \"props\": expected an Array or an Object, " +
      "but got " + (toRawType(props)) + ".",
      vm
    );
  }
  options.props = res;
}

/**
 * Normalize all injections into Object-based format
 */
function normalizeInject (options, vm) {
  var inject = options.inject;
  if (!inject) { return }
  var normalized = options.inject = {};
  if (Array.isArray(inject)) {
    for (var i = 0; i < inject.length; i++) {
      normalized[inject[i]] = { from: inject[i] };
    }
  } else if (isPlainObject(inject)) {
    for (var key in inject) {
      var val = inject[key];
      normalized[key] = isPlainObject(val)
        ? extend({ from: key }, val)
        : { from: val };
    }
  } else if (process.env.NODE_ENV !== 'production') {
    warn(
      "Invalid value for option \"inject\": expected an Array or an Object, " +
      "but got " + (toRawType(inject)) + ".",
      vm
    );
  }
}

/**
 * Normalize raw function directives into object format.
 */
function normalizeDirectives (options) {
  var dirs = options.directives;
  if (dirs) {
    for (var key in dirs) {
      var def = dirs[key];
      if (typeof def === 'function') {
        dirs[key] = { bind: def, update: def };
      }
    }
  }
}

function assertObjectType (name, value, vm) {
  if (!isPlainObject(value)) {
    warn(
      "Invalid value for option \"" + name + "\": expected an Object, " +
      "but got " + (toRawType(value)) + ".",
      vm
    );
  }
}

/**
 * Merge two option objects into a new one.
 * Core utility used in both instantiation and inheritance.
 */
function mergeOptions (
  parent,
  child,
  vm
) {
  if (process.env.NODE_ENV !== 'production') {
    checkComponents(child);
  }

  if (typeof child === 'function') {
    child = child.options;
  }

  normalizeProps(child, vm);
  normalizeInject(child, vm);
  normalizeDirectives(child);
  var extendsFrom = child.extends;
  if (extendsFrom) {
    parent = mergeOptions(parent, extendsFrom, vm);
  }
  if (child.mixins) {
    for (var i = 0, l = child.mixins.length; i < l; i++) {
      parent = mergeOptions(parent, child.mixins[i], vm);
    }
  }
  var options = {};
  var key;
  for (key in parent) {
    mergeField(key);
  }
  for (key in child) {
    if (!hasOwn(parent, key)) {
      mergeField(key);
    }
  }
  function mergeField (key) {
    var strat = strats[key] || defaultStrat;
    options[key] = strat(parent[key], child[key], vm, key);
  }
  return options
}

/**
 * Resolve an asset.
 * This function is used because child instances need access
 * to assets defined in its ancestor chain.
 */
function resolveAsset (
  options,
  type,
  id,
  warnMissing
) {
  /* istanbul ignore if */
  if (typeof id !== 'string') {
    return
  }
  var assets = options[type];
  // check local registration variations first
  if (hasOwn(assets, id)) { return assets[id] }
  var camelizedId = camelize(id);
  if (hasOwn(assets, camelizedId)) { return assets[camelizedId] }
  var PascalCaseId = capitalize(camelizedId);
  if (hasOwn(assets, PascalCaseId)) { return assets[PascalCaseId] }
  // fallback to prototype chain
  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];
  if (process.env.NODE_ENV !== 'production' && warnMissing && !res) {
    warn(
      'Failed to resolve ' + type.slice(0, -1) + ': ' + id,
      options
    );
  }
  return res
}

/*  */

function validateProp (
  key,
  propOptions,
  propsData,
  vm
) {
  var prop = propOptions[key];
  var absent = !hasOwn(propsData, key);
  var value = propsData[key];
  // handle boolean props
  if (isType(Boolean, prop.type)) {
    if (absent && !hasOwn(prop, 'default')) {
      value = false;
    } else if (!isType(String, prop.type) && (value === '' || value === hyphenate(key))) {
      value = true;
    }
  }
  // check default value
  if (value === undefined) {
    value = getPropDefaultValue(vm, prop, key);
    // since the default value is a fresh copy,
    // make sure to observe it.
    var prevShouldConvert = observerState.shouldConvert;
    observerState.shouldConvert = true;
    observe(value);
    observerState.shouldConvert = prevShouldConvert;
  }
  if (
    process.env.NODE_ENV !== 'production' &&
    // skip validation for weex recycle-list child component props
    !(false && isObject(value) && ('@binding' in value))
  ) {
    assertProp(prop, key, value, vm, absent);
  }
  return value
}

/**
 * Get the default value of a prop.
 */
function getPropDefaultValue (vm, prop, key) {
  // no default, return undefined
  if (!hasOwn(prop, 'default')) {
    return undefined
  }
  var def = prop.default;
  // warn against non-factory defaults for Object & Array
  if (process.env.NODE_ENV !== 'production' && isObject(def)) {
    warn(
      'Invalid default value for prop "' + key + '": ' +
      'Props with type Object/Array must use a factory function ' +
      'to return the default value.',
      vm
    );
  }
  // the raw prop value was also undefined from previous render,
  // return previous default value to avoid unnecessary watcher trigger
  if (vm && vm.$options.propsData &&
    vm.$options.propsData[key] === undefined &&
    vm._props[key] !== undefined
  ) {
    return vm._props[key]
  }
  // call factory function for non-Function types
  // a value is Function if its prototype is function even across different execution context
  return typeof def === 'function' && getType(prop.type) !== 'Function'
    ? def.call(vm)
    : def
}

/**
 * Assert whether a prop is valid.
 */
function assertProp (
  prop,
  name,
  value,
  vm,
  absent
) {
  if (prop.required && absent) {
    warn(
      'Missing required prop: "' + name + '"',
      vm
    );
    return
  }
  if (value == null && !prop.required) {
    return
  }
  var type = prop.type;
  var valid = !type || type === true;
  var expectedTypes = [];
  if (type) {
    if (!Array.isArray(type)) {
      type = [type];
    }
    for (var i = 0; i < type.length && !valid; i++) {
      var assertedType = assertType(value, type[i]);
      expectedTypes.push(assertedType.expectedType || '');
      valid = assertedType.valid;
    }
  }
  if (!valid) {
    warn(
      "Invalid prop: type check failed for prop \"" + name + "\"." +
      " Expected " + (expectedTypes.map(capitalize).join(', ')) +
      ", got " + (toRawType(value)) + ".",
      vm
    );
    return
  }
  var validator = prop.validator;
  if (validator) {
    if (!validator(value)) {
      warn(
        'Invalid prop: custom validator check failed for prop "' + name + '".',
        vm
      );
    }
  }
}

var simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;

function assertType (value, type) {
  var valid;
  var expectedType = getType(type);
  if (simpleCheckRE.test(expectedType)) {
    var t = typeof value;
    valid = t === expectedType.toLowerCase();
    // for primitive wrapper objects
    if (!valid && t === 'object') {
      valid = value instanceof type;
    }
  } else if (expectedType === 'Object') {
    valid = isPlainObject(value);
  } else if (expectedType === 'Array') {
    valid = Array.isArray(value);
  } else {
    valid = value instanceof type;
  }
  return {
    valid: valid,
    expectedType: expectedType
  }
}

/**
 * Use function string name to check built-in types,
 * because a simple equality check will fail when running
 * across different vms / iframes.
 */
function getType (fn) {
  var match = fn && fn.toString().match(/^\s*function (\w+)/);
  return match ? match[1] : ''
}

function isType (type, fn) {
  if (!Array.isArray(fn)) {
    return getType(fn) === getType(type)
  }
  for (var i = 0, len = fn.length; i < len; i++) {
    if (getType(fn[i]) === getType(type)) {
      return true
    }
  }
  /* istanbul ignore next */
  return false
}

/*  */

function handleError (err, vm, info) {
  if (vm) {
    var cur = vm;
    while ((cur = cur.$parent)) {
      var hooks = cur.$options.errorCaptured;
      if (hooks) {
        for (var i = 0; i < hooks.length; i++) {
          try {
            var capture = hooks[i].call(cur, err, vm, info) === false;
            if (capture) { return }
          } catch (e) {
            globalHandleError(e, cur, 'errorCaptured hook');
          }
        }
      }
    }
  }
  globalHandleError(err, vm, info);
}

function globalHandleError (err, vm, info) {
  if (config.errorHandler) {
    try {
      return config.errorHandler.call(null, err, vm, info)
    } catch (e) {
      logError(e, null, 'config.errorHandler');
    }
  }
  logError(err, vm, info);
}

function logError (err, vm, info) {
  if (process.env.NODE_ENV !== 'production') {
    warn(("Error in " + info + ": \"" + (err.toString()) + "\""), vm);
  }
  /* istanbul ignore else */
  if ((inBrowser || inWeex) && typeof console !== 'undefined') {
    console.error(err);
  } else {
    throw err
  }
}

/*  */
/* globals MessageChannel */

var callbacks = [];
var pending = false;

function flushCallbacks () {
  pending = false;
  var copies = callbacks.slice(0);
  callbacks.length = 0;
  for (var i = 0; i < copies.length; i++) {
    copies[i]();
  }
}

// Here we have async deferring wrappers using both micro and macro tasks.
// In < 2.4 we used micro tasks everywhere, but there are some scenarios where
// micro tasks have too high a priority and fires in between supposedly
// sequential events (e.g. #4521, #6690) or even between bubbling of the same
// event (#6566). However, using macro tasks everywhere also has subtle problems
// when state is changed right before repaint (e.g. #6813, out-in transitions).
// Here we use micro task by default, but expose a way to force macro task when
// needed (e.g. in event handlers attached by v-on).
var microTimerFunc;
var macroTimerFunc;
var useMacroTask = false;

// Determine (macro) Task defer implementation.
// Technically setImmediate should be the ideal choice, but it's only available
// in IE. The only polyfill that consistently queues the callback after all DOM
// events triggered in the same loop is by using MessageChannel.
/* istanbul ignore if */
if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {
  macroTimerFunc = function () {
    setImmediate(flushCallbacks);
  };
} else if (typeof MessageChannel !== 'undefined' && (
  isNative(MessageChannel) ||
  // PhantomJS
  MessageChannel.toString() === '[object MessageChannelConstructor]'
)) {
  var channel = new MessageChannel();
  var port = channel.port2;
  channel.port1.onmessage = flushCallbacks;
  macroTimerFunc = function () {
    port.postMessage(1);
  };
} else {
  /* istanbul ignore next */
  macroTimerFunc = function () {
    setTimeout(flushCallbacks, 0);
  };
}

// Determine MicroTask defer implementation.
/* istanbul ignore next, $flow-disable-line */
if (typeof Promise !== 'undefined' && isNative(Promise)) {
  var p = Promise.resolve();
  microTimerFunc = function () {
    p.then(flushCallbacks);
    // in problematic UIWebViews, Promise.then doesn't completely break, but
    // it can get stuck in a weird state where callbacks are pushed into the
    // microtask queue but the queue isn't being flushed, until the browser
    // needs to do some other work, e.g. handle a timer. Therefore we can
    // "force" the microtask queue to be flushed by adding an empty timer.
    if (isIOS) { setTimeout(noop); }
  };
} else {
  // fallback to macro
  microTimerFunc = macroTimerFunc;
}

/**
 * Wrap a function so that if any code inside triggers state change,
 * the changes are queued using a Task instead of a MicroTask.
 */
function withMacroTask (fn) {
  return fn._withTask || (fn._withTask = function () {
    useMacroTask = true;
    var res = fn.apply(null, arguments);
    useMacroTask = false;
    return res
  })
}

function nextTick (cb, ctx) {
  var _resolve;
  callbacks.push(function () {
    if (cb) {
      try {
        cb.call(ctx);
      } catch (e) {
        handleError(e, ctx, 'nextTick');
      }
    } else if (_resolve) {
      _resolve(ctx);
    }
  });
  if (!pending) {
    pending = true;
    if (useMacroTask) {
      macroTimerFunc();
    } else {
      microTimerFunc();
    }
  }
  // $flow-disable-line
  if (!cb && typeof Promise !== 'undefined') {
    return new Promise(function (resolve) {
      _resolve = resolve;
    })
  }
}

/*  */

/* not type checking this file because flow doesn't play well with Proxy */

var initProxy;

if (process.env.NODE_ENV !== 'production') {
  var allowedGlobals = makeMap(
    'Infinity,undefined,NaN,isFinite,isNaN,' +
    'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' +
    'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' +
    'require' // for Webpack/Browserify
  );

  var warnNonPresent = function (target, key) {
    warn(
      "Property or method \"" + key + "\" is not defined on the instance but " +
      'referenced during render. Make sure that this property is reactive, ' +
      'either in the data option, or for class-based components, by ' +
      'initializing the property. ' +
      'See: https://vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.',
      target
    );
  };

  var hasProxy =
    typeof Proxy !== 'undefined' &&
    Proxy.toString().match(/native code/);

  if (hasProxy) {
    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta,exact');
    config.keyCodes = new Proxy(config.keyCodes, {
      set: function set (target, key, value) {
        if (isBuiltInModifier(key)) {
          warn(("Avoid overwriting built-in modifier in config.keyCodes: ." + key));
          return false
        } else {
          target[key] = value;
          return true
        }
      }
    });
  }

  var hasHandler = {
    has: function has (target, key) {
      var has = key in target;
      var isAllowed = allowedGlobals(key) || key.charAt(0) === '_';
      if (!has && !isAllowed) {
        warnNonPresent(target, key);
      }
      return has || !isAllowed
    }
  };

  var getHandler = {
    get: function get (target, key) {
      if (typeof key === 'string' && !(key in target)) {
        warnNonPresent(target, key);
      }
      return target[key]
    }
  };

  initProxy = function initProxy (vm) {
    if (hasProxy) {
      // determine which proxy handler to use
      var options = vm.$options;
      var handlers = options.render && options.render._withStripped
        ? getHandler
        : hasHandler;
      vm._renderProxy = new Proxy(vm, handlers);
    } else {
      vm._renderProxy = vm;
    }
  };
}

/*  */

var seenObjects = new _Set();

/**
 * Recursively traverse an object to evoke all converted
 * getters, so that every nested property inside the object
 * is collected as a "deep" dependency.
 */
function traverse (val) {
  _traverse(val, seenObjects);
  seenObjects.clear();
}

function _traverse (val, seen) {
  var i, keys;
  var isA = Array.isArray(val);
  if ((!isA && !isObject(val)) || Object.isFrozen(val)) {
    return
  }
  if (val.__ob__) {
    var depId = val.__ob__.dep.id;
    if (seen.has(depId)) {
      return
    }
    seen.add(depId);
  }
  if (isA) {
    i = val.length;
    while (i--) { _traverse(val[i], seen); }
  } else {
    keys = Object.keys(val);
    i = keys.length;
    while (i--) { _traverse(val[keys[i]], seen); }
  }
}

var mark;
var measure;

if (process.env.NODE_ENV !== 'production') {
  var perf = inBrowser && window.performance;
  /* istanbul ignore if */
  if (
    perf &&
    perf.mark &&
    perf.measure &&
    perf.clearMarks &&
    perf.clearMeasures
  ) {
    mark = function (tag) { return perf.mark(tag); };
    measure = function (name, startTag, endTag) {
      perf.measure(name, startTag, endTag);
      perf.clearMarks(startTag);
      perf.clearMarks(endTag);
      perf.clearMeasures(name);
    };
  }
}

/*  */

var normalizeEvent = cached(function (name) {
  var passive = name.charAt(0) === '&';
  name = passive ? name.slice(1) : name;
  var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first
  name = once$$1 ? name.slice(1) : name;
  var capture = name.charAt(0) === '!';
  name = capture ? name.slice(1) : name;
  return {
    name: name,
    once: once$$1,
    capture: capture,
    passive: passive
  }
});

function createFnInvoker (fns) {
  function invoker () {
    var arguments$1 = arguments;

    var fns = invoker.fns;
    if (Array.isArray(fns)) {
      var cloned = fns.slice();
      for (var i = 0; i < cloned.length; i++) {
        cloned[i].apply(null, arguments$1);
      }
    } else {
      // return handler return value for single handlers
      return fns.apply(null, arguments)
    }
  }
  invoker.fns = fns;
  return invoker
}

function updateListeners (
  on,
  oldOn,
  add,
  remove$$1,
  vm
) {
  var name, def, cur, old, event;
  for (name in on) {
    def = cur = on[name];
    old = oldOn[name];
    event = normalizeEvent(name);
    /* istanbul ignore if */
    if (isUndef(cur)) {
      process.env.NODE_ENV !== 'production' && warn(
        "Invalid handler for event \"" + (event.name) + "\": got " + String(cur),
        vm
      );
    } else if (isUndef(old)) {
      if (isUndef(cur.fns)) {
        cur = on[name] = createFnInvoker(cur);
      }
      add(event.name, cur, event.once, event.capture, event.passive, event.params);
    } else if (cur !== old) {
      old.fns = cur;
      on[name] = old;
    }
  }
  for (name in oldOn) {
    if (isUndef(on[name])) {
      event = normalizeEvent(name);
      remove$$1(event.name, oldOn[name], event.capture);
    }
  }
}

/*  */

function mergeVNodeHook (def, hookKey, hook) {
  if (def instanceof VNode) {
    def = def.data.hook || (def.data.hook = {});
  }
  var invoker;
  var oldHook = def[hookKey];

  function wrappedHook () {
    hook.apply(this, arguments);
    // important: remove merged hook to ensure it's called only once
    // and prevent memory leak
    remove(invoker.fns, wrappedHook);
  }

  if (isUndef(oldHook)) {
    // no existing hook
    invoker = createFnInvoker([wrappedHook]);
  } else {
    /* istanbul ignore if */
    if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {
      // already a merged invoker
      invoker = oldHook;
      invoker.fns.push(wrappedHook);
    } else {
      // existing plain hook
      invoker = createFnInvoker([oldHook, wrappedHook]);
    }
  }

  invoker.merged = true;
  def[hookKey] = invoker;
}

/*  */

function extractPropsFromVNodeData (
  data,
  Ctor,
  tag
) {
  // we are only extracting raw values here.
  // validation and default values are handled in the child
  // component itself.
  var propOptions = Ctor.options.props;
  if (isUndef(propOptions)) {
    return
  }
  var res = {};
  var attrs = data.attrs;
  var props = data.props;
  if (isDef(attrs) || isDef(props)) {
    for (var key in propOptions) {
      var altKey = hyphenate(key);
      if (process.env.NODE_ENV !== 'production') {
        var keyInLowerCase = key.toLowerCase();
        if (
          key !== keyInLowerCase &&
          attrs && hasOwn(attrs, keyInLowerCase)
        ) {
          tip(
            "Prop \"" + keyInLowerCase + "\" is passed to component " +
            (formatComponentName(tag || Ctor)) + ", but the declared prop name is" +
            " \"" + key + "\". " +
            "Note that HTML attributes are case-insensitive and camelCased " +
            "props need to use their kebab-case equivalents when using in-DOM " +
            "templates. You should probably use \"" + altKey + "\" instead of \"" + key + "\"."
          );
        }
      }
      checkProp(res, props, key, altKey, true) ||
      checkProp(res, attrs, key, altKey, false);
    }
  }
  return res
}

function checkProp (
  res,
  hash,
  key,
  altKey,
  preserve
) {
  if (isDef(hash)) {
    if (hasOwn(hash, key)) {
      res[key] = hash[key];
      if (!preserve) {
        delete hash[key];
      }
      return true
    } else if (hasOwn(hash, altKey)) {
      res[key] = hash[altKey];
      if (!preserve) {
        delete hash[altKey];
      }
      return true
    }
  }
  return false
}

/*  */

// The template compiler attempts to minimize the need for normalization by
// statically analyzing the template at compile time.
//
// For plain HTML markup, normalization can be completely skipped because the
// generated render function is guaranteed to return Array<VNode>. There are
// two cases where extra normalization is needed:

// 1. When the children contains components - because a functional component
// may return an Array instead of a single root. In this case, just a simple
// normalization is needed - if any child is an Array, we flatten the whole
// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep
// because functional components already normalize their own children.
function simpleNormalizeChildren (children) {
  for (var i = 0; i < children.length; i++) {
    if (Array.isArray(children[i])) {
      return Array.prototype.concat.apply([], children)
    }
  }
  return children
}

// 2. When the children contains constructs that always generated nested Arrays,
// e.g. <template>, <slot>, v-for, or when the children is provided by user
// with hand-written render functions / JSX. In such cases a full normalization
// is needed to cater to all possible types of children values.
function normalizeChildren (children) {
  return isPrimitive(children)
    ? [createTextVNode(children)]
    : Array.isArray(children)
      ? normalizeArrayChildren(children)
      : undefined
}

function isTextNode (node) {
  return isDef(node) && isDef(node.text) && isFalse(node.isComment)
}

function normalizeArrayChildren (children, nestedIndex) {
  var res = [];
  var i, c, lastIndex, last;
  for (i = 0; i < children.length; i++) {
    c = children[i];
    if (isUndef(c) || typeof c === 'boolean') { continue }
    lastIndex = res.length - 1;
    last = res[lastIndex];
    //  nested
    if (Array.isArray(c)) {
      if (c.length > 0) {
        c = normalizeArrayChildren(c, ((nestedIndex || '') + "_" + i));
        // merge adjacent text nodes
        if (isTextNode(c[0]) && isTextNode(last)) {
          res[lastIndex] = createTextVNode(last.text + (c[0]).text);
          c.shift();
        }
        res.push.apply(res, c);
      }
    } else if (isPrimitive(c)) {
      if (isTextNode(last)) {
        // merge adjacent text nodes
        // this is necessary for SSR hydration because text nodes are
        // essentially merged when rendered to HTML strings
        res[lastIndex] = createTextVNode(last.text + c);
      } else if (c !== '') {
        // convert primitive to vnode
        res.push(createTextVNode(c));
      }
    } else {
      if (isTextNode(c) && isTextNode(last)) {
        // merge adjacent text nodes
        res[lastIndex] = createTextVNode(last.text + c.text);
      } else {
        // default key for nested array children (likely generated by v-for)
        if (isTrue(children._isVList) &&
          isDef(c.tag) &&
          isUndef(c.key) &&
          isDef(nestedIndex)) {
          c.key = "__vlist" + nestedIndex + "_" + i + "__";
        }
        res.push(c);
      }
    }
  }
  return res
}

/*  */

function ensureCtor (comp, base) {
  if (
    comp.__esModule ||
    (hasSymbol && comp[Symbol.toStringTag] === 'Module')
  ) {
    comp = comp.default;
  }
  return isObject(comp)
    ? base.extend(comp)
    : comp
}

function createAsyncPlaceholder (
  factory,
  data,
  context,
  children,
  tag
) {
  var node = createEmptyVNode();
  node.asyncFactory = factory;
  node.asyncMeta = { data: data, context: context, children: children, tag: tag };
  return node
}

function resolveAsyncComponent (
  factory,
  baseCtor,
  context
) {
  if (isTrue(factory.error) && isDef(factory.errorComp)) {
    return factory.errorComp
  }

  if (isDef(factory.resolved)) {
    return factory.resolved
  }

  if (isTrue(factory.loading) && isDef(factory.loadingComp)) {
    return factory.loadingComp
  }

  if (isDef(factory.contexts)) {
    // already pending
    factory.contexts.push(context);
  } else {
    var contexts = factory.contexts = [context];
    var sync = true;

    var forceRender = function () {
      for (var i = 0, l = contexts.length; i < l; i++) {
        contexts[i].$forceUpdate();
      }
    };

    var resolve = once(function (res) {
      // cache resolved
      factory.resolved = ensureCtor(res, baseCtor);
      // invoke callbacks only if this is not a synchronous resolve
      // (async resolves are shimmed as synchronous during SSR)
      if (!sync) {
        forceRender();
      }
    });

    var reject = once(function (reason) {
      process.env.NODE_ENV !== 'production' && warn(
        "Failed to resolve async component: " + (String(factory)) +
        (reason ? ("\nReason: " + reason) : '')
      );
      if (isDef(factory.errorComp)) {
        factory.error = true;
        forceRender();
      }
    });

    var res = factory(resolve, reject);

    if (isObject(res)) {
      if (typeof res.then === 'function') {
        // () => Promise
        if (isUndef(factory.resolved)) {
          res.then(resolve, reject);
        }
      } else if (isDef(res.component) && typeof res.component.then === 'function') {
        res.component.then(resolve, reject);

        if (isDef(res.error)) {
          factory.errorComp = ensureCtor(res.error, baseCtor);
        }

        if (isDef(res.loading)) {
          factory.loadingComp = ensureCtor(res.loading, baseCtor);
          if (res.delay === 0) {
            factory.loading = true;
          } else {
            setTimeout(function () {
              if (isUndef(factory.resolved) && isUndef(factory.error)) {
                factory.loading = true;
                forceRender();
              }
            }, res.delay || 200);
          }
        }

        if (isDef(res.timeout)) {
          setTimeout(function () {
            if (isUndef(factory.resolved)) {
              reject(
                process.env.NODE_ENV !== 'production'
                  ? ("timeout (" + (res.timeout) + "ms)")
                  : null
              );
            }
          }, res.timeout);
        }
      }
    }

    sync = false;
    // return in case resolved synchronously
    return factory.loading
      ? factory.loadingComp
      : factory.resolved
  }
}

/*  */

function isAsyncPlaceholder (node) {
  return node.isComment && node.asyncFactory
}

/*  */

function getFirstComponentChild (children) {
  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      var c = children[i];
      if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {
        return c
      }
    }
  }
}

/*  */

/*  */

function initEvents (vm) {
  vm._events = Object.create(null);
  vm._hasHookEvent = false;
  // init parent attached events
  var listeners = vm.$options._parentListeners;
  if (listeners) {
    updateComponentListeners(vm, listeners);
  }
}

var target;

function add (event, fn, once) {
  if (once) {
    target.$once(event, fn);
  } else {
    target.$on(event, fn);
  }
}

function remove$1 (event, fn) {
  target.$off(event, fn);
}

function updateComponentListeners (
  vm,
  listeners,
  oldListeners
) {
  target = vm;
  updateListeners(listeners, oldListeners || {}, add, remove$1, vm);
  target = undefined;
}

function eventsMixin (Vue) {
  var hookRE = /^hook:/;
  Vue.prototype.$on = function (event, fn) {
    var this$1 = this;

    var vm = this;
    if (Array.isArray(event)) {
      for (var i = 0, l = event.length; i < l; i++) {
        this$1.$on(event[i], fn);
      }
    } else {
      (vm._events[event] || (vm._events[event] = [])).push(fn);
      // optimize hook:event cost by using a boolean flag marked at registration
      // instead of a hash lookup
      if (hookRE.test(event)) {
        vm._hasHookEvent = true;
      }
    }
    return vm
  };

  Vue.prototype.$once = function (event, fn) {
    var vm = this;
    function on () {
      vm.$off(event, on);
      fn.apply(vm, arguments);
    }
    on.fn = fn;
    vm.$on(event, on);
    return vm
  };

  Vue.prototype.$off = function (event, fn) {
    var this$1 = this;

    var vm = this;
    // all
    if (!arguments.length) {
      vm._events = Object.create(null);
      return vm
    }
    // array of events
    if (Array.isArray(event)) {
      for (var i = 0, l = event.length; i < l; i++) {
        this$1.$off(event[i], fn);
      }
      return vm
    }
    // specific event
    var cbs = vm._events[event];
    if (!cbs) {
      return vm
    }
    if (!fn) {
      vm._events[event] = null;
      return vm
    }
    if (fn) {
      // specific handler
      var cb;
      var i$1 = cbs.length;
      while (i$1--) {
        cb = cbs[i$1];
        if (cb === fn || cb.fn === fn) {
          cbs.splice(i$1, 1);
          break
        }
      }
    }
    return vm
  };

  Vue.prototype.$emit = function (event) {
    var vm = this;
    if (process.env.NODE_ENV !== 'production') {
      var lowerCaseEvent = event.toLowerCase();
      if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {
        tip(
          "Event \"" + lowerCaseEvent + "\" is emitted in component " +
          (formatComponentName(vm)) + " but the handler is registered for \"" + event + "\". " +
          "Note that HTML attributes are case-insensitive and you cannot use " +
          "v-on to listen to camelCase events when using in-DOM templates. " +
          "You should probably use \"" + (hyphenate(event)) + "\" instead of \"" + event + "\"."
        );
      }
    }
    var cbs = vm._events[event];
    if (cbs) {
      cbs = cbs.length > 1 ? toArray(cbs) : cbs;
      var args = toArray(arguments, 1);
      for (var i = 0, l = cbs.length; i < l; i++) {
        try {
          cbs[i].apply(vm, args);
        } catch (e) {
          handleError(e, vm, ("event handler for \"" + event + "\""));
        }
      }
    }
    return vm
  };
}

/*  */



/**
 * Runtime helper for resolving raw children VNodes into a slot object.
 */
function resolveSlots (
  children,
  context
) {
  var slots = {};
  if (!children) {
    return slots
  }
  for (var i = 0, l = children.length; i < l; i++) {
    var child = children[i];
    var data = child.data;
    // remove slot attribute if the node is resolved as a Vue slot node
    if (data && data.attrs && data.attrs.slot) {
      delete data.attrs.slot;
    }
    // named slots should only be respected if the vnode was rendered in the
    // same context.
    if ((child.context === context || child.fnContext === context) &&
      data && data.slot != null
    ) {
      var name = data.slot;
      var slot = (slots[name] || (slots[name] = []));
      if (child.tag === 'template') {
        slot.push.apply(slot, child.children || []);
      } else {
        slot.push(child);
      }
    } else {
      (slots.default || (slots.default = [])).push(child);
    }
  }
  // ignore slots that contains only whitespace
  for (var name$1 in slots) {
    if (slots[name$1].every(isWhitespace)) {
      delete slots[name$1];
    }
  }
  return slots
}

function isWhitespace (node) {
  return (node.isComment && !node.asyncFactory) || node.text === ' '
}

function resolveScopedSlots (
  fns, // see flow/vnode
  res
) {
  res = res || {};
  for (var i = 0; i < fns.length; i++) {
    if (Array.isArray(fns[i])) {
      resolveScopedSlots(fns[i], res);
    } else {
      res[fns[i].key] = fns[i].fn;
    }
  }
  return res
}

/*  */

var activeInstance = null;
var isUpdatingChildComponent = false;

function initLifecycle (vm) {
  var options = vm.$options;

  // locate first non-abstract parent
  var parent = options.parent;
  if (parent && !options.abstract) {
    while (parent.$options.abstract && parent.$parent) {
      parent = parent.$parent;
    }
    parent.$children.push(vm);
  }

  vm.$parent = parent;
  vm.$root = parent ? parent.$root : vm;

  vm.$children = [];
  vm.$refs = {};

  vm._watcher = null;
  vm._inactive = null;
  vm._directInactive = false;
  vm._isMounted = false;
  vm._isDestroyed = false;
  vm._isBeingDestroyed = false;
}

function lifecycleMixin (Vue) {
  Vue.prototype._update = function (vnode, hydrating) {
    var vm = this;
    if (vm._isMounted) {
      callHook(vm, 'beforeUpdate');
    }
    var prevEl = vm.$el;
    var prevVnode = vm._vnode;
    var prevActiveInstance = activeInstance;
    activeInstance = vm;
    vm._vnode = vnode;
    // Vue.prototype.__patch__ is injected in entry points
    // based on the rendering backend used.
    if (!prevVnode) {
      // initial render
      vm.$el = vm.__patch__(
        vm.$el, vnode, hydrating, false /* removeOnly */,
        vm.$options._parentElm,
        vm.$options._refElm
      );
      // no need for the ref nodes after initial patch
      // this prevents keeping a detached DOM tree in memory (#5851)
      vm.$options._parentElm = vm.$options._refElm = null;
    } else {
      // updates
      vm.$el = vm.__patch__(prevVnode, vnode);
    }
    activeInstance = prevActiveInstance;
    // update __vue__ reference
    if (prevEl) {
      prevEl.__vue__ = null;
    }
    if (vm.$el) {
      vm.$el.__vue__ = vm;
    }
    // if parent is an HOC, update its $el as well
    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
      vm.$parent.$el = vm.$el;
    }
    // updated hook is called by the scheduler to ensure that children are
    // updated in a parent's updated hook.
  };

  Vue.prototype.$forceUpdate = function () {
    var vm = this;
    if (vm._watcher) {
      vm._watcher.update();
    }
  };

  Vue.prototype.$destroy = function () {
    var vm = this;
    if (vm._isBeingDestroyed) {
      return
    }
    callHook(vm, 'beforeDestroy');
    vm._isBeingDestroyed = true;
    // remove self from parent
    var parent = vm.$parent;
    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
      remove(parent.$children, vm);
    }
    // teardown watchers
    if (vm._watcher) {
      vm._watcher.teardown();
    }
    var i = vm._watchers.length;
    while (i--) {
      vm._watchers[i].teardown();
    }
    // remove reference from data ob
    // frozen object may not have observer.
    if (vm._data.__ob__) {
      vm._data.__ob__.vmCount--;
    }
    // call the last hook...
    vm._isDestroyed = true;
    // invoke destroy hooks on current rendered tree
    vm.__patch__(vm._vnode, null);
    // fire destroyed hook
    callHook(vm, 'destroyed');
    // turn off all instance listeners.
    vm.$off();
    // remove __vue__ reference
    if (vm.$el) {
      vm.$el.__vue__ = null;
    }
    // release circular reference (#6759)
    if (vm.$vnode) {
      vm.$vnode.parent = null;
    }
  };
}

function mountComponent (
  vm,
  el,
  hydrating
) {
  vm.$el = el;
  if (!vm.$options.render) {
    vm.$options.render = createEmptyVNode;
    if (process.env.NODE_ENV !== 'production') {
      /* istanbul ignore if */
      if ((vm.$options.template && vm.$options.template.charAt(0) !== '#') ||
        vm.$options.el || el) {
        warn(
          'You are using the runtime-only build of Vue where the template ' +
          'compiler is not available. Either pre-compile the templates into ' +
          'render functions, or use the compiler-included build.',
          vm
        );
      } else {
        warn(
          'Failed to mount component: template or render function not defined.',
          vm
        );
      }
    }
  }
  callHook(vm, 'beforeMount');

  var updateComponent;
  /* istanbul ignore if */
  if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
    updateComponent = function () {
      var name = vm._name;
      var id = vm._uid;
      var startTag = "vue-perf-start:" + id;
      var endTag = "vue-perf-end:" + id;

      mark(startTag);
      var vnode = vm._render();
      mark(endTag);
      measure(("vue " + name + " render"), startTag, endTag);

      mark(startTag);
      vm._update(vnode, hydrating);
      mark(endTag);
      measure(("vue " + name + " patch"), startTag, endTag);
    };
  } else {
    updateComponent = function () {
      vm._update(vm._render(), hydrating);
    };
  }

  // we set this to vm._watcher inside the watcher's constructor
  // since the watcher's initial patch may call $forceUpdate (e.g. inside child
  // component's mounted hook), which relies on vm._watcher being already defined
  new Watcher(vm, updateComponent, noop, null, true /* isRenderWatcher */);
  hydrating = false;

  // manually mounted instance, call mounted on self
  // mounted is called for render-created child components in its inserted hook
  if (vm.$vnode == null) {
    vm._isMounted = true;
    callHook(vm, 'mounted');
  }
  return vm
}

function updateChildComponent (
  vm,
  propsData,
  listeners,
  parentVnode,
  renderChildren
) {
  if (process.env.NODE_ENV !== 'production') {
    isUpdatingChildComponent = true;
  }

  // determine whether component has slot children
  // we need to do this before overwriting $options._renderChildren
  var hasChildren = !!(
    renderChildren ||               // has new static slots
    vm.$options._renderChildren ||  // has old static slots
    parentVnode.data.scopedSlots || // has new scoped slots
    vm.$scopedSlots !== emptyObject // has old scoped slots
  );

  vm.$options._parentVnode = parentVnode;
  vm.$vnode = parentVnode; // update vm's placeholder node without re-render

  if (vm._vnode) { // update child tree's parent
    vm._vnode.parent = parentVnode;
  }
  vm.$options._renderChildren = renderChildren;

  // update $attrs and $listeners hash
  // these are also reactive so they may trigger child update if the child
  // used them during render
  vm.$attrs = (parentVnode.data && parentVnode.data.attrs) || emptyObject;
  vm.$listeners = listeners || emptyObject;

  // update props
  if (propsData && vm.$options.props) {
    observerState.shouldConvert = false;
    var props = vm._props;
    var propKeys = vm.$options._propKeys || [];
    for (var i = 0; i < propKeys.length; i++) {
      var key = propKeys[i];
      props[key] = validateProp(key, vm.$options.props, propsData, vm);
    }
    observerState.shouldConvert = true;
    // keep a copy of raw propsData
    vm.$options.propsData = propsData;
  }

  // update listeners
  if (listeners) {
    var oldListeners = vm.$options._parentListeners;
    vm.$options._parentListeners = listeners;
    updateComponentListeners(vm, listeners, oldListeners);
  }
  // resolve slots + force update if has children
  if (hasChildren) {
    vm.$slots = resolveSlots(renderChildren, parentVnode.context);
    vm.$forceUpdate();
  }

  if (process.env.NODE_ENV !== 'production') {
    isUpdatingChildComponent = false;
  }
}

function isInInactiveTree (vm) {
  while (vm && (vm = vm.$parent)) {
    if (vm._inactive) { return true }
  }
  return false
}

function activateChildComponent (vm, direct) {
  if (direct) {
    vm._directInactive = false;
    if (isInInactiveTree(vm)) {
      return
    }
  } else if (vm._directInactive) {
    return
  }
  if (vm._inactive || vm._inactive === null) {
    vm._inactive = false;
    for (var i = 0; i < vm.$children.length; i++) {
      activateChildComponent(vm.$children[i]);
    }
    callHook(vm, 'activated');
  }
}

function deactivateChildComponent (vm, direct) {
  if (direct) {
    vm._directInactive = true;
    if (isInInactiveTree(vm)) {
      return
    }
  }
  if (!vm._inactive) {
    vm._inactive = true;
    for (var i = 0; i < vm.$children.length; i++) {
      deactivateChildComponent(vm.$children[i]);
    }
    callHook(vm, 'deactivated');
  }
}

function callHook (vm, hook) {
  var handlers = vm.$options[hook];
  if (handlers) {
    for (var i = 0, j = handlers.length; i < j; i++) {
      try {
        handlers[i].call(vm);
      } catch (e) {
        handleError(e, vm, (hook + " hook"));
      }
    }
  }
  if (vm._hasHookEvent) {
    vm.$emit('hook:' + hook);
  }
}

/*  */


var MAX_UPDATE_COUNT = 100;

var queue = [];
var activatedChildren = [];
var has = {};
var circular = {};
var waiting = false;
var flushing = false;
var index = 0;

/**
 * Reset the scheduler's state.
 */
function resetSchedulerState () {
  index = queue.length = activatedChildren.length = 0;
  has = {};
  if (process.env.NODE_ENV !== 'production') {
    circular = {};
  }
  waiting = flushing = false;
}

/**
 * Flush both queues and run the watchers.
 */
function flushSchedulerQueue () {
  flushing = true;
  var watcher, id;

  // Sort queue before flush.
  // This ensures that:
  // 1. Components are updated from parent to child. (because parent is always
  //    created before the child)
  // 2. A component's user watchers are run before its render watcher (because
  //    user watchers are created before the render watcher)
  // 3. If a component is destroyed during a parent component's watcher run,
  //    its watchers can be skipped.
  queue.sort(function (a, b) { return a.id - b.id; });

  // do not cache length because more watchers might be pushed
  // as we run existing watchers
  for (index = 0; index < queue.length; index++) {
    watcher = queue[index];
    id = watcher.id;
    has[id] = null;
    watcher.run();
    // in dev build, check and stop circular updates.
    if (process.env.NODE_ENV !== 'production' && has[id] != null) {
      circular[id] = (circular[id] || 0) + 1;
      if (circular[id] > MAX_UPDATE_COUNT) {
        warn(
          'You may have an infinite update loop ' + (
            watcher.user
              ? ("in watcher with expression \"" + (watcher.expression) + "\"")
              : "in a component render function."
          ),
          watcher.vm
        );
        break
      }
    }
  }

  // keep copies of post queues before resetting state
  var activatedQueue = activatedChildren.slice();
  var updatedQueue = queue.slice();

  resetSchedulerState();

  // call component updated and activated hooks
  callActivatedHooks(activatedQueue);
  callUpdatedHooks(updatedQueue);

  // devtool hook
  /* istanbul ignore if */
  if (devtools && config.devtools) {
    devtools.emit('flush');
  }
}

function callUpdatedHooks (queue) {
  var i = queue.length;
  while (i--) {
    var watcher = queue[i];
    var vm = watcher.vm;
    if (vm._watcher === watcher && vm._isMounted) {
      callHook(vm, 'updated');
    }
  }
}

/**
 * Queue a kept-alive component that was activated during patch.
 * The queue will be processed after the entire tree has been patched.
 */
function queueActivatedComponent (vm) {
  // setting _inactive to false here so that a render function can
  // rely on checking whether it's in an inactive tree (e.g. router-view)
  vm._inactive = false;
  activatedChildren.push(vm);
}

function callActivatedHooks (queue) {
  for (var i = 0; i < queue.length; i++) {
    queue[i]._inactive = true;
    activateChildComponent(queue[i], true /* true */);
  }
}

/**
 * Push a watcher into the watcher queue.
 * Jobs with duplicate IDs will be skipped unless it's
 * pushed when the queue is being flushed.
 */
function queueWatcher (watcher) {
  var id = watcher.id;
  if (has[id] == null) {
    has[id] = true;
    if (!flushing) {
      queue.push(watcher);
    } else {
      // if already flushing, splice the watcher based on its id
      // if already past its id, it will be run next immediately.
      var i = queue.length - 1;
      while (i > index && queue[i].id > watcher.id) {
        i--;
      }
      queue.splice(i + 1, 0, watcher);
    }
    // queue the flush
    if (!waiting) {
      waiting = true;
      nextTick(flushSchedulerQueue);
    }
  }
}

/*  */

var uid$2 = 0;

/**
 * A watcher parses an expression, collects dependencies,
 * and fires callback when the expression value changes.
 * This is used for both the $watch() api and directives.
 */
var Watcher = function Watcher (
  vm,
  expOrFn,
  cb,
  options,
  isRenderWatcher
) {
  this.vm = vm;
  if (isRenderWatcher) {
    vm._watcher = this;
  }
  vm._watchers.push(this);
  // options
  if (options) {
    this.deep = !!options.deep;
    this.user = !!options.user;
    this.lazy = !!options.lazy;
    this.sync = !!options.sync;
  } else {
    this.deep = this.user = this.lazy = this.sync = false;
  }
  this.cb = cb;
  this.id = ++uid$2; // uid for batching
  this.active = true;
  this.dirty = this.lazy; // for lazy watchers
  this.deps = [];
  this.newDeps = [];
  this.depIds = new _Set();
  this.newDepIds = new _Set();
  this.expression = process.env.NODE_ENV !== 'production'
    ? expOrFn.toString()
    : '';
  // parse expression for getter
  if (typeof expOrFn === 'function') {
    this.getter = expOrFn;
  } else {
    this.getter = parsePath(expOrFn);
    if (!this.getter) {
      this.getter = function () {};
      process.env.NODE_ENV !== 'production' && warn(
        "Failed watching path: \"" + expOrFn + "\" " +
        'Watcher only accepts simple dot-delimited paths. ' +
        'For full control, use a function instead.',
        vm
      );
    }
  }
  this.value = this.lazy
    ? undefined
    : this.get();
};

/**
 * Evaluate the getter, and re-collect dependencies.
 */
Watcher.prototype.get = function get () {
  pushTarget(this);
  var value;
  var vm = this.vm;
  try {
    value = this.getter.call(vm, vm);
  } catch (e) {
    if (this.user) {
      handleError(e, vm, ("getter for watcher \"" + (this.expression) + "\""));
    } else {
      throw e
    }
  } finally {
    // "touch" every property so they are all tracked as
    // dependencies for deep watching
    if (this.deep) {
      traverse(value);
    }
    popTarget();
    this.cleanupDeps();
  }
  return value
};

/**
 * Add a dependency to this directive.
 */
Watcher.prototype.addDep = function addDep (dep) {
  var id = dep.id;
  if (!this.newDepIds.has(id)) {
    this.newDepIds.add(id);
    this.newDeps.push(dep);
    if (!this.depIds.has(id)) {
      dep.addSub(this);
    }
  }
};

/**
 * Clean up for dependency collection.
 */
Watcher.prototype.cleanupDeps = function cleanupDeps () {
    var this$1 = this;

  var i = this.deps.length;
  while (i--) {
    var dep = this$1.deps[i];
    if (!this$1.newDepIds.has(dep.id)) {
      dep.removeSub(this$1);
    }
  }
  var tmp = this.depIds;
  this.depIds = this.newDepIds;
  this.newDepIds = tmp;
  this.newDepIds.clear();
  tmp = this.deps;
  this.deps = this.newDeps;
  this.newDeps = tmp;
  this.newDeps.length = 0;
};

/**
 * Subscriber interface.
 * Will be called when a dependency changes.
 */
Watcher.prototype.update = function update () {
  /* istanbul ignore else */
  if (this.lazy) {
    this.dirty = true;
  } else if (this.sync) {
    this.run();
  } else {
    queueWatcher(this);
  }
};

/**
 * Scheduler job interface.
 * Will be called by the scheduler.
 */
Watcher.prototype.run = function run () {
  if (this.active) {
    var value = this.get();
    if (
      value !== this.value ||
      // Deep watchers and watchers on Object/Arrays should fire even
      // when the value is the same, because the value may
      // have mutated.
      isObject(value) ||
      this.deep
    ) {
      // set new value
      var oldValue = this.value;
      this.value = value;
      if (this.user) {
        try {
          this.cb.call(this.vm, value, oldValue);
        } catch (e) {
          handleError(e, this.vm, ("callback for watcher \"" + (this.expression) + "\""));
        }
      } else {
        this.cb.call(this.vm, value, oldValue);
      }
    }
  }
};

/**
 * Evaluate the value of the watcher.
 * This only gets called for lazy watchers.
 */
Watcher.prototype.evaluate = function evaluate () {
  this.value = this.get();
  this.dirty = false;
};

/**
 * Depend on all deps collected by this watcher.
 */
Watcher.prototype.depend = function depend () {
    var this$1 = this;

  var i = this.deps.length;
  while (i--) {
    this$1.deps[i].depend();
  }
};

/**
 * Remove self from all dependencies' subscriber list.
 */
Watcher.prototype.teardown = function teardown () {
    var this$1 = this;

  if (this.active) {
    // remove self from vm's watcher list
    // this is a somewhat expensive operation so we skip it
    // if the vm is being destroyed.
    if (!this.vm._isBeingDestroyed) {
      remove(this.vm._watchers, this);
    }
    var i = this.deps.length;
    while (i--) {
      this$1.deps[i].removeSub(this$1);
    }
    this.active = false;
  }
};

/*  */

var sharedPropertyDefinition = {
  enumerable: true,
  configurable: true,
  get: noop,
  set: noop
};

function proxy (target, sourceKey, key) {
  sharedPropertyDefinition.get = function proxyGetter () {
    return this[sourceKey][key]
  };
  sharedPropertyDefinition.set = function proxySetter (val) {
    this[sourceKey][key] = val;
  };
  Object.defineProperty(target, key, sharedPropertyDefinition);
}

function initState (vm) {
  vm._watchers = [];
  var opts = vm.$options;
  if (opts.props) { initProps(vm, opts.props); }
  if (opts.methods) { initMethods(vm, opts.methods); }
  if (opts.data) {
    initData(vm);
  } else {
    observe(vm._data = {}, true /* asRootData */);
  }
  if (opts.computed) { initComputed(vm, opts.computed); }
  if (opts.watch && opts.watch !== nativeWatch) {
    initWatch(vm, opts.watch);
  }
}

function initProps (vm, propsOptions) {
  var propsData = vm.$options.propsData || {};
  var props = vm._props = {};
  // cache prop keys so that future props updates can iterate using Array
  // instead of dynamic object key enumeration.
  var keys = vm.$options._propKeys = [];
  var isRoot = !vm.$parent;
  // root instance props should be converted
  observerState.shouldConvert = isRoot;
  var loop = function ( key ) {
    keys.push(key);
    var value = validateProp(key, propsOptions, propsData, vm);
    /* istanbul ignore else */
    if (process.env.NODE_ENV !== 'production') {
      var hyphenatedKey = hyphenate(key);
      if (isReservedAttribute(hyphenatedKey) ||
          config.isReservedAttr(hyphenatedKey)) {
        warn(
          ("\"" + hyphenatedKey + "\" is a reserved attribute and cannot be used as component prop."),
          vm
        );
      }
      defineReactive(props, key, value, function () {
        if (vm.$parent && !isUpdatingChildComponent) {
          warn(
            "Avoid mutating a prop directly since the value will be " +
            "overwritten whenever the parent component re-renders. " +
            "Instead, use a data or computed property based on the prop's " +
            "value. Prop being mutated: \"" + key + "\"",
            vm
          );
        }
      });
    } else {
      defineReactive(props, key, value);
    }
    // static props are already proxied on the component's prototype
    // during Vue.extend(). We only need to proxy props defined at
    // instantiation here.
    if (!(key in vm)) {
      proxy(vm, "_props", key);
    }
  };

  for (var key in propsOptions) loop( key );
  observerState.shouldConvert = true;
}

function initData (vm) {
  var data = vm.$options.data;
  data = vm._data = typeof data === 'function'
    ? getData(data, vm)
    : data || {};
  if (!isPlainObject(data)) {
    data = {};
    process.env.NODE_ENV !== 'production' && warn(
      'data functions should return an object:\n' +
      'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',
      vm
    );
  }
  // proxy data on instance
  var keys = Object.keys(data);
  var props = vm.$options.props;
  var methods = vm.$options.methods;
  var i = keys.length;
  while (i--) {
    var key = keys[i];
    if (process.env.NODE_ENV !== 'production') {
      if (methods && hasOwn(methods, key)) {
        warn(
          ("Method \"" + key + "\" has already been defined as a data property."),
          vm
        );
      }
    }
    if (props && hasOwn(props, key)) {
      process.env.NODE_ENV !== 'production' && warn(
        "The data property \"" + key + "\" is already declared as a prop. " +
        "Use prop default value instead.",
        vm
      );
    } else if (!isReserved(key)) {
      proxy(vm, "_data", key);
    }
  }
  // observe data
  observe(data, true /* asRootData */);
}

function getData (data, vm) {
  try {
    return data.call(vm, vm)
  } catch (e) {
    handleError(e, vm, "data()");
    return {}
  }
}

var computedWatcherOptions = { lazy: true };

function initComputed (vm, computed) {
  // $flow-disable-line
  var watchers = vm._computedWatchers = Object.create(null);
  // computed properties are just getters during SSR
  var isSSR = isServerRendering();

  for (var key in computed) {
    var userDef = computed[key];
    var getter = typeof userDef === 'function' ? userDef : userDef.get;
    if (process.env.NODE_ENV !== 'production' && getter == null) {
      warn(
        ("Getter is missing for computed property \"" + key + "\"."),
        vm
      );
    }

    if (!isSSR) {
      // create internal watcher for the computed property.
      watchers[key] = new Watcher(
        vm,
        getter || noop,
        noop,
        computedWatcherOptions
      );
    }

    // component-defined computed properties are already defined on the
    // component prototype. We only need to define computed properties defined
    // at instantiation here.
    if (!(key in vm)) {
      defineComputed(vm, key, userDef);
    } else if (process.env.NODE_ENV !== 'production') {
      if (key in vm.$data) {
        warn(("The computed property \"" + key + "\" is already defined in data."), vm);
      } else if (vm.$options.props && key in vm.$options.props) {
        warn(("The computed property \"" + key + "\" is already defined as a prop."), vm);
      }
    }
  }
}

function defineComputed (
  target,
  key,
  userDef
) {
  var shouldCache = !isServerRendering();
  if (typeof userDef === 'function') {
    sharedPropertyDefinition.get = shouldCache
      ? createComputedGetter(key)
      : userDef;
    sharedPropertyDefinition.set = noop;
  } else {
    sharedPropertyDefinition.get = userDef.get
      ? shouldCache && userDef.cache !== false
        ? createComputedGetter(key)
        : userDef.get
      : noop;
    sharedPropertyDefinition.set = userDef.set
      ? userDef.set
      : noop;
  }
  if (process.env.NODE_ENV !== 'production' &&
      sharedPropertyDefinition.set === noop) {
    sharedPropertyDefinition.set = function () {
      warn(
        ("Computed property \"" + key + "\" was assigned to but it has no setter."),
        this
      );
    };
  }
  Object.defineProperty(target, key, sharedPropertyDefinition);
}

function createComputedGetter (key) {
  return function computedGetter () {
    var watcher = this._computedWatchers && this._computedWatchers[key];
    if (watcher) {
      if (watcher.dirty) {
        watcher.evaluate();
      }
      if (Dep.target) {
        watcher.depend();
      }
      return watcher.value
    }
  }
}

function initMethods (vm, methods) {
  var props = vm.$options.props;
  for (var key in methods) {
    if (process.env.NODE_ENV !== 'production') {
      if (methods[key] == null) {
        warn(
          "Method \"" + key + "\" has an undefined value in the component definition. " +
          "Did you reference the function correctly?",
          vm
        );
      }
      if (props && hasOwn(props, key)) {
        warn(
          ("Method \"" + key + "\" has already been defined as a prop."),
          vm
        );
      }
      if ((key in vm) && isReserved(key)) {
        warn(
          "Method \"" + key + "\" conflicts with an existing Vue instance method. " +
          "Avoid defining component methods that start with _ or $."
        );
      }
    }
    vm[key] = methods[key] == null ? noop : bind(methods[key], vm);
  }
}

function initWatch (vm, watch) {
  for (var key in watch) {
    var handler = watch[key];
    if (Array.isArray(handler)) {
      for (var i = 0; i < handler.length; i++) {
        createWatcher(vm, key, handler[i]);
      }
    } else {
      createWatcher(vm, key, handler);
    }
  }
}

function createWatcher (
  vm,
  keyOrFn,
  handler,
  options
) {
  if (isPlainObject(handler)) {
    options = handler;
    handler = handler.handler;
  }
  if (typeof handler === 'string') {
    handler = vm[handler];
  }
  return vm.$watch(keyOrFn, handler, options)
}

function stateMixin (Vue) {
  // flow somehow has problems with directly declared definition object
  // when using Object.defineProperty, so we have to procedurally build up
  // the object here.
  var dataDef = {};
  dataDef.get = function () { return this._data };
  var propsDef = {};
  propsDef.get = function () { return this._props };
  if (process.env.NODE_ENV !== 'production') {
    dataDef.set = function (newData) {
      warn(
        'Avoid replacing instance root $data. ' +
        'Use nested data properties instead.',
        this
      );
    };
    propsDef.set = function () {
      warn("$props is readonly.", this);
    };
  }
  Object.defineProperty(Vue.prototype, '$data', dataDef);
  Object.defineProperty(Vue.prototype, '$props', propsDef);

  Vue.prototype.$set = set;
  Vue.prototype.$delete = del;

  Vue.prototype.$watch = function (
    expOrFn,
    cb,
    options
  ) {
    var vm = this;
    if (isPlainObject(cb)) {
      return createWatcher(vm, expOrFn, cb, options)
    }
    options = options || {};
    options.user = true;
    var watcher = new Watcher(vm, expOrFn, cb, options);
    if (options.immediate) {
      cb.call(vm, watcher.value);
    }
    return function unwatchFn () {
      watcher.teardown();
    }
  };
}

/*  */

function initProvide (vm) {
  var provide = vm.$options.provide;
  if (provide) {
    vm._provided = typeof provide === 'function'
      ? provide.call(vm)
      : provide;
  }
}

function initInjections (vm) {
  var result = resolveInject(vm.$options.inject, vm);
  if (result) {
    observerState.shouldConvert = false;
    Object.keys(result).forEach(function (key) {
      /* istanbul ignore else */
      if (process.env.NODE_ENV !== 'production') {
        defineReactive(vm, key, result[key], function () {
          warn(
            "Avoid mutating an injected value directly since the changes will be " +
            "overwritten whenever the provided component re-renders. " +
            "injection being mutated: \"" + key + "\"",
            vm
          );
        });
      } else {
        defineReactive(vm, key, result[key]);
      }
    });
    observerState.shouldConvert = true;
  }
}

function resolveInject (inject, vm) {
  if (inject) {
    // inject is :any because flow is not smart enough to figure out cached
    var result = Object.create(null);
    var keys = hasSymbol
      ? Reflect.ownKeys(inject).filter(function (key) {
        /* istanbul ignore next */
        return Object.getOwnPropertyDescriptor(inject, key).enumerable
      })
      : Object.keys(inject);

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      var provideKey = inject[key].from;
      var source = vm;
      while (source) {
        if (source._provided && provideKey in source._provided) {
          result[key] = source._provided[provideKey];
          break
        }
        source = source.$parent;
      }
      if (!source) {
        if ('default' in inject[key]) {
          var provideDefault = inject[key].default;
          result[key] = typeof provideDefault === 'function'
            ? provideDefault.call(vm)
            : provideDefault;
        } else if (process.env.NODE_ENV !== 'production') {
          warn(("Injection \"" + key + "\" not found"), vm);
        }
      }
    }
    return result
  }
}

/*  */

/**
 * Runtime helper for rendering v-for lists.
 */
function renderList (
  val,
  render
) {
  var ret, i, l, keys, key;
  if (Array.isArray(val) || typeof val === 'string') {
    ret = new Array(val.length);
    for (i = 0, l = val.length; i < l; i++) {
      ret[i] = render(val[i], i);
    }
  } else if (typeof val === 'number') {
    ret = new Array(val);
    for (i = 0; i < val; i++) {
      ret[i] = render(i + 1, i);
    }
  } else if (isObject(val)) {
    keys = Object.keys(val);
    ret = new Array(keys.length);
    for (i = 0, l = keys.length; i < l; i++) {
      key = keys[i];
      ret[i] = render(val[key], key, i);
    }
  }
  if (isDef(ret)) {
    (ret)._isVList = true;
  }
  return ret
}

/*  */

/**
 * Runtime helper for rendering <slot>
 */
function renderSlot (
  name,
  fallback,
  props,
  bindObject
) {
  var scopedSlotFn = this.$scopedSlots[name];
  var nodes;
  if (scopedSlotFn) { // scoped slot
    props = props || {};
    if (bindObject) {
      if (process.env.NODE_ENV !== 'production' && !isObject(bindObject)) {
        warn(
          'slot v-bind without argument expects an Object',
          this
        );
      }
      props = extend(extend({}, bindObject), props);
    }
    nodes = scopedSlotFn(props) || fallback;
  } else {
    var slotNodes = this.$slots[name];
    // warn duplicate slot usage
    if (slotNodes) {
      if (process.env.NODE_ENV !== 'production' && slotNodes._rendered) {
        warn(
          "Duplicate presence of slot \"" + name + "\" found in the same render tree " +
          "- this will likely cause render errors.",
          this
        );
      }
      slotNodes._rendered = true;
    }
    nodes = slotNodes || fallback;
  }

  var target = props && props.slot;
  if (target) {
    return this.$createElement('template', { slot: target }, nodes)
  } else {
    return nodes
  }
}

/*  */

/**
 * Runtime helper for resolving filters
 */
function resolveFilter (id) {
  return resolveAsset(this.$options, 'filters', id, true) || identity
}

/*  */

/**
 * Runtime helper for checking keyCodes from config.
 * exposed as Vue.prototype._k
 * passing in eventKeyName as last argument separately for backwards compat
 */
function checkKeyCodes (
  eventKeyCode,
  key,
  builtInAlias,
  eventKeyName
) {
  var keyCodes = config.keyCodes[key] || builtInAlias;
  if (keyCodes) {
    if (Array.isArray(keyCodes)) {
      return keyCodes.indexOf(eventKeyCode) === -1
    } else {
      return keyCodes !== eventKeyCode
    }
  } else if (eventKeyName) {
    return hyphenate(eventKeyName) !== key
  }
}

/*  */

/**
 * Runtime helper for merging v-bind="object" into a VNode's data.
 */
function bindObjectProps (
  data,
  tag,
  value,
  asProp,
  isSync
) {
  if (value) {
    if (!isObject(value)) {
      process.env.NODE_ENV !== 'production' && warn(
        'v-bind without argument expects an Object or Array value',
        this
      );
    } else {
      if (Array.isArray(value)) {
        value = toObject(value);
      }
      var hash;
      var loop = function ( key ) {
        if (
          key === 'class' ||
          key === 'style' ||
          isReservedAttribute(key)
        ) {
          hash = data;
        } else {
          var type = data.attrs && data.attrs.type;
          hash = asProp || config.mustUseProp(tag, type, key)
            ? data.domProps || (data.domProps = {})
            : data.attrs || (data.attrs = {});
        }
        if (!(key in hash)) {
          hash[key] = value[key];

          if (isSync) {
            var on = data.on || (data.on = {});
            on[("update:" + key)] = function ($event) {
              value[key] = $event;
            };
          }
        }
      };

      for (var key in value) loop( key );
    }
  }
  return data
}

/*  */

/**
 * Runtime helper for rendering static trees.
 */
function renderStatic (
  index,
  isInFor
) {
  var cached = this._staticTrees || (this._staticTrees = []);
  var tree = cached[index];
  // if has already-rendered static tree and not inside v-for,
  // we can reuse the same tree by doing a shallow clone.
  if (tree && !isInFor) {
    return Array.isArray(tree)
      ? cloneVNodes(tree)
      : cloneVNode(tree)
  }
  // otherwise, render a fresh tree.
  tree = cached[index] = this.$options.staticRenderFns[index].call(
    this._renderProxy,
    null,
    this // for render fns generated for functional component templates
  );
  markStatic(tree, ("__static__" + index), false);
  return tree
}

/**
 * Runtime helper for v-once.
 * Effectively it means marking the node as static with a unique key.
 */
function markOnce (
  tree,
  index,
  key
) {
  markStatic(tree, ("__once__" + index + (key ? ("_" + key) : "")), true);
  return tree
}

function markStatic (
  tree,
  key,
  isOnce
) {
  if (Array.isArray(tree)) {
    for (var i = 0; i < tree.length; i++) {
      if (tree[i] && typeof tree[i] !== 'string') {
        markStaticNode(tree[i], (key + "_" + i), isOnce);
      }
    }
  } else {
    markStaticNode(tree, key, isOnce);
  }
}

function markStaticNode (node, key, isOnce) {
  node.isStatic = true;
  node.key = key;
  node.isOnce = isOnce;
}

/*  */

function bindObjectListeners (data, value) {
  if (value) {
    if (!isPlainObject(value)) {
      process.env.NODE_ENV !== 'production' && warn(
        'v-on without argument expects an Object value',
        this
      );
    } else {
      var on = data.on = data.on ? extend({}, data.on) : {};
      for (var key in value) {
        var existing = on[key];
        var ours = value[key];
        on[key] = existing ? [].concat(existing, ours) : ours;
      }
    }
  }
  return data
}

/*  */

function installRenderHelpers (target) {
  target._o = markOnce;
  target._n = toNumber;
  target._s = toString;
  target._l = renderList;
  target._t = renderSlot;
  target._q = looseEqual;
  target._i = looseIndexOf;
  target._m = renderStatic;
  target._f = resolveFilter;
  target._k = checkKeyCodes;
  target._b = bindObjectProps;
  target._v = createTextVNode;
  target._e = createEmptyVNode;
  target._u = resolveScopedSlots;
  target._g = bindObjectListeners;
}

/*  */

function FunctionalRenderContext (
  data,
  props,
  children,
  parent,
  Ctor
) {
  var options = Ctor.options;
  this.data = data;
  this.props = props;
  this.children = children;
  this.parent = parent;
  this.listeners = data.on || emptyObject;
  this.injections = resolveInject(options.inject, parent);
  this.slots = function () { return resolveSlots(children, parent); };

  // ensure the createElement function in functional components
  // gets a unique context - this is necessary for correct named slot check
  var contextVm = Object.create(parent);
  var isCompiled = isTrue(options._compiled);
  var needNormalization = !isCompiled;

  // support for compiled functional template
  if (isCompiled) {
    // exposing $options for renderStatic()
    this.$options = options;
    // pre-resolve slots for renderSlot()
    this.$slots = this.slots();
    this.$scopedSlots = data.scopedSlots || emptyObject;
  }

  if (options._scopeId) {
    this._c = function (a, b, c, d) {
      var vnode = createElement(contextVm, a, b, c, d, needNormalization);
      if (vnode) {
        vnode.fnScopeId = options._scopeId;
        vnode.fnContext = parent;
      }
      return vnode
    };
  } else {
    this._c = function (a, b, c, d) { return createElement(contextVm, a, b, c, d, needNormalization); };
  }
}

installRenderHelpers(FunctionalRenderContext.prototype);

function createFunctionalComponent (
  Ctor,
  propsData,
  data,
  contextVm,
  children
) {
  var options = Ctor.options;
  var props = {};
  var propOptions = options.props;
  if (isDef(propOptions)) {
    for (var key in propOptions) {
      props[key] = validateProp(key, propOptions, propsData || emptyObject);
    }
  } else {
    if (isDef(data.attrs)) { mergeProps(props, data.attrs); }
    if (isDef(data.props)) { mergeProps(props, data.props); }
  }

  var renderContext = new FunctionalRenderContext(
    data,
    props,
    children,
    contextVm,
    Ctor
  );

  var vnode = options.render.call(null, renderContext._c, renderContext);

  if (vnode instanceof VNode) {
    vnode.fnContext = contextVm;
    vnode.fnOptions = options;
    if (data.slot) {
      (vnode.data || (vnode.data = {})).slot = data.slot;
    }
  }

  return vnode
}

function mergeProps (to, from) {
  for (var key in from) {
    to[camelize(key)] = from[key];
  }
}

/*  */




// Register the component hook to weex native render engine.
// The hook will be triggered by native, not javascript.


// Updates the state of the component to weex native render engine.

/*  */

// https://github.com/Hanks10100/weex-native-directive/tree/master/component

// listening on native callback

/*  */

/*  */

// hooks to be invoked on component VNodes during patch
var componentVNodeHooks = {
  init: function init (
    vnode,
    hydrating,
    parentElm,
    refElm
  ) {
    if (!vnode.componentInstance || vnode.componentInstance._isDestroyed) {
      var child = vnode.componentInstance = createComponentInstanceForVnode(
        vnode,
        activeInstance,
        parentElm,
        refElm
      );
      child.$mount(hydrating ? vnode.elm : undefined, hydrating);
    } else if (vnode.data.keepAlive) {
      // kept-alive components, treat as a patch
      var mountedNode = vnode; // work around flow
      componentVNodeHooks.prepatch(mountedNode, mountedNode);
    }
  },

  prepatch: function prepatch (oldVnode, vnode) {
    var options = vnode.componentOptions;
    var child = vnode.componentInstance = oldVnode.componentInstance;
    updateChildComponent(
      child,
      options.propsData, // updated props
      options.listeners, // updated listeners
      vnode, // new parent vnode
      options.children // new children
    );
  },

  insert: function insert (vnode) {
    var context = vnode.context;
    var componentInstance = vnode.componentInstance;
    if (!componentInstance._isMounted) {
      componentInstance._isMounted = true;
      callHook(componentInstance, 'mounted');
    }
    if (vnode.data.keepAlive) {
      if (context._isMounted) {
        // vue-router#1212
        // During updates, a kept-alive component's child components may
        // change, so directly walking the tree here may call activated hooks
        // on incorrect children. Instead we push them into a queue which will
        // be processed after the whole patch process ended.
        queueActivatedComponent(componentInstance);
      } else {
        activateChildComponent(componentInstance, true /* direct */);
      }
    }
  },

  destroy: function destroy (vnode) {
    var componentInstance = vnode.componentInstance;
    if (!componentInstance._isDestroyed) {
      if (!vnode.data.keepAlive) {
        componentInstance.$destroy();
      } else {
        deactivateChildComponent(componentInstance, true /* direct */);
      }
    }
  }
};

var hooksToMerge = Object.keys(componentVNodeHooks);

function createComponent (
  Ctor,
  data,
  context,
  children,
  tag
) {
  if (isUndef(Ctor)) {
    return
  }

  var baseCtor = context.$options._base;

  // plain options object: turn it into a constructor
  if (isObject(Ctor)) {
    Ctor = baseCtor.extend(Ctor);
  }

  // if at this stage it's not a constructor or an async component factory,
  // reject.
  if (typeof Ctor !== 'function') {
    if (process.env.NODE_ENV !== 'production') {
      warn(("Invalid Component definition: " + (String(Ctor))), context);
    }
    return
  }

  // async component
  var asyncFactory;
  if (isUndef(Ctor.cid)) {
    asyncFactory = Ctor;
    Ctor = resolveAsyncComponent(asyncFactory, baseCtor, context);
    if (Ctor === undefined) {
      // return a placeholder node for async component, which is rendered
      // as a comment node but preserves all the raw information for the node.
      // the information will be used for async server-rendering and hydration.
      return createAsyncPlaceholder(
        asyncFactory,
        data,
        context,
        children,
        tag
      )
    }
  }

  data = data || {};

  // resolve constructor options in case global mixins are applied after
  // component constructor creation
  resolveConstructorOptions(Ctor);

  // transform component v-model data into props & events
  if (isDef(data.model)) {
    transformModel(Ctor.options, data);
  }

  // extract props
  var propsData = extractPropsFromVNodeData(data, Ctor, tag);

  // functional component
  if (isTrue(Ctor.options.functional)) {
    return createFunctionalComponent(Ctor, propsData, data, context, children)
  }

  // extract listeners, since these needs to be treated as
  // child component listeners instead of DOM listeners
  var listeners = data.on;
  // replace with listeners with .native modifier
  // so it gets processed during parent component patch.
  data.on = data.nativeOn;

  if (isTrue(Ctor.options.abstract)) {
    // abstract components do not keep anything
    // other than props & listeners & slot

    // work around flow
    var slot = data.slot;
    data = {};
    if (slot) {
      data.slot = slot;
    }
  }

  // merge component management hooks onto the placeholder node
  mergeHooks(data);

  // return a placeholder vnode
  var name = Ctor.options.name || tag;
  var vnode = new VNode(
    ("vue-component-" + (Ctor.cid) + (name ? ("-" + name) : '')),
    data, undefined, undefined, undefined, context,
    { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children },
    asyncFactory
  );

  // Weex specific: invoke recycle-list optimized @render function for
  // extracting cell-slot template.
  // https://github.com/Hanks10100/weex-native-directive/tree/master/component
  /* istanbul ignore if */
  return vnode
}

function createComponentInstanceForVnode (
  vnode, // we know it's MountedComponentVNode but flow doesn't
  parent, // activeInstance in lifecycle state
  parentElm,
  refElm
) {
  var options = {
    _isComponent: true,
    parent: parent,
    _parentVnode: vnode,
    _parentElm: parentElm || null,
    _refElm: refElm || null
  };
  // check inline-template render functions
  var inlineTemplate = vnode.data.inlineTemplate;
  if (isDef(inlineTemplate)) {
    options.render = inlineTemplate.render;
    options.staticRenderFns = inlineTemplate.staticRenderFns;
  }
  return new vnode.componentOptions.Ctor(options)
}

function mergeHooks (data) {
  if (!data.hook) {
    data.hook = {};
  }
  for (var i = 0; i < hooksToMerge.length; i++) {
    var key = hooksToMerge[i];
    var fromParent = data.hook[key];
    var ours = componentVNodeHooks[key];
    data.hook[key] = fromParent ? mergeHook$1(ours, fromParent) : ours;
  }
}

function mergeHook$1 (one, two) {
  return function (a, b, c, d) {
    one(a, b, c, d);
    two(a, b, c, d);
  }
}

// transform component v-model info (value and callback) into
// prop and event handler respectively.
function transformModel (options, data) {
  var prop = (options.model && options.model.prop) || 'value';
  var event = (options.model && options.model.event) || 'input';(data.props || (data.props = {}))[prop] = data.model.value;
  var on = data.on || (data.on = {});
  if (isDef(on[event])) {
    on[event] = [data.model.callback].concat(on[event]);
  } else {
    on[event] = data.model.callback;
  }
}

/*  */

var SIMPLE_NORMALIZE = 1;
var ALWAYS_NORMALIZE = 2;

// wrapper function for providing a more flexible interface
// without getting yelled at by flow
function createElement (
  context,
  tag,
  data,
  children,
  normalizationType,
  alwaysNormalize
) {
  if (Array.isArray(data) || isPrimitive(data)) {
    normalizationType = children;
    children = data;
    data = undefined;
  }
  if (isTrue(alwaysNormalize)) {
    normalizationType = ALWAYS_NORMALIZE;
  }
  return _createElement(context, tag, data, children, normalizationType)
}

function _createElement (
  context,
  tag,
  data,
  children,
  normalizationType
) {
  if (isDef(data) && isDef((data).__ob__)) {
    process.env.NODE_ENV !== 'production' && warn(
      "Avoid using observed data object as vnode data: " + (JSON.stringify(data)) + "\n" +
      'Always create fresh vnode data objects in each render!',
      context
    );
    return createEmptyVNode()
  }
  // object syntax in v-bind
  if (isDef(data) && isDef(data.is)) {
    tag = data.is;
  }
  if (!tag) {
    // in case of component :is set to falsy value
    return createEmptyVNode()
  }
  // warn against non-primitive key
  if (process.env.NODE_ENV !== 'production' &&
    isDef(data) && isDef(data.key) && !isPrimitive(data.key)
  ) {
    {
      warn(
        'Avoid using non-primitive value as key, ' +
        'use string/number value instead.',
        context
      );
    }
  }
  // support single function children as default scoped slot
  if (Array.isArray(children) &&
    typeof children[0] === 'function'
  ) {
    data = data || {};
    data.scopedSlots = { default: children[0] };
    children.length = 0;
  }
  if (normalizationType === ALWAYS_NORMALIZE) {
    children = normalizeChildren(children);
  } else if (normalizationType === SIMPLE_NORMALIZE) {
    children = simpleNormalizeChildren(children);
  }
  var vnode, ns;
  if (typeof tag === 'string') {
    var Ctor;
    ns = (context.$vnode && context.$vnode.ns) || config.getTagNamespace(tag);
    if (config.isReservedTag(tag)) {
      // platform built-in elements
      vnode = new VNode(
        config.parsePlatformTagName(tag), data, children,
        undefined, undefined, context
      );
    } else if (isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {
      // component
      vnode = createComponent(Ctor, data, context, children, tag);
    } else {
      // unknown or unlisted namespaced elements
      // check at runtime because it may get assigned a namespace when its
      // parent normalizes children
      vnode = new VNode(
        tag, data, children,
        undefined, undefined, context
      );
    }
  } else {
    // direct component options / constructor
    vnode = createComponent(tag, data, context, children);
  }
  if (isDef(vnode)) {
    if (ns) { applyNS(vnode, ns); }
    return vnode
  } else {
    return createEmptyVNode()
  }
}

function applyNS (vnode, ns, force) {
  vnode.ns = ns;
  if (vnode.tag === 'foreignObject') {
    // use default namespace inside foreignObject
    ns = undefined;
    force = true;
  }
  if (isDef(vnode.children)) {
    for (var i = 0, l = vnode.children.length; i < l; i++) {
      var child = vnode.children[i];
      if (isDef(child.tag) && (isUndef(child.ns) || isTrue(force))) {
        applyNS(child, ns, force);
      }
    }
  }
}

/*  */

function initRender (vm) {
  vm._vnode = null; // the root of the child tree
  vm._staticTrees = null; // v-once cached trees
  var options = vm.$options;
  var parentVnode = vm.$vnode = options._parentVnode; // the placeholder node in parent tree
  var renderContext = parentVnode && parentVnode.context;
  vm.$slots = resolveSlots(options._renderChildren, renderContext);
  vm.$scopedSlots = emptyObject;
  // bind the createElement fn to this instance
  // so that we get proper render context inside it.
  // args order: tag, data, children, normalizationType, alwaysNormalize
  // internal version is used by render functions compiled from templates
  vm._c = function (a, b, c, d) { return createElement(vm, a, b, c, d, false); };
  // normalization is always applied for the public version, used in
  // user-written render functions.
  vm.$createElement = function (a, b, c, d) { return createElement(vm, a, b, c, d, true); };

  // $attrs & $listeners are exposed for easier HOC creation.
  // they need to be reactive so that HOCs using them are always updated
  var parentData = parentVnode && parentVnode.data;

  /* istanbul ignore else */
  if (process.env.NODE_ENV !== 'production') {
    defineReactive(vm, '$attrs', parentData && parentData.attrs || emptyObject, function () {
      !isUpdatingChildComponent && warn("$attrs is readonly.", vm);
    }, true);
    defineReactive(vm, '$listeners', options._parentListeners || emptyObject, function () {
      !isUpdatingChildComponent && warn("$listeners is readonly.", vm);
    }, true);
  } else {
    defineReactive(vm, '$attrs', parentData && parentData.attrs || emptyObject, null, true);
    defineReactive(vm, '$listeners', options._parentListeners || emptyObject, null, true);
  }
}

function renderMixin (Vue) {
  // install runtime convenience helpers
  installRenderHelpers(Vue.prototype);

  Vue.prototype.$nextTick = function (fn) {
    return nextTick(fn, this)
  };

  Vue.prototype._render = function () {
    var vm = this;
    var ref = vm.$options;
    var render = ref.render;
    var _parentVnode = ref._parentVnode;

    if (vm._isMounted) {
      // if the parent didn't update, the slot nodes will be the ones from
      // last render. They need to be cloned to ensure "freshness" for this render.
      for (var key in vm.$slots) {
        var slot = vm.$slots[key];
        // _rendered is a flag added by renderSlot, but may not be present
        // if the slot is passed from manually written render functions
        if (slot._rendered || (slot[0] && slot[0].elm)) {
          vm.$slots[key] = cloneVNodes(slot, true /* deep */);
        }
      }
    }

    vm.$scopedSlots = (_parentVnode && _parentVnode.data.scopedSlots) || emptyObject;

    // set parent vnode. this allows render functions to have access
    // to the data on the placeholder node.
    vm.$vnode = _parentVnode;
    // render self
    var vnode;
    try {
      vnode = render.call(vm._renderProxy, vm.$createElement);
    } catch (e) {
      handleError(e, vm, "render");
      // return error render result,
      // or previous vnode to prevent render error causing blank component
      /* istanbul ignore else */
      if (process.env.NODE_ENV !== 'production') {
        if (vm.$options.renderError) {
          try {
            vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e);
          } catch (e) {
            handleError(e, vm, "renderError");
            vnode = vm._vnode;
          }
        } else {
          vnode = vm._vnode;
        }
      } else {
        vnode = vm._vnode;
      }
    }
    // return empty vnode in case the render function errored out
    if (!(vnode instanceof VNode)) {
      if (process.env.NODE_ENV !== 'production' && Array.isArray(vnode)) {
        warn(
          'Multiple root nodes returned from render function. Render function ' +
          'should return a single root node.',
          vm
        );
      }
      vnode = createEmptyVNode();
    }
    // set parent
    vnode.parent = _parentVnode;
    return vnode
  };
}

/*  */

var uid = 0;

function initMixin (Vue) {
  Vue.prototype._init = function (options) {
    var vm = this;
    // a uid
    vm._uid = uid++;

    var startTag, endTag;
    /* istanbul ignore if */
    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
      startTag = "vue-perf-start:" + (vm._uid);
      endTag = "vue-perf-end:" + (vm._uid);
      mark(startTag);
    }

    // a flag to avoid this being observed
    vm._isVue = true;
    // merge options
    if (options && options._isComponent) {
      // optimize internal component instantiation
      // since dynamic options merging is pretty slow, and none of the
      // internal component options needs special treatment.
      initInternalComponent(vm, options);
    } else {
      vm.$options = mergeOptions(
        resolveConstructorOptions(vm.constructor),
        options || {},
        vm
      );
    }
    /* istanbul ignore else */
    if (process.env.NODE_ENV !== 'production') {
      initProxy(vm);
    } else {
      vm._renderProxy = vm;
    }
    // expose real self
    vm._self = vm;
    initLifecycle(vm);
    initEvents(vm);
    initRender(vm);
    callHook(vm, 'beforeCreate');
    initInjections(vm); // resolve injections before data/props
    initState(vm);
    initProvide(vm); // resolve provide after data/props
    callHook(vm, 'created');

    /* istanbul ignore if */
    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
      vm._name = formatComponentName(vm, false);
      mark(endTag);
      measure(("vue " + (vm._name) + " init"), startTag, endTag);
    }

    if (vm.$options.el) {
      vm.$mount(vm.$options.el);
    }
  };
}

function initInternalComponent (vm, options) {
  var opts = vm.$options = Object.create(vm.constructor.options);
  // doing this because it's faster than dynamic enumeration.
  var parentVnode = options._parentVnode;
  opts.parent = options.parent;
  opts._parentVnode = parentVnode;
  opts._parentElm = options._parentElm;
  opts._refElm = options._refElm;

  var vnodeComponentOptions = parentVnode.componentOptions;
  opts.propsData = vnodeComponentOptions.propsData;
  opts._parentListeners = vnodeComponentOptions.listeners;
  opts._renderChildren = vnodeComponentOptions.children;
  opts._componentTag = vnodeComponentOptions.tag;

  if (options.render) {
    opts.render = options.render;
    opts.staticRenderFns = options.staticRenderFns;
  }
}

function resolveConstructorOptions (Ctor) {
  var options = Ctor.options;
  if (Ctor.super) {
    var superOptions = resolveConstructorOptions(Ctor.super);
    var cachedSuperOptions = Ctor.superOptions;
    if (superOptions !== cachedSuperOptions) {
      // super option changed,
      // need to resolve new options.
      Ctor.superOptions = superOptions;
      // check if there are any late-modified/attached options (#4976)
      var modifiedOptions = resolveModifiedOptions(Ctor);
      // update base extend options
      if (modifiedOptions) {
        extend(Ctor.extendOptions, modifiedOptions);
      }
      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);
      if (options.name) {
        options.components[options.name] = Ctor;
      }
    }
  }
  return options
}

function resolveModifiedOptions (Ctor) {
  var modified;
  var latest = Ctor.options;
  var extended = Ctor.extendOptions;
  var sealed = Ctor.sealedOptions;
  for (var key in latest) {
    if (latest[key] !== sealed[key]) {
      if (!modified) { modified = {}; }
      modified[key] = dedupe(latest[key], extended[key], sealed[key]);
    }
  }
  return modified
}

function dedupe (latest, extended, sealed) {
  // compare latest and sealed to ensure lifecycle hooks won't be duplicated
  // between merges
  if (Array.isArray(latest)) {
    var res = [];
    sealed = Array.isArray(sealed) ? sealed : [sealed];
    extended = Array.isArray(extended) ? extended : [extended];
    for (var i = 0; i < latest.length; i++) {
      // push original options and not sealed options to exclude duplicated options
      if (extended.indexOf(latest[i]) >= 0 || sealed.indexOf(latest[i]) < 0) {
        res.push(latest[i]);
      }
    }
    return res
  } else {
    return latest
  }
}

function Vue$3 (options) {
  if (process.env.NODE_ENV !== 'production' &&
    !(this instanceof Vue$3)
  ) {
    warn('Vue is a constructor and should be called with the `new` keyword');
  }
  this._init(options);
}

initMixin(Vue$3);
stateMixin(Vue$3);
eventsMixin(Vue$3);
lifecycleMixin(Vue$3);
renderMixin(Vue$3);

/*  */

function initUse (Vue) {
  Vue.use = function (plugin) {
    var installedPlugins = (this._installedPlugins || (this._installedPlugins = []));
    if (installedPlugins.indexOf(plugin) > -1) {
      return this
    }

    // additional parameters
    var args = toArray(arguments, 1);
    args.unshift(this);
    if (typeof plugin.install === 'function') {
      plugin.install.apply(plugin, args);
    } else if (typeof plugin === 'function') {
      plugin.apply(null, args);
    }
    installedPlugins.push(plugin);
    return this
  };
}

/*  */

function initMixin$1 (Vue) {
  Vue.mixin = function (mixin) {
    this.options = mergeOptions(this.options, mixin);
    return this
  };
}

/*  */

function initExtend (Vue) {
  /**
   * Each instance constructor, including Vue, has a unique
   * cid. This enables us to create wrapped "child
   * constructors" for prototypal inheritance and cache them.
   */
  Vue.cid = 0;
  var cid = 1;

  /**
   * Class inheritance
   */
  Vue.extend = function (extendOptions) {
    extendOptions = extendOptions || {};
    var Super = this;
    var SuperId = Super.cid;
    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});
    if (cachedCtors[SuperId]) {
      return cachedCtors[SuperId]
    }

    var name = extendOptions.name || Super.options.name;
    if (process.env.NODE_ENV !== 'production' && name) {
      validateComponentName(name);
    }

    var Sub = function VueComponent (options) {
      this._init(options);
    };
    Sub.prototype = Object.create(Super.prototype);
    Sub.prototype.constructor = Sub;
    Sub.cid = cid++;
    Sub.options = mergeOptions(
      Super.options,
      extendOptions
    );
    Sub['super'] = Super;

    // For props and computed properties, we define the proxy getters on
    // the Vue instances at extension time, on the extended prototype. This
    // avoids Object.defineProperty calls for each instance created.
    if (Sub.options.props) {
      initProps$1(Sub);
    }
    if (Sub.options.computed) {
      initComputed$1(Sub);
    }

    // allow further extension/mixin/plugin usage
    Sub.extend = Super.extend;
    Sub.mixin = Super.mixin;
    Sub.use = Super.use;

    // create asset registers, so extended classes
    // can have their private assets too.
    ASSET_TYPES.forEach(function (type) {
      Sub[type] = Super[type];
    });
    // enable recursive self-lookup
    if (name) {
      Sub.options.components[name] = Sub;
    }

    // keep a reference to the super options at extension time.
    // later at instantiation we can check if Super's options have
    // been updated.
    Sub.superOptions = Super.options;
    Sub.extendOptions = extendOptions;
    Sub.sealedOptions = extend({}, Sub.options);

    // cache constructor
    cachedCtors[SuperId] = Sub;
    return Sub
  };
}

function initProps$1 (Comp) {
  var props = Comp.options.props;
  for (var key in props) {
    proxy(Comp.prototype, "_props", key);
  }
}

function initComputed$1 (Comp) {
  var computed = Comp.options.computed;
  for (var key in computed) {
    defineComputed(Comp.prototype, key, computed[key]);
  }
}

/*  */

function initAssetRegisters (Vue) {
  /**
   * Create asset registration methods.
   */
  ASSET_TYPES.forEach(function (type) {
    Vue[type] = function (
      id,
      definition
    ) {
      if (!definition) {
        return this.options[type + 's'][id]
      } else {
        /* istanbul ignore if */
        if (process.env.NODE_ENV !== 'production' && type === 'component') {
          validateComponentName(id);
        }
        if (type === 'component' && isPlainObject(definition)) {
          definition.name = definition.name || id;
          definition = this.options._base.extend(definition);
        }
        if (type === 'directive' && typeof definition === 'function') {
          definition = { bind: definition, update: definition };
        }
        this.options[type + 's'][id] = definition;
        return definition
      }
    };
  });
}

/*  */

function getComponentName (opts) {
  return opts && (opts.Ctor.options.name || opts.tag)
}

function matches (pattern, name) {
  if (Array.isArray(pattern)) {
    return pattern.indexOf(name) > -1
  } else if (typeof pattern === 'string') {
    return pattern.split(',').indexOf(name) > -1
  } else if (isRegExp(pattern)) {
    return pattern.test(name)
  }
  /* istanbul ignore next */
  return false
}

function pruneCache (keepAliveInstance, filter) {
  var cache = keepAliveInstance.cache;
  var keys = keepAliveInstance.keys;
  var _vnode = keepAliveInstance._vnode;
  for (var key in cache) {
    var cachedNode = cache[key];
    if (cachedNode) {
      var name = getComponentName(cachedNode.componentOptions);
      if (name && !filter(name)) {
        pruneCacheEntry(cache, key, keys, _vnode);
      }
    }
  }
}

function pruneCacheEntry (
  cache,
  key,
  keys,
  current
) {
  var cached$$1 = cache[key];
  if (cached$$1 && (!current || cached$$1.tag !== current.tag)) {
    cached$$1.componentInstance.$destroy();
  }
  cache[key] = null;
  remove(keys, key);
}

var patternTypes = [String, RegExp, Array];

var KeepAlive = {
  name: 'keep-alive',
  abstract: true,

  props: {
    include: patternTypes,
    exclude: patternTypes,
    max: [String, Number]
  },

  created: function created () {
    this.cache = Object.create(null);
    this.keys = [];
  },

  destroyed: function destroyed () {
    var this$1 = this;

    for (var key in this$1.cache) {
      pruneCacheEntry(this$1.cache, key, this$1.keys);
    }
  },

  watch: {
    include: function include (val) {
      pruneCache(this, function (name) { return matches(val, name); });
    },
    exclude: function exclude (val) {
      pruneCache(this, function (name) { return !matches(val, name); });
    }
  },

  render: function render () {
    var slot = this.$slots.default;
    var vnode = getFirstComponentChild(slot);
    var componentOptions = vnode && vnode.componentOptions;
    if (componentOptions) {
      // check pattern
      var name = getComponentName(componentOptions);
      var ref = this;
      var include = ref.include;
      var exclude = ref.exclude;
      if (
        // not included
        (include && (!name || !matches(include, name))) ||
        // excluded
        (exclude && name && matches(exclude, name))
      ) {
        return vnode
      }

      var ref$1 = this;
      var cache = ref$1.cache;
      var keys = ref$1.keys;
      var key = vnode.key == null
        // same constructor may get registered as different local components
        // so cid alone is not enough (#3269)
        ? componentOptions.Ctor.cid + (componentOptions.tag ? ("::" + (componentOptions.tag)) : '')
        : vnode.key;
      if (cache[key]) {
        vnode.componentInstance = cache[key].componentInstance;
        // make current key freshest
        remove(keys, key);
        keys.push(key);
      } else {
        cache[key] = vnode;
        keys.push(key);
        // prune oldest entry
        if (this.max && keys.length > parseInt(this.max)) {
          pruneCacheEntry(cache, keys[0], keys, this._vnode);
        }
      }

      vnode.data.keepAlive = true;
    }
    return vnode || (slot && slot[0])
  }
};

var builtInComponents = {
  KeepAlive: KeepAlive
};

/*  */

function initGlobalAPI (Vue) {
  // config
  var configDef = {};
  configDef.get = function () { return config; };
  if (process.env.NODE_ENV !== 'production') {
    configDef.set = function () {
      warn(
        'Do not replace the Vue.config object, set individual fields instead.'
      );
    };
  }
  Object.defineProperty(Vue, 'config', configDef);

  // exposed util methods.
  // NOTE: these are not considered part of the public API - avoid relying on
  // them unless you are aware of the risk.
  Vue.util = {
    warn: warn,
    extend: extend,
    mergeOptions: mergeOptions,
    defineReactive: defineReactive
  };

  Vue.set = set;
  Vue.delete = del;
  Vue.nextTick = nextTick;

  Vue.options = Object.create(null);
  ASSET_TYPES.forEach(function (type) {
    Vue.options[type + 's'] = Object.create(null);
  });

  // this is used to identify the "base" constructor to extend all plain-object
  // components with in Weex's multi-instance scenarios.
  Vue.options._base = Vue;

  extend(Vue.options.components, builtInComponents);

  initUse(Vue);
  initMixin$1(Vue);
  initExtend(Vue);
  initAssetRegisters(Vue);
}

initGlobalAPI(Vue$3);

Object.defineProperty(Vue$3.prototype, '$isServer', {
  get: isServerRendering
});

Object.defineProperty(Vue$3.prototype, '$ssrContext', {
  get: function get () {
    /* istanbul ignore next */
    return this.$vnode && this.$vnode.ssrContext
  }
});

Vue$3.version = '2.5.13';

/*  */

// these are reserved for web because they are directly compiled away
// during template compilation
var isReservedAttr = makeMap('style,class');

// attributes that should be using props for binding
var acceptValue = makeMap('input,textarea,option,select,progress');
var mustUseProp = function (tag, type, attr) {
  return (
    (attr === 'value' && acceptValue(tag)) && type !== 'button' ||
    (attr === 'selected' && tag === 'option') ||
    (attr === 'checked' && tag === 'input') ||
    (attr === 'muted' && tag === 'video')
  )
};

var isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');

var isBooleanAttr = makeMap(
  'allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +
  'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +
  'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +
  'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +
  'required,reversed,scoped,seamless,selected,sortable,translate,' +
  'truespeed,typemustmatch,visible'
);

var xlinkNS = 'http://www.w3.org/1999/xlink';

var isXlink = function (name) {
  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink'
};

var getXlinkProp = function (name) {
  return isXlink(name) ? name.slice(6, name.length) : ''
};

var isFalsyAttrValue = function (val) {
  return val == null || val === false
};

/*  */

function genClassForVnode (vnode) {
  var data = vnode.data;
  var parentNode = vnode;
  var childNode = vnode;
  while (isDef(childNode.componentInstance)) {
    childNode = childNode.componentInstance._vnode;
    if (childNode && childNode.data) {
      data = mergeClassData(childNode.data, data);
    }
  }
  while (isDef(parentNode = parentNode.parent)) {
    if (parentNode && parentNode.data) {
      data = mergeClassData(data, parentNode.data);
    }
  }
  return renderClass(data.staticClass, data.class)
}

function mergeClassData (child, parent) {
  return {
    staticClass: concat(child.staticClass, parent.staticClass),
    class: isDef(child.class)
      ? [child.class, parent.class]
      : parent.class
  }
}

function renderClass (
  staticClass,
  dynamicClass
) {
  if (isDef(staticClass) || isDef(dynamicClass)) {
    return concat(staticClass, stringifyClass(dynamicClass))
  }
  /* istanbul ignore next */
  return ''
}

function concat (a, b) {
  return a ? b ? (a + ' ' + b) : a : (b || '')
}

function stringifyClass (value) {
  if (Array.isArray(value)) {
    return stringifyArray(value)
  }
  if (isObject(value)) {
    return stringifyObject(value)
  }
  if (typeof value === 'string') {
    return value
  }
  /* istanbul ignore next */
  return ''
}

function stringifyArray (value) {
  var res = '';
  var stringified;
  for (var i = 0, l = value.length; i < l; i++) {
    if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {
      if (res) { res += ' '; }
      res += stringified;
    }
  }
  return res
}

function stringifyObject (value) {
  var res = '';
  for (var key in value) {
    if (value[key]) {
      if (res) { res += ' '; }
      res += key;
    }
  }
  return res
}

/*  */

var namespaceMap = {
  svg: 'http://www.w3.org/2000/svg',
  math: 'http://www.w3.org/1998/Math/MathML'
};

var isHTMLTag = makeMap(
  'html,body,base,head,link,meta,style,title,' +
  'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +
  'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' +
  'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +
  's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +
  'embed,object,param,source,canvas,script,noscript,del,ins,' +
  'caption,col,colgroup,table,thead,tbody,td,th,tr,' +
  'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +
  'output,progress,select,textarea,' +
  'details,dialog,menu,menuitem,summary,' +
  'content,element,shadow,template,blockquote,iframe,tfoot'
);

// this map is intentionally selective, only covering SVG elements that may
// contain child elements.
var isSVG = makeMap(
  'svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' +
  'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +
  'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view',
  true
);



var isReservedTag = function (tag) {
  return isHTMLTag(tag) || isSVG(tag)
};

function getTagNamespace (tag) {
  if (isSVG(tag)) {
    return 'svg'
  }
  // basic support for MathML
  // note it doesn't support other MathML elements being component roots
  if (tag === 'math') {
    return 'math'
  }
}

var unknownElementCache = Object.create(null);
function isUnknownElement (tag) {
  /* istanbul ignore if */
  if (!inBrowser) {
    return true
  }
  if (isReservedTag(tag)) {
    return false
  }
  tag = tag.toLowerCase();
  /* istanbul ignore if */
  if (unknownElementCache[tag] != null) {
    return unknownElementCache[tag]
  }
  var el = document.createElement(tag);
  if (tag.indexOf('-') > -1) {
    // http://stackoverflow.com/a/28210364/1070244
    return (unknownElementCache[tag] = (
      el.constructor === window.HTMLUnknownElement ||
      el.constructor === window.HTMLElement
    ))
  } else {
    return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()))
  }
}

var isTextInputType = makeMap('text,number,password,search,email,tel,url');

/*  */

/**
 * Query an element selector if it's not an element already.
 */
function query (el) {
  if (typeof el === 'string') {
    var selected = document.querySelector(el);
    if (!selected) {
      process.env.NODE_ENV !== 'production' && warn(
        'Cannot find element: ' + el
      );
      return document.createElement('div')
    }
    return selected
  } else {
    return el
  }
}

/*  */

function createElement$1 (tagName, vnode) {
  var elm = document.createElement(tagName);
  if (tagName !== 'select') {
    return elm
  }
  // false or null will remove the attribute but undefined will not
  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {
    elm.setAttribute('multiple', 'multiple');
  }
  return elm
}

function createElementNS (namespace, tagName) {
  return document.createElementNS(namespaceMap[namespace], tagName)
}

function createTextNode (text) {
  return document.createTextNode(text)
}

function createComment (text) {
  return document.createComment(text)
}

function insertBefore (parentNode, newNode, referenceNode) {
  parentNode.insertBefore(newNode, referenceNode);
}

function removeChild (node, child) {
  node.removeChild(child);
}

function appendChild (node, child) {
  node.appendChild(child);
}

function parentNode (node) {
  return node.parentNode
}

function nextSibling (node) {
  return node.nextSibling
}

function tagName (node) {
  return node.tagName
}

function setTextContent (node, text) {
  node.textContent = text;
}

function setAttribute (node, key, val) {
  node.setAttribute(key, val);
}


var nodeOps = Object.freeze({
	createElement: createElement$1,
	createElementNS: createElementNS,
	createTextNode: createTextNode,
	createComment: createComment,
	insertBefore: insertBefore,
	removeChild: removeChild,
	appendChild: appendChild,
	parentNode: parentNode,
	nextSibling: nextSibling,
	tagName: tagName,
	setTextContent: setTextContent,
	setAttribute: setAttribute
});

/*  */

var ref = {
  create: function create (_, vnode) {
    registerRef(vnode);
  },
  update: function update (oldVnode, vnode) {
    if (oldVnode.data.ref !== vnode.data.ref) {
      registerRef(oldVnode, true);
      registerRef(vnode);
    }
  },
  destroy: function destroy (vnode) {
    registerRef(vnode, true);
  }
};

function registerRef (vnode, isRemoval) {
  var key = vnode.data.ref;
  if (!key) { return }

  var vm = vnode.context;
  var ref = vnode.componentInstance || vnode.elm;
  var refs = vm.$refs;
  if (isRemoval) {
    if (Array.isArray(refs[key])) {
      remove(refs[key], ref);
    } else if (refs[key] === ref) {
      refs[key] = undefined;
    }
  } else {
    if (vnode.data.refInFor) {
      if (!Array.isArray(refs[key])) {
        refs[key] = [ref];
      } else if (refs[key].indexOf(ref) < 0) {
        // $flow-disable-line
        refs[key].push(ref);
      }
    } else {
      refs[key] = ref;
    }
  }
}

/**
 * Virtual DOM patching algorithm based on Snabbdom by
 * Simon Friis Vindum (@paldepind)
 * Licensed under the MIT License
 * https://github.com/paldepind/snabbdom/blob/master/LICENSE
 *
 * modified by Evan You (@yyx990803)
 *
 * Not type-checking this because this file is perf-critical and the cost
 * of making flow understand it is not worth it.
 */

var emptyNode = new VNode('', {}, []);

var hooks = ['create', 'activate', 'update', 'remove', 'destroy'];

function sameVnode (a, b) {
  return (
    a.key === b.key && (
      (
        a.tag === b.tag &&
        a.isComment === b.isComment &&
        isDef(a.data) === isDef(b.data) &&
        sameInputType(a, b)
      ) || (
        isTrue(a.isAsyncPlaceholder) &&
        a.asyncFactory === b.asyncFactory &&
        isUndef(b.asyncFactory.error)
      )
    )
  )
}

function sameInputType (a, b) {
  if (a.tag !== 'input') { return true }
  var i;
  var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;
  var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;
  return typeA === typeB || isTextInputType(typeA) && isTextInputType(typeB)
}

function createKeyToOldIdx (children, beginIdx, endIdx) {
  var i, key;
  var map = {};
  for (i = beginIdx; i <= endIdx; ++i) {
    key = children[i].key;
    if (isDef(key)) { map[key] = i; }
  }
  return map
}

function createPatchFunction (backend) {
  var i, j;
  var cbs = {};

  var modules = backend.modules;
  var nodeOps = backend.nodeOps;

  for (i = 0; i < hooks.length; ++i) {
    cbs[hooks[i]] = [];
    for (j = 0; j < modules.length; ++j) {
      if (isDef(modules[j][hooks[i]])) {
        cbs[hooks[i]].push(modules[j][hooks[i]]);
      }
    }
  }

  function emptyNodeAt (elm) {
    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm)
  }

  function createRmCb (childElm, listeners) {
    function remove () {
      if (--remove.listeners === 0) {
        removeNode(childElm);
      }
    }
    remove.listeners = listeners;
    return remove
  }

  function removeNode (el) {
    var parent = nodeOps.parentNode(el);
    // element may have already been removed due to v-html / v-text
    if (isDef(parent)) {
      nodeOps.removeChild(parent, el);
    }
  }

  function isUnknownElement$$1 (vnode, inVPre) {
    return (
      !inVPre &&
      !vnode.ns &&
      !(
        config.ignoredElements.length &&
        config.ignoredElements.some(function (ignore) {
          return isRegExp(ignore)
            ? ignore.test(vnode.tag)
            : ignore === vnode.tag
        })
      ) &&
      config.isUnknownElement(vnode.tag)
    )
  }

  var creatingElmInVPre = 0;
  function createElm (vnode, insertedVnodeQueue, parentElm, refElm, nested) {
    vnode.isRootInsert = !nested; // for transition enter check
    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
      return
    }

    var data = vnode.data;
    var children = vnode.children;
    var tag = vnode.tag;
    if (isDef(tag)) {
      if (process.env.NODE_ENV !== 'production') {
        if (data && data.pre) {
          creatingElmInVPre++;
        }
        if (isUnknownElement$$1(vnode, creatingElmInVPre)) {
          warn(
            'Unknown custom element: <' + tag + '> - did you ' +
            'register the component correctly? For recursive components, ' +
            'make sure to provide the "name" option.',
            vnode.context
          );
        }
      }
      vnode.elm = vnode.ns
        ? nodeOps.createElementNS(vnode.ns, tag)
        : nodeOps.createElement(tag, vnode);
      setScope(vnode);

      /* istanbul ignore if */
      {
        createChildren(vnode, children, insertedVnodeQueue);
        if (isDef(data)) {
          invokeCreateHooks(vnode, insertedVnodeQueue);
        }
        insert(parentElm, vnode.elm, refElm);
      }

      if (process.env.NODE_ENV !== 'production' && data && data.pre) {
        creatingElmInVPre--;
      }
    } else if (isTrue(vnode.isComment)) {
      vnode.elm = nodeOps.createComment(vnode.text);
      insert(parentElm, vnode.elm, refElm);
    } else {
      vnode.elm = nodeOps.createTextNode(vnode.text);
      insert(parentElm, vnode.elm, refElm);
    }
  }

  function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {
    var i = vnode.data;
    if (isDef(i)) {
      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;
      if (isDef(i = i.hook) && isDef(i = i.init)) {
        i(vnode, false /* hydrating */, parentElm, refElm);
      }
      // after calling the init hook, if the vnode is a child component
      // it should've created a child instance and mounted it. the child
      // component also has set the placeholder vnode's elm.
      // in that case we can just return the element and be done.
      if (isDef(vnode.componentInstance)) {
        initComponent(vnode, insertedVnodeQueue);
        if (isTrue(isReactivated)) {
          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);
        }
        return true
      }
    }
  }

  function initComponent (vnode, insertedVnodeQueue) {
    if (isDef(vnode.data.pendingInsert)) {
      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);
      vnode.data.pendingInsert = null;
    }
    vnode.elm = vnode.componentInstance.$el;
    if (isPatchable(vnode)) {
      invokeCreateHooks(vnode, insertedVnodeQueue);
      setScope(vnode);
    } else {
      // empty component root.
      // skip all element-related modules except for ref (#3455)
      registerRef(vnode);
      // make sure to invoke the insert hook
      insertedVnodeQueue.push(vnode);
    }
  }

  function reactivateComponent (vnode, insertedVnodeQueue, parentElm, refElm) {
    var i;
    // hack for #4339: a reactivated component with inner transition
    // does not trigger because the inner node's created hooks are not called
    // again. It's not ideal to involve module-specific logic in here but
    // there doesn't seem to be a better way to do it.
    var innerNode = vnode;
    while (innerNode.componentInstance) {
      innerNode = innerNode.componentInstance._vnode;
      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {
        for (i = 0; i < cbs.activate.length; ++i) {
          cbs.activate[i](emptyNode, innerNode);
        }
        insertedVnodeQueue.push(innerNode);
        break
      }
    }
    // unlike a newly created component,
    // a reactivated keep-alive component doesn't insert itself
    insert(parentElm, vnode.elm, refElm);
  }

  function insert (parent, elm, ref$$1) {
    if (isDef(parent)) {
      if (isDef(ref$$1)) {
        if (ref$$1.parentNode === parent) {
          nodeOps.insertBefore(parent, elm, ref$$1);
        }
      } else {
        nodeOps.appendChild(parent, elm);
      }
    }
  }

  function createChildren (vnode, children, insertedVnodeQueue) {
    if (Array.isArray(children)) {
      if (process.env.NODE_ENV !== 'production') {
        checkDuplicateKeys(children);
      }
      for (var i = 0; i < children.length; ++i) {
        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true);
      }
    } else if (isPrimitive(vnode.text)) {
      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text)));
    }
  }

  function isPatchable (vnode) {
    while (vnode.componentInstance) {
      vnode = vnode.componentInstance._vnode;
    }
    return isDef(vnode.tag)
  }

  function invokeCreateHooks (vnode, insertedVnodeQueue) {
    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
      cbs.create[i$1](emptyNode, vnode);
    }
    i = vnode.data.hook; // Reuse variable
    if (isDef(i)) {
      if (isDef(i.create)) { i.create(emptyNode, vnode); }
      if (isDef(i.insert)) { insertedVnodeQueue.push(vnode); }
    }
  }

  // set scope id attribute for scoped CSS.
  // this is implemented as a special case to avoid the overhead
  // of going through the normal attribute patching process.
  function setScope (vnode) {
    var i;
    if (isDef(i = vnode.fnScopeId)) {
      nodeOps.setAttribute(vnode.elm, i, '');
    } else {
      var ancestor = vnode;
      while (ancestor) {
        if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {
          nodeOps.setAttribute(vnode.elm, i, '');
        }
        ancestor = ancestor.parent;
      }
    }
    // for slot content they should also get the scopeId from the host instance.
    if (isDef(i = activeInstance) &&
      i !== vnode.context &&
      i !== vnode.fnContext &&
      isDef(i = i.$options._scopeId)
    ) {
      nodeOps.setAttribute(vnode.elm, i, '');
    }
  }

  function addVnodes (parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {
    for (; startIdx <= endIdx; ++startIdx) {
      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm);
    }
  }

  function invokeDestroyHook (vnode) {
    var i, j;
    var data = vnode.data;
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.destroy)) { i(vnode); }
      for (i = 0; i < cbs.destroy.length; ++i) { cbs.destroy[i](vnode); }
    }
    if (isDef(i = vnode.children)) {
      for (j = 0; j < vnode.children.length; ++j) {
        invokeDestroyHook(vnode.children[j]);
      }
    }
  }

  function removeVnodes (parentElm, vnodes, startIdx, endIdx) {
    for (; startIdx <= endIdx; ++startIdx) {
      var ch = vnodes[startIdx];
      if (isDef(ch)) {
        if (isDef(ch.tag)) {
          removeAndInvokeRemoveHook(ch);
          invokeDestroyHook(ch);
        } else { // Text node
          removeNode(ch.elm);
        }
      }
    }
  }

  function removeAndInvokeRemoveHook (vnode, rm) {
    if (isDef(rm) || isDef(vnode.data)) {
      var i;
      var listeners = cbs.remove.length + 1;
      if (isDef(rm)) {
        // we have a recursively passed down rm callback
        // increase the listeners count
        rm.listeners += listeners;
      } else {
        // directly removing
        rm = createRmCb(vnode.elm, listeners);
      }
      // recursively invoke hooks on child component root node
      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {
        removeAndInvokeRemoveHook(i, rm);
      }
      for (i = 0; i < cbs.remove.length; ++i) {
        cbs.remove[i](vnode, rm);
      }
      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {
        i(vnode, rm);
      } else {
        rm();
      }
    } else {
      removeNode(vnode.elm);
    }
  }

  function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
    var oldStartIdx = 0;
    var newStartIdx = 0;
    var oldEndIdx = oldCh.length - 1;
    var oldStartVnode = oldCh[0];
    var oldEndVnode = oldCh[oldEndIdx];
    var newEndIdx = newCh.length - 1;
    var newStartVnode = newCh[0];
    var newEndVnode = newCh[newEndIdx];
    var oldKeyToIdx, idxInOld, vnodeToMove, refElm;

    // removeOnly is a special flag used only by <transition-group>
    // to ensure removed elements stay in correct relative positions
    // during leaving transitions
    var canMove = !removeOnly;

    if (process.env.NODE_ENV !== 'production') {
      checkDuplicateKeys(newCh);
    }

    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
      if (isUndef(oldStartVnode)) {
        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left
      } else if (isUndef(oldEndVnode)) {
        oldEndVnode = oldCh[--oldEndIdx];
      } else if (sameVnode(oldStartVnode, newStartVnode)) {
        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);
        oldStartVnode = oldCh[++oldStartIdx];
        newStartVnode = newCh[++newStartIdx];
      } else if (sameVnode(oldEndVnode, newEndVnode)) {
        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);
        oldEndVnode = oldCh[--oldEndIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right
        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);
        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));
        oldStartVnode = oldCh[++oldStartIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left
        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);
        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
        oldEndVnode = oldCh[--oldEndIdx];
        newStartVnode = newCh[++newStartIdx];
      } else {
        if (isUndef(oldKeyToIdx)) { oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); }
        idxInOld = isDef(newStartVnode.key)
          ? oldKeyToIdx[newStartVnode.key]
          : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);
        if (isUndef(idxInOld)) { // New element
          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);
        } else {
          vnodeToMove = oldCh[idxInOld];
          if (sameVnode(vnodeToMove, newStartVnode)) {
            patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue);
            oldCh[idxInOld] = undefined;
            canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);
          } else {
            // same key but different element. treat as new element
            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);
          }
        }
        newStartVnode = newCh[++newStartIdx];
      }
    }
    if (oldStartIdx > oldEndIdx) {
      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;
      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
    } else if (newStartIdx > newEndIdx) {
      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
    }
  }

  function checkDuplicateKeys (children) {
    var seenKeys = {};
    for (var i = 0; i < children.length; i++) {
      var vnode = children[i];
      var key = vnode.key;
      if (isDef(key)) {
        if (seenKeys[key]) {
          warn(
            ("Duplicate keys detected: '" + key + "'. This may cause an update error."),
            vnode.context
          );
        } else {
          seenKeys[key] = true;
        }
      }
    }
  }

  function findIdxInOld (node, oldCh, start, end) {
    for (var i = start; i < end; i++) {
      var c = oldCh[i];
      if (isDef(c) && sameVnode(node, c)) { return i }
    }
  }

  function patchVnode (oldVnode, vnode, insertedVnodeQueue, removeOnly) {
    if (oldVnode === vnode) {
      return
    }

    var elm = vnode.elm = oldVnode.elm;

    if (isTrue(oldVnode.isAsyncPlaceholder)) {
      if (isDef(vnode.asyncFactory.resolved)) {
        hydrate(oldVnode.elm, vnode, insertedVnodeQueue);
      } else {
        vnode.isAsyncPlaceholder = true;
      }
      return
    }

    // reuse element for static trees.
    // note we only do this if the vnode is cloned -
    // if the new node is not cloned it means the render functions have been
    // reset by the hot-reload-api and we need to do a proper re-render.
    if (isTrue(vnode.isStatic) &&
      isTrue(oldVnode.isStatic) &&
      vnode.key === oldVnode.key &&
      (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))
    ) {
      vnode.componentInstance = oldVnode.componentInstance;
      return
    }

    var i;
    var data = vnode.data;
    if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {
      i(oldVnode, vnode);
    }

    var oldCh = oldVnode.children;
    var ch = vnode.children;
    if (isDef(data) && isPatchable(vnode)) {
      for (i = 0; i < cbs.update.length; ++i) { cbs.update[i](oldVnode, vnode); }
      if (isDef(i = data.hook) && isDef(i = i.update)) { i(oldVnode, vnode); }
    }
    if (isUndef(vnode.text)) {
      if (isDef(oldCh) && isDef(ch)) {
        if (oldCh !== ch) { updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly); }
      } else if (isDef(ch)) {
        if (isDef(oldVnode.text)) { nodeOps.setTextContent(elm, ''); }
        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
      } else if (isDef(oldCh)) {
        removeVnodes(elm, oldCh, 0, oldCh.length - 1);
      } else if (isDef(oldVnode.text)) {
        nodeOps.setTextContent(elm, '');
      }
    } else if (oldVnode.text !== vnode.text) {
      nodeOps.setTextContent(elm, vnode.text);
    }
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.postpatch)) { i(oldVnode, vnode); }
    }
  }

  function invokeInsertHook (vnode, queue, initial) {
    // delay insert hooks for component root nodes, invoke them after the
    // element is really inserted
    if (isTrue(initial) && isDef(vnode.parent)) {
      vnode.parent.data.pendingInsert = queue;
    } else {
      for (var i = 0; i < queue.length; ++i) {
        queue[i].data.hook.insert(queue[i]);
      }
    }
  }

  var hydrationBailed = false;
  // list of modules that can skip create hook during hydration because they
  // are already rendered on the client or has no need for initialization
  // Note: style is excluded because it relies on initial clone for future
  // deep updates (#7063).
  var isRenderedModule = makeMap('attrs,class,staticClass,staticStyle,key');

  // Note: this is a browser-only function so we can assume elms are DOM nodes.
  function hydrate (elm, vnode, insertedVnodeQueue, inVPre) {
    var i;
    var tag = vnode.tag;
    var data = vnode.data;
    var children = vnode.children;
    inVPre = inVPre || (data && data.pre);
    vnode.elm = elm;

    if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {
      vnode.isAsyncPlaceholder = true;
      return true
    }
    // assert node match
    if (process.env.NODE_ENV !== 'production') {
      if (!assertNodeMatch(elm, vnode, inVPre)) {
        return false
      }
    }
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.init)) { i(vnode, true /* hydrating */); }
      if (isDef(i = vnode.componentInstance)) {
        // child component. it should have hydrated its own tree.
        initComponent(vnode, insertedVnodeQueue);
        return true
      }
    }
    if (isDef(tag)) {
      if (isDef(children)) {
        // empty element, allow client to pick up and populate children
        if (!elm.hasChildNodes()) {
          createChildren(vnode, children, insertedVnodeQueue);
        } else {
          // v-html and domProps: innerHTML
          if (isDef(i = data) && isDef(i = i.domProps) && isDef(i = i.innerHTML)) {
            if (i !== elm.innerHTML) {
              /* istanbul ignore if */
              if (process.env.NODE_ENV !== 'production' &&
                typeof console !== 'undefined' &&
                !hydrationBailed
              ) {
                hydrationBailed = true;
                console.warn('Parent: ', elm);
                console.warn('server innerHTML: ', i);
                console.warn('client innerHTML: ', elm.innerHTML);
              }
              return false
            }
          } else {
            // iterate and compare children lists
            var childrenMatch = true;
            var childNode = elm.firstChild;
            for (var i$1 = 0; i$1 < children.length; i$1++) {
              if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue, inVPre)) {
                childrenMatch = false;
                break
              }
              childNode = childNode.nextSibling;
            }
            // if childNode is not null, it means the actual childNodes list is
            // longer than the virtual children list.
            if (!childrenMatch || childNode) {
              /* istanbul ignore if */
              if (process.env.NODE_ENV !== 'production' &&
                typeof console !== 'undefined' &&
                !hydrationBailed
              ) {
                hydrationBailed = true;
                console.warn('Parent: ', elm);
                console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);
              }
              return false
            }
          }
        }
      }
      if (isDef(data)) {
        var fullInvoke = false;
        for (var key in data) {
          if (!isRenderedModule(key)) {
            fullInvoke = true;
            invokeCreateHooks(vnode, insertedVnodeQueue);
            break
          }
        }
        if (!fullInvoke && data['class']) {
          // ensure collecting deps for deep class bindings for future updates
          traverse(data['class']);
        }
      }
    } else if (elm.data !== vnode.text) {
      elm.data = vnode.text;
    }
    return true
  }

  function assertNodeMatch (node, vnode, inVPre) {
    if (isDef(vnode.tag)) {
      return vnode.tag.indexOf('vue-component') === 0 || (
        !isUnknownElement$$1(vnode, inVPre) &&
        vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase())
      )
    } else {
      return node.nodeType === (vnode.isComment ? 8 : 3)
    }
  }

  return function patch (oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) {
    if (isUndef(vnode)) {
      if (isDef(oldVnode)) { invokeDestroyHook(oldVnode); }
      return
    }

    var isInitialPatch = false;
    var insertedVnodeQueue = [];

    if (isUndef(oldVnode)) {
      // empty mount (likely as component), create new root element
      isInitialPatch = true;
      createElm(vnode, insertedVnodeQueue, parentElm, refElm);
    } else {
      var isRealElement = isDef(oldVnode.nodeType);
      if (!isRealElement && sameVnode(oldVnode, vnode)) {
        // patch existing root node
        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);
      } else {
        if (isRealElement) {
          // mounting to a real element
          // check if this is server-rendered content and if we can perform
          // a successful hydration.
          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {
            oldVnode.removeAttribute(SSR_ATTR);
            hydrating = true;
          }
          if (isTrue(hydrating)) {
            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
              invokeInsertHook(vnode, insertedVnodeQueue, true);
              return oldVnode
            } else if (process.env.NODE_ENV !== 'production') {
              warn(
                'The client-side rendered virtual DOM tree is not matching ' +
                'server-rendered content. This is likely caused by incorrect ' +
                'HTML markup, for example nesting block-level elements inside ' +
                '<p>, or missing <tbody>. Bailing hydration and performing ' +
                'full client-side render.'
              );
            }
          }
          // either not server-rendered, or hydration failed.
          // create an empty node and replace it
          oldVnode = emptyNodeAt(oldVnode);
        }

        // replacing existing element
        var oldElm = oldVnode.elm;
        var parentElm$1 = nodeOps.parentNode(oldElm);

        // create new node
        createElm(
          vnode,
          insertedVnodeQueue,
          // extremely rare edge case: do not insert if old element is in a
          // leaving transition. Only happens when combining transition +
          // keep-alive + HOCs. (#4590)
          oldElm._leaveCb ? null : parentElm$1,
          nodeOps.nextSibling(oldElm)
        );

        // update parent placeholder node element, recursively
        if (isDef(vnode.parent)) {
          var ancestor = vnode.parent;
          var patchable = isPatchable(vnode);
          while (ancestor) {
            for (var i = 0; i < cbs.destroy.length; ++i) {
              cbs.destroy[i](ancestor);
            }
            ancestor.elm = vnode.elm;
            if (patchable) {
              for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
                cbs.create[i$1](emptyNode, ancestor);
              }
              // #6513
              // invoke insert hooks that may have been merged by create hooks.
              // e.g. for directives that uses the "inserted" hook.
              var insert = ancestor.data.hook.insert;
              if (insert.merged) {
                // start at index 1 to avoid re-invoking component mounted hook
                for (var i$2 = 1; i$2 < insert.fns.length; i$2++) {
                  insert.fns[i$2]();
                }
              }
            } else {
              registerRef(ancestor);
            }
            ancestor = ancestor.parent;
          }
        }

        // destroy old node
        if (isDef(parentElm$1)) {
          removeVnodes(parentElm$1, [oldVnode], 0, 0);
        } else if (isDef(oldVnode.tag)) {
          invokeDestroyHook(oldVnode);
        }
      }
    }

    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);
    return vnode.elm
  }
}

/*  */

var directives = {
  create: updateDirectives,
  update: updateDirectives,
  destroy: function unbindDirectives (vnode) {
    updateDirectives(vnode, emptyNode);
  }
};

function updateDirectives (oldVnode, vnode) {
  if (oldVnode.data.directives || vnode.data.directives) {
    _update(oldVnode, vnode);
  }
}

function _update (oldVnode, vnode) {
  var isCreate = oldVnode === emptyNode;
  var isDestroy = vnode === emptyNode;
  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);
  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);

  var dirsWithInsert = [];
  var dirsWithPostpatch = [];

  var key, oldDir, dir;
  for (key in newDirs) {
    oldDir = oldDirs[key];
    dir = newDirs[key];
    if (!oldDir) {
      // new directive, bind
      callHook$1(dir, 'bind', vnode, oldVnode);
      if (dir.def && dir.def.inserted) {
        dirsWithInsert.push(dir);
      }
    } else {
      // existing directive, update
      dir.oldValue = oldDir.value;
      callHook$1(dir, 'update', vnode, oldVnode);
      if (dir.def && dir.def.componentUpdated) {
        dirsWithPostpatch.push(dir);
      }
    }
  }

  if (dirsWithInsert.length) {
    var callInsert = function () {
      for (var i = 0; i < dirsWithInsert.length; i++) {
        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);
      }
    };
    if (isCreate) {
      mergeVNodeHook(vnode, 'insert', callInsert);
    } else {
      callInsert();
    }
  }

  if (dirsWithPostpatch.length) {
    mergeVNodeHook(vnode, 'postpatch', function () {
      for (var i = 0; i < dirsWithPostpatch.length; i++) {
        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);
      }
    });
  }

  if (!isCreate) {
    for (key in oldDirs) {
      if (!newDirs[key]) {
        // no longer present, unbind
        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);
      }
    }
  }
}

var emptyModifiers = Object.create(null);

function normalizeDirectives$1 (
  dirs,
  vm
) {
  var res = Object.create(null);
  if (!dirs) {
    // $flow-disable-line
    return res
  }
  var i, dir;
  for (i = 0; i < dirs.length; i++) {
    dir = dirs[i];
    if (!dir.modifiers) {
      // $flow-disable-line
      dir.modifiers = emptyModifiers;
    }
    res[getRawDirName(dir)] = dir;
    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);
  }
  // $flow-disable-line
  return res
}

function getRawDirName (dir) {
  return dir.rawName || ((dir.name) + "." + (Object.keys(dir.modifiers || {}).join('.')))
}

function callHook$1 (dir, hook, vnode, oldVnode, isDestroy) {
  var fn = dir.def && dir.def[hook];
  if (fn) {
    try {
      fn(vnode.elm, dir, vnode, oldVnode, isDestroy);
    } catch (e) {
      handleError(e, vnode.context, ("directive " + (dir.name) + " " + hook + " hook"));
    }
  }
}

var baseModules = [
  ref,
  directives
];

/*  */

function updateAttrs (oldVnode, vnode) {
  var opts = vnode.componentOptions;
  if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {
    return
  }
  if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {
    return
  }
  var key, cur, old;
  var elm = vnode.elm;
  var oldAttrs = oldVnode.data.attrs || {};
  var attrs = vnode.data.attrs || {};
  // clone observed objects, as the user probably wants to mutate it
  if (isDef(attrs.__ob__)) {
    attrs = vnode.data.attrs = extend({}, attrs);
  }

  for (key in attrs) {
    cur = attrs[key];
    old = oldAttrs[key];
    if (old !== cur) {
      setAttr(elm, key, cur);
    }
  }
  // #4391: in IE9, setting type can reset value for input[type=radio]
  // #6666: IE/Edge forces progress value down to 1 before setting a max
  /* istanbul ignore if */
  if ((isIE || isEdge) && attrs.value !== oldAttrs.value) {
    setAttr(elm, 'value', attrs.value);
  }
  for (key in oldAttrs) {
    if (isUndef(attrs[key])) {
      if (isXlink(key)) {
        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));
      } else if (!isEnumeratedAttr(key)) {
        elm.removeAttribute(key);
      }
    }
  }
}

function setAttr (el, key, value) {
  if (isBooleanAttr(key)) {
    // set attribute for blank value
    // e.g. <option disabled>Select one</option>
    if (isFalsyAttrValue(value)) {
      el.removeAttribute(key);
    } else {
      // technically allowfullscreen is a boolean attribute for <iframe>,
      // but Flash expects a value of "true" when used on <embed> tag
      value = key === 'allowfullscreen' && el.tagName === 'EMBED'
        ? 'true'
        : key;
      el.setAttribute(key, value);
    }
  } else if (isEnumeratedAttr(key)) {
    el.setAttribute(key, isFalsyAttrValue(value) || value === 'false' ? 'false' : 'true');
  } else if (isXlink(key)) {
    if (isFalsyAttrValue(value)) {
      el.removeAttributeNS(xlinkNS, getXlinkProp(key));
    } else {
      el.setAttributeNS(xlinkNS, key, value);
    }
  } else {
    if (isFalsyAttrValue(value)) {
      el.removeAttribute(key);
    } else {
      // #7138: IE10 & 11 fires input event when setting placeholder on
      // <textarea>... block the first input event and remove the blocker
      // immediately.
      /* istanbul ignore if */
      if (
        isIE && !isIE9 &&
        el.tagName === 'TEXTAREA' &&
        key === 'placeholder' && !el.__ieph
      ) {
        var blocker = function (e) {
          e.stopImmediatePropagation();
          el.removeEventListener('input', blocker);
        };
        el.addEventListener('input', blocker);
        // $flow-disable-line
        el.__ieph = true; /* IE placeholder patched */
      }
      el.setAttribute(key, value);
    }
  }
}

var attrs = {
  create: updateAttrs,
  update: updateAttrs
};

/*  */

function updateClass (oldVnode, vnode) {
  var el = vnode.elm;
  var data = vnode.data;
  var oldData = oldVnode.data;
  if (
    isUndef(data.staticClass) &&
    isUndef(data.class) && (
      isUndef(oldData) || (
        isUndef(oldData.staticClass) &&
        isUndef(oldData.class)
      )
    )
  ) {
    return
  }

  var cls = genClassForVnode(vnode);

  // handle transition classes
  var transitionClass = el._transitionClasses;
  if (isDef(transitionClass)) {
    cls = concat(cls, stringifyClass(transitionClass));
  }

  // set the class
  if (cls !== el._prevClass) {
    el.setAttribute('class', cls);
    el._prevClass = cls;
  }
}

var klass = {
  create: updateClass,
  update: updateClass
};

/*  */

/*  */









// add a raw attr (use this in preTransforms)








// note: this only removes the attr from the Array (attrsList) so that it
// doesn't get processed by processAttrs.
// By default it does NOT remove it from the map (attrsMap) because the map is
// needed during codegen.

/*  */

/**
 * Cross-platform code generation for component v-model
 */


/**
 * Cross-platform codegen helper for generating v-model value assignment code.
 */

/*  */

// in some cases, the event used has to be determined at runtime
// so we used some reserved tokens during compile.
var RANGE_TOKEN = '__r';
var CHECKBOX_RADIO_TOKEN = '__c';

/*  */

// normalize v-model event tokens that can only be determined at runtime.
// it's important to place the event as the first in the array because
// the whole point is ensuring the v-model callback gets called before
// user-attached handlers.
function normalizeEvents (on) {
  /* istanbul ignore if */
  if (isDef(on[RANGE_TOKEN])) {
    // IE input[type=range] only supports `change` event
    var event = isIE ? 'change' : 'input';
    on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);
    delete on[RANGE_TOKEN];
  }
  // This was originally intended to fix #4521 but no longer necessary
  // after 2.5. Keeping it for backwards compat with generated code from < 2.4
  /* istanbul ignore if */
  if (isDef(on[CHECKBOX_RADIO_TOKEN])) {
    on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || []);
    delete on[CHECKBOX_RADIO_TOKEN];
  }
}

var target$1;

function createOnceHandler (handler, event, capture) {
  var _target = target$1; // save current target element in closure
  return function onceHandler () {
    var res = handler.apply(null, arguments);
    if (res !== null) {
      remove$2(event, onceHandler, capture, _target);
    }
  }
}

function add$1 (
  event,
  handler,
  once$$1,
  capture,
  passive
) {
  handler = withMacroTask(handler);
  if (once$$1) { handler = createOnceHandler(handler, event, capture); }
  target$1.addEventListener(
    event,
    handler,
    supportsPassive
      ? { capture: capture, passive: passive }
      : capture
  );
}

function remove$2 (
  event,
  handler,
  capture,
  _target
) {
  (_target || target$1).removeEventListener(
    event,
    handler._withTask || handler,
    capture
  );
}

function updateDOMListeners (oldVnode, vnode) {
  if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {
    return
  }
  var on = vnode.data.on || {};
  var oldOn = oldVnode.data.on || {};
  target$1 = vnode.elm;
  normalizeEvents(on);
  updateListeners(on, oldOn, add$1, remove$2, vnode.context);
  target$1 = undefined;
}

var events = {
  create: updateDOMListeners,
  update: updateDOMListeners
};

/*  */

function updateDOMProps (oldVnode, vnode) {
  if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {
    return
  }
  var key, cur;
  var elm = vnode.elm;
  var oldProps = oldVnode.data.domProps || {};
  var props = vnode.data.domProps || {};
  // clone observed objects, as the user probably wants to mutate it
  if (isDef(props.__ob__)) {
    props = vnode.data.domProps = extend({}, props);
  }

  for (key in oldProps) {
    if (isUndef(props[key])) {
      elm[key] = '';
    }
  }
  for (key in props) {
    cur = props[key];
    // ignore children if the node has textContent or innerHTML,
    // as these will throw away existing DOM nodes and cause removal errors
    // on subsequent patches (#3360)
    if (key === 'textContent' || key === 'innerHTML') {
      if (vnode.children) { vnode.children.length = 0; }
      if (cur === oldProps[key]) { continue }
      // #6601 work around Chrome version <= 55 bug where single textNode
      // replaced by innerHTML/textContent retains its parentNode property
      if (elm.childNodes.length === 1) {
        elm.removeChild(elm.childNodes[0]);
      }
    }

    if (key === 'value') {
      // store value as _value as well since
      // non-string values will be stringified
      elm._value = cur;
      // avoid resetting cursor position when value is the same
      var strCur = isUndef(cur) ? '' : String(cur);
      if (shouldUpdateValue(elm, strCur)) {
        elm.value = strCur;
      }
    } else {
      elm[key] = cur;
    }
  }
}

// check platforms/web/util/attrs.js acceptValue


function shouldUpdateValue (elm, checkVal) {
  return (!elm.composing && (
    elm.tagName === 'OPTION' ||
    isNotInFocusAndDirty(elm, checkVal) ||
    isDirtyWithModifiers(elm, checkVal)
  ))
}

function isNotInFocusAndDirty (elm, checkVal) {
  // return true when textbox (.number and .trim) loses focus and its value is
  // not equal to the updated value
  var notInFocus = true;
  // #6157
  // work around IE bug when accessing document.activeElement in an iframe
  try { notInFocus = document.activeElement !== elm; } catch (e) {}
  return notInFocus && elm.value !== checkVal
}

function isDirtyWithModifiers (elm, newVal) {
  var value = elm.value;
  var modifiers = elm._vModifiers; // injected by v-model runtime
  if (isDef(modifiers)) {
    if (modifiers.lazy) {
      // inputs with lazy should only be updated when not in focus
      return false
    }
    if (modifiers.number) {
      return toNumber(value) !== toNumber(newVal)
    }
    if (modifiers.trim) {
      return value.trim() !== newVal.trim()
    }
  }
  return value !== newVal
}

var domProps = {
  create: updateDOMProps,
  update: updateDOMProps
};

/*  */

var parseStyleText = cached(function (cssText) {
  var res = {};
  var listDelimiter = /;(?![^(]*\))/g;
  var propertyDelimiter = /:(.+)/;
  cssText.split(listDelimiter).forEach(function (item) {
    if (item) {
      var tmp = item.split(propertyDelimiter);
      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return res
});

// merge static and dynamic style data on the same vnode
function normalizeStyleData (data) {
  var style = normalizeStyleBinding(data.style);
  // static style is pre-processed into an object during compilation
  // and is always a fresh object, so it's safe to merge into it
  return data.staticStyle
    ? extend(data.staticStyle, style)
    : style
}

// normalize possible array / string values into Object
function normalizeStyleBinding (bindingStyle) {
  if (Array.isArray(bindingStyle)) {
    return toObject(bindingStyle)
  }
  if (typeof bindingStyle === 'string') {
    return parseStyleText(bindingStyle)
  }
  return bindingStyle
}

/**
 * parent component style should be after child's
 * so that parent component's style could override it
 */
function getStyle (vnode, checkChild) {
  var res = {};
  var styleData;

  if (checkChild) {
    var childNode = vnode;
    while (childNode.componentInstance) {
      childNode = childNode.componentInstance._vnode;
      if (
        childNode && childNode.data &&
        (styleData = normalizeStyleData(childNode.data))
      ) {
        extend(res, styleData);
      }
    }
  }

  if ((styleData = normalizeStyleData(vnode.data))) {
    extend(res, styleData);
  }

  var parentNode = vnode;
  while ((parentNode = parentNode.parent)) {
    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {
      extend(res, styleData);
    }
  }
  return res
}

/*  */

var cssVarRE = /^--/;
var importantRE = /\s*!important$/;
var setProp = function (el, name, val) {
  /* istanbul ignore if */
  if (cssVarRE.test(name)) {
    el.style.setProperty(name, val);
  } else if (importantRE.test(val)) {
    el.style.setProperty(name, val.replace(importantRE, ''), 'important');
  } else {
    var normalizedName = normalize(name);
    if (Array.isArray(val)) {
      // Support values array created by autoprefixer, e.g.
      // {display: ["-webkit-box", "-ms-flexbox", "flex"]}
      // Set them one by one, and the browser will only set those it can recognize
      for (var i = 0, len = val.length; i < len; i++) {
        el.style[normalizedName] = val[i];
      }
    } else {
      el.style[normalizedName] = val;
    }
  }
};

var vendorNames = ['Webkit', 'Moz', 'ms'];

var emptyStyle;
var normalize = cached(function (prop) {
  emptyStyle = emptyStyle || document.createElement('div').style;
  prop = camelize(prop);
  if (prop !== 'filter' && (prop in emptyStyle)) {
    return prop
  }
  var capName = prop.charAt(0).toUpperCase() + prop.slice(1);
  for (var i = 0; i < vendorNames.length; i++) {
    var name = vendorNames[i] + capName;
    if (name in emptyStyle) {
      return name
    }
  }
});

function updateStyle (oldVnode, vnode) {
  var data = vnode.data;
  var oldData = oldVnode.data;

  if (isUndef(data.staticStyle) && isUndef(data.style) &&
    isUndef(oldData.staticStyle) && isUndef(oldData.style)
  ) {
    return
  }

  var cur, name;
  var el = vnode.elm;
  var oldStaticStyle = oldData.staticStyle;
  var oldStyleBinding = oldData.normalizedStyle || oldData.style || {};

  // if static style exists, stylebinding already merged into it when doing normalizeStyleData
  var oldStyle = oldStaticStyle || oldStyleBinding;

  var style = normalizeStyleBinding(vnode.data.style) || {};

  // store normalized style under a different key for next diff
  // make sure to clone it if it's reactive, since the user likely wants
  // to mutate it.
  vnode.data.normalizedStyle = isDef(style.__ob__)
    ? extend({}, style)
    : style;

  var newStyle = getStyle(vnode, true);

  for (name in oldStyle) {
    if (isUndef(newStyle[name])) {
      setProp(el, name, '');
    }
  }
  for (name in newStyle) {
    cur = newStyle[name];
    if (cur !== oldStyle[name]) {
      // ie9 setting to null has no effect, must use empty string
      setProp(el, name, cur == null ? '' : cur);
    }
  }
}

var style = {
  create: updateStyle,
  update: updateStyle
};

/*  */

/**
 * Add class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */
function addClass (el, cls) {
  /* istanbul ignore if */
  if (!cls || !(cls = cls.trim())) {
    return
  }

  /* istanbul ignore else */
  if (el.classList) {
    if (cls.indexOf(' ') > -1) {
      cls.split(/\s+/).forEach(function (c) { return el.classList.add(c); });
    } else {
      el.classList.add(cls);
    }
  } else {
    var cur = " " + (el.getAttribute('class') || '') + " ";
    if (cur.indexOf(' ' + cls + ' ') < 0) {
      el.setAttribute('class', (cur + cls).trim());
    }
  }
}

/**
 * Remove class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */
function removeClass (el, cls) {
  /* istanbul ignore if */
  if (!cls || !(cls = cls.trim())) {
    return
  }

  /* istanbul ignore else */
  if (el.classList) {
    if (cls.indexOf(' ') > -1) {
      cls.split(/\s+/).forEach(function (c) { return el.classList.remove(c); });
    } else {
      el.classList.remove(cls);
    }
    if (!el.classList.length) {
      el.removeAttribute('class');
    }
  } else {
    var cur = " " + (el.getAttribute('class') || '') + " ";
    var tar = ' ' + cls + ' ';
    while (cur.indexOf(tar) >= 0) {
      cur = cur.replace(tar, ' ');
    }
    cur = cur.trim();
    if (cur) {
      el.setAttribute('class', cur);
    } else {
      el.removeAttribute('class');
    }
  }
}

/*  */

function resolveTransition (def) {
  if (!def) {
    return
  }
  /* istanbul ignore else */
  if (typeof def === 'object') {
    var res = {};
    if (def.css !== false) {
      extend(res, autoCssTransition(def.name || 'v'));
    }
    extend(res, def);
    return res
  } else if (typeof def === 'string') {
    return autoCssTransition(def)
  }
}

var autoCssTransition = cached(function (name) {
  return {
    enterClass: (name + "-enter"),
    enterToClass: (name + "-enter-to"),
    enterActiveClass: (name + "-enter-active"),
    leaveClass: (name + "-leave"),
    leaveToClass: (name + "-leave-to"),
    leaveActiveClass: (name + "-leave-active")
  }
});

var hasTransition = inBrowser && !isIE9;
var TRANSITION = 'transition';
var ANIMATION = 'animation';

// Transition property/event sniffing
var transitionProp = 'transition';
var transitionEndEvent = 'transitionend';
var animationProp = 'animation';
var animationEndEvent = 'animationend';
if (hasTransition) {
  /* istanbul ignore if */
  if (window.ontransitionend === undefined &&
    window.onwebkittransitionend !== undefined
  ) {
    transitionProp = 'WebkitTransition';
    transitionEndEvent = 'webkitTransitionEnd';
  }
  if (window.onanimationend === undefined &&
    window.onwebkitanimationend !== undefined
  ) {
    animationProp = 'WebkitAnimation';
    animationEndEvent = 'webkitAnimationEnd';
  }
}

// binding to window is necessary to make hot reload work in IE in strict mode
var raf = inBrowser
  ? window.requestAnimationFrame
    ? window.requestAnimationFrame.bind(window)
    : setTimeout
  : /* istanbul ignore next */ function (fn) { return fn(); };

function nextFrame (fn) {
  raf(function () {
    raf(fn);
  });
}

function addTransitionClass (el, cls) {
  var transitionClasses = el._transitionClasses || (el._transitionClasses = []);
  if (transitionClasses.indexOf(cls) < 0) {
    transitionClasses.push(cls);
    addClass(el, cls);
  }
}

function removeTransitionClass (el, cls) {
  if (el._transitionClasses) {
    remove(el._transitionClasses, cls);
  }
  removeClass(el, cls);
}

function whenTransitionEnds (
  el,
  expectedType,
  cb
) {
  var ref = getTransitionInfo(el, expectedType);
  var type = ref.type;
  var timeout = ref.timeout;
  var propCount = ref.propCount;
  if (!type) { return cb() }
  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;
  var ended = 0;
  var end = function () {
    el.removeEventListener(event, onEnd);
    cb();
  };
  var onEnd = function (e) {
    if (e.target === el) {
      if (++ended >= propCount) {
        end();
      }
    }
  };
  setTimeout(function () {
    if (ended < propCount) {
      end();
    }
  }, timeout + 1);
  el.addEventListener(event, onEnd);
}

var transformRE = /\b(transform|all)(,|$)/;

function getTransitionInfo (el, expectedType) {
  var styles = window.getComputedStyle(el);
  var transitionDelays = styles[transitionProp + 'Delay'].split(', ');
  var transitionDurations = styles[transitionProp + 'Duration'].split(', ');
  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);
  var animationDelays = styles[animationProp + 'Delay'].split(', ');
  var animationDurations = styles[animationProp + 'Duration'].split(', ');
  var animationTimeout = getTimeout(animationDelays, animationDurations);

  var type;
  var timeout = 0;
  var propCount = 0;
  /* istanbul ignore if */
  if (expectedType === TRANSITION) {
    if (transitionTimeout > 0) {
      type = TRANSITION;
      timeout = transitionTimeout;
      propCount = transitionDurations.length;
    }
  } else if (expectedType === ANIMATION) {
    if (animationTimeout > 0) {
      type = ANIMATION;
      timeout = animationTimeout;
      propCount = animationDurations.length;
    }
  } else {
    timeout = Math.max(transitionTimeout, animationTimeout);
    type = timeout > 0
      ? transitionTimeout > animationTimeout
        ? TRANSITION
        : ANIMATION
      : null;
    propCount = type
      ? type === TRANSITION
        ? transitionDurations.length
        : animationDurations.length
      : 0;
  }
  var hasTransform =
    type === TRANSITION &&
    transformRE.test(styles[transitionProp + 'Property']);
  return {
    type: type,
    timeout: timeout,
    propCount: propCount,
    hasTransform: hasTransform
  }
}

function getTimeout (delays, durations) {
  /* istanbul ignore next */
  while (delays.length < durations.length) {
    delays = delays.concat(delays);
  }

  return Math.max.apply(null, durations.map(function (d, i) {
    return toMs(d) + toMs(delays[i])
  }))
}

function toMs (s) {
  return Number(s.slice(0, -1)) * 1000
}

/*  */

function enter (vnode, toggleDisplay) {
  var el = vnode.elm;

  // call leave callback now
  if (isDef(el._leaveCb)) {
    el._leaveCb.cancelled = true;
    el._leaveCb();
  }

  var data = resolveTransition(vnode.data.transition);
  if (isUndef(data)) {
    return
  }

  /* istanbul ignore if */
  if (isDef(el._enterCb) || el.nodeType !== 1) {
    return
  }

  var css = data.css;
  var type = data.type;
  var enterClass = data.enterClass;
  var enterToClass = data.enterToClass;
  var enterActiveClass = data.enterActiveClass;
  var appearClass = data.appearClass;
  var appearToClass = data.appearToClass;
  var appearActiveClass = data.appearActiveClass;
  var beforeEnter = data.beforeEnter;
  var enter = data.enter;
  var afterEnter = data.afterEnter;
  var enterCancelled = data.enterCancelled;
  var beforeAppear = data.beforeAppear;
  var appear = data.appear;
  var afterAppear = data.afterAppear;
  var appearCancelled = data.appearCancelled;
  var duration = data.duration;

  // activeInstance will always be the <transition> component managing this
  // transition. One edge case to check is when the <transition> is placed
  // as the root node of a child component. In that case we need to check
  // <transition>'s parent for appear check.
  var context = activeInstance;
  var transitionNode = activeInstance.$vnode;
  while (transitionNode && transitionNode.parent) {
    transitionNode = transitionNode.parent;
    context = transitionNode.context;
  }

  var isAppear = !context._isMounted || !vnode.isRootInsert;

  if (isAppear && !appear && appear !== '') {
    return
  }

  var startClass = isAppear && appearClass
    ? appearClass
    : enterClass;
  var activeClass = isAppear && appearActiveClass
    ? appearActiveClass
    : enterActiveClass;
  var toClass = isAppear && appearToClass
    ? appearToClass
    : enterToClass;

  var beforeEnterHook = isAppear
    ? (beforeAppear || beforeEnter)
    : beforeEnter;
  var enterHook = isAppear
    ? (typeof appear === 'function' ? appear : enter)
    : enter;
  var afterEnterHook = isAppear
    ? (afterAppear || afterEnter)
    : afterEnter;
  var enterCancelledHook = isAppear
    ? (appearCancelled || enterCancelled)
    : enterCancelled;

  var explicitEnterDuration = toNumber(
    isObject(duration)
      ? duration.enter
      : duration
  );

  if (process.env.NODE_ENV !== 'production' && explicitEnterDuration != null) {
    checkDuration(explicitEnterDuration, 'enter', vnode);
  }

  var expectsCSS = css !== false && !isIE9;
  var userWantsControl = getHookArgumentsLength(enterHook);

  var cb = el._enterCb = once(function () {
    if (expectsCSS) {
      removeTransitionClass(el, toClass);
      removeTransitionClass(el, activeClass);
    }
    if (cb.cancelled) {
      if (expectsCSS) {
        removeTransitionClass(el, startClass);
      }
      enterCancelledHook && enterCancelledHook(el);
    } else {
      afterEnterHook && afterEnterHook(el);
    }
    el._enterCb = null;
  });

  if (!vnode.data.show) {
    // remove pending leave element on enter by injecting an insert hook
    mergeVNodeHook(vnode, 'insert', function () {
      var parent = el.parentNode;
      var pendingNode = parent && parent._pending && parent._pending[vnode.key];
      if (pendingNode &&
        pendingNode.tag === vnode.tag &&
        pendingNode.elm._leaveCb
      ) {
        pendingNode.elm._leaveCb();
      }
      enterHook && enterHook(el, cb);
    });
  }

  // start enter transition
  beforeEnterHook && beforeEnterHook(el);
  if (expectsCSS) {
    addTransitionClass(el, startClass);
    addTransitionClass(el, activeClass);
    nextFrame(function () {
      addTransitionClass(el, toClass);
      removeTransitionClass(el, startClass);
      if (!cb.cancelled && !userWantsControl) {
        if (isValidDuration(explicitEnterDuration)) {
          setTimeout(cb, explicitEnterDuration);
        } else {
          whenTransitionEnds(el, type, cb);
        }
      }
    });
  }

  if (vnode.data.show) {
    toggleDisplay && toggleDisplay();
    enterHook && enterHook(el, cb);
  }

  if (!expectsCSS && !userWantsControl) {
    cb();
  }
}

function leave (vnode, rm) {
  var el = vnode.elm;

  // call enter callback now
  if (isDef(el._enterCb)) {
    el._enterCb.cancelled = true;
    el._enterCb();
  }

  var data = resolveTransition(vnode.data.transition);
  if (isUndef(data) || el.nodeType !== 1) {
    return rm()
  }

  /* istanbul ignore if */
  if (isDef(el._leaveCb)) {
    return
  }

  var css = data.css;
  var type = data.type;
  var leaveClass = data.leaveClass;
  var leaveToClass = data.leaveToClass;
  var leaveActiveClass = data.leaveActiveClass;
  var beforeLeave = data.beforeLeave;
  var leave = data.leave;
  var afterLeave = data.afterLeave;
  var leaveCancelled = data.leaveCancelled;
  var delayLeave = data.delayLeave;
  var duration = data.duration;

  var expectsCSS = css !== false && !isIE9;
  var userWantsControl = getHookArgumentsLength(leave);

  var explicitLeaveDuration = toNumber(
    isObject(duration)
      ? duration.leave
      : duration
  );

  if (process.env.NODE_ENV !== 'production' && isDef(explicitLeaveDuration)) {
    checkDuration(explicitLeaveDuration, 'leave', vnode);
  }

  var cb = el._leaveCb = once(function () {
    if (el.parentNode && el.parentNode._pending) {
      el.parentNode._pending[vnode.key] = null;
    }
    if (expectsCSS) {
      removeTransitionClass(el, leaveToClass);
      removeTransitionClass(el, leaveActiveClass);
    }
    if (cb.cancelled) {
      if (expectsCSS) {
        removeTransitionClass(el, leaveClass);
      }
      leaveCancelled && leaveCancelled(el);
    } else {
      rm();
      afterLeave && afterLeave(el);
    }
    el._leaveCb = null;
  });

  if (delayLeave) {
    delayLeave(performLeave);
  } else {
    performLeave();
  }

  function performLeave () {
    // the delayed leave may have already been cancelled
    if (cb.cancelled) {
      return
    }
    // record leaving element
    if (!vnode.data.show) {
      (el.parentNode._pending || (el.parentNode._pending = {}))[(vnode.key)] = vnode;
    }
    beforeLeave && beforeLeave(el);
    if (expectsCSS) {
      addTransitionClass(el, leaveClass);
      addTransitionClass(el, leaveActiveClass);
      nextFrame(function () {
        addTransitionClass(el, leaveToClass);
        removeTransitionClass(el, leaveClass);
        if (!cb.cancelled && !userWantsControl) {
          if (isValidDuration(explicitLeaveDuration)) {
            setTimeout(cb, explicitLeaveDuration);
          } else {
            whenTransitionEnds(el, type, cb);
          }
        }
      });
    }
    leave && leave(el, cb);
    if (!expectsCSS && !userWantsControl) {
      cb();
    }
  }
}

// only used in dev mode
function checkDuration (val, name, vnode) {
  if (typeof val !== 'number') {
    warn(
      "<transition> explicit " + name + " duration is not a valid number - " +
      "got " + (JSON.stringify(val)) + ".",
      vnode.context
    );
  } else if (isNaN(val)) {
    warn(
      "<transition> explicit " + name + " duration is NaN - " +
      'the duration expression might be incorrect.',
      vnode.context
    );
  }
}

function isValidDuration (val) {
  return typeof val === 'number' && !isNaN(val)
}

/**
 * Normalize a transition hook's argument length. The hook may be:
 * - a merged hook (invoker) with the original in .fns
 * - a wrapped component method (check ._length)
 * - a plain function (.length)
 */
function getHookArgumentsLength (fn) {
  if (isUndef(fn)) {
    return false
  }
  var invokerFns = fn.fns;
  if (isDef(invokerFns)) {
    // invoker
    return getHookArgumentsLength(
      Array.isArray(invokerFns)
        ? invokerFns[0]
        : invokerFns
    )
  } else {
    return (fn._length || fn.length) > 1
  }
}

function _enter (_, vnode) {
  if (vnode.data.show !== true) {
    enter(vnode);
  }
}

var transition = inBrowser ? {
  create: _enter,
  activate: _enter,
  remove: function remove$$1 (vnode, rm) {
    /* istanbul ignore else */
    if (vnode.data.show !== true) {
      leave(vnode, rm);
    } else {
      rm();
    }
  }
} : {};

var platformModules = [
  attrs,
  klass,
  events,
  domProps,
  style,
  transition
];

/*  */

// the directive module should be applied last, after all
// built-in modules have been applied.
var modules = platformModules.concat(baseModules);

var patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });

/**
 * Not type checking this file because flow doesn't like attaching
 * properties to Elements.
 */

/* istanbul ignore if */
if (isIE9) {
  // http://www.matts411.com/post/internet-explorer-9-oninput/
  document.addEventListener('selectionchange', function () {
    var el = document.activeElement;
    if (el && el.vmodel) {
      trigger(el, 'input');
    }
  });
}

var directive = {
  inserted: function inserted (el, binding, vnode, oldVnode) {
    if (vnode.tag === 'select') {
      // #6903
      if (oldVnode.elm && !oldVnode.elm._vOptions) {
        mergeVNodeHook(vnode, 'postpatch', function () {
          directive.componentUpdated(el, binding, vnode);
        });
      } else {
        setSelected(el, binding, vnode.context);
      }
      el._vOptions = [].map.call(el.options, getValue);
    } else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {
      el._vModifiers = binding.modifiers;
      if (!binding.modifiers.lazy) {
        // Safari < 10.2 & UIWebView doesn't fire compositionend when
        // switching focus before confirming composition choice
        // this also fixes the issue where some browsers e.g. iOS Chrome
        // fires "change" instead of "input" on autocomplete.
        el.addEventListener('change', onCompositionEnd);
        if (!isAndroid) {
          el.addEventListener('compositionstart', onCompositionStart);
          el.addEventListener('compositionend', onCompositionEnd);
        }
        /* istanbul ignore if */
        if (isIE9) {
          el.vmodel = true;
        }
      }
    }
  },

  componentUpdated: function componentUpdated (el, binding, vnode) {
    if (vnode.tag === 'select') {
      setSelected(el, binding, vnode.context);
      // in case the options rendered by v-for have changed,
      // it's possible that the value is out-of-sync with the rendered options.
      // detect such cases and filter out values that no longer has a matching
      // option in the DOM.
      var prevOptions = el._vOptions;
      var curOptions = el._vOptions = [].map.call(el.options, getValue);
      if (curOptions.some(function (o, i) { return !looseEqual(o, prevOptions[i]); })) {
        // trigger change event if
        // no matching option found for at least one value
        var needReset = el.multiple
          ? binding.value.some(function (v) { return hasNoMatchingOption(v, curOptions); })
          : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, curOptions);
        if (needReset) {
          trigger(el, 'change');
        }
      }
    }
  }
};

function setSelected (el, binding, vm) {
  actuallySetSelected(el, binding, vm);
  /* istanbul ignore if */
  if (isIE || isEdge) {
    setTimeout(function () {
      actuallySetSelected(el, binding, vm);
    }, 0);
  }
}

function actuallySetSelected (el, binding, vm) {
  var value = binding.value;
  var isMultiple = el.multiple;
  if (isMultiple && !Array.isArray(value)) {
    process.env.NODE_ENV !== 'production' && warn(
      "<select multiple v-model=\"" + (binding.expression) + "\"> " +
      "expects an Array value for its binding, but got " + (Object.prototype.toString.call(value).slice(8, -1)),
      vm
    );
    return
  }
  var selected, option;
  for (var i = 0, l = el.options.length; i < l; i++) {
    option = el.options[i];
    if (isMultiple) {
      selected = looseIndexOf(value, getValue(option)) > -1;
      if (option.selected !== selected) {
        option.selected = selected;
      }
    } else {
      if (looseEqual(getValue(option), value)) {
        if (el.selectedIndex !== i) {
          el.selectedIndex = i;
        }
        return
      }
    }
  }
  if (!isMultiple) {
    el.selectedIndex = -1;
  }
}

function hasNoMatchingOption (value, options) {
  return options.every(function (o) { return !looseEqual(o, value); })
}

function getValue (option) {
  return '_value' in option
    ? option._value
    : option.value
}

function onCompositionStart (e) {
  e.target.composing = true;
}

function onCompositionEnd (e) {
  // prevent triggering an input event for no reason
  if (!e.target.composing) { return }
  e.target.composing = false;
  trigger(e.target, 'input');
}

function trigger (el, type) {
  var e = document.createEvent('HTMLEvents');
  e.initEvent(type, true, true);
  el.dispatchEvent(e);
}

/*  */

// recursively search for possible transition defined inside the component root
function locateNode (vnode) {
  return vnode.componentInstance && (!vnode.data || !vnode.data.transition)
    ? locateNode(vnode.componentInstance._vnode)
    : vnode
}

var show = {
  bind: function bind (el, ref, vnode) {
    var value = ref.value;

    vnode = locateNode(vnode);
    var transition$$1 = vnode.data && vnode.data.transition;
    var originalDisplay = el.__vOriginalDisplay =
      el.style.display === 'none' ? '' : el.style.display;
    if (value && transition$$1) {
      vnode.data.show = true;
      enter(vnode, function () {
        el.style.display = originalDisplay;
      });
    } else {
      el.style.display = value ? originalDisplay : 'none';
    }
  },

  update: function update (el, ref, vnode) {
    var value = ref.value;
    var oldValue = ref.oldValue;

    /* istanbul ignore if */
    if (value === oldValue) { return }
    vnode = locateNode(vnode);
    var transition$$1 = vnode.data && vnode.data.transition;
    if (transition$$1) {
      vnode.data.show = true;
      if (value) {
        enter(vnode, function () {
          el.style.display = el.__vOriginalDisplay;
        });
      } else {
        leave(vnode, function () {
          el.style.display = 'none';
        });
      }
    } else {
      el.style.display = value ? el.__vOriginalDisplay : 'none';
    }
  },

  unbind: function unbind (
    el,
    binding,
    vnode,
    oldVnode,
    isDestroy
  ) {
    if (!isDestroy) {
      el.style.display = el.__vOriginalDisplay;
    }
  }
};

var platformDirectives = {
  model: directive,
  show: show
};

/*  */

// Provides transition support for a single element/component.
// supports transition mode (out-in / in-out)

var transitionProps = {
  name: String,
  appear: Boolean,
  css: Boolean,
  mode: String,
  type: String,
  enterClass: String,
  leaveClass: String,
  enterToClass: String,
  leaveToClass: String,
  enterActiveClass: String,
  leaveActiveClass: String,
  appearClass: String,
  appearActiveClass: String,
  appearToClass: String,
  duration: [Number, String, Object]
};

// in case the child is also an abstract component, e.g. <keep-alive>
// we want to recursively retrieve the real component to be rendered
function getRealChild (vnode) {
  var compOptions = vnode && vnode.componentOptions;
  if (compOptions && compOptions.Ctor.options.abstract) {
    return getRealChild(getFirstComponentChild(compOptions.children))
  } else {
    return vnode
  }
}

function extractTransitionData (comp) {
  var data = {};
  var options = comp.$options;
  // props
  for (var key in options.propsData) {
    data[key] = comp[key];
  }
  // events.
  // extract listeners and pass them directly to the transition methods
  var listeners = options._parentListeners;
  for (var key$1 in listeners) {
    data[camelize(key$1)] = listeners[key$1];
  }
  return data
}

function placeholder (h, rawChild) {
  if (/\d-keep-alive$/.test(rawChild.tag)) {
    return h('keep-alive', {
      props: rawChild.componentOptions.propsData
    })
  }
}

function hasParentTransition (vnode) {
  while ((vnode = vnode.parent)) {
    if (vnode.data.transition) {
      return true
    }
  }
}

function isSameChild (child, oldChild) {
  return oldChild.key === child.key && oldChild.tag === child.tag
}

var Transition = {
  name: 'transition',
  props: transitionProps,
  abstract: true,

  render: function render (h) {
    var this$1 = this;

    var children = this.$slots.default;
    if (!children) {
      return
    }

    // filter out text nodes (possible whitespaces)
    children = children.filter(function (c) { return c.tag || isAsyncPlaceholder(c); });
    /* istanbul ignore if */
    if (!children.length) {
      return
    }

    // warn multiple elements
    if (process.env.NODE_ENV !== 'production' && children.length > 1) {
      warn(
        '<transition> can only be used on a single element. Use ' +
        '<transition-group> for lists.',
        this.$parent
      );
    }

    var mode = this.mode;

    // warn invalid mode
    if (process.env.NODE_ENV !== 'production' &&
      mode && mode !== 'in-out' && mode !== 'out-in'
    ) {
      warn(
        'invalid <transition> mode: ' + mode,
        this.$parent
      );
    }

    var rawChild = children[0];

    // if this is a component root node and the component's
    // parent container node also has transition, skip.
    if (hasParentTransition(this.$vnode)) {
      return rawChild
    }

    // apply transition data to child
    // use getRealChild() to ignore abstract components e.g. keep-alive
    var child = getRealChild(rawChild);
    /* istanbul ignore if */
    if (!child) {
      return rawChild
    }

    if (this._leaving) {
      return placeholder(h, rawChild)
    }

    // ensure a key that is unique to the vnode type and to this transition
    // component instance. This key will be used to remove pending leaving nodes
    // during entering.
    var id = "__transition-" + (this._uid) + "-";
    child.key = child.key == null
      ? child.isComment
        ? id + 'comment'
        : id + child.tag
      : isPrimitive(child.key)
        ? (String(child.key).indexOf(id) === 0 ? child.key : id + child.key)
        : child.key;

    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);
    var oldRawChild = this._vnode;
    var oldChild = getRealChild(oldRawChild);

    // mark v-show
    // so that the transition module can hand over the control to the directive
    if (child.data.directives && child.data.directives.some(function (d) { return d.name === 'show'; })) {
      child.data.show = true;
    }

    if (
      oldChild &&
      oldChild.data &&
      !isSameChild(child, oldChild) &&
      !isAsyncPlaceholder(oldChild) &&
      // #6687 component root is a comment node
      !(oldChild.componentInstance && oldChild.componentInstance._vnode.isComment)
    ) {
      // replace old child transition data with fresh one
      // important for dynamic transitions!
      var oldData = oldChild.data.transition = extend({}, data);
      // handle transition mode
      if (mode === 'out-in') {
        // return placeholder node and queue update when leave finishes
        this._leaving = true;
        mergeVNodeHook(oldData, 'afterLeave', function () {
          this$1._leaving = false;
          this$1.$forceUpdate();
        });
        return placeholder(h, rawChild)
      } else if (mode === 'in-out') {
        if (isAsyncPlaceholder(child)) {
          return oldRawChild
        }
        var delayedLeave;
        var performLeave = function () { delayedLeave(); };
        mergeVNodeHook(data, 'afterEnter', performLeave);
        mergeVNodeHook(data, 'enterCancelled', performLeave);
        mergeVNodeHook(oldData, 'delayLeave', function (leave) { delayedLeave = leave; });
      }
    }

    return rawChild
  }
};

/*  */

// Provides transition support for list items.
// supports move transitions using the FLIP technique.

// Because the vdom's children update algorithm is "unstable" - i.e.
// it doesn't guarantee the relative positioning of removed elements,
// we force transition-group to update its children into two passes:
// in the first pass, we remove all nodes that need to be removed,
// triggering their leaving transition; in the second pass, we insert/move
// into the final desired state. This way in the second pass removed
// nodes will remain where they should be.

var props = extend({
  tag: String,
  moveClass: String
}, transitionProps);

delete props.mode;

var TransitionGroup = {
  props: props,

  render: function render (h) {
    var tag = this.tag || this.$vnode.data.tag || 'span';
    var map = Object.create(null);
    var prevChildren = this.prevChildren = this.children;
    var rawChildren = this.$slots.default || [];
    var children = this.children = [];
    var transitionData = extractTransitionData(this);

    for (var i = 0; i < rawChildren.length; i++) {
      var c = rawChildren[i];
      if (c.tag) {
        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {
          children.push(c);
          map[c.key] = c
          ;(c.data || (c.data = {})).transition = transitionData;
        } else if (process.env.NODE_ENV !== 'production') {
          var opts = c.componentOptions;
          var name = opts ? (opts.Ctor.options.name || opts.tag || '') : c.tag;
          warn(("<transition-group> children must be keyed: <" + name + ">"));
        }
      }
    }

    if (prevChildren) {
      var kept = [];
      var removed = [];
      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {
        var c$1 = prevChildren[i$1];
        c$1.data.transition = transitionData;
        c$1.data.pos = c$1.elm.getBoundingClientRect();
        if (map[c$1.key]) {
          kept.push(c$1);
        } else {
          removed.push(c$1);
        }
      }
      this.kept = h(tag, null, kept);
      this.removed = removed;
    }

    return h(tag, null, children)
  },

  beforeUpdate: function beforeUpdate () {
    // force removing pass
    this.__patch__(
      this._vnode,
      this.kept,
      false, // hydrating
      true // removeOnly (!important avoids unnecessary moves)
    );
    this._vnode = this.kept;
  },

  updated: function updated () {
    var children = this.prevChildren;
    var moveClass = this.moveClass || ((this.name || 'v') + '-move');
    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {
      return
    }

    // we divide the work into three loops to avoid mixing DOM reads and writes
    // in each iteration - which helps prevent layout thrashing.
    children.forEach(callPendingCbs);
    children.forEach(recordPosition);
    children.forEach(applyTranslation);

    // force reflow to put everything in position
    // assign to this to avoid being removed in tree-shaking
    // $flow-disable-line
    this._reflow = document.body.offsetHeight;

    children.forEach(function (c) {
      if (c.data.moved) {
        var el = c.elm;
        var s = el.style;
        addTransitionClass(el, moveClass);
        s.transform = s.WebkitTransform = s.transitionDuration = '';
        el.addEventListener(transitionEndEvent, el._moveCb = function cb (e) {
          if (!e || /transform$/.test(e.propertyName)) {
            el.removeEventListener(transitionEndEvent, cb);
            el._moveCb = null;
            removeTransitionClass(el, moveClass);
          }
        });
      }
    });
  },

  methods: {
    hasMove: function hasMove (el, moveClass) {
      /* istanbul ignore if */
      if (!hasTransition) {
        return false
      }
      /* istanbul ignore if */
      if (this._hasMove) {
        return this._hasMove
      }
      // Detect whether an element with the move class applied has
      // CSS transitions. Since the element may be inside an entering
      // transition at this very moment, we make a clone of it and remove
      // all other transition classes applied to ensure only the move class
      // is applied.
      var clone = el.cloneNode();
      if (el._transitionClasses) {
        el._transitionClasses.forEach(function (cls) { removeClass(clone, cls); });
      }
      addClass(clone, moveClass);
      clone.style.display = 'none';
      this.$el.appendChild(clone);
      var info = getTransitionInfo(clone);
      this.$el.removeChild(clone);
      return (this._hasMove = info.hasTransform)
    }
  }
};

function callPendingCbs (c) {
  /* istanbul ignore if */
  if (c.elm._moveCb) {
    c.elm._moveCb();
  }
  /* istanbul ignore if */
  if (c.elm._enterCb) {
    c.elm._enterCb();
  }
}

function recordPosition (c) {
  c.data.newPos = c.elm.getBoundingClientRect();
}

function applyTranslation (c) {
  var oldPos = c.data.pos;
  var newPos = c.data.newPos;
  var dx = oldPos.left - newPos.left;
  var dy = oldPos.top - newPos.top;
  if (dx || dy) {
    c.data.moved = true;
    var s = c.elm.style;
    s.transform = s.WebkitTransform = "translate(" + dx + "px," + dy + "px)";
    s.transitionDuration = '0s';
  }
}

var platformComponents = {
  Transition: Transition,
  TransitionGroup: TransitionGroup
};

/*  */

// install platform specific utils
Vue$3.config.mustUseProp = mustUseProp;
Vue$3.config.isReservedTag = isReservedTag;
Vue$3.config.isReservedAttr = isReservedAttr;
Vue$3.config.getTagNamespace = getTagNamespace;
Vue$3.config.isUnknownElement = isUnknownElement;

// install platform runtime directives & components
extend(Vue$3.options.directives, platformDirectives);
extend(Vue$3.options.components, platformComponents);

// install platform patch function
Vue$3.prototype.__patch__ = inBrowser ? patch : noop;

// public mount method
Vue$3.prototype.$mount = function (
  el,
  hydrating
) {
  el = el && inBrowser ? query(el) : undefined;
  return mountComponent(this, el, hydrating)
};

// devtools global hook
/* istanbul ignore next */
Vue$3.nextTick(function () {
  if (config.devtools) {
    if (devtools) {
      devtools.emit('init', Vue$3);
    } else if (process.env.NODE_ENV !== 'production' && isChrome) {
      console[console.info ? 'info' : 'log'](
        'Download the Vue Devtools extension for a better development experience:\n' +
        'https://github.com/vuejs/vue-devtools'
      );
    }
  }
  if (process.env.NODE_ENV !== 'production' &&
    config.productionTip !== false &&
    inBrowser && typeof console !== 'undefined'
  ) {
    console[console.info ? 'info' : 'log'](
      "You are running Vue in development mode.\n" +
      "Make sure to turn on production mode when deploying for production.\n" +
      "See more tips at https://vuejs.org/guide/deployment.html"
    );
  }
}, 0);

/*  */

module.exports = Vue$3;

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"_process":386}],391:[function(require,module,exports){
(function (process){
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

'use strict';

/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var warning = function() {};

if (process.env.NODE_ENV !== 'production') {
  warning = function(condition, format, args) {
    var len = arguments.length;
    args = new Array(len > 2 ? len - 2 : 0);
    for (var key = 2; key < len; key++) {
      args[key - 2] = arguments[key];
    }
    if (format === undefined) {
      throw new Error(
        '`warning(condition, format, ...args)` requires a warning ' +
        'message argument'
      );
    }

    if (format.length < 10 || (/^[s\W]*$/).test(format)) {
      throw new Error(
        'The warning format should be able to uniquely identify this ' +
        'warning. Please, use a more descriptive format than: ' + format
      );
    }

    if (!condition) {
      var argIndex = 0;
      var message = 'Warning: ' +
        format.replace(/%s/g, function() {
          return args[argIndex++];
        });
      if (typeof console !== 'undefined') {
        console.error(message);
      }
      try {
        // This error was thrown as a convenience so that you can use this stack
        // to find the callsite that caused this warning to fire.
        throw new Error(message);
      } catch(x) {}
    }
  };
}

module.exports = warning;

}).call(this,require('_process'))

},{"_process":386}],392:[function(require,module,exports){
module.exports={
  "name": "@kynikos/wiki-monkey",
  "version": "4.1.0",
  "author": "Dario Giovannetti",
  "description": "MediaWiki bot and editor-assistant user script.",
  "license": "GPL-3.0",
  "repository": {
    "type": "git",
    "url": "https://github.com/kynikos/wiki-monkey.git"
  },
  "keywords": [
    "wiki mediawiki bot"
  ],
  "dependencies": {
    "@kynikos/misc": "^0.1.3",
    "babel-polyfill": "^6.26.0",
    "hyperscript": "^2.0.2",
    "hyperscript-helpers": "^3.0.3",
    "jss": "^9.5.1",
    "jss-preset-default": "^4.1.0",
    "moment": "^2.20.1",
    "vue": "^2.5.13"
  },
  "devDependencies": {
    "@kynikos/browserify-helpers": "^1.0.8",
    "babel-core": "^6.26.0",
    "babel-preset-env": "^1.6.1",
    "coffeelint": "^2.0.7",
    "coffeescript": "^2.1.1",
    "http-server": "^0.11.1"
  }
}

},{}],393:[function(require,module,exports){
"use strict";

var WikiMonkey;

var _require = require('./modules');

WikiMonkey = _require.WikiMonkey;

new WikiMonkey("ArchWiki", require("./plugins/ArchWikiFixHeader"), require("./plugins/ArchWikiFixHeadings"), require("./plugins/ArchWikiFixLinks"), require("./plugins/ArchWikiNewTemplates"), require("./plugins/ArchWikiNPFilter"), require("./plugins/ArchWikiRCFilter"), require("./plugins/ArchWikiSaveTalk"), require("./plugins/ArchWikiSortContacts"), require("./plugins/ArchWikiWantedCategories"), require("./plugins/DeletePages"), require("./plugins/ExpandContractions"), require("./plugins/FixBacklinkFragments"), require("./plugins/FixDoubleRedirects"), require("./plugins/FixFragments"), require("./plugins/FixLinkFragments"), require("./plugins/MultipleLineBreaks"), require("./plugins/SimpleReplace"), require("./plugins/SynchronizeInterlanguageLinks"), require("./plugins/UpdateCategoryTree"));

},{"./modules":411,"./plugins/ArchWikiFixHeader":413,"./plugins/ArchWikiFixHeadings":414,"./plugins/ArchWikiFixLinks":415,"./plugins/ArchWikiNPFilter":416,"./plugins/ArchWikiNewTemplates":417,"./plugins/ArchWikiRCFilter":418,"./plugins/ArchWikiSaveTalk":419,"./plugins/ArchWikiSortContacts":420,"./plugins/ArchWikiWantedCategories":421,"./plugins/DeletePages":422,"./plugins/ExpandContractions":423,"./plugins/FixBacklinkFragments":424,"./plugins/FixDoubleRedirects":425,"./plugins/FixFragments":426,"./plugins/FixLinkFragments":427,"./plugins/MultipleLineBreaks":428,"./plugins/SimpleReplace":429,"./plugins/SynchronizeInterlanguageLinks":430,"./plugins/UpdateCategoryTree":431}],394:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var App, WM, jssc;

var _require = require('../modules/libs');

jssc = _require.jssc;


WM = require('../modules');

App = require('./index');

module.exports = function () {
  function exports(WM1, functions, lists) {
    _classCallCheck(this, exports);

    var classes, divContainer, fdiv;
    this._previewFilter = this._previewFilter.bind(this);
    this._startAutomatic = this._startAutomatic.bind(this);
    this._startAutomaticContinue = this._startAutomaticContinue.bind(this);
    this.WM = WM1;
    this.configuration = {
      plugin_name: null,
      function_: function function_() {},
      filters: [],
      list: {
        current: null,
        previous: null
      },
      visited: []
    };

    this.botToken = "0";
    divContainer = document.createElement('div');
    divContainer.id = 'WikiMonkeyBot';

    var _jssc = jssc({
      pluginSelect: {
        width: '100%',
        marginBottom: '1em'
      },
      listSelect: {
        marginBottom: '1em'
      },
      botFilter: {
        height: '6em',
        marginBottom: '1em',
        resize: 'vertical'
      },
      botStartStop: {
        marginRight: '0.33em',
        marginBottom: '1em',
        fontWeight: 'bold'
      },
      botSelected: {
        backgroundColor: '#faa',
        padding: '0.2em 0.4em'
      },
      botProcessing: {
        backgroundColor: '#ff8',
        padding: '0.2em 0.4em'
      },
      botChanged: {
        backgroundColor: '#afa',
        padding: '0.2em 0.4em'
      },
      botUnchanged: {
        backgroundColor: '#aaf',
        padding: '0.2em 0.4em'
      },
      botBypassed: {
        backgroundColor: 'orangered',
        padding: '0.2em 0.4em'
      },
      botFailed: {
        backgroundColor: 'red',
        padding: '0.2em 0.4em'
      }
    });

    classes = _jssc.classes;

    this.classes = classes;
    fdiv = this.makeFunctionUI(functions);
    if (fdiv) {
      divContainer.appendChild(fdiv);
      divContainer.appendChild(this.makeConfUI(lists));
      return divContainer;
    } else {
      return false;
    }
  }

  _createClass(exports, [{
    key: 'makeFunctionUI',
    value: function makeFunctionUI(functions) {
      var Plugin, divFunction, ffunctions, fieldset, i, legend, len, makeUI, option, plugin, pluginInst, selectFunctions, self;
      self = this;
      fieldset = document.createElement('fieldset');
      legend = document.createElement('legend');
      legend.innerHTML = 'Plugin';
      selectFunctions = document.createElement('select');
      selectFunctions.id = 'WikiMonkeyBot-PluginSelect';
      selectFunctions.className = this.classes.pluginSelect;
      ffunctions = [];
      for (i = 0, len = functions.length; i < len; i++) {
        Plugin = functions[i];
        plugin = new Plugin(this.WM);
        pluginInst = plugin.conf.bot_label;

        if (!pluginInst || !pluginInst.length) {
          continue;
        }
        ffunctions.push(plugin);
        option = document.createElement('option');
        option.innerHTML = pluginInst;
        if (plugin.constructor.name === WM.conf.default_bot_plugin) {
          option.selected = true;
        }
        selectFunctions.appendChild(option);
      }
      if (ffunctions.length) {
        selectFunctions.addEventListener("change", function (ffunctions) {
          return function () {
            var UI, id, makeUI, select;
            select = document.getElementById('WikiMonkeyBot-PluginSelect');
            id = select.selectedIndex;
            UI = document.getElementById('WikiMonkeyBotFunction');
            plugin = ffunctions[id];

            makeUI = plugin.makeBotUI;
            if (makeUI instanceof Function) {
              UI.replaceChild(makeUI(), UI.firstChild);
            } else {
              UI.replaceChild(document.createElement('div'), UI.firstChild);
            }
            self.configuration.plugin_name = plugin.constructor.name;
            return self.configuration.function_ = function (title, callContinue, chainArgs) {
              return plugin.main_bot(title, callContinue, chainArgs);
            };
          };
        }(ffunctions), false);
        divFunction = document.createElement('div');
        divFunction.id = "WikiMonkeyBotFunction";
        plugin = ffunctions[selectFunctions.selectedIndex];

        makeUI = plugin.makeBotUI;
        if (makeUI instanceof Function) {
          divFunction.appendChild(makeUI());
        } else {
          divFunction.appendChild(document.createElement('div'));
        }
        this.configuration.plugin_name = plugin.constructor.name;
        this.configuration.function_ = function (title, callContinue, chainArgs) {
          return plugin.main_bot(title, callContinue, chainArgs);
        };
        fieldset.appendChild(legend);
        fieldset.appendChild(selectFunctions);
        fieldset.appendChild(divFunction);
        return fieldset;
      } else {
        return false;
      }
    }
  }, {
    key: 'makeListSelector',
    value: function makeListSelector(lists) {
      var i, len, list, option, selectLists, self;
      self = this;
      selectLists = document.createElement('select');
      selectLists.id = 'WikiMonkeyBot-ListSelect';
      selectLists.className = this.classes.listSelect;
      for (i = 0, len = lists.length; i < len; i++) {
        list = lists[i];
        if (list[0]) {
          option = document.createElement('option');
          option.innerHTML = list[2];
          selectLists.appendChild(option);
          if (!this.configuration.list.current) {
            this.configuration.list.current = list;
          }
        }
      }
      selectLists.addEventListener("change", function (lss) {
        return function () {
          var id, select;
          select = document.getElementById('WikiMonkeyBot-ListSelect');
          id = select.selectedIndex;
          self.configuration.list.previous = self.configuration.list.current;

          return self.configuration.list.current = lss[id];
        };
      }(lists), false);
      return selectLists;
    }
  }, {
    key: 'makeConfUI',
    value: function makeConfUI(lists) {
      var bot, duplicates, duplicatestag, elem, elems, fieldset, filter, forceStart, forceStartCB, forceStartLabel, i, inverse, inversetag, legend, len, listSelect, preview, self, start, startMsg;
      self = this;
      bot = document.createElement('div');
      fieldset = document.createElement('fieldset');
      legend = document.createElement('legend');
      legend.innerHTML = 'Filter';
      listSelect = this.makeListSelector(lists);
      filter = document.createElement('textarea');
      filter.id = 'WikiMonkeyBotFilter';
      filter.className = this.classes.botFilter;
      preview = document.createElement('input');
      preview.id = 'WikiMonkeyBotPreview';
      preview.type = 'button';
      preview.value = 'Preview';
      duplicates = document.createElement('input');
      duplicates.type = 'checkbox';
      duplicates.id = 'WikiMonkeyBotDuplicates';
      inverse = document.createElement('input');
      inverse.type = 'checkbox';
      inverse.id = 'WikiMonkeyBotInverse';
      elems = [filter, duplicates, inverse];
      for (i = 0, len = elems.length; i < len; i++) {
        elem = elems[i];
        elem.addEventListener("change", function () {
          return self._disableStartBot('Filters have changed, preview the selection');
        }, false);
      }
      duplicatestag = document.createElement('span');
      duplicatestag.innerHTML = 'Duplicates';
      inversetag = document.createElement('span');
      inversetag.innerHTML = 'Inverse';
      preview.addEventListener("click", this._previewFilter, false);
      fieldset.appendChild(legend);
      if (listSelect.length > 1) {
        fieldset.appendChild(listSelect);
      }
      fieldset.appendChild(filter);
      fieldset.appendChild(preview);
      fieldset.appendChild(duplicates);
      fieldset.appendChild(duplicatestag);
      fieldset.appendChild(inverse);
      fieldset.appendChild(inversetag);
      start = document.createElement('input');
      start.type = 'button';
      start.value = 'Start bot';
      start.id = 'WikiMonkeyBotStart';
      start.className = this.classes.botStartStop;
      start.addEventListener("click", this._startAutomatic, false);
      start.disabled = true;
      startMsg = document.createElement('span');
      startMsg.innerHTML = 'Set and preview the filter first';
      startMsg.id = 'WikiMonkeyBotStartMsg';
      forceStart = document.createElement('span');
      forceStart.id = 'WikiMonkeyBotForceStart';
      forceStartCB = document.createElement('input');
      forceStartCB.type = 'checkbox';
      forceStartCB.disabled = true;
      forceStartLabel = document.createElement('span');
      forceStartLabel.innerHTML = 'Force start, stopping any other currently running bots';
      forceStart.style.display = "none";
      forceStart.appendChild(forceStartCB);
      forceStart.appendChild(forceStartLabel);
      bot.appendChild(fieldset);
      bot.appendChild(start);
      bot.appendChild(startMsg);
      bot.appendChild(forceStart);
      return bot;
    }
  }, {
    key: '_enableStartBot',
    value: function _enableStartBot() {
      document.getElementById('WikiMonkeyBotStartMsg').innerHTML = '';
      return document.getElementById('WikiMonkeyBotStart').disabled = false;
    }
  }, {
    key: '_disableStartBot',
    value: function _disableStartBot(message) {
      document.getElementById('WikiMonkeyBotStartMsg').innerHTML = message;
      return document.getElementById('WikiMonkeyBotStart').disabled = true;
    }
  }, {
    key: '_enableStopBot',
    value: function _enableStopBot(stopId) {
      var self, start, stop;
      self = this;
      stop = document.createElement('input');
      stop.type = 'button';
      stop.value = 'Stop bot';
      stop.id = 'WikiMonkeyBotStop';
      stop.className = this.classes.botStartStop;
      stop.addEventListener("click", function (id) {
        return function () {
          clearTimeout(id);

          self._disableStopBot();
          self._endAutomatic(true);
          return App.log.logInfo('Bot stopped manually');
        };
      }(stopId), false);
      start = document.getElementById('WikiMonkeyBotStart');
      start.parentNode.insertBefore(stop, start);
      return start.style.display = 'none';
    }
  }, {
    key: '_disableStopBot',
    value: function _disableStopBot() {
      var stop;
      stop = document.getElementById('WikiMonkeyBotStop');
      stop.parentNode.removeChild(stop);
      return document.getElementById('WikiMonkeyBotStart').style.display = 'inline';
    }
  }, {
    key: '_disableControls',
    value: function _disableControls() {
      return this._setEnableControls(true);
    }
  }, {
    key: '_reEnableControls',
    value: function _reEnableControls() {
      return this._setEnableControls(false);
    }
  }, {
    key: '_setEnableControls',
    value: function _setEnableControls(flag) {
      var fset, fsets, i, len, results;
      fsets = document.getElementById('WikiMonkeyBot').getElementsByTagName('fieldset');
      results = [];
      for (i = 0, len = fsets.length; i < len; i++) {
        fset = fsets[i];

        results.push(fset.disabled = flag);
      }
      return results;
    }
  }, {
    key: '_enableForceStart',
    value: function _enableForceStart() {
      var force;
      force = document.getElementById('WikiMonkeyBotForceStart');
      force.getElementsByTagName('input')[0].disabled = false;
      return force.style.display = 'inline';
    }
  }, {
    key: '_disableForceStart',
    value: function _disableForceStart() {
      var force;
      force = document.getElementById('WikiMonkeyBotForceStart');
      force.getElementsByTagName('input')[0].checked = false;
      force.getElementsByTagName('input')[0].disabled = true;
      return force.style.display = 'none';
    }
  }, {
    key: '_canForceStart',
    value: function _canForceStart() {
      return document.getElementById('WikiMonkeyBotForceStart').getElementsByTagName('input')[0].checked;
    }
  }, {
    key: 'makeFilters',
    value: function makeFilters() {
      var exc, filter, filters, firstSlash, i, lastSlash, len, modifiers, negative, pattern, regexp;
      this.configuration.filters = [];
      filters = document.getElementById('WikiMonkeyBotFilter').value.split('\n');
      for (i = 0, len = filters.length; i < len; i++) {
        filter = filters[i];

        if (filter) {
          firstSlash = filter.indexOf('/');
          lastSlash = filter.lastIndexOf('/');
          pattern = filter.substring(firstSlash + 1, lastSlash);
          modifiers = filter.substring(lastSlash + 1);
          negative = filter.charAt(0) === '!';
          try {
            regexp = new RegExp(pattern, modifiers);
          } catch (error) {
            exc = error;
            App.log.logError('Invalid regexp: ' + exc);
            return false;
          }
          this.configuration.filters.push([regexp, negative]);
        }
      }

      return true;
    }
  }, {
    key: 'canProcessPage',
    value: function canProcessPage(link) {
      var duplicates, filter, filters, i, inverse, len, negative, regexp, test, title;

      if (link.className.split(" ").indexOf("new") < 0) {
        title = link.innerHTML;
        duplicates = document.getElementById('WikiMonkeyBotDuplicates').checked;
        if (duplicates || this.configuration.visited.indexOf(title) < 0) {
          this.configuration.visited.push(title);
          filters = this.configuration.filters;
          inverse = document.getElementById('WikiMonkeyBotInverse').checked;
          if (filters.length > 0) {
            for (i = 0, len = filters.length; i < len; i++) {
              filter = filters[i];
              regexp = filter[0];
              negative = filter[1];
              test = regexp.test(title);
              if (test !== negative) {
                if (inverse) {
                  return false;
                } else {
                  return true;
                }
              }
            }

            if (inverse) {
              return true;
            } else {
              return false;
            }
          } else {
            if (inverse) {
              return false;
            } else {
              return true;
            }
          }
        } else {
          return false;
        }
      } else {
        return false;
      }
    }
  }, {
    key: 'changeWikiMonkeyLinkClassName',
    value: function changeWikiMonkeyLinkClassName(className, newClass) {
      var classes, cls, i, len, newClasses;
      classes = className.split(" ");
      newClasses = [];
      for (i = 0, len = classes.length; i < len; i++) {
        cls = classes[i];
        if (cls.indexOf("WikiMonkey") < 0) {
          newClasses.push(cls);
        }
      }

      newClasses.push(newClass);
      return newClasses.join(" ");
    }
  }, {
    key: 'restoreOriginalLinkClassName',
    value: function restoreOriginalLinkClassName(className) {
      var classes, cls, i, len, origClasses;
      classes = className.split(" ");
      origClasses = [];
      for (i = 0, len = classes.length; i < len; i++) {
        cls = classes[i];
        if (cls.indexOf("WikiMonkey") < 0) {
          origClasses.push(cls);
        }
      }
      return origClasses.join(" ");
    }
  }, {
    key: '_previewFilter',
    value: function _previewFilter() {
      var N, enable, i, item, items, j, len, len1, link, linkId;
      App.log.logInfo('Updating filter preview, please wait ...');
      this._disableStartBot('Updating filter preview ...');
      if (this.configuration.list.previous) {
        if (this.configuration.list.current[0].nodeName === 'TBODY') {
          items = this.configuration.list.previous[0].getElementsByTagName('td');
        } else {
          items = this.configuration.list.previous[0].getElementsByTagName('li');
        }
        linkId = this.configuration.list.previous[1];
        for (i = 0, len = items.length; i < len; i++) {
          item = items[i];
          link = item.getElementsByTagName('a')[linkId];

          if (link) {
            link.className = this.restoreOriginalLinkClassName(link.className);
          }
        }
      }
      this.configuration.visited = [];
      linkId = this.configuration.list.current[1];
      enable = false;
      N = 0;
      if (this.makeFilters()) {
        if (this.configuration.list.current[0].nodeName === 'TBODY') {
          items = this.configuration.list.current[0].getElementsByTagName('td');
        } else {
          items = this.configuration.list.current[0].getElementsByTagName('li');
        }
        for (j = 0, len1 = items.length; j < len1; j++) {
          item = items[j];
          link = item.getElementsByTagName('a')[linkId];

          if (link) {
            if (this.canProcessPage(link)) {
              link.className = this.changeWikiMonkeyLinkClassName(link.className, this.classes.botSelected);
              enable = true;
              N++;
            } else {
              link.className = this.restoreOriginalLinkClassName(link.className);
            }
          }
        }
      }
      App.log.logInfo('Preview updated (' + N + ' pages selected)');
      if (enable) {
        return this._enableStartBot();
      } else {
        return this._disableStartBot('No pages selected, reset and preview the filter');
      }
    }
  }, {
    key: '_setBotToken',
    value: function _setBotToken() {
      var date, token;
      date = new Date();
      token = date.getTime() + "";
      this.botToken = token;
      return localStorage.setItem('WikiMonkeyBotToken', token);
    }
  }, {
    key: '_resetBotToken',
    value: function _resetBotToken(reset) {
      this.botToken = "0";
      if (reset) {
        return localStorage.setItem('WikiMonkeyBotToken', "0");
      }
    }
  }, {
    key: '_getBotToken',
    value: function _getBotToken() {
      return this.botToken;
    }
  }, {
    key: '_checkOtherBotsRunning',
    value: function _checkOtherBotsRunning() {
      var value;
      value = localStorage.getItem('WikiMonkeyBotToken');

      return value && value !== "0" && value !== this._getBotToken();
    }
  }, {
    key: '_startAutomatic',
    value: function _startAutomatic() {
      var i, item, items, itemsDOM, len, linkId;
      if (this._checkOtherBotsRunning() && !this._canForceStart()) {
        App.log.logError("It's not possible to start the bot (without forcing it) for one of the following reasons:<br> * another bot instance is currently running<br> * a previously running bot has stopped due to a page processing error<br> * a previously running bot has stopped due to a Javascript error<br> * a previously running bot has been interrupted by a browser page refresh");
        return this._enableForceStart();
      } else if (this.makeFilters()) {
        if (this.configuration.list.current[0].nodeName === 'TBODY') {
          itemsDOM = this.configuration.list.current[0].getElementsByTagName('td');
        } else {
          itemsDOM = this.configuration.list.current[0].getElementsByTagName('li');
        }

        items = [];
        for (i = 0, len = itemsDOM.length; i < len; i++) {
          item = itemsDOM[i];
          items.push(item);
        }
        linkId = this.configuration.list.current[1];
        this._disableForceStart();
        this._setBotToken();
        App.log.logInfo('Starting bot ...');
        App.log.logHidden("Plugin: " + this.configuration.plugin_name);
        App.log.logHidden("Filter: " + document.getElementById('WikiMonkeyBotFilter').value);
        this._disableStartBot('Bot is running ...');
        this._disableControls();
        this.configuration.visited = [];
        return this.WM.MW.isUserBot(this._startAutomaticContinue, [items, linkId]);
      }
    }
  }, {
    key: '_startAutomaticContinue',
    value: function _startAutomaticContinue(botTest, args) {
      var items, linkId;
      items = args[0];
      linkId = args[1];
      this.configuration.interval = botTest ? 3000 : 30000;
      return this._processItem(0, items, 0, linkId, null);
    }
  }, {
    key: 'makeCallContinue',
    value: function makeCallContinue(lis, id, linkId, ln, article) {
      var self;
      self = this;
      return function (status, resArgs) {
        switch (status) {
          case 0:
            ln.className = self.changeWikiMonkeyLinkClassName(ln.className, this.classes.botUnchanged);
            App.log.logInfo(App.log.linkToWikiPage(article, article) + " processed (unchanged)");
            id++;
            self._processItem(status, lis, id, linkId, resArgs);
            break;

          case 1:
            ln.className = self.changeWikiMonkeyLinkClassName(ln.className, this.classes.botChanged);
            App.log.logInfo(App.log.linkToWikiPage(article, article) + " processed (changed)");
            id++;
            self._processItem(status, lis, id, linkId, resArgs);
            break;

          case 'protectedpage':
            ln.className = self.changeWikiMonkeyLinkClassName(ln.className, this.classes.botBypassed);
            App.log.logWarning("This user doesn't have the rights to " + "edit " + App.log.linkToWikiPage(article, article) + ", bypassing it ...");
            id++;

            self._processItem(0, lis, id, linkId, resArgs);
            break;
          default:
            ln.className = self.changeWikiMonkeyLinkClassName(ln.className, this.classes.botFailed);
            App.log.logError("Error processing " + App.log.linkToWikiPage(article, article) + ", stopping the bot");
            return self._endAutomatic(true);
        }
      };
    }
  }, {
    key: '_processItem',
    value: function _processItem(status, items, index, linkId, chainArgs) {
      var interval, link, self, stopId, title;
      self = this;
      if (items[index]) {
        link = items[index].getElementsByTagName('a')[linkId];

        if (link && this.canProcessPage(link)) {
          title = link.title;
          if (status === 0) {
            interval = 1000;
          } else {
            interval = this.configuration.interval;
          }
          App.log.logInfo('Waiting ' + interval / 1000 + ' seconds ...');
          stopId = setTimeout(function (lis, id, ln, article, chainArgs) {
            return function () {
              self._disableStopBot();

              if (!self._checkOtherBotsRunning()) {
                ln.className = self.changeWikiMonkeyLinkClassName(ln.className, this.classes.botProcessing);
                App.log.logInfo("Processing " + App.log.linkToWikiPage(article, article) + " ...");
                return self.configuration.function_(article, self.makeCallContinue(lis, id, linkId, ln, article), chainArgs);
              } else {
                App.log.logError('Another bot has been ' + 'force-started, stopping ...');
                return self._endAutomatic(false);
              }
            };
          }(items, index, link, title, chainArgs), interval);
          return this._enableStopBot(stopId);
        } else {
          index++;
          return this._processItem(status, items, index, linkId, chainArgs);
        }
      } else {
        return this._endAutomatic(true);
      }
    }
  }, {
    key: '_endAutomatic',
    value: function _endAutomatic(reset) {
      this._resetBotToken(reset);
      App.log.logInfo('Bot operations completed (check the log for ' + 'warnings or errors)');
      this._disableStartBot('Bot operations completed, reset and preview ' + 'the filter');
      return this._reEnableControls();
    }
  }]);

  return exports;
}();

},{"../modules":411,"../modules/libs":412,"./index":399}],395:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var WM, jssc;

var _require = require('../modules/libs');

jssc = _require.jssc;


WM = require('../modules');

module.exports = function () {
  function exports(WM1, page_type, plugins) {
    _classCallCheck(this, exports);

    var Plugin, classes, commandsFilterDiv, div, divFilter, filters, i, len, option, plugin, pluginInst, selectFilter;
    this.updateFilterUI = this.updateFilterUI.bind(this);
    this.executePlugin = this.executePlugin.bind(this);
    this.WM = WM1;
    this.page_type = page_type;

    var _jssc = jssc({
      commands: {
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'space-between',
        '& > select': {
          flex: 'auto',
          marginRight: '1em'
        },
        "& > input[type='button']": {
          marginRight: '1em'
        },
        "& input[type='checkbox']": {
          marginRight: '0.4em'
        }
      }
    });

    classes = _jssc.classes;

    filters = [];
    selectFilter = $('<select/>').change(this.updateFilterUI(filters));
    for (i = 0, len = plugins.length; i < len; i++) {
      Plugin = plugins[i];
      plugin = new Plugin(this.WM);
      pluginInst = plugin.conf.filter_label;

      if (!pluginInst) {
        continue;
      }
      filters.push(plugin);
      option = $('<option/>').text(pluginInst);
      if (plugin.constructor.name === WM.conf['default_' + this.page_type + '_plugin']) {
        option[0].selected = true;
      }
      option.appendTo(selectFilter);
    }
    if (filters.length) {
      commandsFilterDiv = $('<div/>').attr('id', 'WikiMonkeyFilters-Commands').addClass(classes.commands);
      commandsFilterDiv.append(selectFilter);
      $('<input/>').attr('type', 'button').val('Apply filter').click(this.executePlugin(filters)).appendTo(commandsFilterDiv);
      $('<input/>').attr('type', 'checkbox').change(this.toggleLog).appendTo(commandsFilterDiv);
      $('<span/>').text('Show Log').appendTo(commandsFilterDiv);
      divFilter = $('<div/>').attr('id', "WikiMonkeyFilters-Options");

      $('<div/>').appendTo(divFilter);
      this.doUpdateFilterUI(divFilter, filters, selectFilter[0].selectedIndex);
      div = $('<div/>').attr('id', 'WikiMonkeyFilters').append(commandsFilterDiv).append(divFilter);
      return div[0];
    } else {
      return false;
    }
  }

  _createClass(exports, [{
    key: 'updateFilterUI',
    value: function updateFilterUI(filters) {
      var _this = this;

      return function (event) {
        var UI, id, select;
        UI = $('#WikiMonkeyFilters-Options');
        select = $('#WikiMonkeyFilters-Commands').find('select').first();
        id = select[0].selectedIndex;
        return _this.doUpdateFilterUI(UI, filters, id);
      };
    }
  }, {
    key: 'doUpdateFilterUI',
    value: function doUpdateFilterUI(UI, filters, id) {
      var makeUI;
      makeUI = filters[id].makeUI;
      if (makeUI instanceof Function) {
        return UI.children().first().replaceWith(makeUI());
      } else {
        return UI.children().first().replaceWith($('<div/>'));
      }
    }
  }, {
    key: 'executePlugin',
    value: function executePlugin(filters) {
      var _this2 = this;

      return function (event) {
        var id, select;
        select = $('#WikiMonkeyFilters-Commands').find('select').first();
        id = select[0].selectedIndex;
        filters[id]['main_' + _this2.page_type]();
        return event.target.disabled = true;
      };
    }
  }, {
    key: 'toggleLog',
    value: function toggleLog(event) {
      if (this.checked) {
        return $('#WikiMonkeyLog').show();
      } else {
        return $('#WikiMonkeyLog').hide();
      }
    }
  }]);

  return exports;
}();

},{"../modules":411,"../modules/libs":412}],396:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Str, WM, jssc;

var _require = require('../modules/libs');

jssc = _require.jssc;


WM = require('../modules');

Str = require('@kynikos/misc/dist/Str');

module.exports = function () {
  var classesToLevels;

  var exports = function () {
    function exports() {
      _classCallCheck(this, exports);

      var classes, par;
      this._currentInfoDisplayState = true;

      var _jssc = jssc({
        log: {
          height: '10em',
          border: '2px solid #07b',
          padding: '0.5em',
          overflow: 'auto',
          resize: 'vertical',
          backgroundColor: '#111',
          '& p.timestamp, & p.message': {
            border: 'none',
            padding: 0,
            fontFamily: 'monospace',
            color: '#eee'
          },
          '& p.timestamp': {
            margin: '0 1em 0 0',
            whiteSpace: 'nowrap'
          },
          '& p.message': {
            margin: 0
          },
          '& div.mdebug, & div.minfo, & div.mwarning, & div.merror': {
            display: 'flex'
          },
          '& div.mhidden': {
            display: 'none'
          },
          '& div.mjson': {
            display: 'none'
          },
          '& div.mdebug p.message': {
            color: 'cyan'
          },
          '& div.mwarning p.message': {
            color: 'gold'
          },
          '& div.merror p.message': {
            color: 'red'
          },
          '& a': {
            color: 'inherit',
            textDecoration: 'underline'
          }
        }
      });

      classes = _jssc.classes;

      this.area = document.createElement('div');
      this.area.id = 'WikiMonkeyLog';
      par = document.createElement('p');
      par.appendChild(this.makeFilterLink());
      par.appendChild(document.createTextNode(' '));
      par.appendChild(this.makeSaveLink());
      this.area.appendChild(par);
      this.logarea = document.createElement('div');
      this.logarea.className = classes.log;
      this.area.appendChild(this.logarea);
    }

    _createClass(exports, [{
      key: 'makeFilterLink',
      value: function makeFilterLink() {
        var _this = this;

        var link;
        link = document.createElement('a');
        link.href = '#WikiMonkey';
        link.innerHTML = this.computeFilterLinkAnchor();
        link.addEventListener("click", function (event) {
          var i, len, msg, msgs;
          event.preventDefault();

          _this._currentInfoDisplayState = !_this._currentInfoDisplayState;
          link.innerHTML = _this.computeFilterLinkAnchor();
          msgs = _this.logarea.getElementsByClassName('minfo');
          for (i = 0, len = msgs.length; i < len; i++) {
            msg = msgs[i];
            msg.style.display = _this.computeInfoDisplayStyle();
          }
          return _this.scrollToBottom();
        }, false);
        return link;
      }
    }, {
      key: 'makeSaveLink',
      value: function makeSaveLink() {
        var _this2 = this;

        var link;
        link = document.createElement('a');
        link.href = '#';
        link.download = 'WikiMonkey.log';
        link.innerHTML = '[save log]';
        link.id = 'WikiMonkeyLog-Save';
        link.addEventListener("click", function () {
          link.href = 'data:text/plain;charset=utf-8,' + encodeURIComponent(_this2.composeSaveLogText());
          return link.download = _this2.composeSaveLogFilename();
        }, false);
        return link;
      }
    }, {
      key: 'composeSaveLogText',
      value: function composeSaveLogText() {
        var div, divs, i, len, level, message, ps, text, tstamp;
        divs = this.logarea.getElementsByTagName('div');
        text = '';
        for (i = 0, len = divs.length; i < len; i++) {
          div = divs[i];
          ps = div.getElementsByTagName('p');
          tstamp = ps[0].innerHTML;
          level = classesToLevels[div.className];
          message = ps[1].innerHTML;
          text += tstamp + '\t' + level + '\t' + message + '\n';
        }
        return text;
      }
    }, {
      key: 'composeSaveLogFilename',
      value: function composeSaveLogFilename() {
        var date;
        date = new Date();
        return 'WikiMonkey-' + date.getFullYear() + Str.padLeft(String(date.getMonth() + 1), '0', 2) + Str.padLeft(String(date.getDate()), '0', 2) + Str.padLeft(String(date.getHours()), '0', 2) + Str.padLeft(String(date.getMinutes()), '0', 2) + '.log';
      }
    }, {
      key: 'computeInfoDisplayStyle',
      value: function computeInfoDisplayStyle() {
        if (this._currentInfoDisplayState) {
          return 'flex';
        } else {
          return 'none';
        }
      }
    }, {
      key: 'computeFilterLinkAnchor',
      value: function computeFilterLinkAnchor() {
        if (this._currentInfoDisplayState) {
          return '[hide info messages]';
        } else {
          return '[show info messages]';
        }
      }
    }, {
      key: 'scrollToBottom',
      value: function scrollToBottom() {
        return this.logarea.scrollTop = this.logarea.scrollHeight - this.logarea.clientHeight;
      }
    }, {
      key: 'appendMessage',
      value: function appendMessage(text, type) {
        var line, msg, now, test, tstamp;
        tstamp = document.createElement('p');
        tstamp.className = 'timestamp';
        now = new Date();
        tstamp.innerHTML = now.toLocaleTimeString();
        msg = document.createElement('p');
        msg.className = 'message';

        msg.innerHTML = text ? text : " ";
        line = document.createElement('div');
        line.appendChild(tstamp);
        line.appendChild(msg);
        line.className = type;
        if (type === 'minfo') {
          line.style.display = this.computeInfoDisplayStyle();
        }

        test = this.logarea.scrollTop + this.logarea.clientHeight === this.logarea.scrollHeight;
        this.logarea.appendChild(line);
        if (test) {
          return this.scrollToBottom();
        }
      }
    }, {
      key: 'logHidden',
      value: function logHidden(text) {
        return this.appendMessage(text, 'mhidden');
      }
    }, {
      key: 'logJson',
      value: function logJson(component, data) {
        var text;
        text = JSON.stringify({
          "component": component,
          "data": data
        });
        return this.appendMessage(text, 'mjson');
      }
    }, {
      key: 'logDebug',
      value: function logDebug(text) {
        return this.appendMessage(text, 'mdebug');
      }
    }, {
      key: 'logInfo',
      value: function logInfo(text) {
        return this.appendMessage(text, 'minfo');
      }
    }, {
      key: 'logWarning',
      value: function logWarning(text) {
        return this.appendMessage(text, 'mwarning');
      }
    }, {
      key: 'logError',
      value: function logError(text) {
        return this.appendMessage(text, 'merror');
      }
    }, {
      key: 'linkToPage',
      value: function linkToPage(url, anchor) {
        return "<a href=\"" + url + "\">" + anchor + "</a>";
      }
    }, {
      key: 'linkToWikiPage',
      value: function linkToWikiPage(title, anchor) {
        var wikiUrls;

        wikiUrls = WM.MW.getWikiUrls();
        return "<a href=\"" + wikiUrls.short + title + "\">" + anchor + "</a>";
      }
    }]);

    return exports;
  }();

  ;

  classesToLevels = {
    'mhidden': 'HDN',
    'mjson': 'JSN',
    'mdebug': 'DBG',
    'minfo': 'INF',
    'mwarning': 'WRN',
    'merror': 'ERR'
  };

  return exports;
}.call(undefined);

},{"../modules":411,"../modules/libs":412,"@kynikos/misc/dist/Str":3}],397:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var App, jssc;

var _require = require('../modules/libs');

jssc = _require.jssc;


App = require('./index');

module.exports = function () {
  var _executeGroupAction, makeChangeMenu, makeGroupAction;

  var exports = function () {
    function exports(WM, page_type, plugins) {
      _classCallCheck(this, exports);

      var Plugin, classes, currId, currMenu, entry, execAll, groupAction, groupActions, i, j, len, m, mainDiv, menuSel, menus, parentId, parentMenu, plugin, pluginInst, ref;
      this.executeEntryAction = this.executeEntryAction.bind(this);
      this.warnInputNeeded = this.warnInputNeeded.bind(this);
      this.WM = WM;
      this.page_type = page_type;

      var _jssc = jssc({
        menu: {
          '& input.margin': {
            margin: "0 0.33em 0.33em 0"
          }
        }
      });

      classes = _jssc.classes;

      mainDiv = $('<div/>').attr('id', 'WikiMonkeyMenu').addClass(classes.menu);
      groupActions = {};
      for (i = 0, len = plugins.length; i < len; i++) {
        Plugin = plugins[i];
        plugin = new Plugin(this.WM);
        pluginInst = plugin.conf[this.page_type + '_menu'];

        if (!pluginInst || !pluginInst.length) {
          continue;
        }
        if (plugin.makeUI) {
          groupAction = [this.warnInputNeeded, plugin];
        } else {
          groupAction = [this.executeEntryAction, plugin];
        }
        pluginInst.unshift("WikiMonkeyMenuRoot");
        currId = false;
        for (m = j = 0, ref = pluginInst.length - 1; 0 <= ref ? j < ref : j > ref; m = 0 <= ref ? ++j : --j) {
          parentId = currId;
          currId = pluginInst.slice(0, m + 1).join("-").replace(/ /g, "_");

          menuSel = mainDiv.children('div[id=\'' + currId + '\']');
          if (!menuSel.length) {
            currMenu = $("<div/>").attr("id", currId).hide().appendTo(mainDiv);
            groupActions[currId] = [];
            if (m > 0) {
              parentMenu = mainDiv.children('div[id=\'' + parentId + '\']');
              $('<input/>').attr('type', 'button').val('<').addClass('margin').click(makeChangeMenu(currMenu, parentMenu)).appendTo(currMenu);
              $('<input/>').attr('type', 'button').val(pluginInst[m]).click(makeGroupAction(groupActions[currId])).appendTo(parentMenu);
              $('<input/>').attr('type', 'button').val('>').addClass('margin').click(makeChangeMenu(parentMenu, currMenu)).appendTo(parentMenu);
            }
          } else {
            currMenu = menuSel.first();
          }
          groupActions[currId].push(groupAction);
        }
        entry = $("<input/>").attr('type', 'button').val(pluginInst[pluginInst.length - 1]).addClass('margin').appendTo(currMenu);
        if (plugin.makeUI) {
          entry.click(this.makeEntryUI(currMenu, plugin));
        } else {
          entry.click(this.makeEntryAction(plugin));
        }
      }
      menus = mainDiv.children();
      if (menus.length) {
        execAll = $('<input/>').attr('type', 'button').val("*").addClass('margin').click(makeGroupAction(groupActions["WikiMonkeyMenuRoot"]));

        mainDiv.children("div[id='WikiMonkeyMenuRoot']").first().prepend(execAll);
        menus.first().show();
        return mainDiv[0];
      } else {
        return false;
      }
    }

    _createClass(exports, [{
      key: 'makeEntryUI',
      value: function makeEntryUI(currMenu, plugin) {
        var _this = this;

        return function (event) {
          var UI, UIdiv;
          currMenu.hide();
          UIdiv = $('<div/>');
          $('<input/>').attr('type', 'button').val('<').addClass('margin').click(function (event) {
            UIdiv.remove();
            return currMenu.show();
          }).appendTo(UIdiv);
          $('<input/>').attr('type', 'button').val('Execute').click(_this.makeEntryAction(plugin)).appendTo(UIdiv);
          UI = plugin.makeUI();
          return UIdiv.append(UI).insertAfter(currMenu);
        };
      }
    }, {
      key: 'makeEntryAction',
      value: function makeEntryAction(plugin) {
        var _this2 = this;

        return function (event) {
          return _this2.executeEntryAction(plugin, null);
        };
      }
    }, {
      key: 'executeEntryAction',
      value: function executeEntryAction(plugin, callNext) {
        App.log.logHidden("Plugin: " + plugin.constructor.name);
        return plugin['main_' + this.page_type](callNext);
      }
    }, {
      key: 'warnInputNeeded',
      value: function warnInputNeeded(plugin, callNext) {
        App.log.logWarning("Plugin " + plugin.constructor.name + " was not executed because it requires input from its interface.");
        if (callNext) {
          return callNext();
        }
      }
    }]);

    return exports;
  }();

  ;

  makeChangeMenu = function makeChangeMenu(currentMenu, changeMenu) {
    return function (event) {
      currentMenu.hide();
      return changeMenu.show();
    };
  };

  makeGroupAction = function makeGroupAction(subGroupActions) {
    return function (event) {
      return _executeGroupAction(subGroupActions, -1);
    };
  };

  _executeGroupAction = function executeGroupAction(subGroupActions, id) {
    var callContinue, fid;
    id++;
    if (subGroupActions[id]) {
      fid = subGroupActions[id];
      callContinue = function callContinue() {
        return _executeGroupAction(subGroupActions, id);
      };
      return fid[0](fid[1], callContinue);
    }
  };

  return exports;
}.call(undefined);

},{"../modules/libs":412,"./index":399}],398:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var WM, jssc;

var _require = require('../modules/libs');

jssc = _require.jssc;


WM = require('../modules');

module.exports = function () {
  var disableEditSummarySubmitOnEnter, hideRollbackLinks, scrollToFirstHeading;

  var exports = function () {
    function exports() {
      _classCallCheck(this, exports);
    }

    _createClass(exports, [{
      key: 'applyEditorMods',
      value: function applyEditorMods() {
        if (WM.conf.disable_edit_summary_submit_on_enter) {
          disableEditSummarySubmitOnEnter();
        }
        if (WM.conf.scroll_to_first_heading) {
          return scrollToFirstHeading();
        }
      }
    }, {
      key: 'applyRecentChangesMods',
      value: function applyRecentChangesMods() {
        if (WM.conf.hide_rollback_links) {
          return hideRollbackLinks();
        }
      }
    }, {
      key: 'applyContributionsMods',
      value: function applyContributionsMods() {
        if (WM.conf.hide_rollback_links) {
          return hideRollbackLinks();
        }
      }
    }]);

    return exports;
  }();

  ;

  disableEditSummarySubmitOnEnter = function disableEditSummarySubmitOnEnter() {
    return $('#wpSummary').keydown(function (event) {
      if (event.key === 'Enter' || typeof event.key === 'undefined' && event.keyCode === 13) {
        event.preventDefault();
        return false;
      }
    });
  };

  hideRollbackLinks = function hideRollbackLinks() {
    return jssc({
      '@global span.mw-rollback-link': {
        display: 'none'
      }
    });
  };

  scrollToFirstHeading = function scrollToFirstHeading() {
    return window.scrollTo(0, $('#firstHeading').offset().top);
  };

  return exports;
}.call(undefined);

},{"../modules":411,"../modules/libs":412}],399:[function(require,module,exports){
'use strict';

var A, Div, Fieldset, Legend, Log, Vue, route, version;

var _require = require('../modules/libs');

Vue = _require.Vue;
A = _require.A;
Div = _require.Div;
Fieldset = _require.Fieldset;
Legend = _require.Legend;

var _require2 = require('../../package.json');

version = _require2.version;


route = require('./router');

Log = require('./Log');

module.exports.App = function (WMtemp) {
  var display, displayLog, log, nextNode, root, ui;

  var _route = route(WMtemp);

  ui = _route.ui;
  display = _route.display;
  displayLog = _route.displayLog;
  nextNode = _route.nextNode;

  if (!ui) {
    return false;
  }
  module.exports.log = log = new Log();
  root = Div();
  $(nextNode).before(root);
  return new Vue({
    el: root,
    data: {
      display: display
    },
    render: function render(e) {
      var legend, self, wmmain;
      self = this;
      wmmain = e('div', {
        attrs: {
          id: 'WikiMonkeyMain'
        }
      });
      legend = e('legend', ['Wiki Monkey ', e('a', {
        attrs: {
          href: '#'
        },
        on: {
          click: function click(event) {
            event.preventDefault();
            return self.display = !self.display;
          }
        }
      }, this.display && '[hide]' || '[show]')]);
      return e('fieldset', {
        attrs: {
          id: 'WikiMonkey'
        }
      }, [legend, this.display ? wmmain : void 0]);
    },
    mounted: function mounted() {
      var date;
      if (!displayLog) {
        $(log.area).hide();
      }
      $('#WikiMonkeyMain').append(ui, log.area);
      log.logHidden('Wiki Monkey version: ' + version);
      date = new Date();
      log.logHidden('Date: ' + date.toString());
      return log.logHidden('URL: ' + location.href);
    },
    updated: function updated() {
      var $wmmain;
      $wmmain = $('#WikiMonkeyMain');
      if (!$wmmain.children().length) {
        return $wmmain.append(ui, log.area);
      }
    }
  });
};

},{"../../package.json":392,"../modules/libs":412,"./Log":396,"./router":400}],400:[function(require,module,exports){
'use strict';

var Bot, Filters, Menu, Mods, WM;

WM = require('../modules/index');

Bot = require('./Bot');

Filters = require('./Filters');

Menu = require('./Menu');

Mods = require('./Mods');

module.exports = function (WMtemp) {
  var conf, display, displayLog, nextNode, specialPage, ui;

  specialPage = function () {
    var spage;
    spage = mw.config.get('wgCanonicalSpecialPageName');
    if (spage) {
      return spage.toLowerCase();
    }
    return spage;
  }();
  display = true;
  displayLog = true;

  if ($('#editform').length) {
    nextNode = $('#wpSummaryLabel').parent().next()[0];
    conf = WM.Plugins.editor;
    ui = conf.length ? new Menu(WMtemp, 'editor', conf) : null;
    new Mods().applyEditorMods();
  } else if (mw.config.get('wgDiffNewId')) {
    nextNode = $('#bodyContent h2').first()[0];
    conf = WM.Plugins.diff;
    ui = conf.length ? new Menu(WMtemp, 'diff', conf) : null;
  } else if (mw.config.get('wgCanonicalNamespace') === 'Category') {
    nextNode = $('#contentSub')[0];
    conf = WM.Plugins.bot;
    ui = conf.length ? new Bot(WMtemp, conf, [[$('#mw-pages')[0], 0, "Pages"], [$('#mw-subcategories')[0], 0, "Subcategories"]]) : null;
    display = false;
  } else if (specialPage === "whatlinkshere") {
    nextNode = $('#bodyContent form').first().next()[0];
    conf = WM.Plugins.bot;
    ui = conf.length ? new Bot(WMtemp, conf, [[$('#mw-whatlinkshere-list')[0], 0, "Pages"]]) : null;
    display = false;
  } else if (specialPage === "linksearch" && $('#mw-content-text div.mw-spcontent').length) {
    nextNode = $('#mw-content-text div.mw-spcontent').first()[0];
    conf = WM.Plugins.bot;
    ui = conf.length ? new Bot(WMtemp, conf, [[$(nextNode).first('ol.special').first()[0], 1, "Pages"]]) : null;
    display = false;
  } else if (specialPage === "prefixindex") {
    nextNode = $('#mw-content-text div.mw-prefixindex-body').first()[0];
    conf = WM.Plugins.bot;
    ui = conf.length ? new Bot(WMtemp, conf, [[$(nextNode).find('ul.mw-prefixindex-list').first()[0], 0, "Pages"]]) : null;
    display = false;
  } else if (specialPage === "specialpages") {
    nextNode = $('#contentSub')[0];
    conf = WM.Plugins.special;
    ui = conf.length ? new Menu(WMtemp, 'special', conf) : null;
  } else if (specialPage === "recentchanges") {
    nextNode = $('#mw-content-text h4').first()[0];
    conf = WM.Plugins.recentchanges;
    ui = conf.length ? new Filters(WMtemp, 'recentchanges', conf) : null;
    displayLog = false;
    new Mods().applyRecentChangesMods();
  } else if (specialPage === "newpages") {
    nextNode = $('#mw-content-text ul').first()[0];
    conf = WM.Plugins.newpages;
    ui = conf.length ? new Filters(WMtemp, 'newpages', conf) : null;
    displayLog = false;
  } else if (specialPage === "protectedpages") {
    nextNode = $('#mw-content-text table.mw-protectedpages').first()[0];
    conf = WM.Plugins.bot;
    ui = conf.length ? new Bot(WMtemp, conf, [[$(nextNode).find('tbody').first()[0], 0, "Pages"]]) : null;
    display = false;
  } else if (specialPage === "contributions") {
    new Mods().applyContributionsMods();
  } else if (specialPage === "ancientpages" || specialPage === "brokenredirects" || specialPage === "deadendpages" || specialPage === "doubleredirects" || specialPage === "fewestrevisions" || specialPage === "lonelypages" || specialPage === "uncategorizedcategories" || specialPage === "uncategorizedpages" || specialPage === "uncategorizedtemplates" || specialPage === "unusedcategories" || specialPage === "unwatchedpages") {
    nextNode = $('#mw-content-text div.mw-spcontent').first()[0];
    conf = WM.Plugins.bot;
    ui = conf.length ? new Bot(WMtemp, conf, [[$(nextNode).find('ol').first()[0], 0, "Pages"]]) : null;
    display = false;
  } else if (specialPage === "longpages" || specialPage === "shortpages") {
    nextNode = $('#mw-content-text div.mw-spcontent').first()[0];
    conf = WM.Plugins.bot;
    ui = conf.length ? new Bot(WMtemp, conf, [[$(nextNode).find('ol').first()[0], 1, "Pages"]]) : null;
    display = false;
  } else if (specialPage === "withoutinterwiki") {
    nextNode = $('#mw-content-text div.mw-spcontent > p').first()[0];
    conf = WM.Plugins.bot;
    ui = conf.length ? new Bot(WMtemp, conf, [[$(nextNode).nextAll('ol').first()[0], 0, "Pages"]]) : null;
    display = false;
  } else if (specialPage === "allpages") {
    nextNode = $('#mw-content-text div.mw-allpages-nav').first()[0];
    conf = WM.Plugins.bot;
    ui = conf.length ? new Bot(WMtemp, conf, [[$(nextNode).nextAll('div.mw-allpages-body').first().find('ul').first()[0], 0, "Pages"]]) : null;
    display = false;
  }
  return { ui: ui, display: display, displayLog: displayLog, nextNode: nextNode };
};

},{"../modules/index":411,"./Bot":394,"./Filters":395,"./Menu":397,"./Mods":398}],401:[function(require,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

module.exports = function () {
  var languages, tablesOfContents;

  var exports = function () {
    function exports(WM) {
      _classCallCheck(this, exports);

      this.WM = WM;
    }

    _createClass(exports, [{
      key: "getLocalLanguage",
      value: function getLocalLanguage() {
        return languages.local;
      }
    }, {
      key: "getCategoryLanguages",
      value: function getCategoryLanguages() {
        return languages.categories;
      }
    }, {
      key: "isCategoryLanguage",
      value: function isCategoryLanguage(lang) {
        return languages.categories.indexOf(lang) > -1;
      }
    }, {
      key: "getInterwikiLanguages",
      value: function getInterwikiLanguages() {
        return languages.interlanguage.external.concat(languages.interlanguage.internal);
      }
    }, {
      key: "isInterwikiLanguage",
      value: function isInterwikiLanguage(lang) {
        return this.getInterwikiLanguages().indexOf(lang) > -1;
      }
    }, {
      key: "getInternalInterwikiLanguages",
      value: function getInternalInterwikiLanguages() {
        return languages.interlanguage.internal;
      }
    }, {
      key: "isInternalInterwikiLanguage",
      value: function isInternalInterwikiLanguage(lang) {
        return languages.interlanguage.internal.indexOf(lang) > -1;
      }
    }, {
      key: "getInterlanguageTag",
      value: function getInterlanguageTag(language) {
        return languages.names[language].subtag;
      }
    }, {
      key: "detectLanguage",
      value: function detectLanguage(title) {
        var detectedLanguage, matches, pureTitle, testLangCat;
        matches = title.match(/^(.+?)(?:[ _]\(([^\(]+)\))?$/);
        pureTitle = matches[1];
        detectedLanguage = matches[2];
        if (!detectedLanguage || !this.isCategoryLanguage(detectedLanguage)) {
          testLangCat = matches[1].match(/^[ _]*[Cc]ategory[ _]*:[ _]*(.+?)[ _]*$/);
          if (testLangCat && this.isCategoryLanguage(testLangCat[1])) {
            detectedLanguage = testLangCat[1];
            pureTitle = matches[1];
          } else {
            detectedLanguage = this.getLocalLanguage();
            pureTitle = matches[0];
          }
        }
        return [pureTitle, detectedLanguage];
      }
    }, {
      key: "findAllInterlanguageLinks",
      value: function findAllInterlanguageLinks(source) {
        return this.WM.Parser.findSpecialLinks(source, this.getInterwikiLanguages().join("|"));
      }
    }, {
      key: "findInternalInterlanguageLinks",
      value: function findInternalInterlanguageLinks(source) {
        return this.WM.Parser.findSpecialLinks(source, this.getInternalInterwikiLanguages().join("|"));
      }
    }, {
      key: "getTableOfContents",
      value: function getTableOfContents(tag) {
        return tablesOfContents[tag];
      }
    }]);

    return exports;
  }();

  ;

  languages = {
    local: "English",
    names: {
      "العربية": {
        subtag: "ar",
        english: "Arabic"
      },
      "Български": {
        subtag: "bg",
        english: "Bulgarian"
      },
      "Català": {
        subtag: "ca",
        english: "Catalan"
      },
      "Česky": {
        subtag: "cs",
        english: "Czech"
      },
      "Dansk": {
        subtag: "da",
        english: "Danish"
      },
      "Deutsch": {
        subtag: "de",
        english: "German"
      },
      "Ελληνικά": {
        subtag: "el",
        english: "Greek"
      },
      "English": {
        subtag: "en",
        english: "English"
      },
      "Esperanto": {
        subtag: "eo",
        english: "Esperanto"
      },
      "Español": {
        subtag: "es",
        english: "Spanish"
      },
      "فارسی": {
        subtag: "fa",
        english: "Persian"
      },
      "Suomi": {
        subtag: "fi",
        english: "Finnish"
      },
      "Français": {
        subtag: "fr",
        english: "French"
      },
      "עברית": {
        subtag: "he",
        english: "Hebrew"
      },
      "Hrvatski": {
        subtag: "hr",
        english: "Croatian"
      },
      "Magyar": {
        subtag: "hu",
        english: "Hungarian"
      },
      "Indonesia": {
        subtag: "id",
        english: "Indonesian"
      },
      "Italiano": {
        subtag: "it",
        english: "Italian"
      },
      "日本語": {
        subtag: "ja",
        english: "Japanese"
      },
      "한국어": {
        subtag: "ko",
        english: "Korean"
      },
      "Lietuviškai": {
        subtag: "lt",
        english: "Lithuanian"
      },
      "Norsk Bokmål": {
        subtag: "nb",
        english: "Norwegian (Bokmål)"
      },
      "Nederlands": {
        subtag: "nl",
        english: "Dutch"
      },
      "Polski": {
        subtag: "pl",
        english: "Polish"
      },
      "Português": {
        subtag: "pt",
        english: "Portuguese"
      },
      "Română": {
        subtag: "ro",
        english: "Romanian"
      },
      "Русский": {
        subtag: "ru",
        english: "Russian"
      },
      "Slovenský": {
        subtag: "sk",
        english: "Slovak"
      },
      "Српски": {
        subtag: "sr",
        english: "Serbian"
      },
      "Svenska": {
        subtag: "sv",
        english: "Swedish"
      },
      "ไทย": {
        subtag: "th",
        english: "Thai"
      },
      "Türkçe": {
        subtag: "tr",
        english: "Turkish"
      },
      "Українська": {
        subtag: "uk",
        english: "Ukrainian"
      },
      "Tiếng Việt": {
        subtag: "vi",
        english: "Vietnamese"
      },
      "简体中文": {
        subtag: "zh-hans",
        english: "Chinese (Simplified)"
      },
      "正體中文": {
        subtag: "zh-hant",
        english: "Chinese (Traditional)"
      }
    },
    categories: ["العربية", "Български", "Català", "Česky", "Dansk", "Ελληνικά", "English", "Esperanto", "Español", "Suomi", "עברית", "Hrvatski", "Magyar", "Indonesia", "Italiano", "日本語", "한국어", "Lietuviškai", "Norsk Bokmål", "Nederlands", "Polski", "Português", "Русский", "Slovenský", "Српски", "ไทย", "Türkçe", "Українська", "简体中文", "正體中文"],
    interlanguage: {
      external: ["de", "fa", "fr", "ja", "ro"],
      internal: ["ar", "bg", "cs", "da", "el", "en", "es", "fi", "he", "hr", "hu", "id", "it", "ko", "lt", "nl", "pl", "pt", "ru", "sk", "sr", "sv", "th", "tr", "uk", "zh-hans", "zh-hant"]
    }
  };

  tablesOfContents = {
    "ar": {
      "page": "Table of contents (العربية)",
      "root": "Category:العربية",
      "alsoIn": "also in",
      "indentType": ":",
      "replace": ["[ _]\\(العربية\\)", "", ""],
      "keepAltName": true,
      "showIndices": true,
      "rightToLeft": true
    },
    "bg": {
      "page": "Table of contents (Български)",
      "root": "Category:Български",
      "alsoIn": "също в",
      "indentType": ":",
      "replace": ["[ _]\\(Български\\)", "", ""],
      "keepAltName": true,
      "showIndices": true,
      "rightToLeft": false
    },
    "cs": {
      "page": "Table of contents (Česky)",
      "root": "Category:Česky",
      "alsoIn": "také v",
      "indentType": ":",
      "replace": ["[ _]\\(Česky\\)", "", ""],
      "keepAltName": true,
      "showIndices": true,
      "rightToLeft": false
    },
    "da": {
      "page": "Table of contents (Dansk)",
      "root": "Category:Dansk",
      "alsoIn": "også i",
      "indentType": ":",
      "replace": ["[ _]\\(Dansk\\)", "", ""],
      "keepAltName": true,
      "showIndices": true,
      "rightToLeft": false
    },
    "el": {
      "page": "Table of contents (Ελληνικά)",
      "root": "Category:Ελληνικά",
      "alsoIn": "επίσης σε",
      "indentType": ":",
      "replace": ["[ _]\\(Ελληνικά\\)", "", ""],
      "keepAltName": true,
      "showIndices": true,
      "rightToLeft": false
    },
    "en": {
      "page": "Table of contents",
      "root": "Category:English",
      "alsoIn": "also in",
      "indentType": ":",
      "replace": null,
      "keepAltName": false,
      "showIndices": true,
      "rightToLeft": false
    },
    "es": {
      "page": "Table of contents (Español)",
      "root": "Category:Español",
      "alsoIn": "también en",
      "indentType": ":",
      "replace": ["[ _]\\(Español\\)", "", ""],
      "keepAltName": true,
      "showIndices": true,
      "rightToLeft": false
    },
    "he": {
      "page": "Table of contents (עברית)",
      "root": "Category:עברית",
      "alsoIn": "also in",
      "indentType": ":",
      "replace": ["[ _]\\(עברית\\)", "", ""],
      "keepAltName": true,
      "showIndices": true,
      "rightToLeft": true
    },
    "hr": {
      "page": "Table of contents (Hrvatski)",
      "root": "Category:Hrvatski",
      "alsoIn": "također u",
      "indentType": ":",
      "replace": ["[ _]\\(Hrvatski\\)", "", ""],
      "keepAltName": true,
      "showIndices": true,
      "rightToLeft": false
    },
    "hu": {
      "page": "Table of contents (Magyar)",
      "root": "Category:Magyar",
      "alsoIn": "is",
      "indentType": ":",
      "replace": ["[ _]\\(Magyar\\)", "", ""],
      "keepAltName": true,
      "showIndices": true,
      "rightToLeft": false
    },
    "id": {
      "page": "Table of contents (Indonesia)",
      "root": "Category:Indonesia",
      "alsoIn": "juga di",
      "indentType": ":",
      "replace": ["[ _]\\(Indonesia\\)", "", ""],
      "keepAltName": true,
      "showIndices": true,
      "rightToLeft": false
    },
    "it": {
      "page": "Table of contents (Italiano)",
      "root": "Category:Italiano",
      "alsoIn": "anche in",
      "indentType": ":",
      "replace": ["[ _]\\(Italiano\\)", "", ""],
      "keepAltName": true,
      "showIndices": true,
      "rightToLeft": false
    },
    "ko": {
      "page": "Table of contents (한국어)",
      "root": "Category:한국어",
      "alsoIn": "또한 에",
      "indentType": ":",
      "replace": ["[ _]\\(한국어\\)", "", ""],
      "keepAltName": true,
      "showIndices": true,
      "rightToLeft": false
    },
    "lt": {
      "page": "Table of contents (Lietuviškai)",
      "root": "Category:Lietuviškai",
      "alsoIn": "taip pat ir",
      "indentType": ":",
      "replace": ["[ _]\\(Lietuviškai\\)", "", ""],
      "keepAltName": true,
      "showIndices": true,
      "rightToLeft": false
    },
    "nl": {
      "page": "Table of contents (Nederlands)",
      "root": "Category:Nederlands",
      "alsoIn": "ook in",
      "indentType": ":",
      "replace": ["[ _]\\(Nederlands\\)", "", ""],
      "keepAltName": true,
      "showIndices": true,
      "rightToLeft": false
    },
    "pl": {
      "page": "Table of contents (Polski)",
      "root": "Category:Polski",
      "alsoIn": "również w",
      "indentType": ":",
      "replace": ["[ _]\\(Polski\\)", "", ""],
      "keepAltName": true,
      "showIndices": true,
      "rightToLeft": false
    },
    "pt": {
      "page": "Table of contents (Português)",
      "root": "Category:Português",
      "alsoIn": "também em",
      "indentType": ":",
      "replace": ["[ _]\\(Português\\)", "", ""],
      "keepAltName": true,
      "showIndices": true,
      "rightToLeft": false
    },
    "ru": {
      "page": "Table of contents (Русский)",
      "root": "Category:Русский",
      "alsoIn": "Также в",
      "indentType": ":",
      "replace": ["[ _]\\(Русский\\)", "", ""],
      "keepAltName": true,
      "showIndices": true,
      "rightToLeft": false
    },
    "sk": {
      "page": "Table of contents (Slovenský)",
      "root": "Category:Slovenský",
      "alsoIn": "tiež v",
      "indentType": ":",
      "replace": ["[ _]\\(Slovenský\\)", "", ""],
      "keepAltName": true,
      "showIndices": true,
      "rightToLeft": false
    },
    "sr": {
      "page": "Table of contents (Српски)",
      "root": "Category:Српски",
      "alsoIn": "такође у",
      "indentType": ":",
      "replace": ["[ _]\\(Српски\\)", "", ""],
      "keepAltName": true,
      "showIndices": true,
      "rightToLeft": false
    },
    "th": {
      "page": "Table of contents (ไทย)",
      "root": "Category:ไทย",
      "alsoIn": "ยังอยู่ใน",
      "indentType": ":",
      "replace": ["[ _]\\(ไทย\\)", "", ""],
      "keepAltName": true,
      "showIndices": true,
      "rightToLeft": false
    },
    "tr": {
      "page": "Table of contents (Türkçe)",
      "root": "Category:Türkçe",
      "alsoIn": "ayrıca",
      "indentType": ":",
      "replace": ["[ _]\\(Türkçe\\)", "", ""],
      "keepAltName": true,
      "showIndices": true,
      "rightToLeft": false
    },
    "uk": {
      "page": "Table of contents (Українська)",
      "root": "Category:Українська",
      "alsoIn": "також в",
      "indentType": ":",
      "replace": ["[ _]\\(Українська\\)", "", ""],
      "keepAltName": true,
      "showIndices": true,
      "rightToLeft": false
    },
    "zh-hans": {
      "page": "Table of contents (简体中文)",
      "root": "Category:简体中文",
      "alsoIn": "同时还属于",
      "indentType": ":",
      "replace": ["[ _]\\(简体中文\\)", "", ""],
      "keepAltName": true,
      "showIndices": true,
      "rightToLeft": false
    },
    "zh-hant": {
      "page": "Table of contents (正體中文)",
      "root": "Category:正體中文",
      "alsoIn": "還在",
      "indentType": ":",
      "replace": ["[ _]\\(正體中文\\)", "", ""],
      "keepAltName": true,
      "showIndices": true,
      "rightToLeft": false
    }
  };

  return exports;
}.call(undefined);

},{}],402:[function(require,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Async;

Async = require('@kynikos/misc/dist/Async');

module.exports = function () {
  function exports(WM) {
    _classCallCheck(this, exports);

    this.WM = WM;
  }

  _createClass(exports, [{
    key: "recurseTree",
    value: function recurseTree(params) {
      params.callChildren = this._recurseTreeCallChildren;
      return Async.recurseTreeAsync(params);
    }
  }, {
    key: "recurseTreeContinue",
    value: function recurseTreeContinue(params) {
      return Async.recurseTreeAsync(params);
    }
  }, {
    key: "_recurseTreeCallChildren",
    value: function _recurseTreeCallChildren(params) {
      return this.getSubCategories(params.node, this._recurseTreeCallChildrenContinue, params);
    }
  }, {
    key: "_recurseTreeCallChildrenContinue",
    value: function _recurseTreeCallChildrenContinue(subCats, params) {
      var i, len, subCat;
      for (i = 0, len = subCats.length; i < len; i++) {
        subCat = subCats[i];
        params.children.push(subCat.title);
      }
      return Async.recurseTreeAsync(params);
    }
  }, {
    key: "getSubCategories",
    value: function getSubCategories(parent, call, callArgs) {
      return this._getMembers(parent, "subcat", call, callArgs);
    }
  }, {
    key: "getAllMembers",
    value: function getAllMembers(parent, call, callArgs) {
      return this._getMembers(parent, null, call, callArgs);
    }
  }, {
    key: "_getMembers",
    value: function _getMembers(name, cmtype, call, callArgs) {
      var query;
      query = {
        action: "query",
        list: "categorymembers",
        cmtitle: name,
        cmlimit: 500
      };
      if (cmtype) {
        query.cmtype = cmtype;
      }
      return this._getMembersContinue(query, call, callArgs, []);
    }
  }, {
    key: "_getMembersContinue",
    value: function _getMembersContinue(query, call, callArgs, members) {
      return this.WM.MW.callAPIGet(query, function (res, args) {
        members = members.concat(res.query.categorymembers);
        if (res["query-continue"]) {
          query.cmcontinue = res["query-continue"].categorymembers.cmcontinue;
          return this._getMembersContinue(query, call, args, members);
        } else {
          return call(members, args);
        }
      }, callArgs, null);
    }
  }, {
    key: "getParentsAndInfo",
    value: function getParentsAndInfo(name, call, callArgs) {
      var query;
      query = {
        action: "query",
        prop: "categories|categoryinfo",
        titles: name,
        clprop: "hidden",
        cllimit: 500
      };
      return this._getParentsAndInfoContinue(query, call, callArgs, [], null);
    }
  }, {
    key: "_getParentsAndInfoContinue",
    value: function _getParentsAndInfoContinue(query, call, callArgs, parents, info) {
      return this.WM.MW.callAPIGet(query, function (res, args) {
        var page;
        page = Object.values(res.query.pages)[0];
        if (page.categories) {
          parents = parents.concat(page.categories);
        }
        if (page.categoryinfo) {
          info = page.categoryinfo;
        }
        if (res["query-continue"]) {
          query.prop = "categories";
          query.clcontinue = res["query-continue"].categories.clcontinue;
          return this._getParentsAndInfoContinue(query, call, args, parents, info);
        } else {
          return call(parents, info, args);
        }
      }, callArgs, null);
    }
  }]);

  return exports;
}();

},{"@kynikos/misc/dist/Async":1}],403:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

module.exports = function () {
  function exports(WM) {
    _classCallCheck(this, exports);

    this.WM = WM;
  }

  _createClass(exports, [{
    key: 'getEndTimestamp',
    value: function getEndTimestamp(call, callArgs) {
      var diff, giveEndTimestamp, oldid, pars, title;
      title = mw.config.get('wgPageName');
      diff = mw.config.get('wgDiffNewId');
      oldid = mw.config.get('wgDiffOldId');
      giveEndTimestamp = function giveEndTimestamp(page, id) {
        return call(page.revisions[id].timestamp, callArgs);
      };
      switch (diff) {
        case 'next':
          pars = {
            prop: "revisions",
            titles: title,
            rvlimit: "2",
            rvprop: "timestamp",
            rvdir: "newer",
            rvstartid: oldid
          };
          return this.WM.MW.callQuery(pars, giveEndTimestamp, 1, null);
        case 'prev':
          pars = {
            prop: "revisions",
            revids: oldid,
            rvprop: "timestamp"
          };
          return this.WM.MW.callQuery(pars, giveEndTimestamp, 0, null);
        default:
          pars = {
            prop: "revisions",
            revids: diff,
            rvprop: "timestamp"
          };
          return this.WM.MW.callQuery(pars, giveEndTimestamp, 0, null);
      }
    }
  }]);

  return exports;
}();

},{}],404:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

module.exports = function () {
  function exports(WM) {
    _classCallCheck(this, exports);

    this.WM = WM;
  }

  _createClass(exports, [{
    key: 'getTitle',
    value: function getTitle() {
      return this.WM.Parser.squashContiguousWhitespace(mw.config.get('wgPageName'));
    }
  }, {
    key: 'isSection',
    value: function isSection() {
      if ($('[name=wpSection]').eq(0).val()) {
        return true;
      }
      return false;
    }
  }, {
    key: 'readSource',
    value: function readSource() {
      return $('#wpTextbox1').val();
    }
  }, {
    key: 'writeSource',
    value: function writeSource(text) {
      return $('#wpTextbox1').val(text);
    }
  }, {
    key: 'readSummary',
    value: function readSummary() {
      return $('#wpSummary').val();
    }
  }, {
    key: 'writeSummary',
    value: function writeSummary(text) {
      return $('#wpSummary').val(text);
    }
  }, {
    key: 'appendToSummary',
    value: function appendToSummary(text) {
      return $('#wpSummary').val(this.readSummary() + text);
    }
  }]);

  return exports;
}();

},{}],405:[function(require,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var App;

App = require('../app');

module.exports = function () {
  function exports(WM) {
    _classCallCheck(this, exports);

    this.parseLinks = this.parseLinks.bind(this);
    this.queryLinks = this.queryLinks.bind(this);
    this.createNewLink = this.createNewLink.bind(this);
    this.createVisitedLink = this.createVisitedLink.bind(this);
    this.collectLinks = this.collectLinks.bind(this);
    this._collectLinksContinue = this._collectLinksContinue.bind(this);
    this.updateLinks = this.updateLinks.bind(this);
    this.WM = WM;
  }

  _createClass(exports, [{
    key: "parseLinks",
    value: function parseLinks(supportedLangs, source, iwmap) {
      var i, iw, j, langlinks, len, len1, link, ltag, ltitle, lurl, parsedLinks;
      parsedLinks = this.WM.Parser.findSpecialLinks(source, supportedLangs.join("|"));
      langlinks = [];
      for (i = 0, len = parsedLinks.length; i < len; i++) {
        link = parsedLinks[i];

        ltag = link.namespace;
        ltitle = link.title + (link.fragment ? "#" + link.fragment : "");
        for (j = 0, len1 = iwmap.length; j < len1; j++) {
          iw = iwmap[j];
          if (iw.prefix.toLowerCase() === ltag.toLowerCase()) {
            lurl = this.WM.MW.fixInterwikiUrl(iw.url);
            lurl = lurl.replace("$1", encodeURIComponent(this.WM.Parser.squashContiguousWhitespace(ltitle)));
            break;
          }
        }
        langlinks.push({
          lang: ltag,
          title: ltitle,
          url: lurl,
          index: link.index,
          length: link.length
        });
      }
      return langlinks;
    }
  }, {
    key: "queryLinks",
    value: function queryLinks(queryTitle, title, supportedLangs, whitelist, firstPage, callEnd, callArgs) {
      var _this = this;

      var query;
      query = {
        action: "query",
        prop: "info|revisions",
        rvprop: "content|timestamp",
        intoken: "edit",
        titles: queryTitle,
        meta: "siteinfo",
        siprop: "interwikimap",
        sifilteriw: "local"
      };

      if (!firstPage) {
        query.redirects = "1";
      }
      return this.WM.MW.callAPIGet(query, function (res, args) {
        var edittoken, error, iwmap, langlinks, page, source, timestamp;
        if (res.query.pages) {
          page = Object.values(res.query.pages)[0];
          if (page.revisions) {
            error = null;
            source = page.revisions[0]["*"];
            timestamp = page.revisions[0].timestamp;
            edittoken = page.edittoken;
            iwmap = res.query.interwikimap;
            langlinks = _this.WM.Interlanguage.parseLinks(supportedLangs, source, iwmap);
          } else {
            error = 'nonexisting';
            source = false;
            timestamp = false;
            edittoken = false;
            iwmap = res.query.interwikimap;
            langlinks = false;
          }
        } else if (res.query.redirects) {
          error = 'unsolvedredirect';
          source = false;
          timestamp = false;
          edittoken = false;
          iwmap = res.query.interwikimap;
          langlinks = false;
        } else {
          error = 'unknown';
          source = false;
          timestamp = false;
          edittoken = false;
          iwmap = res.query.interwikimap;
          langlinks = false;
        }
        return callEnd(title, supportedLangs, whitelist, false, error, langlinks, iwmap, source, timestamp, edittoken, args);
      }, callArgs, function (args) {
        return callEnd(title, supportedLangs, whitelist, false, 'unknown', false, false, false, false, false, args);
      });
    }
  }, {
    key: "createNewLink",
    value: function createNewLink(origTag, title, url) {
      return {
        origTag: origTag,
        title: title,
        url: url
      };
    }
  }, {
    key: "createVisitedLink",
    value: function createVisitedLink(origTag, title, url, iwmap, source, timestamp, edittoken, links) {
      var entry, i, len, link;
      entry = {
        origTag: origTag,
        title: title,
        url: url,
        iwmap: iwmap,
        source: source,
        timestamp: timestamp,
        edittoken: edittoken,
        links: []
      };
      for (i = 0, len = links.length; i < len; i++) {
        link = links[i];
        entry.links.push(link);
      }
      return entry;
    }
  }, {
    key: "collectLinks",
    value: function collectLinks(visitedlinks, newlinks, supportedLangs, whitelist, firstPage, callEnd, callArgs) {
      var link, origTag, queryTitle, tag, title, url;
      for (tag in newlinks) {
        link = newlinks[tag];
        break;
      }
      if (link) {
        delete newlinks[tag];
        url = link.url;

        queryTitle = decodeURIComponent(this.WM.MW.getTitleFromWikiUrl(url));
        if (queryTitle) {
          origTag = link.origTag;
          title = link.title;

          if (firstPage || whitelist.indexOf(tag) > -1) {
            App.log.logInfo("Reading " + App.log.linkToPage(url, "[[" + origTag + ":" + title + "]]") + " ...");
            return this.queryLinks(queryTitle, title, supportedLangs, whitelist, firstPage, this.WM.Interlanguage._collectLinksContinue, [url, tag, origTag, visitedlinks, newlinks, callEnd, callArgs]);
          } else {
            return this.WM.Interlanguage._collectLinksContinue(title, supportedLangs, whitelist, firstPage, 'notinwhitelist', [], false, null, null, null, [url, tag, origTag, visitedlinks, newlinks, callEnd, callArgs]);
          }
        } else {
          App.log.logWarning("Cannot extract the page title from " + App.log.linkToPage(url, decodeURI(url)) + ", removing it if it was linked from the processed article");
          return this.WM.Interlanguage.collectLinks(visitedlinks, newlinks, supportedLangs, whitelist, firstPage, callEnd, callArgs);
        }
      } else {
        return callEnd(visitedlinks, callArgs);
      }
    }
  }, {
    key: "_collectLinksContinue",
    value: function _collectLinksContinue(title, supportedLangs, whitelist, firstPage, error, langlinks, iwmap, source, timestamp, edittoken, args) {
      var callArgs, callEnd, i, len, link, newlinks, nlink, origTag, tag, url, visitedlinks, vlink;
      url = args[0];
      tag = args[1];
      origTag = args[2];
      visitedlinks = args[3];
      newlinks = args[4];
      callEnd = args[5];
      callArgs = args[6];
      if (error === 'nonexisting') {
        App.log.logWarning(App.log.linkToPage(url, "[[" + origTag + ":" + title + "]]") + " seems to point to a non-existing article: removing it if it was linked from the processed article");
      } else {
        if (error === 'unsolvedredirect') {
          App.log.logWarning(App.log.linkToPage(url, "[[" + origTag + ":" + title + "]]") + " will not be checked because it points to an external redirect");
        } else if (error === 'unknown') {
          App.log.logWarning(App.log.linkToPage(url, "[[" + origTag + ":" + title + "]]") + " will not be checked because of an unspecified problem");
        } else if (error === 'notinwhitelist') {
          App.log.logWarning(App.log.linkToPage(url, "[[" + origTag + ":" + title + "]]") + " will not be checked because " + tag + " is not included in the whitelist defined in the configuration");
        }
        visitedlinks[tag] = this.WM.Interlanguage.createVisitedLink(origTag, title, url, iwmap, source, timestamp, edittoken, langlinks);
        for (i = 0, len = langlinks.length; i < len; i++) {
          link = langlinks[i];
          nlink = newlinks[link.lang.toLowerCase()];
          vlink = visitedlinks[link.lang.toLowerCase()];
          if (!vlink && !nlink) {
            newlinks[link.lang.toLowerCase()] = this.WM.Interlanguage.createNewLink(link.lang, link.title, link.url);
          } else if (vlink && vlink.url !== link.url) {
            App.log.logWarning("Possibly conflicting interlanguage links: " + App.log.linkToPage(link.url, "[[" + link.lang + ":" + link.title + "]]") + " and " + App.log.linkToPage(vlink.url, "[[" + link.lang + ":" + visitedlinks[link.lang.toLowerCase()].title + "]]"));
          } else if (nlink && nlink.url !== link.url) {
            App.log.logWarning("Possibly conflicting interlanguage links: " + App.log.linkToPage(link.url, "[[" + link.lang + ":" + link.title + "]]") + " and " + App.log.linkToPage(nlink.url, "[[" + link.lang + ":" + newlinks[link.lang.toLowerCase()].title + "]]"));
          }
        }
      }
      return this.WM.Interlanguage.collectLinks(visitedlinks, newlinks, supportedLangs, whitelist, firstPage, callEnd, callArgs);
    }
  }, {
    key: "updateLinks",
    value: function updateLinks(lang, url, iwmap, source, oldlinks, newlinks) {
      var body, cleanText, firstLink, head, i, iw, j, len, len1, link, linkList, links, parts, tag, tagFound, textId, trailws;
      lang = lang.toLowerCase();
      linkList = [];
      for (tag in newlinks) {
        if (tag !== lang) {
          link = newlinks[tag];
          tagFound = false;

          for (i = 0, len = iwmap.length; i < len; i++) {
            iw = iwmap[i];
            if (iw.prefix.toLowerCase() === tag.toLowerCase()) {
              linkList.push("[[" + link.origTag + ":" + link.title + "]]");
              tagFound = true;
              break;
            }
          }
          if (!tagFound) {
            App.log.logWarning(tag + " interlanguage links are not supported in " + App.log.linkToPage(url, "[[" + link.origTag + ":" + link.title + "]]") + " , ignoring them");
          }
        }
      }
      linkList.sort(function (a, b) {
        if (a.toLowerCase() > b.toLowerCase()) {
          return 1;
        }
        if (b.toLowerCase() > a.toLowerCase()) {
          return -1;
        } else {
          return 0;
        }
      });
      cleanText = "";
      textId = 0;
      for (j = 0, len1 = oldlinks.length; j < len1; j++) {
        link = oldlinks[j];
        cleanText += source.substring(textId, link.index);
        textId = link.index + link.length;
      }
      cleanText += source.substring(textId);
      if (oldlinks.length) {
        firstLink = oldlinks[0].index;
      } else {
        firstLink = 0;
      }
      parts = [];

      head = cleanText.substring(0, firstLink).trim();
      if (head) {
        parts.push(head);
      }
      links = linkList.join("\n");
      if (links) {
        parts.push(links);
      }
      body = cleanText.substr(firstLink).trim();
      if (body) {
        parts.push(body);
      }

      trailws = /\s*$/;
      return parts.join("\n") + trailws.exec(source);
    }
  }]);

  return exports;
}();

},{"../app":399}],406:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var A, App;

var _require = require('./libs');

A = _require.A;


App = require('../app');

module.exports = function () {
  var interwikiFixes, localWikiPaths, localWikiUrls, wikiPaths;

  var exports = function () {
    function exports(WM) {
      _classCallCheck(this, exports);

      var hostname, key, wpaths;
      this.WM = WM;
      this.api = new mw.Api();
      wpaths = this._getWikiPaths(location.href);
      hostname = wpaths[0];
      this.userInfo = null;
      localWikiPaths = wpaths[1];
      localWikiUrls = {};
      for (key in localWikiPaths) {
        localWikiUrls[key] = hostname + localWikiPaths[key];
      }
    }

    _createClass(exports, [{
      key: '_getWikiPaths',
      value: function _getWikiPaths(href) {
        var hostname, match, p, paths, r, re, uri;

        for (r in wikiPaths.known) {
          re = new RegExp(r, "i");
          match = re.exec(href);
          if (match) {
            hostname = match[0];
            paths = {};
            for (p in wikiPaths.known[r]) {
              paths[p] = wikiPaths.known[r][p];
            }
            break;
          }
        }
        if (!paths) {
          uri = new mw.Uri(href);
          hostname = uri.host;
          paths = {};
          for (p in wikiPaths.default_) {
            paths[p] = wikiPaths.default_[p];
          }
        }
        return [hostname, paths];
      }
    }, {
      key: 'getWikiPaths',
      value: function getWikiPaths(href) {
        if (href) {
          return this._getWikiPaths(href)[1];
        } else {
          return localWikiPaths;
        }
      }
    }, {
      key: 'linkArticle',
      value: function linkArticle(page, label) {
        return A({
          href: mw.util.getUrl(page)
        }, label || page);
      }
    }, {
      key: 'getWikiUrls',
      value: function getWikiUrls(href) {
        var hostname, key, paths, urls, wpaths;
        if (href) {
          wpaths = this._getWikiPaths(href);
          hostname = wpaths[0];
          paths = wpaths[1];
          urls = {};
          for (key in paths) {
            urls[key] = hostname + paths[key];
          }
          return urls;
        } else {
          return localWikiUrls;
        }
      }
    }, {
      key: 'getTitleFromWikiUrl',
      value: function getTitleFromWikiUrl(url) {
        var match, pathname, r, re, title, uri;
        uri = new mw.Uri(url);
        title = uri.query.title;

        if (!title) {
          pathname = uri.path;
          for (r in wikiPaths.known) {
            re = new RegExp(r, "i");
            match = re.exec(url);
            if (match) {
              if (pathname.indexOf(wikiPaths.known[r].short) === 0) {
                title = pathname.substr(wikiPaths.known[r].short.length);
              } else {
                title = false;
              }
              break;
            }
          }
          if (!title) {
            if (pathname.indexOf(wikiPaths.default_.short) === 0) {
              title = pathname.substr(wikiPaths.default_.short.length);
            } else {
              title = false;
            }
          }
        }
        return title;
      }
    }, {
      key: 'failedQueryError',
      value: function failedQueryError(url) {
        if (url) {
          return 'Failed query: ' + App.log.linkToPage(url, url);
        }
        return "Failed query";
      }
    }, {
      key: 'callAPIGet',
      value: function callAPIGet(params, call, callArgs, callError) {
        var _this = this;

        params.format = "json";
        return this.api.get(params).done(function (data, textStatus, jqXHR) {
          if (call) {
            return call(data, callArgs);
          }
        }).fail(function (jqXHR, textStatus, errorThrown) {
          console.error(jqXHR, textStatus, errorThrown);
          App.log.logError(_this.failedQueryError());
          if (confirm("Wiki Monkey error: Failed query\n\nDo you want " + "to retry?")) {
            App.log.logInfo("Retrying ...");
            return _this.callAPIGet(params, call, callArgs, callError);
          } else if (callError) {
            return callError(callArgs);
          }
        });
      }
    }, {
      key: 'callAPIPost',
      value: function callAPIPost(params, call, callArgs, callError) {
        var _this2 = this;

        params.format = "json";
        return this.api.post(params).done(function (data, textStatus, jqXHR) {
          if (call) {
            return call(data, callArgs);
          }
        }).fail(function (jqXHR, textStatus, errorThrown) {
          console.error(jqXHR, textStatus, errorThrown);
          App.log.logError(_this2.failedQueryError());
          if (confirm("Wiki Monkey error: Failed query\n\nDo you want " + "to retry?")) {
            App.log.logInfo("Retrying ...");
            return _this2.callAPIPost(params, call, callArgs, callError);
          } else if (callError) {
            return callError(callArgs);
          }
        });
      }
    }, {
      key: 'callQuery',
      value: function () {
        var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(params, call, callArgs, callError) {
          var error, page, res;
          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  params.action = "query";
                  _context.prev = 1;
                  _context.next = 4;
                  return this.callAPIGet(params);

                case 4:
                  res = _context.sent;
                  _context.next = 13;
                  break;

                case 7:
                  _context.prev = 7;
                  _context.t0 = _context['catch'](1);

                  error = _context.t0;

                  if (!callError) {
                    _context.next = 12;
                    break;
                  }

                  return _context.abrupt('return', callError(callArgs));

                case 12:
                  throw error;

                case 13:
                  page = Object.values(res.query.pages)[0];

                  if (!call) {
                    _context.next = 16;
                    break;
                  }

                  return _context.abrupt('return', call(page, callArgs));

                case 16:
                  return _context.abrupt('return', page);

                case 17:
                case 'end':
                  return _context.stop();
              }
            }
          }, _callee, this, [[1, 7]]);
        }));

        function callQuery(_x, _x2, _x3, _x4) {
          return _ref.apply(this, arguments);
        }

        return callQuery;
      }()
    }, {
      key: 'callQueryEdit',
      value: function () {
        var _ref2 = _asyncToGenerator(regeneratorRuntime.mark(function _callee2(title, call, callArgs) {
          var edittoken, page, source, timestamp;
          return regeneratorRuntime.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  _context2.next = 2;
                  return this.callQuery({
                    prop: "info|revisions",
                    rvprop: "content|timestamp",
                    intoken: "edit",
                    titles: title
                  });

                case 2:
                  page = _context2.sent;

                  source = page.revisions[0]["*"];
                  timestamp = page.revisions[0].timestamp;
                  edittoken = page.edittoken;

                  if (!call) {
                    _context2.next = 8;
                    break;
                  }

                  return _context2.abrupt('return', call(title, source, timestamp, edittoken, callArgs));

                case 8:
                  return _context2.abrupt('return', { source: source, timestamp: timestamp, edittoken: edittoken });

                case 9:
                case 'end':
                  return _context2.stop();
              }
            }
          }, _callee2, this);
        }));

        function callQueryEdit(_x5, _x6, _x7) {
          return _ref2.apply(this, arguments);
        }

        return callQueryEdit;
      }()
    }, {
      key: 'getUserInfo',
      value: function getUserInfo(call) {
        var _this3 = this;

        var pars, storeInfo;
        storeInfo = function storeInfo(res, call) {
          _this3.userInfo = res;
          return call();
        };
        if (!this.userInfo) {
          pars = {
            action: "query",
            meta: "userinfo",
            uiprop: "groups"
          };
          return this.callAPIGet(pars, storeInfo, call, null);
        } else {
          return call();
        }
      }
    }, {
      key: 'isLoggedIn',
      value: function isLoggedIn(call, args) {
        var _this4 = this;

        return this.getUserInfo(function () {
          var test;
          test = _this4.userInfo.query.userinfo.id !== 0;
          return call(test, args);
        });
      }
    }, {
      key: 'getUserName',
      value: function getUserName(call, args) {
        var _this5 = this;

        return this.getUserInfo(function () {
          return call(_this5.userInfo.query.userinfo.name, args);
        });
      }
    }, {
      key: 'isUserBot',
      value: function isUserBot(call, args) {
        var _this6 = this;

        return this.getUserInfo(function () {
          var groups, res;
          groups = _this6.userInfo.query.userinfo.groups;
          res = groups.indexOf("bot") > -1;
          return call(res, args);
        });
      }
    }, {
      key: 'getBacklinks',
      value: function getBacklinks(bltitle, blnamespace, call, callArgs) {
        var query;
        query = {
          action: "query",
          list: "backlinks",
          bltitle: bltitle,
          bllimit: 500
        };
        if (blnamespace) {
          query.blnamespace = blnamespace;
        }
        return this._getBacklinksContinue(query, call, callArgs, []);
      }
    }, {
      key: '_getBacklinksContinue',
      value: function _getBacklinksContinue(query, call, callArgs, backlinks) {
        var _this7 = this;

        return this.callAPIGet(query, function (res, args) {
          backlinks = backlinks.concat(res.query.backlinks);
          if (res["query-continue"]) {
            query.blcontinue = res["query-continue"].backlinks.blcontinue;
            return _this7._getBacklinksContinue(query, call, args, backlinks);
          } else {
            return call(backlinks, args);
          }
        }, callArgs, null);
      }
    }, {
      key: 'getLanglinks',
      value: function getLanglinks(title, iwmap, call, callArgs) {
        var query;
        query = {
          action: "query",
          prop: "langlinks",
          titles: title,
          lllimit: 500,
          llurl: "1",
          redirects: "1"
        };
        if (iwmap) {
          query.meta = "siteinfo";
          query.siprop = "interwikimap";
          query.sifilteriw = "local";
        }
        return this._getLanglinksContinue(query, call, callArgs, [], null);
      }
    }, {
      key: '_getLanglinksContinue',
      value: function _getLanglinksContinue(query, call, callArgs, langlinks, iwmap) {
        var _this8 = this;

        return this.callAPIGet(query, function (res, args) {
          var page;
          page = Object.values(res.query.pages)[0];
          langlinks = langlinks.concat(page.langlinks);
          if (res.query.interwikimap) {
            iwmap = res.query.interwikimap;
          }
          if (query.meta) {
            delete query.meta;
            delete query.siprop;
            delete query.sifilteriw;
          }
          if (res["query-continue"]) {
            query.llcontinue = res["query-continue"].langlinks.llcontinue;
            return _this8._getLanglinksContinue(query, call, args, langlinks, iwmap);
          } else {
            return call(langlinks, iwmap, args);
          }
        }, callArgs, null);
      }
    }, {
      key: 'getInterwikiMap',
      value: function getInterwikiMap(title) {
        return this.callAPIGet({
          action: "query",
          meta: "siteinfo",
          siprop: "interwikimap"
        });
      }
    }, {
      key: 'getLocalInterwikiMap',
      value: function getLocalInterwikiMap(title, call, callArgs) {
        return this.callAPIGet({
          action: "query",
          meta: "siteinfo",
          siprop: "interwikimap",
          sifilteriw: "local"
        }, function (res, args) {
          return call(res.query.interwikimap, args);
        }, callArgs, null);
      }
    }, {
      key: 'fixInterwikiUrl',
      value: function fixInterwikiUrl(url) {
        var f, furl, i, ref;
        for (f = i = 0, ref = interwikiFixes.length; 0 <= ref ? i < ref : i > ref; f = 0 <= ref ? ++i : --i) {
          furl = url.replace(interwikiFixes[f][0], interwikiFixes[f][1]);
          if (furl !== url) {
            return furl;
          }
        }

        return url;
      }
    }, {
      key: 'getSpecialList',
      value: function () {
        var _ref3 = _asyncToGenerator(regeneratorRuntime.mark(function _callee3(qppage, siprop) {
          var info, key, query, ref, res, results, siteinfo;
          return regeneratorRuntime.wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  query = {
                    action: "query",
                    list: "querypage",
                    qppage: qppage,
                    qplimit: 500
                  };
                  if (siprop) {
                    query.meta = "siteinfo";
                    query.siprop = siprop;
                  }
                  results = [];
                  siteinfo = {};

                case 4:
                  if (!true) {
                    _context3.next = 19;
                    break;
                  }

                  _context3.next = 7;
                  return this.callAPIGet(query);

                case 7:
                  res = _context3.sent;

                  results = results.concat(res.query.querypage.results);
                  ref = res.query;
                  for (key in ref) {
                    info = ref[key];
                    if (key !== "querypage") {
                      siteinfo[key] = info;
                    }
                  }
                  delete query.meta;
                  delete query.siprop;

                  if (!res["query-continue"]) {
                    _context3.next = 16;
                    break;
                  }

                  query.qpoffset = res["query-continue"].querypage.qpoffset;
                  return _context3.abrupt('continue', 4);

                case 16:
                  return _context3.abrupt('return', { results: results, siteinfo: siteinfo });

                case 19:
                case 'end':
                  return _context3.stop();
              }
            }
          }, _callee3, this);
        }));

        function getSpecialList(_x8, _x9) {
          return _ref3.apply(this, arguments);
        }

        return getSpecialList;
      }()
    }, {
      key: 'getUserContribs',
      value: function getUserContribs(ucuser, ucstart, ucend, call, callArgs) {
        var query;
        query = {
          action: "query",
          list: "usercontribs",
          ucuser: ucuser,
          ucprop: "",
          ucstart: ucstart,
          ucend: ucend,
          uclimit: 500
        };
        return this._getUserContribsContinue(query, call, callArgs, []);
      }
    }, {
      key: '_getUserContribsContinue',
      value: function _getUserContribsContinue(query, call, callArgs, results) {
        var _this9 = this;

        return this.callAPIGet(query, function (res, args) {
          results = results.concat(res.query.usercontribs);
          if (res["query-continue"]) {
            query.uccontinue = res["query-continue"].usercontribs.uccontinue;
            return _this9._getUserContribsContinue(query, call, args, results);
          } else {
            return call(results, args);
          }
        }, callArgs, null);
      }
    }]);

    return exports;
  }();

  ;

  localWikiPaths = null;

  localWikiUrls = null;

  wikiPaths = {
    known: {
      "^https?://[^\.]+\.wikipedia\.org": {
        short: "/wiki/",
        full: "/w/index.php",
        api: "/w/api.php"
      },
      "^https?://wiki\.archlinux\.org": {
        short: "/index.php/",
        full: "/index.php",
        api: "/api.php"
      },
      "^https?://wiki\.archlinux\.de": {
        short: "/title/",
        full: "/index.php",
        api: "/api.php"
      },
      "^http://wiki\.archlinux\.fr": {
        short: "/",
        full: "/index.php",
        api: "/api.php"
      },
      "^https?://wiki\.archlinux\.jp": {
        short: "/index.php/",
        full: "/index.php",
        api: "/api.php"
      },
      "^http://wiki\.archlinux\.ro": {
        short: "/index.php/",
        full: "/index.php",
        api: "/api.php"
      },
      "^http://wiki\.archlinux\.ir": {
        short: "/index.php/",
        full: "/index.php",
        api: "/api.php"
      }
    },
    default_: {
      short: "/index.php?title=",
      full: "/index.php",
      api: "/api.php"
    }
  };

  interwikiFixes = [["https://wiki.archlinux.org/index.php/$1_(", "https://wiki.archlinux.org/index.php/$1%20("]];

  return exports;
}.call(undefined);

},{"../app":399,"./libs":412}],407:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var App, RegEx, Str;

RegEx = require('@kynikos/misc/dist/RegEx');

Str = require('@kynikos/misc/dist/Str');

App = require('../app');

module.exports = function () {
  var prepareRegexpWhitespace, prepareTitleCasing;

  var exports = function () {
    function exports(WM) {
      _classCallCheck(this, exports);

      this.WM = WM;
    }

    _createClass(exports, [{
      key: 'squashContiguousWhitespace',
      value: function squashContiguousWhitespace(title) {
        return title.replace(/[_ ]+/g, " ");
      }
    }, {
      key: 'neutralizeNowikiTags',
      value: function neutralizeNowikiTags(source) {
        var CLOSELENGTH, OPENLENGTH, i, len, maskLength, maskString, maskedText, prevId, tag, tags;

        OPENLENGTH = 8;
        CLOSELENGTH = 9;
        tags = Str.findSimpleEnclosures(source, /<nowiki>/i, OPENLENGTH, /<\/nowiki>/i, CLOSELENGTH);
        maskedText = "";
        prevId = 0;
        for (i = 0, len = tags.length; i < len; i++) {
          tag = tags[i];
          if (tag[1]) {
            maskLength = tag[1] - tag[0] + CLOSELENGTH;
            maskString = Str.padRight("", "x", maskLength);
            maskedText += source.substring(prevId, tag[0]) + maskString;
            prevId = tag[1] + CLOSELENGTH;
            continue;
          } else {
            maskLength = source.substr(tag[0]).length;
            maskString = Str.padRight("", "x", maskLength);
            maskedText += source.substring(prevId, tag[0]) + maskString;
            prevId = source.length;
            break;
          }
        }
        maskedText += source.substring(prevId);
        return maskedText;
      }
    }, {
      key: 'dotEncode',
      value: function dotEncode(text) {
        return encodeURIComponent(text).replace(/%/g, ".");
      }
    }, {
      key: 'dotEncodeLinkBreakingFragmentCharacters',
      value: function dotEncodeLinkBreakingFragmentCharacters(fragment) {
        fragment = fragment.replace(/\[/g, ".5B");
        fragment = fragment.replace(/\]/g, ".5D");
        fragment = fragment.replace(/\{/g, ".7B");
        fragment = fragment.replace(/\}/g, ".7D");
        fragment = fragment.replace(/\|/g, ".7C");
        return fragment;
      }
    }, {
      key: 'compareArticleTitles',
      value: function compareArticleTitles(title1, title2) {
        var t1, t2;

        t1 = prepareTitleCasing(this.squashContiguousWhitespace(title1).trim());
        t2 = prepareTitleCasing(this.squashContiguousWhitespace(title2).trim());
        return t1 === t2;
      }
    }, {
      key: 'findBehaviorSwitches',
      value: function findBehaviorSwitches(source, word) {
        var regExp;
        source = this.neutralizeNowikiTags(source);
        regExp;
        if (word) {
          regExp = new RegExp("__" + mw.RegExp.escape(word) + "__", "gi");
        } else {
          regExp = new RegExp("__(TOC|NOTOC|FORCETOC|NOEDITSECTION|" + "NEWSECTIONLINK|NONEWSECTIONLINK|NOGALLERY|HIDDENCAT|" + "NOCONTENTCONVERT|NOCC|NOTITLECONVERT|NOTC|INDEX|" + "NOINDEX|STATICREDIRECT|START|END)__", "gi");
        }
        return RegEx.matchAll(source, regExp);
      }
    }, {
      key: 'findLinksEngine',
      value: function findLinksEngine(source, titlePattern, specialOnly, caseSensitive) {
        var dbrace, dbraces, flags, i, inText, len, links, maskedText, match, nSource, nText, push, regExp, special;

        flags = caseSensitive ? "" : "i";

        special = specialOnly ? "(?:[ _]+:)?[ _]*" : "(?:\\:?[ _]*){0,2}";
        regExp = new RegExp("^" + special + "(" + titlePattern + ")" + "[ _]*(?:\\|[_\\s]*([\\s\\S]+?)[_\\s]*)?[_\\s]*$", flags);
        nSource = this.neutralizeNowikiTags(source);
        links = [];
        dbraces = Str.findInnermostEnclosures(nSource, "[[", "]]");
        for (i = 0, len = dbraces.length; i < len; i++) {
          dbrace = dbraces[i];
          inText = source.substring(dbrace[0] + 2, dbrace[1]);
          match = regExp.exec(inText);
          if (match) {
            push = true;
            if (match[6]) {
              nText = this.neutralizeNowikiTags(match[6]);
              maskedText = Str.findNestedEnclosures(nText, "{{", "}}", "x")[1];
              if (maskedText.search(/(\{\{|\}\})/) > -1) {
                App.log.logWarning("[[" + match[0] + "]] seems to contain part of a template, and the resulting behaviour cannot be predicted by this function, so the link will be ignored altogether");
                push = false;
              }
            }
            if (push) {
              links.push({
                "rawLink": "[[" + match[0] + "]]",
                "link": match[1],
                "rawTitle": match[2],
                "namespace": match[3],
                "title": match[4],
                "fragment": match[5],
                "anchor": match[6],
                "index": dbrace[0],
                "length": dbrace[1] + 2 - dbrace[0]
              });
            }
          }
        }
        return links;
      }
    }, {
      key: 'findSectionLinks',
      value: function findSectionLinks(source) {
        var fragmentChars, titlePattern;

        fragmentChars = "[^\\n\\{\\}\\[\\]\\|]*?";
        titlePattern = "(()())#(" + fragmentChars + ")";
        return this.findLinksEngine(source, titlePattern, false, true);
      }
    }, {
      key: 'findInternalLinks',
      value: function findInternalLinks(source, namespace, title) {
        var caseSensitive, fragmentChars, namespaceChars, rens, retitle, titleChars, titlePattern;

        namespaceChars = "[^\\n\\{\\}\\[\\]\\|\\:\\#]+?";
        titleChars = "[^\\n\\{\\}\\[\\]\\|\\#]+?";
        fragmentChars = "[^\\n\\{\\}\\[\\]\\|]*?";
        if (namespace) {
          rens = prepareRegexpWhitespace(mw.RegExp.escape(namespace));
          if (title) {
            retitle = prepareRegexpWhitespace(mw.RegExp.escape(title));
            titlePattern = "((" + rens + ")[ _]*:[ _]*" + "(" + retitle + "))" + "(?:[ _]*#(" + fragmentChars + "))?";

            caseSensitive = true;
          } else {
            titlePattern = "((" + rens + ")[ _]*:[ _]*" + "(" + titleChars + "))" + "(?:[ _]*#(" + fragmentChars + "))?";

            caseSensitive = false;
          }
        } else if (title) {
          retitle = prepareRegexpWhitespace(mw.RegExp.escape(title));

          titlePattern = "(()(" + retitle + "))" + "(?:[ _]*#(" + fragmentChars + "))?";

          caseSensitive = true;
        } else {
          titlePattern = "((?:(" + namespaceChars + ")[ _]*:[ _]*)?" + "(" + titleChars + "))" + "(?:[ _]*#(" + fragmentChars + "))?";
          caseSensitive = true;
        }
        return this.findLinksEngine(source, titlePattern, false, caseSensitive);
      }
    }, {
      key: 'findInterwikiLinks',
      value: function findInterwikiLinks(source, wiki) {
        return this.findInternalLinks(source, wiki);
      }
    }, {
      key: 'findSpecialLinks',
      value: function findSpecialLinks(source, pattern) {
        var fragmentChars, titleChars, titlePattern;

        titleChars = "[^\\n\\{\\}\\[\\]\\|\\#]+?";
        fragmentChars = "[^\\n\\{\\}\\[\\]\\|]*?";
        titlePattern = "((" + pattern + ")[ _]*:[ _]*" + "(" + titleChars + "))" + "(?:[ _]*#(" + fragmentChars + "))?";

        return this.findLinksEngine(source, titlePattern, true, false);
      }
    }, {
      key: 'findCategories',
      value: function findCategories(source) {
        return this.findSpecialLinks(source, "Category");
      }
    }, {
      key: 'findInterlanguageLinks',
      value: function findInterlanguageLinks(source, language) {
        return this.findSpecialLinks(source, mw.RegExp.escape(language));
      }
    }, {
      key: 'findVariables',
      value: function findVariables(source, variable) {
        var pattern;

        pattern = mw.RegExp.escape(variable);
        return this.findVariablesPattern(source, pattern);
      }
    }, {
      key: 'findVariablesPattern',
      value: function findVariablesPattern(source, pattern) {
        var dbracket, dbrackets, i, inText, len, match, nSource, regExp, results;

        nSource = this.neutralizeNowikiTags(source);
        results = [];
        dbrackets = Str.findNestedEnclosures(nSource, "{{", "}}", "x")[0];
        for (i = 0, len = dbrackets.length; i < len; i++) {
          dbracket = dbrackets[i];
          inText = source.substring(dbracket[0] + 2, dbracket[1]);

          regExp = new RegExp("^\\s*(" + pattern + ")" + "(?:\\:\\s*([\\s\\S]*?))?\\s*$", "");
          match = regExp.exec(inText);
          if (match) {
            results.push({
              "rawVariable": "{{" + match[0] + "}}",
              "name": match[1],
              "value": match[2],
              "index": dbracket[0],
              "length": dbracket[1] + 2 - dbracket[0]
            });
          }
        }
        return results;
      }
    }, {
      key: 'findTransclusionsEngine',
      value: function findTransclusionsEngine(source, pattern, templatesOnly) {
        var argIndex, dbracket, dbrackets, i, inText, len, match, nSource, regExp, transclusions;

        regExp = new RegExp("^(\\s*" + (templatesOnly ? "" : ":?") + "[_ ]*(" + pattern + ")[_ ]*\\s*)" + "(?:\\|([\\s\\S]*))?$", "");
        nSource = this.neutralizeNowikiTags(source);
        transclusions = [];
        dbrackets = Str.findNestedEnclosures(nSource, "{{", "}}", "x")[0];
        for (i = 0, len = dbrackets.length; i < len; i++) {
          dbracket = dbrackets[i];
          inText = source.substring(dbracket[0] + 2, dbracket[1]);
          match = regExp.exec(inText);
          if (match) {
            argIndex = dbracket[0] + match[1].length + 3;
            transclusions.push({
              "rawTransclusion": "{{" + match[0] + "}}",
              "title": match[2],
              "index": dbracket[0],
              "length": dbracket[1] - dbracket[0] + 2,
              "arguments": this.findTransclusionArguments(match, argIndex)
            });
          }
        }
        return transclusions;
      }
    }, {
      key: 'findTransclusionArguments',
      value: function findTransclusionArguments(match, argIndex) {
        var argL, args, argument, eqIndex, i, key, keyIndex, keyMatches, len, mArgs, mArgument, maskedArgs, nArgs, rawArguments, rawKey, reKey, relIndex, value, valueIndex;
        rawArguments = match[3];
        args = [];
        if (rawArguments) {
          nArgs = this.neutralizeNowikiTags(rawArguments);

          maskedArgs = Str.findNestedEnclosures(nArgs, "[[", "]]", "x")[1];

          maskedArgs = Str.findNestedEnclosures(maskedArgs, "{{", "}}", "x")[1];

          if (maskedArgs.search(/(\{\{|\}\}|\[\[|\]\])/) > -1) {
            App.log.logWarning("{{" + match[0] + "}} seems to contain part of a link or template, and the resulting behaviour cannot be predicted by this function, so the whole template will be ignored altogether");
          } else {
            mArgs = maskedArgs.split("|");
            relIndex = 0;
            for (i = 0, len = mArgs.length; i < len; i++) {
              mArgument = mArgs[i];
              argL = mArgument.length;
              argument = rawArguments.substr(relIndex, argL);
              eqIndex = mArgument.indexOf("=");

              if (eqIndex > 0) {
                rawKey = argument.substring(0, eqIndex);
                reKey = /^(\s*)(.+?)\s*$/;
                keyMatches = reKey.exec(rawKey);
                key = keyMatches[2];
                keyIndex = argIndex + (keyMatches[1] ? keyMatches[1].length : 0);

                value = argument.substr(eqIndex + 1);
                valueIndex = argIndex + keyMatches[0].length + 1;
              } else {
                key = null;
                keyIndex = null;
                value = argument;
                valueIndex = argIndex;
              }
              args.push({
                key: key,
                key_index: keyIndex,
                value: value,
                value_index: valueIndex
              });

              relIndex += argL + 1;
            }
          }
        }
        return args;
      }
    }, {
      key: 'findTemplates',
      value: function findTemplates(source, template) {
        var pattern;
        if (template) {
          pattern = mw.RegExp.escape(template);
          pattern = prepareRegexpWhitespace(pattern);
          pattern = prepareTitleCasing(pattern);
        } else {
          pattern = "[^\\n\\{\\}\\[\\]\\||\\#]+?";
        }
        return this.findTemplatesPattern(source, pattern);
      }
    }, {
      key: 'findTemplatesPattern',
      value: function findTemplatesPattern(source, pattern) {
        return this.findTransclusionsEngine(source, pattern, true);
      }
    }, {
      key: 'findTransclusions',
      value: function findTransclusions(source, namespace, title) {
        var namespacePattern, pattern, titleChars, titlePattern;

        titleChars = "[^\\n\\{\\}\\[\\]\\||\\#]+?";
        if (namespace) {
          namespacePattern = mw.RegExp.escape(namespace);
          namespacePattern = prepareRegexpWhitespace(namespacePattern);
          namespacePattern = prepareTitleCasing(namespacePattern);
        }
        if (title) {
          titlePattern = mw.RegExp.escape(title);
          titlePattern = prepareRegexpWhitespace(titlePattern);
          titlePattern = prepareTitleCasing(titlePattern);
        }
        if (namespacePattern && titlePattern) {
          pattern = namespacePattern + "[ _]*:[ _]*" + titlePattern;
        } else if (!namespacePattern && titlePattern) {
          pattern = titlePattern;
        } else if (namespacePattern && !titlePattern) {
          pattern = namespacePattern + "[ _]*:" + titleChars;
        } else {
          pattern = titleChars;
        }
        return this.findTransclusionsEngine(source, pattern, false);
      }
    }, {
      key: 'findSectionHeadings',
      value: function findSectionHeadings(source) {
        var L0, L1, MAXLEVEL, cleanheading, end, heading, i, len, level, line, match, maxTocLevel, minLevel, pLevel, prevLevels, rawheading, regExp, sections, start, tocLevel, tocPeer;

        MAXLEVEL = 6;
        sections = [];
        minLevel = MAXLEVEL;
        maxTocLevel = 0;
        tocLevel = 1;
        regExp = /^(\=+([ _]*(.+?)[ _]*)\=+)[ \t]*$/gm;
        while (true) {
          match = regExp.exec(source);
          if (match) {
            L0 = match[0].length;
            line = match[1];
            rawheading = match[2];
            heading = match[3];
            cleanheading = this.squashContiguousWhitespace(heading);
            L1 = line.length;
            level = 1;
            start = "=";
            end = "=";

            while (true) {
              start = line.substr(level, 1);
              end = line.substr(L1 - level - 1, 1);
              if (L1 - level * 2 > 2 && start === "=" && end === "=") {
                level++;
              } else {
                if (level > MAXLEVEL) {
                  level = MAXLEVEL;
                } else if (level < minLevel) {
                  minLevel = level;
                }
                break;
              }
            }
            if (level === minLevel) {
              tocLevel = 1;
              prevLevels = {};
              prevLevels[level] = 1;
              prevLevels.relMax = level;
              if (maxTocLevel === 0) {
                maxTocLevel = tocLevel;
              }
            } else if (level > prevLevels.relMax) {
              tocLevel++;
              prevLevels[level] = tocLevel;
              prevLevels.relMax = level;
              if (tocLevel > maxTocLevel) {
                maxTocLevel = tocLevel;
              }
            } else if (level < prevLevels.relMax) {
              if (prevLevels[level]) {
                tocLevel = prevLevels[level];
              } else {
                tocPeer = prevLevels.relMax;
                for (i = 0, len = prevLevels.length; i < len; i++) {
                  pLevel = prevLevels[i];
                  if (pLevel > level && pLevel < tocPeer) {
                    tocPeer = pLevel;
                  }
                }
                tocLevel = prevLevels[tocPeer];
                prevLevels[level] = tocLevel;
              }
              prevLevels.relMax = level;
            }
            sections.push({
              line: line,
              rawheading: rawheading,
              heading: heading,
              cleanheading: cleanheading,
              level: level,
              tocLevel: tocLevel,
              index: regExp.lastIndex - L0,
              length0: L0,
              length1: L1
            });
          } else {
            break;
          }
        }

        if (maxTocLevel === 0) {
          minLevel = 0;
        }
        return {
          sections: sections,
          minLevel: minLevel,
          maxTocLevel: maxTocLevel
        };
      }
    }]);

    return exports;
  }();

  ;

  prepareRegexpWhitespace = function prepareRegexpWhitespace(title) {
    return title.replace(/[_ ]+/g, "[_ ]+");
  };

  prepareTitleCasing = function prepareTitleCasing(pattern) {
    var fcLower, fcUpper, firstChar;
    firstChar = pattern.charAt(0);
    fcUpper = firstChar.toUpperCase();
    fcLower = firstChar.toLowerCase();
    if (fcUpper !== fcLower) {
      pattern = "[" + fcUpper + fcLower + "]" + pattern.substr(1);
    }
    return pattern;
  };

  return exports;
}.call(undefined);

},{"../app":399,"@kynikos/misc/dist/RegEx":2,"@kynikos/misc/dist/Str":3}],408:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Str;

Str = require('@kynikos/misc/dist/Str');

module.exports = function () {
  function exports(WM) {
    _classCallCheck(this, exports);

    this.WM = WM;
  }

  _createClass(exports, [{
    key: 'appendRow',
    value: function appendRow(source, mark, values) {
      var endtable, lastId, newText, row;
      lastId = source.lastIndexOf('|}' + mark);
      endtable = lastId > -1 ? lastId : source.lastIndexOf('|}');
      row = "|-\n|" + values.join("\n|") + "\n";
      newText = Str.insert(source, row, endtable);
      return newText;
    }
  }]);

  return exports;
}();

},{"@kynikos/misc/dist/Str":3}],409:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var A,
    Br,
    Div,
    WM,
    moment,
    version,
    indexOf = [].indexOf;

var _require = require('./libs');

moment = _require.moment;
A = _require.A;
Br = _require.Br;
Div = _require.Div;

var _require2 = require('../../package.json');

version = _require2.version;


WM = require('./index');

module.exports = function () {
  var REPO_RAW_URL;

  var exports = function () {
    function exports(WM1) {
      _classCallCheck(this, exports);

      this.WM = WM1;
      this.check_obsolete_config();
      if (WM.conf.update_check_wdays) {
        this.check_and_notify();
      }
    }

    _createClass(exports, [{
      key: 'check_and_notify',
      value: function () {
        var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
          var _this = this;

          var upstream_package;
          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  if (!this.should_check()) {
                    _context.next = 9;
                    break;
                  }

                  _context.next = 3;
                  return $.getJSON(REPO_RAW_URL + '/' + WM.conf.update_check_branch + '/package.json');

                case 3:
                  upstream_package = _context.sent;

                  if (!(version !== upstream_package.version)) {
                    _context.next = 8;
                    break;
                  }

                  return _context.abrupt('return', this.display_notification(['Version ' + upstream_package.version + ' is available.', Br(), A({
                    href: "https://github.com/kynikos/wiki-monkey/wiki/Changelog" }, "Changelog"), Br(), A('Run upgrade', {
                    onclick: function onclick() {
                      return _this.upgrade(upstream_package.version);
                    }
                  })]));

                case 8:
                  return _context.abrupt('return', mw.storage.set('WikiMonkey-last-update-check', moment().format('YYYY-MM-DD')));

                case 9:
                case 'end':
                  return _context.stop();
              }
            }
          }, _callee, this);
        }));

        function check_and_notify() {
          return _ref.apply(this, arguments);
        }

        return check_and_notify;
      }()
    }, {
      key: 'should_check',
      value: function should_check() {
        var diff, lastupdcheck, ref;
        lastupdcheck = mw.storage.get('WikiMonkey-last-update-check');
        if (!lastupdcheck) {
          return true;
        }
        diff = moment().diff(moment(lastupdcheck), 'days');

        if (diff >= 1 && (ref = moment().day(), indexOf.call(WM.conf.update_check_wdays, ref) >= 0) || diff >= 7) {
          return true;
        }
        return false;
      }
    }, {
      key: 'display_notification',
      value: function display_notification(content, optionsoverride) {
        var options;
        options = {
          autoHide: false,
          tag: 'WikiMonkey-upgrade',
          title: 'Wiki Monkey',
          type: 'info'
        };
        $.extend(options, optionsoverride);
        return mw.notification.notify(content, options);
      }
    }, {
      key: 'upgrade',
      value: function upgrade(upstream_version) {
        var _this2 = this;

        var page, pagelink, regex;
        page = 'User:' + mw.user.getName() + '/common.js';
        pagelink = this.WM.MW.linkArticle(page);
        this.display_notification('Upgrading to version ' + upstream_version + '...');

        regex = RegExp('(["\']https?://.+?/kynikos/wiki-monkey/v)' + mw.RegExp.escape(version) + '(/dist/WikiMonkey-[^/]+\\.js["\'])', "g");
        return this.WM.MW.api.edit(page, function (revision) {
          var newtext;
          newtext = revision.content.replace(regex, '$1' + upstream_version + '$2');
          if (newtext === revision.content) {
            return Promise.reject(new Error("Could not find Wiki Monkey loader line"));
          }
          return {
            text: newtext,
            summary: 'Update Wiki Monkey to version ' + upstream_version,
            bot: true
          };
        }).done(function (result) {
          console.log(result);
          return _this2.display_notification(["Upgrade successful: you need to refresh the open wiki page(s) in order to use the new version.", Br(), A({
            href: "https://github.com/kynikos/wiki-monkey/wiki/Changelog"
          }, "Changelog")]);
        }).fail(function (code, error) {
          console.error(code, error);
          return _this2.display_notification(['Could not complete the upgrade to version ' + upstream_version + ': ', A({
            onclick: function onclick() {
              return _this2.upgrade(upstream_version);
            }
          }, "retry"), " in case it was a temporary problem; it is also possible that Wiki Monkey is installed in a non-standard way in ", pagelink, " and the upgrade should be executed manually; finally, it is possible that the upgrade was already launched and completed from another page: in this case refresh the page to verify."], {
            type: 'error'
          });
        });
      }
    }, {
      key: 'check_obsolete_config',
      value: function check_obsolete_config() {
        var _this3 = this;

        var blob, confhref, oldconf;

        oldconf = localStorage.getItem("WikiMonkey");
        if (oldconf !== null) {
          blob = new Blob([oldconf], {
            type: 'application/json'
          });
          confhref = window.URL.createObjectURL(blob);
          return this.display_notification(["Wiki Monkey 4.0.0 uses a completely rewritten configuration system. After updating, your old configuration was not automatically imported, but it is still saved in your browser's localStorage. You can decide to export it and then merge it manually, or simply remove it and use the default configuration options.", Br(), A({
            href: "https://github.com/kynikos/wiki-monkey/wiki/Configuration" }, "New configuration instructions"), Br(), A({
            href: confhref
          }, "View old configuration"), Br(), A({
            href: confhref,
            download: "wikimonkey_oldconf.json"
          }, "Export old configuration"), Br(), A({
            onclick: function onclick() {
              localStorage.removeItem("WikiMonkey");
              return _this3.display_notification("The old configuration was successfully removed.", {
                autoHide: true
              });
            }
          }, "Delete old configuration")]);
        }
      }
    }]);

    return exports;
  }();

  ;

  REPO_RAW_URL = "https://raw.githubusercontent.com/kynikos/wiki-monkey";

  return exports;
}.call(undefined);

},{"../../package.json":392,"./index":411,"./libs":412}],410:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

module.exports = function () {
  function exports(WM) {
    _classCallCheck(this, exports);

    this.WM = WM;
  }

  _createClass(exports, [{
    key: 'isWhatLinksHerePage',
    value: function isWhatLinksHerePage() {
      if (document.getElementById('mw-whatlinkshere-list')) {
        return true;
      } else {
        return false;
      }
    }
  }, {
    key: 'getTitle',
    value: function getTitle() {
      return document.getElementById('contentSub').getElementsByTagName('a')[0].title;
    }
  }]);

  return exports;
}();

},{}],411:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var App, ArchWiki, Cat, Diff, Editor, Interlanguage, MW, Parser, Plugin, Tables, Upgrade, WhatLinksHere, mwmodpromise;

mwmodpromise = mw.loader.using(['mediawiki.api.edit', 'mediawiki.notification', 'mediawiki.Uri']);

require('./libs').init();

Upgrade = require('./Upgrade');

var _require = require('../app');

App = _require.App;

ArchWiki = require('./ArchWiki');

Cat = require('./Cat');

Diff = require('./Diff');

Editor = require('./Editor');

Interlanguage = require('./Interlanguage');

MW = require('./MW');

Parser = require('./Parser');

Tables = require('./Tables');

WhatLinksHere = require('./WhatLinksHere');

var _require2 = require('../plugins/_Plugin');

Plugin = _require2.Plugin;


module.exports.WikiMonkey = function () {
  var WikiMonkey = function () {
    function WikiMonkey(wiki_name) {
      _classCallCheck(this, WikiMonkey);

      this.init = this.init.bind(this);
      this.wiki_name = wiki_name;

      for (var _len = arguments.length, installed_plugins_temp = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        installed_plugins_temp[_key - 1] = arguments[_key];
      }

      this.installed_plugins_temp = installed_plugins_temp;
      this.setup();
      $.when(mwmodpromise, $.ready).done(this.init);
    }

    _createClass(WikiMonkey, [{
      key: 'setup',
      value: function setup() {
        var PluginSub, error, i, interface_, len, option, pmod, pname, ref, user_config, value;

        user_config = window.wikiMonkeyConfig || window.wikimonkey_config || {};
        for (option in user_config) {
          value = user_config[option];
          if (!(option in this.conf)) {
            continue;
          }
          this.conf[option] = value;
          delete user_config[option];
        }
        ref = this.installed_plugins_temp;
        for (i = 0, len = ref.length; i < len; i++) {
          pmod = ref[i];
          for (pname in pmod) {
            PluginSub = pmod[pname];
            if (!(PluginSub.prototype instanceof Plugin)) {
              continue;
            }
            try {
              PluginSub.__configure(this.wiki_name, user_config);
            } catch (error1) {
              error = error1;

              if (error.message === "Plugin disabled") {
                continue;
              }
              throw error;
            }
            for (interface_ in this.Plugins) {
              if (PluginSub.prototype['main_' + interface_]) {
                this.Plugins[interface_].push(PluginSub);
              }
            }
          }
        }
        if (!$.isEmptyObject(user_config)) {
          console.warn("Unkown configuration options", user_config);
        }
        delete this.installed_plugins_temp;
        return Object.assign(module.exports, {
          conf: this.conf,
          Plugins: this.Plugins
        });
      }
    }, {
      key: 'init',
      value: function init() {
        module.exports.ArchWiki = new ArchWiki(this);
        module.exports.Cat = new Cat(this);
        module.exports.Diff = new Diff(this);
        this.Editor = new Editor(this);
        this.Interlanguage = new Interlanguage(this);
        module.exports.MW = this.MW = new MW(this);
        this.Parser = new Parser(this);
        this.Tables = new Tables(this);
        this.WhatLinksHere = new WhatLinksHere(this);
        new Upgrade(this);
        return App(this);
      }
    }]);

    return WikiMonkey;
  }();

  ;

  WikiMonkey.prototype.conf = {
    default_bot_plugin: "SimpleReplace",
    default_recentchanges_plugin: null,
    default_newpages_plugin: null,
    update_check_wdays: [6],
    update_check_branch: 'master',
    hide_rollback_links: true,
    disable_edit_summary_submit_on_enter: true,
    scroll_to_first_heading: false
  };

  WikiMonkey.prototype.Plugins = {
    bot: [],
    diff: [],
    editor: [],
    newpages: [],
    recentchanges: [],
    special: []
  };

  return WikiMonkey;
}.call(undefined);

},{"../app":399,"../plugins/_Plugin":432,"./ArchWiki":401,"./Cat":402,"./Diff":403,"./Editor":404,"./Interlanguage":405,"./MW":406,"./Parser":407,"./Tables":408,"./Upgrade":409,"./WhatLinksHere":410,"./libs":412}],412:[function(require,module,exports){
'use strict';

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }return target;
};

require('babel-polyfill');

module.exports.init = function () {
  var helper, hh, jss, tag;
  module.exports.Vue = require('vue');
  hh = require('hyperscript-helpers')(require('hyperscript'));
  for (tag in hh) {
    helper = hh[tag];

    module.exports[tag.charAt(0).toUpperCase() + tag.slice(1)] = helper;
  }
  module.exports.moment = require('moment');
  jss = require('jss').default;
  jss.setup(require('jss-preset-default').default());
  return module.exports.jssc = function (styles, options) {
    return jss.createStyleSheet(styles, _extends({
      classNamePrefix: "WikiMonkey-"
    }, options)).attach();
  };
};

},{"babel-polyfill":4,"hyperscript":338,"hyperscript-helpers":337,"jss":361,"jss-preset-default":350,"moment":385,"vue":390}],413:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var App,
    Plugin,
    WM,
    indexOf = [].indexOf;

WM = require('../modules');

App = require('../app');

var _require = require('./_Plugin');

Plugin = _require.Plugin;


module.exports.ArchWikiFixHeader = function () {
  var ArchWikiFixHeader = function (_Plugin) {
    _inherits(ArchWikiFixHeader, _Plugin);

    function ArchWikiFixHeader() {
      _classCallCheck(this, ArchWikiFixHeader);

      return _possibleConstructorReturn(this, (ArchWikiFixHeader.__proto__ || Object.getPrototypeOf(ArchWikiFixHeader)).apply(this, arguments));
    }

    _createClass(ArchWikiFixHeader, [{
      key: 'main_editor',
      value: function main_editor(callNext) {
        var b, behaviorswitches, bslist, bswitch, cat, categories, catlang, catlink, catlinks, catlist, cattext, cleantitle, content, contentId, displaytitle, dlct, dt, firstChar, fulllink, header, i, interlanguage, iwlinks, iwlist, j, k, l, language, lct, len, len1, len2, len3, link, linklang, linktext, linktitle, lowercasetitle, newText, ref, ref1, source, tempcontent, titlemod, titlemods;
        source = this.WM.Editor.readSource();
        language = WM.ArchWiki.detectLanguage(this.WM.Editor.getTitle())[1];
        header = "";
        content = source;

        content = content.replace(/^\s*<noinclude>/, "");
        if (content !== source) {
          header += "<noinclude>\n";
        }

        displaytitle = this.WM.Parser.findVariables(content, "DISPLAYTITLE");
        lowercasetitle = this.WM.Parser.findTemplates(content, "Lowercase title");
        titlemods = displaytitle.concat(lowercasetitle);
        titlemods.sort(function (a, b) {
          return a.index - b.index;
        });
        tempcontent = "";
        contentId = 0;
        for (i = 0, len = titlemods.length; i < len; i++) {
          titlemod = titlemods[i];
          tempcontent += content.substring(contentId, titlemod.index);
          contentId = titlemod.index + titlemod.length;
        }
        tempcontent += content.substring(contentId);
        content = tempcontent;
        dt = displaytitle.pop();
        lct = lowercasetitle.pop();
        dlct = "";
        if (dt && !lct) {
          dlct = "{{DISPLAYTITLE:" + dt.value + "}}";
        } else if (!dt && lct) {
          dlct = "{{Lowercase title}}";
        } else if (dt && lct) {
          dlct = dt.index < lct.index ? "{{Lowercase title}}" : '{{DISPLAYTITLE:' + dt.value + '}}';
        }
        if (displaytitle.length || lowercasetitle.length) {
          App.log.logWarning("Found multiple instances of {{DISPLAYTITLE:...}} or {{Lowercase title}}: only the last one has been used, the others have been deleted");
        }

        behaviorswitches = this.WM.Parser.findBehaviorSwitches(content);
        bslist = [];
        tempcontent = "";
        contentId = 0;
        for (b = j = 0, len1 = behaviorswitches.length; j < len1; b = ++j) {
          bswitch = behaviorswitches[b];
          if ((ref = bswitch.match[1]) === "TOC" || ref === "START" || ref === "END") {
            behaviorswitches.splice(b, 1);
          } else {
            if (ref1 = bswitch.match[0], indexOf.call(bslist, ref1) < 0) {
              bslist.push(bswitch.match[0]);
            } else {
              App.log.logWarning('Removed duplicate of ' + bswitch.match[0]);
            }
            tempcontent += content.substring(contentId, bswitch.index);
            contentId = bswitch.index + bswitch.length;
          }
        }
        tempcontent += content.substring(contentId);
        content = tempcontent;
        if (!dlct && bslist.length) {
          header += bslist.join(" ") + "\n";
        } else if (dlct && !bslist.length) {
          header += dlct + "\n";
        } else if (dlct && bslist.length) {
          header += dlct + " " + bslist.join(" ") + "\n";
        }

        categories = this.WM.Parser.findCategories(content);
        catlist = [];
        catlinks = [];
        tempcontent = "";
        contentId = 0;
        for (k = 0, len2 = categories.length; k < len2; k++) {
          cat = categories[k];
          if (cat.fragment) {
            App.log.logWarning(App.log.linkToWikiPage(cat.link, cat.rawLink) + " contains a fragment reference, but it doesn't make sense in categories and will be removed");
          }
          cleantitle = this.WM.Parser.squashContiguousWhitespace(cat.title);
          cattext = "Category:" + cleantitle;

          catlang = WM.ArchWiki.detectLanguage(cattext)[1];
          catlink = "[[" + cattext + (cat.anchor ? "|" + cat.anchor : "") + "]]";
          if (language !== catlang) {
            App.log.logWarning(App.log.linkToWikiPage(cat.link, cattext) + " belongs to a different language than the one of the title (" + language + ")");
          }
          if (catlist.indexOf(cattext) < 0) {
            catlist.push(cattext);
            catlinks.push(catlink);
          } else {
            App.log.logWarning("Removed duplicate of " + App.log.linkToWikiPage(cat.link, cattext));
          }
          tempcontent += content.substring(contentId, cat.index);
          contentId = cat.index + cat.length;
        }
        if (catlist.length) {
          header += catlinks.join("\n") + "\n";
        } else {
          App.log.logWarning("The article is not categorized");
        }
        tempcontent += content.substring(contentId);
        content = tempcontent;

        interlanguage = WM.ArchWiki.findAllInterlanguageLinks(content);
        iwlist = [];
        iwlinks = [];
        tempcontent = "";
        contentId = 0;
        for (l = 0, len3 = interlanguage.length; l < len3; l++) {
          link = interlanguage[l];
          if (link.anchor) {
            App.log.logWarning(link.rawLink + " contains an alternative text, but it doesn't make sense in interlanguage links and will be removed");
          }

          linktitle = link.title;
          linklang = link.namespace;
          linktext = linklang + ":" + linktitle;
          fulllink = "[[" + linktext + (link.fragment ? "#" + link.fragment : "") + "]]";
          if (iwlist.indexOf(linktext) < 0) {
            iwlist.push(linktext);
            iwlinks.push(fulllink);
          } else {
            App.log.logWarning("Removed duplicate of " + linktext);
          }
          tempcontent += content.substring(contentId, link.index);
          contentId = link.index + link.length;
        }
        if (iwlist.length) {
          iwlinks.sort();
          header += iwlinks.join("\n") + "\n";
        }
        tempcontent += content.substring(contentId);
        content = tempcontent;
        firstChar = content.search(/[^\s]/);
        content = content.substr(firstChar);
        newText = header + content;
        if (newText !== source) {
          this.WM.Editor.writeSource(newText);
          App.log.logInfo("Fixed header");
        }
        if (callNext) {
          return callNext();
        }
      }
    }]);

    return ArchWikiFixHeader;
  }(Plugin);

  ;

  ArchWikiFixHeader.conf_default = {
    enabled: true,
    editor_menu: ["Text plugins", "Fix header"]
  };

  return ArchWikiFixHeader;
}.call(undefined);

},{"../app":399,"../modules":411,"./_Plugin":432}],414:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var App, Plugin;

App = require('../app');

var _require = require('./_Plugin');

Plugin = _require.Plugin;


module.exports.ArchWikiFixHeadings = function () {
  var ArchWikiFixHeadings = function (_Plugin) {
    _inherits(ArchWikiFixHeadings, _Plugin);

    function ArchWikiFixHeadings() {
      _classCallCheck(this, ArchWikiFixHeadings);

      return _possibleConstructorReturn(this, (ArchWikiFixHeadings.__proto__ || Object.getPrototypeOf(ArchWikiFixHeadings)).apply(this, arguments));
    }

    _createClass(ArchWikiFixHeadings, [{
      key: 'main_editor',
      value: function main_editor(callNext) {
        var i, increaseLevel, info, len, newtext, prevId, ref, section, source;
        source = this.WM.Editor.readSource();
        info = this.WM.Parser.findSectionHeadings(source);
        if (this.WM.Editor.isSection()) {
          increaseLevel = info.minLevel - 1;
        } else {
          if (info.maxTocLevel < 6) {
            increaseLevel = 1;
          } else {
            increaseLevel = 0;
            App.log.logWarning("There are 6 levels of headings, it has been necessary to start creating them from level 1 although usually it is suggested to start from level 2");
          }
        }
        newtext = "";
        prevId = 0;
        ref = info.sections;
        for (i = 0, len = ref.length; i < len; i++) {
          section = ref[i];
          newtext += source.substring(prevId, section.index);
          newtext += new Array(section.tocLevel + increaseLevel + 1).join("=");
          newtext += section.rawheading;
          newtext += new Array(section.tocLevel + increaseLevel + 1).join("=");
          prevId = section.index + section.length0;
        }
        newtext += source.substr(prevId);
        if (newtext !== source) {
          this.WM.Editor.writeSource(newtext);
          App.log.logInfo("Fixed section headings");
        }
        if (callNext) {
          return callNext();
        }
      }
    }]);

    return ArchWikiFixHeadings;
  }(Plugin);

  ;

  ArchWikiFixHeadings.conf_default = {
    enabled: true,
    editor_menu: ["Text plugins", "Fix headings"]
  };

  return ArchWikiFixHeadings;
}.call(undefined);

},{"../app":399,"./_Plugin":432}],415:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var App, Plugin;

App = require('../app');

var _require = require('./_Plugin');

Plugin = _require.Plugin;


module.exports.ArchWikiFixLinks = function () {
  var ArchWikiFixLinks = function (_Plugin) {
    _inherits(ArchWikiFixLinks, _Plugin);

    function ArchWikiFixLinks() {
      _classCallCheck(this, ArchWikiFixLinks);

      return _possibleConstructorReturn(this, (ArchWikiFixLinks.__proto__ || Object.getPrototypeOf(ArchWikiFixLinks)).apply(this, arguments));
    }

    _createClass(ArchWikiFixLinks, [{
      key: 'doReplace',
      value: function doReplace(txt) {
        var L, match, newText, prevId, re;

        re = /http:\/\/([a-z]+\.)?archlinux\.org(?!\.[a-z])/ig;
        txt = txt.replace(re, 'https://$1archlinux.org');

        re = /\[https?:\/\/wiki\.archlinux\.org\/index\.php\/Category:([^\]]+?) (.+?)\]/ig;
        txt = txt.replace(re, '[[:Category:$1|$2]]');
        re = /\[https?:\/\/wiki\.archlinux\.org\/index\.php\/Category:(.+?)\]/ig;
        txt = txt.replace(re, '[[:Category:$1]]');
        re = /https?:\/\/wiki\.archlinux\.org\/index\.php\/Category:([^\s]+)/ig;
        txt = txt.replace(re, '[[:Category:$1]]');
        re = /\[https?:\/\/wiki\.archlinux\.org\/index\.php\/([^\]]+?) (.+?)\]/ig;
        txt = txt.replace(re, '[[$1|$2]]');
        re = /\[https?:\/\/wiki\.archlinux\.org\/index\.php\/(.+?)\]/ig;
        txt = txt.replace(re, '[[$1]]');
        re = /https?:\/\/wiki\.archlinux\.org\/index\.php\/([^\s]+)/ig;
        txt = txt.replace(re, '[[$1]]');
        re = /https?:\/\/wiki\.archlinux\.org(?!\.)/ig;
        if (re.test(txt)) {
          App.log.logWarning("It hasn't been possible to convert some " + "links to wiki.archlinux.org");
        }

        re = /\[https?:\/\/en\.wikipedia\.org\/wiki\/([^\]]+?) (.+?)\]/ig;
        txt = txt.replace(re, '[[wikipedia:$1|$2]]');
        re = /\[https?:\/\/en\.wikipedia\.org\/wiki\/(.+?)\]/ig;
        txt = txt.replace(re, '[[wikipedia:$1]]');
        re = /https?:\/\/en\.wikipedia\.org\/wiki\/([^\s]+)/ig;
        txt = txt.replace(re, '[[wikipedia:$1]]');
        re = /https?:\/\/([a-z]+?)\.wikipedia\.org(?!\.)/ig;
        if (re.test(txt)) {
          App.log.logWarning("It hasn't been possible to convert some " + "links to Wikipedia");
        }

        re = /\[https?:\/\/(?:www\.)?archlinux\.org\/packages\/(?:community|community-testing|core|extra|multilib|multilib-testing|testing)\/(?:any|i686|x86_64)\/([^\s]+?)\/? +(.+?)?\]/ig;
        newText = '';
        prevId = 0;
        while (true) {
          match = re.exec(txt);
          if (match) {
            if (match[1] === match[2]) {
              L = match[0].length;
              newText += txt.substring(prevId, re.lastIndex - L) + '{{Pkg|' + match[1] + '}}';
              prevId = re.lastIndex;
            }
          } else {
            break;
          }
        }
        newText += txt.substr(prevId);
        txt = newText;
        re = /\[https?:\/\/(?:www\.)?archlinux\.org\/packages\/(?:community|community-testing|core|extra|multilib|multilib-testing|testing)\/(?:any|i686|x86_64)\/([^\s]+?)\/?\]/ig;
        txt = txt.replace(re, '{{Pkg|$1}}');
        re = /([^\[])https?:\/\/(?:www\.)?archlinux\.org\/packages\/(?:community|community-testing|core|extra|multilib|multilib-testing|testing)\/(?:any|i686|x86_64)\/([^\s\/]+)\/?/ig;
        txt = txt.replace(re, '$1{{Pkg|$2}}');
        re = /https?:\/\/(?:www\.)?archlinux\.org\/packages(?!\/?\s)/ig;
        if (re.test(txt)) {
          App.log.logWarning("It hasn't been possible to convert some " + "links to archlinux.org/packages");
        }

        re = /\[https?:\/\/aur\.archlinux\.org\/packages\/([^\s]+?)\/? +(.+?)?\]/ig;
        newText = '';
        prevId = 0;
        while (true) {
          match = re.exec(txt);
          if (match) {
            if (match[1] === match[2]) {
              L = match[0].length;
              newText += txt.substring(prevId, re.lastIndex - L) + '{{AUR|' + match[1] + '}}';
              prevId = re.lastIndex;
            }
          } else {
            break;
          }
        }
        newText += txt.substr(prevId);
        txt = newText;
        re = /\[https?:\/\/aur\.archlinux\.org\/packages\/([^\s]+?)\/?\]/ig;
        txt = txt.replace(re, '{{AUR|$1}}');
        re = /([^\[])https?:\/\/aur\.archlinux\.org\/packages\/([^\s\/]+)\/?/ig;
        txt = txt.replace(re, '$1{{AUR|$2}}');
        re = /https?:\/\/aur\.archlinux\.org(?!(?:\.|(?:\/?packages)?\/?\s))/ig;
        if (re.test(txt)) {
          App.log.logWarning("It hasn't been possible to convert some links to aur.archlinux.org (try the \"Fix old AUR links\" function, if installed)");
        }

        re = /\[https?:\/\/bugs\.archlinux\.org\/task\/([^\s]+?)\/? +(.+?)?\]/ig;
        newText = '';
        prevId = 0;
        while (true) {
          match = re.exec(txt);
          if (match) {
            if (match[1] === match[2]) {
              L = match[0].length;
              newText += txt.substring(prevId, re.lastIndex - L) + '{{Bug|' + match[1] + '}}';
              prevId = re.lastIndex;
            }
          } else {
            break;
          }
        }
        newText += txt.substr(prevId);
        txt = newText;
        re = /\[https?:\/\/bugs\.archlinux\.org\/task\/([^\s]+?)\/?\]/ig;
        txt = txt.replace(re, '{{Bug|$1}}');
        re = /([^\[])https?:\/\/bugs\.archlinux\.org\/task\/([^\s\/]+)\/?/ig;
        txt = txt.replace(re, '$1{{Bug|$2}}');
        re = /https?:\/\/bugs\.archlinux\.org\/task/ig;
        if (re.test(txt)) {
          App.log.logWarning("It hasn't been possible to convert some " + "links to bugs.archlinux.org/task");
        }
        return txt;
      }
    }, {
      key: 'main_editor',
      value: function main_editor(callNext) {
        var newtext, source;
        source = this.WM.Editor.readSource();
        newtext = this.doReplace(source);
        if (newtext !== source) {
          this.WM.Editor.writeSource(newtext);
          App.log.logInfo("Fixed links");
        } else {
          App.log.logInfo("No fixable links found");
        }
        if (callNext) {
          return callNext();
        }
      }
    }]);

    return ArchWikiFixLinks;
  }(Plugin);

  ;

  ArchWikiFixLinks.conf_default = {
    enabled: true,
    editor_menu: ["Text plugins", "Fix external links"]
  };

  return ArchWikiFixLinks;
}.call(undefined);

},{"../app":399,"./_Plugin":432}],416:[function(require,module,exports){
'use strict';

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var App, Plugin, WM, jssc;

var _require = require('../modules/libs');

jssc = _require.jssc;


WM = require('../modules');

App = require('../app');

var _require2 = require('./_Plugin');

Plugin = _require2.Plugin;


module.exports.ArchWikiNPFilter = function () {
  var ArchWikiNPFilter = function (_Plugin) {
    _inherits(ArchWikiNPFilter, _Plugin);

    function ArchWikiNPFilter() {
      _classCallCheck(this, ArchWikiNPFilter);

      return _possibleConstructorReturn(this, (ArchWikiNPFilter.__proto__ || Object.getPrototypeOf(ArchWikiNPFilter)).apply(this, arguments));
    }

    _createClass(ArchWikiNPFilter, [{
      key: 'main_newpages',
      value: function main_newpages() {
        var contentDiv, i, language, len, li, liList, link, pureTitle, ul;
        jssc({
          '@global #mw-content-text > h5': {
            backgroundColor: '#afa'
          }
        });
        contentDiv = $('#mw-content-text');
        ul = contentDiv.find('ul').first();
        liList = ul.children('li');
        for (i = 0, len = liList.length; i < len; i++) {
          li = liList[i];
          link = $(li).find('a.mw-newpages-pagename').first();

          var _WM$ArchWiki$detectLa = WM.ArchWiki.detectLanguage(link[0].title);

          var _WM$ArchWiki$detectLa2 = _slicedToArray(_WM$ArchWiki$detectLa, 2);

          pureTitle = _WM$ArchWiki$detectLa2[0];
          language = _WM$ArchWiki$detectLa2[1];

          if (language !== this.conf.default_language) {
            this.moveArticle(contentDiv, li, language);
          }
        }
        return App.log.logInfo("Grouped articles by language");
      }
    }, {
      key: 'moveArticle',
      value: function moveArticle(contentDiv, li, language) {
        var HLang, i, langFound, langHs, len, ul;
        langHs = contentDiv.children('h5');
        langFound = false;
        for (i = 0, len = langHs.length; i < len; i++) {
          HLang = langHs[i];
          if (HLang.innerHTML === language) {
            ul = $(HLang).next().append(li);
            langFound = true;
            break;
          }
        }
        if (!langFound) {
          return contentDiv.append($('<h5>').text(language), $('<ul>').append(li));
        }
      }
    }]);

    return ArchWikiNPFilter;
  }(Plugin);

  ;

  ArchWikiNPFilter.conf_default = {
    enabled: true,
    filter_label: "Default filter",
    default_language: "English"
  };

  return ArchWikiNPFilter;
}.call(undefined);

},{"../app":399,"../modules":411,"../modules/libs":412,"./_Plugin":432}],417:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var App, Plugin;

App = require('../app');

var _require = require('./_Plugin');

Plugin = _require.Plugin;


module.exports.ArchWikiNewTemplates = function () {
  var ArchWikiNewTemplates = function (_Plugin) {
    _inherits(ArchWikiNewTemplates, _Plugin);

    function ArchWikiNewTemplates() {
      _classCallCheck(this, ArchWikiNewTemplates);

      return _possibleConstructorReturn(this, (ArchWikiNewTemplates.__proto__ || Object.getPrototypeOf(ArchWikiNewTemplates)).apply(this, arguments));
    }

    _createClass(ArchWikiNewTemplates, [{
      key: 'main_editor',
      value: function main_editor(callNext) {
        var i, len, newtext, re10, re11, re12, re13, re14, re15, re16, re8, re9, source, test, tests;
        source = this.WM.Editor.readSource();
        newtext = source;
        re8 = /<pre>(((?!<(pre|nowiki)>)[^\=\|])*?((?!<(pre|nowiki)>)[^\=\|\}]))<\/pre>/ig;
        re9 = /<pre>(((?!<(pre|nowiki)>)[^\|])*?((?!<(pre|nowiki)>)[^\|\}]))<\/pre>/ig;
        re10 = /<pre>(\n*((?!<(pre|nowiki)>).\n*)+?)<\/pre>/ig;
        re11 = /<code>(((?!<(code|nowiki)>)[^\=\|\n])*?((?!<(code|nowiki)>)[^\=\|\}\n]))<\/code>/ig;
        re12 = /<code>(((?!<(code|nowiki)>)[^\|\n])*?((?!<(code|nowiki)>)[^\|\}\n]))<\/code>/ig;
        re13 = /<code>(((?!<(code|nowiki)>)[^\n])+?)<\/code>/ig;
        re14 = /<tt>(((?!<(tt|nowiki)>)[^\=\|\n])*?((?!<(tt|nowiki)>)[^\=\|\}\n]))<\/tt>/ig;
        re15 = /<tt>(((?!<(tt|nowiki)>)[^\|\n])*?((?!<(tt|nowiki)>)[^\|\}\n]))<\/tt>/ig;
        re16 = /<tt>(((?!<(tt|nowiki)>)[^\n])+?)<\/tt>/ig;
        newtext = newtext.replace(re8, '{{bc|$1}}');
        newtext = newtext.replace(re9, '{{bc|1=$1}}');
        newtext = newtext.replace(re10, '{{bc|<nowiki>$1</nowiki>}}');
        newtext = newtext.replace(re11, '{{ic|$1}}');
        newtext = newtext.replace(re12, '{{ic|1=$1}}');
        newtext = newtext.replace(re13, '{{ic|<nowiki>$1</nowiki>}}');
        newtext = newtext.replace(re14, '{{ic|$1}}');
        newtext = newtext.replace(re15, '{{ic|1=$1}}');
        newtext = newtext.replace(re16, '{{ic|<nowiki>$1</nowiki>}}');
        if (newtext !== source) {
          this.WM.Editor.writeSource(newtext);
          App.log.logInfo("Turned HTML tags into proper templates");
        }
        tests = [['&lt;pre>', newtext.match(/<pre/ig)], ['&lt;code>', newtext.match(/<code/ig)], ['&lt;tt>', newtext.match(/<tt/ig)]];
        for (i = 0, len = tests.length; i < len; i++) {
          test = tests[i];
          if (test[1]) {
            App.log.logWarning(test[1].length + ' ' + test[0] + ' instances require manual intervention');
          }
        }
        if (callNext) {
          return callNext();
        }
      }
    }]);

    return ArchWikiNewTemplates;
  }(Plugin);

  ;

  ArchWikiNewTemplates.conf_default = {
    enabled: true,
    editor_menu: ["Text plugins", "Use code templates"]
  };

  return ArchWikiNewTemplates;
}.call(undefined);

},{"../app":399,"./_Plugin":432}],418:[function(require,module,exports){
'use strict';

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var App, Plugin, WM, jssc;

var _require = require('../modules/libs');

jssc = _require.jssc;


WM = require('../modules');

App = require('../app');

var _require2 = require('./_Plugin');

Plugin = _require2.Plugin;


module.exports.ArchWikiRCFilter = function () {
  var ArchWikiRCFilter = function (_Plugin) {
    _inherits(ArchWikiRCFilter, _Plugin);

    function ArchWikiRCFilter() {
      _classCallCheck(this, ArchWikiRCFilter);

      return _possibleConstructorReturn(this, (ArchWikiRCFilter.__proto__ || Object.getPrototypeOf(ArchWikiRCFilter)).apply(this, arguments));
    }

    _createClass(ArchWikiRCFilter, [{
      key: 'main_recentchanges',
      value: function main_recentchanges() {
        var articleTable, groupDiv, h4, h4s, j, k, language, len, len1, link, pureTitle, ref;
        h4s = $('#mw-content-text .mw-changeslist > h4');
        if (h4s.eq(0).next()[0].localName.toLowerCase() !== 'div') {
          return App.log.logError("This filter is designed to work on top of MediaWiki's filter, which you can enable in your user preferences.");
        } else {
          jssc({
            '@global': {
              '#mw-content-text': {
                '& > div > h4': {
                  backgroundColor: '#aaf'
                },
                '& > div > div > h5': {
                  backgroundColor: '#afa'
                }
              }
            }
          });
          for (j = 0, len = h4s.length; j < len; j++) {
            h4 = h4s[j];
            groupDiv = $(h4).next();
            ref = groupDiv.children('table');
            for (k = 0, len1 = ref.length; k < len1; k++) {
              articleTable = ref[k];
              link = $(articleTable).find('a.mw-changeslist-title').first();
              if (link[0]) {
                var _WM$ArchWiki$detectLa = WM.ArchWiki.detectLanguage(link[0].title);

                var _WM$ArchWiki$detectLa2 = _slicedToArray(_WM$ArchWiki$detectLa, 2);

                pureTitle = _WM$ArchWiki$detectLa2[0];
                language = _WM$ArchWiki$detectLa2[1];

                if (language !== this.conf.default_language) {
                  this.moveArticle(groupDiv, articleTable, language);
                }
              }
            }
          }
          return App.log.logInfo("Grouped articles by language");
        }
      }
    }, {
      key: 'moveArticle',
      value: function moveArticle(groupDiv, articleTable, language) {
        var HLang, i, j, langFound, langHs, len;
        langHs = groupDiv.children('h5');
        langFound = false;
        for (i = j = 0, len = langHs.length; j < len; i = ++j) {
          HLang = langHs[i];
          if (HLang.innerHTML === language) {
            if (i + 1 < langHs.length) {
              langHs.eq(i + 1).before(articleTable);
            } else {
              groupDiv.append(articleTable);
            }
            langFound = true;
            break;
          }
        }
        if (!langFound) {
          return groupDiv.append($('<h5>').text(language), articleTable);
        }
      }
    }]);

    return ArchWikiRCFilter;
  }(Plugin);

  ;

  ArchWikiRCFilter.conf_default = {
    enabled: true,
    filter_label: "Default filter",
    default_language: "English"
  };

  return ArchWikiRCFilter;
}.call(undefined);

},{"../app":399,"../modules":411,"../modules/libs":412,"./_Plugin":432}],419:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var App,
    Plugin,
    WM,
    jssc,
    ref,
    boundMethodCheck = function boundMethodCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new Error('Bound instance method accessed before binding');
  }
};

var _require = require('../modules/libs');

jssc = _require.jssc;


WM = require('../modules');

App = require('../app');

var _require2 = require('./_Plugin');

Plugin = _require2.Plugin;


ref = module.exports.ArchWikiSaveTalk = function () {
  var ArchWikiSaveTalk = function (_Plugin) {
    _inherits(ArchWikiSaveTalk, _Plugin);

    function ArchWikiSaveTalk() {
      _classCallCheck(this, ArchWikiSaveTalk);

      var _this = _possibleConstructorReturn(this, (ArchWikiSaveTalk.__proto__ || Object.getPrototypeOf(ArchWikiSaveTalk)).apply(this, arguments));

      _this.mainGetEndTimestamp = _this.mainGetEndTimestamp.bind(_this);
      _this.mainWrite = _this.mainWrite.bind(_this);
      _this.mainEnd = _this.mainEnd.bind(_this);
      return _this;
    }

    _createClass(ArchWikiSaveTalk, [{
      key: 'makeUI',
      value: function makeUI() {
        var article, classes, link;

        var _jssc = jssc({
          saveTalk: {
            marginLeft: '0.33em'
          }
        });

        classes = _jssc.classes;

        article = this.conf.page;
        link = document.createElement('a');
        link.id = "WikiMonkey-ArchWikiSaveTalk";
        link.className = classes.saveTalk;
        link.href = "/index.php/" + article;
        link.innerHTML = article;
        return link;
      }
    }, {
      key: 'main_diff',
      value: function main_diff(callNext) {
        var article, summary;
        article = this.conf.page;
        summary = this.conf.edit_summary;
        App.log.logInfo('Appending diff to ' + App.log.linkToWikiPage(article, article) + " ...");
        return WM.Diff.getEndTimestamp(this.mainGetEndTimestamp, [article, summary, callNext]);
      }
    }, {
      key: 'mainGetEndTimestamp',
      value: function mainGetEndTimestamp(enddate, args) {
        var article, callNext, summary;
        boundMethodCheck(this, ref);
        article = args[0];
        summary = args[1];
        callNext = args[2];
        return this.WM.MW.callQueryEdit(article, this.mainWrite, [summary, enddate, callNext]);
      }
    }, {
      key: 'mainWrite',
      value: function mainWrite(article, source, timestamp, edittoken, args) {
        var callNext, enddate, newtext, pEnddate, summary, title;
        boundMethodCheck(this, ref);
        summary = args[0];
        enddate = args[1];
        callNext = args[2];
        title = mw.config.get('wgPageName');
        pEnddate = enddate.substr(0, 10) + "&nbsp;" + enddate.substr(11, 8);
        newtext = this.WM.Tables.appendRow(source, "<!-- REPLY TABLE -->", ["[" + location.href + " " + title + "]", pEnddate]);
        return this.WM.MW.callAPIPost({
          action: "edit",
          bot: "1",
          title: article,
          summary: summary,
          text: newtext,
          basetimestamp: timestamp,
          token: edittoken
        }, this.mainEnd, [article, callNext], null);
      }
    }, {
      key: 'mainEnd',
      value: function mainEnd(res, args) {
        var article, callNext;
        boundMethodCheck(this, ref);
        article = args[0];
        callNext = args[1];
        if (res.edit && res.edit.result === 'Success') {
          App.log.logInfo('Diff correctly appended to ' + App.log.linkToWikiPage(article, article));
          if (callNext) {
            return callNext();
          }
        } else {
          return App.log.logError('The diff has not been appended!\n' + res['error']['info'] + " (" + res['error']['code'] + ")");
        }
      }
    }]);

    return ArchWikiSaveTalk;
  }(Plugin);

  ;

  ArchWikiSaveTalk.conf_default = {
    enabled: false,
    diff_menu: ["Save discussion"],
    page: null,
    edit_summary: "add discussion"
  };

  return ArchWikiSaveTalk;
}.call(undefined);

},{"../app":399,"../modules":411,"../modules/libs":412,"./_Plugin":432}],420:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var App,
    Plugin,
    ref,
    boundMethodCheck = function boundMethodCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new Error('Bound instance method accessed before binding');
  }
};

App = require('../app');

var _require = require('./_Plugin');

Plugin = _require.Plugin;


ref = module.exports.ArchWikiSortContacts = function () {
  var endMark, regExp, startMark;

  var ArchWikiSortContacts = function (_Plugin) {
    _inherits(ArchWikiSortContacts, _Plugin);

    function ArchWikiSortContacts() {
      _classCallCheck(this, ArchWikiSortContacts);

      var _this = _possibleConstructorReturn(this, (ArchWikiSortContacts.__proto__ || Object.getPrototypeOf(ArchWikiSortContacts)).apply(this, arguments));

      _this.parseList = _this.parseList.bind(_this);
      _this.iterateUsers = _this.iterateUsers.bind(_this);
      _this.storeUserContribs = _this.storeUserContribs.bind(_this);
      _this.updateList = _this.updateList.bind(_this);
      _this.writePage = _this.writePage.bind(_this);
      return _this;
    }

    _createClass(ArchWikiSortContacts, [{
      key: 'main_special',
      value: function main_special(callNext) {
        return this.iteratePages(-1, callNext);
      }
    }, {
      key: 'iteratePages',
      value: function iteratePages(pageid, callNext) {
        var inactiveIntro, inactiveLimit, page, pconf, recentDays, summary;
        pageid++;
        pconf = this.conf.pages[pageid];
        if (pconf) {
          page = pconf.title;
          recentDays = pconf.recent_days;
          inactiveLimit = pconf.inactive_limit;
          inactiveIntro = pconf.inactive_message;
          summary = this.conf.edit_summary;
          App.log.logInfo("Sorting " + App.log.linkToWikiPage(page, page) + " ...");
          return this.WM.MW.callQueryEdit(page, this.parseList, [recentDays, inactiveLimit, inactiveIntro, summary, callNext, pageid]);
        } else if (callNext) {
          return callNext();
        }
      }
    }, {
      key: 'parseList',
      value: function parseList(title, source, timestamp, edittoken, args) {
        var callNext, date, endList, inactiveIntro, inactiveLimit, pageid, recentDays, startList, summary, ucend, ucstart, users, usersArray;
        boundMethodCheck(this, ref);
        recentDays = args[0];
        inactiveLimit = args[1];
        inactiveIntro = args[2];
        summary = args[3];
        callNext = args[4];
        pageid = args[5];
        startList = source.indexOf(startMark);
        endList = source.indexOf(endMark);
        if (startList > -1 && endList > -1) {
          startList += startMark.length;
          date = new Date();
          ucstart = Math.floor(Date.now() / 1000);
          ucend = ucstart - 86400 * recentDays;
          users = {
            active: [],
            inactive: []
          };
          usersArray = source.substring(startList, endList).split("\n");
          return this.iterateUsers(usersArray, -1, ucstart, ucend, users, title, source, startList, endList, timestamp, edittoken, inactiveLimit, inactiveIntro, summary, callNext, pageid);
        } else {
          return App.log.logError("Cannot find the needed marks");
        }
      }
    }, {
      key: 'iterateUsers',
      value: function iterateUsers(usersArray, index, ucstart, ucend, users, title, source, startList, endList, timestamp, edittoken, inactiveLimit, inactiveIntro, summary, callNext, pageid) {
        var match, ucuser, userString;
        boundMethodCheck(this, ref);
        index++;
        if (index < usersArray.length) {
          userString = usersArray[index];
          match = regExp.exec(userString);
          if (match) {
            ucuser = match[1].charAt(0).toUpperCase() + match[1].substr(1);
            if (match[2]) {
              ucuser += "|" + match[2].charAt(0).toUpperCase() + match[2].substr(1);
            }
            App.log.logInfo("Querying " + ucuser + " ...");
            return this.WM.MW.getUserContribs(ucuser, ucstart, ucend, this.storeUserContribs, [usersArray, index, ucstart, ucend, users, title, source, startList, endList, timestamp, edittoken, inactiveLimit, inactiveIntro, summary, callNext, pageid]);
          } else if (userString !== "" && userString.indexOf(inactiveIntro) !== 0) {
            return App.log.logError("An entry in the list may not be correctly " + "formatted");
          } else {
            return this.iterateUsers(usersArray, index, ucstart, ucend, users, title, source, startList, endList, timestamp, edittoken, inactiveLimit, inactiveIntro, summary, callNext, pageid);
          }
        } else {
          return this.updateList(users, title, source, startList, endList, timestamp, edittoken, inactiveIntro, summary, callNext, pageid);
        }
      }
    }, {
      key: 'storeUserContribs',
      value: function storeUserContribs(results, args) {
        var callNext, edits, edittoken, endList, inactiveIntro, inactiveLimit, index, pageid, source, startList, summary, timestamp, title, ucend, ucstart, users, usersArray;
        boundMethodCheck(this, ref);
        usersArray = args[0];
        index = args[1];
        ucstart = args[2];
        ucend = args[3];
        users = args[4];
        title = args[5];
        source = args[6];
        startList = args[7];
        endList = args[8];
        timestamp = args[9];
        edittoken = args[10];
        inactiveLimit = args[11];
        inactiveIntro = args[12];
        summary = args[13];
        callNext = args[14];
        pageid = args[15];
        edits = results.length;
        if (edits < inactiveLimit) {
          users.inactive.push({
            "text": usersArray[index],
            "edits": edits
          });
        } else {
          users.active.push({
            "text": usersArray[index],
            "edits": edits
          });
        }
        return this.iterateUsers(usersArray, index, ucstart, ucend, users, title, source, startList, endList, timestamp, edittoken, inactiveLimit, inactiveIntro, summary, callNext, pageid);
      }
    }, {
      key: 'updateList',
      value: function updateList(users, title, source, startList, endList, timestamp, edittoken, inactiveIntro, summary, callNext, pageid) {
        var i, j, len, len1, newList, newText, ref1, ref2, sorter, user;
        boundMethodCheck(this, ref);
        sorter = function sorter(a, b) {
          if (a.edits < b.edits) {
            return 1;
          } else if (a.edits > b.edits) {
            return -1;
          } else {
            return 0;
          }
        };
        users.active.sort(sorter);
        users.inactive.sort(sorter);
        newList = "\n";
        ref1 = users.active;
        for (i = 0, len = ref1.length; i < len; i++) {
          user = ref1[i];
          newList += user.text + "\n";
        }
        if (users.inactive.length > 0) {
          newList += "\n" + inactiveIntro + "\n\n";
          ref2 = users.inactive;
          for (j = 0, len1 = ref2.length; j < len1; j++) {
            user = ref2[j];
            newList += user.text + "\n";
          }
        }
        newText = source.substring(0, startList) + newList + source.substring(endList);
        if (newText !== source) {
          return this.WM.MW.callAPIPost({
            action: "edit",
            bot: "1",
            minor: "1",
            title: title,
            summary: summary,
            text: newText,
            b1asetimestamp: timestamp,
            token: edittoken
          }, this.writePage, [title, callNext, pageid], null);
        } else {
          App.log.logInfo(App.log.linkToWikiPage(title, title) + " was already up to date");
          return this.iteratePages(pageid, callNext);
        }
      }
    }, {
      key: 'writePage',
      value: function writePage(res, args) {
        var callNext, pageid, title;
        boundMethodCheck(this, ref);
        title = args[0];
        callNext = args[1];
        pageid = args[2];
        if (res.edit && res.edit.result === 'Success') {
          App.log.logInfo(App.log.linkToWikiPage(title, title) + " was correctly updated");
          return this.iteratePages(pageid, callNext);
        } else {
          return App.log.logError(res['error']['info'] + " (" + res['error']['code'] + ")");
        }
      }
    }]);

    return ArchWikiSortContacts;
  }(Plugin);

  ;

  startMark = "START AUTO LIST - DO NOT REMOVE OR MODIFY THIS MARK-->";

  endMark = "<!--END AUTO LIST - DO NOT REMOVE OR MODIFY THIS MARK";

  regExp = new RegExp("^\\*.*?\\[\\[User:(.+?)\\|.+?" + "(?: \\<!-- associated bot: (.+?) -->.*)?$", "");

  ArchWikiSortContacts.conf_default = {
    enabled: false,
    special_menu: ["Sort staff contacts"],
    edit_summary: "automatically sort list according to recent activity",
    pages: [{
      title: "ArchWiki:Administrators",
      recent_days: 30,
      inactive_limit: 30,
      inactive_message: "The following Administrators are currently inactive (less than 30 edits in the last 30 days):"
    }, {
      title: "ArchWiki:Maintainers",
      recent_days: 30,
      inactive_limit: 10,
      inactive_message: "The following Maintainers are currently inactive (less than 10 edits in the last 30 days):"
    }]
  };

  return ArchWikiSortContacts;
}.call(undefined);

},{"../app":399,"./_Plugin":432}],421:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var App, Plugin, WM;

WM = require('../modules');

App = require('../app');

var _require = require('./_Plugin');

Plugin = _require.Plugin;


module.exports.ArchWikiWantedCategories = function () {
  var ArchWikiWantedCategories = function (_Plugin) {
    _inherits(ArchWikiWantedCategories, _Plugin);

    function ArchWikiWantedCategories() {
      _classCallCheck(this, ArchWikiWantedCategories);

      return _possibleConstructorReturn(this, (ArchWikiWantedCategories.__proto__ || Object.getPrototypeOf(ArchWikiWantedCategories)).apply(this, arguments));
    }

    _createClass(ArchWikiWantedCategories, [{
      key: 'main_bot',
      value: function main_bot(title, callBot, chainArgs) {
        title = title.replace(" (page does not exist)", "");
        return this.WM.MW.callQuery({
          prop: "info",
          intoken: "edit",
          titles: title
        }, this.mainAutoWrite, [title, callBot], null);
      }
    }, {
      key: 'mainAutoWrite',
      value: function mainAutoWrite(page, args) {
        var callBot, edittoken, language, summary, text, title;
        title = args[0];
        callBot = args[1];
        edittoken = page.edittoken;
        language = WM.ArchWiki.detectLanguage(title)[1];
        if (language !== WM.ArchWiki.getLocalLanguage()) {
          text = "[[Category:" + language + "]]";
          summary = "wanted category";
          return this.WM.MW.callAPIPost({
            action: "edit",
            bot: "1",
            title: title,
            summary: summary,
            text: text,
            createonly: "1",
            token: edittoken
          }, this.mainAutoEnd, callBot, null);
        } else {
          return callBot(0, null);
        }
      }
    }, {
      key: 'mainAutoEnd',
      value: function mainAutoEnd(res, callBot) {
        if (res.edit && res.edit.result === 'Success') {
          return callBot(1, null);
        } else if (res.error) {
          App.log.logError(res.error.info + " (" + res.error.code + ")");
          return callBot(res.error.code, null);
        } else {
          return callBot(false, null);
        }
      }
    }]);

    return ArchWikiWantedCategories;
  }(Plugin);

  ;

  ArchWikiWantedCategories.conf_default = {
    enabled: false,
    bot_label: "Create wanted categories"
  };

  return ArchWikiWantedCategories;
}.call(undefined);

},{"../app":399,"../modules":411,"./_Plugin":432}],422:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var App, Plugin;

App = require('../app');

var _require = require('./_Plugin');

Plugin = _require.Plugin;


module.exports.DeletePages = function () {
  var DeletePages = function (_Plugin) {
    _inherits(DeletePages, _Plugin);

    function DeletePages() {
      _classCallCheck(this, DeletePages);

      return _possibleConstructorReturn(this, (DeletePages.__proto__ || Object.getPrototypeOf(DeletePages)).apply(this, arguments));
    }

    _createClass(DeletePages, [{
      key: 'main_bot',
      value: function main_bot(title, callBot, chainArgs) {
        var summary;
        summary = this.conf.edit_summary;
        return this.WM.MW.callQuery({
          prop: 'info',
          intoken: 'delete',
          titles: title
        }, this.mainAutoWrite, [title, summary, callBot], null);
      }
    }, {
      key: 'mainAutoWrite',
      value: function mainAutoWrite(page, args) {
        var callBot, deletetoken, summary, title;
        title = args[0];
        summary = args[1];
        callBot = args[2];
        deletetoken = page.deletetoken;
        return this.WM.MW.callAPIPost({
          action: 'delete',
          bot: '1',
          title: title,
          token: deletetoken,
          reason: summary
        }, this.mainAutoEnd, [title, callBot], null);
      }
    }, {
      key: 'mainAutoEnd',
      value: function mainAutoEnd(res, args) {
        var callBot, title;
        title = args[0];
        callBot = args[1];
        if (!res.delete) {
          if (res.error) {
            App.log.logError(App.log.linkToWikiPage(title, title) + ' has not been deleted!\n' + res.error.info + ' (' + res.error.code + ')');
            return callBot(res.error.code, null);
          } else {
            return callBot(false, null);
          }
        } else {
          return callBot(1, null);
        }
      }
    }]);

    return DeletePages;
  }(Plugin);

  ;

  DeletePages.conf_default = {
    enabled: false,
    bot_label: "Delete pages",
    edit_summary: "delete page"
  };

  return DeletePages;
}.call(undefined);

},{"../app":399,"./_Plugin":432}],423:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var App, Plugin;

App = require('../app');

var _require = require('./_Plugin');

Plugin = _require.Plugin;


module.exports.ExpandContractions = function () {
  var ExpandContractions = function (_Plugin) {
    _inherits(ExpandContractions, _Plugin);

    function ExpandContractions() {
      _classCallCheck(this, ExpandContractions);

      return _possibleConstructorReturn(this, (ExpandContractions.__proto__ || Object.getPrototypeOf(ExpandContractions)).apply(this, arguments));
    }

    _createClass(ExpandContractions, [{
      key: 'replace',
      value: function replace(source, regExp, newString, checkString, checkStrings) {
        var newtext;
        newtext = source.replace(regExp, newString);
        if (checkStrings.length > 1 && newtext !== source) {
          App.log.logWarning('Replaced some "' + checkString + '" with "' + checkStrings[0] + '": check that it didn\'t mean "' + checkStrings.slice(1).join('\" or \"') + '" instead');
        }
        return newtext;
      }
    }, {
      key: 'main_editor',
      value: function main_editor(callNext) {
        var newtext, source, ss;
        source = this.WM.Editor.readSource();
        newtext = source;

        newtext = this.replace(newtext, /([a-z])'re/ig, '$1 are', "'re", ["are"]);
        newtext = this.replace(newtext, /([a-z])'ve/ig, '$1 have', "'ve", ["have"]);
        newtext = this.replace(newtext, /([a-z])'ll/ig, '$1 will', "'ll", ["will", "shall"]);
        newtext = this.replace(newtext, /([a-z])'d/ig, '$1 would', "'d", ["would", "had"]);
        newtext = this.replace(newtext, /(c)an't/ig, '$1annot', "can't", ["cannot"]);
        newtext = this.replace(newtext, /(w)on't/ig, '$1ill not', "won't", ["will not"]);
        newtext = this.replace(newtext, /([a-z])n't/ig, '$1 not', "n't", ["not"]);
        newtext = this.replace(newtext, /(here|there)'s/ig, '$1 is', "here/there's", ["here/there is", "here/there has"]);
        newtext = this.replace(newtext, /(g)onna/ig, '$1oing to', "gonna", ["going to"]);

        newtext = this.replace(newtext, /([a-z])'s (been)/ig, '$1 has $2', "'s been", ["has been"]);
        newtext = this.replace(newtext, /(let)'s/ig, '$1 us', "let's", ["let us"]);
        newtext = this.replace(newtext, /(it)'(s own)/ig, '$1$2', "it's own", ["its own"]);
        ss = newtext.match(/[a-z]'s/gi);
        if (ss) {
          App.log.logWarning("Found " + ss.length + " instances of \"'s\": " + "check if they can be replaced with \"is\", \"has\", ...");
        }
        if (newtext !== source) {
          this.WM.Editor.writeSource(newtext);
          App.log.logInfo("Expanded contractions");
        }
        if (callNext) {
          return callNext();
        }
      }
    }]);

    return ExpandContractions;
  }(Plugin);

  ;

  ExpandContractions.conf_default = {
    enabled: true,
    editor_menu: ["Text plugins", "Expand contractions"]
  };

  return ExpandContractions;
}.call(undefined);

},{"../app":399,"./_Plugin":432}],424:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var App,
    Plugin,
    jssc,
    ref,
    boundMethodCheck = function boundMethodCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new Error('Bound instance method accessed before binding');
  }
};

var _require = require('../modules/libs');

jssc = _require.jssc;


App = require('../app');

var _require2 = require('./_Plugin');

Plugin = _require2.Plugin;


ref = module.exports.FixBacklinkFragments = function () {
  var readTarget;

  var FixBacklinkFragments = function (_Plugin) {
    _inherits(FixBacklinkFragments, _Plugin);

    function FixBacklinkFragments() {
      _classCallCheck(this, FixBacklinkFragments);

      var _this = _possibleConstructorReturn(this, (FixBacklinkFragments.__proto__ || Object.getPrototypeOf(FixBacklinkFragments)).apply(this, arguments));

      _this.makeBotUI = _this.makeBotUI.bind(_this);
      _this.fixLinks = _this.fixLinks.bind(_this);
      _this.fixArchWikiLinks = _this.fixArchWikiLinks.bind(_this);
      _this.fixArchWikiLink = _this.fixArchWikiLink.bind(_this);
      _this.fixFragment = _this.fixFragment.bind(_this);
      _this.mainAutoFindSections = _this.mainAutoFindSections.bind(_this);
      _this.mainAutoRead = _this.mainAutoRead.bind(_this);
      _this.mainAutoWrite = _this.mainAutoWrite.bind(_this);
      _this.mainAutoEnd = _this.mainAutoEnd.bind(_this);
      return _this;
    }

    _createClass(FixBacklinkFragments, [{
      key: 'makeBotUI',
      value: function makeBotUI() {
        var classes, divMain, label, target;
        boundMethodCheck(this, ref);

        var _jssc = jssc({
          fixBacklinkFragments: {
            "& input[type='text']": {
              marginLeft: '0.33em'
            }
          }
        });

        classes = _jssc.classes;

        divMain = document.createElement('div');
        divMain.id = "WikiMonkey-FixBacklinkFragments";
        divMain.className = classes.fixBacklinkFragments;
        label = document.createElement('span');
        label.innerHTML = 'Target page:';
        divMain.appendChild(label);
        target = document.createElement('input');
        target.setAttribute('type', 'text');
        target.id = "WikiMonkey-FixBacklinkFragments-Target";
        if (this.WM.WhatLinksHere.isWhatLinksHerePage()) {
          target.value = this.WM.WhatLinksHere.getTitle();
        }
        divMain.appendChild(target);
        return divMain;
      }
    }, {
      key: 'fixLinks',
      value: function fixLinks(source, target, sections) {
        var fixedFragment, i, len, link, links, newText, newlink, oldlink, prevId, rawfragment;
        boundMethodCheck(this, ref);

        links = this.WM.Parser.findInternalLinks(source, null, target);
        newText = "";
        prevId = 0;
        for (i = 0, len = links.length; i < len; i++) {
          link = links[i];
          newText += source.substring(prevId, link.index);
          newlink = link.rawLink;
          rawfragment = link.fragment;
          if (rawfragment) {
            fixedFragment = this.fixFragment(rawfragment, sections);
            if (fixedFragment === true) {
              null;
            } else if (fixedFragment) {
              oldlink = newlink;
              newlink = "[[" + target + "#" + fixedFragment + (link.anchor ? "|" + link.anchor : "") + "]]";
              App.log.logInfo("Fixed broken link fragment: " + oldlink + " -> " + App.log.linkToWikiPage(link.link, newlink));
            } else {
              App.log.logWarning("Cannot fix broken link fragment: " + App.log.linkToWikiPage(link.link, newlink));
            }
          }
          newText += newlink;
          prevId = link.index + link.length;
        }
        newText += source.substr(prevId);

        if (location.hostname === 'wiki.archlinux.org') {
          newText = this.fixArchWikiLinks(newText, target, sections);
        }
        return newText;
      }
    }, {
      key: 'fixArchWikiLinks',
      value: function fixArchWikiLinks(source, target, sections) {
        var i, j, len, len1, link, link2, links, links2, newText1, newText2, prevId;
        boundMethodCheck(this, ref);
        links = this.WM.Parser.findTemplates(source, 'Related');
        newText1 = "";
        prevId = 0;
        for (i = 0, len = links.length; i < len; i++) {
          link = links[i];
          newText1 += source.substring(prevId, link.index);
          newText1 += this.fixArchWikiLink(target, sections, link, 1);
          prevId = link.index + link.length;
        }
        newText1 += source.substr(prevId);
        links2 = this.WM.Parser.findTemplates(newText1, 'Related2');
        newText2 = "";
        prevId = 0;
        for (j = 0, len1 = links2.length; j < len1; j++) {
          link2 = links2[j];
          newText2 += newText1.substring(prevId, link2.index);
          newText2 += this.fixArchWikiLink(target, sections, link2, 2);
          prevId = link2.index + link2.length;
        }
        newText2 += newText1.substr(prevId);
        return newText2;
      }
    }, {
      key: 'fixArchWikiLink',
      value: function fixArchWikiLink(target, sections, template, expectedArgs) {
        var anchor, args, fixedFragment, fragId, link, ltitle, newlink, rawfragment;
        boundMethodCheck(this, ref);
        args = template.arguments;

        if (args.length === expectedArgs) {
          link = args[0].value;
          fragId = link.indexOf('#');
          if (fragId > -1) {
            ltitle = link.substring(0, fragId);

            if (this.WM.Parser.compareArticleTitles(ltitle, target)) {
              rawfragment = link.substr(fragId + 1);
              fixedFragment = this.fixFragment(rawfragment, sections);
              if (fixedFragment === true) {
                null;
              } else if (fixedFragment) {
                anchor = args[1] ? "|" + args[1].value : "";
                newlink = "{{" + template.title + "|" + target + "#" + fixedFragment + anchor + "}}";
                App.log.logInfo("Fixed broken link fragment: " + template.rawTransclusion + " -> " + App.log.linkToWikiPage(link, newlink));
                return newlink;
              } else {
                App.log.logWarning("Cannot fix broken link fragment: " + App.log.linkToWikiPage(link, template.rawTransclusion));
              }
            }
          }
        } else {
          App.log.logWarning("Template:" + template.title + " must have " + expectedArgs + " and only " + expectedArgs + (expectedArgs > 1 ? " arguments: " : " argument: ") + template.rawTransclusion);
        }
        return template.rawTransclusion;
      }
    }, {
      key: 'fixFragment',
      value: function fixFragment(rawfragment, sections) {
        var fragment, i, len, section;
        boundMethodCheck(this, ref);
        if (rawfragment) {
          fragment = this.WM.Parser.squashContiguousWhitespace(rawfragment).trim();
          if (sections.indexOf(fragment) < 0) {
            for (i = 0, len = sections.length; i < len; i++) {
              section = sections[i];

              if (section.toLowerCase() === fragment.toLowerCase()) {
                return section;
              }
            }
            return false;
          } else {
            return true;
          }
        } else {
          return true;
        }
      }
    }, {
      key: 'main_bot',
      value: function main_bot(title, callBot, chainArgs) {
        var params, summary, target;
        summary = this.conf.edit_summary;
        target = readTarget();
        App.log.logHidden("Target page: " + target);
        if (target) {
          if (chainArgs === null) {
            params = {
              'action': 'parse',
              'prop': 'sections',
              'page': target,
              'redirects': 1
            };
            App.log.logWarning("If some articles in the list are linking to the target article through a redirect, you should process the backlinks of that redirect page separately through its Special:WhatLinksHere page, as this plugin can only fix links that exactly match the title of the target article.\nIn order to save time you are advised to hide the redirects in the page lists that allow to do so.");
            return this.WM.MW.callAPIGet(params, this.mainAutoFindSections, [title, target, summary, callBot], null);
          } else {
            return this.mainAutoRead(target, chainArgs, title, summary, callBot);
          }
        } else {
          App.log.logError('The target page cannot be empty');
          return callBot(false, null);
        }
      }
    }, {
      key: 'mainAutoFindSections',
      value: function mainAutoFindSections(res, args) {
        var callBot, i, len, ref1, section, sections, summary, target, title;
        boundMethodCheck(this, ref);
        title = args[0];
        target = args[1];
        summary = args[2];
        callBot = args[3];
        sections = [];
        if (res.parse) {
          ref1 = res.parse.sections;
          for (i = 0, len = ref1.length; i < len; i++) {
            section = ref1[i];
            sections.push(this.WM.Parser.squashContiguousWhitespace(section.line).trim());
          }
          return this.mainAutoRead(target, sections, title, summary, callBot);
        } else {
          App.log.logError("The set target page, " + target + ", seems not to exist");
          if (res.error) {
            return callBot(res.error.code, sections);
          } else {
            return callBot(false, sections);
          }
        }
      }
    }, {
      key: 'mainAutoRead',
      value: function mainAutoRead(target, sections, title, summary, callBot) {
        boundMethodCheck(this, ref);
        return this.WM.MW.callQueryEdit(title, this.mainAutoWrite, [target, summary, callBot, sections]);
      }
    }, {
      key: 'mainAutoWrite',
      value: function mainAutoWrite(title, source, timestamp, edittoken, args) {
        var callBot, newtext, sections, summary, target;
        boundMethodCheck(this, ref);
        target = args[0];
        summary = args[1];
        callBot = args[2];
        sections = args[3];
        newtext = this.fixLinks(source, target, sections);
        if (newtext !== source) {
          return this.WM.MW.callAPIPost({
            action: "edit",
            bot: "1",
            title: title,
            summary: summary,
            text: newtext,
            basetimestamp: timestamp,
            token: edittoken
          }, this.mainAutoEnd, [callBot, sections], null);
        } else {
          return callBot(0, sections);
        }
      }
    }, {
      key: 'mainAutoEnd',
      value: function mainAutoEnd(res, args) {
        var callBot, sections;
        boundMethodCheck(this, ref);
        callBot = args[0];
        sections = args[1];
        if (res.edit && res.edit.result === 'Success') {
          return callBot(1, sections);
        } else if (res.error) {
          App.log.logError(res.error.info + " (" + res.error.code + ")");
          return callBot(res.error.code, sections);
        } else {
          return callBot(false, sections);
        }
      }
    }]);

    return FixBacklinkFragments;
  }(Plugin);

  ;

  FixBacklinkFragments.conf_default = {
    enabled: true,
    bot_label: "Fix links to specific sections of a target page",
    edit_summary: "fix links to specific sections"
  };

  readTarget = function readTarget() {
    return document.getElementById("WikiMonkey-FixBacklinkFragments-Target").value;
  };

  return FixBacklinkFragments;
}.call(undefined);

},{"../app":399,"../modules/libs":412,"./_Plugin":432}],425:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var App,
    Plugin,
    Str,
    ref,
    boundMethodCheck = function boundMethodCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new Error('Bound instance method accessed before binding');
  }
};

App = require('../app');

var _require = require('./_Plugin');

Plugin = _require.Plugin;


Str = require('@kynikos/misc/dist/Str');

ref = module.exports.FixDoubleRedirects = function () {
  var FixDoubleRedirects = function (_Plugin) {
    _inherits(FixDoubleRedirects, _Plugin);

    function FixDoubleRedirects() {
      _classCallCheck(this, FixDoubleRedirects);

      var _this = _possibleConstructorReturn(this, (FixDoubleRedirects.__proto__ || Object.getPrototypeOf(FixDoubleRedirects)).apply(this, arguments));

      _this.process_redirect = _this.process_redirect.bind(_this);
      return _this;
    }

    _createClass(FixDoubleRedirects, [{
      key: 'main_special',
      value: function () {
        var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(callNext) {
          var doubleRedirect, error, i, len, namespaces, results, siteinfo, _ref2, _siteinfo;

          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  App.log.logInfo("Fixing double redirects ...");
                  _context.next = 3;
                  return this.WM.MW.getSpecialList("DoubleRedirects", "namespaces");

                case 3:
                  _ref2 = _context.sent;
                  results = _ref2.results;
                  siteinfo = _ref2.siteinfo;
                  _siteinfo = siteinfo;
                  namespaces = _siteinfo.namespaces;

                  results.reverse();
                  _context.prev = 9;
                  i = 0, len = results.length;

                case 11:
                  if (!(i < len)) {
                    _context.next = 18;
                    break;
                  }

                  doubleRedirect = results[i];
                  _context.next = 15;
                  return this.process_redirect(doubleRedirect, namespaces);

                case 15:
                  i++;
                  _context.next = 11;
                  break;

                case 18:
                  _context.next = 25;
                  break;

                case 20:
                  _context.prev = 20;
                  _context.t0 = _context['catch'](9);

                  error = _context.t0;
                  App.log.logError(error.message);
                  return _context.abrupt('return', false);

                case 25:
                  App.log.logInfo("Fixed double redirects");

                  if (!callNext) {
                    _context.next = 28;
                    break;
                  }

                  return _context.abrupt('return', callNext());

                case 28:
                case 'end':
                  return _context.stop();
              }
            }
          }, _callee, this, [[9, 20]]);
        }));

        function main_special(_x) {
          return _ref.apply(this, arguments);
        }

        return main_special;
      }()
    }, {
      key: 'process_redirect',
      value: function () {
        var _ref3 = _asyncToGenerator(regeneratorRuntime.mark(function _callee2(doubleRedirect, namespaces) {
          var doubleRedirectSource, edittoken, middleRedirect, middleRedirectSource, middleRedirectTitle, middleTarget, newTarget, newTargetAltAnchor, newTargetFragment, newTargetInterlanguage, newTargetNamespace, newTargetTitle, newText, oldTarget, rawMiddleTarget, rawOldTarget, res, source, timestamp, _ref4;

          return regeneratorRuntime.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  boundMethodCheck(this, ref);
                  _context2.next = 3;
                  return this.WM.MW.callQueryEdit(doubleRedirect.title);

                case 3:
                  _ref4 = _context2.sent;
                  source = _ref4.source;
                  timestamp = _ref4.timestamp;
                  edittoken = _ref4.edittoken;

                  doubleRedirectSource = source;
                  middleRedirectTitle = [namespaces[doubleRedirect.databaseResult.b_namespace]['*'], doubleRedirect.databaseResult.b_title].join(':');
                  _context2.next = 11;
                  return this.WM.MW.callQuery({
                    prop: "revisions",
                    rvprop: "content",
                    titles: middleRedirectTitle
                  });

                case 11:
                  middleRedirect = _context2.sent;

                  middleRedirectSource = middleRedirect.revisions[0]["*"];
                  App.log.logInfo('Processing ' + App.log.linkToWikiPage(doubleRedirect.title, doubleRedirect.title) + ' ...');
                  rawOldTarget = doubleRedirectSource.match(/\s*#redirect\s*[^\n]+/i);
                  oldTarget = this.WM.Parser.findInternalLinks(rawOldTarget[0], null)[0];
                  rawMiddleTarget = middleRedirectSource.match(/\s*#redirect\s*[^\n]+/i);
                  middleTarget = this.WM.Parser.findInternalLinks(rawMiddleTarget[0], null)[0];
                  newTargetFragment = function () {
                    if (oldTarget.fragment) {
                      return "#" + oldTarget.fragment;
                    } else if (middleTarget.fragment) {
                      return "#" + middleTarget.fragment;
                    }
                    return "";
                  }();
                  newTargetAltAnchor = function () {
                    if (oldTarget.anchor) {
                      return "|" + oldTarget.anchor;
                    } else if (middleTarget.anchor) {
                      return "|" + middleTarget.anchor;
                    }
                    return "";
                  }();
                  newTargetInterlanguage = doubleRedirect.databaseResult.c_interwiki ? doubleRedirect.databaseResult.c_interwiki + ":" : "";
                  newTargetNamespace = function () {
                    var cns;
                    cns = namespaces[doubleRedirect.databaseResult.c_namespace]["*"];
                    if (cns) {
                      return this.WM.Parser.squashContiguousWhitespace(cns) + ":";
                    }
                    return "";
                  }();
                  newTargetTitle = this.WM.Parser.squashContiguousWhitespace(doubleRedirect.databaseResult.c_title);
                  newTarget = '[[' + newTargetInterlanguage + newTargetNamespace + ('' + newTargetTitle + newTargetFragment + newTargetAltAnchor + ']]');
                  newText = Str.overwriteFor(doubleRedirectSource, newTarget, oldTarget.index, oldTarget.length);

                  if (!(newText !== doubleRedirectSource)) {
                    _context2.next = 33;
                    break;
                  }

                  _context2.next = 28;
                  return this.WM.MW.callAPIPost({
                    action: "edit",
                    bot: "1",
                    title: doubleRedirect.title,
                    summary: this.conf.edit_summary,
                    text: newText,
                    b1asetimestamp: timestamp,
                    token: edittoken
                  });

                case 28:
                  res = _context2.sent;

                  if (!(!res.edit || res.edit.result !== 'Success')) {
                    _context2.next = 31;
                    break;
                  }

                  throw new Error(res.error.info + ' (' + res.error.code + ')');

                case 31:
                  _context2.next = 34;
                  break;

                case 33:
                  return _context2.abrupt('return', App.log.logWarning('Could not fix ' + App.log.linkToWikiPage(doubleRedirect.title, doubleRedirect.title)));

                case 34:
                case 'end':
                  return _context2.stop();
              }
            }
          }, _callee2, this);
        }));

        function process_redirect(_x2, _x3) {
          return _ref3.apply(this, arguments);
        }

        return process_redirect;
      }()
    }]);

    return FixDoubleRedirects;
  }(Plugin);

  ;

  FixDoubleRedirects.conf_default = {
    enabled: true,
    special_menu: ["Fix double redirects"],
    edit_summary: "fix double redirect"
  };

  return FixDoubleRedirects;
}.call(undefined);

},{"../app":399,"./_Plugin":432,"@kynikos/misc/dist/Str":3}],426:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var App, Plugin;

App = require('../app');

var _require = require('./_Plugin');

Plugin = _require.Plugin;


module.exports.FixFragments = function () {
  var FixFragments = function (_Plugin) {
    _inherits(FixFragments, _Plugin);

    function FixFragments() {
      _classCallCheck(this, FixFragments);

      return _possibleConstructorReturn(this, (FixFragments.__proto__ || Object.getPrototypeOf(FixFragments)).apply(this, arguments));
    }

    _createClass(FixFragments, [{
      key: 'fixLinks',
      value: function fixLinks(source) {
        var i, ilinks, j, len, len1, link, newtext1, newtext2, prevId, rawfragment, sections, slinks, title;
        title = this.WM.Editor.getTitle();
        sections = this.WM.Parser.findSectionHeadings(source).sections;
        slinks = this.WM.Parser.findSectionLinks(source);
        newtext1 = "";
        prevId = 0;
        for (i = 0, len = slinks.length; i < len; i++) {
          link = slinks[i];
          newtext1 += source.substring(prevId, link.index);
          newtext1 += this.fixLink(source, sections, link.rawLink, link.fragment, link.anchor);
          prevId = link.index + link.length;
        }
        newtext1 += source.substr(prevId);

        ilinks = this.WM.Parser.findInternalLinks(newtext1, null, title);
        newtext2 = "";
        prevId = 0;
        for (j = 0, len1 = ilinks.length; j < len1; j++) {
          link = ilinks[j];
          newtext2 += newtext1.substring(prevId, link.index);
          rawfragment = link.fragment;
          if (rawfragment) {
            newtext2 += this.fixLink(newtext1, sections, link.rawLink, rawfragment, link.anchor);
          } else {
            newtext2 += link.rawLink;
          }
          prevId = link.index + link.length;
        }
        newtext2 += newtext1.substr(prevId);
        return newtext2;
      }
    }, {
      key: 'fixLink',
      value: function fixLink(source, sections, rawlink, rawfragment, lalt) {
        var dotFragment, dotHeading, escHeading, fragment, heading, i, len, section;
        fragment = this.WM.Parser.squashContiguousWhitespace(rawfragment).trim();
        for (i = 0, len = sections.length; i < len; i++) {
          section = sections[i];
          heading = section.cleanheading;
          dotHeading = this.WM.Parser.dotEncode(heading);
          dotFragment = this.WM.Parser.dotEncode(fragment);
          if (dotHeading.toLowerCase() === dotFragment.toLowerCase()) {
            if (fragment === dotFragment) {
              return "[[#" + dotHeading + (lalt ? "|" + lalt : "") + "]]";
            } else {
              escHeading = this.WM.Parser.dotEncodeLinkBreakingFragmentCharacters(heading);
              return "[[#" + escHeading + (lalt ? "|" + lalt : "") + "]]";
            }
          }
        }

        App.log.logWarning("Cannot fix broken section link: " + rawlink);
        return rawlink;
      }
    }, {
      key: 'main_editor',
      value: function main_editor(callNext) {
        var newtext, source;
        source = this.WM.Editor.readSource();
        newtext = this.fixLinks(source);
        if (newtext !== source) {
          this.WM.Editor.writeSource(newtext);
          App.log.logInfo("Fixed section links");
        } else {
          App.log.logInfo("No fixable section links found");
        }
        if (callNext) {
          return callNext();
        }
      }
    }]);

    return FixFragments;
  }(Plugin);

  ;

  FixFragments.conf_default = {
    enabled: true,
    editor_menu: ["Text plugins", "Fix section links"]
  };

  return FixFragments;
}.call(undefined);

},{"../app":399,"./_Plugin":432}],427:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var App,
    Plugin,
    ref,
    boundMethodCheck = function boundMethodCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new Error('Bound instance method accessed before binding');
  }
},
    indexOf = [].indexOf;

App = require('../app');

var _require = require('./_Plugin');

Plugin = _require.Plugin;


ref = module.exports.FixLinkFragments = function () {
  var FixLinkFragments = function (_Plugin) {
    _inherits(FixLinkFragments, _Plugin);

    function FixLinkFragments() {
      _classCallCheck(this, FixLinkFragments);

      var _this = _possibleConstructorReturn(this, (FixLinkFragments.__proto__ || Object.getPrototypeOf(FixLinkFragments)).apply(this, arguments));

      _this.processLink = _this.processLink.bind(_this);
      _this.processLinkContinue = _this.processLinkContinue.bind(_this);
      _this.fixFragment = _this.fixFragment.bind(_this);
      _this.findArchWikiLinks = _this.findArchWikiLinks.bind(_this);
      _this.findArchWikiLinks2 = _this.findArchWikiLinks2.bind(_this);
      _this.processArchWikiLink = _this.processArchWikiLink.bind(_this);
      _this.processArchWikiLinkContinue = _this.processArchWikiLinkContinue.bind(_this);
      _this.mainContinue = _this.mainContinue.bind(_this);
      _this.mainEnd = _this.mainEnd.bind(_this);
      return _this;
    }

    _createClass(FixLinkFragments, [{
      key: 'processLink',
      value: function processLink(title, iwprefixes, links, index, source, newText, prevId, call, callArgs) {
        var link, params, rawfragment, ref1, target;
        boundMethodCheck(this, ref);
        if (links[index]) {
          link = links[index];
          rawfragment = link.fragment;
          if (!(link.namespace != null && (ref1 = link.namespace.toLowerCase(), indexOf.call(iwprefixes, ref1) >= 0)) && rawfragment) {
            App.log.logInfo("Processing " + App.log.linkToWikiPage(link.link, link.rawLink) + " ...");
            target = (link.namespace ? link.namespace + ":" : "") + link.title;

            if (!this.WM.Parser.compareArticleTitles(target, title)) {
              params = {
                'action': 'parse',
                'prop': 'sections',
                'page': target,
                'redirects': 1
              };
              return this.WM.MW.callAPIGet(params, this.processLinkContinue, [link, target, rawfragment, iwprefixes, links, index, source, newText, prevId, title, call, callArgs], null);
            } else {
              index++;
              return this.processLink(title, iwprefixes, links, index, source, newText, prevId, call, callArgs);
            }
          } else {
            index++;
            return this.processLink(title, iwprefixes, links, index, source, newText, prevId, call, callArgs);
          }
        } else {
          newText += source.substr(prevId);
          return call(newText, iwprefixes, callArgs);
        }
      }
    }, {
      key: 'processLinkContinue',
      value: function processLinkContinue(res, args) {
        var call, callArgs, fixedFragment, i, index, iwprefixes, len, link, links, newText, prevId, rawfragment, ref1, section, sections, source, target, title;
        boundMethodCheck(this, ref);
        link = args[0];
        target = args[1];
        rawfragment = args[2];
        iwprefixes = args[3];
        links = args[4];
        index = args[5];
        source = args[6];
        newText = args[7];
        prevId = args[8];
        title = args[9];
        call = args[10];
        callArgs = args[11];

        if (res.parse) {
          sections = [];
          ref1 = res.parse.sections;
          for (i = 0, len = ref1.length; i < len; i++) {
            section = ref1[i];
            sections.push(this.WM.Parser.squashContiguousWhitespace(section.line).trim());
          }
          fixedFragment = this.fixFragment(rawfragment, sections);
          newText += source.substring(prevId, link.index);
          if (fixedFragment === true) {
            newText += link.rawLink;
          } else if (fixedFragment) {
            newText += "[[" + target + "#" + fixedFragment + (link.anchor ? "|" + link.anchor : "") + "]]";
          } else {
            App.log.logWarning("Cannot fix broken link fragment: " + App.log.linkToWikiPage(link.link, link.rawLink));
            newText += link.rawLink;
          }
          prevId = link.index + link.length;
        }
        index++;
        return this.processLink(title, iwprefixes, links, index, source, newText, prevId, call, callArgs);
      }
    }, {
      key: 'fixFragment',
      value: function fixFragment(rawfragment, sections) {
        var dotFragment, dotSection, fragment, i, len, section;
        boundMethodCheck(this, ref);
        fragment = this.WM.Parser.squashContiguousWhitespace(rawfragment).trim();
        if (sections.indexOf(fragment) < 0) {
          for (i = 0, len = sections.length; i < len; i++) {
            section = sections[i];
            dotSection = this.WM.Parser.dotEncode(section);
            dotFragment = this.WM.Parser.dotEncode(fragment);
            if (dotSection.toLowerCase() === dotFragment.toLowerCase()) {
              if (fragment === dotFragment) {
                return dotSection;
              } else {
                return this.WM.Parser.dotEncodeLinkBreakingFragmentCharacters(section);
              }
            }
          }
          return false;
        } else {
          return true;
        }
      }
    }, {
      key: 'findArchWikiLinks',
      value: function findArchWikiLinks(newText, iwprefixes, callArgs) {
        var templates, title;
        boundMethodCheck(this, ref);
        templates = this.WM.Parser.findTemplates(newText, 'Related');
        title = this.WM.Editor.getTitle();
        return this.processArchWikiLink(title, iwprefixes, templates, 1, 0, newText, "", 0, this.findArchWikiLinks2, callArgs);
      }
    }, {
      key: 'findArchWikiLinks2',
      value: function findArchWikiLinks2(newText, iwprefixes, callArgs) {
        var templates, title;
        boundMethodCheck(this, ref);
        templates = this.WM.Parser.findTemplates(newText, 'Related2');
        title = this.WM.Editor.getTitle();
        return this.processArchWikiLink(title, iwprefixes, templates, 2, 0, newText, "", 0, this.mainEnd, callArgs);
      }
    }, {
      key: 'processArchWikiLink',
      value: function processArchWikiLink(title, iwprefixes, templates, expectedArgs, index, source, newText, prevId, call, callArgs) {
        var args, fragId, link, params, rawfragment, rawtarget, target, template;
        boundMethodCheck(this, ref);
        if (templates[index]) {
          template = templates[index];
          args = template.arguments;

          if (args.length === expectedArgs) {
            link = args[0].value;
            fragId = link.indexOf('#');
            if (fragId > -1) {
              rawtarget = link.substring(0, fragId);
              target = this.WM.Parser.squashContiguousWhitespace(rawtarget).trim();
              rawfragment = link.substr(fragId + 1);
              if (rawfragment) {
                if (!this.WM.Parser.compareArticleTitles(target, title)) {
                  App.log.logInfo("Processing " + App.log.linkToWikiPage(link, template.rawTransclusion) + " ...");
                  params = {
                    'action': 'parse',
                    'prop': 'sections',
                    'page': target,
                    'redirects': 1
                  };
                  return this.WM.MW.callAPIGet(params, this.processArchWikiLinkContinue, [template, target, rawfragment, iwprefixes, templates, expectedArgs, index, source, newText, prevId, title, call, callArgs], null);
                } else {
                  index++;
                  return this.processArchWikiLink(title, iwprefixes, templates, expectedArgs, index, source, newText, prevId, call, callArgs);
                }
              } else {
                index++;
                return this.processArchWikiLink(title, iwprefixes, templates, expectedArgs, index, source, newText, prevId, call, callArgs);
              }
            } else {
              index++;
              return this.processArchWikiLink(title, iwprefixes, templates, expectedArgs, index, source, newText, prevId, call, callArgs);
            }
          } else {
            App.log.logWarning("Template:" + template.title + " must have " + expectedArgs + " and only " + expectedArgs + (expectedArgs > 1 ? " arguments: " : " argument: ") + template.rawTransclusion);
            index++;
            return this.processArchWikiLink(title, iwprefixes, templates, expectedArgs, index, source, newText, prevId, call, callArgs);
          }
        } else {
          newText += source.substr(prevId);
          return call(newText, iwprefixes, callArgs);
        }
      }
    }, {
      key: 'processArchWikiLinkContinue',
      value: function processArchWikiLinkContinue(res, args) {
        var anchor, call, callArgs, expectedArgs, fixedFragment, i, index, iwprefixes, len, newText, prevId, rawfragment, ref1, section, sections, source, target, template, templates, title;
        boundMethodCheck(this, ref);
        template = args[0];
        target = args[1];
        rawfragment = args[2];
        iwprefixes = args[3];
        templates = args[4];
        expectedArgs = args[5];
        index = args[6];
        source = args[7];
        newText = args[8];
        prevId = args[9];
        title = args[10];
        call = args[11];
        callArgs = args[12];

        if (res.parse) {
          sections = [];
          ref1 = res.parse.sections;
          for (i = 0, len = ref1.length; i < len; i++) {
            section = ref1[i];
            sections.push(this.WM.Parser.squashContiguousWhitespace(section.line).trim());
          }
          fixedFragment = this.fixFragment(rawfragment, sections);
          newText += source.substring(prevId, template.index);
          if (fixedFragment === true) {
            newText += template.rawTransclusion;
          } else if (fixedFragment) {
            anchor = template.arguments[1] ? "|" + template.arguments[1].value : "";
            newText += "{{" + template.title + "|" + target + "#" + fixedFragment + anchor + "}}";
          } else {
            App.log.logWarning("Cannot fix broken link fragment: " + App.log.linkToWikiPage(target, template.rawTransclusion));
            newText += template.rawTransclusion;
          }
          prevId = template.index + template.length;
        }
        index++;
        return this.processArchWikiLink(title, iwprefixes, templates, expectedArgs, index, source, newText, prevId, call, callArgs);
      }
    }, {
      key: 'main_editor',
      value: function () {
        var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(callNext) {
          var iw, iwprefixes, links, res, source, title;
          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  source = this.WM.Editor.readSource();
                  App.log.logInfo("Fixing links to sections of other articles ...");
                  title = this.WM.Editor.getTitle();
                  _context.next = 5;
                  return this.WM.MW.getInterwikiMap(title);

                case 5:
                  res = _context.sent;

                  iwprefixes = function () {
                    var i, len, ref1, results;
                    ref1 = res.query.interwikimap;
                    results = [];
                    for (i = 0, len = ref1.length; i < len; i++) {
                      iw = ref1[i];
                      results.push(iw.prefix);
                    }
                    return results;
                  }();
                  links = this.WM.Parser.findInternalLinks(source, null, null);
                  return _context.abrupt('return', this.processLink(title, iwprefixes, links, 0, source, "", 0, this.mainContinue, callNext));

                case 9:
                case 'end':
                  return _context.stop();
              }
            }
          }, _callee, this);
        }));

        function main_editor(_x) {
          return _ref.apply(this, arguments);
        }

        return main_editor;
      }()
    }, {
      key: 'mainContinue',
      value: function mainContinue(newText, iwprefixes, callNext) {
        var templates;
        boundMethodCheck(this, ref);

        if (location.hostname === 'wiki.archlinux.org') {
          return templates = this.findArchWikiLinks(newText, iwprefixes, callNext);
        } else {
          return this.mainEnd(newText, iwprefixes, callNext);
        }
      }
    }, {
      key: 'mainEnd',
      value: function mainEnd(newText, iwprefixes, callNext) {
        var source;
        boundMethodCheck(this, ref);
        source = this.WM.Editor.readSource();
        if (newText !== source) {
          this.WM.Editor.writeSource(newText);
          App.log.logInfo("Replaced links to sections of other articles");
        } else {
          App.log.logInfo("No fixable links to sections of other articles " + "found");
        }
        if (callNext) {
          return callNext();
        }
      }
    }]);

    return FixLinkFragments;
  }(Plugin);

  ;

  FixLinkFragments.conf_default = {
    enabled: true,
    editor_menu: ["Query plugins", "Fix external section links"]
  };

  return FixLinkFragments;
}.call(undefined);

},{"../app":399,"./_Plugin":432}],428:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var App, Plugin;

App = require('../app');

var _require = require('./_Plugin');

Plugin = _require.Plugin;


module.exports.MultipleLineBreaks = function () {
  var MultipleLineBreaks = function (_Plugin) {
    _inherits(MultipleLineBreaks, _Plugin);

    function MultipleLineBreaks() {
      _classCallCheck(this, MultipleLineBreaks);

      return _possibleConstructorReturn(this, (MultipleLineBreaks.__proto__ || Object.getPrototypeOf(MultipleLineBreaks)).apply(this, arguments));
    }

    _createClass(MultipleLineBreaks, [{
      key: 'main_editor',
      value: function main_editor(callNext) {
        var newtext, source;
        source = this.WM.Editor.readSource();
        newtext = source;
        newtext = newtext.replace(/[\n]{3,}/g, '\n\n');
        if (newtext !== source) {
          this.WM.Editor.writeSource(newtext);
          App.log.logInfo("Removed multiple line breaks");
        }
        if (callNext) {
          return callNext();
        }
      }
    }]);

    return MultipleLineBreaks;
  }(Plugin);

  ;

  MultipleLineBreaks.conf_default = {
    enabled: true,
    editor_menu: ["Text plugins", "Squash multiple line breaks"]
  };

  return MultipleLineBreaks;
}.call(undefined);

},{"../app":399,"./_Plugin":432}],429:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var App,
    Plugin,
    jssc,
    ref,
    boundMethodCheck = function boundMethodCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new Error('Bound instance method accessed before binding');
  }
};

var _require = require('../modules/libs');

jssc = _require.jssc;


App = require('../app');

var _require2 = require('./_Plugin');

Plugin = _require2.Plugin;


ref = module.exports.SimpleReplace = function () {
  var configuration, _makeUI, storeRegExp;

  var SimpleReplace = function (_Plugin) {
    _inherits(SimpleReplace, _Plugin);

    function SimpleReplace() {
      _classCallCheck(this, SimpleReplace);

      var _this = _possibleConstructorReturn(this, (SimpleReplace.__proto__ || Object.getPrototypeOf(SimpleReplace)).apply(this, arguments));

      _this.storeConfiguration = _this.storeConfiguration.bind(_this);
      _this.mainAutoWrite = _this.mainAutoWrite.bind(_this);
      _this.mainAutoEnd = _this.mainAutoEnd.bind(_this);
      return _this;
    }

    _createClass(SimpleReplace, [{
      key: 'makeUI',
      value: function makeUI() {
        return _makeUI();
      }
    }, {
      key: 'makeBotUI',
      value: function makeBotUI() {
        var divMain, par3, summary, summaryLabel;
        divMain = _makeUI();
        par3 = document.createElement('div');
        summaryLabel = document.createElement('span');
        summaryLabel.innerHTML = 'Edit summary:';
        summary = document.createElement('input');
        summary.setAttribute('type', 'text');
        summary.id = "WikiMonkey-SimpleReplace-Summary";
        par3.appendChild(summaryLabel);
        par3.appendChild(summary);
        divMain.appendChild(par3);
        return divMain;
      }
    }, {
      key: 'storeConfiguration',
      value: function storeConfiguration() {
        boundMethodCheck(this, ref);
        configuration = {
          pattern: document.getElementById("WikiMonkey-SimpleReplace-RegExp").value,
          ignoreCase: document.getElementById("WikiMonkey-SimpleReplace-IgnoreCase").checked,
          newString: document.getElementById("WikiMonkey-SimpleReplace-NewString").value
        };
        App.log.logHidden("Pattern: " + configuration.pattern);
        App.log.logHidden("Ignore case: " + configuration.ignoreCase);
        return App.log.logHidden("New string: " + configuration.newString);
      }
    }, {
      key: 'main_editor',
      value: function main_editor(callNext) {
        var exc, newtext, source;
        this.storeConfiguration();
        try {
          storeRegExp();
        } catch (error) {
          exc = error;
          App.log.logError("Invalid pattern: " + exc);

          return false;
        }
        source = this.WM.Editor.readSource();
        newtext = source.replace(configuration.regExp, configuration.newString);
        if (newtext !== source) {
          this.WM.Editor.writeSource(newtext);
          App.log.logInfo("Text substituted");
        }
        if (callNext) {
          return callNext();
        }
      }
    }, {
      key: 'main_bot',
      value: function main_bot(title, callBot, chainArgs) {
        var exc, summary;
        this.storeConfiguration();
        try {
          storeRegExp();
        } catch (error) {
          exc = error;
          App.log.logError("Invalid pattern: " + exc);
          callBot(false, null);

          return false;
        }
        summary = document.getElementById("WikiMonkey-SimpleReplace-Summary").value;
        if (summary !== "") {
          return this.WM.MW.callQueryEdit(title, this.mainAutoWrite, [summary, callBot]);
        } else {
          App.log.logError("The edit summary cannot be empty");
          return callBot(false, null);
        }
      }
    }, {
      key: 'mainAutoWrite',
      value: function mainAutoWrite(title, source, timestamp, edittoken, args) {
        var callBot, newtext, summary;
        boundMethodCheck(this, ref);
        summary = args[0];
        callBot = args[1];
        newtext = source.replace(configuration.regExp, configuration.newString);
        if (newtext !== source) {
          return this.WM.MW.callAPIPost({
            action: "edit",
            bot: "1",
            title: title,
            summary: summary,
            text: newtext,
            basetimestamp: timestamp,
            token: edittoken
          }, this.mainAutoEnd, callBot, null);
        } else {
          return callBot(0, null);
        }
      }
    }, {
      key: 'mainAutoEnd',
      value: function mainAutoEnd(res, callBot) {
        boundMethodCheck(this, ref);
        if (res.edit && res.edit.result === 'Success') {
          return callBot(1, null);
        } else if (res.error) {
          App.log.logError(res.error.info + " (" + res.error.code + ")");
          return callBot(res.error.code, null);
        } else {
          return callBot(false, null);
        }
      }
    }]);

    return SimpleReplace;
  }(Plugin);

  ;

  SimpleReplace.conf_default = {
    enabled: true,
    editor_menu: ["RegExp substitution"],
    bot_label: "RegExp substitution"
  };

  _makeUI = function _makeUI() {
    var classes, divMain, ignoreCase, ignoreCaseLabel, newString, newStringLabel, par1, par2, regexp, regexpLabel;

    var _jssc = jssc({
      simpleReplace: {
        '& div': {
          marginBottom: '0.33em'
        },
        "& input[type='text']": {
          marginLeft: '0.33em',
          width: '60%'
        }
      }
    });

    classes = _jssc.classes;

    divMain = document.createElement('div');
    divMain.id = "WikiMonkey-SimpleReplace";
    divMain.className = classes.simpleReplace;
    par1 = document.createElement('div');
    regexpLabel = document.createElement('span');
    regexpLabel.innerHTML = 'RegExp pattern:';
    regexp = document.createElement('input');
    regexp.setAttribute('type', 'text');
    regexp.id = "WikiMonkey-SimpleReplace-RegExp";
    ignoreCase = document.createElement('input');
    ignoreCase.setAttribute('type', 'checkbox');
    ignoreCase.id = "WikiMonkey-SimpleReplace-IgnoreCase";
    ignoreCaseLabel = document.createElement('span');
    ignoreCaseLabel.innerHTML = 'i';
    par1.appendChild(regexpLabel);
    par1.appendChild(regexp);
    par1.appendChild(ignoreCase);
    par1.appendChild(ignoreCaseLabel);
    par2 = document.createElement('div');
    newStringLabel = document.createElement('span');
    newStringLabel.innerHTML = 'New string:';
    newString = document.createElement('input');
    newString.setAttribute('type', 'text');
    newString.id = "WikiMonkey-SimpleReplace-NewString";
    par2.appendChild(newStringLabel);
    par2.appendChild(newString);
    divMain.appendChild(par1);
    divMain.appendChild(par2);
    return divMain;
  };

  configuration = null;

  storeRegExp = function storeRegExp() {
    return configuration.regExp = new RegExp(configuration.pattern, "g" + (configuration.ignoreCase ? "i" : ""));
  };

  return SimpleReplace;
}.call(undefined);

},{"../app":399,"../modules/libs":412,"./_Plugin":432}],430:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var App,
    Plugin,
    WM,
    ref,
    boundMethodCheck = function boundMethodCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new Error('Bound instance method accessed before binding');
  }
};

WM = require('../modules');

App = require('../app');

var _require = require('./_Plugin');

Plugin = _require.Plugin;


ref = module.exports.SynchronizeInterlanguageLinks = function () {
  var SynchronizeInterlanguageLinks = function (_Plugin) {
    _inherits(SynchronizeInterlanguageLinks, _Plugin);

    function SynchronizeInterlanguageLinks() {
      _classCallCheck(this, SynchronizeInterlanguageLinks);

      var _this = _possibleConstructorReturn(this, (SynchronizeInterlanguageLinks.__proto__ || Object.getPrototypeOf(SynchronizeInterlanguageLinks)).apply(this, arguments));

      _this.detectLang = _this.detectLang.bind(_this);
      _this.computeWhiteList = _this.computeWhiteList.bind(_this);
      _this.computeSupportedLangs = _this.computeSupportedLangs.bind(_this);
      _this.mainContinue = _this.mainContinue.bind(_this);
      _this.mainEnd = _this.mainEnd.bind(_this);
      _this.mainAutoWrite = _this.mainAutoWrite.bind(_this);
      _this.mainAutoEnd = _this.mainAutoEnd.bind(_this);
      return _this;
    }

    _createClass(SynchronizeInterlanguageLinks, [{
      key: 'detectLang',
      value: function detectLang(title, tag) {
        var detect, pureTitle;
        boundMethodCheck(this, ref);

        if (tag === "ArchWiki") {
          detect = WM.ArchWiki.detectLanguage(title);
          pureTitle = detect[0];
          tag = WM.ArchWiki.getInterlanguageTag(detect[1]);
        } else {
          pureTitle = title;
        }
        return [pureTitle, tag];
      }
    }, {
      key: 'computeWhiteList',
      value: function computeWhiteList(whitelist) {
        boundMethodCheck(this, ref);

        if (whitelist === "ArchWiki") {
          return WM.ArchWiki.getInternalInterwikiLanguages();
        } else {
          return whitelist;
        }
      }
    }, {
      key: 'computeSupportedLangs',
      value: function computeSupportedLangs(supportedLangs) {
        boundMethodCheck(this, ref);

        if (supportedLangs === "ArchWiki") {
          return WM.ArchWiki.getInterwikiLanguages();
        } else {
          return supportedLangs;
        }
      }
    }, {
      key: 'main_editor',
      value: function main_editor(callNext) {
        var detect, pureTitle, supportedLangs, tag, title, whitelist;
        title = this.WM.Editor.getTitle();
        detect = this.detectLang(title, this.conf.language_tag);
        pureTitle = detect[0];
        tag = detect[1];
        whitelist = this.computeWhiteList(this.conf.tag_whitelist);
        supportedLangs = this.computeSupportedLangs(this.conf.supported_tags);
        App.log.logInfo("Synchronizing interlanguage links ...");
        return this.WM.MW.getLocalInterwikiMap(title, this.mainContinue, [tag, pureTitle, supportedLangs, whitelist, title, callNext]);
      }
    }, {
      key: 'mainContinue',
      value: function mainContinue(iwmap, args) {
        var callNext, i, langlinks, len, link, newlinks, nlink, pureTitle, source, supportedLangs, tag, title, url, visitedlinks, vlink, whitelist, wikiUrls;
        boundMethodCheck(this, ref);
        tag = args[0];
        pureTitle = args[1];
        supportedLangs = args[2];
        whitelist = args[3];
        title = args[4];
        callNext = args[5];
        source = this.WM.Editor.readSource();
        langlinks = this.WM.Interlanguage.parseLinks(supportedLangs, source, iwmap);
        wikiUrls = this.WM.MW.getWikiUrls();
        url = wikiUrls.short + encodeURIComponent(this.WM.Parser.squashContiguousWhitespace(title));
        visitedlinks = {};
        visitedlinks[tag.toLowerCase()] = this.WM.Interlanguage.createVisitedLink(tag, pureTitle, url, iwmap, source, null, null, langlinks);
        newlinks = {};
        App.log.logInfo("Reading " + App.log.linkToPage(url, "edited article") + " ...");
        if (langlinks) {
          for (i = 0, len = langlinks.length; i < len; i++) {
            link = langlinks[i];
            nlink = newlinks[link.lang.toLowerCase()];
            vlink = visitedlinks[link.lang.toLowerCase()];
            if (!vlink && !nlink) {
              newlinks[link.lang.toLowerCase()] = this.WM.Interlanguage.createNewLink(link.lang, link.title, link.url);
            } else if (vlink && vlink.url !== link.url) {
              App.log.logWarning("Possibly conflicting interlanguage " + "links: " + App.log.linkToPage(link.url, "[[" + link.lang + ":" + link.title + "]]") + " and " + App.log.linkToPage(vlink.url, "[[" + link.lang + ":" + visitedlinks[link.lang.toLowerCase()].title + "]]"));
            } else if (nlink && nlink.url !== link.url) {
              App.log.logWarning("Possibly conflicting interlanguage " + "links: " + App.log.linkToPage(link.url, "[[" + link.lang + ":" + link.title + "]]") + " and " + App.log.linkToPage(nlink.url, "[[" + link.lang + ":" + newlinks[link.lang.toLowerCase()].title + "]]"));
            }
          }
          return this.WM.Interlanguage.collectLinks(visitedlinks, newlinks, supportedLangs, whitelist, false, this.mainEnd, [tag, url, source, langlinks, iwmap, callNext]);
        } else {
          App.log.logInfo("No interlanguage links found");
          if (callNext) {
            return callNext();
          }
        }
      }
    }, {
      key: 'mainEnd',
      value: function mainEnd(links, args) {
        var callNext, iwmap, langlinks, newText, source, tag, url;
        boundMethodCheck(this, ref);
        tag = args[0];
        url = args[1];
        source = args[2];
        langlinks = args[3];
        iwmap = args[4];
        callNext = args[5];
        newText = this.WM.Interlanguage.updateLinks(tag, url, iwmap, source, langlinks, links);
        if (newText !== source) {
          this.WM.Editor.writeSource(newText);
          App.log.logInfo("Synchronized interlanguage links");
        } else {
          App.log.logInfo("Interlanguage links were already synchronized");
        }
        if (callNext) {
          return callNext();
        }
      }
    }, {
      key: 'main_bot',
      value: function main_bot(title, callBot, chainArgs) {
        var detect, newlinks, pureTitle, summary, supportedLangs, tag, url, visitedlinks, whitelist, wikiUrls;
        detect = this.detectLang(title, this.conf.language_tag);
        pureTitle = detect[0];
        tag = detect[1];
        whitelist = this.computeWhiteList(this.conf.tag_whitelist);
        supportedLangs = this.computeSupportedLangs(this.conf.supported_tags);
        summary = this.conf.edit_summary;
        wikiUrls = this.WM.MW.getWikiUrls();
        url = wikiUrls.short + encodeURIComponent(this.WM.Parser.squashContiguousWhitespace(title));
        visitedlinks = {};
        newlinks = {};
        newlinks[tag.toLowerCase()] = this.WM.Interlanguage.createNewLink(tag, pureTitle, url);
        return this.WM.Interlanguage.collectLinks(visitedlinks, newlinks, supportedLangs, whitelist, true, this.mainAutoWrite, [title, url, tag, summary, callBot]);
      }
    }, {
      key: 'mainAutoWrite',
      value: function mainAutoWrite(links, args) {
        var callBot, edittoken, iwmap, langlinks, lcTag, newText, source, summary, tag, timestamp, title, url;
        boundMethodCheck(this, ref);
        title = args[0];
        url = args[1];
        tag = args[2];
        summary = args[3];
        callBot = args[4];
        lcTag = tag.toLowerCase();

        iwmap = links[lcTag].iwmap;
        source = links[lcTag].source;
        langlinks = links[lcTag].links;
        timestamp = links[lcTag].timestamp;
        edittoken = links[lcTag].edittoken;
        newText = this.WM.Interlanguage.updateLinks(tag, url, iwmap, source, langlinks, links);
        if (newText !== source) {
          return this.WM.MW.callAPIPost({
            action: "edit",
            bot: "1",
            title: title,
            summary: summary,
            text: newText,
            basetimestamp: timestamp,
            token: edittoken
          }, this.mainAutoEnd, callBot, null);
        } else {
          return callBot(0, null);
        }
      }
    }, {
      key: 'mainAutoEnd',
      value: function mainAutoEnd(res, callBot) {
        boundMethodCheck(this, ref);
        if (res.edit && res.edit.result === 'Success') {
          return callBot(1, null);
        } else if (res.error) {
          App.log.logError(res.error.info + " (" + res.error.code + ")");
          return callBot(res.error.code, null);
        } else {
          return callBot(false, null);
        }
      }
    }]);

    return SynchronizeInterlanguageLinks;
  }(Plugin);

  ;

  SynchronizeInterlanguageLinks.conf_default = {
    enabled: true,
    editor_menu: ["Query plugins", "Sync interlanguage links"],
    bot_label: "Synchronize interlanguage links",
    language_tag: "en",
    tag_whitelist: ["en"],
    supported_tags: ["en"],
    edit_summary: "synchronized interlanguage links with the other wikis"
  };

  SynchronizeInterlanguageLinks.wiki_to_conf_default = {
    ArchWiki: {
      language_tag: "ArchWiki",
      tag_whitelist: "ArchWiki",
      supported_tags: "ArchWiki"
    },
    Wikipedia: {
      enabled: false
    }
  };

  return SynchronizeInterlanguageLinks;
}.call(undefined);

},{"../app":399,"../modules":411,"./_Plugin":432}],431:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var App,
    Plugin,
    Str,
    WM,
    ref,
    boundMethodCheck = function boundMethodCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new Error('Bound instance method accessed before binding');
  }
},
    indexOf = [].indexOf;

WM = require('../modules');

App = require('../app');

var _require = require('./_Plugin');

Plugin = _require.Plugin;


Str = require('@kynikos/misc/dist/Str');

ref = module.exports.UpdateCategoryTree = function () {
  var UpdateCategoryTree = function (_Plugin) {
    _inherits(UpdateCategoryTree, _Plugin);

    function UpdateCategoryTree() {
      _classCallCheck(this, UpdateCategoryTree);

      var _this = _possibleConstructorReturn(this, (UpdateCategoryTree.__proto__ || Object.getPrototypeOf(UpdateCategoryTree)).apply(this, arguments));

      _this.mainContinue = _this.mainContinue.bind(_this);
      _this.readToC = _this.readToC.bind(_this);
      _this.processToC = _this.processToC.bind(_this);
      _this.storeAlternativeNames = _this.storeAlternativeNames.bind(_this);
      _this.processCategory = _this.processCategory.bind(_this);
      _this.processCategoryAddSuffix = _this.processCategoryAddSuffix.bind(_this);
      _this.processCategoryEnd = _this.processCategoryEnd.bind(_this);
      _this.createCatLink = _this.createCatLink.bind(_this);
      _this.writeToC = _this.writeToC.bind(_this);
      _this.checkWrite = _this.checkWrite.bind(_this);
      return _this;
    }

    _createClass(UpdateCategoryTree, [{
      key: 'main_special',
      value: function main_special(callNext) {
        return this.iteratePages(-1, callNext);
      }
    }, {
      key: 'iteratePages',
      value: function iteratePages(pageid, callNext) {
        var params, pconf, showRootAlsoIn, summary;
        pageid++;
        summary = this.conf.edit_summary;
        showRootAlsoIn = this.conf.show_root_also_in;
        pconf = this.conf.pages[pageid];
        if (pconf) {
          if ($.type(pconf) === "string") {
            params = WM.ArchWiki.getTableOfContents(pconf);
          } else {
            params = pconf;
          }
          return this.WM.MW.isUserBot(this.mainContinue, [params, showRootAlsoIn, summary, callNext, pageid]);
        } else if (callNext) {
          return callNext();
        }
      }
    }, {
      key: 'mainContinue',
      value: function mainContinue(botTest, args) {
        boundMethodCheck(this, ref);
        return this.readToC({
          params: args[0],
          minInterval: botTest ? 60000 : 21600000,
          edittoken: "",
          timestamp: "",
          source: "",
          startId: 0,
          endId: 0,
          treeText: "",
          startMark: "START AUTO TOC - DO NOT REMOVE OR MODIFY THIS MARK-->",
          endMark: "<!--END AUTO TOC - DO NOT REMOVE OR MODIFY THIS MARK",
          altNames: {},
          showRootAlsoIn: args[1],
          summary: args[2],
          callNext: args[3],
          pageid: args[4]
        });
      }
    }, {
      key: 'readToC',
      value: function readToC(args) {
        boundMethodCheck(this, ref);
        App.log.logInfo('Updating ' + App.log.linkToWikiPage(args.params.page, args.params.page) + " ...");
        return this.WM.MW.callQueryEdit(args.params.page, this.processToC, args);
      }
    }, {
      key: 'processToC',
      value: function processToC(title, source, timestamp, edittoken, args) {
        var end, msTimestamp, now, start;
        boundMethodCheck(this, ref);
        args.source = source;
        args.timestamp = timestamp;
        args.edittoken = edittoken;
        now = new Date();
        msTimestamp = Date.parse(args.timestamp);
        if (now.getTime() - msTimestamp >= args.minInterval) {
          start = args.source.indexOf(args.startMark);
          end = args.source.lastIndexOf(args.endMark);
          if (start > -1 && end > -1) {
            args.startId = start + args.startMark.length;
            args.endId = end;
            args.treeText = "";
            args.altNames = args.params.keepAltName ? this.storeAlternativeNames(args.source) : {};
            return WM.Cat.recurseTree({
              node: args.params.root,
              callNode: this.processCategory,
              callEnd: this.writeToC,
              callArgs: args
            });
          } else {
            App.log.logError("Cannot find insertion marks in " + App.log.linkToWikiPage(args.params.page, args.params.page));
            return this.iteratePages(args.pageid, args.callNext);
          }
        } else {
          App.log.logWarning(App.log.linkToWikiPage(args.params.page, args.params.page) + ' has been updated too recently');
          return this.iteratePages(args.pageid, args.callNext);
        }
      }
    }, {
      key: 'storeAlternativeNames',
      value: function storeAlternativeNames(source) {
        var dict, match, regExp;
        boundMethodCheck(this, ref);
        dict = {};
        regExp = /\[\[\:([Cc]ategory\:.+?)\|(.+?)\]\]/gm;
        while (true) {
          match = regExp.exec(source);
          if (match) {
            dict[match[1].toLowerCase()] = match[2];
          } else {
            break;
          }
        }
        return dict;
      }
    }, {
      key: 'processCategory',
      value: function processCategory(params) {
        var altName, args, indices, j, node, ref1, text;
        boundMethodCheck(this, ref);
        args = params.callArgs;
        App.log.logInfo("Processing " + App.log.linkToWikiPage(params.node, params.node) + " ...");
        text = "";
        for (j = 0, ref1 = params.ancestors.length; 0 <= ref1 ? j < ref1 : j > ref1; 0 <= ref1 ? j++ : j--) {
          text += args.params.indentType;
        }
        if (args.params.showIndices) {
          indices = [];
          node = params;
          while (node.parentIndex !== null) {
            indices.push(node.siblingIndex + 1);
            node = params.nodesList[node.parentIndex];
          }
          if (indices.length) {
            text += "<small>" + indices.reverse().join(".") + ".</small> ";
          }
        }
        altName = args.altNames[params.node.toLowerCase()] ? args.altNames[params.node.toLowerCase()] : null;
        text += this.createCatLink(params.node, args.params.replace, altName);
        text += args.params.rightToLeft ? "&lrm; " : " ";
        if (params.children === "loop") {
          text += "'''[LOOP]'''\n";
          App.log.logWarning("Loop in " + App.log.linkToWikiPage(params.node, params.node));
          return this.processCategoryEnd(params, args, text);
        } else {
          return WM.Cat.getParentsAndInfo(params.node, this.processCategoryAddSuffix, [params, args, text, altName]);
        }
      }
    }, {
      key: 'processCategoryAddSuffix',
      value: function processCategoryAddSuffix(parents, info, args_) {
        var alsoParents, altName, args, currParent, i, j, k, len, len1, par, params, parentTitles, text;
        boundMethodCheck(this, ref);
        params = args_[0];
        args = args_[1];
        text = args_[2];
        altName = args_[3];
        currParent = params.ancestors[params.ancestors.length - 1];
        alsoParents = [];
        text += "<small>(" + (info ? info.pages : 0) + ")";

        if (currParent || args.showRootAlsoIn) {
          for (j = 0, len = parents.length; j < len; j++) {
            par = parents[j];
            if (currParent !== par.title && !(indexOf.call(par, "hidden") >= 0)) {
              alsoParents.push(par);
            }
          }
          if (alsoParents.length) {
            parentTitles = [];
            for (k = 0, len1 = alsoParents.length; k < len1; k++) {
              i = alsoParents[k];
              altName = args.altNames[alsoParents[i].title.toLowerCase()] ? args.altNames[alsoParents[i].title.toLowerCase()] : null;
              parentTitles.push(this.createCatLink(alsoParents[i].title, args.params.replace, altName));
            }
            text += " (" + args.params.alsoIn + " " + parentTitles.join(", ") + ")";
          }
        }
        text += "</small>\n";
        return this.processCategoryEnd(params, args, text);
      }
    }, {
      key: 'processCategoryEnd',
      value: function processCategoryEnd(params, args, text) {
        boundMethodCheck(this, ref);
        args.treeText += text;
        params.callArgs = args;
        return WM.Cat.recurseTreeContinue(params);
      }
    }, {
      key: 'createCatLink',
      value: function createCatLink(cat, replace, altName) {
        var catName, regExp;
        boundMethodCheck(this, ref);
        if (altName) {
          catName = altName;
        } else if (replace) {
          regExp = new RegExp(replace[0], replace[1]);
          catName = cat.substr(9).replace(regExp, replace[2]);
        } else {
          catName = cat.substr(9);
        }
        return "[[:" + cat + "|" + catName + "]]";
      }
    }, {
      key: 'writeToC',
      value: function writeToC(params) {
        var args, newtext;
        boundMethodCheck(this, ref);
        args = params.callArgs;
        args.treeText = "\n" + args.treeText;
        newtext = Str.overwriteBetween(args.source, args.treeText, args.startId, args.endId);
        if (newtext !== args.source) {
          return this.WM.MW.callAPIPost({
            action: "edit",
            bot: "1",
            minor: "1",
            title: args.params.page,
            summary: args.summary,
            text: newtext,
            basetimestamp: args.timestamp,
            token: args.edittoken
          }, this.checkWrite, args, null);
        } else {
          App.log.logInfo(App.log.linkToWikiPage(args.params.page, args.params.page) + ' is already up to date');
          return this.iteratePages(args.pageid, args.callNext);
        }
      }
    }, {
      key: 'checkWrite',
      value: function checkWrite(res, args) {
        boundMethodCheck(this, ref);
        if (res.edit && res.edit.result === 'Success') {
          App.log.logInfo(App.log.linkToWikiPage(args.params.page, args.params.page) + ' correctly updated');
          return this.iteratePages(args.pageid, args.callNext);
        } else {
          return App.log.logError(App.log.linkToWikiPage(args.params.page, args.params.page) + ' has not been updated!\n' + res['error']['info'] + " (" + res['error']['code'] + ")");
        }
      }
    }]);

    return UpdateCategoryTree;
  }(Plugin);

  ;

  UpdateCategoryTree.conf_default = {
    enabled: false,
    special_menu: ["Update category trees"],
    edit_summary: "automatic update",
    show_root_also_in: false,
    pages: []
  };

  UpdateCategoryTree.wiki_to_conf_default = {
    ArchWiki: {
      pages: ["ar", "cs", "cs", "da", "el", "en", "es", "he", "hr", "hu", "id", "it", "ko", "lt", "nl", "pl", "pt", "ru", "sk", "sr", "th", "tr", "uk", "zh-hans", "zh-hant"]
    },
    Wikipedia: {}
  };

  return UpdateCategoryTree;
}.call(undefined);

},{"../app":399,"../modules":411,"./_Plugin":432,"@kynikos/misc/dist/Str":3}],432:[function(require,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

module.exports.Plugin = function () {
  var Plugin = function () {
    _createClass(Plugin, null, [{
      key: "__configure",
      value: function __configure(wiki_name, user_config) {
        var option, ref, value;

        this.prototype.conf = {};
        if (this.conf_default != null) {
          $.extend(this.prototype.conf, this.conf_default);
        }
        if (this.wiki_to_conf_default != null && wiki_name in this.wiki_to_conf_default) {
          $.extend(this.prototype.conf, this.wiki_to_conf_default[wiki_name]);
        }
        if (this.name in user_config) {
          ref = user_config[this.name];

          for (option in ref) {
            value = ref[option];
            if (!(option in this.prototype.conf)) {
              continue;
            }
            this.prototype.conf[option] = value;
            delete user_config[this.name][option];
          }
        }
        if (!this.prototype.conf.enabled) {
          delete user_config[this.name];

          throw new Error("Plugin disabled");
        }
        if ($.isEmptyObject(user_config[this.name])) {
          return delete user_config[this.name];
        }
      }
    }]);

    function Plugin(WM) {
      _classCallCheck(this, Plugin);

      this.WM = WM;
    }

    return Plugin;
  }();

  ;

  Plugin.prototype.main_bot = null;

  Plugin.prototype.main_diff = null;

  Plugin.prototype.main_editor = null;

  Plugin.prototype.main_newpages = null;

  Plugin.prototype.main_recentchanges = null;

  Plugin.prototype.main_special = null;

  return Plugin;
}.call(undefined);

},{}]},{},[393])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvQGt5bmlrb3MvbWlzYy9kaXN0L0FzeW5jLmpzIiwibm9kZV9tb2R1bGVzL0BreW5pa29zL21pc2MvZGlzdC9SZWdFeC5qcyIsIm5vZGVfbW9kdWxlcy9Aa3luaWtvcy9taXNjL2Rpc3QvU3RyLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXBvbHlmaWxsL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1wb2x5ZmlsbC9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXItcmVzb2x2ZS9lbXB0eS5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyLXNwbGl0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NsYXNzLWxpc3QvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9mbi9yZWdleHAvZXNjYXBlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYS1mdW5jdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2EtbnVtYmVyLXZhbHVlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYWRkLXRvLXVuc2NvcGFibGVzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYW4taW5zdGFuY2UuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hbi1vYmplY3QuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hcnJheS1jb3B5LXdpdGhpbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FycmF5LWZpbGwuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hcnJheS1mcm9tLWl0ZXJhYmxlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYXJyYXktaW5jbHVkZXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hcnJheS1tZXRob2RzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYXJyYXktcmVkdWNlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYXJyYXktc3BlY2llcy1jb25zdHJ1Y3Rvci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FycmF5LXNwZWNpZXMtY3JlYXRlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYmluZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NsYXNzb2YuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jb2YuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jb2xsZWN0aW9uLXN0cm9uZy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NvbGxlY3Rpb24tdG8tanNvbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NvbGxlY3Rpb24td2Vhay5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NvbGxlY3Rpb24uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jb3JlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY3JlYXRlLXByb3BlcnR5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY3R4LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZGF0ZS10by1pc28tc3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZGF0ZS10by1wcmltaXRpdmUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19kZWZpbmVkLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZGVzY3JpcHRvcnMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19kb20tY3JlYXRlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZW51bS1idWcta2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2VudW0ta2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2V4cG9ydC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2ZhaWxzLWlzLXJlZ2V4cC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2ZhaWxzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZml4LXJlLXdrcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2ZsYWdzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZmxhdHRlbi1pbnRvLWFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZm9yLW9mLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZ2xvYmFsLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faGFzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faGlkZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2h0bWwuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pZTgtZG9tLWRlZmluZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2luaGVyaXQtaWYtcmVxdWlyZWQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pbnZva2UuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pb2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXMtYXJyYXktaXRlci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2lzLWFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXMtaW50ZWdlci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2lzLW9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2lzLXJlZ2V4cC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2l0ZXItY2FsbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2l0ZXItY3JlYXRlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXRlci1kZWZpbmUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pdGVyLWRldGVjdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2l0ZXItc3RlcC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2l0ZXJhdG9ycy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2xpYnJhcnkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19tYXRoLWV4cG0xLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fbWF0aC1mcm91bmQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19tYXRoLWxvZzFwLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fbWF0aC1zY2FsZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX21hdGgtc2lnbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX21ldGEuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19tZXRhZGF0YS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX21pY3JvdGFzay5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX25ldy1wcm9taXNlLWNhcGFiaWxpdHkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtYXNzaWduLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWNyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1kcC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1kcHMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZm9yY2VkLXBhbS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1nb3BkLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdvcG4tZXh0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdvcG4uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ29wcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1ncG8uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3Qta2V5cy1pbnRlcm5hbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1rZXlzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LXBpZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1zYXAuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtdG8tYXJyYXkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vd24ta2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3BhcnNlLWZsb2F0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fcGFyc2UtaW50LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fcGVyZm9ybS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3Byb21pc2UtcmVzb2x2ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3Byb3BlcnR5LWRlc2MuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19yZWRlZmluZS1hbGwuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19yZWRlZmluZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3JlcGxhY2VyLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc2FtZS12YWx1ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NldC1jb2xsZWN0aW9uLWZyb20uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zZXQtY29sbGVjdGlvbi1vZi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NldC1wcm90by5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NldC1zcGVjaWVzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc2V0LXRvLXN0cmluZy10YWcuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zaGFyZWQta2V5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc2hhcmVkLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc3BlY2llcy1jb25zdHJ1Y3Rvci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3N0cmljdC1tZXRob2QuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zdHJpbmctYXQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zdHJpbmctY29udGV4dC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy1odG1sLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLXBhZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy1yZXBlYXQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zdHJpbmctdHJpbS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy13cy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3Rhc2suanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1hYnNvbHV0ZS1pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLWluZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8taW50ZWdlci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLWlvYmplY3QuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1sZW5ndGguanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1vYmplY3QuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1wcmltaXRpdmUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190eXBlZC1hcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3R5cGVkLWJ1ZmZlci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3R5cGVkLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdWlkLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdmFsaWRhdGUtY29sbGVjdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3drcy1kZWZpbmUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL193a3MtZXh0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fd2tzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2NvcmUucmVnZXhwLmVzY2FwZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmNvcHktd2l0aGluLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZXZlcnkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5maWxsLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZmlsdGVyLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZmluZC1pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmZpbmQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5mb3ItZWFjaC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmZyb20uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5pbmRleC1vZi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmlzLWFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuaXRlcmF0b3IuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5qb2luLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkubGFzdC1pbmRleC1vZi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5Lm1hcC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5Lm9mLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkucmVkdWNlLXJpZ2h0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkucmVkdWNlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuc2xpY2UuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5zb21lLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuc29ydC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LnNwZWNpZXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5kYXRlLm5vdy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmRhdGUudG8taXNvLXN0cmluZy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmRhdGUudG8tanNvbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmRhdGUudG8tcHJpbWl0aXZlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuZGF0ZS50by1zdHJpbmcuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5mdW5jdGlvbi5iaW5kLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuZnVuY3Rpb24uaGFzLWluc3RhbmNlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuZnVuY3Rpb24ubmFtZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hcC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguYWNvc2guanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmFzaW5oLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5hdGFuaC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguY2JydC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguY2x6MzIuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmNvc2guanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmV4cG0xLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5mcm91bmQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmh5cG90LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5pbXVsLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5sb2cxMC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGgubG9nMXAuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmxvZzIuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLnNpZ24uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLnNpbmguanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLnRhbmguanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLnRydW5jLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLmNvbnN0cnVjdG9yLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLmVwc2lsb24uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIuaXMtZmluaXRlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLmlzLWludGVnZXIuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIuaXMtbmFuLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLmlzLXNhZmUtaW50ZWdlci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5tYXgtc2FmZS1pbnRlZ2VyLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLm1pbi1zYWZlLWludGVnZXIuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIucGFyc2UtZmxvYXQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIucGFyc2UtaW50LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLnRvLWZpeGVkLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLnRvLXByZWNpc2lvbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5hc3NpZ24uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuY3JlYXRlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmRlZmluZS1wcm9wZXJ0aWVzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmRlZmluZS1wcm9wZXJ0eS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5mcmVlemUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmdldC1vd24tcHJvcGVydHktbmFtZXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LXByb3RvdHlwZS1vZi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5pcy1leHRlbnNpYmxlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmlzLWZyb3plbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5pcy1zZWFsZWQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuaXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3Qua2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5wcmV2ZW50LWV4dGVuc2lvbnMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3Quc2VhbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5zZXQtcHJvdG90eXBlLW9mLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnBhcnNlLWZsb2F0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucGFyc2UtaW50LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucHJvbWlzZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuYXBwbHkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmNvbnN0cnVjdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZGVmaW5lLXByb3BlcnR5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5kZWxldGUtcHJvcGVydHkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmVudW1lcmF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5nZXQtcHJvdG90eXBlLW9mLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5nZXQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0Lmhhcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuaXMtZXh0ZW5zaWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3Qub3duLWtleXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LnByZXZlbnQtZXh0ZW5zaW9ucy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3Quc2V0LXByb3RvdHlwZS1vZi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3Quc2V0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLmNvbnN0cnVjdG9yLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLmZsYWdzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLm1hdGNoLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLnJlcGxhY2UuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAuc2VhcmNoLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLnNwbGl0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLnRvLXN0cmluZy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnNldC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5hbmNob3IuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuYmlnLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmJsaW5rLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmJvbGQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuY29kZS1wb2ludC1hdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5lbmRzLXdpdGguanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuZml4ZWQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuZm9udGNvbG9yLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmZvbnRzaXplLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmZyb20tY29kZS1wb2ludC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5pbmNsdWRlcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5pdGFsaWNzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmxpbmsuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcucmF3LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnJlcGVhdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5zbWFsbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5zdGFydHMtd2l0aC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5zdHJpa2UuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuc3ViLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnN1cC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy50cmltLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3ltYm9sLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQuYXJyYXktYnVmZmVyLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQuZGF0YS12aWV3LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQuZmxvYXQzMi1hcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLmZsb2F0NjQtYXJyYXkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC5pbnQxNi1hcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLmludDMyLWFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQuaW50OC1hcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLnVpbnQxNi1hcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLnVpbnQzMi1hcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLnVpbnQ4LWFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQudWludDgtY2xhbXBlZC1hcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LndlYWstbWFwLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYud2Vhay1zZXQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5hcnJheS5mbGF0LW1hcC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LmFycmF5LmZsYXR0ZW4uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5hcnJheS5pbmNsdWRlcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LmFzYXAuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5lcnJvci5pcy1lcnJvci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lmdsb2JhbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hcC5mcm9tLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcubWFwLm9mLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcubWFwLnRvLWpzb24uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5tYXRoLmNsYW1wLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcubWF0aC5kZWctcGVyLXJhZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hdGguZGVncmVlcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hdGguZnNjYWxlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcubWF0aC5pYWRkaC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hdGguaW11bGguanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5tYXRoLmlzdWJoLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcubWF0aC5yYWQtcGVyLWRlZy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hdGgucmFkaWFucy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hdGguc2NhbGUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5tYXRoLnNpZ25iaXQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5tYXRoLnVtdWxoLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcub2JqZWN0LmRlZmluZS1nZXR0ZXIuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5vYmplY3QuZGVmaW5lLXNldHRlci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm9iamVjdC5lbnRyaWVzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcub2JqZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcnMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5vYmplY3QubG9va3VwLWdldHRlci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm9iamVjdC5sb29rdXAtc2V0dGVyLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcub2JqZWN0LnZhbHVlcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm9ic2VydmFibGUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5wcm9taXNlLmZpbmFsbHkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5wcm9taXNlLnRyeS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QuZGVmaW5lLW1ldGFkYXRhLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcucmVmbGVjdC5kZWxldGUtbWV0YWRhdGEuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0LmdldC1tZXRhZGF0YS1rZXlzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcucmVmbGVjdC5nZXQtbWV0YWRhdGEuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0LmdldC1vd24tbWV0YWRhdGEta2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QuZ2V0LW93bi1tZXRhZGF0YS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QuaGFzLW1ldGFkYXRhLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcucmVmbGVjdC5oYXMtb3duLW1ldGFkYXRhLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcucmVmbGVjdC5tZXRhZGF0YS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnNldC5mcm9tLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuc2V0Lm9mLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuc2V0LnRvLWpzb24uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5zdHJpbmcuYXQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5zdHJpbmcubWF0Y2gtYWxsLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuc3RyaW5nLnBhZC1lbmQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5zdHJpbmcucGFkLXN0YXJ0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuc3RyaW5nLnRyaW0tbGVmdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnN0cmluZy50cmltLXJpZ2h0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuc3ltYm9sLmFzeW5jLWl0ZXJhdG9yLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuc3ltYm9sLm9ic2VydmFibGUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5zeXN0ZW0uZ2xvYmFsLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcud2Vhay1tYXAuZnJvbS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LndlYWstbWFwLm9mLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcud2Vhay1zZXQuZnJvbS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LndlYWstc2V0Lm9mLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy93ZWIuaW1tZWRpYXRlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy93ZWIudGltZXJzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvc2hpbS5qcyIsIm5vZGVfbW9kdWxlcy9jc3MtdmVuZG9yL2xpYi9jYW1lbGl6ZS5qcyIsIm5vZGVfbW9kdWxlcy9jc3MtdmVuZG9yL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jc3MtdmVuZG9yL2xpYi9wcmVmaXguanMiLCJub2RlX21vZHVsZXMvY3NzLXZlbmRvci9saWIvc3VwcG9ydGVkLXByb3BlcnR5LmpzIiwibm9kZV9tb2R1bGVzL2Nzcy12ZW5kb3IvbGliL3N1cHBvcnRlZC12YWx1ZS5qcyIsIm5vZGVfbW9kdWxlcy9oeXBlcnNjcmlwdC1oZWxwZXJzL2Rpc3QvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaHlwZXJzY3JpcHQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaW5kZXhvZi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pcy1pbi1icm93c2VyL2Rpc3QvaW5kZXguanMiLCJub2RlX21vZHVsZXMvanNzLWNhbWVsLWNhc2UvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2pzcy1jb21wb3NlL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9qc3MtZGVmYXVsdC11bml0L2xpYi9kZWZhdWx0VW5pdHMuanMiLCJub2RlX21vZHVsZXMvanNzLWRlZmF1bHQtdW5pdC9saWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvanNzLWV4cGFuZC9saWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvanNzLWV4cGFuZC9saWIvcHJvcHMuanMiLCJub2RlX21vZHVsZXMvanNzLWV4dGVuZC9saWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvanNzLWdsb2JhbC9saWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvanNzLW5lc3RlZC9saWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvanNzLXByZXNldC1kZWZhdWx0L2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9qc3MtcHJvcHMtc29ydC9saWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvanNzLXRlbXBsYXRlL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9qc3MtdGVtcGxhdGUvbGliL3BhcnNlLmpzIiwibm9kZV9tb2R1bGVzL2pzcy12ZW5kb3ItcHJlZml4ZXIvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2pzcy9saWIvSnNzLmpzIiwibm9kZV9tb2R1bGVzL2pzcy9saWIvUGx1Z2luc1JlZ2lzdHJ5LmpzIiwibm9kZV9tb2R1bGVzL2pzcy9saWIvUnVsZUxpc3QuanMiLCJub2RlX21vZHVsZXMvanNzL2xpYi9TaGVldHNNYW5hZ2VyLmpzIiwibm9kZV9tb2R1bGVzL2pzcy9saWIvU2hlZXRzUmVnaXN0cnkuanMiLCJub2RlX21vZHVsZXMvanNzL2xpYi9TdHlsZVNoZWV0LmpzIiwibm9kZV9tb2R1bGVzL2pzcy9saWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvanNzL2xpYi9wbHVnaW5zL2Z1bmN0aW9ucy5qcyIsIm5vZGVfbW9kdWxlcy9qc3MvbGliL3BsdWdpbnMvb2JzZXJ2YWJsZXMuanMiLCJub2RlX21vZHVsZXMvanNzL2xpYi9wbHVnaW5zL3J1bGVzLmpzIiwibm9kZV9tb2R1bGVzL2pzcy9saWIvcmVuZGVyZXJzL0RvbVJlbmRlcmVyLmpzIiwibm9kZV9tb2R1bGVzL2pzcy9saWIvcmVuZGVyZXJzL1ZpcnR1YWxSZW5kZXJlci5qcyIsIm5vZGVfbW9kdWxlcy9qc3MvbGliL3J1bGVzL0NvbmRpdGlvbmFsUnVsZS5qcyIsIm5vZGVfbW9kdWxlcy9qc3MvbGliL3J1bGVzL0ZvbnRGYWNlUnVsZS5qcyIsIm5vZGVfbW9kdWxlcy9qc3MvbGliL3J1bGVzL0tleWZyYW1lc1J1bGUuanMiLCJub2RlX21vZHVsZXMvanNzL2xpYi9ydWxlcy9TaW1wbGVSdWxlLmpzIiwibm9kZV9tb2R1bGVzL2pzcy9saWIvcnVsZXMvU3R5bGVSdWxlLmpzIiwibm9kZV9tb2R1bGVzL2pzcy9saWIvcnVsZXMvVmlld3BvcnRSdWxlLmpzIiwibm9kZV9tb2R1bGVzL2pzcy9saWIvc2hlZXRzLmpzIiwibm9kZV9tb2R1bGVzL2pzcy9saWIvdXRpbHMvY2xvbmVTdHlsZS5qcyIsIm5vZGVfbW9kdWxlcy9qc3MvbGliL3V0aWxzL2NyZWF0ZUdlbmVyYXRlQ2xhc3NOYW1lLmpzIiwibm9kZV9tb2R1bGVzL2pzcy9saWIvdXRpbHMvY3JlYXRlUnVsZS5qcyIsIm5vZGVfbW9kdWxlcy9qc3MvbGliL3V0aWxzL2VzY2FwZS5qcyIsIm5vZGVfbW9kdWxlcy9qc3MvbGliL3V0aWxzL2dldER5bmFtaWNTdHlsZXMuanMiLCJub2RlX21vZHVsZXMvanNzL2xpYi91dGlscy9pc09ic2VydmFibGUuanMiLCJub2RlX21vZHVsZXMvanNzL2xpYi91dGlscy9rZWJhYkNhc2UuanMiLCJub2RlX21vZHVsZXMvanNzL2xpYi91dGlscy9saW5rUnVsZS5qcyIsIm5vZGVfbW9kdWxlcy9qc3MvbGliL3V0aWxzL21vZHVsZUlkLmpzIiwibm9kZV9tb2R1bGVzL2pzcy9saWIvdXRpbHMvdG9Dc3MuanMiLCJub2RlX21vZHVsZXMvanNzL2xpYi91dGlscy90b0Nzc1ZhbHVlLmpzIiwibm9kZV9tb2R1bGVzL21vbWVudC9tb21lbnQuanMiLCJub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3N5bWJvbC1vYnNlcnZhYmxlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3N5bWJvbC1vYnNlcnZhYmxlL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zeW1ib2wtb2JzZXJ2YWJsZS9saWIvcG9ueWZpbGwuanMiLCJub2RlX21vZHVsZXMvdnVlL2Rpc3QvdnVlLnJ1bnRpbWUuY29tbW9uLmpzIiwibm9kZV9tb2R1bGVzL3dhcm5pbmcvYnJvd3Nlci5qcyIsInBhY2thZ2UuanNvbiIsInNyYy9fbG9jYWwuY29mZmVlIiwic3JjL2FwcC9Cb3QuY29mZmVlIiwic3JjL2FwcC9GaWx0ZXJzLmNvZmZlZSIsInNyYy9hcHAvTG9nLmNvZmZlZSIsInNyYy9hcHAvTWVudS5jb2ZmZWUiLCJzcmMvYXBwL01vZHMuY29mZmVlIiwic3JjL2FwcC9pbmRleC5jb2ZmZWUiLCJzcmMvYXBwL3JvdXRlci5jb2ZmZWUiLCJzcmMvbW9kdWxlcy9BcmNoV2lraS5jb2ZmZWUiLCJzcmMvbW9kdWxlcy9DYXQuY29mZmVlIiwic3JjL21vZHVsZXMvRGlmZi5jb2ZmZWUiLCJzcmMvbW9kdWxlcy9FZGl0b3IuY29mZmVlIiwic3JjL21vZHVsZXMvSW50ZXJsYW5ndWFnZS5jb2ZmZWUiLCJzcmMvbW9kdWxlcy9NVy5jb2ZmZWUiLCJzcmMvbW9kdWxlcy9QYXJzZXIuY29mZmVlIiwic3JjL21vZHVsZXMvVGFibGVzLmNvZmZlZSIsInNyYy9tb2R1bGVzL1VwZ3JhZGUuY29mZmVlIiwic3JjL21vZHVsZXMvV2hhdExpbmtzSGVyZS5jb2ZmZWUiLCJzcmMvbW9kdWxlcy9pbmRleC5jb2ZmZWUiLCJzcmMvbW9kdWxlcy9saWJzLmNvZmZlZSIsInNyYy9wbHVnaW5zL0FyY2hXaWtpRml4SGVhZGVyLmNvZmZlZSIsInNyYy9wbHVnaW5zL0FyY2hXaWtpRml4SGVhZGluZ3MuY29mZmVlIiwic3JjL3BsdWdpbnMvQXJjaFdpa2lGaXhMaW5rcy5jb2ZmZWUiLCJzcmMvcGx1Z2lucy9BcmNoV2lraU5QRmlsdGVyLmNvZmZlZSIsInNyYy9wbHVnaW5zL0FyY2hXaWtpTmV3VGVtcGxhdGVzLmNvZmZlZSIsInNyYy9wbHVnaW5zL0FyY2hXaWtpUkNGaWx0ZXIuY29mZmVlIiwic3JjL3BsdWdpbnMvQXJjaFdpa2lTYXZlVGFsay5jb2ZmZWUiLCJzcmMvcGx1Z2lucy9BcmNoV2lraVNvcnRDb250YWN0cy5jb2ZmZWUiLCJzcmMvcGx1Z2lucy9BcmNoV2lraVdhbnRlZENhdGVnb3JpZXMuY29mZmVlIiwic3JjL3BsdWdpbnMvRGVsZXRlUGFnZXMuY29mZmVlIiwic3JjL3BsdWdpbnMvRXhwYW5kQ29udHJhY3Rpb25zLmNvZmZlZSIsInNyYy9wbHVnaW5zL0ZpeEJhY2tsaW5rRnJhZ21lbnRzLmNvZmZlZSIsInNyYy9wbHVnaW5zL0ZpeERvdWJsZVJlZGlyZWN0cy5jb2ZmZWUiLCJzcmMvcGx1Z2lucy9GaXhGcmFnbWVudHMuY29mZmVlIiwic3JjL3BsdWdpbnMvRml4TGlua0ZyYWdtZW50cy5jb2ZmZWUiLCJzcmMvcGx1Z2lucy9NdWx0aXBsZUxpbmVCcmVha3MuY29mZmVlIiwic3JjL3BsdWdpbnMvU2ltcGxlUmVwbGFjZS5jb2ZmZWUiLCJzcmMvcGx1Z2lucy9TeW5jaHJvbml6ZUludGVybGFuZ3VhZ2VMaW5rcy5jb2ZmZWUiLCJzcmMvcGx1Z2lucy9VcGRhdGVDYXRlZ29yeVRyZWUuY29mZmVlIiwic3JjL3BsdWdpbnMvX1BsdWdpbi5jb2ZmZWUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDMUxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDaHVCQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuR0E7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JGQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBOztBQ0RBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaGVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4UkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdk1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7O0FDREE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25MQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbE5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0UEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDek9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzlhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3Y3SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4TEE7QUFDQTs7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDbnZQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNoQ0EsSUFBQSxBQWtCQTs7ZUFBZSxRQWxCZixBQWtCQSxBQUFlLEFBQVE7O0FBQXZCLEFBQUM7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QkFBTyxBQUFZLFlBQUEsQUFBQyxLQUFELEFBQUMsQUFBTSxNQUY5QixBQUU4QjtBQUxsQzs7QUFPQSxZQUFHLENBQUksQUFBQyxLQUFBLEFBQUUsVUFBQSxBQUFJLEtBQWQsQUFBZTtBQUNYLGlCQUFPLEFBQVksWUFBQSxBQUFDLEtBQXBCLEFBQW1CLEFBQUM7O0FBR3BCLGdCQUFNLElBQUEsQUFBSSxNQUpkLEFBSVUsQUFBVTs7QUFFcEIsWUFBRyxBQUFDLEVBQUQsQUFBRSxjQUFjLEFBQVksWUFBQSxBQUFDLEtBQWhDLEFBQUcsQUFBNEIsQUFBQztpQkFDNUIsT0FBTyxBQUFZLFlBQUEsQUFBQyxLQUR4QixBQUN1QixBQUFDO0FBeEJkOzs7O0FBMEJkLEFBQWEsb0JBQUE7OztBQUFDLEFBQUMsV0FBQSxLQUFGO0FBakNqQjs7Ozs7OzttQkFtQ0ksV0FBVTs7bUJBQ1YsWUFBVzs7bUJBQ1gsY0FBYTs7bUJBQ2IsZ0JBQWU7O21CQUNmLHFCQUFvQjs7bUJBQ3BCLGVBQWMiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMi4xLjFcbi8vIEphdmFTY3JpcHQgYXV4aWxpYXJ5IGxpYnJhcnlcbi8vIENvcHlyaWdodCAoQykgMjAxMiBEYXJpbyBHaW92YW5uZXR0aSA8ZGV2QGRhcmlvZ2lvdmFubmV0dGkubmV0PlxuXG4vLyBUaGlzIGZpbGUgaXMgcGFydCBvZiBKYXZhU2NyaXB0IGF1eGlsaWFyeSBsaWJyYXJ5LlxuXG4vLyBKYXZhU2NyaXB0IGF1eGlsaWFyeSBsaWJyYXJ5IGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0XG4vLyBhbmQvb3IgbW9kaWZ5IGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFzIHB1Ymxpc2hlZCBieSB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzXG4vLyBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuLy8gSmF2YVNjcmlwdCBhdXhpbGlhcnkgbGlicmFyeSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmVcbi8vIHVzZWZ1bCwgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIEphdmFTY3JpcHQgYXV4aWxpYXJ5IGxpYnJhcnkuXG4vLyBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG5tb2R1bGUuZXhwb3J0cy5leGVjdXRlQXN5bmMgPSBmdW5jdGlvbiAoZnVuY3Rpb25zLCBpZCkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHZhciBjYWxsQ29udGludWUsIGZpZDtcbiAgaWQrKztcbiAgaWYgKGZ1bmN0aW9uc1tpZF0pIHtcbiAgICBmaWQgPSBmdW5jdGlvbnNbaWRdO1xuICAgIGNhbGxDb250aW51ZSA9IGZ1bmN0aW9uIGNhbGxDb250aW51ZSgpIHtcbiAgICAgIHJldHVybiBfdGhpcy5leGVjdXRlQXN5bmMoZnVuY3Rpb25zLCBpZCk7XG4gICAgfTtcbiAgICByZXR1cm4gZmlkWzBdKGZpZFsxXSwgY2FsbENvbnRpbnVlKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMucmVjdXJzZVRyZWVBc3luYyA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgdmFyIHBhcmVudDtcbiAgLy8gcGFyYW1zID0ge1xuICAvLyAgIG5vZGU6ICxcbiAgLy8gICBwYXJlbnRJbmRleDogLFxuICAvLyAgIHNpYmxpbmdJbmRleDogLFxuICAvLyAgIGFuY2VzdG9yczogLFxuICAvLyAgIGNoaWxkcmVuOiAsXG4gIC8vICAgY2FsbENoaWxkcmVuOiAsXG4gIC8vICAgY2FsbE5vZGU6ICxcbiAgLy8gICBjYWxsRW5kOiAsXG4gIC8vICAgY2FsbEFyZ3M6ICxcbiAgLy8gICBzdGFnZTogLFxuICAvLyAgIG5vZGVzTGlzdDpcbiAgLy8gfVxuXG4gIC8vIG5vZGVzTGlzdDogW1xuICAvLyAgIHtcbiAgLy8gICAgIG5vZGU6ICxcbiAgLy8gICAgIHBhcmVudEluZGV4OiAsXG4gIC8vICAgICBzaWJsaW5nSW5kZXg6ICxcbiAgLy8gICAgIGFuY2VzdG9yczogWy4uLl0sXG4gIC8vICAgICBjaGlsZHJlbjogWy4uLl1cbiAgLy8gICB9LFxuICAvLyAgIHsuLi59XG4gIC8vIF1cblxuICAvLyBFeGFtcGxlOlxuXG4gIC8vIHJlY3Vyc2VUcmVlQXN5bmMoe1xuICAvLyAgIG5vZGU6ICxcbiAgLy8gICBjYWxsQ2hpbGRyZW46ICxcbiAgLy8gICBjYWxsTm9kZTogLFxuICAvLyAgIGNhbGxFbmQ6ICxcbiAgLy8gICBjYWxsQXJnczpcbiAgLy8gfSk7XG5cbiAgLy8gY2FsbENoaWxkcmVuKHBhcmFtcykge1xuICAvLyAgIHBhcmFtcy5jaGlsZHJlbiA9IDtcbiAgLy8gICByZWN1cnNlVHJlZUFzeW5jKHBhcmFtcyk7XG4gIC8vIH1cblxuICAvLyBjYWxsTm9kZShwYXJhbXMpIHtcbiAgLy8gICByZWN1cnNlVHJlZUFzeW5jKHBhcmFtcyk7XG4gIC8vIH1cblxuICAvLyBjYWxsRW5kKHBhcmFtcykge31cbiAgc3dpdGNoIChwYXJhbXMuc3RhZ2UpIHtcbiAgICBjYXNlIHZvaWQgMDpcbiAgICAgIHBhcmFtcy5wYXJlbnRJbmRleCA9IG51bGw7XG4gICAgICBwYXJhbXMuc2libGluZ0luZGV4ID0gMDtcbiAgICAgIHBhcmFtcy5hbmNlc3RvcnMgPSBbXTtcbiAgICAgIHBhcmFtcy5jaGlsZHJlbiA9IFtdO1xuICAgICAgcGFyYW1zLm5vZGVzTGlzdCA9IFtdO1xuICAgICAgcGFyYW1zLnN0YWdlID0gMTtcbiAgICAgIHJldHVybiB0aGlzLnJlY3Vyc2VUcmVlQXN5bmMocGFyYW1zKTtcbiAgICBjYXNlIDE6XG4gICAgICBwYXJhbXMuc3RhZ2UgPSAyO1xuICAgICAgLy8gUHJldmVudCBpbmZpbml0ZSBsb29wc1xuICAgICAgaWYgKHBhcmFtcy5hbmNlc3RvcnMuaW5kZXhPZihwYXJhbXMubm9kZSkgPT09IC0xKSB7XG4gICAgICAgIHJldHVybiBwYXJhbXMuY2FsbENoaWxkcmVuKHBhcmFtcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJhbXMuY2hpbGRyZW4gPSBcImxvb3BcIjtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVjdXJzZVRyZWVBc3luYyhwYXJhbXMpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAyOlxuICAgICAgcGFyYW1zLm5vZGVzTGlzdC5wdXNoKHtcbiAgICAgICAgbm9kZTogcGFyYW1zLm5vZGUsXG4gICAgICAgIHBhcmVudEluZGV4OiBwYXJhbXMucGFyZW50SW5kZXgsXG4gICAgICAgIHNpYmxpbmdJbmRleDogcGFyYW1zLnNpYmxpbmdJbmRleCxcbiAgICAgICAgYW5jZXN0b3JzOiBwYXJhbXMuYW5jZXN0b3JzLnNsaWNlKDApLFxuICAgICAgICBjaGlsZHJlbjogcGFyYW1zLmNoaWxkcmVuLnNsaWNlKDApXG4gICAgICB9KTtcbiAgICAgIHBhcmFtcy5zdGFnZSA9IDM7XG4gICAgICByZXR1cm4gcGFyYW1zLmNhbGxOb2RlKHBhcmFtcyk7XG4gICAgY2FzZSAzOlxuICAgICAgaWYgKHBhcmFtcy5jaGlsZHJlbi5sZW5ndGggJiYgcGFyYW1zLmNoaWxkcmVuICE9PSBcImxvb3BcIikge1xuICAgICAgICAvLyBHbyB0byB0aGUgZmlyc3QgY2hpbGRcbiAgICAgICAgcGFyYW1zLmFuY2VzdG9ycy5wdXNoKHBhcmFtcy5ub2RlKTtcbiAgICAgICAgcGFyYW1zLm5vZGUgPSBwYXJhbXMuY2hpbGRyZW5bMF07XG4gICAgICAgIHBhcmFtcy5wYXJlbnRJbmRleCA9IHBhcmFtcy5ub2Rlc0xpc3QubGVuZ3RoIC0gMTtcbiAgICAgICAgcGFyYW1zLnNpYmxpbmdJbmRleCA9IDA7XG4gICAgICAgIHBhcmFtcy5jaGlsZHJlbiA9IFtdO1xuICAgICAgICBwYXJhbXMuc3RhZ2UgPSAxO1xuICAgICAgICByZXR1cm4gdGhpcy5yZWN1cnNlVHJlZUFzeW5jKHBhcmFtcyk7XG4gICAgICB9IGVsc2UgaWYgKHBhcmFtcy5wYXJlbnRJbmRleCAhPT0gbnVsbCkge1xuICAgICAgICAvLyBHbyB0byB0aGUgbmV4dCBzaWJsaW5nXG4gICAgICAgIHBhcmVudCA9IHBhcmFtcy5ub2Rlc0xpc3RbcGFyYW1zLnBhcmVudEluZGV4XTtcbiAgICAgICAgcGFyYW1zLnNpYmxpbmdJbmRleCsrO1xuICAgICAgICBwYXJhbXMubm9kZSA9IHBhcmVudC5jaGlsZHJlbltwYXJhbXMuc2libGluZ0luZGV4XTtcbiAgICAgICAgcGFyYW1zLmNoaWxkcmVuID0gW107XG4gICAgICAgIGlmIChwYXJhbXMubm9kZSkge1xuICAgICAgICAgIHBhcmFtcy5zdGFnZSA9IDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gVGhlcmUgYXJlIG5vIG1vcmUgc2libGluZ3NcbiAgICAgICAgICBwYXJhbXMubm9kZSA9IHBhcmVudC5ub2RlO1xuICAgICAgICAgIHBhcmFtcy5wYXJlbnRJbmRleCA9IHBhcmVudC5wYXJlbnRJbmRleDtcbiAgICAgICAgICBwYXJhbXMuc2libGluZ0luZGV4ID0gcGFyZW50LnNpYmxpbmdJbmRleDtcbiAgICAgICAgICBwYXJhbXMuYW5jZXN0b3JzID0gcGFyZW50LmFuY2VzdG9ycy5zbGljZSgwKTtcbiAgICAgICAgICBwYXJhbXMuc3RhZ2UgPSAzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnJlY3Vyc2VUcmVlQXN5bmMocGFyYW1zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEVuZCBvZiByZWN1cnNpb25cbiAgICAgICAgcmV0dXJuIHBhcmFtcy5jYWxsRW5kKHBhcmFtcyk7XG4gICAgICB9XG4gIH1cbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMi4xLjFcbi8vIEphdmFTY3JpcHQgYXV4aWxpYXJ5IGxpYnJhcnlcbi8vIENvcHlyaWdodCAoQykgMjAxMiBEYXJpbyBHaW92YW5uZXR0aSA8ZGV2QGRhcmlvZ2lvdmFubmV0dGkubmV0PlxuXG4vLyBUaGlzIGZpbGUgaXMgcGFydCBvZiBKYXZhU2NyaXB0IGF1eGlsaWFyeSBsaWJyYXJ5LlxuXG4vLyBKYXZhU2NyaXB0IGF1eGlsaWFyeSBsaWJyYXJ5IGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0XG4vLyBhbmQvb3IgbW9kaWZ5IGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFzIHB1Ymxpc2hlZCBieSB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzXG4vLyBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuLy8gSmF2YVNjcmlwdCBhdXhpbGlhcnkgbGlicmFyeSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmVcbi8vIHVzZWZ1bCwgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIEphdmFTY3JpcHQgYXV4aWxpYXJ5IGxpYnJhcnkuXG4vLyBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG5tb2R1bGUuZXhwb3J0cy5lc2NhcGVQYXR0ZXJuID0gZnVuY3Rpb24gKHN0cmluZykge1xuICAvLyBFc2NhcGluZyBhbnkgb3RoZXIgY2hhcmFjdGVycyBpcyBub3QgbmVjZXNzYXJ5LCByZWZlcmVuY2VzOlxuICAvLyAtIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvR3VpZGUvUmVndWxhcl9FeHByZXNzaW9uc1xuICAvLyAtIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzU2MTQ5My9pcy10aGVyZS1hLXJlZ2V4cC1lc2NhcGUtZnVuY3Rpb24taW4tamF2YXNjcmlwdFxuICAvLyAtIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjU5MzYzNy9ob3ctdG8tZXNjYXBlLXJlZ3VsYXItZXhwcmVzc2lvbi1pbi1qYXZhc2NyaXB0XG4gIC8vIC0gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy80OTQwMzUvaG93LWRvLXlvdS1wYXNzLWEtdmFyaWFibGUtdG8tYS1yZWd1bGFyLWV4cHJlc3Npb24tamF2YXNjcmlwdFxuICAvLyAtIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzQ0NjE3MC9lc2NhcGUtc3RyaW5nLWZvci11c2UtaW4tamF2YXNjcmlwdC1yZWdleFxuICAvLyAtIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzk5MDc4L3doYXQtc3BlY2lhbC1jaGFyYWN0ZXJzLW11c3QtYmUtZXNjYXBlZC1pbi1yZWd1bGFyLWV4cHJlc3Npb25zXG5cbiAgLy8gTm90ZSBmb3IgV2lraSBNb25rZXk6IGRvICpub3QqIGVzY2FwZSAnXFxzJyBoZXJlIHNvIHRoYXQgaXQgd2lsbCBiZVxuICAvLyBzYWZlIHRvIHVzZSBwcmVwYXJlUmVnZXhwV2hpdGVzcGFjZSBpbiBXTS5QYXJzZXJcbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC9bLVtcXF17fSgpXiQqKz8ufFxcXFxdL2csIFwiXFxcXCQmXCIpO1xufTtcblxubW9kdWxlLmV4cG9ydHMubWF0Y2hBbGwgPSBmdW5jdGlvbiAoc291cmNlLCByZWdFeHApIHtcbiAgdmFyIEwsIG1hdGNoLCByZXN1bHQ7XG4gIHJlc3VsdCA9IFtdO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIG1hdGNoID0gcmVnRXhwLmV4ZWMoc291cmNlKTtcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIEwgPSBtYXRjaFswXS5sZW5ndGg7XG4gICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgIFwibWF0Y2hcIjogbWF0Y2gsXG4gICAgICAgIFwiaW5kZXhcIjogcmVnRXhwLmxhc3RJbmRleCAtIEwsXG4gICAgICAgIFwibGVuZ3RoXCI6IExcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbm1vZHVsZS5leHBvcnRzLm1hdGNoQWxsQ29uZGl0aW9uYWwgPSBmdW5jdGlvbiAoc291cmNlLCByZWdFeHAsIHRlc3QpIHtcbiAgdmFyIEwsIG1hdGNoLCByZXN1bHQ7XG4gIHJlc3VsdCA9IFtdO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIG1hdGNoID0gcmVnRXhwLmV4ZWMoc291cmNlKTtcbiAgICBpZiAobWF0Y2ggJiYgdGVzdChtYXRjaCkpIHtcbiAgICAgIEwgPSBtYXRjaFswXS5sZW5ndGg7XG4gICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgIFwibWF0Y2hcIjogbWF0Y2gsXG4gICAgICAgIFwiaW5kZXhcIjogcmVnRXhwLmxhc3RJbmRleCAtIEwsXG4gICAgICAgIFwibGVuZ3RoXCI6IExcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMi4xLjFcbi8vIEphdmFTY3JpcHQgYXV4aWxpYXJ5IGxpYnJhcnlcbi8vIENvcHlyaWdodCAoQykgMjAxMiBEYXJpbyBHaW92YW5uZXR0aSA8ZGV2QGRhcmlvZ2lvdmFubmV0dGkubmV0PlxuXG4vLyBUaGlzIGZpbGUgaXMgcGFydCBvZiBKYXZhU2NyaXB0IGF1eGlsaWFyeSBsaWJyYXJ5LlxuXG4vLyBKYXZhU2NyaXB0IGF1eGlsaWFyeSBsaWJyYXJ5IGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0XG4vLyBhbmQvb3IgbW9kaWZ5IGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFzIHB1Ymxpc2hlZCBieSB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzXG4vLyBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuLy8gSmF2YVNjcmlwdCBhdXhpbGlhcnkgbGlicmFyeSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmVcbi8vIHVzZWZ1bCwgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIEphdmFTY3JpcHQgYXV4aWxpYXJ5IGxpYnJhcnkuXG4vLyBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG5tb2R1bGUuZXhwb3J0cy5pbnNlcnQgPSBmdW5jdGlvbiAoc3RyaW5nLCBuZXdTdHJpbmcsIGlkKSB7XG4gIGlmIChpZCA9PSBudWxsKSB7XG4gICAgaWQgPSAwO1xuICB9XG4gIHJldHVybiBzdHJpbmcuc3Vic3RyaW5nKDAsIGlkKSArIG5ld1N0cmluZyArIHN0cmluZy5zdWJzdHIoaWQpO1xufTtcblxubW9kdWxlLmV4cG9ydHMub3ZlcndyaXRlRm9yID0gZnVuY3Rpb24gKHN0cmluZywgbmV3U3RyaW5nLCBpZCwgbGVuZ3RoKSB7XG4gIGlmIChpZCA9PSBudWxsKSB7XG4gICAgaWQgPSAwO1xuICB9XG4gIGlmICghbGVuZ3RoIHx8IGxlbmd0aCA8IDApIHtcbiAgICBsZW5ndGggPSAwO1xuICB9XG4gIHJldHVybiBzdHJpbmcuc3Vic3RyaW5nKDAsIGlkKSArIG5ld1N0cmluZyArIHN0cmluZy5zdWJzdHIoaWQgKyBsZW5ndGgpO1xufTtcblxubW9kdWxlLmV4cG9ydHMub3ZlcndyaXRlQXQgPSBmdW5jdGlvbiAoc3RyaW5nLCBuZXdTdHJpbmcsIGlkKSB7XG4gIHJldHVybiBtb2R1bGUuZXhwb3J0cy5vdmVyd3JpdGVGb3Ioc3RyaW5nLCBuZXdTdHJpbmcsIGlkLCBuZXdTdHJpbmcubGVuZ3RoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzLm92ZXJ3cml0ZUJldHdlZW4gPSBmdW5jdGlvbiAoc3RyaW5nLCBuZXdTdHJpbmcsIGlkMSwgaWQyKSB7XG4gIHZhciB0ZW1waWQ7XG4gIGlmIChpZDEgPT0gbnVsbCkge1xuICAgIGlkMSA9IDA7XG4gIH1cbiAgaWYgKGlkMiA9PSBudWxsKSB7XG4gICAgaWQyID0gaWQxO1xuICB9XG4gIGlmIChpZDEgPiBpZDIpIHtcbiAgICB0ZW1waWQgPSBpZDI7XG4gICAgaWQyID0gaWQxO1xuICAgIGlkMSA9IHRlbXBpZDtcbiAgfVxuICByZXR1cm4gc3RyaW5nLnN1YnN0cmluZygwLCBpZDEpICsgbmV3U3RyaW5nICsgc3RyaW5nLnN1YnN0cihpZDIpO1xufTtcblxubW9kdWxlLmV4cG9ydHMucmVtb3ZlRm9yID0gZnVuY3Rpb24gKHN0cmluZywgaWQsIGxlbmd0aCkge1xuICByZXR1cm4gbW9kdWxlLmV4cG9ydHMub3ZlcndyaXRlRm9yKHN0cmluZywgXCJcIiwgaWQsIGxlbmd0aCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5yZW1vdmVCZXR3ZWVuID0gZnVuY3Rpb24gKHN0cmluZywgaWQxLCBpZDIpIHtcbiAgcmV0dXJuIG1vZHVsZS5leHBvcnRzLm92ZXJ3cml0ZUJldHdlZW4oc3RyaW5nLCBcIlwiLCBpZDEsIGlkMik7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5wYWRMZWZ0ID0gZnVuY3Rpb24gKHN0cmluZywgZmlsbGVyLCBsZW5ndGgpIHtcbiAgd2hpbGUgKHN0cmluZy5sZW5ndGggPCBsZW5ndGgpIHtcbiAgICBzdHJpbmcgPSBmaWxsZXIgKyBzdHJpbmc7XG4gIH1cbiAgcmV0dXJuIHN0cmluZztcbn07XG5cbm1vZHVsZS5leHBvcnRzLnBhZFJpZ2h0ID0gZnVuY3Rpb24gKHN0cmluZywgZmlsbGVyLCBsZW5ndGgpIHtcbiAgd2hpbGUgKHN0cmluZy5sZW5ndGggPCBsZW5ndGgpIHtcbiAgICBzdHJpbmcgKz0gZmlsbGVyO1xuICB9XG4gIHJldHVybiBzdHJpbmc7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5maW5kU2ltcGxlRW5jbG9zdXJlcyA9IGZ1bmN0aW9uIChzdHJpbmcsIG9wZW5UYWcsIG9wZW5MZW5ndGgsIGNsb3NlVGFnLCBjbG9zZUxlbmd0aCkge1xuICB2YXIgY0luZGV4LCBjSW5kZXhSZWwsIG9JbmRleCwgb0luZGV4UmVsLCByZXN1bHRzLCBzZWFyY2hJbmRleDtcbiAgLy8gb3BlblRhZyBhbmQgY2xvc2VUYWcgY2FuIGJlIHN0cmluZ3Mgb3IgcmVndWxhciBleHByZXNzaW9uc1xuICAvLyBJZiB0aGUgc3RyaW5nIGlzIFwiPDw+PlwiIGFuZCB0aGUgdGFncyBhcmUgXCI8XCIgYW5kIFwiPlwiLCB0aGUgcmVzdWx0IGlzXG4gIC8vICAgW1swLCAyXSwgXVxuICAvLyBSZXN1bHRzIGFyZSBndWFyYW50ZWVkIHRvIGJlIGluIG9yZGVyIG9mIGFwcGVhcmFuY2UgaW4gdGhlIG9yaWdpbmFsXG4gIC8vICAgdGV4dFxuICByZXN1bHRzID0gW107XG4gIHNlYXJjaEluZGV4ID0gMDtcbiAgb0luZGV4UmVsID0gc3RyaW5nLnNlYXJjaChvcGVuVGFnKTtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBpZiAob0luZGV4UmVsID4gLTEpIHtcbiAgICAgIG9JbmRleCA9IHNlYXJjaEluZGV4ICsgb0luZGV4UmVsO1xuICAgICAgY0luZGV4UmVsID0gc3RyaW5nLnN1YnN0cihvSW5kZXggKyBvcGVuTGVuZ3RoKS5zZWFyY2goY2xvc2VUYWcpO1xuICAgICAgaWYgKGNJbmRleFJlbCA+IC0xKSB7XG4gICAgICAgIGNJbmRleCA9IG9JbmRleCArIG9wZW5MZW5ndGggKyBjSW5kZXhSZWw7XG4gICAgICAgIHJlc3VsdHMucHVzaChbb0luZGV4LCBjSW5kZXhdKTtcbiAgICAgICAgc2VhcmNoSW5kZXggPSBjSW5kZXggKyBjbG9zZUxlbmd0aDtcbiAgICAgICAgaWYgKHNlYXJjaEluZGV4IDwgc3RyaW5nLmxlbmd0aCkge1xuICAgICAgICAgIG9JbmRleFJlbCA9IHN0cmluZy5zdWJzdHIoc2VhcmNoSW5kZXgpLnNlYXJjaChvcGVuVGFnKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQSB0YWcgaXMgbGVmdCBvcGVuIChubyBjbG9zaW5nIHRhZyBpcyBmb3VuZClcbiAgICAgICAgLy8gTGV0IGVhY2ggaW1wbGVtZW50YXRpb24gZGVjaWRlIHdoYXQgdG8gZG8gaW4gdGhpcyBjYXNlXG4gICAgICAgIC8vICAgKGVpdGhlciBjb25zaWRlciB0aGUgdGFnIHdvcmtpbmcgdW50aWwgdGhlIGVuZCBvZiB0ZXh0XG4gICAgICAgIC8vICAgb3Igbm90KVxuICAgICAgICByZXN1bHRzLnB1c2goW29JbmRleCwgZmFsc2VdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0cztcbn07XG5cbm1vZHVsZS5leHBvcnRzLmZpbmROZXN0ZWRFbmNsb3N1cmVzID0gZnVuY3Rpb24gKHN0cmluZywgb3BlblRhZywgY2xvc2VUYWcsIG1hc2tDaGFyKSB7XG4gIHZhciBjSW5kZXgsIGNJbmRleFJlbCwgY2xvc2VMZW5ndGgsIG1hc2tMZW5ndGgsIG1hc2tlZFN0cmluZywgbWFza2VkU3RyaW5nMSwgbWFza2VkU3RyaW5nMiwgbWFza2VkU3RyaW5nMywgb0luZGV4LCBvSW5kZXhSZWwsIG9wZW5MZW5ndGgsIHJlc3VsdHMsIHNlYXJjaEluZGV4O1xuICAvLyBvcGVuVGFnIGFuZCBjbG9zZVRhZyBtdXN0IGJlIHN0cmluZ3MsICpub3QqIHJlZ3VsYXIgZXhwcmVzc2lvbnMsXG4gIC8vICAgdW5saWtlIHRoaXMuZmluZFNpbXBsZUVuY2xvc3VyZXNcbiAgLy8gbWFza0NoYXIgbXVzdCBiZSBhICoxKi1jaGFyYWN0ZXIgc3RyaW5nIGFuZCBtdXN0ICpub3QqIGJlIHBhcnQgb2ZcbiAgLy8gICBuZWl0aGVyIG9wZW5UYWcgbm9yIGNsb3NlVGFnXG4gIC8vIElmIHRoZSBzdHJpbmcgaXMgXCI8PD4+XCIgYW5kIHRoZSB0YWdzIGFyZSBcIjxcIiBhbmQgXCI+XCIsIHRoZSByZXN1bHQgaXNcbiAgLy8gICBbWzEsIDJdLCBbMCwgM11dXG4gIG9wZW5MZW5ndGggPSBvcGVuVGFnLmxlbmd0aDtcbiAgY2xvc2VMZW5ndGggPSBjbG9zZVRhZy5sZW5ndGg7XG4gIHJlc3VsdHMgPSBbXTtcbiAgc2VhcmNoSW5kZXggPSAwO1xuICBjSW5kZXhSZWwgPSBzdHJpbmcuaW5kZXhPZihjbG9zZVRhZyk7XG4gIG1hc2tlZFN0cmluZyA9IHN0cmluZztcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBpZiAoY0luZGV4UmVsID4gLTEpIHtcbiAgICAgIGNJbmRleCA9IHNlYXJjaEluZGV4ICsgY0luZGV4UmVsO1xuICAgICAgb0luZGV4UmVsID0gbWFza2VkU3RyaW5nLnN1YnN0cmluZyhzZWFyY2hJbmRleCwgY0luZGV4KS5sYXN0SW5kZXhPZihvcGVuVGFnKTtcbiAgICAgIGlmIChvSW5kZXhSZWwgPiAtMSkge1xuICAgICAgICBvSW5kZXggPSBzZWFyY2hJbmRleCArIG9JbmRleFJlbDtcbiAgICAgICAgcmVzdWx0cy5wdXNoKFtvSW5kZXgsIGNJbmRleF0pO1xuICAgICAgICBtYXNrZWRTdHJpbmcxID0gbWFza2VkU3RyaW5nLnN1YnN0cmluZygwLCBvSW5kZXgpO1xuICAgICAgICBtYXNrTGVuZ3RoID0gY0luZGV4IC0gb0luZGV4ICsgY2xvc2VMZW5ndGg7XG4gICAgICAgIG1hc2tlZFN0cmluZzIgPSBtb2R1bGUuZXhwb3J0cy5wYWRSaWdodChcIlwiLCBtYXNrQ2hhciwgbWFza0xlbmd0aCk7XG4gICAgICAgIG1hc2tlZFN0cmluZzMgPSBtYXNrZWRTdHJpbmcuc3Vic3RyaW5nKGNJbmRleCArIGNsb3NlTGVuZ3RoKTtcbiAgICAgICAgbWFza2VkU3RyaW5nID0gbWFza2VkU3RyaW5nMSArIG1hc2tlZFN0cmluZzIgKyBtYXNrZWRTdHJpbmczO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRG8gKm5vdCogaW5jcmVtZW50IHNlYXJjaEluZGV4IGluIHRoaXMgY2FzZSwgaW4gZmFjdCBpblxuICAgICAgICAvLyAgIHdlIGRvbid0IGtub3cgeWV0IHdoZXRoZXIgdGhlcmUgYXJlIG1vcmUgb3BlblRhZ3NcbiAgICAgICAgLy8gICBiZWZvcmUgdGhlIG9uZSBmb3VuZFxuICAgICAgICBzZWFyY2hJbmRleCA9IGNJbmRleCArIGNsb3NlTGVuZ3RoO1xuICAgICAgfVxuICAgICAgY0luZGV4UmVsID0gbWFza2VkU3RyaW5nLnN1YnN0cmluZyhzZWFyY2hJbmRleCkuaW5kZXhPZihjbG9zZVRhZyk7XG4gICAgICBjb250aW51ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBbcmVzdWx0cywgbWFza2VkU3RyaW5nXTtcbn07XG5cbm1vZHVsZS5leHBvcnRzLmZpbmRJbm5lcm1vc3RFbmNsb3N1cmVzID0gZnVuY3Rpb24gKHN0cmluZywgb3BlblRhZywgY2xvc2VUYWcpIHtcbiAgdmFyIGNJbmRleCwgY0luZGV4UmVsLCBjbG9zZUxlbmd0aCwgb0luZGV4LCBvSW5kZXhSZWwsIG9wZW5MZW5ndGgsIHJlc3VsdHMsIHNlYXJjaEluZGV4O1xuICAvLyBvcGVuVGFnIGFuZCBjbG9zZVRhZyBtdXN0IGJlIHN0cmluZ3MsICpub3QqIHJlZ3VsYXIgZXhwcmVzc2lvbnMsXG4gIC8vICAgdW5saWtlIHRoaXMuZmluZFNpbXBsZUVuY2xvc3VyZXNcbiAgLy8gSWYgdGhlIHN0cmluZyBpcyBcIjw8Pj5cIiBhbmQgdGhlIHRhZ3MgYXJlIFwiPFwiIGFuZCBcIj5cIiwgdGhlIHJlc3VsdCBpc1xuICAvLyAgIFtbMSwgMl0sIF1cbiAgb3Blbkxlbmd0aCA9IG9wZW5UYWcubGVuZ3RoO1xuICBjbG9zZUxlbmd0aCA9IGNsb3NlVGFnLmxlbmd0aDtcbiAgcmVzdWx0cyA9IFtdO1xuICBzZWFyY2hJbmRleCA9IDA7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgY0luZGV4UmVsID0gc3RyaW5nLnN1YnN0cmluZyhzZWFyY2hJbmRleCkuaW5kZXhPZihjbG9zZVRhZyk7XG4gICAgaWYgKGNJbmRleFJlbCA+IC0xKSB7XG4gICAgICBjSW5kZXggPSBzZWFyY2hJbmRleCArIGNJbmRleFJlbDtcbiAgICAgIG9JbmRleFJlbCA9IHN0cmluZy5zdWJzdHJpbmcoc2VhcmNoSW5kZXgsIGNJbmRleCkubGFzdEluZGV4T2Yob3BlblRhZyk7XG4gICAgICBpZiAob0luZGV4UmVsID4gLTEpIHtcbiAgICAgICAgb0luZGV4ID0gc2VhcmNoSW5kZXggKyBvSW5kZXhSZWw7XG4gICAgICAgIHJlc3VsdHMucHVzaChbb0luZGV4LCBjSW5kZXhdKTtcbiAgICAgIH1cbiAgICAgIHNlYXJjaEluZGV4ID0gY0luZGV4ICsgY2xvc2VMZW5ndGg7XG4gICAgICBjb250aW51ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHRzO1xufTsiLCJcInVzZSBzdHJpY3RcIjtcblxucmVxdWlyZShcImNvcmUtanMvc2hpbVwiKTtcblxucmVxdWlyZShcInJlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZVwiKTtcblxucmVxdWlyZShcImNvcmUtanMvZm4vcmVnZXhwL2VzY2FwZVwiKTtcblxuaWYgKGdsb2JhbC5fYmFiZWxQb2x5ZmlsbCkge1xuICB0aHJvdyBuZXcgRXJyb3IoXCJvbmx5IG9uZSBpbnN0YW5jZSBvZiBiYWJlbC1wb2x5ZmlsbCBpcyBhbGxvd2VkXCIpO1xufVxuZ2xvYmFsLl9iYWJlbFBvbHlmaWxsID0gdHJ1ZTtcblxudmFyIERFRklORV9QUk9QRVJUWSA9IFwiZGVmaW5lUHJvcGVydHlcIjtcbmZ1bmN0aW9uIGRlZmluZShPLCBrZXksIHZhbHVlKSB7XG4gIE9ba2V5XSB8fCBPYmplY3RbREVGSU5FX1BST1BFUlRZXShPLCBrZXksIHtcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgdmFsdWU6IHZhbHVlXG4gIH0pO1xufVxuXG5kZWZpbmUoU3RyaW5nLnByb3RvdHlwZSwgXCJwYWRMZWZ0XCIsIFwiXCIucGFkU3RhcnQpO1xuZGVmaW5lKFN0cmluZy5wcm90b3R5cGUsIFwicGFkUmlnaHRcIiwgXCJcIi5wYWRFbmQpO1xuXG5cInBvcCxyZXZlcnNlLHNoaWZ0LGtleXMsdmFsdWVzLGVudHJpZXMsaW5kZXhPZixldmVyeSxzb21lLGZvckVhY2gsbWFwLGZpbHRlcixmaW5kLGZpbmRJbmRleCxpbmNsdWRlcyxqb2luLHNsaWNlLGNvbmNhdCxwdXNoLHNwbGljZSx1bnNoaWZ0LHNvcnQsbGFzdEluZGV4T2YscmVkdWNlLHJlZHVjZVJpZ2h0LGNvcHlXaXRoaW4sZmlsbFwiLnNwbGl0KFwiLFwiKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgW11ba2V5XSAmJiBkZWZpbmUoQXJyYXksIGtleSwgRnVuY3Rpb24uY2FsbC5iaW5kKFtdW2tleV0pKTtcbn0pOyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIGh0dHBzOi8vcmF3LmdpdGh1Yi5jb20vZmFjZWJvb2svcmVnZW5lcmF0b3IvbWFzdGVyL0xJQ0VOU0UgZmlsZS4gQW5cbiAqIGFkZGl0aW9uYWwgZ3JhbnQgb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpblxuICogdGhlIHNhbWUgZGlyZWN0b3J5LlxuICovXG5cbiEoZnVuY3Rpb24oZ2xvYmFsKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIHZhciBPcCA9IE9iamVjdC5wcm90b3R5cGU7XG4gIHZhciBoYXNPd24gPSBPcC5oYXNPd25Qcm9wZXJ0eTtcbiAgdmFyIHVuZGVmaW5lZDsgLy8gTW9yZSBjb21wcmVzc2libGUgdGhhbiB2b2lkIDAuXG4gIHZhciAkU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiID8gU3ltYm9sIDoge307XG4gIHZhciBpdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuaXRlcmF0b3IgfHwgXCJAQGl0ZXJhdG9yXCI7XG4gIHZhciBhc3luY0l0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5hc3luY0l0ZXJhdG9yIHx8IFwiQEBhc3luY0l0ZXJhdG9yXCI7XG4gIHZhciB0b1N0cmluZ1RhZ1N5bWJvbCA9ICRTeW1ib2wudG9TdHJpbmdUYWcgfHwgXCJAQHRvU3RyaW5nVGFnXCI7XG5cbiAgdmFyIGluTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIjtcbiAgdmFyIHJ1bnRpbWUgPSBnbG9iYWwucmVnZW5lcmF0b3JSdW50aW1lO1xuICBpZiAocnVudGltZSkge1xuICAgIGlmIChpbk1vZHVsZSkge1xuICAgICAgLy8gSWYgcmVnZW5lcmF0b3JSdW50aW1lIGlzIGRlZmluZWQgZ2xvYmFsbHkgYW5kIHdlJ3JlIGluIGEgbW9kdWxlLFxuICAgICAgLy8gbWFrZSB0aGUgZXhwb3J0cyBvYmplY3QgaWRlbnRpY2FsIHRvIHJlZ2VuZXJhdG9yUnVudGltZS5cbiAgICAgIG1vZHVsZS5leHBvcnRzID0gcnVudGltZTtcbiAgICB9XG4gICAgLy8gRG9uJ3QgYm90aGVyIGV2YWx1YXRpbmcgdGhlIHJlc3Qgb2YgdGhpcyBmaWxlIGlmIHRoZSBydW50aW1lIHdhc1xuICAgIC8vIGFscmVhZHkgZGVmaW5lZCBnbG9iYWxseS5cbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBEZWZpbmUgdGhlIHJ1bnRpbWUgZ2xvYmFsbHkgKGFzIGV4cGVjdGVkIGJ5IGdlbmVyYXRlZCBjb2RlKSBhcyBlaXRoZXJcbiAgLy8gbW9kdWxlLmV4cG9ydHMgKGlmIHdlJ3JlIGluIGEgbW9kdWxlKSBvciBhIG5ldywgZW1wdHkgb2JqZWN0LlxuICBydW50aW1lID0gZ2xvYmFsLnJlZ2VuZXJhdG9yUnVudGltZSA9IGluTW9kdWxlID8gbW9kdWxlLmV4cG9ydHMgOiB7fTtcblxuICBmdW5jdGlvbiB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gSWYgb3V0ZXJGbiBwcm92aWRlZCBhbmQgb3V0ZXJGbi5wcm90b3R5cGUgaXMgYSBHZW5lcmF0b3IsIHRoZW4gb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IuXG4gICAgdmFyIHByb3RvR2VuZXJhdG9yID0gb3V0ZXJGbiAmJiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvciA/IG91dGVyRm4gOiBHZW5lcmF0b3I7XG4gICAgdmFyIGdlbmVyYXRvciA9IE9iamVjdC5jcmVhdGUocHJvdG9HZW5lcmF0b3IucHJvdG90eXBlKTtcbiAgICB2YXIgY29udGV4dCA9IG5ldyBDb250ZXh0KHRyeUxvY3NMaXN0IHx8IFtdKTtcblxuICAgIC8vIFRoZSAuX2ludm9rZSBtZXRob2QgdW5pZmllcyB0aGUgaW1wbGVtZW50YXRpb25zIG9mIHRoZSAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMuXG4gICAgZ2VuZXJhdG9yLl9pbnZva2UgPSBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuXG4gICAgcmV0dXJuIGdlbmVyYXRvcjtcbiAgfVxuICBydW50aW1lLndyYXAgPSB3cmFwO1xuXG4gIC8vIFRyeS9jYXRjaCBoZWxwZXIgdG8gbWluaW1pemUgZGVvcHRpbWl6YXRpb25zLiBSZXR1cm5zIGEgY29tcGxldGlvblxuICAvLyByZWNvcmQgbGlrZSBjb250ZXh0LnRyeUVudHJpZXNbaV0uY29tcGxldGlvbi4gVGhpcyBpbnRlcmZhY2UgY291bGRcbiAgLy8gaGF2ZSBiZWVuIChhbmQgd2FzIHByZXZpb3VzbHkpIGRlc2lnbmVkIHRvIHRha2UgYSBjbG9zdXJlIHRvIGJlXG4gIC8vIGludm9rZWQgd2l0aG91dCBhcmd1bWVudHMsIGJ1dCBpbiBhbGwgdGhlIGNhc2VzIHdlIGNhcmUgYWJvdXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGFuIGV4aXN0aW5nIG1ldGhvZCB3ZSB3YW50IHRvIGNhbGwsIHNvIHRoZXJlJ3Mgbm8gbmVlZFxuICAvLyB0byBjcmVhdGUgYSBuZXcgZnVuY3Rpb24gb2JqZWN0LiBXZSBjYW4gZXZlbiBnZXQgYXdheSB3aXRoIGFzc3VtaW5nXG4gIC8vIHRoZSBtZXRob2QgdGFrZXMgZXhhY3RseSBvbmUgYXJndW1lbnQsIHNpbmNlIHRoYXQgaGFwcGVucyB0byBiZSB0cnVlXG4gIC8vIGluIGV2ZXJ5IGNhc2UsIHNvIHdlIGRvbid0IGhhdmUgdG8gdG91Y2ggdGhlIGFyZ3VtZW50cyBvYmplY3QuIFRoZVxuICAvLyBvbmx5IGFkZGl0aW9uYWwgYWxsb2NhdGlvbiByZXF1aXJlZCBpcyB0aGUgY29tcGxldGlvbiByZWNvcmQsIHdoaWNoXG4gIC8vIGhhcyBhIHN0YWJsZSBzaGFwZSBhbmQgc28gaG9wZWZ1bGx5IHNob3VsZCBiZSBjaGVhcCB0byBhbGxvY2F0ZS5cbiAgZnVuY3Rpb24gdHJ5Q2F0Y2goZm4sIG9iaiwgYXJnKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwibm9ybWFsXCIsIGFyZzogZm4uY2FsbChvYmosIGFyZykgfTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwidGhyb3dcIiwgYXJnOiBlcnIgfTtcbiAgICB9XG4gIH1cblxuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRTdGFydCA9IFwic3VzcGVuZGVkU3RhcnRcIjtcbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkWWllbGQgPSBcInN1c3BlbmRlZFlpZWxkXCI7XG4gIHZhciBHZW5TdGF0ZUV4ZWN1dGluZyA9IFwiZXhlY3V0aW5nXCI7XG4gIHZhciBHZW5TdGF0ZUNvbXBsZXRlZCA9IFwiY29tcGxldGVkXCI7XG5cbiAgLy8gUmV0dXJuaW5nIHRoaXMgb2JqZWN0IGZyb20gdGhlIGlubmVyRm4gaGFzIHRoZSBzYW1lIGVmZmVjdCBhc1xuICAvLyBicmVha2luZyBvdXQgb2YgdGhlIGRpc3BhdGNoIHN3aXRjaCBzdGF0ZW1lbnQuXG4gIHZhciBDb250aW51ZVNlbnRpbmVsID0ge307XG5cbiAgLy8gRHVtbXkgY29uc3RydWN0b3IgZnVuY3Rpb25zIHRoYXQgd2UgdXNlIGFzIHRoZSAuY29uc3RydWN0b3IgYW5kXG4gIC8vIC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgcHJvcGVydGllcyBmb3IgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIEdlbmVyYXRvclxuICAvLyBvYmplY3RzLiBGb3IgZnVsbCBzcGVjIGNvbXBsaWFuY2UsIHlvdSBtYXkgd2lzaCB0byBjb25maWd1cmUgeW91clxuICAvLyBtaW5pZmllciBub3QgdG8gbWFuZ2xlIHRoZSBuYW1lcyBvZiB0aGVzZSB0d28gZnVuY3Rpb25zLlxuICBmdW5jdGlvbiBHZW5lcmF0b3IoKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvbigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKCkge31cblxuICAvLyBUaGlzIGlzIGEgcG9seWZpbGwgZm9yICVJdGVyYXRvclByb3RvdHlwZSUgZm9yIGVudmlyb25tZW50cyB0aGF0XG4gIC8vIGRvbid0IG5hdGl2ZWx5IHN1cHBvcnQgaXQuXG4gIHZhciBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xuICBJdGVyYXRvclByb3RvdHlwZVtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgdmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuICB2YXIgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90byAmJiBnZXRQcm90byhnZXRQcm90byh2YWx1ZXMoW10pKSk7XG4gIGlmIChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAmJlxuICAgICAgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgIT09IE9wICYmXG4gICAgICBoYXNPd24uY2FsbChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wpKSB7XG4gICAgLy8gVGhpcyBlbnZpcm9ubWVudCBoYXMgYSBuYXRpdmUgJUl0ZXJhdG9yUHJvdG90eXBlJTsgdXNlIGl0IGluc3RlYWRcbiAgICAvLyBvZiB0aGUgcG9seWZpbGwuXG4gICAgSXRlcmF0b3JQcm90b3R5cGUgPSBOYXRpdmVJdGVyYXRvclByb3RvdHlwZTtcbiAgfVxuXG4gIHZhciBHcCA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSA9XG4gICAgR2VuZXJhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUpO1xuICBHZW5lcmF0b3JGdW5jdGlvbi5wcm90b3R5cGUgPSBHcC5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uO1xuICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZVt0b1N0cmluZ1RhZ1N5bWJvbF0gPVxuICAgIEdlbmVyYXRvckZ1bmN0aW9uLmRpc3BsYXlOYW1lID0gXCJHZW5lcmF0b3JGdW5jdGlvblwiO1xuXG4gIC8vIEhlbHBlciBmb3IgZGVmaW5pbmcgdGhlIC5uZXh0LCAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMgb2YgdGhlXG4gIC8vIEl0ZXJhdG9yIGludGVyZmFjZSBpbiB0ZXJtcyBvZiBhIHNpbmdsZSAuX2ludm9rZSBtZXRob2QuXG4gIGZ1bmN0aW9uIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhwcm90b3R5cGUpIHtcbiAgICBbXCJuZXh0XCIsIFwidGhyb3dcIiwgXCJyZXR1cm5cIl0uZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgIHByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnZva2UobWV0aG9kLCBhcmcpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIHJ1bnRpbWUuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIHZhciBjdG9yID0gdHlwZW9mIGdlbkZ1biA9PT0gXCJmdW5jdGlvblwiICYmIGdlbkZ1bi5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gY3RvclxuICAgICAgPyBjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fFxuICAgICAgICAvLyBGb3IgdGhlIG5hdGl2ZSBHZW5lcmF0b3JGdW5jdGlvbiBjb25zdHJ1Y3RvciwgdGhlIGJlc3Qgd2UgY2FuXG4gICAgICAgIC8vIGRvIGlzIHRvIGNoZWNrIGl0cyAubmFtZSBwcm9wZXJ0eS5cbiAgICAgICAgKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSA9PT0gXCJHZW5lcmF0b3JGdW5jdGlvblwiXG4gICAgICA6IGZhbHNlO1xuICB9O1xuXG4gIHJ1bnRpbWUubWFyayA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIGlmIChPYmplY3Quc2V0UHJvdG90eXBlT2YpIHtcbiAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihnZW5GdW4sIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2VuRnVuLl9fcHJvdG9fXyA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICAgICAgaWYgKCEodG9TdHJpbmdUYWdTeW1ib2wgaW4gZ2VuRnVuKSkge1xuICAgICAgICBnZW5GdW5bdG9TdHJpbmdUYWdTeW1ib2xdID0gXCJHZW5lcmF0b3JGdW5jdGlvblwiO1xuICAgICAgfVxuICAgIH1cbiAgICBnZW5GdW4ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShHcCk7XG4gICAgcmV0dXJuIGdlbkZ1bjtcbiAgfTtcblxuICAvLyBXaXRoaW4gdGhlIGJvZHkgb2YgYW55IGFzeW5jIGZ1bmN0aW9uLCBgYXdhaXQgeGAgaXMgdHJhbnNmb3JtZWQgdG9cbiAgLy8gYHlpZWxkIHJlZ2VuZXJhdG9yUnVudGltZS5hd3JhcCh4KWAsIHNvIHRoYXQgdGhlIHJ1bnRpbWUgY2FuIHRlc3RcbiAgLy8gYGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIilgIHRvIGRldGVybWluZSBpZiB0aGUgeWllbGRlZCB2YWx1ZSBpc1xuICAvLyBtZWFudCB0byBiZSBhd2FpdGVkLlxuICBydW50aW1lLmF3cmFwID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHsgX19hd2FpdDogYXJnIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gQXN5bmNJdGVyYXRvcihnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGdlbmVyYXRvclttZXRob2RdLCBnZW5lcmF0b3IsIGFyZyk7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICByZWplY3QocmVjb3JkLmFyZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmVzdWx0ID0gcmVjb3JkLmFyZztcbiAgICAgICAgdmFyIHZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICBpZiAodmFsdWUgJiZcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKSkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUuX19hd2FpdCkudGhlbihmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgaW52b2tlKFwibmV4dFwiLCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIGludm9rZShcInRocm93XCIsIGVyciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24odW53cmFwcGVkKSB7XG4gICAgICAgICAgLy8gV2hlbiBhIHlpZWxkZWQgUHJvbWlzZSBpcyByZXNvbHZlZCwgaXRzIGZpbmFsIHZhbHVlIGJlY29tZXNcbiAgICAgICAgICAvLyB0aGUgLnZhbHVlIG9mIHRoZSBQcm9taXNlPHt2YWx1ZSxkb25lfT4gcmVzdWx0IGZvciB0aGVcbiAgICAgICAgICAvLyBjdXJyZW50IGl0ZXJhdGlvbi4gSWYgdGhlIFByb21pc2UgaXMgcmVqZWN0ZWQsIGhvd2V2ZXIsIHRoZVxuICAgICAgICAgIC8vIHJlc3VsdCBmb3IgdGhpcyBpdGVyYXRpb24gd2lsbCBiZSByZWplY3RlZCB3aXRoIHRoZSBzYW1lXG4gICAgICAgICAgLy8gcmVhc29uLiBOb3RlIHRoYXQgcmVqZWN0aW9ucyBvZiB5aWVsZGVkIFByb21pc2VzIGFyZSBub3RcbiAgICAgICAgICAvLyB0aHJvd24gYmFjayBpbnRvIHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24sIGFzIGlzIHRoZSBjYXNlXG4gICAgICAgICAgLy8gd2hlbiBhbiBhd2FpdGVkIFByb21pc2UgaXMgcmVqZWN0ZWQuIFRoaXMgZGlmZmVyZW5jZSBpblxuICAgICAgICAgIC8vIGJlaGF2aW9yIGJldHdlZW4geWllbGQgYW5kIGF3YWl0IGlzIGltcG9ydGFudCwgYmVjYXVzZSBpdFxuICAgICAgICAgIC8vIGFsbG93cyB0aGUgY29uc3VtZXIgdG8gZGVjaWRlIHdoYXQgdG8gZG8gd2l0aCB0aGUgeWllbGRlZFxuICAgICAgICAgIC8vIHJlamVjdGlvbiAoc3dhbGxvdyBpdCBhbmQgY29udGludWUsIG1hbnVhbGx5IC50aHJvdyBpdCBiYWNrXG4gICAgICAgICAgLy8gaW50byB0aGUgZ2VuZXJhdG9yLCBhYmFuZG9uIGl0ZXJhdGlvbiwgd2hhdGV2ZXIpLiBXaXRoXG4gICAgICAgICAgLy8gYXdhaXQsIGJ5IGNvbnRyYXN0LCB0aGVyZSBpcyBubyBvcHBvcnR1bml0eSB0byBleGFtaW5lIHRoZVxuICAgICAgICAgIC8vIHJlamVjdGlvbiByZWFzb24gb3V0c2lkZSB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uLCBzbyB0aGVcbiAgICAgICAgICAvLyBvbmx5IG9wdGlvbiBpcyB0byB0aHJvdyBpdCBmcm9tIHRoZSBhd2FpdCBleHByZXNzaW9uLCBhbmRcbiAgICAgICAgICAvLyBsZXQgdGhlIGdlbmVyYXRvciBmdW5jdGlvbiBoYW5kbGUgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICByZXN1bHQudmFsdWUgPSB1bndyYXBwZWQ7XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9LCByZWplY3QpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZ2xvYmFsLnByb2Nlc3MgPT09IFwib2JqZWN0XCIgJiYgZ2xvYmFsLnByb2Nlc3MuZG9tYWluKSB7XG4gICAgICBpbnZva2UgPSBnbG9iYWwucHJvY2Vzcy5kb21haW4uYmluZChpbnZva2UpO1xuICAgIH1cblxuICAgIHZhciBwcmV2aW91c1Byb21pc2U7XG5cbiAgICBmdW5jdGlvbiBlbnF1ZXVlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBmdW5jdGlvbiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcmV2aW91c1Byb21pc2UgPVxuICAgICAgICAvLyBJZiBlbnF1ZXVlIGhhcyBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gd2Ugd2FudCB0byB3YWl0IHVudGlsXG4gICAgICAgIC8vIGFsbCBwcmV2aW91cyBQcm9taXNlcyBoYXZlIGJlZW4gcmVzb2x2ZWQgYmVmb3JlIGNhbGxpbmcgaW52b2tlLFxuICAgICAgICAvLyBzbyB0aGF0IHJlc3VsdHMgYXJlIGFsd2F5cyBkZWxpdmVyZWQgaW4gdGhlIGNvcnJlY3Qgb3JkZXIuIElmXG4gICAgICAgIC8vIGVucXVldWUgaGFzIG5vdCBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gaXQgaXMgaW1wb3J0YW50IHRvXG4gICAgICAgIC8vIGNhbGwgaW52b2tlIGltbWVkaWF0ZWx5LCB3aXRob3V0IHdhaXRpbmcgb24gYSBjYWxsYmFjayB0byBmaXJlLFxuICAgICAgICAvLyBzbyB0aGF0IHRoZSBhc3luYyBnZW5lcmF0b3IgZnVuY3Rpb24gaGFzIHRoZSBvcHBvcnR1bml0eSB0byBkb1xuICAgICAgICAvLyBhbnkgbmVjZXNzYXJ5IHNldHVwIGluIGEgcHJlZGljdGFibGUgd2F5LiBUaGlzIHByZWRpY3RhYmlsaXR5XG4gICAgICAgIC8vIGlzIHdoeSB0aGUgUHJvbWlzZSBjb25zdHJ1Y3RvciBzeW5jaHJvbm91c2x5IGludm9rZXMgaXRzXG4gICAgICAgIC8vIGV4ZWN1dG9yIGNhbGxiYWNrLCBhbmQgd2h5IGFzeW5jIGZ1bmN0aW9ucyBzeW5jaHJvbm91c2x5XG4gICAgICAgIC8vIGV4ZWN1dGUgY29kZSBiZWZvcmUgdGhlIGZpcnN0IGF3YWl0LiBTaW5jZSB3ZSBpbXBsZW1lbnQgc2ltcGxlXG4gICAgICAgIC8vIGFzeW5jIGZ1bmN0aW9ucyBpbiB0ZXJtcyBvZiBhc3luYyBnZW5lcmF0b3JzLCBpdCBpcyBlc3BlY2lhbGx5XG4gICAgICAgIC8vIGltcG9ydGFudCB0byBnZXQgdGhpcyByaWdodCwgZXZlbiB0aG91Z2ggaXQgcmVxdWlyZXMgY2FyZS5cbiAgICAgICAgcHJldmlvdXNQcm9taXNlID8gcHJldmlvdXNQcm9taXNlLnRoZW4oXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcsXG4gICAgICAgICAgLy8gQXZvaWQgcHJvcGFnYXRpbmcgZmFpbHVyZXMgdG8gUHJvbWlzZXMgcmV0dXJuZWQgYnkgbGF0ZXJcbiAgICAgICAgICAvLyBpbnZvY2F0aW9ucyBvZiB0aGUgaXRlcmF0b3IuXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmdcbiAgICAgICAgKSA6IGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCk7XG4gICAgfVxuXG4gICAgLy8gRGVmaW5lIHRoZSB1bmlmaWVkIGhlbHBlciBtZXRob2QgdGhhdCBpcyB1c2VkIHRvIGltcGxlbWVudCAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIChzZWUgZGVmaW5lSXRlcmF0b3JNZXRob2RzKS5cbiAgICB0aGlzLl9pbnZva2UgPSBlbnF1ZXVlO1xuICB9XG5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlKTtcbiAgQXN5bmNJdGVyYXRvci5wcm90b3R5cGVbYXN5bmNJdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIHJ1bnRpbWUuQXN5bmNJdGVyYXRvciA9IEFzeW5jSXRlcmF0b3I7XG5cbiAgLy8gTm90ZSB0aGF0IHNpbXBsZSBhc3luYyBmdW5jdGlvbnMgYXJlIGltcGxlbWVudGVkIG9uIHRvcCBvZlxuICAvLyBBc3luY0l0ZXJhdG9yIG9iamVjdHM7IHRoZXkganVzdCByZXR1cm4gYSBQcm9taXNlIGZvciB0aGUgdmFsdWUgb2ZcbiAgLy8gdGhlIGZpbmFsIHJlc3VsdCBwcm9kdWNlZCBieSB0aGUgaXRlcmF0b3IuXG4gIHJ1bnRpbWUuYXN5bmMgPSBmdW5jdGlvbihpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIHZhciBpdGVyID0gbmV3IEFzeW5jSXRlcmF0b3IoXG4gICAgICB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KVxuICAgICk7XG5cbiAgICByZXR1cm4gcnVudGltZS5pc0dlbmVyYXRvckZ1bmN0aW9uKG91dGVyRm4pXG4gICAgICA/IGl0ZXIgLy8gSWYgb3V0ZXJGbiBpcyBhIGdlbmVyYXRvciwgcmV0dXJuIHRoZSBmdWxsIGl0ZXJhdG9yLlxuICAgICAgOiBpdGVyLm5leHQoKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQuZG9uZSA/IHJlc3VsdC52YWx1ZSA6IGl0ZXIubmV4dCgpO1xuICAgICAgICB9KTtcbiAgfTtcblxuICBmdW5jdGlvbiBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpIHtcbiAgICB2YXIgc3RhdGUgPSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZykge1xuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUV4ZWN1dGluZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBydW5uaW5nXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlQ29tcGxldGVkKSB7XG4gICAgICAgIGlmIChtZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHRocm93IGFyZztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJlIGZvcmdpdmluZywgcGVyIDI1LjMuMy4zLjMgb2YgdGhlIHNwZWM6XG4gICAgICAgIC8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1nZW5lcmF0b3JyZXN1bWVcbiAgICAgICAgcmV0dXJuIGRvbmVSZXN1bHQoKTtcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5tZXRob2QgPSBtZXRob2Q7XG4gICAgICBjb250ZXh0LmFyZyA9IGFyZztcblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIGRlbGVnYXRlID0gY29udGV4dC5kZWxlZ2F0ZTtcbiAgICAgICAgaWYgKGRlbGVnYXRlKSB7XG4gICAgICAgICAgdmFyIGRlbGVnYXRlUmVzdWx0ID0gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG4gICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0KSB7XG4gICAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQgPT09IENvbnRpbnVlU2VudGluZWwpIGNvbnRpbnVlO1xuICAgICAgICAgICAgcmV0dXJuIGRlbGVnYXRlUmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgICAvLyBTZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgICAgIGNvbnRleHQuc2VudCA9IGNvbnRleHQuX3NlbnQgPSBjb250ZXh0LmFyZztcblxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQpIHtcbiAgICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgICB0aHJvdyBjb250ZXh0LmFyZztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKTtcblxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInJldHVyblwiKSB7XG4gICAgICAgICAgY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgY29udGV4dC5hcmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUV4ZWN1dGluZztcblxuICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG4gICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIikge1xuICAgICAgICAgIC8vIElmIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gZnJvbSBpbm5lckZuLCB3ZSBsZWF2ZSBzdGF0ZSA9PT1cbiAgICAgICAgICAvLyBHZW5TdGF0ZUV4ZWN1dGluZyBhbmQgbG9vcCBiYWNrIGZvciBhbm90aGVyIGludm9jYXRpb24uXG4gICAgICAgICAgc3RhdGUgPSBjb250ZXh0LmRvbmVcbiAgICAgICAgICAgID8gR2VuU3RhdGVDb21wbGV0ZWRcbiAgICAgICAgICAgIDogR2VuU3RhdGVTdXNwZW5kZWRZaWVsZDtcblxuICAgICAgICAgIGlmIChyZWNvcmQuYXJnID09PSBDb250aW51ZVNlbnRpbmVsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IHJlY29yZC5hcmcsXG4gICAgICAgICAgICBkb25lOiBjb250ZXh0LmRvbmVcbiAgICAgICAgICB9O1xuXG4gICAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgLy8gRGlzcGF0Y2ggdGhlIGV4Y2VwdGlvbiBieSBsb29waW5nIGJhY2sgYXJvdW5kIHRvIHRoZVxuICAgICAgICAgIC8vIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpIGNhbGwgYWJvdmUuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8vIENhbGwgZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdKGNvbnRleHQuYXJnKSBhbmQgaGFuZGxlIHRoZVxuICAvLyByZXN1bHQsIGVpdGhlciBieSByZXR1cm5pbmcgYSB7IHZhbHVlLCBkb25lIH0gcmVzdWx0IGZyb20gdGhlXG4gIC8vIGRlbGVnYXRlIGl0ZXJhdG9yLCBvciBieSBtb2RpZnlpbmcgY29udGV4dC5tZXRob2QgYW5kIGNvbnRleHQuYXJnLFxuICAvLyBzZXR0aW5nIGNvbnRleHQuZGVsZWdhdGUgdG8gbnVsbCwgYW5kIHJldHVybmluZyB0aGUgQ29udGludWVTZW50aW5lbC5cbiAgZnVuY3Rpb24gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCkge1xuICAgIHZhciBtZXRob2QgPSBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF07XG4gICAgaWYgKG1ldGhvZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBBIC50aHJvdyBvciAucmV0dXJuIHdoZW4gdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBubyAudGhyb3dcbiAgICAgIC8vIG1ldGhvZCBhbHdheXMgdGVybWluYXRlcyB0aGUgeWllbGQqIGxvb3AuXG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgaWYgKGRlbGVnYXRlLml0ZXJhdG9yLnJldHVybikge1xuICAgICAgICAgIC8vIElmIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgYSByZXR1cm4gbWV0aG9kLCBnaXZlIGl0IGFcbiAgICAgICAgICAvLyBjaGFuY2UgdG8gY2xlYW4gdXAuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuXG4gICAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIC8vIElmIG1heWJlSW52b2tlRGVsZWdhdGUoY29udGV4dCkgY2hhbmdlZCBjb250ZXh0Lm1ldGhvZCBmcm9tXG4gICAgICAgICAgICAvLyBcInJldHVyblwiIHRvIFwidGhyb3dcIiwgbGV0IHRoYXQgb3ZlcnJpZGUgdGhlIFR5cGVFcnJvciBiZWxvdy5cbiAgICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgXCJUaGUgaXRlcmF0b3IgZG9lcyBub3QgcHJvdmlkZSBhICd0aHJvdycgbWV0aG9kXCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2gobWV0aG9kLCBkZWxlZ2F0ZS5pdGVyYXRvciwgY29udGV4dC5hcmcpO1xuXG4gICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICB2YXIgaW5mbyA9IHJlY29yZC5hcmc7XG5cbiAgICBpZiAoISBpbmZvKSB7XG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcIml0ZXJhdG9yIHJlc3VsdCBpcyBub3QgYW4gb2JqZWN0XCIpO1xuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICBpZiAoaW5mby5kb25lKSB7XG4gICAgICAvLyBBc3NpZ24gdGhlIHJlc3VsdCBvZiB0aGUgZmluaXNoZWQgZGVsZWdhdGUgdG8gdGhlIHRlbXBvcmFyeVxuICAgICAgLy8gdmFyaWFibGUgc3BlY2lmaWVkIGJ5IGRlbGVnYXRlLnJlc3VsdE5hbWUgKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHRbZGVsZWdhdGUucmVzdWx0TmFtZV0gPSBpbmZvLnZhbHVlO1xuXG4gICAgICAvLyBSZXN1bWUgZXhlY3V0aW9uIGF0IHRoZSBkZXNpcmVkIGxvY2F0aW9uIChzZWUgZGVsZWdhdGVZaWVsZCkuXG4gICAgICBjb250ZXh0Lm5leHQgPSBkZWxlZ2F0ZS5uZXh0TG9jO1xuXG4gICAgICAvLyBJZiBjb250ZXh0Lm1ldGhvZCB3YXMgXCJ0aHJvd1wiIGJ1dCB0aGUgZGVsZWdhdGUgaGFuZGxlZCB0aGVcbiAgICAgIC8vIGV4Y2VwdGlvbiwgbGV0IHRoZSBvdXRlciBnZW5lcmF0b3IgcHJvY2VlZCBub3JtYWxseS4gSWZcbiAgICAgIC8vIGNvbnRleHQubWV0aG9kIHdhcyBcIm5leHRcIiwgZm9yZ2V0IGNvbnRleHQuYXJnIHNpbmNlIGl0IGhhcyBiZWVuXG4gICAgICAvLyBcImNvbnN1bWVkXCIgYnkgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yLiBJZiBjb250ZXh0Lm1ldGhvZCB3YXNcbiAgICAgIC8vIFwicmV0dXJuXCIsIGFsbG93IHRoZSBvcmlnaW5hbCAucmV0dXJuIGNhbGwgdG8gY29udGludWUgaW4gdGhlXG4gICAgICAvLyBvdXRlciBnZW5lcmF0b3IuXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgIT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmUteWllbGQgdGhlIHJlc3VsdCByZXR1cm5lZCBieSB0aGUgZGVsZWdhdGUgbWV0aG9kLlxuICAgICAgcmV0dXJuIGluZm87XG4gICAgfVxuXG4gICAgLy8gVGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGlzIGZpbmlzaGVkLCBzbyBmb3JnZXQgaXQgYW5kIGNvbnRpbnVlIHdpdGhcbiAgICAvLyB0aGUgb3V0ZXIgZ2VuZXJhdG9yLlxuICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICB9XG5cbiAgLy8gRGVmaW5lIEdlbmVyYXRvci5wcm90b3R5cGUue25leHQsdGhyb3cscmV0dXJufSBpbiB0ZXJtcyBvZiB0aGVcbiAgLy8gdW5pZmllZCAuX2ludm9rZSBoZWxwZXIgbWV0aG9kLlxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoR3ApO1xuXG4gIEdwW3RvU3RyaW5nVGFnU3ltYm9sXSA9IFwiR2VuZXJhdG9yXCI7XG5cbiAgLy8gQSBHZW5lcmF0b3Igc2hvdWxkIGFsd2F5cyByZXR1cm4gaXRzZWxmIGFzIHRoZSBpdGVyYXRvciBvYmplY3Qgd2hlbiB0aGVcbiAgLy8gQEBpdGVyYXRvciBmdW5jdGlvbiBpcyBjYWxsZWQgb24gaXQuIFNvbWUgYnJvd3NlcnMnIGltcGxlbWVudGF0aW9ucyBvZiB0aGVcbiAgLy8gaXRlcmF0b3IgcHJvdG90eXBlIGNoYWluIGluY29ycmVjdGx5IGltcGxlbWVudCB0aGlzLCBjYXVzaW5nIHRoZSBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0IHRvIG5vdCBiZSByZXR1cm5lZCBmcm9tIHRoaXMgY2FsbC4gVGhpcyBlbnN1cmVzIHRoYXQgZG9lc24ndCBoYXBwZW4uXG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVnZW5lcmF0b3IvaXNzdWVzLzI3NCBmb3IgbW9yZSBkZXRhaWxzLlxuICBHcFtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBHcC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBcIltvYmplY3QgR2VuZXJhdG9yXVwiO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHB1c2hUcnlFbnRyeShsb2NzKSB7XG4gICAgdmFyIGVudHJ5ID0geyB0cnlMb2M6IGxvY3NbMF0gfTtcblxuICAgIGlmICgxIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmNhdGNoTG9jID0gbG9jc1sxXTtcbiAgICB9XG5cbiAgICBpZiAoMiBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5maW5hbGx5TG9jID0gbG9jc1syXTtcbiAgICAgIGVudHJ5LmFmdGVyTG9jID0gbG9jc1szXTtcbiAgICB9XG5cbiAgICB0aGlzLnRyeUVudHJpZXMucHVzaChlbnRyeSk7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldFRyeUVudHJ5KGVudHJ5KSB7XG4gICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb24gfHwge307XG4gICAgcmVjb3JkLnR5cGUgPSBcIm5vcm1hbFwiO1xuICAgIGRlbGV0ZSByZWNvcmQuYXJnO1xuICAgIGVudHJ5LmNvbXBsZXRpb24gPSByZWNvcmQ7XG4gIH1cblxuICBmdW5jdGlvbiBDb250ZXh0KHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gVGhlIHJvb3QgZW50cnkgb2JqZWN0IChlZmZlY3RpdmVseSBhIHRyeSBzdGF0ZW1lbnQgd2l0aG91dCBhIGNhdGNoXG4gICAgLy8gb3IgYSBmaW5hbGx5IGJsb2NrKSBnaXZlcyB1cyBhIHBsYWNlIHRvIHN0b3JlIHZhbHVlcyB0aHJvd24gZnJvbVxuICAgIC8vIGxvY2F0aW9ucyB3aGVyZSB0aGVyZSBpcyBubyBlbmNsb3NpbmcgdHJ5IHN0YXRlbWVudC5cbiAgICB0aGlzLnRyeUVudHJpZXMgPSBbeyB0cnlMb2M6IFwicm9vdFwiIH1dO1xuICAgIHRyeUxvY3NMaXN0LmZvckVhY2gocHVzaFRyeUVudHJ5LCB0aGlzKTtcbiAgICB0aGlzLnJlc2V0KHRydWUpO1xuICB9XG5cbiAgcnVudGltZS5rZXlzID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICB9XG4gICAga2V5cy5yZXZlcnNlKCk7XG5cbiAgICAvLyBSYXRoZXIgdGhhbiByZXR1cm5pbmcgYW4gb2JqZWN0IHdpdGggYSBuZXh0IG1ldGhvZCwgd2Uga2VlcFxuICAgIC8vIHRoaW5ncyBzaW1wbGUgYW5kIHJldHVybiB0aGUgbmV4dCBmdW5jdGlvbiBpdHNlbGYuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICB3aGlsZSAoa2V5cy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXMucG9wKCk7XG4gICAgICAgIGlmIChrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgbmV4dC52YWx1ZSA9IGtleTtcbiAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUbyBhdm9pZCBjcmVhdGluZyBhbiBhZGRpdGlvbmFsIG9iamVjdCwgd2UganVzdCBoYW5nIHRoZSAudmFsdWVcbiAgICAgIC8vIGFuZCAuZG9uZSBwcm9wZXJ0aWVzIG9mZiB0aGUgbmV4dCBmdW5jdGlvbiBvYmplY3QgaXRzZWxmLiBUaGlzXG4gICAgICAvLyBhbHNvIGVuc3VyZXMgdGhhdCB0aGUgbWluaWZpZXIgd2lsbCBub3QgYW5vbnltaXplIHRoZSBmdW5jdGlvbi5cbiAgICAgIG5leHQuZG9uZSA9IHRydWU7XG4gICAgICByZXR1cm4gbmV4dDtcbiAgICB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIHZhbHVlcyhpdGVyYWJsZSkge1xuICAgIGlmIChpdGVyYWJsZSkge1xuICAgICAgdmFyIGl0ZXJhdG9yTWV0aG9kID0gaXRlcmFibGVbaXRlcmF0b3JTeW1ib2xdO1xuICAgICAgaWYgKGl0ZXJhdG9yTWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRvck1ldGhvZC5jYWxsKGl0ZXJhYmxlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBpdGVyYWJsZS5uZXh0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhYmxlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzTmFOKGl0ZXJhYmxlLmxlbmd0aCkpIHtcbiAgICAgICAgdmFyIGkgPSAtMSwgbmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgd2hpbGUgKCsraSA8IGl0ZXJhYmxlLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGhhc093bi5jYWxsKGl0ZXJhYmxlLCBpKSkge1xuICAgICAgICAgICAgICBuZXh0LnZhbHVlID0gaXRlcmFibGVbaV07XG4gICAgICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuZXh0LnZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG5leHQuZG9uZSA9IHRydWU7XG5cbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gbmV4dC5uZXh0ID0gbmV4dDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gYW4gaXRlcmF0b3Igd2l0aCBubyB2YWx1ZXMuXG4gICAgcmV0dXJuIHsgbmV4dDogZG9uZVJlc3VsdCB9O1xuICB9XG4gIHJ1bnRpbWUudmFsdWVzID0gdmFsdWVzO1xuXG4gIGZ1bmN0aW9uIGRvbmVSZXN1bHQoKSB7XG4gICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICB9XG5cbiAgQ29udGV4dC5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IENvbnRleHQsXG5cbiAgICByZXNldDogZnVuY3Rpb24oc2tpcFRlbXBSZXNldCkge1xuICAgICAgdGhpcy5wcmV2ID0gMDtcbiAgICAgIHRoaXMubmV4dCA9IDA7XG4gICAgICAvLyBSZXNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgIHRoaXMuc2VudCA9IHRoaXMuX3NlbnQgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICB0aGlzLm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHRoaXMudHJ5RW50cmllcy5mb3JFYWNoKHJlc2V0VHJ5RW50cnkpO1xuXG4gICAgICBpZiAoIXNraXBUZW1wUmVzZXQpIHtcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzKSB7XG4gICAgICAgICAgLy8gTm90IHN1cmUgYWJvdXQgdGhlIG9wdGltYWwgb3JkZXIgb2YgdGhlc2UgY29uZGl0aW9uczpcbiAgICAgICAgICBpZiAobmFtZS5jaGFyQXQoMCkgPT09IFwidFwiICYmXG4gICAgICAgICAgICAgIGhhc093bi5jYWxsKHRoaXMsIG5hbWUpICYmXG4gICAgICAgICAgICAgICFpc05hTigrbmFtZS5zbGljZSgxKSkpIHtcbiAgICAgICAgICAgIHRoaXNbbmFtZV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcblxuICAgICAgdmFyIHJvb3RFbnRyeSA9IHRoaXMudHJ5RW50cmllc1swXTtcbiAgICAgIHZhciByb290UmVjb3JkID0gcm9vdEVudHJ5LmNvbXBsZXRpb247XG4gICAgICBpZiAocm9vdFJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcm9vdFJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnJ2YWw7XG4gICAgfSxcblxuICAgIGRpc3BhdGNoRXhjZXB0aW9uOiBmdW5jdGlvbihleGNlcHRpb24pIHtcbiAgICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29udGV4dCA9IHRoaXM7XG4gICAgICBmdW5jdGlvbiBoYW5kbGUobG9jLCBjYXVnaHQpIHtcbiAgICAgICAgcmVjb3JkLnR5cGUgPSBcInRocm93XCI7XG4gICAgICAgIHJlY29yZC5hcmcgPSBleGNlcHRpb247XG4gICAgICAgIGNvbnRleHQubmV4dCA9IGxvYztcblxuICAgICAgICBpZiAoY2F1Z2h0KSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRpc3BhdGNoZWQgZXhjZXB0aW9uIHdhcyBjYXVnaHQgYnkgYSBjYXRjaCBibG9jayxcbiAgICAgICAgICAvLyB0aGVuIGxldCB0aGF0IGNhdGNoIGJsb2NrIGhhbmRsZSB0aGUgZXhjZXB0aW9uIG5vcm1hbGx5LlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gISEgY2F1Z2h0O1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gXCJyb290XCIpIHtcbiAgICAgICAgICAvLyBFeGNlcHRpb24gdGhyb3duIG91dHNpZGUgb2YgYW55IHRyeSBibG9jayB0aGF0IGNvdWxkIGhhbmRsZVxuICAgICAgICAgIC8vIGl0LCBzbyBzZXQgdGhlIGNvbXBsZXRpb24gdmFsdWUgb2YgdGhlIGVudGlyZSBmdW5jdGlvbiB0b1xuICAgICAgICAgIC8vIHRocm93IHRoZSBleGNlcHRpb24uXG4gICAgICAgICAgcmV0dXJuIGhhbmRsZShcImVuZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2KSB7XG4gICAgICAgICAgdmFyIGhhc0NhdGNoID0gaGFzT3duLmNhbGwoZW50cnksIFwiY2F0Y2hMb2NcIik7XG4gICAgICAgICAgdmFyIGhhc0ZpbmFsbHkgPSBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpO1xuXG4gICAgICAgICAgaWYgKGhhc0NhdGNoICYmIGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNDYXRjaCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRyeSBzdGF0ZW1lbnQgd2l0aG91dCBjYXRjaCBvciBmaW5hbGx5XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBhYnJ1cHQ6IGZ1bmN0aW9uKHR5cGUsIGFyZykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2ICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpICYmXG4gICAgICAgICAgICB0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgdmFyIGZpbmFsbHlFbnRyeSA9IGVudHJ5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkgJiZcbiAgICAgICAgICAodHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgIHR5cGUgPT09IFwiY29udGludWVcIikgJiZcbiAgICAgICAgICBmaW5hbGx5RW50cnkudHJ5TG9jIDw9IGFyZyAmJlxuICAgICAgICAgIGFyZyA8PSBmaW5hbGx5RW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAvLyBJZ25vcmUgdGhlIGZpbmFsbHkgZW50cnkgaWYgY29udHJvbCBpcyBub3QganVtcGluZyB0byBhXG4gICAgICAgIC8vIGxvY2F0aW9uIG91dHNpZGUgdGhlIHRyeS9jYXRjaCBibG9jay5cbiAgICAgICAgZmluYWxseUVudHJ5ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlY29yZCA9IGZpbmFsbHlFbnRyeSA/IGZpbmFsbHlFbnRyeS5jb21wbGV0aW9uIDoge307XG4gICAgICByZWNvcmQudHlwZSA9IHR5cGU7XG4gICAgICByZWNvcmQuYXJnID0gYXJnO1xuXG4gICAgICBpZiAoZmluYWxseUVudHJ5KSB7XG4gICAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgIHRoaXMubmV4dCA9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jO1xuICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuY29tcGxldGUocmVjb3JkKTtcbiAgICB9LFxuXG4gICAgY29tcGxldGU6IGZ1bmN0aW9uKHJlY29yZCwgYWZ0ZXJMb2MpIHtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgcmVjb3JkLnR5cGUgPT09IFwiY29udGludWVcIikge1xuICAgICAgICB0aGlzLm5leHQgPSByZWNvcmQuYXJnO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICB0aGlzLnJ2YWwgPSB0aGlzLmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIHRoaXMubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gXCJlbmRcIjtcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIgJiYgYWZ0ZXJMb2MpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gYWZ0ZXJMb2M7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH0sXG5cbiAgICBmaW5pc2g6IGZ1bmN0aW9uKGZpbmFsbHlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkuZmluYWxseUxvYyA9PT0gZmluYWxseUxvYykge1xuICAgICAgICAgIHRoaXMuY29tcGxldGUoZW50cnkuY29tcGxldGlvbiwgZW50cnkuYWZ0ZXJMb2MpO1xuICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIFwiY2F0Y2hcIjogZnVuY3Rpb24odHJ5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gdHJ5TG9jKSB7XG4gICAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG4gICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIHZhciB0aHJvd24gPSByZWNvcmQuYXJnO1xuICAgICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aHJvd247XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVGhlIGNvbnRleHQuY2F0Y2ggbWV0aG9kIG11c3Qgb25seSBiZSBjYWxsZWQgd2l0aCBhIGxvY2F0aW9uXG4gICAgICAvLyBhcmd1bWVudCB0aGF0IGNvcnJlc3BvbmRzIHRvIGEga25vd24gY2F0Y2ggYmxvY2suXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIGNhdGNoIGF0dGVtcHRcIik7XG4gICAgfSxcblxuICAgIGRlbGVnYXRlWWllbGQ6IGZ1bmN0aW9uKGl0ZXJhYmxlLCByZXN1bHROYW1lLCBuZXh0TG9jKSB7XG4gICAgICB0aGlzLmRlbGVnYXRlID0ge1xuICAgICAgICBpdGVyYXRvcjogdmFsdWVzKGl0ZXJhYmxlKSxcbiAgICAgICAgcmVzdWx0TmFtZTogcmVzdWx0TmFtZSxcbiAgICAgICAgbmV4dExvYzogbmV4dExvY1xuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAvLyBEZWxpYmVyYXRlbHkgZm9yZ2V0IHRoZSBsYXN0IHNlbnQgdmFsdWUgc28gdGhhdCB3ZSBkb24ndFxuICAgICAgICAvLyBhY2NpZGVudGFsbHkgcGFzcyBpdCBvbiB0byB0aGUgZGVsZWdhdGUuXG4gICAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG4gIH07XG59KShcbiAgLy8gQW1vbmcgdGhlIHZhcmlvdXMgdHJpY2tzIGZvciBvYnRhaW5pbmcgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbFxuICAvLyBvYmplY3QsIHRoaXMgc2VlbXMgdG8gYmUgdGhlIG1vc3QgcmVsaWFibGUgdGVjaG5pcXVlIHRoYXQgZG9lcyBub3RcbiAgLy8gdXNlIGluZGlyZWN0IGV2YWwgKHdoaWNoIHZpb2xhdGVzIENvbnRlbnQgU2VjdXJpdHkgUG9saWN5KS5cbiAgdHlwZW9mIGdsb2JhbCA9PT0gXCJvYmplY3RcIiA/IGdsb2JhbCA6XG4gIHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIgPyB3aW5kb3cgOlxuICB0eXBlb2Ygc2VsZiA9PT0gXCJvYmplY3RcIiA/IHNlbGYgOiB0aGlzXG4pO1xuIiwiIiwiLyohXG4gKiBDcm9zcy1Ccm93c2VyIFNwbGl0IDEuMS4xXG4gKiBDb3B5cmlnaHQgMjAwNy0yMDEyIFN0ZXZlbiBMZXZpdGhhbiA8c3RldmVubGV2aXRoYW4uY29tPlxuICogQXZhaWxhYmxlIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICogRUNNQVNjcmlwdCBjb21wbGlhbnQsIHVuaWZvcm0gY3Jvc3MtYnJvd3NlciBzcGxpdCBtZXRob2RcbiAqL1xuXG4vKipcbiAqIFNwbGl0cyBhIHN0cmluZyBpbnRvIGFuIGFycmF5IG9mIHN0cmluZ3MgdXNpbmcgYSByZWdleCBvciBzdHJpbmcgc2VwYXJhdG9yLiBNYXRjaGVzIG9mIHRoZVxuICogc2VwYXJhdG9yIGFyZSBub3QgaW5jbHVkZWQgaW4gdGhlIHJlc3VsdCBhcnJheS4gSG93ZXZlciwgaWYgYHNlcGFyYXRvcmAgaXMgYSByZWdleCB0aGF0IGNvbnRhaW5zXG4gKiBjYXB0dXJpbmcgZ3JvdXBzLCBiYWNrcmVmZXJlbmNlcyBhcmUgc3BsaWNlZCBpbnRvIHRoZSByZXN1bHQgZWFjaCB0aW1lIGBzZXBhcmF0b3JgIGlzIG1hdGNoZWQuXG4gKiBGaXhlcyBicm93c2VyIGJ1Z3MgY29tcGFyZWQgdG8gdGhlIG5hdGl2ZSBgU3RyaW5nLnByb3RvdHlwZS5zcGxpdGAgYW5kIGNhbiBiZSB1c2VkIHJlbGlhYmx5XG4gKiBjcm9zcy1icm93c2VyLlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBTdHJpbmcgdG8gc3BsaXQuXG4gKiBAcGFyYW0ge1JlZ0V4cHxTdHJpbmd9IHNlcGFyYXRvciBSZWdleCBvciBzdHJpbmcgdG8gdXNlIGZvciBzZXBhcmF0aW5nIHRoZSBzdHJpbmcuXG4gKiBAcGFyYW0ge051bWJlcn0gW2xpbWl0XSBNYXhpbXVtIG51bWJlciBvZiBpdGVtcyB0byBpbmNsdWRlIGluIHRoZSByZXN1bHQgYXJyYXkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IEFycmF5IG9mIHN1YnN0cmluZ3MuXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIEJhc2ljIHVzZVxuICogc3BsaXQoJ2EgYiBjIGQnLCAnICcpO1xuICogLy8gLT4gWydhJywgJ2InLCAnYycsICdkJ11cbiAqXG4gKiAvLyBXaXRoIGxpbWl0XG4gKiBzcGxpdCgnYSBiIGMgZCcsICcgJywgMik7XG4gKiAvLyAtPiBbJ2EnLCAnYiddXG4gKlxuICogLy8gQmFja3JlZmVyZW5jZXMgaW4gcmVzdWx0IGFycmF5XG4gKiBzcGxpdCgnLi53b3JkMSB3b3JkMi4uJywgLyhbYS16XSspKFxcZCspL2kpO1xuICogLy8gLT4gWycuLicsICd3b3JkJywgJzEnLCAnICcsICd3b3JkJywgJzInLCAnLi4nXVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbiBzcGxpdCh1bmRlZikge1xuXG4gIHZhciBuYXRpdmVTcGxpdCA9IFN0cmluZy5wcm90b3R5cGUuc3BsaXQsXG4gICAgY29tcGxpYW50RXhlY05wY2cgPSAvKCk/Py8uZXhlYyhcIlwiKVsxXSA9PT0gdW5kZWYsXG4gICAgLy8gTlBDRzogbm9ucGFydGljaXBhdGluZyBjYXB0dXJpbmcgZ3JvdXBcbiAgICBzZWxmO1xuXG4gIHNlbGYgPSBmdW5jdGlvbihzdHIsIHNlcGFyYXRvciwgbGltaXQpIHtcbiAgICAvLyBJZiBgc2VwYXJhdG9yYCBpcyBub3QgYSByZWdleCwgdXNlIGBuYXRpdmVTcGxpdGBcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHNlcGFyYXRvcikgIT09IFwiW29iamVjdCBSZWdFeHBdXCIpIHtcbiAgICAgIHJldHVybiBuYXRpdmVTcGxpdC5jYWxsKHN0ciwgc2VwYXJhdG9yLCBsaW1pdCk7XG4gICAgfVxuICAgIHZhciBvdXRwdXQgPSBbXSxcbiAgICAgIGZsYWdzID0gKHNlcGFyYXRvci5pZ25vcmVDYXNlID8gXCJpXCIgOiBcIlwiKSArIChzZXBhcmF0b3IubXVsdGlsaW5lID8gXCJtXCIgOiBcIlwiKSArIChzZXBhcmF0b3IuZXh0ZW5kZWQgPyBcInhcIiA6IFwiXCIpICsgLy8gUHJvcG9zZWQgZm9yIEVTNlxuICAgICAgKHNlcGFyYXRvci5zdGlja3kgPyBcInlcIiA6IFwiXCIpLFxuICAgICAgLy8gRmlyZWZveCAzK1xuICAgICAgbGFzdExhc3RJbmRleCA9IDAsXG4gICAgICAvLyBNYWtlIGBnbG9iYWxgIGFuZCBhdm9pZCBgbGFzdEluZGV4YCBpc3N1ZXMgYnkgd29ya2luZyB3aXRoIGEgY29weVxuICAgICAgc2VwYXJhdG9yID0gbmV3IFJlZ0V4cChzZXBhcmF0b3Iuc291cmNlLCBmbGFncyArIFwiZ1wiKSxcbiAgICAgIHNlcGFyYXRvcjIsIG1hdGNoLCBsYXN0SW5kZXgsIGxhc3RMZW5ndGg7XG4gICAgc3RyICs9IFwiXCI7IC8vIFR5cGUtY29udmVydFxuICAgIGlmICghY29tcGxpYW50RXhlY05wY2cpIHtcbiAgICAgIC8vIERvZXNuJ3QgbmVlZCBmbGFncyBneSwgYnV0IHRoZXkgZG9uJ3QgaHVydFxuICAgICAgc2VwYXJhdG9yMiA9IG5ldyBSZWdFeHAoXCJeXCIgKyBzZXBhcmF0b3Iuc291cmNlICsgXCIkKD8hXFxcXHMpXCIsIGZsYWdzKTtcbiAgICB9XG4gICAgLyogVmFsdWVzIGZvciBgbGltaXRgLCBwZXIgdGhlIHNwZWM6XG4gICAgICogSWYgdW5kZWZpbmVkOiA0Mjk0OTY3Mjk1IC8vIE1hdGgucG93KDIsIDMyKSAtIDFcbiAgICAgKiBJZiAwLCBJbmZpbml0eSwgb3IgTmFOOiAwXG4gICAgICogSWYgcG9zaXRpdmUgbnVtYmVyOiBsaW1pdCA9IE1hdGguZmxvb3IobGltaXQpOyBpZiAobGltaXQgPiA0Mjk0OTY3Mjk1KSBsaW1pdCAtPSA0Mjk0OTY3Mjk2O1xuICAgICAqIElmIG5lZ2F0aXZlIG51bWJlcjogNDI5NDk2NzI5NiAtIE1hdGguZmxvb3IoTWF0aC5hYnMobGltaXQpKVxuICAgICAqIElmIG90aGVyOiBUeXBlLWNvbnZlcnQsIHRoZW4gdXNlIHRoZSBhYm92ZSBydWxlc1xuICAgICAqL1xuICAgIGxpbWl0ID0gbGltaXQgPT09IHVuZGVmID8gLTEgPj4+IDAgOiAvLyBNYXRoLnBvdygyLCAzMikgLSAxXG4gICAgbGltaXQgPj4+IDA7IC8vIFRvVWludDMyKGxpbWl0KVxuICAgIHdoaWxlIChtYXRjaCA9IHNlcGFyYXRvci5leGVjKHN0cikpIHtcbiAgICAgIC8vIGBzZXBhcmF0b3IubGFzdEluZGV4YCBpcyBub3QgcmVsaWFibGUgY3Jvc3MtYnJvd3NlclxuICAgICAgbGFzdEluZGV4ID0gbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGg7XG4gICAgICBpZiAobGFzdEluZGV4ID4gbGFzdExhc3RJbmRleCkge1xuICAgICAgICBvdXRwdXQucHVzaChzdHIuc2xpY2UobGFzdExhc3RJbmRleCwgbWF0Y2guaW5kZXgpKTtcbiAgICAgICAgLy8gRml4IGJyb3dzZXJzIHdob3NlIGBleGVjYCBtZXRob2RzIGRvbid0IGNvbnNpc3RlbnRseSByZXR1cm4gYHVuZGVmaW5lZGAgZm9yXG4gICAgICAgIC8vIG5vbnBhcnRpY2lwYXRpbmcgY2FwdHVyaW5nIGdyb3Vwc1xuICAgICAgICBpZiAoIWNvbXBsaWFudEV4ZWNOcGNnICYmIG1hdGNoLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICBtYXRjaFswXS5yZXBsYWNlKHNlcGFyYXRvcjIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoIC0gMjsgaSsrKSB7XG4gICAgICAgICAgICAgIGlmIChhcmd1bWVudHNbaV0gPT09IHVuZGVmKSB7XG4gICAgICAgICAgICAgICAgbWF0Y2hbaV0gPSB1bmRlZjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXRjaC5sZW5ndGggPiAxICYmIG1hdGNoLmluZGV4IDwgc3RyLmxlbmd0aCkge1xuICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KG91dHB1dCwgbWF0Y2guc2xpY2UoMSkpO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RMZW5ndGggPSBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgIGxhc3RMYXN0SW5kZXggPSBsYXN0SW5kZXg7XG4gICAgICAgIGlmIChvdXRwdXQubGVuZ3RoID49IGxpbWl0KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzZXBhcmF0b3IubGFzdEluZGV4ID09PSBtYXRjaC5pbmRleCkge1xuICAgICAgICBzZXBhcmF0b3IubGFzdEluZGV4Kys7IC8vIEF2b2lkIGFuIGluZmluaXRlIGxvb3BcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGxhc3RMYXN0SW5kZXggPT09IHN0ci5sZW5ndGgpIHtcbiAgICAgIGlmIChsYXN0TGVuZ3RoIHx8ICFzZXBhcmF0b3IudGVzdChcIlwiKSkge1xuICAgICAgICBvdXRwdXQucHVzaChcIlwiKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0LnB1c2goc3RyLnNsaWNlKGxhc3RMYXN0SW5kZXgpKTtcbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dC5sZW5ndGggPiBsaW1pdCA/IG91dHB1dC5zbGljZSgwLCBsaW1pdCkgOiBvdXRwdXQ7XG4gIH07XG5cbiAgcmV0dXJuIHNlbGY7XG59KSgpO1xuIiwiLy8gY29udGFpbnMsIGFkZCwgcmVtb3ZlLCB0b2dnbGVcbnZhciBpbmRleG9mID0gcmVxdWlyZSgnaW5kZXhvZicpXG5cbm1vZHVsZS5leHBvcnRzID0gQ2xhc3NMaXN0XG5cbmZ1bmN0aW9uIENsYXNzTGlzdChlbGVtKSB7XG4gICAgdmFyIGNsID0gZWxlbS5jbGFzc0xpc3RcblxuICAgIGlmIChjbCkge1xuICAgICAgICByZXR1cm4gY2xcbiAgICB9XG5cbiAgICB2YXIgY2xhc3NMaXN0ID0ge1xuICAgICAgICBhZGQ6IGFkZFxuICAgICAgICAsIHJlbW92ZTogcmVtb3ZlXG4gICAgICAgICwgY29udGFpbnM6IGNvbnRhaW5zXG4gICAgICAgICwgdG9nZ2xlOiB0b2dnbGVcbiAgICAgICAgLCB0b1N0cmluZzogJHRvU3RyaW5nXG4gICAgICAgICwgbGVuZ3RoOiAwXG4gICAgICAgICwgaXRlbTogaXRlbVxuICAgIH1cblxuICAgIHJldHVybiBjbGFzc0xpc3RcblxuICAgIGZ1bmN0aW9uIGFkZCh0b2tlbikge1xuICAgICAgICB2YXIgbGlzdCA9IGdldFRva2VucygpXG4gICAgICAgIGlmIChpbmRleG9mKGxpc3QsIHRva2VuKSA+IC0xKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBsaXN0LnB1c2godG9rZW4pXG4gICAgICAgIHNldFRva2VucyhsaXN0KVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbW92ZSh0b2tlbikge1xuICAgICAgICB2YXIgbGlzdCA9IGdldFRva2VucygpXG4gICAgICAgICAgICAsIGluZGV4ID0gaW5kZXhvZihsaXN0LCB0b2tlbilcblxuICAgICAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGxpc3Quc3BsaWNlKGluZGV4LCAxKVxuICAgICAgICBzZXRUb2tlbnMobGlzdClcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb250YWlucyh0b2tlbikge1xuICAgICAgICByZXR1cm4gaW5kZXhvZihnZXRUb2tlbnMoKSwgdG9rZW4pID4gLTFcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b2dnbGUodG9rZW4pIHtcbiAgICAgICAgaWYgKGNvbnRhaW5zKHRva2VuKSkge1xuICAgICAgICAgICAgcmVtb3ZlKHRva2VuKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhZGQodG9rZW4pXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gJHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gZWxlbS5jbGFzc05hbWVcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpdGVtKGluZGV4KSB7XG4gICAgICAgIHZhciB0b2tlbnMgPSBnZXRUb2tlbnMoKVxuICAgICAgICByZXR1cm4gdG9rZW5zW2luZGV4XSB8fCBudWxsXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0VG9rZW5zKCkge1xuICAgICAgICB2YXIgY2xhc3NOYW1lID0gZWxlbS5jbGFzc05hbWVcblxuICAgICAgICByZXR1cm4gZmlsdGVyKGNsYXNzTmFtZS5zcGxpdChcIiBcIiksIGlzVHJ1dGh5KVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldFRva2VucyhsaXN0KSB7XG4gICAgICAgIHZhciBsZW5ndGggPSBsaXN0Lmxlbmd0aFxuXG4gICAgICAgIGVsZW0uY2xhc3NOYW1lID0gbGlzdC5qb2luKFwiIFwiKVxuICAgICAgICBjbGFzc0xpc3QubGVuZ3RoID0gbGVuZ3RoXG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjbGFzc0xpc3RbaV0gPSBsaXN0W2ldXG4gICAgICAgIH1cblxuICAgICAgICBkZWxldGUgbGlzdFtsZW5ndGhdXG4gICAgfVxufVxuXG5mdW5jdGlvbiBmaWx0ZXIgKGFyciwgZm4pIHtcbiAgICB2YXIgcmV0ID0gW11cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoZm4oYXJyW2ldKSkgcmV0LnB1c2goYXJyW2ldKVxuICAgIH1cbiAgICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGlzVHJ1dGh5KHZhbHVlKSB7XG4gICAgcmV0dXJuICEhdmFsdWVcbn1cbiIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvY29yZS5yZWdleHAuZXNjYXBlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5SZWdFeHAuZXNjYXBlO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKHR5cGVvZiBpdCAhPSAnZnVuY3Rpb24nKSB0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhIGZ1bmN0aW9uIScpO1xuICByZXR1cm4gaXQ7XG59O1xuIiwidmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIG1zZykge1xuICBpZiAodHlwZW9mIGl0ICE9ICdudW1iZXInICYmIGNvZihpdCkgIT0gJ051bWJlcicpIHRocm93IFR5cGVFcnJvcihtc2cpO1xuICByZXR1cm4gK2l0O1xufTtcbiIsIi8vIDIyLjEuMy4zMSBBcnJheS5wcm90b3R5cGVbQEB1bnNjb3BhYmxlc11cbnZhciBVTlNDT1BBQkxFUyA9IHJlcXVpcmUoJy4vX3drcycpKCd1bnNjb3BhYmxlcycpO1xudmFyIEFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5pZiAoQXJyYXlQcm90b1tVTlNDT1BBQkxFU10gPT0gdW5kZWZpbmVkKSByZXF1aXJlKCcuL19oaWRlJykoQXJyYXlQcm90bywgVU5TQ09QQUJMRVMsIHt9KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICBBcnJheVByb3RvW1VOU0NPUEFCTEVTXVtrZXldID0gdHJ1ZTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgQ29uc3RydWN0b3IsIG5hbWUsIGZvcmJpZGRlbkZpZWxkKSB7XG4gIGlmICghKGl0IGluc3RhbmNlb2YgQ29uc3RydWN0b3IpIHx8IChmb3JiaWRkZW5GaWVsZCAhPT0gdW5kZWZpbmVkICYmIGZvcmJpZGRlbkZpZWxkIGluIGl0KSkge1xuICAgIHRocm93IFR5cGVFcnJvcihuYW1lICsgJzogaW5jb3JyZWN0IGludm9jYXRpb24hJyk7XG4gIH0gcmV0dXJuIGl0O1xufTtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKCFpc09iamVjdChpdCkpIHRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGFuIG9iamVjdCEnKTtcbiAgcmV0dXJuIGl0O1xufTtcbiIsIi8vIDIyLjEuMy4zIEFycmF5LnByb3RvdHlwZS5jb3B5V2l0aGluKHRhcmdldCwgc3RhcnQsIGVuZCA9IHRoaXMubGVuZ3RoKVxuJ3VzZSBzdHJpY3QnO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gcmVxdWlyZSgnLi9fdG8tYWJzb2x1dGUtaW5kZXgnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFtdLmNvcHlXaXRoaW4gfHwgZnVuY3Rpb24gY29weVdpdGhpbih0YXJnZXQgLyogPSAwICovLCBzdGFydCAvKiA9IDAsIGVuZCA9IEBsZW5ndGggKi8pIHtcbiAgdmFyIE8gPSB0b09iamVjdCh0aGlzKTtcbiAgdmFyIGxlbiA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgdmFyIHRvID0gdG9BYnNvbHV0ZUluZGV4KHRhcmdldCwgbGVuKTtcbiAgdmFyIGZyb20gPSB0b0Fic29sdXRlSW5kZXgoc3RhcnQsIGxlbik7XG4gIHZhciBlbmQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZDtcbiAgdmFyIGNvdW50ID0gTWF0aC5taW4oKGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogdG9BYnNvbHV0ZUluZGV4KGVuZCwgbGVuKSkgLSBmcm9tLCBsZW4gLSB0byk7XG4gIHZhciBpbmMgPSAxO1xuICBpZiAoZnJvbSA8IHRvICYmIHRvIDwgZnJvbSArIGNvdW50KSB7XG4gICAgaW5jID0gLTE7XG4gICAgZnJvbSArPSBjb3VudCAtIDE7XG4gICAgdG8gKz0gY291bnQgLSAxO1xuICB9XG4gIHdoaWxlIChjb3VudC0tID4gMCkge1xuICAgIGlmIChmcm9tIGluIE8pIE9bdG9dID0gT1tmcm9tXTtcbiAgICBlbHNlIGRlbGV0ZSBPW3RvXTtcbiAgICB0byArPSBpbmM7XG4gICAgZnJvbSArPSBpbmM7XG4gIH0gcmV0dXJuIE87XG59O1xuIiwiLy8gMjIuMS4zLjYgQXJyYXkucHJvdG90eXBlLmZpbGwodmFsdWUsIHN0YXJ0ID0gMCwgZW5kID0gdGhpcy5sZW5ndGgpXG4ndXNlIHN0cmljdCc7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciB0b0Fic29sdXRlSW5kZXggPSByZXF1aXJlKCcuL190by1hYnNvbHV0ZS1pbmRleCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGZpbGwodmFsdWUgLyogLCBzdGFydCA9IDAsIGVuZCA9IEBsZW5ndGggKi8pIHtcbiAgdmFyIE8gPSB0b09iamVjdCh0aGlzKTtcbiAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgdmFyIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgaW5kZXggPSB0b0Fic29sdXRlSW5kZXgoYUxlbiA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQsIGxlbmd0aCk7XG4gIHZhciBlbmQgPSBhTGVuID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZDtcbiAgdmFyIGVuZFBvcyA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogdG9BYnNvbHV0ZUluZGV4KGVuZCwgbGVuZ3RoKTtcbiAgd2hpbGUgKGVuZFBvcyA+IGluZGV4KSBPW2luZGV4KytdID0gdmFsdWU7XG4gIHJldHVybiBPO1xufTtcbiIsInZhciBmb3JPZiA9IHJlcXVpcmUoJy4vX2Zvci1vZicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdGVyLCBJVEVSQVRPUikge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvck9mKGl0ZXIsIGZhbHNlLCByZXN1bHQucHVzaCwgcmVzdWx0LCBJVEVSQVRPUik7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuIiwiLy8gZmFsc2UgLT4gQXJyYXkjaW5kZXhPZlxuLy8gdHJ1ZSAgLT4gQXJyYXkjaW5jbHVkZXNcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciB0b0Fic29sdXRlSW5kZXggPSByZXF1aXJlKCcuL190by1hYnNvbHV0ZS1pbmRleCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoSVNfSU5DTFVERVMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgkdGhpcywgZWwsIGZyb21JbmRleCkge1xuICAgIHZhciBPID0gdG9JT2JqZWN0KCR0aGlzKTtcbiAgICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICAgIHZhciBpbmRleCA9IHRvQWJzb2x1dGVJbmRleChmcm9tSW5kZXgsIGxlbmd0aCk7XG4gICAgdmFyIHZhbHVlO1xuICAgIC8vIEFycmF5I2luY2x1ZGVzIHVzZXMgU2FtZVZhbHVlWmVybyBlcXVhbGl0eSBhbGdvcml0aG1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgaWYgKElTX0lOQ0xVREVTICYmIGVsICE9IGVsKSB3aGlsZSAobGVuZ3RoID4gaW5kZXgpIHtcbiAgICAgIHZhbHVlID0gT1tpbmRleCsrXTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICAgIGlmICh2YWx1ZSAhPSB2YWx1ZSkgcmV0dXJuIHRydWU7XG4gICAgLy8gQXJyYXkjaW5kZXhPZiBpZ25vcmVzIGhvbGVzLCBBcnJheSNpbmNsdWRlcyAtIG5vdFxuICAgIH0gZWxzZSBmb3IgKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKykgaWYgKElTX0lOQ0xVREVTIHx8IGluZGV4IGluIE8pIHtcbiAgICAgIGlmIChPW2luZGV4XSA9PT0gZWwpIHJldHVybiBJU19JTkNMVURFUyB8fCBpbmRleCB8fCAwO1xuICAgIH0gcmV0dXJuICFJU19JTkNMVURFUyAmJiAtMTtcbiAgfTtcbn07XG4iLCIvLyAwIC0+IEFycmF5I2ZvckVhY2hcbi8vIDEgLT4gQXJyYXkjbWFwXG4vLyAyIC0+IEFycmF5I2ZpbHRlclxuLy8gMyAtPiBBcnJheSNzb21lXG4vLyA0IC0+IEFycmF5I2V2ZXJ5XG4vLyA1IC0+IEFycmF5I2ZpbmRcbi8vIDYgLT4gQXJyYXkjZmluZEluZGV4XG52YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG52YXIgSU9iamVjdCA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgYXNjID0gcmVxdWlyZSgnLi9fYXJyYXktc3BlY2llcy1jcmVhdGUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFRZUEUsICRjcmVhdGUpIHtcbiAgdmFyIElTX01BUCA9IFRZUEUgPT0gMTtcbiAgdmFyIElTX0ZJTFRFUiA9IFRZUEUgPT0gMjtcbiAgdmFyIElTX1NPTUUgPSBUWVBFID09IDM7XG4gIHZhciBJU19FVkVSWSA9IFRZUEUgPT0gNDtcbiAgdmFyIElTX0ZJTkRfSU5ERVggPSBUWVBFID09IDY7XG4gIHZhciBOT19IT0xFUyA9IFRZUEUgPT0gNSB8fCBJU19GSU5EX0lOREVYO1xuICB2YXIgY3JlYXRlID0gJGNyZWF0ZSB8fCBhc2M7XG4gIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIGNhbGxiYWNrZm4sIHRoYXQpIHtcbiAgICB2YXIgTyA9IHRvT2JqZWN0KCR0aGlzKTtcbiAgICB2YXIgc2VsZiA9IElPYmplY3QoTyk7XG4gICAgdmFyIGYgPSBjdHgoY2FsbGJhY2tmbiwgdGhhdCwgMyk7XG4gICAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKHNlbGYubGVuZ3RoKTtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciByZXN1bHQgPSBJU19NQVAgPyBjcmVhdGUoJHRoaXMsIGxlbmd0aCkgOiBJU19GSUxURVIgPyBjcmVhdGUoJHRoaXMsIDApIDogdW5kZWZpbmVkO1xuICAgIHZhciB2YWwsIHJlcztcbiAgICBmb3IgKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKykgaWYgKE5PX0hPTEVTIHx8IGluZGV4IGluIHNlbGYpIHtcbiAgICAgIHZhbCA9IHNlbGZbaW5kZXhdO1xuICAgICAgcmVzID0gZih2YWwsIGluZGV4LCBPKTtcbiAgICAgIGlmIChUWVBFKSB7XG4gICAgICAgIGlmIChJU19NQVApIHJlc3VsdFtpbmRleF0gPSByZXM7ICAgLy8gbWFwXG4gICAgICAgIGVsc2UgaWYgKHJlcykgc3dpdGNoIChUWVBFKSB7XG4gICAgICAgICAgY2FzZSAzOiByZXR1cm4gdHJ1ZTsgICAgICAgICAgICAgLy8gc29tZVxuICAgICAgICAgIGNhc2UgNTogcmV0dXJuIHZhbDsgICAgICAgICAgICAgIC8vIGZpbmRcbiAgICAgICAgICBjYXNlIDY6IHJldHVybiBpbmRleDsgICAgICAgICAgICAvLyBmaW5kSW5kZXhcbiAgICAgICAgICBjYXNlIDI6IHJlc3VsdC5wdXNoKHZhbCk7ICAgICAgICAvLyBmaWx0ZXJcbiAgICAgICAgfSBlbHNlIGlmIChJU19FVkVSWSkgcmV0dXJuIGZhbHNlOyAvLyBldmVyeVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gSVNfRklORF9JTkRFWCA/IC0xIDogSVNfU09NRSB8fCBJU19FVkVSWSA/IElTX0VWRVJZIDogcmVzdWx0O1xuICB9O1xufTtcbiIsInZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciBJT2JqZWN0ID0gcmVxdWlyZSgnLi9faW9iamVjdCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHRoYXQsIGNhbGxiYWNrZm4sIGFMZW4sIG1lbW8sIGlzUmlnaHQpIHtcbiAgYUZ1bmN0aW9uKGNhbGxiYWNrZm4pO1xuICB2YXIgTyA9IHRvT2JqZWN0KHRoYXQpO1xuICB2YXIgc2VsZiA9IElPYmplY3QoTyk7XG4gIHZhciBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gIHZhciBpbmRleCA9IGlzUmlnaHQgPyBsZW5ndGggLSAxIDogMDtcbiAgdmFyIGkgPSBpc1JpZ2h0ID8gLTEgOiAxO1xuICBpZiAoYUxlbiA8IDIpIGZvciAoOzspIHtcbiAgICBpZiAoaW5kZXggaW4gc2VsZikge1xuICAgICAgbWVtbyA9IHNlbGZbaW5kZXhdO1xuICAgICAgaW5kZXggKz0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpbmRleCArPSBpO1xuICAgIGlmIChpc1JpZ2h0ID8gaW5kZXggPCAwIDogbGVuZ3RoIDw9IGluZGV4KSB7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ1JlZHVjZSBvZiBlbXB0eSBhcnJheSB3aXRoIG5vIGluaXRpYWwgdmFsdWUnKTtcbiAgICB9XG4gIH1cbiAgZm9yICg7aXNSaWdodCA/IGluZGV4ID49IDAgOiBsZW5ndGggPiBpbmRleDsgaW5kZXggKz0gaSkgaWYgKGluZGV4IGluIHNlbGYpIHtcbiAgICBtZW1vID0gY2FsbGJhY2tmbihtZW1vLCBzZWxmW2luZGV4XSwgaW5kZXgsIE8pO1xuICB9XG4gIHJldHVybiBtZW1vO1xufTtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuL19pcy1hcnJheScpO1xudmFyIFNQRUNJRVMgPSByZXF1aXJlKCcuL193a3MnKSgnc3BlY2llcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvcmlnaW5hbCkge1xuICB2YXIgQztcbiAgaWYgKGlzQXJyYXkob3JpZ2luYWwpKSB7XG4gICAgQyA9IG9yaWdpbmFsLmNvbnN0cnVjdG9yO1xuICAgIC8vIGNyb3NzLXJlYWxtIGZhbGxiYWNrXG4gICAgaWYgKHR5cGVvZiBDID09ICdmdW5jdGlvbicgJiYgKEMgPT09IEFycmF5IHx8IGlzQXJyYXkoQy5wcm90b3R5cGUpKSkgQyA9IHVuZGVmaW5lZDtcbiAgICBpZiAoaXNPYmplY3QoQykpIHtcbiAgICAgIEMgPSBDW1NQRUNJRVNdO1xuICAgICAgaWYgKEMgPT09IG51bGwpIEMgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9IHJldHVybiBDID09PSB1bmRlZmluZWQgPyBBcnJheSA6IEM7XG59O1xuIiwiLy8gOS40LjIuMyBBcnJheVNwZWNpZXNDcmVhdGUob3JpZ2luYWxBcnJheSwgbGVuZ3RoKVxudmFyIHNwZWNpZXNDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4vX2FycmF5LXNwZWNpZXMtY29uc3RydWN0b3InKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3JpZ2luYWwsIGxlbmd0aCkge1xuICByZXR1cm4gbmV3IChzcGVjaWVzQ29uc3RydWN0b3Iob3JpZ2luYWwpKShsZW5ndGgpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBpbnZva2UgPSByZXF1aXJlKCcuL19pbnZva2UnKTtcbnZhciBhcnJheVNsaWNlID0gW10uc2xpY2U7XG52YXIgZmFjdG9yaWVzID0ge307XG5cbnZhciBjb25zdHJ1Y3QgPSBmdW5jdGlvbiAoRiwgbGVuLCBhcmdzKSB7XG4gIGlmICghKGxlbiBpbiBmYWN0b3JpZXMpKSB7XG4gICAgZm9yICh2YXIgbiA9IFtdLCBpID0gMDsgaSA8IGxlbjsgaSsrKSBuW2ldID0gJ2FbJyArIGkgKyAnXSc7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jXG4gICAgZmFjdG9yaWVzW2xlbl0gPSBGdW5jdGlvbignRixhJywgJ3JldHVybiBuZXcgRignICsgbi5qb2luKCcsJykgKyAnKScpO1xuICB9IHJldHVybiBmYWN0b3JpZXNbbGVuXShGLCBhcmdzKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRnVuY3Rpb24uYmluZCB8fCBmdW5jdGlvbiBiaW5kKHRoYXQgLyogLCAuLi5hcmdzICovKSB7XG4gIHZhciBmbiA9IGFGdW5jdGlvbih0aGlzKTtcbiAgdmFyIHBhcnRBcmdzID0gYXJyYXlTbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gIHZhciBib3VuZCA9IGZ1bmN0aW9uICgvKiBhcmdzLi4uICovKSB7XG4gICAgdmFyIGFyZ3MgPSBwYXJ0QXJncy5jb25jYXQoYXJyYXlTbGljZS5jYWxsKGFyZ3VtZW50cykpO1xuICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgYm91bmQgPyBjb25zdHJ1Y3QoZm4sIGFyZ3MubGVuZ3RoLCBhcmdzKSA6IGludm9rZShmbiwgYXJncywgdGhhdCk7XG4gIH07XG4gIGlmIChpc09iamVjdChmbi5wcm90b3R5cGUpKSBib3VuZC5wcm90b3R5cGUgPSBmbi5wcm90b3R5cGU7XG4gIHJldHVybiBib3VuZDtcbn07XG4iLCIvLyBnZXR0aW5nIHRhZyBmcm9tIDE5LjEuMy42IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcoKVxudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xudmFyIFRBRyA9IHJlcXVpcmUoJy4vX3drcycpKCd0b1N0cmluZ1RhZycpO1xuLy8gRVMzIHdyb25nIGhlcmVcbnZhciBBUkcgPSBjb2YoZnVuY3Rpb24gKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID09ICdBcmd1bWVudHMnO1xuXG4vLyBmYWxsYmFjayBmb3IgSUUxMSBTY3JpcHQgQWNjZXNzIERlbmllZCBlcnJvclxudmFyIHRyeUdldCA9IGZ1bmN0aW9uIChpdCwga2V5KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGl0W2tleV07XG4gIH0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIE8sIFQsIEI7XG4gIHJldHVybiBpdCA9PT0gdW5kZWZpbmVkID8gJ1VuZGVmaW5lZCcgOiBpdCA9PT0gbnVsbCA/ICdOdWxsJ1xuICAgIC8vIEBAdG9TdHJpbmdUYWcgY2FzZVxuICAgIDogdHlwZW9mIChUID0gdHJ5R2V0KE8gPSBPYmplY3QoaXQpLCBUQUcpKSA9PSAnc3RyaW5nJyA/IFRcbiAgICAvLyBidWlsdGluVGFnIGNhc2VcbiAgICA6IEFSRyA/IGNvZihPKVxuICAgIC8vIEVTMyBhcmd1bWVudHMgZmFsbGJhY2tcbiAgICA6IChCID0gY29mKE8pKSA9PSAnT2JqZWN0JyAmJiB0eXBlb2YgTy5jYWxsZWUgPT0gJ2Z1bmN0aW9uJyA/ICdBcmd1bWVudHMnIDogQjtcbn07XG4iLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoaXQpLnNsaWNlKDgsIC0xKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mO1xudmFyIGNyZWF0ZSA9IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKTtcbnZhciByZWRlZmluZUFsbCA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpO1xudmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyIGFuSW5zdGFuY2UgPSByZXF1aXJlKCcuL19hbi1pbnN0YW5jZScpO1xudmFyIGZvck9mID0gcmVxdWlyZSgnLi9fZm9yLW9mJyk7XG52YXIgJGl0ZXJEZWZpbmUgPSByZXF1aXJlKCcuL19pdGVyLWRlZmluZScpO1xudmFyIHN0ZXAgPSByZXF1aXJlKCcuL19pdGVyLXN0ZXAnKTtcbnZhciBzZXRTcGVjaWVzID0gcmVxdWlyZSgnLi9fc2V0LXNwZWNpZXMnKTtcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJyk7XG52YXIgZmFzdEtleSA9IHJlcXVpcmUoJy4vX21ldGEnKS5mYXN0S2V5O1xudmFyIHZhbGlkYXRlID0gcmVxdWlyZSgnLi9fdmFsaWRhdGUtY29sbGVjdGlvbicpO1xudmFyIFNJWkUgPSBERVNDUklQVE9SUyA/ICdfcycgOiAnc2l6ZSc7XG5cbnZhciBnZXRFbnRyeSA9IGZ1bmN0aW9uICh0aGF0LCBrZXkpIHtcbiAgLy8gZmFzdCBjYXNlXG4gIHZhciBpbmRleCA9IGZhc3RLZXkoa2V5KTtcbiAgdmFyIGVudHJ5O1xuICBpZiAoaW5kZXggIT09ICdGJykgcmV0dXJuIHRoYXQuX2lbaW5kZXhdO1xuICAvLyBmcm96ZW4gb2JqZWN0IGNhc2VcbiAgZm9yIChlbnRyeSA9IHRoYXQuX2Y7IGVudHJ5OyBlbnRyeSA9IGVudHJ5Lm4pIHtcbiAgICBpZiAoZW50cnkuayA9PSBrZXkpIHJldHVybiBlbnRyeTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGdldENvbnN0cnVjdG9yOiBmdW5jdGlvbiAod3JhcHBlciwgTkFNRSwgSVNfTUFQLCBBRERFUikge1xuICAgIHZhciBDID0gd3JhcHBlcihmdW5jdGlvbiAodGhhdCwgaXRlcmFibGUpIHtcbiAgICAgIGFuSW5zdGFuY2UodGhhdCwgQywgTkFNRSwgJ19pJyk7XG4gICAgICB0aGF0Ll90ID0gTkFNRTsgICAgICAgICAvLyBjb2xsZWN0aW9uIHR5cGVcbiAgICAgIHRoYXQuX2kgPSBjcmVhdGUobnVsbCk7IC8vIGluZGV4XG4gICAgICB0aGF0Ll9mID0gdW5kZWZpbmVkOyAgICAvLyBmaXJzdCBlbnRyeVxuICAgICAgdGhhdC5fbCA9IHVuZGVmaW5lZDsgICAgLy8gbGFzdCBlbnRyeVxuICAgICAgdGhhdFtTSVpFXSA9IDA7ICAgICAgICAgLy8gc2l6ZVxuICAgICAgaWYgKGl0ZXJhYmxlICE9IHVuZGVmaW5lZCkgZm9yT2YoaXRlcmFibGUsIElTX01BUCwgdGhhdFtBRERFUl0sIHRoYXQpO1xuICAgIH0pO1xuICAgIHJlZGVmaW5lQWxsKEMucHJvdG90eXBlLCB7XG4gICAgICAvLyAyMy4xLjMuMSBNYXAucHJvdG90eXBlLmNsZWFyKClcbiAgICAgIC8vIDIzLjIuMy4yIFNldC5wcm90b3R5cGUuY2xlYXIoKVxuICAgICAgY2xlYXI6IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgICBmb3IgKHZhciB0aGF0ID0gdmFsaWRhdGUodGhpcywgTkFNRSksIGRhdGEgPSB0aGF0Ll9pLCBlbnRyeSA9IHRoYXQuX2Y7IGVudHJ5OyBlbnRyeSA9IGVudHJ5Lm4pIHtcbiAgICAgICAgICBlbnRyeS5yID0gdHJ1ZTtcbiAgICAgICAgICBpZiAoZW50cnkucCkgZW50cnkucCA9IGVudHJ5LnAubiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBkZWxldGUgZGF0YVtlbnRyeS5pXTtcbiAgICAgICAgfVxuICAgICAgICB0aGF0Ll9mID0gdGhhdC5fbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhhdFtTSVpFXSA9IDA7XG4gICAgICB9LFxuICAgICAgLy8gMjMuMS4zLjMgTWFwLnByb3RvdHlwZS5kZWxldGUoa2V5KVxuICAgICAgLy8gMjMuMi4zLjQgU2V0LnByb3RvdHlwZS5kZWxldGUodmFsdWUpXG4gICAgICAnZGVsZXRlJzogZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YXIgdGhhdCA9IHZhbGlkYXRlKHRoaXMsIE5BTUUpO1xuICAgICAgICB2YXIgZW50cnkgPSBnZXRFbnRyeSh0aGF0LCBrZXkpO1xuICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICB2YXIgbmV4dCA9IGVudHJ5Lm47XG4gICAgICAgICAgdmFyIHByZXYgPSBlbnRyeS5wO1xuICAgICAgICAgIGRlbGV0ZSB0aGF0Ll9pW2VudHJ5LmldO1xuICAgICAgICAgIGVudHJ5LnIgPSB0cnVlO1xuICAgICAgICAgIGlmIChwcmV2KSBwcmV2Lm4gPSBuZXh0O1xuICAgICAgICAgIGlmIChuZXh0KSBuZXh0LnAgPSBwcmV2O1xuICAgICAgICAgIGlmICh0aGF0Ll9mID09IGVudHJ5KSB0aGF0Ll9mID0gbmV4dDtcbiAgICAgICAgICBpZiAodGhhdC5fbCA9PSBlbnRyeSkgdGhhdC5fbCA9IHByZXY7XG4gICAgICAgICAgdGhhdFtTSVpFXS0tO1xuICAgICAgICB9IHJldHVybiAhIWVudHJ5O1xuICAgICAgfSxcbiAgICAgIC8vIDIzLjIuMy42IFNldC5wcm90b3R5cGUuZm9yRWFjaChjYWxsYmFja2ZuLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxuICAgICAgLy8gMjMuMS4zLjUgTWFwLnByb3RvdHlwZS5mb3JFYWNoKGNhbGxiYWNrZm4sIHRoaXNBcmcgPSB1bmRlZmluZWQpXG4gICAgICBmb3JFYWNoOiBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrZm4gLyogLCB0aGF0ID0gdW5kZWZpbmVkICovKSB7XG4gICAgICAgIHZhbGlkYXRlKHRoaXMsIE5BTUUpO1xuICAgICAgICB2YXIgZiA9IGN0eChjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCwgMyk7XG4gICAgICAgIHZhciBlbnRyeTtcbiAgICAgICAgd2hpbGUgKGVudHJ5ID0gZW50cnkgPyBlbnRyeS5uIDogdGhpcy5fZikge1xuICAgICAgICAgIGYoZW50cnkudiwgZW50cnkuaywgdGhpcyk7XG4gICAgICAgICAgLy8gcmV2ZXJ0IHRvIHRoZSBsYXN0IGV4aXN0aW5nIGVudHJ5XG4gICAgICAgICAgd2hpbGUgKGVudHJ5ICYmIGVudHJ5LnIpIGVudHJ5ID0gZW50cnkucDtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIDIzLjEuMy43IE1hcC5wcm90b3R5cGUuaGFzKGtleSlcbiAgICAgIC8vIDIzLjIuMy43IFNldC5wcm90b3R5cGUuaGFzKHZhbHVlKVxuICAgICAgaGFzOiBmdW5jdGlvbiBoYXMoa2V5KSB7XG4gICAgICAgIHJldHVybiAhIWdldEVudHJ5KHZhbGlkYXRlKHRoaXMsIE5BTUUpLCBrZXkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChERVNDUklQVE9SUykgZFAoQy5wcm90b3R5cGUsICdzaXplJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZSh0aGlzLCBOQU1FKVtTSVpFXTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gQztcbiAgfSxcbiAgZGVmOiBmdW5jdGlvbiAodGhhdCwga2V5LCB2YWx1ZSkge1xuICAgIHZhciBlbnRyeSA9IGdldEVudHJ5KHRoYXQsIGtleSk7XG4gICAgdmFyIHByZXYsIGluZGV4O1xuICAgIC8vIGNoYW5nZSBleGlzdGluZyBlbnRyeVxuICAgIGlmIChlbnRyeSkge1xuICAgICAgZW50cnkudiA9IHZhbHVlO1xuICAgIC8vIGNyZWF0ZSBuZXcgZW50cnlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhhdC5fbCA9IGVudHJ5ID0ge1xuICAgICAgICBpOiBpbmRleCA9IGZhc3RLZXkoa2V5LCB0cnVlKSwgLy8gPC0gaW5kZXhcbiAgICAgICAgazoga2V5LCAgICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIGtleVxuICAgICAgICB2OiB2YWx1ZSwgICAgICAgICAgICAgICAgICAgICAgLy8gPC0gdmFsdWVcbiAgICAgICAgcDogcHJldiA9IHRoYXQuX2wsICAgICAgICAgICAgIC8vIDwtIHByZXZpb3VzIGVudHJ5XG4gICAgICAgIG46IHVuZGVmaW5lZCwgICAgICAgICAgICAgICAgICAvLyA8LSBuZXh0IGVudHJ5XG4gICAgICAgIHI6IGZhbHNlICAgICAgICAgICAgICAgICAgICAgICAvLyA8LSByZW1vdmVkXG4gICAgICB9O1xuICAgICAgaWYgKCF0aGF0Ll9mKSB0aGF0Ll9mID0gZW50cnk7XG4gICAgICBpZiAocHJldikgcHJldi5uID0gZW50cnk7XG4gICAgICB0aGF0W1NJWkVdKys7XG4gICAgICAvLyBhZGQgdG8gaW5kZXhcbiAgICAgIGlmIChpbmRleCAhPT0gJ0YnKSB0aGF0Ll9pW2luZGV4XSA9IGVudHJ5O1xuICAgIH0gcmV0dXJuIHRoYXQ7XG4gIH0sXG4gIGdldEVudHJ5OiBnZXRFbnRyeSxcbiAgc2V0U3Ryb25nOiBmdW5jdGlvbiAoQywgTkFNRSwgSVNfTUFQKSB7XG4gICAgLy8gYWRkIC5rZXlzLCAudmFsdWVzLCAuZW50cmllcywgW0BAaXRlcmF0b3JdXG4gICAgLy8gMjMuMS4zLjQsIDIzLjEuMy44LCAyMy4xLjMuMTEsIDIzLjEuMy4xMiwgMjMuMi4zLjUsIDIzLjIuMy44LCAyMy4yLjMuMTAsIDIzLjIuMy4xMVxuICAgICRpdGVyRGVmaW5lKEMsIE5BTUUsIGZ1bmN0aW9uIChpdGVyYXRlZCwga2luZCkge1xuICAgICAgdGhpcy5fdCA9IHZhbGlkYXRlKGl0ZXJhdGVkLCBOQU1FKTsgLy8gdGFyZ2V0XG4gICAgICB0aGlzLl9rID0ga2luZDsgICAgICAgICAgICAgICAgICAgICAvLyBraW5kXG4gICAgICB0aGlzLl9sID0gdW5kZWZpbmVkOyAgICAgICAgICAgICAgICAvLyBwcmV2aW91c1xuICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgIHZhciBraW5kID0gdGhhdC5faztcbiAgICAgIHZhciBlbnRyeSA9IHRoYXQuX2w7XG4gICAgICAvLyByZXZlcnQgdG8gdGhlIGxhc3QgZXhpc3RpbmcgZW50cnlcbiAgICAgIHdoaWxlIChlbnRyeSAmJiBlbnRyeS5yKSBlbnRyeSA9IGVudHJ5LnA7XG4gICAgICAvLyBnZXQgbmV4dCBlbnRyeVxuICAgICAgaWYgKCF0aGF0Ll90IHx8ICEodGhhdC5fbCA9IGVudHJ5ID0gZW50cnkgPyBlbnRyeS5uIDogdGhhdC5fdC5fZikpIHtcbiAgICAgICAgLy8gb3IgZmluaXNoIHRoZSBpdGVyYXRpb25cbiAgICAgICAgdGhhdC5fdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIHN0ZXAoMSk7XG4gICAgICB9XG4gICAgICAvLyByZXR1cm4gc3RlcCBieSBraW5kXG4gICAgICBpZiAoa2luZCA9PSAna2V5cycpIHJldHVybiBzdGVwKDAsIGVudHJ5LmspO1xuICAgICAgaWYgKGtpbmQgPT0gJ3ZhbHVlcycpIHJldHVybiBzdGVwKDAsIGVudHJ5LnYpO1xuICAgICAgcmV0dXJuIHN0ZXAoMCwgW2VudHJ5LmssIGVudHJ5LnZdKTtcbiAgICB9LCBJU19NQVAgPyAnZW50cmllcycgOiAndmFsdWVzJywgIUlTX01BUCwgdHJ1ZSk7XG5cbiAgICAvLyBhZGQgW0BAc3BlY2llc10sIDIzLjEuMi4yLCAyMy4yLjIuMlxuICAgIHNldFNwZWNpZXMoTkFNRSk7XG4gIH1cbn07XG4iLCIvLyBodHRwczovL2dpdGh1Yi5jb20vRGF2aWRCcnVhbnQvTWFwLVNldC5wcm90b3R5cGUudG9KU09OXG52YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4vX2NsYXNzb2YnKTtcbnZhciBmcm9tID0gcmVxdWlyZSgnLi9fYXJyYXktZnJvbS1pdGVyYWJsZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTkFNRSkge1xuICByZXR1cm4gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgIGlmIChjbGFzc29mKHRoaXMpICE9IE5BTUUpIHRocm93IFR5cGVFcnJvcihOQU1FICsgXCIjdG9KU09OIGlzbid0IGdlbmVyaWNcIik7XG4gICAgcmV0dXJuIGZyb20odGhpcyk7XG4gIH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHJlZGVmaW5lQWxsID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUtYWxsJyk7XG52YXIgZ2V0V2VhayA9IHJlcXVpcmUoJy4vX21ldGEnKS5nZXRXZWFrO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBhbkluc3RhbmNlID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKTtcbnZhciBmb3JPZiA9IHJlcXVpcmUoJy4vX2Zvci1vZicpO1xudmFyIGNyZWF0ZUFycmF5TWV0aG9kID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpO1xudmFyICRoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciB2YWxpZGF0ZSA9IHJlcXVpcmUoJy4vX3ZhbGlkYXRlLWNvbGxlY3Rpb24nKTtcbnZhciBhcnJheUZpbmQgPSBjcmVhdGVBcnJheU1ldGhvZCg1KTtcbnZhciBhcnJheUZpbmRJbmRleCA9IGNyZWF0ZUFycmF5TWV0aG9kKDYpO1xudmFyIGlkID0gMDtcblxuLy8gZmFsbGJhY2sgZm9yIHVuY2F1Z2h0IGZyb3plbiBrZXlzXG52YXIgdW5jYXVnaHRGcm96ZW5TdG9yZSA9IGZ1bmN0aW9uICh0aGF0KSB7XG4gIHJldHVybiB0aGF0Ll9sIHx8ICh0aGF0Ll9sID0gbmV3IFVuY2F1Z2h0RnJvemVuU3RvcmUoKSk7XG59O1xudmFyIFVuY2F1Z2h0RnJvemVuU3RvcmUgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuYSA9IFtdO1xufTtcbnZhciBmaW5kVW5jYXVnaHRGcm96ZW4gPSBmdW5jdGlvbiAoc3RvcmUsIGtleSkge1xuICByZXR1cm4gYXJyYXlGaW5kKHN0b3JlLmEsIGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiBpdFswXSA9PT0ga2V5O1xuICB9KTtcbn07XG5VbmNhdWdodEZyb3plblN0b3JlLnByb3RvdHlwZSA9IHtcbiAgZ2V0OiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIGVudHJ5ID0gZmluZFVuY2F1Z2h0RnJvemVuKHRoaXMsIGtleSk7XG4gICAgaWYgKGVudHJ5KSByZXR1cm4gZW50cnlbMV07XG4gIH0sXG4gIGhhczogZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiAhIWZpbmRVbmNhdWdodEZyb3plbih0aGlzLCBrZXkpO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgdmFyIGVudHJ5ID0gZmluZFVuY2F1Z2h0RnJvemVuKHRoaXMsIGtleSk7XG4gICAgaWYgKGVudHJ5KSBlbnRyeVsxXSA9IHZhbHVlO1xuICAgIGVsc2UgdGhpcy5hLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgfSxcbiAgJ2RlbGV0ZSc6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgaW5kZXggPSBhcnJheUZpbmRJbmRleCh0aGlzLmEsIGZ1bmN0aW9uIChpdCkge1xuICAgICAgcmV0dXJuIGl0WzBdID09PSBrZXk7XG4gICAgfSk7XG4gICAgaWYgKH5pbmRleCkgdGhpcy5hLnNwbGljZShpbmRleCwgMSk7XG4gICAgcmV0dXJuICEhfmluZGV4O1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ2V0Q29uc3RydWN0b3I6IGZ1bmN0aW9uICh3cmFwcGVyLCBOQU1FLCBJU19NQVAsIEFEREVSKSB7XG4gICAgdmFyIEMgPSB3cmFwcGVyKGZ1bmN0aW9uICh0aGF0LCBpdGVyYWJsZSkge1xuICAgICAgYW5JbnN0YW5jZSh0aGF0LCBDLCBOQU1FLCAnX2knKTtcbiAgICAgIHRoYXQuX3QgPSBOQU1FOyAgICAgIC8vIGNvbGxlY3Rpb24gdHlwZVxuICAgICAgdGhhdC5faSA9IGlkKys7ICAgICAgLy8gY29sbGVjdGlvbiBpZFxuICAgICAgdGhhdC5fbCA9IHVuZGVmaW5lZDsgLy8gbGVhayBzdG9yZSBmb3IgdW5jYXVnaHQgZnJvemVuIG9iamVjdHNcbiAgICAgIGlmIChpdGVyYWJsZSAhPSB1bmRlZmluZWQpIGZvck9mKGl0ZXJhYmxlLCBJU19NQVAsIHRoYXRbQURERVJdLCB0aGF0KTtcbiAgICB9KTtcbiAgICByZWRlZmluZUFsbChDLnByb3RvdHlwZSwge1xuICAgICAgLy8gMjMuMy4zLjIgV2Vha01hcC5wcm90b3R5cGUuZGVsZXRlKGtleSlcbiAgICAgIC8vIDIzLjQuMy4zIFdlYWtTZXQucHJvdG90eXBlLmRlbGV0ZSh2YWx1ZSlcbiAgICAgICdkZWxldGUnOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmICghaXNPYmplY3Qoa2V5KSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICB2YXIgZGF0YSA9IGdldFdlYWsoa2V5KTtcbiAgICAgICAgaWYgKGRhdGEgPT09IHRydWUpIHJldHVybiB1bmNhdWdodEZyb3plblN0b3JlKHZhbGlkYXRlKHRoaXMsIE5BTUUpKVsnZGVsZXRlJ10oa2V5KTtcbiAgICAgICAgcmV0dXJuIGRhdGEgJiYgJGhhcyhkYXRhLCB0aGlzLl9pKSAmJiBkZWxldGUgZGF0YVt0aGlzLl9pXTtcbiAgICAgIH0sXG4gICAgICAvLyAyMy4zLjMuNCBXZWFrTWFwLnByb3RvdHlwZS5oYXMoa2V5KVxuICAgICAgLy8gMjMuNC4zLjQgV2Vha1NldC5wcm90b3R5cGUuaGFzKHZhbHVlKVxuICAgICAgaGFzOiBmdW5jdGlvbiBoYXMoa2V5KSB7XG4gICAgICAgIGlmICghaXNPYmplY3Qoa2V5KSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICB2YXIgZGF0YSA9IGdldFdlYWsoa2V5KTtcbiAgICAgICAgaWYgKGRhdGEgPT09IHRydWUpIHJldHVybiB1bmNhdWdodEZyb3plblN0b3JlKHZhbGlkYXRlKHRoaXMsIE5BTUUpKS5oYXMoa2V5KTtcbiAgICAgICAgcmV0dXJuIGRhdGEgJiYgJGhhcyhkYXRhLCB0aGlzLl9pKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gQztcbiAgfSxcbiAgZGVmOiBmdW5jdGlvbiAodGhhdCwga2V5LCB2YWx1ZSkge1xuICAgIHZhciBkYXRhID0gZ2V0V2Vhayhhbk9iamVjdChrZXkpLCB0cnVlKTtcbiAgICBpZiAoZGF0YSA9PT0gdHJ1ZSkgdW5jYXVnaHRGcm96ZW5TdG9yZSh0aGF0KS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgZWxzZSBkYXRhW3RoYXQuX2ldID0gdmFsdWU7XG4gICAgcmV0dXJuIHRoYXQ7XG4gIH0sXG4gIHVmc3RvcmU6IHVuY2F1Z2h0RnJvemVuU3RvcmVcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcbnZhciByZWRlZmluZUFsbCA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpO1xudmFyIG1ldGEgPSByZXF1aXJlKCcuL19tZXRhJyk7XG52YXIgZm9yT2YgPSByZXF1aXJlKCcuL19mb3Itb2YnKTtcbnZhciBhbkluc3RhbmNlID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbnZhciAkaXRlckRldGVjdCA9IHJlcXVpcmUoJy4vX2l0ZXItZGV0ZWN0Jyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIGluaGVyaXRJZlJlcXVpcmVkID0gcmVxdWlyZSgnLi9faW5oZXJpdC1pZi1yZXF1aXJlZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChOQU1FLCB3cmFwcGVyLCBtZXRob2RzLCBjb21tb24sIElTX01BUCwgSVNfV0VBSykge1xuICB2YXIgQmFzZSA9IGdsb2JhbFtOQU1FXTtcbiAgdmFyIEMgPSBCYXNlO1xuICB2YXIgQURERVIgPSBJU19NQVAgPyAnc2V0JyA6ICdhZGQnO1xuICB2YXIgcHJvdG8gPSBDICYmIEMucHJvdG90eXBlO1xuICB2YXIgTyA9IHt9O1xuICB2YXIgZml4TWV0aG9kID0gZnVuY3Rpb24gKEtFWSkge1xuICAgIHZhciBmbiA9IHByb3RvW0tFWV07XG4gICAgcmVkZWZpbmUocHJvdG8sIEtFWSxcbiAgICAgIEtFWSA9PSAnZGVsZXRlJyA/IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHJldHVybiBJU19XRUFLICYmICFpc09iamVjdChhKSA/IGZhbHNlIDogZm4uY2FsbCh0aGlzLCBhID09PSAwID8gMCA6IGEpO1xuICAgICAgfSA6IEtFWSA9PSAnaGFzJyA/IGZ1bmN0aW9uIGhhcyhhKSB7XG4gICAgICAgIHJldHVybiBJU19XRUFLICYmICFpc09iamVjdChhKSA/IGZhbHNlIDogZm4uY2FsbCh0aGlzLCBhID09PSAwID8gMCA6IGEpO1xuICAgICAgfSA6IEtFWSA9PSAnZ2V0JyA/IGZ1bmN0aW9uIGdldChhKSB7XG4gICAgICAgIHJldHVybiBJU19XRUFLICYmICFpc09iamVjdChhKSA/IHVuZGVmaW5lZCA6IGZuLmNhbGwodGhpcywgYSA9PT0gMCA/IDAgOiBhKTtcbiAgICAgIH0gOiBLRVkgPT0gJ2FkZCcgPyBmdW5jdGlvbiBhZGQoYSkgeyBmbi5jYWxsKHRoaXMsIGEgPT09IDAgPyAwIDogYSk7IHJldHVybiB0aGlzOyB9XG4gICAgICAgIDogZnVuY3Rpb24gc2V0KGEsIGIpIHsgZm4uY2FsbCh0aGlzLCBhID09PSAwID8gMCA6IGEsIGIpOyByZXR1cm4gdGhpczsgfVxuICAgICk7XG4gIH07XG4gIGlmICh0eXBlb2YgQyAhPSAnZnVuY3Rpb24nIHx8ICEoSVNfV0VBSyB8fCBwcm90by5mb3JFYWNoICYmICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgbmV3IEMoKS5lbnRyaWVzKCkubmV4dCgpO1xuICB9KSkpIHtcbiAgICAvLyBjcmVhdGUgY29sbGVjdGlvbiBjb25zdHJ1Y3RvclxuICAgIEMgPSBjb21tb24uZ2V0Q29uc3RydWN0b3Iod3JhcHBlciwgTkFNRSwgSVNfTUFQLCBBRERFUik7XG4gICAgcmVkZWZpbmVBbGwoQy5wcm90b3R5cGUsIG1ldGhvZHMpO1xuICAgIG1ldGEuTkVFRCA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGluc3RhbmNlID0gbmV3IEMoKTtcbiAgICAvLyBlYXJseSBpbXBsZW1lbnRhdGlvbnMgbm90IHN1cHBvcnRzIGNoYWluaW5nXG4gICAgdmFyIEhBU05UX0NIQUlOSU5HID0gaW5zdGFuY2VbQURERVJdKElTX1dFQUsgPyB7fSA6IC0wLCAxKSAhPSBpbnN0YW5jZTtcbiAgICAvLyBWOCB+ICBDaHJvbWl1bSA0MC0gd2Vhay1jb2xsZWN0aW9ucyB0aHJvd3Mgb24gcHJpbWl0aXZlcywgYnV0IHNob3VsZCByZXR1cm4gZmFsc2VcbiAgICB2YXIgVEhST1dTX09OX1BSSU1JVElWRVMgPSBmYWlscyhmdW5jdGlvbiAoKSB7IGluc3RhbmNlLmhhcygxKTsgfSk7XG4gICAgLy8gbW9zdCBlYXJseSBpbXBsZW1lbnRhdGlvbnMgZG9lc24ndCBzdXBwb3J0cyBpdGVyYWJsZXMsIG1vc3QgbW9kZXJuIC0gbm90IGNsb3NlIGl0IGNvcnJlY3RseVxuICAgIHZhciBBQ0NFUFRfSVRFUkFCTEVTID0gJGl0ZXJEZXRlY3QoZnVuY3Rpb24gKGl0ZXIpIHsgbmV3IEMoaXRlcik7IH0pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgIC8vIGZvciBlYXJseSBpbXBsZW1lbnRhdGlvbnMgLTAgYW5kICswIG5vdCB0aGUgc2FtZVxuICAgIHZhciBCVUdHWV9aRVJPID0gIUlTX1dFQUsgJiYgZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgICAgLy8gVjggfiBDaHJvbWl1bSA0Mi0gZmFpbHMgb25seSB3aXRoIDUrIGVsZW1lbnRzXG4gICAgICB2YXIgJGluc3RhbmNlID0gbmV3IEMoKTtcbiAgICAgIHZhciBpbmRleCA9IDU7XG4gICAgICB3aGlsZSAoaW5kZXgtLSkgJGluc3RhbmNlW0FEREVSXShpbmRleCwgaW5kZXgpO1xuICAgICAgcmV0dXJuICEkaW5zdGFuY2UuaGFzKC0wKTtcbiAgICB9KTtcbiAgICBpZiAoIUFDQ0VQVF9JVEVSQUJMRVMpIHtcbiAgICAgIEMgPSB3cmFwcGVyKGZ1bmN0aW9uICh0YXJnZXQsIGl0ZXJhYmxlKSB7XG4gICAgICAgIGFuSW5zdGFuY2UodGFyZ2V0LCBDLCBOQU1FKTtcbiAgICAgICAgdmFyIHRoYXQgPSBpbmhlcml0SWZSZXF1aXJlZChuZXcgQmFzZSgpLCB0YXJnZXQsIEMpO1xuICAgICAgICBpZiAoaXRlcmFibGUgIT0gdW5kZWZpbmVkKSBmb3JPZihpdGVyYWJsZSwgSVNfTUFQLCB0aGF0W0FEREVSXSwgdGhhdCk7XG4gICAgICAgIHJldHVybiB0aGF0O1xuICAgICAgfSk7XG4gICAgICBDLnByb3RvdHlwZSA9IHByb3RvO1xuICAgICAgcHJvdG8uY29uc3RydWN0b3IgPSBDO1xuICAgIH1cbiAgICBpZiAoVEhST1dTX09OX1BSSU1JVElWRVMgfHwgQlVHR1lfWkVSTykge1xuICAgICAgZml4TWV0aG9kKCdkZWxldGUnKTtcbiAgICAgIGZpeE1ldGhvZCgnaGFzJyk7XG4gICAgICBJU19NQVAgJiYgZml4TWV0aG9kKCdnZXQnKTtcbiAgICB9XG4gICAgaWYgKEJVR0dZX1pFUk8gfHwgSEFTTlRfQ0hBSU5JTkcpIGZpeE1ldGhvZChBRERFUik7XG4gICAgLy8gd2VhayBjb2xsZWN0aW9ucyBzaG91bGQgbm90IGNvbnRhaW5zIC5jbGVhciBtZXRob2RcbiAgICBpZiAoSVNfV0VBSyAmJiBwcm90by5jbGVhcikgZGVsZXRlIHByb3RvLmNsZWFyO1xuICB9XG5cbiAgc2V0VG9TdHJpbmdUYWcoQywgTkFNRSk7XG5cbiAgT1tOQU1FXSA9IEM7XG4gICRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogKEMgIT0gQmFzZSksIE8pO1xuXG4gIGlmICghSVNfV0VBSykgY29tbW9uLnNldFN0cm9uZyhDLCBOQU1FLCBJU19NQVApO1xuXG4gIHJldHVybiBDO1xufTtcbiIsInZhciBjb3JlID0gbW9kdWxlLmV4cG9ydHMgPSB7IHZlcnNpb246ICcyLjUuMScgfTtcbmlmICh0eXBlb2YgX19lID09ICdudW1iZXInKSBfX2UgPSBjb3JlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4iLCIndXNlIHN0cmljdCc7XG52YXIgJGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG52YXIgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqZWN0LCBpbmRleCwgdmFsdWUpIHtcbiAgaWYgKGluZGV4IGluIG9iamVjdCkgJGRlZmluZVByb3BlcnR5LmYob2JqZWN0LCBpbmRleCwgY3JlYXRlRGVzYygwLCB2YWx1ZSkpO1xuICBlbHNlIG9iamVjdFtpbmRleF0gPSB2YWx1ZTtcbn07XG4iLCIvLyBvcHRpb25hbCAvIHNpbXBsZSBjb250ZXh0IGJpbmRpbmdcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChmbiwgdGhhdCwgbGVuZ3RoKSB7XG4gIGFGdW5jdGlvbihmbik7XG4gIGlmICh0aGF0ID09PSB1bmRlZmluZWQpIHJldHVybiBmbjtcbiAgc3dpdGNoIChsZW5ndGgpIHtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbiAoYSkge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSk7XG4gICAgfTtcbiAgICBjYXNlIDI6IHJldHVybiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYik7XG4gICAgfTtcbiAgICBjYXNlIDM6IHJldHVybiBmdW5jdGlvbiAoYSwgYiwgYykge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYiwgYyk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gKC8qIC4uLmFyZ3MgKi8pIHtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhhdCwgYXJndW1lbnRzKTtcbiAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG4vLyAyMC4zLjQuMzYgLyAxNS45LjUuNDMgRGF0ZS5wcm90b3R5cGUudG9JU09TdHJpbmcoKVxudmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbnZhciBnZXRUaW1lID0gRGF0ZS5wcm90b3R5cGUuZ2V0VGltZTtcbnZhciAkdG9JU09TdHJpbmcgPSBEYXRlLnByb3RvdHlwZS50b0lTT1N0cmluZztcblxudmFyIGx6ID0gZnVuY3Rpb24gKG51bSkge1xuICByZXR1cm4gbnVtID4gOSA/IG51bSA6ICcwJyArIG51bTtcbn07XG5cbi8vIFBoYW50b21KUyAvIG9sZCBXZWJLaXQgaGFzIGEgYnJva2VuIGltcGxlbWVudGF0aW9uc1xubW9kdWxlLmV4cG9ydHMgPSAoZmFpbHMoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gJHRvSVNPU3RyaW5nLmNhbGwobmV3IERhdGUoLTVlMTMgLSAxKSkgIT0gJzAzODUtMDctMjVUMDc6MDY6MzkuOTk5Wic7XG59KSB8fCAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAkdG9JU09TdHJpbmcuY2FsbChuZXcgRGF0ZShOYU4pKTtcbn0pKSA/IGZ1bmN0aW9uIHRvSVNPU3RyaW5nKCkge1xuICBpZiAoIWlzRmluaXRlKGdldFRpbWUuY2FsbCh0aGlzKSkpIHRocm93IFJhbmdlRXJyb3IoJ0ludmFsaWQgdGltZSB2YWx1ZScpO1xuICB2YXIgZCA9IHRoaXM7XG4gIHZhciB5ID0gZC5nZXRVVENGdWxsWWVhcigpO1xuICB2YXIgbSA9IGQuZ2V0VVRDTWlsbGlzZWNvbmRzKCk7XG4gIHZhciBzID0geSA8IDAgPyAnLScgOiB5ID4gOTk5OSA/ICcrJyA6ICcnO1xuICByZXR1cm4gcyArICgnMDAwMDAnICsgTWF0aC5hYnMoeSkpLnNsaWNlKHMgPyAtNiA6IC00KSArXG4gICAgJy0nICsgbHooZC5nZXRVVENNb250aCgpICsgMSkgKyAnLScgKyBseihkLmdldFVUQ0RhdGUoKSkgK1xuICAgICdUJyArIGx6KGQuZ2V0VVRDSG91cnMoKSkgKyAnOicgKyBseihkLmdldFVUQ01pbnV0ZXMoKSkgK1xuICAgICc6JyArIGx6KGQuZ2V0VVRDU2Vjb25kcygpKSArICcuJyArIChtID4gOTkgPyBtIDogJzAnICsgbHoobSkpICsgJ1onO1xufSA6ICR0b0lTT1N0cmluZztcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7XG52YXIgTlVNQkVSID0gJ251bWJlcic7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGhpbnQpIHtcbiAgaWYgKGhpbnQgIT09ICdzdHJpbmcnICYmIGhpbnQgIT09IE5VTUJFUiAmJiBoaW50ICE9PSAnZGVmYXVsdCcpIHRocm93IFR5cGVFcnJvcignSW5jb3JyZWN0IGhpbnQnKTtcbiAgcmV0dXJuIHRvUHJpbWl0aXZlKGFuT2JqZWN0KHRoaXMpLCBoaW50ICE9IE5VTUJFUik7XG59O1xuIiwiLy8gNy4yLjEgUmVxdWlyZU9iamVjdENvZXJjaWJsZShhcmd1bWVudClcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpdCA9PSB1bmRlZmluZWQpIHRocm93IFR5cGVFcnJvcihcIkNhbid0IGNhbGwgbWV0aG9kIG9uICBcIiArIGl0KTtcbiAgcmV0dXJuIGl0O1xufTtcbiIsIi8vIFRoYW5rJ3MgSUU4IGZvciBoaXMgZnVubnkgZGVmaW5lUHJvcGVydHlcbm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAnYScsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9IH0pLmEgIT0gNztcbn0pO1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgZG9jdW1lbnQgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5kb2N1bWVudDtcbi8vIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50IGlzICdvYmplY3QnIGluIG9sZCBJRVxudmFyIGlzID0gaXNPYmplY3QoZG9jdW1lbnQpICYmIGlzT2JqZWN0KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGlzID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChpdCkgOiB7fTtcbn07XG4iLCIvLyBJRSA4LSBkb24ndCBlbnVtIGJ1ZyBrZXlzXG5tb2R1bGUuZXhwb3J0cyA9IChcbiAgJ2NvbnN0cnVjdG9yLGhhc093blByb3BlcnR5LGlzUHJvdG90eXBlT2YscHJvcGVydHlJc0VudW1lcmFibGUsdG9Mb2NhbGVTdHJpbmcsdG9TdHJpbmcsdmFsdWVPZidcbikuc3BsaXQoJywnKTtcbiIsIi8vIGFsbCBlbnVtZXJhYmxlIG9iamVjdCBrZXlzLCBpbmNsdWRlcyBzeW1ib2xzXG52YXIgZ2V0S2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG52YXIgZ09QUyA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BzJyk7XG52YXIgcElFID0gcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIHJlc3VsdCA9IGdldEtleXMoaXQpO1xuICB2YXIgZ2V0U3ltYm9scyA9IGdPUFMuZjtcbiAgaWYgKGdldFN5bWJvbHMpIHtcbiAgICB2YXIgc3ltYm9scyA9IGdldFN5bWJvbHMoaXQpO1xuICAgIHZhciBpc0VudW0gPSBwSUUuZjtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGtleTtcbiAgICB3aGlsZSAoc3ltYm9scy5sZW5ndGggPiBpKSBpZiAoaXNFbnVtLmNhbGwoaXQsIGtleSA9IHN5bWJvbHNbaSsrXSkpIHJlc3VsdC5wdXNoKGtleSk7XG4gIH0gcmV0dXJuIHJlc3VsdDtcbn07XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgY29yZSA9IHJlcXVpcmUoJy4vX2NvcmUnKTtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcbnZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcblxudmFyICRleHBvcnQgPSBmdW5jdGlvbiAodHlwZSwgbmFtZSwgc291cmNlKSB7XG4gIHZhciBJU19GT1JDRUQgPSB0eXBlICYgJGV4cG9ydC5GO1xuICB2YXIgSVNfR0xPQkFMID0gdHlwZSAmICRleHBvcnQuRztcbiAgdmFyIElTX1NUQVRJQyA9IHR5cGUgJiAkZXhwb3J0LlM7XG4gIHZhciBJU19QUk9UTyA9IHR5cGUgJiAkZXhwb3J0LlA7XG4gIHZhciBJU19CSU5EID0gdHlwZSAmICRleHBvcnQuQjtcbiAgdmFyIHRhcmdldCA9IElTX0dMT0JBTCA/IGdsb2JhbCA6IElTX1NUQVRJQyA/IGdsb2JhbFtuYW1lXSB8fCAoZ2xvYmFsW25hbWVdID0ge30pIDogKGdsb2JhbFtuYW1lXSB8fCB7fSlbUFJPVE9UWVBFXTtcbiAgdmFyIGV4cG9ydHMgPSBJU19HTE9CQUwgPyBjb3JlIDogY29yZVtuYW1lXSB8fCAoY29yZVtuYW1lXSA9IHt9KTtcbiAgdmFyIGV4cFByb3RvID0gZXhwb3J0c1tQUk9UT1RZUEVdIHx8IChleHBvcnRzW1BST1RPVFlQRV0gPSB7fSk7XG4gIHZhciBrZXksIG93biwgb3V0LCBleHA7XG4gIGlmIChJU19HTE9CQUwpIHNvdXJjZSA9IG5hbWU7XG4gIGZvciAoa2V5IGluIHNvdXJjZSkge1xuICAgIC8vIGNvbnRhaW5zIGluIG5hdGl2ZVxuICAgIG93biA9ICFJU19GT1JDRUQgJiYgdGFyZ2V0ICYmIHRhcmdldFtrZXldICE9PSB1bmRlZmluZWQ7XG4gICAgLy8gZXhwb3J0IG5hdGl2ZSBvciBwYXNzZWRcbiAgICBvdXQgPSAob3duID8gdGFyZ2V0IDogc291cmNlKVtrZXldO1xuICAgIC8vIGJpbmQgdGltZXJzIHRvIGdsb2JhbCBmb3IgY2FsbCBmcm9tIGV4cG9ydCBjb250ZXh0XG4gICAgZXhwID0gSVNfQklORCAmJiBvd24gPyBjdHgob3V0LCBnbG9iYWwpIDogSVNfUFJPVE8gJiYgdHlwZW9mIG91dCA9PSAnZnVuY3Rpb24nID8gY3R4KEZ1bmN0aW9uLmNhbGwsIG91dCkgOiBvdXQ7XG4gICAgLy8gZXh0ZW5kIGdsb2JhbFxuICAgIGlmICh0YXJnZXQpIHJlZGVmaW5lKHRhcmdldCwga2V5LCBvdXQsIHR5cGUgJiAkZXhwb3J0LlUpO1xuICAgIC8vIGV4cG9ydFxuICAgIGlmIChleHBvcnRzW2tleV0gIT0gb3V0KSBoaWRlKGV4cG9ydHMsIGtleSwgZXhwKTtcbiAgICBpZiAoSVNfUFJPVE8gJiYgZXhwUHJvdG9ba2V5XSAhPSBvdXQpIGV4cFByb3RvW2tleV0gPSBvdXQ7XG4gIH1cbn07XG5nbG9iYWwuY29yZSA9IGNvcmU7XG4vLyB0eXBlIGJpdG1hcFxuJGV4cG9ydC5GID0gMTsgICAvLyBmb3JjZWRcbiRleHBvcnQuRyA9IDI7ICAgLy8gZ2xvYmFsXG4kZXhwb3J0LlMgPSA0OyAgIC8vIHN0YXRpY1xuJGV4cG9ydC5QID0gODsgICAvLyBwcm90b1xuJGV4cG9ydC5CID0gMTY7ICAvLyBiaW5kXG4kZXhwb3J0LlcgPSAzMjsgIC8vIHdyYXBcbiRleHBvcnQuVSA9IDY0OyAgLy8gc2FmZVxuJGV4cG9ydC5SID0gMTI4OyAvLyByZWFsIHByb3RvIG1ldGhvZCBmb3IgYGxpYnJhcnlgXG5tb2R1bGUuZXhwb3J0cyA9ICRleHBvcnQ7XG4iLCJ2YXIgTUFUQ0ggPSByZXF1aXJlKCcuL193a3MnKSgnbWF0Y2gnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEtFWSkge1xuICB2YXIgcmUgPSAvLi87XG4gIHRyeSB7XG4gICAgJy8uLydbS0VZXShyZSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0cnkge1xuICAgICAgcmVbTUFUQ0hdID0gZmFsc2U7XG4gICAgICByZXR1cm4gIScvLi8nW0tFWV0ocmUpO1xuICAgIH0gY2F0Y2ggKGYpIHsgLyogZW1wdHkgKi8gfVxuICB9IHJldHVybiB0cnVlO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGV4ZWMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gISFleGVjKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbnZhciB3a3MgPSByZXF1aXJlKCcuL193a3MnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoS0VZLCBsZW5ndGgsIGV4ZWMpIHtcbiAgdmFyIFNZTUJPTCA9IHdrcyhLRVkpO1xuICB2YXIgZm5zID0gZXhlYyhkZWZpbmVkLCBTWU1CT0wsICcnW0tFWV0pO1xuICB2YXIgc3RyZm4gPSBmbnNbMF07XG4gIHZhciByeGZuID0gZm5zWzFdO1xuICBpZiAoZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIHZhciBPID0ge307XG4gICAgT1tTWU1CT0xdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfTtcbiAgICByZXR1cm4gJydbS0VZXShPKSAhPSA3O1xuICB9KSkge1xuICAgIHJlZGVmaW5lKFN0cmluZy5wcm90b3R5cGUsIEtFWSwgc3RyZm4pO1xuICAgIGhpZGUoUmVnRXhwLnByb3RvdHlwZSwgU1lNQk9MLCBsZW5ndGggPT0gMlxuICAgICAgLy8gMjEuMi41LjggUmVnRXhwLnByb3RvdHlwZVtAQHJlcGxhY2VdKHN0cmluZywgcmVwbGFjZVZhbHVlKVxuICAgICAgLy8gMjEuMi41LjExIFJlZ0V4cC5wcm90b3R5cGVbQEBzcGxpdF0oc3RyaW5nLCBsaW1pdClcbiAgICAgID8gZnVuY3Rpb24gKHN0cmluZywgYXJnKSB7IHJldHVybiByeGZuLmNhbGwoc3RyaW5nLCB0aGlzLCBhcmcpOyB9XG4gICAgICAvLyAyMS4yLjUuNiBSZWdFeHAucHJvdG90eXBlW0BAbWF0Y2hdKHN0cmluZylcbiAgICAgIC8vIDIxLjIuNS45IFJlZ0V4cC5wcm90b3R5cGVbQEBzZWFyY2hdKHN0cmluZylcbiAgICAgIDogZnVuY3Rpb24gKHN0cmluZykgeyByZXR1cm4gcnhmbi5jYWxsKHN0cmluZywgdGhpcyk7IH1cbiAgICApO1xuICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gMjEuMi41LjMgZ2V0IFJlZ0V4cC5wcm90b3R5cGUuZmxhZ3NcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB0aGF0ID0gYW5PYmplY3QodGhpcyk7XG4gIHZhciByZXN1bHQgPSAnJztcbiAgaWYgKHRoYXQuZ2xvYmFsKSByZXN1bHQgKz0gJ2cnO1xuICBpZiAodGhhdC5pZ25vcmVDYXNlKSByZXN1bHQgKz0gJ2knO1xuICBpZiAodGhhdC5tdWx0aWxpbmUpIHJlc3VsdCArPSAnbSc7XG4gIGlmICh0aGF0LnVuaWNvZGUpIHJlc3VsdCArPSAndSc7XG4gIGlmICh0aGF0LnN0aWNreSkgcmVzdWx0ICs9ICd5JztcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL3Byb3Bvc2FsLWZsYXRNYXAvI3NlYy1GbGF0dGVuSW50b0FycmF5XG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJy4vX2lzLWFycmF5Jyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyIElTX0NPTkNBVF9TUFJFQURBQkxFID0gcmVxdWlyZSgnLi9fd2tzJykoJ2lzQ29uY2F0U3ByZWFkYWJsZScpO1xuXG5mdW5jdGlvbiBmbGF0dGVuSW50b0FycmF5KHRhcmdldCwgb3JpZ2luYWwsIHNvdXJjZSwgc291cmNlTGVuLCBzdGFydCwgZGVwdGgsIG1hcHBlciwgdGhpc0FyZykge1xuICB2YXIgdGFyZ2V0SW5kZXggPSBzdGFydDtcbiAgdmFyIHNvdXJjZUluZGV4ID0gMDtcbiAgdmFyIG1hcEZuID0gbWFwcGVyID8gY3R4KG1hcHBlciwgdGhpc0FyZywgMykgOiBmYWxzZTtcbiAgdmFyIGVsZW1lbnQsIHNwcmVhZGFibGU7XG5cbiAgd2hpbGUgKHNvdXJjZUluZGV4IDwgc291cmNlTGVuKSB7XG4gICAgaWYgKHNvdXJjZUluZGV4IGluIHNvdXJjZSkge1xuICAgICAgZWxlbWVudCA9IG1hcEZuID8gbWFwRm4oc291cmNlW3NvdXJjZUluZGV4XSwgc291cmNlSW5kZXgsIG9yaWdpbmFsKSA6IHNvdXJjZVtzb3VyY2VJbmRleF07XG5cbiAgICAgIHNwcmVhZGFibGUgPSBmYWxzZTtcbiAgICAgIGlmIChpc09iamVjdChlbGVtZW50KSkge1xuICAgICAgICBzcHJlYWRhYmxlID0gZWxlbWVudFtJU19DT05DQVRfU1BSRUFEQUJMRV07XG4gICAgICAgIHNwcmVhZGFibGUgPSBzcHJlYWRhYmxlICE9PSB1bmRlZmluZWQgPyAhIXNwcmVhZGFibGUgOiBpc0FycmF5KGVsZW1lbnQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3ByZWFkYWJsZSAmJiBkZXB0aCA+IDApIHtcbiAgICAgICAgdGFyZ2V0SW5kZXggPSBmbGF0dGVuSW50b0FycmF5KHRhcmdldCwgb3JpZ2luYWwsIGVsZW1lbnQsIHRvTGVuZ3RoKGVsZW1lbnQubGVuZ3RoKSwgdGFyZ2V0SW5kZXgsIGRlcHRoIC0gMSkgLSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRhcmdldEluZGV4ID49IDB4MWZmZmZmZmZmZmZmZmYpIHRocm93IFR5cGVFcnJvcigpO1xuICAgICAgICB0YXJnZXRbdGFyZ2V0SW5kZXhdID0gZWxlbWVudDtcbiAgICAgIH1cblxuICAgICAgdGFyZ2V0SW5kZXgrKztcbiAgICB9XG4gICAgc291cmNlSW5kZXgrKztcbiAgfVxuICByZXR1cm4gdGFyZ2V0SW5kZXg7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZmxhdHRlbkludG9BcnJheTtcbiIsInZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciBjYWxsID0gcmVxdWlyZSgnLi9faXRlci1jYWxsJyk7XG52YXIgaXNBcnJheUl0ZXIgPSByZXF1aXJlKCcuL19pcy1hcnJheS1pdGVyJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIGdldEl0ZXJGbiA9IHJlcXVpcmUoJy4vY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kJyk7XG52YXIgQlJFQUsgPSB7fTtcbnZhciBSRVRVUk4gPSB7fTtcbnZhciBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXRlcmFibGUsIGVudHJpZXMsIGZuLCB0aGF0LCBJVEVSQVRPUikge1xuICB2YXIgaXRlckZuID0gSVRFUkFUT1IgPyBmdW5jdGlvbiAoKSB7IHJldHVybiBpdGVyYWJsZTsgfSA6IGdldEl0ZXJGbihpdGVyYWJsZSk7XG4gIHZhciBmID0gY3R4KGZuLCB0aGF0LCBlbnRyaWVzID8gMiA6IDEpO1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGVuZ3RoLCBzdGVwLCBpdGVyYXRvciwgcmVzdWx0O1xuICBpZiAodHlwZW9mIGl0ZXJGbiAhPSAnZnVuY3Rpb24nKSB0aHJvdyBUeXBlRXJyb3IoaXRlcmFibGUgKyAnIGlzIG5vdCBpdGVyYWJsZSEnKTtcbiAgLy8gZmFzdCBjYXNlIGZvciBhcnJheXMgd2l0aCBkZWZhdWx0IGl0ZXJhdG9yXG4gIGlmIChpc0FycmF5SXRlcihpdGVyRm4pKSBmb3IgKGxlbmd0aCA9IHRvTGVuZ3RoKGl0ZXJhYmxlLmxlbmd0aCk7IGxlbmd0aCA+IGluZGV4OyBpbmRleCsrKSB7XG4gICAgcmVzdWx0ID0gZW50cmllcyA/IGYoYW5PYmplY3Qoc3RlcCA9IGl0ZXJhYmxlW2luZGV4XSlbMF0sIHN0ZXBbMV0pIDogZihpdGVyYWJsZVtpbmRleF0pO1xuICAgIGlmIChyZXN1bHQgPT09IEJSRUFLIHx8IHJlc3VsdCA9PT0gUkVUVVJOKSByZXR1cm4gcmVzdWx0O1xuICB9IGVsc2UgZm9yIChpdGVyYXRvciA9IGl0ZXJGbi5jYWxsKGl0ZXJhYmxlKTsgIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lOykge1xuICAgIHJlc3VsdCA9IGNhbGwoaXRlcmF0b3IsIGYsIHN0ZXAudmFsdWUsIGVudHJpZXMpO1xuICAgIGlmIChyZXN1bHQgPT09IEJSRUFLIHx8IHJlc3VsdCA9PT0gUkVUVVJOKSByZXR1cm4gcmVzdWx0O1xuICB9XG59O1xuZXhwb3J0cy5CUkVBSyA9IEJSRUFLO1xuZXhwb3J0cy5SRVRVUk4gPSBSRVRVUk47XG4iLCIvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvODYjaXNzdWVjb21tZW50LTExNTc1OTAyOFxudmFyIGdsb2JhbCA9IG1vZHVsZS5leHBvcnRzID0gdHlwZW9mIHdpbmRvdyAhPSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuTWF0aCA9PSBNYXRoXG4gID8gd2luZG93IDogdHlwZW9mIHNlbGYgIT0gJ3VuZGVmaW5lZCcgJiYgc2VsZi5NYXRoID09IE1hdGggPyBzZWxmXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuY1xuICA6IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5pZiAodHlwZW9mIF9fZyA9PSAnbnVtYmVyJykgX19nID0gZ2xvYmFsOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4iLCJ2YXIgaGFzT3duUHJvcGVydHkgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBrZXkpIHtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoaXQsIGtleSk7XG59O1xuIiwidmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG52YXIgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIGRQLmYob2JqZWN0LCBrZXksIGNyZWF0ZURlc2MoMSwgdmFsdWUpKTtcbn0gOiBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIHJldHVybiBvYmplY3Q7XG59O1xuIiwidmFyIGRvY3VtZW50ID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuZG9jdW1lbnQ7XG5tb2R1bGUuZXhwb3J0cyA9IGRvY3VtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiIsIm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlcXVpcmUoJy4vX2RvbS1jcmVhdGUnKSgnZGl2JyksICdhJywgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH0gfSkuYSAhPSA3O1xufSk7XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBzZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX3NldC1wcm90bycpLnNldDtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHRoYXQsIHRhcmdldCwgQykge1xuICB2YXIgUyA9IHRhcmdldC5jb25zdHJ1Y3RvcjtcbiAgdmFyIFA7XG4gIGlmIChTICE9PSBDICYmIHR5cGVvZiBTID09ICdmdW5jdGlvbicgJiYgKFAgPSBTLnByb3RvdHlwZSkgIT09IEMucHJvdG90eXBlICYmIGlzT2JqZWN0KFApICYmIHNldFByb3RvdHlwZU9mKSB7XG4gICAgc2V0UHJvdG90eXBlT2YodGhhdCwgUCk7XG4gIH0gcmV0dXJuIHRoYXQ7XG59O1xuIiwiLy8gZmFzdCBhcHBseSwgaHR0cDovL2pzcGVyZi5sbmtpdC5jb20vZmFzdC1hcHBseS81XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChmbiwgYXJncywgdGhhdCkge1xuICB2YXIgdW4gPSB0aGF0ID09PSB1bmRlZmluZWQ7XG4gIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICBjYXNlIDA6IHJldHVybiB1biA/IGZuKClcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCk7XG4gICAgY2FzZSAxOiByZXR1cm4gdW4gPyBmbihhcmdzWzBdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdKTtcbiAgICBjYXNlIDI6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgIGNhc2UgMzogcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgY2FzZSA0OiByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKTtcbiAgfSByZXR1cm4gZm4uYXBwbHkodGhhdCwgYXJncyk7XG59O1xuIiwiLy8gZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBhbmQgbm9uLWVudW1lcmFibGUgb2xkIFY4IHN0cmluZ3NcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0KCd6JykucHJvcGVydHlJc0VudW1lcmFibGUoMCkgPyBPYmplY3QgOiBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGNvZihpdCkgPT0gJ1N0cmluZycgPyBpdC5zcGxpdCgnJykgOiBPYmplY3QoaXQpO1xufTtcbiIsIi8vIGNoZWNrIG9uIGRlZmF1bHQgQXJyYXkgaXRlcmF0b3JcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbnZhciBJVEVSQVRPUiA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpO1xudmFyIEFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCAhPT0gdW5kZWZpbmVkICYmIChJdGVyYXRvcnMuQXJyYXkgPT09IGl0IHx8IEFycmF5UHJvdG9bSVRFUkFUT1JdID09PSBpdCk7XG59O1xuIiwiLy8gNy4yLjIgSXNBcnJheShhcmd1bWVudClcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiBpc0FycmF5KGFyZykge1xuICByZXR1cm4gY29mKGFyZykgPT0gJ0FycmF5Jztcbn07XG4iLCIvLyAyMC4xLjIuMyBOdW1iZXIuaXNJbnRlZ2VyKG51bWJlcilcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNJbnRlZ2VyKGl0KSB7XG4gIHJldHVybiAhaXNPYmplY3QoaXQpICYmIGlzRmluaXRlKGl0KSAmJiBmbG9vcihpdCkgPT09IGl0O1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0eXBlb2YgaXQgPT09ICdvYmplY3QnID8gaXQgIT09IG51bGwgOiB0eXBlb2YgaXQgPT09ICdmdW5jdGlvbic7XG59O1xuIiwiLy8gNy4yLjggSXNSZWdFeHAoYXJndW1lbnQpXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbnZhciBNQVRDSCA9IHJlcXVpcmUoJy4vX3drcycpKCdtYXRjaCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIGlzUmVnRXhwO1xuICByZXR1cm4gaXNPYmplY3QoaXQpICYmICgoaXNSZWdFeHAgPSBpdFtNQVRDSF0pICE9PSB1bmRlZmluZWQgPyAhIWlzUmVnRXhwIDogY29mKGl0KSA9PSAnUmVnRXhwJyk7XG59O1xuIiwiLy8gY2FsbCBzb21ldGhpbmcgb24gaXRlcmF0b3Igc3RlcCB3aXRoIHNhZmUgY2xvc2luZyBvbiBlcnJvclxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdGVyYXRvciwgZm4sIHZhbHVlLCBlbnRyaWVzKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGVudHJpZXMgPyBmbihhbk9iamVjdCh2YWx1ZSlbMF0sIHZhbHVlWzFdKSA6IGZuKHZhbHVlKTtcbiAgLy8gNy40LjYgSXRlcmF0b3JDbG9zZShpdGVyYXRvciwgY29tcGxldGlvbilcbiAgfSBjYXRjaCAoZSkge1xuICAgIHZhciByZXQgPSBpdGVyYXRvclsncmV0dXJuJ107XG4gICAgaWYgKHJldCAhPT0gdW5kZWZpbmVkKSBhbk9iamVjdChyZXQuY2FsbChpdGVyYXRvcikpO1xuICAgIHRocm93IGU7XG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgY3JlYXRlID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpO1xudmFyIGRlc2NyaXB0b3IgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG5cbi8vIDI1LjEuMi4xLjEgJUl0ZXJhdG9yUHJvdG90eXBlJVtAQGl0ZXJhdG9yXSgpXG5yZXF1aXJlKCcuL19oaWRlJykoSXRlcmF0b3JQcm90b3R5cGUsIHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpLCBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpIHtcbiAgQ29uc3RydWN0b3IucHJvdG90eXBlID0gY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlLCB7IG5leHQ6IGRlc2NyaXB0b3IoMSwgbmV4dCkgfSk7XG4gIHNldFRvU3RyaW5nVGFnKENvbnN0cnVjdG9yLCBOQU1FICsgJyBJdGVyYXRvcicpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBMSUJSQVJZID0gcmVxdWlyZSgnLi9fbGlicmFyeScpO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbnZhciAkaXRlckNyZWF0ZSA9IHJlcXVpcmUoJy4vX2l0ZXItY3JlYXRlJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpO1xudmFyIElURVJBVE9SID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyk7XG52YXIgQlVHR1kgPSAhKFtdLmtleXMgJiYgJ25leHQnIGluIFtdLmtleXMoKSk7IC8vIFNhZmFyaSBoYXMgYnVnZ3kgaXRlcmF0b3JzIHcvbyBgbmV4dGBcbnZhciBGRl9JVEVSQVRPUiA9ICdAQGl0ZXJhdG9yJztcbnZhciBLRVlTID0gJ2tleXMnO1xudmFyIFZBTFVFUyA9ICd2YWx1ZXMnO1xuXG52YXIgcmV0dXJuVGhpcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEJhc2UsIE5BTUUsIENvbnN0cnVjdG9yLCBuZXh0LCBERUZBVUxULCBJU19TRVQsIEZPUkNFRCkge1xuICAkaXRlckNyZWF0ZShDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCk7XG4gIHZhciBnZXRNZXRob2QgPSBmdW5jdGlvbiAoa2luZCkge1xuICAgIGlmICghQlVHR1kgJiYga2luZCBpbiBwcm90bykgcmV0dXJuIHByb3RvW2tpbmRdO1xuICAgIHN3aXRjaCAoa2luZCkge1xuICAgICAgY2FzZSBLRVlTOiByZXR1cm4gZnVuY3Rpb24ga2V5cygpIHsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgICAgIGNhc2UgVkFMVUVTOiByZXR1cm4gZnVuY3Rpb24gdmFsdWVzKCkgeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICAgIH0gcmV0dXJuIGZ1bmN0aW9uIGVudHJpZXMoKSB7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gIH07XG4gIHZhciBUQUcgPSBOQU1FICsgJyBJdGVyYXRvcic7XG4gIHZhciBERUZfVkFMVUVTID0gREVGQVVMVCA9PSBWQUxVRVM7XG4gIHZhciBWQUxVRVNfQlVHID0gZmFsc2U7XG4gIHZhciBwcm90byA9IEJhc2UucHJvdG90eXBlO1xuICB2YXIgJG5hdGl2ZSA9IHByb3RvW0lURVJBVE9SXSB8fCBwcm90b1tGRl9JVEVSQVRPUl0gfHwgREVGQVVMVCAmJiBwcm90b1tERUZBVUxUXTtcbiAgdmFyICRkZWZhdWx0ID0gJG5hdGl2ZSB8fCBnZXRNZXRob2QoREVGQVVMVCk7XG4gIHZhciAkZW50cmllcyA9IERFRkFVTFQgPyAhREVGX1ZBTFVFUyA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKCdlbnRyaWVzJykgOiB1bmRlZmluZWQ7XG4gIHZhciAkYW55TmF0aXZlID0gTkFNRSA9PSAnQXJyYXknID8gcHJvdG8uZW50cmllcyB8fCAkbmF0aXZlIDogJG5hdGl2ZTtcbiAgdmFyIG1ldGhvZHMsIGtleSwgSXRlcmF0b3JQcm90b3R5cGU7XG4gIC8vIEZpeCBuYXRpdmVcbiAgaWYgKCRhbnlOYXRpdmUpIHtcbiAgICBJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mKCRhbnlOYXRpdmUuY2FsbChuZXcgQmFzZSgpKSk7XG4gICAgaWYgKEl0ZXJhdG9yUHJvdG90eXBlICE9PSBPYmplY3QucHJvdG90eXBlICYmIEl0ZXJhdG9yUHJvdG90eXBlLm5leHQpIHtcbiAgICAgIC8vIFNldCBAQHRvU3RyaW5nVGFnIHRvIG5hdGl2ZSBpdGVyYXRvcnNcbiAgICAgIHNldFRvU3RyaW5nVGFnKEl0ZXJhdG9yUHJvdG90eXBlLCBUQUcsIHRydWUpO1xuICAgICAgLy8gZml4IGZvciBzb21lIG9sZCBlbmdpbmVzXG4gICAgICBpZiAoIUxJQlJBUlkgJiYgIWhhcyhJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IpKSBoaWRlKEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUiwgcmV0dXJuVGhpcyk7XG4gICAgfVxuICB9XG4gIC8vIGZpeCBBcnJheSN7dmFsdWVzLCBAQGl0ZXJhdG9yfS5uYW1lIGluIFY4IC8gRkZcbiAgaWYgKERFRl9WQUxVRVMgJiYgJG5hdGl2ZSAmJiAkbmF0aXZlLm5hbWUgIT09IFZBTFVFUykge1xuICAgIFZBTFVFU19CVUcgPSB0cnVlO1xuICAgICRkZWZhdWx0ID0gZnVuY3Rpb24gdmFsdWVzKCkgeyByZXR1cm4gJG5hdGl2ZS5jYWxsKHRoaXMpOyB9O1xuICB9XG4gIC8vIERlZmluZSBpdGVyYXRvclxuICBpZiAoKCFMSUJSQVJZIHx8IEZPUkNFRCkgJiYgKEJVR0dZIHx8IFZBTFVFU19CVUcgfHwgIXByb3RvW0lURVJBVE9SXSkpIHtcbiAgICBoaWRlKHByb3RvLCBJVEVSQVRPUiwgJGRlZmF1bHQpO1xuICB9XG4gIC8vIFBsdWcgZm9yIGxpYnJhcnlcbiAgSXRlcmF0b3JzW05BTUVdID0gJGRlZmF1bHQ7XG4gIEl0ZXJhdG9yc1tUQUddID0gcmV0dXJuVGhpcztcbiAgaWYgKERFRkFVTFQpIHtcbiAgICBtZXRob2RzID0ge1xuICAgICAgdmFsdWVzOiBERUZfVkFMVUVTID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoVkFMVUVTKSxcbiAgICAgIGtleXM6IElTX1NFVCA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKEtFWVMpLFxuICAgICAgZW50cmllczogJGVudHJpZXNcbiAgICB9O1xuICAgIGlmIChGT1JDRUQpIGZvciAoa2V5IGluIG1ldGhvZHMpIHtcbiAgICAgIGlmICghKGtleSBpbiBwcm90bykpIHJlZGVmaW5lKHByb3RvLCBrZXksIG1ldGhvZHNba2V5XSk7XG4gICAgfSBlbHNlICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKEJVR0dZIHx8IFZBTFVFU19CVUcpLCBOQU1FLCBtZXRob2RzKTtcbiAgfVxuICByZXR1cm4gbWV0aG9kcztcbn07XG4iLCJ2YXIgSVRFUkFUT1IgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKTtcbnZhciBTQUZFX0NMT1NJTkcgPSBmYWxzZTtcblxudHJ5IHtcbiAgdmFyIHJpdGVyID0gWzddW0lURVJBVE9SXSgpO1xuICByaXRlclsncmV0dXJuJ10gPSBmdW5jdGlvbiAoKSB7IFNBRkVfQ0xPU0lORyA9IHRydWU7IH07XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby10aHJvdy1saXRlcmFsXG4gIEFycmF5LmZyb20ocml0ZXIsIGZ1bmN0aW9uICgpIHsgdGhyb3cgMjsgfSk7XG59IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZXhlYywgc2tpcENsb3NpbmcpIHtcbiAgaWYgKCFza2lwQ2xvc2luZyAmJiAhU0FGRV9DTE9TSU5HKSByZXR1cm4gZmFsc2U7XG4gIHZhciBzYWZlID0gZmFsc2U7XG4gIHRyeSB7XG4gICAgdmFyIGFyciA9IFs3XTtcbiAgICB2YXIgaXRlciA9IGFycltJVEVSQVRPUl0oKTtcbiAgICBpdGVyLm5leHQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB7IGRvbmU6IHNhZmUgPSB0cnVlIH07IH07XG4gICAgYXJyW0lURVJBVE9SXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGl0ZXI7IH07XG4gICAgZXhlYyhhcnIpO1xuICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cbiAgcmV0dXJuIHNhZmU7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZG9uZSwgdmFsdWUpIHtcbiAgcmV0dXJuIHsgdmFsdWU6IHZhbHVlLCBkb25lOiAhIWRvbmUgfTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHt9O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmYWxzZTtcbiIsIi8vIDIwLjIuMi4xNCBNYXRoLmV4cG0xKHgpXG52YXIgJGV4cG0xID0gTWF0aC5leHBtMTtcbm1vZHVsZS5leHBvcnRzID0gKCEkZXhwbTFcbiAgLy8gT2xkIEZGIGJ1Z1xuICB8fCAkZXhwbTEoMTApID4gMjIwMjUuNDY1Nzk0ODA2NzE5IHx8ICRleHBtMSgxMCkgPCAyMjAyNS40NjU3OTQ4MDY3MTY1MTY4XG4gIC8vIFRvciBCcm93c2VyIGJ1Z1xuICB8fCAkZXhwbTEoLTJlLTE3KSAhPSAtMmUtMTdcbikgPyBmdW5jdGlvbiBleHBtMSh4KSB7XG4gIHJldHVybiAoeCA9ICt4KSA9PSAwID8geCA6IHggPiAtMWUtNiAmJiB4IDwgMWUtNiA/IHggKyB4ICogeCAvIDIgOiBNYXRoLmV4cCh4KSAtIDE7XG59IDogJGV4cG0xO1xuIiwiLy8gMjAuMi4yLjE2IE1hdGguZnJvdW5kKHgpXG52YXIgc2lnbiA9IHJlcXVpcmUoJy4vX21hdGgtc2lnbicpO1xudmFyIHBvdyA9IE1hdGgucG93O1xudmFyIEVQU0lMT04gPSBwb3coMiwgLTUyKTtcbnZhciBFUFNJTE9OMzIgPSBwb3coMiwgLTIzKTtcbnZhciBNQVgzMiA9IHBvdygyLCAxMjcpICogKDIgLSBFUFNJTE9OMzIpO1xudmFyIE1JTjMyID0gcG93KDIsIC0xMjYpO1xuXG52YXIgcm91bmRUaWVzVG9FdmVuID0gZnVuY3Rpb24gKG4pIHtcbiAgcmV0dXJuIG4gKyAxIC8gRVBTSUxPTiAtIDEgLyBFUFNJTE9OO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBNYXRoLmZyb3VuZCB8fCBmdW5jdGlvbiBmcm91bmQoeCkge1xuICB2YXIgJGFicyA9IE1hdGguYWJzKHgpO1xuICB2YXIgJHNpZ24gPSBzaWduKHgpO1xuICB2YXIgYSwgcmVzdWx0O1xuICBpZiAoJGFicyA8IE1JTjMyKSByZXR1cm4gJHNpZ24gKiByb3VuZFRpZXNUb0V2ZW4oJGFicyAvIE1JTjMyIC8gRVBTSUxPTjMyKSAqIE1JTjMyICogRVBTSUxPTjMyO1xuICBhID0gKDEgKyBFUFNJTE9OMzIgLyBFUFNJTE9OKSAqICRhYnM7XG4gIHJlc3VsdCA9IGEgLSAoYSAtICRhYnMpO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gIGlmIChyZXN1bHQgPiBNQVgzMiB8fCByZXN1bHQgIT0gcmVzdWx0KSByZXR1cm4gJHNpZ24gKiBJbmZpbml0eTtcbiAgcmV0dXJuICRzaWduICogcmVzdWx0O1xufTtcbiIsIi8vIDIwLjIuMi4yMCBNYXRoLmxvZzFwKHgpXG5tb2R1bGUuZXhwb3J0cyA9IE1hdGgubG9nMXAgfHwgZnVuY3Rpb24gbG9nMXAoeCkge1xuICByZXR1cm4gKHggPSAreCkgPiAtMWUtOCAmJiB4IDwgMWUtOCA/IHggLSB4ICogeCAvIDIgOiBNYXRoLmxvZygxICsgeCk7XG59O1xuIiwiLy8gaHR0cHM6Ly9yd2FsZHJvbi5naXRodWIuaW8vcHJvcG9zYWwtbWF0aC1leHRlbnNpb25zL1xubW9kdWxlLmV4cG9ydHMgPSBNYXRoLnNjYWxlIHx8IGZ1bmN0aW9uIHNjYWxlKHgsIGluTG93LCBpbkhpZ2gsIG91dExvdywgb3V0SGlnaCkge1xuICBpZiAoXG4gICAgYXJndW1lbnRzLmxlbmd0aCA9PT0gMFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgICAgfHwgeCAhPSB4XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgICB8fCBpbkxvdyAhPSBpbkxvd1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgICAgfHwgaW5IaWdoICE9IGluSGlnaFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgICAgfHwgb3V0TG93ICE9IG91dExvd1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgICAgfHwgb3V0SGlnaCAhPSBvdXRIaWdoXG4gICkgcmV0dXJuIE5hTjtcbiAgaWYgKHggPT09IEluZmluaXR5IHx8IHggPT09IC1JbmZpbml0eSkgcmV0dXJuIHg7XG4gIHJldHVybiAoeCAtIGluTG93KSAqIChvdXRIaWdoIC0gb3V0TG93KSAvIChpbkhpZ2ggLSBpbkxvdykgKyBvdXRMb3c7XG59O1xuIiwiLy8gMjAuMi4yLjI4IE1hdGguc2lnbih4KVxubW9kdWxlLmV4cG9ydHMgPSBNYXRoLnNpZ24gfHwgZnVuY3Rpb24gc2lnbih4KSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgcmV0dXJuICh4ID0gK3gpID09IDAgfHwgeCAhPSB4ID8geCA6IHggPCAwID8gLTEgOiAxO1xufTtcbiIsInZhciBNRVRBID0gcmVxdWlyZSgnLi9fdWlkJykoJ21ldGEnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIHNldERlc2MgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mO1xudmFyIGlkID0gMDtcbnZhciBpc0V4dGVuc2libGUgPSBPYmplY3QuaXNFeHRlbnNpYmxlIHx8IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRydWU7XG59O1xudmFyIEZSRUVaRSA9ICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGlzRXh0ZW5zaWJsZShPYmplY3QucHJldmVudEV4dGVuc2lvbnMoe30pKTtcbn0pO1xudmFyIHNldE1ldGEgPSBmdW5jdGlvbiAoaXQpIHtcbiAgc2V0RGVzYyhpdCwgTUVUQSwgeyB2YWx1ZToge1xuICAgIGk6ICdPJyArICsraWQsIC8vIG9iamVjdCBJRFxuICAgIHc6IHt9ICAgICAgICAgIC8vIHdlYWsgY29sbGVjdGlvbnMgSURzXG4gIH0gfSk7XG59O1xudmFyIGZhc3RLZXkgPSBmdW5jdGlvbiAoaXQsIGNyZWF0ZSkge1xuICAvLyByZXR1cm4gcHJpbWl0aXZlIHdpdGggcHJlZml4XG4gIGlmICghaXNPYmplY3QoaXQpKSByZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnID8gaXQgOiAodHlwZW9mIGl0ID09ICdzdHJpbmcnID8gJ1MnIDogJ1AnKSArIGl0O1xuICBpZiAoIWhhcyhpdCwgTUVUQSkpIHtcbiAgICAvLyBjYW4ndCBzZXQgbWV0YWRhdGEgdG8gdW5jYXVnaHQgZnJvemVuIG9iamVjdFxuICAgIGlmICghaXNFeHRlbnNpYmxlKGl0KSkgcmV0dXJuICdGJztcbiAgICAvLyBub3QgbmVjZXNzYXJ5IHRvIGFkZCBtZXRhZGF0YVxuICAgIGlmICghY3JlYXRlKSByZXR1cm4gJ0UnO1xuICAgIC8vIGFkZCBtaXNzaW5nIG1ldGFkYXRhXG4gICAgc2V0TWV0YShpdCk7XG4gIC8vIHJldHVybiBvYmplY3QgSURcbiAgfSByZXR1cm4gaXRbTUVUQV0uaTtcbn07XG52YXIgZ2V0V2VhayA9IGZ1bmN0aW9uIChpdCwgY3JlYXRlKSB7XG4gIGlmICghaGFzKGl0LCBNRVRBKSkge1xuICAgIC8vIGNhbid0IHNldCBtZXRhZGF0YSB0byB1bmNhdWdodCBmcm96ZW4gb2JqZWN0XG4gICAgaWYgKCFpc0V4dGVuc2libGUoaXQpKSByZXR1cm4gdHJ1ZTtcbiAgICAvLyBub3QgbmVjZXNzYXJ5IHRvIGFkZCBtZXRhZGF0YVxuICAgIGlmICghY3JlYXRlKSByZXR1cm4gZmFsc2U7XG4gICAgLy8gYWRkIG1pc3NpbmcgbWV0YWRhdGFcbiAgICBzZXRNZXRhKGl0KTtcbiAgLy8gcmV0dXJuIGhhc2ggd2VhayBjb2xsZWN0aW9ucyBJRHNcbiAgfSByZXR1cm4gaXRbTUVUQV0udztcbn07XG4vLyBhZGQgbWV0YWRhdGEgb24gZnJlZXplLWZhbWlseSBtZXRob2RzIGNhbGxpbmdcbnZhciBvbkZyZWV6ZSA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoRlJFRVpFICYmIG1ldGEuTkVFRCAmJiBpc0V4dGVuc2libGUoaXQpICYmICFoYXMoaXQsIE1FVEEpKSBzZXRNZXRhKGl0KTtcbiAgcmV0dXJuIGl0O1xufTtcbnZhciBtZXRhID0gbW9kdWxlLmV4cG9ydHMgPSB7XG4gIEtFWTogTUVUQSxcbiAgTkVFRDogZmFsc2UsXG4gIGZhc3RLZXk6IGZhc3RLZXksXG4gIGdldFdlYWs6IGdldFdlYWssXG4gIG9uRnJlZXplOiBvbkZyZWV6ZVxufTtcbiIsInZhciBNYXAgPSByZXF1aXJlKCcuL2VzNi5tYXAnKTtcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgc2hhcmVkID0gcmVxdWlyZSgnLi9fc2hhcmVkJykoJ21ldGFkYXRhJyk7XG52YXIgc3RvcmUgPSBzaGFyZWQuc3RvcmUgfHwgKHNoYXJlZC5zdG9yZSA9IG5ldyAocmVxdWlyZSgnLi9lczYud2Vhay1tYXAnKSkoKSk7XG5cbnZhciBnZXRPckNyZWF0ZU1ldGFkYXRhTWFwID0gZnVuY3Rpb24gKHRhcmdldCwgdGFyZ2V0S2V5LCBjcmVhdGUpIHtcbiAgdmFyIHRhcmdldE1ldGFkYXRhID0gc3RvcmUuZ2V0KHRhcmdldCk7XG4gIGlmICghdGFyZ2V0TWV0YWRhdGEpIHtcbiAgICBpZiAoIWNyZWF0ZSkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBzdG9yZS5zZXQodGFyZ2V0LCB0YXJnZXRNZXRhZGF0YSA9IG5ldyBNYXAoKSk7XG4gIH1cbiAgdmFyIGtleU1ldGFkYXRhID0gdGFyZ2V0TWV0YWRhdGEuZ2V0KHRhcmdldEtleSk7XG4gIGlmICgha2V5TWV0YWRhdGEpIHtcbiAgICBpZiAoIWNyZWF0ZSkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB0YXJnZXRNZXRhZGF0YS5zZXQodGFyZ2V0S2V5LCBrZXlNZXRhZGF0YSA9IG5ldyBNYXAoKSk7XG4gIH0gcmV0dXJuIGtleU1ldGFkYXRhO1xufTtcbnZhciBvcmRpbmFyeUhhc093bk1ldGFkYXRhID0gZnVuY3Rpb24gKE1ldGFkYXRhS2V5LCBPLCBQKSB7XG4gIHZhciBtZXRhZGF0YU1hcCA9IGdldE9yQ3JlYXRlTWV0YWRhdGFNYXAoTywgUCwgZmFsc2UpO1xuICByZXR1cm4gbWV0YWRhdGFNYXAgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogbWV0YWRhdGFNYXAuaGFzKE1ldGFkYXRhS2V5KTtcbn07XG52YXIgb3JkaW5hcnlHZXRPd25NZXRhZGF0YSA9IGZ1bmN0aW9uIChNZXRhZGF0YUtleSwgTywgUCkge1xuICB2YXIgbWV0YWRhdGFNYXAgPSBnZXRPckNyZWF0ZU1ldGFkYXRhTWFwKE8sIFAsIGZhbHNlKTtcbiAgcmV0dXJuIG1ldGFkYXRhTWFwID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBtZXRhZGF0YU1hcC5nZXQoTWV0YWRhdGFLZXkpO1xufTtcbnZhciBvcmRpbmFyeURlZmluZU93bk1ldGFkYXRhID0gZnVuY3Rpb24gKE1ldGFkYXRhS2V5LCBNZXRhZGF0YVZhbHVlLCBPLCBQKSB7XG4gIGdldE9yQ3JlYXRlTWV0YWRhdGFNYXAoTywgUCwgdHJ1ZSkuc2V0KE1ldGFkYXRhS2V5LCBNZXRhZGF0YVZhbHVlKTtcbn07XG52YXIgb3JkaW5hcnlPd25NZXRhZGF0YUtleXMgPSBmdW5jdGlvbiAodGFyZ2V0LCB0YXJnZXRLZXkpIHtcbiAgdmFyIG1ldGFkYXRhTWFwID0gZ2V0T3JDcmVhdGVNZXRhZGF0YU1hcCh0YXJnZXQsIHRhcmdldEtleSwgZmFsc2UpO1xuICB2YXIga2V5cyA9IFtdO1xuICBpZiAobWV0YWRhdGFNYXApIG1ldGFkYXRhTWFwLmZvckVhY2goZnVuY3Rpb24gKF8sIGtleSkgeyBrZXlzLnB1c2goa2V5KTsgfSk7XG4gIHJldHVybiBrZXlzO1xufTtcbnZhciB0b01ldGFLZXkgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGl0ID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIGl0ID09ICdzeW1ib2wnID8gaXQgOiBTdHJpbmcoaXQpO1xufTtcbnZhciBleHAgPSBmdW5jdGlvbiAoTykge1xuICAkZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCBPKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzdG9yZTogc3RvcmUsXG4gIG1hcDogZ2V0T3JDcmVhdGVNZXRhZGF0YU1hcCxcbiAgaGFzOiBvcmRpbmFyeUhhc093bk1ldGFkYXRhLFxuICBnZXQ6IG9yZGluYXJ5R2V0T3duTWV0YWRhdGEsXG4gIHNldDogb3JkaW5hcnlEZWZpbmVPd25NZXRhZGF0YSxcbiAga2V5czogb3JkaW5hcnlPd25NZXRhZGF0YUtleXMsXG4gIGtleTogdG9NZXRhS2V5LFxuICBleHA6IGV4cFxufTtcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBtYWNyb3Rhc2sgPSByZXF1aXJlKCcuL190YXNrJykuc2V0O1xudmFyIE9ic2VydmVyID0gZ2xvYmFsLk11dGF0aW9uT2JzZXJ2ZXIgfHwgZ2xvYmFsLldlYktpdE11dGF0aW9uT2JzZXJ2ZXI7XG52YXIgcHJvY2VzcyA9IGdsb2JhbC5wcm9jZXNzO1xudmFyIFByb21pc2UgPSBnbG9iYWwuUHJvbWlzZTtcbnZhciBpc05vZGUgPSByZXF1aXJlKCcuL19jb2YnKShwcm9jZXNzKSA9PSAncHJvY2Vzcyc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaGVhZCwgbGFzdCwgbm90aWZ5O1xuXG4gIHZhciBmbHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcGFyZW50LCBmbjtcbiAgICBpZiAoaXNOb2RlICYmIChwYXJlbnQgPSBwcm9jZXNzLmRvbWFpbikpIHBhcmVudC5leGl0KCk7XG4gICAgd2hpbGUgKGhlYWQpIHtcbiAgICAgIGZuID0gaGVhZC5mbjtcbiAgICAgIGhlYWQgPSBoZWFkLm5leHQ7XG4gICAgICB0cnkge1xuICAgICAgICBmbigpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoaGVhZCkgbm90aWZ5KCk7XG4gICAgICAgIGVsc2UgbGFzdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9IGxhc3QgPSB1bmRlZmluZWQ7XG4gICAgaWYgKHBhcmVudCkgcGFyZW50LmVudGVyKCk7XG4gIH07XG5cbiAgLy8gTm9kZS5qc1xuICBpZiAoaXNOb2RlKSB7XG4gICAgbm90aWZ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhmbHVzaCk7XG4gICAgfTtcbiAgLy8gYnJvd3NlcnMgd2l0aCBNdXRhdGlvbk9ic2VydmVyXG4gIH0gZWxzZSBpZiAoT2JzZXJ2ZXIpIHtcbiAgICB2YXIgdG9nZ2xlID0gdHJ1ZTtcbiAgICB2YXIgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnKTtcbiAgICBuZXcgT2JzZXJ2ZXIoZmx1c2gpLm9ic2VydmUobm9kZSwgeyBjaGFyYWN0ZXJEYXRhOiB0cnVlIH0pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIG5vZGUuZGF0YSA9IHRvZ2dsZSA9ICF0b2dnbGU7XG4gICAgfTtcbiAgLy8gZW52aXJvbm1lbnRzIHdpdGggbWF5YmUgbm9uLWNvbXBsZXRlbHkgY29ycmVjdCwgYnV0IGV4aXN0ZW50IFByb21pc2VcbiAgfSBlbHNlIGlmIChQcm9taXNlICYmIFByb21pc2UucmVzb2x2ZSkge1xuICAgIHZhciBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgbm90aWZ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcHJvbWlzZS50aGVuKGZsdXNoKTtcbiAgICB9O1xuICAvLyBmb3Igb3RoZXIgZW52aXJvbm1lbnRzIC0gbWFjcm90YXNrIGJhc2VkIG9uOlxuICAvLyAtIHNldEltbWVkaWF0ZVxuICAvLyAtIE1lc3NhZ2VDaGFubmVsXG4gIC8vIC0gd2luZG93LnBvc3RNZXNzYWdcbiAgLy8gLSBvbnJlYWR5c3RhdGVjaGFuZ2VcbiAgLy8gLSBzZXRUaW1lb3V0XG4gIH0gZWxzZSB7XG4gICAgbm90aWZ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgLy8gc3RyYW5nZSBJRSArIHdlYnBhY2sgZGV2IHNlcnZlciBidWcgLSB1c2UgLmNhbGwoZ2xvYmFsKVxuICAgICAgbWFjcm90YXNrLmNhbGwoZ2xvYmFsLCBmbHVzaCk7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoZm4pIHtcbiAgICB2YXIgdGFzayA9IHsgZm46IGZuLCBuZXh0OiB1bmRlZmluZWQgfTtcbiAgICBpZiAobGFzdCkgbGFzdC5uZXh0ID0gdGFzaztcbiAgICBpZiAoIWhlYWQpIHtcbiAgICAgIGhlYWQgPSB0YXNrO1xuICAgICAgbm90aWZ5KCk7XG4gICAgfSBsYXN0ID0gdGFzaztcbiAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG4vLyAyNS40LjEuNSBOZXdQcm9taXNlQ2FwYWJpbGl0eShDKVxudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcblxuZnVuY3Rpb24gUHJvbWlzZUNhcGFiaWxpdHkoQykge1xuICB2YXIgcmVzb2x2ZSwgcmVqZWN0O1xuICB0aGlzLnByb21pc2UgPSBuZXcgQyhmdW5jdGlvbiAoJCRyZXNvbHZlLCAkJHJlamVjdCkge1xuICAgIGlmIChyZXNvbHZlICE9PSB1bmRlZmluZWQgfHwgcmVqZWN0ICE9PSB1bmRlZmluZWQpIHRocm93IFR5cGVFcnJvcignQmFkIFByb21pc2UgY29uc3RydWN0b3InKTtcbiAgICByZXNvbHZlID0gJCRyZXNvbHZlO1xuICAgIHJlamVjdCA9ICQkcmVqZWN0O1xuICB9KTtcbiAgdGhpcy5yZXNvbHZlID0gYUZ1bmN0aW9uKHJlc29sdmUpO1xuICB0aGlzLnJlamVjdCA9IGFGdW5jdGlvbihyZWplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cy5mID0gZnVuY3Rpb24gKEMpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlQ2FwYWJpbGl0eShDKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG4vLyAxOS4xLjIuMSBPYmplY3QuYXNzaWduKHRhcmdldCwgc291cmNlLCAuLi4pXG52YXIgZ2V0S2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG52YXIgZ09QUyA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BzJyk7XG52YXIgcElFID0gcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgSU9iamVjdCA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKTtcbnZhciAkYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcblxuLy8gc2hvdWxkIHdvcmsgd2l0aCBzeW1ib2xzIGFuZCBzaG91bGQgaGF2ZSBkZXRlcm1pbmlzdGljIHByb3BlcnR5IG9yZGVyIChWOCBidWcpXG5tb2R1bGUuZXhwb3J0cyA9ICEkYXNzaWduIHx8IHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICB2YXIgQSA9IHt9O1xuICB2YXIgQiA9IHt9O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgdmFyIFMgPSBTeW1ib2woKTtcbiAgdmFyIEsgPSAnYWJjZGVmZ2hpamtsbW5vcHFyc3QnO1xuICBBW1NdID0gNztcbiAgSy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAoaykgeyBCW2tdID0gazsgfSk7XG4gIHJldHVybiAkYXNzaWduKHt9LCBBKVtTXSAhPSA3IHx8IE9iamVjdC5rZXlzKCRhc3NpZ24oe30sIEIpKS5qb2luKCcnKSAhPSBLO1xufSkgPyBmdW5jdGlvbiBhc3NpZ24odGFyZ2V0LCBzb3VyY2UpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICB2YXIgVCA9IHRvT2JqZWN0KHRhcmdldCk7XG4gIHZhciBhTGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgdmFyIGluZGV4ID0gMTtcbiAgdmFyIGdldFN5bWJvbHMgPSBnT1BTLmY7XG4gIHZhciBpc0VudW0gPSBwSUUuZjtcbiAgd2hpbGUgKGFMZW4gPiBpbmRleCkge1xuICAgIHZhciBTID0gSU9iamVjdChhcmd1bWVudHNbaW5kZXgrK10pO1xuICAgIHZhciBrZXlzID0gZ2V0U3ltYm9scyA/IGdldEtleXMoUykuY29uY2F0KGdldFN5bWJvbHMoUykpIDogZ2V0S2V5cyhTKTtcbiAgICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgdmFyIGogPSAwO1xuICAgIHZhciBrZXk7XG4gICAgd2hpbGUgKGxlbmd0aCA+IGopIGlmIChpc0VudW0uY2FsbChTLCBrZXkgPSBrZXlzW2orK10pKSBUW2tleV0gPSBTW2tleV07XG4gIH0gcmV0dXJuIFQ7XG59IDogJGFzc2lnbjtcbiIsIi8vIDE5LjEuMi4yIC8gMTUuMi4zLjUgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgZFBzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwcycpO1xudmFyIGVudW1CdWdLZXlzID0gcmVxdWlyZSgnLi9fZW51bS1idWcta2V5cycpO1xudmFyIElFX1BST1RPID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpO1xudmFyIEVtcHR5ID0gZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9O1xudmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xuXG4vLyBDcmVhdGUgb2JqZWN0IHdpdGggZmFrZSBgbnVsbGAgcHJvdG90eXBlOiB1c2UgaWZyYW1lIE9iamVjdCB3aXRoIGNsZWFyZWQgcHJvdG90eXBlXG52YXIgY3JlYXRlRGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gVGhyYXNoLCB3YXN0ZSBhbmQgc29kb215OiBJRSBHQyBidWdcbiAgdmFyIGlmcmFtZSA9IHJlcXVpcmUoJy4vX2RvbS1jcmVhdGUnKSgnaWZyYW1lJyk7XG4gIHZhciBpID0gZW51bUJ1Z0tleXMubGVuZ3RoO1xuICB2YXIgbHQgPSAnPCc7XG4gIHZhciBndCA9ICc+JztcbiAgdmFyIGlmcmFtZURvY3VtZW50O1xuICBpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgcmVxdWlyZSgnLi9faHRtbCcpLmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gIGlmcmFtZS5zcmMgPSAnamF2YXNjcmlwdDonOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNjcmlwdC11cmxcbiAgLy8gY3JlYXRlRGljdCA9IGlmcmFtZS5jb250ZW50V2luZG93Lk9iamVjdDtcbiAgLy8gaHRtbC5yZW1vdmVDaGlsZChpZnJhbWUpO1xuICBpZnJhbWVEb2N1bWVudCA9IGlmcmFtZS5jb250ZW50V2luZG93LmRvY3VtZW50O1xuICBpZnJhbWVEb2N1bWVudC5vcGVuKCk7XG4gIGlmcmFtZURvY3VtZW50LndyaXRlKGx0ICsgJ3NjcmlwdCcgKyBndCArICdkb2N1bWVudC5GPU9iamVjdCcgKyBsdCArICcvc2NyaXB0JyArIGd0KTtcbiAgaWZyYW1lRG9jdW1lbnQuY2xvc2UoKTtcbiAgY3JlYXRlRGljdCA9IGlmcmFtZURvY3VtZW50LkY7XG4gIHdoaWxlIChpLS0pIGRlbGV0ZSBjcmVhdGVEaWN0W1BST1RPVFlQRV1bZW51bUJ1Z0tleXNbaV1dO1xuICByZXR1cm4gY3JlYXRlRGljdCgpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuY3JlYXRlIHx8IGZ1bmN0aW9uIGNyZWF0ZShPLCBQcm9wZXJ0aWVzKSB7XG4gIHZhciByZXN1bHQ7XG4gIGlmIChPICE9PSBudWxsKSB7XG4gICAgRW1wdHlbUFJPVE9UWVBFXSA9IGFuT2JqZWN0KE8pO1xuICAgIHJlc3VsdCA9IG5ldyBFbXB0eSgpO1xuICAgIEVtcHR5W1BST1RPVFlQRV0gPSBudWxsO1xuICAgIC8vIGFkZCBcIl9fcHJvdG9fX1wiIGZvciBPYmplY3QuZ2V0UHJvdG90eXBlT2YgcG9seWZpbGxcbiAgICByZXN1bHRbSUVfUFJPVE9dID0gTztcbiAgfSBlbHNlIHJlc3VsdCA9IGNyZWF0ZURpY3QoKTtcbiAgcmV0dXJuIFByb3BlcnRpZXMgPT09IHVuZGVmaW5lZCA/IHJlc3VsdCA6IGRQcyhyZXN1bHQsIFByb3BlcnRpZXMpO1xufTtcbiIsInZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIElFOF9ET01fREVGSU5FID0gcmVxdWlyZSgnLi9faWU4LWRvbS1kZWZpbmUnKTtcbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpO1xudmFyIGRQID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG5leHBvcnRzLmYgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gT2JqZWN0LmRlZmluZVByb3BlcnR5IDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcykge1xuICBhbk9iamVjdChPKTtcbiAgUCA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuICBhbk9iamVjdChBdHRyaWJ1dGVzKTtcbiAgaWYgKElFOF9ET01fREVGSU5FKSB0cnkge1xuICAgIHJldHVybiBkUChPLCBQLCBBdHRyaWJ1dGVzKTtcbiAgfSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG4gIGlmICgnZ2V0JyBpbiBBdHRyaWJ1dGVzIHx8ICdzZXQnIGluIEF0dHJpYnV0ZXMpIHRocm93IFR5cGVFcnJvcignQWNjZXNzb3JzIG5vdCBzdXBwb3J0ZWQhJyk7XG4gIGlmICgndmFsdWUnIGluIEF0dHJpYnV0ZXMpIE9bUF0gPSBBdHRyaWJ1dGVzLnZhbHVlO1xuICByZXR1cm4gTztcbn07XG4iLCJ2YXIgZFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGdldEtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcykge1xuICBhbk9iamVjdChPKTtcbiAgdmFyIGtleXMgPSBnZXRLZXlzKFByb3BlcnRpZXMpO1xuICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gIHZhciBpID0gMDtcbiAgdmFyIFA7XG4gIHdoaWxlIChsZW5ndGggPiBpKSBkUC5mKE8sIFAgPSBrZXlzW2krK10sIFByb3BlcnRpZXNbUF0pO1xuICByZXR1cm4gTztcbn07XG4iLCIndXNlIHN0cmljdCc7XG4vLyBGb3JjZWQgcmVwbGFjZW1lbnQgcHJvdG90eXBlIGFjY2Vzc29ycyBtZXRob2RzXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2xpYnJhcnknKSB8fCAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHZhciBLID0gTWF0aC5yYW5kb20oKTtcbiAgLy8gSW4gRkYgdGhyb3dzIG9ubHkgZGVmaW5lIG1ldGhvZHNcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmLCBuby11c2VsZXNzLWNhbGxcbiAgX19kZWZpbmVTZXR0ZXJfXy5jYWxsKG51bGwsIEssIGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSk7XG4gIGRlbGV0ZSByZXF1aXJlKCcuL19nbG9iYWwnKVtLXTtcbn0pO1xuIiwidmFyIHBJRSA9IHJlcXVpcmUoJy4vX29iamVjdC1waWUnKTtcbnZhciBjcmVhdGVEZXNjID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIElFOF9ET01fREVGSU5FID0gcmVxdWlyZSgnLi9faWU4LWRvbS1kZWZpbmUnKTtcbnZhciBnT1BEID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxuZXhwb3J0cy5mID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IGdPUEQgOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUCkge1xuICBPID0gdG9JT2JqZWN0KE8pO1xuICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gIGlmIChJRThfRE9NX0RFRklORSkgdHJ5IHtcbiAgICByZXR1cm4gZ09QRChPLCBQKTtcbiAgfSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG4gIGlmIChoYXMoTywgUCkpIHJldHVybiBjcmVhdGVEZXNjKCFwSUUuZi5jYWxsKE8sIFApLCBPW1BdKTtcbn07XG4iLCIvLyBmYWxsYmFjayBmb3IgSUUxMSBidWdneSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB3aXRoIGlmcmFtZSBhbmQgd2luZG93XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIGdPUE4gPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbicpLmY7XG52YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxudmFyIHdpbmRvd05hbWVzID0gdHlwZW9mIHdpbmRvdyA9PSAnb2JqZWN0JyAmJiB3aW5kb3cgJiYgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXNcbiAgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh3aW5kb3cpIDogW107XG5cbnZhciBnZXRXaW5kb3dOYW1lcyA9IGZ1bmN0aW9uIChpdCkge1xuICB0cnkge1xuICAgIHJldHVybiBnT1BOKGl0KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiB3aW5kb3dOYW1lcy5zbGljZSgpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5mID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhpdCkge1xuICByZXR1cm4gd2luZG93TmFtZXMgJiYgdG9TdHJpbmcuY2FsbChpdCkgPT0gJ1tvYmplY3QgV2luZG93XScgPyBnZXRXaW5kb3dOYW1lcyhpdCkgOiBnT1BOKHRvSU9iamVjdChpdCkpO1xufTtcbiIsIi8vIDE5LjEuMi43IC8gMTUuMi4zLjQgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTylcbnZhciAka2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzLWludGVybmFsJyk7XG52YXIgaGlkZGVuS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKS5jb25jYXQoJ2xlbmd0aCcsICdwcm90b3R5cGUnKTtcblxuZXhwb3J0cy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgfHwgZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhPKSB7XG4gIHJldHVybiAka2V5cyhPLCBoaWRkZW5LZXlzKTtcbn07XG4iLCJleHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuIiwiLy8gMTkuMS4yLjkgLyAxNS4yLjMuMiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTylcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyIElFX1BST1RPID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpO1xudmFyIE9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gKE8pIHtcbiAgTyA9IHRvT2JqZWN0KE8pO1xuICBpZiAoaGFzKE8sIElFX1BST1RPKSkgcmV0dXJuIE9bSUVfUFJPVE9dO1xuICBpZiAodHlwZW9mIE8uY29uc3RydWN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBPIGluc3RhbmNlb2YgTy5jb25zdHJ1Y3Rvcikge1xuICAgIHJldHVybiBPLmNvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgfSByZXR1cm4gTyBpbnN0YW5jZW9mIE9iamVjdCA/IE9iamVjdFByb3RvIDogbnVsbDtcbn07XG4iLCJ2YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIGFycmF5SW5kZXhPZiA9IHJlcXVpcmUoJy4vX2FycmF5LWluY2x1ZGVzJykoZmFsc2UpO1xudmFyIElFX1BST1RPID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWVzKSB7XG4gIHZhciBPID0gdG9JT2JqZWN0KG9iamVjdCk7XG4gIHZhciBpID0gMDtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIga2V5O1xuICBmb3IgKGtleSBpbiBPKSBpZiAoa2V5ICE9IElFX1BST1RPKSBoYXMoTywga2V5KSAmJiByZXN1bHQucHVzaChrZXkpO1xuICAvLyBEb24ndCBlbnVtIGJ1ZyAmIGhpZGRlbiBrZXlzXG4gIHdoaWxlIChuYW1lcy5sZW5ndGggPiBpKSBpZiAoaGFzKE8sIGtleSA9IG5hbWVzW2krK10pKSB7XG4gICAgfmFycmF5SW5kZXhPZihyZXN1bHQsIGtleSkgfHwgcmVzdWx0LnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcbiIsIi8vIDE5LjEuMi4xNCAvIDE1LjIuMy4xNCBPYmplY3Qua2V5cyhPKVxudmFyICRrZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMtaW50ZXJuYWwnKTtcbnZhciBlbnVtQnVnS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiBrZXlzKE8pIHtcbiAgcmV0dXJuICRrZXlzKE8sIGVudW1CdWdLZXlzKTtcbn07XG4iLCJleHBvcnRzLmYgPSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbiIsIi8vIG1vc3QgT2JqZWN0IG1ldGhvZHMgYnkgRVM2IHNob3VsZCBhY2NlcHQgcHJpbWl0aXZlc1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBjb3JlID0gcmVxdWlyZSgnLi9fY29yZScpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEtFWSwgZXhlYykge1xuICB2YXIgZm4gPSAoY29yZS5PYmplY3QgfHwge30pW0tFWV0gfHwgT2JqZWN0W0tFWV07XG4gIHZhciBleHAgPSB7fTtcbiAgZXhwW0tFWV0gPSBleGVjKGZuKTtcbiAgJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiBmYWlscyhmdW5jdGlvbiAoKSB7IGZuKDEpOyB9KSwgJ09iamVjdCcsIGV4cCk7XG59O1xuIiwidmFyIGdldEtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciBpc0VudW0gPSByZXF1aXJlKCcuL19vYmplY3QtcGllJykuZjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGlzRW50cmllcykge1xuICByZXR1cm4gZnVuY3Rpb24gKGl0KSB7XG4gICAgdmFyIE8gPSB0b0lPYmplY3QoaXQpO1xuICAgIHZhciBrZXlzID0gZ2V0S2V5cyhPKTtcbiAgICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIga2V5O1xuICAgIHdoaWxlIChsZW5ndGggPiBpKSBpZiAoaXNFbnVtLmNhbGwoTywga2V5ID0ga2V5c1tpKytdKSkge1xuICAgICAgcmVzdWx0LnB1c2goaXNFbnRyaWVzID8gW2tleSwgT1trZXldXSA6IE9ba2V5XSk7XG4gICAgfSByZXR1cm4gcmVzdWx0O1xuICB9O1xufTtcbiIsIi8vIGFsbCBvYmplY3Qga2V5cywgaW5jbHVkZXMgbm9uLWVudW1lcmFibGUgYW5kIHN5bWJvbHNcbnZhciBnT1BOID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKTtcbnZhciBnT1BTID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcHMnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIFJlZmxlY3QgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5SZWZsZWN0O1xubW9kdWxlLmV4cG9ydHMgPSBSZWZsZWN0ICYmIFJlZmxlY3Qub3duS2V5cyB8fCBmdW5jdGlvbiBvd25LZXlzKGl0KSB7XG4gIHZhciBrZXlzID0gZ09QTi5mKGFuT2JqZWN0KGl0KSk7XG4gIHZhciBnZXRTeW1ib2xzID0gZ09QUy5mO1xuICByZXR1cm4gZ2V0U3ltYm9scyA/IGtleXMuY29uY2F0KGdldFN5bWJvbHMoaXQpKSA6IGtleXM7XG59O1xuIiwidmFyICRwYXJzZUZsb2F0ID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykucGFyc2VGbG9hdDtcbnZhciAkdHJpbSA9IHJlcXVpcmUoJy4vX3N0cmluZy10cmltJykudHJpbTtcblxubW9kdWxlLmV4cG9ydHMgPSAxIC8gJHBhcnNlRmxvYXQocmVxdWlyZSgnLi9fc3RyaW5nLXdzJykgKyAnLTAnKSAhPT0gLUluZmluaXR5ID8gZnVuY3Rpb24gcGFyc2VGbG9hdChzdHIpIHtcbiAgdmFyIHN0cmluZyA9ICR0cmltKFN0cmluZyhzdHIpLCAzKTtcbiAgdmFyIHJlc3VsdCA9ICRwYXJzZUZsb2F0KHN0cmluZyk7XG4gIHJldHVybiByZXN1bHQgPT09IDAgJiYgc3RyaW5nLmNoYXJBdCgwKSA9PSAnLScgPyAtMCA6IHJlc3VsdDtcbn0gOiAkcGFyc2VGbG9hdDtcbiIsInZhciAkcGFyc2VJbnQgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5wYXJzZUludDtcbnZhciAkdHJpbSA9IHJlcXVpcmUoJy4vX3N0cmluZy10cmltJykudHJpbTtcbnZhciB3cyA9IHJlcXVpcmUoJy4vX3N0cmluZy13cycpO1xudmFyIGhleCA9IC9eWy0rXT8wW3hYXS87XG5cbm1vZHVsZS5leHBvcnRzID0gJHBhcnNlSW50KHdzICsgJzA4JykgIT09IDggfHwgJHBhcnNlSW50KHdzICsgJzB4MTYnKSAhPT0gMjIgPyBmdW5jdGlvbiBwYXJzZUludChzdHIsIHJhZGl4KSB7XG4gIHZhciBzdHJpbmcgPSAkdHJpbShTdHJpbmcoc3RyKSwgMyk7XG4gIHJldHVybiAkcGFyc2VJbnQoc3RyaW5nLCAocmFkaXggPj4+IDApIHx8IChoZXgudGVzdChzdHJpbmcpID8gMTYgOiAxMCkpO1xufSA6ICRwYXJzZUludDtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGV4ZWMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4geyBlOiBmYWxzZSwgdjogZXhlYygpIH07XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4geyBlOiB0cnVlLCB2OiBlIH07XG4gIH1cbn07XG4iLCJ2YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5ID0gcmVxdWlyZSgnLi9fbmV3LXByb21pc2UtY2FwYWJpbGl0eScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChDLCB4KSB7XG4gIGFuT2JqZWN0KEMpO1xuICBpZiAoaXNPYmplY3QoeCkgJiYgeC5jb25zdHJ1Y3RvciA9PT0gQykgcmV0dXJuIHg7XG4gIHZhciBwcm9taXNlQ2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5LmYoQyk7XG4gIHZhciByZXNvbHZlID0gcHJvbWlzZUNhcGFiaWxpdHkucmVzb2x2ZTtcbiAgcmVzb2x2ZSh4KTtcbiAgcmV0dXJuIHByb21pc2VDYXBhYmlsaXR5LnByb21pc2U7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYml0bWFwLCB2YWx1ZSkge1xuICByZXR1cm4ge1xuICAgIGVudW1lcmFibGU6ICEoYml0bWFwICYgMSksXG4gICAgY29uZmlndXJhYmxlOiAhKGJpdG1hcCAmIDIpLFxuICAgIHdyaXRhYmxlOiAhKGJpdG1hcCAmIDQpLFxuICAgIHZhbHVlOiB2YWx1ZVxuICB9O1xufTtcbiIsInZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh0YXJnZXQsIHNyYywgc2FmZSkge1xuICBmb3IgKHZhciBrZXkgaW4gc3JjKSByZWRlZmluZSh0YXJnZXQsIGtleSwgc3JjW2tleV0sIHNhZmUpO1xuICByZXR1cm4gdGFyZ2V0O1xufTtcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIFNSQyA9IHJlcXVpcmUoJy4vX3VpZCcpKCdzcmMnKTtcbnZhciBUT19TVFJJTkcgPSAndG9TdHJpbmcnO1xudmFyICR0b1N0cmluZyA9IEZ1bmN0aW9uW1RPX1NUUklOR107XG52YXIgVFBMID0gKCcnICsgJHRvU3RyaW5nKS5zcGxpdChUT19TVFJJTkcpO1xuXG5yZXF1aXJlKCcuL19jb3JlJykuaW5zcGVjdFNvdXJjZSA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gJHRvU3RyaW5nLmNhbGwoaXQpO1xufTtcblxuKG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE8sIGtleSwgdmFsLCBzYWZlKSB7XG4gIHZhciBpc0Z1bmN0aW9uID0gdHlwZW9mIHZhbCA9PSAnZnVuY3Rpb24nO1xuICBpZiAoaXNGdW5jdGlvbikgaGFzKHZhbCwgJ25hbWUnKSB8fCBoaWRlKHZhbCwgJ25hbWUnLCBrZXkpO1xuICBpZiAoT1trZXldID09PSB2YWwpIHJldHVybjtcbiAgaWYgKGlzRnVuY3Rpb24pIGhhcyh2YWwsIFNSQykgfHwgaGlkZSh2YWwsIFNSQywgT1trZXldID8gJycgKyBPW2tleV0gOiBUUEwuam9pbihTdHJpbmcoa2V5KSkpO1xuICBpZiAoTyA9PT0gZ2xvYmFsKSB7XG4gICAgT1trZXldID0gdmFsO1xuICB9IGVsc2UgaWYgKCFzYWZlKSB7XG4gICAgZGVsZXRlIE9ba2V5XTtcbiAgICBoaWRlKE8sIGtleSwgdmFsKTtcbiAgfSBlbHNlIGlmIChPW2tleV0pIHtcbiAgICBPW2tleV0gPSB2YWw7XG4gIH0gZWxzZSB7XG4gICAgaGlkZShPLCBrZXksIHZhbCk7XG4gIH1cbi8vIGFkZCBmYWtlIEZ1bmN0aW9uI3RvU3RyaW5nIGZvciBjb3JyZWN0IHdvcmsgd3JhcHBlZCBtZXRob2RzIC8gY29uc3RydWN0b3JzIHdpdGggbWV0aG9kcyBsaWtlIExvRGFzaCBpc05hdGl2ZVxufSkoRnVuY3Rpb24ucHJvdG90eXBlLCBUT19TVFJJTkcsIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICByZXR1cm4gdHlwZW9mIHRoaXMgPT0gJ2Z1bmN0aW9uJyAmJiB0aGlzW1NSQ10gfHwgJHRvU3RyaW5nLmNhbGwodGhpcyk7XG59KTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHJlZ0V4cCwgcmVwbGFjZSkge1xuICB2YXIgcmVwbGFjZXIgPSByZXBsYWNlID09PSBPYmplY3QocmVwbGFjZSkgPyBmdW5jdGlvbiAocGFydCkge1xuICAgIHJldHVybiByZXBsYWNlW3BhcnRdO1xuICB9IDogcmVwbGFjZTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiBTdHJpbmcoaXQpLnJlcGxhY2UocmVnRXhwLCByZXBsYWNlcik7XG4gIH07XG59O1xuIiwiLy8gNy4yLjkgU2FtZVZhbHVlKHgsIHkpXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5pcyB8fCBmdW5jdGlvbiBpcyh4LCB5KSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgcmV0dXJuIHggPT09IHkgPyB4ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geSA6IHggIT0geCAmJiB5ICE9IHk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9wcm9wb3NhbC1zZXRtYXAtb2Zmcm9tL1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG52YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG52YXIgZm9yT2YgPSByZXF1aXJlKCcuL19mb3Itb2YnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQ09MTEVDVElPTikge1xuICAkZXhwb3J0KCRleHBvcnQuUywgQ09MTEVDVElPTiwgeyBmcm9tOiBmdW5jdGlvbiBmcm9tKHNvdXJjZSAvKiAsIG1hcEZuLCB0aGlzQXJnICovKSB7XG4gICAgdmFyIG1hcEZuID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBtYXBwaW5nLCBBLCBuLCBjYjtcbiAgICBhRnVuY3Rpb24odGhpcyk7XG4gICAgbWFwcGluZyA9IG1hcEZuICE9PSB1bmRlZmluZWQ7XG4gICAgaWYgKG1hcHBpbmcpIGFGdW5jdGlvbihtYXBGbik7XG4gICAgaWYgKHNvdXJjZSA9PSB1bmRlZmluZWQpIHJldHVybiBuZXcgdGhpcygpO1xuICAgIEEgPSBbXTtcbiAgICBpZiAobWFwcGluZykge1xuICAgICAgbiA9IDA7XG4gICAgICBjYiA9IGN0eChtYXBGbiwgYXJndW1lbnRzWzJdLCAyKTtcbiAgICAgIGZvck9mKHNvdXJjZSwgZmFsc2UsIGZ1bmN0aW9uIChuZXh0SXRlbSkge1xuICAgICAgICBBLnB1c2goY2IobmV4dEl0ZW0sIG4rKykpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvck9mKHNvdXJjZSwgZmFsc2UsIEEucHVzaCwgQSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgdGhpcyhBKTtcbiAgfSB9KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL3Byb3Bvc2FsLXNldG1hcC1vZmZyb20vXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChDT0xMRUNUSU9OKSB7XG4gICRleHBvcnQoJGV4cG9ydC5TLCBDT0xMRUNUSU9OLCB7IG9mOiBmdW5jdGlvbiBvZigpIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgQSA9IEFycmF5KGxlbmd0aCk7XG4gICAgd2hpbGUgKGxlbmd0aC0tKSBBW2xlbmd0aF0gPSBhcmd1bWVudHNbbGVuZ3RoXTtcbiAgICByZXR1cm4gbmV3IHRoaXMoQSk7XG4gIH0gfSk7XG59O1xuIiwiLy8gV29ya3Mgd2l0aCBfX3Byb3RvX18gb25seS4gT2xkIHY4IGNhbid0IHdvcmsgd2l0aCBudWxsIHByb3RvIG9iamVjdHMuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBjaGVjayA9IGZ1bmN0aW9uIChPLCBwcm90bykge1xuICBhbk9iamVjdChPKTtcbiAgaWYgKCFpc09iamVjdChwcm90bykgJiYgcHJvdG8gIT09IG51bGwpIHRocm93IFR5cGVFcnJvcihwcm90byArIFwiOiBjYW4ndCBzZXQgYXMgcHJvdG90eXBlIVwiKTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2V0OiBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgKCdfX3Byb3RvX18nIGluIHt9ID8gLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIGZ1bmN0aW9uICh0ZXN0LCBidWdneSwgc2V0KSB7XG4gICAgICB0cnkge1xuICAgICAgICBzZXQgPSByZXF1aXJlKCcuL19jdHgnKShGdW5jdGlvbi5jYWxsLCByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpLmYoT2JqZWN0LnByb3RvdHlwZSwgJ19fcHJvdG9fXycpLnNldCwgMik7XG4gICAgICAgIHNldCh0ZXN0LCBbXSk7XG4gICAgICAgIGJ1Z2d5ID0gISh0ZXN0IGluc3RhbmNlb2YgQXJyYXkpO1xuICAgICAgfSBjYXRjaCAoZSkgeyBidWdneSA9IHRydWU7IH1cbiAgICAgIHJldHVybiBmdW5jdGlvbiBzZXRQcm90b3R5cGVPZihPLCBwcm90bykge1xuICAgICAgICBjaGVjayhPLCBwcm90byk7XG4gICAgICAgIGlmIChidWdneSkgTy5fX3Byb3RvX18gPSBwcm90bztcbiAgICAgICAgZWxzZSBzZXQoTywgcHJvdG8pO1xuICAgICAgICByZXR1cm4gTztcbiAgICAgIH07XG4gICAgfSh7fSwgZmFsc2UpIDogdW5kZWZpbmVkKSxcbiAgY2hlY2s6IGNoZWNrXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpO1xudmFyIFNQRUNJRVMgPSByZXF1aXJlKCcuL193a3MnKSgnc3BlY2llcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChLRVkpIHtcbiAgdmFyIEMgPSBnbG9iYWxbS0VZXTtcbiAgaWYgKERFU0NSSVBUT1JTICYmIEMgJiYgIUNbU1BFQ0lFU10pIGRQLmYoQywgU1BFQ0lFUywge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH1cbiAgfSk7XG59O1xuIiwidmFyIGRlZiA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgVEFHID0gcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCB0YWcsIHN0YXQpIHtcbiAgaWYgKGl0ICYmICFoYXMoaXQgPSBzdGF0ID8gaXQgOiBpdC5wcm90b3R5cGUsIFRBRykpIGRlZihpdCwgVEFHLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgdmFsdWU6IHRhZyB9KTtcbn07XG4iLCJ2YXIgc2hhcmVkID0gcmVxdWlyZSgnLi9fc2hhcmVkJykoJ2tleXMnKTtcbnZhciB1aWQgPSByZXF1aXJlKCcuL191aWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gc2hhcmVkW2tleV0gfHwgKHNoYXJlZFtrZXldID0gdWlkKGtleSkpO1xufTtcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBTSEFSRUQgPSAnX19jb3JlLWpzX3NoYXJlZF9fJztcbnZhciBzdG9yZSA9IGdsb2JhbFtTSEFSRURdIHx8IChnbG9iYWxbU0hBUkVEXSA9IHt9KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gc3RvcmVba2V5XSB8fCAoc3RvcmVba2V5XSA9IHt9KTtcbn07XG4iLCIvLyA3LjMuMjAgU3BlY2llc0NvbnN0cnVjdG9yKE8sIGRlZmF1bHRDb25zdHJ1Y3RvcilcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcbnZhciBTUEVDSUVTID0gcmVxdWlyZSgnLi9fd2tzJykoJ3NwZWNpZXMnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE8sIEQpIHtcbiAgdmFyIEMgPSBhbk9iamVjdChPKS5jb25zdHJ1Y3RvcjtcbiAgdmFyIFM7XG4gIHJldHVybiBDID09PSB1bmRlZmluZWQgfHwgKFMgPSBhbk9iamVjdChDKVtTUEVDSUVTXSkgPT0gdW5kZWZpbmVkID8gRCA6IGFGdW5jdGlvbihTKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChtZXRob2QsIGFyZykge1xuICByZXR1cm4gISFtZXRob2QgJiYgZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11c2VsZXNzLWNhbGxcbiAgICBhcmcgPyBtZXRob2QuY2FsbChudWxsLCBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH0sIDEpIDogbWV0aG9kLmNhbGwobnVsbCk7XG4gIH0pO1xufTtcbiIsInZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbi8vIHRydWUgIC0+IFN0cmluZyNhdFxuLy8gZmFsc2UgLT4gU3RyaW5nI2NvZGVQb2ludEF0XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChUT19TVFJJTkcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh0aGF0LCBwb3MpIHtcbiAgICB2YXIgcyA9IFN0cmluZyhkZWZpbmVkKHRoYXQpKTtcbiAgICB2YXIgaSA9IHRvSW50ZWdlcihwb3MpO1xuICAgIHZhciBsID0gcy5sZW5ndGg7XG4gICAgdmFyIGEsIGI7XG4gICAgaWYgKGkgPCAwIHx8IGkgPj0gbCkgcmV0dXJuIFRPX1NUUklORyA/ICcnIDogdW5kZWZpbmVkO1xuICAgIGEgPSBzLmNoYXJDb2RlQXQoaSk7XG4gICAgcmV0dXJuIGEgPCAweGQ4MDAgfHwgYSA+IDB4ZGJmZiB8fCBpICsgMSA9PT0gbCB8fCAoYiA9IHMuY2hhckNvZGVBdChpICsgMSkpIDwgMHhkYzAwIHx8IGIgPiAweGRmZmZcbiAgICAgID8gVE9fU1RSSU5HID8gcy5jaGFyQXQoaSkgOiBhXG4gICAgICA6IFRPX1NUUklORyA/IHMuc2xpY2UoaSwgaSArIDIpIDogKGEgLSAweGQ4MDAgPDwgMTApICsgKGIgLSAweGRjMDApICsgMHgxMDAwMDtcbiAgfTtcbn07XG4iLCIvLyBoZWxwZXIgZm9yIFN0cmluZyN7c3RhcnRzV2l0aCwgZW5kc1dpdGgsIGluY2x1ZGVzfVxudmFyIGlzUmVnRXhwID0gcmVxdWlyZSgnLi9faXMtcmVnZXhwJyk7XG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodGhhdCwgc2VhcmNoU3RyaW5nLCBOQU1FKSB7XG4gIGlmIChpc1JlZ0V4cChzZWFyY2hTdHJpbmcpKSB0aHJvdyBUeXBlRXJyb3IoJ1N0cmluZyMnICsgTkFNRSArIFwiIGRvZXNuJ3QgYWNjZXB0IHJlZ2V4IVwiKTtcbiAgcmV0dXJuIFN0cmluZyhkZWZpbmVkKHRoYXQpKTtcbn07XG4iLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xudmFyIHF1b3QgPSAvXCIvZztcbi8vIEIuMi4zLjIuMSBDcmVhdGVIVE1MKHN0cmluZywgdGFnLCBhdHRyaWJ1dGUsIHZhbHVlKVxudmFyIGNyZWF0ZUhUTUwgPSBmdW5jdGlvbiAoc3RyaW5nLCB0YWcsIGF0dHJpYnV0ZSwgdmFsdWUpIHtcbiAgdmFyIFMgPSBTdHJpbmcoZGVmaW5lZChzdHJpbmcpKTtcbiAgdmFyIHAxID0gJzwnICsgdGFnO1xuICBpZiAoYXR0cmlidXRlICE9PSAnJykgcDEgKz0gJyAnICsgYXR0cmlidXRlICsgJz1cIicgKyBTdHJpbmcodmFsdWUpLnJlcGxhY2UocXVvdCwgJyZxdW90OycpICsgJ1wiJztcbiAgcmV0dXJuIHAxICsgJz4nICsgUyArICc8LycgKyB0YWcgKyAnPic7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTkFNRSwgZXhlYykge1xuICB2YXIgTyA9IHt9O1xuICBPW05BTUVdID0gZXhlYyhjcmVhdGVIVE1MKTtcbiAgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiBmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHRlc3QgPSAnJ1tOQU1FXSgnXCInKTtcbiAgICByZXR1cm4gdGVzdCAhPT0gdGVzdC50b0xvd2VyQ2FzZSgpIHx8IHRlc3Quc3BsaXQoJ1wiJykubGVuZ3RoID4gMztcbiAgfSksICdTdHJpbmcnLCBPKTtcbn07XG4iLCIvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1zdHJpbmctcGFkLXN0YXJ0LWVuZFxudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgcmVwZWF0ID0gcmVxdWlyZSgnLi9fc3RyaW5nLXJlcGVhdCcpO1xudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHRoYXQsIG1heExlbmd0aCwgZmlsbFN0cmluZywgbGVmdCkge1xuICB2YXIgUyA9IFN0cmluZyhkZWZpbmVkKHRoYXQpKTtcbiAgdmFyIHN0cmluZ0xlbmd0aCA9IFMubGVuZ3RoO1xuICB2YXIgZmlsbFN0ciA9IGZpbGxTdHJpbmcgPT09IHVuZGVmaW5lZCA/ICcgJyA6IFN0cmluZyhmaWxsU3RyaW5nKTtcbiAgdmFyIGludE1heExlbmd0aCA9IHRvTGVuZ3RoKG1heExlbmd0aCk7XG4gIGlmIChpbnRNYXhMZW5ndGggPD0gc3RyaW5nTGVuZ3RoIHx8IGZpbGxTdHIgPT0gJycpIHJldHVybiBTO1xuICB2YXIgZmlsbExlbiA9IGludE1heExlbmd0aCAtIHN0cmluZ0xlbmd0aDtcbiAgdmFyIHN0cmluZ0ZpbGxlciA9IHJlcGVhdC5jYWxsKGZpbGxTdHIsIE1hdGguY2VpbChmaWxsTGVuIC8gZmlsbFN0ci5sZW5ndGgpKTtcbiAgaWYgKHN0cmluZ0ZpbGxlci5sZW5ndGggPiBmaWxsTGVuKSBzdHJpbmdGaWxsZXIgPSBzdHJpbmdGaWxsZXIuc2xpY2UoMCwgZmlsbExlbik7XG4gIHJldHVybiBsZWZ0ID8gc3RyaW5nRmlsbGVyICsgUyA6IFMgKyBzdHJpbmdGaWxsZXI7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHJlcGVhdChjb3VudCkge1xuICB2YXIgc3RyID0gU3RyaW5nKGRlZmluZWQodGhpcykpO1xuICB2YXIgcmVzID0gJyc7XG4gIHZhciBuID0gdG9JbnRlZ2VyKGNvdW50KTtcbiAgaWYgKG4gPCAwIHx8IG4gPT0gSW5maW5pdHkpIHRocm93IFJhbmdlRXJyb3IoXCJDb3VudCBjYW4ndCBiZSBuZWdhdGl2ZVwiKTtcbiAgZm9yICg7biA+IDA7IChuID4+Pj0gMSkgJiYgKHN0ciArPSBzdHIpKSBpZiAobiAmIDEpIHJlcyArPSBzdHI7XG4gIHJldHVybiByZXM7XG59O1xuIiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbnZhciBzcGFjZXMgPSByZXF1aXJlKCcuL19zdHJpbmctd3MnKTtcbnZhciBzcGFjZSA9ICdbJyArIHNwYWNlcyArICddJztcbnZhciBub24gPSAnXFx1MjAwYlxcdTAwODUnO1xudmFyIGx0cmltID0gUmVnRXhwKCdeJyArIHNwYWNlICsgc3BhY2UgKyAnKicpO1xudmFyIHJ0cmltID0gUmVnRXhwKHNwYWNlICsgc3BhY2UgKyAnKiQnKTtcblxudmFyIGV4cG9ydGVyID0gZnVuY3Rpb24gKEtFWSwgZXhlYywgQUxJQVMpIHtcbiAgdmFyIGV4cCA9IHt9O1xuICB2YXIgRk9SQ0UgPSBmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICEhc3BhY2VzW0tFWV0oKSB8fCBub25bS0VZXSgpICE9IG5vbjtcbiAgfSk7XG4gIHZhciBmbiA9IGV4cFtLRVldID0gRk9SQ0UgPyBleGVjKHRyaW0pIDogc3BhY2VzW0tFWV07XG4gIGlmIChBTElBUykgZXhwW0FMSUFTXSA9IGZuO1xuICAkZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIEZPUkNFLCAnU3RyaW5nJywgZXhwKTtcbn07XG5cbi8vIDEgLT4gU3RyaW5nI3RyaW1MZWZ0XG4vLyAyIC0+IFN0cmluZyN0cmltUmlnaHRcbi8vIDMgLT4gU3RyaW5nI3RyaW1cbnZhciB0cmltID0gZXhwb3J0ZXIudHJpbSA9IGZ1bmN0aW9uIChzdHJpbmcsIFRZUEUpIHtcbiAgc3RyaW5nID0gU3RyaW5nKGRlZmluZWQoc3RyaW5nKSk7XG4gIGlmIChUWVBFICYgMSkgc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UobHRyaW0sICcnKTtcbiAgaWYgKFRZUEUgJiAyKSBzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShydHJpbSwgJycpO1xuICByZXR1cm4gc3RyaW5nO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRlcjtcbiIsIm1vZHVsZS5leHBvcnRzID0gJ1xceDA5XFx4MEFcXHgwQlxceDBDXFx4MERcXHgyMFxceEEwXFx1MTY4MFxcdTE4MEVcXHUyMDAwXFx1MjAwMVxcdTIwMDJcXHUyMDAzJyArXG4gICdcXHUyMDA0XFx1MjAwNVxcdTIwMDZcXHUyMDA3XFx1MjAwOFxcdTIwMDlcXHUyMDBBXFx1MjAyRlxcdTIwNUZcXHUzMDAwXFx1MjAyOFxcdTIwMjlcXHVGRUZGJztcbiIsInZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciBpbnZva2UgPSByZXF1aXJlKCcuL19pbnZva2UnKTtcbnZhciBodG1sID0gcmVxdWlyZSgnLi9faHRtbCcpO1xudmFyIGNlbCA9IHJlcXVpcmUoJy4vX2RvbS1jcmVhdGUnKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBwcm9jZXNzID0gZ2xvYmFsLnByb2Nlc3M7XG52YXIgc2V0VGFzayA9IGdsb2JhbC5zZXRJbW1lZGlhdGU7XG52YXIgY2xlYXJUYXNrID0gZ2xvYmFsLmNsZWFySW1tZWRpYXRlO1xudmFyIE1lc3NhZ2VDaGFubmVsID0gZ2xvYmFsLk1lc3NhZ2VDaGFubmVsO1xudmFyIERpc3BhdGNoID0gZ2xvYmFsLkRpc3BhdGNoO1xudmFyIGNvdW50ZXIgPSAwO1xudmFyIHF1ZXVlID0ge307XG52YXIgT05SRUFEWVNUQVRFQ0hBTkdFID0gJ29ucmVhZHlzdGF0ZWNoYW5nZSc7XG52YXIgZGVmZXIsIGNoYW5uZWwsIHBvcnQ7XG52YXIgcnVuID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaWQgPSArdGhpcztcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xuICBpZiAocXVldWUuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgdmFyIGZuID0gcXVldWVbaWRdO1xuICAgIGRlbGV0ZSBxdWV1ZVtpZF07XG4gICAgZm4oKTtcbiAgfVxufTtcbnZhciBsaXN0ZW5lciA9IGZ1bmN0aW9uIChldmVudCkge1xuICBydW4uY2FsbChldmVudC5kYXRhKTtcbn07XG4vLyBOb2RlLmpzIDAuOSsgJiBJRTEwKyBoYXMgc2V0SW1tZWRpYXRlLCBvdGhlcndpc2U6XG5pZiAoIXNldFRhc2sgfHwgIWNsZWFyVGFzaykge1xuICBzZXRUYXNrID0gZnVuY3Rpb24gc2V0SW1tZWRpYXRlKGZuKSB7XG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICB2YXIgaSA9IDE7XG4gICAgd2hpbGUgKGFyZ3VtZW50cy5sZW5ndGggPiBpKSBhcmdzLnB1c2goYXJndW1lbnRzW2krK10pO1xuICAgIHF1ZXVlWysrY291bnRlcl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LWZ1bmNcbiAgICAgIGludm9rZSh0eXBlb2YgZm4gPT0gJ2Z1bmN0aW9uJyA/IGZuIDogRnVuY3Rpb24oZm4pLCBhcmdzKTtcbiAgICB9O1xuICAgIGRlZmVyKGNvdW50ZXIpO1xuICAgIHJldHVybiBjb3VudGVyO1xuICB9O1xuICBjbGVhclRhc2sgPSBmdW5jdGlvbiBjbGVhckltbWVkaWF0ZShpZCkge1xuICAgIGRlbGV0ZSBxdWV1ZVtpZF07XG4gIH07XG4gIC8vIE5vZGUuanMgMC44LVxuICBpZiAocmVxdWlyZSgnLi9fY29mJykocHJvY2VzcykgPT0gJ3Byb2Nlc3MnKSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soY3R4KHJ1biwgaWQsIDEpKTtcbiAgICB9O1xuICAvLyBTcGhlcmUgKEpTIGdhbWUgZW5naW5lKSBEaXNwYXRjaCBBUElcbiAgfSBlbHNlIGlmIChEaXNwYXRjaCAmJiBEaXNwYXRjaC5ub3cpIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgRGlzcGF0Y2gubm93KGN0eChydW4sIGlkLCAxKSk7XG4gICAgfTtcbiAgLy8gQnJvd3NlcnMgd2l0aCBNZXNzYWdlQ2hhbm5lbCwgaW5jbHVkZXMgV2ViV29ya2Vyc1xuICB9IGVsc2UgaWYgKE1lc3NhZ2VDaGFubmVsKSB7XG4gICAgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgIHBvcnQgPSBjaGFubmVsLnBvcnQyO1xuICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gbGlzdGVuZXI7XG4gICAgZGVmZXIgPSBjdHgocG9ydC5wb3N0TWVzc2FnZSwgcG9ydCwgMSk7XG4gIC8vIEJyb3dzZXJzIHdpdGggcG9zdE1lc3NhZ2UsIHNraXAgV2ViV29ya2Vyc1xuICAvLyBJRTggaGFzIHBvc3RNZXNzYWdlLCBidXQgaXQncyBzeW5jICYgdHlwZW9mIGl0cyBwb3N0TWVzc2FnZSBpcyAnb2JqZWN0J1xuICB9IGVsc2UgaWYgKGdsb2JhbC5hZGRFdmVudExpc3RlbmVyICYmIHR5cGVvZiBwb3N0TWVzc2FnZSA9PSAnZnVuY3Rpb24nICYmICFnbG9iYWwuaW1wb3J0U2NyaXB0cykge1xuICAgIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICBnbG9iYWwucG9zdE1lc3NhZ2UoaWQgKyAnJywgJyonKTtcbiAgICB9O1xuICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgbGlzdGVuZXIsIGZhbHNlKTtcbiAgLy8gSUU4LVxuICB9IGVsc2UgaWYgKE9OUkVBRFlTVEFURUNIQU5HRSBpbiBjZWwoJ3NjcmlwdCcpKSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIGh0bWwuYXBwZW5kQ2hpbGQoY2VsKCdzY3JpcHQnKSlbT05SRUFEWVNUQVRFQ0hBTkdFXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaHRtbC5yZW1vdmVDaGlsZCh0aGlzKTtcbiAgICAgICAgcnVuLmNhbGwoaWQpO1xuICAgICAgfTtcbiAgICB9O1xuICAvLyBSZXN0IG9sZCBicm93c2Vyc1xuICB9IGVsc2Uge1xuICAgIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICBzZXRUaW1lb3V0KGN0eChydW4sIGlkLCAxKSwgMCk7XG4gICAgfTtcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNldDogc2V0VGFzayxcbiAgY2xlYXI6IGNsZWFyVGFza1xufTtcbiIsInZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG52YXIgbWF4ID0gTWF0aC5tYXg7XG52YXIgbWluID0gTWF0aC5taW47XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpbmRleCwgbGVuZ3RoKSB7XG4gIGluZGV4ID0gdG9JbnRlZ2VyKGluZGV4KTtcbiAgcmV0dXJuIGluZGV4IDwgMCA/IG1heChpbmRleCArIGxlbmd0aCwgMCkgOiBtaW4oaW5kZXgsIGxlbmd0aCk7XG59O1xuIiwiLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtdG9pbmRleFxudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKGl0ID09PSB1bmRlZmluZWQpIHJldHVybiAwO1xuICB2YXIgbnVtYmVyID0gdG9JbnRlZ2VyKGl0KTtcbiAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKG51bWJlcik7XG4gIGlmIChudW1iZXIgIT09IGxlbmd0aCkgdGhyb3cgUmFuZ2VFcnJvcignV3JvbmcgbGVuZ3RoIScpO1xuICByZXR1cm4gbGVuZ3RoO1xufTtcbiIsIi8vIDcuMS40IFRvSW50ZWdlclxudmFyIGNlaWwgPSBNYXRoLmNlaWw7XG52YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGlzTmFOKGl0ID0gK2l0KSA/IDAgOiAoaXQgPiAwID8gZmxvb3IgOiBjZWlsKShpdCk7XG59O1xuIiwiLy8gdG8gaW5kZXhlZCBvYmplY3QsIHRvT2JqZWN0IHdpdGggZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBzdHJpbmdzXG52YXIgSU9iamVjdCA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKTtcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIElPYmplY3QoZGVmaW5lZChpdCkpO1xufTtcbiIsIi8vIDcuMS4xNSBUb0xlbmd0aFxudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcbnZhciBtaW4gPSBNYXRoLm1pbjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCA+IDAgPyBtaW4odG9JbnRlZ2VyKGl0KSwgMHgxZmZmZmZmZmZmZmZmZikgOiAwOyAvLyBwb3coMiwgNTMpIC0gMSA9PSA5MDA3MTk5MjU0NzQwOTkxXG59O1xuIiwiLy8gNy4xLjEzIFRvT2JqZWN0KGFyZ3VtZW50KVxudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gT2JqZWN0KGRlZmluZWQoaXQpKTtcbn07XG4iLCIvLyA3LjEuMSBUb1ByaW1pdGl2ZShpbnB1dCBbLCBQcmVmZXJyZWRUeXBlXSlcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xuLy8gaW5zdGVhZCBvZiB0aGUgRVM2IHNwZWMgdmVyc2lvbiwgd2UgZGlkbid0IGltcGxlbWVudCBAQHRvUHJpbWl0aXZlIGNhc2Vcbi8vIGFuZCB0aGUgc2Vjb25kIGFyZ3VtZW50IC0gZmxhZyAtIHByZWZlcnJlZCB0eXBlIGlzIGEgc3RyaW5nXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgUykge1xuICBpZiAoIWlzT2JqZWN0KGl0KSkgcmV0dXJuIGl0O1xuICB2YXIgZm4sIHZhbDtcbiAgaWYgKFMgJiYgdHlwZW9mIChmbiA9IGl0LnRvU3RyaW5nKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpIHJldHVybiB2YWw7XG4gIGlmICh0eXBlb2YgKGZuID0gaXQudmFsdWVPZikgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKSByZXR1cm4gdmFsO1xuICBpZiAoIVMgJiYgdHlwZW9mIChmbiA9IGl0LnRvU3RyaW5nKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpIHJldHVybiB2YWw7XG4gIHRocm93IFR5cGVFcnJvcihcIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZVwiKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5pZiAocmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSkge1xuICB2YXIgTElCUkFSWSA9IHJlcXVpcmUoJy4vX2xpYnJhcnknKTtcbiAgdmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xuICB2YXIgZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xuICB2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuICB2YXIgJHR5cGVkID0gcmVxdWlyZSgnLi9fdHlwZWQnKTtcbiAgdmFyICRidWZmZXIgPSByZXF1aXJlKCcuL190eXBlZC1idWZmZXInKTtcbiAgdmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xuICB2YXIgYW5JbnN0YW5jZSA9IHJlcXVpcmUoJy4vX2FuLWluc3RhbmNlJyk7XG4gIHZhciBwcm9wZXJ0eURlc2MgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG4gIHZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xuICB2YXIgcmVkZWZpbmVBbGwgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKTtcbiAgdmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcbiAgdmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG4gIHZhciB0b0luZGV4ID0gcmVxdWlyZSgnLi9fdG8taW5kZXgnKTtcbiAgdmFyIHRvQWJzb2x1dGVJbmRleCA9IHJlcXVpcmUoJy4vX3RvLWFic29sdXRlLWluZGV4Jyk7XG4gIHZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpO1xuICB2YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG4gIHZhciBjbGFzc29mID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpO1xuICB2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbiAgdmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG4gIHZhciBpc0FycmF5SXRlciA9IHJlcXVpcmUoJy4vX2lzLWFycmF5LWl0ZXInKTtcbiAgdmFyIGNyZWF0ZSA9IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKTtcbiAgdmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpO1xuICB2YXIgZ09QTiA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuJykuZjtcbiAgdmFyIGdldEl0ZXJGbiA9IHJlcXVpcmUoJy4vY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kJyk7XG4gIHZhciB1aWQgPSByZXF1aXJlKCcuL191aWQnKTtcbiAgdmFyIHdrcyA9IHJlcXVpcmUoJy4vX3drcycpO1xuICB2YXIgY3JlYXRlQXJyYXlNZXRob2QgPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJyk7XG4gIHZhciBjcmVhdGVBcnJheUluY2x1ZGVzID0gcmVxdWlyZSgnLi9fYXJyYXktaW5jbHVkZXMnKTtcbiAgdmFyIHNwZWNpZXNDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4vX3NwZWNpZXMtY29uc3RydWN0b3InKTtcbiAgdmFyIEFycmF5SXRlcmF0b3JzID0gcmVxdWlyZSgnLi9lczYuYXJyYXkuaXRlcmF0b3InKTtcbiAgdmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xuICB2YXIgJGl0ZXJEZXRlY3QgPSByZXF1aXJlKCcuL19pdGVyLWRldGVjdCcpO1xuICB2YXIgc2V0U3BlY2llcyA9IHJlcXVpcmUoJy4vX3NldC1zcGVjaWVzJyk7XG4gIHZhciBhcnJheUZpbGwgPSByZXF1aXJlKCcuL19hcnJheS1maWxsJyk7XG4gIHZhciBhcnJheUNvcHlXaXRoaW4gPSByZXF1aXJlKCcuL19hcnJheS1jb3B5LXdpdGhpbicpO1xuICB2YXIgJERQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG4gIHZhciAkR09QRCA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJyk7XG4gIHZhciBkUCA9ICREUC5mO1xuICB2YXIgZ09QRCA9ICRHT1BELmY7XG4gIHZhciBSYW5nZUVycm9yID0gZ2xvYmFsLlJhbmdlRXJyb3I7XG4gIHZhciBUeXBlRXJyb3IgPSBnbG9iYWwuVHlwZUVycm9yO1xuICB2YXIgVWludDhBcnJheSA9IGdsb2JhbC5VaW50OEFycmF5O1xuICB2YXIgQVJSQVlfQlVGRkVSID0gJ0FycmF5QnVmZmVyJztcbiAgdmFyIFNIQVJFRF9CVUZGRVIgPSAnU2hhcmVkJyArIEFSUkFZX0JVRkZFUjtcbiAgdmFyIEJZVEVTX1BFUl9FTEVNRU5UID0gJ0JZVEVTX1BFUl9FTEVNRU5UJztcbiAgdmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xuICB2YXIgQXJyYXlQcm90byA9IEFycmF5W1BST1RPVFlQRV07XG4gIHZhciAkQXJyYXlCdWZmZXIgPSAkYnVmZmVyLkFycmF5QnVmZmVyO1xuICB2YXIgJERhdGFWaWV3ID0gJGJ1ZmZlci5EYXRhVmlldztcbiAgdmFyIGFycmF5Rm9yRWFjaCA9IGNyZWF0ZUFycmF5TWV0aG9kKDApO1xuICB2YXIgYXJyYXlGaWx0ZXIgPSBjcmVhdGVBcnJheU1ldGhvZCgyKTtcbiAgdmFyIGFycmF5U29tZSA9IGNyZWF0ZUFycmF5TWV0aG9kKDMpO1xuICB2YXIgYXJyYXlFdmVyeSA9IGNyZWF0ZUFycmF5TWV0aG9kKDQpO1xuICB2YXIgYXJyYXlGaW5kID0gY3JlYXRlQXJyYXlNZXRob2QoNSk7XG4gIHZhciBhcnJheUZpbmRJbmRleCA9IGNyZWF0ZUFycmF5TWV0aG9kKDYpO1xuICB2YXIgYXJyYXlJbmNsdWRlcyA9IGNyZWF0ZUFycmF5SW5jbHVkZXModHJ1ZSk7XG4gIHZhciBhcnJheUluZGV4T2YgPSBjcmVhdGVBcnJheUluY2x1ZGVzKGZhbHNlKTtcbiAgdmFyIGFycmF5VmFsdWVzID0gQXJyYXlJdGVyYXRvcnMudmFsdWVzO1xuICB2YXIgYXJyYXlLZXlzID0gQXJyYXlJdGVyYXRvcnMua2V5cztcbiAgdmFyIGFycmF5RW50cmllcyA9IEFycmF5SXRlcmF0b3JzLmVudHJpZXM7XG4gIHZhciBhcnJheUxhc3RJbmRleE9mID0gQXJyYXlQcm90by5sYXN0SW5kZXhPZjtcbiAgdmFyIGFycmF5UmVkdWNlID0gQXJyYXlQcm90by5yZWR1Y2U7XG4gIHZhciBhcnJheVJlZHVjZVJpZ2h0ID0gQXJyYXlQcm90by5yZWR1Y2VSaWdodDtcbiAgdmFyIGFycmF5Sm9pbiA9IEFycmF5UHJvdG8uam9pbjtcbiAgdmFyIGFycmF5U29ydCA9IEFycmF5UHJvdG8uc29ydDtcbiAgdmFyIGFycmF5U2xpY2UgPSBBcnJheVByb3RvLnNsaWNlO1xuICB2YXIgYXJyYXlUb1N0cmluZyA9IEFycmF5UHJvdG8udG9TdHJpbmc7XG4gIHZhciBhcnJheVRvTG9jYWxlU3RyaW5nID0gQXJyYXlQcm90by50b0xvY2FsZVN0cmluZztcbiAgdmFyIElURVJBVE9SID0gd2tzKCdpdGVyYXRvcicpO1xuICB2YXIgVEFHID0gd2tzKCd0b1N0cmluZ1RhZycpO1xuICB2YXIgVFlQRURfQ09OU1RSVUNUT1IgPSB1aWQoJ3R5cGVkX2NvbnN0cnVjdG9yJyk7XG4gIHZhciBERUZfQ09OU1RSVUNUT1IgPSB1aWQoJ2RlZl9jb25zdHJ1Y3RvcicpO1xuICB2YXIgQUxMX0NPTlNUUlVDVE9SUyA9ICR0eXBlZC5DT05TVFI7XG4gIHZhciBUWVBFRF9BUlJBWSA9ICR0eXBlZC5UWVBFRDtcbiAgdmFyIFZJRVcgPSAkdHlwZWQuVklFVztcbiAgdmFyIFdST05HX0xFTkdUSCA9ICdXcm9uZyBsZW5ndGghJztcblxuICB2YXIgJG1hcCA9IGNyZWF0ZUFycmF5TWV0aG9kKDEsIGZ1bmN0aW9uIChPLCBsZW5ndGgpIHtcbiAgICByZXR1cm4gYWxsb2NhdGUoc3BlY2llc0NvbnN0cnVjdG9yKE8sIE9bREVGX0NPTlNUUlVDVE9SXSksIGxlbmd0aCk7XG4gIH0pO1xuXG4gIHZhciBMSVRUTEVfRU5ESUFOID0gZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICAgIHJldHVybiBuZXcgVWludDhBcnJheShuZXcgVWludDE2QXJyYXkoWzFdKS5idWZmZXIpWzBdID09PSAxO1xuICB9KTtcblxuICB2YXIgRk9SQ0VEX1NFVCA9ICEhVWludDhBcnJheSAmJiAhIVVpbnQ4QXJyYXlbUFJPVE9UWVBFXS5zZXQgJiYgZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIG5ldyBVaW50OEFycmF5KDEpLnNldCh7fSk7XG4gIH0pO1xuXG4gIHZhciB0b09mZnNldCA9IGZ1bmN0aW9uIChpdCwgQllURVMpIHtcbiAgICB2YXIgb2Zmc2V0ID0gdG9JbnRlZ2VyKGl0KTtcbiAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgJSBCWVRFUykgdGhyb3cgUmFuZ2VFcnJvcignV3Jvbmcgb2Zmc2V0IScpO1xuICAgIHJldHVybiBvZmZzZXQ7XG4gIH07XG5cbiAgdmFyIHZhbGlkYXRlID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgaWYgKGlzT2JqZWN0KGl0KSAmJiBUWVBFRF9BUlJBWSBpbiBpdCkgcmV0dXJuIGl0O1xuICAgIHRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGEgdHlwZWQgYXJyYXkhJyk7XG4gIH07XG5cbiAgdmFyIGFsbG9jYXRlID0gZnVuY3Rpb24gKEMsIGxlbmd0aCkge1xuICAgIGlmICghKGlzT2JqZWN0KEMpICYmIFRZUEVEX0NPTlNUUlVDVE9SIGluIEMpKSB7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ0l0IGlzIG5vdCBhIHR5cGVkIGFycmF5IGNvbnN0cnVjdG9yIScpO1xuICAgIH0gcmV0dXJuIG5ldyBDKGxlbmd0aCk7XG4gIH07XG5cbiAgdmFyIHNwZWNpZXNGcm9tTGlzdCA9IGZ1bmN0aW9uIChPLCBsaXN0KSB7XG4gICAgcmV0dXJuIGZyb21MaXN0KHNwZWNpZXNDb25zdHJ1Y3RvcihPLCBPW0RFRl9DT05TVFJVQ1RPUl0pLCBsaXN0KTtcbiAgfTtcblxuICB2YXIgZnJvbUxpc3QgPSBmdW5jdGlvbiAoQywgbGlzdCkge1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIGxlbmd0aCA9IGxpc3QubGVuZ3RoO1xuICAgIHZhciByZXN1bHQgPSBhbGxvY2F0ZShDLCBsZW5ndGgpO1xuICAgIHdoaWxlIChsZW5ndGggPiBpbmRleCkgcmVzdWx0W2luZGV4XSA9IGxpc3RbaW5kZXgrK107XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICB2YXIgYWRkR2V0dGVyID0gZnVuY3Rpb24gKGl0LCBrZXksIGludGVybmFsKSB7XG4gICAgZFAoaXQsIGtleSwgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RbaW50ZXJuYWxdOyB9IH0pO1xuICB9O1xuXG4gIHZhciAkZnJvbSA9IGZ1bmN0aW9uIGZyb20oc291cmNlIC8qICwgbWFwZm4sIHRoaXNBcmcgKi8pIHtcbiAgICB2YXIgTyA9IHRvT2JqZWN0KHNvdXJjZSk7XG4gICAgdmFyIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBtYXBmbiA9IGFMZW4gPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICAgIHZhciBtYXBwaW5nID0gbWFwZm4gIT09IHVuZGVmaW5lZDtcbiAgICB2YXIgaXRlckZuID0gZ2V0SXRlckZuKE8pO1xuICAgIHZhciBpLCBsZW5ndGgsIHZhbHVlcywgcmVzdWx0LCBzdGVwLCBpdGVyYXRvcjtcbiAgICBpZiAoaXRlckZuICE9IHVuZGVmaW5lZCAmJiAhaXNBcnJheUl0ZXIoaXRlckZuKSkge1xuICAgICAgZm9yIChpdGVyYXRvciA9IGl0ZXJGbi5jYWxsKE8pLCB2YWx1ZXMgPSBbXSwgaSA9IDA7ICEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZTsgaSsrKSB7XG4gICAgICAgIHZhbHVlcy5wdXNoKHN0ZXAudmFsdWUpO1xuICAgICAgfSBPID0gdmFsdWVzO1xuICAgIH1cbiAgICBpZiAobWFwcGluZyAmJiBhTGVuID4gMikgbWFwZm4gPSBjdHgobWFwZm4sIGFyZ3VtZW50c1syXSwgMik7XG4gICAgZm9yIChpID0gMCwgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpLCByZXN1bHQgPSBhbGxvY2F0ZSh0aGlzLCBsZW5ndGgpOyBsZW5ndGggPiBpOyBpKyspIHtcbiAgICAgIHJlc3VsdFtpXSA9IG1hcHBpbmcgPyBtYXBmbihPW2ldLCBpKSA6IE9baV07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgdmFyICRvZiA9IGZ1bmN0aW9uIG9mKC8qIC4uLml0ZW1zICovKSB7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgcmVzdWx0ID0gYWxsb2NhdGUodGhpcywgbGVuZ3RoKTtcbiAgICB3aGlsZSAobGVuZ3RoID4gaW5kZXgpIHJlc3VsdFtpbmRleF0gPSBhcmd1bWVudHNbaW5kZXgrK107XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBpT1MgU2FmYXJpIDYueCBmYWlscyBoZXJlXG4gIHZhciBUT19MT0NBTEVfQlVHID0gISFVaW50OEFycmF5ICYmIGZhaWxzKGZ1bmN0aW9uICgpIHsgYXJyYXlUb0xvY2FsZVN0cmluZy5jYWxsKG5ldyBVaW50OEFycmF5KDEpKTsgfSk7XG5cbiAgdmFyICR0b0xvY2FsZVN0cmluZyA9IGZ1bmN0aW9uIHRvTG9jYWxlU3RyaW5nKCkge1xuICAgIHJldHVybiBhcnJheVRvTG9jYWxlU3RyaW5nLmFwcGx5KFRPX0xPQ0FMRV9CVUcgPyBhcnJheVNsaWNlLmNhbGwodmFsaWRhdGUodGhpcykpIDogdmFsaWRhdGUodGhpcyksIGFyZ3VtZW50cyk7XG4gIH07XG5cbiAgdmFyIHByb3RvID0ge1xuICAgIGNvcHlXaXRoaW46IGZ1bmN0aW9uIGNvcHlXaXRoaW4odGFyZ2V0LCBzdGFydCAvKiAsIGVuZCAqLykge1xuICAgICAgcmV0dXJuIGFycmF5Q29weVdpdGhpbi5jYWxsKHZhbGlkYXRlKHRoaXMpLCB0YXJnZXQsIHN0YXJ0LCBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBldmVyeTogZnVuY3Rpb24gZXZlcnkoY2FsbGJhY2tmbiAvKiAsIHRoaXNBcmcgKi8pIHtcbiAgICAgIHJldHVybiBhcnJheUV2ZXJ5KHZhbGlkYXRlKHRoaXMpLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBmaWxsOiBmdW5jdGlvbiBmaWxsKHZhbHVlIC8qICwgc3RhcnQsIGVuZCAqLykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICByZXR1cm4gYXJyYXlGaWxsLmFwcGx5KHZhbGlkYXRlKHRoaXMpLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgZmlsdGVyOiBmdW5jdGlvbiBmaWx0ZXIoY2FsbGJhY2tmbiAvKiAsIHRoaXNBcmcgKi8pIHtcbiAgICAgIHJldHVybiBzcGVjaWVzRnJvbUxpc3QodGhpcywgYXJyYXlGaWx0ZXIodmFsaWRhdGUodGhpcyksIGNhbGxiYWNrZm4sXG4gICAgICAgIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKSk7XG4gICAgfSxcbiAgICBmaW5kOiBmdW5jdGlvbiBmaW5kKHByZWRpY2F0ZSAvKiAsIHRoaXNBcmcgKi8pIHtcbiAgICAgIHJldHVybiBhcnJheUZpbmQodmFsaWRhdGUodGhpcyksIHByZWRpY2F0ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgZmluZEluZGV4OiBmdW5jdGlvbiBmaW5kSW5kZXgocHJlZGljYXRlIC8qICwgdGhpc0FyZyAqLykge1xuICAgICAgcmV0dXJuIGFycmF5RmluZEluZGV4KHZhbGlkYXRlKHRoaXMpLCBwcmVkaWNhdGUsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIGZvckVhY2g6IGZ1bmN0aW9uIGZvckVhY2goY2FsbGJhY2tmbiAvKiAsIHRoaXNBcmcgKi8pIHtcbiAgICAgIGFycmF5Rm9yRWFjaCh2YWxpZGF0ZSh0aGlzKSwgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgaW5kZXhPZjogZnVuY3Rpb24gaW5kZXhPZihzZWFyY2hFbGVtZW50IC8qICwgZnJvbUluZGV4ICovKSB7XG4gICAgICByZXR1cm4gYXJyYXlJbmRleE9mKHZhbGlkYXRlKHRoaXMpLCBzZWFyY2hFbGVtZW50LCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBpbmNsdWRlczogZnVuY3Rpb24gaW5jbHVkZXMoc2VhcmNoRWxlbWVudCAvKiAsIGZyb21JbmRleCAqLykge1xuICAgICAgcmV0dXJuIGFycmF5SW5jbHVkZXModmFsaWRhdGUodGhpcyksIHNlYXJjaEVsZW1lbnQsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIGpvaW46IGZ1bmN0aW9uIGpvaW4oc2VwYXJhdG9yKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIHJldHVybiBhcnJheUpvaW4uYXBwbHkodmFsaWRhdGUodGhpcyksIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICBsYXN0SW5kZXhPZjogZnVuY3Rpb24gbGFzdEluZGV4T2Yoc2VhcmNoRWxlbWVudCAvKiAsIGZyb21JbmRleCAqLykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICByZXR1cm4gYXJyYXlMYXN0SW5kZXhPZi5hcHBseSh2YWxpZGF0ZSh0aGlzKSwgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIG1hcDogZnVuY3Rpb24gbWFwKG1hcGZuIC8qICwgdGhpc0FyZyAqLykge1xuICAgICAgcmV0dXJuICRtYXAodmFsaWRhdGUodGhpcyksIG1hcGZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICByZWR1Y2U6IGZ1bmN0aW9uIHJlZHVjZShjYWxsYmFja2ZuIC8qICwgaW5pdGlhbFZhbHVlICovKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIHJldHVybiBhcnJheVJlZHVjZS5hcHBseSh2YWxpZGF0ZSh0aGlzKSwgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIHJlZHVjZVJpZ2h0OiBmdW5jdGlvbiByZWR1Y2VSaWdodChjYWxsYmFja2ZuIC8qICwgaW5pdGlhbFZhbHVlICovKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIHJldHVybiBhcnJheVJlZHVjZVJpZ2h0LmFwcGx5KHZhbGlkYXRlKHRoaXMpLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgcmV2ZXJzZTogZnVuY3Rpb24gcmV2ZXJzZSgpIHtcbiAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgIHZhciBsZW5ndGggPSB2YWxpZGF0ZSh0aGF0KS5sZW5ndGg7XG4gICAgICB2YXIgbWlkZGxlID0gTWF0aC5mbG9vcihsZW5ndGggLyAyKTtcbiAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICB2YXIgdmFsdWU7XG4gICAgICB3aGlsZSAoaW5kZXggPCBtaWRkbGUpIHtcbiAgICAgICAgdmFsdWUgPSB0aGF0W2luZGV4XTtcbiAgICAgICAgdGhhdFtpbmRleCsrXSA9IHRoYXRbLS1sZW5ndGhdO1xuICAgICAgICB0aGF0W2xlbmd0aF0gPSB2YWx1ZTtcbiAgICAgIH0gcmV0dXJuIHRoYXQ7XG4gICAgfSxcbiAgICBzb21lOiBmdW5jdGlvbiBzb21lKGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKSB7XG4gICAgICByZXR1cm4gYXJyYXlTb21lKHZhbGlkYXRlKHRoaXMpLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBzb3J0OiBmdW5jdGlvbiBzb3J0KGNvbXBhcmVmbikge1xuICAgICAgcmV0dXJuIGFycmF5U29ydC5jYWxsKHZhbGlkYXRlKHRoaXMpLCBjb21wYXJlZm4pO1xuICAgIH0sXG4gICAgc3ViYXJyYXk6IGZ1bmN0aW9uIHN1YmFycmF5KGJlZ2luLCBlbmQpIHtcbiAgICAgIHZhciBPID0gdmFsaWRhdGUodGhpcyk7XG4gICAgICB2YXIgbGVuZ3RoID0gTy5sZW5ndGg7XG4gICAgICB2YXIgJGJlZ2luID0gdG9BYnNvbHV0ZUluZGV4KGJlZ2luLCBsZW5ndGgpO1xuICAgICAgcmV0dXJuIG5ldyAoc3BlY2llc0NvbnN0cnVjdG9yKE8sIE9bREVGX0NPTlNUUlVDVE9SXSkpKFxuICAgICAgICBPLmJ1ZmZlcixcbiAgICAgICAgTy5ieXRlT2Zmc2V0ICsgJGJlZ2luICogTy5CWVRFU19QRVJfRUxFTUVOVCxcbiAgICAgICAgdG9MZW5ndGgoKGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogdG9BYnNvbHV0ZUluZGV4KGVuZCwgbGVuZ3RoKSkgLSAkYmVnaW4pXG4gICAgICApO1xuICAgIH1cbiAgfTtcblxuICB2YXIgJHNsaWNlID0gZnVuY3Rpb24gc2xpY2Uoc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiBzcGVjaWVzRnJvbUxpc3QodGhpcywgYXJyYXlTbGljZS5jYWxsKHZhbGlkYXRlKHRoaXMpLCBzdGFydCwgZW5kKSk7XG4gIH07XG5cbiAgdmFyICRzZXQgPSBmdW5jdGlvbiBzZXQoYXJyYXlMaWtlIC8qICwgb2Zmc2V0ICovKSB7XG4gICAgdmFsaWRhdGUodGhpcyk7XG4gICAgdmFyIG9mZnNldCA9IHRvT2Zmc2V0KGFyZ3VtZW50c1sxXSwgMSk7XG4gICAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoO1xuICAgIHZhciBzcmMgPSB0b09iamVjdChhcnJheUxpa2UpO1xuICAgIHZhciBsZW4gPSB0b0xlbmd0aChzcmMubGVuZ3RoKTtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIGlmIChsZW4gKyBvZmZzZXQgPiBsZW5ndGgpIHRocm93IFJhbmdlRXJyb3IoV1JPTkdfTEVOR1RIKTtcbiAgICB3aGlsZSAoaW5kZXggPCBsZW4pIHRoaXNbb2Zmc2V0ICsgaW5kZXhdID0gc3JjW2luZGV4KytdO1xuICB9O1xuXG4gIHZhciAkaXRlcmF0b3JzID0ge1xuICAgIGVudHJpZXM6IGZ1bmN0aW9uIGVudHJpZXMoKSB7XG4gICAgICByZXR1cm4gYXJyYXlFbnRyaWVzLmNhbGwodmFsaWRhdGUodGhpcykpO1xuICAgIH0sXG4gICAga2V5czogZnVuY3Rpb24ga2V5cygpIHtcbiAgICAgIHJldHVybiBhcnJheUtleXMuY2FsbCh2YWxpZGF0ZSh0aGlzKSk7XG4gICAgfSxcbiAgICB2YWx1ZXM6IGZ1bmN0aW9uIHZhbHVlcygpIHtcbiAgICAgIHJldHVybiBhcnJheVZhbHVlcy5jYWxsKHZhbGlkYXRlKHRoaXMpKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGlzVEFJbmRleCA9IGZ1bmN0aW9uICh0YXJnZXQsIGtleSkge1xuICAgIHJldHVybiBpc09iamVjdCh0YXJnZXQpXG4gICAgICAmJiB0YXJnZXRbVFlQRURfQVJSQVldXG4gICAgICAmJiB0eXBlb2Yga2V5ICE9ICdzeW1ib2wnXG4gICAgICAmJiBrZXkgaW4gdGFyZ2V0XG4gICAgICAmJiBTdHJpbmcoK2tleSkgPT0gU3RyaW5nKGtleSk7XG4gIH07XG4gIHZhciAkZ2V0RGVzYyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkge1xuICAgIHJldHVybiBpc1RBSW5kZXgodGFyZ2V0LCBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpKVxuICAgICAgPyBwcm9wZXJ0eURlc2MoMiwgdGFyZ2V0W2tleV0pXG4gICAgICA6IGdPUEQodGFyZ2V0LCBrZXkpO1xuICB9O1xuICB2YXIgJHNldERlc2MgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIGlmIChpc1RBSW5kZXgodGFyZ2V0LCBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpKVxuICAgICAgJiYgaXNPYmplY3QoZGVzYylcbiAgICAgICYmIGhhcyhkZXNjLCAndmFsdWUnKVxuICAgICAgJiYgIWhhcyhkZXNjLCAnZ2V0JylcbiAgICAgICYmICFoYXMoZGVzYywgJ3NldCcpXG4gICAgICAvLyBUT0RPOiBhZGQgdmFsaWRhdGlvbiBkZXNjcmlwdG9yIHcvbyBjYWxsaW5nIGFjY2Vzc29yc1xuICAgICAgJiYgIWRlc2MuY29uZmlndXJhYmxlXG4gICAgICAmJiAoIWhhcyhkZXNjLCAnd3JpdGFibGUnKSB8fCBkZXNjLndyaXRhYmxlKVxuICAgICAgJiYgKCFoYXMoZGVzYywgJ2VudW1lcmFibGUnKSB8fCBkZXNjLmVudW1lcmFibGUpXG4gICAgKSB7XG4gICAgICB0YXJnZXRba2V5XSA9IGRlc2MudmFsdWU7XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH0gcmV0dXJuIGRQKHRhcmdldCwga2V5LCBkZXNjKTtcbiAgfTtcblxuICBpZiAoIUFMTF9DT05TVFJVQ1RPUlMpIHtcbiAgICAkR09QRC5mID0gJGdldERlc2M7XG4gICAgJERQLmYgPSAkc2V0RGVzYztcbiAgfVxuXG4gICRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIUFMTF9DT05TVFJVQ1RPUlMsICdPYmplY3QnLCB7XG4gICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiAkZ2V0RGVzYyxcbiAgICBkZWZpbmVQcm9wZXJ0eTogJHNldERlc2NcbiAgfSk7XG5cbiAgaWYgKGZhaWxzKGZ1bmN0aW9uICgpIHsgYXJyYXlUb1N0cmluZy5jYWxsKHt9KTsgfSkpIHtcbiAgICBhcnJheVRvU3RyaW5nID0gYXJyYXlUb0xvY2FsZVN0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIGFycmF5Sm9pbi5jYWxsKHRoaXMpO1xuICAgIH07XG4gIH1cblxuICB2YXIgJFR5cGVkQXJyYXlQcm90b3R5cGUkID0gcmVkZWZpbmVBbGwoe30sIHByb3RvKTtcbiAgcmVkZWZpbmVBbGwoJFR5cGVkQXJyYXlQcm90b3R5cGUkLCAkaXRlcmF0b3JzKTtcbiAgaGlkZSgkVHlwZWRBcnJheVByb3RvdHlwZSQsIElURVJBVE9SLCAkaXRlcmF0b3JzLnZhbHVlcyk7XG4gIHJlZGVmaW5lQWxsKCRUeXBlZEFycmF5UHJvdG90eXBlJCwge1xuICAgIHNsaWNlOiAkc2xpY2UsXG4gICAgc2V0OiAkc2V0LFxuICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7IC8qIG5vb3AgKi8gfSxcbiAgICB0b1N0cmluZzogYXJyYXlUb1N0cmluZyxcbiAgICB0b0xvY2FsZVN0cmluZzogJHRvTG9jYWxlU3RyaW5nXG4gIH0pO1xuICBhZGRHZXR0ZXIoJFR5cGVkQXJyYXlQcm90b3R5cGUkLCAnYnVmZmVyJywgJ2InKTtcbiAgYWRkR2V0dGVyKCRUeXBlZEFycmF5UHJvdG90eXBlJCwgJ2J5dGVPZmZzZXQnLCAnbycpO1xuICBhZGRHZXR0ZXIoJFR5cGVkQXJyYXlQcm90b3R5cGUkLCAnYnl0ZUxlbmd0aCcsICdsJyk7XG4gIGFkZEdldHRlcigkVHlwZWRBcnJheVByb3RvdHlwZSQsICdsZW5ndGgnLCAnZScpO1xuICBkUCgkVHlwZWRBcnJheVByb3RvdHlwZSQsIFRBRywge1xuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpc1tUWVBFRF9BUlJBWV07IH1cbiAgfSk7XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1zdGF0ZW1lbnRzXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEtFWSwgQllURVMsIHdyYXBwZXIsIENMQU1QRUQpIHtcbiAgICBDTEFNUEVEID0gISFDTEFNUEVEO1xuICAgIHZhciBOQU1FID0gS0VZICsgKENMQU1QRUQgPyAnQ2xhbXBlZCcgOiAnJykgKyAnQXJyYXknO1xuICAgIHZhciBHRVRURVIgPSAnZ2V0JyArIEtFWTtcbiAgICB2YXIgU0VUVEVSID0gJ3NldCcgKyBLRVk7XG4gICAgdmFyIFR5cGVkQXJyYXkgPSBnbG9iYWxbTkFNRV07XG4gICAgdmFyIEJhc2UgPSBUeXBlZEFycmF5IHx8IHt9O1xuICAgIHZhciBUQUMgPSBUeXBlZEFycmF5ICYmIGdldFByb3RvdHlwZU9mKFR5cGVkQXJyYXkpO1xuICAgIHZhciBGT1JDRUQgPSAhVHlwZWRBcnJheSB8fCAhJHR5cGVkLkFCVjtcbiAgICB2YXIgTyA9IHt9O1xuICAgIHZhciBUeXBlZEFycmF5UHJvdG90eXBlID0gVHlwZWRBcnJheSAmJiBUeXBlZEFycmF5W1BST1RPVFlQRV07XG4gICAgdmFyIGdldHRlciA9IGZ1bmN0aW9uICh0aGF0LCBpbmRleCkge1xuICAgICAgdmFyIGRhdGEgPSB0aGF0Ll9kO1xuICAgICAgcmV0dXJuIGRhdGEudltHRVRURVJdKGluZGV4ICogQllURVMgKyBkYXRhLm8sIExJVFRMRV9FTkRJQU4pO1xuICAgIH07XG4gICAgdmFyIHNldHRlciA9IGZ1bmN0aW9uICh0aGF0LCBpbmRleCwgdmFsdWUpIHtcbiAgICAgIHZhciBkYXRhID0gdGhhdC5fZDtcbiAgICAgIGlmIChDTEFNUEVEKSB2YWx1ZSA9ICh2YWx1ZSA9IE1hdGgucm91bmQodmFsdWUpKSA8IDAgPyAwIDogdmFsdWUgPiAweGZmID8gMHhmZiA6IHZhbHVlICYgMHhmZjtcbiAgICAgIGRhdGEudltTRVRURVJdKGluZGV4ICogQllURVMgKyBkYXRhLm8sIHZhbHVlLCBMSVRUTEVfRU5ESUFOKTtcbiAgICB9O1xuICAgIHZhciBhZGRFbGVtZW50ID0gZnVuY3Rpb24gKHRoYXQsIGluZGV4KSB7XG4gICAgICBkUCh0aGF0LCBpbmRleCwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gZ2V0dGVyKHRoaXMsIGluZGV4KTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gc2V0dGVyKHRoaXMsIGluZGV4LCB2YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgIH07XG4gICAgaWYgKEZPUkNFRCkge1xuICAgICAgVHlwZWRBcnJheSA9IHdyYXBwZXIoZnVuY3Rpb24gKHRoYXQsIGRhdGEsICRvZmZzZXQsICRsZW5ndGgpIHtcbiAgICAgICAgYW5JbnN0YW5jZSh0aGF0LCBUeXBlZEFycmF5LCBOQU1FLCAnX2QnKTtcbiAgICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgICAgdmFyIG9mZnNldCA9IDA7XG4gICAgICAgIHZhciBidWZmZXIsIGJ5dGVMZW5ndGgsIGxlbmd0aCwga2xhc3M7XG4gICAgICAgIGlmICghaXNPYmplY3QoZGF0YSkpIHtcbiAgICAgICAgICBsZW5ndGggPSB0b0luZGV4KGRhdGEpO1xuICAgICAgICAgIGJ5dGVMZW5ndGggPSBsZW5ndGggKiBCWVRFUztcbiAgICAgICAgICBidWZmZXIgPSBuZXcgJEFycmF5QnVmZmVyKGJ5dGVMZW5ndGgpO1xuICAgICAgICB9IGVsc2UgaWYgKGRhdGEgaW5zdGFuY2VvZiAkQXJyYXlCdWZmZXIgfHwgKGtsYXNzID0gY2xhc3NvZihkYXRhKSkgPT0gQVJSQVlfQlVGRkVSIHx8IGtsYXNzID09IFNIQVJFRF9CVUZGRVIpIHtcbiAgICAgICAgICBidWZmZXIgPSBkYXRhO1xuICAgICAgICAgIG9mZnNldCA9IHRvT2Zmc2V0KCRvZmZzZXQsIEJZVEVTKTtcbiAgICAgICAgICB2YXIgJGxlbiA9IGRhdGEuYnl0ZUxlbmd0aDtcbiAgICAgICAgICBpZiAoJGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoJGxlbiAlIEJZVEVTKSB0aHJvdyBSYW5nZUVycm9yKFdST05HX0xFTkdUSCk7XG4gICAgICAgICAgICBieXRlTGVuZ3RoID0gJGxlbiAtIG9mZnNldDtcbiAgICAgICAgICAgIGlmIChieXRlTGVuZ3RoIDwgMCkgdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19MRU5HVEgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBieXRlTGVuZ3RoID0gdG9MZW5ndGgoJGxlbmd0aCkgKiBCWVRFUztcbiAgICAgICAgICAgIGlmIChieXRlTGVuZ3RoICsgb2Zmc2V0ID4gJGxlbikgdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19MRU5HVEgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZW5ndGggPSBieXRlTGVuZ3RoIC8gQllURVM7XG4gICAgICAgIH0gZWxzZSBpZiAoVFlQRURfQVJSQVkgaW4gZGF0YSkge1xuICAgICAgICAgIHJldHVybiBmcm9tTGlzdChUeXBlZEFycmF5LCBkYXRhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gJGZyb20uY2FsbChUeXBlZEFycmF5LCBkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBoaWRlKHRoYXQsICdfZCcsIHtcbiAgICAgICAgICBiOiBidWZmZXIsXG4gICAgICAgICAgbzogb2Zmc2V0LFxuICAgICAgICAgIGw6IGJ5dGVMZW5ndGgsXG4gICAgICAgICAgZTogbGVuZ3RoLFxuICAgICAgICAgIHY6IG5ldyAkRGF0YVZpZXcoYnVmZmVyKVxuICAgICAgICB9KTtcbiAgICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSBhZGRFbGVtZW50KHRoYXQsIGluZGV4KyspO1xuICAgICAgfSk7XG4gICAgICBUeXBlZEFycmF5UHJvdG90eXBlID0gVHlwZWRBcnJheVtQUk9UT1RZUEVdID0gY3JlYXRlKCRUeXBlZEFycmF5UHJvdG90eXBlJCk7XG4gICAgICBoaWRlKFR5cGVkQXJyYXlQcm90b3R5cGUsICdjb25zdHJ1Y3RvcicsIFR5cGVkQXJyYXkpO1xuICAgIH0gZWxzZSBpZiAoIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICAgIFR5cGVkQXJyYXkoMSk7XG4gICAgfSkgfHwgIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICAgIG5ldyBUeXBlZEFycmF5KC0xKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICB9KSB8fCAhJGl0ZXJEZXRlY3QoZnVuY3Rpb24gKGl0ZXIpIHtcbiAgICAgIG5ldyBUeXBlZEFycmF5KCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgICBuZXcgVHlwZWRBcnJheShudWxsKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICAgIG5ldyBUeXBlZEFycmF5KDEuNSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgICBuZXcgVHlwZWRBcnJheShpdGVyKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICB9LCB0cnVlKSkge1xuICAgICAgVHlwZWRBcnJheSA9IHdyYXBwZXIoZnVuY3Rpb24gKHRoYXQsIGRhdGEsICRvZmZzZXQsICRsZW5ndGgpIHtcbiAgICAgICAgYW5JbnN0YW5jZSh0aGF0LCBUeXBlZEFycmF5LCBOQU1FKTtcbiAgICAgICAgdmFyIGtsYXNzO1xuICAgICAgICAvLyBgd3NgIG1vZHVsZSBidWcsIHRlbXBvcmFyaWx5IHJlbW92ZSB2YWxpZGF0aW9uIGxlbmd0aCBmb3IgVWludDhBcnJheVxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vd2Vic29ja2V0cy93cy9wdWxsLzY0NVxuICAgICAgICBpZiAoIWlzT2JqZWN0KGRhdGEpKSByZXR1cm4gbmV3IEJhc2UodG9JbmRleChkYXRhKSk7XG4gICAgICAgIGlmIChkYXRhIGluc3RhbmNlb2YgJEFycmF5QnVmZmVyIHx8IChrbGFzcyA9IGNsYXNzb2YoZGF0YSkpID09IEFSUkFZX0JVRkZFUiB8fCBrbGFzcyA9PSBTSEFSRURfQlVGRkVSKSB7XG4gICAgICAgICAgcmV0dXJuICRsZW5ndGggIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyBuZXcgQmFzZShkYXRhLCB0b09mZnNldCgkb2Zmc2V0LCBCWVRFUyksICRsZW5ndGgpXG4gICAgICAgICAgICA6ICRvZmZzZXQgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICA/IG5ldyBCYXNlKGRhdGEsIHRvT2Zmc2V0KCRvZmZzZXQsIEJZVEVTKSlcbiAgICAgICAgICAgICAgOiBuZXcgQmFzZShkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoVFlQRURfQVJSQVkgaW4gZGF0YSkgcmV0dXJuIGZyb21MaXN0KFR5cGVkQXJyYXksIGRhdGEpO1xuICAgICAgICByZXR1cm4gJGZyb20uY2FsbChUeXBlZEFycmF5LCBkYXRhKTtcbiAgICAgIH0pO1xuICAgICAgYXJyYXlGb3JFYWNoKFRBQyAhPT0gRnVuY3Rpb24ucHJvdG90eXBlID8gZ09QTihCYXNlKS5jb25jYXQoZ09QTihUQUMpKSA6IGdPUE4oQmFzZSksIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKCEoa2V5IGluIFR5cGVkQXJyYXkpKSBoaWRlKFR5cGVkQXJyYXksIGtleSwgQmFzZVtrZXldKTtcbiAgICAgIH0pO1xuICAgICAgVHlwZWRBcnJheVtQUk9UT1RZUEVdID0gVHlwZWRBcnJheVByb3RvdHlwZTtcbiAgICAgIGlmICghTElCUkFSWSkgVHlwZWRBcnJheVByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFR5cGVkQXJyYXk7XG4gICAgfVxuICAgIHZhciAkbmF0aXZlSXRlcmF0b3IgPSBUeXBlZEFycmF5UHJvdG90eXBlW0lURVJBVE9SXTtcbiAgICB2YXIgQ09SUkVDVF9JVEVSX05BTUUgPSAhISRuYXRpdmVJdGVyYXRvclxuICAgICAgJiYgKCRuYXRpdmVJdGVyYXRvci5uYW1lID09ICd2YWx1ZXMnIHx8ICRuYXRpdmVJdGVyYXRvci5uYW1lID09IHVuZGVmaW5lZCk7XG4gICAgdmFyICRpdGVyYXRvciA9ICRpdGVyYXRvcnMudmFsdWVzO1xuICAgIGhpZGUoVHlwZWRBcnJheSwgVFlQRURfQ09OU1RSVUNUT1IsIHRydWUpO1xuICAgIGhpZGUoVHlwZWRBcnJheVByb3RvdHlwZSwgVFlQRURfQVJSQVksIE5BTUUpO1xuICAgIGhpZGUoVHlwZWRBcnJheVByb3RvdHlwZSwgVklFVywgdHJ1ZSk7XG4gICAgaGlkZShUeXBlZEFycmF5UHJvdG90eXBlLCBERUZfQ09OU1RSVUNUT1IsIFR5cGVkQXJyYXkpO1xuXG4gICAgaWYgKENMQU1QRUQgPyBuZXcgVHlwZWRBcnJheSgxKVtUQUddICE9IE5BTUUgOiAhKFRBRyBpbiBUeXBlZEFycmF5UHJvdG90eXBlKSkge1xuICAgICAgZFAoVHlwZWRBcnJheVByb3RvdHlwZSwgVEFHLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gTkFNRTsgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgT1tOQU1FXSA9IFR5cGVkQXJyYXk7XG5cbiAgICAkZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuVyArICRleHBvcnQuRiAqIChUeXBlZEFycmF5ICE9IEJhc2UpLCBPKTtcblxuICAgICRleHBvcnQoJGV4cG9ydC5TLCBOQU1FLCB7XG4gICAgICBCWVRFU19QRVJfRUxFTUVOVDogQllURVNcbiAgICB9KTtcblxuICAgICRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogZmFpbHMoZnVuY3Rpb24gKCkgeyBCYXNlLm9mLmNhbGwoVHlwZWRBcnJheSwgMSk7IH0pLCBOQU1FLCB7XG4gICAgICBmcm9tOiAkZnJvbSxcbiAgICAgIG9mOiAkb2ZcbiAgICB9KTtcblxuICAgIGlmICghKEJZVEVTX1BFUl9FTEVNRU5UIGluIFR5cGVkQXJyYXlQcm90b3R5cGUpKSBoaWRlKFR5cGVkQXJyYXlQcm90b3R5cGUsIEJZVEVTX1BFUl9FTEVNRU5ULCBCWVRFUyk7XG5cbiAgICAkZXhwb3J0KCRleHBvcnQuUCwgTkFNRSwgcHJvdG8pO1xuXG4gICAgc2V0U3BlY2llcyhOQU1FKTtcblxuICAgICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogRk9SQ0VEX1NFVCwgTkFNRSwgeyBzZXQ6ICRzZXQgfSk7XG5cbiAgICAkZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqICFDT1JSRUNUX0lURVJfTkFNRSwgTkFNRSwgJGl0ZXJhdG9ycyk7XG5cbiAgICBpZiAoIUxJQlJBUlkgJiYgVHlwZWRBcnJheVByb3RvdHlwZS50b1N0cmluZyAhPSBhcnJheVRvU3RyaW5nKSBUeXBlZEFycmF5UHJvdG90eXBlLnRvU3RyaW5nID0gYXJyYXlUb1N0cmluZztcblxuICAgICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgICAgbmV3IFR5cGVkQXJyYXkoMSkuc2xpY2UoKTtcbiAgICB9KSwgTkFNRSwgeyBzbGljZTogJHNsaWNlIH0pO1xuXG4gICAgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIFsxLCAyXS50b0xvY2FsZVN0cmluZygpICE9IG5ldyBUeXBlZEFycmF5KFsxLCAyXSkudG9Mb2NhbGVTdHJpbmcoKTtcbiAgICB9KSB8fCAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgICAgVHlwZWRBcnJheVByb3RvdHlwZS50b0xvY2FsZVN0cmluZy5jYWxsKFsxLCAyXSk7XG4gICAgfSkpLCBOQU1FLCB7IHRvTG9jYWxlU3RyaW5nOiAkdG9Mb2NhbGVTdHJpbmcgfSk7XG5cbiAgICBJdGVyYXRvcnNbTkFNRV0gPSBDT1JSRUNUX0lURVJfTkFNRSA/ICRuYXRpdmVJdGVyYXRvciA6ICRpdGVyYXRvcjtcbiAgICBpZiAoIUxJQlJBUlkgJiYgIUNPUlJFQ1RfSVRFUl9OQU1FKSBoaWRlKFR5cGVkQXJyYXlQcm90b3R5cGUsIElURVJBVE9SLCAkaXRlcmF0b3IpO1xuICB9O1xufSBlbHNlIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKTtcbnZhciBMSUJSQVJZID0gcmVxdWlyZSgnLi9fbGlicmFyeScpO1xudmFyICR0eXBlZCA9IHJlcXVpcmUoJy4vX3R5cGVkJyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciByZWRlZmluZUFsbCA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbnZhciBhbkluc3RhbmNlID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKTtcbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciB0b0luZGV4ID0gcmVxdWlyZSgnLi9fdG8taW5kZXgnKTtcbnZhciBnT1BOID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mO1xudmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbnZhciBhcnJheUZpbGwgPSByZXF1aXJlKCcuL19hcnJheS1maWxsJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIEFSUkFZX0JVRkZFUiA9ICdBcnJheUJ1ZmZlcic7XG52YXIgREFUQV9WSUVXID0gJ0RhdGFWaWV3JztcbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcbnZhciBXUk9OR19MRU5HVEggPSAnV3JvbmcgbGVuZ3RoISc7XG52YXIgV1JPTkdfSU5ERVggPSAnV3JvbmcgaW5kZXghJztcbnZhciAkQXJyYXlCdWZmZXIgPSBnbG9iYWxbQVJSQVlfQlVGRkVSXTtcbnZhciAkRGF0YVZpZXcgPSBnbG9iYWxbREFUQV9WSUVXXTtcbnZhciBNYXRoID0gZ2xvYmFsLk1hdGg7XG52YXIgUmFuZ2VFcnJvciA9IGdsb2JhbC5SYW5nZUVycm9yO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNoYWRvdy1yZXN0cmljdGVkLW5hbWVzXG52YXIgSW5maW5pdHkgPSBnbG9iYWwuSW5maW5pdHk7XG52YXIgQmFzZUJ1ZmZlciA9ICRBcnJheUJ1ZmZlcjtcbnZhciBhYnMgPSBNYXRoLmFicztcbnZhciBwb3cgPSBNYXRoLnBvdztcbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG52YXIgbG9nID0gTWF0aC5sb2c7XG52YXIgTE4yID0gTWF0aC5MTjI7XG52YXIgQlVGRkVSID0gJ2J1ZmZlcic7XG52YXIgQllURV9MRU5HVEggPSAnYnl0ZUxlbmd0aCc7XG52YXIgQllURV9PRkZTRVQgPSAnYnl0ZU9mZnNldCc7XG52YXIgJEJVRkZFUiA9IERFU0NSSVBUT1JTID8gJ19iJyA6IEJVRkZFUjtcbnZhciAkTEVOR1RIID0gREVTQ1JJUFRPUlMgPyAnX2wnIDogQllURV9MRU5HVEg7XG52YXIgJE9GRlNFVCA9IERFU0NSSVBUT1JTID8gJ19vJyA6IEJZVEVfT0ZGU0VUO1xuXG4vLyBJRUVFNzU0IGNvbnZlcnNpb25zIGJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvaWVlZTc1NFxuZnVuY3Rpb24gcGFja0lFRUU3NTQodmFsdWUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgYnVmZmVyID0gQXJyYXkobkJ5dGVzKTtcbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDE7XG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxO1xuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDE7XG4gIHZhciBydCA9IG1MZW4gPT09IDIzID8gcG93KDIsIC0yNCkgLSBwb3coMiwgLTc3KSA6IDA7XG4gIHZhciBpID0gMDtcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgdmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCA/IDEgOiAwO1xuICB2YXIgZSwgbSwgYztcbiAgdmFsdWUgPSBhYnModmFsdWUpO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gIGlmICh2YWx1ZSAhPSB2YWx1ZSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgbSA9IHZhbHVlICE9IHZhbHVlID8gMSA6IDA7XG4gICAgZSA9IGVNYXg7XG4gIH0gZWxzZSB7XG4gICAgZSA9IGZsb29yKGxvZyh2YWx1ZSkgLyBMTjIpO1xuICAgIGlmICh2YWx1ZSAqIChjID0gcG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS07XG4gICAgICBjICo9IDI7XG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIHBvdygyLCAxIC0gZUJpYXMpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrKztcbiAgICAgIGMgLz0gMjtcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMDtcbiAgICAgIGUgPSBlTWF4O1xuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAodmFsdWUgKiBjIC0gMSkgKiBwb3coMiwgbUxlbik7XG4gICAgICBlID0gZSArIGVCaWFzO1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBwb3coMiwgZUJpYXMgLSAxKSAqIHBvdygyLCBtTGVuKTtcbiAgICAgIGUgPSAwO1xuICAgIH1cbiAgfVxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbaSsrXSA9IG0gJiAyNTUsIG0gLz0gMjU2LCBtTGVuIC09IDgpO1xuICBlID0gZSA8PCBtTGVuIHwgbTtcbiAgZUxlbiArPSBtTGVuO1xuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltpKytdID0gZSAmIDI1NSwgZSAvPSAyNTYsIGVMZW4gLT0gOCk7XG4gIGJ1ZmZlclstLWldIHw9IHMgKiAxMjg7XG4gIHJldHVybiBidWZmZXI7XG59XG5mdW5jdGlvbiB1bnBhY2tJRUVFNzU0KGJ1ZmZlciwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxO1xuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMTtcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxO1xuICB2YXIgbkJpdHMgPSBlTGVuIC0gNztcbiAgdmFyIGkgPSBuQnl0ZXMgLSAxO1xuICB2YXIgcyA9IGJ1ZmZlcltpLS1dO1xuICB2YXIgZSA9IHMgJiAxMjc7XG4gIHZhciBtO1xuICBzID4+PSA3O1xuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gZSAqIDI1NiArIGJ1ZmZlcltpXSwgaS0tLCBuQml0cyAtPSA4KTtcbiAgbSA9IGUgJiAoMSA8PCAtbkJpdHMpIC0gMTtcbiAgZSA+Pj0gLW5CaXRzO1xuICBuQml0cyArPSBtTGVuO1xuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gbSAqIDI1NiArIGJ1ZmZlcltpXSwgaS0tLCBuQml0cyAtPSA4KTtcbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzO1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6IHMgPyAtSW5maW5pdHkgOiBJbmZpbml0eTtcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIHBvdygyLCBtTGVuKTtcbiAgICBlID0gZSAtIGVCaWFzO1xuICB9IHJldHVybiAocyA/IC0xIDogMSkgKiBtICogcG93KDIsIGUgLSBtTGVuKTtcbn1cblxuZnVuY3Rpb24gdW5wYWNrSTMyKGJ5dGVzKSB7XG4gIHJldHVybiBieXRlc1szXSA8PCAyNCB8IGJ5dGVzWzJdIDw8IDE2IHwgYnl0ZXNbMV0gPDwgOCB8IGJ5dGVzWzBdO1xufVxuZnVuY3Rpb24gcGFja0k4KGl0KSB7XG4gIHJldHVybiBbaXQgJiAweGZmXTtcbn1cbmZ1bmN0aW9uIHBhY2tJMTYoaXQpIHtcbiAgcmV0dXJuIFtpdCAmIDB4ZmYsIGl0ID4+IDggJiAweGZmXTtcbn1cbmZ1bmN0aW9uIHBhY2tJMzIoaXQpIHtcbiAgcmV0dXJuIFtpdCAmIDB4ZmYsIGl0ID4+IDggJiAweGZmLCBpdCA+PiAxNiAmIDB4ZmYsIGl0ID4+IDI0ICYgMHhmZl07XG59XG5mdW5jdGlvbiBwYWNrRjY0KGl0KSB7XG4gIHJldHVybiBwYWNrSUVFRTc1NChpdCwgNTIsIDgpO1xufVxuZnVuY3Rpb24gcGFja0YzMihpdCkge1xuICByZXR1cm4gcGFja0lFRUU3NTQoaXQsIDIzLCA0KTtcbn1cblxuZnVuY3Rpb24gYWRkR2V0dGVyKEMsIGtleSwgaW50ZXJuYWwpIHtcbiAgZFAoQ1tQUk9UT1RZUEVdLCBrZXksIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzW2ludGVybmFsXTsgfSB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0KHZpZXcsIGJ5dGVzLCBpbmRleCwgaXNMaXR0bGVFbmRpYW4pIHtcbiAgdmFyIG51bUluZGV4ID0gK2luZGV4O1xuICB2YXIgaW50SW5kZXggPSB0b0luZGV4KG51bUluZGV4KTtcbiAgaWYgKGludEluZGV4ICsgYnl0ZXMgPiB2aWV3WyRMRU5HVEhdKSB0aHJvdyBSYW5nZUVycm9yKFdST05HX0lOREVYKTtcbiAgdmFyIHN0b3JlID0gdmlld1skQlVGRkVSXS5fYjtcbiAgdmFyIHN0YXJ0ID0gaW50SW5kZXggKyB2aWV3WyRPRkZTRVRdO1xuICB2YXIgcGFjayA9IHN0b3JlLnNsaWNlKHN0YXJ0LCBzdGFydCArIGJ5dGVzKTtcbiAgcmV0dXJuIGlzTGl0dGxlRW5kaWFuID8gcGFjayA6IHBhY2sucmV2ZXJzZSgpO1xufVxuZnVuY3Rpb24gc2V0KHZpZXcsIGJ5dGVzLCBpbmRleCwgY29udmVyc2lvbiwgdmFsdWUsIGlzTGl0dGxlRW5kaWFuKSB7XG4gIHZhciBudW1JbmRleCA9ICtpbmRleDtcbiAgdmFyIGludEluZGV4ID0gdG9JbmRleChudW1JbmRleCk7XG4gIGlmIChpbnRJbmRleCArIGJ5dGVzID4gdmlld1skTEVOR1RIXSkgdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19JTkRFWCk7XG4gIHZhciBzdG9yZSA9IHZpZXdbJEJVRkZFUl0uX2I7XG4gIHZhciBzdGFydCA9IGludEluZGV4ICsgdmlld1skT0ZGU0VUXTtcbiAgdmFyIHBhY2sgPSBjb252ZXJzaW9uKCt2YWx1ZSk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXM7IGkrKykgc3RvcmVbc3RhcnQgKyBpXSA9IHBhY2tbaXNMaXR0bGVFbmRpYW4gPyBpIDogYnl0ZXMgLSBpIC0gMV07XG59XG5cbmlmICghJHR5cGVkLkFCVikge1xuICAkQXJyYXlCdWZmZXIgPSBmdW5jdGlvbiBBcnJheUJ1ZmZlcihsZW5ndGgpIHtcbiAgICBhbkluc3RhbmNlKHRoaXMsICRBcnJheUJ1ZmZlciwgQVJSQVlfQlVGRkVSKTtcbiAgICB2YXIgYnl0ZUxlbmd0aCA9IHRvSW5kZXgobGVuZ3RoKTtcbiAgICB0aGlzLl9iID0gYXJyYXlGaWxsLmNhbGwoQXJyYXkoYnl0ZUxlbmd0aCksIDApO1xuICAgIHRoaXNbJExFTkdUSF0gPSBieXRlTGVuZ3RoO1xuICB9O1xuXG4gICREYXRhVmlldyA9IGZ1bmN0aW9uIERhdGFWaWV3KGJ1ZmZlciwgYnl0ZU9mZnNldCwgYnl0ZUxlbmd0aCkge1xuICAgIGFuSW5zdGFuY2UodGhpcywgJERhdGFWaWV3LCBEQVRBX1ZJRVcpO1xuICAgIGFuSW5zdGFuY2UoYnVmZmVyLCAkQXJyYXlCdWZmZXIsIERBVEFfVklFVyk7XG4gICAgdmFyIGJ1ZmZlckxlbmd0aCA9IGJ1ZmZlclskTEVOR1RIXTtcbiAgICB2YXIgb2Zmc2V0ID0gdG9JbnRlZ2VyKGJ5dGVPZmZzZXQpO1xuICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCA+IGJ1ZmZlckxlbmd0aCkgdGhyb3cgUmFuZ2VFcnJvcignV3Jvbmcgb2Zmc2V0IScpO1xuICAgIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID09PSB1bmRlZmluZWQgPyBidWZmZXJMZW5ndGggLSBvZmZzZXQgOiB0b0xlbmd0aChieXRlTGVuZ3RoKTtcbiAgICBpZiAob2Zmc2V0ICsgYnl0ZUxlbmd0aCA+IGJ1ZmZlckxlbmd0aCkgdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19MRU5HVEgpO1xuICAgIHRoaXNbJEJVRkZFUl0gPSBidWZmZXI7XG4gICAgdGhpc1skT0ZGU0VUXSA9IG9mZnNldDtcbiAgICB0aGlzWyRMRU5HVEhdID0gYnl0ZUxlbmd0aDtcbiAgfTtcblxuICBpZiAoREVTQ1JJUFRPUlMpIHtcbiAgICBhZGRHZXR0ZXIoJEFycmF5QnVmZmVyLCBCWVRFX0xFTkdUSCwgJ19sJyk7XG4gICAgYWRkR2V0dGVyKCREYXRhVmlldywgQlVGRkVSLCAnX2InKTtcbiAgICBhZGRHZXR0ZXIoJERhdGFWaWV3LCBCWVRFX0xFTkdUSCwgJ19sJyk7XG4gICAgYWRkR2V0dGVyKCREYXRhVmlldywgQllURV9PRkZTRVQsICdfbycpO1xuICB9XG5cbiAgcmVkZWZpbmVBbGwoJERhdGFWaWV3W1BST1RPVFlQRV0sIHtcbiAgICBnZXRJbnQ4OiBmdW5jdGlvbiBnZXRJbnQ4KGJ5dGVPZmZzZXQpIHtcbiAgICAgIHJldHVybiBnZXQodGhpcywgMSwgYnl0ZU9mZnNldClbMF0gPDwgMjQgPj4gMjQ7XG4gICAgfSxcbiAgICBnZXRVaW50ODogZnVuY3Rpb24gZ2V0VWludDgoYnl0ZU9mZnNldCkge1xuICAgICAgcmV0dXJuIGdldCh0aGlzLCAxLCBieXRlT2Zmc2V0KVswXTtcbiAgICB9LFxuICAgIGdldEludDE2OiBmdW5jdGlvbiBnZXRJbnQxNihieXRlT2Zmc2V0IC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICB2YXIgYnl0ZXMgPSBnZXQodGhpcywgMiwgYnl0ZU9mZnNldCwgYXJndW1lbnRzWzFdKTtcbiAgICAgIHJldHVybiAoYnl0ZXNbMV0gPDwgOCB8IGJ5dGVzWzBdKSA8PCAxNiA+PiAxNjtcbiAgICB9LFxuICAgIGdldFVpbnQxNjogZnVuY3Rpb24gZ2V0VWludDE2KGJ5dGVPZmZzZXQgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHZhciBieXRlcyA9IGdldCh0aGlzLCAyLCBieXRlT2Zmc2V0LCBhcmd1bWVudHNbMV0pO1xuICAgICAgcmV0dXJuIGJ5dGVzWzFdIDw8IDggfCBieXRlc1swXTtcbiAgICB9LFxuICAgIGdldEludDMyOiBmdW5jdGlvbiBnZXRJbnQzMihieXRlT2Zmc2V0IC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICByZXR1cm4gdW5wYWNrSTMyKGdldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBhcmd1bWVudHNbMV0pKTtcbiAgICB9LFxuICAgIGdldFVpbnQzMjogZnVuY3Rpb24gZ2V0VWludDMyKGJ5dGVPZmZzZXQgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHJldHVybiB1bnBhY2tJMzIoZ2V0KHRoaXMsIDQsIGJ5dGVPZmZzZXQsIGFyZ3VtZW50c1sxXSkpID4+PiAwO1xuICAgIH0sXG4gICAgZ2V0RmxvYXQzMjogZnVuY3Rpb24gZ2V0RmxvYXQzMihieXRlT2Zmc2V0IC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICByZXR1cm4gdW5wYWNrSUVFRTc1NChnZXQodGhpcywgNCwgYnl0ZU9mZnNldCwgYXJndW1lbnRzWzFdKSwgMjMsIDQpO1xuICAgIH0sXG4gICAgZ2V0RmxvYXQ2NDogZnVuY3Rpb24gZ2V0RmxvYXQ2NChieXRlT2Zmc2V0IC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICByZXR1cm4gdW5wYWNrSUVFRTc1NChnZXQodGhpcywgOCwgYnl0ZU9mZnNldCwgYXJndW1lbnRzWzFdKSwgNTIsIDgpO1xuICAgIH0sXG4gICAgc2V0SW50ODogZnVuY3Rpb24gc2V0SW50OChieXRlT2Zmc2V0LCB2YWx1ZSkge1xuICAgICAgc2V0KHRoaXMsIDEsIGJ5dGVPZmZzZXQsIHBhY2tJOCwgdmFsdWUpO1xuICAgIH0sXG4gICAgc2V0VWludDg6IGZ1bmN0aW9uIHNldFVpbnQ4KGJ5dGVPZmZzZXQsIHZhbHVlKSB7XG4gICAgICBzZXQodGhpcywgMSwgYnl0ZU9mZnNldCwgcGFja0k4LCB2YWx1ZSk7XG4gICAgfSxcbiAgICBzZXRJbnQxNjogZnVuY3Rpb24gc2V0SW50MTYoYnl0ZU9mZnNldCwgdmFsdWUgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHNldCh0aGlzLCAyLCBieXRlT2Zmc2V0LCBwYWNrSTE2LCB2YWx1ZSwgYXJndW1lbnRzWzJdKTtcbiAgICB9LFxuICAgIHNldFVpbnQxNjogZnVuY3Rpb24gc2V0VWludDE2KGJ5dGVPZmZzZXQsIHZhbHVlIC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICBzZXQodGhpcywgMiwgYnl0ZU9mZnNldCwgcGFja0kxNiwgdmFsdWUsIGFyZ3VtZW50c1syXSk7XG4gICAgfSxcbiAgICBzZXRJbnQzMjogZnVuY3Rpb24gc2V0SW50MzIoYnl0ZU9mZnNldCwgdmFsdWUgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHNldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBwYWNrSTMyLCB2YWx1ZSwgYXJndW1lbnRzWzJdKTtcbiAgICB9LFxuICAgIHNldFVpbnQzMjogZnVuY3Rpb24gc2V0VWludDMyKGJ5dGVPZmZzZXQsIHZhbHVlIC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICBzZXQodGhpcywgNCwgYnl0ZU9mZnNldCwgcGFja0kzMiwgdmFsdWUsIGFyZ3VtZW50c1syXSk7XG4gICAgfSxcbiAgICBzZXRGbG9hdDMyOiBmdW5jdGlvbiBzZXRGbG9hdDMyKGJ5dGVPZmZzZXQsIHZhbHVlIC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICBzZXQodGhpcywgNCwgYnl0ZU9mZnNldCwgcGFja0YzMiwgdmFsdWUsIGFyZ3VtZW50c1syXSk7XG4gICAgfSxcbiAgICBzZXRGbG9hdDY0OiBmdW5jdGlvbiBzZXRGbG9hdDY0KGJ5dGVPZmZzZXQsIHZhbHVlIC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICBzZXQodGhpcywgOCwgYnl0ZU9mZnNldCwgcGFja0Y2NCwgdmFsdWUsIGFyZ3VtZW50c1syXSk7XG4gICAgfVxuICB9KTtcbn0gZWxzZSB7XG4gIGlmICghZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgICRBcnJheUJ1ZmZlcigxKTtcbiAgfSkgfHwgIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICBuZXcgJEFycmF5QnVmZmVyKC0xKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgfSkgfHwgZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIG5ldyAkQXJyYXlCdWZmZXIoKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICBuZXcgJEFycmF5QnVmZmVyKDEuNSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgbmV3ICRBcnJheUJ1ZmZlcihOYU4pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgIHJldHVybiAkQXJyYXlCdWZmZXIubmFtZSAhPSBBUlJBWV9CVUZGRVI7XG4gIH0pKSB7XG4gICAgJEFycmF5QnVmZmVyID0gZnVuY3Rpb24gQXJyYXlCdWZmZXIobGVuZ3RoKSB7XG4gICAgICBhbkluc3RhbmNlKHRoaXMsICRBcnJheUJ1ZmZlcik7XG4gICAgICByZXR1cm4gbmV3IEJhc2VCdWZmZXIodG9JbmRleChsZW5ndGgpKTtcbiAgICB9O1xuICAgIHZhciBBcnJheUJ1ZmZlclByb3RvID0gJEFycmF5QnVmZmVyW1BST1RPVFlQRV0gPSBCYXNlQnVmZmVyW1BST1RPVFlQRV07XG4gICAgZm9yICh2YXIga2V5cyA9IGdPUE4oQmFzZUJ1ZmZlciksIGogPSAwLCBrZXk7IGtleXMubGVuZ3RoID4gajspIHtcbiAgICAgIGlmICghKChrZXkgPSBrZXlzW2orK10pIGluICRBcnJheUJ1ZmZlcikpIGhpZGUoJEFycmF5QnVmZmVyLCBrZXksIEJhc2VCdWZmZXJba2V5XSk7XG4gICAgfVxuICAgIGlmICghTElCUkFSWSkgQXJyYXlCdWZmZXJQcm90by5jb25zdHJ1Y3RvciA9ICRBcnJheUJ1ZmZlcjtcbiAgfVxuICAvLyBpT1MgU2FmYXJpIDcueCBidWdcbiAgdmFyIHZpZXcgPSBuZXcgJERhdGFWaWV3KG5ldyAkQXJyYXlCdWZmZXIoMikpO1xuICB2YXIgJHNldEludDggPSAkRGF0YVZpZXdbUFJPVE9UWVBFXS5zZXRJbnQ4O1xuICB2aWV3LnNldEludDgoMCwgMjE0NzQ4MzY0OCk7XG4gIHZpZXcuc2V0SW50OCgxLCAyMTQ3NDgzNjQ5KTtcbiAgaWYgKHZpZXcuZ2V0SW50OCgwKSB8fCAhdmlldy5nZXRJbnQ4KDEpKSByZWRlZmluZUFsbCgkRGF0YVZpZXdbUFJPVE9UWVBFXSwge1xuICAgIHNldEludDg6IGZ1bmN0aW9uIHNldEludDgoYnl0ZU9mZnNldCwgdmFsdWUpIHtcbiAgICAgICRzZXRJbnQ4LmNhbGwodGhpcywgYnl0ZU9mZnNldCwgdmFsdWUgPDwgMjQgPj4gMjQpO1xuICAgIH0sXG4gICAgc2V0VWludDg6IGZ1bmN0aW9uIHNldFVpbnQ4KGJ5dGVPZmZzZXQsIHZhbHVlKSB7XG4gICAgICAkc2V0SW50OC5jYWxsKHRoaXMsIGJ5dGVPZmZzZXQsIHZhbHVlIDw8IDI0ID4+IDI0KTtcbiAgICB9XG4gIH0sIHRydWUpO1xufVxuc2V0VG9TdHJpbmdUYWcoJEFycmF5QnVmZmVyLCBBUlJBWV9CVUZGRVIpO1xuc2V0VG9TdHJpbmdUYWcoJERhdGFWaWV3LCBEQVRBX1ZJRVcpO1xuaGlkZSgkRGF0YVZpZXdbUFJPVE9UWVBFXSwgJHR5cGVkLlZJRVcsIHRydWUpO1xuZXhwb3J0c1tBUlJBWV9CVUZGRVJdID0gJEFycmF5QnVmZmVyO1xuZXhwb3J0c1tEQVRBX1ZJRVddID0gJERhdGFWaWV3O1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG52YXIgdWlkID0gcmVxdWlyZSgnLi9fdWlkJyk7XG52YXIgVFlQRUQgPSB1aWQoJ3R5cGVkX2FycmF5Jyk7XG52YXIgVklFVyA9IHVpZCgndmlldycpO1xudmFyIEFCViA9ICEhKGdsb2JhbC5BcnJheUJ1ZmZlciAmJiBnbG9iYWwuRGF0YVZpZXcpO1xudmFyIENPTlNUUiA9IEFCVjtcbnZhciBpID0gMDtcbnZhciBsID0gOTtcbnZhciBUeXBlZDtcblxudmFyIFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnMgPSAoXG4gICdJbnQ4QXJyYXksVWludDhBcnJheSxVaW50OENsYW1wZWRBcnJheSxJbnQxNkFycmF5LFVpbnQxNkFycmF5LEludDMyQXJyYXksVWludDMyQXJyYXksRmxvYXQzMkFycmF5LEZsb2F0NjRBcnJheSdcbikuc3BsaXQoJywnKTtcblxud2hpbGUgKGkgPCBsKSB7XG4gIGlmIChUeXBlZCA9IGdsb2JhbFtUeXBlZEFycmF5Q29uc3RydWN0b3JzW2krK11dKSB7XG4gICAgaGlkZShUeXBlZC5wcm90b3R5cGUsIFRZUEVELCB0cnVlKTtcbiAgICBoaWRlKFR5cGVkLnByb3RvdHlwZSwgVklFVywgdHJ1ZSk7XG4gIH0gZWxzZSBDT05TVFIgPSBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEFCVjogQUJWLFxuICBDT05TVFI6IENPTlNUUixcbiAgVFlQRUQ6IFRZUEVELFxuICBWSUVXOiBWSUVXXG59O1xuIiwidmFyIGlkID0gMDtcbnZhciBweCA9IE1hdGgucmFuZG9tKCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuICdTeW1ib2woJy5jb25jYXQoa2V5ID09PSB1bmRlZmluZWQgPyAnJyA6IGtleSwgJylfJywgKCsraWQgKyBweCkudG9TdHJpbmcoMzYpKTtcbn07XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBUWVBFKSB7XG4gIGlmICghaXNPYmplY3QoaXQpIHx8IGl0Ll90ICE9PSBUWVBFKSB0aHJvdyBUeXBlRXJyb3IoJ0luY29tcGF0aWJsZSByZWNlaXZlciwgJyArIFRZUEUgKyAnIHJlcXVpcmVkIScpO1xuICByZXR1cm4gaXQ7XG59O1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGNvcmUgPSByZXF1aXJlKCcuL19jb3JlJyk7XG52YXIgTElCUkFSWSA9IHJlcXVpcmUoJy4vX2xpYnJhcnknKTtcbnZhciB3a3NFeHQgPSByZXF1aXJlKCcuL193a3MtZXh0Jyk7XG52YXIgZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobmFtZSkge1xuICB2YXIgJFN5bWJvbCA9IGNvcmUuU3ltYm9sIHx8IChjb3JlLlN5bWJvbCA9IExJQlJBUlkgPyB7fSA6IGdsb2JhbC5TeW1ib2wgfHwge30pO1xuICBpZiAobmFtZS5jaGFyQXQoMCkgIT0gJ18nICYmICEobmFtZSBpbiAkU3ltYm9sKSkgZGVmaW5lUHJvcGVydHkoJFN5bWJvbCwgbmFtZSwgeyB2YWx1ZTogd2tzRXh0LmYobmFtZSkgfSk7XG59O1xuIiwiZXhwb3J0cy5mID0gcmVxdWlyZSgnLi9fd2tzJyk7XG4iLCJ2YXIgc3RvcmUgPSByZXF1aXJlKCcuL19zaGFyZWQnKSgnd2tzJyk7XG52YXIgdWlkID0gcmVxdWlyZSgnLi9fdWlkJyk7XG52YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuU3ltYm9sO1xudmFyIFVTRV9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09ICdmdW5jdGlvbic7XG5cbnZhciAkZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIHN0b3JlW25hbWVdIHx8IChzdG9yZVtuYW1lXSA9XG4gICAgVVNFX1NZTUJPTCAmJiBTeW1ib2xbbmFtZV0gfHwgKFVTRV9TWU1CT0wgPyBTeW1ib2wgOiB1aWQpKCdTeW1ib2wuJyArIG5hbWUpKTtcbn07XG5cbiRleHBvcnRzLnN0b3JlID0gc3RvcmU7XG4iLCJ2YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4vX2NsYXNzb2YnKTtcbnZhciBJVEVSQVRPUiA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19jb3JlJykuZ2V0SXRlcmF0b3JNZXRob2QgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKGl0ICE9IHVuZGVmaW5lZCkgcmV0dXJuIGl0W0lURVJBVE9SXVxuICAgIHx8IGl0WydAQGl0ZXJhdG9yJ11cbiAgICB8fCBJdGVyYXRvcnNbY2xhc3NvZihpdCldO1xufTtcbiIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9iZW5qYW1pbmdyL1JleEV4cC5lc2NhcGVcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJHJlID0gcmVxdWlyZSgnLi9fcmVwbGFjZXInKSgvW1xcXFxeJCorPy4oKXxbXFxde31dL2csICdcXFxcJCYnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWdFeHAnLCB7IGVzY2FwZTogZnVuY3Rpb24gZXNjYXBlKGl0KSB7IHJldHVybiAkcmUoaXQpOyB9IH0pO1xuIiwiLy8gMjIuMS4zLjMgQXJyYXkucHJvdG90eXBlLmNvcHlXaXRoaW4odGFyZ2V0LCBzdGFydCwgZW5kID0gdGhpcy5sZW5ndGgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCwgJ0FycmF5JywgeyBjb3B5V2l0aGluOiByZXF1aXJlKCcuL19hcnJheS1jb3B5LXdpdGhpbicpIH0pO1xuXG5yZXF1aXJlKCcuL19hZGQtdG8tdW5zY29wYWJsZXMnKSgnY29weVdpdGhpbicpO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkZXZlcnkgPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJykoNCk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKShbXS5ldmVyeSwgdHJ1ZSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjUgLyAxNS40LjQuMTYgQXJyYXkucHJvdG90eXBlLmV2ZXJ5KGNhbGxiYWNrZm4gWywgdGhpc0FyZ10pXG4gIGV2ZXJ5OiBmdW5jdGlvbiBldmVyeShjYWxsYmFja2ZuIC8qICwgdGhpc0FyZyAqLykge1xuICAgIHJldHVybiAkZXZlcnkodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzWzFdKTtcbiAgfVxufSk7XG4iLCIvLyAyMi4xLjMuNiBBcnJheS5wcm90b3R5cGUuZmlsbCh2YWx1ZSwgc3RhcnQgPSAwLCBlbmQgPSB0aGlzLmxlbmd0aClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QLCAnQXJyYXknLCB7IGZpbGw6IHJlcXVpcmUoJy4vX2FycmF5LWZpbGwnKSB9KTtcblxucmVxdWlyZSgnLi9fYWRkLXRvLXVuc2NvcGFibGVzJykoJ2ZpbGwnKTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJGZpbHRlciA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKSgyKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKFtdLmZpbHRlciwgdHJ1ZSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjcgLyAxNS40LjQuMjAgQXJyYXkucHJvdG90eXBlLmZpbHRlcihjYWxsYmFja2ZuIFssIHRoaXNBcmddKVxuICBmaWx0ZXI6IGZ1bmN0aW9uIGZpbHRlcihjYWxsYmFja2ZuIC8qICwgdGhpc0FyZyAqLykge1xuICAgIHJldHVybiAkZmlsdGVyKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50c1sxXSk7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gMjIuMS4zLjkgQXJyYXkucHJvdG90eXBlLmZpbmRJbmRleChwcmVkaWNhdGUsIHRoaXNBcmcgPSB1bmRlZmluZWQpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRmaW5kID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpKDYpO1xudmFyIEtFWSA9ICdmaW5kSW5kZXgnO1xudmFyIGZvcmNlZCA9IHRydWU7XG4vLyBTaG91bGRuJ3Qgc2tpcCBob2xlc1xuaWYgKEtFWSBpbiBbXSkgQXJyYXkoMSlbS0VZXShmdW5jdGlvbiAoKSB7IGZvcmNlZCA9IGZhbHNlOyB9KTtcbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogZm9yY2VkLCAnQXJyYXknLCB7XG4gIGZpbmRJbmRleDogZnVuY3Rpb24gZmluZEluZGV4KGNhbGxiYWNrZm4gLyogLCB0aGF0ID0gdW5kZWZpbmVkICovKSB7XG4gICAgcmV0dXJuICRmaW5kKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgfVxufSk7XG5yZXF1aXJlKCcuL19hZGQtdG8tdW5zY29wYWJsZXMnKShLRVkpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gMjIuMS4zLjggQXJyYXkucHJvdG90eXBlLmZpbmQocHJlZGljYXRlLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkZmluZCA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKSg1KTtcbnZhciBLRVkgPSAnZmluZCc7XG52YXIgZm9yY2VkID0gdHJ1ZTtcbi8vIFNob3VsZG4ndCBza2lwIGhvbGVzXG5pZiAoS0VZIGluIFtdKSBBcnJheSgxKVtLRVldKGZ1bmN0aW9uICgpIHsgZm9yY2VkID0gZmFsc2U7IH0pO1xuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiBmb3JjZWQsICdBcnJheScsIHtcbiAgZmluZDogZnVuY3Rpb24gZmluZChjYWxsYmFja2ZuIC8qICwgdGhhdCA9IHVuZGVmaW5lZCAqLykge1xuICAgIHJldHVybiAkZmluZCh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gIH1cbn0pO1xucmVxdWlyZSgnLi9fYWRkLXRvLXVuc2NvcGFibGVzJykoS0VZKTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJGZvckVhY2ggPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJykoMCk7XG52YXIgU1RSSUNUID0gcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKFtdLmZvckVhY2gsIHRydWUpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqICFTVFJJQ1QsICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjEwIC8gMTUuNC40LjE4IEFycmF5LnByb3RvdHlwZS5mb3JFYWNoKGNhbGxiYWNrZm4gWywgdGhpc0FyZ10pXG4gIGZvckVhY2g6IGZ1bmN0aW9uIGZvckVhY2goY2FsbGJhY2tmbiAvKiAsIHRoaXNBcmcgKi8pIHtcbiAgICByZXR1cm4gJGZvckVhY2godGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzWzFdKTtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgY2FsbCA9IHJlcXVpcmUoJy4vX2l0ZXItY2FsbCcpO1xudmFyIGlzQXJyYXlJdGVyID0gcmVxdWlyZSgnLi9faXMtYXJyYXktaXRlcicpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgY3JlYXRlUHJvcGVydHkgPSByZXF1aXJlKCcuL19jcmVhdGUtcHJvcGVydHknKTtcbnZhciBnZXRJdGVyRm4gPSByZXF1aXJlKCcuL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19pdGVyLWRldGVjdCcpKGZ1bmN0aW9uIChpdGVyKSB7IEFycmF5LmZyb20oaXRlcik7IH0pLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMi4xIEFycmF5LmZyb20oYXJyYXlMaWtlLCBtYXBmbiA9IHVuZGVmaW5lZCwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbiAgZnJvbTogZnVuY3Rpb24gZnJvbShhcnJheUxpa2UgLyogLCBtYXBmbiA9IHVuZGVmaW5lZCwgdGhpc0FyZyA9IHVuZGVmaW5lZCAqLykge1xuICAgIHZhciBPID0gdG9PYmplY3QoYXJyYXlMaWtlKTtcbiAgICB2YXIgQyA9IHR5cGVvZiB0aGlzID09ICdmdW5jdGlvbicgPyB0aGlzIDogQXJyYXk7XG4gICAgdmFyIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBtYXBmbiA9IGFMZW4gPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICAgIHZhciBtYXBwaW5nID0gbWFwZm4gIT09IHVuZGVmaW5lZDtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBpdGVyRm4gPSBnZXRJdGVyRm4oTyk7XG4gICAgdmFyIGxlbmd0aCwgcmVzdWx0LCBzdGVwLCBpdGVyYXRvcjtcbiAgICBpZiAobWFwcGluZykgbWFwZm4gPSBjdHgobWFwZm4sIGFMZW4gPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkLCAyKTtcbiAgICAvLyBpZiBvYmplY3QgaXNuJ3QgaXRlcmFibGUgb3IgaXQncyBhcnJheSB3aXRoIGRlZmF1bHQgaXRlcmF0b3IgLSB1c2Ugc2ltcGxlIGNhc2VcbiAgICBpZiAoaXRlckZuICE9IHVuZGVmaW5lZCAmJiAhKEMgPT0gQXJyYXkgJiYgaXNBcnJheUl0ZXIoaXRlckZuKSkpIHtcbiAgICAgIGZvciAoaXRlcmF0b3IgPSBpdGVyRm4uY2FsbChPKSwgcmVzdWx0ID0gbmV3IEMoKTsgIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lOyBpbmRleCsrKSB7XG4gICAgICAgIGNyZWF0ZVByb3BlcnR5KHJlc3VsdCwgaW5kZXgsIG1hcHBpbmcgPyBjYWxsKGl0ZXJhdG9yLCBtYXBmbiwgW3N0ZXAudmFsdWUsIGluZGV4XSwgdHJ1ZSkgOiBzdGVwLnZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICAgICAgZm9yIChyZXN1bHQgPSBuZXcgQyhsZW5ndGgpOyBsZW5ndGggPiBpbmRleDsgaW5kZXgrKykge1xuICAgICAgICBjcmVhdGVQcm9wZXJ0eShyZXN1bHQsIGluZGV4LCBtYXBwaW5nID8gbWFwZm4oT1tpbmRleF0sIGluZGV4KSA6IE9baW5kZXhdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0Lmxlbmd0aCA9IGluZGV4O1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkaW5kZXhPZiA9IHJlcXVpcmUoJy4vX2FycmF5LWluY2x1ZGVzJykoZmFsc2UpO1xudmFyICRuYXRpdmUgPSBbXS5pbmRleE9mO1xudmFyIE5FR0FUSVZFX1pFUk8gPSAhISRuYXRpdmUgJiYgMSAvIFsxXS5pbmRleE9mKDEsIC0wKSA8IDA7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKE5FR0FUSVZFX1pFUk8gfHwgIXJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKSgkbmF0aXZlKSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjExIC8gMTUuNC40LjE0IEFycmF5LnByb3RvdHlwZS5pbmRleE9mKHNlYXJjaEVsZW1lbnQgWywgZnJvbUluZGV4XSlcbiAgaW5kZXhPZjogZnVuY3Rpb24gaW5kZXhPZihzZWFyY2hFbGVtZW50IC8qICwgZnJvbUluZGV4ID0gMCAqLykge1xuICAgIHJldHVybiBORUdBVElWRV9aRVJPXG4gICAgICAvLyBjb252ZXJ0IC0wIHRvICswXG4gICAgICA/ICRuYXRpdmUuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCAwXG4gICAgICA6ICRpbmRleE9mKHRoaXMsIHNlYXJjaEVsZW1lbnQsIGFyZ3VtZW50c1sxXSk7XG4gIH1cbn0pO1xuIiwiLy8gMjIuMS4yLjIgLyAxNS40LjMuMiBBcnJheS5pc0FycmF5KGFyZylcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnQXJyYXknLCB7IGlzQXJyYXk6IHJlcXVpcmUoJy4vX2lzLWFycmF5JykgfSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgYWRkVG9VbnNjb3BhYmxlcyA9IHJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpO1xudmFyIHN0ZXAgPSByZXF1aXJlKCcuL19pdGVyLXN0ZXAnKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG5cbi8vIDIyLjEuMy40IEFycmF5LnByb3RvdHlwZS5lbnRyaWVzKClcbi8vIDIyLjEuMy4xMyBBcnJheS5wcm90b3R5cGUua2V5cygpXG4vLyAyMi4xLjMuMjkgQXJyYXkucHJvdG90eXBlLnZhbHVlcygpXG4vLyAyMi4xLjMuMzAgQXJyYXkucHJvdG90eXBlW0BAaXRlcmF0b3JdKClcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9faXRlci1kZWZpbmUnKShBcnJheSwgJ0FycmF5JywgZnVuY3Rpb24gKGl0ZXJhdGVkLCBraW5kKSB7XG4gIHRoaXMuX3QgPSB0b0lPYmplY3QoaXRlcmF0ZWQpOyAvLyB0YXJnZXRcbiAgdGhpcy5faSA9IDA7ICAgICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXhcbiAgdGhpcy5fayA9IGtpbmQ7ICAgICAgICAgICAgICAgIC8vIGtpbmRcbi8vIDIyLjEuNS4yLjEgJUFycmF5SXRlcmF0b3JQcm90b3R5cGUlLm5leHQoKVxufSwgZnVuY3Rpb24gKCkge1xuICB2YXIgTyA9IHRoaXMuX3Q7XG4gIHZhciBraW5kID0gdGhpcy5faztcbiAgdmFyIGluZGV4ID0gdGhpcy5faSsrO1xuICBpZiAoIU8gfHwgaW5kZXggPj0gTy5sZW5ndGgpIHtcbiAgICB0aGlzLl90ID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiBzdGVwKDEpO1xuICB9XG4gIGlmIChraW5kID09ICdrZXlzJykgcmV0dXJuIHN0ZXAoMCwgaW5kZXgpO1xuICBpZiAoa2luZCA9PSAndmFsdWVzJykgcmV0dXJuIHN0ZXAoMCwgT1tpbmRleF0pO1xuICByZXR1cm4gc3RlcCgwLCBbaW5kZXgsIE9baW5kZXhdXSk7XG59LCAndmFsdWVzJyk7XG5cbi8vIGFyZ3VtZW50c0xpc3RbQEBpdGVyYXRvcl0gaXMgJUFycmF5UHJvdG9fdmFsdWVzJSAoOS40LjQuNiwgOS40LjQuNylcbkl0ZXJhdG9ycy5Bcmd1bWVudHMgPSBJdGVyYXRvcnMuQXJyYXk7XG5cbmFkZFRvVW5zY29wYWJsZXMoJ2tleXMnKTtcbmFkZFRvVW5zY29wYWJsZXMoJ3ZhbHVlcycpO1xuYWRkVG9VbnNjb3BhYmxlcygnZW50cmllcycpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gMjIuMS4zLjEzIEFycmF5LnByb3RvdHlwZS5qb2luKHNlcGFyYXRvcilcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIGFycmF5Sm9pbiA9IFtdLmpvaW47XG5cbi8vIGZhbGxiYWNrIGZvciBub3QgYXJyYXktbGlrZSBzdHJpbmdzXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIChyZXF1aXJlKCcuL19pb2JqZWN0JykgIT0gT2JqZWN0IHx8ICFyZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoYXJyYXlKb2luKSksICdBcnJheScsIHtcbiAgam9pbjogZnVuY3Rpb24gam9pbihzZXBhcmF0b3IpIHtcbiAgICByZXR1cm4gYXJyYXlKb2luLmNhbGwodG9JT2JqZWN0KHRoaXMpLCBzZXBhcmF0b3IgPT09IHVuZGVmaW5lZCA/ICcsJyA6IHNlcGFyYXRvcik7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgJG5hdGl2ZSA9IFtdLmxhc3RJbmRleE9mO1xudmFyIE5FR0FUSVZFX1pFUk8gPSAhISRuYXRpdmUgJiYgMSAvIFsxXS5sYXN0SW5kZXhPZigxLCAtMCkgPCAwO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIChORUdBVElWRV9aRVJPIHx8ICFyZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoJG5hdGl2ZSkpLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy4xNCAvIDE1LjQuNC4xNSBBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2Yoc2VhcmNoRWxlbWVudCBbLCBmcm9tSW5kZXhdKVxuICBsYXN0SW5kZXhPZjogZnVuY3Rpb24gbGFzdEluZGV4T2Yoc2VhcmNoRWxlbWVudCAvKiAsIGZyb21JbmRleCA9IEBbKi0xXSAqLykge1xuICAgIC8vIGNvbnZlcnQgLTAgdG8gKzBcbiAgICBpZiAoTkVHQVRJVkVfWkVSTykgcmV0dXJuICRuYXRpdmUuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCAwO1xuICAgIHZhciBPID0gdG9JT2JqZWN0KHRoaXMpO1xuICAgIHZhciBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gICAgdmFyIGluZGV4ID0gbGVuZ3RoIC0gMTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIGluZGV4ID0gTWF0aC5taW4oaW5kZXgsIHRvSW50ZWdlcihhcmd1bWVudHNbMV0pKTtcbiAgICBpZiAoaW5kZXggPCAwKSBpbmRleCA9IGxlbmd0aCArIGluZGV4O1xuICAgIGZvciAoO2luZGV4ID49IDA7IGluZGV4LS0pIGlmIChpbmRleCBpbiBPKSBpZiAoT1tpbmRleF0gPT09IHNlYXJjaEVsZW1lbnQpIHJldHVybiBpbmRleCB8fCAwO1xuICAgIHJldHVybiAtMTtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRtYXAgPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJykoMSk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKShbXS5tYXAsIHRydWUpLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy4xNSAvIDE1LjQuNC4xOSBBcnJheS5wcm90b3R5cGUubWFwKGNhbGxiYWNrZm4gWywgdGhpc0FyZ10pXG4gIG1hcDogZnVuY3Rpb24gbWFwKGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKSB7XG4gICAgcmV0dXJuICRtYXAodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzWzFdKTtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGNyZWF0ZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fY3JlYXRlLXByb3BlcnR5Jyk7XG5cbi8vIFdlYktpdCBBcnJheS5vZiBpc24ndCBnZW5lcmljXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBGKCkgeyAvKiBlbXB0eSAqLyB9XG4gIHJldHVybiAhKEFycmF5Lm9mLmNhbGwoRikgaW5zdGFuY2VvZiBGKTtcbn0pLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMi4zIEFycmF5Lm9mKCAuLi5pdGVtcylcbiAgb2Y6IGZ1bmN0aW9uIG9mKC8qIC4uLmFyZ3MgKi8pIHtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBhTGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgcmVzdWx0ID0gbmV3ICh0eXBlb2YgdGhpcyA9PSAnZnVuY3Rpb24nID8gdGhpcyA6IEFycmF5KShhTGVuKTtcbiAgICB3aGlsZSAoYUxlbiA+IGluZGV4KSBjcmVhdGVQcm9wZXJ0eShyZXN1bHQsIGluZGV4LCBhcmd1bWVudHNbaW5kZXgrK10pO1xuICAgIHJlc3VsdC5sZW5ndGggPSBhTGVuO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkcmVkdWNlID0gcmVxdWlyZSgnLi9fYXJyYXktcmVkdWNlJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKShbXS5yZWR1Y2VSaWdodCwgdHJ1ZSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjE5IC8gMTUuNC40LjIyIEFycmF5LnByb3RvdHlwZS5yZWR1Y2VSaWdodChjYWxsYmFja2ZuIFssIGluaXRpYWxWYWx1ZV0pXG4gIHJlZHVjZVJpZ2h0OiBmdW5jdGlvbiByZWR1Y2VSaWdodChjYWxsYmFja2ZuIC8qICwgaW5pdGlhbFZhbHVlICovKSB7XG4gICAgcmV0dXJuICRyZWR1Y2UodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCwgYXJndW1lbnRzWzFdLCB0cnVlKTtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRyZWR1Y2UgPSByZXF1aXJlKCcuL19hcnJheS1yZWR1Y2UnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKFtdLnJlZHVjZSwgdHJ1ZSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjE4IC8gMTUuNC40LjIxIEFycmF5LnByb3RvdHlwZS5yZWR1Y2UoY2FsbGJhY2tmbiBbLCBpbml0aWFsVmFsdWVdKVxuICByZWR1Y2U6IGZ1bmN0aW9uIHJlZHVjZShjYWxsYmFja2ZuIC8qICwgaW5pdGlhbFZhbHVlICovKSB7XG4gICAgcmV0dXJuICRyZWR1Y2UodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCwgYXJndW1lbnRzWzFdLCBmYWxzZSk7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBodG1sID0gcmVxdWlyZSgnLi9faHRtbCcpO1xudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xudmFyIHRvQWJzb2x1dGVJbmRleCA9IHJlcXVpcmUoJy4vX3RvLWFic29sdXRlLWluZGV4Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciBhcnJheVNsaWNlID0gW10uc2xpY2U7XG5cbi8vIGZhbGxiYWNrIGZvciBub3QgYXJyYXktbGlrZSBFUzMgc3RyaW5ncyBhbmQgRE9NIG9iamVjdHNcbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIGlmIChodG1sKSBhcnJheVNsaWNlLmNhbGwoaHRtbCk7XG59KSwgJ0FycmF5Jywge1xuICBzbGljZTogZnVuY3Rpb24gc2xpY2UoYmVnaW4sIGVuZCkge1xuICAgIHZhciBsZW4gPSB0b0xlbmd0aCh0aGlzLmxlbmd0aCk7XG4gICAgdmFyIGtsYXNzID0gY29mKHRoaXMpO1xuICAgIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogZW5kO1xuICAgIGlmIChrbGFzcyA9PSAnQXJyYXknKSByZXR1cm4gYXJyYXlTbGljZS5jYWxsKHRoaXMsIGJlZ2luLCBlbmQpO1xuICAgIHZhciBzdGFydCA9IHRvQWJzb2x1dGVJbmRleChiZWdpbiwgbGVuKTtcbiAgICB2YXIgdXBUbyA9IHRvQWJzb2x1dGVJbmRleChlbmQsIGxlbik7XG4gICAgdmFyIHNpemUgPSB0b0xlbmd0aCh1cFRvIC0gc3RhcnQpO1xuICAgIHZhciBjbG9uZWQgPSBBcnJheShzaXplKTtcbiAgICB2YXIgaSA9IDA7XG4gICAgZm9yICg7IGkgPCBzaXplOyBpKyspIGNsb25lZFtpXSA9IGtsYXNzID09ICdTdHJpbmcnXG4gICAgICA/IHRoaXMuY2hhckF0KHN0YXJ0ICsgaSlcbiAgICAgIDogdGhpc1tzdGFydCArIGldO1xuICAgIHJldHVybiBjbG9uZWQ7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkc29tZSA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKSgzKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKFtdLnNvbWUsIHRydWUpLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy4yMyAvIDE1LjQuNC4xNyBBcnJheS5wcm90b3R5cGUuc29tZShjYWxsYmFja2ZuIFssIHRoaXNBcmddKVxuICBzb21lOiBmdW5jdGlvbiBzb21lKGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKSB7XG4gICAgcmV0dXJuICRzb21lKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50c1sxXSk7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG52YXIgJHNvcnQgPSBbXS5zb3J0O1xudmFyIHRlc3QgPSBbMSwgMiwgM107XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgLy8gSUU4LVxuICB0ZXN0LnNvcnQodW5kZWZpbmVkKTtcbn0pIHx8ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIC8vIFY4IGJ1Z1xuICB0ZXN0LnNvcnQobnVsbCk7XG4gIC8vIE9sZCBXZWJLaXRcbn0pIHx8ICFyZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoJHNvcnQpKSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjMuMjUgQXJyYXkucHJvdG90eXBlLnNvcnQoY29tcGFyZWZuKVxuICBzb3J0OiBmdW5jdGlvbiBzb3J0KGNvbXBhcmVmbikge1xuICAgIHJldHVybiBjb21wYXJlZm4gPT09IHVuZGVmaW5lZFxuICAgICAgPyAkc29ydC5jYWxsKHRvT2JqZWN0KHRoaXMpKVxuICAgICAgOiAkc29ydC5jYWxsKHRvT2JqZWN0KHRoaXMpLCBhRnVuY3Rpb24oY29tcGFyZWZuKSk7XG4gIH1cbn0pO1xuIiwicmVxdWlyZSgnLi9fc2V0LXNwZWNpZXMnKSgnQXJyYXknKTtcbiIsIi8vIDIwLjMuMy4xIC8gMTUuOS40LjQgRGF0ZS5ub3coKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdEYXRlJywgeyBub3c6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpOyB9IH0pO1xuIiwiLy8gMjAuMy40LjM2IC8gMTUuOS41LjQzIERhdGUucHJvdG90eXBlLnRvSVNPU3RyaW5nKClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgdG9JU09TdHJpbmcgPSByZXF1aXJlKCcuL19kYXRlLXRvLWlzby1zdHJpbmcnKTtcblxuLy8gUGhhbnRvbUpTIC8gb2xkIFdlYktpdCBoYXMgYSBicm9rZW4gaW1wbGVtZW50YXRpb25zXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIChEYXRlLnByb3RvdHlwZS50b0lTT1N0cmluZyAhPT0gdG9JU09TdHJpbmcpLCAnRGF0ZScsIHtcbiAgdG9JU09TdHJpbmc6IHRvSVNPU3RyaW5nXG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gbmV3IERhdGUoTmFOKS50b0pTT04oKSAhPT0gbnVsbFxuICAgIHx8IERhdGUucHJvdG90eXBlLnRvSlNPTi5jYWxsKHsgdG9JU09TdHJpbmc6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDE7IH0gfSkgIT09IDE7XG59KSwgJ0RhdGUnLCB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuICB0b0pTT046IGZ1bmN0aW9uIHRvSlNPTihrZXkpIHtcbiAgICB2YXIgTyA9IHRvT2JqZWN0KHRoaXMpO1xuICAgIHZhciBwdiA9IHRvUHJpbWl0aXZlKE8pO1xuICAgIHJldHVybiB0eXBlb2YgcHYgPT0gJ251bWJlcicgJiYgIWlzRmluaXRlKHB2KSA/IG51bGwgOiBPLnRvSVNPU3RyaW5nKCk7XG4gIH1cbn0pO1xuIiwidmFyIFRPX1BSSU1JVElWRSA9IHJlcXVpcmUoJy4vX3drcycpKCd0b1ByaW1pdGl2ZScpO1xudmFyIHByb3RvID0gRGF0ZS5wcm90b3R5cGU7XG5cbmlmICghKFRPX1BSSU1JVElWRSBpbiBwcm90bykpIHJlcXVpcmUoJy4vX2hpZGUnKShwcm90bywgVE9fUFJJTUlUSVZFLCByZXF1aXJlKCcuL19kYXRlLXRvLXByaW1pdGl2ZScpKTtcbiIsInZhciBEYXRlUHJvdG8gPSBEYXRlLnByb3RvdHlwZTtcbnZhciBJTlZBTElEX0RBVEUgPSAnSW52YWxpZCBEYXRlJztcbnZhciBUT19TVFJJTkcgPSAndG9TdHJpbmcnO1xudmFyICR0b1N0cmluZyA9IERhdGVQcm90b1tUT19TVFJJTkddO1xudmFyIGdldFRpbWUgPSBEYXRlUHJvdG8uZ2V0VGltZTtcbmlmIChuZXcgRGF0ZShOYU4pICsgJycgIT0gSU5WQUxJRF9EQVRFKSB7XG4gIHJlcXVpcmUoJy4vX3JlZGVmaW5lJykoRGF0ZVByb3RvLCBUT19TVFJJTkcsIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHZhciB2YWx1ZSA9IGdldFRpbWUuY2FsbCh0aGlzKTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZSA/ICR0b1N0cmluZy5jYWxsKHRoaXMpIDogSU5WQUxJRF9EQVRFO1xuICB9KTtcbn1cbiIsIi8vIDE5LjIuMy4yIC8gMTUuMy40LjUgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQodGhpc0FyZywgYXJncy4uLilcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QLCAnRnVuY3Rpb24nLCB7IGJpbmQ6IHJlcXVpcmUoJy4vX2JpbmQnKSB9KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpO1xudmFyIEhBU19JTlNUQU5DRSA9IHJlcXVpcmUoJy4vX3drcycpKCdoYXNJbnN0YW5jZScpO1xudmFyIEZ1bmN0aW9uUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGU7XG4vLyAxOS4yLjMuNiBGdW5jdGlvbi5wcm90b3R5cGVbQEBoYXNJbnN0YW5jZV0oVilcbmlmICghKEhBU19JTlNUQU5DRSBpbiBGdW5jdGlvblByb3RvKSkgcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZihGdW5jdGlvblByb3RvLCBIQVNfSU5TVEFOQ0UsIHsgdmFsdWU6IGZ1bmN0aW9uIChPKSB7XG4gIGlmICh0eXBlb2YgdGhpcyAhPSAnZnVuY3Rpb24nIHx8ICFpc09iamVjdChPKSkgcmV0dXJuIGZhbHNlO1xuICBpZiAoIWlzT2JqZWN0KHRoaXMucHJvdG90eXBlKSkgcmV0dXJuIE8gaW5zdGFuY2VvZiB0aGlzO1xuICAvLyBmb3IgZW52aXJvbm1lbnQgdy9vIG5hdGl2ZSBgQEBoYXNJbnN0YW5jZWAgbG9naWMgZW5vdWdoIGBpbnN0YW5jZW9mYCwgYnV0IGFkZCB0aGlzOlxuICB3aGlsZSAoTyA9IGdldFByb3RvdHlwZU9mKE8pKSBpZiAodGhpcy5wcm90b3R5cGUgPT09IE8pIHJldHVybiB0cnVlO1xuICByZXR1cm4gZmFsc2U7XG59IH0pO1xuIiwidmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbnZhciBGUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGU7XG52YXIgbmFtZVJFID0gL15cXHMqZnVuY3Rpb24gKFteIChdKikvO1xudmFyIE5BTUUgPSAnbmFtZSc7XG5cbi8vIDE5LjIuNC4yIG5hbWVcbk5BTUUgaW4gRlByb3RvIHx8IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgZFAoRlByb3RvLCBOQU1FLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiAoJycgKyB0aGlzKS5tYXRjaChuYW1lUkUpWzFdO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHN0cm9uZyA9IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24tc3Ryb25nJyk7XG52YXIgdmFsaWRhdGUgPSByZXF1aXJlKCcuL192YWxpZGF0ZS1jb2xsZWN0aW9uJyk7XG52YXIgTUFQID0gJ01hcCc7XG5cbi8vIDIzLjEgTWFwIE9iamVjdHNcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbicpKE1BUCwgZnVuY3Rpb24gKGdldCkge1xuICByZXR1cm4gZnVuY3Rpb24gTWFwKCkgeyByZXR1cm4gZ2V0KHRoaXMsIGFyZ3VtZW50cy5sZW5ndGggPiAwID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTsgfTtcbn0sIHtcbiAgLy8gMjMuMS4zLjYgTWFwLnByb3RvdHlwZS5nZXQoa2V5KVxuICBnZXQ6IGZ1bmN0aW9uIGdldChrZXkpIHtcbiAgICB2YXIgZW50cnkgPSBzdHJvbmcuZ2V0RW50cnkodmFsaWRhdGUodGhpcywgTUFQKSwga2V5KTtcbiAgICByZXR1cm4gZW50cnkgJiYgZW50cnkudjtcbiAgfSxcbiAgLy8gMjMuMS4zLjkgTWFwLnByb3RvdHlwZS5zZXQoa2V5LCB2YWx1ZSlcbiAgc2V0OiBmdW5jdGlvbiBzZXQoa2V5LCB2YWx1ZSkge1xuICAgIHJldHVybiBzdHJvbmcuZGVmKHZhbGlkYXRlKHRoaXMsIE1BUCksIGtleSA9PT0gMCA/IDAgOiBrZXksIHZhbHVlKTtcbiAgfVxufSwgc3Ryb25nLCB0cnVlKTtcbiIsIi8vIDIwLjIuMi4zIE1hdGguYWNvc2goeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgbG9nMXAgPSByZXF1aXJlKCcuL19tYXRoLWxvZzFwJyk7XG52YXIgc3FydCA9IE1hdGguc3FydDtcbnZhciAkYWNvc2ggPSBNYXRoLmFjb3NoO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICEoJGFjb3NoXG4gIC8vIFY4IGJ1ZzogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTM1MDlcbiAgJiYgTWF0aC5mbG9vcigkYWNvc2goTnVtYmVyLk1BWF9WQUxVRSkpID09IDcxMFxuICAvLyBUb3IgQnJvd3NlciBidWc6IE1hdGguYWNvc2goSW5maW5pdHkpIC0+IE5hTlxuICAmJiAkYWNvc2goSW5maW5pdHkpID09IEluZmluaXR5XG4pLCAnTWF0aCcsIHtcbiAgYWNvc2g6IGZ1bmN0aW9uIGFjb3NoKHgpIHtcbiAgICByZXR1cm4gKHggPSAreCkgPCAxID8gTmFOIDogeCA+IDk0OTA2MjY1LjYyNDI1MTU2XG4gICAgICA/IE1hdGgubG9nKHgpICsgTWF0aC5MTjJcbiAgICAgIDogbG9nMXAoeCAtIDEgKyBzcXJ0KHggLSAxKSAqIHNxcnQoeCArIDEpKTtcbiAgfVxufSk7XG4iLCIvLyAyMC4yLjIuNSBNYXRoLmFzaW5oKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRhc2luaCA9IE1hdGguYXNpbmg7XG5cbmZ1bmN0aW9uIGFzaW5oKHgpIHtcbiAgcmV0dXJuICFpc0Zpbml0ZSh4ID0gK3gpIHx8IHggPT0gMCA/IHggOiB4IDwgMCA/IC1hc2luaCgteCkgOiBNYXRoLmxvZyh4ICsgTWF0aC5zcXJ0KHggKiB4ICsgMSkpO1xufVxuXG4vLyBUb3IgQnJvd3NlciBidWc6IE1hdGguYXNpbmgoMCkgLT4gLTBcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogISgkYXNpbmggJiYgMSAvICRhc2luaCgwKSA+IDApLCAnTWF0aCcsIHsgYXNpbmg6IGFzaW5oIH0pO1xuIiwiLy8gMjAuMi4yLjcgTWF0aC5hdGFuaCh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkYXRhbmggPSBNYXRoLmF0YW5oO1xuXG4vLyBUb3IgQnJvd3NlciBidWc6IE1hdGguYXRhbmgoLTApIC0+IDBcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogISgkYXRhbmggJiYgMSAvICRhdGFuaCgtMCkgPCAwKSwgJ01hdGgnLCB7XG4gIGF0YW5oOiBmdW5jdGlvbiBhdGFuaCh4KSB7XG4gICAgcmV0dXJuICh4ID0gK3gpID09IDAgPyB4IDogTWF0aC5sb2coKDEgKyB4KSAvICgxIC0geCkpIC8gMjtcbiAgfVxufSk7XG4iLCIvLyAyMC4yLjIuOSBNYXRoLmNicnQoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgc2lnbiA9IHJlcXVpcmUoJy4vX21hdGgtc2lnbicpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGNicnQ6IGZ1bmN0aW9uIGNicnQoeCkge1xuICAgIHJldHVybiBzaWduKHggPSAreCkgKiBNYXRoLnBvdyhNYXRoLmFicyh4KSwgMSAvIDMpO1xuICB9XG59KTtcbiIsIi8vIDIwLjIuMi4xMSBNYXRoLmNsejMyKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGNsejMyOiBmdW5jdGlvbiBjbHozMih4KSB7XG4gICAgcmV0dXJuICh4ID4+Pj0gMCkgPyAzMSAtIE1hdGguZmxvb3IoTWF0aC5sb2coeCArIDAuNSkgKiBNYXRoLkxPRzJFKSA6IDMyO1xuICB9XG59KTtcbiIsIi8vIDIwLjIuMi4xMiBNYXRoLmNvc2goeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgZXhwID0gTWF0aC5leHA7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgY29zaDogZnVuY3Rpb24gY29zaCh4KSB7XG4gICAgcmV0dXJuIChleHAoeCA9ICt4KSArIGV4cCgteCkpIC8gMjtcbiAgfVxufSk7XG4iLCIvLyAyMC4yLjIuMTQgTWF0aC5leHBtMSh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkZXhwbTEgPSByZXF1aXJlKCcuL19tYXRoLWV4cG0xJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKCRleHBtMSAhPSBNYXRoLmV4cG0xKSwgJ01hdGgnLCB7IGV4cG0xOiAkZXhwbTEgfSk7XG4iLCIvLyAyMC4yLjIuMTYgTWF0aC5mcm91bmQoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHsgZnJvdW5kOiByZXF1aXJlKCcuL19tYXRoLWZyb3VuZCcpIH0pO1xuIiwiLy8gMjAuMi4yLjE3IE1hdGguaHlwb3QoW3ZhbHVlMVssIHZhbHVlMlssIOKApiBdXV0pXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGFicyA9IE1hdGguYWJzO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGh5cG90OiBmdW5jdGlvbiBoeXBvdCh2YWx1ZTEsIHZhbHVlMikgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgdmFyIHN1bSA9IDA7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBhTGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgbGFyZyA9IDA7XG4gICAgdmFyIGFyZywgZGl2O1xuICAgIHdoaWxlIChpIDwgYUxlbikge1xuICAgICAgYXJnID0gYWJzKGFyZ3VtZW50c1tpKytdKTtcbiAgICAgIGlmIChsYXJnIDwgYXJnKSB7XG4gICAgICAgIGRpdiA9IGxhcmcgLyBhcmc7XG4gICAgICAgIHN1bSA9IHN1bSAqIGRpdiAqIGRpdiArIDE7XG4gICAgICAgIGxhcmcgPSBhcmc7XG4gICAgICB9IGVsc2UgaWYgKGFyZyA+IDApIHtcbiAgICAgICAgZGl2ID0gYXJnIC8gbGFyZztcbiAgICAgICAgc3VtICs9IGRpdiAqIGRpdjtcbiAgICAgIH0gZWxzZSBzdW0gKz0gYXJnO1xuICAgIH1cbiAgICByZXR1cm4gbGFyZyA9PT0gSW5maW5pdHkgPyBJbmZpbml0eSA6IGxhcmcgKiBNYXRoLnNxcnQoc3VtKTtcbiAgfVxufSk7XG4iLCIvLyAyMC4yLjIuMTggTWF0aC5pbXVsKHgsIHkpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRpbXVsID0gTWF0aC5pbXVsO1xuXG4vLyBzb21lIFdlYktpdCB2ZXJzaW9ucyBmYWlscyB3aXRoIGJpZyBudW1iZXJzLCBzb21lIGhhcyB3cm9uZyBhcml0eVxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICRpbXVsKDB4ZmZmZmZmZmYsIDUpICE9IC01IHx8ICRpbXVsLmxlbmd0aCAhPSAyO1xufSksICdNYXRoJywge1xuICBpbXVsOiBmdW5jdGlvbiBpbXVsKHgsIHkpIHtcbiAgICB2YXIgVUlOVDE2ID0gMHhmZmZmO1xuICAgIHZhciB4biA9ICt4O1xuICAgIHZhciB5biA9ICt5O1xuICAgIHZhciB4bCA9IFVJTlQxNiAmIHhuO1xuICAgIHZhciB5bCA9IFVJTlQxNiAmIHluO1xuICAgIHJldHVybiAwIHwgeGwgKiB5bCArICgoVUlOVDE2ICYgeG4gPj4+IDE2KSAqIHlsICsgeGwgKiAoVUlOVDE2ICYgeW4gPj4+IDE2KSA8PCAxNiA+Pj4gMCk7XG4gIH1cbn0pO1xuIiwiLy8gMjAuMi4yLjIxIE1hdGgubG9nMTAoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgbG9nMTA6IGZ1bmN0aW9uIGxvZzEwKHgpIHtcbiAgICByZXR1cm4gTWF0aC5sb2coeCkgKiBNYXRoLkxPRzEwRTtcbiAgfVxufSk7XG4iLCIvLyAyMC4yLjIuMjAgTWF0aC5sb2cxcCh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywgeyBsb2cxcDogcmVxdWlyZSgnLi9fbWF0aC1sb2cxcCcpIH0pO1xuIiwiLy8gMjAuMi4yLjIyIE1hdGgubG9nMih4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBsb2cyOiBmdW5jdGlvbiBsb2cyKHgpIHtcbiAgICByZXR1cm4gTWF0aC5sb2coeCkgLyBNYXRoLkxOMjtcbiAgfVxufSk7XG4iLCIvLyAyMC4yLjIuMjggTWF0aC5zaWduKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7IHNpZ246IHJlcXVpcmUoJy4vX21hdGgtc2lnbicpIH0pO1xuIiwiLy8gMjAuMi4yLjMwIE1hdGguc2luaCh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBleHBtMSA9IHJlcXVpcmUoJy4vX21hdGgtZXhwbTEnKTtcbnZhciBleHAgPSBNYXRoLmV4cDtcblxuLy8gVjggbmVhciBDaHJvbWl1bSAzOCBoYXMgYSBwcm9ibGVtIHdpdGggdmVyeSBzbWFsbCBudW1iZXJzXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gIU1hdGguc2luaCgtMmUtMTcpICE9IC0yZS0xNztcbn0pLCAnTWF0aCcsIHtcbiAgc2luaDogZnVuY3Rpb24gc2luaCh4KSB7XG4gICAgcmV0dXJuIE1hdGguYWJzKHggPSAreCkgPCAxXG4gICAgICA/IChleHBtMSh4KSAtIGV4cG0xKC14KSkgLyAyXG4gICAgICA6IChleHAoeCAtIDEpIC0gZXhwKC14IC0gMSkpICogKE1hdGguRSAvIDIpO1xuICB9XG59KTtcbiIsIi8vIDIwLjIuMi4zMyBNYXRoLnRhbmgoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgZXhwbTEgPSByZXF1aXJlKCcuL19tYXRoLWV4cG0xJyk7XG52YXIgZXhwID0gTWF0aC5leHA7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgdGFuaDogZnVuY3Rpb24gdGFuaCh4KSB7XG4gICAgdmFyIGEgPSBleHBtMSh4ID0gK3gpO1xuICAgIHZhciBiID0gZXhwbTEoLXgpO1xuICAgIHJldHVybiBhID09IEluZmluaXR5ID8gMSA6IGIgPT0gSW5maW5pdHkgPyAtMSA6IChhIC0gYikgLyAoZXhwKHgpICsgZXhwKC14KSk7XG4gIH1cbn0pO1xuIiwiLy8gMjAuMi4yLjM0IE1hdGgudHJ1bmMoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgdHJ1bmM6IGZ1bmN0aW9uIHRydW5jKGl0KSB7XG4gICAgcmV0dXJuIChpdCA+IDAgPyBNYXRoLmZsb29yIDogTWF0aC5jZWlsKShpdCk7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xudmFyIGluaGVyaXRJZlJlcXVpcmVkID0gcmVxdWlyZSgnLi9faW5oZXJpdC1pZi1yZXF1aXJlZCcpO1xudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xudmFyIGdPUE4gPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbicpLmY7XG52YXIgZ09QRCA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJykuZjtcbnZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG52YXIgJHRyaW0gPSByZXF1aXJlKCcuL19zdHJpbmctdHJpbScpLnRyaW07XG52YXIgTlVNQkVSID0gJ051bWJlcic7XG52YXIgJE51bWJlciA9IGdsb2JhbFtOVU1CRVJdO1xudmFyIEJhc2UgPSAkTnVtYmVyO1xudmFyIHByb3RvID0gJE51bWJlci5wcm90b3R5cGU7XG4vLyBPcGVyYSB+MTIgaGFzIGJyb2tlbiBPYmplY3QjdG9TdHJpbmdcbnZhciBCUk9LRU5fQ09GID0gY29mKHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKShwcm90bykpID09IE5VTUJFUjtcbnZhciBUUklNID0gJ3RyaW0nIGluIFN0cmluZy5wcm90b3R5cGU7XG5cbi8vIDcuMS4zIFRvTnVtYmVyKGFyZ3VtZW50KVxudmFyIHRvTnVtYmVyID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHZhciBpdCA9IHRvUHJpbWl0aXZlKGFyZ3VtZW50LCBmYWxzZSk7XG4gIGlmICh0eXBlb2YgaXQgPT0gJ3N0cmluZycgJiYgaXQubGVuZ3RoID4gMikge1xuICAgIGl0ID0gVFJJTSA/IGl0LnRyaW0oKSA6ICR0cmltKGl0LCAzKTtcbiAgICB2YXIgZmlyc3QgPSBpdC5jaGFyQ29kZUF0KDApO1xuICAgIHZhciB0aGlyZCwgcmFkaXgsIG1heENvZGU7XG4gICAgaWYgKGZpcnN0ID09PSA0MyB8fCBmaXJzdCA9PT0gNDUpIHtcbiAgICAgIHRoaXJkID0gaXQuY2hhckNvZGVBdCgyKTtcbiAgICAgIGlmICh0aGlyZCA9PT0gODggfHwgdGhpcmQgPT09IDEyMCkgcmV0dXJuIE5hTjsgLy8gTnVtYmVyKCcrMHgxJykgc2hvdWxkIGJlIE5hTiwgb2xkIFY4IGZpeFxuICAgIH0gZWxzZSBpZiAoZmlyc3QgPT09IDQ4KSB7XG4gICAgICBzd2l0Y2ggKGl0LmNoYXJDb2RlQXQoMSkpIHtcbiAgICAgICAgY2FzZSA2NjogY2FzZSA5ODogcmFkaXggPSAyOyBtYXhDb2RlID0gNDk7IGJyZWFrOyAvLyBmYXN0IGVxdWFsIC9eMGJbMDFdKyQvaVxuICAgICAgICBjYXNlIDc5OiBjYXNlIDExMTogcmFkaXggPSA4OyBtYXhDb2RlID0gNTU7IGJyZWFrOyAvLyBmYXN0IGVxdWFsIC9eMG9bMC03XSskL2lcbiAgICAgICAgZGVmYXVsdDogcmV0dXJuICtpdDtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGRpZ2l0cyA9IGl0LnNsaWNlKDIpLCBpID0gMCwgbCA9IGRpZ2l0cy5sZW5ndGgsIGNvZGU7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgY29kZSA9IGRpZ2l0cy5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAvLyBwYXJzZUludCBwYXJzZXMgYSBzdHJpbmcgdG8gYSBmaXJzdCB1bmF2YWlsYWJsZSBzeW1ib2xcbiAgICAgICAgLy8gYnV0IFRvTnVtYmVyIHNob3VsZCByZXR1cm4gTmFOIGlmIGEgc3RyaW5nIGNvbnRhaW5zIHVuYXZhaWxhYmxlIHN5bWJvbHNcbiAgICAgICAgaWYgKGNvZGUgPCA0OCB8fCBjb2RlID4gbWF4Q29kZSkgcmV0dXJuIE5hTjtcbiAgICAgIH0gcmV0dXJuIHBhcnNlSW50KGRpZ2l0cywgcmFkaXgpO1xuICAgIH1cbiAgfSByZXR1cm4gK2l0O1xufTtcblxuaWYgKCEkTnVtYmVyKCcgMG8xJykgfHwgISROdW1iZXIoJzBiMScpIHx8ICROdW1iZXIoJysweDEnKSkge1xuICAkTnVtYmVyID0gZnVuY3Rpb24gTnVtYmVyKHZhbHVlKSB7XG4gICAgdmFyIGl0ID0gYXJndW1lbnRzLmxlbmd0aCA8IDEgPyAwIDogdmFsdWU7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIHJldHVybiB0aGF0IGluc3RhbmNlb2YgJE51bWJlclxuICAgICAgLy8gY2hlY2sgb24gMS4uY29uc3RydWN0b3IoZm9vKSBjYXNlXG4gICAgICAmJiAoQlJPS0VOX0NPRiA/IGZhaWxzKGZ1bmN0aW9uICgpIHsgcHJvdG8udmFsdWVPZi5jYWxsKHRoYXQpOyB9KSA6IGNvZih0aGF0KSAhPSBOVU1CRVIpXG4gICAgICAgID8gaW5oZXJpdElmUmVxdWlyZWQobmV3IEJhc2UodG9OdW1iZXIoaXQpKSwgdGhhdCwgJE51bWJlcikgOiB0b051bWJlcihpdCk7XG4gIH07XG4gIGZvciAodmFyIGtleXMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gZ09QTihCYXNlKSA6IChcbiAgICAvLyBFUzM6XG4gICAgJ01BWF9WQUxVRSxNSU5fVkFMVUUsTmFOLE5FR0FUSVZFX0lORklOSVRZLFBPU0lUSVZFX0lORklOSVRZLCcgK1xuICAgIC8vIEVTNiAoaW4gY2FzZSwgaWYgbW9kdWxlcyB3aXRoIEVTNiBOdW1iZXIgc3RhdGljcyByZXF1aXJlZCBiZWZvcmUpOlxuICAgICdFUFNJTE9OLGlzRmluaXRlLGlzSW50ZWdlcixpc05hTixpc1NhZmVJbnRlZ2VyLE1BWF9TQUZFX0lOVEVHRVIsJyArXG4gICAgJ01JTl9TQUZFX0lOVEVHRVIscGFyc2VGbG9hdCxwYXJzZUludCxpc0ludGVnZXInXG4gICkuc3BsaXQoJywnKSwgaiA9IDAsIGtleTsga2V5cy5sZW5ndGggPiBqOyBqKyspIHtcbiAgICBpZiAoaGFzKEJhc2UsIGtleSA9IGtleXNbal0pICYmICFoYXMoJE51bWJlciwga2V5KSkge1xuICAgICAgZFAoJE51bWJlciwga2V5LCBnT1BEKEJhc2UsIGtleSkpO1xuICAgIH1cbiAgfVxuICAkTnVtYmVyLnByb3RvdHlwZSA9IHByb3RvO1xuICBwcm90by5jb25zdHJ1Y3RvciA9ICROdW1iZXI7XG4gIHJlcXVpcmUoJy4vX3JlZGVmaW5lJykoZ2xvYmFsLCBOVU1CRVIsICROdW1iZXIpO1xufVxuIiwiLy8gMjAuMS4yLjEgTnVtYmVyLkVQU0lMT05cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTnVtYmVyJywgeyBFUFNJTE9OOiBNYXRoLnBvdygyLCAtNTIpIH0pO1xuIiwiLy8gMjAuMS4yLjIgTnVtYmVyLmlzRmluaXRlKG51bWJlcilcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgX2lzRmluaXRlID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuaXNGaW5pdGU7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTnVtYmVyJywge1xuICBpc0Zpbml0ZTogZnVuY3Rpb24gaXNGaW5pdGUoaXQpIHtcbiAgICByZXR1cm4gdHlwZW9mIGl0ID09ICdudW1iZXInICYmIF9pc0Zpbml0ZShpdCk7XG4gIH1cbn0pO1xuIiwiLy8gMjAuMS4yLjMgTnVtYmVyLmlzSW50ZWdlcihudW1iZXIpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ051bWJlcicsIHsgaXNJbnRlZ2VyOiByZXF1aXJlKCcuL19pcy1pbnRlZ2VyJykgfSk7XG4iLCIvLyAyMC4xLjIuNCBOdW1iZXIuaXNOYU4obnVtYmVyKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdOdW1iZXInLCB7XG4gIGlzTmFOOiBmdW5jdGlvbiBpc05hTihudW1iZXIpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgcmV0dXJuIG51bWJlciAhPSBudW1iZXI7XG4gIH1cbn0pO1xuIiwiLy8gMjAuMS4yLjUgTnVtYmVyLmlzU2FmZUludGVnZXIobnVtYmVyKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBpc0ludGVnZXIgPSByZXF1aXJlKCcuL19pcy1pbnRlZ2VyJyk7XG52YXIgYWJzID0gTWF0aC5hYnM7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTnVtYmVyJywge1xuICBpc1NhZmVJbnRlZ2VyOiBmdW5jdGlvbiBpc1NhZmVJbnRlZ2VyKG51bWJlcikge1xuICAgIHJldHVybiBpc0ludGVnZXIobnVtYmVyKSAmJiBhYnMobnVtYmVyKSA8PSAweDFmZmZmZmZmZmZmZmZmO1xuICB9XG59KTtcbiIsIi8vIDIwLjEuMi42IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ051bWJlcicsIHsgTUFYX1NBRkVfSU5URUdFUjogMHgxZmZmZmZmZmZmZmZmZiB9KTtcbiIsIi8vIDIwLjEuMi4xMCBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUlxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdOdW1iZXInLCB7IE1JTl9TQUZFX0lOVEVHRVI6IC0weDFmZmZmZmZmZmZmZmZmIH0pO1xuIiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkcGFyc2VGbG9hdCA9IHJlcXVpcmUoJy4vX3BhcnNlLWZsb2F0Jyk7XG4vLyAyMC4xLjIuMTIgTnVtYmVyLnBhcnNlRmxvYXQoc3RyaW5nKVxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoTnVtYmVyLnBhcnNlRmxvYXQgIT0gJHBhcnNlRmxvYXQpLCAnTnVtYmVyJywgeyBwYXJzZUZsb2F0OiAkcGFyc2VGbG9hdCB9KTtcbiIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJHBhcnNlSW50ID0gcmVxdWlyZSgnLi9fcGFyc2UtaW50Jyk7XG4vLyAyMC4xLjIuMTMgTnVtYmVyLnBhcnNlSW50KHN0cmluZywgcmFkaXgpXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIChOdW1iZXIucGFyc2VJbnQgIT0gJHBhcnNlSW50KSwgJ051bWJlcicsIHsgcGFyc2VJbnQ6ICRwYXJzZUludCB9KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xudmFyIGFOdW1iZXJWYWx1ZSA9IHJlcXVpcmUoJy4vX2EtbnVtYmVyLXZhbHVlJyk7XG52YXIgcmVwZWF0ID0gcmVxdWlyZSgnLi9fc3RyaW5nLXJlcGVhdCcpO1xudmFyICR0b0ZpeGVkID0gMS4wLnRvRml4ZWQ7XG52YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xudmFyIGRhdGEgPSBbMCwgMCwgMCwgMCwgMCwgMF07XG52YXIgRVJST1IgPSAnTnVtYmVyLnRvRml4ZWQ6IGluY29ycmVjdCBpbnZvY2F0aW9uISc7XG52YXIgWkVSTyA9ICcwJztcblxudmFyIG11bHRpcGx5ID0gZnVuY3Rpb24gKG4sIGMpIHtcbiAgdmFyIGkgPSAtMTtcbiAgdmFyIGMyID0gYztcbiAgd2hpbGUgKCsraSA8IDYpIHtcbiAgICBjMiArPSBuICogZGF0YVtpXTtcbiAgICBkYXRhW2ldID0gYzIgJSAxZTc7XG4gICAgYzIgPSBmbG9vcihjMiAvIDFlNyk7XG4gIH1cbn07XG52YXIgZGl2aWRlID0gZnVuY3Rpb24gKG4pIHtcbiAgdmFyIGkgPSA2O1xuICB2YXIgYyA9IDA7XG4gIHdoaWxlICgtLWkgPj0gMCkge1xuICAgIGMgKz0gZGF0YVtpXTtcbiAgICBkYXRhW2ldID0gZmxvb3IoYyAvIG4pO1xuICAgIGMgPSAoYyAlIG4pICogMWU3O1xuICB9XG59O1xudmFyIG51bVRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaSA9IDY7XG4gIHZhciBzID0gJyc7XG4gIHdoaWxlICgtLWkgPj0gMCkge1xuICAgIGlmIChzICE9PSAnJyB8fCBpID09PSAwIHx8IGRhdGFbaV0gIT09IDApIHtcbiAgICAgIHZhciB0ID0gU3RyaW5nKGRhdGFbaV0pO1xuICAgICAgcyA9IHMgPT09ICcnID8gdCA6IHMgKyByZXBlYXQuY2FsbChaRVJPLCA3IC0gdC5sZW5ndGgpICsgdDtcbiAgICB9XG4gIH0gcmV0dXJuIHM7XG59O1xudmFyIHBvdyA9IGZ1bmN0aW9uICh4LCBuLCBhY2MpIHtcbiAgcmV0dXJuIG4gPT09IDAgPyBhY2MgOiBuICUgMiA9PT0gMSA/IHBvdyh4LCBuIC0gMSwgYWNjICogeCkgOiBwb3coeCAqIHgsIG4gLyAyLCBhY2MpO1xufTtcbnZhciBsb2cgPSBmdW5jdGlvbiAoeCkge1xuICB2YXIgbiA9IDA7XG4gIHZhciB4MiA9IHg7XG4gIHdoaWxlICh4MiA+PSA0MDk2KSB7XG4gICAgbiArPSAxMjtcbiAgICB4MiAvPSA0MDk2O1xuICB9XG4gIHdoaWxlICh4MiA+PSAyKSB7XG4gICAgbiArPSAxO1xuICAgIHgyIC89IDI7XG4gIH0gcmV0dXJuIG47XG59O1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqICghISR0b0ZpeGVkICYmIChcbiAgMC4wMDAwOC50b0ZpeGVkKDMpICE9PSAnMC4wMDAnIHx8XG4gIDAuOS50b0ZpeGVkKDApICE9PSAnMScgfHxcbiAgMS4yNTUudG9GaXhlZCgyKSAhPT0gJzEuMjUnIHx8XG4gIDEwMDAwMDAwMDAwMDAwMDAxMjguMC50b0ZpeGVkKDApICE9PSAnMTAwMDAwMDAwMDAwMDAwMDEyOCdcbikgfHwgIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICAvLyBWOCB+IEFuZHJvaWQgNC4zLVxuICAkdG9GaXhlZC5jYWxsKHt9KTtcbn0pKSwgJ051bWJlcicsIHtcbiAgdG9GaXhlZDogZnVuY3Rpb24gdG9GaXhlZChmcmFjdGlvbkRpZ2l0cykge1xuICAgIHZhciB4ID0gYU51bWJlclZhbHVlKHRoaXMsIEVSUk9SKTtcbiAgICB2YXIgZiA9IHRvSW50ZWdlcihmcmFjdGlvbkRpZ2l0cyk7XG4gICAgdmFyIHMgPSAnJztcbiAgICB2YXIgbSA9IFpFUk87XG4gICAgdmFyIGUsIHosIGosIGs7XG4gICAgaWYgKGYgPCAwIHx8IGYgPiAyMCkgdGhyb3cgUmFuZ2VFcnJvcihFUlJPUik7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgIGlmICh4ICE9IHgpIHJldHVybiAnTmFOJztcbiAgICBpZiAoeCA8PSAtMWUyMSB8fCB4ID49IDFlMjEpIHJldHVybiBTdHJpbmcoeCk7XG4gICAgaWYgKHggPCAwKSB7XG4gICAgICBzID0gJy0nO1xuICAgICAgeCA9IC14O1xuICAgIH1cbiAgICBpZiAoeCA+IDFlLTIxKSB7XG4gICAgICBlID0gbG9nKHggKiBwb3coMiwgNjksIDEpKSAtIDY5O1xuICAgICAgeiA9IGUgPCAwID8geCAqIHBvdygyLCAtZSwgMSkgOiB4IC8gcG93KDIsIGUsIDEpO1xuICAgICAgeiAqPSAweDEwMDAwMDAwMDAwMDAwO1xuICAgICAgZSA9IDUyIC0gZTtcbiAgICAgIGlmIChlID4gMCkge1xuICAgICAgICBtdWx0aXBseSgwLCB6KTtcbiAgICAgICAgaiA9IGY7XG4gICAgICAgIHdoaWxlIChqID49IDcpIHtcbiAgICAgICAgICBtdWx0aXBseSgxZTcsIDApO1xuICAgICAgICAgIGogLT0gNztcbiAgICAgICAgfVxuICAgICAgICBtdWx0aXBseShwb3coMTAsIGosIDEpLCAwKTtcbiAgICAgICAgaiA9IGUgLSAxO1xuICAgICAgICB3aGlsZSAoaiA+PSAyMykge1xuICAgICAgICAgIGRpdmlkZSgxIDw8IDIzKTtcbiAgICAgICAgICBqIC09IDIzO1xuICAgICAgICB9XG4gICAgICAgIGRpdmlkZSgxIDw8IGopO1xuICAgICAgICBtdWx0aXBseSgxLCAxKTtcbiAgICAgICAgZGl2aWRlKDIpO1xuICAgICAgICBtID0gbnVtVG9TdHJpbmcoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG11bHRpcGx5KDAsIHopO1xuICAgICAgICBtdWx0aXBseSgxIDw8IC1lLCAwKTtcbiAgICAgICAgbSA9IG51bVRvU3RyaW5nKCkgKyByZXBlYXQuY2FsbChaRVJPLCBmKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGYgPiAwKSB7XG4gICAgICBrID0gbS5sZW5ndGg7XG4gICAgICBtID0gcyArIChrIDw9IGYgPyAnMC4nICsgcmVwZWF0LmNhbGwoWkVSTywgZiAtIGspICsgbSA6IG0uc2xpY2UoMCwgayAtIGYpICsgJy4nICsgbS5zbGljZShrIC0gZikpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gcyArIG07XG4gICAgfSByZXR1cm4gbTtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG52YXIgYU51bWJlclZhbHVlID0gcmVxdWlyZSgnLi9fYS1udW1iZXItdmFsdWUnKTtcbnZhciAkdG9QcmVjaXNpb24gPSAxLjAudG9QcmVjaXNpb247XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKCRmYWlscyhmdW5jdGlvbiAoKSB7XG4gIC8vIElFNy1cbiAgcmV0dXJuICR0b1ByZWNpc2lvbi5jYWxsKDEsIHVuZGVmaW5lZCkgIT09ICcxJztcbn0pIHx8ICEkZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvLyBWOCB+IEFuZHJvaWQgNC4zLVxuICAkdG9QcmVjaXNpb24uY2FsbCh7fSk7XG59KSksICdOdW1iZXInLCB7XG4gIHRvUHJlY2lzaW9uOiBmdW5jdGlvbiB0b1ByZWNpc2lvbihwcmVjaXNpb24pIHtcbiAgICB2YXIgdGhhdCA9IGFOdW1iZXJWYWx1ZSh0aGlzLCAnTnVtYmVyI3RvUHJlY2lzaW9uOiBpbmNvcnJlY3QgaW52b2NhdGlvbiEnKTtcbiAgICByZXR1cm4gcHJlY2lzaW9uID09PSB1bmRlZmluZWQgPyAkdG9QcmVjaXNpb24uY2FsbCh0aGF0KSA6ICR0b1ByZWNpc2lvbi5jYWxsKHRoYXQsIHByZWNpc2lvbik7XG4gIH1cbn0pO1xuIiwiLy8gMTkuMS4zLjEgT2JqZWN0LmFzc2lnbih0YXJnZXQsIHNvdXJjZSlcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GLCAnT2JqZWN0JywgeyBhc3NpZ246IHJlcXVpcmUoJy4vX29iamVjdC1hc3NpZ24nKSB9KTtcbiIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG4vLyAxOS4xLjIuMiAvIDE1LjIuMy41IE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcbiRleHBvcnQoJGV4cG9ydC5TLCAnT2JqZWN0JywgeyBjcmVhdGU6IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKSB9KTtcbiIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG4vLyAxOS4xLjIuMyAvIDE1LjIuMy43IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpLCAnT2JqZWN0JywgeyBkZWZpbmVQcm9wZXJ0aWVzOiByZXF1aXJlKCcuL19vYmplY3QtZHBzJykgfSk7XG4iLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuLy8gMTkuMS4yLjQgLyAxNS4yLjMuNiBPYmplY3QuZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcylcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJyksICdPYmplY3QnLCB7IGRlZmluZVByb3BlcnR5OiByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mIH0pO1xuIiwiLy8gMTkuMS4yLjUgT2JqZWN0LmZyZWV6ZShPKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgbWV0YSA9IHJlcXVpcmUoJy4vX21ldGEnKS5vbkZyZWV6ZTtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdmcmVlemUnLCBmdW5jdGlvbiAoJGZyZWV6ZSkge1xuICByZXR1cm4gZnVuY3Rpb24gZnJlZXplKGl0KSB7XG4gICAgcmV0dXJuICRmcmVlemUgJiYgaXNPYmplY3QoaXQpID8gJGZyZWV6ZShtZXRhKGl0KSkgOiBpdDtcbiAgfTtcbn0pO1xuIiwiLy8gMTkuMS4yLjYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKVxudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKS5mO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2dldE93blByb3BlcnR5RGVzY3JpcHRvcicsIGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihpdCwga2V5KSB7XG4gICAgcmV0dXJuICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodG9JT2JqZWN0KGl0KSwga2V5KTtcbiAgfTtcbn0pO1xuIiwiLy8gMTkuMS4yLjcgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTylcbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgnZ2V0T3duUHJvcGVydHlOYW1lcycsIGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHJlcXVpcmUoJy4vX29iamVjdC1nb3BuLWV4dCcpLmY7XG59KTtcbiIsIi8vIDE5LjEuMi45IE9iamVjdC5nZXRQcm90b3R5cGVPZihPKVxudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgJGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2dldFByb3RvdHlwZU9mJywgZnVuY3Rpb24gKCkge1xuICByZXR1cm4gZnVuY3Rpb24gZ2V0UHJvdG90eXBlT2YoaXQpIHtcbiAgICByZXR1cm4gJGdldFByb3RvdHlwZU9mKHRvT2JqZWN0KGl0KSk7XG4gIH07XG59KTtcbiIsIi8vIDE5LjEuMi4xMSBPYmplY3QuaXNFeHRlbnNpYmxlKE8pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdpc0V4dGVuc2libGUnLCBmdW5jdGlvbiAoJGlzRXh0ZW5zaWJsZSkge1xuICByZXR1cm4gZnVuY3Rpb24gaXNFeHRlbnNpYmxlKGl0KSB7XG4gICAgcmV0dXJuIGlzT2JqZWN0KGl0KSA/ICRpc0V4dGVuc2libGUgPyAkaXNFeHRlbnNpYmxlKGl0KSA6IHRydWUgOiBmYWxzZTtcbiAgfTtcbn0pO1xuIiwiLy8gMTkuMS4yLjEyIE9iamVjdC5pc0Zyb3plbihPKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgnaXNGcm96ZW4nLCBmdW5jdGlvbiAoJGlzRnJvemVuKSB7XG4gIHJldHVybiBmdW5jdGlvbiBpc0Zyb3plbihpdCkge1xuICAgIHJldHVybiBpc09iamVjdChpdCkgPyAkaXNGcm96ZW4gPyAkaXNGcm96ZW4oaXQpIDogZmFsc2UgOiB0cnVlO1xuICB9O1xufSk7XG4iLCIvLyAxOS4xLjIuMTMgT2JqZWN0LmlzU2VhbGVkKE8pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdpc1NlYWxlZCcsIGZ1bmN0aW9uICgkaXNTZWFsZWQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGlzU2VhbGVkKGl0KSB7XG4gICAgcmV0dXJuIGlzT2JqZWN0KGl0KSA/ICRpc1NlYWxlZCA/ICRpc1NlYWxlZChpdCkgOiBmYWxzZSA6IHRydWU7XG4gIH07XG59KTtcbiIsIi8vIDE5LjEuMy4xMCBPYmplY3QuaXModmFsdWUxLCB2YWx1ZTIpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuJGV4cG9ydCgkZXhwb3J0LlMsICdPYmplY3QnLCB7IGlzOiByZXF1aXJlKCcuL19zYW1lLXZhbHVlJykgfSk7XG4iLCIvLyAxOS4xLjIuMTQgT2JqZWN0LmtleXMoTylcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyICRrZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdrZXlzJywgZnVuY3Rpb24gKCkge1xuICByZXR1cm4gZnVuY3Rpb24ga2V5cyhpdCkge1xuICAgIHJldHVybiAka2V5cyh0b09iamVjdChpdCkpO1xuICB9O1xufSk7XG4iLCIvLyAxOS4xLjIuMTUgT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKE8pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBtZXRhID0gcmVxdWlyZSgnLi9fbWV0YScpLm9uRnJlZXplO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ3ByZXZlbnRFeHRlbnNpb25zJywgZnVuY3Rpb24gKCRwcmV2ZW50RXh0ZW5zaW9ucykge1xuICByZXR1cm4gZnVuY3Rpb24gcHJldmVudEV4dGVuc2lvbnMoaXQpIHtcbiAgICByZXR1cm4gJHByZXZlbnRFeHRlbnNpb25zICYmIGlzT2JqZWN0KGl0KSA/ICRwcmV2ZW50RXh0ZW5zaW9ucyhtZXRhKGl0KSkgOiBpdDtcbiAgfTtcbn0pO1xuIiwiLy8gMTkuMS4yLjE3IE9iamVjdC5zZWFsKE8pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBtZXRhID0gcmVxdWlyZSgnLi9fbWV0YScpLm9uRnJlZXplO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ3NlYWwnLCBmdW5jdGlvbiAoJHNlYWwpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHNlYWwoaXQpIHtcbiAgICByZXR1cm4gJHNlYWwgJiYgaXNPYmplY3QoaXQpID8gJHNlYWwobWV0YShpdCkpIDogaXQ7XG4gIH07XG59KTtcbiIsIi8vIDE5LjEuMy4xOSBPYmplY3Quc2V0UHJvdG90eXBlT2YoTywgcHJvdG8pXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuJGV4cG9ydCgkZXhwb3J0LlMsICdPYmplY3QnLCB7IHNldFByb3RvdHlwZU9mOiByZXF1aXJlKCcuL19zZXQtcHJvdG8nKS5zZXQgfSk7XG4iLCIndXNlIHN0cmljdCc7XG4vLyAxOS4xLjMuNiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKClcbnZhciBjbGFzc29mID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpO1xudmFyIHRlc3QgPSB7fTtcbnRlc3RbcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJyldID0gJ3onO1xuaWYgKHRlc3QgKyAnJyAhPSAnW29iamVjdCB6XScpIHtcbiAgcmVxdWlyZSgnLi9fcmVkZWZpbmUnKShPYmplY3QucHJvdG90eXBlLCAndG9TdHJpbmcnLCBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gJ1tvYmplY3QgJyArIGNsYXNzb2YodGhpcykgKyAnXSc7XG4gIH0sIHRydWUpO1xufVxuIiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkcGFyc2VGbG9hdCA9IHJlcXVpcmUoJy4vX3BhcnNlLWZsb2F0Jyk7XG4vLyAxOC4yLjQgcGFyc2VGbG9hdChzdHJpbmcpXG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuRiAqIChwYXJzZUZsb2F0ICE9ICRwYXJzZUZsb2F0KSwgeyBwYXJzZUZsb2F0OiAkcGFyc2VGbG9hdCB9KTtcbiIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJHBhcnNlSW50ID0gcmVxdWlyZSgnLi9fcGFyc2UtaW50Jyk7XG4vLyAxOC4yLjUgcGFyc2VJbnQoc3RyaW5nLCByYWRpeClcbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5GICogKHBhcnNlSW50ICE9ICRwYXJzZUludCksIHsgcGFyc2VJbnQ6ICRwYXJzZUludCB9KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBMSUJSQVJZID0gcmVxdWlyZSgnLi9fbGlicmFyeScpO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuL19jbGFzc29mJyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xudmFyIGFuSW5zdGFuY2UgPSByZXF1aXJlKCcuL19hbi1pbnN0YW5jZScpO1xudmFyIGZvck9mID0gcmVxdWlyZSgnLi9fZm9yLW9mJyk7XG52YXIgc3BlY2llc0NvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi9fc3BlY2llcy1jb25zdHJ1Y3RvcicpO1xudmFyIHRhc2sgPSByZXF1aXJlKCcuL190YXNrJykuc2V0O1xudmFyIG1pY3JvdGFzayA9IHJlcXVpcmUoJy4vX21pY3JvdGFzaycpKCk7XG52YXIgbmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUgPSByZXF1aXJlKCcuL19uZXctcHJvbWlzZS1jYXBhYmlsaXR5Jyk7XG52YXIgcGVyZm9ybSA9IHJlcXVpcmUoJy4vX3BlcmZvcm0nKTtcbnZhciBwcm9taXNlUmVzb2x2ZSA9IHJlcXVpcmUoJy4vX3Byb21pc2UtcmVzb2x2ZScpO1xudmFyIFBST01JU0UgPSAnUHJvbWlzZSc7XG52YXIgVHlwZUVycm9yID0gZ2xvYmFsLlR5cGVFcnJvcjtcbnZhciBwcm9jZXNzID0gZ2xvYmFsLnByb2Nlc3M7XG52YXIgJFByb21pc2UgPSBnbG9iYWxbUFJPTUlTRV07XG52YXIgaXNOb2RlID0gY2xhc3NvZihwcm9jZXNzKSA9PSAncHJvY2Vzcyc7XG52YXIgZW1wdHkgPSBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH07XG52YXIgSW50ZXJuYWwsIG5ld0dlbmVyaWNQcm9taXNlQ2FwYWJpbGl0eSwgT3duUHJvbWlzZUNhcGFiaWxpdHksIFdyYXBwZXI7XG52YXIgbmV3UHJvbWlzZUNhcGFiaWxpdHkgPSBuZXdHZW5lcmljUHJvbWlzZUNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZS5mO1xuXG52YXIgVVNFX05BVElWRSA9ICEhZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIC8vIGNvcnJlY3Qgc3ViY2xhc3Npbmcgd2l0aCBAQHNwZWNpZXMgc3VwcG9ydFxuICAgIHZhciBwcm9taXNlID0gJFByb21pc2UucmVzb2x2ZSgxKTtcbiAgICB2YXIgRmFrZVByb21pc2UgPSAocHJvbWlzZS5jb25zdHJ1Y3RvciA9IHt9KVtyZXF1aXJlKCcuL193a3MnKSgnc3BlY2llcycpXSA9IGZ1bmN0aW9uIChleGVjKSB7XG4gICAgICBleGVjKGVtcHR5LCBlbXB0eSk7XG4gICAgfTtcbiAgICAvLyB1bmhhbmRsZWQgcmVqZWN0aW9ucyB0cmFja2luZyBzdXBwb3J0LCBOb2RlSlMgUHJvbWlzZSB3aXRob3V0IGl0IGZhaWxzIEBAc3BlY2llcyB0ZXN0XG4gICAgcmV0dXJuIChpc05vZGUgfHwgdHlwZW9mIFByb21pc2VSZWplY3Rpb25FdmVudCA9PSAnZnVuY3Rpb24nKSAmJiBwcm9taXNlLnRoZW4oZW1wdHkpIGluc3RhbmNlb2YgRmFrZVByb21pc2U7XG4gIH0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxufSgpO1xuXG4vLyBoZWxwZXJzXG52YXIgaXNUaGVuYWJsZSA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgdGhlbjtcbiAgcmV0dXJuIGlzT2JqZWN0KGl0KSAmJiB0eXBlb2YgKHRoZW4gPSBpdC50aGVuKSA9PSAnZnVuY3Rpb24nID8gdGhlbiA6IGZhbHNlO1xufTtcbnZhciBub3RpZnkgPSBmdW5jdGlvbiAocHJvbWlzZSwgaXNSZWplY3QpIHtcbiAgaWYgKHByb21pc2UuX24pIHJldHVybjtcbiAgcHJvbWlzZS5fbiA9IHRydWU7XG4gIHZhciBjaGFpbiA9IHByb21pc2UuX2M7XG4gIG1pY3JvdGFzayhmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZhbHVlID0gcHJvbWlzZS5fdjtcbiAgICB2YXIgb2sgPSBwcm9taXNlLl9zID09IDE7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBydW4gPSBmdW5jdGlvbiAocmVhY3Rpb24pIHtcbiAgICAgIHZhciBoYW5kbGVyID0gb2sgPyByZWFjdGlvbi5vayA6IHJlYWN0aW9uLmZhaWw7XG4gICAgICB2YXIgcmVzb2x2ZSA9IHJlYWN0aW9uLnJlc29sdmU7XG4gICAgICB2YXIgcmVqZWN0ID0gcmVhY3Rpb24ucmVqZWN0O1xuICAgICAgdmFyIGRvbWFpbiA9IHJlYWN0aW9uLmRvbWFpbjtcbiAgICAgIHZhciByZXN1bHQsIHRoZW47XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICAgIGlmICghb2spIHtcbiAgICAgICAgICAgIGlmIChwcm9taXNlLl9oID09IDIpIG9uSGFuZGxlVW5oYW5kbGVkKHByb21pc2UpO1xuICAgICAgICAgICAgcHJvbWlzZS5faCA9IDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChoYW5kbGVyID09PSB0cnVlKSByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChkb21haW4pIGRvbWFpbi5lbnRlcigpO1xuICAgICAgICAgICAgcmVzdWx0ID0gaGFuZGxlcih2YWx1ZSk7XG4gICAgICAgICAgICBpZiAoZG9tYWluKSBkb21haW4uZXhpdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVzdWx0ID09PSByZWFjdGlvbi5wcm9taXNlKSB7XG4gICAgICAgICAgICByZWplY3QoVHlwZUVycm9yKCdQcm9taXNlLWNoYWluIGN5Y2xlJykpO1xuICAgICAgICAgIH0gZWxzZSBpZiAodGhlbiA9IGlzVGhlbmFibGUocmVzdWx0KSkge1xuICAgICAgICAgICAgdGhlbi5jYWxsKHJlc3VsdCwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9IGVsc2UgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9IGVsc2UgcmVqZWN0KHZhbHVlKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgd2hpbGUgKGNoYWluLmxlbmd0aCA+IGkpIHJ1bihjaGFpbltpKytdKTsgLy8gdmFyaWFibGUgbGVuZ3RoIC0gY2FuJ3QgdXNlIGZvckVhY2hcbiAgICBwcm9taXNlLl9jID0gW107XG4gICAgcHJvbWlzZS5fbiA9IGZhbHNlO1xuICAgIGlmIChpc1JlamVjdCAmJiAhcHJvbWlzZS5faCkgb25VbmhhbmRsZWQocHJvbWlzZSk7XG4gIH0pO1xufTtcbnZhciBvblVuaGFuZGxlZCA9IGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gIHRhc2suY2FsbChnbG9iYWwsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdmFsdWUgPSBwcm9taXNlLl92O1xuICAgIHZhciB1bmhhbmRsZWQgPSBpc1VuaGFuZGxlZChwcm9taXNlKTtcbiAgICB2YXIgcmVzdWx0LCBoYW5kbGVyLCBjb25zb2xlO1xuICAgIGlmICh1bmhhbmRsZWQpIHtcbiAgICAgIHJlc3VsdCA9IHBlcmZvcm0oZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaXNOb2RlKSB7XG4gICAgICAgICAgcHJvY2Vzcy5lbWl0KCd1bmhhbmRsZWRSZWplY3Rpb24nLCB2YWx1ZSwgcHJvbWlzZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaGFuZGxlciA9IGdsb2JhbC5vbnVuaGFuZGxlZHJlamVjdGlvbikge1xuICAgICAgICAgIGhhbmRsZXIoeyBwcm9taXNlOiBwcm9taXNlLCByZWFzb246IHZhbHVlIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKChjb25zb2xlID0gZ2xvYmFsLmNvbnNvbGUpICYmIGNvbnNvbGUuZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdVbmhhbmRsZWQgcHJvbWlzZSByZWplY3Rpb24nLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgLy8gQnJvd3NlcnMgc2hvdWxkIG5vdCB0cmlnZ2VyIGByZWplY3Rpb25IYW5kbGVkYCBldmVudCBpZiBpdCB3YXMgaGFuZGxlZCBoZXJlLCBOb2RlSlMgLSBzaG91bGRcbiAgICAgIHByb21pc2UuX2ggPSBpc05vZGUgfHwgaXNVbmhhbmRsZWQocHJvbWlzZSkgPyAyIDogMTtcbiAgICB9IHByb21pc2UuX2EgPSB1bmRlZmluZWQ7XG4gICAgaWYgKHVuaGFuZGxlZCAmJiByZXN1bHQuZSkgdGhyb3cgcmVzdWx0LnY7XG4gIH0pO1xufTtcbnZhciBpc1VuaGFuZGxlZCA9IGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gIGlmIChwcm9taXNlLl9oID09IDEpIHJldHVybiBmYWxzZTtcbiAgdmFyIGNoYWluID0gcHJvbWlzZS5fYSB8fCBwcm9taXNlLl9jO1xuICB2YXIgaSA9IDA7XG4gIHZhciByZWFjdGlvbjtcbiAgd2hpbGUgKGNoYWluLmxlbmd0aCA+IGkpIHtcbiAgICByZWFjdGlvbiA9IGNoYWluW2krK107XG4gICAgaWYgKHJlYWN0aW9uLmZhaWwgfHwgIWlzVW5oYW5kbGVkKHJlYWN0aW9uLnByb21pc2UpKSByZXR1cm4gZmFsc2U7XG4gIH0gcmV0dXJuIHRydWU7XG59O1xudmFyIG9uSGFuZGxlVW5oYW5kbGVkID0gZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgdGFzay5jYWxsKGdsb2JhbCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBoYW5kbGVyO1xuICAgIGlmIChpc05vZGUpIHtcbiAgICAgIHByb2Nlc3MuZW1pdCgncmVqZWN0aW9uSGFuZGxlZCcsIHByb21pc2UpO1xuICAgIH0gZWxzZSBpZiAoaGFuZGxlciA9IGdsb2JhbC5vbnJlamVjdGlvbmhhbmRsZWQpIHtcbiAgICAgIGhhbmRsZXIoeyBwcm9taXNlOiBwcm9taXNlLCByZWFzb246IHByb21pc2UuX3YgfSk7XG4gICAgfVxuICB9KTtcbn07XG52YXIgJHJlamVjdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICB2YXIgcHJvbWlzZSA9IHRoaXM7XG4gIGlmIChwcm9taXNlLl9kKSByZXR1cm47XG4gIHByb21pc2UuX2QgPSB0cnVlO1xuICBwcm9taXNlID0gcHJvbWlzZS5fdyB8fCBwcm9taXNlOyAvLyB1bndyYXBcbiAgcHJvbWlzZS5fdiA9IHZhbHVlO1xuICBwcm9taXNlLl9zID0gMjtcbiAgaWYgKCFwcm9taXNlLl9hKSBwcm9taXNlLl9hID0gcHJvbWlzZS5fYy5zbGljZSgpO1xuICBub3RpZnkocHJvbWlzZSwgdHJ1ZSk7XG59O1xudmFyICRyZXNvbHZlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHZhciBwcm9taXNlID0gdGhpcztcbiAgdmFyIHRoZW47XG4gIGlmIChwcm9taXNlLl9kKSByZXR1cm47XG4gIHByb21pc2UuX2QgPSB0cnVlO1xuICBwcm9taXNlID0gcHJvbWlzZS5fdyB8fCBwcm9taXNlOyAvLyB1bndyYXBcbiAgdHJ5IHtcbiAgICBpZiAocHJvbWlzZSA9PT0gdmFsdWUpIHRocm93IFR5cGVFcnJvcihcIlByb21pc2UgY2FuJ3QgYmUgcmVzb2x2ZWQgaXRzZWxmXCIpO1xuICAgIGlmICh0aGVuID0gaXNUaGVuYWJsZSh2YWx1ZSkpIHtcbiAgICAgIG1pY3JvdGFzayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB3cmFwcGVyID0geyBfdzogcHJvbWlzZSwgX2Q6IGZhbHNlIH07IC8vIHdyYXBcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGVuLmNhbGwodmFsdWUsIGN0eCgkcmVzb2x2ZSwgd3JhcHBlciwgMSksIGN0eCgkcmVqZWN0LCB3cmFwcGVyLCAxKSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAkcmVqZWN0LmNhbGwod3JhcHBlciwgZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9taXNlLl92ID0gdmFsdWU7XG4gICAgICBwcm9taXNlLl9zID0gMTtcbiAgICAgIG5vdGlmeShwcm9taXNlLCBmYWxzZSk7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgJHJlamVjdC5jYWxsKHsgX3c6IHByb21pc2UsIF9kOiBmYWxzZSB9LCBlKTsgLy8gd3JhcFxuICB9XG59O1xuXG4vLyBjb25zdHJ1Y3RvciBwb2x5ZmlsbFxuaWYgKCFVU0VfTkFUSVZFKSB7XG4gIC8vIDI1LjQuMy4xIFByb21pc2UoZXhlY3V0b3IpXG4gICRQcm9taXNlID0gZnVuY3Rpb24gUHJvbWlzZShleGVjdXRvcikge1xuICAgIGFuSW5zdGFuY2UodGhpcywgJFByb21pc2UsIFBST01JU0UsICdfaCcpO1xuICAgIGFGdW5jdGlvbihleGVjdXRvcik7XG4gICAgSW50ZXJuYWwuY2FsbCh0aGlzKTtcbiAgICB0cnkge1xuICAgICAgZXhlY3V0b3IoY3R4KCRyZXNvbHZlLCB0aGlzLCAxKSwgY3R4KCRyZWplY3QsIHRoaXMsIDEpKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICRyZWplY3QuY2FsbCh0aGlzLCBlcnIpO1xuICAgIH1cbiAgfTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gIEludGVybmFsID0gZnVuY3Rpb24gUHJvbWlzZShleGVjdXRvcikge1xuICAgIHRoaXMuX2MgPSBbXTsgICAgICAgICAgICAgLy8gPC0gYXdhaXRpbmcgcmVhY3Rpb25zXG4gICAgdGhpcy5fYSA9IHVuZGVmaW5lZDsgICAgICAvLyA8LSBjaGVja2VkIGluIGlzVW5oYW5kbGVkIHJlYWN0aW9uc1xuICAgIHRoaXMuX3MgPSAwOyAgICAgICAgICAgICAgLy8gPC0gc3RhdGVcbiAgICB0aGlzLl9kID0gZmFsc2U7ICAgICAgICAgIC8vIDwtIGRvbmVcbiAgICB0aGlzLl92ID0gdW5kZWZpbmVkOyAgICAgIC8vIDwtIHZhbHVlXG4gICAgdGhpcy5faCA9IDA7ICAgICAgICAgICAgICAvLyA8LSByZWplY3Rpb24gc3RhdGUsIDAgLSBkZWZhdWx0LCAxIC0gaGFuZGxlZCwgMiAtIHVuaGFuZGxlZFxuICAgIHRoaXMuX24gPSBmYWxzZTsgICAgICAgICAgLy8gPC0gbm90aWZ5XG4gIH07XG4gIEludGVybmFsLnByb3RvdHlwZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpKCRQcm9taXNlLnByb3RvdHlwZSwge1xuICAgIC8vIDI1LjQuNS4zIFByb21pc2UucHJvdG90eXBlLnRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpXG4gICAgdGhlbjogZnVuY3Rpb24gdGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICAgICAgdmFyIHJlYWN0aW9uID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkoc3BlY2llc0NvbnN0cnVjdG9yKHRoaXMsICRQcm9taXNlKSk7XG4gICAgICByZWFjdGlvbi5vayA9IHR5cGVvZiBvbkZ1bGZpbGxlZCA9PSAnZnVuY3Rpb24nID8gb25GdWxmaWxsZWQgOiB0cnVlO1xuICAgICAgcmVhY3Rpb24uZmFpbCA9IHR5cGVvZiBvblJlamVjdGVkID09ICdmdW5jdGlvbicgJiYgb25SZWplY3RlZDtcbiAgICAgIHJlYWN0aW9uLmRvbWFpbiA9IGlzTm9kZSA/IHByb2Nlc3MuZG9tYWluIDogdW5kZWZpbmVkO1xuICAgICAgdGhpcy5fYy5wdXNoKHJlYWN0aW9uKTtcbiAgICAgIGlmICh0aGlzLl9hKSB0aGlzLl9hLnB1c2gocmVhY3Rpb24pO1xuICAgICAgaWYgKHRoaXMuX3MpIG5vdGlmeSh0aGlzLCBmYWxzZSk7XG4gICAgICByZXR1cm4gcmVhY3Rpb24ucHJvbWlzZTtcbiAgICB9LFxuICAgIC8vIDI1LjQuNS4xIFByb21pc2UucHJvdG90eXBlLmNhdGNoKG9uUmVqZWN0ZWQpXG4gICAgJ2NhdGNoJzogZnVuY3Rpb24gKG9uUmVqZWN0ZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLnRoZW4odW5kZWZpbmVkLCBvblJlamVjdGVkKTtcbiAgICB9XG4gIH0pO1xuICBPd25Qcm9taXNlQ2FwYWJpbGl0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcHJvbWlzZSA9IG5ldyBJbnRlcm5hbCgpO1xuICAgIHRoaXMucHJvbWlzZSA9IHByb21pc2U7XG4gICAgdGhpcy5yZXNvbHZlID0gY3R4KCRyZXNvbHZlLCBwcm9taXNlLCAxKTtcbiAgICB0aGlzLnJlamVjdCA9IGN0eCgkcmVqZWN0LCBwcm9taXNlLCAxKTtcbiAgfTtcbiAgbmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUuZiA9IG5ld1Byb21pc2VDYXBhYmlsaXR5ID0gZnVuY3Rpb24gKEMpIHtcbiAgICByZXR1cm4gQyA9PT0gJFByb21pc2UgfHwgQyA9PT0gV3JhcHBlclxuICAgICAgPyBuZXcgT3duUHJvbWlzZUNhcGFiaWxpdHkoQylcbiAgICAgIDogbmV3R2VuZXJpY1Byb21pc2VDYXBhYmlsaXR5KEMpO1xuICB9O1xufVxuXG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuVyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCB7IFByb21pc2U6ICRQcm9taXNlIH0pO1xucmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKSgkUHJvbWlzZSwgUFJPTUlTRSk7XG5yZXF1aXJlKCcuL19zZXQtc3BlY2llcycpKFBST01JU0UpO1xuV3JhcHBlciA9IHJlcXVpcmUoJy4vX2NvcmUnKVtQUk9NSVNFXTtcblxuLy8gc3RhdGljc1xuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgUFJPTUlTRSwge1xuICAvLyAyNS40LjQuNSBQcm9taXNlLnJlamVjdChyKVxuICByZWplY3Q6IGZ1bmN0aW9uIHJlamVjdChyKSB7XG4gICAgdmFyIGNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eSh0aGlzKTtcbiAgICB2YXIgJCRyZWplY3QgPSBjYXBhYmlsaXR5LnJlamVjdDtcbiAgICAkJHJlamVjdChyKTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG59KTtcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKExJQlJBUlkgfHwgIVVTRV9OQVRJVkUpLCBQUk9NSVNFLCB7XG4gIC8vIDI1LjQuNC42IFByb21pc2UucmVzb2x2ZSh4KVxuICByZXNvbHZlOiBmdW5jdGlvbiByZXNvbHZlKHgpIHtcbiAgICByZXR1cm4gcHJvbWlzZVJlc29sdmUoTElCUkFSWSAmJiB0aGlzID09PSBXcmFwcGVyID8gJFByb21pc2UgOiB0aGlzLCB4KTtcbiAgfVxufSk7XG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICEoVVNFX05BVElWRSAmJiByZXF1aXJlKCcuL19pdGVyLWRldGVjdCcpKGZ1bmN0aW9uIChpdGVyKSB7XG4gICRQcm9taXNlLmFsbChpdGVyKVsnY2F0Y2gnXShlbXB0eSk7XG59KSksIFBST01JU0UsIHtcbiAgLy8gMjUuNC40LjEgUHJvbWlzZS5hbGwoaXRlcmFibGUpXG4gIGFsbDogZnVuY3Rpb24gYWxsKGl0ZXJhYmxlKSB7XG4gICAgdmFyIEMgPSB0aGlzO1xuICAgIHZhciBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkoQyk7XG4gICAgdmFyIHJlc29sdmUgPSBjYXBhYmlsaXR5LnJlc29sdmU7XG4gICAgdmFyIHJlamVjdCA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgIHZhciByZXN1bHQgPSBwZXJmb3JtKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICB2YXIgcmVtYWluaW5nID0gMTtcbiAgICAgIGZvck9mKGl0ZXJhYmxlLCBmYWxzZSwgZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgICAgICAgdmFyICRpbmRleCA9IGluZGV4Kys7XG4gICAgICAgIHZhciBhbHJlYWR5Q2FsbGVkID0gZmFsc2U7XG4gICAgICAgIHZhbHVlcy5wdXNoKHVuZGVmaW5lZCk7XG4gICAgICAgIHJlbWFpbmluZysrO1xuICAgICAgICBDLnJlc29sdmUocHJvbWlzZSkudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICBpZiAoYWxyZWFkeUNhbGxlZCkgcmV0dXJuO1xuICAgICAgICAgIGFscmVhZHlDYWxsZWQgPSB0cnVlO1xuICAgICAgICAgIHZhbHVlc1skaW5kZXhdID0gdmFsdWU7XG4gICAgICAgICAgLS1yZW1haW5pbmcgfHwgcmVzb2x2ZSh2YWx1ZXMpO1xuICAgICAgICB9LCByZWplY3QpO1xuICAgICAgfSk7XG4gICAgICAtLXJlbWFpbmluZyB8fCByZXNvbHZlKHZhbHVlcyk7XG4gICAgfSk7XG4gICAgaWYgKHJlc3VsdC5lKSByZWplY3QocmVzdWx0LnYpO1xuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH0sXG4gIC8vIDI1LjQuNC40IFByb21pc2UucmFjZShpdGVyYWJsZSlcbiAgcmFjZTogZnVuY3Rpb24gcmFjZShpdGVyYWJsZSkge1xuICAgIHZhciBDID0gdGhpcztcbiAgICB2YXIgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KEMpO1xuICAgIHZhciByZWplY3QgPSBjYXBhYmlsaXR5LnJlamVjdDtcbiAgICB2YXIgcmVzdWx0ID0gcGVyZm9ybShmdW5jdGlvbiAoKSB7XG4gICAgICBmb3JPZihpdGVyYWJsZSwgZmFsc2UsIGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gICAgICAgIEMucmVzb2x2ZShwcm9taXNlKS50aGVuKGNhcGFiaWxpdHkucmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGlmIChyZXN1bHQuZSkgcmVqZWN0KHJlc3VsdC52KTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG59KTtcbiIsIi8vIDI2LjEuMSBSZWZsZWN0LmFwcGx5KHRhcmdldCwgdGhpc0FyZ3VtZW50LCBhcmd1bWVudHNMaXN0KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciByQXBwbHkgPSAocmVxdWlyZSgnLi9fZ2xvYmFsJykuUmVmbGVjdCB8fCB7fSkuYXBwbHk7XG52YXIgZkFwcGx5ID0gRnVuY3Rpb24uYXBwbHk7XG4vLyBNUyBFZGdlIGFyZ3VtZW50c0xpc3QgYXJndW1lbnQgaXMgb3B0aW9uYWxcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByQXBwbHkoZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9KTtcbn0pLCAnUmVmbGVjdCcsIHtcbiAgYXBwbHk6IGZ1bmN0aW9uIGFwcGx5KHRhcmdldCwgdGhpc0FyZ3VtZW50LCBhcmd1bWVudHNMaXN0KSB7XG4gICAgdmFyIFQgPSBhRnVuY3Rpb24odGFyZ2V0KTtcbiAgICB2YXIgTCA9IGFuT2JqZWN0KGFyZ3VtZW50c0xpc3QpO1xuICAgIHJldHVybiByQXBwbHkgPyByQXBwbHkoVCwgdGhpc0FyZ3VtZW50LCBMKSA6IGZBcHBseS5jYWxsKFQsIHRoaXNBcmd1bWVudCwgTCk7XG4gIH1cbn0pO1xuIiwiLy8gMjYuMS4yIFJlZmxlY3QuY29uc3RydWN0KHRhcmdldCwgYXJndW1lbnRzTGlzdCBbLCBuZXdUYXJnZXRdKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBjcmVhdGUgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJyk7XG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG52YXIgYmluZCA9IHJlcXVpcmUoJy4vX2JpbmQnKTtcbnZhciByQ29uc3RydWN0ID0gKHJlcXVpcmUoJy4vX2dsb2JhbCcpLlJlZmxlY3QgfHwge30pLmNvbnN0cnVjdDtcblxuLy8gTVMgRWRnZSBzdXBwb3J0cyBvbmx5IDIgYXJndW1lbnRzIGFuZCBhcmd1bWVudHNMaXN0IGFyZ3VtZW50IGlzIG9wdGlvbmFsXG4vLyBGRiBOaWdodGx5IHNldHMgdGhpcmQgYXJndW1lbnQgYXMgYG5ldy50YXJnZXRgLCBidXQgZG9lcyBub3QgY3JlYXRlIGB0aGlzYCBmcm9tIGl0XG52YXIgTkVXX1RBUkdFVF9CVUcgPSBmYWlscyhmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEYoKSB7IC8qIGVtcHR5ICovIH1cbiAgcmV0dXJuICEockNvbnN0cnVjdChmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH0sIFtdLCBGKSBpbnN0YW5jZW9mIEYpO1xufSk7XG52YXIgQVJHU19CVUcgPSAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICByQ29uc3RydWN0KGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSk7XG59KTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoTkVXX1RBUkdFVF9CVUcgfHwgQVJHU19CVUcpLCAnUmVmbGVjdCcsIHtcbiAgY29uc3RydWN0OiBmdW5jdGlvbiBjb25zdHJ1Y3QoVGFyZ2V0LCBhcmdzIC8qICwgbmV3VGFyZ2V0ICovKSB7XG4gICAgYUZ1bmN0aW9uKFRhcmdldCk7XG4gICAgYW5PYmplY3QoYXJncyk7XG4gICAgdmFyIG5ld1RhcmdldCA9IGFyZ3VtZW50cy5sZW5ndGggPCAzID8gVGFyZ2V0IDogYUZ1bmN0aW9uKGFyZ3VtZW50c1syXSk7XG4gICAgaWYgKEFSR1NfQlVHICYmICFORVdfVEFSR0VUX0JVRykgcmV0dXJuIHJDb25zdHJ1Y3QoVGFyZ2V0LCBhcmdzLCBuZXdUYXJnZXQpO1xuICAgIGlmIChUYXJnZXQgPT0gbmV3VGFyZ2V0KSB7XG4gICAgICAvLyB3L28gYWx0ZXJlZCBuZXdUYXJnZXQsIG9wdGltaXphdGlvbiBmb3IgMC00IGFyZ3VtZW50c1xuICAgICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDA6IHJldHVybiBuZXcgVGFyZ2V0KCk7XG4gICAgICAgIGNhc2UgMTogcmV0dXJuIG5ldyBUYXJnZXQoYXJnc1swXSk7XG4gICAgICAgIGNhc2UgMjogcmV0dXJuIG5ldyBUYXJnZXQoYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgIGNhc2UgMzogcmV0dXJuIG5ldyBUYXJnZXQoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgIGNhc2UgNDogcmV0dXJuIG5ldyBUYXJnZXQoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSk7XG4gICAgICB9XG4gICAgICAvLyB3L28gYWx0ZXJlZCBuZXdUYXJnZXQsIGxvdCBvZiBhcmd1bWVudHMgY2FzZVxuICAgICAgdmFyICRhcmdzID0gW251bGxdO1xuICAgICAgJGFyZ3MucHVzaC5hcHBseSgkYXJncywgYXJncyk7XG4gICAgICByZXR1cm4gbmV3IChiaW5kLmFwcGx5KFRhcmdldCwgJGFyZ3MpKSgpO1xuICAgIH1cbiAgICAvLyB3aXRoIGFsdGVyZWQgbmV3VGFyZ2V0LCBub3Qgc3VwcG9ydCBidWlsdC1pbiBjb25zdHJ1Y3RvcnNcbiAgICB2YXIgcHJvdG8gPSBuZXdUYXJnZXQucHJvdG90eXBlO1xuICAgIHZhciBpbnN0YW5jZSA9IGNyZWF0ZShpc09iamVjdChwcm90bykgPyBwcm90byA6IE9iamVjdC5wcm90b3R5cGUpO1xuICAgIHZhciByZXN1bHQgPSBGdW5jdGlvbi5hcHBseS5jYWxsKFRhcmdldCwgaW5zdGFuY2UsIGFyZ3MpO1xuICAgIHJldHVybiBpc09iamVjdChyZXN1bHQpID8gcmVzdWx0IDogaW5zdGFuY2U7XG4gIH1cbn0pO1xuIiwiLy8gMjYuMS4zIFJlZmxlY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eUtleSwgYXR0cmlidXRlcylcbnZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7XG5cbi8vIE1TIEVkZ2UgaGFzIGJyb2tlbiBSZWZsZWN0LmRlZmluZVByb3BlcnR5IC0gdGhyb3dpbmcgaW5zdGVhZCBvZiByZXR1cm5pbmcgZmFsc2VcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICBSZWZsZWN0LmRlZmluZVByb3BlcnR5KGRQLmYoe30sIDEsIHsgdmFsdWU6IDEgfSksIDEsIHsgdmFsdWU6IDIgfSk7XG59KSwgJ1JlZmxlY3QnLCB7XG4gIGRlZmluZVByb3BlcnR5OiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5S2V5LCBhdHRyaWJ1dGVzKSB7XG4gICAgYW5PYmplY3QodGFyZ2V0KTtcbiAgICBwcm9wZXJ0eUtleSA9IHRvUHJpbWl0aXZlKHByb3BlcnR5S2V5LCB0cnVlKTtcbiAgICBhbk9iamVjdChhdHRyaWJ1dGVzKTtcbiAgICB0cnkge1xuICAgICAgZFAuZih0YXJnZXQsIHByb3BlcnR5S2V5LCBhdHRyaWJ1dGVzKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbn0pO1xuIiwiLy8gMjYuMS40IFJlZmxlY3QuZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eUtleSlcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgZ09QRCA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJykuZjtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7XG4gIGRlbGV0ZVByb3BlcnR5OiBmdW5jdGlvbiBkZWxldGVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5S2V5KSB7XG4gICAgdmFyIGRlc2MgPSBnT1BEKGFuT2JqZWN0KHRhcmdldCksIHByb3BlcnR5S2V5KTtcbiAgICByZXR1cm4gZGVzYyAmJiAhZGVzYy5jb25maWd1cmFibGUgPyBmYWxzZSA6IGRlbGV0ZSB0YXJnZXRbcHJvcGVydHlLZXldO1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIDI2LjEuNSBSZWZsZWN0LmVudW1lcmF0ZSh0YXJnZXQpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgRW51bWVyYXRlID0gZnVuY3Rpb24gKGl0ZXJhdGVkKSB7XG4gIHRoaXMuX3QgPSBhbk9iamVjdChpdGVyYXRlZCk7IC8vIHRhcmdldFxuICB0aGlzLl9pID0gMDsgICAgICAgICAgICAgICAgICAvLyBuZXh0IGluZGV4XG4gIHZhciBrZXlzID0gdGhpcy5fayA9IFtdOyAgICAgIC8vIGtleXNcbiAgdmFyIGtleTtcbiAgZm9yIChrZXkgaW4gaXRlcmF0ZWQpIGtleXMucHVzaChrZXkpO1xufTtcbnJlcXVpcmUoJy4vX2l0ZXItY3JlYXRlJykoRW51bWVyYXRlLCAnT2JqZWN0JywgZnVuY3Rpb24gKCkge1xuICB2YXIgdGhhdCA9IHRoaXM7XG4gIHZhciBrZXlzID0gdGhhdC5faztcbiAgdmFyIGtleTtcbiAgZG8ge1xuICAgIGlmICh0aGF0Ll9pID49IGtleXMubGVuZ3RoKSByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIH0gd2hpbGUgKCEoKGtleSA9IGtleXNbdGhhdC5faSsrXSkgaW4gdGhhdC5fdCkpO1xuICByZXR1cm4geyB2YWx1ZToga2V5LCBkb25lOiBmYWxzZSB9O1xufSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHtcbiAgZW51bWVyYXRlOiBmdW5jdGlvbiBlbnVtZXJhdGUodGFyZ2V0KSB7XG4gICAgcmV0dXJuIG5ldyBFbnVtZXJhdGUodGFyZ2V0KTtcbiAgfVxufSk7XG4iLCIvLyAyNi4xLjcgUmVmbGVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBwcm9wZXJ0eUtleSlcbnZhciBnT1BEID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKTtcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge1xuICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIHByb3BlcnR5S2V5KSB7XG4gICAgcmV0dXJuIGdPUEQuZihhbk9iamVjdCh0YXJnZXQpLCBwcm9wZXJ0eUtleSk7XG4gIH1cbn0pO1xuIiwiLy8gMjYuMS44IFJlZmxlY3QuZ2V0UHJvdG90eXBlT2YodGFyZ2V0KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBnZXRQcm90byA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7XG4gIGdldFByb3RvdHlwZU9mOiBmdW5jdGlvbiBnZXRQcm90b3R5cGVPZih0YXJnZXQpIHtcbiAgICByZXR1cm4gZ2V0UHJvdG8oYW5PYmplY3QodGFyZ2V0KSk7XG4gIH1cbn0pO1xuIiwiLy8gMjYuMS42IFJlZmxlY3QuZ2V0KHRhcmdldCwgcHJvcGVydHlLZXkgWywgcmVjZWl2ZXJdKVxudmFyIGdPUEQgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpO1xudmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5cbmZ1bmN0aW9uIGdldCh0YXJnZXQsIHByb3BlcnR5S2V5IC8qICwgcmVjZWl2ZXIgKi8pIHtcbiAgdmFyIHJlY2VpdmVyID0gYXJndW1lbnRzLmxlbmd0aCA8IDMgPyB0YXJnZXQgOiBhcmd1bWVudHNbMl07XG4gIHZhciBkZXNjLCBwcm90bztcbiAgaWYgKGFuT2JqZWN0KHRhcmdldCkgPT09IHJlY2VpdmVyKSByZXR1cm4gdGFyZ2V0W3Byb3BlcnR5S2V5XTtcbiAgaWYgKGRlc2MgPSBnT1BELmYodGFyZ2V0LCBwcm9wZXJ0eUtleSkpIHJldHVybiBoYXMoZGVzYywgJ3ZhbHVlJylcbiAgICA/IGRlc2MudmFsdWVcbiAgICA6IGRlc2MuZ2V0ICE9PSB1bmRlZmluZWRcbiAgICAgID8gZGVzYy5nZXQuY2FsbChyZWNlaXZlcilcbiAgICAgIDogdW5kZWZpbmVkO1xuICBpZiAoaXNPYmplY3QocHJvdG8gPSBnZXRQcm90b3R5cGVPZih0YXJnZXQpKSkgcmV0dXJuIGdldChwcm90bywgcHJvcGVydHlLZXksIHJlY2VpdmVyKTtcbn1cblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0JywgeyBnZXQ6IGdldCB9KTtcbiIsIi8vIDI2LjEuOSBSZWZsZWN0Lmhhcyh0YXJnZXQsIHByb3BlcnR5S2V5KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge1xuICBoYXM6IGZ1bmN0aW9uIGhhcyh0YXJnZXQsIHByb3BlcnR5S2V5KSB7XG4gICAgcmV0dXJuIHByb3BlcnR5S2V5IGluIHRhcmdldDtcbiAgfVxufSk7XG4iLCIvLyAyNi4xLjEwIFJlZmxlY3QuaXNFeHRlbnNpYmxlKHRhcmdldClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciAkaXNFeHRlbnNpYmxlID0gT2JqZWN0LmlzRXh0ZW5zaWJsZTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge1xuICBpc0V4dGVuc2libGU6IGZ1bmN0aW9uIGlzRXh0ZW5zaWJsZSh0YXJnZXQpIHtcbiAgICBhbk9iamVjdCh0YXJnZXQpO1xuICAgIHJldHVybiAkaXNFeHRlbnNpYmxlID8gJGlzRXh0ZW5zaWJsZSh0YXJnZXQpIDogdHJ1ZTtcbiAgfVxufSk7XG4iLCIvLyAyNi4xLjExIFJlZmxlY3Qub3duS2V5cyh0YXJnZXQpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7IG93bktleXM6IHJlcXVpcmUoJy4vX293bi1rZXlzJykgfSk7XG4iLCIvLyAyNi4xLjEyIFJlZmxlY3QucHJldmVudEV4dGVuc2lvbnModGFyZ2V0KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyICRwcmV2ZW50RXh0ZW5zaW9ucyA9IE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucztcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge1xuICBwcmV2ZW50RXh0ZW5zaW9uczogZnVuY3Rpb24gcHJldmVudEV4dGVuc2lvbnModGFyZ2V0KSB7XG4gICAgYW5PYmplY3QodGFyZ2V0KTtcbiAgICB0cnkge1xuICAgICAgaWYgKCRwcmV2ZW50RXh0ZW5zaW9ucykgJHByZXZlbnRFeHRlbnNpb25zKHRhcmdldCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG59KTtcbiIsIi8vIDI2LjEuMTQgUmVmbGVjdC5zZXRQcm90b3R5cGVPZih0YXJnZXQsIHByb3RvKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBzZXRQcm90byA9IHJlcXVpcmUoJy4vX3NldC1wcm90bycpO1xuXG5pZiAoc2V0UHJvdG8pICRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHtcbiAgc2V0UHJvdG90eXBlT2Y6IGZ1bmN0aW9uIHNldFByb3RvdHlwZU9mKHRhcmdldCwgcHJvdG8pIHtcbiAgICBzZXRQcm90by5jaGVjayh0YXJnZXQsIHByb3RvKTtcbiAgICB0cnkge1xuICAgICAgc2V0UHJvdG8uc2V0KHRhcmdldCwgcHJvdG8pO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxufSk7XG4iLCIvLyAyNi4xLjEzIFJlZmxlY3Quc2V0KHRhcmdldCwgcHJvcGVydHlLZXksIFYgWywgcmVjZWl2ZXJdKVxudmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG52YXIgZ09QRCA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJyk7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGNyZWF0ZURlc2MgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xuXG5mdW5jdGlvbiBzZXQodGFyZ2V0LCBwcm9wZXJ0eUtleSwgViAvKiAsIHJlY2VpdmVyICovKSB7XG4gIHZhciByZWNlaXZlciA9IGFyZ3VtZW50cy5sZW5ndGggPCA0ID8gdGFyZ2V0IDogYXJndW1lbnRzWzNdO1xuICB2YXIgb3duRGVzYyA9IGdPUEQuZihhbk9iamVjdCh0YXJnZXQpLCBwcm9wZXJ0eUtleSk7XG4gIHZhciBleGlzdGluZ0Rlc2NyaXB0b3IsIHByb3RvO1xuICBpZiAoIW93bkRlc2MpIHtcbiAgICBpZiAoaXNPYmplY3QocHJvdG8gPSBnZXRQcm90b3R5cGVPZih0YXJnZXQpKSkge1xuICAgICAgcmV0dXJuIHNldChwcm90bywgcHJvcGVydHlLZXksIFYsIHJlY2VpdmVyKTtcbiAgICB9XG4gICAgb3duRGVzYyA9IGNyZWF0ZURlc2MoMCk7XG4gIH1cbiAgaWYgKGhhcyhvd25EZXNjLCAndmFsdWUnKSkge1xuICAgIGlmIChvd25EZXNjLndyaXRhYmxlID09PSBmYWxzZSB8fCAhaXNPYmplY3QocmVjZWl2ZXIpKSByZXR1cm4gZmFsc2U7XG4gICAgZXhpc3RpbmdEZXNjcmlwdG9yID0gZ09QRC5mKHJlY2VpdmVyLCBwcm9wZXJ0eUtleSkgfHwgY3JlYXRlRGVzYygwKTtcbiAgICBleGlzdGluZ0Rlc2NyaXB0b3IudmFsdWUgPSBWO1xuICAgIGRQLmYocmVjZWl2ZXIsIHByb3BlcnR5S2V5LCBleGlzdGluZ0Rlc2NyaXB0b3IpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBvd25EZXNjLnNldCA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiAob3duRGVzYy5zZXQuY2FsbChyZWNlaXZlciwgViksIHRydWUpO1xufVxuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7IHNldDogc2V0IH0pO1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGluaGVyaXRJZlJlcXVpcmVkID0gcmVxdWlyZSgnLi9faW5oZXJpdC1pZi1yZXF1aXJlZCcpO1xudmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbnZhciBnT1BOID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mO1xudmFyIGlzUmVnRXhwID0gcmVxdWlyZSgnLi9faXMtcmVnZXhwJyk7XG52YXIgJGZsYWdzID0gcmVxdWlyZSgnLi9fZmxhZ3MnKTtcbnZhciAkUmVnRXhwID0gZ2xvYmFsLlJlZ0V4cDtcbnZhciBCYXNlID0gJFJlZ0V4cDtcbnZhciBwcm90byA9ICRSZWdFeHAucHJvdG90eXBlO1xudmFyIHJlMSA9IC9hL2c7XG52YXIgcmUyID0gL2EvZztcbi8vIFwibmV3XCIgY3JlYXRlcyBhIG5ldyBvYmplY3QsIG9sZCB3ZWJraXQgYnVnZ3kgaGVyZVxudmFyIENPUlJFQ1RfTkVXID0gbmV3ICRSZWdFeHAocmUxKSAhPT0gcmUxO1xuXG5pZiAocmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiAoIUNPUlJFQ1RfTkVXIHx8IHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZTJbcmVxdWlyZSgnLi9fd2tzJykoJ21hdGNoJyldID0gZmFsc2U7XG4gIC8vIFJlZ0V4cCBjb25zdHJ1Y3RvciBjYW4gYWx0ZXIgZmxhZ3MgYW5kIElzUmVnRXhwIHdvcmtzIGNvcnJlY3Qgd2l0aCBAQG1hdGNoXG4gIHJldHVybiAkUmVnRXhwKHJlMSkgIT0gcmUxIHx8ICRSZWdFeHAocmUyKSA9PSByZTIgfHwgJFJlZ0V4cChyZTEsICdpJykgIT0gJy9hL2knO1xufSkpKSB7XG4gICRSZWdFeHAgPSBmdW5jdGlvbiBSZWdFeHAocCwgZikge1xuICAgIHZhciB0aVJFID0gdGhpcyBpbnN0YW5jZW9mICRSZWdFeHA7XG4gICAgdmFyIHBpUkUgPSBpc1JlZ0V4cChwKTtcbiAgICB2YXIgZmlVID0gZiA9PT0gdW5kZWZpbmVkO1xuICAgIHJldHVybiAhdGlSRSAmJiBwaVJFICYmIHAuY29uc3RydWN0b3IgPT09ICRSZWdFeHAgJiYgZmlVID8gcFxuICAgICAgOiBpbmhlcml0SWZSZXF1aXJlZChDT1JSRUNUX05FV1xuICAgICAgICA/IG5ldyBCYXNlKHBpUkUgJiYgIWZpVSA/IHAuc291cmNlIDogcCwgZilcbiAgICAgICAgOiBCYXNlKChwaVJFID0gcCBpbnN0YW5jZW9mICRSZWdFeHApID8gcC5zb3VyY2UgOiBwLCBwaVJFICYmIGZpVSA/ICRmbGFncy5jYWxsKHApIDogZilcbiAgICAgICwgdGlSRSA/IHRoaXMgOiBwcm90bywgJFJlZ0V4cCk7XG4gIH07XG4gIHZhciBwcm94eSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICBrZXkgaW4gJFJlZ0V4cCB8fCBkUCgkUmVnRXhwLCBrZXksIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gQmFzZVtrZXldOyB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAoaXQpIHsgQmFzZVtrZXldID0gaXQ7IH1cbiAgICB9KTtcbiAgfTtcbiAgZm9yICh2YXIga2V5cyA9IGdPUE4oQmFzZSksIGkgPSAwOyBrZXlzLmxlbmd0aCA+IGk7KSBwcm94eShrZXlzW2krK10pO1xuICBwcm90by5jb25zdHJ1Y3RvciA9ICRSZWdFeHA7XG4gICRSZWdFeHAucHJvdG90eXBlID0gcHJvdG87XG4gIHJlcXVpcmUoJy4vX3JlZGVmaW5lJykoZ2xvYmFsLCAnUmVnRXhwJywgJFJlZ0V4cCk7XG59XG5cbnJlcXVpcmUoJy4vX3NldC1zcGVjaWVzJykoJ1JlZ0V4cCcpO1xuIiwiLy8gMjEuMi41LjMgZ2V0IFJlZ0V4cC5wcm90b3R5cGUuZmxhZ3MoKVxuaWYgKHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgLy4vZy5mbGFncyAhPSAnZycpIHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmYoUmVnRXhwLnByb3RvdHlwZSwgJ2ZsYWdzJywge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGdldDogcmVxdWlyZSgnLi9fZmxhZ3MnKVxufSk7XG4iLCIvLyBAQG1hdGNoIGxvZ2ljXG5yZXF1aXJlKCcuL19maXgtcmUtd2tzJykoJ21hdGNoJywgMSwgZnVuY3Rpb24gKGRlZmluZWQsIE1BVENILCAkbWF0Y2gpIHtcbiAgLy8gMjEuMS4zLjExIFN0cmluZy5wcm90b3R5cGUubWF0Y2gocmVnZXhwKVxuICByZXR1cm4gW2Z1bmN0aW9uIG1hdGNoKHJlZ2V4cCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICB2YXIgTyA9IGRlZmluZWQodGhpcyk7XG4gICAgdmFyIGZuID0gcmVnZXhwID09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHJlZ2V4cFtNQVRDSF07XG4gICAgcmV0dXJuIGZuICE9PSB1bmRlZmluZWQgPyBmbi5jYWxsKHJlZ2V4cCwgTykgOiBuZXcgUmVnRXhwKHJlZ2V4cClbTUFUQ0hdKFN0cmluZyhPKSk7XG4gIH0sICRtYXRjaF07XG59KTtcbiIsIi8vIEBAcmVwbGFjZSBsb2dpY1xucmVxdWlyZSgnLi9fZml4LXJlLXdrcycpKCdyZXBsYWNlJywgMiwgZnVuY3Rpb24gKGRlZmluZWQsIFJFUExBQ0UsICRyZXBsYWNlKSB7XG4gIC8vIDIxLjEuMy4xNCBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2Uoc2VhcmNoVmFsdWUsIHJlcGxhY2VWYWx1ZSlcbiAgcmV0dXJuIFtmdW5jdGlvbiByZXBsYWNlKHNlYXJjaFZhbHVlLCByZXBsYWNlVmFsdWUpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgdmFyIE8gPSBkZWZpbmVkKHRoaXMpO1xuICAgIHZhciBmbiA9IHNlYXJjaFZhbHVlID09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHNlYXJjaFZhbHVlW1JFUExBQ0VdO1xuICAgIHJldHVybiBmbiAhPT0gdW5kZWZpbmVkXG4gICAgICA/IGZuLmNhbGwoc2VhcmNoVmFsdWUsIE8sIHJlcGxhY2VWYWx1ZSlcbiAgICAgIDogJHJlcGxhY2UuY2FsbChTdHJpbmcoTyksIHNlYXJjaFZhbHVlLCByZXBsYWNlVmFsdWUpO1xuICB9LCAkcmVwbGFjZV07XG59KTtcbiIsIi8vIEBAc2VhcmNoIGxvZ2ljXG5yZXF1aXJlKCcuL19maXgtcmUtd2tzJykoJ3NlYXJjaCcsIDEsIGZ1bmN0aW9uIChkZWZpbmVkLCBTRUFSQ0gsICRzZWFyY2gpIHtcbiAgLy8gMjEuMS4zLjE1IFN0cmluZy5wcm90b3R5cGUuc2VhcmNoKHJlZ2V4cClcbiAgcmV0dXJuIFtmdW5jdGlvbiBzZWFyY2gocmVnZXhwKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIHZhciBPID0gZGVmaW5lZCh0aGlzKTtcbiAgICB2YXIgZm4gPSByZWdleHAgPT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogcmVnZXhwW1NFQVJDSF07XG4gICAgcmV0dXJuIGZuICE9PSB1bmRlZmluZWQgPyBmbi5jYWxsKHJlZ2V4cCwgTykgOiBuZXcgUmVnRXhwKHJlZ2V4cClbU0VBUkNIXShTdHJpbmcoTykpO1xuICB9LCAkc2VhcmNoXTtcbn0pO1xuIiwiLy8gQEBzcGxpdCBsb2dpY1xucmVxdWlyZSgnLi9fZml4LXJlLXdrcycpKCdzcGxpdCcsIDIsIGZ1bmN0aW9uIChkZWZpbmVkLCBTUExJVCwgJHNwbGl0KSB7XG4gICd1c2Ugc3RyaWN0JztcbiAgdmFyIGlzUmVnRXhwID0gcmVxdWlyZSgnLi9faXMtcmVnZXhwJyk7XG4gIHZhciBfc3BsaXQgPSAkc3BsaXQ7XG4gIHZhciAkcHVzaCA9IFtdLnB1c2g7XG4gIHZhciAkU1BMSVQgPSAnc3BsaXQnO1xuICB2YXIgTEVOR1RIID0gJ2xlbmd0aCc7XG4gIHZhciBMQVNUX0lOREVYID0gJ2xhc3RJbmRleCc7XG4gIGlmIChcbiAgICAnYWJiYydbJFNQTElUXSgvKGIpKi8pWzFdID09ICdjJyB8fFxuICAgICd0ZXN0J1skU1BMSVRdKC8oPzopLywgLTEpW0xFTkdUSF0gIT0gNCB8fFxuICAgICdhYidbJFNQTElUXSgvKD86YWIpKi8pW0xFTkdUSF0gIT0gMiB8fFxuICAgICcuJ1skU1BMSVRdKC8oLj8pKC4/KS8pW0xFTkdUSF0gIT0gNCB8fFxuICAgICcuJ1skU1BMSVRdKC8oKSgpLylbTEVOR1RIXSA+IDEgfHxcbiAgICAnJ1skU1BMSVRdKC8uPy8pW0xFTkdUSF1cbiAgKSB7XG4gICAgdmFyIE5QQ0cgPSAvKCk/Py8uZXhlYygnJylbMV0gPT09IHVuZGVmaW5lZDsgLy8gbm9ucGFydGljaXBhdGluZyBjYXB0dXJpbmcgZ3JvdXBcbiAgICAvLyBiYXNlZCBvbiBlczUtc2hpbSBpbXBsZW1lbnRhdGlvbiwgbmVlZCB0byByZXdvcmsgaXRcbiAgICAkc3BsaXQgPSBmdW5jdGlvbiAoc2VwYXJhdG9yLCBsaW1pdCkge1xuICAgICAgdmFyIHN0cmluZyA9IFN0cmluZyh0aGlzKTtcbiAgICAgIGlmIChzZXBhcmF0b3IgPT09IHVuZGVmaW5lZCAmJiBsaW1pdCA9PT0gMCkgcmV0dXJuIFtdO1xuICAgICAgLy8gSWYgYHNlcGFyYXRvcmAgaXMgbm90IGEgcmVnZXgsIHVzZSBuYXRpdmUgc3BsaXRcbiAgICAgIGlmICghaXNSZWdFeHAoc2VwYXJhdG9yKSkgcmV0dXJuIF9zcGxpdC5jYWxsKHN0cmluZywgc2VwYXJhdG9yLCBsaW1pdCk7XG4gICAgICB2YXIgb3V0cHV0ID0gW107XG4gICAgICB2YXIgZmxhZ3MgPSAoc2VwYXJhdG9yLmlnbm9yZUNhc2UgPyAnaScgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKHNlcGFyYXRvci5tdWx0aWxpbmUgPyAnbScgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKHNlcGFyYXRvci51bmljb2RlID8gJ3UnIDogJycpICtcbiAgICAgICAgICAgICAgICAgIChzZXBhcmF0b3Iuc3RpY2t5ID8gJ3knIDogJycpO1xuICAgICAgdmFyIGxhc3RMYXN0SW5kZXggPSAwO1xuICAgICAgdmFyIHNwbGl0TGltaXQgPSBsaW1pdCA9PT0gdW5kZWZpbmVkID8gNDI5NDk2NzI5NSA6IGxpbWl0ID4+PiAwO1xuICAgICAgLy8gTWFrZSBgZ2xvYmFsYCBhbmQgYXZvaWQgYGxhc3RJbmRleGAgaXNzdWVzIGJ5IHdvcmtpbmcgd2l0aCBhIGNvcHlcbiAgICAgIHZhciBzZXBhcmF0b3JDb3B5ID0gbmV3IFJlZ0V4cChzZXBhcmF0b3Iuc291cmNlLCBmbGFncyArICdnJyk7XG4gICAgICB2YXIgc2VwYXJhdG9yMiwgbWF0Y2gsIGxhc3RJbmRleCwgbGFzdExlbmd0aCwgaTtcbiAgICAgIC8vIERvZXNuJ3QgbmVlZCBmbGFncyBneSwgYnV0IHRoZXkgZG9uJ3QgaHVydFxuICAgICAgaWYgKCFOUENHKSBzZXBhcmF0b3IyID0gbmV3IFJlZ0V4cCgnXicgKyBzZXBhcmF0b3JDb3B5LnNvdXJjZSArICckKD8hXFxcXHMpJywgZmxhZ3MpO1xuICAgICAgd2hpbGUgKG1hdGNoID0gc2VwYXJhdG9yQ29weS5leGVjKHN0cmluZykpIHtcbiAgICAgICAgLy8gYHNlcGFyYXRvckNvcHkubGFzdEluZGV4YCBpcyBub3QgcmVsaWFibGUgY3Jvc3MtYnJvd3NlclxuICAgICAgICBsYXN0SW5kZXggPSBtYXRjaC5pbmRleCArIG1hdGNoWzBdW0xFTkdUSF07XG4gICAgICAgIGlmIChsYXN0SW5kZXggPiBsYXN0TGFzdEluZGV4KSB7XG4gICAgICAgICAgb3V0cHV0LnB1c2goc3RyaW5nLnNsaWNlKGxhc3RMYXN0SW5kZXgsIG1hdGNoLmluZGV4KSk7XG4gICAgICAgICAgLy8gRml4IGJyb3dzZXJzIHdob3NlIGBleGVjYCBtZXRob2RzIGRvbid0IGNvbnNpc3RlbnRseSByZXR1cm4gYHVuZGVmaW5lZGAgZm9yIE5QQ0dcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbG9vcC1mdW5jXG4gICAgICAgICAgaWYgKCFOUENHICYmIG1hdGNoW0xFTkdUSF0gPiAxKSBtYXRjaFswXS5yZXBsYWNlKHNlcGFyYXRvcjIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDE7IGkgPCBhcmd1bWVudHNbTEVOR1RIXSAtIDI7IGkrKykgaWYgKGFyZ3VtZW50c1tpXSA9PT0gdW5kZWZpbmVkKSBtYXRjaFtpXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAobWF0Y2hbTEVOR1RIXSA+IDEgJiYgbWF0Y2guaW5kZXggPCBzdHJpbmdbTEVOR1RIXSkgJHB1c2guYXBwbHkob3V0cHV0LCBtYXRjaC5zbGljZSgxKSk7XG4gICAgICAgICAgbGFzdExlbmd0aCA9IG1hdGNoWzBdW0xFTkdUSF07XG4gICAgICAgICAgbGFzdExhc3RJbmRleCA9IGxhc3RJbmRleDtcbiAgICAgICAgICBpZiAob3V0cHV0W0xFTkdUSF0gPj0gc3BsaXRMaW1pdCkgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlcGFyYXRvckNvcHlbTEFTVF9JTkRFWF0gPT09IG1hdGNoLmluZGV4KSBzZXBhcmF0b3JDb3B5W0xBU1RfSU5ERVhdKys7IC8vIEF2b2lkIGFuIGluZmluaXRlIGxvb3BcbiAgICAgIH1cbiAgICAgIGlmIChsYXN0TGFzdEluZGV4ID09PSBzdHJpbmdbTEVOR1RIXSkge1xuICAgICAgICBpZiAobGFzdExlbmd0aCB8fCAhc2VwYXJhdG9yQ29weS50ZXN0KCcnKSkgb3V0cHV0LnB1c2goJycpO1xuICAgICAgfSBlbHNlIG91dHB1dC5wdXNoKHN0cmluZy5zbGljZShsYXN0TGFzdEluZGV4KSk7XG4gICAgICByZXR1cm4gb3V0cHV0W0xFTkdUSF0gPiBzcGxpdExpbWl0ID8gb3V0cHV0LnNsaWNlKDAsIHNwbGl0TGltaXQpIDogb3V0cHV0O1xuICAgIH07XG4gIC8vIENoYWtyYSwgVjhcbiAgfSBlbHNlIGlmICgnMCdbJFNQTElUXSh1bmRlZmluZWQsIDApW0xFTkdUSF0pIHtcbiAgICAkc3BsaXQgPSBmdW5jdGlvbiAoc2VwYXJhdG9yLCBsaW1pdCkge1xuICAgICAgcmV0dXJuIHNlcGFyYXRvciA9PT0gdW5kZWZpbmVkICYmIGxpbWl0ID09PSAwID8gW10gOiBfc3BsaXQuY2FsbCh0aGlzLCBzZXBhcmF0b3IsIGxpbWl0KTtcbiAgICB9O1xuICB9XG4gIC8vIDIxLjEuMy4xNyBTdHJpbmcucHJvdG90eXBlLnNwbGl0KHNlcGFyYXRvciwgbGltaXQpXG4gIHJldHVybiBbZnVuY3Rpb24gc3BsaXQoc2VwYXJhdG9yLCBsaW1pdCkge1xuICAgIHZhciBPID0gZGVmaW5lZCh0aGlzKTtcbiAgICB2YXIgZm4gPSBzZXBhcmF0b3IgPT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogc2VwYXJhdG9yW1NQTElUXTtcbiAgICByZXR1cm4gZm4gIT09IHVuZGVmaW5lZCA/IGZuLmNhbGwoc2VwYXJhdG9yLCBPLCBsaW1pdCkgOiAkc3BsaXQuY2FsbChTdHJpbmcoTyksIHNlcGFyYXRvciwgbGltaXQpO1xuICB9LCAkc3BsaXRdO1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG5yZXF1aXJlKCcuL2VzNi5yZWdleHAuZmxhZ3MnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyICRmbGFncyA9IHJlcXVpcmUoJy4vX2ZsYWdzJyk7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpO1xudmFyIFRPX1NUUklORyA9ICd0b1N0cmluZyc7XG52YXIgJHRvU3RyaW5nID0gLy4vW1RPX1NUUklOR107XG5cbnZhciBkZWZpbmUgPSBmdW5jdGlvbiAoZm4pIHtcbiAgcmVxdWlyZSgnLi9fcmVkZWZpbmUnKShSZWdFeHAucHJvdG90eXBlLCBUT19TVFJJTkcsIGZuLCB0cnVlKTtcbn07XG5cbi8vIDIxLjIuNS4xNCBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nKClcbmlmIChyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHsgcmV0dXJuICR0b1N0cmluZy5jYWxsKHsgc291cmNlOiAnYScsIGZsYWdzOiAnYicgfSkgIT0gJy9hL2InOyB9KSkge1xuICBkZWZpbmUoZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgdmFyIFIgPSBhbk9iamVjdCh0aGlzKTtcbiAgICByZXR1cm4gJy8nLmNvbmNhdChSLnNvdXJjZSwgJy8nLFxuICAgICAgJ2ZsYWdzJyBpbiBSID8gUi5mbGFncyA6ICFERVNDUklQVE9SUyAmJiBSIGluc3RhbmNlb2YgUmVnRXhwID8gJGZsYWdzLmNhbGwoUikgOiB1bmRlZmluZWQpO1xuICB9KTtcbi8vIEZGNDQtIFJlZ0V4cCN0b1N0cmluZyBoYXMgYSB3cm9uZyBuYW1lXG59IGVsc2UgaWYgKCR0b1N0cmluZy5uYW1lICE9IFRPX1NUUklORykge1xuICBkZWZpbmUoZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuICR0b1N0cmluZy5jYWxsKHRoaXMpO1xuICB9KTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcbnZhciBzdHJvbmcgPSByZXF1aXJlKCcuL19jb2xsZWN0aW9uLXN0cm9uZycpO1xudmFyIHZhbGlkYXRlID0gcmVxdWlyZSgnLi9fdmFsaWRhdGUtY29sbGVjdGlvbicpO1xudmFyIFNFVCA9ICdTZXQnO1xuXG4vLyAyMy4yIFNldCBPYmplY3RzXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24nKShTRVQsIGZ1bmN0aW9uIChnZXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIFNldCgpIHsgcmV0dXJuIGdldCh0aGlzLCBhcmd1bWVudHMubGVuZ3RoID4gMCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7IH07XG59LCB7XG4gIC8vIDIzLjIuMy4xIFNldC5wcm90b3R5cGUuYWRkKHZhbHVlKVxuICBhZGQ6IGZ1bmN0aW9uIGFkZCh2YWx1ZSkge1xuICAgIHJldHVybiBzdHJvbmcuZGVmKHZhbGlkYXRlKHRoaXMsIFNFVCksIHZhbHVlID0gdmFsdWUgPT09IDAgPyAwIDogdmFsdWUsIHZhbHVlKTtcbiAgfVxufSwgc3Ryb25nKTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjIgU3RyaW5nLnByb3RvdHlwZS5hbmNob3IobmFtZSlcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ2FuY2hvcicsIGZ1bmN0aW9uIChjcmVhdGVIVE1MKSB7XG4gIHJldHVybiBmdW5jdGlvbiBhbmNob3IobmFtZSkge1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdhJywgJ25hbWUnLCBuYW1lKTtcbiAgfTtcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuMyBTdHJpbmcucHJvdG90eXBlLmJpZygpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdiaWcnLCBmdW5jdGlvbiAoY3JlYXRlSFRNTCkge1xuICByZXR1cm4gZnVuY3Rpb24gYmlnKCkge1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdiaWcnLCAnJywgJycpO1xuICB9O1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy40IFN0cmluZy5wcm90b3R5cGUuYmxpbmsoKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnYmxpbmsnLCBmdW5jdGlvbiAoY3JlYXRlSFRNTCkge1xuICByZXR1cm4gZnVuY3Rpb24gYmxpbmsoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ2JsaW5rJywgJycsICcnKTtcbiAgfTtcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuNSBTdHJpbmcucHJvdG90eXBlLmJvbGQoKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnYm9sZCcsIGZ1bmN0aW9uIChjcmVhdGVIVE1MKSB7XG4gIHJldHVybiBmdW5jdGlvbiBib2xkKCkge1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdiJywgJycsICcnKTtcbiAgfTtcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkYXQgPSByZXF1aXJlKCcuL19zdHJpbmctYXQnKShmYWxzZSk7XG4kZXhwb3J0KCRleHBvcnQuUCwgJ1N0cmluZycsIHtcbiAgLy8gMjEuMS4zLjMgU3RyaW5nLnByb3RvdHlwZS5jb2RlUG9pbnRBdChwb3MpXG4gIGNvZGVQb2ludEF0OiBmdW5jdGlvbiBjb2RlUG9pbnRBdChwb3MpIHtcbiAgICByZXR1cm4gJGF0KHRoaXMsIHBvcyk7XG4gIH1cbn0pO1xuIiwiLy8gMjEuMS4zLjYgU3RyaW5nLnByb3RvdHlwZS5lbmRzV2l0aChzZWFyY2hTdHJpbmcgWywgZW5kUG9zaXRpb25dKVxuJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIGNvbnRleHQgPSByZXF1aXJlKCcuL19zdHJpbmctY29udGV4dCcpO1xudmFyIEVORFNfV0lUSCA9ICdlbmRzV2l0aCc7XG52YXIgJGVuZHNXaXRoID0gJydbRU5EU19XSVRIXTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscy1pcy1yZWdleHAnKShFTkRTX1dJVEgpLCAnU3RyaW5nJywge1xuICBlbmRzV2l0aDogZnVuY3Rpb24gZW5kc1dpdGgoc2VhcmNoU3RyaW5nIC8qICwgZW5kUG9zaXRpb24gPSBAbGVuZ3RoICovKSB7XG4gICAgdmFyIHRoYXQgPSBjb250ZXh0KHRoaXMsIHNlYXJjaFN0cmluZywgRU5EU19XSVRIKTtcbiAgICB2YXIgZW5kUG9zaXRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgbGVuID0gdG9MZW5ndGgodGhhdC5sZW5ndGgpO1xuICAgIHZhciBlbmQgPSBlbmRQb3NpdGlvbiA9PT0gdW5kZWZpbmVkID8gbGVuIDogTWF0aC5taW4odG9MZW5ndGgoZW5kUG9zaXRpb24pLCBsZW4pO1xuICAgIHZhciBzZWFyY2ggPSBTdHJpbmcoc2VhcmNoU3RyaW5nKTtcbiAgICByZXR1cm4gJGVuZHNXaXRoXG4gICAgICA/ICRlbmRzV2l0aC5jYWxsKHRoYXQsIHNlYXJjaCwgZW5kKVxuICAgICAgOiB0aGF0LnNsaWNlKGVuZCAtIHNlYXJjaC5sZW5ndGgsIGVuZCkgPT09IHNlYXJjaDtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy42IFN0cmluZy5wcm90b3R5cGUuZml4ZWQoKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnZml4ZWQnLCBmdW5jdGlvbiAoY3JlYXRlSFRNTCkge1xuICByZXR1cm4gZnVuY3Rpb24gZml4ZWQoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ3R0JywgJycsICcnKTtcbiAgfTtcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuNyBTdHJpbmcucHJvdG90eXBlLmZvbnRjb2xvcihjb2xvcilcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ2ZvbnRjb2xvcicsIGZ1bmN0aW9uIChjcmVhdGVIVE1MKSB7XG4gIHJldHVybiBmdW5jdGlvbiBmb250Y29sb3IoY29sb3IpIHtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnZm9udCcsICdjb2xvcicsIGNvbG9yKTtcbiAgfTtcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuOCBTdHJpbmcucHJvdG90eXBlLmZvbnRzaXplKHNpemUpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdmb250c2l6ZScsIGZ1bmN0aW9uIChjcmVhdGVIVE1MKSB7XG4gIHJldHVybiBmdW5jdGlvbiBmb250c2l6ZShzaXplKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ2ZvbnQnLCAnc2l6ZScsIHNpemUpO1xuICB9O1xufSk7XG4iLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHRvQWJzb2x1dGVJbmRleCA9IHJlcXVpcmUoJy4vX3RvLWFic29sdXRlLWluZGV4Jyk7XG52YXIgZnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcbnZhciAkZnJvbUNvZGVQb2ludCA9IFN0cmluZy5mcm9tQ29kZVBvaW50O1xuXG4vLyBsZW5ndGggc2hvdWxkIGJlIDEsIG9sZCBGRiBwcm9ibGVtXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICghISRmcm9tQ29kZVBvaW50ICYmICRmcm9tQ29kZVBvaW50Lmxlbmd0aCAhPSAxKSwgJ1N0cmluZycsIHtcbiAgLy8gMjEuMS4yLjIgU3RyaW5nLmZyb21Db2RlUG9pbnQoLi4uY29kZVBvaW50cylcbiAgZnJvbUNvZGVQb2ludDogZnVuY3Rpb24gZnJvbUNvZGVQb2ludCh4KSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICB2YXIgcmVzID0gW107XG4gICAgdmFyIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgY29kZTtcbiAgICB3aGlsZSAoYUxlbiA+IGkpIHtcbiAgICAgIGNvZGUgPSArYXJndW1lbnRzW2krK107XG4gICAgICBpZiAodG9BYnNvbHV0ZUluZGV4KGNvZGUsIDB4MTBmZmZmKSAhPT0gY29kZSkgdGhyb3cgUmFuZ2VFcnJvcihjb2RlICsgJyBpcyBub3QgYSB2YWxpZCBjb2RlIHBvaW50Jyk7XG4gICAgICByZXMucHVzaChjb2RlIDwgMHgxMDAwMFxuICAgICAgICA/IGZyb21DaGFyQ29kZShjb2RlKVxuICAgICAgICA6IGZyb21DaGFyQ29kZSgoKGNvZGUgLT0gMHgxMDAwMCkgPj4gMTApICsgMHhkODAwLCBjb2RlICUgMHg0MDAgKyAweGRjMDApXG4gICAgICApO1xuICAgIH0gcmV0dXJuIHJlcy5qb2luKCcnKTtcbiAgfVxufSk7XG4iLCIvLyAyMS4xLjMuNyBTdHJpbmcucHJvdG90eXBlLmluY2x1ZGVzKHNlYXJjaFN0cmluZywgcG9zaXRpb24gPSAwKVxuJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBjb250ZXh0ID0gcmVxdWlyZSgnLi9fc3RyaW5nLWNvbnRleHQnKTtcbnZhciBJTkNMVURFUyA9ICdpbmNsdWRlcyc7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogcmVxdWlyZSgnLi9fZmFpbHMtaXMtcmVnZXhwJykoSU5DTFVERVMpLCAnU3RyaW5nJywge1xuICBpbmNsdWRlczogZnVuY3Rpb24gaW5jbHVkZXMoc2VhcmNoU3RyaW5nIC8qICwgcG9zaXRpb24gPSAwICovKSB7XG4gICAgcmV0dXJuICEhfmNvbnRleHQodGhpcywgc2VhcmNoU3RyaW5nLCBJTkNMVURFUylcbiAgICAgIC5pbmRleE9mKHNlYXJjaFN0cmluZywgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjkgU3RyaW5nLnByb3RvdHlwZS5pdGFsaWNzKClcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ2l0YWxpY3MnLCBmdW5jdGlvbiAoY3JlYXRlSFRNTCkge1xuICByZXR1cm4gZnVuY3Rpb24gaXRhbGljcygpIHtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnaScsICcnLCAnJyk7XG4gIH07XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkYXQgPSByZXF1aXJlKCcuL19zdHJpbmctYXQnKSh0cnVlKTtcblxuLy8gMjEuMS4zLjI3IFN0cmluZy5wcm90b3R5cGVbQEBpdGVyYXRvcl0oKVxucmVxdWlyZSgnLi9faXRlci1kZWZpbmUnKShTdHJpbmcsICdTdHJpbmcnLCBmdW5jdGlvbiAoaXRlcmF0ZWQpIHtcbiAgdGhpcy5fdCA9IFN0cmluZyhpdGVyYXRlZCk7IC8vIHRhcmdldFxuICB0aGlzLl9pID0gMDsgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxuLy8gMjEuMS41LjIuMSAlU3RyaW5nSXRlcmF0b3JQcm90b3R5cGUlLm5leHQoKVxufSwgZnVuY3Rpb24gKCkge1xuICB2YXIgTyA9IHRoaXMuX3Q7XG4gIHZhciBpbmRleCA9IHRoaXMuX2k7XG4gIHZhciBwb2ludDtcbiAgaWYgKGluZGV4ID49IE8ubGVuZ3RoKSByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIHBvaW50ID0gJGF0KE8sIGluZGV4KTtcbiAgdGhpcy5faSArPSBwb2ludC5sZW5ndGg7XG4gIHJldHVybiB7IHZhbHVlOiBwb2ludCwgZG9uZTogZmFsc2UgfTtcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuMTAgU3RyaW5nLnByb3RvdHlwZS5saW5rKHVybClcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ2xpbmsnLCBmdW5jdGlvbiAoY3JlYXRlSFRNTCkge1xuICByZXR1cm4gZnVuY3Rpb24gbGluayh1cmwpIHtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnYScsICdocmVmJywgdXJsKTtcbiAgfTtcbn0pO1xuIiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdTdHJpbmcnLCB7XG4gIC8vIDIxLjEuMi40IFN0cmluZy5yYXcoY2FsbFNpdGUsIC4uLnN1YnN0aXR1dGlvbnMpXG4gIHJhdzogZnVuY3Rpb24gcmF3KGNhbGxTaXRlKSB7XG4gICAgdmFyIHRwbCA9IHRvSU9iamVjdChjYWxsU2l0ZS5yYXcpO1xuICAgIHZhciBsZW4gPSB0b0xlbmd0aCh0cGwubGVuZ3RoKTtcbiAgICB2YXIgYUxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAobGVuID4gaSkge1xuICAgICAgcmVzLnB1c2goU3RyaW5nKHRwbFtpKytdKSk7XG4gICAgICBpZiAoaSA8IGFMZW4pIHJlcy5wdXNoKFN0cmluZyhhcmd1bWVudHNbaV0pKTtcbiAgICB9IHJldHVybiByZXMuam9pbignJyk7XG4gIH1cbn0pO1xuIiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAsICdTdHJpbmcnLCB7XG4gIC8vIDIxLjEuMy4xMyBTdHJpbmcucHJvdG90eXBlLnJlcGVhdChjb3VudClcbiAgcmVwZWF0OiByZXF1aXJlKCcuL19zdHJpbmctcmVwZWF0Jylcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuMTEgU3RyaW5nLnByb3RvdHlwZS5zbWFsbCgpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdzbWFsbCcsIGZ1bmN0aW9uIChjcmVhdGVIVE1MKSB7XG4gIHJldHVybiBmdW5jdGlvbiBzbWFsbCgpIHtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnc21hbGwnLCAnJywgJycpO1xuICB9O1xufSk7XG4iLCIvLyAyMS4xLjMuMTggU3RyaW5nLnByb3RvdHlwZS5zdGFydHNXaXRoKHNlYXJjaFN0cmluZyBbLCBwb3NpdGlvbiBdKVxuJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIGNvbnRleHQgPSByZXF1aXJlKCcuL19zdHJpbmctY29udGV4dCcpO1xudmFyIFNUQVJUU19XSVRIID0gJ3N0YXJ0c1dpdGgnO1xudmFyICRzdGFydHNXaXRoID0gJydbU1RBUlRTX1dJVEhdO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzLWlzLXJlZ2V4cCcpKFNUQVJUU19XSVRIKSwgJ1N0cmluZycsIHtcbiAgc3RhcnRzV2l0aDogZnVuY3Rpb24gc3RhcnRzV2l0aChzZWFyY2hTdHJpbmcgLyogLCBwb3NpdGlvbiA9IDAgKi8pIHtcbiAgICB2YXIgdGhhdCA9IGNvbnRleHQodGhpcywgc2VhcmNoU3RyaW5nLCBTVEFSVFNfV0lUSCk7XG4gICAgdmFyIGluZGV4ID0gdG9MZW5ndGgoTWF0aC5taW4oYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQsIHRoYXQubGVuZ3RoKSk7XG4gICAgdmFyIHNlYXJjaCA9IFN0cmluZyhzZWFyY2hTdHJpbmcpO1xuICAgIHJldHVybiAkc3RhcnRzV2l0aFxuICAgICAgPyAkc3RhcnRzV2l0aC5jYWxsKHRoYXQsIHNlYXJjaCwgaW5kZXgpXG4gICAgICA6IHRoYXQuc2xpY2UoaW5kZXgsIGluZGV4ICsgc2VhcmNoLmxlbmd0aCkgPT09IHNlYXJjaDtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy4xMiBTdHJpbmcucHJvdG90eXBlLnN0cmlrZSgpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdzdHJpa2UnLCBmdW5jdGlvbiAoY3JlYXRlSFRNTCkge1xuICByZXR1cm4gZnVuY3Rpb24gc3RyaWtlKCkge1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdzdHJpa2UnLCAnJywgJycpO1xuICB9O1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy4xMyBTdHJpbmcucHJvdG90eXBlLnN1YigpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdzdWInLCBmdW5jdGlvbiAoY3JlYXRlSFRNTCkge1xuICByZXR1cm4gZnVuY3Rpb24gc3ViKCkge1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdzdWInLCAnJywgJycpO1xuICB9O1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy4xNCBTdHJpbmcucHJvdG90eXBlLnN1cCgpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdzdXAnLCBmdW5jdGlvbiAoY3JlYXRlSFRNTCkge1xuICByZXR1cm4gZnVuY3Rpb24gc3VwKCkge1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdzdXAnLCAnJywgJycpO1xuICB9O1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG4vLyAyMS4xLjMuMjUgU3RyaW5nLnByb3RvdHlwZS50cmltKClcbnJlcXVpcmUoJy4vX3N0cmluZy10cmltJykoJ3RyaW0nLCBmdW5jdGlvbiAoJHRyaW0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHRyaW0oKSB7XG4gICAgcmV0dXJuICR0cmltKHRoaXMsIDMpO1xuICB9O1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG4vLyBFQ01BU2NyaXB0IDYgc3ltYm9scyBzaGltXG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJyk7XG52YXIgTUVUQSA9IHJlcXVpcmUoJy4vX21ldGEnKS5LRVk7XG52YXIgJGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbnZhciBzaGFyZWQgPSByZXF1aXJlKCcuL19zaGFyZWQnKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJyk7XG52YXIgdWlkID0gcmVxdWlyZSgnLi9fdWlkJyk7XG52YXIgd2tzID0gcmVxdWlyZSgnLi9fd2tzJyk7XG52YXIgd2tzRXh0ID0gcmVxdWlyZSgnLi9fd2tzLWV4dCcpO1xudmFyIHdrc0RlZmluZSA9IHJlcXVpcmUoJy4vX3drcy1kZWZpbmUnKTtcbnZhciBlbnVtS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0ta2V5cycpO1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuL19pcy1hcnJheScpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7XG52YXIgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbnZhciBfY3JlYXRlID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpO1xudmFyIGdPUE5FeHQgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbi1leHQnKTtcbnZhciAkR09QRCA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJyk7XG52YXIgJERQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG52YXIgJGtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xudmFyIGdPUEQgPSAkR09QRC5mO1xudmFyIGRQID0gJERQLmY7XG52YXIgZ09QTiA9IGdPUE5FeHQuZjtcbnZhciAkU3ltYm9sID0gZ2xvYmFsLlN5bWJvbDtcbnZhciAkSlNPTiA9IGdsb2JhbC5KU09OO1xudmFyIF9zdHJpbmdpZnkgPSAkSlNPTiAmJiAkSlNPTi5zdHJpbmdpZnk7XG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG52YXIgSElEREVOID0gd2tzKCdfaGlkZGVuJyk7XG52YXIgVE9fUFJJTUlUSVZFID0gd2tzKCd0b1ByaW1pdGl2ZScpO1xudmFyIGlzRW51bSA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIFN5bWJvbFJlZ2lzdHJ5ID0gc2hhcmVkKCdzeW1ib2wtcmVnaXN0cnknKTtcbnZhciBBbGxTeW1ib2xzID0gc2hhcmVkKCdzeW1ib2xzJyk7XG52YXIgT1BTeW1ib2xzID0gc2hhcmVkKCdvcC1zeW1ib2xzJyk7XG52YXIgT2JqZWN0UHJvdG8gPSBPYmplY3RbUFJPVE9UWVBFXTtcbnZhciBVU0VfTkFUSVZFID0gdHlwZW9mICRTeW1ib2wgPT0gJ2Z1bmN0aW9uJztcbnZhciBRT2JqZWN0ID0gZ2xvYmFsLlFPYmplY3Q7XG4vLyBEb24ndCB1c2Ugc2V0dGVycyBpbiBRdCBTY3JpcHQsIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy8xNzNcbnZhciBzZXR0ZXIgPSAhUU9iamVjdCB8fCAhUU9iamVjdFtQUk9UT1RZUEVdIHx8ICFRT2JqZWN0W1BST1RPVFlQRV0uZmluZENoaWxkO1xuXG4vLyBmYWxsYmFjayBmb3Igb2xkIEFuZHJvaWQsIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD02ODdcbnZhciBzZXRTeW1ib2xEZXNjID0gREVTQ1JJUFRPUlMgJiYgJGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIF9jcmVhdGUoZFAoe30sICdhJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZFAodGhpcywgJ2EnLCB7IHZhbHVlOiA3IH0pLmE7IH1cbiAgfSkpLmEgIT0gNztcbn0pID8gZnVuY3Rpb24gKGl0LCBrZXksIEQpIHtcbiAgdmFyIHByb3RvRGVzYyA9IGdPUEQoT2JqZWN0UHJvdG8sIGtleSk7XG4gIGlmIChwcm90b0Rlc2MpIGRlbGV0ZSBPYmplY3RQcm90b1trZXldO1xuICBkUChpdCwga2V5LCBEKTtcbiAgaWYgKHByb3RvRGVzYyAmJiBpdCAhPT0gT2JqZWN0UHJvdG8pIGRQKE9iamVjdFByb3RvLCBrZXksIHByb3RvRGVzYyk7XG59IDogZFA7XG5cbnZhciB3cmFwID0gZnVuY3Rpb24gKHRhZykge1xuICB2YXIgc3ltID0gQWxsU3ltYm9sc1t0YWddID0gX2NyZWF0ZSgkU3ltYm9sW1BST1RPVFlQRV0pO1xuICBzeW0uX2sgPSB0YWc7XG4gIHJldHVybiBzeW07XG59O1xuXG52YXIgaXNTeW1ib2wgPSBVU0VfTkFUSVZFICYmIHR5cGVvZiAkU3ltYm9sLml0ZXJhdG9yID09ICdzeW1ib2wnID8gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0eXBlb2YgaXQgPT0gJ3N5bWJvbCc7XG59IDogZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCBpbnN0YW5jZW9mICRTeW1ib2w7XG59O1xuXG52YXIgJGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoaXQsIGtleSwgRCkge1xuICBpZiAoaXQgPT09IE9iamVjdFByb3RvKSAkZGVmaW5lUHJvcGVydHkoT1BTeW1ib2xzLCBrZXksIEQpO1xuICBhbk9iamVjdChpdCk7XG4gIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSk7XG4gIGFuT2JqZWN0KEQpO1xuICBpZiAoaGFzKEFsbFN5bWJvbHMsIGtleSkpIHtcbiAgICBpZiAoIUQuZW51bWVyYWJsZSkge1xuICAgICAgaWYgKCFoYXMoaXQsIEhJRERFTikpIGRQKGl0LCBISURERU4sIGNyZWF0ZURlc2MoMSwge30pKTtcbiAgICAgIGl0W0hJRERFTl1ba2V5XSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChoYXMoaXQsIEhJRERFTikgJiYgaXRbSElEREVOXVtrZXldKSBpdFtISURERU5dW2tleV0gPSBmYWxzZTtcbiAgICAgIEQgPSBfY3JlYXRlKEQsIHsgZW51bWVyYWJsZTogY3JlYXRlRGVzYygwLCBmYWxzZSkgfSk7XG4gICAgfSByZXR1cm4gc2V0U3ltYm9sRGVzYyhpdCwga2V5LCBEKTtcbiAgfSByZXR1cm4gZFAoaXQsIGtleSwgRCk7XG59O1xudmFyICRkZWZpbmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhpdCwgUCkge1xuICBhbk9iamVjdChpdCk7XG4gIHZhciBrZXlzID0gZW51bUtleXMoUCA9IHRvSU9iamVjdChQKSk7XG4gIHZhciBpID0gMDtcbiAgdmFyIGwgPSBrZXlzLmxlbmd0aDtcbiAgdmFyIGtleTtcbiAgd2hpbGUgKGwgPiBpKSAkZGVmaW5lUHJvcGVydHkoaXQsIGtleSA9IGtleXNbaSsrXSwgUFtrZXldKTtcbiAgcmV0dXJuIGl0O1xufTtcbnZhciAkY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKGl0LCBQKSB7XG4gIHJldHVybiBQID09PSB1bmRlZmluZWQgPyBfY3JlYXRlKGl0KSA6ICRkZWZpbmVQcm9wZXJ0aWVzKF9jcmVhdGUoaXQpLCBQKTtcbn07XG52YXIgJHByb3BlcnR5SXNFbnVtZXJhYmxlID0gZnVuY3Rpb24gcHJvcGVydHlJc0VudW1lcmFibGUoa2V5KSB7XG4gIHZhciBFID0gaXNFbnVtLmNhbGwodGhpcywga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKSk7XG4gIGlmICh0aGlzID09PSBPYmplY3RQcm90byAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhaGFzKE9QU3ltYm9scywga2V5KSkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gRSB8fCAhaGFzKHRoaXMsIGtleSkgfHwgIWhhcyhBbGxTeW1ib2xzLCBrZXkpIHx8IGhhcyh0aGlzLCBISURERU4pICYmIHRoaXNbSElEREVOXVtrZXldID8gRSA6IHRydWU7XG59O1xudmFyICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSkge1xuICBpdCA9IHRvSU9iamVjdChpdCk7XG4gIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSk7XG4gIGlmIChpdCA9PT0gT2JqZWN0UHJvdG8gJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIWhhcyhPUFN5bWJvbHMsIGtleSkpIHJldHVybjtcbiAgdmFyIEQgPSBnT1BEKGl0LCBrZXkpO1xuICBpZiAoRCAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhKGhhcyhpdCwgSElEREVOKSAmJiBpdFtISURERU5dW2tleV0pKSBELmVudW1lcmFibGUgPSB0cnVlO1xuICByZXR1cm4gRDtcbn07XG52YXIgJGdldE93blByb3BlcnR5TmFtZXMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KSB7XG4gIHZhciBuYW1lcyA9IGdPUE4odG9JT2JqZWN0KGl0KSk7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGkgPSAwO1xuICB2YXIga2V5O1xuICB3aGlsZSAobmFtZXMubGVuZ3RoID4gaSkge1xuICAgIGlmICghaGFzKEFsbFN5bWJvbHMsIGtleSA9IG5hbWVzW2krK10pICYmIGtleSAhPSBISURERU4gJiYga2V5ICE9IE1FVEEpIHJlc3VsdC5wdXNoKGtleSk7XG4gIH0gcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgJGdldE93blByb3BlcnR5U3ltYm9scyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5U3ltYm9scyhpdCkge1xuICB2YXIgSVNfT1AgPSBpdCA9PT0gT2JqZWN0UHJvdG87XG4gIHZhciBuYW1lcyA9IGdPUE4oSVNfT1AgPyBPUFN5bWJvbHMgOiB0b0lPYmplY3QoaXQpKTtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIgaSA9IDA7XG4gIHZhciBrZXk7XG4gIHdoaWxlIChuYW1lcy5sZW5ndGggPiBpKSB7XG4gICAgaWYgKGhhcyhBbGxTeW1ib2xzLCBrZXkgPSBuYW1lc1tpKytdKSAmJiAoSVNfT1AgPyBoYXMoT2JqZWN0UHJvdG8sIGtleSkgOiB0cnVlKSkgcmVzdWx0LnB1c2goQWxsU3ltYm9sc1trZXldKTtcbiAgfSByZXR1cm4gcmVzdWx0O1xufTtcblxuLy8gMTkuNC4xLjEgU3ltYm9sKFtkZXNjcmlwdGlvbl0pXG5pZiAoIVVTRV9OQVRJVkUpIHtcbiAgJFN5bWJvbCA9IGZ1bmN0aW9uIFN5bWJvbCgpIHtcbiAgICBpZiAodGhpcyBpbnN0YW5jZW9mICRTeW1ib2wpIHRocm93IFR5cGVFcnJvcignU3ltYm9sIGlzIG5vdCBhIGNvbnN0cnVjdG9yIScpO1xuICAgIHZhciB0YWcgPSB1aWQoYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpO1xuICAgIHZhciAkc2V0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBpZiAodGhpcyA9PT0gT2JqZWN0UHJvdG8pICRzZXQuY2FsbChPUFN5bWJvbHMsIHZhbHVlKTtcbiAgICAgIGlmIChoYXModGhpcywgSElEREVOKSAmJiBoYXModGhpc1tISURERU5dLCB0YWcpKSB0aGlzW0hJRERFTl1bdGFnXSA9IGZhbHNlO1xuICAgICAgc2V0U3ltYm9sRGVzYyh0aGlzLCB0YWcsIGNyZWF0ZURlc2MoMSwgdmFsdWUpKTtcbiAgICB9O1xuICAgIGlmIChERVNDUklQVE9SUyAmJiBzZXR0ZXIpIHNldFN5bWJvbERlc2MoT2JqZWN0UHJvdG8sIHRhZywgeyBjb25maWd1cmFibGU6IHRydWUsIHNldDogJHNldCB9KTtcbiAgICByZXR1cm4gd3JhcCh0YWcpO1xuICB9O1xuICByZWRlZmluZSgkU3ltYm9sW1BST1RPVFlQRV0sICd0b1N0cmluZycsIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl9rO1xuICB9KTtcblxuICAkR09QRC5mID0gJGdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbiAgJERQLmYgPSAkZGVmaW5lUHJvcGVydHk7XG4gIHJlcXVpcmUoJy4vX29iamVjdC1nb3BuJykuZiA9IGdPUE5FeHQuZiA9ICRnZXRPd25Qcm9wZXJ0eU5hbWVzO1xuICByZXF1aXJlKCcuL19vYmplY3QtcGllJykuZiA9ICRwcm9wZXJ0eUlzRW51bWVyYWJsZTtcbiAgcmVxdWlyZSgnLi9fb2JqZWN0LWdvcHMnKS5mID0gJGdldE93blByb3BlcnR5U3ltYm9scztcblxuICBpZiAoREVTQ1JJUFRPUlMgJiYgIXJlcXVpcmUoJy4vX2xpYnJhcnknKSkge1xuICAgIHJlZGVmaW5lKE9iamVjdFByb3RvLCAncHJvcGVydHlJc0VudW1lcmFibGUnLCAkcHJvcGVydHlJc0VudW1lcmFibGUsIHRydWUpO1xuICB9XG5cbiAgd2tzRXh0LmYgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHJldHVybiB3cmFwKHdrcyhuYW1lKSk7XG4gIH07XG59XG5cbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsIHsgU3ltYm9sOiAkU3ltYm9sIH0pO1xuXG5mb3IgKHZhciBlczZTeW1ib2xzID0gKFxuICAvLyAxOS40LjIuMiwgMTkuNC4yLjMsIDE5LjQuMi40LCAxOS40LjIuNiwgMTkuNC4yLjgsIDE5LjQuMi45LCAxOS40LjIuMTAsIDE5LjQuMi4xMSwgMTkuNC4yLjEyLCAxOS40LjIuMTMsIDE5LjQuMi4xNFxuICAnaGFzSW5zdGFuY2UsaXNDb25jYXRTcHJlYWRhYmxlLGl0ZXJhdG9yLG1hdGNoLHJlcGxhY2Usc2VhcmNoLHNwZWNpZXMsc3BsaXQsdG9QcmltaXRpdmUsdG9TdHJpbmdUYWcsdW5zY29wYWJsZXMnXG4pLnNwbGl0KCcsJyksIGogPSAwOyBlczZTeW1ib2xzLmxlbmd0aCA+IGo7KXdrcyhlczZTeW1ib2xzW2orK10pO1xuXG5mb3IgKHZhciB3ZWxsS25vd25TeW1ib2xzID0gJGtleXMod2tzLnN0b3JlKSwgayA9IDA7IHdlbGxLbm93blN5bWJvbHMubGVuZ3RoID4gazspIHdrc0RlZmluZSh3ZWxsS25vd25TeW1ib2xzW2srK10pO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCAnU3ltYm9sJywge1xuICAvLyAxOS40LjIuMSBTeW1ib2wuZm9yKGtleSlcbiAgJ2Zvcic6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gaGFzKFN5bWJvbFJlZ2lzdHJ5LCBrZXkgKz0gJycpXG4gICAgICA/IFN5bWJvbFJlZ2lzdHJ5W2tleV1cbiAgICAgIDogU3ltYm9sUmVnaXN0cnlba2V5XSA9ICRTeW1ib2woa2V5KTtcbiAgfSxcbiAgLy8gMTkuNC4yLjUgU3ltYm9sLmtleUZvcihzeW0pXG4gIGtleUZvcjogZnVuY3Rpb24ga2V5Rm9yKHN5bSkge1xuICAgIGlmICghaXNTeW1ib2woc3ltKSkgdGhyb3cgVHlwZUVycm9yKHN5bSArICcgaXMgbm90IGEgc3ltYm9sIScpO1xuICAgIGZvciAodmFyIGtleSBpbiBTeW1ib2xSZWdpc3RyeSkgaWYgKFN5bWJvbFJlZ2lzdHJ5W2tleV0gPT09IHN5bSkgcmV0dXJuIGtleTtcbiAgfSxcbiAgdXNlU2V0dGVyOiBmdW5jdGlvbiAoKSB7IHNldHRlciA9IHRydWU7IH0sXG4gIHVzZVNpbXBsZTogZnVuY3Rpb24gKCkgeyBzZXR0ZXIgPSBmYWxzZTsgfVxufSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsICdPYmplY3QnLCB7XG4gIC8vIDE5LjEuMi4yIE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcbiAgY3JlYXRlOiAkY3JlYXRlLFxuICAvLyAxOS4xLjIuNCBPYmplY3QuZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcylcbiAgZGVmaW5lUHJvcGVydHk6ICRkZWZpbmVQcm9wZXJ0eSxcbiAgLy8gMTkuMS4yLjMgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcylcbiAgZGVmaW5lUHJvcGVydGllczogJGRlZmluZVByb3BlcnRpZXMsXG4gIC8vIDE5LjEuMi42IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUClcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLFxuICAvLyAxOS4xLjIuNyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPKVxuICBnZXRPd25Qcm9wZXJ0eU5hbWVzOiAkZ2V0T3duUHJvcGVydHlOYW1lcyxcbiAgLy8gMTkuMS4yLjggT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhPKVxuICBnZXRPd25Qcm9wZXJ0eVN5bWJvbHM6ICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHNcbn0pO1xuXG4vLyAyNC4zLjIgSlNPTi5zdHJpbmdpZnkodmFsdWUgWywgcmVwbGFjZXIgWywgc3BhY2VdXSlcbiRKU09OICYmICRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKCFVU0VfTkFUSVZFIHx8ICRmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHZhciBTID0gJFN5bWJvbCgpO1xuICAvLyBNUyBFZGdlIGNvbnZlcnRzIHN5bWJvbCB2YWx1ZXMgdG8gSlNPTiBhcyB7fVxuICAvLyBXZWJLaXQgY29udmVydHMgc3ltYm9sIHZhbHVlcyB0byBKU09OIGFzIG51bGxcbiAgLy8gVjggdGhyb3dzIG9uIGJveGVkIHN5bWJvbHNcbiAgcmV0dXJuIF9zdHJpbmdpZnkoW1NdKSAhPSAnW251bGxdJyB8fCBfc3RyaW5naWZ5KHsgYTogUyB9KSAhPSAne30nIHx8IF9zdHJpbmdpZnkoT2JqZWN0KFMpKSAhPSAne30nO1xufSkpLCAnSlNPTicsIHtcbiAgc3RyaW5naWZ5OiBmdW5jdGlvbiBzdHJpbmdpZnkoaXQpIHtcbiAgICBpZiAoaXQgPT09IHVuZGVmaW5lZCB8fCBpc1N5bWJvbChpdCkpIHJldHVybjsgLy8gSUU4IHJldHVybnMgc3RyaW5nIG9uIHVuZGVmaW5lZFxuICAgIHZhciBhcmdzID0gW2l0XTtcbiAgICB2YXIgaSA9IDE7XG4gICAgdmFyIHJlcGxhY2VyLCAkcmVwbGFjZXI7XG4gICAgd2hpbGUgKGFyZ3VtZW50cy5sZW5ndGggPiBpKSBhcmdzLnB1c2goYXJndW1lbnRzW2krK10pO1xuICAgIHJlcGxhY2VyID0gYXJnc1sxXTtcbiAgICBpZiAodHlwZW9mIHJlcGxhY2VyID09ICdmdW5jdGlvbicpICRyZXBsYWNlciA9IHJlcGxhY2VyO1xuICAgIGlmICgkcmVwbGFjZXIgfHwgIWlzQXJyYXkocmVwbGFjZXIpKSByZXBsYWNlciA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICBpZiAoJHJlcGxhY2VyKSB2YWx1ZSA9ICRyZXBsYWNlci5jYWxsKHRoaXMsIGtleSwgdmFsdWUpO1xuICAgICAgaWYgKCFpc1N5bWJvbCh2YWx1ZSkpIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIGFyZ3NbMV0gPSByZXBsYWNlcjtcbiAgICByZXR1cm4gX3N0cmluZ2lmeS5hcHBseSgkSlNPTiwgYXJncyk7XG4gIH1cbn0pO1xuXG4vLyAxOS40LjMuNCBTeW1ib2wucHJvdG90eXBlW0BAdG9QcmltaXRpdmVdKGhpbnQpXG4kU3ltYm9sW1BST1RPVFlQRV1bVE9fUFJJTUlUSVZFXSB8fCByZXF1aXJlKCcuL19oaWRlJykoJFN5bWJvbFtQUk9UT1RZUEVdLCBUT19QUklNSVRJVkUsICRTeW1ib2xbUFJPVE9UWVBFXS52YWx1ZU9mKTtcbi8vIDE5LjQuMy41IFN5bWJvbC5wcm90b3R5cGVbQEB0b1N0cmluZ1RhZ11cbnNldFRvU3RyaW5nVGFnKCRTeW1ib2wsICdTeW1ib2wnKTtcbi8vIDIwLjIuMS45IE1hdGhbQEB0b1N0cmluZ1RhZ11cbnNldFRvU3RyaW5nVGFnKE1hdGgsICdNYXRoJywgdHJ1ZSk7XG4vLyAyNC4zLjMgSlNPTltAQHRvU3RyaW5nVGFnXVxuc2V0VG9TdHJpbmdUYWcoZ2xvYmFsLkpTT04sICdKU09OJywgdHJ1ZSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICR0eXBlZCA9IHJlcXVpcmUoJy4vX3R5cGVkJyk7XG52YXIgYnVmZmVyID0gcmVxdWlyZSgnLi9fdHlwZWQtYnVmZmVyJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciB0b0Fic29sdXRlSW5kZXggPSByZXF1aXJlKCcuL190by1hYnNvbHV0ZS1pbmRleCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBBcnJheUJ1ZmZlciA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLkFycmF5QnVmZmVyO1xudmFyIHNwZWNpZXNDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4vX3NwZWNpZXMtY29uc3RydWN0b3InKTtcbnZhciAkQXJyYXlCdWZmZXIgPSBidWZmZXIuQXJyYXlCdWZmZXI7XG52YXIgJERhdGFWaWV3ID0gYnVmZmVyLkRhdGFWaWV3O1xudmFyICRpc1ZpZXcgPSAkdHlwZWQuQUJWICYmIEFycmF5QnVmZmVyLmlzVmlldztcbnZhciAkc2xpY2UgPSAkQXJyYXlCdWZmZXIucHJvdG90eXBlLnNsaWNlO1xudmFyIFZJRVcgPSAkdHlwZWQuVklFVztcbnZhciBBUlJBWV9CVUZGRVIgPSAnQXJyYXlCdWZmZXInO1xuXG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuVyArICRleHBvcnQuRiAqIChBcnJheUJ1ZmZlciAhPT0gJEFycmF5QnVmZmVyKSwgeyBBcnJheUJ1ZmZlcjogJEFycmF5QnVmZmVyIH0pO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICEkdHlwZWQuQ09OU1RSLCBBUlJBWV9CVUZGRVIsIHtcbiAgLy8gMjQuMS4zLjEgQXJyYXlCdWZmZXIuaXNWaWV3KGFyZylcbiAgaXNWaWV3OiBmdW5jdGlvbiBpc1ZpZXcoaXQpIHtcbiAgICByZXR1cm4gJGlzVmlldyAmJiAkaXNWaWV3KGl0KSB8fCBpc09iamVjdChpdCkgJiYgVklFVyBpbiBpdDtcbiAgfVxufSk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5VICsgJGV4cG9ydC5GICogcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAhbmV3ICRBcnJheUJ1ZmZlcigyKS5zbGljZSgxLCB1bmRlZmluZWQpLmJ5dGVMZW5ndGg7XG59KSwgQVJSQVlfQlVGRkVSLCB7XG4gIC8vIDI0LjEuNC4zIEFycmF5QnVmZmVyLnByb3RvdHlwZS5zbGljZShzdGFydCwgZW5kKVxuICBzbGljZTogZnVuY3Rpb24gc2xpY2Uoc3RhcnQsIGVuZCkge1xuICAgIGlmICgkc2xpY2UgIT09IHVuZGVmaW5lZCAmJiBlbmQgPT09IHVuZGVmaW5lZCkgcmV0dXJuICRzbGljZS5jYWxsKGFuT2JqZWN0KHRoaXMpLCBzdGFydCk7IC8vIEZGIGZpeFxuICAgIHZhciBsZW4gPSBhbk9iamVjdCh0aGlzKS5ieXRlTGVuZ3RoO1xuICAgIHZhciBmaXJzdCA9IHRvQWJzb2x1dGVJbmRleChzdGFydCwgbGVuKTtcbiAgICB2YXIgZmluYWwgPSB0b0Fic29sdXRlSW5kZXgoZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiBlbmQsIGxlbik7XG4gICAgdmFyIHJlc3VsdCA9IG5ldyAoc3BlY2llc0NvbnN0cnVjdG9yKHRoaXMsICRBcnJheUJ1ZmZlcikpKHRvTGVuZ3RoKGZpbmFsIC0gZmlyc3QpKTtcbiAgICB2YXIgdmlld1MgPSBuZXcgJERhdGFWaWV3KHRoaXMpO1xuICAgIHZhciB2aWV3VCA9IG5ldyAkRGF0YVZpZXcocmVzdWx0KTtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHdoaWxlIChmaXJzdCA8IGZpbmFsKSB7XG4gICAgICB2aWV3VC5zZXRVaW50OChpbmRleCsrLCB2aWV3Uy5nZXRVaW50OChmaXJzdCsrKSk7XG4gICAgfSByZXR1cm4gcmVzdWx0O1xuICB9XG59KTtcblxucmVxdWlyZSgnLi9fc2V0LXNwZWNpZXMnKShBUlJBWV9CVUZGRVIpO1xuIiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX3R5cGVkJykuQUJWLCB7XG4gIERhdGFWaWV3OiByZXF1aXJlKCcuL190eXBlZC1idWZmZXInKS5EYXRhVmlld1xufSk7XG4iLCJyZXF1aXJlKCcuL190eXBlZC1hcnJheScpKCdGbG9hdDMyJywgNCwgZnVuY3Rpb24gKGluaXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIEZsb2F0MzJBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7XG4iLCJyZXF1aXJlKCcuL190eXBlZC1hcnJheScpKCdGbG9hdDY0JywgOCwgZnVuY3Rpb24gKGluaXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIEZsb2F0NjRBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7XG4iLCJyZXF1aXJlKCcuL190eXBlZC1hcnJheScpKCdJbnQxNicsIDIsIGZ1bmN0aW9uIChpbml0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBJbnQxNkFycmF5KGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59KTtcbiIsInJlcXVpcmUoJy4vX3R5cGVkLWFycmF5JykoJ0ludDMyJywgNCwgZnVuY3Rpb24gKGluaXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIEludDMyQXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcbn0pO1xuIiwicmVxdWlyZSgnLi9fdHlwZWQtYXJyYXknKSgnSW50OCcsIDEsIGZ1bmN0aW9uIChpbml0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBJbnQ4QXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcbn0pO1xuIiwicmVxdWlyZSgnLi9fdHlwZWQtYXJyYXknKSgnVWludDE2JywgMiwgZnVuY3Rpb24gKGluaXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIFVpbnQxNkFycmF5KGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59KTtcbiIsInJlcXVpcmUoJy4vX3R5cGVkLWFycmF5JykoJ1VpbnQzMicsIDQsIGZ1bmN0aW9uIChpbml0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBVaW50MzJBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7XG4iLCJyZXF1aXJlKCcuL190eXBlZC1hcnJheScpKCdVaW50OCcsIDEsIGZ1bmN0aW9uIChpbml0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBVaW50OEFycmF5KGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59KTtcbiIsInJlcXVpcmUoJy4vX3R5cGVkLWFycmF5JykoJ1VpbnQ4JywgMSwgZnVuY3Rpb24gKGluaXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIFVpbnQ4Q2xhbXBlZEFycmF5KGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59LCB0cnVlKTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBlYWNoID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpKDApO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcbnZhciBtZXRhID0gcmVxdWlyZSgnLi9fbWV0YScpO1xudmFyIGFzc2lnbiA9IHJlcXVpcmUoJy4vX29iamVjdC1hc3NpZ24nKTtcbnZhciB3ZWFrID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbi13ZWFrJyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG52YXIgdmFsaWRhdGUgPSByZXF1aXJlKCcuL192YWxpZGF0ZS1jb2xsZWN0aW9uJyk7XG52YXIgV0VBS19NQVAgPSAnV2Vha01hcCc7XG52YXIgZ2V0V2VhayA9IG1ldGEuZ2V0V2VhaztcbnZhciBpc0V4dGVuc2libGUgPSBPYmplY3QuaXNFeHRlbnNpYmxlO1xudmFyIHVuY2F1Z2h0RnJvemVuU3RvcmUgPSB3ZWFrLnVmc3RvcmU7XG52YXIgdG1wID0ge307XG52YXIgSW50ZXJuYWxNYXA7XG5cbnZhciB3cmFwcGVyID0gZnVuY3Rpb24gKGdldCkge1xuICByZXR1cm4gZnVuY3Rpb24gV2Vha01hcCgpIHtcbiAgICByZXR1cm4gZ2V0KHRoaXMsIGFyZ3VtZW50cy5sZW5ndGggPiAwID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTtcbiAgfTtcbn07XG5cbnZhciBtZXRob2RzID0ge1xuICAvLyAyMy4zLjMuMyBXZWFrTWFwLnByb3RvdHlwZS5nZXQoa2V5KVxuICBnZXQ6IGZ1bmN0aW9uIGdldChrZXkpIHtcbiAgICBpZiAoaXNPYmplY3Qoa2V5KSkge1xuICAgICAgdmFyIGRhdGEgPSBnZXRXZWFrKGtleSk7XG4gICAgICBpZiAoZGF0YSA9PT0gdHJ1ZSkgcmV0dXJuIHVuY2F1Z2h0RnJvemVuU3RvcmUodmFsaWRhdGUodGhpcywgV0VBS19NQVApKS5nZXQoa2V5KTtcbiAgICAgIHJldHVybiBkYXRhID8gZGF0YVt0aGlzLl9pXSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0sXG4gIC8vIDIzLjMuMy41IFdlYWtNYXAucHJvdG90eXBlLnNldChrZXksIHZhbHVlKVxuICBzZXQ6IGZ1bmN0aW9uIHNldChrZXksIHZhbHVlKSB7XG4gICAgcmV0dXJuIHdlYWsuZGVmKHZhbGlkYXRlKHRoaXMsIFdFQUtfTUFQKSwga2V5LCB2YWx1ZSk7XG4gIH1cbn07XG5cbi8vIDIzLjMgV2Vha01hcCBPYmplY3RzXG52YXIgJFdlYWtNYXAgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24nKShXRUFLX01BUCwgd3JhcHBlciwgbWV0aG9kcywgd2VhaywgdHJ1ZSwgdHJ1ZSk7XG5cbi8vIElFMTEgV2Vha01hcCBmcm96ZW4ga2V5cyBmaXhcbmlmIChmYWlscyhmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgJFdlYWtNYXAoKS5zZXQoKE9iamVjdC5mcmVlemUgfHwgT2JqZWN0KSh0bXApLCA3KS5nZXQodG1wKSAhPSA3OyB9KSkge1xuICBJbnRlcm5hbE1hcCA9IHdlYWsuZ2V0Q29uc3RydWN0b3Iod3JhcHBlciwgV0VBS19NQVApO1xuICBhc3NpZ24oSW50ZXJuYWxNYXAucHJvdG90eXBlLCBtZXRob2RzKTtcbiAgbWV0YS5ORUVEID0gdHJ1ZTtcbiAgZWFjaChbJ2RlbGV0ZScsICdoYXMnLCAnZ2V0JywgJ3NldCddLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIHByb3RvID0gJFdlYWtNYXAucHJvdG90eXBlO1xuICAgIHZhciBtZXRob2QgPSBwcm90b1trZXldO1xuICAgIHJlZGVmaW5lKHByb3RvLCBrZXksIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAvLyBzdG9yZSBmcm96ZW4gb2JqZWN0cyBvbiBpbnRlcm5hbCB3ZWFrbWFwIHNoaW1cbiAgICAgIGlmIChpc09iamVjdChhKSAmJiAhaXNFeHRlbnNpYmxlKGEpKSB7XG4gICAgICAgIGlmICghdGhpcy5fZikgdGhpcy5fZiA9IG5ldyBJbnRlcm5hbE1hcCgpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5fZltrZXldKGEsIGIpO1xuICAgICAgICByZXR1cm4ga2V5ID09ICdzZXQnID8gdGhpcyA6IHJlc3VsdDtcbiAgICAgIC8vIHN0b3JlIGFsbCB0aGUgcmVzdCBvbiBuYXRpdmUgd2Vha21hcFxuICAgICAgfSByZXR1cm4gbWV0aG9kLmNhbGwodGhpcywgYSwgYik7XG4gICAgfSk7XG4gIH0pO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHdlYWsgPSByZXF1aXJlKCcuL19jb2xsZWN0aW9uLXdlYWsnKTtcbnZhciB2YWxpZGF0ZSA9IHJlcXVpcmUoJy4vX3ZhbGlkYXRlLWNvbGxlY3Rpb24nKTtcbnZhciBXRUFLX1NFVCA9ICdXZWFrU2V0JztcblxuLy8gMjMuNCBXZWFrU2V0IE9iamVjdHNcbnJlcXVpcmUoJy4vX2NvbGxlY3Rpb24nKShXRUFLX1NFVCwgZnVuY3Rpb24gKGdldCkge1xuICByZXR1cm4gZnVuY3Rpb24gV2Vha1NldCgpIHsgcmV0dXJuIGdldCh0aGlzLCBhcmd1bWVudHMubGVuZ3RoID4gMCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7IH07XG59LCB7XG4gIC8vIDIzLjQuMy4xIFdlYWtTZXQucHJvdG90eXBlLmFkZCh2YWx1ZSlcbiAgYWRkOiBmdW5jdGlvbiBhZGQodmFsdWUpIHtcbiAgICByZXR1cm4gd2Vhay5kZWYodmFsaWRhdGUodGhpcywgV0VBS19TRVQpLCB2YWx1ZSwgdHJ1ZSk7XG4gIH1cbn0sIHdlYWssIGZhbHNlLCB0cnVlKTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vcHJvcG9zYWwtZmxhdE1hcC8jc2VjLUFycmF5LnByb3RvdHlwZS5mbGF0TWFwXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGZsYXR0ZW5JbnRvQXJyYXkgPSByZXF1aXJlKCcuL19mbGF0dGVuLWludG8tYXJyYXknKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xudmFyIGFycmF5U3BlY2llc0NyZWF0ZSA9IHJlcXVpcmUoJy4vX2FycmF5LXNwZWNpZXMtY3JlYXRlJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QLCAnQXJyYXknLCB7XG4gIGZsYXRNYXA6IGZ1bmN0aW9uIGZsYXRNYXAoY2FsbGJhY2tmbiAvKiAsIHRoaXNBcmcgKi8pIHtcbiAgICB2YXIgTyA9IHRvT2JqZWN0KHRoaXMpO1xuICAgIHZhciBzb3VyY2VMZW4sIEE7XG4gICAgYUZ1bmN0aW9uKGNhbGxiYWNrZm4pO1xuICAgIHNvdXJjZUxlbiA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgICBBID0gYXJyYXlTcGVjaWVzQ3JlYXRlKE8sIDApO1xuICAgIGZsYXR0ZW5JbnRvQXJyYXkoQSwgTywgTywgc291cmNlTGVuLCAwLCAxLCBjYWxsYmFja2ZuLCBhcmd1bWVudHNbMV0pO1xuICAgIHJldHVybiBBO1xuICB9XG59KTtcblxucmVxdWlyZSgnLi9fYWRkLXRvLXVuc2NvcGFibGVzJykoJ2ZsYXRNYXAnKTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vcHJvcG9zYWwtZmxhdE1hcC8jc2VjLUFycmF5LnByb3RvdHlwZS5mbGF0dGVuXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGZsYXR0ZW5JbnRvQXJyYXkgPSByZXF1aXJlKCcuL19mbGF0dGVuLWludG8tYXJyYXknKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xudmFyIGFycmF5U3BlY2llc0NyZWF0ZSA9IHJlcXVpcmUoJy4vX2FycmF5LXNwZWNpZXMtY3JlYXRlJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QLCAnQXJyYXknLCB7XG4gIGZsYXR0ZW46IGZ1bmN0aW9uIGZsYXR0ZW4oLyogZGVwdGhBcmcgPSAxICovKSB7XG4gICAgdmFyIGRlcHRoQXJnID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBPID0gdG9PYmplY3QodGhpcyk7XG4gICAgdmFyIHNvdXJjZUxlbiA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgICB2YXIgQSA9IGFycmF5U3BlY2llc0NyZWF0ZShPLCAwKTtcbiAgICBmbGF0dGVuSW50b0FycmF5KEEsIE8sIE8sIHNvdXJjZUxlbiwgMCwgZGVwdGhBcmcgPT09IHVuZGVmaW5lZCA/IDEgOiB0b0ludGVnZXIoZGVwdGhBcmcpKTtcbiAgICByZXR1cm4gQTtcbiAgfVxufSk7XG5cbnJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpKCdmbGF0dGVuJyk7XG4iLCIndXNlIHN0cmljdCc7XG4vLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9BcnJheS5wcm90b3R5cGUuaW5jbHVkZXNcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJGluY2x1ZGVzID0gcmVxdWlyZSgnLi9fYXJyYXktaW5jbHVkZXMnKSh0cnVlKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAsICdBcnJheScsIHtcbiAgaW5jbHVkZXM6IGZ1bmN0aW9uIGluY2x1ZGVzKGVsIC8qICwgZnJvbUluZGV4ID0gMCAqLykge1xuICAgIHJldHVybiAkaW5jbHVkZXModGhpcywgZWwsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgfVxufSk7XG5cbnJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpKCdpbmNsdWRlcycpO1xuIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3J3YWxkcm9uL3RjMzktbm90ZXMvYmxvYi9tYXN0ZXIvZXM2LzIwMTQtMDkvc2VwdC0yNS5tZCM1MTAtZ2xvYmFsYXNhcC1mb3ItZW5xdWV1aW5nLWEtbWljcm90YXNrXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIG1pY3JvdGFzayA9IHJlcXVpcmUoJy4vX21pY3JvdGFzaycpKCk7XG52YXIgcHJvY2VzcyA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLnByb2Nlc3M7XG52YXIgaXNOb2RlID0gcmVxdWlyZSgnLi9fY29mJykocHJvY2VzcykgPT0gJ3Byb2Nlc3MnO1xuXG4kZXhwb3J0KCRleHBvcnQuRywge1xuICBhc2FwOiBmdW5jdGlvbiBhc2FwKGZuKSB7XG4gICAgdmFyIGRvbWFpbiA9IGlzTm9kZSAmJiBwcm9jZXNzLmRvbWFpbjtcbiAgICBtaWNyb3Rhc2soZG9tYWluID8gZG9tYWluLmJpbmQoZm4pIDogZm4pO1xuICB9XG59KTtcbiIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9samhhcmIvcHJvcG9zYWwtaXMtZXJyb3JcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnRXJyb3InLCB7XG4gIGlzRXJyb3I6IGZ1bmN0aW9uIGlzRXJyb3IoaXQpIHtcbiAgICByZXR1cm4gY29mKGl0KSA9PT0gJ0Vycm9yJztcbiAgfVxufSk7XG4iLCIvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1nbG9iYWxcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5HLCB7IGdsb2JhbDogcmVxdWlyZSgnLi9fZ2xvYmFsJykgfSk7XG4iLCIvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL3Byb3Bvc2FsLXNldG1hcC1vZmZyb20vI3NlYy1tYXAuZnJvbVxucmVxdWlyZSgnLi9fc2V0LWNvbGxlY3Rpb24tZnJvbScpKCdNYXAnKTtcbiIsIi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vcHJvcG9zYWwtc2V0bWFwLW9mZnJvbS8jc2VjLW1hcC5vZlxucmVxdWlyZSgnLi9fc2V0LWNvbGxlY3Rpb24tb2YnKSgnTWFwJyk7XG4iLCIvLyBodHRwczovL2dpdGh1Yi5jb20vRGF2aWRCcnVhbnQvTWFwLVNldC5wcm90b3R5cGUudG9KU09OXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuUiwgJ01hcCcsIHsgdG9KU09OOiByZXF1aXJlKCcuL19jb2xsZWN0aW9uLXRvLWpzb24nKSgnTWFwJykgfSk7XG4iLCIvLyBodHRwczovL3J3YWxkcm9uLmdpdGh1Yi5pby9wcm9wb3NhbC1tYXRoLWV4dGVuc2lvbnMvXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGNsYW1wOiBmdW5jdGlvbiBjbGFtcCh4LCBsb3dlciwgdXBwZXIpIHtcbiAgICByZXR1cm4gTWF0aC5taW4odXBwZXIsIE1hdGgubWF4KGxvd2VyLCB4KSk7XG4gIH1cbn0pO1xuIiwiLy8gaHR0cHM6Ly9yd2FsZHJvbi5naXRodWIuaW8vcHJvcG9zYWwtbWF0aC1leHRlbnNpb25zL1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywgeyBERUdfUEVSX1JBRDogTWF0aC5QSSAvIDE4MCB9KTtcbiIsIi8vIGh0dHBzOi8vcndhbGRyb24uZ2l0aHViLmlvL3Byb3Bvc2FsLW1hdGgtZXh0ZW5zaW9ucy9cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgUkFEX1BFUl9ERUcgPSAxODAgLyBNYXRoLlBJO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGRlZ3JlZXM6IGZ1bmN0aW9uIGRlZ3JlZXMocmFkaWFucykge1xuICAgIHJldHVybiByYWRpYW5zICogUkFEX1BFUl9ERUc7XG4gIH1cbn0pO1xuIiwiLy8gaHR0cHM6Ly9yd2FsZHJvbi5naXRodWIuaW8vcHJvcG9zYWwtbWF0aC1leHRlbnNpb25zL1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBzY2FsZSA9IHJlcXVpcmUoJy4vX21hdGgtc2NhbGUnKTtcbnZhciBmcm91bmQgPSByZXF1aXJlKCcuL19tYXRoLWZyb3VuZCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGZzY2FsZTogZnVuY3Rpb24gZnNjYWxlKHgsIGluTG93LCBpbkhpZ2gsIG91dExvdywgb3V0SGlnaCkge1xuICAgIHJldHVybiBmcm91bmQoc2NhbGUoeCwgaW5Mb3csIGluSGlnaCwgb3V0TG93LCBvdXRIaWdoKSk7XG4gIH1cbn0pO1xuIiwiLy8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vQnJlbmRhbkVpY2gvNDI5NGQ1YzIxMmE2ZDIyNTQ3MDNcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgaWFkZGg6IGZ1bmN0aW9uIGlhZGRoKHgwLCB4MSwgeTAsIHkxKSB7XG4gICAgdmFyICR4MCA9IHgwID4+PiAwO1xuICAgIHZhciAkeDEgPSB4MSA+Pj4gMDtcbiAgICB2YXIgJHkwID0geTAgPj4+IDA7XG4gICAgcmV0dXJuICR4MSArICh5MSA+Pj4gMCkgKyAoKCR4MCAmICR5MCB8ICgkeDAgfCAkeTApICYgfigkeDAgKyAkeTAgPj4+IDApKSA+Pj4gMzEpIHwgMDtcbiAgfVxufSk7XG4iLCIvLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9CcmVuZGFuRWljaC80Mjk0ZDVjMjEyYTZkMjI1NDcwM1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBpbXVsaDogZnVuY3Rpb24gaW11bGgodSwgdikge1xuICAgIHZhciBVSU5UMTYgPSAweGZmZmY7XG4gICAgdmFyICR1ID0gK3U7XG4gICAgdmFyICR2ID0gK3Y7XG4gICAgdmFyIHUwID0gJHUgJiBVSU5UMTY7XG4gICAgdmFyIHYwID0gJHYgJiBVSU5UMTY7XG4gICAgdmFyIHUxID0gJHUgPj4gMTY7XG4gICAgdmFyIHYxID0gJHYgPj4gMTY7XG4gICAgdmFyIHQgPSAodTEgKiB2MCA+Pj4gMCkgKyAodTAgKiB2MCA+Pj4gMTYpO1xuICAgIHJldHVybiB1MSAqIHYxICsgKHQgPj4gMTYpICsgKCh1MCAqIHYxID4+PiAwKSArICh0ICYgVUlOVDE2KSA+PiAxNik7XG4gIH1cbn0pO1xuIiwiLy8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vQnJlbmRhbkVpY2gvNDI5NGQ1YzIxMmE2ZDIyNTQ3MDNcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgaXN1Ymg6IGZ1bmN0aW9uIGlzdWJoKHgwLCB4MSwgeTAsIHkxKSB7XG4gICAgdmFyICR4MCA9IHgwID4+PiAwO1xuICAgIHZhciAkeDEgPSB4MSA+Pj4gMDtcbiAgICB2YXIgJHkwID0geTAgPj4+IDA7XG4gICAgcmV0dXJuICR4MSAtICh5MSA+Pj4gMCkgLSAoKH4keDAgJiAkeTAgfCB+KCR4MCBeICR5MCkgJiAkeDAgLSAkeTAgPj4+IDApID4+PiAzMSkgfCAwO1xuICB9XG59KTtcbiIsIi8vIGh0dHBzOi8vcndhbGRyb24uZ2l0aHViLmlvL3Byb3Bvc2FsLW1hdGgtZXh0ZW5zaW9ucy9cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHsgUkFEX1BFUl9ERUc6IDE4MCAvIE1hdGguUEkgfSk7XG4iLCIvLyBodHRwczovL3J3YWxkcm9uLmdpdGh1Yi5pby9wcm9wb3NhbC1tYXRoLWV4dGVuc2lvbnMvXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIERFR19QRVJfUkFEID0gTWF0aC5QSSAvIDE4MDtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICByYWRpYW5zOiBmdW5jdGlvbiByYWRpYW5zKGRlZ3JlZXMpIHtcbiAgICByZXR1cm4gZGVncmVlcyAqIERFR19QRVJfUkFEO1xuICB9XG59KTtcbiIsIi8vIGh0dHBzOi8vcndhbGRyb24uZ2l0aHViLmlvL3Byb3Bvc2FsLW1hdGgtZXh0ZW5zaW9ucy9cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHsgc2NhbGU6IHJlcXVpcmUoJy4vX21hdGgtc2NhbGUnKSB9KTtcbiIsIi8vIGh0dHA6Ly9qZmJhc3RpZW4uZ2l0aHViLmlvL3BhcGVycy9NYXRoLnNpZ25iaXQuaHRtbFxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywgeyBzaWduYml0OiBmdW5jdGlvbiBzaWduYml0KHgpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICByZXR1cm4gKHggPSAreCkgIT0geCA/IHggOiB4ID09IDAgPyAxIC8geCA9PSBJbmZpbml0eSA6IHggPiAwO1xufSB9KTtcbiIsIi8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL0JyZW5kYW5FaWNoLzQyOTRkNWMyMTJhNmQyMjU0NzAzXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIHVtdWxoOiBmdW5jdGlvbiB1bXVsaCh1LCB2KSB7XG4gICAgdmFyIFVJTlQxNiA9IDB4ZmZmZjtcbiAgICB2YXIgJHUgPSArdTtcbiAgICB2YXIgJHYgPSArdjtcbiAgICB2YXIgdTAgPSAkdSAmIFVJTlQxNjtcbiAgICB2YXIgdjAgPSAkdiAmIFVJTlQxNjtcbiAgICB2YXIgdTEgPSAkdSA+Pj4gMTY7XG4gICAgdmFyIHYxID0gJHYgPj4+IDE2O1xuICAgIHZhciB0ID0gKHUxICogdjAgPj4+IDApICsgKHUwICogdjAgPj4+IDE2KTtcbiAgICByZXR1cm4gdTEgKiB2MSArICh0ID4+PiAxNikgKyAoKHUwICogdjEgPj4+IDApICsgKHQgJiBVSU5UMTYpID4+PiAxNik7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcbnZhciAkZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcblxuLy8gQi4yLjIuMiBPYmplY3QucHJvdG90eXBlLl9fZGVmaW5lR2V0dGVyX18oUCwgZ2V0dGVyKVxucmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiAkZXhwb3J0KCRleHBvcnQuUCArIHJlcXVpcmUoJy4vX29iamVjdC1mb3JjZWQtcGFtJyksICdPYmplY3QnLCB7XG4gIF9fZGVmaW5lR2V0dGVyX186IGZ1bmN0aW9uIF9fZGVmaW5lR2V0dGVyX18oUCwgZ2V0dGVyKSB7XG4gICAgJGRlZmluZVByb3BlcnR5LmYodG9PYmplY3QodGhpcyksIFAsIHsgZ2V0OiBhRnVuY3Rpb24oZ2V0dGVyKSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0pO1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG52YXIgJGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG5cbi8vIEIuMi4yLjMgT2JqZWN0LnByb3RvdHlwZS5fX2RlZmluZVNldHRlcl9fKFAsIHNldHRlcilcbnJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgJGV4cG9ydCgkZXhwb3J0LlAgKyByZXF1aXJlKCcuL19vYmplY3QtZm9yY2VkLXBhbScpLCAnT2JqZWN0Jywge1xuICBfX2RlZmluZVNldHRlcl9fOiBmdW5jdGlvbiBfX2RlZmluZVNldHRlcl9fKFAsIHNldHRlcikge1xuICAgICRkZWZpbmVQcm9wZXJ0eS5mKHRvT2JqZWN0KHRoaXMpLCBQLCB7IHNldDogYUZ1bmN0aW9uKHNldHRlciksIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9KTtcbiAgfVxufSk7XG4iLCIvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1vYmplY3QtdmFsdWVzLWVudHJpZXNcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJGVudHJpZXMgPSByZXF1aXJlKCcuL19vYmplY3QtdG8tYXJyYXknKSh0cnVlKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdPYmplY3QnLCB7XG4gIGVudHJpZXM6IGZ1bmN0aW9uIGVudHJpZXMoaXQpIHtcbiAgICByZXR1cm4gJGVudHJpZXMoaXQpO1xuICB9XG59KTtcbiIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLW9iamVjdC1nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3JzXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIG93bktleXMgPSByZXF1aXJlKCcuL19vd24ta2V5cycpO1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciBnT1BEID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKTtcbnZhciBjcmVhdGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2NyZWF0ZS1wcm9wZXJ0eScpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ09iamVjdCcsIHtcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yczogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhvYmplY3QpIHtcbiAgICB2YXIgTyA9IHRvSU9iamVjdChvYmplY3QpO1xuICAgIHZhciBnZXREZXNjID0gZ09QRC5mO1xuICAgIHZhciBrZXlzID0gb3duS2V5cyhPKTtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBrZXksIGRlc2M7XG4gICAgd2hpbGUgKGtleXMubGVuZ3RoID4gaSkge1xuICAgICAgZGVzYyA9IGdldERlc2MoTywga2V5ID0ga2V5c1tpKytdKTtcbiAgICAgIGlmIChkZXNjICE9PSB1bmRlZmluZWQpIGNyZWF0ZVByb3BlcnR5KHJlc3VsdCwga2V5LCBkZXNjKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcbnZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKTtcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpLmY7XG5cbi8vIEIuMi4yLjQgT2JqZWN0LnByb3RvdHlwZS5fX2xvb2t1cEdldHRlcl9fKFApXG5yZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmICRleHBvcnQoJGV4cG9ydC5QICsgcmVxdWlyZSgnLi9fb2JqZWN0LWZvcmNlZC1wYW0nKSwgJ09iamVjdCcsIHtcbiAgX19sb29rdXBHZXR0ZXJfXzogZnVuY3Rpb24gX19sb29rdXBHZXR0ZXJfXyhQKSB7XG4gICAgdmFyIE8gPSB0b09iamVjdCh0aGlzKTtcbiAgICB2YXIgSyA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuICAgIHZhciBEO1xuICAgIGRvIHtcbiAgICAgIGlmIChEID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIEspKSByZXR1cm4gRC5nZXQ7XG4gICAgfSB3aGlsZSAoTyA9IGdldFByb3RvdHlwZU9mKE8pKTtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcbnZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKTtcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpLmY7XG5cbi8vIEIuMi4yLjUgT2JqZWN0LnByb3RvdHlwZS5fX2xvb2t1cFNldHRlcl9fKFApXG5yZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmICRleHBvcnQoJGV4cG9ydC5QICsgcmVxdWlyZSgnLi9fb2JqZWN0LWZvcmNlZC1wYW0nKSwgJ09iamVjdCcsIHtcbiAgX19sb29rdXBTZXR0ZXJfXzogZnVuY3Rpb24gX19sb29rdXBTZXR0ZXJfXyhQKSB7XG4gICAgdmFyIE8gPSB0b09iamVjdCh0aGlzKTtcbiAgICB2YXIgSyA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuICAgIHZhciBEO1xuICAgIGRvIHtcbiAgICAgIGlmIChEID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIEspKSByZXR1cm4gRC5zZXQ7XG4gICAgfSB3aGlsZSAoTyA9IGdldFByb3RvdHlwZU9mKE8pKTtcbiAgfVxufSk7XG4iLCIvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1vYmplY3QtdmFsdWVzLWVudHJpZXNcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJHZhbHVlcyA9IHJlcXVpcmUoJy4vX29iamVjdC10by1hcnJheScpKGZhbHNlKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdPYmplY3QnLCB7XG4gIHZhbHVlczogZnVuY3Rpb24gdmFsdWVzKGl0KSB7XG4gICAgcmV0dXJuICR2YWx1ZXMoaXQpO1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96ZW5wYXJzaW5nL2VzLW9ic2VydmFibGVcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgY29yZSA9IHJlcXVpcmUoJy4vX2NvcmUnKTtcbnZhciBtaWNyb3Rhc2sgPSByZXF1aXJlKCcuL19taWNyb3Rhc2snKSgpO1xudmFyIE9CU0VSVkFCTEUgPSByZXF1aXJlKCcuL193a3MnKSgnb2JzZXJ2YWJsZScpO1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGFuSW5zdGFuY2UgPSByZXF1aXJlKCcuL19hbi1pbnN0YW5jZScpO1xudmFyIHJlZGVmaW5lQWxsID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUtYWxsJyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciBmb3JPZiA9IHJlcXVpcmUoJy4vX2Zvci1vZicpO1xudmFyIFJFVFVSTiA9IGZvck9mLlJFVFVSTjtcblxudmFyIGdldE1ldGhvZCA9IGZ1bmN0aW9uIChmbikge1xuICByZXR1cm4gZm4gPT0gbnVsbCA/IHVuZGVmaW5lZCA6IGFGdW5jdGlvbihmbik7XG59O1xuXG52YXIgY2xlYW51cFN1YnNjcmlwdGlvbiA9IGZ1bmN0aW9uIChzdWJzY3JpcHRpb24pIHtcbiAgdmFyIGNsZWFudXAgPSBzdWJzY3JpcHRpb24uX2M7XG4gIGlmIChjbGVhbnVwKSB7XG4gICAgc3Vic2NyaXB0aW9uLl9jID0gdW5kZWZpbmVkO1xuICAgIGNsZWFudXAoKTtcbiAgfVxufTtcblxudmFyIHN1YnNjcmlwdGlvbkNsb3NlZCA9IGZ1bmN0aW9uIChzdWJzY3JpcHRpb24pIHtcbiAgcmV0dXJuIHN1YnNjcmlwdGlvbi5fbyA9PT0gdW5kZWZpbmVkO1xufTtcblxudmFyIGNsb3NlU3Vic2NyaXB0aW9uID0gZnVuY3Rpb24gKHN1YnNjcmlwdGlvbikge1xuICBpZiAoIXN1YnNjcmlwdGlvbkNsb3NlZChzdWJzY3JpcHRpb24pKSB7XG4gICAgc3Vic2NyaXB0aW9uLl9vID0gdW5kZWZpbmVkO1xuICAgIGNsZWFudXBTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uKTtcbiAgfVxufTtcblxudmFyIFN1YnNjcmlwdGlvbiA9IGZ1bmN0aW9uIChvYnNlcnZlciwgc3Vic2NyaWJlcikge1xuICBhbk9iamVjdChvYnNlcnZlcik7XG4gIHRoaXMuX2MgPSB1bmRlZmluZWQ7XG4gIHRoaXMuX28gPSBvYnNlcnZlcjtcbiAgb2JzZXJ2ZXIgPSBuZXcgU3Vic2NyaXB0aW9uT2JzZXJ2ZXIodGhpcyk7XG4gIHRyeSB7XG4gICAgdmFyIGNsZWFudXAgPSBzdWJzY3JpYmVyKG9ic2VydmVyKTtcbiAgICB2YXIgc3Vic2NyaXB0aW9uID0gY2xlYW51cDtcbiAgICBpZiAoY2xlYW51cCAhPSBudWxsKSB7XG4gICAgICBpZiAodHlwZW9mIGNsZWFudXAudW5zdWJzY3JpYmUgPT09ICdmdW5jdGlvbicpIGNsZWFudXAgPSBmdW5jdGlvbiAoKSB7IHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpOyB9O1xuICAgICAgZWxzZSBhRnVuY3Rpb24oY2xlYW51cCk7XG4gICAgICB0aGlzLl9jID0gY2xlYW51cDtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBvYnNlcnZlci5lcnJvcihlKTtcbiAgICByZXR1cm47XG4gIH0gaWYgKHN1YnNjcmlwdGlvbkNsb3NlZCh0aGlzKSkgY2xlYW51cFN1YnNjcmlwdGlvbih0aGlzKTtcbn07XG5cblN1YnNjcmlwdGlvbi5wcm90b3R5cGUgPSByZWRlZmluZUFsbCh7fSwge1xuICB1bnN1YnNjcmliZTogZnVuY3Rpb24gdW5zdWJzY3JpYmUoKSB7IGNsb3NlU3Vic2NyaXB0aW9uKHRoaXMpOyB9XG59KTtcblxudmFyIFN1YnNjcmlwdGlvbk9ic2VydmVyID0gZnVuY3Rpb24gKHN1YnNjcmlwdGlvbikge1xuICB0aGlzLl9zID0gc3Vic2NyaXB0aW9uO1xufTtcblxuU3Vic2NyaXB0aW9uT2JzZXJ2ZXIucHJvdG90eXBlID0gcmVkZWZpbmVBbGwoe30sIHtcbiAgbmV4dDogZnVuY3Rpb24gbmV4dCh2YWx1ZSkge1xuICAgIHZhciBzdWJzY3JpcHRpb24gPSB0aGlzLl9zO1xuICAgIGlmICghc3Vic2NyaXB0aW9uQ2xvc2VkKHN1YnNjcmlwdGlvbikpIHtcbiAgICAgIHZhciBvYnNlcnZlciA9IHN1YnNjcmlwdGlvbi5fbztcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBtID0gZ2V0TWV0aG9kKG9ic2VydmVyLm5leHQpO1xuICAgICAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvYnNlcnZlciwgdmFsdWUpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNsb3NlU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgZXJyb3I6IGZ1bmN0aW9uIGVycm9yKHZhbHVlKSB7XG4gICAgdmFyIHN1YnNjcmlwdGlvbiA9IHRoaXMuX3M7XG4gICAgaWYgKHN1YnNjcmlwdGlvbkNsb3NlZChzdWJzY3JpcHRpb24pKSB0aHJvdyB2YWx1ZTtcbiAgICB2YXIgb2JzZXJ2ZXIgPSBzdWJzY3JpcHRpb24uX287XG4gICAgc3Vic2NyaXB0aW9uLl9vID0gdW5kZWZpbmVkO1xuICAgIHRyeSB7XG4gICAgICB2YXIgbSA9IGdldE1ldGhvZChvYnNlcnZlci5lcnJvcik7XG4gICAgICBpZiAoIW0pIHRocm93IHZhbHVlO1xuICAgICAgdmFsdWUgPSBtLmNhbGwob2JzZXJ2ZXIsIHZhbHVlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjbGVhbnVwU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH0gY2xlYW51cFN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb24pO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfSxcbiAgY29tcGxldGU6IGZ1bmN0aW9uIGNvbXBsZXRlKHZhbHVlKSB7XG4gICAgdmFyIHN1YnNjcmlwdGlvbiA9IHRoaXMuX3M7XG4gICAgaWYgKCFzdWJzY3JpcHRpb25DbG9zZWQoc3Vic2NyaXB0aW9uKSkge1xuICAgICAgdmFyIG9ic2VydmVyID0gc3Vic2NyaXB0aW9uLl9vO1xuICAgICAgc3Vic2NyaXB0aW9uLl9vID0gdW5kZWZpbmVkO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIG0gPSBnZXRNZXRob2Qob2JzZXJ2ZXIuY29tcGxldGUpO1xuICAgICAgICB2YWx1ZSA9IG0gPyBtLmNhbGwob2JzZXJ2ZXIsIHZhbHVlKSA6IHVuZGVmaW5lZDtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjbGVhbnVwU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgfSBjbGVhbnVwU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbik7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICB9XG59KTtcblxudmFyICRPYnNlcnZhYmxlID0gZnVuY3Rpb24gT2JzZXJ2YWJsZShzdWJzY3JpYmVyKSB7XG4gIGFuSW5zdGFuY2UodGhpcywgJE9ic2VydmFibGUsICdPYnNlcnZhYmxlJywgJ19mJykuX2YgPSBhRnVuY3Rpb24oc3Vic2NyaWJlcik7XG59O1xuXG5yZWRlZmluZUFsbCgkT2JzZXJ2YWJsZS5wcm90b3R5cGUsIHtcbiAgc3Vic2NyaWJlOiBmdW5jdGlvbiBzdWJzY3JpYmUob2JzZXJ2ZXIpIHtcbiAgICByZXR1cm4gbmV3IFN1YnNjcmlwdGlvbihvYnNlcnZlciwgdGhpcy5fZik7XG4gIH0sXG4gIGZvckVhY2g6IGZ1bmN0aW9uIGZvckVhY2goZm4pIHtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgcmV0dXJuIG5ldyAoY29yZS5Qcm9taXNlIHx8IGdsb2JhbC5Qcm9taXNlKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBhRnVuY3Rpb24oZm4pO1xuICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IHRoYXQuc3Vic2NyaWJlKHtcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBmbih2YWx1ZSk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlcnJvcjogcmVqZWN0LFxuICAgICAgICBjb21wbGV0ZTogcmVzb2x2ZVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn0pO1xuXG5yZWRlZmluZUFsbCgkT2JzZXJ2YWJsZSwge1xuICBmcm9tOiBmdW5jdGlvbiBmcm9tKHgpIHtcbiAgICB2YXIgQyA9IHR5cGVvZiB0aGlzID09PSAnZnVuY3Rpb24nID8gdGhpcyA6ICRPYnNlcnZhYmxlO1xuICAgIHZhciBtZXRob2QgPSBnZXRNZXRob2QoYW5PYmplY3QoeClbT0JTRVJWQUJMRV0pO1xuICAgIGlmIChtZXRob2QpIHtcbiAgICAgIHZhciBvYnNlcnZhYmxlID0gYW5PYmplY3QobWV0aG9kLmNhbGwoeCkpO1xuICAgICAgcmV0dXJuIG9ic2VydmFibGUuY29uc3RydWN0b3IgPT09IEMgPyBvYnNlcnZhYmxlIDogbmV3IEMoZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICAgIHJldHVybiBvYnNlcnZhYmxlLnN1YnNjcmliZShvYnNlcnZlcik7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBDKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgdmFyIGRvbmUgPSBmYWxzZTtcbiAgICAgIG1pY3JvdGFzayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghZG9uZSkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoZm9yT2YoeCwgZmFsc2UsIGZ1bmN0aW9uIChpdCkge1xuICAgICAgICAgICAgICBvYnNlcnZlci5uZXh0KGl0KTtcbiAgICAgICAgICAgICAgaWYgKGRvbmUpIHJldHVybiBSRVRVUk47XG4gICAgICAgICAgICB9KSA9PT0gUkVUVVJOKSByZXR1cm47XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKGRvbmUpIHRocm93IGU7XG4gICAgICAgICAgICBvYnNlcnZlci5lcnJvcihlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9IG9ic2VydmVyLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgZG9uZSA9IHRydWU7IH07XG4gICAgfSk7XG4gIH0sXG4gIG9mOiBmdW5jdGlvbiBvZigpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGFyZ3VtZW50cy5sZW5ndGgsIGl0ZW1zID0gQXJyYXkobCk7IGkgPCBsOykgaXRlbXNbaV0gPSBhcmd1bWVudHNbaSsrXTtcbiAgICByZXR1cm4gbmV3ICh0eXBlb2YgdGhpcyA9PT0gJ2Z1bmN0aW9uJyA/IHRoaXMgOiAkT2JzZXJ2YWJsZSkoZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICB2YXIgZG9uZSA9IGZhbHNlO1xuICAgICAgbWljcm90YXNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFkb25lKSB7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBpdGVtcy5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dChpdGVtc1tqXSk7XG4gICAgICAgICAgICBpZiAoZG9uZSkgcmV0dXJuO1xuICAgICAgICAgIH0gb2JzZXJ2ZXIuY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyBkb25lID0gdHJ1ZTsgfTtcbiAgICB9KTtcbiAgfVxufSk7XG5cbmhpZGUoJE9ic2VydmFibGUucHJvdG90eXBlLCBPQlNFUlZBQkxFLCBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9KTtcblxuJGV4cG9ydCgkZXhwb3J0LkcsIHsgT2JzZXJ2YWJsZTogJE9ic2VydmFibGUgfSk7XG5cbnJlcXVpcmUoJy4vX3NldC1zcGVjaWVzJykoJ09ic2VydmFibGUnKTtcbiIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLXByb21pc2UtZmluYWxseVxuJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBjb3JlID0gcmVxdWlyZSgnLi9fY29yZScpO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIHNwZWNpZXNDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4vX3NwZWNpZXMtY29uc3RydWN0b3InKTtcbnZhciBwcm9taXNlUmVzb2x2ZSA9IHJlcXVpcmUoJy4vX3Byb21pc2UtcmVzb2x2ZScpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuUiwgJ1Byb21pc2UnLCB7ICdmaW5hbGx5JzogZnVuY3Rpb24gKG9uRmluYWxseSkge1xuICB2YXIgQyA9IHNwZWNpZXNDb25zdHJ1Y3Rvcih0aGlzLCBjb3JlLlByb21pc2UgfHwgZ2xvYmFsLlByb21pc2UpO1xuICB2YXIgaXNGdW5jdGlvbiA9IHR5cGVvZiBvbkZpbmFsbHkgPT0gJ2Z1bmN0aW9uJztcbiAgcmV0dXJuIHRoaXMudGhlbihcbiAgICBpc0Z1bmN0aW9uID8gZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZShDLCBvbkZpbmFsbHkoKSkudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiB4OyB9KTtcbiAgICB9IDogb25GaW5hbGx5LFxuICAgIGlzRnVuY3Rpb24gPyBmdW5jdGlvbiAoZSkge1xuICAgICAgcmV0dXJuIHByb21pc2VSZXNvbHZlKEMsIG9uRmluYWxseSgpKS50aGVuKGZ1bmN0aW9uICgpIHsgdGhyb3cgZTsgfSk7XG4gICAgfSA6IG9uRmluYWxseVxuICApO1xufSB9KTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLXByb21pc2UtdHJ5XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5ID0gcmVxdWlyZSgnLi9fbmV3LXByb21pc2UtY2FwYWJpbGl0eScpO1xudmFyIHBlcmZvcm0gPSByZXF1aXJlKCcuL19wZXJmb3JtJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUHJvbWlzZScsIHsgJ3RyeSc6IGZ1bmN0aW9uIChjYWxsYmFja2ZuKSB7XG4gIHZhciBwcm9taXNlQ2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5LmYodGhpcyk7XG4gIHZhciByZXN1bHQgPSBwZXJmb3JtKGNhbGxiYWNrZm4pO1xuICAocmVzdWx0LmUgPyBwcm9taXNlQ2FwYWJpbGl0eS5yZWplY3QgOiBwcm9taXNlQ2FwYWJpbGl0eS5yZXNvbHZlKShyZXN1bHQudik7XG4gIHJldHVybiBwcm9taXNlQ2FwYWJpbGl0eS5wcm9taXNlO1xufSB9KTtcbiIsInZhciBtZXRhZGF0YSA9IHJlcXVpcmUoJy4vX21ldGFkYXRhJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciB0b01ldGFLZXkgPSBtZXRhZGF0YS5rZXk7XG52YXIgb3JkaW5hcnlEZWZpbmVPd25NZXRhZGF0YSA9IG1ldGFkYXRhLnNldDtcblxubWV0YWRhdGEuZXhwKHsgZGVmaW5lTWV0YWRhdGE6IGZ1bmN0aW9uIGRlZmluZU1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlLCB0YXJnZXQsIHRhcmdldEtleSkge1xuICBvcmRpbmFyeURlZmluZU93bk1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlLCBhbk9iamVjdCh0YXJnZXQpLCB0b01ldGFLZXkodGFyZ2V0S2V5KSk7XG59IH0pO1xuIiwidmFyIG1ldGFkYXRhID0gcmVxdWlyZSgnLi9fbWV0YWRhdGEnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIHRvTWV0YUtleSA9IG1ldGFkYXRhLmtleTtcbnZhciBnZXRPckNyZWF0ZU1ldGFkYXRhTWFwID0gbWV0YWRhdGEubWFwO1xudmFyIHN0b3JlID0gbWV0YWRhdGEuc3RvcmU7XG5cbm1ldGFkYXRhLmV4cCh7IGRlbGV0ZU1ldGFkYXRhOiBmdW5jdGlvbiBkZWxldGVNZXRhZGF0YShtZXRhZGF0YUtleSwgdGFyZ2V0IC8qICwgdGFyZ2V0S2V5ICovKSB7XG4gIHZhciB0YXJnZXRLZXkgPSBhcmd1bWVudHMubGVuZ3RoIDwgMyA/IHVuZGVmaW5lZCA6IHRvTWV0YUtleShhcmd1bWVudHNbMl0pO1xuICB2YXIgbWV0YWRhdGFNYXAgPSBnZXRPckNyZWF0ZU1ldGFkYXRhTWFwKGFuT2JqZWN0KHRhcmdldCksIHRhcmdldEtleSwgZmFsc2UpO1xuICBpZiAobWV0YWRhdGFNYXAgPT09IHVuZGVmaW5lZCB8fCAhbWV0YWRhdGFNYXBbJ2RlbGV0ZSddKG1ldGFkYXRhS2V5KSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobWV0YWRhdGFNYXAuc2l6ZSkgcmV0dXJuIHRydWU7XG4gIHZhciB0YXJnZXRNZXRhZGF0YSA9IHN0b3JlLmdldCh0YXJnZXQpO1xuICB0YXJnZXRNZXRhZGF0YVsnZGVsZXRlJ10odGFyZ2V0S2V5KTtcbiAgcmV0dXJuICEhdGFyZ2V0TWV0YWRhdGEuc2l6ZSB8fCBzdG9yZVsnZGVsZXRlJ10odGFyZ2V0KTtcbn0gfSk7XG4iLCJ2YXIgU2V0ID0gcmVxdWlyZSgnLi9lczYuc2V0Jyk7XG52YXIgZnJvbSA9IHJlcXVpcmUoJy4vX2FycmF5LWZyb20taXRlcmFibGUnKTtcbnZhciBtZXRhZGF0YSA9IHJlcXVpcmUoJy4vX21ldGFkYXRhJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKTtcbnZhciBvcmRpbmFyeU93bk1ldGFkYXRhS2V5cyA9IG1ldGFkYXRhLmtleXM7XG52YXIgdG9NZXRhS2V5ID0gbWV0YWRhdGEua2V5O1xuXG52YXIgb3JkaW5hcnlNZXRhZGF0YUtleXMgPSBmdW5jdGlvbiAoTywgUCkge1xuICB2YXIgb0tleXMgPSBvcmRpbmFyeU93bk1ldGFkYXRhS2V5cyhPLCBQKTtcbiAgdmFyIHBhcmVudCA9IGdldFByb3RvdHlwZU9mKE8pO1xuICBpZiAocGFyZW50ID09PSBudWxsKSByZXR1cm4gb0tleXM7XG4gIHZhciBwS2V5cyA9IG9yZGluYXJ5TWV0YWRhdGFLZXlzKHBhcmVudCwgUCk7XG4gIHJldHVybiBwS2V5cy5sZW5ndGggPyBvS2V5cy5sZW5ndGggPyBmcm9tKG5ldyBTZXQob0tleXMuY29uY2F0KHBLZXlzKSkpIDogcEtleXMgOiBvS2V5cztcbn07XG5cbm1ldGFkYXRhLmV4cCh7IGdldE1ldGFkYXRhS2V5czogZnVuY3Rpb24gZ2V0TWV0YWRhdGFLZXlzKHRhcmdldCAvKiAsIHRhcmdldEtleSAqLykge1xuICByZXR1cm4gb3JkaW5hcnlNZXRhZGF0YUtleXMoYW5PYmplY3QodGFyZ2V0KSwgYXJndW1lbnRzLmxlbmd0aCA8IDIgPyB1bmRlZmluZWQgOiB0b01ldGFLZXkoYXJndW1lbnRzWzFdKSk7XG59IH0pO1xuIiwidmFyIG1ldGFkYXRhID0gcmVxdWlyZSgnLi9fbWV0YWRhdGEnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpO1xudmFyIG9yZGluYXJ5SGFzT3duTWV0YWRhdGEgPSBtZXRhZGF0YS5oYXM7XG52YXIgb3JkaW5hcnlHZXRPd25NZXRhZGF0YSA9IG1ldGFkYXRhLmdldDtcbnZhciB0b01ldGFLZXkgPSBtZXRhZGF0YS5rZXk7XG5cbnZhciBvcmRpbmFyeUdldE1ldGFkYXRhID0gZnVuY3Rpb24gKE1ldGFkYXRhS2V5LCBPLCBQKSB7XG4gIHZhciBoYXNPd24gPSBvcmRpbmFyeUhhc093bk1ldGFkYXRhKE1ldGFkYXRhS2V5LCBPLCBQKTtcbiAgaWYgKGhhc093bikgcmV0dXJuIG9yZGluYXJ5R2V0T3duTWV0YWRhdGEoTWV0YWRhdGFLZXksIE8sIFApO1xuICB2YXIgcGFyZW50ID0gZ2V0UHJvdG90eXBlT2YoTyk7XG4gIHJldHVybiBwYXJlbnQgIT09IG51bGwgPyBvcmRpbmFyeUdldE1ldGFkYXRhKE1ldGFkYXRhS2V5LCBwYXJlbnQsIFApIDogdW5kZWZpbmVkO1xufTtcblxubWV0YWRhdGEuZXhwKHsgZ2V0TWV0YWRhdGE6IGZ1bmN0aW9uIGdldE1ldGFkYXRhKG1ldGFkYXRhS2V5LCB0YXJnZXQgLyogLCB0YXJnZXRLZXkgKi8pIHtcbiAgcmV0dXJuIG9yZGluYXJ5R2V0TWV0YWRhdGEobWV0YWRhdGFLZXksIGFuT2JqZWN0KHRhcmdldCksIGFyZ3VtZW50cy5sZW5ndGggPCAzID8gdW5kZWZpbmVkIDogdG9NZXRhS2V5KGFyZ3VtZW50c1syXSkpO1xufSB9KTtcbiIsInZhciBtZXRhZGF0YSA9IHJlcXVpcmUoJy4vX21ldGFkYXRhJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBvcmRpbmFyeU93bk1ldGFkYXRhS2V5cyA9IG1ldGFkYXRhLmtleXM7XG52YXIgdG9NZXRhS2V5ID0gbWV0YWRhdGEua2V5O1xuXG5tZXRhZGF0YS5leHAoeyBnZXRPd25NZXRhZGF0YUtleXM6IGZ1bmN0aW9uIGdldE93bk1ldGFkYXRhS2V5cyh0YXJnZXQgLyogLCB0YXJnZXRLZXkgKi8pIHtcbiAgcmV0dXJuIG9yZGluYXJ5T3duTWV0YWRhdGFLZXlzKGFuT2JqZWN0KHRhcmdldCksIGFyZ3VtZW50cy5sZW5ndGggPCAyID8gdW5kZWZpbmVkIDogdG9NZXRhS2V5KGFyZ3VtZW50c1sxXSkpO1xufSB9KTtcbiIsInZhciBtZXRhZGF0YSA9IHJlcXVpcmUoJy4vX21ldGFkYXRhJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBvcmRpbmFyeUdldE93bk1ldGFkYXRhID0gbWV0YWRhdGEuZ2V0O1xudmFyIHRvTWV0YUtleSA9IG1ldGFkYXRhLmtleTtcblxubWV0YWRhdGEuZXhwKHsgZ2V0T3duTWV0YWRhdGE6IGZ1bmN0aW9uIGdldE93bk1ldGFkYXRhKG1ldGFkYXRhS2V5LCB0YXJnZXQgLyogLCB0YXJnZXRLZXkgKi8pIHtcbiAgcmV0dXJuIG9yZGluYXJ5R2V0T3duTWV0YWRhdGEobWV0YWRhdGFLZXksIGFuT2JqZWN0KHRhcmdldClcbiAgICAsIGFyZ3VtZW50cy5sZW5ndGggPCAzID8gdW5kZWZpbmVkIDogdG9NZXRhS2V5KGFyZ3VtZW50c1syXSkpO1xufSB9KTtcbiIsInZhciBtZXRhZGF0YSA9IHJlcXVpcmUoJy4vX21ldGFkYXRhJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKTtcbnZhciBvcmRpbmFyeUhhc093bk1ldGFkYXRhID0gbWV0YWRhdGEuaGFzO1xudmFyIHRvTWV0YUtleSA9IG1ldGFkYXRhLmtleTtcblxudmFyIG9yZGluYXJ5SGFzTWV0YWRhdGEgPSBmdW5jdGlvbiAoTWV0YWRhdGFLZXksIE8sIFApIHtcbiAgdmFyIGhhc093biA9IG9yZGluYXJ5SGFzT3duTWV0YWRhdGEoTWV0YWRhdGFLZXksIE8sIFApO1xuICBpZiAoaGFzT3duKSByZXR1cm4gdHJ1ZTtcbiAgdmFyIHBhcmVudCA9IGdldFByb3RvdHlwZU9mKE8pO1xuICByZXR1cm4gcGFyZW50ICE9PSBudWxsID8gb3JkaW5hcnlIYXNNZXRhZGF0YShNZXRhZGF0YUtleSwgcGFyZW50LCBQKSA6IGZhbHNlO1xufTtcblxubWV0YWRhdGEuZXhwKHsgaGFzTWV0YWRhdGE6IGZ1bmN0aW9uIGhhc01ldGFkYXRhKG1ldGFkYXRhS2V5LCB0YXJnZXQgLyogLCB0YXJnZXRLZXkgKi8pIHtcbiAgcmV0dXJuIG9yZGluYXJ5SGFzTWV0YWRhdGEobWV0YWRhdGFLZXksIGFuT2JqZWN0KHRhcmdldCksIGFyZ3VtZW50cy5sZW5ndGggPCAzID8gdW5kZWZpbmVkIDogdG9NZXRhS2V5KGFyZ3VtZW50c1syXSkpO1xufSB9KTtcbiIsInZhciBtZXRhZGF0YSA9IHJlcXVpcmUoJy4vX21ldGFkYXRhJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBvcmRpbmFyeUhhc093bk1ldGFkYXRhID0gbWV0YWRhdGEuaGFzO1xudmFyIHRvTWV0YUtleSA9IG1ldGFkYXRhLmtleTtcblxubWV0YWRhdGEuZXhwKHsgaGFzT3duTWV0YWRhdGE6IGZ1bmN0aW9uIGhhc093bk1ldGFkYXRhKG1ldGFkYXRhS2V5LCB0YXJnZXQgLyogLCB0YXJnZXRLZXkgKi8pIHtcbiAgcmV0dXJuIG9yZGluYXJ5SGFzT3duTWV0YWRhdGEobWV0YWRhdGFLZXksIGFuT2JqZWN0KHRhcmdldClcbiAgICAsIGFyZ3VtZW50cy5sZW5ndGggPCAzID8gdW5kZWZpbmVkIDogdG9NZXRhS2V5KGFyZ3VtZW50c1syXSkpO1xufSB9KTtcbiIsInZhciAkbWV0YWRhdGEgPSByZXF1aXJlKCcuL19tZXRhZGF0YScpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xudmFyIHRvTWV0YUtleSA9ICRtZXRhZGF0YS5rZXk7XG52YXIgb3JkaW5hcnlEZWZpbmVPd25NZXRhZGF0YSA9ICRtZXRhZGF0YS5zZXQ7XG5cbiRtZXRhZGF0YS5leHAoeyBtZXRhZGF0YTogZnVuY3Rpb24gbWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGRlY29yYXRvcih0YXJnZXQsIHRhcmdldEtleSkge1xuICAgIG9yZGluYXJ5RGVmaW5lT3duTWV0YWRhdGEoXG4gICAgICBtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSxcbiAgICAgICh0YXJnZXRLZXkgIT09IHVuZGVmaW5lZCA/IGFuT2JqZWN0IDogYUZ1bmN0aW9uKSh0YXJnZXQpLFxuICAgICAgdG9NZXRhS2V5KHRhcmdldEtleSlcbiAgICApO1xuICB9O1xufSB9KTtcbiIsIi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vcHJvcG9zYWwtc2V0bWFwLW9mZnJvbS8jc2VjLXNldC5mcm9tXG5yZXF1aXJlKCcuL19zZXQtY29sbGVjdGlvbi1mcm9tJykoJ1NldCcpO1xuIiwiLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9wcm9wb3NhbC1zZXRtYXAtb2Zmcm9tLyNzZWMtc2V0Lm9mXG5yZXF1aXJlKCcuL19zZXQtY29sbGVjdGlvbi1vZicpKCdTZXQnKTtcbiIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9EYXZpZEJydWFudC9NYXAtU2V0LnByb3RvdHlwZS50b0pTT05cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5SLCAnU2V0JywgeyB0b0pTT046IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24tdG8tanNvbicpKCdTZXQnKSB9KTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRoaWFzYnluZW5zL1N0cmluZy5wcm90b3R5cGUuYXRcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJGF0ID0gcmVxdWlyZSgnLi9fc3RyaW5nLWF0JykodHJ1ZSk7XG5cbiRleHBvcnQoJGV4cG9ydC5QLCAnU3RyaW5nJywge1xuICBhdDogZnVuY3Rpb24gYXQocG9zKSB7XG4gICAgcmV0dXJuICRhdCh0aGlzLCBwb3MpO1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vU3RyaW5nLnByb3RvdHlwZS5tYXRjaEFsbC9cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIGlzUmVnRXhwID0gcmVxdWlyZSgnLi9faXMtcmVnZXhwJyk7XG52YXIgZ2V0RmxhZ3MgPSByZXF1aXJlKCcuL19mbGFncycpO1xudmFyIFJlZ0V4cFByb3RvID0gUmVnRXhwLnByb3RvdHlwZTtcblxudmFyICRSZWdFeHBTdHJpbmdJdGVyYXRvciA9IGZ1bmN0aW9uIChyZWdleHAsIHN0cmluZykge1xuICB0aGlzLl9yID0gcmVnZXhwO1xuICB0aGlzLl9zID0gc3RyaW5nO1xufTtcblxucmVxdWlyZSgnLi9faXRlci1jcmVhdGUnKSgkUmVnRXhwU3RyaW5nSXRlcmF0b3IsICdSZWdFeHAgU3RyaW5nJywgZnVuY3Rpb24gbmV4dCgpIHtcbiAgdmFyIG1hdGNoID0gdGhpcy5fci5leGVjKHRoaXMuX3MpO1xuICByZXR1cm4geyB2YWx1ZTogbWF0Y2gsIGRvbmU6IG1hdGNoID09PSBudWxsIH07XG59KTtcblxuJGV4cG9ydCgkZXhwb3J0LlAsICdTdHJpbmcnLCB7XG4gIG1hdGNoQWxsOiBmdW5jdGlvbiBtYXRjaEFsbChyZWdleHApIHtcbiAgICBkZWZpbmVkKHRoaXMpO1xuICAgIGlmICghaXNSZWdFeHAocmVnZXhwKSkgdGhyb3cgVHlwZUVycm9yKHJlZ2V4cCArICcgaXMgbm90IGEgcmVnZXhwIScpO1xuICAgIHZhciBTID0gU3RyaW5nKHRoaXMpO1xuICAgIHZhciBmbGFncyA9ICdmbGFncycgaW4gUmVnRXhwUHJvdG8gPyBTdHJpbmcocmVnZXhwLmZsYWdzKSA6IGdldEZsYWdzLmNhbGwocmVnZXhwKTtcbiAgICB2YXIgcnggPSBuZXcgUmVnRXhwKHJlZ2V4cC5zb3VyY2UsIH5mbGFncy5pbmRleE9mKCdnJykgPyBmbGFncyA6ICdnJyArIGZsYWdzKTtcbiAgICByeC5sYXN0SW5kZXggPSB0b0xlbmd0aChyZWdleHAubGFzdEluZGV4KTtcbiAgICByZXR1cm4gbmV3ICRSZWdFeHBTdHJpbmdJdGVyYXRvcihyeCwgUyk7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtc3RyaW5nLXBhZC1zdGFydC1lbmRcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJHBhZCA9IHJlcXVpcmUoJy4vX3N0cmluZy1wYWQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAsICdTdHJpbmcnLCB7XG4gIHBhZEVuZDogZnVuY3Rpb24gcGFkRW5kKG1heExlbmd0aCAvKiAsIGZpbGxTdHJpbmcgPSAnICcgKi8pIHtcbiAgICByZXR1cm4gJHBhZCh0aGlzLCBtYXhMZW5ndGgsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkLCBmYWxzZSk7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtc3RyaW5nLXBhZC1zdGFydC1lbmRcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJHBhZCA9IHJlcXVpcmUoJy4vX3N0cmluZy1wYWQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAsICdTdHJpbmcnLCB7XG4gIHBhZFN0YXJ0OiBmdW5jdGlvbiBwYWRTdGFydChtYXhMZW5ndGggLyogLCBmaWxsU3RyaW5nID0gJyAnICovKSB7XG4gICAgcmV0dXJuICRwYWQodGhpcywgbWF4TGVuZ3RoLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCwgdHJ1ZSk7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3NlYm1hcmtiYWdlL2VjbWFzY3JpcHQtc3RyaW5nLWxlZnQtcmlnaHQtdHJpbVxucmVxdWlyZSgnLi9fc3RyaW5nLXRyaW0nKSgndHJpbUxlZnQnLCBmdW5jdGlvbiAoJHRyaW0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHRyaW1MZWZ0KCkge1xuICAgIHJldHVybiAkdHJpbSh0aGlzLCAxKTtcbiAgfTtcbn0sICd0cmltU3RhcnQnKTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zZWJtYXJrYmFnZS9lY21hc2NyaXB0LXN0cmluZy1sZWZ0LXJpZ2h0LXRyaW1cbnJlcXVpcmUoJy4vX3N0cmluZy10cmltJykoJ3RyaW1SaWdodCcsIGZ1bmN0aW9uICgkdHJpbSkge1xuICByZXR1cm4gZnVuY3Rpb24gdHJpbVJpZ2h0KCkge1xuICAgIHJldHVybiAkdHJpbSh0aGlzLCAyKTtcbiAgfTtcbn0sICd0cmltRW5kJyk7XG4iLCJyZXF1aXJlKCcuL193a3MtZGVmaW5lJykoJ2FzeW5jSXRlcmF0b3InKTtcbiIsInJlcXVpcmUoJy4vX3drcy1kZWZpbmUnKSgnb2JzZXJ2YWJsZScpO1xuIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtZ2xvYmFsXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1N5c3RlbScsIHsgZ2xvYmFsOiByZXF1aXJlKCcuL19nbG9iYWwnKSB9KTtcbiIsIi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vcHJvcG9zYWwtc2V0bWFwLW9mZnJvbS8jc2VjLXdlYWttYXAuZnJvbVxucmVxdWlyZSgnLi9fc2V0LWNvbGxlY3Rpb24tZnJvbScpKCdXZWFrTWFwJyk7XG4iLCIvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL3Byb3Bvc2FsLXNldG1hcC1vZmZyb20vI3NlYy13ZWFrbWFwLm9mXG5yZXF1aXJlKCcuL19zZXQtY29sbGVjdGlvbi1vZicpKCdXZWFrTWFwJyk7XG4iLCIvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL3Byb3Bvc2FsLXNldG1hcC1vZmZyb20vI3NlYy13ZWFrc2V0LmZyb21cbnJlcXVpcmUoJy4vX3NldC1jb2xsZWN0aW9uLWZyb20nKSgnV2Vha1NldCcpO1xuIiwiLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9wcm9wb3NhbC1zZXRtYXAtb2Zmcm9tLyNzZWMtd2Vha3NldC5vZlxucmVxdWlyZSgnLi9fc2V0LWNvbGxlY3Rpb24tb2YnKSgnV2Vha1NldCcpO1xuIiwidmFyICRpdGVyYXRvcnMgPSByZXF1aXJlKCcuL2VzNi5hcnJheS5pdGVyYXRvcicpO1xudmFyIGdldEtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xudmFyIHdrcyA9IHJlcXVpcmUoJy4vX3drcycpO1xudmFyIElURVJBVE9SID0gd2tzKCdpdGVyYXRvcicpO1xudmFyIFRPX1NUUklOR19UQUcgPSB3a3MoJ3RvU3RyaW5nVGFnJyk7XG52YXIgQXJyYXlWYWx1ZXMgPSBJdGVyYXRvcnMuQXJyYXk7XG5cbnZhciBET01JdGVyYWJsZXMgPSB7XG4gIENTU1J1bGVMaXN0OiB0cnVlLCAvLyBUT0RPOiBOb3Qgc3BlYyBjb21wbGlhbnQsIHNob3VsZCBiZSBmYWxzZS5cbiAgQ1NTU3R5bGVEZWNsYXJhdGlvbjogZmFsc2UsXG4gIENTU1ZhbHVlTGlzdDogZmFsc2UsXG4gIENsaWVudFJlY3RMaXN0OiBmYWxzZSxcbiAgRE9NUmVjdExpc3Q6IGZhbHNlLFxuICBET01TdHJpbmdMaXN0OiBmYWxzZSxcbiAgRE9NVG9rZW5MaXN0OiB0cnVlLFxuICBEYXRhVHJhbnNmZXJJdGVtTGlzdDogZmFsc2UsXG4gIEZpbGVMaXN0OiBmYWxzZSxcbiAgSFRNTEFsbENvbGxlY3Rpb246IGZhbHNlLFxuICBIVE1MQ29sbGVjdGlvbjogZmFsc2UsXG4gIEhUTUxGb3JtRWxlbWVudDogZmFsc2UsXG4gIEhUTUxTZWxlY3RFbGVtZW50OiBmYWxzZSxcbiAgTWVkaWFMaXN0OiB0cnVlLCAvLyBUT0RPOiBOb3Qgc3BlYyBjb21wbGlhbnQsIHNob3VsZCBiZSBmYWxzZS5cbiAgTWltZVR5cGVBcnJheTogZmFsc2UsXG4gIE5hbWVkTm9kZU1hcDogZmFsc2UsXG4gIE5vZGVMaXN0OiB0cnVlLFxuICBQYWludFJlcXVlc3RMaXN0OiBmYWxzZSxcbiAgUGx1Z2luOiBmYWxzZSxcbiAgUGx1Z2luQXJyYXk6IGZhbHNlLFxuICBTVkdMZW5ndGhMaXN0OiBmYWxzZSxcbiAgU1ZHTnVtYmVyTGlzdDogZmFsc2UsXG4gIFNWR1BhdGhTZWdMaXN0OiBmYWxzZSxcbiAgU1ZHUG9pbnRMaXN0OiBmYWxzZSxcbiAgU1ZHU3RyaW5nTGlzdDogZmFsc2UsXG4gIFNWR1RyYW5zZm9ybUxpc3Q6IGZhbHNlLFxuICBTb3VyY2VCdWZmZXJMaXN0OiBmYWxzZSxcbiAgU3R5bGVTaGVldExpc3Q6IHRydWUsIC8vIFRPRE86IE5vdCBzcGVjIGNvbXBsaWFudCwgc2hvdWxkIGJlIGZhbHNlLlxuICBUZXh0VHJhY2tDdWVMaXN0OiBmYWxzZSxcbiAgVGV4dFRyYWNrTGlzdDogZmFsc2UsXG4gIFRvdWNoTGlzdDogZmFsc2Vcbn07XG5cbmZvciAodmFyIGNvbGxlY3Rpb25zID0gZ2V0S2V5cyhET01JdGVyYWJsZXMpLCBpID0gMDsgaSA8IGNvbGxlY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gIHZhciBOQU1FID0gY29sbGVjdGlvbnNbaV07XG4gIHZhciBleHBsaWNpdCA9IERPTUl0ZXJhYmxlc1tOQU1FXTtcbiAgdmFyIENvbGxlY3Rpb24gPSBnbG9iYWxbTkFNRV07XG4gIHZhciBwcm90byA9IENvbGxlY3Rpb24gJiYgQ29sbGVjdGlvbi5wcm90b3R5cGU7XG4gIHZhciBrZXk7XG4gIGlmIChwcm90bykge1xuICAgIGlmICghcHJvdG9bSVRFUkFUT1JdKSBoaWRlKHByb3RvLCBJVEVSQVRPUiwgQXJyYXlWYWx1ZXMpO1xuICAgIGlmICghcHJvdG9bVE9fU1RSSU5HX1RBR10pIGhpZGUocHJvdG8sIFRPX1NUUklOR19UQUcsIE5BTUUpO1xuICAgIEl0ZXJhdG9yc1tOQU1FXSA9IEFycmF5VmFsdWVzO1xuICAgIGlmIChleHBsaWNpdCkgZm9yIChrZXkgaW4gJGl0ZXJhdG9ycykgaWYgKCFwcm90b1trZXldKSByZWRlZmluZShwcm90bywga2V5LCAkaXRlcmF0b3JzW2tleV0sIHRydWUpO1xuICB9XG59XG4iLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICR0YXNrID0gcmVxdWlyZSgnLi9fdGFzaycpO1xuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LkIsIHtcbiAgc2V0SW1tZWRpYXRlOiAkdGFzay5zZXQsXG4gIGNsZWFySW1tZWRpYXRlOiAkdGFzay5jbGVhclxufSk7XG4iLCIvLyBpZTktIHNldFRpbWVvdXQgJiBzZXRJbnRlcnZhbCBhZGRpdGlvbmFsIHBhcmFtZXRlcnMgZml4XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIG5hdmlnYXRvciA9IGdsb2JhbC5uYXZpZ2F0b3I7XG52YXIgc2xpY2UgPSBbXS5zbGljZTtcbnZhciBNU0lFID0gISFuYXZpZ2F0b3IgJiYgL01TSUUgLlxcLi8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTsgLy8gPC0gZGlydHkgaWU5LSBjaGVja1xudmFyIHdyYXAgPSBmdW5jdGlvbiAoc2V0KSB7XG4gIHJldHVybiBmdW5jdGlvbiAoZm4sIHRpbWUgLyogLCAuLi5hcmdzICovKSB7XG4gICAgdmFyIGJvdW5kQXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyO1xuICAgIHZhciBhcmdzID0gYm91bmRBcmdzID8gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpIDogZmFsc2U7XG4gICAgcmV0dXJuIHNldChib3VuZEFyZ3MgPyBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LWZ1bmNcbiAgICAgICh0eXBlb2YgZm4gPT0gJ2Z1bmN0aW9uJyA/IGZuIDogRnVuY3Rpb24oZm4pKS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9IDogZm4sIHRpbWUpO1xuICB9O1xufTtcbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5CICsgJGV4cG9ydC5GICogTVNJRSwge1xuICBzZXRUaW1lb3V0OiB3cmFwKGdsb2JhbC5zZXRUaW1lb3V0KSxcbiAgc2V0SW50ZXJ2YWw6IHdyYXAoZ2xvYmFsLnNldEludGVydmFsKVxufSk7XG4iLCJyZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN5bWJvbCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuY3JlYXRlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydHknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmRlZmluZS1wcm9wZXJ0aWVzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3InKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmdldC1wcm90b3R5cGUtb2YnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmtleXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmdldC1vd24tcHJvcGVydHktbmFtZXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmZyZWV6ZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3Quc2VhbCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QucHJldmVudC1leHRlbnNpb25zJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5pcy1mcm96ZW4nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmlzLXNlYWxlZCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuaXMtZXh0ZW5zaWJsZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuYXNzaWduJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5pcycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3Quc2V0LXByb3RvdHlwZS1vZicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmZ1bmN0aW9uLmJpbmQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuZnVuY3Rpb24ubmFtZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5mdW5jdGlvbi5oYXMtaW5zdGFuY2UnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucGFyc2UtaW50Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnBhcnNlLWZsb2F0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci5jb25zdHJ1Y3RvcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIudG8tZml4ZWQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLnRvLXByZWNpc2lvbicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIuZXBzaWxvbicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIuaXMtZmluaXRlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci5pcy1pbnRlZ2VyJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci5pcy1uYW4nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLmlzLXNhZmUtaW50ZWdlcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIubWF4LXNhZmUtaW50ZWdlcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIubWluLXNhZmUtaW50ZWdlcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIucGFyc2UtZmxvYXQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLnBhcnNlLWludCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmFjb3NoJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGguYXNpbmgnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5hdGFuaCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmNicnQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5jbHozMicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmNvc2gnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5leHBtMScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmZyb3VuZCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmh5cG90Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGguaW11bCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmxvZzEwJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGgubG9nMXAnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5sb2cyJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGguc2lnbicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLnNpbmgnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC50YW5oJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGgudHJ1bmMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmZyb20tY29kZS1wb2ludCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcucmF3Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy50cmltJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuY29kZS1wb2ludC1hdCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuZW5kcy13aXRoJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5pbmNsdWRlcycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcucmVwZWF0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5zdGFydHMtd2l0aCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuYW5jaG9yJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5iaWcnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmJsaW5rJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5ib2xkJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5maXhlZCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuZm9udGNvbG9yJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5mb250c2l6ZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuaXRhbGljcycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcubGluaycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuc21hbGwnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLnN0cmlrZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuc3ViJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5zdXAnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuZGF0ZS5ub3cnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuZGF0ZS50by1qc29uJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmRhdGUudG8taXNvLXN0cmluZycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5kYXRlLnRvLXN0cmluZycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5kYXRlLnRvLXByaW1pdGl2ZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5pcy1hcnJheScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5mcm9tJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5Lm9mJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LmpvaW4nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuc2xpY2UnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuc29ydCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5mb3ItZWFjaCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5tYXAnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuZmlsdGVyJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LnNvbWUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuZXZlcnknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkucmVkdWNlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LnJlZHVjZS1yaWdodCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5pbmRleC1vZicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5sYXN0LWluZGV4LW9mJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LmNvcHktd2l0aGluJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LmZpbGwnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuZmluZCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5maW5kLWluZGV4Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LnNwZWNpZXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuaXRlcmF0b3InKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVnZXhwLmNvbnN0cnVjdG9yJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZ2V4cC50by1zdHJpbmcnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVnZXhwLmZsYWdzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZ2V4cC5tYXRjaCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWdleHAucmVwbGFjZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWdleHAuc2VhcmNoJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZ2V4cC5zcGxpdCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5wcm9taXNlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hcCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zZXQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYud2Vhay1tYXAnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYud2Vhay1zZXQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYudHlwZWQuYXJyYXktYnVmZmVyJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnR5cGVkLmRhdGEtdmlldycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi50eXBlZC5pbnQ4LWFycmF5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnR5cGVkLnVpbnQ4LWFycmF5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnR5cGVkLnVpbnQ4LWNsYW1wZWQtYXJyYXknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYudHlwZWQuaW50MTYtYXJyYXknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYudHlwZWQudWludDE2LWFycmF5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnR5cGVkLmludDMyLWFycmF5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnR5cGVkLnVpbnQzMi1hcnJheScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi50eXBlZC5mbG9hdDMyLWFycmF5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnR5cGVkLmZsb2F0NjQtYXJyYXknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5hcHBseScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LmNvbnN0cnVjdCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LmRlZmluZS1wcm9wZXJ0eScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LmRlbGV0ZS1wcm9wZXJ0eScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LmVudW1lcmF0ZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LmdldCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LmdldC1wcm90b3R5cGUtb2YnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5oYXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5pcy1leHRlbnNpYmxlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3Qub3duLWtleXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5wcmV2ZW50LWV4dGVuc2lvbnMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5zZXQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5zZXQtcHJvdG90eXBlLW9mJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LmFycmF5LmluY2x1ZGVzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LmFycmF5LmZsYXQtbWFwJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LmFycmF5LmZsYXR0ZW4nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuc3RyaW5nLmF0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnN0cmluZy5wYWQtc3RhcnQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuc3RyaW5nLnBhZC1lbmQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuc3RyaW5nLnRyaW0tbGVmdCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5zdHJpbmcudHJpbS1yaWdodCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5zdHJpbmcubWF0Y2gtYWxsJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnN5bWJvbC5hc3luYy1pdGVyYXRvcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5zeW1ib2wub2JzZXJ2YWJsZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9ycycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5vYmplY3QudmFsdWVzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm9iamVjdC5lbnRyaWVzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm9iamVjdC5kZWZpbmUtZ2V0dGVyJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm9iamVjdC5kZWZpbmUtc2V0dGVyJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm9iamVjdC5sb29rdXAtZ2V0dGVyJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm9iamVjdC5sb29rdXAtc2V0dGVyJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm1hcC50by1qc29uJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnNldC50by1qc29uJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm1hcC5vZicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5zZXQub2YnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcud2Vhay1tYXAub2YnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcud2Vhay1zZXQub2YnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcubWFwLmZyb20nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuc2V0LmZyb20nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcud2Vhay1tYXAuZnJvbScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy53ZWFrLXNldC5mcm9tJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lmdsb2JhbCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5zeXN0ZW0uZ2xvYmFsJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LmVycm9yLmlzLWVycm9yJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm1hdGguY2xhbXAnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcubWF0aC5kZWctcGVyLXJhZCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5tYXRoLmRlZ3JlZXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcubWF0aC5mc2NhbGUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcubWF0aC5pYWRkaCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5tYXRoLmlzdWJoJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm1hdGguaW11bGgnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcubWF0aC5yYWQtcGVyLWRlZycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5tYXRoLnJhZGlhbnMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcubWF0aC5zY2FsZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5tYXRoLnVtdWxoJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm1hdGguc2lnbmJpdCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5wcm9taXNlLmZpbmFsbHknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcucHJvbWlzZS50cnknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcucmVmbGVjdC5kZWZpbmUtbWV0YWRhdGEnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcucmVmbGVjdC5kZWxldGUtbWV0YWRhdGEnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcucmVmbGVjdC5nZXQtbWV0YWRhdGEnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcucmVmbGVjdC5nZXQtbWV0YWRhdGEta2V5cycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5yZWZsZWN0LmdldC1vd24tbWV0YWRhdGEnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcucmVmbGVjdC5nZXQtb3duLW1ldGFkYXRhLWtleXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcucmVmbGVjdC5oYXMtbWV0YWRhdGEnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcucmVmbGVjdC5oYXMtb3duLW1ldGFkYXRhJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnJlZmxlY3QubWV0YWRhdGEnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuYXNhcCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5vYnNlcnZhYmxlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvd2ViLnRpbWVycycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL3dlYi5pbW1lZGlhdGUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbW9kdWxlcy9fY29yZScpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0c1snZGVmYXVsdCddID0gY2FtZWxpemU7XG52YXIgcmVnRXhwID0gL1stXFxzXSsoLik/L2c7XG5cbi8qKlxuICogQ29udmVydCBkYXNoIHNlcGFyYXRlZCBzdHJpbmdzIHRvIGNhbWVsIGNhc2VkLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuZnVuY3Rpb24gY2FtZWxpemUoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZShyZWdFeHAsIHRvVXBwZXIpO1xufVxuXG5mdW5jdGlvbiB0b1VwcGVyKG1hdGNoLCBjKSB7XG4gIHJldHVybiBjID8gYy50b1VwcGVyQ2FzZSgpIDogJyc7XG59IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5zdXBwb3J0ZWRWYWx1ZSA9IGV4cG9ydHMuc3VwcG9ydGVkUHJvcGVydHkgPSBleHBvcnRzLnByZWZpeCA9IHVuZGVmaW5lZDtcblxudmFyIF9wcmVmaXggPSByZXF1aXJlKCcuL3ByZWZpeCcpO1xuXG52YXIgX3ByZWZpeDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wcmVmaXgpO1xuXG52YXIgX3N1cHBvcnRlZFByb3BlcnR5ID0gcmVxdWlyZSgnLi9zdXBwb3J0ZWQtcHJvcGVydHknKTtcblxudmFyIF9zdXBwb3J0ZWRQcm9wZXJ0eTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zdXBwb3J0ZWRQcm9wZXJ0eSk7XG5cbnZhciBfc3VwcG9ydGVkVmFsdWUgPSByZXF1aXJlKCcuL3N1cHBvcnRlZC12YWx1ZScpO1xuXG52YXIgX3N1cHBvcnRlZFZhbHVlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3N1cHBvcnRlZFZhbHVlKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5leHBvcnRzWydkZWZhdWx0J10gPSB7XG4gIHByZWZpeDogX3ByZWZpeDJbJ2RlZmF1bHQnXSxcbiAgc3VwcG9ydGVkUHJvcGVydHk6IF9zdXBwb3J0ZWRQcm9wZXJ0eTJbJ2RlZmF1bHQnXSxcbiAgc3VwcG9ydGVkVmFsdWU6IF9zdXBwb3J0ZWRWYWx1ZTJbJ2RlZmF1bHQnXVxufTsgLyoqXG4gICAgKiBDU1MgVmVuZG9yIHByZWZpeCBkZXRlY3Rpb24gYW5kIHByb3BlcnR5IGZlYXR1cmUgdGVzdGluZy5cbiAgICAqXG4gICAgKiBAY29weXJpZ2h0IE9sZWcgU2xvYm9kc2tvaSAyMDE1XG4gICAgKiBAd2Vic2l0ZSBodHRwczovL2dpdGh1Yi5jb20vanNzdHlsZXMvY3NzLXZlbmRvclxuICAgICogQGxpY2Vuc2UgTUlUXG4gICAgKi9cblxuZXhwb3J0cy5wcmVmaXggPSBfcHJlZml4MlsnZGVmYXVsdCddO1xuZXhwb3J0cy5zdXBwb3J0ZWRQcm9wZXJ0eSA9IF9zdXBwb3J0ZWRQcm9wZXJ0eTJbJ2RlZmF1bHQnXTtcbmV4cG9ydHMuc3VwcG9ydGVkVmFsdWUgPSBfc3VwcG9ydGVkVmFsdWUyWydkZWZhdWx0J107IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2lzSW5Ccm93c2VyID0gcmVxdWlyZSgnaXMtaW4tYnJvd3NlcicpO1xuXG52YXIgX2lzSW5Ccm93c2VyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2lzSW5Ccm93c2VyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIganMgPSAnJzsgLyoqXG4gICAgICAgICAgICAgICogRXhwb3J0IGphdmFzY3JpcHQgc3R5bGUgYW5kIGNzcyBzdHlsZSB2ZW5kb3IgcHJlZml4ZXMuXG4gICAgICAgICAgICAgICogQmFzZWQgb24gXCJ0cmFuc2Zvcm1cIiBzdXBwb3J0IHRlc3QuXG4gICAgICAgICAgICAgICovXG5cbnZhciBjc3MgPSAnJztcblxuLy8gV2Ugc2hvdWxkIG5vdCBkbyBhbnl0aGluZyBpZiByZXF1aXJlZCBzZXJ2ZXJzaWRlLlxuaWYgKF9pc0luQnJvd3NlcjJbJ2RlZmF1bHQnXSkge1xuICAvLyBPcmRlciBtYXR0ZXJzLiBXZSBuZWVkIHRvIGNoZWNrIFdlYmtpdCB0aGUgbGFzdCBvbmUgYmVjYXVzZVxuICAvLyBvdGhlciB2ZW5kb3JzIHVzZSB0byBhZGQgV2Via2l0IHByZWZpeGVzIHRvIHNvbWUgcHJvcGVydGllc1xuICB2YXIganNDc3NNYXAgPSB7XG4gICAgTW96OiAnLW1vei0nLFxuICAgIC8vIElFIGRpZCBpdCB3cm9uZyBhZ2FpbiAuLi5cbiAgICBtczogJy1tcy0nLFxuICAgIE86ICctby0nLFxuICAgIFdlYmtpdDogJy13ZWJraXQtJ1xuICB9O1xuICB2YXIgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwJykuc3R5bGU7XG4gIHZhciB0ZXN0UHJvcCA9ICdUcmFuc2Zvcm0nO1xuXG4gIGZvciAodmFyIGtleSBpbiBqc0Nzc01hcCkge1xuICAgIGlmIChrZXkgKyB0ZXN0UHJvcCBpbiBzdHlsZSkge1xuICAgICAganMgPSBrZXk7XG4gICAgICBjc3MgPSBqc0Nzc01hcFtrZXldO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogVmVuZG9yIHByZWZpeCBzdHJpbmcgZm9yIHRoZSBjdXJyZW50IGJyb3dzZXIuXG4gKlxuICogQHR5cGUge3tqczogU3RyaW5nLCBjc3M6IFN0cmluZ319XG4gKiBAYXBpIHB1YmxpY1xuICovXG5leHBvcnRzWydkZWZhdWx0J10gPSB7IGpzOiBqcywgY3NzOiBjc3MgfTsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzWydkZWZhdWx0J10gPSBzdXBwb3J0ZWRQcm9wZXJ0eTtcblxudmFyIF9pc0luQnJvd3NlciA9IHJlcXVpcmUoJ2lzLWluLWJyb3dzZXInKTtcblxudmFyIF9pc0luQnJvd3NlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pc0luQnJvd3Nlcik7XG5cbnZhciBfcHJlZml4ID0gcmVxdWlyZSgnLi9wcmVmaXgnKTtcblxudmFyIF9wcmVmaXgyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcHJlZml4KTtcblxudmFyIF9jYW1lbGl6ZSA9IHJlcXVpcmUoJy4vY2FtZWxpemUnKTtcblxudmFyIF9jYW1lbGl6ZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jYW1lbGl6ZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIGVsID0gdm9pZCAwO1xudmFyIGNhY2hlID0ge307XG5cbmlmIChfaXNJbkJyb3dzZXIyWydkZWZhdWx0J10pIHtcbiAgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwJyk7XG5cbiAgLyoqXG4gICAqIFdlIHRlc3QgZXZlcnkgcHJvcGVydHkgb24gdmVuZG9yIHByZWZpeCByZXF1aXJlbWVudC5cbiAgICogT25jZSB0ZXN0ZWQsIHJlc3VsdCBpcyBjYWNoZWQuIEl0IGdpdmVzIHVzIHVwIHRvIDcwJSBwZXJmIGJvb3N0LlxuICAgKiBodHRwOi8vanNwZXJmLmNvbS9lbGVtZW50LXN0eWxlLW9iamVjdC1hY2Nlc3MtdnMtcGxhaW4tb2JqZWN0XG4gICAqXG4gICAqIFByZWZpbGwgY2FjaGUgd2l0aCBrbm93biBjc3MgcHJvcGVydGllcyB0byByZWR1Y2UgYW1vdW50IG9mXG4gICAqIHByb3BlcnRpZXMgd2UgbmVlZCB0byBmZWF0dXJlIHRlc3QgYXQgcnVudGltZS5cbiAgICogaHR0cDovL2Rhdmlkd2Fsc2gubmFtZS92ZW5kb3ItcHJlZml4XG4gICAqL1xuICB2YXIgY29tcHV0ZWQgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsICcnKTtcbiAgZm9yICh2YXIga2V5IGluIGNvbXB1dGVkKSB7XG4gICAgaWYgKCFpc05hTihrZXkpKSBjYWNoZVtjb21wdXRlZFtrZXldXSA9IGNvbXB1dGVkW2tleV07XG4gIH1cbn1cblxuLyoqXG4gKiBUZXN0IGlmIGEgcHJvcGVydHkgaXMgc3VwcG9ydGVkLCByZXR1cm5zIHN1cHBvcnRlZCBwcm9wZXJ0eSB3aXRoIHZlbmRvclxuICogcHJlZml4IGlmIHJlcXVpcmVkLiBSZXR1cm5zIGBmYWxzZWAgaWYgbm90IHN1cHBvcnRlZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJvcCBkYXNoIHNlcGFyYXRlZFxuICogQHJldHVybiB7U3RyaW5nfEJvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5mdW5jdGlvbiBzdXBwb3J0ZWRQcm9wZXJ0eShwcm9wKSB7XG4gIC8vIEZvciBzZXJ2ZXItc2lkZSByZW5kZXJpbmcuXG4gIGlmICghZWwpIHJldHVybiBwcm9wO1xuXG4gIC8vIFdlIGhhdmUgbm90IHRlc3RlZCB0aGlzIHByb3AgeWV0LCBsZXRzIGRvIHRoZSB0ZXN0LlxuICBpZiAoY2FjaGVbcHJvcF0gIT0gbnVsbCkgcmV0dXJuIGNhY2hlW3Byb3BdO1xuXG4gIC8vIENhbWVsaXphdGlvbiBpcyByZXF1aXJlZCBiZWNhdXNlIHdlIGNhbid0IHRlc3QgdXNpbmdcbiAgLy8gY3NzIHN5bnRheCBmb3IgZS5nLiBpbiBGRi5cbiAgLy8gVGVzdCBpZiBwcm9wZXJ0eSBpcyBzdXBwb3J0ZWQgYXMgaXQgaXMuXG4gIGlmICgoMCwgX2NhbWVsaXplMlsnZGVmYXVsdCddKShwcm9wKSBpbiBlbC5zdHlsZSkge1xuICAgIGNhY2hlW3Byb3BdID0gcHJvcDtcbiAgfVxuICAvLyBUZXN0IGlmIHByb3BlcnR5IGlzIHN1cHBvcnRlZCB3aXRoIHZlbmRvciBwcmVmaXguXG4gIGVsc2UgaWYgKF9wcmVmaXgyWydkZWZhdWx0J10uanMgKyAoMCwgX2NhbWVsaXplMlsnZGVmYXVsdCddKSgnLScgKyBwcm9wKSBpbiBlbC5zdHlsZSkge1xuICAgICAgY2FjaGVbcHJvcF0gPSBfcHJlZml4MlsnZGVmYXVsdCddLmNzcyArIHByb3A7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhY2hlW3Byb3BdID0gZmFsc2U7XG4gICAgfVxuXG4gIHJldHVybiBjYWNoZVtwcm9wXTtcbn0iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzWydkZWZhdWx0J10gPSBzdXBwb3J0ZWRWYWx1ZTtcblxudmFyIF9pc0luQnJvd3NlciA9IHJlcXVpcmUoJ2lzLWluLWJyb3dzZXInKTtcblxudmFyIF9pc0luQnJvd3NlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pc0luQnJvd3Nlcik7XG5cbnZhciBfcHJlZml4ID0gcmVxdWlyZSgnLi9wcmVmaXgnKTtcblxudmFyIF9wcmVmaXgyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcHJlZml4KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgY2FjaGUgPSB7fTtcbnZhciBlbCA9IHZvaWQgMDtcblxuaWYgKF9pc0luQnJvd3NlcjJbJ2RlZmF1bHQnXSkgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwJyk7XG5cbi8qKlxuICogUmV0dXJucyBwcmVmaXhlZCB2YWx1ZSBpZiBuZWVkZWQuIFJldHVybnMgYGZhbHNlYCBpZiB2YWx1ZSBpcyBub3Qgc3VwcG9ydGVkLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eVxuICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gKiBAcmV0dXJuIHtTdHJpbmd8Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIHN1cHBvcnRlZFZhbHVlKHByb3BlcnR5LCB2YWx1ZSkge1xuICAvLyBGb3Igc2VydmVyLXNpZGUgcmVuZGVyaW5nLlxuICBpZiAoIWVsKSByZXR1cm4gdmFsdWU7XG5cbiAgLy8gSXQgaXMgYSBzdHJpbmcgb3IgYSBudW1iZXIgYXMgYSBzdHJpbmcgbGlrZSAnMScuXG4gIC8vIFdlIHdhbnQgb25seSBwcmVmaXhhYmxlIHZhbHVlcyBoZXJlLlxuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJyB8fCAhaXNOYU4ocGFyc2VJbnQodmFsdWUsIDEwKSkpIHJldHVybiB2YWx1ZTtcblxuICB2YXIgY2FjaGVLZXkgPSBwcm9wZXJ0eSArIHZhbHVlO1xuXG4gIGlmIChjYWNoZVtjYWNoZUtleV0gIT0gbnVsbCkgcmV0dXJuIGNhY2hlW2NhY2hlS2V5XTtcblxuICAvLyBJRSBjYW4gZXZlbiB0aHJvdyBhbiBlcnJvciBpbiBzb21lIGNhc2VzLCBmb3IgZS5nLiBzdHlsZS5jb250ZW50ID0gJ2JhcidcbiAgdHJ5IHtcbiAgICAvLyBUZXN0IHZhbHVlIGFzIGl0IGlzLlxuICAgIGVsLnN0eWxlW3Byb3BlcnR5XSA9IHZhbHVlO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjYWNoZVtjYWNoZUtleV0gPSBmYWxzZTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBWYWx1ZSBpcyBzdXBwb3J0ZWQgYXMgaXQgaXMuXG4gIGlmIChlbC5zdHlsZVtwcm9wZXJ0eV0gIT09ICcnKSB7XG4gICAgY2FjaGVbY2FjaGVLZXldID0gdmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgLy8gVGVzdCB2YWx1ZSB3aXRoIHZlbmRvciBwcmVmaXguXG4gICAgdmFsdWUgPSBfcHJlZml4MlsnZGVmYXVsdCddLmNzcyArIHZhbHVlO1xuXG4gICAgLy8gSGFyZGNvZGUgdGVzdCB0byBjb252ZXJ0IFwiZmxleFwiIHRvIFwiLW1zLWZsZXhib3hcIiBmb3IgSUUxMC5cbiAgICBpZiAodmFsdWUgPT09ICctbXMtZmxleCcpIHZhbHVlID0gJy1tcy1mbGV4Ym94JztcblxuICAgIGVsLnN0eWxlW3Byb3BlcnR5XSA9IHZhbHVlO1xuXG4gICAgLy8gVmFsdWUgaXMgc3VwcG9ydGVkIHdpdGggdmVuZG9yIHByZWZpeC5cbiAgICBpZiAoZWwuc3R5bGVbcHJvcGVydHldICE9PSAnJykgY2FjaGVbY2FjaGVLZXldID0gdmFsdWU7XG4gIH1cblxuICBpZiAoIWNhY2hlW2NhY2hlS2V5XSkgY2FjaGVbY2FjaGVLZXldID0gZmFsc2U7XG5cbiAgLy8gUmVzZXQgc3R5bGUgdmFsdWUuXG4gIGVsLnN0eWxlW3Byb3BlcnR5XSA9ICcnO1xuXG4gIHJldHVybiBjYWNoZVtjYWNoZUtleV07XG59IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbnZhciBpc1ZhbGlkU3RyaW5nID0gZnVuY3Rpb24gaXNWYWxpZFN0cmluZyhwYXJhbSkge1xuICByZXR1cm4gdHlwZW9mIHBhcmFtID09PSAnc3RyaW5nJyAmJiBwYXJhbS5sZW5ndGggPiAwO1xufTtcblxudmFyIHN0YXJ0c1dpdGggPSBmdW5jdGlvbiBzdGFydHNXaXRoKHN0cmluZywgc3RhcnQpIHtcbiAgcmV0dXJuIHN0cmluZ1swXSA9PT0gc3RhcnQ7XG59O1xuXG52YXIgaXNTZWxlY3RvciA9IGZ1bmN0aW9uIGlzU2VsZWN0b3IocGFyYW0pIHtcbiAgcmV0dXJuIGlzVmFsaWRTdHJpbmcocGFyYW0pICYmIChzdGFydHNXaXRoKHBhcmFtLCAnLicpIHx8IHN0YXJ0c1dpdGgocGFyYW0sICcjJykpO1xufTtcblxudmFyIG5vZGUgPSBmdW5jdGlvbiBub2RlKGgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh0YWdOYW1lKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChmaXJzdCkge1xuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHJlc3QgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIHJlc3RbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNTZWxlY3RvcihmaXJzdCkpIHtcbiAgICAgICAgcmV0dXJuIGguYXBwbHkodW5kZWZpbmVkLCBbdGFnTmFtZSArIGZpcnN0XS5jb25jYXQocmVzdCkpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZmlyc3QgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBoKHRhZ05hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGguYXBwbHkodW5kZWZpbmVkLCBbdGFnTmFtZSwgZmlyc3RdLmNvbmNhdChyZXN0KSk7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcbn07XG5cbnZhciBUQUdfTkFNRVMgPSBbJ2EnLCAnYWJicicsICdhY3JvbnltJywgJ2FkZHJlc3MnLCAnYXBwbGV0JywgJ2FyZWEnLCAnYXJ0aWNsZScsICdhc2lkZScsICdhdWRpbycsICdiJywgJ2Jhc2UnLCAnYmFzZWZvbnQnLCAnYmRpJywgJ2JkbycsICdiZ3NvdW5kJywgJ2JpZycsICdibGluaycsICdibG9ja3F1b3RlJywgJ2JvZHknLCAnYnInLCAnYnV0dG9uJywgJ2NhbnZhcycsICdjYXB0aW9uJywgJ2NlbnRlcicsICdjaXRlJywgJ2NvZGUnLCAnY29sJywgJ2NvbGdyb3VwJywgJ2NvbW1hbmQnLCAnY29udGVudCcsICdkYXRhJywgJ2RhdGFsaXN0JywgJ2RkJywgJ2RlbCcsICdkZXRhaWxzJywgJ2RmbicsICdkaWFsb2cnLCAnZGlyJywgJ2RpdicsICdkbCcsICdkdCcsICdlbGVtZW50JywgJ2VtJywgJ2VtYmVkJywgJ2ZpZWxkc2V0JywgJ2ZpZ2NhcHRpb24nLCAnZmlndXJlJywgJ2ZvbnQnLCAnZm9vdGVyJywgJ2Zvcm0nLCAnZnJhbWUnLCAnZnJhbWVzZXQnLCAnaDEnLCAnaDInLCAnaDMnLCAnaDQnLCAnaDUnLCAnaDYnLCAnaGVhZCcsICdoZWFkZXInLCAnaGdyb3VwJywgJ2hyJywgJ2h0bWwnLCAnaScsICdpZnJhbWUnLCAnaW1hZ2UnLCAnaW1nJywgJ2lucHV0JywgJ2lucycsICdpc2luZGV4JywgJ2tiZCcsICdrZXlnZW4nLCAnbGFiZWwnLCAnbGVnZW5kJywgJ2xpJywgJ2xpbmsnLCAnbGlzdGluZycsICdtYWluJywgJ21hcCcsICdtYXJrJywgJ21hcnF1ZWUnLCAnbWF0aCcsICdtZW51JywgJ21lbnVpdGVtJywgJ21ldGEnLCAnbWV0ZXInLCAnbXVsdGljb2wnLCAnbmF2JywgJ25leHRpZCcsICdub2JyJywgJ25vZW1iZWQnLCAnbm9mcmFtZXMnLCAnbm9zY3JpcHQnLCAnb2JqZWN0JywgJ29sJywgJ29wdGdyb3VwJywgJ29wdGlvbicsICdvdXRwdXQnLCAncCcsICdwYXJhbScsICdwaWN0dXJlJywgJ3BsYWludGV4dCcsICdwcmUnLCAncHJvZ3Jlc3MnLCAncScsICdyYicsICdyYmMnLCAncnAnLCAncnQnLCAncnRjJywgJ3J1YnknLCAncycsICdzYW1wJywgJ3NjcmlwdCcsICdzZWN0aW9uJywgJ3NlbGVjdCcsICdzaGFkb3cnLCAnc2xvdCcsICdzbWFsbCcsICdzb3VyY2UnLCAnc3BhY2VyJywgJ3NwYW4nLCAnc3RyaWtlJywgJ3N0cm9uZycsICdzdHlsZScsICdzdWInLCAnc3VtbWFyeScsICdzdXAnLCAnc3ZnJywgJ3RhYmxlJywgJ3Rib2R5JywgJ3RkJywgJ3RlbXBsYXRlJywgJ3RleHRhcmVhJywgJ3Rmb290JywgJ3RoJywgJ3RoZWFkJywgJ3RpbWUnLCAndGl0bGUnLCAndHInLCAndHJhY2snLCAndHQnLCAndScsICd1bCcsICd2YXInLCAndmlkZW8nLCAnd2JyJywgJ3htcCddO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBmdW5jdGlvbiAoaCkge1xuICB2YXIgY3JlYXRlVGFnID0gbm9kZShoKTtcbiAgdmFyIGV4cG9ydGVkID0geyBUQUdfTkFNRVM6IFRBR19OQU1FUywgaXNTZWxlY3RvcjogaXNTZWxlY3RvciwgY3JlYXRlVGFnOiBjcmVhdGVUYWcgfTtcbiAgVEFHX05BTUVTLmZvckVhY2goZnVuY3Rpb24gKG4pIHtcbiAgICBleHBvcnRlZFtuXSA9IGNyZWF0ZVRhZyhuKTtcbiAgfSk7XG4gIHJldHVybiBleHBvcnRlZDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsInZhciBzcGxpdCA9IHJlcXVpcmUoJ2Jyb3dzZXItc3BsaXQnKVxudmFyIENsYXNzTGlzdCA9IHJlcXVpcmUoJ2NsYXNzLWxpc3QnKVxuXG52YXIgdyA9IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID8gcmVxdWlyZSgnaHRtbC1lbGVtZW50JykgOiB3aW5kb3dcbnZhciBkb2N1bWVudCA9IHcuZG9jdW1lbnRcbnZhciBUZXh0ID0gdy5UZXh0XG5cbmZ1bmN0aW9uIGNvbnRleHQgKCkge1xuXG4gIHZhciBjbGVhbnVwRnVuY3MgPSBbXVxuXG4gIGZ1bmN0aW9uIGgoKSB7XG4gICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cyksIGUgPSBudWxsXG4gICAgZnVuY3Rpb24gaXRlbSAobCkge1xuICAgICAgdmFyIHJcbiAgICAgIGZ1bmN0aW9uIHBhcnNlQ2xhc3MgKHN0cmluZykge1xuICAgICAgICAvLyBPdXIgbWluaW1hbCBwYXJzZXIgZG9lc27igJl0IHVuZGVyc3RhbmQgZXNjYXBpbmcgQ1NTIHNwZWNpYWxcbiAgICAgICAgLy8gY2hhcmFjdGVycyBsaWtlIGAjYC4gRG9u4oCZdCB1c2UgdGhlbS4gTW9yZSByZWFkaW5nOlxuICAgICAgICAvLyBodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvY3NzLWVzY2FwZXMgLlxuXG4gICAgICAgIHZhciBtID0gc3BsaXQoc3RyaW5nLCAvKFtcXC4jXT9bXlxccyMuXSspLylcbiAgICAgICAgaWYoL15cXC58Iy8udGVzdChtWzFdKSlcbiAgICAgICAgICBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICAgICAgZm9yRWFjaChtLCBmdW5jdGlvbiAodikge1xuICAgICAgICAgIHZhciBzID0gdi5zdWJzdHJpbmcoMSx2Lmxlbmd0aClcbiAgICAgICAgICBpZighdikgcmV0dXJuXG4gICAgICAgICAgaWYoIWUpXG4gICAgICAgICAgICBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh2KVxuICAgICAgICAgIGVsc2UgaWYgKHZbMF0gPT09ICcuJylcbiAgICAgICAgICAgIENsYXNzTGlzdChlKS5hZGQocylcbiAgICAgICAgICBlbHNlIGlmICh2WzBdID09PSAnIycpXG4gICAgICAgICAgICBlLnNldEF0dHJpYnV0ZSgnaWQnLCBzKVxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICBpZihsID09IG51bGwpXG4gICAgICAgIDtcbiAgICAgIGVsc2UgaWYoJ3N0cmluZycgPT09IHR5cGVvZiBsKSB7XG4gICAgICAgIGlmKCFlKVxuICAgICAgICAgIHBhcnNlQ2xhc3MobClcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGUuYXBwZW5kQ2hpbGQociA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGwpKVxuICAgICAgfVxuICAgICAgZWxzZSBpZignbnVtYmVyJyA9PT0gdHlwZW9mIGxcbiAgICAgICAgfHwgJ2Jvb2xlYW4nID09PSB0eXBlb2YgbFxuICAgICAgICB8fCBsIGluc3RhbmNlb2YgRGF0ZVxuICAgICAgICB8fCBsIGluc3RhbmNlb2YgUmVnRXhwICkge1xuICAgICAgICAgIGUuYXBwZW5kQ2hpbGQociA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGwudG9TdHJpbmcoKSkpXG4gICAgICB9XG4gICAgICAvL3RoZXJlIG1pZ2h0IGJlIGEgYmV0dGVyIHdheSB0byBoYW5kbGUgdGhpcy4uLlxuICAgICAgZWxzZSBpZiAoaXNBcnJheShsKSlcbiAgICAgICAgZm9yRWFjaChsLCBpdGVtKVxuICAgICAgZWxzZSBpZihpc05vZGUobCkpXG4gICAgICAgIGUuYXBwZW5kQ2hpbGQociA9IGwpXG4gICAgICBlbHNlIGlmKGwgaW5zdGFuY2VvZiBUZXh0KVxuICAgICAgICBlLmFwcGVuZENoaWxkKHIgPSBsKVxuICAgICAgZWxzZSBpZiAoJ29iamVjdCcgPT09IHR5cGVvZiBsKSB7XG4gICAgICAgIGZvciAodmFyIGsgaW4gbCkge1xuICAgICAgICAgIGlmKCdmdW5jdGlvbicgPT09IHR5cGVvZiBsW2tdKSB7XG4gICAgICAgICAgICBpZigvXm9uXFx3Ky8udGVzdChrKSkge1xuICAgICAgICAgICAgICAoZnVuY3Rpb24gKGssIGwpIHsgLy8gY2FwdHVyZSBrLCBsIGluIHRoZSBjbG9zdXJlXG4gICAgICAgICAgICAgICAgaWYgKGUuYWRkRXZlbnRMaXN0ZW5lcil7XG4gICAgICAgICAgICAgICAgICBlLmFkZEV2ZW50TGlzdGVuZXIoay5zdWJzdHJpbmcoMiksIGxba10sIGZhbHNlKVxuICAgICAgICAgICAgICAgICAgY2xlYW51cEZ1bmNzLnB1c2goZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgZS5yZW1vdmVFdmVudExpc3RlbmVyKGsuc3Vic3RyaW5nKDIpLCBsW2tdLCBmYWxzZSlcbiAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgICBlLmF0dGFjaEV2ZW50KGssIGxba10pXG4gICAgICAgICAgICAgICAgICBjbGVhbnVwRnVuY3MucHVzaChmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICBlLmRldGFjaEV2ZW50KGssIGxba10pXG4gICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSkoaywgbClcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIG9ic2VydmFibGVcbiAgICAgICAgICAgICAgZVtrXSA9IGxba10oKVxuICAgICAgICAgICAgICBjbGVhbnVwRnVuY3MucHVzaChsW2tdKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgICAgZVtrXSA9IHZcbiAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYoayA9PT0gJ3N0eWxlJykge1xuICAgICAgICAgICAgaWYoJ3N0cmluZycgPT09IHR5cGVvZiBsW2tdKSB7XG4gICAgICAgICAgICAgIGUuc3R5bGUuY3NzVGV4dCA9IGxba11cbiAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICBmb3IgKHZhciBzIGluIGxba10pIChmdW5jdGlvbihzLCB2KSB7XG4gICAgICAgICAgICAgICAgaWYoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIHYpIHtcbiAgICAgICAgICAgICAgICAgIC8vIG9ic2VydmFibGVcbiAgICAgICAgICAgICAgICAgIGUuc3R5bGUuc2V0UHJvcGVydHkocywgdigpKVxuICAgICAgICAgICAgICAgICAgY2xlYW51cEZ1bmNzLnB1c2godihmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIGUuc3R5bGUuc2V0UHJvcGVydHkocywgdmFsKVxuICAgICAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgICB2YXIgbWF0Y2ggPSBsW2tdW3NdLm1hdGNoKC8oLiopXFxXKyFpbXBvcnRhbnRcXFcqJC8pO1xuICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGUuc3R5bGUuc2V0UHJvcGVydHkocywgbWF0Y2hbMV0sICdpbXBvcnRhbnQnKVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZS5zdHlsZS5zZXRQcm9wZXJ0eShzLCBsW2tdW3NdKVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KShzLCBsW2tdW3NdKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZihrID09PSAnYXR0cnMnKSB7XG4gICAgICAgICAgICBmb3IgKHZhciB2IGluIGxba10pIHtcbiAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUodiwgbFtrXVt2XSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoay5zdWJzdHIoMCwgNSkgPT09IFwiZGF0YS1cIikge1xuICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoaywgbFtrXSlcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZVtrXSA9IGxba11cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGwpIHtcbiAgICAgICAgLy9hc3N1bWUgaXQncyBhbiBvYnNlcnZhYmxlIVxuICAgICAgICB2YXIgdiA9IGwoKVxuICAgICAgICBlLmFwcGVuZENoaWxkKHIgPSBpc05vZGUodikgPyB2IDogZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodikpXG5cbiAgICAgICAgY2xlYW51cEZ1bmNzLnB1c2gobChmdW5jdGlvbiAodikge1xuICAgICAgICAgIGlmKGlzTm9kZSh2KSAmJiByLnBhcmVudEVsZW1lbnQpXG4gICAgICAgICAgICByLnBhcmVudEVsZW1lbnQucmVwbGFjZUNoaWxkKHYsIHIpLCByID0gdlxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHIudGV4dENvbnRlbnQgPSB2XG4gICAgICAgIH0pKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gclxuICAgIH1cbiAgICB3aGlsZShhcmdzLmxlbmd0aClcbiAgICAgIGl0ZW0oYXJncy5zaGlmdCgpKVxuXG4gICAgcmV0dXJuIGVcbiAgfVxuXG4gIGguY2xlYW51cCA9IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsZWFudXBGdW5jcy5sZW5ndGg7IGkrKyl7XG4gICAgICBjbGVhbnVwRnVuY3NbaV0oKVxuICAgIH1cbiAgICBjbGVhbnVwRnVuY3MubGVuZ3RoID0gMFxuICB9XG5cbiAgcmV0dXJuIGhcbn1cblxudmFyIGggPSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRleHQoKVxuaC5jb250ZXh0ID0gY29udGV4dFxuXG5mdW5jdGlvbiBpc05vZGUgKGVsKSB7XG4gIHJldHVybiBlbCAmJiBlbC5ub2RlTmFtZSAmJiBlbC5ub2RlVHlwZVxufVxuXG5mdW5jdGlvbiBmb3JFYWNoIChhcnIsIGZuKSB7XG4gIGlmIChhcnIuZm9yRWFjaCkgcmV0dXJuIGFyci5mb3JFYWNoKGZuKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykgZm4oYXJyW2ldLCBpKVxufVxuXG5mdW5jdGlvbiBpc0FycmF5IChhcnIpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSdcbn1cblxuXG4iLCJcbnZhciBpbmRleE9mID0gW10uaW5kZXhPZjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhcnIsIG9iail7XG4gIGlmIChpbmRleE9mKSByZXR1cm4gYXJyLmluZGV4T2Yob2JqKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoYXJyW2ldID09PSBvYmopIHJldHVybiBpO1xuICB9XG4gIHJldHVybiAtMTtcbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG52YXIgaXNCcm93c2VyID0gZXhwb3J0cy5pc0Jyb3dzZXIgPSAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKHdpbmRvdykpID09PSBcIm9iamVjdFwiICYmICh0eXBlb2YgZG9jdW1lbnQgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihkb2N1bWVudCkpID09PSAnb2JqZWN0JyAmJiBkb2N1bWVudC5ub2RlVHlwZSA9PT0gOTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gaXNCcm93c2VyOyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBjYW1lbENhc2U7XG52YXIgcmVnRXhwID0gLyhbQS1aXSkvZztcblxuLyoqXG4gKiBSZXBsYWNlIGEgc3RyaW5nIHBhc3NlZCBmcm9tIFN0cmluZyNyZXBsYWNlLlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5mdW5jdGlvbiByZXBsYWNlKHN0cikge1xuICByZXR1cm4gXCItXCIgKyBzdHIudG9Mb3dlckNhc2UoKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGNhbWVsIGNhc2VkIHByb3BlcnR5IG5hbWVzIHRvIGRhc2ggc2VwYXJhdGVkLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdHlsZVxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5mdW5jdGlvbiBjb252ZXJ0Q2FzZShzdHlsZSkge1xuICB2YXIgY29udmVydGVkID0ge307XG5cbiAgZm9yICh2YXIgcHJvcCBpbiBzdHlsZSkge1xuICAgIGNvbnZlcnRlZFtwcm9wLnJlcGxhY2UocmVnRXhwLCByZXBsYWNlKV0gPSBzdHlsZVtwcm9wXTtcbiAgfVxuXG4gIGlmIChzdHlsZS5mYWxsYmFja3MpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShzdHlsZS5mYWxsYmFja3MpKSBjb252ZXJ0ZWQuZmFsbGJhY2tzID0gc3R5bGUuZmFsbGJhY2tzLm1hcChjb252ZXJ0Q2FzZSk7ZWxzZSBjb252ZXJ0ZWQuZmFsbGJhY2tzID0gY29udmVydENhc2Uoc3R5bGUuZmFsbGJhY2tzKTtcbiAgfVxuXG4gIHJldHVybiBjb252ZXJ0ZWQ7XG59XG5cbi8qKlxuICogQWxsb3cgY2FtZWwgY2FzZWQgcHJvcGVydHkgbmFtZXMgYnkgY29udmVydGluZyB0aGVtIGJhY2sgdG8gZGFzaGVyaXplZC5cbiAqXG4gKiBAcGFyYW0ge1J1bGV9IHJ1bGVcbiAqL1xuZnVuY3Rpb24gY2FtZWxDYXNlKCkge1xuICBmdW5jdGlvbiBvblByb2Nlc3NTdHlsZShzdHlsZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHN0eWxlKSkge1xuICAgICAgLy8gSGFuZGxlIHJ1bGVzIGxpa2UgQGZvbnQtZmFjZSwgd2hpY2ggY2FuIGhhdmUgbXVsdGlwbGUgc3R5bGVzIGluIGFuIGFycmF5XG4gICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgc3R5bGUubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIHN0eWxlW2luZGV4XSA9IGNvbnZlcnRDYXNlKHN0eWxlW2luZGV4XSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3R5bGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbnZlcnRDYXNlKHN0eWxlKTtcbiAgfVxuXG4gIHJldHVybiB7IG9uUHJvY2Vzc1N0eWxlOiBvblByb2Nlc3NTdHlsZSB9O1xufSIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGpzc0NvbXBvc2U7XG5cbnZhciBfd2FybmluZyA9IHJlcXVpcmUoJ3dhcm5pbmcnKTtcblxudmFyIF93YXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dhcm5pbmcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vKipcbiAqIFNldCBzZWxlY3Rvci5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3JpZ2luYWwgcnVsZVxuICogQHBhcmFtIHtTdHJpbmd9IGNsYXNzTmFtZSBjbGFzcyBzdHJpbmdcbiAqIEByZXR1cm4ge0Jvb2xlYW59IGZsYWcsIGluZGljYXRpbmcgZnVuY3Rpb24gd2FzIHN1Y2Nlc3NmdWxsIG9yIG5vdFxuICovXG5mdW5jdGlvbiByZWdpc3RlckNsYXNzKHJ1bGUsIGNsYXNzTmFtZSkge1xuICAvLyBTa2lwIGZhbHN5IHZhbHVlc1xuICBpZiAoIWNsYXNzTmFtZSkgcmV0dXJuIHRydWU7XG5cbiAgLy8gU3VwcG9ydCBhcnJheSBvZiBjbGFzcyBuYW1lcyBge2NvbXBvc2VzOiBbJ2ZvbycsICdiYXInXX1gXG4gIGlmIChBcnJheS5pc0FycmF5KGNsYXNzTmFtZSkpIHtcbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgY2xhc3NOYW1lLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdmFyIGlzU2V0dGVkID0gcmVnaXN0ZXJDbGFzcyhydWxlLCBjbGFzc05hbWVbaW5kZXhdKTtcbiAgICAgIGlmICghaXNTZXR0ZWQpIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIFN1cHBvcnQgc3BhY2Ugc2VwYXJhdGVkIGNsYXNzIG5hbWVzIGB7Y29tcG9zZXM6ICdmb28gYmFyJ31gXG4gIGlmIChjbGFzc05hbWUuaW5kZXhPZignICcpID4gLTEpIHtcbiAgICByZXR1cm4gcmVnaXN0ZXJDbGFzcyhydWxlLCBjbGFzc05hbWUuc3BsaXQoJyAnKSk7XG4gIH1cblxuICB2YXIgcGFyZW50ID0gcnVsZS5vcHRpb25zLnBhcmVudDtcblxuICAvLyBJdCBpcyBhIHJlZiB0byBhIGxvY2FsIHJ1bGUuXG5cbiAgaWYgKGNsYXNzTmFtZVswXSA9PT0gJyQnKSB7XG4gICAgdmFyIHJlZlJ1bGUgPSBwYXJlbnQuZ2V0UnVsZShjbGFzc05hbWUuc3Vic3RyKDEpKTtcblxuICAgIGlmICghcmVmUnVsZSkge1xuICAgICAgKDAsIF93YXJuaW5nMi5kZWZhdWx0KShmYWxzZSwgJ1tKU1NdIFJlZmVyZW5jZWQgcnVsZSBpcyBub3QgZGVmaW5lZC4gXFxyXFxuJXMnLCBydWxlKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAocmVmUnVsZSA9PT0gcnVsZSkge1xuICAgICAgKDAsIF93YXJuaW5nMi5kZWZhdWx0KShmYWxzZSwgJ1tKU1NdIEN5Y2xpYyBjb21wb3NpdGlvbiBkZXRlY3RlZC4gXFxyXFxuJXMnLCBydWxlKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBwYXJlbnQuY2xhc3Nlc1tydWxlLmtleV0gKz0gJyAnICsgcGFyZW50LmNsYXNzZXNbcmVmUnVsZS5rZXldO1xuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBydWxlLm9wdGlvbnMucGFyZW50LmNsYXNzZXNbcnVsZS5rZXldICs9ICcgJyArIGNsYXNzTmFtZTtcblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGNvbXBvc2UgcHJvcGVydHkgdG8gYWRkaXRpb25hbCBjbGFzcywgcmVtb3ZlIHByb3BlcnR5IGZyb20gb3JpZ2luYWwgc3R5bGVzLlxuICpcbiAqIEBwYXJhbSB7UnVsZX0gcnVsZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuZnVuY3Rpb24ganNzQ29tcG9zZSgpIHtcbiAgZnVuY3Rpb24gb25Qcm9jZXNzU3R5bGUoc3R5bGUsIHJ1bGUpIHtcbiAgICBpZiAoIXN0eWxlLmNvbXBvc2VzKSByZXR1cm4gc3R5bGU7XG4gICAgcmVnaXN0ZXJDbGFzcyhydWxlLCBzdHlsZS5jb21wb3Nlcyk7XG4gICAgLy8gUmVtb3ZlIGNvbXBvc2VzIHByb3BlcnR5IHRvIHByZXZlbnQgaW5maW5pdGUgbG9vcC5cbiAgICBkZWxldGUgc3R5bGUuY29tcG9zZXM7XG4gICAgcmV0dXJuIHN0eWxlO1xuICB9XG4gIHJldHVybiB7IG9uUHJvY2Vzc1N0eWxlOiBvblByb2Nlc3NTdHlsZSB9O1xufSIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbi8qKlxuICogR2VuZXJhdGVkIGpzcy1kZWZhdWx0LXVuaXQgQ1NTIHByb3BlcnR5IHVuaXRzXG4gKlxuICogQHR5cGUgb2JqZWN0XG4gKi9cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IHtcbiAgJ2FuaW1hdGlvbi1kZWxheSc6ICdtcycsXG4gICdhbmltYXRpb24tZHVyYXRpb24nOiAnbXMnLFxuICAnYmFja2dyb3VuZC1wb3NpdGlvbic6ICdweCcsXG4gICdiYWNrZ3JvdW5kLXBvc2l0aW9uLXgnOiAncHgnLFxuICAnYmFja2dyb3VuZC1wb3NpdGlvbi15JzogJ3B4JyxcbiAgJ2JhY2tncm91bmQtc2l6ZSc6ICdweCcsXG4gIGJvcmRlcjogJ3B4JyxcbiAgJ2JvcmRlci1ib3R0b20nOiAncHgnLFxuICAnYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1cyc6ICdweCcsXG4gICdib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1cyc6ICdweCcsXG4gICdib3JkZXItYm90dG9tLXdpZHRoJzogJ3B4JyxcbiAgJ2JvcmRlci1sZWZ0JzogJ3B4JyxcbiAgJ2JvcmRlci1sZWZ0LXdpZHRoJzogJ3B4JyxcbiAgJ2JvcmRlci1yYWRpdXMnOiAncHgnLFxuICAnYm9yZGVyLXJpZ2h0JzogJ3B4JyxcbiAgJ2JvcmRlci1yaWdodC13aWR0aCc6ICdweCcsXG4gICdib3JkZXItc3BhY2luZyc6ICdweCcsXG4gICdib3JkZXItdG9wJzogJ3B4JyxcbiAgJ2JvcmRlci10b3AtbGVmdC1yYWRpdXMnOiAncHgnLFxuICAnYm9yZGVyLXRvcC1yaWdodC1yYWRpdXMnOiAncHgnLFxuICAnYm9yZGVyLXRvcC13aWR0aCc6ICdweCcsXG4gICdib3JkZXItd2lkdGgnOiAncHgnLFxuICAnYm9yZGVyLWFmdGVyLXdpZHRoJzogJ3B4JyxcbiAgJ2JvcmRlci1iZWZvcmUtd2lkdGgnOiAncHgnLFxuICAnYm9yZGVyLWVuZC13aWR0aCc6ICdweCcsXG4gICdib3JkZXItaG9yaXpvbnRhbC1zcGFjaW5nJzogJ3B4JyxcbiAgJ2JvcmRlci1zdGFydC13aWR0aCc6ICdweCcsXG4gICdib3JkZXItdmVydGljYWwtc3BhY2luZyc6ICdweCcsXG4gIGJvdHRvbTogJ3B4JyxcbiAgJ2JveC1zaGFkb3cnOiAncHgnLFxuICAnY29sdW1uLWdhcCc6ICdweCcsXG4gICdjb2x1bW4tcnVsZSc6ICdweCcsXG4gICdjb2x1bW4tcnVsZS13aWR0aCc6ICdweCcsXG4gICdjb2x1bW4td2lkdGgnOiAncHgnLFxuICAnZmxleC1iYXNpcyc6ICdweCcsXG4gICdmb250LXNpemUnOiAncHgnLFxuICAnZm9udC1zaXplLWRlbHRhJzogJ3B4JyxcbiAgaGVpZ2h0OiAncHgnLFxuICBsZWZ0OiAncHgnLFxuICAnbGV0dGVyLXNwYWNpbmcnOiAncHgnLFxuICAnbG9naWNhbC1oZWlnaHQnOiAncHgnLFxuICAnbG9naWNhbC13aWR0aCc6ICdweCcsXG4gIG1hcmdpbjogJ3B4JyxcbiAgJ21hcmdpbi1hZnRlcic6ICdweCcsXG4gICdtYXJnaW4tYmVmb3JlJzogJ3B4JyxcbiAgJ21hcmdpbi1ib3R0b20nOiAncHgnLFxuICAnbWFyZ2luLWxlZnQnOiAncHgnLFxuICAnbWFyZ2luLXJpZ2h0JzogJ3B4JyxcbiAgJ21hcmdpbi10b3AnOiAncHgnLFxuICAnbWF4LWhlaWdodCc6ICdweCcsXG4gICdtYXgtd2lkdGgnOiAncHgnLFxuICAnbWFyZ2luLWVuZCc6ICdweCcsXG4gICdtYXJnaW4tc3RhcnQnOiAncHgnLFxuICAnbWFzay1wb3NpdGlvbi14JzogJ3B4JyxcbiAgJ21hc2stcG9zaXRpb24teSc6ICdweCcsXG4gICdtYXNrLXNpemUnOiAncHgnLFxuICAnbWF4LWxvZ2ljYWwtaGVpZ2h0JzogJ3B4JyxcbiAgJ21heC1sb2dpY2FsLXdpZHRoJzogJ3B4JyxcbiAgJ21pbi1oZWlnaHQnOiAncHgnLFxuICAnbWluLXdpZHRoJzogJ3B4JyxcbiAgJ21pbi1sb2dpY2FsLWhlaWdodCc6ICdweCcsXG4gICdtaW4tbG9naWNhbC13aWR0aCc6ICdweCcsXG4gIG1vdGlvbjogJ3B4JyxcbiAgJ21vdGlvbi1vZmZzZXQnOiAncHgnLFxuICBvdXRsaW5lOiAncHgnLFxuICAnb3V0bGluZS1vZmZzZXQnOiAncHgnLFxuICAnb3V0bGluZS13aWR0aCc6ICdweCcsXG4gIHBhZGRpbmc6ICdweCcsXG4gICdwYWRkaW5nLWJvdHRvbSc6ICdweCcsXG4gICdwYWRkaW5nLWxlZnQnOiAncHgnLFxuICAncGFkZGluZy1yaWdodCc6ICdweCcsXG4gICdwYWRkaW5nLXRvcCc6ICdweCcsXG4gICdwYWRkaW5nLWFmdGVyJzogJ3B4JyxcbiAgJ3BhZGRpbmctYmVmb3JlJzogJ3B4JyxcbiAgJ3BhZGRpbmctZW5kJzogJ3B4JyxcbiAgJ3BhZGRpbmctc3RhcnQnOiAncHgnLFxuICAncGVyc3BlY3RpdmUtb3JpZ2luLXgnOiAnJScsXG4gICdwZXJzcGVjdGl2ZS1vcmlnaW4teSc6ICclJyxcbiAgcGVyc3BlY3RpdmU6ICdweCcsXG4gIHJpZ2h0OiAncHgnLFxuICAnc2hhcGUtbWFyZ2luJzogJ3B4JyxcbiAgc2l6ZTogJ3B4JyxcbiAgJ3RleHQtaW5kZW50JzogJ3B4JyxcbiAgJ3RleHQtc3Ryb2tlJzogJ3B4JyxcbiAgJ3RleHQtc3Ryb2tlLXdpZHRoJzogJ3B4JyxcbiAgdG9wOiAncHgnLFxuICAndHJhbnNmb3JtLW9yaWdpbic6ICclJyxcbiAgJ3RyYW5zZm9ybS1vcmlnaW4teCc6ICclJyxcbiAgJ3RyYW5zZm9ybS1vcmlnaW4teSc6ICclJyxcbiAgJ3RyYW5zZm9ybS1vcmlnaW4teic6ICclJyxcbiAgJ3RyYW5zaXRpb24tZGVsYXknOiAnbXMnLFxuICAndHJhbnNpdGlvbi1kdXJhdGlvbic6ICdtcycsXG4gICd2ZXJ0aWNhbC1hbGlnbic6ICdweCcsXG4gIHdpZHRoOiAncHgnLFxuICAnd29yZC1zcGFjaW5nJzogJ3B4JyxcbiAgLy8gTm90IGV4aXN0aW5nIHByb3BlcnRpZXMuXG4gIC8vIFVzZWQgdG8gYXZvaWQgaXNzdWVzIHdpdGgganNzLWV4cGFuZCBpbnRlcmdyYXRpb24uXG4gICdib3gtc2hhZG93LXgnOiAncHgnLFxuICAnYm94LXNoYWRvdy15JzogJ3B4JyxcbiAgJ2JveC1zaGFkb3ctYmx1cic6ICdweCcsXG4gICdib3gtc2hhZG93LXNwcmVhZCc6ICdweCcsXG4gICdmb250LWxpbmUtaGVpZ2h0JzogJ3B4JyxcbiAgJ3RleHQtc2hhZG93LXgnOiAncHgnLFxuICAndGV4dC1zaGFkb3cteSc6ICdweCcsXG4gICd0ZXh0LXNoYWRvdy1ibHVyJzogJ3B4J1xufTsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gZGVmYXVsdFVuaXQ7XG5cbnZhciBfZGVmYXVsdFVuaXRzID0gcmVxdWlyZSgnLi9kZWZhdWx0VW5pdHMnKTtcblxudmFyIF9kZWZhdWx0VW5pdHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGVmYXVsdFVuaXRzKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG4vKipcbiAqIENsb25lcyB0aGUgb2JqZWN0IGFuZCBhZGRzIGEgY2FtZWwgY2FzZWQgcHJvcGVydHkgdmVyc2lvbi5cbiAqL1xuZnVuY3Rpb24gYWRkQ2FtZWxDYXNlZFZlcnNpb24ob2JqKSB7XG4gIHZhciByZWdFeHAgPSAvKC1bYS16XSkvZztcbiAgdmFyIHJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlKHN0cikge1xuICAgIHJldHVybiBzdHJbMV0udG9VcHBlckNhc2UoKTtcbiAgfTtcbiAgdmFyIG5ld09iaiA9IHt9O1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgbmV3T2JqW2tleV0gPSBvYmpba2V5XTtcbiAgICBuZXdPYmpba2V5LnJlcGxhY2UocmVnRXhwLCByZXBsYWNlKV0gPSBvYmpba2V5XTtcbiAgfVxuICByZXR1cm4gbmV3T2JqO1xufVxuXG52YXIgdW5pdHMgPSBhZGRDYW1lbENhc2VkVmVyc2lvbihfZGVmYXVsdFVuaXRzMlsnZGVmYXVsdCddKTtcblxuLyoqXG4gKiBSZWN1cnNpdmUgZGVlcCBzdHlsZSBwYXNzaW5nIGZ1bmN0aW9uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGN1cnJlbnQgcHJvcGVydHlcbiAqIEBwYXJhbSB7KE9iamVjdHxBcnJheXxOdW1iZXJ8U3RyaW5nKX0gcHJvcGVydHkgdmFsdWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHsoT2JqZWN0fEFycmF5fE51bWJlcnxTdHJpbmcpfSByZXN1bHRpbmcgdmFsdWVcbiAqL1xuZnVuY3Rpb24gaXRlcmF0ZShwcm9wLCB2YWx1ZSwgb3B0aW9ucykge1xuICBpZiAoIXZhbHVlKSByZXR1cm4gdmFsdWU7XG5cbiAgdmFyIGNvbnZlcnRlZFZhbHVlID0gdmFsdWU7XG5cbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHZhbHVlKTtcbiAgaWYgKHR5cGUgPT09ICdvYmplY3QnICYmIEFycmF5LmlzQXJyYXkodmFsdWUpKSB0eXBlID0gJ2FycmF5JztcblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAgaWYgKHByb3AgPT09ICdmYWxsYmFja3MnKSB7XG4gICAgICAgIGZvciAodmFyIGlubmVyUHJvcCBpbiB2YWx1ZSkge1xuICAgICAgICAgIHZhbHVlW2lubmVyUHJvcF0gPSBpdGVyYXRlKGlubmVyUHJvcCwgdmFsdWVbaW5uZXJQcm9wXSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBfaW5uZXJQcm9wIGluIHZhbHVlKSB7XG4gICAgICAgIHZhbHVlW19pbm5lclByb3BdID0gaXRlcmF0ZShwcm9wICsgJy0nICsgX2lubmVyUHJvcCwgdmFsdWVbX2lubmVyUHJvcF0sIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnYXJyYXknOlxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YWx1ZVtpXSA9IGl0ZXJhdGUocHJvcCwgdmFsdWVbaV0sIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIGlmICh2YWx1ZSAhPT0gMCkge1xuICAgICAgICBjb252ZXJ0ZWRWYWx1ZSA9IHZhbHVlICsgKG9wdGlvbnNbcHJvcF0gfHwgdW5pdHNbcHJvcF0gfHwgJycpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIGNvbnZlcnRlZFZhbHVlO1xufVxuXG4vKipcbiAqIEFkZCB1bml0IHRvIG51bWVyaWMgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBkZWZhdWx0VW5pdCgpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gIHZhciBjYW1lbENhc2VkT3B0aW9ucyA9IGFkZENhbWVsQ2FzZWRWZXJzaW9uKG9wdGlvbnMpO1xuXG4gIGZ1bmN0aW9uIG9uUHJvY2Vzc1N0eWxlKHN0eWxlLCBydWxlKSB7XG4gICAgaWYgKHJ1bGUudHlwZSAhPT0gJ3N0eWxlJykgcmV0dXJuIHN0eWxlO1xuXG4gICAgZm9yICh2YXIgcHJvcCBpbiBzdHlsZSkge1xuICAgICAgc3R5bGVbcHJvcF0gPSBpdGVyYXRlKHByb3AsIHN0eWxlW3Byb3BdLCBjYW1lbENhc2VkT3B0aW9ucyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0eWxlO1xuICB9XG5cbiAgZnVuY3Rpb24gb25DaGFuZ2VWYWx1ZSh2YWx1ZSwgcHJvcCkge1xuICAgIHJldHVybiBpdGVyYXRlKHByb3AsIHZhbHVlLCBjYW1lbENhc2VkT3B0aW9ucyk7XG4gIH1cblxuICByZXR1cm4geyBvblByb2Nlc3NTdHlsZTogb25Qcm9jZXNzU3R5bGUsIG9uQ2hhbmdlVmFsdWU6IG9uQ2hhbmdlVmFsdWUgfTtcbn0iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuZXhwb3J0cy5kZWZhdWx0ID0ganNzRXhwYW5kO1xuXG52YXIgX3Byb3BzID0gcmVxdWlyZSgnLi9wcm9wcycpO1xuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG4vKipcbiAqIE1hcCB2YWx1ZXMgYnkgZ2l2ZW4gcHJvcC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBvZiB2YWx1ZXNcbiAqIEBwYXJhbSB7U3RyaW5nfSBvcmlnaW5hbCBwcm9wZXJ0eVxuICogQHBhcmFtIHtTdHJpbmd9IG9yaWdpbmFsIHJ1bGVcbiAqIEByZXR1cm4ge1N0cmluZ30gbWFwcGVkIHZhbHVlc1xuICovXG5mdW5jdGlvbiBtYXBWYWx1ZXNCeVByb3AodmFsdWUsIHByb3AsIHJ1bGUpIHtcbiAgcmV0dXJuIHZhbHVlLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgIHJldHVybiBvYmplY3RUb1N0cmluZyhpdGVtLCBwcm9wLCBydWxlKTtcbiAgfSk7XG59XG5cbi8qKlxuICogQ29udmVydCBhcnJheSB0byBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgb2YgdmFsdWVzXG4gKiBAcGFyYW0ge1N0cmluZ30gb3JpZ2luYWwgcHJvcGVydHlcbiAqIEBwYXJhbSB7T2JqZWN0fSBzaGVtZSwgZm9yIGNvbnZlcnRpbmcgYXJyYXlzIGluIHN0cmluZ3NcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcmlnaW5hbCBydWxlXG4gKiBAcmV0dXJuIHtTdHJpbmd9IGNvbnZlcnRlZCBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gYXJyYXlUb1N0cmluZyh2YWx1ZSwgcHJvcCwgc2NoZW1lLCBydWxlKSB7XG4gIGlmIChzY2hlbWVbcHJvcF0gPT0gbnVsbCkgcmV0dXJuIHZhbHVlLmpvaW4oJywnKTtcbiAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcnO1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZVswXSkpIHJldHVybiBhcnJheVRvU3RyaW5nKHZhbHVlWzBdLCBwcm9wLCBzY2hlbWUpO1xuICBpZiAoX3R5cGVvZih2YWx1ZVswXSkgPT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG1hcFZhbHVlc0J5UHJvcCh2YWx1ZSwgcHJvcCwgcnVsZSk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlLmpvaW4oJyAnKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IG9iamVjdCB0byBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBvZiB2YWx1ZXNcbiAqIEBwYXJhbSB7U3RyaW5nfSBvcmlnaW5hbCBwcm9wZXJ0eVxuICogQHBhcmFtIHtPYmplY3R9IG9yaWdpbmFsIHJ1bGVcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaXMgZmFsbGJhY2sgcHJvcFxuICogQHJldHVybiB7U3RyaW5nfSBjb252ZXJ0ZWQgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKHZhbHVlLCBwcm9wLCBydWxlLCBpc0ZhbGxiYWNrKSB7XG4gIGlmICghKF9wcm9wcy5wcm9wT2JqW3Byb3BdIHx8IF9wcm9wcy5jdXN0b21Qcm9wT2JqW3Byb3BdKSkgcmV0dXJuICcnO1xuXG4gIHZhciByZXN1bHQgPSBbXTtcblxuICAvLyBDaGVjayBpZiBleGlzdHMgYW55IG5vbi1zdGFuZGFydCBwcm9wZXJ0eVxuICBpZiAoX3Byb3BzLmN1c3RvbVByb3BPYmpbcHJvcF0pIHtcbiAgICB2YWx1ZSA9IGN1c3RvbVByb3BzVG9TdHlsZSh2YWx1ZSwgcnVsZSwgX3Byb3BzLmN1c3RvbVByb3BPYmpbcHJvcF0sIGlzRmFsbGJhY2spO1xuICB9XG5cbiAgLy8gUGFzcyB0aHJvdWdodCBhbGwgc3RhbmRhcnQgcHJvcHNcbiAgaWYgKE9iamVjdC5rZXlzKHZhbHVlKS5sZW5ndGgpIHtcbiAgICBmb3IgKHZhciBiYXNlUHJvcCBpbiBfcHJvcHMucHJvcE9ialtwcm9wXSkge1xuICAgICAgaWYgKHZhbHVlW2Jhc2VQcm9wXSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZVtiYXNlUHJvcF0pKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goYXJyYXlUb1N0cmluZyh2YWx1ZVtiYXNlUHJvcF0sIGJhc2VQcm9wLCBfcHJvcHMucHJvcEFycmF5SW5PYmopKTtcbiAgICAgICAgfSBlbHNlIHJlc3VsdC5wdXNoKHZhbHVlW2Jhc2VQcm9wXSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBBZGQgZGVmYXVsdCB2YWx1ZSBmcm9tIHByb3BzIGNvbmZpZy5cbiAgICAgIGlmIChfcHJvcHMucHJvcE9ialtwcm9wXVtiYXNlUHJvcF0gIT0gbnVsbCkge1xuICAgICAgICByZXN1bHQucHVzaChfcHJvcHMucHJvcE9ialtwcm9wXVtiYXNlUHJvcF0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQuam9pbignICcpO1xufVxuXG4vKipcbiAqIENvbnZlcnQgY3VzdG9tIHByb3BlcnRpZXMgdmFsdWVzIHRvIHN0eWxlcyBhZGRpbmcgdGhlbSB0byBydWxlIGRpcmVjdGx5XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBvZiB2YWx1ZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcmlnaW5hbCBydWxlXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHksIHRoYXQgY29udGFpbiBwYXJ0aWFsIGN1c3RvbSBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGlzIGZhbGxiYWNrIHByb3BcbiAqIEByZXR1cm4ge09iamVjdH0gdmFsdWUgd2l0aG91dCBjdXN0b20gcHJvcGVydGllcywgdGhhdCB3YXMgYWxyZWFkeSBhZGRlZCB0byBydWxlXG4gKi9cbmZ1bmN0aW9uIGN1c3RvbVByb3BzVG9TdHlsZSh2YWx1ZSwgcnVsZSwgY3VzdG9tUHJvcHMsIGlzRmFsbGJhY2spIHtcbiAgZm9yICh2YXIgcHJvcCBpbiBjdXN0b21Qcm9wcykge1xuICAgIHZhciBwcm9wTmFtZSA9IGN1c3RvbVByb3BzW3Byb3BdO1xuXG4gICAgLy8gSWYgY3VycmVudCBwcm9wZXJ0eSBkb2Vzbid0IGV4aXN0IGFscmVhZHkgaW4gcnVsZSAtIGFkZCBuZXcgb25lXG4gICAgaWYgKHR5cGVvZiB2YWx1ZVtwcm9wXSAhPT0gJ3VuZGVmaW5lZCcgJiYgKGlzRmFsbGJhY2sgfHwgIXJ1bGUucHJvcChwcm9wTmFtZSkpKSB7XG4gICAgICB2YXIgYXBwZW5kZWRWYWx1ZSA9IHN0eWxlRGV0ZWN0b3IoX2RlZmluZVByb3BlcnR5KHt9LCBwcm9wTmFtZSwgdmFsdWVbcHJvcF0pLCBydWxlKVtwcm9wTmFtZV07XG5cbiAgICAgIC8vIEFkZCBzdHlsZSBkaXJlY3RseSBpbiBydWxlXG4gICAgICBpZiAoaXNGYWxsYmFjaykgcnVsZS5zdHlsZS5mYWxsYmFja3NbcHJvcE5hbWVdID0gYXBwZW5kZWRWYWx1ZTtlbHNlIHJ1bGUuc3R5bGVbcHJvcE5hbWVdID0gYXBwZW5kZWRWYWx1ZTtcbiAgICB9XG4gICAgLy8gRGVsZXRlIGNvbnZlcnRlZCBwcm9wZXJ0eSB0byBhdm9pZCBkb3VibGUgY29udmVydGluZ1xuICAgIGRlbGV0ZSB2YWx1ZVtwcm9wXTtcbiAgfVxuXG4gIHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBEZXRlY3QgaWYgYSBzdHlsZSBuZWVkcyB0byBiZSBjb252ZXJ0ZWQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHN0eWxlXG4gKiBAcGFyYW0ge09iamVjdH0gcnVsZVxuICogQHBhcmFtIHtCb29sZWFufSBpcyBmYWxsYmFjayBwcm9wXG4gKiBAcmV0dXJuIHtPYmplY3R9IGNvbnZlcnRlZFN0eWxlXG4gKi9cbmZ1bmN0aW9uIHN0eWxlRGV0ZWN0b3Ioc3R5bGUsIHJ1bGUsIGlzRmFsbGJhY2spIHtcbiAgZm9yICh2YXIgcHJvcCBpbiBzdHlsZSkge1xuICAgIHZhciB2YWx1ZSA9IHN0eWxlW3Byb3BdO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAvLyBDaGVjayBkb3VibGUgYXJyYXlzIHRvIGF2b2lkIHJlY3Vyc2lvbi5cbiAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZVswXSkpIHtcbiAgICAgICAgaWYgKHByb3AgPT09ICdmYWxsYmFja3MnKSB7XG4gICAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IHN0eWxlLmZhbGxiYWNrcy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIHN0eWxlLmZhbGxiYWNrc1tpbmRleF0gPSBzdHlsZURldGVjdG9yKHN0eWxlLmZhbGxiYWNrc1tpbmRleF0sIHJ1bGUsIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0eWxlW3Byb3BdID0gYXJyYXlUb1N0cmluZyh2YWx1ZSwgcHJvcCwgX3Byb3BzLnByb3BBcnJheSk7XG4gICAgICAgIC8vIEF2b2lkIGNyZWF0aW5nIHByb3BlcnRpZXMgd2l0aCBlbXB0eSB2YWx1ZXNcbiAgICAgICAgaWYgKCFzdHlsZVtwcm9wXSkgZGVsZXRlIHN0eWxlW3Byb3BdO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YodmFsdWUpKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGlmIChwcm9wID09PSAnZmFsbGJhY2tzJykge1xuICAgICAgICBzdHlsZS5mYWxsYmFja3MgPSBzdHlsZURldGVjdG9yKHN0eWxlLmZhbGxiYWNrcywgcnVsZSwgdHJ1ZSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBzdHlsZVtwcm9wXSA9IG9iamVjdFRvU3RyaW5nKHZhbHVlLCBwcm9wLCBydWxlLCBpc0ZhbGxiYWNrKTtcbiAgICAgIC8vIEF2b2lkIGNyZWF0aW5nIHByb3BlcnRpZXMgd2l0aCBlbXB0eSB2YWx1ZXNcbiAgICAgIGlmICghc3R5bGVbcHJvcF0pIGRlbGV0ZSBzdHlsZVtwcm9wXTtcbiAgICB9XG5cbiAgICAvLyBNYXliZSBhIGNvbXB1dGVkIHZhbHVlIHJlc3VsdGluZyBpbiBhbiBlbXB0eSBzdHJpbmdcbiAgICBlbHNlIGlmIChzdHlsZVtwcm9wXSA9PT0gJycpIGRlbGV0ZSBzdHlsZVtwcm9wXTtcbiAgfVxuXG4gIHJldHVybiBzdHlsZTtcbn1cblxuLyoqXG4gKiBBZGRzIHBvc3NpYmlsaXR5IHRvIHdyaXRlIGV4cGFuZGVkIHN0eWxlcy5cbiAqXG4gKiBAcGFyYW0ge1J1bGV9IHJ1bGVcbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIGpzc0V4cGFuZCgpIHtcbiAgZnVuY3Rpb24gb25Qcm9jZXNzU3R5bGUoc3R5bGUsIHJ1bGUpIHtcbiAgICBpZiAoIXN0eWxlIHx8IHJ1bGUudHlwZSAhPT0gJ3N0eWxlJykgcmV0dXJuIHN0eWxlO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc3R5bGUpKSB7XG4gICAgICAvLyBQYXNzIHJ1bGVzIG9uZSBieSBvbmUgYW5kIHJlZm9ybWF0IHRoZW1cbiAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBzdHlsZS5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgc3R5bGVbaW5kZXhdID0gc3R5bGVEZXRlY3RvcihzdHlsZVtpbmRleF0sIHJ1bGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0eWxlO1xuICAgIH1cblxuICAgIHJldHVybiBzdHlsZURldGVjdG9yKHN0eWxlLCBydWxlKTtcbiAgfVxuXG4gIHJldHVybiB7IG9uUHJvY2Vzc1N0eWxlOiBvblByb2Nlc3NTdHlsZSB9O1xufSIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbi8qKlxuICogQSBzY2hlbWUgZm9yIGNvbnZlcnRpbmcgcHJvcGVydGllcyBmcm9tIGFycmF5IHRvIHJlZ3VsYXIgc3R5bGUuXG4gKiBBbGwgcHJvcGVydGllcyBsaXN0ZWQgYmVsb3cgd2lsbCBiZSB0cmFuc2Zvcm1lZCB0byBhIHN0cmluZyBzZXBhcmF0ZWQgYnkgc3BhY2UuXG4gKi9cbnZhciBwcm9wQXJyYXkgPSBleHBvcnRzLnByb3BBcnJheSA9IHtcbiAgJ2JhY2tncm91bmQtc2l6ZSc6IHRydWUsXG4gICdiYWNrZ3JvdW5kLXBvc2l0aW9uJzogdHJ1ZSxcbiAgYm9yZGVyOiB0cnVlLFxuICAnYm9yZGVyLWJvdHRvbSc6IHRydWUsXG4gICdib3JkZXItbGVmdCc6IHRydWUsXG4gICdib3JkZXItdG9wJzogdHJ1ZSxcbiAgJ2JvcmRlci1yaWdodCc6IHRydWUsXG4gICdib3JkZXItcmFkaXVzJzogdHJ1ZSxcbiAgJ2JvcmRlci1pbWFnZSc6IHRydWUsXG4gICdib3gtc2hhZG93JzogdHJ1ZSxcbiAgZmxleDogdHJ1ZSxcbiAgbWFyZ2luOiB0cnVlLFxuICBwYWRkaW5nOiB0cnVlLFxuICBvdXRsaW5lOiB0cnVlLFxuICAndHJhbnNmb3JtLW9yaWdpbic6IHRydWUsXG4gIHRyYW5zZm9ybTogdHJ1ZSxcbiAgdHJhbnNpdGlvbjogdHJ1ZVxuXG4gIC8qKlxuICAgKiBBIHNjaGVtZSBmb3IgY29udmVydGluZyBhcnJheXMgdG8gcmVndWxhciBzdHlsZXMgaW5zaWRlIG9mIG9iamVjdHMuXG4gICAqIEZvciBlLmcuOiBcIntwb3NpdGlvbjogWzAsIDBdfVwiID0+IFwiYmFja2dyb3VuZC1wb3NpdGlvbjogMCAwO1wiLlxuICAgKi9cbn07dmFyIHByb3BBcnJheUluT2JqID0gZXhwb3J0cy5wcm9wQXJyYXlJbk9iaiA9IHtcbiAgcG9zaXRpb246IHRydWUsIC8vIGJhY2tncm91bmQtcG9zaXRpb25cbiAgc2l6ZTogdHJ1ZSAvLyBiYWNrZ3JvdW5kLXNpemVcblxuXG4gIC8qKlxuICAgKiBBIHNjaGVtZSBmb3IgcGFyc2luZyBhbmQgYnVpbGRpbmcgY29ycmVjdCBzdHlsZXMgZnJvbSBwYXNzZWQgb2JqZWN0cy5cbiAgICovXG59O3ZhciBwcm9wT2JqID0gZXhwb3J0cy5wcm9wT2JqID0ge1xuICBwYWRkaW5nOiB7XG4gICAgdG9wOiAwLFxuICAgIHJpZ2h0OiAwLFxuICAgIGJvdHRvbTogMCxcbiAgICBsZWZ0OiAwXG4gIH0sXG4gIG1hcmdpbjoge1xuICAgIHRvcDogMCxcbiAgICByaWdodDogMCxcbiAgICBib3R0b206IDAsXG4gICAgbGVmdDogMFxuICB9LFxuICBiYWNrZ3JvdW5kOiB7XG4gICAgYXR0YWNobWVudDogbnVsbCxcbiAgICBjb2xvcjogbnVsbCxcbiAgICBpbWFnZTogbnVsbCxcbiAgICBwb3NpdGlvbjogbnVsbCxcbiAgICByZXBlYXQ6IG51bGxcbiAgfSxcbiAgYm9yZGVyOiB7XG4gICAgd2lkdGg6IG51bGwsXG4gICAgc3R5bGU6IG51bGwsXG4gICAgY29sb3I6IG51bGxcbiAgfSxcbiAgJ2JvcmRlci10b3AnOiB7XG4gICAgd2lkdGg6IG51bGwsXG4gICAgc3R5bGU6IG51bGwsXG4gICAgY29sb3I6IG51bGxcbiAgfSxcbiAgJ2JvcmRlci1yaWdodCc6IHtcbiAgICB3aWR0aDogbnVsbCxcbiAgICBzdHlsZTogbnVsbCxcbiAgICBjb2xvcjogbnVsbFxuICB9LFxuICAnYm9yZGVyLWJvdHRvbSc6IHtcbiAgICB3aWR0aDogbnVsbCxcbiAgICBzdHlsZTogbnVsbCxcbiAgICBjb2xvcjogbnVsbFxuICB9LFxuICAnYm9yZGVyLWxlZnQnOiB7XG4gICAgd2lkdGg6IG51bGwsXG4gICAgc3R5bGU6IG51bGwsXG4gICAgY29sb3I6IG51bGxcbiAgfSxcbiAgb3V0bGluZToge1xuICAgIHdpZHRoOiBudWxsLFxuICAgIHN0eWxlOiBudWxsLFxuICAgIGNvbG9yOiBudWxsXG4gIH0sXG4gICdsaXN0LXN0eWxlJzoge1xuICAgIHR5cGU6IG51bGwsXG4gICAgcG9zaXRpb246IG51bGwsXG4gICAgaW1hZ2U6IG51bGxcbiAgfSxcbiAgdHJhbnNpdGlvbjoge1xuICAgIHByb3BlcnR5OiBudWxsLFxuICAgIGR1cmF0aW9uOiBudWxsLFxuICAgICd0aW1pbmctZnVuY3Rpb24nOiBudWxsLFxuICAgIHRpbWluZ0Z1bmN0aW9uOiBudWxsLCAvLyBOZWVkZWQgZm9yIGF2b2lkaW5nIGNvbWlsYXRpb24gaXNzdWVzIHdpdGgganNzLWNhbWVsLWNhc2VcbiAgICBkZWxheTogbnVsbFxuICB9LFxuICBhbmltYXRpb246IHtcbiAgICBuYW1lOiBudWxsLFxuICAgIGR1cmF0aW9uOiBudWxsLFxuICAgICd0aW1pbmctZnVuY3Rpb24nOiBudWxsLFxuICAgIHRpbWluZ0Z1bmN0aW9uOiBudWxsLCAvLyBOZWVkZWQgdG8gYXZvaWQgY29tcGlsYXRpb24gaXNzdWVzIHdpdGgganNzLWNhbWVsLWNhc2VcbiAgICBkZWxheTogbnVsbCxcbiAgICAnaXRlcmF0aW9uLWNvdW50JzogbnVsbCxcbiAgICBpdGVyYXRpb25Db3VudDogbnVsbCwgLy8gTmVlZGVkIHRvIGF2b2lkIGNvbXBpbGF0aW9uIGlzc3VlcyB3aXRoIGpzcy1jYW1lbC1jYXNlXG4gICAgZGlyZWN0aW9uOiBudWxsLFxuICAgICdmaWxsLW1vZGUnOiBudWxsLFxuICAgIGZpbGxNb2RlOiBudWxsLCAvLyBOZWVkZWQgdG8gYXZvaWQgY29tcGlsYXRpb24gaXNzdWVzIHdpdGgganNzLWNhbWVsLWNhc2VcbiAgICAncGxheS1zdGF0ZSc6IG51bGwsXG4gICAgcGxheVN0YXRlOiBudWxsIC8vIE5lZWRlZCB0byBhdm9pZCBjb21waWxhdGlvbiBpc3N1ZXMgd2l0aCBqc3MtY2FtZWwtY2FzZVxuICB9LFxuICAnYm94LXNoYWRvdyc6IHtcbiAgICB4OiAwLFxuICAgIHk6IDAsXG4gICAgYmx1cjogMCxcbiAgICBzcHJlYWQ6IDAsXG4gICAgY29sb3I6IG51bGwsXG4gICAgaW5zZXQ6IG51bGxcbiAgfSxcbiAgJ3RleHQtc2hhZG93Jzoge1xuICAgIHg6IDAsXG4gICAgeTogMCxcbiAgICBibHVyOiBudWxsLFxuICAgIGNvbG9yOiBudWxsXG4gIH1cblxuICAvKipcbiAgICogQSBzY2hlbWUgZm9yIGNvbnZlcnRpbmcgbm9uLXN0YW5kYXJ0IHByb3BlcnRpZXMgaW5zaWRlIG9iamVjdC5cbiAgICogRm9yIGUuZy46IGluY2x1ZGUgJ2JvcmRlci1yYWRpdXMnIHByb3BlcnR5IGluc2lkZSAnYm9yZGVyJyBvYmplY3QuXG4gICAqL1xufTt2YXIgY3VzdG9tUHJvcE9iaiA9IGV4cG9ydHMuY3VzdG9tUHJvcE9iaiA9IHtcbiAgYm9yZGVyOiB7XG4gICAgcmFkaXVzOiAnYm9yZGVyLXJhZGl1cycsXG4gICAgaW1hZ2U6ICdib3JkZXItaW1hZ2UnXG4gIH0sXG4gIGJhY2tncm91bmQ6IHtcbiAgICBzaXplOiAnYmFja2dyb3VuZC1zaXplJyxcbiAgICBpbWFnZTogJ2JhY2tncm91bmQtaW1hZ2UnXG4gIH0sXG4gIGZvbnQ6IHtcbiAgICBzdHlsZTogJ2ZvbnQtc3R5bGUnLFxuICAgIHZhcmlhbnQ6ICdmb250LXZhcmlhbnQnLFxuICAgIHdlaWdodDogJ2ZvbnQtd2VpZ2h0JyxcbiAgICBzdHJldGNoOiAnZm9udC1zdHJldGNoJyxcbiAgICBzaXplOiAnZm9udC1zaXplJyxcbiAgICBmYW1pbHk6ICdmb250LWZhbWlseScsXG4gICAgbGluZUhlaWdodDogJ2xpbmUtaGVpZ2h0JywgLy8gTmVlZGVkIHRvIGF2b2lkIGNvbXBpbGF0aW9uIGlzc3VlcyB3aXRoIGpzcy1jYW1lbC1jYXNlXG4gICAgJ2xpbmUtaGVpZ2h0JzogJ2xpbmUtaGVpZ2h0J1xuICB9LFxuICBmbGV4OiB7XG4gICAgZ3JvdzogJ2ZsZXgtZ3JvdycsXG4gICAgYmFzaXM6ICdmbGV4LWJhc2lzJyxcbiAgICBkaXJlY3Rpb246ICdmbGV4LWRpcmVjdGlvbicsXG4gICAgd3JhcDogJ2ZsZXgtd3JhcCcsXG4gICAgZmxvdzogJ2ZsZXgtZmxvdycsXG4gICAgc2hyaW5rOiAnZmxleC1zaHJpbmsnXG4gIH0sXG4gIGFsaWduOiB7XG4gICAgc2VsZjogJ2FsaWduLXNlbGYnLFxuICAgIGl0ZW1zOiAnYWxpZ24taXRlbXMnLFxuICAgIGNvbnRlbnQ6ICdhbGlnbi1jb250ZW50J1xuICB9XG59OyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBqc3NFeHRlbmQ7XG5cbnZhciBfd2FybmluZyA9IHJlcXVpcmUoJ3dhcm5pbmcnKTtcblxudmFyIF93YXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dhcm5pbmcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBpc09iamVjdCA9IGZ1bmN0aW9uIGlzT2JqZWN0KG9iaikge1xuICByZXR1cm4gb2JqICYmICh0eXBlb2Ygb2JqID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihvYmopKSA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkob2JqKTtcbn07XG5cbi8qKlxuICogUmVjdXJzaXZlbHkgZXh0ZW5kIHN0eWxlcy5cbiAqL1xuZnVuY3Rpb24gZXh0ZW5kKHN0eWxlLCBydWxlLCBzaGVldCkge1xuICB2YXIgbmV3U3R5bGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHt9O1xuXG4gIGlmICh0eXBlb2Ygc3R5bGUuZXh0ZW5kID09PSAnc3RyaW5nJykge1xuICAgIGlmIChzaGVldCkge1xuICAgICAgdmFyIHJlZlJ1bGUgPSBzaGVldC5nZXRSdWxlKHN0eWxlLmV4dGVuZCk7XG4gICAgICBpZiAocmVmUnVsZSkge1xuICAgICAgICBpZiAocmVmUnVsZSA9PT0gcnVsZSkgKDAsIF93YXJuaW5nMlsnZGVmYXVsdCddKShmYWxzZSwgJ1tKU1NdIEEgcnVsZSB0cmllcyB0byBleHRlbmQgaXRzZWxmIFxcclxcbiVzJywgcnVsZSk7ZWxzZSBpZiAocmVmUnVsZS5vcHRpb25zLnBhcmVudCkge1xuICAgICAgICAgIHZhciBvcmlnaW5hbFN0eWxlID0gcmVmUnVsZS5vcHRpb25zLnBhcmVudC5ydWxlcy5yYXdbc3R5bGUuZXh0ZW5kXTtcbiAgICAgICAgICBleHRlbmQob3JpZ2luYWxTdHlsZSwgcnVsZSwgc2hlZXQsIG5ld1N0eWxlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHN0eWxlLmV4dGVuZCkpIHtcbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgc3R5bGUuZXh0ZW5kLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgZXh0ZW5kKHN0eWxlLmV4dGVuZFtpbmRleF0sIHJ1bGUsIHNoZWV0LCBuZXdTdHlsZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIHByb3AgaW4gc3R5bGUuZXh0ZW5kKSB7XG4gICAgICBpZiAocHJvcCA9PT0gJ2V4dGVuZCcpIHtcbiAgICAgICAgZXh0ZW5kKHN0eWxlLmV4dGVuZC5leHRlbmQsIHJ1bGUsIHNoZWV0LCBuZXdTdHlsZSk7XG4gICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KHN0eWxlLmV4dGVuZFtwcm9wXSkpIHtcbiAgICAgICAgaWYgKCFuZXdTdHlsZVtwcm9wXSkgbmV3U3R5bGVbcHJvcF0gPSB7fTtcbiAgICAgICAgZXh0ZW5kKHN0eWxlLmV4dGVuZFtwcm9wXSwgcnVsZSwgc2hlZXQsIG5ld1N0eWxlW3Byb3BdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5ld1N0eWxlW3Byb3BdID0gc3R5bGUuZXh0ZW5kW3Byb3BdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvLyBDb3B5IGJhc2Ugc3R5bGUuXG4gIGZvciAodmFyIF9wcm9wIGluIHN0eWxlKSB7XG4gICAgaWYgKF9wcm9wID09PSAnZXh0ZW5kJykgY29udGludWU7XG4gICAgaWYgKGlzT2JqZWN0KG5ld1N0eWxlW19wcm9wXSkgJiYgaXNPYmplY3Qoc3R5bGVbX3Byb3BdKSkge1xuICAgICAgZXh0ZW5kKHN0eWxlW19wcm9wXSwgcnVsZSwgc2hlZXQsIG5ld1N0eWxlW19wcm9wXSk7XG4gICAgfSBlbHNlIGlmIChpc09iamVjdChzdHlsZVtfcHJvcF0pKSB7XG4gICAgICBuZXdTdHlsZVtfcHJvcF0gPSBleHRlbmQoc3R5bGVbX3Byb3BdLCBydWxlLCBzaGVldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld1N0eWxlW19wcm9wXSA9IHN0eWxlW19wcm9wXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3U3R5bGU7XG59XG5cbi8qKlxuICogSGFuZGxlIGBleHRlbmRgIHByb3BlcnR5LlxuICpcbiAqIEBwYXJhbSB7UnVsZX0gcnVsZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuZnVuY3Rpb24ganNzRXh0ZW5kKCkge1xuICBmdW5jdGlvbiBvblByb2Nlc3NTdHlsZShzdHlsZSwgcnVsZSwgc2hlZXQpIHtcbiAgICByZXR1cm4gc3R5bGUuZXh0ZW5kID8gZXh0ZW5kKHN0eWxlLCBydWxlLCBzaGVldCkgOiBzdHlsZTtcbiAgfVxuXG4gIHJldHVybiB7IG9uUHJvY2Vzc1N0eWxlOiBvblByb2Nlc3NTdHlsZSB9O1xufSIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0ganNzR2xvYmFsO1xuXG52YXIgX2pzcyA9IHJlcXVpcmUoJ2pzcycpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgcHJvcEtleSA9ICdAZ2xvYmFsJztcbnZhciBwcmVmaXhLZXkgPSAnQGdsb2JhbCAnO1xuXG52YXIgR2xvYmFsQ29udGFpbmVyUnVsZSA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gR2xvYmFsQ29udGFpbmVyUnVsZShrZXksIHN0eWxlcywgb3B0aW9ucykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBHbG9iYWxDb250YWluZXJSdWxlKTtcblxuICAgIHRoaXMudHlwZSA9ICdnbG9iYWwnO1xuXG4gICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLnJ1bGVzID0gbmV3IF9qc3MuUnVsZUxpc3QoX2V4dGVuZHMoe30sIG9wdGlvbnMsIHtcbiAgICAgIHBhcmVudDogdGhpc1xuICAgIH0pKTtcblxuICAgIGZvciAodmFyIHNlbGVjdG9yIGluIHN0eWxlcykge1xuICAgICAgdGhpcy5ydWxlcy5hZGQoc2VsZWN0b3IsIHN0eWxlc1tzZWxlY3Rvcl0sIHsgc2VsZWN0b3I6IHNlbGVjdG9yIH0pO1xuICAgIH1cblxuICAgIHRoaXMucnVsZXMucHJvY2VzcygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIHJ1bGUuXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKEdsb2JhbENvbnRhaW5lclJ1bGUsIFt7XG4gICAga2V5OiAnZ2V0UnVsZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFJ1bGUobmFtZSkge1xuICAgICAgcmV0dXJuIHRoaXMucnVsZXMuZ2V0KG5hbWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbmQgcmVnaXN0ZXIgcnVsZSwgcnVuIHBsdWdpbnMuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2FkZFJ1bGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRSdWxlKG5hbWUsIHN0eWxlLCBvcHRpb25zKSB7XG4gICAgICB2YXIgcnVsZSA9IHRoaXMucnVsZXMuYWRkKG5hbWUsIHN0eWxlLCBvcHRpb25zKTtcbiAgICAgIHRoaXMub3B0aW9ucy5qc3MucGx1Z2lucy5vblByb2Nlc3NSdWxlKHJ1bGUpO1xuICAgICAgcmV0dXJuIHJ1bGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGluZGV4IG9mIGEgcnVsZS5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnaW5kZXhPZicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluZGV4T2YocnVsZSkge1xuICAgICAgcmV0dXJuIHRoaXMucnVsZXMuaW5kZXhPZihydWxlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSBDU1Mgc3RyaW5nLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICd0b1N0cmluZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIHRoaXMucnVsZXMudG9TdHJpbmcoKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gR2xvYmFsQ29udGFpbmVyUnVsZTtcbn0oKTtcblxudmFyIEdsb2JhbFByZWZpeGVkUnVsZSA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gR2xvYmFsUHJlZml4ZWRSdWxlKG5hbWUsIHN0eWxlLCBvcHRpb25zKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEdsb2JhbFByZWZpeGVkUnVsZSk7XG5cbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdmFyIHNlbGVjdG9yID0gbmFtZS5zdWJzdHIocHJlZml4S2V5Lmxlbmd0aCk7XG4gICAgdGhpcy5ydWxlID0gb3B0aW9ucy5qc3MuY3JlYXRlUnVsZShzZWxlY3Rvciwgc3R5bGUsIF9leHRlbmRzKHt9LCBvcHRpb25zLCB7XG4gICAgICBwYXJlbnQ6IHRoaXMsXG4gICAgICBzZWxlY3Rvcjogc2VsZWN0b3JcbiAgICB9KSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoR2xvYmFsUHJlZml4ZWRSdWxlLCBbe1xuICAgIGtleTogJ3RvU3RyaW5nJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcob3B0aW9ucykge1xuICAgICAgcmV0dXJuIHRoaXMucnVsZS50b1N0cmluZyhvcHRpb25zKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gR2xvYmFsUHJlZml4ZWRSdWxlO1xufSgpO1xuXG52YXIgc2VwYXJhdG9yUmVnRXhwID0gL1xccyosXFxzKi9nO1xuXG5mdW5jdGlvbiBhZGRTY29wZShzZWxlY3Rvciwgc2NvcGUpIHtcbiAgdmFyIHBhcnRzID0gc2VsZWN0b3Iuc3BsaXQoc2VwYXJhdG9yUmVnRXhwKTtcbiAgdmFyIHNjb3BlZCA9ICcnO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgc2NvcGVkICs9IHNjb3BlICsgJyAnICsgcGFydHNbaV0udHJpbSgpO1xuICAgIGlmIChwYXJ0c1tpICsgMV0pIHNjb3BlZCArPSAnLCAnO1xuICB9XG4gIHJldHVybiBzY29wZWQ7XG59XG5cbmZ1bmN0aW9uIGhhbmRsZU5lc3RlZEdsb2JhbENvbnRhaW5lclJ1bGUocnVsZSkge1xuICB2YXIgb3B0aW9ucyA9IHJ1bGUub3B0aW9ucyxcbiAgICAgIHN0eWxlID0gcnVsZS5zdHlsZTtcblxuICB2YXIgcnVsZXMgPSBzdHlsZVtwcm9wS2V5XTtcblxuICBpZiAoIXJ1bGVzKSByZXR1cm47XG5cbiAgZm9yICh2YXIgbmFtZSBpbiBydWxlcykge1xuICAgIG9wdGlvbnMuc2hlZXQuYWRkUnVsZShuYW1lLCBydWxlc1tuYW1lXSwgX2V4dGVuZHMoe30sIG9wdGlvbnMsIHtcbiAgICAgIHNlbGVjdG9yOiBhZGRTY29wZShuYW1lLCBydWxlLnNlbGVjdG9yKVxuICAgIH0pKTtcbiAgfVxuXG4gIGRlbGV0ZSBzdHlsZVtwcm9wS2V5XTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlUHJlZml4ZWRHbG9iYWxSdWxlKHJ1bGUpIHtcbiAgdmFyIG9wdGlvbnMgPSBydWxlLm9wdGlvbnMsXG4gICAgICBzdHlsZSA9IHJ1bGUuc3R5bGU7XG5cbiAgZm9yICh2YXIgcHJvcCBpbiBzdHlsZSkge1xuICAgIGlmIChwcm9wLnN1YnN0cigwLCBwcm9wS2V5Lmxlbmd0aCkgIT09IHByb3BLZXkpIGNvbnRpbnVlO1xuXG4gICAgdmFyIHNlbGVjdG9yID0gYWRkU2NvcGUocHJvcC5zdWJzdHIocHJvcEtleS5sZW5ndGgpLCBydWxlLnNlbGVjdG9yKTtcbiAgICBvcHRpb25zLnNoZWV0LmFkZFJ1bGUoc2VsZWN0b3IsIHN0eWxlW3Byb3BdLCBfZXh0ZW5kcyh7fSwgb3B0aW9ucywge1xuICAgICAgc2VsZWN0b3I6IHNlbGVjdG9yXG4gICAgfSkpO1xuICAgIGRlbGV0ZSBzdHlsZVtwcm9wXTtcbiAgfVxufVxuXG4vKipcbiAqIENvbnZlcnQgbmVzdGVkIHJ1bGVzIHRvIHNlcGFyYXRlLCByZW1vdmUgdGhlbSBmcm9tIG9yaWdpbmFsIHN0eWxlcy5cbiAqXG4gKiBAcGFyYW0ge1J1bGV9IHJ1bGVcbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIGpzc0dsb2JhbCgpIHtcbiAgZnVuY3Rpb24gb25DcmVhdGVSdWxlKG5hbWUsIHN0eWxlcywgb3B0aW9ucykge1xuICAgIGlmIChuYW1lID09PSBwcm9wS2V5KSB7XG4gICAgICByZXR1cm4gbmV3IEdsb2JhbENvbnRhaW5lclJ1bGUobmFtZSwgc3R5bGVzLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBpZiAobmFtZVswXSA9PT0gJ0AnICYmIG5hbWUuc3Vic3RyKDAsIHByZWZpeEtleS5sZW5ndGgpID09PSBwcmVmaXhLZXkpIHtcbiAgICAgIHJldHVybiBuZXcgR2xvYmFsUHJlZml4ZWRSdWxlKG5hbWUsIHN0eWxlcywgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgdmFyIHBhcmVudCA9IG9wdGlvbnMucGFyZW50O1xuXG5cbiAgICBpZiAocGFyZW50KSB7XG4gICAgICBpZiAocGFyZW50LnR5cGUgPT09ICdnbG9iYWwnIHx8IHBhcmVudC5vcHRpb25zLnBhcmVudC50eXBlID09PSAnZ2xvYmFsJykge1xuICAgICAgICBvcHRpb25zLmdsb2JhbCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuZ2xvYmFsKSBvcHRpb25zLnNlbGVjdG9yID0gbmFtZTtcblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gb25Qcm9jZXNzUnVsZShydWxlKSB7XG4gICAgaWYgKHJ1bGUudHlwZSAhPT0gJ3N0eWxlJykgcmV0dXJuO1xuXG4gICAgaGFuZGxlTmVzdGVkR2xvYmFsQ29udGFpbmVyUnVsZShydWxlKTtcbiAgICBoYW5kbGVQcmVmaXhlZEdsb2JhbFJ1bGUocnVsZSk7XG4gIH1cblxuICByZXR1cm4geyBvbkNyZWF0ZVJ1bGU6IG9uQ3JlYXRlUnVsZSwgb25Qcm9jZXNzUnVsZTogb25Qcm9jZXNzUnVsZSB9O1xufSIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuZXhwb3J0cy5kZWZhdWx0ID0ganNzTmVzdGVkO1xuXG52YXIgX3dhcm5pbmcgPSByZXF1aXJlKCd3YXJuaW5nJyk7XG5cbnZhciBfd2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93YXJuaW5nKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIHNlcGFyYXRvclJlZ0V4cCA9IC9cXHMqLFxccyovZztcbnZhciBwYXJlbnRSZWdFeHAgPSAvJi9nO1xudmFyIHJlZlJlZ0V4cCA9IC9cXCQoW1xcdy1dKykvZztcblxuLyoqXG4gKiBDb252ZXJ0IG5lc3RlZCBydWxlcyB0byBzZXBhcmF0ZSwgcmVtb3ZlIHRoZW0gZnJvbSBvcmlnaW5hbCBzdHlsZXMuXG4gKlxuICogQHBhcmFtIHtSdWxlfSBydWxlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5mdW5jdGlvbiBqc3NOZXN0ZWQoKSB7XG4gIC8vIEdldCBhIGZ1bmN0aW9uIHRvIGJlIHVzZWQgZm9yICRyZWYgcmVwbGFjZW1lbnQuXG4gIGZ1bmN0aW9uIGdldFJlcGxhY2VSZWYoY29udGFpbmVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChtYXRjaCwga2V5KSB7XG4gICAgICB2YXIgcnVsZSA9IGNvbnRhaW5lci5nZXRSdWxlKGtleSk7XG4gICAgICBpZiAocnVsZSkgcmV0dXJuIHJ1bGUuc2VsZWN0b3I7XG4gICAgICAoMCwgX3dhcm5pbmcyLmRlZmF1bHQpKGZhbHNlLCAnW0pTU10gQ291bGQgbm90IGZpbmQgdGhlIHJlZmVyZW5jZWQgcnVsZSAlcyBpbiAlcy4nLCBrZXksIGNvbnRhaW5lci5vcHRpb25zLm1ldGEgfHwgY29udGFpbmVyKTtcbiAgICAgIHJldHVybiBrZXk7XG4gICAgfTtcbiAgfVxuXG4gIHZhciBoYXNBbmQgPSBmdW5jdGlvbiBoYXNBbmQoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5pbmRleE9mKCcmJykgIT09IC0xO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHJlcGxhY2VQYXJlbnRSZWZzKG5lc3RlZFByb3AsIHBhcmVudFByb3ApIHtcbiAgICB2YXIgcGFyZW50U2VsZWN0b3JzID0gcGFyZW50UHJvcC5zcGxpdChzZXBhcmF0b3JSZWdFeHApO1xuICAgIHZhciBuZXN0ZWRTZWxlY3RvcnMgPSBuZXN0ZWRQcm9wLnNwbGl0KHNlcGFyYXRvclJlZ0V4cCk7XG5cbiAgICB2YXIgcmVzdWx0ID0gJyc7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmVudFNlbGVjdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHBhcmVudCA9IHBhcmVudFNlbGVjdG9yc1tpXTtcblxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBuZXN0ZWRTZWxlY3RvcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIG5lc3RlZCA9IG5lc3RlZFNlbGVjdG9yc1tqXTtcbiAgICAgICAgaWYgKHJlc3VsdCkgcmVzdWx0ICs9ICcsICc7XG4gICAgICAgIC8vIFJlcGxhY2UgYWxsICYgYnkgdGhlIHBhcmVudCBvciBwcmVmaXggJiB3aXRoIHRoZSBwYXJlbnQuXG4gICAgICAgIHJlc3VsdCArPSBoYXNBbmQobmVzdGVkKSA/IG5lc3RlZC5yZXBsYWNlKHBhcmVudFJlZ0V4cCwgcGFyZW50KSA6IHBhcmVudCArICcgJyArIG5lc3RlZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0T3B0aW9ucyhydWxlLCBjb250YWluZXIsIG9wdGlvbnMpIHtcbiAgICAvLyBPcHRpb25zIGhhcyBiZWVuIGFscmVhZHkgY3JlYXRlZCwgbm93IHdlIG9ubHkgaW5jcmVhc2UgaW5kZXguXG4gICAgaWYgKG9wdGlvbnMpIHJldHVybiBfZXh0ZW5kcyh7fSwgb3B0aW9ucywgeyBpbmRleDogb3B0aW9ucy5pbmRleCArIDEgfSk7XG5cbiAgICB2YXIgbmVzdGluZ0xldmVsID0gcnVsZS5vcHRpb25zLm5lc3RpbmdMZXZlbDtcblxuICAgIG5lc3RpbmdMZXZlbCA9IG5lc3RpbmdMZXZlbCA9PT0gdW5kZWZpbmVkID8gMSA6IG5lc3RpbmdMZXZlbCArIDE7XG5cbiAgICByZXR1cm4gX2V4dGVuZHMoe30sIHJ1bGUub3B0aW9ucywge1xuICAgICAgbmVzdGluZ0xldmVsOiBuZXN0aW5nTGV2ZWwsXG4gICAgICBpbmRleDogY29udGFpbmVyLmluZGV4T2YocnVsZSkgKyAxXG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBvblByb2Nlc3NTdHlsZShzdHlsZSwgcnVsZSkge1xuICAgIGlmIChydWxlLnR5cGUgIT09ICdzdHlsZScpIHJldHVybiBzdHlsZTtcbiAgICB2YXIgY29udGFpbmVyID0gcnVsZS5vcHRpb25zLnBhcmVudDtcbiAgICB2YXIgb3B0aW9ucyA9IHZvaWQgMDtcbiAgICB2YXIgcmVwbGFjZVJlZiA9IHZvaWQgMDtcbiAgICBmb3IgKHZhciBwcm9wIGluIHN0eWxlKSB7XG4gICAgICB2YXIgaXNOZXN0ZWQgPSBoYXNBbmQocHJvcCk7XG4gICAgICB2YXIgaXNOZXN0ZWRDb25kaXRpb25hbCA9IHByb3BbMF0gPT09ICdAJztcblxuICAgICAgaWYgKCFpc05lc3RlZCAmJiAhaXNOZXN0ZWRDb25kaXRpb25hbCkgY29udGludWU7XG5cbiAgICAgIG9wdGlvbnMgPSBnZXRPcHRpb25zKHJ1bGUsIGNvbnRhaW5lciwgb3B0aW9ucyk7XG5cbiAgICAgIGlmIChpc05lc3RlZCkge1xuICAgICAgICB2YXIgc2VsZWN0b3IgPSByZXBsYWNlUGFyZW50UmVmcyhwcm9wLCBydWxlLnNlbGVjdG9yXG4gICAgICAgIC8vIExhemlseSBjcmVhdGUgdGhlIHJlZiByZXBsYWNlciBmdW5jdGlvbiBqdXN0IG9uY2UgZm9yXG4gICAgICAgIC8vIGFsbCBuZXN0ZWQgcnVsZXMgd2l0aGluIHRoZSBzaGVldC5cbiAgICAgICAgKTtpZiAoIXJlcGxhY2VSZWYpIHJlcGxhY2VSZWYgPSBnZXRSZXBsYWNlUmVmKGNvbnRhaW5lclxuICAgICAgICAvLyBSZXBsYWNlIGFsbCAkcmVmcy5cbiAgICAgICAgKTtzZWxlY3RvciA9IHNlbGVjdG9yLnJlcGxhY2UocmVmUmVnRXhwLCByZXBsYWNlUmVmKTtcblxuICAgICAgICBjb250YWluZXIuYWRkUnVsZShzZWxlY3Rvciwgc3R5bGVbcHJvcF0sIF9leHRlbmRzKHt9LCBvcHRpb25zLCB7IHNlbGVjdG9yOiBzZWxlY3RvciB9KSk7XG4gICAgICB9IGVsc2UgaWYgKGlzTmVzdGVkQ29uZGl0aW9uYWwpIHtcbiAgICAgICAgY29udGFpbmVyXG4gICAgICAgIC8vIFBsYWNlIGNvbmRpdGlvbmFsIHJpZ2h0IGFmdGVyIHRoZSBwYXJlbnQgcnVsZSB0byBlbnN1cmUgcmlnaHQgb3JkZXJpbmcuXG4gICAgICAgIC5hZGRSdWxlKHByb3AsIG51bGwsIG9wdGlvbnMpLmFkZFJ1bGUocnVsZS5rZXksIHN0eWxlW3Byb3BdLCB7IHNlbGVjdG9yOiBydWxlLnNlbGVjdG9yIH0pO1xuICAgICAgfVxuXG4gICAgICBkZWxldGUgc3R5bGVbcHJvcF07XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0eWxlO1xuICB9XG5cbiAgcmV0dXJuIHsgb25Qcm9jZXNzU3R5bGU6IG9uUHJvY2Vzc1N0eWxlIH07XG59IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2pzc1RlbXBsYXRlID0gcmVxdWlyZSgnanNzLXRlbXBsYXRlJyk7XG5cbnZhciBfanNzVGVtcGxhdGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfanNzVGVtcGxhdGUpO1xuXG52YXIgX2pzc0dsb2JhbCA9IHJlcXVpcmUoJ2pzcy1nbG9iYWwnKTtcblxudmFyIF9qc3NHbG9iYWwyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfanNzR2xvYmFsKTtcblxudmFyIF9qc3NFeHRlbmQgPSByZXF1aXJlKCdqc3MtZXh0ZW5kJyk7XG5cbnZhciBfanNzRXh0ZW5kMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2pzc0V4dGVuZCk7XG5cbnZhciBfanNzTmVzdGVkID0gcmVxdWlyZSgnanNzLW5lc3RlZCcpO1xuXG52YXIgX2pzc05lc3RlZDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9qc3NOZXN0ZWQpO1xuXG52YXIgX2pzc0NvbXBvc2UgPSByZXF1aXJlKCdqc3MtY29tcG9zZScpO1xuXG52YXIgX2pzc0NvbXBvc2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfanNzQ29tcG9zZSk7XG5cbnZhciBfanNzQ2FtZWxDYXNlID0gcmVxdWlyZSgnanNzLWNhbWVsLWNhc2UnKTtcblxudmFyIF9qc3NDYW1lbENhc2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfanNzQ2FtZWxDYXNlKTtcblxudmFyIF9qc3NEZWZhdWx0VW5pdCA9IHJlcXVpcmUoJ2pzcy1kZWZhdWx0LXVuaXQnKTtcblxudmFyIF9qc3NEZWZhdWx0VW5pdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9qc3NEZWZhdWx0VW5pdCk7XG5cbnZhciBfanNzRXhwYW5kID0gcmVxdWlyZSgnanNzLWV4cGFuZCcpO1xuXG52YXIgX2pzc0V4cGFuZDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9qc3NFeHBhbmQpO1xuXG52YXIgX2pzc1ZlbmRvclByZWZpeGVyID0gcmVxdWlyZSgnanNzLXZlbmRvci1wcmVmaXhlcicpO1xuXG52YXIgX2pzc1ZlbmRvclByZWZpeGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2pzc1ZlbmRvclByZWZpeGVyKTtcblxudmFyIF9qc3NQcm9wc1NvcnQgPSByZXF1aXJlKCdqc3MtcHJvcHMtc29ydCcpO1xuXG52YXIgX2pzc1Byb3BzU29ydDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9qc3NQcm9wc1NvcnQpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgcmV0dXJuIHtcbiAgICBwbHVnaW5zOiBbKDAsIF9qc3NUZW1wbGF0ZTIuZGVmYXVsdCkob3B0aW9ucy50ZW1wbGF0ZSksICgwLCBfanNzR2xvYmFsMi5kZWZhdWx0KShvcHRpb25zLmdsb2JhbCksICgwLCBfanNzRXh0ZW5kMi5kZWZhdWx0KShvcHRpb25zLmV4dGVuZCksICgwLCBfanNzTmVzdGVkMi5kZWZhdWx0KShvcHRpb25zLm5lc3RlZCksICgwLCBfanNzQ29tcG9zZTIuZGVmYXVsdCkob3B0aW9ucy5jb21wb3NlKSwgKDAsIF9qc3NDYW1lbENhc2UyLmRlZmF1bHQpKG9wdGlvbnMuY2FtZWxDYXNlKSwgKDAsIF9qc3NEZWZhdWx0VW5pdDIuZGVmYXVsdCkob3B0aW9ucy5kZWZhdWx0VW5pdCksICgwLCBfanNzRXhwYW5kMi5kZWZhdWx0KShvcHRpb25zLmV4cGFuZCksICgwLCBfanNzVmVuZG9yUHJlZml4ZXIyLmRlZmF1bHQpKG9wdGlvbnMudmVuZG9yUHJlZml4ZXIpLCAoMCwgX2pzc1Byb3BzU29ydDIuZGVmYXVsdCkob3B0aW9ucy5wcm9wc1NvcnQpXVxuICB9O1xufTsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzWydkZWZhdWx0J10gPSBqc3NQcm9wc1NvcnQ7XG4vKipcbiAqIFNvcnQgcHJvcHMgYnkgbGVuZ3RoLlxuICovXG5mdW5jdGlvbiBqc3NQcm9wc1NvcnQoKSB7XG4gIGZ1bmN0aW9uIHNvcnQocHJvcDAsIHByb3AxKSB7XG4gICAgcmV0dXJuIHByb3AwLmxlbmd0aCAtIHByb3AxLmxlbmd0aDtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uUHJvY2Vzc1N0eWxlKHN0eWxlLCBydWxlKSB7XG4gICAgaWYgKHJ1bGUudHlwZSAhPT0gJ3N0eWxlJykgcmV0dXJuIHN0eWxlO1xuXG4gICAgdmFyIG5ld1N0eWxlID0ge307XG4gICAgdmFyIHByb3BzID0gT2JqZWN0LmtleXMoc3R5bGUpLnNvcnQoc29ydCk7XG4gICAgZm9yICh2YXIgcHJvcCBpbiBwcm9wcykge1xuICAgICAgbmV3U3R5bGVbcHJvcHNbcHJvcF1dID0gc3R5bGVbcHJvcHNbcHJvcF1dO1xuICAgIH1cbiAgICByZXR1cm4gbmV3U3R5bGU7XG4gIH1cblxuICByZXR1cm4geyBvblByb2Nlc3NTdHlsZTogb25Qcm9jZXNzU3R5bGUgfTtcbn0iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfcGFyc2UgPSByZXF1aXJlKCcuL3BhcnNlJyk7XG5cbnZhciBfcGFyc2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcGFyc2UpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBvblByb2Nlc3NSdWxlID0gZnVuY3Rpb24gb25Qcm9jZXNzUnVsZShydWxlKSB7XG4gIGlmICh0eXBlb2YgcnVsZS5zdHlsZSA9PT0gJ3N0cmluZycpIHtcbiAgICBydWxlLnN0eWxlID0gKDAsIF9wYXJzZTJbJ2RlZmF1bHQnXSkocnVsZS5zdHlsZSk7XG4gIH1cbn07XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHsgb25Qcm9jZXNzUnVsZTogb25Qcm9jZXNzUnVsZSB9O1xufTsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfd2FybmluZyA9IHJlcXVpcmUoJ3dhcm5pbmcnKTtcblxudmFyIF93YXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dhcm5pbmcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBzZW1pV2l0aE5sID0gLztcXG4vO1xuXG4vKipcbiAqIE5haXZlIENTUyBwYXJzZXIuXG4gKiAtIFN1cHBvcnRzIG9ubHkgcnVsZSBib2R5IChubyBzZWxlY3RvcnMpXG4gKiAtIFJlcXVpcmVzIHNlbWljb2xvbiBhbmQgbmV3IGxpbmUgYWZ0ZXIgdGhlIHZhbHVlIChleGNlcHQgb2YgbGFzdCBsaW5lKVxuICogLSBObyBuZXN0ZWQgcnVsZXMgc3VwcG9ydFxuICovXG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGZ1bmN0aW9uIChjc3NUZXh0KSB7XG4gIHZhciBzdHlsZSA9IHt9O1xuICB2YXIgc3BsaXQgPSBjc3NUZXh0LnNwbGl0KHNlbWlXaXRoTmwpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHNwbGl0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlY2wgPSAoc3BsaXRbaV0gfHwgJycpLnRyaW0oKTtcblxuICAgIGlmICghZGVjbCkgY29udGludWU7XG4gICAgdmFyIGNvbG9uSW5kZXggPSBkZWNsLmluZGV4T2YoJzonKTtcbiAgICBpZiAoY29sb25JbmRleCA9PT0gLTEpIHtcbiAgICAgICgwLCBfd2FybmluZzJbJ2RlZmF1bHQnXSkoZmFsc2UsICdNYWxmb3JtZWQgQ1NTIHN0cmluZyBcIiVzXCInLCBkZWNsKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB2YXIgcHJvcCA9IGRlY2wuc3Vic3RyKDAsIGNvbG9uSW5kZXgpLnRyaW0oKTtcbiAgICB2YXIgdmFsdWUgPSBkZWNsLnN1YnN0cihjb2xvbkluZGV4ICsgMSkudHJpbSgpO1xuICAgIHN0eWxlW3Byb3BdID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHN0eWxlO1xufTsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzWydkZWZhdWx0J10gPSBqc3NWZW5kb3JQcmVmaXhlcjtcblxudmFyIF9jc3NWZW5kb3IgPSByZXF1aXJlKCdjc3MtdmVuZG9yJyk7XG5cbnZhciB2ZW5kb3IgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfY3NzVmVuZG9yKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IG5ld09ialsnZGVmYXVsdCddID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuLyoqXG4gKiBBZGQgdmVuZG9yIHByZWZpeCB0byBhIHByb3BlcnR5IG5hbWUgd2hlbiBuZWVkZWQuXG4gKlxuICogQHBhcmFtIHtSdWxlfSBydWxlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5mdW5jdGlvbiBqc3NWZW5kb3JQcmVmaXhlcigpIHtcbiAgZnVuY3Rpb24gb25Qcm9jZXNzUnVsZShydWxlKSB7XG4gICAgaWYgKHJ1bGUudHlwZSA9PT0gJ2tleWZyYW1lcycpIHtcbiAgICAgIHJ1bGUua2V5ID0gJ0AnICsgdmVuZG9yLnByZWZpeC5jc3MgKyBydWxlLmtleS5zdWJzdHIoMSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25Qcm9jZXNzU3R5bGUoc3R5bGUsIHJ1bGUpIHtcbiAgICBpZiAocnVsZS50eXBlICE9PSAnc3R5bGUnKSByZXR1cm4gc3R5bGU7XG5cbiAgICBmb3IgKHZhciBwcm9wIGluIHN0eWxlKSB7XG4gICAgICB2YXIgdmFsdWUgPSBzdHlsZVtwcm9wXTtcblxuICAgICAgdmFyIGNoYW5nZVByb3AgPSBmYWxzZTtcbiAgICAgIHZhciBzdXBwb3J0ZWRQcm9wID0gdmVuZG9yLnN1cHBvcnRlZFByb3BlcnR5KHByb3ApO1xuICAgICAgaWYgKHN1cHBvcnRlZFByb3AgJiYgc3VwcG9ydGVkUHJvcCAhPT0gcHJvcCkgY2hhbmdlUHJvcCA9IHRydWU7XG5cbiAgICAgIHZhciBjaGFuZ2VWYWx1ZSA9IGZhbHNlO1xuICAgICAgdmFyIHN1cHBvcnRlZFZhbHVlID0gdmVuZG9yLnN1cHBvcnRlZFZhbHVlKHN1cHBvcnRlZFByb3AsIHZhbHVlKTtcbiAgICAgIGlmIChzdXBwb3J0ZWRWYWx1ZSAmJiBzdXBwb3J0ZWRWYWx1ZSAhPT0gdmFsdWUpIGNoYW5nZVZhbHVlID0gdHJ1ZTtcblxuICAgICAgaWYgKGNoYW5nZVByb3AgfHwgY2hhbmdlVmFsdWUpIHtcbiAgICAgICAgaWYgKGNoYW5nZVByb3ApIGRlbGV0ZSBzdHlsZVtwcm9wXTtcbiAgICAgICAgc3R5bGVbc3VwcG9ydGVkUHJvcCB8fCBwcm9wXSA9IHN1cHBvcnRlZFZhbHVlIHx8IHZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzdHlsZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uQ2hhbmdlVmFsdWUodmFsdWUsIHByb3ApIHtcbiAgICByZXR1cm4gdmVuZG9yLnN1cHBvcnRlZFZhbHVlKHByb3AsIHZhbHVlKTtcbiAgfVxuXG4gIHJldHVybiB7IG9uUHJvY2Vzc1J1bGU6IG9uUHJvY2Vzc1J1bGUsIG9uUHJvY2Vzc1N0eWxlOiBvblByb2Nlc3NTdHlsZSwgb25DaGFuZ2VWYWx1ZTogb25DaGFuZ2VWYWx1ZSB9O1xufSIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX2lzSW5Ccm93c2VyID0gcmVxdWlyZSgnaXMtaW4tYnJvd3NlcicpO1xuXG52YXIgX2lzSW5Ccm93c2VyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2lzSW5Ccm93c2VyKTtcblxudmFyIF9TdHlsZVNoZWV0ID0gcmVxdWlyZSgnLi9TdHlsZVNoZWV0Jyk7XG5cbnZhciBfU3R5bGVTaGVldDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9TdHlsZVNoZWV0KTtcblxudmFyIF9QbHVnaW5zUmVnaXN0cnkgPSByZXF1aXJlKCcuL1BsdWdpbnNSZWdpc3RyeScpO1xuXG52YXIgX1BsdWdpbnNSZWdpc3RyeTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9QbHVnaW5zUmVnaXN0cnkpO1xuXG52YXIgX3J1bGVzID0gcmVxdWlyZSgnLi9wbHVnaW5zL3J1bGVzJyk7XG5cbnZhciBfcnVsZXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcnVsZXMpO1xuXG52YXIgX29ic2VydmFibGVzID0gcmVxdWlyZSgnLi9wbHVnaW5zL29ic2VydmFibGVzJyk7XG5cbnZhciBfb2JzZXJ2YWJsZXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfb2JzZXJ2YWJsZXMpO1xuXG52YXIgX2Z1bmN0aW9ucyA9IHJlcXVpcmUoJy4vcGx1Z2lucy9mdW5jdGlvbnMnKTtcblxudmFyIF9mdW5jdGlvbnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZnVuY3Rpb25zKTtcblxudmFyIF9zaGVldHMgPSByZXF1aXJlKCcuL3NoZWV0cycpO1xuXG52YXIgX3NoZWV0czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zaGVldHMpO1xuXG52YXIgX1N0eWxlUnVsZSA9IHJlcXVpcmUoJy4vcnVsZXMvU3R5bGVSdWxlJyk7XG5cbnZhciBfU3R5bGVSdWxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1N0eWxlUnVsZSk7XG5cbnZhciBfY3JlYXRlR2VuZXJhdGVDbGFzc05hbWUgPSByZXF1aXJlKCcuL3V0aWxzL2NyZWF0ZUdlbmVyYXRlQ2xhc3NOYW1lJyk7XG5cbnZhciBfY3JlYXRlR2VuZXJhdGVDbGFzc05hbWUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlR2VuZXJhdGVDbGFzc05hbWUpO1xuXG52YXIgX2NyZWF0ZVJ1bGUyID0gcmVxdWlyZSgnLi91dGlscy9jcmVhdGVSdWxlJyk7XG5cbnZhciBfY3JlYXRlUnVsZTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVSdWxlMik7XG5cbnZhciBfRG9tUmVuZGVyZXIgPSByZXF1aXJlKCcuL3JlbmRlcmVycy9Eb21SZW5kZXJlcicpO1xuXG52YXIgX0RvbVJlbmRlcmVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0RvbVJlbmRlcmVyKTtcblxudmFyIF9WaXJ0dWFsUmVuZGVyZXIgPSByZXF1aXJlKCcuL3JlbmRlcmVycy9WaXJ0dWFsUmVuZGVyZXInKTtcblxudmFyIF9WaXJ0dWFsUmVuZGVyZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVmlydHVhbFJlbmRlcmVyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgZGVmYXVsdFBsdWdpbnMgPSBfcnVsZXMyWydkZWZhdWx0J10uY29uY2F0KFtfb2JzZXJ2YWJsZXMyWydkZWZhdWx0J10sIF9mdW5jdGlvbnMyWydkZWZhdWx0J11dKTtcblxudmFyIGluc3RhbmNlQ291bnRlciA9IDA7XG5cbnZhciBKc3MgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEpzcyhvcHRpb25zKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEpzcyk7XG5cbiAgICB0aGlzLmlkID0gaW5zdGFuY2VDb3VudGVyKys7XG4gICAgdGhpcy52ZXJzaW9uID0gXCI5LjUuMVwiO1xuICAgIHRoaXMucGx1Z2lucyA9IG5ldyBfUGx1Z2luc1JlZ2lzdHJ5MlsnZGVmYXVsdCddKCk7XG4gICAgdGhpcy5vcHRpb25zID0ge1xuICAgICAgY3JlYXRlR2VuZXJhdGVDbGFzc05hbWU6IF9jcmVhdGVHZW5lcmF0ZUNsYXNzTmFtZTJbJ2RlZmF1bHQnXSxcbiAgICAgIFJlbmRlcmVyOiBfaXNJbkJyb3dzZXIyWydkZWZhdWx0J10gPyBfRG9tUmVuZGVyZXIyWydkZWZhdWx0J10gOiBfVmlydHVhbFJlbmRlcmVyMlsnZGVmYXVsdCddLFxuICAgICAgcGx1Z2luczogW11cbiAgICB9O1xuICAgIHRoaXMuZ2VuZXJhdGVDbGFzc05hbWUgPSAoMCwgX2NyZWF0ZUdlbmVyYXRlQ2xhc3NOYW1lMlsnZGVmYXVsdCddKSgpO1xuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1zcHJlYWRcbiAgICB0aGlzLnVzZS5hcHBseSh0aGlzLCBkZWZhdWx0UGx1Z2lucyk7XG4gICAgdGhpcy5zZXR1cChvcHRpb25zKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhKc3MsIFt7XG4gICAga2V5OiAnc2V0dXAnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXR1cCgpIHtcbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgICAgaWYgKG9wdGlvbnMuY3JlYXRlR2VuZXJhdGVDbGFzc05hbWUpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLmNyZWF0ZUdlbmVyYXRlQ2xhc3NOYW1lID0gb3B0aW9ucy5jcmVhdGVHZW5lcmF0ZUNsYXNzTmFtZTtcbiAgICAgICAgLy8gJEZsb3dGaXhNZVxuICAgICAgICB0aGlzLmdlbmVyYXRlQ2xhc3NOYW1lID0gb3B0aW9ucy5jcmVhdGVHZW5lcmF0ZUNsYXNzTmFtZSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5pbnNlcnRpb25Qb2ludCAhPSBudWxsKSB0aGlzLm9wdGlvbnMuaW5zZXJ0aW9uUG9pbnQgPSBvcHRpb25zLmluc2VydGlvblBvaW50O1xuICAgICAgaWYgKG9wdGlvbnMudmlydHVhbCB8fCBvcHRpb25zLlJlbmRlcmVyKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5SZW5kZXJlciA9IG9wdGlvbnMuUmVuZGVyZXIgfHwgKG9wdGlvbnMudmlydHVhbCA/IF9WaXJ0dWFsUmVuZGVyZXIyWydkZWZhdWx0J10gOiBfRG9tUmVuZGVyZXIyWydkZWZhdWx0J10pO1xuICAgICAgfVxuXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLXNwcmVhZFxuICAgICAgaWYgKG9wdGlvbnMucGx1Z2lucykgdGhpcy51c2UuYXBwbHkodGhpcywgb3B0aW9ucy5wbHVnaW5zKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgU3R5bGUgU2hlZXQuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2NyZWF0ZVN0eWxlU2hlZXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVTdHlsZVNoZWV0KHN0eWxlcykge1xuICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgICB2YXIgaW5kZXggPSBvcHRpb25zLmluZGV4O1xuICAgICAgaWYgKHR5cGVvZiBpbmRleCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgaW5kZXggPSBfc2hlZXRzMlsnZGVmYXVsdCddLmluZGV4ID09PSAwID8gMCA6IF9zaGVldHMyWydkZWZhdWx0J10uaW5kZXggKyAxO1xuICAgICAgfVxuICAgICAgdmFyIHNoZWV0ID0gbmV3IF9TdHlsZVNoZWV0MlsnZGVmYXVsdCddKHN0eWxlcywgX2V4dGVuZHMoe30sIG9wdGlvbnMsIHtcbiAgICAgICAganNzOiB0aGlzLFxuICAgICAgICBnZW5lcmF0ZUNsYXNzTmFtZTogb3B0aW9ucy5nZW5lcmF0ZUNsYXNzTmFtZSB8fCB0aGlzLmdlbmVyYXRlQ2xhc3NOYW1lLFxuICAgICAgICBpbnNlcnRpb25Qb2ludDogdGhpcy5vcHRpb25zLmluc2VydGlvblBvaW50LFxuICAgICAgICBSZW5kZXJlcjogdGhpcy5vcHRpb25zLlJlbmRlcmVyLFxuICAgICAgICBpbmRleDogaW5kZXhcbiAgICAgIH0pKTtcbiAgICAgIHRoaXMucGx1Z2lucy5vblByb2Nlc3NTaGVldChzaGVldCk7XG5cbiAgICAgIHJldHVybiBzaGVldDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXRhY2ggdGhlIFN0eWxlIFNoZWV0IGFuZCByZW1vdmUgaXQgZnJvbSB0aGUgcmVnaXN0cnkuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3JlbW92ZVN0eWxlU2hlZXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVTdHlsZVNoZWV0KHNoZWV0KSB7XG4gICAgICBzaGVldC5kZXRhY2goKTtcbiAgICAgIF9zaGVldHMyWydkZWZhdWx0J10ucmVtb3ZlKHNoZWV0KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIHJ1bGUgd2l0aG91dCBhIFN0eWxlIFNoZWV0LlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdjcmVhdGVSdWxlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlUnVsZShuYW1lKSB7XG4gICAgICB2YXIgc3R5bGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuXG4gICAgICAvLyBFbmFibGUgcnVsZSB3aXRob3V0IG5hbWUgZm9yIGlubGluZSBzdHlsZXMuXG4gICAgICBpZiAoKHR5cGVvZiBuYW1lID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihuYW1lKSkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIG9wdGlvbnMgPSBzdHlsZTtcbiAgICAgICAgc3R5bGUgPSBuYW1lO1xuICAgICAgICBuYW1lID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICAvLyBDYXN0IGZyb20gUnVsZUZhY3RvcnlPcHRpb25zIHRvIFJ1bGVPcHRpb25zXG4gICAgICAvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy80MTMyODcyOC9mb3JjZS1jYXN0aW5nLWluLWZsb3dcbiAgICAgIHZhciBydWxlT3B0aW9ucyA9IG9wdGlvbnM7XG5cbiAgICAgIHJ1bGVPcHRpb25zLmpzcyA9IHRoaXM7XG4gICAgICBydWxlT3B0aW9ucy5SZW5kZXJlciA9IHRoaXMub3B0aW9ucy5SZW5kZXJlcjtcbiAgICAgIGlmICghcnVsZU9wdGlvbnMuZ2VuZXJhdGVDbGFzc05hbWUpIHJ1bGVPcHRpb25zLmdlbmVyYXRlQ2xhc3NOYW1lID0gdGhpcy5nZW5lcmF0ZUNsYXNzTmFtZTtcbiAgICAgIGlmICghcnVsZU9wdGlvbnMuY2xhc3NlcykgcnVsZU9wdGlvbnMuY2xhc3NlcyA9IHt9O1xuICAgICAgdmFyIHJ1bGUgPSAoMCwgX2NyZWF0ZVJ1bGUzWydkZWZhdWx0J10pKG5hbWUsIHN0eWxlLCBydWxlT3B0aW9ucyk7XG5cbiAgICAgIGlmICghcnVsZU9wdGlvbnMuc2VsZWN0b3IgJiYgcnVsZSBpbnN0YW5jZW9mIF9TdHlsZVJ1bGUyWydkZWZhdWx0J10pIHtcbiAgICAgICAgcnVsZS5zZWxlY3RvciA9ICcuJyArIHJ1bGVPcHRpb25zLmdlbmVyYXRlQ2xhc3NOYW1lKHJ1bGUpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnBsdWdpbnMub25Qcm9jZXNzUnVsZShydWxlKTtcblxuICAgICAgcmV0dXJuIHJ1bGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgcGx1Z2luLiBQYXNzZWQgZnVuY3Rpb24gd2lsbCBiZSBpbnZva2VkIHdpdGggYSBydWxlIGluc3RhbmNlLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICd1c2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1c2UoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcGx1Z2lucyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBwbHVnaW5zW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICBwbHVnaW5zLmZvckVhY2goZnVuY3Rpb24gKHBsdWdpbikge1xuICAgICAgICAvLyBBdm9pZHMgYXBwbHlpbmcgc2FtZSBwbHVnaW4gdHdpY2UsIGF0IGxlYXN0IGJhc2VkIG9uIHJlZi5cbiAgICAgICAgaWYgKF90aGlzLm9wdGlvbnMucGx1Z2lucy5pbmRleE9mKHBsdWdpbikgPT09IC0xKSB7XG4gICAgICAgICAgX3RoaXMub3B0aW9ucy5wbHVnaW5zLnB1c2gocGx1Z2luKTtcbiAgICAgICAgICBfdGhpcy5wbHVnaW5zLnVzZShwbHVnaW4pO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEpzcztcbn0oKTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gSnNzOyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF93YXJuaW5nID0gcmVxdWlyZSgnd2FybmluZycpO1xuXG52YXIgX3dhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd2FybmluZyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIFBsdWdpbnNSZWdpc3RyeSA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUGx1Z2luc1JlZ2lzdHJ5KCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQbHVnaW5zUmVnaXN0cnkpO1xuXG4gICAgdGhpcy5ob29rcyA9IHtcbiAgICAgIG9uQ3JlYXRlUnVsZTogW10sXG4gICAgICBvblByb2Nlc3NSdWxlOiBbXSxcbiAgICAgIG9uUHJvY2Vzc1N0eWxlOiBbXSxcbiAgICAgIG9uUHJvY2Vzc1NoZWV0OiBbXSxcbiAgICAgIG9uQ2hhbmdlVmFsdWU6IFtdLFxuICAgICAgb25VcGRhdGU6IFtdXG5cbiAgICAgIC8qKlxuICAgICAgICogQ2FsbCBgb25DcmVhdGVSdWxlYCBob29rcyBhbmQgcmV0dXJuIGFuIG9iamVjdCBpZiByZXR1cm5lZCBieSBhIGhvb2suXG4gICAgICAgKi9cbiAgICB9O1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFBsdWdpbnNSZWdpc3RyeSwgW3tcbiAgICBrZXk6ICdvbkNyZWF0ZVJ1bGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkNyZWF0ZVJ1bGUobmFtZSwgZGVjbCwgb3B0aW9ucykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmhvb2tzLm9uQ3JlYXRlUnVsZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcnVsZSA9IHRoaXMuaG9va3Mub25DcmVhdGVSdWxlW2ldKG5hbWUsIGRlY2wsIG9wdGlvbnMpO1xuICAgICAgICBpZiAocnVsZSkgcmV0dXJuIHJ1bGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxsIGBvblByb2Nlc3NSdWxlYCBob29rcy5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnb25Qcm9jZXNzUnVsZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uUHJvY2Vzc1J1bGUocnVsZSkge1xuICAgICAgaWYgKHJ1bGUuaXNQcm9jZXNzZWQpIHJldHVybjtcbiAgICAgIHZhciBzaGVldCA9IHJ1bGUub3B0aW9ucy5zaGVldDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmhvb2tzLm9uUHJvY2Vzc1J1bGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5ob29rcy5vblByb2Nlc3NSdWxlW2ldKHJ1bGUsIHNoZWV0KTtcbiAgICAgIH1cblxuICAgICAgLy8gJEZsb3dGaXhNZVxuICAgICAgaWYgKHJ1bGUuc3R5bGUpIHRoaXMub25Qcm9jZXNzU3R5bGUocnVsZS5zdHlsZSwgcnVsZSwgc2hlZXQpO1xuXG4gICAgICBydWxlLmlzUHJvY2Vzc2VkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxsIGBvblByb2Nlc3NTdHlsZWAgaG9va3MuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ29uUHJvY2Vzc1N0eWxlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25Qcm9jZXNzU3R5bGUoc3R5bGUsIHJ1bGUsIHNoZWV0KSB7XG4gICAgICB2YXIgbmV4dFN0eWxlID0gc3R5bGU7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ob29rcy5vblByb2Nlc3NTdHlsZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBuZXh0U3R5bGUgPSB0aGlzLmhvb2tzLm9uUHJvY2Vzc1N0eWxlW2ldKG5leHRTdHlsZSwgcnVsZSwgc2hlZXQpO1xuICAgICAgICAvLyAkRmxvd0ZpeE1lXG4gICAgICAgIHJ1bGUuc3R5bGUgPSBuZXh0U3R5bGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbCBgb25Qcm9jZXNzU2hlZXRgIGhvb2tzLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdvblByb2Nlc3NTaGVldCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uUHJvY2Vzc1NoZWV0KHNoZWV0KSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaG9va3Mub25Qcm9jZXNzU2hlZXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5ob29rcy5vblByb2Nlc3NTaGVldFtpXShzaGVldCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbCBgb25VcGRhdGVgIGhvb2tzLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdvblVwZGF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uVXBkYXRlKGRhdGEsIHJ1bGUsIHNoZWV0KSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaG9va3Mub25VcGRhdGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5ob29rcy5vblVwZGF0ZVtpXShkYXRhLCBydWxlLCBzaGVldCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbCBgb25DaGFuZ2VWYWx1ZWAgaG9va3MuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ29uQ2hhbmdlVmFsdWUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkNoYW5nZVZhbHVlKHZhbHVlLCBwcm9wLCBydWxlKSB7XG4gICAgICB2YXIgcHJvY2Vzc2VkVmFsdWUgPSB2YWx1ZTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ob29rcy5vbkNoYW5nZVZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHByb2Nlc3NlZFZhbHVlID0gdGhpcy5ob29rcy5vbkNoYW5nZVZhbHVlW2ldKHByb2Nlc3NlZFZhbHVlLCBwcm9wLCBydWxlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwcm9jZXNzZWRWYWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlciBhIHBsdWdpbi5cbiAgICAgKiBJZiBmdW5jdGlvbiBpcyBwYXNzZWQsIGl0IGlzIGEgc2hvcnRjdXQgZm9yIGB7b25Qcm9jZXNzUnVsZX1gLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICd1c2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1c2UocGx1Z2luKSB7XG4gICAgICBmb3IgKHZhciBuYW1lIGluIHBsdWdpbikge1xuICAgICAgICBpZiAodGhpcy5ob29rc1tuYW1lXSkgdGhpcy5ob29rc1tuYW1lXS5wdXNoKHBsdWdpbltuYW1lXSk7ZWxzZSAoMCwgX3dhcm5pbmcyWydkZWZhdWx0J10pKGZhbHNlLCAnW0pTU10gVW5rbm93biBob29rIFwiJXNcIi4nLCBuYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUGx1Z2luc1JlZ2lzdHJ5O1xufSgpO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBQbHVnaW5zUmVnaXN0cnk7IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX2NyZWF0ZVJ1bGUgPSByZXF1aXJlKCcuL3V0aWxzL2NyZWF0ZVJ1bGUnKTtcblxudmFyIF9jcmVhdGVSdWxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZVJ1bGUpO1xuXG52YXIgX2xpbmtSdWxlID0gcmVxdWlyZSgnLi91dGlscy9saW5rUnVsZScpO1xuXG52YXIgX2xpbmtSdWxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2xpbmtSdWxlKTtcblxudmFyIF9TdHlsZVJ1bGUgPSByZXF1aXJlKCcuL3J1bGVzL1N0eWxlUnVsZScpO1xuXG52YXIgX1N0eWxlUnVsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9TdHlsZVJ1bGUpO1xuXG52YXIgX2VzY2FwZSA9IHJlcXVpcmUoJy4vdXRpbHMvZXNjYXBlJyk7XG5cbnZhciBfZXNjYXBlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2VzY2FwZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuLyoqXG4gKiBDb250YWlucyBydWxlcyBvYmplY3RzIGFuZCBhbGxvd3MgYWRkaW5nL3JlbW92aW5nIGV0Yy5cbiAqIElzIHVzZWQgZm9yIGUuZy4gYnkgYFN0eWxlU2hlZXRgIG9yIGBDb25kaXRpb25hbFJ1bGVgLlxuICovXG52YXIgUnVsZUxpc3QgPSBmdW5jdGlvbiAoKSB7XG5cbiAgLy8gT3JpZ2luYWwgc3R5bGVzIG9iamVjdC5cbiAgZnVuY3Rpb24gUnVsZUxpc3Qob3B0aW9ucykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSdWxlTGlzdCk7XG5cbiAgICB0aGlzLm1hcCA9IHt9O1xuICAgIHRoaXMucmF3ID0ge307XG4gICAgdGhpcy5pbmRleCA9IFtdO1xuXG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLmNsYXNzZXMgPSBvcHRpb25zLmNsYXNzZXM7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGFuZCByZWdpc3RlciBydWxlLlxuICAgKlxuICAgKiBXaWxsIG5vdCByZW5kZXIgYWZ0ZXIgU3R5bGUgU2hlZXQgd2FzIHJlbmRlcmVkIHRoZSBmaXJzdCB0aW1lLlxuICAgKi9cblxuXG4gIC8vIFVzZWQgdG8gZW5zdXJlIGNvcnJlY3QgcnVsZXMgb3JkZXIuXG5cbiAgLy8gUnVsZXMgcmVnaXN0cnkgZm9yIGFjY2VzcyBieSAuZ2V0KCkgbWV0aG9kLlxuICAvLyBJdCBjb250YWlucyB0aGUgc2FtZSBydWxlIHJlZ2lzdGVyZWQgYnkgbmFtZSBhbmQgYnkgc2VsZWN0b3IuXG5cblxuICBfY3JlYXRlQ2xhc3MoUnVsZUxpc3QsIFt7XG4gICAga2V5OiAnYWRkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkKG5hbWUsIGRlY2wsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBfb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgICBwYXJlbnQgPSBfb3B0aW9ucy5wYXJlbnQsXG4gICAgICAgICAgc2hlZXQgPSBfb3B0aW9ucy5zaGVldCxcbiAgICAgICAgICBqc3MgPSBfb3B0aW9ucy5qc3MsXG4gICAgICAgICAgUmVuZGVyZXIgPSBfb3B0aW9ucy5SZW5kZXJlcixcbiAgICAgICAgICBnZW5lcmF0ZUNsYXNzTmFtZSA9IF9vcHRpb25zLmdlbmVyYXRlQ2xhc3NOYW1lO1xuXG5cbiAgICAgIG9wdGlvbnMgPSBfZXh0ZW5kcyh7XG4gICAgICAgIGNsYXNzZXM6IHRoaXMuY2xhc3NlcyxcbiAgICAgICAgcGFyZW50OiBwYXJlbnQsXG4gICAgICAgIHNoZWV0OiBzaGVldCxcbiAgICAgICAganNzOiBqc3MsXG4gICAgICAgIFJlbmRlcmVyOiBSZW5kZXJlcixcbiAgICAgICAgZ2VuZXJhdGVDbGFzc05hbWU6IGdlbmVyYXRlQ2xhc3NOYW1lXG4gICAgICB9LCBvcHRpb25zKTtcblxuICAgICAgaWYgKCFvcHRpb25zLnNlbGVjdG9yICYmIHRoaXMuY2xhc3Nlc1tuYW1lXSkge1xuICAgICAgICBvcHRpb25zLnNlbGVjdG9yID0gJy4nICsgKDAsIF9lc2NhcGUyWydkZWZhdWx0J10pKHRoaXMuY2xhc3Nlc1tuYW1lXSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucmF3W25hbWVdID0gZGVjbDtcblxuICAgICAgdmFyIHJ1bGUgPSAoMCwgX2NyZWF0ZVJ1bGUyWydkZWZhdWx0J10pKG5hbWUsIGRlY2wsIG9wdGlvbnMpO1xuXG4gICAgICB2YXIgY2xhc3NOYW1lID0gdm9pZCAwO1xuXG4gICAgICBpZiAoIW9wdGlvbnMuc2VsZWN0b3IgJiYgcnVsZSBpbnN0YW5jZW9mIF9TdHlsZVJ1bGUyWydkZWZhdWx0J10pIHtcbiAgICAgICAgY2xhc3NOYW1lID0gZ2VuZXJhdGVDbGFzc05hbWUocnVsZSwgc2hlZXQpO1xuICAgICAgICBydWxlLnNlbGVjdG9yID0gJy4nICsgKDAsIF9lc2NhcGUyWydkZWZhdWx0J10pKGNsYXNzTmFtZSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucmVnaXN0ZXIocnVsZSwgY2xhc3NOYW1lKTtcblxuICAgICAgdmFyIGluZGV4ID0gb3B0aW9ucy5pbmRleCA9PT0gdW5kZWZpbmVkID8gdGhpcy5pbmRleC5sZW5ndGggOiBvcHRpb25zLmluZGV4O1xuICAgICAgdGhpcy5pbmRleC5zcGxpY2UoaW5kZXgsIDAsIHJ1bGUpO1xuXG4gICAgICByZXR1cm4gcnVsZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgYSBydWxlLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdnZXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXQobmFtZSkge1xuICAgICAgcmV0dXJuIHRoaXMubWFwW25hbWVdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBhIHJ1bGUuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3JlbW92ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZShydWxlKSB7XG4gICAgICB0aGlzLnVucmVnaXN0ZXIocnVsZSk7XG4gICAgICB0aGlzLmluZGV4LnNwbGljZSh0aGlzLmluZGV4T2YocnVsZSksIDEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBpbmRleCBvZiBhIHJ1bGUuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2luZGV4T2YnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbmRleE9mKHJ1bGUpIHtcbiAgICAgIHJldHVybiB0aGlzLmluZGV4LmluZGV4T2YocnVsZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUnVuIGBvblByb2Nlc3NSdWxlKClgIHBsdWdpbnMgb24gZXZlcnkgcnVsZS5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAncHJvY2VzcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByb2Nlc3MoKSB7XG4gICAgICB2YXIgcGx1Z2lucyA9IHRoaXMub3B0aW9ucy5qc3MucGx1Z2lucztcbiAgICAgIC8vIFdlIG5lZWQgdG8gY2xvbmUgYXJyYXkgYmVjYXVzZSBpZiB3ZSBtb2RpZnkgdGhlIGluZGV4IHNvbWV3aGVyZSBlbHNlIGR1cmluZyBhIGxvb3BcbiAgICAgIC8vIHdlIGVuZCB1cCB3aXRoIHZlcnkgaGFyZC10by10cmFjay1kb3duIHNpZGUgZWZmZWN0cy5cblxuICAgICAgdGhpcy5pbmRleC5zbGljZSgwKS5mb3JFYWNoKHBsdWdpbnMub25Qcm9jZXNzUnVsZSwgcGx1Z2lucyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgYSBydWxlIGluIGAubWFwYCBhbmQgYC5jbGFzc2VzYCBtYXBzLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdyZWdpc3RlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlZ2lzdGVyKHJ1bGUsIGNsYXNzTmFtZSkge1xuICAgICAgdGhpcy5tYXBbcnVsZS5rZXldID0gcnVsZTtcbiAgICAgIGlmIChydWxlIGluc3RhbmNlb2YgX1N0eWxlUnVsZTJbJ2RlZmF1bHQnXSkge1xuICAgICAgICB0aGlzLm1hcFtydWxlLnNlbGVjdG9yXSA9IHJ1bGU7XG4gICAgICAgIGlmIChjbGFzc05hbWUpIHRoaXMuY2xhc3Nlc1tydWxlLmtleV0gPSBjbGFzc05hbWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVW5yZWdpc3RlciBhIHJ1bGUuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3VucmVnaXN0ZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bnJlZ2lzdGVyKHJ1bGUpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLm1hcFtydWxlLmtleV07XG4gICAgICBpZiAocnVsZSBpbnN0YW5jZW9mIF9TdHlsZVJ1bGUyWydkZWZhdWx0J10pIHtcbiAgICAgICAgZGVsZXRlIHRoaXMubWFwW3J1bGUuc2VsZWN0b3JdO1xuICAgICAgICBkZWxldGUgdGhpcy5jbGFzc2VzW3J1bGUua2V5XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIGZ1bmN0aW9uIHZhbHVlcyB3aXRoIGEgbmV3IGRhdGEuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3VwZGF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZShuYW1lLCBkYXRhKSB7XG4gICAgICB2YXIgX29wdGlvbnMyID0gdGhpcy5vcHRpb25zLFxuICAgICAgICAgIHBsdWdpbnMgPSBfb3B0aW9uczIuanNzLnBsdWdpbnMsXG4gICAgICAgICAgc2hlZXQgPSBfb3B0aW9uczIuc2hlZXQ7XG5cbiAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcGx1Z2lucy5vblVwZGF0ZShkYXRhLCB0aGlzLmdldChuYW1lKSwgc2hlZXQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLmluZGV4Lmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICBwbHVnaW5zLm9uVXBkYXRlKG5hbWUsIHRoaXMuaW5kZXhbaW5kZXhdLCBzaGVldCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGluayByZW5kZXJhYmxlIHJ1bGVzIHdpdGggQ1NTUnVsZUxpc3QuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2xpbmsnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsaW5rKGNzc1J1bGVzKSB7XG4gICAgICB2YXIgbWFwID0gdGhpcy5vcHRpb25zLnNoZWV0LnJlbmRlcmVyLmdldFVuZXNjYXBlZEtleXNNYXAodGhpcy5pbmRleCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY3NzUnVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNzc1J1bGUgPSBjc3NSdWxlc1tpXTtcbiAgICAgICAgdmFyIF9rZXkgPSB0aGlzLm9wdGlvbnMuc2hlZXQucmVuZGVyZXIuZ2V0S2V5KGNzc1J1bGUpO1xuICAgICAgICBpZiAobWFwW19rZXldKSBfa2V5ID0gbWFwW19rZXldO1xuICAgICAgICB2YXIgcnVsZSA9IHRoaXMubWFwW19rZXldO1xuICAgICAgICBpZiAocnVsZSkgKDAsIF9saW5rUnVsZTJbJ2RlZmF1bHQnXSkocnVsZSwgY3NzUnVsZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydCBydWxlcyB0byBhIENTUyBzdHJpbmcuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3RvU3RyaW5nJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcob3B0aW9ucykge1xuICAgICAgdmFyIHN0ciA9ICcnO1xuICAgICAgdmFyIHNoZWV0ID0gdGhpcy5vcHRpb25zLnNoZWV0O1xuXG4gICAgICB2YXIgbGluayA9IHNoZWV0ID8gc2hlZXQub3B0aW9ucy5saW5rIDogZmFsc2U7XG5cbiAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLmluZGV4Lmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICB2YXIgcnVsZSA9IHRoaXMuaW5kZXhbaW5kZXhdO1xuICAgICAgICB2YXIgY3NzID0gcnVsZS50b1N0cmluZyhvcHRpb25zKTtcblxuICAgICAgICAvLyBObyBuZWVkIHRvIHJlbmRlciBhbiBlbXB0eSBydWxlLlxuICAgICAgICBpZiAoIWNzcyAmJiAhbGluaykgY29udGludWU7XG5cbiAgICAgICAgaWYgKHN0cikgc3RyICs9ICdcXG4nO1xuICAgICAgICBzdHIgKz0gY3NzO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBSdWxlTGlzdDtcbn0oKTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gUnVsZUxpc3Q7IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX3dhcm5pbmcgPSByZXF1aXJlKCd3YXJuaW5nJyk7XG5cbnZhciBfd2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93YXJuaW5nKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4vKipcbiAqIFNoZWV0c01hbmFnZXIgaXMgbGlrZSBhIFdlYWtNYXAgd2hpY2ggaXMgZGVzaWduZWQgdG8gY291bnQgU3R5bGVTaGVldFxuICogaW5zdGFuY2VzIGFuZCBhdHRhY2gvZGV0YWNoIGF1dG9tYXRpY2FsbHkuXG4gKi9cbnZhciBTaGVldHNNYW5hZ2VyID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTaGVldHNNYW5hZ2VyKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTaGVldHNNYW5hZ2VyKTtcblxuICAgIHRoaXMuc2hlZXRzID0gW107XG4gICAgdGhpcy5yZWZzID0gW107XG4gICAgdGhpcy5rZXlzID0gW107XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoU2hlZXRzTWFuYWdlciwgW3tcbiAgICBrZXk6ICdnZXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXQoa2V5KSB7XG4gICAgICB2YXIgaW5kZXggPSB0aGlzLmtleXMuaW5kZXhPZihrZXkpO1xuICAgICAgcmV0dXJuIHRoaXMuc2hlZXRzW2luZGV4XTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdhZGQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGQoa2V5LCBzaGVldCkge1xuICAgICAgdmFyIHNoZWV0cyA9IHRoaXMuc2hlZXRzLFxuICAgICAgICAgIHJlZnMgPSB0aGlzLnJlZnMsXG4gICAgICAgICAga2V5cyA9IHRoaXMua2V5cztcblxuICAgICAgdmFyIGluZGV4ID0gc2hlZXRzLmluZGV4T2Yoc2hlZXQpO1xuXG4gICAgICBpZiAoaW5kZXggIT09IC0xKSByZXR1cm4gaW5kZXg7XG5cbiAgICAgIHNoZWV0cy5wdXNoKHNoZWV0KTtcbiAgICAgIHJlZnMucHVzaCgwKTtcbiAgICAgIGtleXMucHVzaChrZXkpO1xuXG4gICAgICByZXR1cm4gc2hlZXRzLmxlbmd0aCAtIDE7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnbWFuYWdlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWFuYWdlKGtleSkge1xuICAgICAgdmFyIGluZGV4ID0gdGhpcy5rZXlzLmluZGV4T2Yoa2V5KTtcbiAgICAgIHZhciBzaGVldCA9IHRoaXMuc2hlZXRzW2luZGV4XTtcbiAgICAgIGlmICh0aGlzLnJlZnNbaW5kZXhdID09PSAwKSBzaGVldC5hdHRhY2goKTtcbiAgICAgIHRoaXMucmVmc1tpbmRleF0rKztcbiAgICAgIGlmICghdGhpcy5rZXlzW2luZGV4XSkgdGhpcy5rZXlzLnNwbGljZShpbmRleCwgMCwga2V5KTtcbiAgICAgIHJldHVybiBzaGVldDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd1bm1hbmFnZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVubWFuYWdlKGtleSkge1xuICAgICAgdmFyIGluZGV4ID0gdGhpcy5rZXlzLmluZGV4T2Yoa2V5KTtcbiAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgLy8gZXNsaW50LWlnbm9yZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICAoMCwgX3dhcm5pbmcyWydkZWZhdWx0J10pKGZhbHNlLCAnU2hlZXRzTWFuYWdlcjogY2FuXFwndCBmaW5kIHNoZWV0IHRvIHVubWFuYWdlJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnJlZnNbaW5kZXhdID4gMCkge1xuICAgICAgICB0aGlzLnJlZnNbaW5kZXhdLS07XG4gICAgICAgIGlmICh0aGlzLnJlZnNbaW5kZXhdID09PSAwKSB0aGlzLnNoZWV0c1tpbmRleF0uZGV0YWNoKCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc2l6ZScsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5rZXlzLmxlbmd0aDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU2hlZXRzTWFuYWdlcjtcbn0oKTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gU2hlZXRzTWFuYWdlcjsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbi8qKlxuICogU2hlZXRzIHJlZ2lzdHJ5IHRvIGFjY2VzcyB0aGVtIGFsbCBhdCBvbmUgcGxhY2UuXG4gKi9cbnZhciBTaGVldHNSZWdpc3RyeSA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU2hlZXRzUmVnaXN0cnkoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNoZWV0c1JlZ2lzdHJ5KTtcblxuICAgIHRoaXMucmVnaXN0cnkgPSBbXTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhTaGVldHNSZWdpc3RyeSwgW3tcbiAgICBrZXk6ICdhZGQnLFxuXG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlciBhIFN0eWxlIFNoZWV0LlxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGQoc2hlZXQpIHtcbiAgICAgIHZhciByZWdpc3RyeSA9IHRoaXMucmVnaXN0cnk7XG4gICAgICB2YXIgaW5kZXggPSBzaGVldC5vcHRpb25zLmluZGV4O1xuXG5cbiAgICAgIGlmIChyZWdpc3RyeS5pbmRleE9mKHNoZWV0KSAhPT0gLTEpIHJldHVybjtcblxuICAgICAgaWYgKHJlZ2lzdHJ5Lmxlbmd0aCA9PT0gMCB8fCBpbmRleCA+PSB0aGlzLmluZGV4KSB7XG4gICAgICAgIHJlZ2lzdHJ5LnB1c2goc2hlZXQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIEZpbmQgYSBwb3NpdGlvbi5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVnaXN0cnkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHJlZ2lzdHJ5W2ldLm9wdGlvbnMuaW5kZXggPiBpbmRleCkge1xuICAgICAgICAgIHJlZ2lzdHJ5LnNwbGljZShpLCAwLCBzaGVldCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVzZXQgdGhlIHJlZ2lzdHJ5LlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdyZXNldCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgdGhpcy5yZWdpc3RyeSA9IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhIFN0eWxlIFNoZWV0LlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdyZW1vdmUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmUoc2hlZXQpIHtcbiAgICAgIHZhciBpbmRleCA9IHRoaXMucmVnaXN0cnkuaW5kZXhPZihzaGVldCk7XG4gICAgICB0aGlzLnJlZ2lzdHJ5LnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydCBhbGwgYXR0YWNoZWQgc2hlZXRzIHRvIGEgQ1NTIHN0cmluZy5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAndG9TdHJpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZyhvcHRpb25zKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZWdpc3RyeS5maWx0ZXIoZnVuY3Rpb24gKHNoZWV0KSB7XG4gICAgICAgIHJldHVybiBzaGVldC5hdHRhY2hlZDtcbiAgICAgIH0pLm1hcChmdW5jdGlvbiAoc2hlZXQpIHtcbiAgICAgICAgcmV0dXJuIHNoZWV0LnRvU3RyaW5nKG9wdGlvbnMpO1xuICAgICAgfSkuam9pbignXFxuJyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnaW5kZXgnLFxuXG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50IGhpZ2hlc3QgaW5kZXggbnVtYmVyLlxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMucmVnaXN0cnkubGVuZ3RoID09PSAwID8gMCA6IHRoaXMucmVnaXN0cnlbdGhpcy5yZWdpc3RyeS5sZW5ndGggLSAxXS5vcHRpb25zLmluZGV4O1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTaGVldHNSZWdpc3RyeTtcbn0oKTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gU2hlZXRzUmVnaXN0cnk7IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX2xpbmtSdWxlID0gcmVxdWlyZSgnLi91dGlscy9saW5rUnVsZScpO1xuXG52YXIgX2xpbmtSdWxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2xpbmtSdWxlKTtcblxudmFyIF9SdWxlTGlzdCA9IHJlcXVpcmUoJy4vUnVsZUxpc3QnKTtcblxudmFyIF9SdWxlTGlzdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9SdWxlTGlzdCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIFN0eWxlU2hlZXQgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFN0eWxlU2hlZXQoc3R5bGVzLCBvcHRpb25zKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFN0eWxlU2hlZXQpO1xuXG4gICAgdGhpcy5hdHRhY2hlZCA9IGZhbHNlO1xuICAgIHRoaXMuZGVwbG95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmxpbmtlZCA9IGZhbHNlO1xuICAgIHRoaXMuY2xhc3NlcyA9IHt9O1xuICAgIHRoaXMub3B0aW9ucyA9IF9leHRlbmRzKHt9LCBvcHRpb25zLCB7XG4gICAgICBzaGVldDogdGhpcyxcbiAgICAgIHBhcmVudDogdGhpcyxcbiAgICAgIGNsYXNzZXM6IHRoaXMuY2xhc3Nlc1xuICAgIH0pO1xuICAgIHRoaXMucmVuZGVyZXIgPSBuZXcgb3B0aW9ucy5SZW5kZXJlcih0aGlzKTtcbiAgICB0aGlzLnJ1bGVzID0gbmV3IF9SdWxlTGlzdDJbJ2RlZmF1bHQnXSh0aGlzLm9wdGlvbnMpO1xuXG4gICAgZm9yICh2YXIgbmFtZSBpbiBzdHlsZXMpIHtcbiAgICAgIHRoaXMucnVsZXMuYWRkKG5hbWUsIHN0eWxlc1tuYW1lXSk7XG4gICAgfVxuXG4gICAgdGhpcy5ydWxlcy5wcm9jZXNzKCk7XG4gIH1cblxuICAvKipcbiAgICogQXR0YWNoIHJlbmRlcmFibGUgdG8gdGhlIHJlbmRlciB0cmVlLlxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhTdHlsZVNoZWV0LCBbe1xuICAgIGtleTogJ2F0dGFjaCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGF0dGFjaCgpIHtcbiAgICAgIGlmICh0aGlzLmF0dGFjaGVkKSByZXR1cm4gdGhpcztcbiAgICAgIGlmICghdGhpcy5kZXBsb3llZCkgdGhpcy5kZXBsb3koKTtcbiAgICAgIHRoaXMucmVuZGVyZXIuYXR0YWNoKCk7XG4gICAgICBpZiAoIXRoaXMubGlua2VkICYmIHRoaXMub3B0aW9ucy5saW5rKSB0aGlzLmxpbmsoKTtcbiAgICAgIHRoaXMuYXR0YWNoZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIHJlbmRlcmFibGUgZnJvbSByZW5kZXIgdHJlZS5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZGV0YWNoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGV0YWNoKCkge1xuICAgICAgaWYgKCF0aGlzLmF0dGFjaGVkKSByZXR1cm4gdGhpcztcbiAgICAgIHRoaXMucmVuZGVyZXIuZGV0YWNoKCk7XG4gICAgICB0aGlzLmF0dGFjaGVkID0gZmFsc2U7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGQgYSBydWxlIHRvIHRoZSBjdXJyZW50IHN0eWxlc2hlZXQuXG4gICAgICogV2lsbCBpbnNlcnQgYSBydWxlIGFsc28gYWZ0ZXIgdGhlIHN0eWxlc2hlZXQgaGFzIGJlZW4gcmVuZGVyZWQgZmlyc3QgdGltZS5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnYWRkUnVsZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZFJ1bGUobmFtZSwgZGVjbCwgb3B0aW9ucykge1xuICAgICAgdmFyIHF1ZXVlID0gdGhpcy5xdWV1ZTtcblxuICAgICAgLy8gUGx1Z2lucyBjYW4gY3JlYXRlIHJ1bGVzLlxuICAgICAgLy8gSW4gb3JkZXIgdG8gcHJlc2VydmUgdGhlIHJpZ2h0IG9yZGVyLCB3ZSBuZWVkIHRvIHF1ZXVlIGFsbCBgLmFkZFJ1bGVgIGNhbGxzLFxuICAgICAgLy8gd2hpY2ggaGFwcGVuIGFmdGVyIHRoZSBmaXJzdCBgcnVsZXMuYWRkKClgIGNhbGwuXG5cbiAgICAgIGlmICh0aGlzLmF0dGFjaGVkICYmICFxdWV1ZSkgdGhpcy5xdWV1ZSA9IFtdO1xuXG4gICAgICB2YXIgcnVsZSA9IHRoaXMucnVsZXMuYWRkKG5hbWUsIGRlY2wsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5vcHRpb25zLmpzcy5wbHVnaW5zLm9uUHJvY2Vzc1J1bGUocnVsZSk7XG5cbiAgICAgIGlmICh0aGlzLmF0dGFjaGVkKSB7XG4gICAgICAgIGlmICghdGhpcy5kZXBsb3llZCkgcmV0dXJuIHJ1bGU7XG4gICAgICAgIC8vIERvbid0IGluc2VydCBydWxlIGRpcmVjdGx5IGlmIHRoZXJlIGlzIG5vIHN0cmluZ2lmaWVkIHZlcnNpb24geWV0LlxuICAgICAgICAvLyBJdCB3aWxsIGJlIGluc2VydGVkIGFsbCB0b2dldGhlciB3aGVuIC5hdHRhY2ggaXMgY2FsbGVkLlxuICAgICAgICBpZiAocXVldWUpIHF1ZXVlLnB1c2gocnVsZSk7ZWxzZSB7XG4gICAgICAgICAgdGhpcy5pbnNlcnRSdWxlKHJ1bGUpO1xuICAgICAgICAgIGlmICh0aGlzLnF1ZXVlKSB7XG4gICAgICAgICAgICB0aGlzLnF1ZXVlLmZvckVhY2godGhpcy5pbnNlcnRSdWxlLCB0aGlzKTtcbiAgICAgICAgICAgIHRoaXMucXVldWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBydWxlO1xuICAgICAgfVxuXG4gICAgICAvLyBXZSBjYW4ndCBhZGQgcnVsZXMgdG8gYSBkZXRhY2hlZCBzdHlsZSBub2RlLlxuICAgICAgLy8gV2Ugd2lsbCByZWRlcGxveSB0aGUgc2hlZXQgb25jZSB1c2VyIHdpbGwgYXR0YWNoIGl0LlxuICAgICAgdGhpcy5kZXBsb3llZCA9IGZhbHNlO1xuXG4gICAgICByZXR1cm4gcnVsZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnNlcnQgcnVsZSBpbnRvIHRoZSBTdHlsZVNoZWV0XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2luc2VydFJ1bGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnNlcnRSdWxlKHJ1bGUpIHtcbiAgICAgIHZhciByZW5kZXJhYmxlID0gdGhpcy5yZW5kZXJlci5pbnNlcnRSdWxlKHJ1bGUpO1xuICAgICAgaWYgKHJlbmRlcmFibGUgJiYgdGhpcy5vcHRpb25zLmxpbmspICgwLCBfbGlua1J1bGUyWydkZWZhdWx0J10pKHJ1bGUsIHJlbmRlcmFibGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbmQgYWRkIHJ1bGVzLlxuICAgICAqIFdpbGwgcmVuZGVyIGFsc28gYWZ0ZXIgU3R5bGUgU2hlZXQgd2FzIHJlbmRlcmVkIHRoZSBmaXJzdCB0aW1lLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdhZGRSdWxlcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZFJ1bGVzKHN0eWxlcywgb3B0aW9ucykge1xuICAgICAgdmFyIGFkZGVkID0gW107XG4gICAgICBmb3IgKHZhciBuYW1lIGluIHN0eWxlcykge1xuICAgICAgICBhZGRlZC5wdXNoKHRoaXMuYWRkUnVsZShuYW1lLCBzdHlsZXNbbmFtZV0sIG9wdGlvbnMpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhZGRlZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgYSBydWxlIGJ5IG5hbWUuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2dldFJ1bGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRSdWxlKG5hbWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnJ1bGVzLmdldChuYW1lKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWxldGUgYSBydWxlIGJ5IG5hbWUuXG4gICAgICogUmV0dXJucyBgdHJ1ZWA6IGlmIHJ1bGUgaGFzIGJlZW4gZGVsZXRlZCBmcm9tIHRoZSBET00uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2RlbGV0ZVJ1bGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWxldGVSdWxlKG5hbWUpIHtcbiAgICAgIHZhciBydWxlID0gdGhpcy5ydWxlcy5nZXQobmFtZSk7XG5cbiAgICAgIGlmICghcnVsZSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICB0aGlzLnJ1bGVzLnJlbW92ZShydWxlKTtcblxuICAgICAgaWYgKHRoaXMuYXR0YWNoZWQgJiYgcnVsZS5yZW5kZXJhYmxlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLmRlbGV0ZVJ1bGUocnVsZS5yZW5kZXJhYmxlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGluZGV4IG9mIGEgcnVsZS5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnaW5kZXhPZicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluZGV4T2YocnVsZSkge1xuICAgICAgcmV0dXJuIHRoaXMucnVsZXMuaW5kZXhPZihydWxlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXBsb3kgcHVyZSBDU1Mgc3RyaW5nIHRvIGEgcmVuZGVyYWJsZS5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZGVwbG95JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVwbG95KCkge1xuICAgICAgdGhpcy5yZW5kZXJlci5kZXBsb3koKTtcbiAgICAgIHRoaXMuZGVwbG95ZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGluayByZW5kZXJhYmxlIENTUyBydWxlcyBmcm9tIHNoZWV0IHdpdGggdGhlaXIgY29ycmVzcG9uZGluZyBtb2RlbHMuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2xpbmsnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsaW5rKCkge1xuICAgICAgdmFyIGNzc1J1bGVzID0gdGhpcy5yZW5kZXJlci5nZXRSdWxlcygpO1xuXG4gICAgICAvLyBJcyB1bmRlZmluZWQgd2hlbiBWaXJ0dWFsUmVuZGVyZXIgaXMgdXNlZC5cbiAgICAgIGlmIChjc3NSdWxlcykgdGhpcy5ydWxlcy5saW5rKGNzc1J1bGVzKTtcbiAgICAgIHRoaXMubGlua2VkID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgZnVuY3Rpb24gdmFsdWVzIHdpdGggYSBuZXcgZGF0YS5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAndXBkYXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlKG5hbWUsIGRhdGEpIHtcbiAgICAgIHRoaXMucnVsZXMudXBkYXRlKG5hbWUsIGRhdGEpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydCBydWxlcyB0byBhIENTUyBzdHJpbmcuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3RvU3RyaW5nJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcob3B0aW9ucykge1xuICAgICAgcmV0dXJuIHRoaXMucnVsZXMudG9TdHJpbmcob3B0aW9ucyk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFN0eWxlU2hlZXQ7XG59KCk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IFN0eWxlU2hlZXQ7IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5jcmVhdGUgPSBleHBvcnRzLmNyZWF0ZUdlbmVyYXRlQ2xhc3NOYW1lID0gZXhwb3J0cy5zaGVldHMgPSBleHBvcnRzLlJ1bGVMaXN0ID0gZXhwb3J0cy5TaGVldHNNYW5hZ2VyID0gZXhwb3J0cy5TaGVldHNSZWdpc3RyeSA9IGV4cG9ydHMudG9Dc3NWYWx1ZSA9IGV4cG9ydHMuZ2V0RHluYW1pY1N0eWxlcyA9IHVuZGVmaW5lZDtcblxudmFyIF9nZXREeW5hbWljU3R5bGVzID0gcmVxdWlyZSgnLi91dGlscy9nZXREeW5hbWljU3R5bGVzJyk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnZ2V0RHluYW1pY1N0eWxlcycsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldER5bmFtaWNTdHlsZXMpWydkZWZhdWx0J107XG4gIH1cbn0pO1xuXG52YXIgX3RvQ3NzVmFsdWUgPSByZXF1aXJlKCcuL3V0aWxzL3RvQ3NzVmFsdWUnKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICd0b0Nzc1ZhbHVlJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdG9Dc3NWYWx1ZSlbJ2RlZmF1bHQnXTtcbiAgfVxufSk7XG5cbnZhciBfU2hlZXRzUmVnaXN0cnkgPSByZXF1aXJlKCcuL1NoZWV0c1JlZ2lzdHJ5Jyk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnU2hlZXRzUmVnaXN0cnknLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9TaGVldHNSZWdpc3RyeSlbJ2RlZmF1bHQnXTtcbiAgfVxufSk7XG5cbnZhciBfU2hlZXRzTWFuYWdlciA9IHJlcXVpcmUoJy4vU2hlZXRzTWFuYWdlcicpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ1NoZWV0c01hbmFnZXInLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9TaGVldHNNYW5hZ2VyKVsnZGVmYXVsdCddO1xuICB9XG59KTtcblxudmFyIF9SdWxlTGlzdCA9IHJlcXVpcmUoJy4vUnVsZUxpc3QnKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdSdWxlTGlzdCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1J1bGVMaXN0KVsnZGVmYXVsdCddO1xuICB9XG59KTtcblxudmFyIF9zaGVldHMgPSByZXF1aXJlKCcuL3NoZWV0cycpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ3NoZWV0cycsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3NoZWV0cylbJ2RlZmF1bHQnXTtcbiAgfVxufSk7XG5cbnZhciBfY3JlYXRlR2VuZXJhdGVDbGFzc05hbWUgPSByZXF1aXJlKCcuL3V0aWxzL2NyZWF0ZUdlbmVyYXRlQ2xhc3NOYW1lJyk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnY3JlYXRlR2VuZXJhdGVDbGFzc05hbWUnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVHZW5lcmF0ZUNsYXNzTmFtZSlbJ2RlZmF1bHQnXTtcbiAgfVxufSk7XG5cbnZhciBfSnNzID0gcmVxdWlyZSgnLi9Kc3MnKTtcblxudmFyIF9Kc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfSnNzKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgSnNzLlxuICovXG52YXIgY3JlYXRlID0gZXhwb3J0cy5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUob3B0aW9ucykge1xuICByZXR1cm4gbmV3IF9Kc3MyWydkZWZhdWx0J10ob3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIEEgZ2xvYmFsIEpzcyBpbnN0YW5jZS5cbiAqL1xuZXhwb3J0c1snZGVmYXVsdCddID0gY3JlYXRlKCk7IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX1J1bGVMaXN0ID0gcmVxdWlyZSgnLi4vUnVsZUxpc3QnKTtcblxudmFyIF9SdWxlTGlzdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9SdWxlTGlzdCk7XG5cbnZhciBfU3R5bGVSdWxlID0gcmVxdWlyZSgnLi4vcnVsZXMvU3R5bGVSdWxlJyk7XG5cbnZhciBfU3R5bGVSdWxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1N0eWxlUnVsZSk7XG5cbnZhciBfa2ViYWJDYXNlID0gcmVxdWlyZSgnLi4vdXRpbHMva2ViYWJDYXNlJyk7XG5cbnZhciBfa2ViYWJDYXNlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2tlYmFiQ2FzZSk7XG5cbnZhciBfY3JlYXRlUnVsZSA9IHJlcXVpcmUoJy4uL3V0aWxzL2NyZWF0ZVJ1bGUnKTtcblxudmFyIF9jcmVhdGVSdWxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZVJ1bGUpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbi8vIEEgc3ltYm9sIHJlcGxhY2VtZW50LlxudmFyIG5vdyA9IERhdGUubm93KCk7XG52YXIgZm5WYWx1ZXNOcyA9ICdmblZhbHVlcycgKyBub3c7XG52YXIgZm5TdHlsZU5zID0gJ2ZuU3R5bGUnICsgKytub3c7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IHtcbiAgb25DcmVhdGVSdWxlOiBmdW5jdGlvbiBvbkNyZWF0ZVJ1bGUobmFtZSwgZGVjbCwgb3B0aW9ucykge1xuICAgIGlmICh0eXBlb2YgZGVjbCAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuIG51bGw7XG4gICAgdmFyIHJ1bGUgPSAoMCwgX2NyZWF0ZVJ1bGUyWydkZWZhdWx0J10pKG5hbWUsIHt9LCBvcHRpb25zKTtcbiAgICBydWxlW2ZuU3R5bGVOc10gPSBkZWNsO1xuICAgIHJldHVybiBydWxlO1xuICB9LFxuICBvblByb2Nlc3NTdHlsZTogZnVuY3Rpb24gb25Qcm9jZXNzU3R5bGUoc3R5bGUsIHJ1bGUpIHtcbiAgICB2YXIgZm4gPSB7fTtcbiAgICBmb3IgKHZhciBwcm9wIGluIHN0eWxlKSB7XG4gICAgICB2YXIgdmFsdWUgPSBzdHlsZVtwcm9wXTtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicpIGNvbnRpbnVlO1xuICAgICAgZGVsZXRlIHN0eWxlW3Byb3BdO1xuICAgICAgZm5bKDAsIF9rZWJhYkNhc2UyWydkZWZhdWx0J10pKHByb3ApXSA9IHZhbHVlO1xuICAgIH1cbiAgICBydWxlID0gcnVsZTtcbiAgICBydWxlW2ZuVmFsdWVzTnNdID0gZm47XG4gICAgcmV0dXJuIHN0eWxlO1xuICB9LFxuICBvblVwZGF0ZTogZnVuY3Rpb24gb25VcGRhdGUoZGF0YSwgcnVsZSkge1xuICAgIC8vIEl0IGlzIGEgcnVsZXMgY29udGFpbmVyIGxpa2UgZm9yIGUuZy4gQ29uZGl0aW9uYWxSdWxlLlxuICAgIGlmIChydWxlLnJ1bGVzIGluc3RhbmNlb2YgX1J1bGVMaXN0MlsnZGVmYXVsdCddKSB7XG4gICAgICBydWxlLnJ1bGVzLnVwZGF0ZShkYXRhKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCEocnVsZSBpbnN0YW5jZW9mIF9TdHlsZVJ1bGUyWydkZWZhdWx0J10pKSByZXR1cm47XG5cbiAgICBydWxlID0gcnVsZTtcblxuICAgIC8vIElmIHdlIGhhdmUgYSBmbiB2YWx1ZXMgbWFwLCBpdCBpcyBhIHJ1bGUgd2l0aCBmdW5jdGlvbiB2YWx1ZXMuXG4gICAgaWYgKHJ1bGVbZm5WYWx1ZXNOc10pIHtcbiAgICAgIGZvciAodmFyIHByb3AgaW4gcnVsZVtmblZhbHVlc05zXSkge1xuICAgICAgICBydWxlLnByb3AocHJvcCwgcnVsZVtmblZhbHVlc05zXVtwcm9wXShkYXRhKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcnVsZSA9IHJ1bGU7XG5cbiAgICB2YXIgZm5TdHlsZSA9IHJ1bGVbZm5TdHlsZU5zXTtcblxuICAgIC8vIElmIHdlIGhhdmUgYSBzdHlsZSBmdW5jdGlvbiwgdGhlIGVudGlyZSBydWxlIGlzIGR5bmFtaWMgYW5kIHN0eWxlIG9iamVjdFxuICAgIC8vIHdpbGwgYmUgcmV0dXJuZWQgZnJvbSB0aGF0IGZ1bmN0aW9uLlxuICAgIGlmIChmblN0eWxlKSB7XG4gICAgICB2YXIgc3R5bGUgPSBmblN0eWxlKGRhdGEpO1xuICAgICAgZm9yICh2YXIgX3Byb3AgaW4gc3R5bGUpIHtcbiAgICAgICAgcnVsZS5wcm9wKF9wcm9wLCBzdHlsZVtfcHJvcF0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfU3R5bGVSdWxlID0gcmVxdWlyZSgnLi4vcnVsZXMvU3R5bGVSdWxlJyk7XG5cbnZhciBfU3R5bGVSdWxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1N0eWxlUnVsZSk7XG5cbnZhciBfY3JlYXRlUnVsZSA9IHJlcXVpcmUoJy4uL3V0aWxzL2NyZWF0ZVJ1bGUnKTtcblxudmFyIF9jcmVhdGVSdWxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZVJ1bGUpO1xuXG52YXIgX2lzT2JzZXJ2YWJsZSA9IHJlcXVpcmUoJy4uL3V0aWxzL2lzT2JzZXJ2YWJsZScpO1xuXG52YXIgX2lzT2JzZXJ2YWJsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pc09ic2VydmFibGUpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IHtcbiAgb25DcmVhdGVSdWxlOiBmdW5jdGlvbiBvbkNyZWF0ZVJ1bGUobmFtZSwgZGVjbCwgb3B0aW9ucykge1xuICAgIGlmICghKDAsIF9pc09ic2VydmFibGUyWydkZWZhdWx0J10pKGRlY2wpKSByZXR1cm4gbnVsbDtcblxuICAgIC8vIENhc3QgYGRlY2xgIHRvIGBPYnNlcnZhYmxlYCwgc2luY2UgaXQgcGFzc2VkIHRoZSB0eXBlIGd1YXJkLlxuICAgIHZhciBzdHlsZSQgPSBkZWNsO1xuXG4gICAgdmFyIHJ1bGUgPSAoMCwgX2NyZWF0ZVJ1bGUyWydkZWZhdWx0J10pKG5hbWUsIHt9LCBvcHRpb25zKTtcblxuICAgIC8vIFRPRE9cbiAgICAvLyBDYWxsIGBzdHJlYW0uc3Vic2NyaWJlKClgIHJldHVybnMgYSBzdWJzY3JpcHRpb24sIHdoaWNoIHNob3VsZCBiZSBleHBsaWNpdGx5XG4gICAgLy8gdW5zdWJzY3JpYmVkIGZyb20gd2hlbiB3ZSBrbm93IHRoaXMgc2hlZXQgaXMgbm8gbG9uZ2VyIG5lZWRlZC5cbiAgICBzdHlsZSQuc3Vic2NyaWJlKGZ1bmN0aW9uIChzdHlsZSkge1xuICAgICAgZm9yICh2YXIgcHJvcCBpbiBzdHlsZSkge1xuICAgICAgICBydWxlLnByb3AocHJvcCwgc3R5bGVbcHJvcF0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJ1bGU7XG4gIH0sXG4gIG9uUHJvY2Vzc1J1bGU6IGZ1bmN0aW9uIG9uUHJvY2Vzc1J1bGUocnVsZSkge1xuICAgIGlmICghKHJ1bGUgaW5zdGFuY2VvZiBfU3R5bGVSdWxlMlsnZGVmYXVsdCddKSkgcmV0dXJuO1xuICAgIHZhciBzdHlsZVJ1bGUgPSBydWxlO1xuICAgIHZhciBzdHlsZSA9IHN0eWxlUnVsZS5zdHlsZTtcblxuICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKHByb3ApIHtcbiAgICAgIHZhciB2YWx1ZSA9IHN0eWxlW3Byb3BdO1xuICAgICAgaWYgKCEoMCwgX2lzT2JzZXJ2YWJsZTJbJ2RlZmF1bHQnXSkodmFsdWUpKSByZXR1cm4gJ2NvbnRpbnVlJztcbiAgICAgIGRlbGV0ZSBzdHlsZVtwcm9wXTtcbiAgICAgIHZhbHVlLnN1YnNjcmliZSh7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uIG5leHQobmV4dFZhbHVlKSB7XG4gICAgICAgICAgc3R5bGVSdWxlLnByb3AocHJvcCwgbmV4dFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGZvciAodmFyIHByb3AgaW4gc3R5bGUpIHtcbiAgICAgIHZhciBfcmV0ID0gX2xvb3AocHJvcCk7XG5cbiAgICAgIGlmIChfcmV0ID09PSAnY29udGludWUnKSBjb250aW51ZTtcbiAgICB9XG4gIH1cbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX1NpbXBsZVJ1bGUgPSByZXF1aXJlKCcuLi9ydWxlcy9TaW1wbGVSdWxlJyk7XG5cbnZhciBfU2ltcGxlUnVsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9TaW1wbGVSdWxlKTtcblxudmFyIF9LZXlmcmFtZXNSdWxlID0gcmVxdWlyZSgnLi4vcnVsZXMvS2V5ZnJhbWVzUnVsZScpO1xuXG52YXIgX0tleWZyYW1lc1J1bGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfS2V5ZnJhbWVzUnVsZSk7XG5cbnZhciBfQ29uZGl0aW9uYWxSdWxlID0gcmVxdWlyZSgnLi4vcnVsZXMvQ29uZGl0aW9uYWxSdWxlJyk7XG5cbnZhciBfQ29uZGl0aW9uYWxSdWxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0NvbmRpdGlvbmFsUnVsZSk7XG5cbnZhciBfRm9udEZhY2VSdWxlID0gcmVxdWlyZSgnLi4vcnVsZXMvRm9udEZhY2VSdWxlJyk7XG5cbnZhciBfRm9udEZhY2VSdWxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0ZvbnRGYWNlUnVsZSk7XG5cbnZhciBfVmlld3BvcnRSdWxlID0gcmVxdWlyZSgnLi4vcnVsZXMvVmlld3BvcnRSdWxlJyk7XG5cbnZhciBfVmlld3BvcnRSdWxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1ZpZXdwb3J0UnVsZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIGNsYXNzZXMgPSB7XG4gICdAY2hhcnNldCc6IF9TaW1wbGVSdWxlMlsnZGVmYXVsdCddLFxuICAnQGltcG9ydCc6IF9TaW1wbGVSdWxlMlsnZGVmYXVsdCddLFxuICAnQG5hbWVzcGFjZSc6IF9TaW1wbGVSdWxlMlsnZGVmYXVsdCddLFxuICAnQGtleWZyYW1lcyc6IF9LZXlmcmFtZXNSdWxlMlsnZGVmYXVsdCddLFxuICAnQG1lZGlhJzogX0NvbmRpdGlvbmFsUnVsZTJbJ2RlZmF1bHQnXSxcbiAgJ0BzdXBwb3J0cyc6IF9Db25kaXRpb25hbFJ1bGUyWydkZWZhdWx0J10sXG4gICdAZm9udC1mYWNlJzogX0ZvbnRGYWNlUnVsZTJbJ2RlZmF1bHQnXSxcbiAgJ0B2aWV3cG9ydCc6IF9WaWV3cG9ydFJ1bGUyWydkZWZhdWx0J10sXG4gICdALW1zLXZpZXdwb3J0JzogX1ZpZXdwb3J0UnVsZTJbJ2RlZmF1bHQnXVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBwbHVnaW5zIHdoaWNoIHdpbGwgcmVnaXN0ZXIgYWxsIHJ1bGVzLlxuICAgKi9cbn07XG5leHBvcnRzWydkZWZhdWx0J10gPSBPYmplY3Qua2V5cyhjbGFzc2VzKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAvLyBodHRwczovL2pzcGVyZi5jb20vaW5kZXhvZi12cy1zdWJzdHItdnMtcmVnZXgtYXQtdGhlLWJlZ2lubmluZy0zXG4gIHZhciByZSA9IG5ldyBSZWdFeHAoJ14nICsga2V5KTtcbiAgdmFyIG9uQ3JlYXRlUnVsZSA9IGZ1bmN0aW9uIG9uQ3JlYXRlUnVsZShuYW1lLCBkZWNsLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHJlLnRlc3QobmFtZSkgPyBuZXcgY2xhc3Nlc1trZXldKG5hbWUsIGRlY2wsIG9wdGlvbnMpIDogbnVsbDtcbiAgfTtcbiAgcmV0dXJuIHsgb25DcmVhdGVSdWxlOiBvbkNyZWF0ZVJ1bGUgfTtcbn0pOyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF93YXJuaW5nID0gcmVxdWlyZSgnd2FybmluZycpO1xuXG52YXIgX3dhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd2FybmluZyk7XG5cbnZhciBfc2hlZXRzID0gcmVxdWlyZSgnLi4vc2hlZXRzJyk7XG5cbnZhciBfc2hlZXRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3NoZWV0cyk7XG5cbnZhciBfU3R5bGVSdWxlID0gcmVxdWlyZSgnLi4vcnVsZXMvU3R5bGVSdWxlJyk7XG5cbnZhciBfU3R5bGVSdWxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1N0eWxlUnVsZSk7XG5cbnZhciBfdG9Dc3NWYWx1ZSA9IHJlcXVpcmUoJy4uL3V0aWxzL3RvQ3NzVmFsdWUnKTtcblxudmFyIF90b0Nzc1ZhbHVlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RvQ3NzVmFsdWUpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbi8qKlxuICogR2V0IGEgc3R5bGUgcHJvcGVydHkuXG4gKi9cbmZ1bmN0aW9uIGdldFN0eWxlKGNzc1J1bGUsIHByb3ApIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gY3NzUnVsZS5zdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKHByb3ApO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyBJRSBtYXkgdGhyb3cgaWYgcHJvcGVydHkgaXMgdW5rbm93bi5cbiAgICByZXR1cm4gJyc7XG4gIH1cbn1cblxuLyoqXG4gKiBTZXQgYSBzdHlsZSBwcm9wZXJ0eS5cbiAqL1xuZnVuY3Rpb24gc2V0U3R5bGUoY3NzUnVsZSwgcHJvcCwgdmFsdWUpIHtcbiAgdHJ5IHtcbiAgICB2YXIgY3NzVmFsdWUgPSB2YWx1ZTtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgY3NzVmFsdWUgPSAoMCwgX3RvQ3NzVmFsdWUyWydkZWZhdWx0J10pKHZhbHVlLCB0cnVlKTtcblxuICAgICAgaWYgKHZhbHVlW3ZhbHVlLmxlbmd0aCAtIDFdID09PSAnIWltcG9ydGFudCcpIHtcbiAgICAgICAgY3NzUnVsZS5zdHlsZS5zZXRQcm9wZXJ0eShwcm9wLCBjc3NWYWx1ZSwgJ2ltcG9ydGFudCcpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjc3NSdWxlLnN0eWxlLnNldFByb3BlcnR5KHByb3AsIGNzc1ZhbHVlKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gSUUgbWF5IHRocm93IGlmIHByb3BlcnR5IGlzIHVua25vd24uXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG52YXIgQ1NTUnVsZVR5cGVzID0ge1xuICBTVFlMRV9SVUxFOiAxLFxuICBLRVlGUkFNRVNfUlVMRTogN1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIENTUyBSdWxlIGtleS5cbiAgICovXG5cbn07dmFyIGdldEtleSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGV4dHJhY3RLZXkgPSBmdW5jdGlvbiBleHRyYWN0S2V5KGNzc1RleHQpIHtcbiAgICB2YXIgZnJvbSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcbiAgICByZXR1cm4gY3NzVGV4dC5zdWJzdHIoZnJvbSwgY3NzVGV4dC5pbmRleE9mKCd7JykgLSAxKTtcbiAgfTtcblxuICByZXR1cm4gZnVuY3Rpb24gKGNzc1J1bGUpIHtcbiAgICBpZiAoY3NzUnVsZS50eXBlID09PSBDU1NSdWxlVHlwZXMuU1RZTEVfUlVMRSkgcmV0dXJuIGNzc1J1bGUuc2VsZWN0b3JUZXh0O1xuICAgIGlmIChjc3NSdWxlLnR5cGUgPT09IENTU1J1bGVUeXBlcy5LRVlGUkFNRVNfUlVMRSkge1xuICAgICAgdmFyIG5hbWUgPSBjc3NSdWxlLm5hbWU7XG5cbiAgICAgIGlmIChuYW1lKSByZXR1cm4gJ0BrZXlmcmFtZXMgJyArIG5hbWU7XG5cbiAgICAgIC8vIFRoZXJlIGlzIG5vIHJ1bGUubmFtZSBpbiB0aGUgZm9sbG93aW5nIGJyb3dzZXJzOlxuICAgICAgLy8gLSBJRSA5XG4gICAgICAvLyAtIFNhZmFyaSA3LjEuOFxuICAgICAgLy8gLSBNb2JpbGUgU2FmYXJpIDkuMC4wXG4gICAgICB2YXIgY3NzVGV4dCA9IGNzc1J1bGUuY3NzVGV4dDtcblxuICAgICAgcmV0dXJuICdAJyArIGV4dHJhY3RLZXkoY3NzVGV4dCwgY3NzVGV4dC5pbmRleE9mKCdrZXlmcmFtZXMnKSk7XG4gICAgfVxuXG4gICAgLy8gQ29uZGl0aW9uYWxzLlxuICAgIHJldHVybiBleHRyYWN0S2V5KGNzc1J1bGUuY3NzVGV4dCk7XG4gIH07XG59KCk7XG5cbi8qKlxuICogU2V0IHRoZSBzZWxlY3Rvci5cbiAqL1xuZnVuY3Rpb24gc2V0U2VsZWN0b3IoY3NzUnVsZSwgc2VsZWN0b3JUZXh0KSB7XG4gIGNzc1J1bGUuc2VsZWN0b3JUZXh0ID0gc2VsZWN0b3JUZXh0O1xuXG4gIC8vIFJldHVybiBmYWxzZSBpZiBzZXR0ZXIgd2FzIG5vdCBzdWNjZXNzZnVsLlxuICAvLyBDdXJyZW50bHkgd29ya3MgaW4gY2hyb21lIG9ubHkuXG4gIHJldHVybiBjc3NSdWxlLnNlbGVjdG9yVGV4dCA9PT0gc2VsZWN0b3JUZXh0O1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGBoZWFkYCBlbGVtZW50IHVwb24gdGhlIGZpcnN0IGNhbGwgYW5kIGNhY2hlcyBpdC5cbiAqL1xudmFyIGdldEhlYWQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBoZWFkID0gdm9pZCAwO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmICghaGVhZCkgaGVhZCA9IGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXTtcbiAgICByZXR1cm4gaGVhZDtcbiAgfTtcbn0oKTtcblxuLyoqXG4gKiBHZXRzIGEgbWFwIG9mIHJ1bGUga2V5cywgd2hlcmUgdGhlIHByb3BlcnR5IGlzIGFuIHVuZXNjYXBlZCBrZXkgYW5kIHZhbHVlXG4gKiBpcyBhIHBvdGVudGlhbGx5IGVzY2FwZWQgb25lLlxuICogSXQgaXMgdXNlZCB0byBpZGVudGlmeSBDU1MgcnVsZXMgYW5kIHRoZSBjb3JyZXNwb25kaW5nIEpTUyBydWxlcy4gQXMgYW4gaWRlbnRpZmllclxuICogZm9yIENTU1N0eWxlUnVsZSB3ZSBub3JtYWxseSB1c2UgYHNlbGVjdG9yVGV4dGAuIFRob3VnaCBpZiBvcmlnaW5hbCBzZWxlY3RvciB0ZXh0XG4gKiBjb250YWlucyBlc2NhcGVkIGNvZGUgcG9pbnRzIGUuZy4gYDpub3QoI1xcXFwyMClgLCBDU1NPTSB3aWxsIGNvbXBpbGUgaXQgdG8gYDpub3QoIyApYFxuICogYW5kIHNvIENTUyBydWxlJ3MgYHNlbGVjdG9yVGV4dGAgd29uJ3QgbWF0Y2ggSlNTIHJ1bGUgc2VsZWN0b3IuXG4gKlxuICogaHR0cHM6Ly93d3cudzMub3JnL0ludGVybmF0aW9uYWwvcXVlc3Rpb25zL3FhLWVzY2FwZXMjY3NzZXNjYXBlc1xuICovXG52YXIgZ2V0VW5lc2NhcGVkS2V5c01hcCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0eWxlID0gdm9pZCAwO1xuICB2YXIgaXNBdHRhY2hlZCA9IGZhbHNlO1xuXG4gIHJldHVybiBmdW5jdGlvbiAocnVsZXMpIHtcbiAgICB2YXIgbWFwID0ge307XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2Zsb3cvaXNzdWVzLzI2OTZcbiAgICBpZiAoIXN0eWxlKSBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBydWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHJ1bGUgPSBydWxlc1tpXTtcbiAgICAgIGlmICghKHJ1bGUgaW5zdGFuY2VvZiBfU3R5bGVSdWxlMlsnZGVmYXVsdCddKSkgY29udGludWU7XG4gICAgICB2YXIgc2VsZWN0b3IgPSBydWxlLnNlbGVjdG9yO1xuICAgICAgLy8gT25seSB1bmVzY2FwZSBzZWxlY3RvciBvdmVyIENTU09NIGlmIGl0IGNvbnRhaW5zIGEgYmFjayBzbGFzaC5cblxuICAgICAgaWYgKHNlbGVjdG9yICYmIHNlbGVjdG9yLmluZGV4T2YoJ1xcXFwnKSAhPT0gLTEpIHtcbiAgICAgICAgLy8gTGF6aWxseSBhdHRhY2ggd2hlbiBuZWVkZWQuXG4gICAgICAgIGlmICghaXNBdHRhY2hlZCkge1xuICAgICAgICAgIGdldEhlYWQoKS5hcHBlbmRDaGlsZChzdHlsZSk7XG4gICAgICAgICAgaXNBdHRhY2hlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgc3R5bGUudGV4dENvbnRlbnQgPSBzZWxlY3RvciArICcge30nO1xuICAgICAgICB2YXIgX3N0eWxlID0gc3R5bGUsXG4gICAgICAgICAgICBzaGVldCA9IF9zdHlsZS5zaGVldDtcblxuICAgICAgICBpZiAoc2hlZXQpIHtcbiAgICAgICAgICB2YXIgY3NzUnVsZXMgPSBzaGVldC5jc3NSdWxlcztcblxuICAgICAgICAgIGlmIChjc3NSdWxlcykgbWFwW2Nzc1J1bGVzWzBdLnNlbGVjdG9yVGV4dF0gPSBydWxlLmtleTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNBdHRhY2hlZCkge1xuICAgICAgZ2V0SGVhZCgpLnJlbW92ZUNoaWxkKHN0eWxlKTtcbiAgICAgIGlzQXR0YWNoZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIG1hcDtcbiAgfTtcbn0oKTtcblxuLyoqXG4gKiBGaW5kIGF0dGFjaGVkIHNoZWV0IHdpdGggYW4gaW5kZXggaGlnaGVyIHRoYW4gdGhlIHBhc3NlZCBvbmUuXG4gKi9cbmZ1bmN0aW9uIGZpbmRIaWdoZXJTaGVldChyZWdpc3RyeSwgb3B0aW9ucykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHJlZ2lzdHJ5Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNoZWV0ID0gcmVnaXN0cnlbaV07XG4gICAgaWYgKHNoZWV0LmF0dGFjaGVkICYmIHNoZWV0Lm9wdGlvbnMuaW5kZXggPiBvcHRpb25zLmluZGV4ICYmIHNoZWV0Lm9wdGlvbnMuaW5zZXJ0aW9uUG9pbnQgPT09IG9wdGlvbnMuaW5zZXJ0aW9uUG9pbnQpIHtcbiAgICAgIHJldHVybiBzaGVldDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogRmluZCBhdHRhY2hlZCBzaGVldCB3aXRoIHRoZSBoaWdoZXN0IGluZGV4LlxuICovXG5mdW5jdGlvbiBmaW5kSGlnaGVzdFNoZWV0KHJlZ2lzdHJ5LCBvcHRpb25zKSB7XG4gIGZvciAodmFyIGkgPSByZWdpc3RyeS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHZhciBzaGVldCA9IHJlZ2lzdHJ5W2ldO1xuICAgIGlmIChzaGVldC5hdHRhY2hlZCAmJiBzaGVldC5vcHRpb25zLmluc2VydGlvblBvaW50ID09PSBvcHRpb25zLmluc2VydGlvblBvaW50KSB7XG4gICAgICByZXR1cm4gc2hlZXQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIEZpbmQgYSBjb21tZW50IHdpdGggXCJqc3NcIiBpbnNpZGUuXG4gKi9cbmZ1bmN0aW9uIGZpbmRDb21tZW50Tm9kZSh0ZXh0KSB7XG4gIHZhciBoZWFkID0gZ2V0SGVhZCgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGhlYWQuY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBub2RlID0gaGVhZC5jaGlsZE5vZGVzW2ldO1xuICAgIGlmIChub2RlLm5vZGVUeXBlID09PSA4ICYmIG5vZGUubm9kZVZhbHVlLnRyaW0oKSA9PT0gdGV4dCkge1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIEZpbmQgYSBub2RlIGJlZm9yZSB3aGljaCB3ZSBjYW4gaW5zZXJ0IHRoZSBzaGVldC5cbiAqL1xuZnVuY3Rpb24gZmluZFByZXZOb2RlKG9wdGlvbnMpIHtcbiAgdmFyIHJlZ2lzdHJ5ID0gX3NoZWV0czJbJ2RlZmF1bHQnXS5yZWdpc3RyeTtcblxuXG4gIGlmIChyZWdpc3RyeS5sZW5ndGggPiAwKSB7XG4gICAgLy8gVHJ5IHRvIGluc2VydCBiZWZvcmUgdGhlIG5leHQgaGlnaGVyIHNoZWV0LlxuICAgIHZhciBzaGVldCA9IGZpbmRIaWdoZXJTaGVldChyZWdpc3RyeSwgb3B0aW9ucyk7XG4gICAgaWYgKHNoZWV0KSByZXR1cm4gc2hlZXQucmVuZGVyZXIuZWxlbWVudDtcblxuICAgIC8vIE90aGVyd2lzZSBpbnNlcnQgYWZ0ZXIgdGhlIGxhc3QgYXR0YWNoZWQuXG4gICAgc2hlZXQgPSBmaW5kSGlnaGVzdFNoZWV0KHJlZ2lzdHJ5LCBvcHRpb25zKTtcbiAgICBpZiAoc2hlZXQpIHJldHVybiBzaGVldC5yZW5kZXJlci5lbGVtZW50Lm5leHRFbGVtZW50U2libGluZztcbiAgfVxuXG4gIC8vIFRyeSB0byBmaW5kIGEgY29tbWVudCBwbGFjZWhvbGRlciBpZiByZWdpc3RyeSBpcyBlbXB0eS5cbiAgdmFyIGluc2VydGlvblBvaW50ID0gb3B0aW9ucy5pbnNlcnRpb25Qb2ludDtcblxuICBpZiAoaW5zZXJ0aW9uUG9pbnQgJiYgdHlwZW9mIGluc2VydGlvblBvaW50ID09PSAnc3RyaW5nJykge1xuICAgIHZhciBjb21tZW50ID0gZmluZENvbW1lbnROb2RlKGluc2VydGlvblBvaW50KTtcbiAgICBpZiAoY29tbWVudCkgcmV0dXJuIGNvbW1lbnQubmV4dFNpYmxpbmc7XG4gICAgLy8gSWYgdXNlciBzcGVjaWZpZXMgYW4gaW5zZXJ0aW9uIHBvaW50IGFuZCBpdCBjYW4ndCBiZSBmb3VuZCBpbiB0aGUgZG9jdW1lbnQgLVxuICAgIC8vIGJhZCBzcGVjaWZpY2l0eSBpc3N1ZXMgbWF5IGFwcGVhci5cbiAgICAoMCwgX3dhcm5pbmcyWydkZWZhdWx0J10pKGluc2VydGlvblBvaW50ID09PSAnanNzJywgJ1tKU1NdIEluc2VydGlvbiBwb2ludCBcIiVzXCIgbm90IGZvdW5kLicsIGluc2VydGlvblBvaW50KTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIEluc2VydCBzdHlsZSBlbGVtZW50IGludG8gdGhlIERPTS5cbiAqL1xuZnVuY3Rpb24gaW5zZXJ0U3R5bGUoc3R5bGUsIG9wdGlvbnMpIHtcbiAgdmFyIGluc2VydGlvblBvaW50ID0gb3B0aW9ucy5pbnNlcnRpb25Qb2ludDtcblxuICB2YXIgcHJldk5vZGUgPSBmaW5kUHJldk5vZGUob3B0aW9ucyk7XG5cbiAgaWYgKHByZXZOb2RlKSB7XG4gICAgdmFyIHBhcmVudE5vZGUgPSBwcmV2Tm9kZS5wYXJlbnROb2RlO1xuXG4gICAgaWYgKHBhcmVudE5vZGUpIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHN0eWxlLCBwcmV2Tm9kZSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gV29ya3Mgd2l0aCBpZnJhbWVzIGFuZCBhbnkgbm9kZSB0eXBlcy5cbiAgaWYgKGluc2VydGlvblBvaW50ICYmIHR5cGVvZiBpbnNlcnRpb25Qb2ludC5ub2RlVHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy80MTMyODcyOC9mb3JjZS1jYXN0aW5nLWluLWZsb3dcbiAgICB2YXIgaW5zZXJ0aW9uUG9pbnRFbGVtZW50ID0gaW5zZXJ0aW9uUG9pbnQ7XG4gICAgdmFyIF9wYXJlbnROb2RlID0gaW5zZXJ0aW9uUG9pbnRFbGVtZW50LnBhcmVudE5vZGU7XG5cbiAgICBpZiAoX3BhcmVudE5vZGUpIF9wYXJlbnROb2RlLmluc2VydEJlZm9yZShzdHlsZSwgaW5zZXJ0aW9uUG9pbnRFbGVtZW50Lm5leHRTaWJsaW5nKTtlbHNlICgwLCBfd2FybmluZzJbJ2RlZmF1bHQnXSkoZmFsc2UsICdbSlNTXSBJbnNlcnRpb24gcG9pbnQgaXMgbm90IGluIHRoZSBET00uJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZ2V0SGVhZCgpLmluc2VydEJlZm9yZShzdHlsZSwgcHJldk5vZGUpO1xufVxuXG52YXIgRG9tUmVuZGVyZXIgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIERvbVJlbmRlcmVyKHNoZWV0KSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERvbVJlbmRlcmVyKTtcblxuICAgIHRoaXMuZ2V0U3R5bGUgPSBnZXRTdHlsZTtcbiAgICB0aGlzLnNldFN0eWxlID0gc2V0U3R5bGU7XG4gICAgdGhpcy5zZXRTZWxlY3RvciA9IHNldFNlbGVjdG9yO1xuICAgIHRoaXMuZ2V0S2V5ID0gZ2V0S2V5O1xuICAgIHRoaXMuZ2V0VW5lc2NhcGVkS2V5c01hcCA9IGdldFVuZXNjYXBlZEtleXNNYXA7XG4gICAgdGhpcy5oYXNJbnNlcnRlZFJ1bGVzID0gZmFsc2U7XG5cbiAgICAvLyBUaGVyZSBpcyBubyBzaGVldCB3aGVuIHRoZSByZW5kZXJlciBpcyB1c2VkIGZyb20gYSBzdGFuZGFsb25lIFN0eWxlUnVsZS5cbiAgICBpZiAoc2hlZXQpIF9zaGVldHMyWydkZWZhdWx0J10uYWRkKHNoZWV0KTtcblxuICAgIHRoaXMuc2hlZXQgPSBzaGVldDtcblxuICAgIHZhciBfcmVmID0gdGhpcy5zaGVldCA/IHRoaXMuc2hlZXQub3B0aW9ucyA6IHt9LFxuICAgICAgICBtZWRpYSA9IF9yZWYubWVkaWEsXG4gICAgICAgIG1ldGEgPSBfcmVmLm1ldGEsXG4gICAgICAgIGVsZW1lbnQgPSBfcmVmLmVsZW1lbnQ7XG5cbiAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50IHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgdGhpcy5lbGVtZW50LnR5cGUgPSAndGV4dC9jc3MnO1xuICAgIHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2RhdGEtanNzJywgJycpO1xuICAgIGlmIChtZWRpYSkgdGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZSgnbWVkaWEnLCBtZWRpYSk7XG4gICAgaWYgKG1ldGEpIHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2RhdGEtbWV0YScsIG1ldGEpO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlcnNjb3JlLWRhbmdsZVxuICAgIHZhciBub25jZSA9IGdsb2JhbC5fX3dlYnBhY2tfbm9uY2VfXztcbiAgICBpZiAobm9uY2UpIHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ25vbmNlJywgbm9uY2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluc2VydCBzdHlsZSBlbGVtZW50IGludG8gcmVuZGVyIHRyZWUuXG4gICAqL1xuXG5cbiAgLy8gSFRNTFN0eWxlRWxlbWVudCBuZWVkcyBmaXhpbmcgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2Zsb3cvaXNzdWVzLzI2OTZcblxuXG4gIF9jcmVhdGVDbGFzcyhEb21SZW5kZXJlciwgW3tcbiAgICBrZXk6ICdhdHRhY2gnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhdHRhY2goKSB7XG4gICAgICAvLyBJbiB0aGUgY2FzZSB0aGUgZWxlbWVudCBub2RlIGlzIGV4dGVybmFsIGFuZCBpdCBpcyBhbHJlYWR5IGluIHRoZSBET00uXG4gICAgICBpZiAodGhpcy5lbGVtZW50LnBhcmVudE5vZGUgfHwgIXRoaXMuc2hlZXQpIHJldHVybjtcblxuICAgICAgLy8gV2hlbiBydWxlcyBhcmUgaW5zZXJ0ZWQgdXNpbmcgYGluc2VydFJ1bGVgIEFQSSwgYWZ0ZXIgYHNoZWV0LmRldGFjaCgpLmF0dGFjaCgpYFxuICAgICAgLy8gYnJvd3NlcnMgcmVtb3ZlIHRob3NlIHJ1bGVzLlxuICAgICAgLy8gVE9ETyBmaWd1cmUgb3V0IGlmIGl0cyBhIGJ1ZyBhbmQgaWYgaXQgaXMga25vd24uXG4gICAgICAvLyBXb3JrYXJvdW5kIGlzIHRvIHJlZGVwbG95IHRoZSBzaGVldCBiZWZvcmUgYXR0YWNoaW5nIGFzIGEgc3RyaW5nLlxuICAgICAgaWYgKHRoaXMuaGFzSW5zZXJ0ZWRSdWxlcykge1xuICAgICAgICB0aGlzLmRlcGxveSgpO1xuICAgICAgICB0aGlzLmhhc0luc2VydGVkUnVsZXMgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaW5zZXJ0U3R5bGUodGhpcy5lbGVtZW50LCB0aGlzLnNoZWV0Lm9wdGlvbnMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBzdHlsZSBlbGVtZW50IGZyb20gcmVuZGVyIHRyZWUuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2RldGFjaCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRldGFjaCgpIHtcbiAgICAgIHRoaXMuZWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZWxlbWVudCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5qZWN0IENTUyBzdHJpbmcgaW50byBlbGVtZW50LlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdkZXBsb3knLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXBsb3koKSB7XG4gICAgICBpZiAoIXRoaXMuc2hlZXQpIHJldHVybjtcbiAgICAgIHRoaXMuZWxlbWVudC50ZXh0Q29udGVudCA9ICdcXG4nICsgdGhpcy5zaGVldC50b1N0cmluZygpICsgJ1xcbic7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5zZXJ0IGEgcnVsZSBpbnRvIGVsZW1lbnQuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2luc2VydFJ1bGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnNlcnRSdWxlKHJ1bGUsIGluZGV4KSB7XG4gICAgICB2YXIgc2hlZXQgPSB0aGlzLmVsZW1lbnQuc2hlZXQ7XG4gICAgICB2YXIgY3NzUnVsZXMgPSBzaGVldC5jc3NSdWxlcztcblxuICAgICAgdmFyIHN0ciA9IHJ1bGUudG9TdHJpbmcoKTtcbiAgICAgIGlmICghaW5kZXgpIGluZGV4ID0gY3NzUnVsZXMubGVuZ3RoO1xuXG4gICAgICBpZiAoIXN0cikgcmV0dXJuIGZhbHNlO1xuXG4gICAgICB0cnkge1xuICAgICAgICBzaGVldC5pbnNlcnRSdWxlKHN0ciwgaW5kZXgpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICgwLCBfd2FybmluZzJbJ2RlZmF1bHQnXSkoZmFsc2UsICdbSlNTXSBDYW4gbm90IGluc2VydCBhbiB1bnN1cHBvcnRlZCBydWxlIFxcblxcciVzJywgcnVsZSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaGFzSW5zZXJ0ZWRSdWxlcyA9IHRydWU7XG5cbiAgICAgIHJldHVybiBjc3NSdWxlc1tpbmRleF07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVsZXRlIGEgcnVsZS5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZGVsZXRlUnVsZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlbGV0ZVJ1bGUoY3NzUnVsZSkge1xuICAgICAgdmFyIHNoZWV0ID0gdGhpcy5lbGVtZW50LnNoZWV0O1xuXG4gICAgICB2YXIgaW5kZXggPSB0aGlzLmluZGV4T2YoY3NzUnVsZSk7XG4gICAgICBpZiAoaW5kZXggPT09IC0xKSByZXR1cm4gZmFsc2U7XG4gICAgICBzaGVldC5kZWxldGVSdWxlKGluZGV4KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBpbmRleCBvZiBhIENTUyBSdWxlLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdpbmRleE9mJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5kZXhPZihjc3NSdWxlKSB7XG4gICAgICB2YXIgY3NzUnVsZXMgPSB0aGlzLmVsZW1lbnQuc2hlZXQuY3NzUnVsZXM7XG5cbiAgICAgIGZvciAodmFyIF9pbmRleCA9IDA7IF9pbmRleCA8IGNzc1J1bGVzLmxlbmd0aDsgX2luZGV4KyspIHtcbiAgICAgICAgaWYgKGNzc1J1bGUgPT09IGNzc1J1bGVzW19pbmRleF0pIHJldHVybiBfaW5kZXg7XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgYSBuZXcgQ1NTIHJ1bGUgYW5kIHJlcGxhY2UgdGhlIGV4aXN0aW5nIG9uZS5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAncmVwbGFjZVJ1bGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXBsYWNlUnVsZShjc3NSdWxlLCBydWxlKSB7XG4gICAgICB2YXIgaW5kZXggPSB0aGlzLmluZGV4T2YoY3NzUnVsZSk7XG4gICAgICB2YXIgbmV3Q3NzUnVsZSA9IHRoaXMuaW5zZXJ0UnVsZShydWxlLCBpbmRleCk7XG4gICAgICB0aGlzLmVsZW1lbnQuc2hlZXQuZGVsZXRlUnVsZShpbmRleCk7XG4gICAgICByZXR1cm4gbmV3Q3NzUnVsZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgYWxsIHJ1bGVzIGVsZW1lbnRzLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdnZXRSdWxlcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFJ1bGVzKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudC5zaGVldC5jc3NSdWxlcztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRG9tUmVuZGVyZXI7XG59KCk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IERvbVJlbmRlcmVyOyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuLyogZXNsaW50LWRpc2FibGUgY2xhc3MtbWV0aG9kcy11c2UtdGhpcyAqL1xuXG4vKipcbiAqIFJlbmRlcmluZyBiYWNrZW5kIHRvIGRvIG5vdGhpbmcgaW4gbm9kZWpzLlxuICovXG52YXIgVmlydHVhbFJlbmRlcmVyID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBWaXJ0dWFsUmVuZGVyZXIoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFZpcnR1YWxSZW5kZXJlcik7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoVmlydHVhbFJlbmRlcmVyLCBbe1xuICAgIGtleTogJ3NldFN0eWxlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0U3R5bGUoKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdnZXRTdHlsZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFN0eWxlKCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3NldFNlbGVjdG9yJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0U2VsZWN0b3IoKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdnZXRLZXknLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRLZXkoKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnYXR0YWNoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXR0YWNoKCkge31cbiAgfSwge1xuICAgIGtleTogJ2RldGFjaCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRldGFjaCgpIHt9XG4gIH0sIHtcbiAgICBrZXk6ICdkZXBsb3knLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXBsb3koKSB7fVxuICB9LCB7XG4gICAga2V5OiAnaW5zZXJ0UnVsZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluc2VydFJ1bGUoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZGVsZXRlUnVsZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlbGV0ZVJ1bGUoKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdyZXBsYWNlUnVsZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlcGxhY2VSdWxlKCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2dldFJ1bGVzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UnVsZXMoKSB7fVxuICB9LCB7XG4gICAga2V5OiAnaW5kZXhPZicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluZGV4T2YoKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFZpcnR1YWxSZW5kZXJlcjtcbn0oKTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gVmlydHVhbFJlbmRlcmVyOyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9SdWxlTGlzdCA9IHJlcXVpcmUoJy4uL1J1bGVMaXN0Jyk7XG5cbnZhciBfUnVsZUxpc3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUnVsZUxpc3QpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbi8qKlxuICogQ29uZGl0aW9uYWwgcnVsZSBmb3IgQG1lZGlhLCBAc3VwcG9ydHNcbiAqL1xudmFyIENvbmRpdGlvbmFsUnVsZSA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQ29uZGl0aW9uYWxSdWxlKGtleSwgc3R5bGVzLCBvcHRpb25zKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENvbmRpdGlvbmFsUnVsZSk7XG5cbiAgICB0aGlzLnR5cGUgPSAnY29uZGl0aW9uYWwnO1xuICAgIHRoaXMuaXNQcm9jZXNzZWQgPSBmYWxzZTtcblxuICAgIHRoaXMua2V5ID0ga2V5O1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5ydWxlcyA9IG5ldyBfUnVsZUxpc3QyWydkZWZhdWx0J10oX2V4dGVuZHMoe30sIG9wdGlvbnMsIHsgcGFyZW50OiB0aGlzIH0pKTtcblxuICAgIGZvciAodmFyIG5hbWUgaW4gc3R5bGVzKSB7XG4gICAgICB0aGlzLnJ1bGVzLmFkZChuYW1lLCBzdHlsZXNbbmFtZV0pO1xuICAgIH1cblxuICAgIHRoaXMucnVsZXMucHJvY2VzcygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIHJ1bGUuXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKENvbmRpdGlvbmFsUnVsZSwgW3tcbiAgICBrZXk6ICdnZXRSdWxlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UnVsZShuYW1lKSB7XG4gICAgICByZXR1cm4gdGhpcy5ydWxlcy5nZXQobmFtZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGluZGV4IG9mIGEgcnVsZS5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnaW5kZXhPZicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluZGV4T2YocnVsZSkge1xuICAgICAgcmV0dXJuIHRoaXMucnVsZXMuaW5kZXhPZihydWxlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYW5kIHJlZ2lzdGVyIHJ1bGUsIHJ1biBwbHVnaW5zLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdhZGRSdWxlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkUnVsZShuYW1lLCBzdHlsZSwgb3B0aW9ucykge1xuICAgICAgdmFyIHJ1bGUgPSB0aGlzLnJ1bGVzLmFkZChuYW1lLCBzdHlsZSwgb3B0aW9ucyk7XG4gICAgICB0aGlzLm9wdGlvbnMuanNzLnBsdWdpbnMub25Qcm9jZXNzUnVsZShydWxlKTtcbiAgICAgIHJldHVybiBydWxlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhIENTUyBzdHJpbmcuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3RvU3RyaW5nJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogeyBpbmRlbnQ6IDEgfTtcblxuICAgICAgdmFyIGlubmVyID0gdGhpcy5ydWxlcy50b1N0cmluZyhvcHRpb25zKTtcbiAgICAgIHJldHVybiBpbm5lciA/IHRoaXMua2V5ICsgJyB7XFxuJyArIGlubmVyICsgJ1xcbn0nIDogJyc7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIENvbmRpdGlvbmFsUnVsZTtcbn0oKTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gQ29uZGl0aW9uYWxSdWxlOyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF90b0NzcyA9IHJlcXVpcmUoJy4uL3V0aWxzL3RvQ3NzJyk7XG5cbnZhciBfdG9Dc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdG9Dc3MpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBGb250RmFjZVJ1bGUgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEZvbnRGYWNlUnVsZShrZXksIHN0eWxlLCBvcHRpb25zKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEZvbnRGYWNlUnVsZSk7XG5cbiAgICB0aGlzLnR5cGUgPSAnZm9udC1mYWNlJztcbiAgICB0aGlzLmlzUHJvY2Vzc2VkID0gZmFsc2U7XG5cbiAgICB0aGlzLmtleSA9IGtleTtcbiAgICB0aGlzLnN0eWxlID0gc3R5bGU7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYSBDU1Mgc3RyaW5nLlxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhGb250RmFjZVJ1bGUsIFt7XG4gICAga2V5OiAndG9TdHJpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZyhvcHRpb25zKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLnN0eWxlKSkge1xuICAgICAgICB2YXIgc3RyID0gJyc7XG4gICAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLnN0eWxlLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgIHN0ciArPSAoMCwgX3RvQ3NzMlsnZGVmYXVsdCddKSh0aGlzLmtleSwgdGhpcy5zdHlsZVtpbmRleF0pO1xuICAgICAgICAgIGlmICh0aGlzLnN0eWxlW2luZGV4ICsgMV0pIHN0ciArPSAnXFxuJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gKDAsIF90b0NzczJbJ2RlZmF1bHQnXSkodGhpcy5rZXksIHRoaXMuc3R5bGUsIG9wdGlvbnMpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBGb250RmFjZVJ1bGU7XG59KCk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IEZvbnRGYWNlUnVsZTsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfUnVsZUxpc3QgPSByZXF1aXJlKCcuLi9SdWxlTGlzdCcpO1xuXG52YXIgX1J1bGVMaXN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1J1bGVMaXN0KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4vKipcbiAqIFJ1bGUgZm9yIEBrZXlmcmFtZXNcbiAqL1xudmFyIEtleWZyYW1lc1J1bGUgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEtleWZyYW1lc1J1bGUoa2V5LCBmcmFtZXMsIG9wdGlvbnMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgS2V5ZnJhbWVzUnVsZSk7XG5cbiAgICB0aGlzLnR5cGUgPSAna2V5ZnJhbWVzJztcbiAgICB0aGlzLmlzUHJvY2Vzc2VkID0gZmFsc2U7XG5cbiAgICB0aGlzLmtleSA9IGtleTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMucnVsZXMgPSBuZXcgX1J1bGVMaXN0MlsnZGVmYXVsdCddKF9leHRlbmRzKHt9LCBvcHRpb25zLCB7IHBhcmVudDogdGhpcyB9KSk7XG5cbiAgICBmb3IgKHZhciBuYW1lIGluIGZyYW1lcykge1xuICAgICAgdGhpcy5ydWxlcy5hZGQobmFtZSwgZnJhbWVzW25hbWVdLCBfZXh0ZW5kcyh7fSwgdGhpcy5vcHRpb25zLCB7XG4gICAgICAgIHBhcmVudDogdGhpcyxcbiAgICAgICAgc2VsZWN0b3I6IG5hbWVcbiAgICAgIH0pKTtcbiAgICB9XG5cbiAgICB0aGlzLnJ1bGVzLnByb2Nlc3MoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYSBDU1Mgc3RyaW5nLlxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhLZXlmcmFtZXNSdWxlLCBbe1xuICAgIGtleTogJ3RvU3RyaW5nJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogeyBpbmRlbnQ6IDEgfTtcblxuICAgICAgdmFyIGlubmVyID0gdGhpcy5ydWxlcy50b1N0cmluZyhvcHRpb25zKTtcbiAgICAgIGlmIChpbm5lcikgaW5uZXIgKz0gJ1xcbic7XG4gICAgICByZXR1cm4gdGhpcy5rZXkgKyAnIHtcXG4nICsgaW5uZXIgKyAnfSc7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEtleWZyYW1lc1J1bGU7XG59KCk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IEtleWZyYW1lc1J1bGU7IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgU2ltcGxlUnVsZSA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU2ltcGxlUnVsZShrZXksIHZhbHVlLCBvcHRpb25zKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNpbXBsZVJ1bGUpO1xuXG4gICAgdGhpcy50eXBlID0gJ3NpbXBsZSc7XG4gICAgdGhpcy5pc1Byb2Nlc3NlZCA9IGZhbHNlO1xuXG4gICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGVzIGEgQ1NTIHN0cmluZy5cbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuXG5cbiAgX2NyZWF0ZUNsYXNzKFNpbXBsZVJ1bGUsIFt7XG4gICAga2V5OiAndG9TdHJpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZyhvcHRpb25zKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLnZhbHVlKSkge1xuICAgICAgICB2YXIgc3RyID0gJyc7XG4gICAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLnZhbHVlLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgIHN0ciArPSB0aGlzLmtleSArICcgJyArIHRoaXMudmFsdWVbaW5kZXhdICsgJzsnO1xuICAgICAgICAgIGlmICh0aGlzLnZhbHVlW2luZGV4ICsgMV0pIHN0ciArPSAnXFxuJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5rZXkgKyAnICcgKyB0aGlzLnZhbHVlICsgJzsnO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTaW1wbGVSdWxlO1xufSgpO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBTaW1wbGVSdWxlOyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX3dhcm5pbmcgPSByZXF1aXJlKCd3YXJuaW5nJyk7XG5cbnZhciBfd2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93YXJuaW5nKTtcblxudmFyIF90b0NzcyA9IHJlcXVpcmUoJy4uL3V0aWxzL3RvQ3NzJyk7XG5cbnZhciBfdG9Dc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdG9Dc3MpO1xuXG52YXIgX3RvQ3NzVmFsdWUgPSByZXF1aXJlKCcuLi91dGlscy90b0Nzc1ZhbHVlJyk7XG5cbnZhciBfdG9Dc3NWYWx1ZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90b0Nzc1ZhbHVlKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgU3R5bGVSdWxlID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTdHlsZVJ1bGUoa2V5LCBzdHlsZSwgb3B0aW9ucykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTdHlsZVJ1bGUpO1xuXG4gICAgdGhpcy50eXBlID0gJ3N0eWxlJztcbiAgICB0aGlzLmlzUHJvY2Vzc2VkID0gZmFsc2U7XG4gICAgdmFyIHNoZWV0ID0gb3B0aW9ucy5zaGVldCxcbiAgICAgICAgUmVuZGVyZXIgPSBvcHRpb25zLlJlbmRlcmVyLFxuICAgICAgICBzZWxlY3RvciA9IG9wdGlvbnMuc2VsZWN0b3I7XG5cbiAgICB0aGlzLmtleSA9IGtleTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuc3R5bGUgPSBzdHlsZTtcbiAgICBpZiAoc2VsZWN0b3IpIHRoaXMuc2VsZWN0b3JUZXh0ID0gc2VsZWN0b3I7XG4gICAgdGhpcy5yZW5kZXJlciA9IHNoZWV0ID8gc2hlZXQucmVuZGVyZXIgOiBuZXcgUmVuZGVyZXIoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgc2VsZWN0b3Igc3RyaW5nLlxuICAgKiBBdHRlbnRpb246IHVzZSB0aGlzIHdpdGggY2F1dGlvbi4gTW9zdCBicm93c2VycyBkaWRuJ3QgaW1wbGVtZW50XG4gICAqIHNlbGVjdG9yVGV4dCBzZXR0ZXIsIHNvIHRoaXMgbWF5IHJlc3VsdCBpbiByZXJlbmRlcmluZyBvZiBlbnRpcmUgU3R5bGUgU2hlZXQuXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKFN0eWxlUnVsZSwgW3tcbiAgICBrZXk6ICdwcm9wJyxcblxuXG4gICAgLyoqXG4gICAgICogR2V0IG9yIHNldCBhIHN0eWxlIHByb3BlcnR5LlxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9wKG5hbWUsIG5leHRWYWx1ZSkge1xuICAgICAgLy8gSXQncyBhIHNldHRlci5cbiAgICAgIGlmIChuZXh0VmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAvLyBEb24ndCBkbyBhbnl0aGluZyBpZiB0aGUgdmFsdWUgaGFzIG5vdCBjaGFuZ2VkLlxuICAgICAgICBpZiAodGhpcy5zdHlsZVtuYW1lXSAhPT0gbmV4dFZhbHVlKSB7XG4gICAgICAgICAgbmV4dFZhbHVlID0gdGhpcy5vcHRpb25zLmpzcy5wbHVnaW5zLm9uQ2hhbmdlVmFsdWUobmV4dFZhbHVlLCBuYW1lLCB0aGlzKTtcbiAgICAgICAgICB0aGlzLnN0eWxlW25hbWVdID0gbmV4dFZhbHVlO1xuXG4gICAgICAgICAgLy8gUmVuZGVyYWJsZSBpcyBkZWZpbmVkIGlmIFN0eWxlU2hlZXQgb3B0aW9uIGBsaW5rYCBpcyB0cnVlLlxuICAgICAgICAgIGlmICh0aGlzLnJlbmRlcmFibGUpIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUodGhpcy5yZW5kZXJhYmxlLCBuYW1lLCBuZXh0VmFsdWUpO2Vsc2Uge1xuICAgICAgICAgICAgdmFyIHNoZWV0ID0gdGhpcy5vcHRpb25zLnNoZWV0O1xuXG4gICAgICAgICAgICBpZiAoc2hlZXQgJiYgc2hlZXQuYXR0YWNoZWQpIHtcbiAgICAgICAgICAgICAgKDAsIF93YXJuaW5nMlsnZGVmYXVsdCddKShmYWxzZSwgJ1J1bGUgaXMgbm90IGxpbmtlZC4gTWlzc2luZyBzaGVldCBvcHRpb24gXCJsaW5rOiB0cnVlXCIuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5zdHlsZVtuYW1lXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBcHBseSBydWxlIHRvIGFuIGVsZW1lbnQgaW5saW5lLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdhcHBseVRvJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXBwbHlUbyhyZW5kZXJhYmxlKSB7XG4gICAgICB2YXIganNvbiA9IHRoaXMudG9KU09OKCk7XG4gICAgICBmb3IgKHZhciBwcm9wIGluIGpzb24pIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZShyZW5kZXJhYmxlLCBwcm9wLCBqc29uW3Byb3BdKTtcbiAgICAgIH1yZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIEpTT04gcmVwcmVzZW50YXRpb24gb2YgdGhlIHJ1bGUuXG4gICAgICogRmFsbGJhY2tzIGFyZSBub3Qgc3VwcG9ydGVkLlxuICAgICAqIFVzZWZ1bCBmb3IgaW5saW5lIHN0eWxlcy5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAndG9KU09OJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgdmFyIGpzb24gPSB7fTtcbiAgICAgIGZvciAodmFyIHByb3AgaW4gdGhpcy5zdHlsZSkge1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLnN0eWxlW3Byb3BdO1xuICAgICAgICBpZiAoKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YodmFsdWUpKSAhPT0gJ29iamVjdCcpIGpzb25bcHJvcF0gPSB2YWx1ZTtlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkganNvbltwcm9wXSA9ICgwLCBfdG9Dc3NWYWx1ZTJbJ2RlZmF1bHQnXSkodmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGpzb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGEgQ1NTIHN0cmluZy5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAndG9TdHJpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZyhvcHRpb25zKSB7XG4gICAgICB2YXIgc2hlZXQgPSB0aGlzLm9wdGlvbnMuc2hlZXQ7XG5cbiAgICAgIHZhciBsaW5rID0gc2hlZXQgPyBzaGVldC5vcHRpb25zLmxpbmsgOiBmYWxzZTtcbiAgICAgIHZhciBvcHRzID0gbGluayA/IF9leHRlbmRzKHt9LCBvcHRpb25zLCB7IGFsbG93RW1wdHk6IHRydWUgfSkgOiBvcHRpb25zO1xuICAgICAgcmV0dXJuICgwLCBfdG9Dc3MyWydkZWZhdWx0J10pKHRoaXMuc2VsZWN0b3IsIHRoaXMuc3R5bGUsIG9wdHMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3NlbGVjdG9yJyxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChzZWxlY3Rvcikge1xuICAgICAgaWYgKHNlbGVjdG9yID09PSB0aGlzLnNlbGVjdG9yVGV4dCkgcmV0dXJuO1xuXG4gICAgICB0aGlzLnNlbGVjdG9yVGV4dCA9IHNlbGVjdG9yO1xuXG4gICAgICBpZiAodGhpcy5yZW5kZXJhYmxlKSB7XG4gICAgICAgIHZhciBoYXNDaGFuZ2VkID0gdGhpcy5yZW5kZXJlci5zZXRTZWxlY3Rvcih0aGlzLnJlbmRlcmFibGUsIHNlbGVjdG9yKTtcblxuICAgICAgICAvLyBJZiBzZWxlY3RvciBzZXR0ZXIgaXMgbm90IGltcGxlbWVudGVkLCByZXJlbmRlciB0aGUgcnVsZS5cbiAgICAgICAgaWYgKCFoYXNDaGFuZ2VkICYmIHRoaXMucmVuZGVyYWJsZSkge1xuICAgICAgICAgIHZhciByZW5kZXJhYmxlID0gdGhpcy5yZW5kZXJlci5yZXBsYWNlUnVsZSh0aGlzLnJlbmRlcmFibGUsIHRoaXMpO1xuICAgICAgICAgIGlmIChyZW5kZXJhYmxlKSB0aGlzLnJlbmRlcmFibGUgPSByZW5kZXJhYmxlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHNlbGVjdG9yIHN0cmluZy5cbiAgICAgKi9cbiAgICAsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZWxlY3RvclRleHQ7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFN0eWxlUnVsZTtcbn0oKTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gU3R5bGVSdWxlOyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF90b0NzcyA9IHJlcXVpcmUoJy4uL3V0aWxzL3RvQ3NzJyk7XG5cbnZhciBfdG9Dc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdG9Dc3MpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBWaWV3cG9ydFJ1bGUgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFZpZXdwb3J0UnVsZShrZXksIHN0eWxlLCBvcHRpb25zKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFZpZXdwb3J0UnVsZSk7XG5cbiAgICB0aGlzLnR5cGUgPSAndmlld3BvcnQnO1xuICAgIHRoaXMuaXNQcm9jZXNzZWQgPSBmYWxzZTtcblxuICAgIHRoaXMua2V5ID0ga2V5O1xuICAgIHRoaXMuc3R5bGUgPSBzdHlsZTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhIENTUyBzdHJpbmcuXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKFZpZXdwb3J0UnVsZSwgW3tcbiAgICBrZXk6ICd0b1N0cmluZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiAoMCwgX3RvQ3NzMlsnZGVmYXVsdCddKSh0aGlzLmtleSwgdGhpcy5zdHlsZSwgb3B0aW9ucyk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFZpZXdwb3J0UnVsZTtcbn0oKTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gVmlld3BvcnRSdWxlOyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9TaGVldHNSZWdpc3RyeSA9IHJlcXVpcmUoJy4vU2hlZXRzUmVnaXN0cnknKTtcblxudmFyIF9TaGVldHNSZWdpc3RyeTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9TaGVldHNSZWdpc3RyeSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuLyoqXG4gKiBUaGlzIGlzIGEgZ2xvYmFsIHNoZWV0cyByZWdpc3RyeS4gT25seSBEb21SZW5kZXJlciB3aWxsIGFkZCBzaGVldHMgdG8gaXQuXG4gKiBPbiB0aGUgc2VydmVyIG9uZSBzaG91bGQgdXNlIGFuIG93biBTaGVldHNSZWdpc3RyeSBpbnN0YW5jZSBhbmQgYWRkIHRoZVxuICogc2hlZXRzIHRvIGl0LCBiZWNhdXNlIHlvdSBuZWVkIHRvIG1ha2Ugc3VyZSB0byBjcmVhdGUgYSBuZXcgcmVnaXN0cnkgZm9yXG4gKiBlYWNoIHJlcXVlc3QgaW4gb3JkZXIgdG8gbm90IGxlYWsgc2hlZXRzIGFjcm9zcyByZXF1ZXN0cy5cbiAqL1xuZXhwb3J0c1snZGVmYXVsdCddID0gbmV3IF9TaGVldHNSZWdpc3RyeTJbJ2RlZmF1bHQnXSgpOyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBjbG9uZVN0eWxlO1xuXG52YXIgX2lzT2JzZXJ2YWJsZSA9IHJlcXVpcmUoJy4vaXNPYnNlcnZhYmxlJyk7XG5cbnZhciBfaXNPYnNlcnZhYmxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2lzT2JzZXJ2YWJsZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuZnVuY3Rpb24gY2xvbmVTdHlsZShzdHlsZSkge1xuICAvLyBTdXBwb3J0IGVtcHR5IHZhbHVlcyBpbiBjYXNlIHVzZXIgZW5kcyB1cCB3aXRoIHRoZW0gYnkgYWNjaWRlbnQuXG4gIGlmIChzdHlsZSA9PSBudWxsKSByZXR1cm4gc3R5bGU7XG5cbiAgLy8gU3VwcG9ydCBzdHJpbmcgdmFsdWUgZm9yIFNpbXBsZVJ1bGUuXG4gIHZhciB0eXBlT2ZTdHlsZSA9IHR5cGVvZiBzdHlsZSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2Yoc3R5bGUpO1xuXG4gIGlmICh0eXBlT2ZTdHlsZSA9PT0gJ3N0cmluZycgfHwgdHlwZU9mU3R5bGUgPT09ICdudW1iZXInIHx8IHR5cGVPZlN0eWxlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHN0eWxlO1xuICB9XG5cbiAgLy8gU3VwcG9ydCBhcnJheSBmb3IgRm9udEZhY2VSdWxlLlxuICBpZiAoaXNBcnJheShzdHlsZSkpIHJldHVybiBzdHlsZS5tYXAoY2xvbmVTdHlsZSk7XG5cbiAgLy8gU3VwcG9ydCBPYnNlcnZhYmxlIHN0eWxlcy4gIE9ic2VydmFibGVzIGFyZSBpbW11dGFibGUsIHNvIHdlIGRvbid0IG5lZWQgdG9cbiAgLy8gY29weSB0aGVtLlxuICBpZiAoKDAsIF9pc09ic2VydmFibGUyWydkZWZhdWx0J10pKHN0eWxlKSkgcmV0dXJuIHN0eWxlO1xuXG4gIHZhciBuZXdTdHlsZSA9IHt9O1xuICBmb3IgKHZhciBuYW1lIGluIHN0eWxlKSB7XG4gICAgdmFyIHZhbHVlID0gc3R5bGVbbmFtZV07XG4gICAgaWYgKCh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHZhbHVlKSkgPT09ICdvYmplY3QnKSB7XG4gICAgICBuZXdTdHlsZVtuYW1lXSA9IGNsb25lU3R5bGUodmFsdWUpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIG5ld1N0eWxlW25hbWVdID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gbmV3U3R5bGU7XG59IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3dhcm5pbmcgPSByZXF1aXJlKCd3YXJuaW5nJyk7XG5cbnZhciBfd2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93YXJuaW5nKTtcblxudmFyIF9TdHlsZVNoZWV0ID0gcmVxdWlyZSgnLi4vU3R5bGVTaGVldCcpO1xuXG52YXIgX1N0eWxlU2hlZXQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU3R5bGVTaGVldCk7XG5cbnZhciBfbW9kdWxlSWQgPSByZXF1aXJlKCcuL21vZHVsZUlkJyk7XG5cbnZhciBfbW9kdWxlSWQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbW9kdWxlSWQpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBtYXhSdWxlcyA9IDFlMTA7XG5cblxudmFyIGVudiA9IHByb2Nlc3MuZW52Lk5PREVfRU5WO1xuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB3aGljaCBnZW5lcmF0ZXMgdW5pcXVlIGNsYXNzIG5hbWVzIGJhc2VkIG9uIGNvdW50ZXJzLlxuICogV2hlbiBuZXcgZ2VuZXJhdG9yIGZ1bmN0aW9uIGlzIGNyZWF0ZWQsIHJ1bGUgY291bnRlciBpcyByZXNldGVkLlxuICogV2UgbmVlZCB0byByZXNldCB0aGUgcnVsZSBjb3VudGVyIGZvciBTU1IgZm9yIGVhY2ggcmVxdWVzdC5cbiAqL1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBydWxlQ291bnRlciA9IDA7XG4gIHZhciBkZWZhdWx0UHJlZml4ID0gZW52ID09PSAncHJvZHVjdGlvbicgPyAnYycgOiAnJztcblxuICByZXR1cm4gZnVuY3Rpb24gKHJ1bGUsIHNoZWV0KSB7XG4gICAgcnVsZUNvdW50ZXIgKz0gMTtcblxuICAgIGlmIChydWxlQ291bnRlciA+IG1heFJ1bGVzKSB7XG4gICAgICAoMCwgX3dhcm5pbmcyWydkZWZhdWx0J10pKGZhbHNlLCAnW0pTU10gWW91IG1pZ2h0IGhhdmUgYSBtZW1vcnkgbGVhay4gUnVsZSBjb3VudGVyIGlzIGF0ICVzLicsIHJ1bGVDb3VudGVyKTtcbiAgICB9XG5cbiAgICB2YXIgcHJlZml4ID0gZGVmYXVsdFByZWZpeDtcbiAgICB2YXIganNzSWQgPSAnJztcblxuICAgIGlmIChzaGVldCkge1xuICAgICAgcHJlZml4ID0gc2hlZXQub3B0aW9ucy5jbGFzc05hbWVQcmVmaXggfHwgZGVmYXVsdFByZWZpeDtcbiAgICAgIGlmIChzaGVldC5vcHRpb25zLmpzcy5pZCAhPSBudWxsKSBqc3NJZCArPSBzaGVldC5vcHRpb25zLmpzcy5pZDtcbiAgICB9XG5cbiAgICBpZiAoZW52ID09PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHJldHVybiAnJyArIHByZWZpeCArIF9tb2R1bGVJZDJbJ2RlZmF1bHQnXSArIGpzc0lkICsgcnVsZUNvdW50ZXI7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByZWZpeCArIHJ1bGUua2V5ICsgJy0nICsgX21vZHVsZUlkMlsnZGVmYXVsdCddICsgKGpzc0lkICYmICctJyArIGpzc0lkKSArICctJyArIHJ1bGVDb3VudGVyO1xuICB9O1xufTsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzWydkZWZhdWx0J10gPSBjcmVhdGVSdWxlO1xuXG52YXIgX3dhcm5pbmcgPSByZXF1aXJlKCd3YXJuaW5nJyk7XG5cbnZhciBfd2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93YXJuaW5nKTtcblxudmFyIF9TdHlsZVJ1bGUgPSByZXF1aXJlKCcuLi9ydWxlcy9TdHlsZVJ1bGUnKTtcblxudmFyIF9TdHlsZVJ1bGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU3R5bGVSdWxlKTtcblxudmFyIF9jbG9uZVN0eWxlID0gcmVxdWlyZSgnLi4vdXRpbHMvY2xvbmVTdHlsZScpO1xuXG52YXIgX2Nsb25lU3R5bGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xvbmVTdHlsZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuLyoqXG4gKiBDcmVhdGUgYSBydWxlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBjcmVhdGVSdWxlKCkge1xuICB2YXIgbmFtZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogJ3VubmFtZWQnO1xuICB2YXIgZGVjbCA9IGFyZ3VtZW50c1sxXTtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHNbMl07XG4gIHZhciBqc3MgPSBvcHRpb25zLmpzcztcblxuICB2YXIgZGVjbENvcHkgPSAoMCwgX2Nsb25lU3R5bGUyWydkZWZhdWx0J10pKGRlY2wpO1xuXG4gIHZhciBydWxlID0ganNzLnBsdWdpbnMub25DcmVhdGVSdWxlKG5hbWUsIGRlY2xDb3B5LCBvcHRpb25zKTtcbiAgaWYgKHJ1bGUpIHJldHVybiBydWxlO1xuXG4gIC8vIEl0IGlzIGFuIGF0LXJ1bGUgYW5kIGl0IGhhcyBubyBpbnN0YW5jZS5cbiAgaWYgKG5hbWVbMF0gPT09ICdAJykge1xuICAgICgwLCBfd2FybmluZzJbJ2RlZmF1bHQnXSkoZmFsc2UsICdbSlNTXSBVbmtub3duIGF0LXJ1bGUgJXMnLCBuYW1lKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgX1N0eWxlUnVsZTJbJ2RlZmF1bHQnXShuYW1lLCBkZWNsQ29weSwgb3B0aW9ucyk7XG59IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xudmFyIENTUyA9IGdsb2JhbC5DU1M7XG5cbnZhciBlbnYgPSBwcm9jZXNzLmVudi5OT0RFX0VOVjtcblxudmFyIGVzY2FwZVJlZ2V4ID0gLyhbW1xcXS4jKiQ+PCt+PXxeOigpLFwiJ2BdKS9nO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBmdW5jdGlvbiAoc3RyKSB7XG4gIC8vIFdlIGRvbid0IG5lZWQgdG8gZXNjYXBlIGl0IGluIHByb2R1Y3Rpb24sIGJlY2F1c2Ugd2UgYXJlIG5vdCB1c2luZyB1c2VyJ3NcbiAgLy8gaW5wdXQgZm9yIHNlbGVjdG9ycywgd2UgYXJlIGdlbmVyYXRpbmcgYSB2YWxpZCBzZWxlY3Rvci5cbiAgaWYgKGVudiA9PT0gJ3Byb2R1Y3Rpb24nKSByZXR1cm4gc3RyO1xuXG4gIGlmICghQ1NTIHx8ICFDU1MuZXNjYXBlKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKGVzY2FwZVJlZ2V4LCAnXFxcXCQxJyk7XG4gIH1cblxuICByZXR1cm4gQ1NTLmVzY2FwZShzdHIpO1xufTsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuLyoqXG4gKiBFeHRyYWN0cyBhIHN0eWxlcyBvYmplY3Qgd2l0aCBvbmx5IHByb3BzIHRoYXQgY29udGFpbiBmdW5jdGlvbiB2YWx1ZXMuXG4gKi9cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGZ1bmN0aW9uIChzdHlsZXMpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNoYWRvd1xuICBmdW5jdGlvbiBleHRyYWN0KHN0eWxlcykge1xuICAgIHZhciB0byA9IG51bGw7XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gc3R5bGVzKSB7XG4gICAgICB2YXIgdmFsdWUgPSBzdHlsZXNba2V5XTtcbiAgICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih2YWx1ZSk7XG5cbiAgICAgIGlmICh0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGlmICghdG8pIHRvID0ge307XG4gICAgICAgIHRvW2tleV0gPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGwgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHZhciBleHRyYWN0ZWQgPSBleHRyYWN0KHZhbHVlKTtcbiAgICAgICAgaWYgKGV4dHJhY3RlZCkge1xuICAgICAgICAgIGlmICghdG8pIHRvID0ge307XG4gICAgICAgICAgdG9ba2V5XSA9IGV4dHJhY3RlZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0bztcbiAgfVxuXG4gIHJldHVybiBleHRyYWN0KHN0eWxlcyk7XG59OyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9zeW1ib2xPYnNlcnZhYmxlID0gcmVxdWlyZSgnc3ltYm9sLW9ic2VydmFibGUnKTtcblxudmFyIF9zeW1ib2xPYnNlcnZhYmxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3N5bWJvbE9ic2VydmFibGUpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgJiYgdmFsdWVbX3N5bWJvbE9ic2VydmFibGUyWydkZWZhdWx0J11dICYmIHZhbHVlID09PSB2YWx1ZVtfc3ltYm9sT2JzZXJ2YWJsZTJbJ2RlZmF1bHQnXV0oKTtcbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG52YXIgcmVnRXhwID0gLyhbQS1aXSkvZztcbnZhciByZXBsYWNlID0gZnVuY3Rpb24gcmVwbGFjZShzdHIpIHtcbiAgcmV0dXJuIFwiLVwiICsgc3RyLnRvTG93ZXJDYXNlKCk7XG59O1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKHJlZ0V4cCwgcmVwbGFjZSk7XG59OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBsaW5rUnVsZTtcbi8qKlxuICogTGluayBydWxlIHdpdGggQ1NTU3R5bGVSdWxlIGFuZCBuZXN0ZWQgcnVsZXMgd2l0aCBjb3JyZXNwb25kaW5nIG5lc3RlZCBjc3NSdWxlcyBpZiBib3RoIGV4aXN0cy5cbiAqL1xuZnVuY3Rpb24gbGlua1J1bGUocnVsZSwgY3NzUnVsZSkge1xuICBydWxlLnJlbmRlcmFibGUgPSBjc3NSdWxlO1xuICBpZiAocnVsZS5ydWxlcyAmJiBjc3NSdWxlLmNzc1J1bGVzKSBydWxlLnJ1bGVzLmxpbmsoY3NzUnVsZS5jc3NSdWxlcyk7XG59IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xudmFyIG5zID0gJzJmMWFjYzZjM2E2MDZiMDgyZTVlZWY1ZTU0NDE0ZmZiJztcbmlmIChnbG9iYWxbbnNdID09IG51bGwpIGdsb2JhbFtuc10gPSAwO1xuXG4vLyBCdW5kbGUgbWF5IGNvbnRhaW4gbXVsdGlwbGUgSlNTIHZlcnNpb25zIGF0IHRoZSBzYW1lIHRpbWUuIEluIG9yZGVyIHRvIGlkZW50aWZ5XG4vLyB0aGUgY3VycmVudCB2ZXJzaW9uIHdpdGgganVzdCBvbmUgc2hvcnQgbnVtYmVyIGFuZCB1c2UgaXQgZm9yIGNsYXNzZXMgZ2VuZXJhdGlvblxuLy8gd2UgdXNlIGEgY291bnRlci4gQWxzbyBpdCBpcyBtb3JlIGFjY3VyYXRlLCBiZWNhdXNlIHVzZXIgY2FuIG1hbnVhbGx5IHJlZXZhbHVhdGVcbi8vIHRoZSBtb2R1bGUuXG5leHBvcnRzWydkZWZhdWx0J10gPSBnbG9iYWxbbnNdKys7IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0c1snZGVmYXVsdCddID0gdG9Dc3M7XG5cbnZhciBfdG9Dc3NWYWx1ZSA9IHJlcXVpcmUoJy4vdG9Dc3NWYWx1ZScpO1xuXG52YXIgX3RvQ3NzVmFsdWUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdG9Dc3NWYWx1ZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuLyoqXG4gKiBJbmRlbnQgYSBzdHJpbmcuXG4gKiBodHRwOi8vanNwZXJmLmNvbS9hcnJheS1qb2luLXZzLWZvclxuICovXG5mdW5jdGlvbiBpbmRlbnRTdHIoc3RyLCBpbmRlbnQpIHtcbiAgdmFyIHJlc3VsdCA9ICcnO1xuICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgaW5kZW50OyBpbmRleCsrKSB7XG4gICAgcmVzdWx0ICs9ICcgICc7XG4gIH1yZXR1cm4gcmVzdWx0ICsgc3RyO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgUnVsZSB0byBDU1Mgc3RyaW5nLlxuICovXG5cbmZ1bmN0aW9uIHRvQ3NzKHNlbGVjdG9yLCBzdHlsZSkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG5cbiAgdmFyIHJlc3VsdCA9ICcnO1xuXG4gIGlmICghc3R5bGUpIHJldHVybiByZXN1bHQ7XG5cbiAgdmFyIF9vcHRpb25zJGluZGVudCA9IG9wdGlvbnMuaW5kZW50LFxuICAgICAgaW5kZW50ID0gX29wdGlvbnMkaW5kZW50ID09PSB1bmRlZmluZWQgPyAwIDogX29wdGlvbnMkaW5kZW50O1xuICB2YXIgZmFsbGJhY2tzID0gc3R5bGUuZmFsbGJhY2tzO1xuXG5cbiAgaW5kZW50Kys7XG5cbiAgLy8gQXBwbHkgZmFsbGJhY2tzIGZpcnN0LlxuICBpZiAoZmFsbGJhY2tzKSB7XG4gICAgLy8gQXJyYXkgc3ludGF4IHtmYWxsYmFja3M6IFt7cHJvcDogdmFsdWV9XX1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShmYWxsYmFja3MpKSB7XG4gICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgZmFsbGJhY2tzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICB2YXIgZmFsbGJhY2sgPSBmYWxsYmFja3NbaW5kZXhdO1xuICAgICAgICBmb3IgKHZhciBwcm9wIGluIGZhbGxiYWNrKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gZmFsbGJhY2tbcHJvcF07XG4gICAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSAnXFxuJyArIGluZGVudFN0cihwcm9wICsgJzogJyArICgwLCBfdG9Dc3NWYWx1ZTJbJ2RlZmF1bHQnXSkodmFsdWUpICsgJzsnLCBpbmRlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBPYmplY3Qgc3ludGF4IHtmYWxsYmFja3M6IHtwcm9wOiB2YWx1ZX19XG4gICAgZWxzZSB7XG4gICAgICAgIGZvciAodmFyIF9wcm9wIGluIGZhbGxiYWNrcykge1xuICAgICAgICAgIHZhciBfdmFsdWUgPSBmYWxsYmFja3NbX3Byb3BdO1xuICAgICAgICAgIGlmIChfdmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0ICs9ICdcXG4nICsgaW5kZW50U3RyKF9wcm9wICsgJzogJyArICgwLCBfdG9Dc3NWYWx1ZTJbJ2RlZmF1bHQnXSkoX3ZhbHVlKSArICc7JywgaW5kZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIF9wcm9wMiBpbiBzdHlsZSkge1xuICAgIHZhciBfdmFsdWUyID0gc3R5bGVbX3Byb3AyXTtcbiAgICBpZiAoX3ZhbHVlMiAhPSBudWxsICYmIF9wcm9wMiAhPT0gJ2ZhbGxiYWNrcycpIHtcbiAgICAgIHJlc3VsdCArPSAnXFxuJyArIGluZGVudFN0cihfcHJvcDIgKyAnOiAnICsgKDAsIF90b0Nzc1ZhbHVlMlsnZGVmYXVsdCddKShfdmFsdWUyKSArICc7JywgaW5kZW50KTtcbiAgICB9XG4gIH1cblxuICAvLyBBbGxvdyBlbXB0eSBzdHlsZSBpbiB0aGlzIGNhc2UsIGJlY2F1c2UgcHJvcGVydGllcyB3aWxsIGJlIGFkZGVkIGR5bmFtaWNhbGx5LlxuICBpZiAoIXJlc3VsdCAmJiAhb3B0aW9ucy5hbGxvd0VtcHR5KSByZXR1cm4gcmVzdWx0O1xuXG4gIGluZGVudC0tO1xuICByZXN1bHQgPSBpbmRlbnRTdHIoc2VsZWN0b3IgKyAnIHsnICsgcmVzdWx0ICsgJ1xcbicsIGluZGVudCkgKyBpbmRlbnRTdHIoJ30nLCBpbmRlbnQpO1xuXG4gIHJldHVybiByZXN1bHQ7XG59IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0c1snZGVmYXVsdCddID0gdG9Dc3NWYWx1ZTtcbnZhciBqb2luID0gZnVuY3Rpb24gam9pbih2YWx1ZSwgYnkpIHtcbiAgdmFyIHJlc3VsdCA9ICcnO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gUmVtb3ZlICFpbXBvcnRhbnQgZnJvbSB0aGUgdmFsdWUsIGl0IHdpbGwgYmUgcmVhZGRlZCBsYXRlci5cbiAgICBpZiAodmFsdWVbaV0gPT09ICchaW1wb3J0YW50JykgYnJlYWs7XG4gICAgaWYgKHJlc3VsdCkgcmVzdWx0ICs9IGJ5O1xuICAgIHJlc3VsdCArPSB2YWx1ZVtpXTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhcnJheSB2YWx1ZXMgdG8gc3RyaW5nLlxuICpcbiAqIGBtYXJnaW46IFtbJzVweCcsICcxMHB4J11dYCA+IGBtYXJnaW46IDVweCAxMHB4O2BcbiAqIGBib3JkZXI6IFsnMXB4JywgJzJweCddYCA+IGBib3JkZXI6IDFweCwgMnB4O2BcbiAqIGBtYXJnaW46IFtbJzVweCcsICcxMHB4J10sICchaW1wb3J0YW50J11gID4gYG1hcmdpbjogNXB4IDEwcHggIWltcG9ydGFudDtgXG4gKiBgY29sb3I6IFsncmVkJywgIWltcG9ydGFudF1gID4gYGNvbG9yOiByZWQgIWltcG9ydGFudDtgXG4gKi9cbmZ1bmN0aW9uIHRvQ3NzVmFsdWUodmFsdWUpIHtcbiAgdmFyIGlnbm9yZUltcG9ydGFudCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG5cbiAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkgcmV0dXJuIHZhbHVlO1xuXG4gIHZhciBjc3NWYWx1ZSA9ICcnO1xuXG4gIC8vIFN1cHBvcnQgc3BhY2Ugc2VwYXJhdGVkIHZhbHVlcyB2aWEgYFtbJzVweCcsICcxMHB4J11dYC5cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVbMF0pKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHZhbHVlW2ldID09PSAnIWltcG9ydGFudCcpIGJyZWFrO1xuICAgICAgaWYgKGNzc1ZhbHVlKSBjc3NWYWx1ZSArPSAnLCAnO1xuICAgICAgY3NzVmFsdWUgKz0gam9pbih2YWx1ZVtpXSwgJyAnKTtcbiAgICB9XG4gIH0gZWxzZSBjc3NWYWx1ZSA9IGpvaW4odmFsdWUsICcsICcpO1xuXG4gIC8vIEFkZCAhaW1wb3J0YW50LCBiZWNhdXNlIGl0IHdhcyBpZ25vcmVkLlxuICBpZiAoIWlnbm9yZUltcG9ydGFudCAmJiB2YWx1ZVt2YWx1ZS5sZW5ndGggLSAxXSA9PT0gJyFpbXBvcnRhbnQnKSB7XG4gICAgY3NzVmFsdWUgKz0gJyAhaW1wb3J0YW50JztcbiAgfVxuXG4gIHJldHVybiBjc3NWYWx1ZTtcbn0iLCIvLyEgbW9tZW50LmpzXG4vLyEgdmVyc2lvbiA6IDIuMjAuMVxuLy8hIGF1dGhvcnMgOiBUaW0gV29vZCwgSXNrcmVuIENoZXJuZXYsIE1vbWVudC5qcyBjb250cmlidXRvcnNcbi8vISBsaWNlbnNlIDogTUlUXG4vLyEgbW9tZW50anMuY29tXG5cbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcbiAgICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuICAgIGdsb2JhbC5tb21lbnQgPSBmYWN0b3J5KClcbn0odGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG52YXIgaG9va0NhbGxiYWNrO1xuXG5mdW5jdGlvbiBob29rcyAoKSB7XG4gICAgcmV0dXJuIGhvb2tDYWxsYmFjay5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufVxuXG4vLyBUaGlzIGlzIGRvbmUgdG8gcmVnaXN0ZXIgdGhlIG1ldGhvZCBjYWxsZWQgd2l0aCBtb21lbnQoKVxuLy8gd2l0aG91dCBjcmVhdGluZyBjaXJjdWxhciBkZXBlbmRlbmNpZXMuXG5mdW5jdGlvbiBzZXRIb29rQ2FsbGJhY2sgKGNhbGxiYWNrKSB7XG4gICAgaG9va0NhbGxiYWNrID0gY2FsbGJhY2s7XG59XG5cbmZ1bmN0aW9uIGlzQXJyYXkoaW5wdXQpIHtcbiAgICByZXR1cm4gaW5wdXQgaW5zdGFuY2VvZiBBcnJheSB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBBcnJheV0nO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdChpbnB1dCkge1xuICAgIC8vIElFOCB3aWxsIHRyZWF0IHVuZGVmaW5lZCBhbmQgbnVsbCBhcyBvYmplY3QgaWYgaXQgd2Fzbid0IGZvclxuICAgIC8vIGlucHV0ICE9IG51bGxcbiAgICByZXR1cm4gaW5wdXQgIT0gbnVsbCAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBPYmplY3RdJztcbn1cblxuZnVuY3Rpb24gaXNPYmplY3RFbXB0eShvYmopIHtcbiAgICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMpIHtcbiAgICAgICAgcmV0dXJuIChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopLmxlbmd0aCA9PT0gMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGs7XG4gICAgICAgIGZvciAoayBpbiBvYmopIHtcbiAgICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoaykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChpbnB1dCkge1xuICAgIHJldHVybiBpbnB1dCA9PT0gdm9pZCAwO1xufVxuXG5mdW5jdGlvbiBpc051bWJlcihpbnB1dCkge1xuICAgIHJldHVybiB0eXBlb2YgaW5wdXQgPT09ICdudW1iZXInIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09ICdbb2JqZWN0IE51bWJlcl0nO1xufVxuXG5mdW5jdGlvbiBpc0RhdGUoaW5wdXQpIHtcbiAgICByZXR1cm4gaW5wdXQgaW5zdGFuY2VvZiBEYXRlIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cblxuZnVuY3Rpb24gbWFwKGFyciwgZm4pIHtcbiAgICB2YXIgcmVzID0gW10sIGk7XG4gICAgZm9yIChpID0gMDsgaSA8IGFyci5sZW5ndGg7ICsraSkge1xuICAgICAgICByZXMucHVzaChmbihhcnJbaV0sIGkpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cblxuZnVuY3Rpb24gaGFzT3duUHJvcChhLCBiKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhLCBiKTtcbn1cblxuZnVuY3Rpb24gZXh0ZW5kKGEsIGIpIHtcbiAgICBmb3IgKHZhciBpIGluIGIpIHtcbiAgICAgICAgaWYgKGhhc093blByb3AoYiwgaSkpIHtcbiAgICAgICAgICAgIGFbaV0gPSBiW2ldO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGhhc093blByb3AoYiwgJ3RvU3RyaW5nJykpIHtcbiAgICAgICAgYS50b1N0cmluZyA9IGIudG9TdHJpbmc7XG4gICAgfVxuXG4gICAgaWYgKGhhc093blByb3AoYiwgJ3ZhbHVlT2YnKSkge1xuICAgICAgICBhLnZhbHVlT2YgPSBiLnZhbHVlT2Y7XG4gICAgfVxuXG4gICAgcmV0dXJuIGE7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVVUQyAoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QpIHtcbiAgICByZXR1cm4gY3JlYXRlTG9jYWxPclVUQyhpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCwgdHJ1ZSkudXRjKCk7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRQYXJzaW5nRmxhZ3MoKSB7XG4gICAgLy8gV2UgbmVlZCB0byBkZWVwIGNsb25lIHRoaXMgb2JqZWN0LlxuICAgIHJldHVybiB7XG4gICAgICAgIGVtcHR5ICAgICAgICAgICA6IGZhbHNlLFxuICAgICAgICB1bnVzZWRUb2tlbnMgICAgOiBbXSxcbiAgICAgICAgdW51c2VkSW5wdXQgICAgIDogW10sXG4gICAgICAgIG92ZXJmbG93ICAgICAgICA6IC0yLFxuICAgICAgICBjaGFyc0xlZnRPdmVyICAgOiAwLFxuICAgICAgICBudWxsSW5wdXQgICAgICAgOiBmYWxzZSxcbiAgICAgICAgaW52YWxpZE1vbnRoICAgIDogbnVsbCxcbiAgICAgICAgaW52YWxpZEZvcm1hdCAgIDogZmFsc2UsXG4gICAgICAgIHVzZXJJbnZhbGlkYXRlZCA6IGZhbHNlLFxuICAgICAgICBpc28gICAgICAgICAgICAgOiBmYWxzZSxcbiAgICAgICAgcGFyc2VkRGF0ZVBhcnRzIDogW10sXG4gICAgICAgIG1lcmlkaWVtICAgICAgICA6IG51bGwsXG4gICAgICAgIHJmYzI4MjIgICAgICAgICA6IGZhbHNlLFxuICAgICAgICB3ZWVrZGF5TWlzbWF0Y2ggOiBmYWxzZVxuICAgIH07XG59XG5cbmZ1bmN0aW9uIGdldFBhcnNpbmdGbGFncyhtKSB7XG4gICAgaWYgKG0uX3BmID09IG51bGwpIHtcbiAgICAgICAgbS5fcGYgPSBkZWZhdWx0UGFyc2luZ0ZsYWdzKCk7XG4gICAgfVxuICAgIHJldHVybiBtLl9wZjtcbn1cblxudmFyIHNvbWU7XG5pZiAoQXJyYXkucHJvdG90eXBlLnNvbWUpIHtcbiAgICBzb21lID0gQXJyYXkucHJvdG90eXBlLnNvbWU7XG59IGVsc2Uge1xuICAgIHNvbWUgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgICAgIHZhciB0ID0gT2JqZWN0KHRoaXMpO1xuICAgICAgICB2YXIgbGVuID0gdC5sZW5ndGggPj4+IDA7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaWYgKGkgaW4gdCAmJiBmdW4uY2FsbCh0aGlzLCB0W2ldLCBpLCB0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG59XG5cbmZ1bmN0aW9uIGlzVmFsaWQobSkge1xuICAgIGlmIChtLl9pc1ZhbGlkID09IG51bGwpIHtcbiAgICAgICAgdmFyIGZsYWdzID0gZ2V0UGFyc2luZ0ZsYWdzKG0pO1xuICAgICAgICB2YXIgcGFyc2VkUGFydHMgPSBzb21lLmNhbGwoZmxhZ3MucGFyc2VkRGF0ZVBhcnRzLCBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgcmV0dXJuIGkgIT0gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBpc05vd1ZhbGlkID0gIWlzTmFOKG0uX2QuZ2V0VGltZSgpKSAmJlxuICAgICAgICAgICAgZmxhZ3Mub3ZlcmZsb3cgPCAwICYmXG4gICAgICAgICAgICAhZmxhZ3MuZW1wdHkgJiZcbiAgICAgICAgICAgICFmbGFncy5pbnZhbGlkTW9udGggJiZcbiAgICAgICAgICAgICFmbGFncy5pbnZhbGlkV2Vla2RheSAmJlxuICAgICAgICAgICAgIWZsYWdzLndlZWtkYXlNaXNtYXRjaCAmJlxuICAgICAgICAgICAgIWZsYWdzLm51bGxJbnB1dCAmJlxuICAgICAgICAgICAgIWZsYWdzLmludmFsaWRGb3JtYXQgJiZcbiAgICAgICAgICAgICFmbGFncy51c2VySW52YWxpZGF0ZWQgJiZcbiAgICAgICAgICAgICghZmxhZ3MubWVyaWRpZW0gfHwgKGZsYWdzLm1lcmlkaWVtICYmIHBhcnNlZFBhcnRzKSk7XG5cbiAgICAgICAgaWYgKG0uX3N0cmljdCkge1xuICAgICAgICAgICAgaXNOb3dWYWxpZCA9IGlzTm93VmFsaWQgJiZcbiAgICAgICAgICAgICAgICBmbGFncy5jaGFyc0xlZnRPdmVyID09PSAwICYmXG4gICAgICAgICAgICAgICAgZmxhZ3MudW51c2VkVG9rZW5zLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgICAgICAgICAgIGZsYWdzLmJpZ0hvdXIgPT09IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChPYmplY3QuaXNGcm96ZW4gPT0gbnVsbCB8fCAhT2JqZWN0LmlzRnJvemVuKG0pKSB7XG4gICAgICAgICAgICBtLl9pc1ZhbGlkID0gaXNOb3dWYWxpZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBpc05vd1ZhbGlkO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtLl9pc1ZhbGlkO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVJbnZhbGlkIChmbGFncykge1xuICAgIHZhciBtID0gY3JlYXRlVVRDKE5hTik7XG4gICAgaWYgKGZsYWdzICE9IG51bGwpIHtcbiAgICAgICAgZXh0ZW5kKGdldFBhcnNpbmdGbGFncyhtKSwgZmxhZ3MpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKG0pLnVzZXJJbnZhbGlkYXRlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG07XG59XG5cbi8vIFBsdWdpbnMgdGhhdCBhZGQgcHJvcGVydGllcyBzaG91bGQgYWxzbyBhZGQgdGhlIGtleSBoZXJlIChudWxsIHZhbHVlKSxcbi8vIHNvIHdlIGNhbiBwcm9wZXJseSBjbG9uZSBvdXJzZWx2ZXMuXG52YXIgbW9tZW50UHJvcGVydGllcyA9IGhvb2tzLm1vbWVudFByb3BlcnRpZXMgPSBbXTtcblxuZnVuY3Rpb24gY29weUNvbmZpZyh0bywgZnJvbSkge1xuICAgIHZhciBpLCBwcm9wLCB2YWw7XG5cbiAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2lzQU1vbWVudE9iamVjdCkpIHtcbiAgICAgICAgdG8uX2lzQU1vbWVudE9iamVjdCA9IGZyb20uX2lzQU1vbWVudE9iamVjdDtcbiAgICB9XG4gICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9pKSkge1xuICAgICAgICB0by5faSA9IGZyb20uX2k7XG4gICAgfVxuICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fZikpIHtcbiAgICAgICAgdG8uX2YgPSBmcm9tLl9mO1xuICAgIH1cbiAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2wpKSB7XG4gICAgICAgIHRvLl9sID0gZnJvbS5fbDtcbiAgICB9XG4gICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9zdHJpY3QpKSB7XG4gICAgICAgIHRvLl9zdHJpY3QgPSBmcm9tLl9zdHJpY3Q7XG4gICAgfVxuICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fdHptKSkge1xuICAgICAgICB0by5fdHptID0gZnJvbS5fdHptO1xuICAgIH1cbiAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2lzVVRDKSkge1xuICAgICAgICB0by5faXNVVEMgPSBmcm9tLl9pc1VUQztcbiAgICB9XG4gICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9vZmZzZXQpKSB7XG4gICAgICAgIHRvLl9vZmZzZXQgPSBmcm9tLl9vZmZzZXQ7XG4gICAgfVxuICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fcGYpKSB7XG4gICAgICAgIHRvLl9wZiA9IGdldFBhcnNpbmdGbGFncyhmcm9tKTtcbiAgICB9XG4gICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9sb2NhbGUpKSB7XG4gICAgICAgIHRvLl9sb2NhbGUgPSBmcm9tLl9sb2NhbGU7XG4gICAgfVxuXG4gICAgaWYgKG1vbWVudFByb3BlcnRpZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbW9tZW50UHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcHJvcCA9IG1vbWVudFByb3BlcnRpZXNbaV07XG4gICAgICAgICAgICB2YWwgPSBmcm9tW3Byb3BdO1xuICAgICAgICAgICAgaWYgKCFpc1VuZGVmaW5lZCh2YWwpKSB7XG4gICAgICAgICAgICAgICAgdG9bcHJvcF0gPSB2YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdG87XG59XG5cbnZhciB1cGRhdGVJblByb2dyZXNzID0gZmFsc2U7XG5cbi8vIE1vbWVudCBwcm90b3R5cGUgb2JqZWN0XG5mdW5jdGlvbiBNb21lbnQoY29uZmlnKSB7XG4gICAgY29weUNvbmZpZyh0aGlzLCBjb25maWcpO1xuICAgIHRoaXMuX2QgPSBuZXcgRGF0ZShjb25maWcuX2QgIT0gbnVsbCA/IGNvbmZpZy5fZC5nZXRUaW1lKCkgOiBOYU4pO1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgdGhpcy5fZCA9IG5ldyBEYXRlKE5hTik7XG4gICAgfVxuICAgIC8vIFByZXZlbnQgaW5maW5pdGUgbG9vcCBpbiBjYXNlIHVwZGF0ZU9mZnNldCBjcmVhdGVzIG5ldyBtb21lbnRcbiAgICAvLyBvYmplY3RzLlxuICAgIGlmICh1cGRhdGVJblByb2dyZXNzID09PSBmYWxzZSkge1xuICAgICAgICB1cGRhdGVJblByb2dyZXNzID0gdHJ1ZTtcbiAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KHRoaXMpO1xuICAgICAgICB1cGRhdGVJblByb2dyZXNzID0gZmFsc2U7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBpc01vbWVudCAob2JqKSB7XG4gICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIE1vbWVudCB8fCAob2JqICE9IG51bGwgJiYgb2JqLl9pc0FNb21lbnRPYmplY3QgIT0gbnVsbCk7XG59XG5cbmZ1bmN0aW9uIGFic0Zsb29yIChudW1iZXIpIHtcbiAgICBpZiAobnVtYmVyIDwgMCkge1xuICAgICAgICAvLyAtMCAtPiAwXG4gICAgICAgIHJldHVybiBNYXRoLmNlaWwobnVtYmVyKSB8fCAwO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKG51bWJlcik7XG4gICAgfVxufVxuXG5mdW5jdGlvbiB0b0ludChhcmd1bWVudEZvckNvZXJjaW9uKSB7XG4gICAgdmFyIGNvZXJjZWROdW1iZXIgPSArYXJndW1lbnRGb3JDb2VyY2lvbixcbiAgICAgICAgdmFsdWUgPSAwO1xuXG4gICAgaWYgKGNvZXJjZWROdW1iZXIgIT09IDAgJiYgaXNGaW5pdGUoY29lcmNlZE51bWJlcikpIHtcbiAgICAgICAgdmFsdWUgPSBhYnNGbG9vcihjb2VyY2VkTnVtYmVyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG59XG5cbi8vIGNvbXBhcmUgdHdvIGFycmF5cywgcmV0dXJuIHRoZSBudW1iZXIgb2YgZGlmZmVyZW5jZXNcbmZ1bmN0aW9uIGNvbXBhcmVBcnJheXMoYXJyYXkxLCBhcnJheTIsIGRvbnRDb252ZXJ0KSB7XG4gICAgdmFyIGxlbiA9IE1hdGgubWluKGFycmF5MS5sZW5ndGgsIGFycmF5Mi5sZW5ndGgpLFxuICAgICAgICBsZW5ndGhEaWZmID0gTWF0aC5hYnMoYXJyYXkxLmxlbmd0aCAtIGFycmF5Mi5sZW5ndGgpLFxuICAgICAgICBkaWZmcyA9IDAsXG4gICAgICAgIGk7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmICgoZG9udENvbnZlcnQgJiYgYXJyYXkxW2ldICE9PSBhcnJheTJbaV0pIHx8XG4gICAgICAgICAgICAoIWRvbnRDb252ZXJ0ICYmIHRvSW50KGFycmF5MVtpXSkgIT09IHRvSW50KGFycmF5MltpXSkpKSB7XG4gICAgICAgICAgICBkaWZmcysrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkaWZmcyArIGxlbmd0aERpZmY7XG59XG5cbmZ1bmN0aW9uIHdhcm4obXNnKSB7XG4gICAgaWYgKGhvb2tzLnN1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5ncyA9PT0gZmFsc2UgJiZcbiAgICAgICAgICAgICh0eXBlb2YgY29uc29sZSAhPT0gICd1bmRlZmluZWQnKSAmJiBjb25zb2xlLndhcm4pIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdEZXByZWNhdGlvbiB3YXJuaW5nOiAnICsgbXNnKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRlcHJlY2F0ZShtc2csIGZuKSB7XG4gICAgdmFyIGZpcnN0VGltZSA9IHRydWU7XG5cbiAgICByZXR1cm4gZXh0ZW5kKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGhvb2tzLmRlcHJlY2F0aW9uSGFuZGxlciAhPSBudWxsKSB7XG4gICAgICAgICAgICBob29rcy5kZXByZWNhdGlvbkhhbmRsZXIobnVsbCwgbXNnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmlyc3RUaW1lKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgdmFyIGFyZztcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYXJnID0gJyc7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbaV0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZyArPSAnXFxuWycgKyBpICsgJ10gJztcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGFyZ3VtZW50c1swXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJnICs9IGtleSArICc6ICcgKyBhcmd1bWVudHNbMF1ba2V5XSArICcsICc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYXJnID0gYXJnLnNsaWNlKDAsIC0yKTsgLy8gUmVtb3ZlIHRyYWlsaW5nIGNvbW1hIGFuZCBzcGFjZVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXJncy5wdXNoKGFyZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3YXJuKG1zZyArICdcXG5Bcmd1bWVudHM6ICcgKyBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzKS5qb2luKCcnKSArICdcXG4nICsgKG5ldyBFcnJvcigpKS5zdGFjayk7XG4gICAgICAgICAgICBmaXJzdFRpbWUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9LCBmbik7XG59XG5cbnZhciBkZXByZWNhdGlvbnMgPSB7fTtcblxuZnVuY3Rpb24gZGVwcmVjYXRlU2ltcGxlKG5hbWUsIG1zZykge1xuICAgIGlmIChob29rcy5kZXByZWNhdGlvbkhhbmRsZXIgIT0gbnVsbCkge1xuICAgICAgICBob29rcy5kZXByZWNhdGlvbkhhbmRsZXIobmFtZSwgbXNnKTtcbiAgICB9XG4gICAgaWYgKCFkZXByZWNhdGlvbnNbbmFtZV0pIHtcbiAgICAgICAgd2Fybihtc2cpO1xuICAgICAgICBkZXByZWNhdGlvbnNbbmFtZV0gPSB0cnVlO1xuICAgIH1cbn1cblxuaG9va3Muc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmdzID0gZmFsc2U7XG5ob29rcy5kZXByZWNhdGlvbkhhbmRsZXIgPSBudWxsO1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGlucHV0KSB7XG4gICAgcmV0dXJuIGlucHV0IGluc3RhbmNlb2YgRnVuY3Rpb24gfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbn1cblxuZnVuY3Rpb24gc2V0IChjb25maWcpIHtcbiAgICB2YXIgcHJvcCwgaTtcbiAgICBmb3IgKGkgaW4gY29uZmlnKSB7XG4gICAgICAgIHByb3AgPSBjb25maWdbaV07XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKHByb3ApKSB7XG4gICAgICAgICAgICB0aGlzW2ldID0gcHJvcDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXNbJ18nICsgaV0gPSBwcm9wO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRoaXMuX2NvbmZpZyA9IGNvbmZpZztcbiAgICAvLyBMZW5pZW50IG9yZGluYWwgcGFyc2luZyBhY2NlcHRzIGp1c3QgYSBudW1iZXIgaW4gYWRkaXRpb24gdG9cbiAgICAvLyBudW1iZXIgKyAocG9zc2libHkpIHN0dWZmIGNvbWluZyBmcm9tIF9kYXlPZk1vbnRoT3JkaW5hbFBhcnNlLlxuICAgIC8vIFRPRE86IFJlbW92ZSBcIm9yZGluYWxQYXJzZVwiIGZhbGxiYWNrIGluIG5leHQgbWFqb3IgcmVsZWFzZS5cbiAgICB0aGlzLl9kYXlPZk1vbnRoT3JkaW5hbFBhcnNlTGVuaWVudCA9IG5ldyBSZWdFeHAoXG4gICAgICAgICh0aGlzLl9kYXlPZk1vbnRoT3JkaW5hbFBhcnNlLnNvdXJjZSB8fCB0aGlzLl9vcmRpbmFsUGFyc2Uuc291cmNlKSArXG4gICAgICAgICAgICAnfCcgKyAoL1xcZHsxLDJ9Lykuc291cmNlKTtcbn1cblxuZnVuY3Rpb24gbWVyZ2VDb25maWdzKHBhcmVudENvbmZpZywgY2hpbGRDb25maWcpIHtcbiAgICB2YXIgcmVzID0gZXh0ZW5kKHt9LCBwYXJlbnRDb25maWcpLCBwcm9wO1xuICAgIGZvciAocHJvcCBpbiBjaGlsZENvbmZpZykge1xuICAgICAgICBpZiAoaGFzT3duUHJvcChjaGlsZENvbmZpZywgcHJvcCkpIHtcbiAgICAgICAgICAgIGlmIChpc09iamVjdChwYXJlbnRDb25maWdbcHJvcF0pICYmIGlzT2JqZWN0KGNoaWxkQ29uZmlnW3Byb3BdKSkge1xuICAgICAgICAgICAgICAgIHJlc1twcm9wXSA9IHt9O1xuICAgICAgICAgICAgICAgIGV4dGVuZChyZXNbcHJvcF0sIHBhcmVudENvbmZpZ1twcm9wXSk7XG4gICAgICAgICAgICAgICAgZXh0ZW5kKHJlc1twcm9wXSwgY2hpbGRDb25maWdbcHJvcF0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjaGlsZENvbmZpZ1twcm9wXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzW3Byb3BdID0gY2hpbGRDb25maWdbcHJvcF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSByZXNbcHJvcF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChwcm9wIGluIHBhcmVudENvbmZpZykge1xuICAgICAgICBpZiAoaGFzT3duUHJvcChwYXJlbnRDb25maWcsIHByb3ApICYmXG4gICAgICAgICAgICAgICAgIWhhc093blByb3AoY2hpbGRDb25maWcsIHByb3ApICYmXG4gICAgICAgICAgICAgICAgaXNPYmplY3QocGFyZW50Q29uZmlnW3Byb3BdKSkge1xuICAgICAgICAgICAgLy8gbWFrZSBzdXJlIGNoYW5nZXMgdG8gcHJvcGVydGllcyBkb24ndCBtb2RpZnkgcGFyZW50IGNvbmZpZ1xuICAgICAgICAgICAgcmVzW3Byb3BdID0gZXh0ZW5kKHt9LCByZXNbcHJvcF0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5cbmZ1bmN0aW9uIExvY2FsZShjb25maWcpIHtcbiAgICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy5zZXQoY29uZmlnKTtcbiAgICB9XG59XG5cbnZhciBrZXlzO1xuXG5pZiAoT2JqZWN0LmtleXMpIHtcbiAgICBrZXlzID0gT2JqZWN0LmtleXM7XG59IGVsc2Uge1xuICAgIGtleXMgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHZhciBpLCByZXMgPSBbXTtcbiAgICAgICAgZm9yIChpIGluIG9iaikge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3Aob2JqLCBpKSkge1xuICAgICAgICAgICAgICAgIHJlcy5wdXNoKGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbn1cblxudmFyIGRlZmF1bHRDYWxlbmRhciA9IHtcbiAgICBzYW1lRGF5IDogJ1tUb2RheSBhdF0gTFQnLFxuICAgIG5leHREYXkgOiAnW1RvbW9ycm93IGF0XSBMVCcsXG4gICAgbmV4dFdlZWsgOiAnZGRkZCBbYXRdIExUJyxcbiAgICBsYXN0RGF5IDogJ1tZZXN0ZXJkYXkgYXRdIExUJyxcbiAgICBsYXN0V2VlayA6ICdbTGFzdF0gZGRkZCBbYXRdIExUJyxcbiAgICBzYW1lRWxzZSA6ICdMJ1xufTtcblxuZnVuY3Rpb24gY2FsZW5kYXIgKGtleSwgbW9tLCBub3cpIHtcbiAgICB2YXIgb3V0cHV0ID0gdGhpcy5fY2FsZW5kYXJba2V5XSB8fCB0aGlzLl9jYWxlbmRhclsnc2FtZUVsc2UnXTtcbiAgICByZXR1cm4gaXNGdW5jdGlvbihvdXRwdXQpID8gb3V0cHV0LmNhbGwobW9tLCBub3cpIDogb3V0cHV0O1xufVxuXG52YXIgZGVmYXVsdExvbmdEYXRlRm9ybWF0ID0ge1xuICAgIExUUyAgOiAnaDptbTpzcyBBJyxcbiAgICBMVCAgIDogJ2g6bW0gQScsXG4gICAgTCAgICA6ICdNTS9ERC9ZWVlZJyxcbiAgICBMTCAgIDogJ01NTU0gRCwgWVlZWScsXG4gICAgTExMICA6ICdNTU1NIEQsIFlZWVkgaDptbSBBJyxcbiAgICBMTExMIDogJ2RkZGQsIE1NTU0gRCwgWVlZWSBoOm1tIEEnXG59O1xuXG5mdW5jdGlvbiBsb25nRGF0ZUZvcm1hdCAoa2V5KSB7XG4gICAgdmFyIGZvcm1hdCA9IHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleV0sXG4gICAgICAgIGZvcm1hdFVwcGVyID0gdGhpcy5fbG9uZ0RhdGVGb3JtYXRba2V5LnRvVXBwZXJDYXNlKCldO1xuXG4gICAgaWYgKGZvcm1hdCB8fCAhZm9ybWF0VXBwZXIpIHtcbiAgICAgICAgcmV0dXJuIGZvcm1hdDtcbiAgICB9XG5cbiAgICB0aGlzLl9sb25nRGF0ZUZvcm1hdFtrZXldID0gZm9ybWF0VXBwZXIucmVwbGFjZSgvTU1NTXxNTXxERHxkZGRkL2csIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgcmV0dXJuIHZhbC5zbGljZSgxKTtcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzLl9sb25nRGF0ZUZvcm1hdFtrZXldO1xufVxuXG52YXIgZGVmYXVsdEludmFsaWREYXRlID0gJ0ludmFsaWQgZGF0ZSc7XG5cbmZ1bmN0aW9uIGludmFsaWREYXRlICgpIHtcbiAgICByZXR1cm4gdGhpcy5faW52YWxpZERhdGU7XG59XG5cbnZhciBkZWZhdWx0T3JkaW5hbCA9ICclZCc7XG52YXIgZGVmYXVsdERheU9mTW9udGhPcmRpbmFsUGFyc2UgPSAvXFxkezEsMn0vO1xuXG5mdW5jdGlvbiBvcmRpbmFsIChudW1iZXIpIHtcbiAgICByZXR1cm4gdGhpcy5fb3JkaW5hbC5yZXBsYWNlKCclZCcsIG51bWJlcik7XG59XG5cbnZhciBkZWZhdWx0UmVsYXRpdmVUaW1lID0ge1xuICAgIGZ1dHVyZSA6ICdpbiAlcycsXG4gICAgcGFzdCAgIDogJyVzIGFnbycsXG4gICAgcyAgOiAnYSBmZXcgc2Vjb25kcycsXG4gICAgc3MgOiAnJWQgc2Vjb25kcycsXG4gICAgbSAgOiAnYSBtaW51dGUnLFxuICAgIG1tIDogJyVkIG1pbnV0ZXMnLFxuICAgIGggIDogJ2FuIGhvdXInLFxuICAgIGhoIDogJyVkIGhvdXJzJyxcbiAgICBkICA6ICdhIGRheScsXG4gICAgZGQgOiAnJWQgZGF5cycsXG4gICAgTSAgOiAnYSBtb250aCcsXG4gICAgTU0gOiAnJWQgbW9udGhzJyxcbiAgICB5ICA6ICdhIHllYXInLFxuICAgIHl5IDogJyVkIHllYXJzJ1xufTtcblxuZnVuY3Rpb24gcmVsYXRpdmVUaW1lIChudW1iZXIsIHdpdGhvdXRTdWZmaXgsIHN0cmluZywgaXNGdXR1cmUpIHtcbiAgICB2YXIgb3V0cHV0ID0gdGhpcy5fcmVsYXRpdmVUaW1lW3N0cmluZ107XG4gICAgcmV0dXJuIChpc0Z1bmN0aW9uKG91dHB1dCkpID9cbiAgICAgICAgb3V0cHV0KG51bWJlciwgd2l0aG91dFN1ZmZpeCwgc3RyaW5nLCBpc0Z1dHVyZSkgOlxuICAgICAgICBvdXRwdXQucmVwbGFjZSgvJWQvaSwgbnVtYmVyKTtcbn1cblxuZnVuY3Rpb24gcGFzdEZ1dHVyZSAoZGlmZiwgb3V0cHV0KSB7XG4gICAgdmFyIGZvcm1hdCA9IHRoaXMuX3JlbGF0aXZlVGltZVtkaWZmID4gMCA/ICdmdXR1cmUnIDogJ3Bhc3QnXTtcbiAgICByZXR1cm4gaXNGdW5jdGlvbihmb3JtYXQpID8gZm9ybWF0KG91dHB1dCkgOiBmb3JtYXQucmVwbGFjZSgvJXMvaSwgb3V0cHV0KTtcbn1cblxudmFyIGFsaWFzZXMgPSB7fTtcblxuZnVuY3Rpb24gYWRkVW5pdEFsaWFzICh1bml0LCBzaG9ydGhhbmQpIHtcbiAgICB2YXIgbG93ZXJDYXNlID0gdW5pdC50b0xvd2VyQ2FzZSgpO1xuICAgIGFsaWFzZXNbbG93ZXJDYXNlXSA9IGFsaWFzZXNbbG93ZXJDYXNlICsgJ3MnXSA9IGFsaWFzZXNbc2hvcnRoYW5kXSA9IHVuaXQ7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVVuaXRzKHVuaXRzKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB1bml0cyA9PT0gJ3N0cmluZycgPyBhbGlhc2VzW3VuaXRzXSB8fCBhbGlhc2VzW3VuaXRzLnRvTG93ZXJDYXNlKCldIDogdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVPYmplY3RVbml0cyhpbnB1dE9iamVjdCkge1xuICAgIHZhciBub3JtYWxpemVkSW5wdXQgPSB7fSxcbiAgICAgICAgbm9ybWFsaXplZFByb3AsXG4gICAgICAgIHByb3A7XG5cbiAgICBmb3IgKHByb3AgaW4gaW5wdXRPYmplY3QpIHtcbiAgICAgICAgaWYgKGhhc093blByb3AoaW5wdXRPYmplY3QsIHByb3ApKSB7XG4gICAgICAgICAgICBub3JtYWxpemVkUHJvcCA9IG5vcm1hbGl6ZVVuaXRzKHByb3ApO1xuICAgICAgICAgICAgaWYgKG5vcm1hbGl6ZWRQcm9wKSB7XG4gICAgICAgICAgICAgICAgbm9ybWFsaXplZElucHV0W25vcm1hbGl6ZWRQcm9wXSA9IGlucHV0T2JqZWN0W3Byb3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vcm1hbGl6ZWRJbnB1dDtcbn1cblxudmFyIHByaW9yaXRpZXMgPSB7fTtcblxuZnVuY3Rpb24gYWRkVW5pdFByaW9yaXR5KHVuaXQsIHByaW9yaXR5KSB7XG4gICAgcHJpb3JpdGllc1t1bml0XSA9IHByaW9yaXR5O1xufVxuXG5mdW5jdGlvbiBnZXRQcmlvcml0aXplZFVuaXRzKHVuaXRzT2JqKSB7XG4gICAgdmFyIHVuaXRzID0gW107XG4gICAgZm9yICh2YXIgdSBpbiB1bml0c09iaikge1xuICAgICAgICB1bml0cy5wdXNoKHt1bml0OiB1LCBwcmlvcml0eTogcHJpb3JpdGllc1t1XX0pO1xuICAgIH1cbiAgICB1bml0cy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBhLnByaW9yaXR5IC0gYi5wcmlvcml0eTtcbiAgICB9KTtcbiAgICByZXR1cm4gdW5pdHM7XG59XG5cbmZ1bmN0aW9uIHplcm9GaWxsKG51bWJlciwgdGFyZ2V0TGVuZ3RoLCBmb3JjZVNpZ24pIHtcbiAgICB2YXIgYWJzTnVtYmVyID0gJycgKyBNYXRoLmFicyhudW1iZXIpLFxuICAgICAgICB6ZXJvc1RvRmlsbCA9IHRhcmdldExlbmd0aCAtIGFic051bWJlci5sZW5ndGgsXG4gICAgICAgIHNpZ24gPSBudW1iZXIgPj0gMDtcbiAgICByZXR1cm4gKHNpZ24gPyAoZm9yY2VTaWduID8gJysnIDogJycpIDogJy0nKSArXG4gICAgICAgIE1hdGgucG93KDEwLCBNYXRoLm1heCgwLCB6ZXJvc1RvRmlsbCkpLnRvU3RyaW5nKCkuc3Vic3RyKDEpICsgYWJzTnVtYmVyO1xufVxuXG52YXIgZm9ybWF0dGluZ1Rva2VucyA9IC8oXFxbW15cXFtdKlxcXSl8KFxcXFwpPyhbSGhdbW0oc3MpP3xNb3xNTT9NP00/fERvfERERG98REQ/RD9EP3xkZGQ/ZD98ZG8/fHdbb3x3XT98V1tvfFddP3xRbz98WVlZWVlZfFlZWVlZfFlZWVl8WVl8Z2coZ2dnPyk/fEdHKEdHRz8pP3xlfEV8YXxBfGhoP3xISD98a2s/fG1tP3xzcz98U3sxLDl9fHh8WHx6ej98Wlo/fC4pL2c7XG5cbnZhciBsb2NhbEZvcm1hdHRpbmdUb2tlbnMgPSAvKFxcW1teXFxbXSpcXF0pfChcXFxcKT8oTFRTfExUfExMP0w/TD98bHsxLDR9KS9nO1xuXG52YXIgZm9ybWF0RnVuY3Rpb25zID0ge307XG5cbnZhciBmb3JtYXRUb2tlbkZ1bmN0aW9ucyA9IHt9O1xuXG4vLyB0b2tlbjogICAgJ00nXG4vLyBwYWRkZWQ6ICAgWydNTScsIDJdXG4vLyBvcmRpbmFsOiAgJ01vJ1xuLy8gY2FsbGJhY2s6IGZ1bmN0aW9uICgpIHsgdGhpcy5tb250aCgpICsgMSB9XG5mdW5jdGlvbiBhZGRGb3JtYXRUb2tlbiAodG9rZW4sIHBhZGRlZCwgb3JkaW5hbCwgY2FsbGJhY2spIHtcbiAgICB2YXIgZnVuYyA9IGNhbGxiYWNrO1xuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1tjYWxsYmFja10oKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHRva2VuKSB7XG4gICAgICAgIGZvcm1hdFRva2VuRnVuY3Rpb25zW3Rva2VuXSA9IGZ1bmM7XG4gICAgfVxuICAgIGlmIChwYWRkZWQpIHtcbiAgICAgICAgZm9ybWF0VG9rZW5GdW5jdGlvbnNbcGFkZGVkWzBdXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB6ZXJvRmlsbChmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIHBhZGRlZFsxXSwgcGFkZGVkWzJdKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKG9yZGluYWwpIHtcbiAgICAgICAgZm9ybWF0VG9rZW5GdW5jdGlvbnNbb3JkaW5hbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkub3JkaW5hbChmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIHRva2VuKTtcbiAgICAgICAgfTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUZvcm1hdHRpbmdUb2tlbnMoaW5wdXQpIHtcbiAgICBpZiAoaW5wdXQubWF0Y2goL1xcW1tcXHNcXFNdLykpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0LnJlcGxhY2UoL15cXFt8XFxdJC9nLCAnJyk7XG4gICAgfVxuICAgIHJldHVybiBpbnB1dC5yZXBsYWNlKC9cXFxcL2csICcnKTtcbn1cblxuZnVuY3Rpb24gbWFrZUZvcm1hdEZ1bmN0aW9uKGZvcm1hdCkge1xuICAgIHZhciBhcnJheSA9IGZvcm1hdC5tYXRjaChmb3JtYXR0aW5nVG9rZW5zKSwgaSwgbGVuZ3RoO1xuXG4gICAgZm9yIChpID0gMCwgbGVuZ3RoID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGZvcm1hdFRva2VuRnVuY3Rpb25zW2FycmF5W2ldXSkge1xuICAgICAgICAgICAgYXJyYXlbaV0gPSBmb3JtYXRUb2tlbkZ1bmN0aW9uc1thcnJheVtpXV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhcnJheVtpXSA9IHJlbW92ZUZvcm1hdHRpbmdUb2tlbnMoYXJyYXlbaV0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChtb20pIHtcbiAgICAgICAgdmFyIG91dHB1dCA9ICcnLCBpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIG91dHB1dCArPSBpc0Z1bmN0aW9uKGFycmF5W2ldKSA/IGFycmF5W2ldLmNhbGwobW9tLCBmb3JtYXQpIDogYXJyYXlbaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9O1xufVxuXG4vLyBmb3JtYXQgZGF0ZSB1c2luZyBuYXRpdmUgZGF0ZSBvYmplY3RcbmZ1bmN0aW9uIGZvcm1hdE1vbWVudChtLCBmb3JtYXQpIHtcbiAgICBpZiAoIW0uaXNWYWxpZCgpKSB7XG4gICAgICAgIHJldHVybiBtLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xuICAgIH1cblxuICAgIGZvcm1hdCA9IGV4cGFuZEZvcm1hdChmb3JtYXQsIG0ubG9jYWxlRGF0YSgpKTtcbiAgICBmb3JtYXRGdW5jdGlvbnNbZm9ybWF0XSA9IGZvcm1hdEZ1bmN0aW9uc1tmb3JtYXRdIHx8IG1ha2VGb3JtYXRGdW5jdGlvbihmb3JtYXQpO1xuXG4gICAgcmV0dXJuIGZvcm1hdEZ1bmN0aW9uc1tmb3JtYXRdKG0pO1xufVxuXG5mdW5jdGlvbiBleHBhbmRGb3JtYXQoZm9ybWF0LCBsb2NhbGUpIHtcbiAgICB2YXIgaSA9IDU7XG5cbiAgICBmdW5jdGlvbiByZXBsYWNlTG9uZ0RhdGVGb3JtYXRUb2tlbnMoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS5sb25nRGF0ZUZvcm1hdChpbnB1dCkgfHwgaW5wdXQ7XG4gICAgfVxuXG4gICAgbG9jYWxGb3JtYXR0aW5nVG9rZW5zLmxhc3RJbmRleCA9IDA7XG4gICAgd2hpbGUgKGkgPj0gMCAmJiBsb2NhbEZvcm1hdHRpbmdUb2tlbnMudGVzdChmb3JtYXQpKSB7XG4gICAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKGxvY2FsRm9ybWF0dGluZ1Rva2VucywgcmVwbGFjZUxvbmdEYXRlRm9ybWF0VG9rZW5zKTtcbiAgICAgICAgbG9jYWxGb3JtYXR0aW5nVG9rZW5zLmxhc3RJbmRleCA9IDA7XG4gICAgICAgIGkgLT0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gZm9ybWF0O1xufVxuXG52YXIgbWF0Y2gxICAgICAgICAgPSAvXFxkLzsgICAgICAgICAgICAvLyAgICAgICAwIC0gOVxudmFyIG1hdGNoMiAgICAgICAgID0gL1xcZFxcZC87ICAgICAgICAgIC8vICAgICAgMDAgLSA5OVxudmFyIG1hdGNoMyAgICAgICAgID0gL1xcZHszfS87ICAgICAgICAgLy8gICAgIDAwMCAtIDk5OVxudmFyIG1hdGNoNCAgICAgICAgID0gL1xcZHs0fS87ICAgICAgICAgLy8gICAgMDAwMCAtIDk5OTlcbnZhciBtYXRjaDYgICAgICAgICA9IC9bKy1dP1xcZHs2fS87ICAgIC8vIC05OTk5OTkgLSA5OTk5OTlcbnZhciBtYXRjaDF0bzIgICAgICA9IC9cXGRcXGQ/LzsgICAgICAgICAvLyAgICAgICAwIC0gOTlcbnZhciBtYXRjaDN0bzQgICAgICA9IC9cXGRcXGRcXGRcXGQ/LzsgICAgIC8vICAgICA5OTkgLSA5OTk5XG52YXIgbWF0Y2g1dG82ICAgICAgPSAvXFxkXFxkXFxkXFxkXFxkXFxkPy87IC8vICAgOTk5OTkgLSA5OTk5OTlcbnZhciBtYXRjaDF0bzMgICAgICA9IC9cXGR7MSwzfS87ICAgICAgIC8vICAgICAgIDAgLSA5OTlcbnZhciBtYXRjaDF0bzQgICAgICA9IC9cXGR7MSw0fS87ICAgICAgIC8vICAgICAgIDAgLSA5OTk5XG52YXIgbWF0Y2gxdG82ICAgICAgPSAvWystXT9cXGR7MSw2fS87ICAvLyAtOTk5OTk5IC0gOTk5OTk5XG5cbnZhciBtYXRjaFVuc2lnbmVkICA9IC9cXGQrLzsgICAgICAgICAgIC8vICAgICAgIDAgLSBpbmZcbnZhciBtYXRjaFNpZ25lZCAgICA9IC9bKy1dP1xcZCsvOyAgICAgIC8vICAgIC1pbmYgLSBpbmZcblxudmFyIG1hdGNoT2Zmc2V0ICAgID0gL1p8WystXVxcZFxcZDo/XFxkXFxkL2dpOyAvLyArMDA6MDAgLTAwOjAwICswMDAwIC0wMDAwIG9yIFpcbnZhciBtYXRjaFNob3J0T2Zmc2V0ID0gL1p8WystXVxcZFxcZCg/Ojo/XFxkXFxkKT8vZ2k7IC8vICswMCAtMDAgKzAwOjAwIC0wMDowMCArMDAwMCAtMDAwMCBvciBaXG5cbnZhciBtYXRjaFRpbWVzdGFtcCA9IC9bKy1dP1xcZCsoXFwuXFxkezEsM30pPy87IC8vIDEyMzQ1Njc4OSAxMjM0NTY3ODkuMTIzXG5cbi8vIGFueSB3b3JkIChvciB0d28pIGNoYXJhY3RlcnMgb3IgbnVtYmVycyBpbmNsdWRpbmcgdHdvL3RocmVlIHdvcmQgbW9udGggaW4gYXJhYmljLlxuLy8gaW5jbHVkZXMgc2NvdHRpc2ggZ2FlbGljIHR3byB3b3JkIGFuZCBoeXBoZW5hdGVkIG1vbnRoc1xudmFyIG1hdGNoV29yZCA9IC9bMC05XXswLDI1Nn1bJ2EtelxcdTAwQTAtXFx1MDVGRlxcdTA3MDAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkYwN1xcdUZGMTAtXFx1RkZFRl17MSwyNTZ9fFtcXHUwNjAwLVxcdTA2RkZcXC9dezEsMjU2fShcXHMqP1tcXHUwNjAwLVxcdTA2RkZdezEsMjU2fSl7MSwyfS9pO1xuXG5cbnZhciByZWdleGVzID0ge307XG5cbmZ1bmN0aW9uIGFkZFJlZ2V4VG9rZW4gKHRva2VuLCByZWdleCwgc3RyaWN0UmVnZXgpIHtcbiAgICByZWdleGVzW3Rva2VuXSA9IGlzRnVuY3Rpb24ocmVnZXgpID8gcmVnZXggOiBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZURhdGEpIHtcbiAgICAgICAgcmV0dXJuIChpc1N0cmljdCAmJiBzdHJpY3RSZWdleCkgPyBzdHJpY3RSZWdleCA6IHJlZ2V4O1xuICAgIH07XG59XG5cbmZ1bmN0aW9uIGdldFBhcnNlUmVnZXhGb3JUb2tlbiAodG9rZW4sIGNvbmZpZykge1xuICAgIGlmICghaGFzT3duUHJvcChyZWdleGVzLCB0b2tlbikpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAodW5lc2NhcGVGb3JtYXQodG9rZW4pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVnZXhlc1t0b2tlbl0oY29uZmlnLl9zdHJpY3QsIGNvbmZpZy5fbG9jYWxlKTtcbn1cblxuLy8gQ29kZSBmcm9tIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzU2MTQ5My9pcy10aGVyZS1hLXJlZ2V4cC1lc2NhcGUtZnVuY3Rpb24taW4tamF2YXNjcmlwdFxuZnVuY3Rpb24gdW5lc2NhcGVGb3JtYXQocykge1xuICAgIHJldHVybiByZWdleEVzY2FwZShzLnJlcGxhY2UoJ1xcXFwnLCAnJykucmVwbGFjZSgvXFxcXChcXFspfFxcXFwoXFxdKXxcXFsoW15cXF1cXFtdKilcXF18XFxcXCguKS9nLCBmdW5jdGlvbiAobWF0Y2hlZCwgcDEsIHAyLCBwMywgcDQpIHtcbiAgICAgICAgcmV0dXJuIHAxIHx8IHAyIHx8IHAzIHx8IHA0O1xuICAgIH0pKTtcbn1cblxuZnVuY3Rpb24gcmVnZXhFc2NhcGUocykge1xuICAgIHJldHVybiBzLnJlcGxhY2UoL1stXFwvXFxcXF4kKis/LigpfFtcXF17fV0vZywgJ1xcXFwkJicpO1xufVxuXG52YXIgdG9rZW5zID0ge307XG5cbmZ1bmN0aW9uIGFkZFBhcnNlVG9rZW4gKHRva2VuLCBjYWxsYmFjaykge1xuICAgIHZhciBpLCBmdW5jID0gY2FsbGJhY2s7XG4gICAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdG9rZW4gPSBbdG9rZW5dO1xuICAgIH1cbiAgICBpZiAoaXNOdW1iZXIoY2FsbGJhY2spKSB7XG4gICAgICAgIGZ1bmMgPSBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgICAgICBhcnJheVtjYWxsYmFja10gPSB0b0ludChpbnB1dCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCB0b2tlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICB0b2tlbnNbdG9rZW5baV1dID0gZnVuYztcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGFkZFdlZWtQYXJzZVRva2VuICh0b2tlbiwgY2FsbGJhY2spIHtcbiAgICBhZGRQYXJzZVRva2VuKHRva2VuLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgIGNvbmZpZy5fdyA9IGNvbmZpZy5fdyB8fCB7fTtcbiAgICAgICAgY2FsbGJhY2soaW5wdXQsIGNvbmZpZy5fdywgY29uZmlnLCB0b2tlbik7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGFkZFRpbWVUb0FycmF5RnJvbVRva2VuKHRva2VuLCBpbnB1dCwgY29uZmlnKSB7XG4gICAgaWYgKGlucHV0ICE9IG51bGwgJiYgaGFzT3duUHJvcCh0b2tlbnMsIHRva2VuKSkge1xuICAgICAgICB0b2tlbnNbdG9rZW5dKGlucHV0LCBjb25maWcuX2EsIGNvbmZpZywgdG9rZW4pO1xuICAgIH1cbn1cblxudmFyIFlFQVIgPSAwO1xudmFyIE1PTlRIID0gMTtcbnZhciBEQVRFID0gMjtcbnZhciBIT1VSID0gMztcbnZhciBNSU5VVEUgPSA0O1xudmFyIFNFQ09ORCA9IDU7XG52YXIgTUlMTElTRUNPTkQgPSA2O1xudmFyIFdFRUsgPSA3O1xudmFyIFdFRUtEQVkgPSA4O1xuXG4vLyBGT1JNQVRUSU5HXG5cbmFkZEZvcm1hdFRva2VuKCdZJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciB5ID0gdGhpcy55ZWFyKCk7XG4gICAgcmV0dXJuIHkgPD0gOTk5OSA/ICcnICsgeSA6ICcrJyArIHk7XG59KTtcblxuYWRkRm9ybWF0VG9rZW4oMCwgWydZWScsIDJdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMueWVhcigpICUgMTAwO1xufSk7XG5cbmFkZEZvcm1hdFRva2VuKDAsIFsnWVlZWScsICAgNF0sICAgICAgIDAsICd5ZWFyJyk7XG5hZGRGb3JtYXRUb2tlbigwLCBbJ1lZWVlZJywgIDVdLCAgICAgICAwLCAneWVhcicpO1xuYWRkRm9ybWF0VG9rZW4oMCwgWydZWVlZWVknLCA2LCB0cnVlXSwgMCwgJ3llYXInKTtcblxuLy8gQUxJQVNFU1xuXG5hZGRVbml0QWxpYXMoJ3llYXInLCAneScpO1xuXG4vLyBQUklPUklUSUVTXG5cbmFkZFVuaXRQcmlvcml0eSgneWVhcicsIDEpO1xuXG4vLyBQQVJTSU5HXG5cbmFkZFJlZ2V4VG9rZW4oJ1knLCAgICAgIG1hdGNoU2lnbmVkKTtcbmFkZFJlZ2V4VG9rZW4oJ1lZJywgICAgIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbmFkZFJlZ2V4VG9rZW4oJ1lZWVknLCAgIG1hdGNoMXRvNCwgbWF0Y2g0KTtcbmFkZFJlZ2V4VG9rZW4oJ1lZWVlZJywgIG1hdGNoMXRvNiwgbWF0Y2g2KTtcbmFkZFJlZ2V4VG9rZW4oJ1lZWVlZWScsIG1hdGNoMXRvNiwgbWF0Y2g2KTtcblxuYWRkUGFyc2VUb2tlbihbJ1lZWVlZJywgJ1lZWVlZWSddLCBZRUFSKTtcbmFkZFBhcnNlVG9rZW4oJ1lZWVknLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgYXJyYXlbWUVBUl0gPSBpbnB1dC5sZW5ndGggPT09IDIgPyBob29rcy5wYXJzZVR3b0RpZ2l0WWVhcihpbnB1dCkgOiB0b0ludChpbnB1dCk7XG59KTtcbmFkZFBhcnNlVG9rZW4oJ1lZJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgIGFycmF5W1lFQVJdID0gaG9va3MucGFyc2VUd29EaWdpdFllYXIoaW5wdXQpO1xufSk7XG5hZGRQYXJzZVRva2VuKCdZJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgIGFycmF5W1lFQVJdID0gcGFyc2VJbnQoaW5wdXQsIDEwKTtcbn0pO1xuXG4vLyBIRUxQRVJTXG5cbmZ1bmN0aW9uIGRheXNJblllYXIoeWVhcikge1xuICAgIHJldHVybiBpc0xlYXBZZWFyKHllYXIpID8gMzY2IDogMzY1O1xufVxuXG5mdW5jdGlvbiBpc0xlYXBZZWFyKHllYXIpIHtcbiAgICByZXR1cm4gKHllYXIgJSA0ID09PSAwICYmIHllYXIgJSAxMDAgIT09IDApIHx8IHllYXIgJSA0MDAgPT09IDA7XG59XG5cbi8vIEhPT0tTXG5cbmhvb2tzLnBhcnNlVHdvRGlnaXRZZWFyID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgcmV0dXJuIHRvSW50KGlucHV0KSArICh0b0ludChpbnB1dCkgPiA2OCA/IDE5MDAgOiAyMDAwKTtcbn07XG5cbi8vIE1PTUVOVFNcblxudmFyIGdldFNldFllYXIgPSBtYWtlR2V0U2V0KCdGdWxsWWVhcicsIHRydWUpO1xuXG5mdW5jdGlvbiBnZXRJc0xlYXBZZWFyICgpIHtcbiAgICByZXR1cm4gaXNMZWFwWWVhcih0aGlzLnllYXIoKSk7XG59XG5cbmZ1bmN0aW9uIG1ha2VHZXRTZXQgKHVuaXQsIGtlZXBUaW1lKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgc2V0JDEodGhpcywgdW5pdCwgdmFsdWUpO1xuICAgICAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KHRoaXMsIGtlZXBUaW1lKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGdldCh0aGlzLCB1bml0KTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbmZ1bmN0aW9uIGdldCAobW9tLCB1bml0KSB7XG4gICAgcmV0dXJuIG1vbS5pc1ZhbGlkKCkgP1xuICAgICAgICBtb20uX2RbJ2dldCcgKyAobW9tLl9pc1VUQyA/ICdVVEMnIDogJycpICsgdW5pdF0oKSA6IE5hTjtcbn1cblxuZnVuY3Rpb24gc2V0JDEgKG1vbSwgdW5pdCwgdmFsdWUpIHtcbiAgICBpZiAobW9tLmlzVmFsaWQoKSAmJiAhaXNOYU4odmFsdWUpKSB7XG4gICAgICAgIGlmICh1bml0ID09PSAnRnVsbFllYXInICYmIGlzTGVhcFllYXIobW9tLnllYXIoKSkgJiYgbW9tLm1vbnRoKCkgPT09IDEgJiYgbW9tLmRhdGUoKSA9PT0gMjkpIHtcbiAgICAgICAgICAgIG1vbS5fZFsnc2V0JyArIChtb20uX2lzVVRDID8gJ1VUQycgOiAnJykgKyB1bml0XSh2YWx1ZSwgbW9tLm1vbnRoKCksIGRheXNJbk1vbnRoKHZhbHVlLCBtb20ubW9udGgoKSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbW9tLl9kWydzZXQnICsgKG1vbS5faXNVVEMgPyAnVVRDJyA6ICcnKSArIHVuaXRdKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLy8gTU9NRU5UU1xuXG5mdW5jdGlvbiBzdHJpbmdHZXQgKHVuaXRzKSB7XG4gICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgaWYgKGlzRnVuY3Rpb24odGhpc1t1bml0c10pKSB7XG4gICAgICAgIHJldHVybiB0aGlzW3VuaXRzXSgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn1cblxuXG5mdW5jdGlvbiBzdHJpbmdTZXQgKHVuaXRzLCB2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdW5pdHMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplT2JqZWN0VW5pdHModW5pdHMpO1xuICAgICAgICB2YXIgcHJpb3JpdGl6ZWQgPSBnZXRQcmlvcml0aXplZFVuaXRzKHVuaXRzKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmlvcml0aXplZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpc1twcmlvcml0aXplZFtpXS51bml0XSh1bml0c1twcmlvcml0aXplZFtpXS51bml0XSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24odGhpc1t1bml0c10pKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1t1bml0c10odmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufVxuXG5mdW5jdGlvbiBtb2QobiwgeCkge1xuICAgIHJldHVybiAoKG4gJSB4KSArIHgpICUgeDtcbn1cblxudmFyIGluZGV4T2Y7XG5cbmlmIChBcnJheS5wcm90b3R5cGUuaW5kZXhPZikge1xuICAgIGluZGV4T2YgPSBBcnJheS5wcm90b3R5cGUuaW5kZXhPZjtcbn0gZWxzZSB7XG4gICAgaW5kZXhPZiA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIC8vIEkga25vd1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmICh0aGlzW2ldID09PSBvKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH07XG59XG5cbmZ1bmN0aW9uIGRheXNJbk1vbnRoKHllYXIsIG1vbnRoKSB7XG4gICAgaWYgKGlzTmFOKHllYXIpIHx8IGlzTmFOKG1vbnRoKSkge1xuICAgICAgICByZXR1cm4gTmFOO1xuICAgIH1cbiAgICB2YXIgbW9kTW9udGggPSBtb2QobW9udGgsIDEyKTtcbiAgICB5ZWFyICs9IChtb250aCAtIG1vZE1vbnRoKSAvIDEyO1xuICAgIHJldHVybiBtb2RNb250aCA9PT0gMSA/IChpc0xlYXBZZWFyKHllYXIpID8gMjkgOiAyOCkgOiAoMzEgLSBtb2RNb250aCAlIDcgJSAyKTtcbn1cblxuLy8gRk9STUFUVElOR1xuXG5hZGRGb3JtYXRUb2tlbignTScsIFsnTU0nLCAyXSwgJ01vJywgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLm1vbnRoKCkgKyAxO1xufSk7XG5cbmFkZEZvcm1hdFRva2VuKCdNTU0nLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm1vbnRoc1Nob3J0KHRoaXMsIGZvcm1hdCk7XG59KTtcblxuYWRkRm9ybWF0VG9rZW4oJ01NTU0nLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm1vbnRocyh0aGlzLCBmb3JtYXQpO1xufSk7XG5cbi8vIEFMSUFTRVNcblxuYWRkVW5pdEFsaWFzKCdtb250aCcsICdNJyk7XG5cbi8vIFBSSU9SSVRZXG5cbmFkZFVuaXRQcmlvcml0eSgnbW9udGgnLCA4KTtcblxuLy8gUEFSU0lOR1xuXG5hZGRSZWdleFRva2VuKCdNJywgICAgbWF0Y2gxdG8yKTtcbmFkZFJlZ2V4VG9rZW4oJ01NJywgICBtYXRjaDF0bzIsIG1hdGNoMik7XG5hZGRSZWdleFRva2VuKCdNTU0nLCAgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICByZXR1cm4gbG9jYWxlLm1vbnRoc1Nob3J0UmVnZXgoaXNTdHJpY3QpO1xufSk7XG5hZGRSZWdleFRva2VuKCdNTU1NJywgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICByZXR1cm4gbG9jYWxlLm1vbnRoc1JlZ2V4KGlzU3RyaWN0KTtcbn0pO1xuXG5hZGRQYXJzZVRva2VuKFsnTScsICdNTSddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgYXJyYXlbTU9OVEhdID0gdG9JbnQoaW5wdXQpIC0gMTtcbn0pO1xuXG5hZGRQYXJzZVRva2VuKFsnTU1NJywgJ01NTU0nXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnLCB0b2tlbikge1xuICAgIHZhciBtb250aCA9IGNvbmZpZy5fbG9jYWxlLm1vbnRoc1BhcnNlKGlucHV0LCB0b2tlbiwgY29uZmlnLl9zdHJpY3QpO1xuICAgIC8vIGlmIHdlIGRpZG4ndCBmaW5kIGEgbW9udGggbmFtZSwgbWFyayB0aGUgZGF0ZSBhcyBpbnZhbGlkLlxuICAgIGlmIChtb250aCAhPSBudWxsKSB7XG4gICAgICAgIGFycmF5W01PTlRIXSA9IG1vbnRoO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmludmFsaWRNb250aCA9IGlucHV0O1xuICAgIH1cbn0pO1xuXG4vLyBMT0NBTEVTXG5cbnZhciBNT05USFNfSU5fRk9STUFUID0gL0Rbb0RdPyhcXFtbXlxcW1xcXV0qXFxdfFxccykrTU1NTT8vO1xudmFyIGRlZmF1bHRMb2NhbGVNb250aHMgPSAnSmFudWFyeV9GZWJydWFyeV9NYXJjaF9BcHJpbF9NYXlfSnVuZV9KdWx5X0F1Z3VzdF9TZXB0ZW1iZXJfT2N0b2Jlcl9Ob3ZlbWJlcl9EZWNlbWJlcicuc3BsaXQoJ18nKTtcbmZ1bmN0aW9uIGxvY2FsZU1vbnRocyAobSwgZm9ybWF0KSB7XG4gICAgaWYgKCFtKSB7XG4gICAgICAgIHJldHVybiBpc0FycmF5KHRoaXMuX21vbnRocykgPyB0aGlzLl9tb250aHMgOlxuICAgICAgICAgICAgdGhpcy5fbW9udGhzWydzdGFuZGFsb25lJ107XG4gICAgfVxuICAgIHJldHVybiBpc0FycmF5KHRoaXMuX21vbnRocykgPyB0aGlzLl9tb250aHNbbS5tb250aCgpXSA6XG4gICAgICAgIHRoaXMuX21vbnRoc1sodGhpcy5fbW9udGhzLmlzRm9ybWF0IHx8IE1PTlRIU19JTl9GT1JNQVQpLnRlc3QoZm9ybWF0KSA/ICdmb3JtYXQnIDogJ3N0YW5kYWxvbmUnXVttLm1vbnRoKCldO1xufVxuXG52YXIgZGVmYXVsdExvY2FsZU1vbnRoc1Nob3J0ID0gJ0phbl9GZWJfTWFyX0Fwcl9NYXlfSnVuX0p1bF9BdWdfU2VwX09jdF9Ob3ZfRGVjJy5zcGxpdCgnXycpO1xuZnVuY3Rpb24gbG9jYWxlTW9udGhzU2hvcnQgKG0sIGZvcm1hdCkge1xuICAgIGlmICghbSkge1xuICAgICAgICByZXR1cm4gaXNBcnJheSh0aGlzLl9tb250aHNTaG9ydCkgPyB0aGlzLl9tb250aHNTaG9ydCA6XG4gICAgICAgICAgICB0aGlzLl9tb250aHNTaG9ydFsnc3RhbmRhbG9uZSddO1xuICAgIH1cbiAgICByZXR1cm4gaXNBcnJheSh0aGlzLl9tb250aHNTaG9ydCkgPyB0aGlzLl9tb250aHNTaG9ydFttLm1vbnRoKCldIDpcbiAgICAgICAgdGhpcy5fbW9udGhzU2hvcnRbTU9OVEhTX0lOX0ZPUk1BVC50ZXN0KGZvcm1hdCkgPyAnZm9ybWF0JyA6ICdzdGFuZGFsb25lJ11bbS5tb250aCgpXTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlU3RyaWN0UGFyc2UobW9udGhOYW1lLCBmb3JtYXQsIHN0cmljdCkge1xuICAgIHZhciBpLCBpaSwgbW9tLCBsbGMgPSBtb250aE5hbWUudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICBpZiAoIXRoaXMuX21vbnRoc1BhcnNlKSB7XG4gICAgICAgIC8vIHRoaXMgaXMgbm90IHVzZWRcbiAgICAgICAgdGhpcy5fbW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgdGhpcy5fbG9uZ01vbnRoc1BhcnNlID0gW107XG4gICAgICAgIHRoaXMuX3Nob3J0TW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDEyOyArK2kpIHtcbiAgICAgICAgICAgIG1vbSA9IGNyZWF0ZVVUQyhbMjAwMCwgaV0pO1xuICAgICAgICAgICAgdGhpcy5fc2hvcnRNb250aHNQYXJzZVtpXSA9IHRoaXMubW9udGhzU2hvcnQobW9tLCAnJykudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgICAgIHRoaXMuX2xvbmdNb250aHNQYXJzZVtpXSA9IHRoaXMubW9udGhzKG1vbSwgJycpLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc3RyaWN0KSB7XG4gICAgICAgIGlmIChmb3JtYXQgPT09ICdNTU0nKSB7XG4gICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydE1vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX2xvbmdNb250aHNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZm9ybWF0ID09PSAnTU1NJykge1xuICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRNb250aHNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9sb25nTW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbG9uZ01vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0TW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBsb2NhbGVNb250aHNQYXJzZSAobW9udGhOYW1lLCBmb3JtYXQsIHN0cmljdCkge1xuICAgIHZhciBpLCBtb20sIHJlZ2V4O1xuXG4gICAgaWYgKHRoaXMuX21vbnRoc1BhcnNlRXhhY3QpIHtcbiAgICAgICAgcmV0dXJuIGhhbmRsZVN0cmljdFBhcnNlLmNhbGwodGhpcywgbW9udGhOYW1lLCBmb3JtYXQsIHN0cmljdCk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9tb250aHNQYXJzZSkge1xuICAgICAgICB0aGlzLl9tb250aHNQYXJzZSA9IFtdO1xuICAgICAgICB0aGlzLl9sb25nTW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgdGhpcy5fc2hvcnRNb250aHNQYXJzZSA9IFtdO1xuICAgIH1cblxuICAgIC8vIFRPRE86IGFkZCBzb3J0aW5nXG4gICAgLy8gU29ydGluZyBtYWtlcyBzdXJlIGlmIG9uZSBtb250aCAob3IgYWJicikgaXMgYSBwcmVmaXggb2YgYW5vdGhlclxuICAgIC8vIHNlZSBzb3J0aW5nIGluIGNvbXB1dGVNb250aHNQYXJzZVxuICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgIC8vIG1ha2UgdGhlIHJlZ2V4IGlmIHdlIGRvbid0IGhhdmUgaXQgYWxyZWFkeVxuICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIGldKTtcbiAgICAgICAgaWYgKHN0cmljdCAmJiAhdGhpcy5fbG9uZ01vbnRoc1BhcnNlW2ldKSB7XG4gICAgICAgICAgICB0aGlzLl9sb25nTW9udGhzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKCdeJyArIHRoaXMubW9udGhzKG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnJykgKyAnJCcsICdpJyk7XG4gICAgICAgICAgICB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlW2ldID0gbmV3IFJlZ0V4cCgnXicgKyB0aGlzLm1vbnRoc1Nob3J0KG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnJykgKyAnJCcsICdpJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzdHJpY3QgJiYgIXRoaXMuX21vbnRoc1BhcnNlW2ldKSB7XG4gICAgICAgICAgICByZWdleCA9ICdeJyArIHRoaXMubW9udGhzKG1vbSwgJycpICsgJ3xeJyArIHRoaXMubW9udGhzU2hvcnQobW9tLCAnJyk7XG4gICAgICAgICAgICB0aGlzLl9tb250aHNQYXJzZVtpXSA9IG5ldyBSZWdFeHAocmVnZXgucmVwbGFjZSgnLicsICcnKSwgJ2knKTtcbiAgICAgICAgfVxuICAgICAgICAvLyB0ZXN0IHRoZSByZWdleFxuICAgICAgICBpZiAoc3RyaWN0ICYmIGZvcm1hdCA9PT0gJ01NTU0nICYmIHRoaXMuX2xvbmdNb250aHNQYXJzZVtpXS50ZXN0KG1vbnRoTmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9IGVsc2UgaWYgKHN0cmljdCAmJiBmb3JtYXQgPT09ICdNTU0nICYmIHRoaXMuX3Nob3J0TW9udGhzUGFyc2VbaV0udGVzdChtb250aE5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfSBlbHNlIGlmICghc3RyaWN0ICYmIHRoaXMuX21vbnRoc1BhcnNlW2ldLnRlc3QobW9udGhOYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8vIE1PTUVOVFNcblxuZnVuY3Rpb24gc2V0TW9udGggKG1vbSwgdmFsdWUpIHtcbiAgICB2YXIgZGF5T2ZNb250aDtcblxuICAgIGlmICghbW9tLmlzVmFsaWQoKSkge1xuICAgICAgICAvLyBObyBvcFxuICAgICAgICByZXR1cm4gbW9tO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICgvXlxcZCskLy50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgdmFsdWUgPSB0b0ludCh2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSA9IG1vbS5sb2NhbGVEYXRhKCkubW9udGhzUGFyc2UodmFsdWUpO1xuICAgICAgICAgICAgLy8gVE9ETzogQW5vdGhlciBzaWxlbnQgZmFpbHVyZT9cbiAgICAgICAgICAgIGlmICghaXNOdW1iZXIodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1vbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRheU9mTW9udGggPSBNYXRoLm1pbihtb20uZGF0ZSgpLCBkYXlzSW5Nb250aChtb20ueWVhcigpLCB2YWx1ZSkpO1xuICAgIG1vbS5fZFsnc2V0JyArIChtb20uX2lzVVRDID8gJ1VUQycgOiAnJykgKyAnTW9udGgnXSh2YWx1ZSwgZGF5T2ZNb250aCk7XG4gICAgcmV0dXJuIG1vbTtcbn1cblxuZnVuY3Rpb24gZ2V0U2V0TW9udGggKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgc2V0TW9udGgodGhpcywgdmFsdWUpO1xuICAgICAgICBob29rcy51cGRhdGVPZmZzZXQodGhpcywgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBnZXQodGhpcywgJ01vbnRoJyk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBnZXREYXlzSW5Nb250aCAoKSB7XG4gICAgcmV0dXJuIGRheXNJbk1vbnRoKHRoaXMueWVhcigpLCB0aGlzLm1vbnRoKCkpO1xufVxuXG52YXIgZGVmYXVsdE1vbnRoc1Nob3J0UmVnZXggPSBtYXRjaFdvcmQ7XG5mdW5jdGlvbiBtb250aHNTaG9ydFJlZ2V4IChpc1N0cmljdCkge1xuICAgIGlmICh0aGlzLl9tb250aHNQYXJzZUV4YWN0KSB7XG4gICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX21vbnRoc1JlZ2V4JykpIHtcbiAgICAgICAgICAgIGNvbXB1dGVNb250aHNQYXJzZS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1N0cmljdCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1Nob3J0U3RyaWN0UmVnZXg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU2hvcnRSZWdleDtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX21vbnRoc1Nob3J0UmVnZXgnKSkge1xuICAgICAgICAgICAgdGhpcy5fbW9udGhzU2hvcnRSZWdleCA9IGRlZmF1bHRNb250aHNTaG9ydFJlZ2V4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9tb250aHNTaG9ydFN0cmljdFJlZ2V4ICYmIGlzU3RyaWN0ID9cbiAgICAgICAgICAgIHRoaXMuX21vbnRoc1Nob3J0U3RyaWN0UmVnZXggOiB0aGlzLl9tb250aHNTaG9ydFJlZ2V4O1xuICAgIH1cbn1cblxudmFyIGRlZmF1bHRNb250aHNSZWdleCA9IG1hdGNoV29yZDtcbmZ1bmN0aW9uIG1vbnRoc1JlZ2V4IChpc1N0cmljdCkge1xuICAgIGlmICh0aGlzLl9tb250aHNQYXJzZUV4YWN0KSB7XG4gICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX21vbnRoc1JlZ2V4JykpIHtcbiAgICAgICAgICAgIGNvbXB1dGVNb250aHNQYXJzZS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1N0cmljdCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1N0cmljdFJlZ2V4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1JlZ2V4O1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfbW9udGhzUmVnZXgnKSkge1xuICAgICAgICAgICAgdGhpcy5fbW9udGhzUmVnZXggPSBkZWZhdWx0TW9udGhzUmVnZXg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1N0cmljdFJlZ2V4ICYmIGlzU3RyaWN0ID9cbiAgICAgICAgICAgIHRoaXMuX21vbnRoc1N0cmljdFJlZ2V4IDogdGhpcy5fbW9udGhzUmVnZXg7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjb21wdXRlTW9udGhzUGFyc2UgKCkge1xuICAgIGZ1bmN0aW9uIGNtcExlblJldihhLCBiKSB7XG4gICAgICAgIHJldHVybiBiLmxlbmd0aCAtIGEubGVuZ3RoO1xuICAgIH1cblxuICAgIHZhciBzaG9ydFBpZWNlcyA9IFtdLCBsb25nUGllY2VzID0gW10sIG1peGVkUGllY2VzID0gW10sXG4gICAgICAgIGksIG1vbTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgICAvLyBtYWtlIHRoZSByZWdleCBpZiB3ZSBkb24ndCBoYXZlIGl0IGFscmVhZHlcbiAgICAgICAgbW9tID0gY3JlYXRlVVRDKFsyMDAwLCBpXSk7XG4gICAgICAgIHNob3J0UGllY2VzLnB1c2godGhpcy5tb250aHNTaG9ydChtb20sICcnKSk7XG4gICAgICAgIGxvbmdQaWVjZXMucHVzaCh0aGlzLm1vbnRocyhtb20sICcnKSk7XG4gICAgICAgIG1peGVkUGllY2VzLnB1c2godGhpcy5tb250aHMobW9tLCAnJykpO1xuICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKHRoaXMubW9udGhzU2hvcnQobW9tLCAnJykpO1xuICAgIH1cbiAgICAvLyBTb3J0aW5nIG1ha2VzIHN1cmUgaWYgb25lIG1vbnRoIChvciBhYmJyKSBpcyBhIHByZWZpeCBvZiBhbm90aGVyIGl0XG4gICAgLy8gd2lsbCBtYXRjaCB0aGUgbG9uZ2VyIHBpZWNlLlxuICAgIHNob3J0UGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICBsb25nUGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICBtaXhlZFBpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgZm9yIChpID0gMDsgaSA8IDEyOyBpKyspIHtcbiAgICAgICAgc2hvcnRQaWVjZXNbaV0gPSByZWdleEVzY2FwZShzaG9ydFBpZWNlc1tpXSk7XG4gICAgICAgIGxvbmdQaWVjZXNbaV0gPSByZWdleEVzY2FwZShsb25nUGllY2VzW2ldKTtcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IDI0OyBpKyspIHtcbiAgICAgICAgbWl4ZWRQaWVjZXNbaV0gPSByZWdleEVzY2FwZShtaXhlZFBpZWNlc1tpXSk7XG4gICAgfVxuXG4gICAgdGhpcy5fbW9udGhzUmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBtaXhlZFBpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgdGhpcy5fbW9udGhzU2hvcnRSZWdleCA9IHRoaXMuX21vbnRoc1JlZ2V4O1xuICAgIHRoaXMuX21vbnRoc1N0cmljdFJlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgbG9uZ1BpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgdGhpcy5fbW9udGhzU2hvcnRTdHJpY3RSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIHNob3J0UGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRGF0ZSAoeSwgbSwgZCwgaCwgTSwgcywgbXMpIHtcbiAgICAvLyBjYW4ndCBqdXN0IGFwcGx5KCkgdG8gY3JlYXRlIGEgZGF0ZTpcbiAgICAvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3EvMTgxMzQ4XG4gICAgdmFyIGRhdGUgPSBuZXcgRGF0ZSh5LCBtLCBkLCBoLCBNLCBzLCBtcyk7XG5cbiAgICAvLyB0aGUgZGF0ZSBjb25zdHJ1Y3RvciByZW1hcHMgeWVhcnMgMC05OSB0byAxOTAwLTE5OTlcbiAgICBpZiAoeSA8IDEwMCAmJiB5ID49IDAgJiYgaXNGaW5pdGUoZGF0ZS5nZXRGdWxsWWVhcigpKSkge1xuICAgICAgICBkYXRlLnNldEZ1bGxZZWFyKHkpO1xuICAgIH1cbiAgICByZXR1cm4gZGF0ZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlVVRDRGF0ZSAoeSkge1xuICAgIHZhciBkYXRlID0gbmV3IERhdGUoRGF0ZS5VVEMuYXBwbHkobnVsbCwgYXJndW1lbnRzKSk7XG5cbiAgICAvLyB0aGUgRGF0ZS5VVEMgZnVuY3Rpb24gcmVtYXBzIHllYXJzIDAtOTkgdG8gMTkwMC0xOTk5XG4gICAgaWYgKHkgPCAxMDAgJiYgeSA+PSAwICYmIGlzRmluaXRlKGRhdGUuZ2V0VVRDRnVsbFllYXIoKSkpIHtcbiAgICAgICAgZGF0ZS5zZXRVVENGdWxsWWVhcih5KTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGU7XG59XG5cbi8vIHN0YXJ0LW9mLWZpcnN0LXdlZWsgLSBzdGFydC1vZi15ZWFyXG5mdW5jdGlvbiBmaXJzdFdlZWtPZmZzZXQoeWVhciwgZG93LCBkb3kpIHtcbiAgICB2YXIgLy8gZmlyc3Qtd2VlayBkYXkgLS0gd2hpY2ggamFudWFyeSBpcyBhbHdheXMgaW4gdGhlIGZpcnN0IHdlZWsgKDQgZm9yIGlzbywgMSBmb3Igb3RoZXIpXG4gICAgICAgIGZ3ZCA9IDcgKyBkb3cgLSBkb3ksXG4gICAgICAgIC8vIGZpcnN0LXdlZWsgZGF5IGxvY2FsIHdlZWtkYXkgLS0gd2hpY2ggbG9jYWwgd2Vla2RheSBpcyBmd2RcbiAgICAgICAgZndkbHcgPSAoNyArIGNyZWF0ZVVUQ0RhdGUoeWVhciwgMCwgZndkKS5nZXRVVENEYXkoKSAtIGRvdykgJSA3O1xuXG4gICAgcmV0dXJuIC1md2RsdyArIGZ3ZCAtIDE7XG59XG5cbi8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT193ZWVrX2RhdGUjQ2FsY3VsYXRpbmdfYV9kYXRlX2dpdmVuX3RoZV95ZWFyLjJDX3dlZWtfbnVtYmVyX2FuZF93ZWVrZGF5XG5mdW5jdGlvbiBkYXlPZlllYXJGcm9tV2Vla3MoeWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpIHtcbiAgICB2YXIgbG9jYWxXZWVrZGF5ID0gKDcgKyB3ZWVrZGF5IC0gZG93KSAlIDcsXG4gICAgICAgIHdlZWtPZmZzZXQgPSBmaXJzdFdlZWtPZmZzZXQoeWVhciwgZG93LCBkb3kpLFxuICAgICAgICBkYXlPZlllYXIgPSAxICsgNyAqICh3ZWVrIC0gMSkgKyBsb2NhbFdlZWtkYXkgKyB3ZWVrT2Zmc2V0LFxuICAgICAgICByZXNZZWFyLCByZXNEYXlPZlllYXI7XG5cbiAgICBpZiAoZGF5T2ZZZWFyIDw9IDApIHtcbiAgICAgICAgcmVzWWVhciA9IHllYXIgLSAxO1xuICAgICAgICByZXNEYXlPZlllYXIgPSBkYXlzSW5ZZWFyKHJlc1llYXIpICsgZGF5T2ZZZWFyO1xuICAgIH0gZWxzZSBpZiAoZGF5T2ZZZWFyID4gZGF5c0luWWVhcih5ZWFyKSkge1xuICAgICAgICByZXNZZWFyID0geWVhciArIDE7XG4gICAgICAgIHJlc0RheU9mWWVhciA9IGRheU9mWWVhciAtIGRheXNJblllYXIoeWVhcik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmVzWWVhciA9IHllYXI7XG4gICAgICAgIHJlc0RheU9mWWVhciA9IGRheU9mWWVhcjtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB5ZWFyOiByZXNZZWFyLFxuICAgICAgICBkYXlPZlllYXI6IHJlc0RheU9mWWVhclxuICAgIH07XG59XG5cbmZ1bmN0aW9uIHdlZWtPZlllYXIobW9tLCBkb3csIGRveSkge1xuICAgIHZhciB3ZWVrT2Zmc2V0ID0gZmlyc3RXZWVrT2Zmc2V0KG1vbS55ZWFyKCksIGRvdywgZG95KSxcbiAgICAgICAgd2VlayA9IE1hdGguZmxvb3IoKG1vbS5kYXlPZlllYXIoKSAtIHdlZWtPZmZzZXQgLSAxKSAvIDcpICsgMSxcbiAgICAgICAgcmVzV2VlaywgcmVzWWVhcjtcblxuICAgIGlmICh3ZWVrIDwgMSkge1xuICAgICAgICByZXNZZWFyID0gbW9tLnllYXIoKSAtIDE7XG4gICAgICAgIHJlc1dlZWsgPSB3ZWVrICsgd2Vla3NJblllYXIocmVzWWVhciwgZG93LCBkb3kpO1xuICAgIH0gZWxzZSBpZiAod2VlayA+IHdlZWtzSW5ZZWFyKG1vbS55ZWFyKCksIGRvdywgZG95KSkge1xuICAgICAgICByZXNXZWVrID0gd2VlayAtIHdlZWtzSW5ZZWFyKG1vbS55ZWFyKCksIGRvdywgZG95KTtcbiAgICAgICAgcmVzWWVhciA9IG1vbS55ZWFyKCkgKyAxO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc1llYXIgPSBtb20ueWVhcigpO1xuICAgICAgICByZXNXZWVrID0gd2VlaztcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB3ZWVrOiByZXNXZWVrLFxuICAgICAgICB5ZWFyOiByZXNZZWFyXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gd2Vla3NJblllYXIoeWVhciwgZG93LCBkb3kpIHtcbiAgICB2YXIgd2Vla09mZnNldCA9IGZpcnN0V2Vla09mZnNldCh5ZWFyLCBkb3csIGRveSksXG4gICAgICAgIHdlZWtPZmZzZXROZXh0ID0gZmlyc3RXZWVrT2Zmc2V0KHllYXIgKyAxLCBkb3csIGRveSk7XG4gICAgcmV0dXJuIChkYXlzSW5ZZWFyKHllYXIpIC0gd2Vla09mZnNldCArIHdlZWtPZmZzZXROZXh0KSAvIDc7XG59XG5cbi8vIEZPUk1BVFRJTkdcblxuYWRkRm9ybWF0VG9rZW4oJ3cnLCBbJ3d3JywgMl0sICd3bycsICd3ZWVrJyk7XG5hZGRGb3JtYXRUb2tlbignVycsIFsnV1cnLCAyXSwgJ1dvJywgJ2lzb1dlZWsnKTtcblxuLy8gQUxJQVNFU1xuXG5hZGRVbml0QWxpYXMoJ3dlZWsnLCAndycpO1xuYWRkVW5pdEFsaWFzKCdpc29XZWVrJywgJ1cnKTtcblxuLy8gUFJJT1JJVElFU1xuXG5hZGRVbml0UHJpb3JpdHkoJ3dlZWsnLCA1KTtcbmFkZFVuaXRQcmlvcml0eSgnaXNvV2VlaycsIDUpO1xuXG4vLyBQQVJTSU5HXG5cbmFkZFJlZ2V4VG9rZW4oJ3cnLCAgbWF0Y2gxdG8yKTtcbmFkZFJlZ2V4VG9rZW4oJ3d3JywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuYWRkUmVnZXhUb2tlbignVycsICBtYXRjaDF0bzIpO1xuYWRkUmVnZXhUb2tlbignV1cnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG5cbmFkZFdlZWtQYXJzZVRva2VuKFsndycsICd3dycsICdXJywgJ1dXJ10sIGZ1bmN0aW9uIChpbnB1dCwgd2VlaywgY29uZmlnLCB0b2tlbikge1xuICAgIHdlZWtbdG9rZW4uc3Vic3RyKDAsIDEpXSA9IHRvSW50KGlucHV0KTtcbn0pO1xuXG4vLyBIRUxQRVJTXG5cbi8vIExPQ0FMRVNcblxuZnVuY3Rpb24gbG9jYWxlV2VlayAobW9tKSB7XG4gICAgcmV0dXJuIHdlZWtPZlllYXIobW9tLCB0aGlzLl93ZWVrLmRvdywgdGhpcy5fd2Vlay5kb3kpLndlZWs7XG59XG5cbnZhciBkZWZhdWx0TG9jYWxlV2VlayA9IHtcbiAgICBkb3cgOiAwLCAvLyBTdW5kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICBkb3kgOiA2ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiAxc3QgaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG59O1xuXG5mdW5jdGlvbiBsb2NhbGVGaXJzdERheU9mV2VlayAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dlZWsuZG93O1xufVxuXG5mdW5jdGlvbiBsb2NhbGVGaXJzdERheU9mWWVhciAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dlZWsuZG95O1xufVxuXG4vLyBNT01FTlRTXG5cbmZ1bmN0aW9uIGdldFNldFdlZWsgKGlucHV0KSB7XG4gICAgdmFyIHdlZWsgPSB0aGlzLmxvY2FsZURhdGEoKS53ZWVrKHRoaXMpO1xuICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gd2VlayA6IHRoaXMuYWRkKChpbnB1dCAtIHdlZWspICogNywgJ2QnKTtcbn1cblxuZnVuY3Rpb24gZ2V0U2V0SVNPV2VlayAoaW5wdXQpIHtcbiAgICB2YXIgd2VlayA9IHdlZWtPZlllYXIodGhpcywgMSwgNCkud2VlaztcbiAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IHdlZWsgOiB0aGlzLmFkZCgoaW5wdXQgLSB3ZWVrKSAqIDcsICdkJyk7XG59XG5cbi8vIEZPUk1BVFRJTkdcblxuYWRkRm9ybWF0VG9rZW4oJ2QnLCAwLCAnZG8nLCAnZGF5Jyk7XG5cbmFkZEZvcm1hdFRva2VuKCdkZCcsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkud2Vla2RheXNNaW4odGhpcywgZm9ybWF0KTtcbn0pO1xuXG5hZGRGb3JtYXRUb2tlbignZGRkJywgMCwgMCwgZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS53ZWVrZGF5c1Nob3J0KHRoaXMsIGZvcm1hdCk7XG59KTtcblxuYWRkRm9ybWF0VG9rZW4oJ2RkZGQnLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLndlZWtkYXlzKHRoaXMsIGZvcm1hdCk7XG59KTtcblxuYWRkRm9ybWF0VG9rZW4oJ2UnLCAwLCAwLCAnd2Vla2RheScpO1xuYWRkRm9ybWF0VG9rZW4oJ0UnLCAwLCAwLCAnaXNvV2Vla2RheScpO1xuXG4vLyBBTElBU0VTXG5cbmFkZFVuaXRBbGlhcygnZGF5JywgJ2QnKTtcbmFkZFVuaXRBbGlhcygnd2Vla2RheScsICdlJyk7XG5hZGRVbml0QWxpYXMoJ2lzb1dlZWtkYXknLCAnRScpO1xuXG4vLyBQUklPUklUWVxuYWRkVW5pdFByaW9yaXR5KCdkYXknLCAxMSk7XG5hZGRVbml0UHJpb3JpdHkoJ3dlZWtkYXknLCAxMSk7XG5hZGRVbml0UHJpb3JpdHkoJ2lzb1dlZWtkYXknLCAxMSk7XG5cbi8vIFBBUlNJTkdcblxuYWRkUmVnZXhUb2tlbignZCcsICAgIG1hdGNoMXRvMik7XG5hZGRSZWdleFRva2VuKCdlJywgICAgbWF0Y2gxdG8yKTtcbmFkZFJlZ2V4VG9rZW4oJ0UnLCAgICBtYXRjaDF0bzIpO1xuYWRkUmVnZXhUb2tlbignZGQnLCAgIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgcmV0dXJuIGxvY2FsZS53ZWVrZGF5c01pblJlZ2V4KGlzU3RyaWN0KTtcbn0pO1xuYWRkUmVnZXhUb2tlbignZGRkJywgICBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgIHJldHVybiBsb2NhbGUud2Vla2RheXNTaG9ydFJlZ2V4KGlzU3RyaWN0KTtcbn0pO1xuYWRkUmVnZXhUb2tlbignZGRkZCcsICAgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICByZXR1cm4gbG9jYWxlLndlZWtkYXlzUmVnZXgoaXNTdHJpY3QpO1xufSk7XG5cbmFkZFdlZWtQYXJzZVRva2VuKFsnZGQnLCAnZGRkJywgJ2RkZGQnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgdmFyIHdlZWtkYXkgPSBjb25maWcuX2xvY2FsZS53ZWVrZGF5c1BhcnNlKGlucHV0LCB0b2tlbiwgY29uZmlnLl9zdHJpY3QpO1xuICAgIC8vIGlmIHdlIGRpZG4ndCBnZXQgYSB3ZWVrZGF5IG5hbWUsIG1hcmsgdGhlIGRhdGUgYXMgaW52YWxpZFxuICAgIGlmICh3ZWVrZGF5ICE9IG51bGwpIHtcbiAgICAgICAgd2Vlay5kID0gd2Vla2RheTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5pbnZhbGlkV2Vla2RheSA9IGlucHV0O1xuICAgIH1cbn0pO1xuXG5hZGRXZWVrUGFyc2VUb2tlbihbJ2QnLCAnZScsICdFJ10sIGZ1bmN0aW9uIChpbnB1dCwgd2VlaywgY29uZmlnLCB0b2tlbikge1xuICAgIHdlZWtbdG9rZW5dID0gdG9JbnQoaW5wdXQpO1xufSk7XG5cbi8vIEhFTFBFUlNcblxuZnVuY3Rpb24gcGFyc2VXZWVrZGF5KGlucHV0LCBsb2NhbGUpIHtcbiAgICBpZiAodHlwZW9mIGlucHV0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgfVxuXG4gICAgaWYgKCFpc05hTihpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KGlucHV0LCAxMCk7XG4gICAgfVxuXG4gICAgaW5wdXQgPSBsb2NhbGUud2Vla2RheXNQYXJzZShpbnB1dCk7XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBwYXJzZUlzb1dlZWtkYXkoaW5wdXQsIGxvY2FsZSkge1xuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUud2Vla2RheXNQYXJzZShpbnB1dCkgJSA3IHx8IDc7XG4gICAgfVxuICAgIHJldHVybiBpc05hTihpbnB1dCkgPyBudWxsIDogaW5wdXQ7XG59XG5cbi8vIExPQ0FMRVNcblxudmFyIGRlZmF1bHRMb2NhbGVXZWVrZGF5cyA9ICdTdW5kYXlfTW9uZGF5X1R1ZXNkYXlfV2VkbmVzZGF5X1RodXJzZGF5X0ZyaWRheV9TYXR1cmRheScuc3BsaXQoJ18nKTtcbmZ1bmN0aW9uIGxvY2FsZVdlZWtkYXlzIChtLCBmb3JtYXQpIHtcbiAgICBpZiAoIW0pIHtcbiAgICAgICAgcmV0dXJuIGlzQXJyYXkodGhpcy5fd2Vla2RheXMpID8gdGhpcy5fd2Vla2RheXMgOlxuICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNbJ3N0YW5kYWxvbmUnXTtcbiAgICB9XG4gICAgcmV0dXJuIGlzQXJyYXkodGhpcy5fd2Vla2RheXMpID8gdGhpcy5fd2Vla2RheXNbbS5kYXkoKV0gOlxuICAgICAgICB0aGlzLl93ZWVrZGF5c1t0aGlzLl93ZWVrZGF5cy5pc0Zvcm1hdC50ZXN0KGZvcm1hdCkgPyAnZm9ybWF0JyA6ICdzdGFuZGFsb25lJ11bbS5kYXkoKV07XG59XG5cbnZhciBkZWZhdWx0TG9jYWxlV2Vla2RheXNTaG9ydCA9ICdTdW5fTW9uX1R1ZV9XZWRfVGh1X0ZyaV9TYXQnLnNwbGl0KCdfJyk7XG5mdW5jdGlvbiBsb2NhbGVXZWVrZGF5c1Nob3J0IChtKSB7XG4gICAgcmV0dXJuIChtKSA/IHRoaXMuX3dlZWtkYXlzU2hvcnRbbS5kYXkoKV0gOiB0aGlzLl93ZWVrZGF5c1Nob3J0O1xufVxuXG52YXIgZGVmYXVsdExvY2FsZVdlZWtkYXlzTWluID0gJ1N1X01vX1R1X1dlX1RoX0ZyX1NhJy5zcGxpdCgnXycpO1xuZnVuY3Rpb24gbG9jYWxlV2Vla2RheXNNaW4gKG0pIHtcbiAgICByZXR1cm4gKG0pID8gdGhpcy5fd2Vla2RheXNNaW5bbS5kYXkoKV0gOiB0aGlzLl93ZWVrZGF5c01pbjtcbn1cblxuZnVuY3Rpb24gaGFuZGxlU3RyaWN0UGFyc2UkMSh3ZWVrZGF5TmFtZSwgZm9ybWF0LCBzdHJpY3QpIHtcbiAgICB2YXIgaSwgaWksIG1vbSwgbGxjID0gd2Vla2RheU5hbWUudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICBpZiAoIXRoaXMuX3dlZWtkYXlzUGFyc2UpIHtcbiAgICAgICAgdGhpcy5fd2Vla2RheXNQYXJzZSA9IFtdO1xuICAgICAgICB0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgdGhpcy5fbWluV2Vla2RheXNQYXJzZSA9IFtdO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCA3OyArK2kpIHtcbiAgICAgICAgICAgIG1vbSA9IGNyZWF0ZVVUQyhbMjAwMCwgMV0pLmRheShpKTtcbiAgICAgICAgICAgIHRoaXMuX21pbldlZWtkYXlzUGFyc2VbaV0gPSB0aGlzLndlZWtkYXlzTWluKG1vbSwgJycpLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2VbaV0gPSB0aGlzLndlZWtkYXlzU2hvcnQobW9tLCAnJykudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzUGFyc2VbaV0gPSB0aGlzLndlZWtkYXlzKG1vbSwgJycpLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc3RyaWN0KSB7XG4gICAgICAgIGlmIChmb3JtYXQgPT09ICdkZGRkJykge1xuICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fd2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgIH0gZWxzZSBpZiAoZm9ybWF0ID09PSAnZGRkJykge1xuICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX21pbldlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ2RkZGQnKSB7XG4gICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl93ZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9taW5XZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgfSBlbHNlIGlmIChmb3JtYXQgPT09ICdkZGQnKSB7XG4gICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fd2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9taW5XZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX21pbldlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fd2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBsb2NhbGVXZWVrZGF5c1BhcnNlICh3ZWVrZGF5TmFtZSwgZm9ybWF0LCBzdHJpY3QpIHtcbiAgICB2YXIgaSwgbW9tLCByZWdleDtcblxuICAgIGlmICh0aGlzLl93ZWVrZGF5c1BhcnNlRXhhY3QpIHtcbiAgICAgICAgcmV0dXJuIGhhbmRsZVN0cmljdFBhcnNlJDEuY2FsbCh0aGlzLCB3ZWVrZGF5TmFtZSwgZm9ybWF0LCBzdHJpY3QpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fd2Vla2RheXNQYXJzZSkge1xuICAgICAgICB0aGlzLl93ZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgIHRoaXMuX21pbldlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgdGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgIHRoaXMuX2Z1bGxXZWVrZGF5c1BhcnNlID0gW107XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IDc7IGkrKykge1xuICAgICAgICAvLyBtYWtlIHRoZSByZWdleCBpZiB3ZSBkb24ndCBoYXZlIGl0IGFscmVhZHlcblxuICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIDFdKS5kYXkoaSk7XG4gICAgICAgIGlmIChzdHJpY3QgJiYgIXRoaXMuX2Z1bGxXZWVrZGF5c1BhcnNlW2ldKSB7XG4gICAgICAgICAgICB0aGlzLl9mdWxsV2Vla2RheXNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoJ14nICsgdGhpcy53ZWVrZGF5cyhtb20sICcnKS5yZXBsYWNlKCcuJywgJ1xcLj8nKSArICckJywgJ2knKTtcbiAgICAgICAgICAgIHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoJ14nICsgdGhpcy53ZWVrZGF5c1Nob3J0KG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnXFwuPycpICsgJyQnLCAnaScpO1xuICAgICAgICAgICAgdGhpcy5fbWluV2Vla2RheXNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoJ14nICsgdGhpcy53ZWVrZGF5c01pbihtb20sICcnKS5yZXBsYWNlKCcuJywgJ1xcLj8nKSArICckJywgJ2knKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX3dlZWtkYXlzUGFyc2VbaV0pIHtcbiAgICAgICAgICAgIHJlZ2V4ID0gJ14nICsgdGhpcy53ZWVrZGF5cyhtb20sICcnKSArICd8XicgKyB0aGlzLndlZWtkYXlzU2hvcnQobW9tLCAnJykgKyAnfF4nICsgdGhpcy53ZWVrZGF5c01pbihtb20sICcnKTtcbiAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKHJlZ2V4LnJlcGxhY2UoJy4nLCAnJyksICdpJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGVzdCB0aGUgcmVnZXhcbiAgICAgICAgaWYgKHN0cmljdCAmJiBmb3JtYXQgPT09ICdkZGRkJyAmJiB0aGlzLl9mdWxsV2Vla2RheXNQYXJzZVtpXS50ZXN0KHdlZWtkYXlOYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RyaWN0ICYmIGZvcm1hdCA9PT0gJ2RkZCcgJiYgdGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlW2ldLnRlc3Qod2Vla2RheU5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfSBlbHNlIGlmIChzdHJpY3QgJiYgZm9ybWF0ID09PSAnZGQnICYmIHRoaXMuX21pbldlZWtkYXlzUGFyc2VbaV0udGVzdCh3ZWVrZGF5TmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9IGVsc2UgaWYgKCFzdHJpY3QgJiYgdGhpcy5fd2Vla2RheXNQYXJzZVtpXS50ZXN0KHdlZWtkYXlOYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8vIE1PTUVOVFNcblxuZnVuY3Rpb24gZ2V0U2V0RGF5T2ZXZWVrIChpbnB1dCkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgPyB0aGlzIDogTmFOO1xuICAgIH1cbiAgICB2YXIgZGF5ID0gdGhpcy5faXNVVEMgPyB0aGlzLl9kLmdldFVUQ0RheSgpIDogdGhpcy5fZC5nZXREYXkoKTtcbiAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICBpbnB1dCA9IHBhcnNlV2Vla2RheShpbnB1dCwgdGhpcy5sb2NhbGVEYXRhKCkpO1xuICAgICAgICByZXR1cm4gdGhpcy5hZGQoaW5wdXQgLSBkYXksICdkJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGRheTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGdldFNldExvY2FsZURheU9mV2VlayAoaW5wdXQpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgIHJldHVybiBpbnB1dCAhPSBudWxsID8gdGhpcyA6IE5hTjtcbiAgICB9XG4gICAgdmFyIHdlZWtkYXkgPSAodGhpcy5kYXkoKSArIDcgLSB0aGlzLmxvY2FsZURhdGEoKS5fd2Vlay5kb3cpICUgNztcbiAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IHdlZWtkYXkgOiB0aGlzLmFkZChpbnB1dCAtIHdlZWtkYXksICdkJyk7XG59XG5cbmZ1bmN0aW9uIGdldFNldElTT0RheU9mV2VlayAoaW5wdXQpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgIHJldHVybiBpbnB1dCAhPSBudWxsID8gdGhpcyA6IE5hTjtcbiAgICB9XG5cbiAgICAvLyBiZWhhdmVzIHRoZSBzYW1lIGFzIG1vbWVudCNkYXkgZXhjZXB0XG4gICAgLy8gYXMgYSBnZXR0ZXIsIHJldHVybnMgNyBpbnN0ZWFkIG9mIDAgKDEtNyByYW5nZSBpbnN0ZWFkIG9mIDAtNilcbiAgICAvLyBhcyBhIHNldHRlciwgc3VuZGF5IHNob3VsZCBiZWxvbmcgdG8gdGhlIHByZXZpb3VzIHdlZWsuXG5cbiAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICB2YXIgd2Vla2RheSA9IHBhcnNlSXNvV2Vla2RheShpbnB1dCwgdGhpcy5sb2NhbGVEYXRhKCkpO1xuICAgICAgICByZXR1cm4gdGhpcy5kYXkodGhpcy5kYXkoKSAlIDcgPyB3ZWVrZGF5IDogd2Vla2RheSAtIDcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRheSgpIHx8IDc7XG4gICAgfVxufVxuXG52YXIgZGVmYXVsdFdlZWtkYXlzUmVnZXggPSBtYXRjaFdvcmQ7XG5mdW5jdGlvbiB3ZWVrZGF5c1JlZ2V4IChpc1N0cmljdCkge1xuICAgIGlmICh0aGlzLl93ZWVrZGF5c1BhcnNlRXhhY3QpIHtcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNSZWdleCcpKSB7XG4gICAgICAgICAgICBjb21wdXRlV2Vla2RheXNQYXJzZS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1N0cmljdCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzU3RyaWN0UmVnZXg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNSZWdleDtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzUmVnZXgnKSkge1xuICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNSZWdleCA9IGRlZmF1bHRXZWVrZGF5c1JlZ2V4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1N0cmljdFJlZ2V4ICYmIGlzU3RyaWN0ID9cbiAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzU3RyaWN0UmVnZXggOiB0aGlzLl93ZWVrZGF5c1JlZ2V4O1xuICAgIH1cbn1cblxudmFyIGRlZmF1bHRXZWVrZGF5c1Nob3J0UmVnZXggPSBtYXRjaFdvcmQ7XG5mdW5jdGlvbiB3ZWVrZGF5c1Nob3J0UmVnZXggKGlzU3RyaWN0KSB7XG4gICAgaWYgKHRoaXMuX3dlZWtkYXlzUGFyc2VFeGFjdCkge1xuICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ193ZWVrZGF5c1JlZ2V4JykpIHtcbiAgICAgICAgICAgIGNvbXB1dGVXZWVrZGF5c1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzU3RyaWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTaG9ydFN0cmljdFJlZ2V4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzU2hvcnRSZWdleDtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzU2hvcnRSZWdleCcpKSB7XG4gICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1Nob3J0UmVnZXggPSBkZWZhdWx0V2Vla2RheXNTaG9ydFJlZ2V4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1Nob3J0U3RyaWN0UmVnZXggJiYgaXNTdHJpY3QgP1xuICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNTaG9ydFN0cmljdFJlZ2V4IDogdGhpcy5fd2Vla2RheXNTaG9ydFJlZ2V4O1xuICAgIH1cbn1cblxudmFyIGRlZmF1bHRXZWVrZGF5c01pblJlZ2V4ID0gbWF0Y2hXb3JkO1xuZnVuY3Rpb24gd2Vla2RheXNNaW5SZWdleCAoaXNTdHJpY3QpIHtcbiAgICBpZiAodGhpcy5fd2Vla2RheXNQYXJzZUV4YWN0KSB7XG4gICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzUmVnZXgnKSkge1xuICAgICAgICAgICAgY29tcHV0ZVdlZWtkYXlzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNTdHJpY3QpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c01pblN0cmljdFJlZ2V4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzTWluUmVnZXg7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ193ZWVrZGF5c01pblJlZ2V4JykpIHtcbiAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzTWluUmVnZXggPSBkZWZhdWx0V2Vla2RheXNNaW5SZWdleDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNNaW5TdHJpY3RSZWdleCAmJiBpc1N0cmljdCA/XG4gICAgICAgICAgICB0aGlzLl93ZWVrZGF5c01pblN0cmljdFJlZ2V4IDogdGhpcy5fd2Vla2RheXNNaW5SZWdleDtcbiAgICB9XG59XG5cblxuZnVuY3Rpb24gY29tcHV0ZVdlZWtkYXlzUGFyc2UgKCkge1xuICAgIGZ1bmN0aW9uIGNtcExlblJldihhLCBiKSB7XG4gICAgICAgIHJldHVybiBiLmxlbmd0aCAtIGEubGVuZ3RoO1xuICAgIH1cblxuICAgIHZhciBtaW5QaWVjZXMgPSBbXSwgc2hvcnRQaWVjZXMgPSBbXSwgbG9uZ1BpZWNlcyA9IFtdLCBtaXhlZFBpZWNlcyA9IFtdLFxuICAgICAgICBpLCBtb20sIG1pbnAsIHNob3J0cCwgbG9uZ3A7XG4gICAgZm9yIChpID0gMDsgaSA8IDc7IGkrKykge1xuICAgICAgICAvLyBtYWtlIHRoZSByZWdleCBpZiB3ZSBkb24ndCBoYXZlIGl0IGFscmVhZHlcbiAgICAgICAgbW9tID0gY3JlYXRlVVRDKFsyMDAwLCAxXSkuZGF5KGkpO1xuICAgICAgICBtaW5wID0gdGhpcy53ZWVrZGF5c01pbihtb20sICcnKTtcbiAgICAgICAgc2hvcnRwID0gdGhpcy53ZWVrZGF5c1Nob3J0KG1vbSwgJycpO1xuICAgICAgICBsb25ncCA9IHRoaXMud2Vla2RheXMobW9tLCAnJyk7XG4gICAgICAgIG1pblBpZWNlcy5wdXNoKG1pbnApO1xuICAgICAgICBzaG9ydFBpZWNlcy5wdXNoKHNob3J0cCk7XG4gICAgICAgIGxvbmdQaWVjZXMucHVzaChsb25ncCk7XG4gICAgICAgIG1peGVkUGllY2VzLnB1c2gobWlucCk7XG4gICAgICAgIG1peGVkUGllY2VzLnB1c2goc2hvcnRwKTtcbiAgICAgICAgbWl4ZWRQaWVjZXMucHVzaChsb25ncCk7XG4gICAgfVxuICAgIC8vIFNvcnRpbmcgbWFrZXMgc3VyZSBpZiBvbmUgd2Vla2RheSAob3IgYWJicikgaXMgYSBwcmVmaXggb2YgYW5vdGhlciBpdFxuICAgIC8vIHdpbGwgbWF0Y2ggdGhlIGxvbmdlciBwaWVjZS5cbiAgICBtaW5QaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgIHNob3J0UGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICBsb25nUGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICBtaXhlZFBpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgZm9yIChpID0gMDsgaSA8IDc7IGkrKykge1xuICAgICAgICBzaG9ydFBpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKHNob3J0UGllY2VzW2ldKTtcbiAgICAgICAgbG9uZ1BpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKGxvbmdQaWVjZXNbaV0pO1xuICAgICAgICBtaXhlZFBpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKG1peGVkUGllY2VzW2ldKTtcbiAgICB9XG5cbiAgICB0aGlzLl93ZWVrZGF5c1JlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgbWl4ZWRQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgIHRoaXMuX3dlZWtkYXlzU2hvcnRSZWdleCA9IHRoaXMuX3dlZWtkYXlzUmVnZXg7XG4gICAgdGhpcy5fd2Vla2RheXNNaW5SZWdleCA9IHRoaXMuX3dlZWtkYXlzUmVnZXg7XG5cbiAgICB0aGlzLl93ZWVrZGF5c1N0cmljdFJlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgbG9uZ1BpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgdGhpcy5fd2Vla2RheXNTaG9ydFN0cmljdFJlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgc2hvcnRQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgIHRoaXMuX3dlZWtkYXlzTWluU3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBtaW5QaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xufVxuXG4vLyBGT1JNQVRUSU5HXG5cbmZ1bmN0aW9uIGhGb3JtYXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaG91cnMoKSAlIDEyIHx8IDEyO1xufVxuXG5mdW5jdGlvbiBrRm9ybWF0KCkge1xuICAgIHJldHVybiB0aGlzLmhvdXJzKCkgfHwgMjQ7XG59XG5cbmFkZEZvcm1hdFRva2VuKCdIJywgWydISCcsIDJdLCAwLCAnaG91cicpO1xuYWRkRm9ybWF0VG9rZW4oJ2gnLCBbJ2hoJywgMl0sIDAsIGhGb3JtYXQpO1xuYWRkRm9ybWF0VG9rZW4oJ2snLCBbJ2trJywgMl0sIDAsIGtGb3JtYXQpO1xuXG5hZGRGb3JtYXRUb2tlbignaG1tJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAnJyArIGhGb3JtYXQuYXBwbHkodGhpcykgKyB6ZXJvRmlsbCh0aGlzLm1pbnV0ZXMoKSwgMik7XG59KTtcblxuYWRkRm9ybWF0VG9rZW4oJ2htbXNzJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAnJyArIGhGb3JtYXQuYXBwbHkodGhpcykgKyB6ZXJvRmlsbCh0aGlzLm1pbnV0ZXMoKSwgMikgK1xuICAgICAgICB6ZXJvRmlsbCh0aGlzLnNlY29uZHMoKSwgMik7XG59KTtcblxuYWRkRm9ybWF0VG9rZW4oJ0htbScsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gJycgKyB0aGlzLmhvdXJzKCkgKyB6ZXJvRmlsbCh0aGlzLm1pbnV0ZXMoKSwgMik7XG59KTtcblxuYWRkRm9ybWF0VG9rZW4oJ0htbXNzJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAnJyArIHRoaXMuaG91cnMoKSArIHplcm9GaWxsKHRoaXMubWludXRlcygpLCAyKSArXG4gICAgICAgIHplcm9GaWxsKHRoaXMuc2Vjb25kcygpLCAyKTtcbn0pO1xuXG5mdW5jdGlvbiBtZXJpZGllbSAodG9rZW4sIGxvd2VyY2FzZSkge1xuICAgIGFkZEZvcm1hdFRva2VuKHRva2VuLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5tZXJpZGllbSh0aGlzLmhvdXJzKCksIHRoaXMubWludXRlcygpLCBsb3dlcmNhc2UpO1xuICAgIH0pO1xufVxuXG5tZXJpZGllbSgnYScsIHRydWUpO1xubWVyaWRpZW0oJ0EnLCBmYWxzZSk7XG5cbi8vIEFMSUFTRVNcblxuYWRkVW5pdEFsaWFzKCdob3VyJywgJ2gnKTtcblxuLy8gUFJJT1JJVFlcbmFkZFVuaXRQcmlvcml0eSgnaG91cicsIDEzKTtcblxuLy8gUEFSU0lOR1xuXG5mdW5jdGlvbiBtYXRjaE1lcmlkaWVtIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgcmV0dXJuIGxvY2FsZS5fbWVyaWRpZW1QYXJzZTtcbn1cblxuYWRkUmVnZXhUb2tlbignYScsICBtYXRjaE1lcmlkaWVtKTtcbmFkZFJlZ2V4VG9rZW4oJ0EnLCAgbWF0Y2hNZXJpZGllbSk7XG5hZGRSZWdleFRva2VuKCdIJywgIG1hdGNoMXRvMik7XG5hZGRSZWdleFRva2VuKCdoJywgIG1hdGNoMXRvMik7XG5hZGRSZWdleFRva2VuKCdrJywgIG1hdGNoMXRvMik7XG5hZGRSZWdleFRva2VuKCdISCcsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbmFkZFJlZ2V4VG9rZW4oJ2hoJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuYWRkUmVnZXhUb2tlbigna2snLCBtYXRjaDF0bzIsIG1hdGNoMik7XG5cbmFkZFJlZ2V4VG9rZW4oJ2htbScsIG1hdGNoM3RvNCk7XG5hZGRSZWdleFRva2VuKCdobW1zcycsIG1hdGNoNXRvNik7XG5hZGRSZWdleFRva2VuKCdIbW0nLCBtYXRjaDN0bzQpO1xuYWRkUmVnZXhUb2tlbignSG1tc3MnLCBtYXRjaDV0bzYpO1xuXG5hZGRQYXJzZVRva2VuKFsnSCcsICdISCddLCBIT1VSKTtcbmFkZFBhcnNlVG9rZW4oWydrJywgJ2trJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgIHZhciBrSW5wdXQgPSB0b0ludChpbnB1dCk7XG4gICAgYXJyYXlbSE9VUl0gPSBrSW5wdXQgPT09IDI0ID8gMCA6IGtJbnB1dDtcbn0pO1xuYWRkUGFyc2VUb2tlbihbJ2EnLCAnQSddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICBjb25maWcuX2lzUG0gPSBjb25maWcuX2xvY2FsZS5pc1BNKGlucHV0KTtcbiAgICBjb25maWcuX21lcmlkaWVtID0gaW5wdXQ7XG59KTtcbmFkZFBhcnNlVG9rZW4oWydoJywgJ2hoJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgIGFycmF5W0hPVVJdID0gdG9JbnQoaW5wdXQpO1xuICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPSB0cnVlO1xufSk7XG5hZGRQYXJzZVRva2VuKCdobW0nLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICB2YXIgcG9zID0gaW5wdXQubGVuZ3RoIC0gMjtcbiAgICBhcnJheVtIT1VSXSA9IHRvSW50KGlucHV0LnN1YnN0cigwLCBwb3MpKTtcbiAgICBhcnJheVtNSU5VVEVdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvcykpO1xuICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPSB0cnVlO1xufSk7XG5hZGRQYXJzZVRva2VuKCdobW1zcycsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgIHZhciBwb3MxID0gaW5wdXQubGVuZ3RoIC0gNDtcbiAgICB2YXIgcG9zMiA9IGlucHV0Lmxlbmd0aCAtIDI7XG4gICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dC5zdWJzdHIoMCwgcG9zMSkpO1xuICAgIGFycmF5W01JTlVURV0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zMSwgMikpO1xuICAgIGFycmF5W1NFQ09ORF0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zMikpO1xuICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPSB0cnVlO1xufSk7XG5hZGRQYXJzZVRva2VuKCdIbW0nLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICB2YXIgcG9zID0gaW5wdXQubGVuZ3RoIC0gMjtcbiAgICBhcnJheVtIT1VSXSA9IHRvSW50KGlucHV0LnN1YnN0cigwLCBwb3MpKTtcbiAgICBhcnJheVtNSU5VVEVdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvcykpO1xufSk7XG5hZGRQYXJzZVRva2VuKCdIbW1zcycsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgIHZhciBwb3MxID0gaW5wdXQubGVuZ3RoIC0gNDtcbiAgICB2YXIgcG9zMiA9IGlucHV0Lmxlbmd0aCAtIDI7XG4gICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dC5zdWJzdHIoMCwgcG9zMSkpO1xuICAgIGFycmF5W01JTlVURV0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zMSwgMikpO1xuICAgIGFycmF5W1NFQ09ORF0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zMikpO1xufSk7XG5cbi8vIExPQ0FMRVNcblxuZnVuY3Rpb24gbG9jYWxlSXNQTSAoaW5wdXQpIHtcbiAgICAvLyBJRTggUXVpcmtzIE1vZGUgJiBJRTcgU3RhbmRhcmRzIE1vZGUgZG8gbm90IGFsbG93IGFjY2Vzc2luZyBzdHJpbmdzIGxpa2UgYXJyYXlzXG4gICAgLy8gVXNpbmcgY2hhckF0IHNob3VsZCBiZSBtb3JlIGNvbXBhdGlibGUuXG4gICAgcmV0dXJuICgoaW5wdXQgKyAnJykudG9Mb3dlckNhc2UoKS5jaGFyQXQoMCkgPT09ICdwJyk7XG59XG5cbnZhciBkZWZhdWx0TG9jYWxlTWVyaWRpZW1QYXJzZSA9IC9bYXBdXFwuP20/XFwuPy9pO1xuZnVuY3Rpb24gbG9jYWxlTWVyaWRpZW0gKGhvdXJzLCBtaW51dGVzLCBpc0xvd2VyKSB7XG4gICAgaWYgKGhvdXJzID4gMTEpIHtcbiAgICAgICAgcmV0dXJuIGlzTG93ZXIgPyAncG0nIDogJ1BNJztcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gaXNMb3dlciA/ICdhbScgOiAnQU0nO1xuICAgIH1cbn1cblxuXG4vLyBNT01FTlRTXG5cbi8vIFNldHRpbmcgdGhlIGhvdXIgc2hvdWxkIGtlZXAgdGhlIHRpbWUsIGJlY2F1c2UgdGhlIHVzZXIgZXhwbGljaXRseVxuLy8gc3BlY2lmaWVkIHdoaWNoIGhvdXIgaGUgd2FudHMuIFNvIHRyeWluZyB0byBtYWludGFpbiB0aGUgc2FtZSBob3VyIChpblxuLy8gYSBuZXcgdGltZXpvbmUpIG1ha2VzIHNlbnNlLiBBZGRpbmcvc3VidHJhY3RpbmcgaG91cnMgZG9lcyBub3QgZm9sbG93XG4vLyB0aGlzIHJ1bGUuXG52YXIgZ2V0U2V0SG91ciA9IG1ha2VHZXRTZXQoJ0hvdXJzJywgdHJ1ZSk7XG5cbi8vIG1vbnRoc1xuLy8gd2Vla1xuLy8gd2Vla2RheXNcbi8vIG1lcmlkaWVtXG52YXIgYmFzZUNvbmZpZyA9IHtcbiAgICBjYWxlbmRhcjogZGVmYXVsdENhbGVuZGFyLFxuICAgIGxvbmdEYXRlRm9ybWF0OiBkZWZhdWx0TG9uZ0RhdGVGb3JtYXQsXG4gICAgaW52YWxpZERhdGU6IGRlZmF1bHRJbnZhbGlkRGF0ZSxcbiAgICBvcmRpbmFsOiBkZWZhdWx0T3JkaW5hbCxcbiAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOiBkZWZhdWx0RGF5T2ZNb250aE9yZGluYWxQYXJzZSxcbiAgICByZWxhdGl2ZVRpbWU6IGRlZmF1bHRSZWxhdGl2ZVRpbWUsXG5cbiAgICBtb250aHM6IGRlZmF1bHRMb2NhbGVNb250aHMsXG4gICAgbW9udGhzU2hvcnQ6IGRlZmF1bHRMb2NhbGVNb250aHNTaG9ydCxcblxuICAgIHdlZWs6IGRlZmF1bHRMb2NhbGVXZWVrLFxuXG4gICAgd2Vla2RheXM6IGRlZmF1bHRMb2NhbGVXZWVrZGF5cyxcbiAgICB3ZWVrZGF5c01pbjogZGVmYXVsdExvY2FsZVdlZWtkYXlzTWluLFxuICAgIHdlZWtkYXlzU2hvcnQ6IGRlZmF1bHRMb2NhbGVXZWVrZGF5c1Nob3J0LFxuXG4gICAgbWVyaWRpZW1QYXJzZTogZGVmYXVsdExvY2FsZU1lcmlkaWVtUGFyc2Vcbn07XG5cbi8vIGludGVybmFsIHN0b3JhZ2UgZm9yIGxvY2FsZSBjb25maWcgZmlsZXNcbnZhciBsb2NhbGVzID0ge307XG52YXIgbG9jYWxlRmFtaWxpZXMgPSB7fTtcbnZhciBnbG9iYWxMb2NhbGU7XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUxvY2FsZShrZXkpIHtcbiAgICByZXR1cm4ga2V5ID8ga2V5LnRvTG93ZXJDYXNlKCkucmVwbGFjZSgnXycsICctJykgOiBrZXk7XG59XG5cbi8vIHBpY2sgdGhlIGxvY2FsZSBmcm9tIHRoZSBhcnJheVxuLy8gdHJ5IFsnZW4tYXUnLCAnZW4tZ2InXSBhcyAnZW4tYXUnLCAnZW4tZ2InLCAnZW4nLCBhcyBpbiBtb3ZlIHRocm91Z2ggdGhlIGxpc3QgdHJ5aW5nIGVhY2hcbi8vIHN1YnN0cmluZyBmcm9tIG1vc3Qgc3BlY2lmaWMgdG8gbGVhc3QsIGJ1dCBtb3ZlIHRvIHRoZSBuZXh0IGFycmF5IGl0ZW0gaWYgaXQncyBhIG1vcmUgc3BlY2lmaWMgdmFyaWFudCB0aGFuIHRoZSBjdXJyZW50IHJvb3RcbmZ1bmN0aW9uIGNob29zZUxvY2FsZShuYW1lcykge1xuICAgIHZhciBpID0gMCwgaiwgbmV4dCwgbG9jYWxlLCBzcGxpdDtcblxuICAgIHdoaWxlIChpIDwgbmFtZXMubGVuZ3RoKSB7XG4gICAgICAgIHNwbGl0ID0gbm9ybWFsaXplTG9jYWxlKG5hbWVzW2ldKS5zcGxpdCgnLScpO1xuICAgICAgICBqID0gc3BsaXQubGVuZ3RoO1xuICAgICAgICBuZXh0ID0gbm9ybWFsaXplTG9jYWxlKG5hbWVzW2kgKyAxXSk7XG4gICAgICAgIG5leHQgPSBuZXh0ID8gbmV4dC5zcGxpdCgnLScpIDogbnVsbDtcbiAgICAgICAgd2hpbGUgKGogPiAwKSB7XG4gICAgICAgICAgICBsb2NhbGUgPSBsb2FkTG9jYWxlKHNwbGl0LnNsaWNlKDAsIGopLmpvaW4oJy0nKSk7XG4gICAgICAgICAgICBpZiAobG9jYWxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvY2FsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXh0ICYmIG5leHQubGVuZ3RoID49IGogJiYgY29tcGFyZUFycmF5cyhzcGxpdCwgbmV4dCwgdHJ1ZSkgPj0gaiAtIDEpIHtcbiAgICAgICAgICAgICAgICAvL3RoZSBuZXh0IGFycmF5IGl0ZW0gaXMgYmV0dGVyIHRoYW4gYSBzaGFsbG93ZXIgc3Vic3RyaW5nIG9mIHRoaXMgb25lXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBqLS07XG4gICAgICAgIH1cbiAgICAgICAgaSsrO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gbG9hZExvY2FsZShuYW1lKSB7XG4gICAgdmFyIG9sZExvY2FsZSA9IG51bGw7XG4gICAgLy8gVE9ETzogRmluZCBhIGJldHRlciB3YXkgdG8gcmVnaXN0ZXIgYW5kIGxvYWQgYWxsIHRoZSBsb2NhbGVzIGluIE5vZGVcbiAgICBpZiAoIWxvY2FsZXNbbmFtZV0gJiYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnKSAmJlxuICAgICAgICAgICAgbW9kdWxlICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBvbGRMb2NhbGUgPSBnbG9iYWxMb2NhbGUuX2FiYnI7XG4gICAgICAgICAgICB2YXIgYWxpYXNlZFJlcXVpcmUgPSByZXF1aXJlO1xuICAgICAgICAgICAgYWxpYXNlZFJlcXVpcmUoJy4vbG9jYWxlLycgKyBuYW1lKTtcbiAgICAgICAgICAgIGdldFNldEdsb2JhbExvY2FsZShvbGRMb2NhbGUpO1xuICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgIH1cbiAgICByZXR1cm4gbG9jYWxlc1tuYW1lXTtcbn1cblxuLy8gVGhpcyBmdW5jdGlvbiB3aWxsIGxvYWQgbG9jYWxlIGFuZCB0aGVuIHNldCB0aGUgZ2xvYmFsIGxvY2FsZS4gIElmXG4vLyBubyBhcmd1bWVudHMgYXJlIHBhc3NlZCBpbiwgaXQgd2lsbCBzaW1wbHkgcmV0dXJuIHRoZSBjdXJyZW50IGdsb2JhbFxuLy8gbG9jYWxlIGtleS5cbmZ1bmN0aW9uIGdldFNldEdsb2JhbExvY2FsZSAoa2V5LCB2YWx1ZXMpIHtcbiAgICB2YXIgZGF0YTtcbiAgICBpZiAoa2V5KSB7XG4gICAgICAgIGlmIChpc1VuZGVmaW5lZCh2YWx1ZXMpKSB7XG4gICAgICAgICAgICBkYXRhID0gZ2V0TG9jYWxlKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkYXRhID0gZGVmaW5lTG9jYWxlKGtleSwgdmFsdWVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICAvLyBtb21lbnQuZHVyYXRpb24uX2xvY2FsZSA9IG1vbWVudC5fbG9jYWxlID0gZGF0YTtcbiAgICAgICAgICAgIGdsb2JhbExvY2FsZSA9IGRhdGE7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZ2xvYmFsTG9jYWxlLl9hYmJyO1xufVxuXG5mdW5jdGlvbiBkZWZpbmVMb2NhbGUgKG5hbWUsIGNvbmZpZykge1xuICAgIGlmIChjb25maWcgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIHBhcmVudENvbmZpZyA9IGJhc2VDb25maWc7XG4gICAgICAgIGNvbmZpZy5hYmJyID0gbmFtZTtcbiAgICAgICAgaWYgKGxvY2FsZXNbbmFtZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgZGVwcmVjYXRlU2ltcGxlKCdkZWZpbmVMb2NhbGVPdmVycmlkZScsXG4gICAgICAgICAgICAgICAgICAgICd1c2UgbW9tZW50LnVwZGF0ZUxvY2FsZShsb2NhbGVOYW1lLCBjb25maWcpIHRvIGNoYW5nZSAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2FuIGV4aXN0aW5nIGxvY2FsZS4gbW9tZW50LmRlZmluZUxvY2FsZShsb2NhbGVOYW1lLCAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2NvbmZpZykgc2hvdWxkIG9ubHkgYmUgdXNlZCBmb3IgY3JlYXRpbmcgYSBuZXcgbG9jYWxlICcgK1xuICAgICAgICAgICAgICAgICAgICAnU2VlIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvZGVmaW5lLWxvY2FsZS8gZm9yIG1vcmUgaW5mby4nKTtcbiAgICAgICAgICAgIHBhcmVudENvbmZpZyA9IGxvY2FsZXNbbmFtZV0uX2NvbmZpZztcbiAgICAgICAgfSBlbHNlIGlmIChjb25maWcucGFyZW50TG9jYWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChsb2NhbGVzW2NvbmZpZy5wYXJlbnRMb2NhbGVdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnRDb25maWcgPSBsb2NhbGVzW2NvbmZpZy5wYXJlbnRMb2NhbGVdLl9jb25maWc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghbG9jYWxlRmFtaWxpZXNbY29uZmlnLnBhcmVudExvY2FsZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxlRmFtaWxpZXNbY29uZmlnLnBhcmVudExvY2FsZV0gPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbG9jYWxlRmFtaWxpZXNbY29uZmlnLnBhcmVudExvY2FsZV0ucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZzogY29uZmlnXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbG9jYWxlc1tuYW1lXSA9IG5ldyBMb2NhbGUobWVyZ2VDb25maWdzKHBhcmVudENvbmZpZywgY29uZmlnKSk7XG5cbiAgICAgICAgaWYgKGxvY2FsZUZhbWlsaWVzW25hbWVdKSB7XG4gICAgICAgICAgICBsb2NhbGVGYW1pbGllc1tuYW1lXS5mb3JFYWNoKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgZGVmaW5lTG9jYWxlKHgubmFtZSwgeC5jb25maWcpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBiYWNrd2FyZHMgY29tcGF0IGZvciBub3c6IGFsc28gc2V0IHRoZSBsb2NhbGVcbiAgICAgICAgLy8gbWFrZSBzdXJlIHdlIHNldCB0aGUgbG9jYWxlIEFGVEVSIGFsbCBjaGlsZCBsb2NhbGVzIGhhdmUgYmVlblxuICAgICAgICAvLyBjcmVhdGVkLCBzbyB3ZSB3b24ndCBlbmQgdXAgd2l0aCB0aGUgY2hpbGQgbG9jYWxlIHNldC5cbiAgICAgICAgZ2V0U2V0R2xvYmFsTG9jYWxlKG5hbWUpO1xuXG5cbiAgICAgICAgcmV0dXJuIGxvY2FsZXNbbmFtZV07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gdXNlZnVsIGZvciB0ZXN0aW5nXG4gICAgICAgIGRlbGV0ZSBsb2NhbGVzW25hbWVdO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUxvY2FsZShuYW1lLCBjb25maWcpIHtcbiAgICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgdmFyIGxvY2FsZSwgdG1wTG9jYWxlLCBwYXJlbnRDb25maWcgPSBiYXNlQ29uZmlnO1xuICAgICAgICAvLyBNRVJHRVxuICAgICAgICB0bXBMb2NhbGUgPSBsb2FkTG9jYWxlKG5hbWUpO1xuICAgICAgICBpZiAodG1wTG9jYWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHBhcmVudENvbmZpZyA9IHRtcExvY2FsZS5fY29uZmlnO1xuICAgICAgICB9XG4gICAgICAgIGNvbmZpZyA9IG1lcmdlQ29uZmlncyhwYXJlbnRDb25maWcsIGNvbmZpZyk7XG4gICAgICAgIGxvY2FsZSA9IG5ldyBMb2NhbGUoY29uZmlnKTtcbiAgICAgICAgbG9jYWxlLnBhcmVudExvY2FsZSA9IGxvY2FsZXNbbmFtZV07XG4gICAgICAgIGxvY2FsZXNbbmFtZV0gPSBsb2NhbGU7XG5cbiAgICAgICAgLy8gYmFja3dhcmRzIGNvbXBhdCBmb3Igbm93OiBhbHNvIHNldCB0aGUgbG9jYWxlXG4gICAgICAgIGdldFNldEdsb2JhbExvY2FsZShuYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBwYXNzIG51bGwgZm9yIGNvbmZpZyB0byB1bnVwZGF0ZSwgdXNlZnVsIGZvciB0ZXN0c1xuICAgICAgICBpZiAobG9jYWxlc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAobG9jYWxlc1tuYW1lXS5wYXJlbnRMb2NhbGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGxvY2FsZXNbbmFtZV0gPSBsb2NhbGVzW25hbWVdLnBhcmVudExvY2FsZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobG9jYWxlc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGxvY2FsZXNbbmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGxvY2FsZXNbbmFtZV07XG59XG5cbi8vIHJldHVybnMgbG9jYWxlIGRhdGFcbmZ1bmN0aW9uIGdldExvY2FsZSAoa2V5KSB7XG4gICAgdmFyIGxvY2FsZTtcblxuICAgIGlmIChrZXkgJiYga2V5Ll9sb2NhbGUgJiYga2V5Ll9sb2NhbGUuX2FiYnIpIHtcbiAgICAgICAga2V5ID0ga2V5Ll9sb2NhbGUuX2FiYnI7XG4gICAgfVxuXG4gICAgaWYgKCFrZXkpIHtcbiAgICAgICAgcmV0dXJuIGdsb2JhbExvY2FsZTtcbiAgICB9XG5cbiAgICBpZiAoIWlzQXJyYXkoa2V5KSkge1xuICAgICAgICAvL3Nob3J0LWNpcmN1aXQgZXZlcnl0aGluZyBlbHNlXG4gICAgICAgIGxvY2FsZSA9IGxvYWRMb2NhbGUoa2V5KTtcbiAgICAgICAgaWYgKGxvY2FsZSkge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsZTtcbiAgICAgICAgfVxuICAgICAgICBrZXkgPSBba2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2hvb3NlTG9jYWxlKGtleSk7XG59XG5cbmZ1bmN0aW9uIGxpc3RMb2NhbGVzKCkge1xuICAgIHJldHVybiBrZXlzKGxvY2FsZXMpO1xufVxuXG5mdW5jdGlvbiBjaGVja092ZXJmbG93IChtKSB7XG4gICAgdmFyIG92ZXJmbG93O1xuICAgIHZhciBhID0gbS5fYTtcblxuICAgIGlmIChhICYmIGdldFBhcnNpbmdGbGFncyhtKS5vdmVyZmxvdyA9PT0gLTIpIHtcbiAgICAgICAgb3ZlcmZsb3cgPVxuICAgICAgICAgICAgYVtNT05USF0gICAgICAgPCAwIHx8IGFbTU9OVEhdICAgICAgID4gMTEgID8gTU9OVEggOlxuICAgICAgICAgICAgYVtEQVRFXSAgICAgICAgPCAxIHx8IGFbREFURV0gICAgICAgID4gZGF5c0luTW9udGgoYVtZRUFSXSwgYVtNT05USF0pID8gREFURSA6XG4gICAgICAgICAgICBhW0hPVVJdICAgICAgICA8IDAgfHwgYVtIT1VSXSAgICAgICAgPiAyNCB8fCAoYVtIT1VSXSA9PT0gMjQgJiYgKGFbTUlOVVRFXSAhPT0gMCB8fCBhW1NFQ09ORF0gIT09IDAgfHwgYVtNSUxMSVNFQ09ORF0gIT09IDApKSA/IEhPVVIgOlxuICAgICAgICAgICAgYVtNSU5VVEVdICAgICAgPCAwIHx8IGFbTUlOVVRFXSAgICAgID4gNTkgID8gTUlOVVRFIDpcbiAgICAgICAgICAgIGFbU0VDT05EXSAgICAgIDwgMCB8fCBhW1NFQ09ORF0gICAgICA+IDU5ICA/IFNFQ09ORCA6XG4gICAgICAgICAgICBhW01JTExJU0VDT05EXSA8IDAgfHwgYVtNSUxMSVNFQ09ORF0gPiA5OTkgPyBNSUxMSVNFQ09ORCA6XG4gICAgICAgICAgICAtMTtcblxuICAgICAgICBpZiAoZ2V0UGFyc2luZ0ZsYWdzKG0pLl9vdmVyZmxvd0RheU9mWWVhciAmJiAob3ZlcmZsb3cgPCBZRUFSIHx8IG92ZXJmbG93ID4gREFURSkpIHtcbiAgICAgICAgICAgIG92ZXJmbG93ID0gREFURTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ2V0UGFyc2luZ0ZsYWdzKG0pLl9vdmVyZmxvd1dlZWtzICYmIG92ZXJmbG93ID09PSAtMSkge1xuICAgICAgICAgICAgb3ZlcmZsb3cgPSBXRUVLO1xuICAgICAgICB9XG4gICAgICAgIGlmIChnZXRQYXJzaW5nRmxhZ3MobSkuX292ZXJmbG93V2Vla2RheSAmJiBvdmVyZmxvdyA9PT0gLTEpIHtcbiAgICAgICAgICAgIG92ZXJmbG93ID0gV0VFS0RBWTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhtKS5vdmVyZmxvdyA9IG92ZXJmbG93O1xuICAgIH1cblxuICAgIHJldHVybiBtO1xufVxuXG4vLyBQaWNrIHRoZSBmaXJzdCBkZWZpbmVkIG9mIHR3byBvciB0aHJlZSBhcmd1bWVudHMuXG5mdW5jdGlvbiBkZWZhdWx0cyhhLCBiLCBjKSB7XG4gICAgaWYgKGEgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gYTtcbiAgICB9XG4gICAgaWYgKGIgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gYjtcbiAgICB9XG4gICAgcmV0dXJuIGM7XG59XG5cbmZ1bmN0aW9uIGN1cnJlbnREYXRlQXJyYXkoY29uZmlnKSB7XG4gICAgLy8gaG9va3MgaXMgYWN0dWFsbHkgdGhlIGV4cG9ydGVkIG1vbWVudCBvYmplY3RcbiAgICB2YXIgbm93VmFsdWUgPSBuZXcgRGF0ZShob29rcy5ub3coKSk7XG4gICAgaWYgKGNvbmZpZy5fdXNlVVRDKSB7XG4gICAgICAgIHJldHVybiBbbm93VmFsdWUuZ2V0VVRDRnVsbFllYXIoKSwgbm93VmFsdWUuZ2V0VVRDTW9udGgoKSwgbm93VmFsdWUuZ2V0VVRDRGF0ZSgpXTtcbiAgICB9XG4gICAgcmV0dXJuIFtub3dWYWx1ZS5nZXRGdWxsWWVhcigpLCBub3dWYWx1ZS5nZXRNb250aCgpLCBub3dWYWx1ZS5nZXREYXRlKCldO1xufVxuXG4vLyBjb252ZXJ0IGFuIGFycmF5IHRvIGEgZGF0ZS5cbi8vIHRoZSBhcnJheSBzaG91bGQgbWlycm9yIHRoZSBwYXJhbWV0ZXJzIGJlbG93XG4vLyBub3RlOiBhbGwgdmFsdWVzIHBhc3QgdGhlIHllYXIgYXJlIG9wdGlvbmFsIGFuZCB3aWxsIGRlZmF1bHQgdG8gdGhlIGxvd2VzdCBwb3NzaWJsZSB2YWx1ZS5cbi8vIFt5ZWFyLCBtb250aCwgZGF5ICwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kXVxuZnVuY3Rpb24gY29uZmlnRnJvbUFycmF5IChjb25maWcpIHtcbiAgICB2YXIgaSwgZGF0ZSwgaW5wdXQgPSBbXSwgY3VycmVudERhdGUsIGV4cGVjdGVkV2Vla2RheSwgeWVhclRvVXNlO1xuXG4gICAgaWYgKGNvbmZpZy5fZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY3VycmVudERhdGUgPSBjdXJyZW50RGF0ZUFycmF5KGNvbmZpZyk7XG5cbiAgICAvL2NvbXB1dGUgZGF5IG9mIHRoZSB5ZWFyIGZyb20gd2Vla3MgYW5kIHdlZWtkYXlzXG4gICAgaWYgKGNvbmZpZy5fdyAmJiBjb25maWcuX2FbREFURV0gPT0gbnVsbCAmJiBjb25maWcuX2FbTU9OVEhdID09IG51bGwpIHtcbiAgICAgICAgZGF5T2ZZZWFyRnJvbVdlZWtJbmZvKGNvbmZpZyk7XG4gICAgfVxuXG4gICAgLy9pZiB0aGUgZGF5IG9mIHRoZSB5ZWFyIGlzIHNldCwgZmlndXJlIG91dCB3aGF0IGl0IGlzXG4gICAgaWYgKGNvbmZpZy5fZGF5T2ZZZWFyICE9IG51bGwpIHtcbiAgICAgICAgeWVhclRvVXNlID0gZGVmYXVsdHMoY29uZmlnLl9hW1lFQVJdLCBjdXJyZW50RGF0ZVtZRUFSXSk7XG5cbiAgICAgICAgaWYgKGNvbmZpZy5fZGF5T2ZZZWFyID4gZGF5c0luWWVhcih5ZWFyVG9Vc2UpIHx8IGNvbmZpZy5fZGF5T2ZZZWFyID09PSAwKSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5fb3ZlcmZsb3dEYXlPZlllYXIgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgZGF0ZSA9IGNyZWF0ZVVUQ0RhdGUoeWVhclRvVXNlLCAwLCBjb25maWcuX2RheU9mWWVhcik7XG4gICAgICAgIGNvbmZpZy5fYVtNT05USF0gPSBkYXRlLmdldFVUQ01vbnRoKCk7XG4gICAgICAgIGNvbmZpZy5fYVtEQVRFXSA9IGRhdGUuZ2V0VVRDRGF0ZSgpO1xuICAgIH1cblxuICAgIC8vIERlZmF1bHQgdG8gY3VycmVudCBkYXRlLlxuICAgIC8vICogaWYgbm8geWVhciwgbW9udGgsIGRheSBvZiBtb250aCBhcmUgZ2l2ZW4sIGRlZmF1bHQgdG8gdG9kYXlcbiAgICAvLyAqIGlmIGRheSBvZiBtb250aCBpcyBnaXZlbiwgZGVmYXVsdCBtb250aCBhbmQgeWVhclxuICAgIC8vICogaWYgbW9udGggaXMgZ2l2ZW4sIGRlZmF1bHQgb25seSB5ZWFyXG4gICAgLy8gKiBpZiB5ZWFyIGlzIGdpdmVuLCBkb24ndCBkZWZhdWx0IGFueXRoaW5nXG4gICAgZm9yIChpID0gMDsgaSA8IDMgJiYgY29uZmlnLl9hW2ldID09IG51bGw7ICsraSkge1xuICAgICAgICBjb25maWcuX2FbaV0gPSBpbnB1dFtpXSA9IGN1cnJlbnREYXRlW2ldO1xuICAgIH1cblxuICAgIC8vIFplcm8gb3V0IHdoYXRldmVyIHdhcyBub3QgZGVmYXVsdGVkLCBpbmNsdWRpbmcgdGltZVxuICAgIGZvciAoOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgIGNvbmZpZy5fYVtpXSA9IGlucHV0W2ldID0gKGNvbmZpZy5fYVtpXSA9PSBudWxsKSA/IChpID09PSAyID8gMSA6IDApIDogY29uZmlnLl9hW2ldO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciAyNDowMDowMC4wMDBcbiAgICBpZiAoY29uZmlnLl9hW0hPVVJdID09PSAyNCAmJlxuICAgICAgICAgICAgY29uZmlnLl9hW01JTlVURV0gPT09IDAgJiZcbiAgICAgICAgICAgIGNvbmZpZy5fYVtTRUNPTkRdID09PSAwICYmXG4gICAgICAgICAgICBjb25maWcuX2FbTUlMTElTRUNPTkRdID09PSAwKSB7XG4gICAgICAgIGNvbmZpZy5fbmV4dERheSA9IHRydWU7XG4gICAgICAgIGNvbmZpZy5fYVtIT1VSXSA9IDA7XG4gICAgfVxuXG4gICAgY29uZmlnLl9kID0gKGNvbmZpZy5fdXNlVVRDID8gY3JlYXRlVVRDRGF0ZSA6IGNyZWF0ZURhdGUpLmFwcGx5KG51bGwsIGlucHV0KTtcbiAgICBleHBlY3RlZFdlZWtkYXkgPSBjb25maWcuX3VzZVVUQyA/IGNvbmZpZy5fZC5nZXRVVENEYXkoKSA6IGNvbmZpZy5fZC5nZXREYXkoKTtcblxuICAgIC8vIEFwcGx5IHRpbWV6b25lIG9mZnNldCBmcm9tIGlucHV0LiBUaGUgYWN0dWFsIHV0Y09mZnNldCBjYW4gYmUgY2hhbmdlZFxuICAgIC8vIHdpdGggcGFyc2Vab25lLlxuICAgIGlmIChjb25maWcuX3R6bSAhPSBudWxsKSB7XG4gICAgICAgIGNvbmZpZy5fZC5zZXRVVENNaW51dGVzKGNvbmZpZy5fZC5nZXRVVENNaW51dGVzKCkgLSBjb25maWcuX3R6bSk7XG4gICAgfVxuXG4gICAgaWYgKGNvbmZpZy5fbmV4dERheSkge1xuICAgICAgICBjb25maWcuX2FbSE9VUl0gPSAyNDtcbiAgICB9XG5cbiAgICAvLyBjaGVjayBmb3IgbWlzbWF0Y2hpbmcgZGF5IG9mIHdlZWtcbiAgICBpZiAoY29uZmlnLl93ICYmIHR5cGVvZiBjb25maWcuX3cuZCAhPT0gJ3VuZGVmaW5lZCcgJiYgY29uZmlnLl93LmQgIT09IGV4cGVjdGVkV2Vla2RheSkge1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS53ZWVrZGF5TWlzbWF0Y2ggPSB0cnVlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZGF5T2ZZZWFyRnJvbVdlZWtJbmZvKGNvbmZpZykge1xuICAgIHZhciB3LCB3ZWVrWWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3ksIHRlbXAsIHdlZWtkYXlPdmVyZmxvdztcblxuICAgIHcgPSBjb25maWcuX3c7XG4gICAgaWYgKHcuR0cgIT0gbnVsbCB8fCB3LlcgIT0gbnVsbCB8fCB3LkUgIT0gbnVsbCkge1xuICAgICAgICBkb3cgPSAxO1xuICAgICAgICBkb3kgPSA0O1xuXG4gICAgICAgIC8vIFRPRE86IFdlIG5lZWQgdG8gdGFrZSB0aGUgY3VycmVudCBpc29XZWVrWWVhciwgYnV0IHRoYXQgZGVwZW5kcyBvblxuICAgICAgICAvLyBob3cgd2UgaW50ZXJwcmV0IG5vdyAobG9jYWwsIHV0YywgZml4ZWQgb2Zmc2V0KS4gU28gY3JlYXRlXG4gICAgICAgIC8vIGEgbm93IHZlcnNpb24gb2YgY3VycmVudCBjb25maWcgKHRha2UgbG9jYWwvdXRjL29mZnNldCBmbGFncywgYW5kXG4gICAgICAgIC8vIGNyZWF0ZSBub3cpLlxuICAgICAgICB3ZWVrWWVhciA9IGRlZmF1bHRzKHcuR0csIGNvbmZpZy5fYVtZRUFSXSwgd2Vla09mWWVhcihjcmVhdGVMb2NhbCgpLCAxLCA0KS55ZWFyKTtcbiAgICAgICAgd2VlayA9IGRlZmF1bHRzKHcuVywgMSk7XG4gICAgICAgIHdlZWtkYXkgPSBkZWZhdWx0cyh3LkUsIDEpO1xuICAgICAgICBpZiAod2Vla2RheSA8IDEgfHwgd2Vla2RheSA+IDcpIHtcbiAgICAgICAgICAgIHdlZWtkYXlPdmVyZmxvdyA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBkb3cgPSBjb25maWcuX2xvY2FsZS5fd2Vlay5kb3c7XG4gICAgICAgIGRveSA9IGNvbmZpZy5fbG9jYWxlLl93ZWVrLmRveTtcblxuICAgICAgICB2YXIgY3VyV2VlayA9IHdlZWtPZlllYXIoY3JlYXRlTG9jYWwoKSwgZG93LCBkb3kpO1xuXG4gICAgICAgIHdlZWtZZWFyID0gZGVmYXVsdHMody5nZywgY29uZmlnLl9hW1lFQVJdLCBjdXJXZWVrLnllYXIpO1xuXG4gICAgICAgIC8vIERlZmF1bHQgdG8gY3VycmVudCB3ZWVrLlxuICAgICAgICB3ZWVrID0gZGVmYXVsdHMody53LCBjdXJXZWVrLndlZWspO1xuXG4gICAgICAgIGlmICh3LmQgIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gd2Vla2RheSAtLSBsb3cgZGF5IG51bWJlcnMgYXJlIGNvbnNpZGVyZWQgbmV4dCB3ZWVrXG4gICAgICAgICAgICB3ZWVrZGF5ID0gdy5kO1xuICAgICAgICAgICAgaWYgKHdlZWtkYXkgPCAwIHx8IHdlZWtkYXkgPiA2KSB7XG4gICAgICAgICAgICAgICAgd2Vla2RheU92ZXJmbG93ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh3LmUgIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gbG9jYWwgd2Vla2RheSAtLSBjb3VudGluZyBzdGFydHMgZnJvbSBiZWdpbmluZyBvZiB3ZWVrXG4gICAgICAgICAgICB3ZWVrZGF5ID0gdy5lICsgZG93O1xuICAgICAgICAgICAgaWYgKHcuZSA8IDAgfHwgdy5lID4gNikge1xuICAgICAgICAgICAgICAgIHdlZWtkYXlPdmVyZmxvdyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBkZWZhdWx0IHRvIGJlZ2luaW5nIG9mIHdlZWtcbiAgICAgICAgICAgIHdlZWtkYXkgPSBkb3c7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHdlZWsgPCAxIHx8IHdlZWsgPiB3ZWVrc0luWWVhcih3ZWVrWWVhciwgZG93LCBkb3kpKSB7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLl9vdmVyZmxvd1dlZWtzID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHdlZWtkYXlPdmVyZmxvdyAhPSBudWxsKSB7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLl9vdmVyZmxvd1dlZWtkYXkgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRlbXAgPSBkYXlPZlllYXJGcm9tV2Vla3Mod2Vla1llYXIsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KTtcbiAgICAgICAgY29uZmlnLl9hW1lFQVJdID0gdGVtcC55ZWFyO1xuICAgICAgICBjb25maWcuX2RheU9mWWVhciA9IHRlbXAuZGF5T2ZZZWFyO1xuICAgIH1cbn1cblxuLy8gaXNvIDg2MDEgcmVnZXhcbi8vIDAwMDAtMDAtMDAgMDAwMC1XMDAgb3IgMDAwMC1XMDAtMCArIFQgKyAwMCBvciAwMDowMCBvciAwMDowMDowMCBvciAwMDowMDowMC4wMDAgKyArMDA6MDAgb3IgKzAwMDAgb3IgKzAwKVxudmFyIGV4dGVuZGVkSXNvUmVnZXggPSAvXlxccyooKD86WystXVxcZHs2fXxcXGR7NH0pLSg/OlxcZFxcZC1cXGRcXGR8V1xcZFxcZC1cXGR8V1xcZFxcZHxcXGRcXGRcXGR8XFxkXFxkKSkoPzooVHwgKShcXGRcXGQoPzo6XFxkXFxkKD86OlxcZFxcZCg/OlsuLF1cXGQrKT8pPyk/KShbXFwrXFwtXVxcZFxcZCg/Ojo/XFxkXFxkKT98XFxzKlopPyk/JC87XG52YXIgYmFzaWNJc29SZWdleCA9IC9eXFxzKigoPzpbKy1dXFxkezZ9fFxcZHs0fSkoPzpcXGRcXGRcXGRcXGR8V1xcZFxcZFxcZHxXXFxkXFxkfFxcZFxcZFxcZHxcXGRcXGQpKSg/OihUfCApKFxcZFxcZCg/OlxcZFxcZCg/OlxcZFxcZCg/OlsuLF1cXGQrKT8pPyk/KShbXFwrXFwtXVxcZFxcZCg/Ojo/XFxkXFxkKT98XFxzKlopPyk/JC87XG5cbnZhciB0elJlZ2V4ID0gL1p8WystXVxcZFxcZCg/Ojo/XFxkXFxkKT8vO1xuXG52YXIgaXNvRGF0ZXMgPSBbXG4gICAgWydZWVlZWVktTU0tREQnLCAvWystXVxcZHs2fS1cXGRcXGQtXFxkXFxkL10sXG4gICAgWydZWVlZLU1NLUREJywgL1xcZHs0fS1cXGRcXGQtXFxkXFxkL10sXG4gICAgWydHR0dHLVtXXVdXLUUnLCAvXFxkezR9LVdcXGRcXGQtXFxkL10sXG4gICAgWydHR0dHLVtXXVdXJywgL1xcZHs0fS1XXFxkXFxkLywgZmFsc2VdLFxuICAgIFsnWVlZWS1EREQnLCAvXFxkezR9LVxcZHszfS9dLFxuICAgIFsnWVlZWS1NTScsIC9cXGR7NH0tXFxkXFxkLywgZmFsc2VdLFxuICAgIFsnWVlZWVlZTU1ERCcsIC9bKy1dXFxkezEwfS9dLFxuICAgIFsnWVlZWU1NREQnLCAvXFxkezh9L10sXG4gICAgLy8gWVlZWU1NIGlzIE5PVCBhbGxvd2VkIGJ5IHRoZSBzdGFuZGFyZFxuICAgIFsnR0dHR1tXXVdXRScsIC9cXGR7NH1XXFxkezN9L10sXG4gICAgWydHR0dHW1ddV1cnLCAvXFxkezR9V1xcZHsyfS8sIGZhbHNlXSxcbiAgICBbJ1lZWVlEREQnLCAvXFxkezd9L11cbl07XG5cbi8vIGlzbyB0aW1lIGZvcm1hdHMgYW5kIHJlZ2V4ZXNcbnZhciBpc29UaW1lcyA9IFtcbiAgICBbJ0hIOm1tOnNzLlNTU1MnLCAvXFxkXFxkOlxcZFxcZDpcXGRcXGRcXC5cXGQrL10sXG4gICAgWydISDptbTpzcyxTU1NTJywgL1xcZFxcZDpcXGRcXGQ6XFxkXFxkLFxcZCsvXSxcbiAgICBbJ0hIOm1tOnNzJywgL1xcZFxcZDpcXGRcXGQ6XFxkXFxkL10sXG4gICAgWydISDptbScsIC9cXGRcXGQ6XFxkXFxkL10sXG4gICAgWydISG1tc3MuU1NTUycsIC9cXGRcXGRcXGRcXGRcXGRcXGRcXC5cXGQrL10sXG4gICAgWydISG1tc3MsU1NTUycsIC9cXGRcXGRcXGRcXGRcXGRcXGQsXFxkKy9dLFxuICAgIFsnSEhtbXNzJywgL1xcZFxcZFxcZFxcZFxcZFxcZC9dLFxuICAgIFsnSEhtbScsIC9cXGRcXGRcXGRcXGQvXSxcbiAgICBbJ0hIJywgL1xcZFxcZC9dXG5dO1xuXG52YXIgYXNwTmV0SnNvblJlZ2V4ID0gL15cXC8/RGF0ZVxcKChcXC0/XFxkKykvaTtcblxuLy8gZGF0ZSBmcm9tIGlzbyBmb3JtYXRcbmZ1bmN0aW9uIGNvbmZpZ0Zyb21JU08oY29uZmlnKSB7XG4gICAgdmFyIGksIGwsXG4gICAgICAgIHN0cmluZyA9IGNvbmZpZy5faSxcbiAgICAgICAgbWF0Y2ggPSBleHRlbmRlZElzb1JlZ2V4LmV4ZWMoc3RyaW5nKSB8fCBiYXNpY0lzb1JlZ2V4LmV4ZWMoc3RyaW5nKSxcbiAgICAgICAgYWxsb3dUaW1lLCBkYXRlRm9ybWF0LCB0aW1lRm9ybWF0LCB0ekZvcm1hdDtcblxuICAgIGlmIChtYXRjaCkge1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5pc28gPSB0cnVlO1xuXG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSBpc29EYXRlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpc29EYXRlc1tpXVsxXS5leGVjKG1hdGNoWzFdKSkge1xuICAgICAgICAgICAgICAgIGRhdGVGb3JtYXQgPSBpc29EYXRlc1tpXVswXTtcbiAgICAgICAgICAgICAgICBhbGxvd1RpbWUgPSBpc29EYXRlc1tpXVsyXSAhPT0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGVGb3JtYXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hdGNoWzNdKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gaXNvVGltZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzb1RpbWVzW2ldWzFdLmV4ZWMobWF0Y2hbM10pKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG1hdGNoWzJdIHNob3VsZCBiZSAnVCcgb3Igc3BhY2VcbiAgICAgICAgICAgICAgICAgICAgdGltZUZvcm1hdCA9IChtYXRjaFsyXSB8fCAnICcpICsgaXNvVGltZXNbaV1bMF07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aW1lRm9ybWF0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFhbGxvd1RpbWUgJiYgdGltZUZvcm1hdCAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF0Y2hbNF0pIHtcbiAgICAgICAgICAgIGlmICh0elJlZ2V4LmV4ZWMobWF0Y2hbNF0pKSB7XG4gICAgICAgICAgICAgICAgdHpGb3JtYXQgPSAnWic7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25maWcuX2YgPSBkYXRlRm9ybWF0ICsgKHRpbWVGb3JtYXQgfHwgJycpICsgKHR6Rm9ybWF0IHx8ICcnKTtcbiAgICAgICAgY29uZmlnRnJvbVN0cmluZ0FuZEZvcm1hdChjb25maWcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgIH1cbn1cblxuLy8gUkZDIDI4MjIgcmVnZXg6IEZvciBkZXRhaWxzIHNlZSBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMjgyMiNzZWN0aW9uLTMuM1xudmFyIHJmYzI4MjIgPSAvXig/OihNb258VHVlfFdlZHxUaHV8RnJpfFNhdHxTdW4pLD9cXHMpPyhcXGR7MSwyfSlcXHMoSmFufEZlYnxNYXJ8QXByfE1heXxKdW58SnVsfEF1Z3xTZXB8T2N0fE5vdnxEZWMpXFxzKFxcZHsyLDR9KVxccyhcXGRcXGQpOihcXGRcXGQpKD86OihcXGRcXGQpKT9cXHMoPzooVVR8R01UfFtFQ01QXVtTRF1UKXwoW1p6XSl8KFsrLV1cXGR7NH0pKSQvO1xuXG5mdW5jdGlvbiBleHRyYWN0RnJvbVJGQzI4MjJTdHJpbmdzKHllYXJTdHIsIG1vbnRoU3RyLCBkYXlTdHIsIGhvdXJTdHIsIG1pbnV0ZVN0ciwgc2Vjb25kU3RyKSB7XG4gICAgdmFyIHJlc3VsdCA9IFtcbiAgICAgICAgdW50cnVuY2F0ZVllYXIoeWVhclN0ciksXG4gICAgICAgIGRlZmF1bHRMb2NhbGVNb250aHNTaG9ydC5pbmRleE9mKG1vbnRoU3RyKSxcbiAgICAgICAgcGFyc2VJbnQoZGF5U3RyLCAxMCksXG4gICAgICAgIHBhcnNlSW50KGhvdXJTdHIsIDEwKSxcbiAgICAgICAgcGFyc2VJbnQobWludXRlU3RyLCAxMClcbiAgICBdO1xuXG4gICAgaWYgKHNlY29uZFN0cikge1xuICAgICAgICByZXN1bHQucHVzaChwYXJzZUludChzZWNvbmRTdHIsIDEwKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gdW50cnVuY2F0ZVllYXIoeWVhclN0cikge1xuICAgIHZhciB5ZWFyID0gcGFyc2VJbnQoeWVhclN0ciwgMTApO1xuICAgIGlmICh5ZWFyIDw9IDQ5KSB7XG4gICAgICAgIHJldHVybiAyMDAwICsgeWVhcjtcbiAgICB9IGVsc2UgaWYgKHllYXIgPD0gOTk5KSB7XG4gICAgICAgIHJldHVybiAxOTAwICsgeWVhcjtcbiAgICB9XG4gICAgcmV0dXJuIHllYXI7XG59XG5cbmZ1bmN0aW9uIHByZXByb2Nlc3NSRkMyODIyKHMpIHtcbiAgICAvLyBSZW1vdmUgY29tbWVudHMgYW5kIGZvbGRpbmcgd2hpdGVzcGFjZSBhbmQgcmVwbGFjZSBtdWx0aXBsZS1zcGFjZXMgd2l0aCBhIHNpbmdsZSBzcGFjZVxuICAgIHJldHVybiBzLnJlcGxhY2UoL1xcKFteKV0qXFwpfFtcXG5cXHRdL2csICcgJykucmVwbGFjZSgvKFxcc1xccyspL2csICcgJykudHJpbSgpO1xufVxuXG5mdW5jdGlvbiBjaGVja1dlZWtkYXkod2Vla2RheVN0ciwgcGFyc2VkSW5wdXQsIGNvbmZpZykge1xuICAgIGlmICh3ZWVrZGF5U3RyKSB7XG4gICAgICAgIC8vIFRPRE86IFJlcGxhY2UgdGhlIHZhbmlsbGEgSlMgRGF0ZSBvYmplY3Qgd2l0aCBhbiBpbmRlcGVudGVudCBkYXktb2Ytd2VlayBjaGVjay5cbiAgICAgICAgdmFyIHdlZWtkYXlQcm92aWRlZCA9IGRlZmF1bHRMb2NhbGVXZWVrZGF5c1Nob3J0LmluZGV4T2Yod2Vla2RheVN0ciksXG4gICAgICAgICAgICB3ZWVrZGF5QWN0dWFsID0gbmV3IERhdGUocGFyc2VkSW5wdXRbMF0sIHBhcnNlZElucHV0WzFdLCBwYXJzZWRJbnB1dFsyXSkuZ2V0RGF5KCk7XG4gICAgICAgIGlmICh3ZWVrZGF5UHJvdmlkZWQgIT09IHdlZWtkYXlBY3R1YWwpIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLndlZWtkYXlNaXNtYXRjaCA9IHRydWU7XG4gICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxudmFyIG9ic09mZnNldHMgPSB7XG4gICAgVVQ6IDAsXG4gICAgR01UOiAwLFxuICAgIEVEVDogLTQgKiA2MCxcbiAgICBFU1Q6IC01ICogNjAsXG4gICAgQ0RUOiAtNSAqIDYwLFxuICAgIENTVDogLTYgKiA2MCxcbiAgICBNRFQ6IC02ICogNjAsXG4gICAgTVNUOiAtNyAqIDYwLFxuICAgIFBEVDogLTcgKiA2MCxcbiAgICBQU1Q6IC04ICogNjBcbn07XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZU9mZnNldChvYnNPZmZzZXQsIG1pbGl0YXJ5T2Zmc2V0LCBudW1PZmZzZXQpIHtcbiAgICBpZiAob2JzT2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiBvYnNPZmZzZXRzW29ic09mZnNldF07XG4gICAgfSBlbHNlIGlmIChtaWxpdGFyeU9mZnNldCkge1xuICAgICAgICAvLyB0aGUgb25seSBhbGxvd2VkIG1pbGl0YXJ5IHR6IGlzIFpcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGhtID0gcGFyc2VJbnQobnVtT2Zmc2V0LCAxMCk7XG4gICAgICAgIHZhciBtID0gaG0gJSAxMDAsIGggPSAoaG0gLSBtKSAvIDEwMDtcbiAgICAgICAgcmV0dXJuIGggKiA2MCArIG07XG4gICAgfVxufVxuXG4vLyBkYXRlIGFuZCB0aW1lIGZyb20gcmVmIDI4MjIgZm9ybWF0XG5mdW5jdGlvbiBjb25maWdGcm9tUkZDMjgyMihjb25maWcpIHtcbiAgICB2YXIgbWF0Y2ggPSByZmMyODIyLmV4ZWMocHJlcHJvY2Vzc1JGQzI4MjIoY29uZmlnLl9pKSk7XG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIHZhciBwYXJzZWRBcnJheSA9IGV4dHJhY3RGcm9tUkZDMjgyMlN0cmluZ3MobWF0Y2hbNF0sIG1hdGNoWzNdLCBtYXRjaFsyXSwgbWF0Y2hbNV0sIG1hdGNoWzZdLCBtYXRjaFs3XSk7XG4gICAgICAgIGlmICghY2hlY2tXZWVrZGF5KG1hdGNoWzFdLCBwYXJzZWRBcnJheSwgY29uZmlnKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uZmlnLl9hID0gcGFyc2VkQXJyYXk7XG4gICAgICAgIGNvbmZpZy5fdHptID0gY2FsY3VsYXRlT2Zmc2V0KG1hdGNoWzhdLCBtYXRjaFs5XSwgbWF0Y2hbMTBdKTtcblxuICAgICAgICBjb25maWcuX2QgPSBjcmVhdGVVVENEYXRlLmFwcGx5KG51bGwsIGNvbmZpZy5fYSk7XG4gICAgICAgIGNvbmZpZy5fZC5zZXRVVENNaW51dGVzKGNvbmZpZy5fZC5nZXRVVENNaW51dGVzKCkgLSBjb25maWcuX3R6bSk7XG5cbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykucmZjMjgyMiA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgfVxufVxuXG4vLyBkYXRlIGZyb20gaXNvIGZvcm1hdCBvciBmYWxsYmFja1xuZnVuY3Rpb24gY29uZmlnRnJvbVN0cmluZyhjb25maWcpIHtcbiAgICB2YXIgbWF0Y2hlZCA9IGFzcE5ldEpzb25SZWdleC5leGVjKGNvbmZpZy5faSk7XG5cbiAgICBpZiAobWF0Y2hlZCAhPT0gbnVsbCkge1xuICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZSgrbWF0Y2hlZFsxXSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25maWdGcm9tSVNPKGNvbmZpZyk7XG4gICAgaWYgKGNvbmZpZy5faXNWYWxpZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgZGVsZXRlIGNvbmZpZy5faXNWYWxpZDtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uZmlnRnJvbVJGQzI4MjIoY29uZmlnKTtcbiAgICBpZiAoY29uZmlnLl9pc1ZhbGlkID09PSBmYWxzZSkge1xuICAgICAgICBkZWxldGUgY29uZmlnLl9pc1ZhbGlkO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBGaW5hbCBhdHRlbXB0LCB1c2UgSW5wdXQgRmFsbGJhY2tcbiAgICBob29rcy5jcmVhdGVGcm9tSW5wdXRGYWxsYmFjayhjb25maWcpO1xufVxuXG5ob29rcy5jcmVhdGVGcm9tSW5wdXRGYWxsYmFjayA9IGRlcHJlY2F0ZShcbiAgICAndmFsdWUgcHJvdmlkZWQgaXMgbm90IGluIGEgcmVjb2duaXplZCBSRkMyODIyIG9yIElTTyBmb3JtYXQuIG1vbWVudCBjb25zdHJ1Y3Rpb24gZmFsbHMgYmFjayB0byBqcyBEYXRlKCksICcgK1xuICAgICd3aGljaCBpcyBub3QgcmVsaWFibGUgYWNyb3NzIGFsbCBicm93c2VycyBhbmQgdmVyc2lvbnMuIE5vbiBSRkMyODIyL0lTTyBkYXRlIGZvcm1hdHMgYXJlICcgK1xuICAgICdkaXNjb3VyYWdlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGFuIHVwY29taW5nIG1ham9yIHJlbGVhc2UuIFBsZWFzZSByZWZlciB0byAnICtcbiAgICAnaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9qcy1kYXRlLyBmb3IgbW9yZSBpbmZvLicsXG4gICAgZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShjb25maWcuX2kgKyAoY29uZmlnLl91c2VVVEMgPyAnIFVUQycgOiAnJykpO1xuICAgIH1cbik7XG5cbi8vIGNvbnN0YW50IHRoYXQgcmVmZXJzIHRvIHRoZSBJU08gc3RhbmRhcmRcbmhvb2tzLklTT184NjAxID0gZnVuY3Rpb24gKCkge307XG5cbi8vIGNvbnN0YW50IHRoYXQgcmVmZXJzIHRvIHRoZSBSRkMgMjgyMiBmb3JtXG5ob29rcy5SRkNfMjgyMiA9IGZ1bmN0aW9uICgpIHt9O1xuXG4vLyBkYXRlIGZyb20gc3RyaW5nIGFuZCBmb3JtYXQgc3RyaW5nXG5mdW5jdGlvbiBjb25maWdGcm9tU3RyaW5nQW5kRm9ybWF0KGNvbmZpZykge1xuICAgIC8vIFRPRE86IE1vdmUgdGhpcyB0byBhbm90aGVyIHBhcnQgb2YgdGhlIGNyZWF0aW9uIGZsb3cgdG8gcHJldmVudCBjaXJjdWxhciBkZXBzXG4gICAgaWYgKGNvbmZpZy5fZiA9PT0gaG9va3MuSVNPXzg2MDEpIHtcbiAgICAgICAgY29uZmlnRnJvbUlTTyhjb25maWcpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChjb25maWcuX2YgPT09IGhvb2tzLlJGQ18yODIyKSB7XG4gICAgICAgIGNvbmZpZ0Zyb21SRkMyODIyKGNvbmZpZyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uZmlnLl9hID0gW107XG4gICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuZW1wdHkgPSB0cnVlO1xuXG4gICAgLy8gVGhpcyBhcnJheSBpcyB1c2VkIHRvIG1ha2UgYSBEYXRlLCBlaXRoZXIgd2l0aCBgbmV3IERhdGVgIG9yIGBEYXRlLlVUQ2BcbiAgICB2YXIgc3RyaW5nID0gJycgKyBjb25maWcuX2ksXG4gICAgICAgIGksIHBhcnNlZElucHV0LCB0b2tlbnMsIHRva2VuLCBza2lwcGVkLFxuICAgICAgICBzdHJpbmdMZW5ndGggPSBzdHJpbmcubGVuZ3RoLFxuICAgICAgICB0b3RhbFBhcnNlZElucHV0TGVuZ3RoID0gMDtcblxuICAgIHRva2VucyA9IGV4cGFuZEZvcm1hdChjb25maWcuX2YsIGNvbmZpZy5fbG9jYWxlKS5tYXRjaChmb3JtYXR0aW5nVG9rZW5zKSB8fCBbXTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdG9rZW4gPSB0b2tlbnNbaV07XG4gICAgICAgIHBhcnNlZElucHV0ID0gKHN0cmluZy5tYXRjaChnZXRQYXJzZVJlZ2V4Rm9yVG9rZW4odG9rZW4sIGNvbmZpZykpIHx8IFtdKVswXTtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ3Rva2VuJywgdG9rZW4sICdwYXJzZWRJbnB1dCcsIHBhcnNlZElucHV0LFxuICAgICAgICAvLyAgICAgICAgICdyZWdleCcsIGdldFBhcnNlUmVnZXhGb3JUb2tlbih0b2tlbiwgY29uZmlnKSk7XG4gICAgICAgIGlmIChwYXJzZWRJbnB1dCkge1xuICAgICAgICAgICAgc2tpcHBlZCA9IHN0cmluZy5zdWJzdHIoMCwgc3RyaW5nLmluZGV4T2YocGFyc2VkSW5wdXQpKTtcbiAgICAgICAgICAgIGlmIChza2lwcGVkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS51bnVzZWRJbnB1dC5wdXNoKHNraXBwZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RyaW5nID0gc3RyaW5nLnNsaWNlKHN0cmluZy5pbmRleE9mKHBhcnNlZElucHV0KSArIHBhcnNlZElucHV0Lmxlbmd0aCk7XG4gICAgICAgICAgICB0b3RhbFBhcnNlZElucHV0TGVuZ3RoICs9IHBhcnNlZElucHV0Lmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICAvLyBkb24ndCBwYXJzZSBpZiBpdCdzIG5vdCBhIGtub3duIHRva2VuXG4gICAgICAgIGlmIChmb3JtYXRUb2tlbkZ1bmN0aW9uc1t0b2tlbl0pIHtcbiAgICAgICAgICAgIGlmIChwYXJzZWRJbnB1dCkge1xuICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmVtcHR5ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS51bnVzZWRUb2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhZGRUaW1lVG9BcnJheUZyb21Ub2tlbih0b2tlbiwgcGFyc2VkSW5wdXQsIGNvbmZpZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29uZmlnLl9zdHJpY3QgJiYgIXBhcnNlZElucHV0KSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS51bnVzZWRUb2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhZGQgcmVtYWluaW5nIHVucGFyc2VkIGlucHV0IGxlbmd0aCB0byB0aGUgc3RyaW5nXG4gICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuY2hhcnNMZWZ0T3ZlciA9IHN0cmluZ0xlbmd0aCAtIHRvdGFsUGFyc2VkSW5wdXRMZW5ndGg7XG4gICAgaWYgKHN0cmluZy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnVudXNlZElucHV0LnB1c2goc3RyaW5nKTtcbiAgICB9XG5cbiAgICAvLyBjbGVhciBfMTJoIGZsYWcgaWYgaG91ciBpcyA8PSAxMlxuICAgIGlmIChjb25maWcuX2FbSE9VUl0gPD0gMTIgJiZcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9PT0gdHJ1ZSAmJlxuICAgICAgICBjb25maWcuX2FbSE9VUl0gPiAwKSB7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykucGFyc2VkRGF0ZVBhcnRzID0gY29uZmlnLl9hLnNsaWNlKDApO1xuICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLm1lcmlkaWVtID0gY29uZmlnLl9tZXJpZGllbTtcbiAgICAvLyBoYW5kbGUgbWVyaWRpZW1cbiAgICBjb25maWcuX2FbSE9VUl0gPSBtZXJpZGllbUZpeFdyYXAoY29uZmlnLl9sb2NhbGUsIGNvbmZpZy5fYVtIT1VSXSwgY29uZmlnLl9tZXJpZGllbSk7XG5cbiAgICBjb25maWdGcm9tQXJyYXkoY29uZmlnKTtcbiAgICBjaGVja092ZXJmbG93KGNvbmZpZyk7XG59XG5cblxuZnVuY3Rpb24gbWVyaWRpZW1GaXhXcmFwIChsb2NhbGUsIGhvdXIsIG1lcmlkaWVtKSB7XG4gICAgdmFyIGlzUG07XG5cbiAgICBpZiAobWVyaWRpZW0gPT0gbnVsbCkge1xuICAgICAgICAvLyBub3RoaW5nIHRvIGRvXG4gICAgICAgIHJldHVybiBob3VyO1xuICAgIH1cbiAgICBpZiAobG9jYWxlLm1lcmlkaWVtSG91ciAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUubWVyaWRpZW1Ib3VyKGhvdXIsIG1lcmlkaWVtKTtcbiAgICB9IGVsc2UgaWYgKGxvY2FsZS5pc1BNICE9IG51bGwpIHtcbiAgICAgICAgLy8gRmFsbGJhY2tcbiAgICAgICAgaXNQbSA9IGxvY2FsZS5pc1BNKG1lcmlkaWVtKTtcbiAgICAgICAgaWYgKGlzUG0gJiYgaG91ciA8IDEyKSB7XG4gICAgICAgICAgICBob3VyICs9IDEyO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNQbSAmJiBob3VyID09PSAxMikge1xuICAgICAgICAgICAgaG91ciA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhvdXI7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gdGhpcyBpcyBub3Qgc3VwcG9zZWQgdG8gaGFwcGVuXG4gICAgICAgIHJldHVybiBob3VyO1xuICAgIH1cbn1cblxuLy8gZGF0ZSBmcm9tIHN0cmluZyBhbmQgYXJyYXkgb2YgZm9ybWF0IHN0cmluZ3NcbmZ1bmN0aW9uIGNvbmZpZ0Zyb21TdHJpbmdBbmRBcnJheShjb25maWcpIHtcbiAgICB2YXIgdGVtcENvbmZpZyxcbiAgICAgICAgYmVzdE1vbWVudCxcblxuICAgICAgICBzY29yZVRvQmVhdCxcbiAgICAgICAgaSxcbiAgICAgICAgY3VycmVudFNjb3JlO1xuXG4gICAgaWYgKGNvbmZpZy5fZi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuaW52YWxpZEZvcm1hdCA9IHRydWU7XG4gICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKE5hTik7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgY29uZmlnLl9mLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGN1cnJlbnRTY29yZSA9IDA7XG4gICAgICAgIHRlbXBDb25maWcgPSBjb3B5Q29uZmlnKHt9LCBjb25maWcpO1xuICAgICAgICBpZiAoY29uZmlnLl91c2VVVEMgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGVtcENvbmZpZy5fdXNlVVRDID0gY29uZmlnLl91c2VVVEM7XG4gICAgICAgIH1cbiAgICAgICAgdGVtcENvbmZpZy5fZiA9IGNvbmZpZy5fZltpXTtcbiAgICAgICAgY29uZmlnRnJvbVN0cmluZ0FuZEZvcm1hdCh0ZW1wQ29uZmlnKTtcblxuICAgICAgICBpZiAoIWlzVmFsaWQodGVtcENvbmZpZykpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgdGhlcmUgaXMgYW55IGlucHV0IHRoYXQgd2FzIG5vdCBwYXJzZWQgYWRkIGEgcGVuYWx0eSBmb3IgdGhhdCBmb3JtYXRcbiAgICAgICAgY3VycmVudFNjb3JlICs9IGdldFBhcnNpbmdGbGFncyh0ZW1wQ29uZmlnKS5jaGFyc0xlZnRPdmVyO1xuXG4gICAgICAgIC8vb3IgdG9rZW5zXG4gICAgICAgIGN1cnJlbnRTY29yZSArPSBnZXRQYXJzaW5nRmxhZ3ModGVtcENvbmZpZykudW51c2VkVG9rZW5zLmxlbmd0aCAqIDEwO1xuXG4gICAgICAgIGdldFBhcnNpbmdGbGFncyh0ZW1wQ29uZmlnKS5zY29yZSA9IGN1cnJlbnRTY29yZTtcblxuICAgICAgICBpZiAoc2NvcmVUb0JlYXQgPT0gbnVsbCB8fCBjdXJyZW50U2NvcmUgPCBzY29yZVRvQmVhdCkge1xuICAgICAgICAgICAgc2NvcmVUb0JlYXQgPSBjdXJyZW50U2NvcmU7XG4gICAgICAgICAgICBiZXN0TW9tZW50ID0gdGVtcENvbmZpZztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGV4dGVuZChjb25maWcsIGJlc3RNb21lbnQgfHwgdGVtcENvbmZpZyk7XG59XG5cbmZ1bmN0aW9uIGNvbmZpZ0Zyb21PYmplY3QoY29uZmlnKSB7XG4gICAgaWYgKGNvbmZpZy5fZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGkgPSBub3JtYWxpemVPYmplY3RVbml0cyhjb25maWcuX2kpO1xuICAgIGNvbmZpZy5fYSA9IG1hcChbaS55ZWFyLCBpLm1vbnRoLCBpLmRheSB8fCBpLmRhdGUsIGkuaG91ciwgaS5taW51dGUsIGkuc2Vjb25kLCBpLm1pbGxpc2Vjb25kXSwgZnVuY3Rpb24gKG9iaikge1xuICAgICAgICByZXR1cm4gb2JqICYmIHBhcnNlSW50KG9iaiwgMTApO1xuICAgIH0pO1xuXG4gICAgY29uZmlnRnJvbUFycmF5KGNvbmZpZyk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZyb21Db25maWcgKGNvbmZpZykge1xuICAgIHZhciByZXMgPSBuZXcgTW9tZW50KGNoZWNrT3ZlcmZsb3cocHJlcGFyZUNvbmZpZyhjb25maWcpKSk7XG4gICAgaWYgKHJlcy5fbmV4dERheSkge1xuICAgICAgICAvLyBBZGRpbmcgaXMgc21hcnQgZW5vdWdoIGFyb3VuZCBEU1RcbiAgICAgICAgcmVzLmFkZCgxLCAnZCcpO1xuICAgICAgICByZXMuX25leHREYXkgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcztcbn1cblxuZnVuY3Rpb24gcHJlcGFyZUNvbmZpZyAoY29uZmlnKSB7XG4gICAgdmFyIGlucHV0ID0gY29uZmlnLl9pLFxuICAgICAgICBmb3JtYXQgPSBjb25maWcuX2Y7XG5cbiAgICBjb25maWcuX2xvY2FsZSA9IGNvbmZpZy5fbG9jYWxlIHx8IGdldExvY2FsZShjb25maWcuX2wpO1xuXG4gICAgaWYgKGlucHV0ID09PSBudWxsIHx8IChmb3JtYXQgPT09IHVuZGVmaW5lZCAmJiBpbnB1dCA9PT0gJycpKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVJbnZhbGlkKHtudWxsSW5wdXQ6IHRydWV9KTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICBjb25maWcuX2kgPSBpbnB1dCA9IGNvbmZpZy5fbG9jYWxlLnByZXBhcnNlKGlucHV0KTtcbiAgICB9XG5cbiAgICBpZiAoaXNNb21lbnQoaW5wdXQpKSB7XG4gICAgICAgIHJldHVybiBuZXcgTW9tZW50KGNoZWNrT3ZlcmZsb3coaW5wdXQpKTtcbiAgICB9IGVsc2UgaWYgKGlzRGF0ZShpbnB1dCkpIHtcbiAgICAgICAgY29uZmlnLl9kID0gaW5wdXQ7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KGZvcm1hdCkpIHtcbiAgICAgICAgY29uZmlnRnJvbVN0cmluZ0FuZEFycmF5KGNvbmZpZyk7XG4gICAgfSBlbHNlIGlmIChmb3JtYXQpIHtcbiAgICAgICAgY29uZmlnRnJvbVN0cmluZ0FuZEZvcm1hdChjb25maWcpO1xuICAgIH0gIGVsc2Uge1xuICAgICAgICBjb25maWdGcm9tSW5wdXQoY29uZmlnKTtcbiAgICB9XG5cbiAgICBpZiAoIWlzVmFsaWQoY29uZmlnKSkge1xuICAgICAgICBjb25maWcuX2QgPSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBjb25maWc7XG59XG5cbmZ1bmN0aW9uIGNvbmZpZ0Zyb21JbnB1dChjb25maWcpIHtcbiAgICB2YXIgaW5wdXQgPSBjb25maWcuX2k7XG4gICAgaWYgKGlzVW5kZWZpbmVkKGlucHV0KSkge1xuICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShob29rcy5ub3coKSk7XG4gICAgfSBlbHNlIGlmIChpc0RhdGUoaW5wdXQpKSB7XG4gICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKGlucHV0LnZhbHVlT2YoKSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNvbmZpZ0Zyb21TdHJpbmcoY29uZmlnKTtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgIGNvbmZpZy5fYSA9IG1hcChpbnB1dC5zbGljZSgwKSwgZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KG9iaiwgMTApO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uZmlnRnJvbUFycmF5KGNvbmZpZyk7XG4gICAgfSBlbHNlIGlmIChpc09iamVjdChpbnB1dCkpIHtcbiAgICAgICAgY29uZmlnRnJvbU9iamVjdChjb25maWcpO1xuICAgIH0gZWxzZSBpZiAoaXNOdW1iZXIoaW5wdXQpKSB7XG4gICAgICAgIC8vIGZyb20gbWlsbGlzZWNvbmRzXG4gICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKGlucHV0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBob29rcy5jcmVhdGVGcm9tSW5wdXRGYWxsYmFjayhjb25maWcpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlTG9jYWxPclVUQyAoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QsIGlzVVRDKSB7XG4gICAgdmFyIGMgPSB7fTtcblxuICAgIGlmIChsb2NhbGUgPT09IHRydWUgfHwgbG9jYWxlID09PSBmYWxzZSkge1xuICAgICAgICBzdHJpY3QgPSBsb2NhbGU7XG4gICAgICAgIGxvY2FsZSA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBpZiAoKGlzT2JqZWN0KGlucHV0KSAmJiBpc09iamVjdEVtcHR5KGlucHV0KSkgfHxcbiAgICAgICAgICAgIChpc0FycmF5KGlucHV0KSAmJiBpbnB1dC5sZW5ndGggPT09IDApKSB7XG4gICAgICAgIGlucHV0ID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvLyBvYmplY3QgY29uc3RydWN0aW9uIG11c3QgYmUgZG9uZSB0aGlzIHdheS5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9pc3N1ZXMvMTQyM1xuICAgIGMuX2lzQU1vbWVudE9iamVjdCA9IHRydWU7XG4gICAgYy5fdXNlVVRDID0gYy5faXNVVEMgPSBpc1VUQztcbiAgICBjLl9sID0gbG9jYWxlO1xuICAgIGMuX2kgPSBpbnB1dDtcbiAgICBjLl9mID0gZm9ybWF0O1xuICAgIGMuX3N0cmljdCA9IHN0cmljdDtcblxuICAgIHJldHVybiBjcmVhdGVGcm9tQ29uZmlnKGMpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVMb2NhbCAoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QpIHtcbiAgICByZXR1cm4gY3JlYXRlTG9jYWxPclVUQyhpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCwgZmFsc2UpO1xufVxuXG52YXIgcHJvdG90eXBlTWluID0gZGVwcmVjYXRlKFxuICAgICdtb21lbnQoKS5taW4gaXMgZGVwcmVjYXRlZCwgdXNlIG1vbWVudC5tYXggaW5zdGVhZC4gaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9taW4tbWF4LycsXG4gICAgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb3RoZXIgPSBjcmVhdGVMb2NhbC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICBpZiAodGhpcy5pc1ZhbGlkKCkgJiYgb3RoZXIuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gb3RoZXIgPCB0aGlzID8gdGhpcyA6IG90aGVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUludmFsaWQoKTtcbiAgICAgICAgfVxuICAgIH1cbik7XG5cbnZhciBwcm90b3R5cGVNYXggPSBkZXByZWNhdGUoXG4gICAgJ21vbWVudCgpLm1heCBpcyBkZXByZWNhdGVkLCB1c2UgbW9tZW50Lm1pbiBpbnN0ZWFkLiBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL21pbi1tYXgvJyxcbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvdGhlciA9IGNyZWF0ZUxvY2FsLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgIGlmICh0aGlzLmlzVmFsaWQoKSAmJiBvdGhlci5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBvdGhlciA+IHRoaXMgPyB0aGlzIDogb3RoZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlSW52YWxpZCgpO1xuICAgICAgICB9XG4gICAgfVxuKTtcblxuLy8gUGljayBhIG1vbWVudCBtIGZyb20gbW9tZW50cyBzbyB0aGF0IG1bZm5dKG90aGVyKSBpcyB0cnVlIGZvciBhbGxcbi8vIG90aGVyLiBUaGlzIHJlbGllcyBvbiB0aGUgZnVuY3Rpb24gZm4gdG8gYmUgdHJhbnNpdGl2ZS5cbi8vXG4vLyBtb21lbnRzIHNob3VsZCBlaXRoZXIgYmUgYW4gYXJyYXkgb2YgbW9tZW50IG9iamVjdHMgb3IgYW4gYXJyYXksIHdob3NlXG4vLyBmaXJzdCBlbGVtZW50IGlzIGFuIGFycmF5IG9mIG1vbWVudCBvYmplY3RzLlxuZnVuY3Rpb24gcGlja0J5KGZuLCBtb21lbnRzKSB7XG4gICAgdmFyIHJlcywgaTtcbiAgICBpZiAobW9tZW50cy5sZW5ndGggPT09IDEgJiYgaXNBcnJheShtb21lbnRzWzBdKSkge1xuICAgICAgICBtb21lbnRzID0gbW9tZW50c1swXTtcbiAgICB9XG4gICAgaWYgKCFtb21lbnRzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlTG9jYWwoKTtcbiAgICB9XG4gICAgcmVzID0gbW9tZW50c1swXTtcbiAgICBmb3IgKGkgPSAxOyBpIDwgbW9tZW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAoIW1vbWVudHNbaV0uaXNWYWxpZCgpIHx8IG1vbWVudHNbaV1bZm5dKHJlcykpIHtcbiAgICAgICAgICAgIHJlcyA9IG1vbWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cblxuLy8gVE9ETzogVXNlIFtdLnNvcnQgaW5zdGVhZD9cbmZ1bmN0aW9uIG1pbiAoKSB7XG4gICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG5cbiAgICByZXR1cm4gcGlja0J5KCdpc0JlZm9yZScsIGFyZ3MpO1xufVxuXG5mdW5jdGlvbiBtYXggKCkge1xuICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuXG4gICAgcmV0dXJuIHBpY2tCeSgnaXNBZnRlcicsIGFyZ3MpO1xufVxuXG52YXIgbm93ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBEYXRlLm5vdyA/IERhdGUubm93KCkgOiArKG5ldyBEYXRlKCkpO1xufTtcblxudmFyIG9yZGVyaW5nID0gWyd5ZWFyJywgJ3F1YXJ0ZXInLCAnbW9udGgnLCAnd2VlaycsICdkYXknLCAnaG91cicsICdtaW51dGUnLCAnc2Vjb25kJywgJ21pbGxpc2Vjb25kJ107XG5cbmZ1bmN0aW9uIGlzRHVyYXRpb25WYWxpZChtKSB7XG4gICAgZm9yICh2YXIga2V5IGluIG0pIHtcbiAgICAgICAgaWYgKCEoaW5kZXhPZi5jYWxsKG9yZGVyaW5nLCBrZXkpICE9PSAtMSAmJiAobVtrZXldID09IG51bGwgfHwgIWlzTmFOKG1ba2V5XSkpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHVuaXRIYXNEZWNpbWFsID0gZmFsc2U7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcmRlcmluZy5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAobVtvcmRlcmluZ1tpXV0pIHtcbiAgICAgICAgICAgIGlmICh1bml0SGFzRGVjaW1hbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gb25seSBhbGxvdyBub24taW50ZWdlcnMgZm9yIHNtYWxsZXN0IHVuaXRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJzZUZsb2F0KG1bb3JkZXJpbmdbaV1dKSAhPT0gdG9JbnQobVtvcmRlcmluZ1tpXV0pKSB7XG4gICAgICAgICAgICAgICAgdW5pdEhhc0RlY2ltYWwgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGlzVmFsaWQkMSgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNWYWxpZDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlSW52YWxpZCQxKCkge1xuICAgIHJldHVybiBjcmVhdGVEdXJhdGlvbihOYU4pO1xufVxuXG5mdW5jdGlvbiBEdXJhdGlvbiAoZHVyYXRpb24pIHtcbiAgICB2YXIgbm9ybWFsaXplZElucHV0ID0gbm9ybWFsaXplT2JqZWN0VW5pdHMoZHVyYXRpb24pLFxuICAgICAgICB5ZWFycyA9IG5vcm1hbGl6ZWRJbnB1dC55ZWFyIHx8IDAsXG4gICAgICAgIHF1YXJ0ZXJzID0gbm9ybWFsaXplZElucHV0LnF1YXJ0ZXIgfHwgMCxcbiAgICAgICAgbW9udGhzID0gbm9ybWFsaXplZElucHV0Lm1vbnRoIHx8IDAsXG4gICAgICAgIHdlZWtzID0gbm9ybWFsaXplZElucHV0LndlZWsgfHwgMCxcbiAgICAgICAgZGF5cyA9IG5vcm1hbGl6ZWRJbnB1dC5kYXkgfHwgMCxcbiAgICAgICAgaG91cnMgPSBub3JtYWxpemVkSW5wdXQuaG91ciB8fCAwLFxuICAgICAgICBtaW51dGVzID0gbm9ybWFsaXplZElucHV0Lm1pbnV0ZSB8fCAwLFxuICAgICAgICBzZWNvbmRzID0gbm9ybWFsaXplZElucHV0LnNlY29uZCB8fCAwLFxuICAgICAgICBtaWxsaXNlY29uZHMgPSBub3JtYWxpemVkSW5wdXQubWlsbGlzZWNvbmQgfHwgMDtcblxuICAgIHRoaXMuX2lzVmFsaWQgPSBpc0R1cmF0aW9uVmFsaWQobm9ybWFsaXplZElucHV0KTtcblxuICAgIC8vIHJlcHJlc2VudGF0aW9uIGZvciBkYXRlQWRkUmVtb3ZlXG4gICAgdGhpcy5fbWlsbGlzZWNvbmRzID0gK21pbGxpc2Vjb25kcyArXG4gICAgICAgIHNlY29uZHMgKiAxZTMgKyAvLyAxMDAwXG4gICAgICAgIG1pbnV0ZXMgKiA2ZTQgKyAvLyAxMDAwICogNjBcbiAgICAgICAgaG91cnMgKiAxMDAwICogNjAgKiA2MDsgLy91c2luZyAxMDAwICogNjAgKiA2MCBpbnN0ZWFkIG9mIDM2ZTUgdG8gYXZvaWQgZmxvYXRpbmcgcG9pbnQgcm91bmRpbmcgZXJyb3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L2lzc3Vlcy8yOTc4XG4gICAgLy8gQmVjYXVzZSBvZiBkYXRlQWRkUmVtb3ZlIHRyZWF0cyAyNCBob3VycyBhcyBkaWZmZXJlbnQgZnJvbSBhXG4gICAgLy8gZGF5IHdoZW4gd29ya2luZyBhcm91bmQgRFNULCB3ZSBuZWVkIHRvIHN0b3JlIHRoZW0gc2VwYXJhdGVseVxuICAgIHRoaXMuX2RheXMgPSArZGF5cyArXG4gICAgICAgIHdlZWtzICogNztcbiAgICAvLyBJdCBpcyBpbXBvc3NpYmxlIHRvIHRyYW5zbGF0ZSBtb250aHMgaW50byBkYXlzIHdpdGhvdXQga25vd2luZ1xuICAgIC8vIHdoaWNoIG1vbnRocyB5b3UgYXJlIGFyZSB0YWxraW5nIGFib3V0LCBzbyB3ZSBoYXZlIHRvIHN0b3JlXG4gICAgLy8gaXQgc2VwYXJhdGVseS5cbiAgICB0aGlzLl9tb250aHMgPSArbW9udGhzICtcbiAgICAgICAgcXVhcnRlcnMgKiAzICtcbiAgICAgICAgeWVhcnMgKiAxMjtcblxuICAgIHRoaXMuX2RhdGEgPSB7fTtcblxuICAgIHRoaXMuX2xvY2FsZSA9IGdldExvY2FsZSgpO1xuXG4gICAgdGhpcy5fYnViYmxlKCk7XG59XG5cbmZ1bmN0aW9uIGlzRHVyYXRpb24gKG9iaikge1xuICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBEdXJhdGlvbjtcbn1cblxuZnVuY3Rpb24gYWJzUm91bmQgKG51bWJlcikge1xuICAgIGlmIChudW1iZXIgPCAwKSB7XG4gICAgICAgIHJldHVybiBNYXRoLnJvdW5kKC0xICogbnVtYmVyKSAqIC0xO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBNYXRoLnJvdW5kKG51bWJlcik7XG4gICAgfVxufVxuXG4vLyBGT1JNQVRUSU5HXG5cbmZ1bmN0aW9uIG9mZnNldCAodG9rZW4sIHNlcGFyYXRvcikge1xuICAgIGFkZEZvcm1hdFRva2VuKHRva2VuLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLnV0Y09mZnNldCgpO1xuICAgICAgICB2YXIgc2lnbiA9ICcrJztcbiAgICAgICAgaWYgKG9mZnNldCA8IDApIHtcbiAgICAgICAgICAgIG9mZnNldCA9IC1vZmZzZXQ7XG4gICAgICAgICAgICBzaWduID0gJy0nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzaWduICsgemVyb0ZpbGwofn4ob2Zmc2V0IC8gNjApLCAyKSArIHNlcGFyYXRvciArIHplcm9GaWxsKH5+KG9mZnNldCkgJSA2MCwgMik7XG4gICAgfSk7XG59XG5cbm9mZnNldCgnWicsICc6Jyk7XG5vZmZzZXQoJ1paJywgJycpO1xuXG4vLyBQQVJTSU5HXG5cbmFkZFJlZ2V4VG9rZW4oJ1onLCAgbWF0Y2hTaG9ydE9mZnNldCk7XG5hZGRSZWdleFRva2VuKCdaWicsIG1hdGNoU2hvcnRPZmZzZXQpO1xuYWRkUGFyc2VUb2tlbihbJ1onLCAnWlonXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgY29uZmlnLl91c2VVVEMgPSB0cnVlO1xuICAgIGNvbmZpZy5fdHptID0gb2Zmc2V0RnJvbVN0cmluZyhtYXRjaFNob3J0T2Zmc2V0LCBpbnB1dCk7XG59KTtcblxuLy8gSEVMUEVSU1xuXG4vLyB0aW1lem9uZSBjaHVua2VyXG4vLyAnKzEwOjAwJyA+IFsnMTAnLCAgJzAwJ11cbi8vICctMTUzMCcgID4gWyctMTUnLCAnMzAnXVxudmFyIGNodW5rT2Zmc2V0ID0gLyhbXFwrXFwtXXxcXGRcXGQpL2dpO1xuXG5mdW5jdGlvbiBvZmZzZXRGcm9tU3RyaW5nKG1hdGNoZXIsIHN0cmluZykge1xuICAgIHZhciBtYXRjaGVzID0gKHN0cmluZyB8fCAnJykubWF0Y2gobWF0Y2hlcik7XG5cbiAgICBpZiAobWF0Y2hlcyA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgY2h1bmsgICA9IG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAxXSB8fCBbXTtcbiAgICB2YXIgcGFydHMgICA9IChjaHVuayArICcnKS5tYXRjaChjaHVua09mZnNldCkgfHwgWyctJywgMCwgMF07XG4gICAgdmFyIG1pbnV0ZXMgPSArKHBhcnRzWzFdICogNjApICsgdG9JbnQocGFydHNbMl0pO1xuXG4gICAgcmV0dXJuIG1pbnV0ZXMgPT09IDAgP1xuICAgICAgMCA6XG4gICAgICBwYXJ0c1swXSA9PT0gJysnID8gbWludXRlcyA6IC1taW51dGVzO1xufVxuXG4vLyBSZXR1cm4gYSBtb21lbnQgZnJvbSBpbnB1dCwgdGhhdCBpcyBsb2NhbC91dGMvem9uZSBlcXVpdmFsZW50IHRvIG1vZGVsLlxuZnVuY3Rpb24gY2xvbmVXaXRoT2Zmc2V0KGlucHV0LCBtb2RlbCkge1xuICAgIHZhciByZXMsIGRpZmY7XG4gICAgaWYgKG1vZGVsLl9pc1VUQykge1xuICAgICAgICByZXMgPSBtb2RlbC5jbG9uZSgpO1xuICAgICAgICBkaWZmID0gKGlzTW9tZW50KGlucHV0KSB8fCBpc0RhdGUoaW5wdXQpID8gaW5wdXQudmFsdWVPZigpIDogY3JlYXRlTG9jYWwoaW5wdXQpLnZhbHVlT2YoKSkgLSByZXMudmFsdWVPZigpO1xuICAgICAgICAvLyBVc2UgbG93LWxldmVsIGFwaSwgYmVjYXVzZSB0aGlzIGZuIGlzIGxvdy1sZXZlbCBhcGkuXG4gICAgICAgIHJlcy5fZC5zZXRUaW1lKHJlcy5fZC52YWx1ZU9mKCkgKyBkaWZmKTtcbiAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KHJlcywgZmFsc2UpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVMb2NhbChpbnB1dCkubG9jYWwoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGdldERhdGVPZmZzZXQgKG0pIHtcbiAgICAvLyBPbiBGaXJlZm94LjI0IERhdGUjZ2V0VGltZXpvbmVPZmZzZXQgcmV0dXJucyBhIGZsb2F0aW5nIHBvaW50LlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L3B1bGwvMTg3MVxuICAgIHJldHVybiAtTWF0aC5yb3VuZChtLl9kLmdldFRpbWV6b25lT2Zmc2V0KCkgLyAxNSkgKiAxNTtcbn1cblxuLy8gSE9PS1NcblxuLy8gVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCB3aGVuZXZlciBhIG1vbWVudCBpcyBtdXRhdGVkLlxuLy8gSXQgaXMgaW50ZW5kZWQgdG8ga2VlcCB0aGUgb2Zmc2V0IGluIHN5bmMgd2l0aCB0aGUgdGltZXpvbmUuXG5ob29rcy51cGRhdGVPZmZzZXQgPSBmdW5jdGlvbiAoKSB7fTtcblxuLy8gTU9NRU5UU1xuXG4vLyBrZWVwTG9jYWxUaW1lID0gdHJ1ZSBtZWFucyBvbmx5IGNoYW5nZSB0aGUgdGltZXpvbmUsIHdpdGhvdXRcbi8vIGFmZmVjdGluZyB0aGUgbG9jYWwgaG91ci4gU28gNTozMToyNiArMDMwMCAtLVt1dGNPZmZzZXQoMiwgdHJ1ZSldLS0+XG4vLyA1OjMxOjI2ICswMjAwIEl0IGlzIHBvc3NpYmxlIHRoYXQgNTozMToyNiBkb2Vzbid0IGV4aXN0IHdpdGggb2Zmc2V0XG4vLyArMDIwMCwgc28gd2UgYWRqdXN0IHRoZSB0aW1lIGFzIG5lZWRlZCwgdG8gYmUgdmFsaWQuXG4vL1xuLy8gS2VlcGluZyB0aGUgdGltZSBhY3R1YWxseSBhZGRzL3N1YnRyYWN0cyAob25lIGhvdXIpXG4vLyBmcm9tIHRoZSBhY3R1YWwgcmVwcmVzZW50ZWQgdGltZS4gVGhhdCBpcyB3aHkgd2UgY2FsbCB1cGRhdGVPZmZzZXRcbi8vIGEgc2Vjb25kIHRpbWUuIEluIGNhc2UgaXQgd2FudHMgdXMgdG8gY2hhbmdlIHRoZSBvZmZzZXQgYWdhaW5cbi8vIF9jaGFuZ2VJblByb2dyZXNzID09IHRydWUgY2FzZSwgdGhlbiB3ZSBoYXZlIHRvIGFkanVzdCwgYmVjYXVzZVxuLy8gdGhlcmUgaXMgbm8gc3VjaCB0aW1lIGluIHRoZSBnaXZlbiB0aW1lem9uZS5cbmZ1bmN0aW9uIGdldFNldE9mZnNldCAoaW5wdXQsIGtlZXBMb2NhbFRpbWUsIGtlZXBNaW51dGVzKSB7XG4gICAgdmFyIG9mZnNldCA9IHRoaXMuX29mZnNldCB8fCAwLFxuICAgICAgICBsb2NhbEFkanVzdDtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgIHJldHVybiBpbnB1dCAhPSBudWxsID8gdGhpcyA6IE5hTjtcbiAgICB9XG4gICAgaWYgKGlucHV0ICE9IG51bGwpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlucHV0ID0gb2Zmc2V0RnJvbVN0cmluZyhtYXRjaFNob3J0T2Zmc2V0LCBpbnB1dCk7XG4gICAgICAgICAgICBpZiAoaW5wdXQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChNYXRoLmFicyhpbnB1dCkgPCAxNiAmJiAha2VlcE1pbnV0ZXMpIHtcbiAgICAgICAgICAgIGlucHV0ID0gaW5wdXQgKiA2MDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX2lzVVRDICYmIGtlZXBMb2NhbFRpbWUpIHtcbiAgICAgICAgICAgIGxvY2FsQWRqdXN0ID0gZ2V0RGF0ZU9mZnNldCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9vZmZzZXQgPSBpbnB1dDtcbiAgICAgICAgdGhpcy5faXNVVEMgPSB0cnVlO1xuICAgICAgICBpZiAobG9jYWxBZGp1c3QgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5hZGQobG9jYWxBZGp1c3QsICdtJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9mZnNldCAhPT0gaW5wdXQpIHtcbiAgICAgICAgICAgIGlmICgha2VlcExvY2FsVGltZSB8fCB0aGlzLl9jaGFuZ2VJblByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgYWRkU3VidHJhY3QodGhpcywgY3JlYXRlRHVyYXRpb24oaW5wdXQgLSBvZmZzZXQsICdtJyksIDEsIGZhbHNlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXRoaXMuX2NoYW5nZUluUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jaGFuZ2VJblByb2dyZXNzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBob29rcy51cGRhdGVPZmZzZXQodGhpcywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2hhbmdlSW5Qcm9ncmVzcyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzVVRDID8gb2Zmc2V0IDogZ2V0RGF0ZU9mZnNldCh0aGlzKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGdldFNldFpvbmUgKGlucHV0LCBrZWVwTG9jYWxUaW1lKSB7XG4gICAgaWYgKGlucHV0ICE9IG51bGwpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlucHV0ID0gLWlucHV0O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy51dGNPZmZzZXQoaW5wdXQsIGtlZXBMb2NhbFRpbWUpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAtdGhpcy51dGNPZmZzZXQoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHNldE9mZnNldFRvVVRDIChrZWVwTG9jYWxUaW1lKSB7XG4gICAgcmV0dXJuIHRoaXMudXRjT2Zmc2V0KDAsIGtlZXBMb2NhbFRpbWUpO1xufVxuXG5mdW5jdGlvbiBzZXRPZmZzZXRUb0xvY2FsIChrZWVwTG9jYWxUaW1lKSB7XG4gICAgaWYgKHRoaXMuX2lzVVRDKSB7XG4gICAgICAgIHRoaXMudXRjT2Zmc2V0KDAsIGtlZXBMb2NhbFRpbWUpO1xuICAgICAgICB0aGlzLl9pc1VUQyA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChrZWVwTG9jYWxUaW1lKSB7XG4gICAgICAgICAgICB0aGlzLnN1YnRyYWN0KGdldERhdGVPZmZzZXQodGhpcyksICdtJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59XG5cbmZ1bmN0aW9uIHNldE9mZnNldFRvUGFyc2VkT2Zmc2V0ICgpIHtcbiAgICBpZiAodGhpcy5fdHptICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy51dGNPZmZzZXQodGhpcy5fdHptLCBmYWxzZSwgdHJ1ZSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5faSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFyIHRab25lID0gb2Zmc2V0RnJvbVN0cmluZyhtYXRjaE9mZnNldCwgdGhpcy5faSk7XG4gICAgICAgIGlmICh0Wm9uZSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnV0Y09mZnNldCh0Wm9uZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnV0Y09mZnNldCgwLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn1cblxuZnVuY3Rpb24gaGFzQWxpZ25lZEhvdXJPZmZzZXQgKGlucHV0KSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlucHV0ID0gaW5wdXQgPyBjcmVhdGVMb2NhbChpbnB1dCkudXRjT2Zmc2V0KCkgOiAwO1xuXG4gICAgcmV0dXJuICh0aGlzLnV0Y09mZnNldCgpIC0gaW5wdXQpICUgNjAgPT09IDA7XG59XG5cbmZ1bmN0aW9uIGlzRGF5bGlnaHRTYXZpbmdUaW1lICgpIHtcbiAgICByZXR1cm4gKFxuICAgICAgICB0aGlzLnV0Y09mZnNldCgpID4gdGhpcy5jbG9uZSgpLm1vbnRoKDApLnV0Y09mZnNldCgpIHx8XG4gICAgICAgIHRoaXMudXRjT2Zmc2V0KCkgPiB0aGlzLmNsb25lKCkubW9udGgoNSkudXRjT2Zmc2V0KClcbiAgICApO1xufVxuXG5mdW5jdGlvbiBpc0RheWxpZ2h0U2F2aW5nVGltZVNoaWZ0ZWQgKCkge1xuICAgIGlmICghaXNVbmRlZmluZWQodGhpcy5faXNEU1RTaGlmdGVkKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNEU1RTaGlmdGVkO1xuICAgIH1cblxuICAgIHZhciBjID0ge307XG5cbiAgICBjb3B5Q29uZmlnKGMsIHRoaXMpO1xuICAgIGMgPSBwcmVwYXJlQ29uZmlnKGMpO1xuXG4gICAgaWYgKGMuX2EpIHtcbiAgICAgICAgdmFyIG90aGVyID0gYy5faXNVVEMgPyBjcmVhdGVVVEMoYy5fYSkgOiBjcmVhdGVMb2NhbChjLl9hKTtcbiAgICAgICAgdGhpcy5faXNEU1RTaGlmdGVkID0gdGhpcy5pc1ZhbGlkKCkgJiZcbiAgICAgICAgICAgIGNvbXBhcmVBcnJheXMoYy5fYSwgb3RoZXIudG9BcnJheSgpKSA+IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5faXNEU1RTaGlmdGVkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX2lzRFNUU2hpZnRlZDtcbn1cblxuZnVuY3Rpb24gaXNMb2NhbCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpID8gIXRoaXMuX2lzVVRDIDogZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVXRjT2Zmc2V0ICgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyB0aGlzLl9pc1VUQyA6IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1V0YyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpID8gdGhpcy5faXNVVEMgJiYgdGhpcy5fb2Zmc2V0ID09PSAwIDogZmFsc2U7XG59XG5cbi8vIEFTUC5ORVQganNvbiBkYXRlIGZvcm1hdCByZWdleFxudmFyIGFzcE5ldFJlZ2V4ID0gL14oXFwtfFxcKyk/KD86KFxcZCopWy4gXSk/KFxcZCspXFw6KFxcZCspKD86XFw6KFxcZCspKFxcLlxcZCopPyk/JC87XG5cbi8vIGZyb20gaHR0cDovL2RvY3MuY2xvc3VyZS1saWJyYXJ5Lmdvb2dsZWNvZGUuY29tL2dpdC9jbG9zdXJlX2dvb2dfZGF0ZV9kYXRlLmpzLnNvdXJjZS5odG1sXG4vLyBzb21ld2hhdCBtb3JlIGluIGxpbmUgd2l0aCA0LjQuMy4yIDIwMDQgc3BlYywgYnV0IGFsbG93cyBkZWNpbWFsIGFueXdoZXJlXG4vLyBhbmQgZnVydGhlciBtb2RpZmllZCB0byBhbGxvdyBmb3Igc3RyaW5ncyBjb250YWluaW5nIGJvdGggd2VlayBhbmQgZGF5XG52YXIgaXNvUmVnZXggPSAvXigtfFxcKyk/UCg/OihbLStdP1swLTksLl0qKVkpPyg/OihbLStdP1swLTksLl0qKU0pPyg/OihbLStdP1swLTksLl0qKVcpPyg/OihbLStdP1swLTksLl0qKUQpPyg/OlQoPzooWy0rXT9bMC05LC5dKilIKT8oPzooWy0rXT9bMC05LC5dKilNKT8oPzooWy0rXT9bMC05LC5dKilTKT8pPyQvO1xuXG5mdW5jdGlvbiBjcmVhdGVEdXJhdGlvbiAoaW5wdXQsIGtleSkge1xuICAgIHZhciBkdXJhdGlvbiA9IGlucHV0LFxuICAgICAgICAvLyBtYXRjaGluZyBhZ2FpbnN0IHJlZ2V4cCBpcyBleHBlbnNpdmUsIGRvIGl0IG9uIGRlbWFuZFxuICAgICAgICBtYXRjaCA9IG51bGwsXG4gICAgICAgIHNpZ24sXG4gICAgICAgIHJldCxcbiAgICAgICAgZGlmZlJlcztcblxuICAgIGlmIChpc0R1cmF0aW9uKGlucHV0KSkge1xuICAgICAgICBkdXJhdGlvbiA9IHtcbiAgICAgICAgICAgIG1zIDogaW5wdXQuX21pbGxpc2Vjb25kcyxcbiAgICAgICAgICAgIGQgIDogaW5wdXQuX2RheXMsXG4gICAgICAgICAgICBNICA6IGlucHV0Ll9tb250aHNcbiAgICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGlzTnVtYmVyKGlucHV0KSkge1xuICAgICAgICBkdXJhdGlvbiA9IHt9O1xuICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgICBkdXJhdGlvbltrZXldID0gaW5wdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkdXJhdGlvbi5taWxsaXNlY29uZHMgPSBpbnB1dDtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoISEobWF0Y2ggPSBhc3BOZXRSZWdleC5leGVjKGlucHV0KSkpIHtcbiAgICAgICAgc2lnbiA9IChtYXRjaFsxXSA9PT0gJy0nKSA/IC0xIDogMTtcbiAgICAgICAgZHVyYXRpb24gPSB7XG4gICAgICAgICAgICB5ICA6IDAsXG4gICAgICAgICAgICBkICA6IHRvSW50KG1hdGNoW0RBVEVdKSAgICAgICAgICAgICAgICAgICAgICAgICAqIHNpZ24sXG4gICAgICAgICAgICBoICA6IHRvSW50KG1hdGNoW0hPVVJdKSAgICAgICAgICAgICAgICAgICAgICAgICAqIHNpZ24sXG4gICAgICAgICAgICBtICA6IHRvSW50KG1hdGNoW01JTlVURV0pICAgICAgICAgICAgICAgICAgICAgICAqIHNpZ24sXG4gICAgICAgICAgICBzICA6IHRvSW50KG1hdGNoW1NFQ09ORF0pICAgICAgICAgICAgICAgICAgICAgICAqIHNpZ24sXG4gICAgICAgICAgICBtcyA6IHRvSW50KGFic1JvdW5kKG1hdGNoW01JTExJU0VDT05EXSAqIDEwMDApKSAqIHNpZ24gLy8gdGhlIG1pbGxpc2Vjb25kIGRlY2ltYWwgcG9pbnQgaXMgaW5jbHVkZWQgaW4gdGhlIG1hdGNoXG4gICAgICAgIH07XG4gICAgfSBlbHNlIGlmICghIShtYXRjaCA9IGlzb1JlZ2V4LmV4ZWMoaW5wdXQpKSkge1xuICAgICAgICBzaWduID0gKG1hdGNoWzFdID09PSAnLScpID8gLTEgOiAobWF0Y2hbMV0gPT09ICcrJykgPyAxIDogMTtcbiAgICAgICAgZHVyYXRpb24gPSB7XG4gICAgICAgICAgICB5IDogcGFyc2VJc28obWF0Y2hbMl0sIHNpZ24pLFxuICAgICAgICAgICAgTSA6IHBhcnNlSXNvKG1hdGNoWzNdLCBzaWduKSxcbiAgICAgICAgICAgIHcgOiBwYXJzZUlzbyhtYXRjaFs0XSwgc2lnbiksXG4gICAgICAgICAgICBkIDogcGFyc2VJc28obWF0Y2hbNV0sIHNpZ24pLFxuICAgICAgICAgICAgaCA6IHBhcnNlSXNvKG1hdGNoWzZdLCBzaWduKSxcbiAgICAgICAgICAgIG0gOiBwYXJzZUlzbyhtYXRjaFs3XSwgc2lnbiksXG4gICAgICAgICAgICBzIDogcGFyc2VJc28obWF0Y2hbOF0sIHNpZ24pXG4gICAgICAgIH07XG4gICAgfSBlbHNlIGlmIChkdXJhdGlvbiA9PSBudWxsKSB7Ly8gY2hlY2tzIGZvciBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICBkdXJhdGlvbiA9IHt9O1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGR1cmF0aW9uID09PSAnb2JqZWN0JyAmJiAoJ2Zyb20nIGluIGR1cmF0aW9uIHx8ICd0bycgaW4gZHVyYXRpb24pKSB7XG4gICAgICAgIGRpZmZSZXMgPSBtb21lbnRzRGlmZmVyZW5jZShjcmVhdGVMb2NhbChkdXJhdGlvbi5mcm9tKSwgY3JlYXRlTG9jYWwoZHVyYXRpb24udG8pKTtcblxuICAgICAgICBkdXJhdGlvbiA9IHt9O1xuICAgICAgICBkdXJhdGlvbi5tcyA9IGRpZmZSZXMubWlsbGlzZWNvbmRzO1xuICAgICAgICBkdXJhdGlvbi5NID0gZGlmZlJlcy5tb250aHM7XG4gICAgfVxuXG4gICAgcmV0ID0gbmV3IER1cmF0aW9uKGR1cmF0aW9uKTtcblxuICAgIGlmIChpc0R1cmF0aW9uKGlucHV0KSAmJiBoYXNPd25Qcm9wKGlucHV0LCAnX2xvY2FsZScpKSB7XG4gICAgICAgIHJldC5fbG9jYWxlID0gaW5wdXQuX2xvY2FsZTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xufVxuXG5jcmVhdGVEdXJhdGlvbi5mbiA9IER1cmF0aW9uLnByb3RvdHlwZTtcbmNyZWF0ZUR1cmF0aW9uLmludmFsaWQgPSBjcmVhdGVJbnZhbGlkJDE7XG5cbmZ1bmN0aW9uIHBhcnNlSXNvIChpbnAsIHNpZ24pIHtcbiAgICAvLyBXZSdkIG5vcm1hbGx5IHVzZSB+fmlucCBmb3IgdGhpcywgYnV0IHVuZm9ydHVuYXRlbHkgaXQgYWxzb1xuICAgIC8vIGNvbnZlcnRzIGZsb2F0cyB0byBpbnRzLlxuICAgIC8vIGlucCBtYXkgYmUgdW5kZWZpbmVkLCBzbyBjYXJlZnVsIGNhbGxpbmcgcmVwbGFjZSBvbiBpdC5cbiAgICB2YXIgcmVzID0gaW5wICYmIHBhcnNlRmxvYXQoaW5wLnJlcGxhY2UoJywnLCAnLicpKTtcbiAgICAvLyBhcHBseSBzaWduIHdoaWxlIHdlJ3JlIGF0IGl0XG4gICAgcmV0dXJuIChpc05hTihyZXMpID8gMCA6IHJlcykgKiBzaWduO1xufVxuXG5mdW5jdGlvbiBwb3NpdGl2ZU1vbWVudHNEaWZmZXJlbmNlKGJhc2UsIG90aGVyKSB7XG4gICAgdmFyIHJlcyA9IHttaWxsaXNlY29uZHM6IDAsIG1vbnRoczogMH07XG5cbiAgICByZXMubW9udGhzID0gb3RoZXIubW9udGgoKSAtIGJhc2UubW9udGgoKSArXG4gICAgICAgIChvdGhlci55ZWFyKCkgLSBiYXNlLnllYXIoKSkgKiAxMjtcbiAgICBpZiAoYmFzZS5jbG9uZSgpLmFkZChyZXMubW9udGhzLCAnTScpLmlzQWZ0ZXIob3RoZXIpKSB7XG4gICAgICAgIC0tcmVzLm1vbnRocztcbiAgICB9XG5cbiAgICByZXMubWlsbGlzZWNvbmRzID0gK290aGVyIC0gKyhiYXNlLmNsb25lKCkuYWRkKHJlcy5tb250aHMsICdNJykpO1xuXG4gICAgcmV0dXJuIHJlcztcbn1cblxuZnVuY3Rpb24gbW9tZW50c0RpZmZlcmVuY2UoYmFzZSwgb3RoZXIpIHtcbiAgICB2YXIgcmVzO1xuICAgIGlmICghKGJhc2UuaXNWYWxpZCgpICYmIG90aGVyLmlzVmFsaWQoKSkpIHtcbiAgICAgICAgcmV0dXJuIHttaWxsaXNlY29uZHM6IDAsIG1vbnRoczogMH07XG4gICAgfVxuXG4gICAgb3RoZXIgPSBjbG9uZVdpdGhPZmZzZXQob3RoZXIsIGJhc2UpO1xuICAgIGlmIChiYXNlLmlzQmVmb3JlKG90aGVyKSkge1xuICAgICAgICByZXMgPSBwb3NpdGl2ZU1vbWVudHNEaWZmZXJlbmNlKGJhc2UsIG90aGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXMgPSBwb3NpdGl2ZU1vbWVudHNEaWZmZXJlbmNlKG90aGVyLCBiYXNlKTtcbiAgICAgICAgcmVzLm1pbGxpc2Vjb25kcyA9IC1yZXMubWlsbGlzZWNvbmRzO1xuICAgICAgICByZXMubW9udGhzID0gLXJlcy5tb250aHM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcztcbn1cblxuLy8gVE9ETzogcmVtb3ZlICduYW1lJyBhcmcgYWZ0ZXIgZGVwcmVjYXRpb24gaXMgcmVtb3ZlZFxuZnVuY3Rpb24gY3JlYXRlQWRkZXIoZGlyZWN0aW9uLCBuYW1lKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh2YWwsIHBlcmlvZCkge1xuICAgICAgICB2YXIgZHVyLCB0bXA7XG4gICAgICAgIC8vaW52ZXJ0IHRoZSBhcmd1bWVudHMsIGJ1dCBjb21wbGFpbiBhYm91dCBpdFxuICAgICAgICBpZiAocGVyaW9kICE9PSBudWxsICYmICFpc05hTigrcGVyaW9kKSkge1xuICAgICAgICAgICAgZGVwcmVjYXRlU2ltcGxlKG5hbWUsICdtb21lbnQoKS4nICsgbmFtZSAgKyAnKHBlcmlvZCwgbnVtYmVyKSBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIG1vbWVudCgpLicgKyBuYW1lICsgJyhudW1iZXIsIHBlcmlvZCkuICcgK1xuICAgICAgICAgICAgJ1NlZSBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL2FkZC1pbnZlcnRlZC1wYXJhbS8gZm9yIG1vcmUgaW5mby4nKTtcbiAgICAgICAgICAgIHRtcCA9IHZhbDsgdmFsID0gcGVyaW9kOyBwZXJpb2QgPSB0bXA7XG4gICAgICAgIH1cblxuICAgICAgICB2YWwgPSB0eXBlb2YgdmFsID09PSAnc3RyaW5nJyA/ICt2YWwgOiB2YWw7XG4gICAgICAgIGR1ciA9IGNyZWF0ZUR1cmF0aW9uKHZhbCwgcGVyaW9kKTtcbiAgICAgICAgYWRkU3VidHJhY3QodGhpcywgZHVyLCBkaXJlY3Rpb24pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBhZGRTdWJ0cmFjdCAobW9tLCBkdXJhdGlvbiwgaXNBZGRpbmcsIHVwZGF0ZU9mZnNldCkge1xuICAgIHZhciBtaWxsaXNlY29uZHMgPSBkdXJhdGlvbi5fbWlsbGlzZWNvbmRzLFxuICAgICAgICBkYXlzID0gYWJzUm91bmQoZHVyYXRpb24uX2RheXMpLFxuICAgICAgICBtb250aHMgPSBhYnNSb3VuZChkdXJhdGlvbi5fbW9udGhzKTtcblxuICAgIGlmICghbW9tLmlzVmFsaWQoKSkge1xuICAgICAgICAvLyBObyBvcFxuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdXBkYXRlT2Zmc2V0ID0gdXBkYXRlT2Zmc2V0ID09IG51bGwgPyB0cnVlIDogdXBkYXRlT2Zmc2V0O1xuXG4gICAgaWYgKG1vbnRocykge1xuICAgICAgICBzZXRNb250aChtb20sIGdldChtb20sICdNb250aCcpICsgbW9udGhzICogaXNBZGRpbmcpO1xuICAgIH1cbiAgICBpZiAoZGF5cykge1xuICAgICAgICBzZXQkMShtb20sICdEYXRlJywgZ2V0KG1vbSwgJ0RhdGUnKSArIGRheXMgKiBpc0FkZGluZyk7XG4gICAgfVxuICAgIGlmIChtaWxsaXNlY29uZHMpIHtcbiAgICAgICAgbW9tLl9kLnNldFRpbWUobW9tLl9kLnZhbHVlT2YoKSArIG1pbGxpc2Vjb25kcyAqIGlzQWRkaW5nKTtcbiAgICB9XG4gICAgaWYgKHVwZGF0ZU9mZnNldCkge1xuICAgICAgICBob29rcy51cGRhdGVPZmZzZXQobW9tLCBkYXlzIHx8IG1vbnRocyk7XG4gICAgfVxufVxuXG52YXIgYWRkICAgICAgPSBjcmVhdGVBZGRlcigxLCAnYWRkJyk7XG52YXIgc3VidHJhY3QgPSBjcmVhdGVBZGRlcigtMSwgJ3N1YnRyYWN0Jyk7XG5cbmZ1bmN0aW9uIGdldENhbGVuZGFyRm9ybWF0KG15TW9tZW50LCBub3cpIHtcbiAgICB2YXIgZGlmZiA9IG15TW9tZW50LmRpZmYobm93LCAnZGF5cycsIHRydWUpO1xuICAgIHJldHVybiBkaWZmIDwgLTYgPyAnc2FtZUVsc2UnIDpcbiAgICAgICAgICAgIGRpZmYgPCAtMSA/ICdsYXN0V2VlaycgOlxuICAgICAgICAgICAgZGlmZiA8IDAgPyAnbGFzdERheScgOlxuICAgICAgICAgICAgZGlmZiA8IDEgPyAnc2FtZURheScgOlxuICAgICAgICAgICAgZGlmZiA8IDIgPyAnbmV4dERheScgOlxuICAgICAgICAgICAgZGlmZiA8IDcgPyAnbmV4dFdlZWsnIDogJ3NhbWVFbHNlJztcbn1cblxuZnVuY3Rpb24gY2FsZW5kYXIkMSAodGltZSwgZm9ybWF0cykge1xuICAgIC8vIFdlIHdhbnQgdG8gY29tcGFyZSB0aGUgc3RhcnQgb2YgdG9kYXksIHZzIHRoaXMuXG4gICAgLy8gR2V0dGluZyBzdGFydC1vZi10b2RheSBkZXBlbmRzIG9uIHdoZXRoZXIgd2UncmUgbG9jYWwvdXRjL29mZnNldCBvciBub3QuXG4gICAgdmFyIG5vdyA9IHRpbWUgfHwgY3JlYXRlTG9jYWwoKSxcbiAgICAgICAgc29kID0gY2xvbmVXaXRoT2Zmc2V0KG5vdywgdGhpcykuc3RhcnRPZignZGF5JyksXG4gICAgICAgIGZvcm1hdCA9IGhvb2tzLmNhbGVuZGFyRm9ybWF0KHRoaXMsIHNvZCkgfHwgJ3NhbWVFbHNlJztcblxuICAgIHZhciBvdXRwdXQgPSBmb3JtYXRzICYmIChpc0Z1bmN0aW9uKGZvcm1hdHNbZm9ybWF0XSkgPyBmb3JtYXRzW2Zvcm1hdF0uY2FsbCh0aGlzLCBub3cpIDogZm9ybWF0c1tmb3JtYXRdKTtcblxuICAgIHJldHVybiB0aGlzLmZvcm1hdChvdXRwdXQgfHwgdGhpcy5sb2NhbGVEYXRhKCkuY2FsZW5kYXIoZm9ybWF0LCB0aGlzLCBjcmVhdGVMb2NhbChub3cpKSk7XG59XG5cbmZ1bmN0aW9uIGNsb25lICgpIHtcbiAgICByZXR1cm4gbmV3IE1vbWVudCh0aGlzKTtcbn1cblxuZnVuY3Rpb24gaXNBZnRlciAoaW5wdXQsIHVuaXRzKSB7XG4gICAgdmFyIGxvY2FsSW5wdXQgPSBpc01vbWVudChpbnB1dCkgPyBpbnB1dCA6IGNyZWF0ZUxvY2FsKGlucHV0KTtcbiAgICBpZiAoISh0aGlzLmlzVmFsaWQoKSAmJiBsb2NhbElucHV0LmlzVmFsaWQoKSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKCFpc1VuZGVmaW5lZCh1bml0cykgPyB1bml0cyA6ICdtaWxsaXNlY29uZCcpO1xuICAgIGlmICh1bml0cyA9PT0gJ21pbGxpc2Vjb25kJykge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZU9mKCkgPiBsb2NhbElucHV0LnZhbHVlT2YoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbG9jYWxJbnB1dC52YWx1ZU9mKCkgPCB0aGlzLmNsb25lKCkuc3RhcnRPZih1bml0cykudmFsdWVPZigpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaXNCZWZvcmUgKGlucHV0LCB1bml0cykge1xuICAgIHZhciBsb2NhbElucHV0ID0gaXNNb21lbnQoaW5wdXQpID8gaW5wdXQgOiBjcmVhdGVMb2NhbChpbnB1dCk7XG4gICAgaWYgKCEodGhpcy5pc1ZhbGlkKCkgJiYgbG9jYWxJbnB1dC5pc1ZhbGlkKCkpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyghaXNVbmRlZmluZWQodW5pdHMpID8gdW5pdHMgOiAnbWlsbGlzZWNvbmQnKTtcbiAgICBpZiAodW5pdHMgPT09ICdtaWxsaXNlY29uZCcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVPZigpIDwgbG9jYWxJbnB1dC52YWx1ZU9mKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5lbmRPZih1bml0cykudmFsdWVPZigpIDwgbG9jYWxJbnB1dC52YWx1ZU9mKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBpc0JldHdlZW4gKGZyb20sIHRvLCB1bml0cywgaW5jbHVzaXZpdHkpIHtcbiAgICBpbmNsdXNpdml0eSA9IGluY2x1c2l2aXR5IHx8ICcoKSc7XG4gICAgcmV0dXJuIChpbmNsdXNpdml0eVswXSA9PT0gJygnID8gdGhpcy5pc0FmdGVyKGZyb20sIHVuaXRzKSA6ICF0aGlzLmlzQmVmb3JlKGZyb20sIHVuaXRzKSkgJiZcbiAgICAgICAgKGluY2x1c2l2aXR5WzFdID09PSAnKScgPyB0aGlzLmlzQmVmb3JlKHRvLCB1bml0cykgOiAhdGhpcy5pc0FmdGVyKHRvLCB1bml0cykpO1xufVxuXG5mdW5jdGlvbiBpc1NhbWUgKGlucHV0LCB1bml0cykge1xuICAgIHZhciBsb2NhbElucHV0ID0gaXNNb21lbnQoaW5wdXQpID8gaW5wdXQgOiBjcmVhdGVMb2NhbChpbnB1dCksXG4gICAgICAgIGlucHV0TXM7XG4gICAgaWYgKCEodGhpcy5pc1ZhbGlkKCkgJiYgbG9jYWxJbnB1dC5pc1ZhbGlkKCkpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyB8fCAnbWlsbGlzZWNvbmQnKTtcbiAgICBpZiAodW5pdHMgPT09ICdtaWxsaXNlY29uZCcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVPZigpID09PSBsb2NhbElucHV0LnZhbHVlT2YoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBpbnB1dE1zID0gbG9jYWxJbnB1dC52YWx1ZU9mKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKCkuc3RhcnRPZih1bml0cykudmFsdWVPZigpIDw9IGlucHV0TXMgJiYgaW5wdXRNcyA8PSB0aGlzLmNsb25lKCkuZW5kT2YodW5pdHMpLnZhbHVlT2YoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGlzU2FtZU9yQWZ0ZXIgKGlucHV0LCB1bml0cykge1xuICAgIHJldHVybiB0aGlzLmlzU2FtZShpbnB1dCwgdW5pdHMpIHx8IHRoaXMuaXNBZnRlcihpbnB1dCx1bml0cyk7XG59XG5cbmZ1bmN0aW9uIGlzU2FtZU9yQmVmb3JlIChpbnB1dCwgdW5pdHMpIHtcbiAgICByZXR1cm4gdGhpcy5pc1NhbWUoaW5wdXQsIHVuaXRzKSB8fCB0aGlzLmlzQmVmb3JlKGlucHV0LHVuaXRzKTtcbn1cblxuZnVuY3Rpb24gZGlmZiAoaW5wdXQsIHVuaXRzLCBhc0Zsb2F0KSB7XG4gICAgdmFyIHRoYXQsXG4gICAgICAgIHpvbmVEZWx0YSxcbiAgICAgICAgZGVsdGEsIG91dHB1dDtcblxuICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG5cbiAgICB0aGF0ID0gY2xvbmVXaXRoT2Zmc2V0KGlucHV0LCB0aGlzKTtcblxuICAgIGlmICghdGhhdC5pc1ZhbGlkKCkpIHtcbiAgICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG5cbiAgICB6b25lRGVsdGEgPSAodGhhdC51dGNPZmZzZXQoKSAtIHRoaXMudXRjT2Zmc2V0KCkpICogNmU0O1xuXG4gICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG5cbiAgICBzd2l0Y2ggKHVuaXRzKSB7XG4gICAgICAgIGNhc2UgJ3llYXInOiBvdXRwdXQgPSBtb250aERpZmYodGhpcywgdGhhdCkgLyAxMjsgYnJlYWs7XG4gICAgICAgIGNhc2UgJ21vbnRoJzogb3V0cHV0ID0gbW9udGhEaWZmKHRoaXMsIHRoYXQpOyBicmVhaztcbiAgICAgICAgY2FzZSAncXVhcnRlcic6IG91dHB1dCA9IG1vbnRoRGlmZih0aGlzLCB0aGF0KSAvIDM7IGJyZWFrO1xuICAgICAgICBjYXNlICdzZWNvbmQnOiBvdXRwdXQgPSAodGhpcyAtIHRoYXQpIC8gMWUzOyBicmVhazsgLy8gMTAwMFxuICAgICAgICBjYXNlICdtaW51dGUnOiBvdXRwdXQgPSAodGhpcyAtIHRoYXQpIC8gNmU0OyBicmVhazsgLy8gMTAwMCAqIDYwXG4gICAgICAgIGNhc2UgJ2hvdXInOiBvdXRwdXQgPSAodGhpcyAtIHRoYXQpIC8gMzZlNTsgYnJlYWs7IC8vIDEwMDAgKiA2MCAqIDYwXG4gICAgICAgIGNhc2UgJ2RheSc6IG91dHB1dCA9ICh0aGlzIC0gdGhhdCAtIHpvbmVEZWx0YSkgLyA4NjRlNTsgYnJlYWs7IC8vIDEwMDAgKiA2MCAqIDYwICogMjQsIG5lZ2F0ZSBkc3RcbiAgICAgICAgY2FzZSAnd2Vlayc6IG91dHB1dCA9ICh0aGlzIC0gdGhhdCAtIHpvbmVEZWx0YSkgLyA2MDQ4ZTU7IGJyZWFrOyAvLyAxMDAwICogNjAgKiA2MCAqIDI0ICogNywgbmVnYXRlIGRzdFxuICAgICAgICBkZWZhdWx0OiBvdXRwdXQgPSB0aGlzIC0gdGhhdDtcbiAgICB9XG5cbiAgICByZXR1cm4gYXNGbG9hdCA/IG91dHB1dCA6IGFic0Zsb29yKG91dHB1dCk7XG59XG5cbmZ1bmN0aW9uIG1vbnRoRGlmZiAoYSwgYikge1xuICAgIC8vIGRpZmZlcmVuY2UgaW4gbW9udGhzXG4gICAgdmFyIHdob2xlTW9udGhEaWZmID0gKChiLnllYXIoKSAtIGEueWVhcigpKSAqIDEyKSArIChiLm1vbnRoKCkgLSBhLm1vbnRoKCkpLFxuICAgICAgICAvLyBiIGlzIGluIChhbmNob3IgLSAxIG1vbnRoLCBhbmNob3IgKyAxIG1vbnRoKVxuICAgICAgICBhbmNob3IgPSBhLmNsb25lKCkuYWRkKHdob2xlTW9udGhEaWZmLCAnbW9udGhzJyksXG4gICAgICAgIGFuY2hvcjIsIGFkanVzdDtcblxuICAgIGlmIChiIC0gYW5jaG9yIDwgMCkge1xuICAgICAgICBhbmNob3IyID0gYS5jbG9uZSgpLmFkZCh3aG9sZU1vbnRoRGlmZiAtIDEsICdtb250aHMnKTtcbiAgICAgICAgLy8gbGluZWFyIGFjcm9zcyB0aGUgbW9udGhcbiAgICAgICAgYWRqdXN0ID0gKGIgLSBhbmNob3IpIC8gKGFuY2hvciAtIGFuY2hvcjIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGFuY2hvcjIgPSBhLmNsb25lKCkuYWRkKHdob2xlTW9udGhEaWZmICsgMSwgJ21vbnRocycpO1xuICAgICAgICAvLyBsaW5lYXIgYWNyb3NzIHRoZSBtb250aFxuICAgICAgICBhZGp1c3QgPSAoYiAtIGFuY2hvcikgLyAoYW5jaG9yMiAtIGFuY2hvcik7XG4gICAgfVxuXG4gICAgLy9jaGVjayBmb3IgbmVnYXRpdmUgemVybywgcmV0dXJuIHplcm8gaWYgbmVnYXRpdmUgemVyb1xuICAgIHJldHVybiAtKHdob2xlTW9udGhEaWZmICsgYWRqdXN0KSB8fCAwO1xufVxuXG5ob29rcy5kZWZhdWx0Rm9ybWF0ID0gJ1lZWVktTU0tRERUSEg6bW06c3NaJztcbmhvb2tzLmRlZmF1bHRGb3JtYXRVdGMgPSAnWVlZWS1NTS1ERFRISDptbTpzc1taXSc7XG5cbmZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmxvY2FsZSgnZW4nKS5mb3JtYXQoJ2RkZCBNTU0gREQgWVlZWSBISDptbTpzcyBbR01UXVpaJyk7XG59XG5cbmZ1bmN0aW9uIHRvSVNPU3RyaW5nKGtlZXBPZmZzZXQpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgdXRjID0ga2VlcE9mZnNldCAhPT0gdHJ1ZTtcbiAgICB2YXIgbSA9IHV0YyA/IHRoaXMuY2xvbmUoKS51dGMoKSA6IHRoaXM7XG4gICAgaWYgKG0ueWVhcigpIDwgMCB8fCBtLnllYXIoKSA+IDk5OTkpIHtcbiAgICAgICAgcmV0dXJuIGZvcm1hdE1vbWVudChtLCB1dGMgPyAnWVlZWVlZLU1NLUREW1RdSEg6bW06c3MuU1NTW1pdJyA6ICdZWVlZWVktTU0tRERbVF1ISDptbTpzcy5TU1NaJyk7XG4gICAgfVxuICAgIGlmIChpc0Z1bmN0aW9uKERhdGUucHJvdG90eXBlLnRvSVNPU3RyaW5nKSkge1xuICAgICAgICAvLyBuYXRpdmUgaW1wbGVtZW50YXRpb24gaXMgfjUweCBmYXN0ZXIsIHVzZSBpdCB3aGVuIHdlIGNhblxuICAgICAgICBpZiAodXRjKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b0RhdGUoKS50b0lTT1N0cmluZygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHRoaXMuX2QudmFsdWVPZigpKS50b0lTT1N0cmluZygpLnJlcGxhY2UoJ1onLCBmb3JtYXRNb21lbnQobSwgJ1onKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZvcm1hdE1vbWVudChtLCB1dGMgPyAnWVlZWS1NTS1ERFtUXUhIOm1tOnNzLlNTU1taXScgOiAnWVlZWS1NTS1ERFtUXUhIOm1tOnNzLlNTU1onKTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gYSBodW1hbiByZWFkYWJsZSByZXByZXNlbnRhdGlvbiBvZiBhIG1vbWVudCB0aGF0IGNhblxuICogYWxzbyBiZSBldmFsdWF0ZWQgdG8gZ2V0IGEgbmV3IG1vbWVudCB3aGljaCBpcyB0aGUgc2FtZVxuICpcbiAqIEBsaW5rIGh0dHBzOi8vbm9kZWpzLm9yZy9kaXN0L2xhdGVzdC9kb2NzL2FwaS91dGlsLmh0bWwjdXRpbF9jdXN0b21faW5zcGVjdF9mdW5jdGlvbl9vbl9vYmplY3RzXG4gKi9cbmZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgcmV0dXJuICdtb21lbnQuaW52YWxpZCgvKiAnICsgdGhpcy5faSArICcgKi8pJztcbiAgICB9XG4gICAgdmFyIGZ1bmMgPSAnbW9tZW50JztcbiAgICB2YXIgem9uZSA9ICcnO1xuICAgIGlmICghdGhpcy5pc0xvY2FsKCkpIHtcbiAgICAgICAgZnVuYyA9IHRoaXMudXRjT2Zmc2V0KCkgPT09IDAgPyAnbW9tZW50LnV0YycgOiAnbW9tZW50LnBhcnNlWm9uZSc7XG4gICAgICAgIHpvbmUgPSAnWic7XG4gICAgfVxuICAgIHZhciBwcmVmaXggPSAnWycgKyBmdW5jICsgJyhcIl0nO1xuICAgIHZhciB5ZWFyID0gKDAgPD0gdGhpcy55ZWFyKCkgJiYgdGhpcy55ZWFyKCkgPD0gOTk5OSkgPyAnWVlZWScgOiAnWVlZWVlZJztcbiAgICB2YXIgZGF0ZXRpbWUgPSAnLU1NLUREW1RdSEg6bW06c3MuU1NTJztcbiAgICB2YXIgc3VmZml4ID0gem9uZSArICdbXCIpXSc7XG5cbiAgICByZXR1cm4gdGhpcy5mb3JtYXQocHJlZml4ICsgeWVhciArIGRhdGV0aW1lICsgc3VmZml4KTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0IChpbnB1dFN0cmluZykge1xuICAgIGlmICghaW5wdXRTdHJpbmcpIHtcbiAgICAgICAgaW5wdXRTdHJpbmcgPSB0aGlzLmlzVXRjKCkgPyBob29rcy5kZWZhdWx0Rm9ybWF0VXRjIDogaG9va3MuZGVmYXVsdEZvcm1hdDtcbiAgICB9XG4gICAgdmFyIG91dHB1dCA9IGZvcm1hdE1vbWVudCh0aGlzLCBpbnB1dFN0cmluZyk7XG4gICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLnBvc3Rmb3JtYXQob3V0cHV0KTtcbn1cblxuZnVuY3Rpb24gZnJvbSAodGltZSwgd2l0aG91dFN1ZmZpeCkge1xuICAgIGlmICh0aGlzLmlzVmFsaWQoKSAmJlxuICAgICAgICAgICAgKChpc01vbWVudCh0aW1lKSAmJiB0aW1lLmlzVmFsaWQoKSkgfHxcbiAgICAgICAgICAgICBjcmVhdGVMb2NhbCh0aW1lKS5pc1ZhbGlkKCkpKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVEdXJhdGlvbih7dG86IHRoaXMsIGZyb206IHRpbWV9KS5sb2NhbGUodGhpcy5sb2NhbGUoKSkuaHVtYW5pemUoIXdpdGhvdXRTdWZmaXgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZnJvbU5vdyAod2l0aG91dFN1ZmZpeCkge1xuICAgIHJldHVybiB0aGlzLmZyb20oY3JlYXRlTG9jYWwoKSwgd2l0aG91dFN1ZmZpeCk7XG59XG5cbmZ1bmN0aW9uIHRvICh0aW1lLCB3aXRob3V0U3VmZml4KSB7XG4gICAgaWYgKHRoaXMuaXNWYWxpZCgpICYmXG4gICAgICAgICAgICAoKGlzTW9tZW50KHRpbWUpICYmIHRpbWUuaXNWYWxpZCgpKSB8fFxuICAgICAgICAgICAgIGNyZWF0ZUxvY2FsKHRpbWUpLmlzVmFsaWQoKSkpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUR1cmF0aW9uKHtmcm9tOiB0aGlzLCB0bzogdGltZX0pLmxvY2FsZSh0aGlzLmxvY2FsZSgpKS5odW1hbml6ZSghd2l0aG91dFN1ZmZpeCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLmludmFsaWREYXRlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiB0b05vdyAod2l0aG91dFN1ZmZpeCkge1xuICAgIHJldHVybiB0aGlzLnRvKGNyZWF0ZUxvY2FsKCksIHdpdGhvdXRTdWZmaXgpO1xufVxuXG4vLyBJZiBwYXNzZWQgYSBsb2NhbGUga2V5LCBpdCB3aWxsIHNldCB0aGUgbG9jYWxlIGZvciB0aGlzXG4vLyBpbnN0YW5jZS4gIE90aGVyd2lzZSwgaXQgd2lsbCByZXR1cm4gdGhlIGxvY2FsZSBjb25maWd1cmF0aW9uXG4vLyB2YXJpYWJsZXMgZm9yIHRoaXMgaW5zdGFuY2UuXG5mdW5jdGlvbiBsb2NhbGUgKGtleSkge1xuICAgIHZhciBuZXdMb2NhbGVEYXRhO1xuXG4gICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sb2NhbGUuX2FiYnI7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbmV3TG9jYWxlRGF0YSA9IGdldExvY2FsZShrZXkpO1xuICAgICAgICBpZiAobmV3TG9jYWxlRGF0YSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2NhbGUgPSBuZXdMb2NhbGVEYXRhO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cblxudmFyIGxhbmcgPSBkZXByZWNhdGUoXG4gICAgJ21vbWVudCgpLmxhbmcoKSBpcyBkZXByZWNhdGVkLiBJbnN0ZWFkLCB1c2UgbW9tZW50KCkubG9jYWxlRGF0YSgpIHRvIGdldCB0aGUgbGFuZ3VhZ2UgY29uZmlndXJhdGlvbi4gVXNlIG1vbWVudCgpLmxvY2FsZSgpIHRvIGNoYW5nZSBsYW5ndWFnZXMuJyxcbiAgICBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlKGtleSk7XG4gICAgICAgIH1cbiAgICB9XG4pO1xuXG5mdW5jdGlvbiBsb2NhbGVEYXRhICgpIHtcbiAgICByZXR1cm4gdGhpcy5fbG9jYWxlO1xufVxuXG5mdW5jdGlvbiBzdGFydE9mICh1bml0cykge1xuICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgIC8vIHRoZSBmb2xsb3dpbmcgc3dpdGNoIGludGVudGlvbmFsbHkgb21pdHMgYnJlYWsga2V5d29yZHNcbiAgICAvLyB0byB1dGlsaXplIGZhbGxpbmcgdGhyb3VnaCB0aGUgY2FzZXMuXG4gICAgc3dpdGNoICh1bml0cykge1xuICAgICAgICBjYXNlICd5ZWFyJzpcbiAgICAgICAgICAgIHRoaXMubW9udGgoMCk7XG4gICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgIGNhc2UgJ3F1YXJ0ZXInOlxuICAgICAgICBjYXNlICdtb250aCc6XG4gICAgICAgICAgICB0aGlzLmRhdGUoMSk7XG4gICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgIGNhc2UgJ3dlZWsnOlxuICAgICAgICBjYXNlICdpc29XZWVrJzpcbiAgICAgICAgY2FzZSAnZGF5JzpcbiAgICAgICAgY2FzZSAnZGF0ZSc6XG4gICAgICAgICAgICB0aGlzLmhvdXJzKDApO1xuICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICBjYXNlICdob3VyJzpcbiAgICAgICAgICAgIHRoaXMubWludXRlcygwKTtcbiAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgY2FzZSAnbWludXRlJzpcbiAgICAgICAgICAgIHRoaXMuc2Vjb25kcygwKTtcbiAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgY2FzZSAnc2Vjb25kJzpcbiAgICAgICAgICAgIHRoaXMubWlsbGlzZWNvbmRzKDApO1xuICAgIH1cblxuICAgIC8vIHdlZWtzIGFyZSBhIHNwZWNpYWwgY2FzZVxuICAgIGlmICh1bml0cyA9PT0gJ3dlZWsnKSB7XG4gICAgICAgIHRoaXMud2Vla2RheSgwKTtcbiAgICB9XG4gICAgaWYgKHVuaXRzID09PSAnaXNvV2VlaycpIHtcbiAgICAgICAgdGhpcy5pc29XZWVrZGF5KDEpO1xuICAgIH1cblxuICAgIC8vIHF1YXJ0ZXJzIGFyZSBhbHNvIHNwZWNpYWxcbiAgICBpZiAodW5pdHMgPT09ICdxdWFydGVyJykge1xuICAgICAgICB0aGlzLm1vbnRoKE1hdGguZmxvb3IodGhpcy5tb250aCgpIC8gMykgKiAzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbn1cblxuZnVuY3Rpb24gZW5kT2YgKHVuaXRzKSB7XG4gICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgaWYgKHVuaXRzID09PSB1bmRlZmluZWQgfHwgdW5pdHMgPT09ICdtaWxsaXNlY29uZCcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gJ2RhdGUnIGlzIGFuIGFsaWFzIGZvciAnZGF5Jywgc28gaXQgc2hvdWxkIGJlIGNvbnNpZGVyZWQgYXMgc3VjaC5cbiAgICBpZiAodW5pdHMgPT09ICdkYXRlJykge1xuICAgICAgICB1bml0cyA9ICdkYXknO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnN0YXJ0T2YodW5pdHMpLmFkZCgxLCAodW5pdHMgPT09ICdpc29XZWVrJyA/ICd3ZWVrJyA6IHVuaXRzKSkuc3VidHJhY3QoMSwgJ21zJyk7XG59XG5cbmZ1bmN0aW9uIHZhbHVlT2YgKCkge1xuICAgIHJldHVybiB0aGlzLl9kLnZhbHVlT2YoKSAtICgodGhpcy5fb2Zmc2V0IHx8IDApICogNjAwMDApO1xufVxuXG5mdW5jdGlvbiB1bml4ICgpIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcih0aGlzLnZhbHVlT2YoKSAvIDEwMDApO1xufVxuXG5mdW5jdGlvbiB0b0RhdGUgKCkge1xuICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLnZhbHVlT2YoKSk7XG59XG5cbmZ1bmN0aW9uIHRvQXJyYXkgKCkge1xuICAgIHZhciBtID0gdGhpcztcbiAgICByZXR1cm4gW20ueWVhcigpLCBtLm1vbnRoKCksIG0uZGF0ZSgpLCBtLmhvdXIoKSwgbS5taW51dGUoKSwgbS5zZWNvbmQoKSwgbS5taWxsaXNlY29uZCgpXTtcbn1cblxuZnVuY3Rpb24gdG9PYmplY3QgKCkge1xuICAgIHZhciBtID0gdGhpcztcbiAgICByZXR1cm4ge1xuICAgICAgICB5ZWFyczogbS55ZWFyKCksXG4gICAgICAgIG1vbnRoczogbS5tb250aCgpLFxuICAgICAgICBkYXRlOiBtLmRhdGUoKSxcbiAgICAgICAgaG91cnM6IG0uaG91cnMoKSxcbiAgICAgICAgbWludXRlczogbS5taW51dGVzKCksXG4gICAgICAgIHNlY29uZHM6IG0uc2Vjb25kcygpLFxuICAgICAgICBtaWxsaXNlY29uZHM6IG0ubWlsbGlzZWNvbmRzKClcbiAgICB9O1xufVxuXG5mdW5jdGlvbiB0b0pTT04gKCkge1xuICAgIC8vIG5ldyBEYXRlKE5hTikudG9KU09OKCkgPT09IG51bGxcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyB0aGlzLnRvSVNPU3RyaW5nKCkgOiBudWxsO1xufVxuXG5mdW5jdGlvbiBpc1ZhbGlkJDIgKCkge1xuICAgIHJldHVybiBpc1ZhbGlkKHRoaXMpO1xufVxuXG5mdW5jdGlvbiBwYXJzaW5nRmxhZ3MgKCkge1xuICAgIHJldHVybiBleHRlbmQoe30sIGdldFBhcnNpbmdGbGFncyh0aGlzKSk7XG59XG5cbmZ1bmN0aW9uIGludmFsaWRBdCAoKSB7XG4gICAgcmV0dXJuIGdldFBhcnNpbmdGbGFncyh0aGlzKS5vdmVyZmxvdztcbn1cblxuZnVuY3Rpb24gY3JlYXRpb25EYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGlucHV0OiB0aGlzLl9pLFxuICAgICAgICBmb3JtYXQ6IHRoaXMuX2YsXG4gICAgICAgIGxvY2FsZTogdGhpcy5fbG9jYWxlLFxuICAgICAgICBpc1VUQzogdGhpcy5faXNVVEMsXG4gICAgICAgIHN0cmljdDogdGhpcy5fc3RyaWN0XG4gICAgfTtcbn1cblxuLy8gRk9STUFUVElOR1xuXG5hZGRGb3JtYXRUb2tlbigwLCBbJ2dnJywgMl0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy53ZWVrWWVhcigpICUgMTAwO1xufSk7XG5cbmFkZEZvcm1hdFRva2VuKDAsIFsnR0cnLCAyXSwgMCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmlzb1dlZWtZZWFyKCkgJSAxMDA7XG59KTtcblxuZnVuY3Rpb24gYWRkV2Vla1llYXJGb3JtYXRUb2tlbiAodG9rZW4sIGdldHRlcikge1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFt0b2tlbiwgdG9rZW4ubGVuZ3RoXSwgMCwgZ2V0dGVyKTtcbn1cblxuYWRkV2Vla1llYXJGb3JtYXRUb2tlbignZ2dnZycsICAgICAnd2Vla1llYXInKTtcbmFkZFdlZWtZZWFyRm9ybWF0VG9rZW4oJ2dnZ2dnJywgICAgJ3dlZWtZZWFyJyk7XG5hZGRXZWVrWWVhckZvcm1hdFRva2VuKCdHR0dHJywgICdpc29XZWVrWWVhcicpO1xuYWRkV2Vla1llYXJGb3JtYXRUb2tlbignR0dHR0cnLCAnaXNvV2Vla1llYXInKTtcblxuLy8gQUxJQVNFU1xuXG5hZGRVbml0QWxpYXMoJ3dlZWtZZWFyJywgJ2dnJyk7XG5hZGRVbml0QWxpYXMoJ2lzb1dlZWtZZWFyJywgJ0dHJyk7XG5cbi8vIFBSSU9SSVRZXG5cbmFkZFVuaXRQcmlvcml0eSgnd2Vla1llYXInLCAxKTtcbmFkZFVuaXRQcmlvcml0eSgnaXNvV2Vla1llYXInLCAxKTtcblxuXG4vLyBQQVJTSU5HXG5cbmFkZFJlZ2V4VG9rZW4oJ0cnLCAgICAgIG1hdGNoU2lnbmVkKTtcbmFkZFJlZ2V4VG9rZW4oJ2cnLCAgICAgIG1hdGNoU2lnbmVkKTtcbmFkZFJlZ2V4VG9rZW4oJ0dHJywgICAgIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbmFkZFJlZ2V4VG9rZW4oJ2dnJywgICAgIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbmFkZFJlZ2V4VG9rZW4oJ0dHR0cnLCAgIG1hdGNoMXRvNCwgbWF0Y2g0KTtcbmFkZFJlZ2V4VG9rZW4oJ2dnZ2cnLCAgIG1hdGNoMXRvNCwgbWF0Y2g0KTtcbmFkZFJlZ2V4VG9rZW4oJ0dHR0dHJywgIG1hdGNoMXRvNiwgbWF0Y2g2KTtcbmFkZFJlZ2V4VG9rZW4oJ2dnZ2dnJywgIG1hdGNoMXRvNiwgbWF0Y2g2KTtcblxuYWRkV2Vla1BhcnNlVG9rZW4oWydnZ2dnJywgJ2dnZ2dnJywgJ0dHR0cnLCAnR0dHR0cnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgd2Vla1t0b2tlbi5zdWJzdHIoMCwgMildID0gdG9JbnQoaW5wdXQpO1xufSk7XG5cbmFkZFdlZWtQYXJzZVRva2VuKFsnZ2cnLCAnR0cnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgd2Vla1t0b2tlbl0gPSBob29rcy5wYXJzZVR3b0RpZ2l0WWVhcihpbnB1dCk7XG59KTtcblxuLy8gTU9NRU5UU1xuXG5mdW5jdGlvbiBnZXRTZXRXZWVrWWVhciAoaW5wdXQpIHtcbiAgICByZXR1cm4gZ2V0U2V0V2Vla1llYXJIZWxwZXIuY2FsbCh0aGlzLFxuICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICB0aGlzLndlZWsoKSxcbiAgICAgICAgICAgIHRoaXMud2Vla2RheSgpLFxuICAgICAgICAgICAgdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWsuZG93LFxuICAgICAgICAgICAgdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWsuZG95KTtcbn1cblxuZnVuY3Rpb24gZ2V0U2V0SVNPV2Vla1llYXIgKGlucHV0KSB7XG4gICAgcmV0dXJuIGdldFNldFdlZWtZZWFySGVscGVyLmNhbGwodGhpcyxcbiAgICAgICAgICAgIGlucHV0LCB0aGlzLmlzb1dlZWsoKSwgdGhpcy5pc29XZWVrZGF5KCksIDEsIDQpO1xufVxuXG5mdW5jdGlvbiBnZXRJU09XZWVrc0luWWVhciAoKSB7XG4gICAgcmV0dXJuIHdlZWtzSW5ZZWFyKHRoaXMueWVhcigpLCAxLCA0KTtcbn1cblxuZnVuY3Rpb24gZ2V0V2Vla3NJblllYXIgKCkge1xuICAgIHZhciB3ZWVrSW5mbyA9IHRoaXMubG9jYWxlRGF0YSgpLl93ZWVrO1xuICAgIHJldHVybiB3ZWVrc0luWWVhcih0aGlzLnllYXIoKSwgd2Vla0luZm8uZG93LCB3ZWVrSW5mby5kb3kpO1xufVxuXG5mdW5jdGlvbiBnZXRTZXRXZWVrWWVhckhlbHBlcihpbnB1dCwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpIHtcbiAgICB2YXIgd2Vla3NUYXJnZXQ7XG4gICAgaWYgKGlucHV0ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHdlZWtPZlllYXIodGhpcywgZG93LCBkb3kpLnllYXI7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgd2Vla3NUYXJnZXQgPSB3ZWVrc0luWWVhcihpbnB1dCwgZG93LCBkb3kpO1xuICAgICAgICBpZiAod2VlayA+IHdlZWtzVGFyZ2V0KSB7XG4gICAgICAgICAgICB3ZWVrID0gd2Vla3NUYXJnZXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNldFdlZWtBbGwuY2FsbCh0aGlzLCBpbnB1dCwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gc2V0V2Vla0FsbCh3ZWVrWWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpIHtcbiAgICB2YXIgZGF5T2ZZZWFyRGF0YSA9IGRheU9mWWVhckZyb21XZWVrcyh3ZWVrWWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpLFxuICAgICAgICBkYXRlID0gY3JlYXRlVVRDRGF0ZShkYXlPZlllYXJEYXRhLnllYXIsIDAsIGRheU9mWWVhckRhdGEuZGF5T2ZZZWFyKTtcblxuICAgIHRoaXMueWVhcihkYXRlLmdldFVUQ0Z1bGxZZWFyKCkpO1xuICAgIHRoaXMubW9udGgoZGF0ZS5nZXRVVENNb250aCgpKTtcbiAgICB0aGlzLmRhdGUoZGF0ZS5nZXRVVENEYXRlKCkpO1xuICAgIHJldHVybiB0aGlzO1xufVxuXG4vLyBGT1JNQVRUSU5HXG5cbmFkZEZvcm1hdFRva2VuKCdRJywgMCwgJ1FvJywgJ3F1YXJ0ZXInKTtcblxuLy8gQUxJQVNFU1xuXG5hZGRVbml0QWxpYXMoJ3F1YXJ0ZXInLCAnUScpO1xuXG4vLyBQUklPUklUWVxuXG5hZGRVbml0UHJpb3JpdHkoJ3F1YXJ0ZXInLCA3KTtcblxuLy8gUEFSU0lOR1xuXG5hZGRSZWdleFRva2VuKCdRJywgbWF0Y2gxKTtcbmFkZFBhcnNlVG9rZW4oJ1EnLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgYXJyYXlbTU9OVEhdID0gKHRvSW50KGlucHV0KSAtIDEpICogMztcbn0pO1xuXG4vLyBNT01FTlRTXG5cbmZ1bmN0aW9uIGdldFNldFF1YXJ0ZXIgKGlucHV0KSB7XG4gICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyBNYXRoLmNlaWwoKHRoaXMubW9udGgoKSArIDEpIC8gMykgOiB0aGlzLm1vbnRoKChpbnB1dCAtIDEpICogMyArIHRoaXMubW9udGgoKSAlIDMpO1xufVxuXG4vLyBGT1JNQVRUSU5HXG5cbmFkZEZvcm1hdFRva2VuKCdEJywgWydERCcsIDJdLCAnRG8nLCAnZGF0ZScpO1xuXG4vLyBBTElBU0VTXG5cbmFkZFVuaXRBbGlhcygnZGF0ZScsICdEJyk7XG5cbi8vIFBSSU9ST0lUWVxuYWRkVW5pdFByaW9yaXR5KCdkYXRlJywgOSk7XG5cbi8vIFBBUlNJTkdcblxuYWRkUmVnZXhUb2tlbignRCcsICBtYXRjaDF0bzIpO1xuYWRkUmVnZXhUb2tlbignREQnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG5hZGRSZWdleFRva2VuKCdEbycsIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgLy8gVE9ETzogUmVtb3ZlIFwib3JkaW5hbFBhcnNlXCIgZmFsbGJhY2sgaW4gbmV4dCBtYWpvciByZWxlYXNlLlxuICAgIHJldHVybiBpc1N0cmljdCA/XG4gICAgICAobG9jYWxlLl9kYXlPZk1vbnRoT3JkaW5hbFBhcnNlIHx8IGxvY2FsZS5fb3JkaW5hbFBhcnNlKSA6XG4gICAgICBsb2NhbGUuX2RheU9mTW9udGhPcmRpbmFsUGFyc2VMZW5pZW50O1xufSk7XG5cbmFkZFBhcnNlVG9rZW4oWydEJywgJ0REJ10sIERBVEUpO1xuYWRkUGFyc2VUb2tlbignRG8nLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgYXJyYXlbREFURV0gPSB0b0ludChpbnB1dC5tYXRjaChtYXRjaDF0bzIpWzBdKTtcbn0pO1xuXG4vLyBNT01FTlRTXG5cbnZhciBnZXRTZXREYXlPZk1vbnRoID0gbWFrZUdldFNldCgnRGF0ZScsIHRydWUpO1xuXG4vLyBGT1JNQVRUSU5HXG5cbmFkZEZvcm1hdFRva2VuKCdEREQnLCBbJ0REREQnLCAzXSwgJ0RERG8nLCAnZGF5T2ZZZWFyJyk7XG5cbi8vIEFMSUFTRVNcblxuYWRkVW5pdEFsaWFzKCdkYXlPZlllYXInLCAnREREJyk7XG5cbi8vIFBSSU9SSVRZXG5hZGRVbml0UHJpb3JpdHkoJ2RheU9mWWVhcicsIDQpO1xuXG4vLyBQQVJTSU5HXG5cbmFkZFJlZ2V4VG9rZW4oJ0RERCcsICBtYXRjaDF0bzMpO1xuYWRkUmVnZXhUb2tlbignRERERCcsIG1hdGNoMyk7XG5hZGRQYXJzZVRva2VuKFsnREREJywgJ0REREQnXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgY29uZmlnLl9kYXlPZlllYXIgPSB0b0ludChpbnB1dCk7XG59KTtcblxuLy8gSEVMUEVSU1xuXG4vLyBNT01FTlRTXG5cbmZ1bmN0aW9uIGdldFNldERheU9mWWVhciAoaW5wdXQpIHtcbiAgICB2YXIgZGF5T2ZZZWFyID0gTWF0aC5yb3VuZCgodGhpcy5jbG9uZSgpLnN0YXJ0T2YoJ2RheScpIC0gdGhpcy5jbG9uZSgpLnN0YXJ0T2YoJ3llYXInKSkgLyA4NjRlNSkgKyAxO1xuICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gZGF5T2ZZZWFyIDogdGhpcy5hZGQoKGlucHV0IC0gZGF5T2ZZZWFyKSwgJ2QnKTtcbn1cblxuLy8gRk9STUFUVElOR1xuXG5hZGRGb3JtYXRUb2tlbignbScsIFsnbW0nLCAyXSwgMCwgJ21pbnV0ZScpO1xuXG4vLyBBTElBU0VTXG5cbmFkZFVuaXRBbGlhcygnbWludXRlJywgJ20nKTtcblxuLy8gUFJJT1JJVFlcblxuYWRkVW5pdFByaW9yaXR5KCdtaW51dGUnLCAxNCk7XG5cbi8vIFBBUlNJTkdcblxuYWRkUmVnZXhUb2tlbignbScsICBtYXRjaDF0bzIpO1xuYWRkUmVnZXhUb2tlbignbW0nLCBtYXRjaDF0bzIsIG1hdGNoMik7XG5hZGRQYXJzZVRva2VuKFsnbScsICdtbSddLCBNSU5VVEUpO1xuXG4vLyBNT01FTlRTXG5cbnZhciBnZXRTZXRNaW51dGUgPSBtYWtlR2V0U2V0KCdNaW51dGVzJywgZmFsc2UpO1xuXG4vLyBGT1JNQVRUSU5HXG5cbmFkZEZvcm1hdFRva2VuKCdzJywgWydzcycsIDJdLCAwLCAnc2Vjb25kJyk7XG5cbi8vIEFMSUFTRVNcblxuYWRkVW5pdEFsaWFzKCdzZWNvbmQnLCAncycpO1xuXG4vLyBQUklPUklUWVxuXG5hZGRVbml0UHJpb3JpdHkoJ3NlY29uZCcsIDE1KTtcblxuLy8gUEFSU0lOR1xuXG5hZGRSZWdleFRva2VuKCdzJywgIG1hdGNoMXRvMik7XG5hZGRSZWdleFRva2VuKCdzcycsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbmFkZFBhcnNlVG9rZW4oWydzJywgJ3NzJ10sIFNFQ09ORCk7XG5cbi8vIE1PTUVOVFNcblxudmFyIGdldFNldFNlY29uZCA9IG1ha2VHZXRTZXQoJ1NlY29uZHMnLCBmYWxzZSk7XG5cbi8vIEZPUk1BVFRJTkdcblxuYWRkRm9ybWF0VG9rZW4oJ1MnLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIH5+KHRoaXMubWlsbGlzZWNvbmQoKSAvIDEwMCk7XG59KTtcblxuYWRkRm9ybWF0VG9rZW4oMCwgWydTUycsIDJdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIH5+KHRoaXMubWlsbGlzZWNvbmQoKSAvIDEwKTtcbn0pO1xuXG5hZGRGb3JtYXRUb2tlbigwLCBbJ1NTUycsIDNdLCAwLCAnbWlsbGlzZWNvbmQnKTtcbmFkZEZvcm1hdFRva2VuKDAsIFsnU1NTUycsIDRdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwO1xufSk7XG5hZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1NTJywgNV0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwO1xufSk7XG5hZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1NTUycsIDZdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDA7XG59KTtcbmFkZEZvcm1hdFRva2VuKDAsIFsnU1NTU1NTUycsIDddLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDAwO1xufSk7XG5hZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1NTU1NTJywgOF0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwMDAwO1xufSk7XG5hZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1NTU1NTUycsIDldLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDAwMDA7XG59KTtcblxuXG4vLyBBTElBU0VTXG5cbmFkZFVuaXRBbGlhcygnbWlsbGlzZWNvbmQnLCAnbXMnKTtcblxuLy8gUFJJT1JJVFlcblxuYWRkVW5pdFByaW9yaXR5KCdtaWxsaXNlY29uZCcsIDE2KTtcblxuLy8gUEFSU0lOR1xuXG5hZGRSZWdleFRva2VuKCdTJywgICAgbWF0Y2gxdG8zLCBtYXRjaDEpO1xuYWRkUmVnZXhUb2tlbignU1MnLCAgIG1hdGNoMXRvMywgbWF0Y2gyKTtcbmFkZFJlZ2V4VG9rZW4oJ1NTUycsICBtYXRjaDF0bzMsIG1hdGNoMyk7XG5cbnZhciB0b2tlbjtcbmZvciAodG9rZW4gPSAnU1NTUyc7IHRva2VuLmxlbmd0aCA8PSA5OyB0b2tlbiArPSAnUycpIHtcbiAgICBhZGRSZWdleFRva2VuKHRva2VuLCBtYXRjaFVuc2lnbmVkKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VNcyhpbnB1dCwgYXJyYXkpIHtcbiAgICBhcnJheVtNSUxMSVNFQ09ORF0gPSB0b0ludCgoJzAuJyArIGlucHV0KSAqIDEwMDApO1xufVxuXG5mb3IgKHRva2VuID0gJ1MnOyB0b2tlbi5sZW5ndGggPD0gOTsgdG9rZW4gKz0gJ1MnKSB7XG4gICAgYWRkUGFyc2VUb2tlbih0b2tlbiwgcGFyc2VNcyk7XG59XG4vLyBNT01FTlRTXG5cbnZhciBnZXRTZXRNaWxsaXNlY29uZCA9IG1ha2VHZXRTZXQoJ01pbGxpc2Vjb25kcycsIGZhbHNlKTtcblxuLy8gRk9STUFUVElOR1xuXG5hZGRGb3JtYXRUb2tlbigneicsICAwLCAwLCAnem9uZUFiYnInKTtcbmFkZEZvcm1hdFRva2VuKCd6eicsIDAsIDAsICd6b25lTmFtZScpO1xuXG4vLyBNT01FTlRTXG5cbmZ1bmN0aW9uIGdldFpvbmVBYmJyICgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNVVEMgPyAnVVRDJyA6ICcnO1xufVxuXG5mdW5jdGlvbiBnZXRab25lTmFtZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzVVRDID8gJ0Nvb3JkaW5hdGVkIFVuaXZlcnNhbCBUaW1lJyA6ICcnO1xufVxuXG52YXIgcHJvdG8gPSBNb21lbnQucHJvdG90eXBlO1xuXG5wcm90by5hZGQgICAgICAgICAgICAgICA9IGFkZDtcbnByb3RvLmNhbGVuZGFyICAgICAgICAgID0gY2FsZW5kYXIkMTtcbnByb3RvLmNsb25lICAgICAgICAgICAgID0gY2xvbmU7XG5wcm90by5kaWZmICAgICAgICAgICAgICA9IGRpZmY7XG5wcm90by5lbmRPZiAgICAgICAgICAgICA9IGVuZE9mO1xucHJvdG8uZm9ybWF0ICAgICAgICAgICAgPSBmb3JtYXQ7XG5wcm90by5mcm9tICAgICAgICAgICAgICA9IGZyb207XG5wcm90by5mcm9tTm93ICAgICAgICAgICA9IGZyb21Ob3c7XG5wcm90by50byAgICAgICAgICAgICAgICA9IHRvO1xucHJvdG8udG9Ob3cgICAgICAgICAgICAgPSB0b05vdztcbnByb3RvLmdldCAgICAgICAgICAgICAgID0gc3RyaW5nR2V0O1xucHJvdG8uaW52YWxpZEF0ICAgICAgICAgPSBpbnZhbGlkQXQ7XG5wcm90by5pc0FmdGVyICAgICAgICAgICA9IGlzQWZ0ZXI7XG5wcm90by5pc0JlZm9yZSAgICAgICAgICA9IGlzQmVmb3JlO1xucHJvdG8uaXNCZXR3ZWVuICAgICAgICAgPSBpc0JldHdlZW47XG5wcm90by5pc1NhbWUgICAgICAgICAgICA9IGlzU2FtZTtcbnByb3RvLmlzU2FtZU9yQWZ0ZXIgICAgID0gaXNTYW1lT3JBZnRlcjtcbnByb3RvLmlzU2FtZU9yQmVmb3JlICAgID0gaXNTYW1lT3JCZWZvcmU7XG5wcm90by5pc1ZhbGlkICAgICAgICAgICA9IGlzVmFsaWQkMjtcbnByb3RvLmxhbmcgICAgICAgICAgICAgID0gbGFuZztcbnByb3RvLmxvY2FsZSAgICAgICAgICAgID0gbG9jYWxlO1xucHJvdG8ubG9jYWxlRGF0YSAgICAgICAgPSBsb2NhbGVEYXRhO1xucHJvdG8ubWF4ICAgICAgICAgICAgICAgPSBwcm90b3R5cGVNYXg7XG5wcm90by5taW4gICAgICAgICAgICAgICA9IHByb3RvdHlwZU1pbjtcbnByb3RvLnBhcnNpbmdGbGFncyAgICAgID0gcGFyc2luZ0ZsYWdzO1xucHJvdG8uc2V0ICAgICAgICAgICAgICAgPSBzdHJpbmdTZXQ7XG5wcm90by5zdGFydE9mICAgICAgICAgICA9IHN0YXJ0T2Y7XG5wcm90by5zdWJ0cmFjdCAgICAgICAgICA9IHN1YnRyYWN0O1xucHJvdG8udG9BcnJheSAgICAgICAgICAgPSB0b0FycmF5O1xucHJvdG8udG9PYmplY3QgICAgICAgICAgPSB0b09iamVjdDtcbnByb3RvLnRvRGF0ZSAgICAgICAgICAgID0gdG9EYXRlO1xucHJvdG8udG9JU09TdHJpbmcgICAgICAgPSB0b0lTT1N0cmluZztcbnByb3RvLmluc3BlY3QgICAgICAgICAgID0gaW5zcGVjdDtcbnByb3RvLnRvSlNPTiAgICAgICAgICAgID0gdG9KU09OO1xucHJvdG8udG9TdHJpbmcgICAgICAgICAgPSB0b1N0cmluZztcbnByb3RvLnVuaXggICAgICAgICAgICAgID0gdW5peDtcbnByb3RvLnZhbHVlT2YgICAgICAgICAgID0gdmFsdWVPZjtcbnByb3RvLmNyZWF0aW9uRGF0YSAgICAgID0gY3JlYXRpb25EYXRhO1xuXG4vLyBZZWFyXG5wcm90by55ZWFyICAgICAgID0gZ2V0U2V0WWVhcjtcbnByb3RvLmlzTGVhcFllYXIgPSBnZXRJc0xlYXBZZWFyO1xuXG4vLyBXZWVrIFllYXJcbnByb3RvLndlZWtZZWFyICAgID0gZ2V0U2V0V2Vla1llYXI7XG5wcm90by5pc29XZWVrWWVhciA9IGdldFNldElTT1dlZWtZZWFyO1xuXG4vLyBRdWFydGVyXG5wcm90by5xdWFydGVyID0gcHJvdG8ucXVhcnRlcnMgPSBnZXRTZXRRdWFydGVyO1xuXG4vLyBNb250aFxucHJvdG8ubW9udGggICAgICAgPSBnZXRTZXRNb250aDtcbnByb3RvLmRheXNJbk1vbnRoID0gZ2V0RGF5c0luTW9udGg7XG5cbi8vIFdlZWtcbnByb3RvLndlZWsgICAgICAgICAgID0gcHJvdG8ud2Vla3MgICAgICAgID0gZ2V0U2V0V2VlaztcbnByb3RvLmlzb1dlZWsgICAgICAgID0gcHJvdG8uaXNvV2Vla3MgICAgID0gZ2V0U2V0SVNPV2VlaztcbnByb3RvLndlZWtzSW5ZZWFyICAgID0gZ2V0V2Vla3NJblllYXI7XG5wcm90by5pc29XZWVrc0luWWVhciA9IGdldElTT1dlZWtzSW5ZZWFyO1xuXG4vLyBEYXlcbnByb3RvLmRhdGUgICAgICAgPSBnZXRTZXREYXlPZk1vbnRoO1xucHJvdG8uZGF5ICAgICAgICA9IHByb3RvLmRheXMgICAgICAgICAgICAgPSBnZXRTZXREYXlPZldlZWs7XG5wcm90by53ZWVrZGF5ICAgID0gZ2V0U2V0TG9jYWxlRGF5T2ZXZWVrO1xucHJvdG8uaXNvV2Vla2RheSA9IGdldFNldElTT0RheU9mV2VlaztcbnByb3RvLmRheU9mWWVhciAgPSBnZXRTZXREYXlPZlllYXI7XG5cbi8vIEhvdXJcbnByb3RvLmhvdXIgPSBwcm90by5ob3VycyA9IGdldFNldEhvdXI7XG5cbi8vIE1pbnV0ZVxucHJvdG8ubWludXRlID0gcHJvdG8ubWludXRlcyA9IGdldFNldE1pbnV0ZTtcblxuLy8gU2Vjb25kXG5wcm90by5zZWNvbmQgPSBwcm90by5zZWNvbmRzID0gZ2V0U2V0U2Vjb25kO1xuXG4vLyBNaWxsaXNlY29uZFxucHJvdG8ubWlsbGlzZWNvbmQgPSBwcm90by5taWxsaXNlY29uZHMgPSBnZXRTZXRNaWxsaXNlY29uZDtcblxuLy8gT2Zmc2V0XG5wcm90by51dGNPZmZzZXQgICAgICAgICAgICA9IGdldFNldE9mZnNldDtcbnByb3RvLnV0YyAgICAgICAgICAgICAgICAgID0gc2V0T2Zmc2V0VG9VVEM7XG5wcm90by5sb2NhbCAgICAgICAgICAgICAgICA9IHNldE9mZnNldFRvTG9jYWw7XG5wcm90by5wYXJzZVpvbmUgICAgICAgICAgICA9IHNldE9mZnNldFRvUGFyc2VkT2Zmc2V0O1xucHJvdG8uaGFzQWxpZ25lZEhvdXJPZmZzZXQgPSBoYXNBbGlnbmVkSG91ck9mZnNldDtcbnByb3RvLmlzRFNUICAgICAgICAgICAgICAgID0gaXNEYXlsaWdodFNhdmluZ1RpbWU7XG5wcm90by5pc0xvY2FsICAgICAgICAgICAgICA9IGlzTG9jYWw7XG5wcm90by5pc1V0Y09mZnNldCAgICAgICAgICA9IGlzVXRjT2Zmc2V0O1xucHJvdG8uaXNVdGMgICAgICAgICAgICAgICAgPSBpc1V0YztcbnByb3RvLmlzVVRDICAgICAgICAgICAgICAgID0gaXNVdGM7XG5cbi8vIFRpbWV6b25lXG5wcm90by56b25lQWJiciA9IGdldFpvbmVBYmJyO1xucHJvdG8uem9uZU5hbWUgPSBnZXRab25lTmFtZTtcblxuLy8gRGVwcmVjYXRpb25zXG5wcm90by5kYXRlcyAgPSBkZXByZWNhdGUoJ2RhdGVzIGFjY2Vzc29yIGlzIGRlcHJlY2F0ZWQuIFVzZSBkYXRlIGluc3RlYWQuJywgZ2V0U2V0RGF5T2ZNb250aCk7XG5wcm90by5tb250aHMgPSBkZXByZWNhdGUoJ21vbnRocyBhY2Nlc3NvciBpcyBkZXByZWNhdGVkLiBVc2UgbW9udGggaW5zdGVhZCcsIGdldFNldE1vbnRoKTtcbnByb3RvLnllYXJzICA9IGRlcHJlY2F0ZSgneWVhcnMgYWNjZXNzb3IgaXMgZGVwcmVjYXRlZC4gVXNlIHllYXIgaW5zdGVhZCcsIGdldFNldFllYXIpO1xucHJvdG8uem9uZSAgID0gZGVwcmVjYXRlKCdtb21lbnQoKS56b25lIGlzIGRlcHJlY2F0ZWQsIHVzZSBtb21lbnQoKS51dGNPZmZzZXQgaW5zdGVhZC4gaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy96b25lLycsIGdldFNldFpvbmUpO1xucHJvdG8uaXNEU1RTaGlmdGVkID0gZGVwcmVjYXRlKCdpc0RTVFNoaWZ0ZWQgaXMgZGVwcmVjYXRlZC4gU2VlIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvZHN0LXNoaWZ0ZWQvIGZvciBtb3JlIGluZm9ybWF0aW9uJywgaXNEYXlsaWdodFNhdmluZ1RpbWVTaGlmdGVkKTtcblxuZnVuY3Rpb24gY3JlYXRlVW5peCAoaW5wdXQpIHtcbiAgICByZXR1cm4gY3JlYXRlTG9jYWwoaW5wdXQgKiAxMDAwKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlSW5ab25lICgpIHtcbiAgICByZXR1cm4gY3JlYXRlTG9jYWwuYXBwbHkobnVsbCwgYXJndW1lbnRzKS5wYXJzZVpvbmUoKTtcbn1cblxuZnVuY3Rpb24gcHJlUGFyc2VQb3N0Rm9ybWF0IChzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nO1xufVxuXG52YXIgcHJvdG8kMSA9IExvY2FsZS5wcm90b3R5cGU7XG5cbnByb3RvJDEuY2FsZW5kYXIgICAgICAgID0gY2FsZW5kYXI7XG5wcm90byQxLmxvbmdEYXRlRm9ybWF0ICA9IGxvbmdEYXRlRm9ybWF0O1xucHJvdG8kMS5pbnZhbGlkRGF0ZSAgICAgPSBpbnZhbGlkRGF0ZTtcbnByb3RvJDEub3JkaW5hbCAgICAgICAgID0gb3JkaW5hbDtcbnByb3RvJDEucHJlcGFyc2UgICAgICAgID0gcHJlUGFyc2VQb3N0Rm9ybWF0O1xucHJvdG8kMS5wb3N0Zm9ybWF0ICAgICAgPSBwcmVQYXJzZVBvc3RGb3JtYXQ7XG5wcm90byQxLnJlbGF0aXZlVGltZSAgICA9IHJlbGF0aXZlVGltZTtcbnByb3RvJDEucGFzdEZ1dHVyZSAgICAgID0gcGFzdEZ1dHVyZTtcbnByb3RvJDEuc2V0ICAgICAgICAgICAgID0gc2V0O1xuXG4vLyBNb250aFxucHJvdG8kMS5tb250aHMgICAgICAgICAgICA9ICAgICAgICBsb2NhbGVNb250aHM7XG5wcm90byQxLm1vbnRoc1Nob3J0ICAgICAgID0gICAgICAgIGxvY2FsZU1vbnRoc1Nob3J0O1xucHJvdG8kMS5tb250aHNQYXJzZSAgICAgICA9ICAgICAgICBsb2NhbGVNb250aHNQYXJzZTtcbnByb3RvJDEubW9udGhzUmVnZXggICAgICAgPSBtb250aHNSZWdleDtcbnByb3RvJDEubW9udGhzU2hvcnRSZWdleCAgPSBtb250aHNTaG9ydFJlZ2V4O1xuXG4vLyBXZWVrXG5wcm90byQxLndlZWsgPSBsb2NhbGVXZWVrO1xucHJvdG8kMS5maXJzdERheU9mWWVhciA9IGxvY2FsZUZpcnN0RGF5T2ZZZWFyO1xucHJvdG8kMS5maXJzdERheU9mV2VlayA9IGxvY2FsZUZpcnN0RGF5T2ZXZWVrO1xuXG4vLyBEYXkgb2YgV2Vla1xucHJvdG8kMS53ZWVrZGF5cyAgICAgICA9ICAgICAgICBsb2NhbGVXZWVrZGF5cztcbnByb3RvJDEud2Vla2RheXNNaW4gICAgPSAgICAgICAgbG9jYWxlV2Vla2RheXNNaW47XG5wcm90byQxLndlZWtkYXlzU2hvcnQgID0gICAgICAgIGxvY2FsZVdlZWtkYXlzU2hvcnQ7XG5wcm90byQxLndlZWtkYXlzUGFyc2UgID0gICAgICAgIGxvY2FsZVdlZWtkYXlzUGFyc2U7XG5cbnByb3RvJDEud2Vla2RheXNSZWdleCAgICAgICA9ICAgICAgICB3ZWVrZGF5c1JlZ2V4O1xucHJvdG8kMS53ZWVrZGF5c1Nob3J0UmVnZXggID0gICAgICAgIHdlZWtkYXlzU2hvcnRSZWdleDtcbnByb3RvJDEud2Vla2RheXNNaW5SZWdleCAgICA9ICAgICAgICB3ZWVrZGF5c01pblJlZ2V4O1xuXG4vLyBIb3Vyc1xucHJvdG8kMS5pc1BNID0gbG9jYWxlSXNQTTtcbnByb3RvJDEubWVyaWRpZW0gPSBsb2NhbGVNZXJpZGllbTtcblxuZnVuY3Rpb24gZ2V0JDEgKGZvcm1hdCwgaW5kZXgsIGZpZWxkLCBzZXR0ZXIpIHtcbiAgICB2YXIgbG9jYWxlID0gZ2V0TG9jYWxlKCk7XG4gICAgdmFyIHV0YyA9IGNyZWF0ZVVUQygpLnNldChzZXR0ZXIsIGluZGV4KTtcbiAgICByZXR1cm4gbG9jYWxlW2ZpZWxkXSh1dGMsIGZvcm1hdCk7XG59XG5cbmZ1bmN0aW9uIGxpc3RNb250aHNJbXBsIChmb3JtYXQsIGluZGV4LCBmaWVsZCkge1xuICAgIGlmIChpc051bWJlcihmb3JtYXQpKSB7XG4gICAgICAgIGluZGV4ID0gZm9ybWF0O1xuICAgICAgICBmb3JtYXQgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgZm9ybWF0ID0gZm9ybWF0IHx8ICcnO1xuXG4gICAgaWYgKGluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGdldCQxKGZvcm1hdCwgaW5kZXgsIGZpZWxkLCAnbW9udGgnKTtcbiAgICB9XG5cbiAgICB2YXIgaTtcbiAgICB2YXIgb3V0ID0gW107XG4gICAgZm9yIChpID0gMDsgaSA8IDEyOyBpKyspIHtcbiAgICAgICAgb3V0W2ldID0gZ2V0JDEoZm9ybWF0LCBpLCBmaWVsZCwgJ21vbnRoJyk7XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG59XG5cbi8vICgpXG4vLyAoNSlcbi8vIChmbXQsIDUpXG4vLyAoZm10KVxuLy8gKHRydWUpXG4vLyAodHJ1ZSwgNSlcbi8vICh0cnVlLCBmbXQsIDUpXG4vLyAodHJ1ZSwgZm10KVxuZnVuY3Rpb24gbGlzdFdlZWtkYXlzSW1wbCAobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4LCBmaWVsZCkge1xuICAgIGlmICh0eXBlb2YgbG9jYWxlU29ydGVkID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgaWYgKGlzTnVtYmVyKGZvcm1hdCkpIHtcbiAgICAgICAgICAgIGluZGV4ID0gZm9ybWF0O1xuICAgICAgICAgICAgZm9ybWF0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9ybWF0ID0gZm9ybWF0IHx8ICcnO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvcm1hdCA9IGxvY2FsZVNvcnRlZDtcbiAgICAgICAgaW5kZXggPSBmb3JtYXQ7XG4gICAgICAgIGxvY2FsZVNvcnRlZCA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChpc051bWJlcihmb3JtYXQpKSB7XG4gICAgICAgICAgICBpbmRleCA9IGZvcm1hdDtcbiAgICAgICAgICAgIGZvcm1hdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvcm1hdCA9IGZvcm1hdCB8fCAnJztcbiAgICB9XG5cbiAgICB2YXIgbG9jYWxlID0gZ2V0TG9jYWxlKCksXG4gICAgICAgIHNoaWZ0ID0gbG9jYWxlU29ydGVkID8gbG9jYWxlLl93ZWVrLmRvdyA6IDA7XG5cbiAgICBpZiAoaW5kZXggIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZ2V0JDEoZm9ybWF0LCAoaW5kZXggKyBzaGlmdCkgJSA3LCBmaWVsZCwgJ2RheScpO1xuICAgIH1cblxuICAgIHZhciBpO1xuICAgIHZhciBvdXQgPSBbXTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgIG91dFtpXSA9IGdldCQxKGZvcm1hdCwgKGkgKyBzaGlmdCkgJSA3LCBmaWVsZCwgJ2RheScpO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xufVxuXG5mdW5jdGlvbiBsaXN0TW9udGhzIChmb3JtYXQsIGluZGV4KSB7XG4gICAgcmV0dXJuIGxpc3RNb250aHNJbXBsKGZvcm1hdCwgaW5kZXgsICdtb250aHMnKTtcbn1cblxuZnVuY3Rpb24gbGlzdE1vbnRoc1Nob3J0IChmb3JtYXQsIGluZGV4KSB7XG4gICAgcmV0dXJuIGxpc3RNb250aHNJbXBsKGZvcm1hdCwgaW5kZXgsICdtb250aHNTaG9ydCcpO1xufVxuXG5mdW5jdGlvbiBsaXN0V2Vla2RheXMgKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCkge1xuICAgIHJldHVybiBsaXN0V2Vla2RheXNJbXBsKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCwgJ3dlZWtkYXlzJyk7XG59XG5cbmZ1bmN0aW9uIGxpc3RXZWVrZGF5c1Nob3J0IChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgpIHtcbiAgICByZXR1cm4gbGlzdFdlZWtkYXlzSW1wbChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgsICd3ZWVrZGF5c1Nob3J0Jyk7XG59XG5cbmZ1bmN0aW9uIGxpc3RXZWVrZGF5c01pbiAobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4KSB7XG4gICAgcmV0dXJuIGxpc3RXZWVrZGF5c0ltcGwobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4LCAnd2Vla2RheXNNaW4nKTtcbn1cblxuZ2V0U2V0R2xvYmFsTG9jYWxlKCdlbicsIHtcbiAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOiAvXFxkezEsMn0odGh8c3R8bmR8cmQpLyxcbiAgICBvcmRpbmFsIDogZnVuY3Rpb24gKG51bWJlcikge1xuICAgICAgICB2YXIgYiA9IG51bWJlciAlIDEwLFxuICAgICAgICAgICAgb3V0cHV0ID0gKHRvSW50KG51bWJlciAlIDEwMCAvIDEwKSA9PT0gMSkgPyAndGgnIDpcbiAgICAgICAgICAgIChiID09PSAxKSA/ICdzdCcgOlxuICAgICAgICAgICAgKGIgPT09IDIpID8gJ25kJyA6XG4gICAgICAgICAgICAoYiA9PT0gMykgPyAncmQnIDogJ3RoJztcbiAgICAgICAgcmV0dXJuIG51bWJlciArIG91dHB1dDtcbiAgICB9XG59KTtcblxuLy8gU2lkZSBlZmZlY3QgaW1wb3J0c1xuaG9va3MubGFuZyA9IGRlcHJlY2F0ZSgnbW9tZW50LmxhbmcgaXMgZGVwcmVjYXRlZC4gVXNlIG1vbWVudC5sb2NhbGUgaW5zdGVhZC4nLCBnZXRTZXRHbG9iYWxMb2NhbGUpO1xuaG9va3MubGFuZ0RhdGEgPSBkZXByZWNhdGUoJ21vbWVudC5sYW5nRGF0YSBpcyBkZXByZWNhdGVkLiBVc2UgbW9tZW50LmxvY2FsZURhdGEgaW5zdGVhZC4nLCBnZXRMb2NhbGUpO1xuXG52YXIgbWF0aEFicyA9IE1hdGguYWJzO1xuXG5mdW5jdGlvbiBhYnMgKCkge1xuICAgIHZhciBkYXRhICAgICAgICAgICA9IHRoaXMuX2RhdGE7XG5cbiAgICB0aGlzLl9taWxsaXNlY29uZHMgPSBtYXRoQWJzKHRoaXMuX21pbGxpc2Vjb25kcyk7XG4gICAgdGhpcy5fZGF5cyAgICAgICAgID0gbWF0aEFicyh0aGlzLl9kYXlzKTtcbiAgICB0aGlzLl9tb250aHMgICAgICAgPSBtYXRoQWJzKHRoaXMuX21vbnRocyk7XG5cbiAgICBkYXRhLm1pbGxpc2Vjb25kcyAgPSBtYXRoQWJzKGRhdGEubWlsbGlzZWNvbmRzKTtcbiAgICBkYXRhLnNlY29uZHMgICAgICAgPSBtYXRoQWJzKGRhdGEuc2Vjb25kcyk7XG4gICAgZGF0YS5taW51dGVzICAgICAgID0gbWF0aEFicyhkYXRhLm1pbnV0ZXMpO1xuICAgIGRhdGEuaG91cnMgICAgICAgICA9IG1hdGhBYnMoZGF0YS5ob3Vycyk7XG4gICAgZGF0YS5tb250aHMgICAgICAgID0gbWF0aEFicyhkYXRhLm1vbnRocyk7XG4gICAgZGF0YS55ZWFycyAgICAgICAgID0gbWF0aEFicyhkYXRhLnllYXJzKTtcblxuICAgIHJldHVybiB0aGlzO1xufVxuXG5mdW5jdGlvbiBhZGRTdWJ0cmFjdCQxIChkdXJhdGlvbiwgaW5wdXQsIHZhbHVlLCBkaXJlY3Rpb24pIHtcbiAgICB2YXIgb3RoZXIgPSBjcmVhdGVEdXJhdGlvbihpbnB1dCwgdmFsdWUpO1xuXG4gICAgZHVyYXRpb24uX21pbGxpc2Vjb25kcyArPSBkaXJlY3Rpb24gKiBvdGhlci5fbWlsbGlzZWNvbmRzO1xuICAgIGR1cmF0aW9uLl9kYXlzICAgICAgICAgKz0gZGlyZWN0aW9uICogb3RoZXIuX2RheXM7XG4gICAgZHVyYXRpb24uX21vbnRocyAgICAgICArPSBkaXJlY3Rpb24gKiBvdGhlci5fbW9udGhzO1xuXG4gICAgcmV0dXJuIGR1cmF0aW9uLl9idWJibGUoKTtcbn1cblxuLy8gc3VwcG9ydHMgb25seSAyLjAtc3R5bGUgYWRkKDEsICdzJykgb3IgYWRkKGR1cmF0aW9uKVxuZnVuY3Rpb24gYWRkJDEgKGlucHV0LCB2YWx1ZSkge1xuICAgIHJldHVybiBhZGRTdWJ0cmFjdCQxKHRoaXMsIGlucHV0LCB2YWx1ZSwgMSk7XG59XG5cbi8vIHN1cHBvcnRzIG9ubHkgMi4wLXN0eWxlIHN1YnRyYWN0KDEsICdzJykgb3Igc3VidHJhY3QoZHVyYXRpb24pXG5mdW5jdGlvbiBzdWJ0cmFjdCQxIChpbnB1dCwgdmFsdWUpIHtcbiAgICByZXR1cm4gYWRkU3VidHJhY3QkMSh0aGlzLCBpbnB1dCwgdmFsdWUsIC0xKTtcbn1cblxuZnVuY3Rpb24gYWJzQ2VpbCAobnVtYmVyKSB7XG4gICAgaWYgKG51bWJlciA8IDApIHtcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IobnVtYmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gTWF0aC5jZWlsKG51bWJlcik7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBidWJibGUgKCkge1xuICAgIHZhciBtaWxsaXNlY29uZHMgPSB0aGlzLl9taWxsaXNlY29uZHM7XG4gICAgdmFyIGRheXMgICAgICAgICA9IHRoaXMuX2RheXM7XG4gICAgdmFyIG1vbnRocyAgICAgICA9IHRoaXMuX21vbnRocztcbiAgICB2YXIgZGF0YSAgICAgICAgID0gdGhpcy5fZGF0YTtcbiAgICB2YXIgc2Vjb25kcywgbWludXRlcywgaG91cnMsIHllYXJzLCBtb250aHNGcm9tRGF5cztcblxuICAgIC8vIGlmIHdlIGhhdmUgYSBtaXggb2YgcG9zaXRpdmUgYW5kIG5lZ2F0aXZlIHZhbHVlcywgYnViYmxlIGRvd24gZmlyc3RcbiAgICAvLyBjaGVjazogaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvaXNzdWVzLzIxNjZcbiAgICBpZiAoISgobWlsbGlzZWNvbmRzID49IDAgJiYgZGF5cyA+PSAwICYmIG1vbnRocyA+PSAwKSB8fFxuICAgICAgICAgICAgKG1pbGxpc2Vjb25kcyA8PSAwICYmIGRheXMgPD0gMCAmJiBtb250aHMgPD0gMCkpKSB7XG4gICAgICAgIG1pbGxpc2Vjb25kcyArPSBhYnNDZWlsKG1vbnRoc1RvRGF5cyhtb250aHMpICsgZGF5cykgKiA4NjRlNTtcbiAgICAgICAgZGF5cyA9IDA7XG4gICAgICAgIG1vbnRocyA9IDA7XG4gICAgfVxuXG4gICAgLy8gVGhlIGZvbGxvd2luZyBjb2RlIGJ1YmJsZXMgdXAgdmFsdWVzLCBzZWUgdGhlIHRlc3RzIGZvclxuICAgIC8vIGV4YW1wbGVzIG9mIHdoYXQgdGhhdCBtZWFucy5cbiAgICBkYXRhLm1pbGxpc2Vjb25kcyA9IG1pbGxpc2Vjb25kcyAlIDEwMDA7XG5cbiAgICBzZWNvbmRzICAgICAgICAgICA9IGFic0Zsb29yKG1pbGxpc2Vjb25kcyAvIDEwMDApO1xuICAgIGRhdGEuc2Vjb25kcyAgICAgID0gc2Vjb25kcyAlIDYwO1xuXG4gICAgbWludXRlcyAgICAgICAgICAgPSBhYnNGbG9vcihzZWNvbmRzIC8gNjApO1xuICAgIGRhdGEubWludXRlcyAgICAgID0gbWludXRlcyAlIDYwO1xuXG4gICAgaG91cnMgICAgICAgICAgICAgPSBhYnNGbG9vcihtaW51dGVzIC8gNjApO1xuICAgIGRhdGEuaG91cnMgICAgICAgID0gaG91cnMgJSAyNDtcblxuICAgIGRheXMgKz0gYWJzRmxvb3IoaG91cnMgLyAyNCk7XG5cbiAgICAvLyBjb252ZXJ0IGRheXMgdG8gbW9udGhzXG4gICAgbW9udGhzRnJvbURheXMgPSBhYnNGbG9vcihkYXlzVG9Nb250aHMoZGF5cykpO1xuICAgIG1vbnRocyArPSBtb250aHNGcm9tRGF5cztcbiAgICBkYXlzIC09IGFic0NlaWwobW9udGhzVG9EYXlzKG1vbnRoc0Zyb21EYXlzKSk7XG5cbiAgICAvLyAxMiBtb250aHMgLT4gMSB5ZWFyXG4gICAgeWVhcnMgPSBhYnNGbG9vcihtb250aHMgLyAxMik7XG4gICAgbW9udGhzICU9IDEyO1xuXG4gICAgZGF0YS5kYXlzICAgPSBkYXlzO1xuICAgIGRhdGEubW9udGhzID0gbW9udGhzO1xuICAgIGRhdGEueWVhcnMgID0geWVhcnM7XG5cbiAgICByZXR1cm4gdGhpcztcbn1cblxuZnVuY3Rpb24gZGF5c1RvTW9udGhzIChkYXlzKSB7XG4gICAgLy8gNDAwIHllYXJzIGhhdmUgMTQ2MDk3IGRheXMgKHRha2luZyBpbnRvIGFjY291bnQgbGVhcCB5ZWFyIHJ1bGVzKVxuICAgIC8vIDQwMCB5ZWFycyBoYXZlIDEyIG1vbnRocyA9PT0gNDgwMFxuICAgIHJldHVybiBkYXlzICogNDgwMCAvIDE0NjA5Nztcbn1cblxuZnVuY3Rpb24gbW9udGhzVG9EYXlzIChtb250aHMpIHtcbiAgICAvLyB0aGUgcmV2ZXJzZSBvZiBkYXlzVG9Nb250aHNcbiAgICByZXR1cm4gbW9udGhzICogMTQ2MDk3IC8gNDgwMDtcbn1cblxuZnVuY3Rpb24gYXMgKHVuaXRzKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICByZXR1cm4gTmFOO1xuICAgIH1cbiAgICB2YXIgZGF5cztcbiAgICB2YXIgbW9udGhzO1xuICAgIHZhciBtaWxsaXNlY29uZHMgPSB0aGlzLl9taWxsaXNlY29uZHM7XG5cbiAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcblxuICAgIGlmICh1bml0cyA9PT0gJ21vbnRoJyB8fCB1bml0cyA9PT0gJ3llYXInKSB7XG4gICAgICAgIGRheXMgICA9IHRoaXMuX2RheXMgICArIG1pbGxpc2Vjb25kcyAvIDg2NGU1O1xuICAgICAgICBtb250aHMgPSB0aGlzLl9tb250aHMgKyBkYXlzVG9Nb250aHMoZGF5cyk7XG4gICAgICAgIHJldHVybiB1bml0cyA9PT0gJ21vbnRoJyA/IG1vbnRocyA6IG1vbnRocyAvIDEyO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGhhbmRsZSBtaWxsaXNlY29uZHMgc2VwYXJhdGVseSBiZWNhdXNlIG9mIGZsb2F0aW5nIHBvaW50IG1hdGggZXJyb3JzIChpc3N1ZSAjMTg2NylcbiAgICAgICAgZGF5cyA9IHRoaXMuX2RheXMgKyBNYXRoLnJvdW5kKG1vbnRoc1RvRGF5cyh0aGlzLl9tb250aHMpKTtcbiAgICAgICAgc3dpdGNoICh1bml0cykge1xuICAgICAgICAgICAgY2FzZSAnd2VlaycgICA6IHJldHVybiBkYXlzIC8gNyAgICAgKyBtaWxsaXNlY29uZHMgLyA2MDQ4ZTU7XG4gICAgICAgICAgICBjYXNlICdkYXknICAgIDogcmV0dXJuIGRheXMgICAgICAgICArIG1pbGxpc2Vjb25kcyAvIDg2NGU1O1xuICAgICAgICAgICAgY2FzZSAnaG91cicgICA6IHJldHVybiBkYXlzICogMjQgICAgKyBtaWxsaXNlY29uZHMgLyAzNmU1O1xuICAgICAgICAgICAgY2FzZSAnbWludXRlJyA6IHJldHVybiBkYXlzICogMTQ0MCAgKyBtaWxsaXNlY29uZHMgLyA2ZTQ7XG4gICAgICAgICAgICBjYXNlICdzZWNvbmQnIDogcmV0dXJuIGRheXMgKiA4NjQwMCArIG1pbGxpc2Vjb25kcyAvIDEwMDA7XG4gICAgICAgICAgICAvLyBNYXRoLmZsb29yIHByZXZlbnRzIGZsb2F0aW5nIHBvaW50IG1hdGggZXJyb3JzIGhlcmVcbiAgICAgICAgICAgIGNhc2UgJ21pbGxpc2Vjb25kJzogcmV0dXJuIE1hdGguZmxvb3IoZGF5cyAqIDg2NGU1KSArIG1pbGxpc2Vjb25kcztcbiAgICAgICAgICAgIGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvcignVW5rbm93biB1bml0ICcgKyB1bml0cyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8vIFRPRE86IFVzZSB0aGlzLmFzKCdtcycpP1xuZnVuY3Rpb24gdmFsdWVPZiQxICgpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgIHJldHVybiBOYU47XG4gICAgfVxuICAgIHJldHVybiAoXG4gICAgICAgIHRoaXMuX21pbGxpc2Vjb25kcyArXG4gICAgICAgIHRoaXMuX2RheXMgKiA4NjRlNSArXG4gICAgICAgICh0aGlzLl9tb250aHMgJSAxMikgKiAyNTkyZTYgK1xuICAgICAgICB0b0ludCh0aGlzLl9tb250aHMgLyAxMikgKiAzMTUzNmU2XG4gICAgKTtcbn1cblxuZnVuY3Rpb24gbWFrZUFzIChhbGlhcykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFzKGFsaWFzKTtcbiAgICB9O1xufVxuXG52YXIgYXNNaWxsaXNlY29uZHMgPSBtYWtlQXMoJ21zJyk7XG52YXIgYXNTZWNvbmRzICAgICAgPSBtYWtlQXMoJ3MnKTtcbnZhciBhc01pbnV0ZXMgICAgICA9IG1ha2VBcygnbScpO1xudmFyIGFzSG91cnMgICAgICAgID0gbWFrZUFzKCdoJyk7XG52YXIgYXNEYXlzICAgICAgICAgPSBtYWtlQXMoJ2QnKTtcbnZhciBhc1dlZWtzICAgICAgICA9IG1ha2VBcygndycpO1xudmFyIGFzTW9udGhzICAgICAgID0gbWFrZUFzKCdNJyk7XG52YXIgYXNZZWFycyAgICAgICAgPSBtYWtlQXMoJ3knKTtcblxuZnVuY3Rpb24gY2xvbmUkMSAoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUR1cmF0aW9uKHRoaXMpO1xufVxuXG5mdW5jdGlvbiBnZXQkMiAodW5pdHMpIHtcbiAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyB0aGlzW3VuaXRzICsgJ3MnXSgpIDogTmFOO1xufVxuXG5mdW5jdGlvbiBtYWtlR2V0dGVyKG5hbWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyB0aGlzLl9kYXRhW25hbWVdIDogTmFOO1xuICAgIH07XG59XG5cbnZhciBtaWxsaXNlY29uZHMgPSBtYWtlR2V0dGVyKCdtaWxsaXNlY29uZHMnKTtcbnZhciBzZWNvbmRzICAgICAgPSBtYWtlR2V0dGVyKCdzZWNvbmRzJyk7XG52YXIgbWludXRlcyAgICAgID0gbWFrZUdldHRlcignbWludXRlcycpO1xudmFyIGhvdXJzICAgICAgICA9IG1ha2VHZXR0ZXIoJ2hvdXJzJyk7XG52YXIgZGF5cyAgICAgICAgID0gbWFrZUdldHRlcignZGF5cycpO1xudmFyIG1vbnRocyAgICAgICA9IG1ha2VHZXR0ZXIoJ21vbnRocycpO1xudmFyIHllYXJzICAgICAgICA9IG1ha2VHZXR0ZXIoJ3llYXJzJyk7XG5cbmZ1bmN0aW9uIHdlZWtzICgpIHtcbiAgICByZXR1cm4gYWJzRmxvb3IodGhpcy5kYXlzKCkgLyA3KTtcbn1cblxudmFyIHJvdW5kID0gTWF0aC5yb3VuZDtcbnZhciB0aHJlc2hvbGRzID0ge1xuICAgIHNzOiA0NCwgICAgICAgICAvLyBhIGZldyBzZWNvbmRzIHRvIHNlY29uZHNcbiAgICBzIDogNDUsICAgICAgICAgLy8gc2Vjb25kcyB0byBtaW51dGVcbiAgICBtIDogNDUsICAgICAgICAgLy8gbWludXRlcyB0byBob3VyXG4gICAgaCA6IDIyLCAgICAgICAgIC8vIGhvdXJzIHRvIGRheVxuICAgIGQgOiAyNiwgICAgICAgICAvLyBkYXlzIHRvIG1vbnRoXG4gICAgTSA6IDExICAgICAgICAgIC8vIG1vbnRocyB0byB5ZWFyXG59O1xuXG4vLyBoZWxwZXIgZnVuY3Rpb24gZm9yIG1vbWVudC5mbi5mcm9tLCBtb21lbnQuZm4uZnJvbU5vdywgYW5kIG1vbWVudC5kdXJhdGlvbi5mbi5odW1hbml6ZVxuZnVuY3Rpb24gc3Vic3RpdHV0ZVRpbWVBZ28oc3RyaW5nLCBudW1iZXIsIHdpdGhvdXRTdWZmaXgsIGlzRnV0dXJlLCBsb2NhbGUpIHtcbiAgICByZXR1cm4gbG9jYWxlLnJlbGF0aXZlVGltZShudW1iZXIgfHwgMSwgISF3aXRob3V0U3VmZml4LCBzdHJpbmcsIGlzRnV0dXJlKTtcbn1cblxuZnVuY3Rpb24gcmVsYXRpdmVUaW1lJDEgKHBvc05lZ0R1cmF0aW9uLCB3aXRob3V0U3VmZml4LCBsb2NhbGUpIHtcbiAgICB2YXIgZHVyYXRpb24gPSBjcmVhdGVEdXJhdGlvbihwb3NOZWdEdXJhdGlvbikuYWJzKCk7XG4gICAgdmFyIHNlY29uZHMgID0gcm91bmQoZHVyYXRpb24uYXMoJ3MnKSk7XG4gICAgdmFyIG1pbnV0ZXMgID0gcm91bmQoZHVyYXRpb24uYXMoJ20nKSk7XG4gICAgdmFyIGhvdXJzICAgID0gcm91bmQoZHVyYXRpb24uYXMoJ2gnKSk7XG4gICAgdmFyIGRheXMgICAgID0gcm91bmQoZHVyYXRpb24uYXMoJ2QnKSk7XG4gICAgdmFyIG1vbnRocyAgID0gcm91bmQoZHVyYXRpb24uYXMoJ00nKSk7XG4gICAgdmFyIHllYXJzICAgID0gcm91bmQoZHVyYXRpb24uYXMoJ3knKSk7XG5cbiAgICB2YXIgYSA9IHNlY29uZHMgPD0gdGhyZXNob2xkcy5zcyAmJiBbJ3MnLCBzZWNvbmRzXSAgfHxcbiAgICAgICAgICAgIHNlY29uZHMgPCB0aHJlc2hvbGRzLnMgICAmJiBbJ3NzJywgc2Vjb25kc10gfHxcbiAgICAgICAgICAgIG1pbnV0ZXMgPD0gMSAgICAgICAgICAgICAmJiBbJ20nXSAgICAgICAgICAgfHxcbiAgICAgICAgICAgIG1pbnV0ZXMgPCB0aHJlc2hvbGRzLm0gICAmJiBbJ21tJywgbWludXRlc10gfHxcbiAgICAgICAgICAgIGhvdXJzICAgPD0gMSAgICAgICAgICAgICAmJiBbJ2gnXSAgICAgICAgICAgfHxcbiAgICAgICAgICAgIGhvdXJzICAgPCB0aHJlc2hvbGRzLmggICAmJiBbJ2hoJywgaG91cnNdICAgfHxcbiAgICAgICAgICAgIGRheXMgICAgPD0gMSAgICAgICAgICAgICAmJiBbJ2QnXSAgICAgICAgICAgfHxcbiAgICAgICAgICAgIGRheXMgICAgPCB0aHJlc2hvbGRzLmQgICAmJiBbJ2RkJywgZGF5c10gICAgfHxcbiAgICAgICAgICAgIG1vbnRocyAgPD0gMSAgICAgICAgICAgICAmJiBbJ00nXSAgICAgICAgICAgfHxcbiAgICAgICAgICAgIG1vbnRocyAgPCB0aHJlc2hvbGRzLk0gICAmJiBbJ01NJywgbW9udGhzXSAgfHxcbiAgICAgICAgICAgIHllYXJzICAgPD0gMSAgICAgICAgICAgICAmJiBbJ3knXSAgICAgICAgICAgfHwgWyd5eScsIHllYXJzXTtcblxuICAgIGFbMl0gPSB3aXRob3V0U3VmZml4O1xuICAgIGFbM10gPSArcG9zTmVnRHVyYXRpb24gPiAwO1xuICAgIGFbNF0gPSBsb2NhbGU7XG4gICAgcmV0dXJuIHN1YnN0aXR1dGVUaW1lQWdvLmFwcGx5KG51bGwsIGEpO1xufVxuXG4vLyBUaGlzIGZ1bmN0aW9uIGFsbG93cyB5b3UgdG8gc2V0IHRoZSByb3VuZGluZyBmdW5jdGlvbiBmb3IgcmVsYXRpdmUgdGltZSBzdHJpbmdzXG5mdW5jdGlvbiBnZXRTZXRSZWxhdGl2ZVRpbWVSb3VuZGluZyAocm91bmRpbmdGdW5jdGlvbikge1xuICAgIGlmIChyb3VuZGluZ0Z1bmN0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHJvdW5kO1xuICAgIH1cbiAgICBpZiAodHlwZW9mKHJvdW5kaW5nRnVuY3Rpb24pID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJvdW5kID0gcm91bmRpbmdGdW5jdGlvbjtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuLy8gVGhpcyBmdW5jdGlvbiBhbGxvd3MgeW91IHRvIHNldCBhIHRocmVzaG9sZCBmb3IgcmVsYXRpdmUgdGltZSBzdHJpbmdzXG5mdW5jdGlvbiBnZXRTZXRSZWxhdGl2ZVRpbWVUaHJlc2hvbGQgKHRocmVzaG9sZCwgbGltaXQpIHtcbiAgICBpZiAodGhyZXNob2xkc1t0aHJlc2hvbGRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAobGltaXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdGhyZXNob2xkc1t0aHJlc2hvbGRdO1xuICAgIH1cbiAgICB0aHJlc2hvbGRzW3RocmVzaG9sZF0gPSBsaW1pdDtcbiAgICBpZiAodGhyZXNob2xkID09PSAncycpIHtcbiAgICAgICAgdGhyZXNob2xkcy5zcyA9IGxpbWl0IC0gMTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGh1bWFuaXplICh3aXRoU3VmZml4KSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkuaW52YWxpZERhdGUoKTtcbiAgICB9XG5cbiAgICB2YXIgbG9jYWxlID0gdGhpcy5sb2NhbGVEYXRhKCk7XG4gICAgdmFyIG91dHB1dCA9IHJlbGF0aXZlVGltZSQxKHRoaXMsICF3aXRoU3VmZml4LCBsb2NhbGUpO1xuXG4gICAgaWYgKHdpdGhTdWZmaXgpIHtcbiAgICAgICAgb3V0cHV0ID0gbG9jYWxlLnBhc3RGdXR1cmUoK3RoaXMsIG91dHB1dCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxvY2FsZS5wb3N0Zm9ybWF0KG91dHB1dCk7XG59XG5cbnZhciBhYnMkMSA9IE1hdGguYWJzO1xuXG5mdW5jdGlvbiBzaWduKHgpIHtcbiAgICByZXR1cm4gKCh4ID4gMCkgLSAoeCA8IDApKSB8fCAreDtcbn1cblxuZnVuY3Rpb24gdG9JU09TdHJpbmckMSgpIHtcbiAgICAvLyBmb3IgSVNPIHN0cmluZ3Mgd2UgZG8gbm90IHVzZSB0aGUgbm9ybWFsIGJ1YmJsaW5nIHJ1bGVzOlxuICAgIC8vICAqIG1pbGxpc2Vjb25kcyBidWJibGUgdXAgdW50aWwgdGhleSBiZWNvbWUgaG91cnNcbiAgICAvLyAgKiBkYXlzIGRvIG5vdCBidWJibGUgYXQgYWxsXG4gICAgLy8gICogbW9udGhzIGJ1YmJsZSB1cCB1bnRpbCB0aGV5IGJlY29tZSB5ZWFyc1xuICAgIC8vIFRoaXMgaXMgYmVjYXVzZSB0aGVyZSBpcyBubyBjb250ZXh0LWZyZWUgY29udmVyc2lvbiBiZXR3ZWVuIGhvdXJzIGFuZCBkYXlzXG4gICAgLy8gKHRoaW5rIG9mIGNsb2NrIGNoYW5nZXMpXG4gICAgLy8gYW5kIGFsc28gbm90IGJldHdlZW4gZGF5cyBhbmQgbW9udGhzICgyOC0zMSBkYXlzIHBlciBtb250aClcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xuICAgIH1cblxuICAgIHZhciBzZWNvbmRzID0gYWJzJDEodGhpcy5fbWlsbGlzZWNvbmRzKSAvIDEwMDA7XG4gICAgdmFyIGRheXMgICAgICAgICA9IGFicyQxKHRoaXMuX2RheXMpO1xuICAgIHZhciBtb250aHMgICAgICAgPSBhYnMkMSh0aGlzLl9tb250aHMpO1xuICAgIHZhciBtaW51dGVzLCBob3VycywgeWVhcnM7XG5cbiAgICAvLyAzNjAwIHNlY29uZHMgLT4gNjAgbWludXRlcyAtPiAxIGhvdXJcbiAgICBtaW51dGVzICAgICAgICAgICA9IGFic0Zsb29yKHNlY29uZHMgLyA2MCk7XG4gICAgaG91cnMgICAgICAgICAgICAgPSBhYnNGbG9vcihtaW51dGVzIC8gNjApO1xuICAgIHNlY29uZHMgJT0gNjA7XG4gICAgbWludXRlcyAlPSA2MDtcblxuICAgIC8vIDEyIG1vbnRocyAtPiAxIHllYXJcbiAgICB5ZWFycyAgPSBhYnNGbG9vcihtb250aHMgLyAxMik7XG4gICAgbW9udGhzICU9IDEyO1xuXG5cbiAgICAvLyBpbnNwaXJlZCBieSBodHRwczovL2dpdGh1Yi5jb20vZG9yZGlsbGUvbW9tZW50LWlzb2R1cmF0aW9uL2Jsb2IvbWFzdGVyL21vbWVudC5pc29kdXJhdGlvbi5qc1xuICAgIHZhciBZID0geWVhcnM7XG4gICAgdmFyIE0gPSBtb250aHM7XG4gICAgdmFyIEQgPSBkYXlzO1xuICAgIHZhciBoID0gaG91cnM7XG4gICAgdmFyIG0gPSBtaW51dGVzO1xuICAgIHZhciBzID0gc2Vjb25kcyA/IHNlY29uZHMudG9GaXhlZCgzKS5yZXBsYWNlKC9cXC4/MCskLywgJycpIDogJyc7XG4gICAgdmFyIHRvdGFsID0gdGhpcy5hc1NlY29uZHMoKTtcblxuICAgIGlmICghdG90YWwpIHtcbiAgICAgICAgLy8gdGhpcyBpcyB0aGUgc2FtZSBhcyBDIydzIChOb2RhKSBhbmQgcHl0aG9uIChpc29kYXRlKS4uLlxuICAgICAgICAvLyBidXQgbm90IG90aGVyIEpTIChnb29nLmRhdGUpXG4gICAgICAgIHJldHVybiAnUDBEJztcbiAgICB9XG5cbiAgICB2YXIgdG90YWxTaWduID0gdG90YWwgPCAwID8gJy0nIDogJyc7XG4gICAgdmFyIHltU2lnbiA9IHNpZ24odGhpcy5fbW9udGhzKSAhPT0gc2lnbih0b3RhbCkgPyAnLScgOiAnJztcbiAgICB2YXIgZGF5c1NpZ24gPSBzaWduKHRoaXMuX2RheXMpICE9PSBzaWduKHRvdGFsKSA/ICctJyA6ICcnO1xuICAgIHZhciBobXNTaWduID0gc2lnbih0aGlzLl9taWxsaXNlY29uZHMpICE9PSBzaWduKHRvdGFsKSA/ICctJyA6ICcnO1xuXG4gICAgcmV0dXJuIHRvdGFsU2lnbiArICdQJyArXG4gICAgICAgIChZID8geW1TaWduICsgWSArICdZJyA6ICcnKSArXG4gICAgICAgIChNID8geW1TaWduICsgTSArICdNJyA6ICcnKSArXG4gICAgICAgIChEID8gZGF5c1NpZ24gKyBEICsgJ0QnIDogJycpICtcbiAgICAgICAgKChoIHx8IG0gfHwgcykgPyAnVCcgOiAnJykgK1xuICAgICAgICAoaCA/IGhtc1NpZ24gKyBoICsgJ0gnIDogJycpICtcbiAgICAgICAgKG0gPyBobXNTaWduICsgbSArICdNJyA6ICcnKSArXG4gICAgICAgIChzID8gaG1zU2lnbiArIHMgKyAnUycgOiAnJyk7XG59XG5cbnZhciBwcm90byQyID0gRHVyYXRpb24ucHJvdG90eXBlO1xuXG5wcm90byQyLmlzVmFsaWQgICAgICAgID0gaXNWYWxpZCQxO1xucHJvdG8kMi5hYnMgICAgICAgICAgICA9IGFicztcbnByb3RvJDIuYWRkICAgICAgICAgICAgPSBhZGQkMTtcbnByb3RvJDIuc3VidHJhY3QgICAgICAgPSBzdWJ0cmFjdCQxO1xucHJvdG8kMi5hcyAgICAgICAgICAgICA9IGFzO1xucHJvdG8kMi5hc01pbGxpc2Vjb25kcyA9IGFzTWlsbGlzZWNvbmRzO1xucHJvdG8kMi5hc1NlY29uZHMgICAgICA9IGFzU2Vjb25kcztcbnByb3RvJDIuYXNNaW51dGVzICAgICAgPSBhc01pbnV0ZXM7XG5wcm90byQyLmFzSG91cnMgICAgICAgID0gYXNIb3VycztcbnByb3RvJDIuYXNEYXlzICAgICAgICAgPSBhc0RheXM7XG5wcm90byQyLmFzV2Vla3MgICAgICAgID0gYXNXZWVrcztcbnByb3RvJDIuYXNNb250aHMgICAgICAgPSBhc01vbnRocztcbnByb3RvJDIuYXNZZWFycyAgICAgICAgPSBhc1llYXJzO1xucHJvdG8kMi52YWx1ZU9mICAgICAgICA9IHZhbHVlT2YkMTtcbnByb3RvJDIuX2J1YmJsZSAgICAgICAgPSBidWJibGU7XG5wcm90byQyLmNsb25lICAgICAgICAgID0gY2xvbmUkMTtcbnByb3RvJDIuZ2V0ICAgICAgICAgICAgPSBnZXQkMjtcbnByb3RvJDIubWlsbGlzZWNvbmRzICAgPSBtaWxsaXNlY29uZHM7XG5wcm90byQyLnNlY29uZHMgICAgICAgID0gc2Vjb25kcztcbnByb3RvJDIubWludXRlcyAgICAgICAgPSBtaW51dGVzO1xucHJvdG8kMi5ob3VycyAgICAgICAgICA9IGhvdXJzO1xucHJvdG8kMi5kYXlzICAgICAgICAgICA9IGRheXM7XG5wcm90byQyLndlZWtzICAgICAgICAgID0gd2Vla3M7XG5wcm90byQyLm1vbnRocyAgICAgICAgID0gbW9udGhzO1xucHJvdG8kMi55ZWFycyAgICAgICAgICA9IHllYXJzO1xucHJvdG8kMi5odW1hbml6ZSAgICAgICA9IGh1bWFuaXplO1xucHJvdG8kMi50b0lTT1N0cmluZyAgICA9IHRvSVNPU3RyaW5nJDE7XG5wcm90byQyLnRvU3RyaW5nICAgICAgID0gdG9JU09TdHJpbmckMTtcbnByb3RvJDIudG9KU09OICAgICAgICAgPSB0b0lTT1N0cmluZyQxO1xucHJvdG8kMi5sb2NhbGUgICAgICAgICA9IGxvY2FsZTtcbnByb3RvJDIubG9jYWxlRGF0YSAgICAgPSBsb2NhbGVEYXRhO1xuXG4vLyBEZXByZWNhdGlvbnNcbnByb3RvJDIudG9Jc29TdHJpbmcgPSBkZXByZWNhdGUoJ3RvSXNvU3RyaW5nKCkgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSB0b0lTT1N0cmluZygpIGluc3RlYWQgKG5vdGljZSB0aGUgY2FwaXRhbHMpJywgdG9JU09TdHJpbmckMSk7XG5wcm90byQyLmxhbmcgPSBsYW5nO1xuXG4vLyBTaWRlIGVmZmVjdCBpbXBvcnRzXG5cbi8vIEZPUk1BVFRJTkdcblxuYWRkRm9ybWF0VG9rZW4oJ1gnLCAwLCAwLCAndW5peCcpO1xuYWRkRm9ybWF0VG9rZW4oJ3gnLCAwLCAwLCAndmFsdWVPZicpO1xuXG4vLyBQQVJTSU5HXG5cbmFkZFJlZ2V4VG9rZW4oJ3gnLCBtYXRjaFNpZ25lZCk7XG5hZGRSZWdleFRva2VuKCdYJywgbWF0Y2hUaW1lc3RhbXApO1xuYWRkUGFyc2VUb2tlbignWCcsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKHBhcnNlRmxvYXQoaW5wdXQsIDEwKSAqIDEwMDApO1xufSk7XG5hZGRQYXJzZVRva2VuKCd4JywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgY29uZmlnLl9kID0gbmV3IERhdGUodG9JbnQoaW5wdXQpKTtcbn0pO1xuXG4vLyBTaWRlIGVmZmVjdCBpbXBvcnRzXG5cblxuaG9va3MudmVyc2lvbiA9ICcyLjIwLjEnO1xuXG5zZXRIb29rQ2FsbGJhY2soY3JlYXRlTG9jYWwpO1xuXG5ob29rcy5mbiAgICAgICAgICAgICAgICAgICAgPSBwcm90bztcbmhvb2tzLm1pbiAgICAgICAgICAgICAgICAgICA9IG1pbjtcbmhvb2tzLm1heCAgICAgICAgICAgICAgICAgICA9IG1heDtcbmhvb2tzLm5vdyAgICAgICAgICAgICAgICAgICA9IG5vdztcbmhvb2tzLnV0YyAgICAgICAgICAgICAgICAgICA9IGNyZWF0ZVVUQztcbmhvb2tzLnVuaXggICAgICAgICAgICAgICAgICA9IGNyZWF0ZVVuaXg7XG5ob29rcy5tb250aHMgICAgICAgICAgICAgICAgPSBsaXN0TW9udGhzO1xuaG9va3MuaXNEYXRlICAgICAgICAgICAgICAgID0gaXNEYXRlO1xuaG9va3MubG9jYWxlICAgICAgICAgICAgICAgID0gZ2V0U2V0R2xvYmFsTG9jYWxlO1xuaG9va3MuaW52YWxpZCAgICAgICAgICAgICAgID0gY3JlYXRlSW52YWxpZDtcbmhvb2tzLmR1cmF0aW9uICAgICAgICAgICAgICA9IGNyZWF0ZUR1cmF0aW9uO1xuaG9va3MuaXNNb21lbnQgICAgICAgICAgICAgID0gaXNNb21lbnQ7XG5ob29rcy53ZWVrZGF5cyAgICAgICAgICAgICAgPSBsaXN0V2Vla2RheXM7XG5ob29rcy5wYXJzZVpvbmUgICAgICAgICAgICAgPSBjcmVhdGVJblpvbmU7XG5ob29rcy5sb2NhbGVEYXRhICAgICAgICAgICAgPSBnZXRMb2NhbGU7XG5ob29rcy5pc0R1cmF0aW9uICAgICAgICAgICAgPSBpc0R1cmF0aW9uO1xuaG9va3MubW9udGhzU2hvcnQgICAgICAgICAgID0gbGlzdE1vbnRoc1Nob3J0O1xuaG9va3Mud2Vla2RheXNNaW4gICAgICAgICAgID0gbGlzdFdlZWtkYXlzTWluO1xuaG9va3MuZGVmaW5lTG9jYWxlICAgICAgICAgID0gZGVmaW5lTG9jYWxlO1xuaG9va3MudXBkYXRlTG9jYWxlICAgICAgICAgID0gdXBkYXRlTG9jYWxlO1xuaG9va3MubG9jYWxlcyAgICAgICAgICAgICAgID0gbGlzdExvY2FsZXM7XG5ob29rcy53ZWVrZGF5c1Nob3J0ICAgICAgICAgPSBsaXN0V2Vla2RheXNTaG9ydDtcbmhvb2tzLm5vcm1hbGl6ZVVuaXRzICAgICAgICA9IG5vcm1hbGl6ZVVuaXRzO1xuaG9va3MucmVsYXRpdmVUaW1lUm91bmRpbmcgID0gZ2V0U2V0UmVsYXRpdmVUaW1lUm91bmRpbmc7XG5ob29rcy5yZWxhdGl2ZVRpbWVUaHJlc2hvbGQgPSBnZXRTZXRSZWxhdGl2ZVRpbWVUaHJlc2hvbGQ7XG5ob29rcy5jYWxlbmRhckZvcm1hdCAgICAgICAgPSBnZXRDYWxlbmRhckZvcm1hdDtcbmhvb2tzLnByb3RvdHlwZSAgICAgICAgICAgICA9IHByb3RvO1xuXG4vLyBjdXJyZW50bHkgSFRNTDUgaW5wdXQgdHlwZSBvbmx5IHN1cHBvcnRzIDI0LWhvdXIgZm9ybWF0c1xuaG9va3MuSFRNTDVfRk1UID0ge1xuICAgIERBVEVUSU1FX0xPQ0FMOiAnWVlZWS1NTS1ERFRISDptbScsICAgICAgICAgICAgIC8vIDxpbnB1dCB0eXBlPVwiZGF0ZXRpbWUtbG9jYWxcIiAvPlxuICAgIERBVEVUSU1FX0xPQ0FMX1NFQ09ORFM6ICdZWVlZLU1NLUREVEhIOm1tOnNzJywgIC8vIDxpbnB1dCB0eXBlPVwiZGF0ZXRpbWUtbG9jYWxcIiBzdGVwPVwiMVwiIC8+XG4gICAgREFURVRJTUVfTE9DQUxfTVM6ICdZWVlZLU1NLUREVEhIOm1tOnNzLlNTUycsICAgLy8gPGlucHV0IHR5cGU9XCJkYXRldGltZS1sb2NhbFwiIHN0ZXA9XCIwLjAwMVwiIC8+XG4gICAgREFURTogJ1lZWVktTU0tREQnLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gPGlucHV0IHR5cGU9XCJkYXRlXCIgLz5cbiAgICBUSU1FOiAnSEg6bW0nLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyA8aW5wdXQgdHlwZT1cInRpbWVcIiAvPlxuICAgIFRJTUVfU0VDT05EUzogJ0hIOm1tOnNzJywgICAgICAgICAgICAgICAgICAgICAgIC8vIDxpbnB1dCB0eXBlPVwidGltZVwiIHN0ZXA9XCIxXCIgLz5cbiAgICBUSU1FX01TOiAnSEg6bW06c3MuU1NTJywgICAgICAgICAgICAgICAgICAgICAgICAvLyA8aW5wdXQgdHlwZT1cInRpbWVcIiBzdGVwPVwiMC4wMDFcIiAvPlxuICAgIFdFRUs6ICdZWVlZLVtXXVdXJywgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDxpbnB1dCB0eXBlPVwid2Vla1wiIC8+XG4gICAgTU9OVEg6ICdZWVlZLU1NJyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gPGlucHV0IHR5cGU9XCJtb250aFwiIC8+XG59O1xuXG5yZXR1cm4gaG9va3M7XG5cbn0pKSk7XG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9pbmRleCcpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3BvbnlmaWxsID0gcmVxdWlyZSgnLi9wb255ZmlsbC5qcycpO1xuXG52YXIgX3BvbnlmaWxsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3BvbnlmaWxsKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgcm9vdDsgLyogZ2xvYmFsIHdpbmRvdyAqL1xuXG5cbmlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgcm9vdCA9IHNlbGY7XG59IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gIHJvb3QgPSB3aW5kb3c7XG59IGVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XG4gIHJvb3QgPSBnbG9iYWw7XG59IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnKSB7XG4gIHJvb3QgPSBtb2R1bGU7XG59IGVsc2Uge1xuICByb290ID0gRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcbn1cblxudmFyIHJlc3VsdCA9ICgwLCBfcG9ueWZpbGwyWydkZWZhdWx0J10pKHJvb3QpO1xuZXhwb3J0c1snZGVmYXVsdCddID0gcmVzdWx0OyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IHN5bWJvbE9ic2VydmFibGVQb255ZmlsbDtcbmZ1bmN0aW9uIHN5bWJvbE9ic2VydmFibGVQb255ZmlsbChyb290KSB7XG5cdHZhciByZXN1bHQ7XG5cdHZhciBfU3ltYm9sID0gcm9vdC5TeW1ib2w7XG5cblx0aWYgKHR5cGVvZiBfU3ltYm9sID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0aWYgKF9TeW1ib2wub2JzZXJ2YWJsZSkge1xuXHRcdFx0cmVzdWx0ID0gX1N5bWJvbC5vYnNlcnZhYmxlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXN1bHQgPSBfU3ltYm9sKCdvYnNlcnZhYmxlJyk7XG5cdFx0XHRfU3ltYm9sLm9ic2VydmFibGUgPSByZXN1bHQ7XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdHJlc3VsdCA9ICdAQG9ic2VydmFibGUnO1xuXHR9XG5cblx0cmV0dXJuIHJlc3VsdDtcbn07IiwiLyohXG4gKiBWdWUuanMgdjIuNS4xM1xuICogKGMpIDIwMTQtMjAxNyBFdmFuIFlvdVxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbi8qICAqL1xuXG52YXIgZW1wdHlPYmplY3QgPSBPYmplY3QuZnJlZXplKHt9KTtcblxuLy8gdGhlc2UgaGVscGVycyBwcm9kdWNlcyBiZXR0ZXIgdm0gY29kZSBpbiBKUyBlbmdpbmVzIGR1ZSB0byB0aGVpclxuLy8gZXhwbGljaXRuZXNzIGFuZCBmdW5jdGlvbiBpbmxpbmluZ1xuZnVuY3Rpb24gaXNVbmRlZiAodikge1xuICByZXR1cm4gdiA9PT0gdW5kZWZpbmVkIHx8IHYgPT09IG51bGxcbn1cblxuZnVuY3Rpb24gaXNEZWYgKHYpIHtcbiAgcmV0dXJuIHYgIT09IHVuZGVmaW5lZCAmJiB2ICE9PSBudWxsXG59XG5cbmZ1bmN0aW9uIGlzVHJ1ZSAodikge1xuICByZXR1cm4gdiA9PT0gdHJ1ZVxufVxuXG5mdW5jdGlvbiBpc0ZhbHNlICh2KSB7XG4gIHJldHVybiB2ID09PSBmYWxzZVxufVxuXG4vKipcbiAqIENoZWNrIGlmIHZhbHVlIGlzIHByaW1pdGl2ZVxuICovXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZSAodmFsdWUpIHtcbiAgcmV0dXJuIChcbiAgICB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8XG4gICAgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyB8fFxuICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ3N5bWJvbCcgfHxcbiAgICB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJ1xuICApXG59XG5cbi8qKlxuICogUXVpY2sgb2JqZWN0IGNoZWNrIC0gdGhpcyBpcyBwcmltYXJpbHkgdXNlZCB0byB0ZWxsXG4gKiBPYmplY3RzIGZyb20gcHJpbWl0aXZlIHZhbHVlcyB3aGVuIHdlIGtub3cgdGhlIHZhbHVlXG4gKiBpcyBhIEpTT04tY29tcGxpYW50IHR5cGUuXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0IChvYmopIHtcbiAgcmV0dXJuIG9iaiAhPT0gbnVsbCAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0J1xufVxuXG4vKipcbiAqIEdldCB0aGUgcmF3IHR5cGUgc3RyaW5nIG9mIGEgdmFsdWUgZS5nLiBbb2JqZWN0IE9iamVjdF1cbiAqL1xudmFyIF90b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbmZ1bmN0aW9uIHRvUmF3VHlwZSAodmFsdWUpIHtcbiAgcmV0dXJuIF90b1N0cmluZy5jYWxsKHZhbHVlKS5zbGljZSg4LCAtMSlcbn1cblxuLyoqXG4gKiBTdHJpY3Qgb2JqZWN0IHR5cGUgY2hlY2suIE9ubHkgcmV0dXJucyB0cnVlXG4gKiBmb3IgcGxhaW4gSmF2YVNjcmlwdCBvYmplY3RzLlxuICovXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0IChvYmopIHtcbiAgcmV0dXJuIF90b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IE9iamVjdF0nXG59XG5cbmZ1bmN0aW9uIGlzUmVnRXhwICh2KSB7XG4gIHJldHVybiBfdG9TdHJpbmcuY2FsbCh2KSA9PT0gJ1tvYmplY3QgUmVnRXhwXSdcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB2YWwgaXMgYSB2YWxpZCBhcnJheSBpbmRleC5cbiAqL1xuZnVuY3Rpb24gaXNWYWxpZEFycmF5SW5kZXggKHZhbCkge1xuICB2YXIgbiA9IHBhcnNlRmxvYXQoU3RyaW5nKHZhbCkpO1xuICByZXR1cm4gbiA+PSAwICYmIE1hdGguZmxvb3IobikgPT09IG4gJiYgaXNGaW5pdGUodmFsKVxufVxuXG4vKipcbiAqIENvbnZlcnQgYSB2YWx1ZSB0byBhIHN0cmluZyB0aGF0IGlzIGFjdHVhbGx5IHJlbmRlcmVkLlxuICovXG5mdW5jdGlvbiB0b1N0cmluZyAodmFsKSB7XG4gIHJldHVybiB2YWwgPT0gbnVsbFxuICAgID8gJydcbiAgICA6IHR5cGVvZiB2YWwgPT09ICdvYmplY3QnXG4gICAgICA/IEpTT04uc3RyaW5naWZ5KHZhbCwgbnVsbCwgMilcbiAgICAgIDogU3RyaW5nKHZhbClcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgaW5wdXQgdmFsdWUgdG8gYSBudW1iZXIgZm9yIHBlcnNpc3RlbmNlLlxuICogSWYgdGhlIGNvbnZlcnNpb24gZmFpbHMsIHJldHVybiBvcmlnaW5hbCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIHRvTnVtYmVyICh2YWwpIHtcbiAgdmFyIG4gPSBwYXJzZUZsb2F0KHZhbCk7XG4gIHJldHVybiBpc05hTihuKSA/IHZhbCA6IG5cbn1cblxuLyoqXG4gKiBNYWtlIGEgbWFwIGFuZCByZXR1cm4gYSBmdW5jdGlvbiBmb3IgY2hlY2tpbmcgaWYgYSBrZXlcbiAqIGlzIGluIHRoYXQgbWFwLlxuICovXG5mdW5jdGlvbiBtYWtlTWFwIChcbiAgc3RyLFxuICBleHBlY3RzTG93ZXJDYXNlXG4pIHtcbiAgdmFyIG1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHZhciBsaXN0ID0gc3RyLnNwbGl0KCcsJyk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIG1hcFtsaXN0W2ldXSA9IHRydWU7XG4gIH1cbiAgcmV0dXJuIGV4cGVjdHNMb3dlckNhc2VcbiAgICA/IGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIG1hcFt2YWwudG9Mb3dlckNhc2UoKV07IH1cbiAgICA6IGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIG1hcFt2YWxdOyB9XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSB0YWcgaXMgYSBidWlsdC1pbiB0YWcuXG4gKi9cbnZhciBpc0J1aWx0SW5UYWcgPSBtYWtlTWFwKCdzbG90LGNvbXBvbmVudCcsIHRydWUpO1xuXG4vKipcbiAqIENoZWNrIGlmIGEgYXR0cmlidXRlIGlzIGEgcmVzZXJ2ZWQgYXR0cmlidXRlLlxuICovXG52YXIgaXNSZXNlcnZlZEF0dHJpYnV0ZSA9IG1ha2VNYXAoJ2tleSxyZWYsc2xvdCxzbG90LXNjb3BlLGlzJyk7XG5cbi8qKlxuICogUmVtb3ZlIGFuIGl0ZW0gZnJvbSBhbiBhcnJheVxuICovXG5mdW5jdGlvbiByZW1vdmUgKGFyciwgaXRlbSkge1xuICBpZiAoYXJyLmxlbmd0aCkge1xuICAgIHZhciBpbmRleCA9IGFyci5pbmRleE9mKGl0ZW0pO1xuICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICByZXR1cm4gYXJyLnNwbGljZShpbmRleCwgMSlcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBvYmplY3QgaGFzIHRoZSBwcm9wZXJ0eS5cbiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbmZ1bmN0aW9uIGhhc093biAob2JqLCBrZXkpIHtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpXG59XG5cbi8qKlxuICogQ3JlYXRlIGEgY2FjaGVkIHZlcnNpb24gb2YgYSBwdXJlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjYWNoZWQgKGZuKSB7XG4gIHZhciBjYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHJldHVybiAoZnVuY3Rpb24gY2FjaGVkRm4gKHN0cikge1xuICAgIHZhciBoaXQgPSBjYWNoZVtzdHJdO1xuICAgIHJldHVybiBoaXQgfHwgKGNhY2hlW3N0cl0gPSBmbihzdHIpKVxuICB9KVxufVxuXG4vKipcbiAqIENhbWVsaXplIGEgaHlwaGVuLWRlbGltaXRlZCBzdHJpbmcuXG4gKi9cbnZhciBjYW1lbGl6ZVJFID0gLy0oXFx3KS9nO1xudmFyIGNhbWVsaXplID0gY2FjaGVkKGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKGNhbWVsaXplUkUsIGZ1bmN0aW9uIChfLCBjKSB7IHJldHVybiBjID8gYy50b1VwcGVyQ2FzZSgpIDogJyc7IH0pXG59KTtcblxuLyoqXG4gKiBDYXBpdGFsaXplIGEgc3RyaW5nLlxuICovXG52YXIgY2FwaXRhbGl6ZSA9IGNhY2hlZChmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSlcbn0pO1xuXG4vKipcbiAqIEh5cGhlbmF0ZSBhIGNhbWVsQ2FzZSBzdHJpbmcuXG4gKi9cbnZhciBoeXBoZW5hdGVSRSA9IC9cXEIoW0EtWl0pL2c7XG52YXIgaHlwaGVuYXRlID0gY2FjaGVkKGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKGh5cGhlbmF0ZVJFLCAnLSQxJykudG9Mb3dlckNhc2UoKVxufSk7XG5cbi8qKlxuICogU2ltcGxlIGJpbmQsIGZhc3RlciB0aGFuIG5hdGl2ZVxuICovXG5mdW5jdGlvbiBiaW5kIChmbiwgY3R4KSB7XG4gIGZ1bmN0aW9uIGJvdW5kRm4gKGEpIHtcbiAgICB2YXIgbCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgcmV0dXJuIGxcbiAgICAgID8gbCA+IDFcbiAgICAgICAgPyBmbi5hcHBseShjdHgsIGFyZ3VtZW50cylcbiAgICAgICAgOiBmbi5jYWxsKGN0eCwgYSlcbiAgICAgIDogZm4uY2FsbChjdHgpXG4gIH1cbiAgLy8gcmVjb3JkIG9yaWdpbmFsIGZuIGxlbmd0aFxuICBib3VuZEZuLl9sZW5ndGggPSBmbi5sZW5ndGg7XG4gIHJldHVybiBib3VuZEZuXG59XG5cbi8qKlxuICogQ29udmVydCBhbiBBcnJheS1saWtlIG9iamVjdCB0byBhIHJlYWwgQXJyYXkuXG4gKi9cbmZ1bmN0aW9uIHRvQXJyYXkgKGxpc3QsIHN0YXJ0KSB7XG4gIHN0YXJ0ID0gc3RhcnQgfHwgMDtcbiAgdmFyIGkgPSBsaXN0Lmxlbmd0aCAtIHN0YXJ0O1xuICB2YXIgcmV0ID0gbmV3IEFycmF5KGkpO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgcmV0W2ldID0gbGlzdFtpICsgc3RhcnRdO1xuICB9XG4gIHJldHVybiByZXRcbn1cblxuLyoqXG4gKiBNaXggcHJvcGVydGllcyBpbnRvIHRhcmdldCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGV4dGVuZCAodG8sIF9mcm9tKSB7XG4gIGZvciAodmFyIGtleSBpbiBfZnJvbSkge1xuICAgIHRvW2tleV0gPSBfZnJvbVtrZXldO1xuICB9XG4gIHJldHVybiB0b1xufVxuXG4vKipcbiAqIE1lcmdlIGFuIEFycmF5IG9mIE9iamVjdHMgaW50byBhIHNpbmdsZSBPYmplY3QuXG4gKi9cbmZ1bmN0aW9uIHRvT2JqZWN0IChhcnIpIHtcbiAgdmFyIHJlcyA9IHt9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGlmIChhcnJbaV0pIHtcbiAgICAgIGV4dGVuZChyZXMsIGFycltpXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyoqXG4gKiBQZXJmb3JtIG5vIG9wZXJhdGlvbi5cbiAqIFN0dWJiaW5nIGFyZ3MgdG8gbWFrZSBGbG93IGhhcHB5IHdpdGhvdXQgbGVhdmluZyB1c2VsZXNzIHRyYW5zcGlsZWQgY29kZVxuICogd2l0aCAuLi5yZXN0IChodHRwczovL2Zsb3cub3JnL2Jsb2cvMjAxNy8wNS8wNy9TdHJpY3QtRnVuY3Rpb24tQ2FsbC1Bcml0eS8pXG4gKi9cbmZ1bmN0aW9uIG5vb3AgKGEsIGIsIGMpIHt9XG5cbi8qKlxuICogQWx3YXlzIHJldHVybiBmYWxzZS5cbiAqL1xudmFyIG5vID0gZnVuY3Rpb24gKGEsIGIsIGMpIHsgcmV0dXJuIGZhbHNlOyB9O1xuXG4vKipcbiAqIFJldHVybiBzYW1lIHZhbHVlXG4gKi9cbnZhciBpZGVudGl0eSA9IGZ1bmN0aW9uIChfKSB7IHJldHVybiBfOyB9O1xuXG4vKipcbiAqIEdlbmVyYXRlIGEgc3RhdGljIGtleXMgc3RyaW5nIGZyb20gY29tcGlsZXIgbW9kdWxlcy5cbiAqL1xuXG5cbi8qKlxuICogQ2hlY2sgaWYgdHdvIHZhbHVlcyBhcmUgbG9vc2VseSBlcXVhbCAtIHRoYXQgaXMsXG4gKiBpZiB0aGV5IGFyZSBwbGFpbiBvYmplY3RzLCBkbyB0aGV5IGhhdmUgdGhlIHNhbWUgc2hhcGU/XG4gKi9cbmZ1bmN0aW9uIGxvb3NlRXF1YWwgKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHsgcmV0dXJuIHRydWUgfVxuICB2YXIgaXNPYmplY3RBID0gaXNPYmplY3QoYSk7XG4gIHZhciBpc09iamVjdEIgPSBpc09iamVjdChiKTtcbiAgaWYgKGlzT2JqZWN0QSAmJiBpc09iamVjdEIpIHtcbiAgICB0cnkge1xuICAgICAgdmFyIGlzQXJyYXlBID0gQXJyYXkuaXNBcnJheShhKTtcbiAgICAgIHZhciBpc0FycmF5QiA9IEFycmF5LmlzQXJyYXkoYik7XG4gICAgICBpZiAoaXNBcnJheUEgJiYgaXNBcnJheUIpIHtcbiAgICAgICAgcmV0dXJuIGEubGVuZ3RoID09PSBiLmxlbmd0aCAmJiBhLmV2ZXJ5KGZ1bmN0aW9uIChlLCBpKSB7XG4gICAgICAgICAgcmV0dXJuIGxvb3NlRXF1YWwoZSwgYltpXSlcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSBpZiAoIWlzQXJyYXlBICYmICFpc0FycmF5Qikge1xuICAgICAgICB2YXIga2V5c0EgPSBPYmplY3Qua2V5cyhhKTtcbiAgICAgICAgdmFyIGtleXNCID0gT2JqZWN0LmtleXMoYik7XG4gICAgICAgIHJldHVybiBrZXlzQS5sZW5ndGggPT09IGtleXNCLmxlbmd0aCAmJiBrZXlzQS5ldmVyeShmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgcmV0dXJuIGxvb3NlRXF1YWwoYVtrZXldLCBiW2tleV0pXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9IGVsc2UgaWYgKCFpc09iamVjdEEgJiYgIWlzT2JqZWN0Qikge1xuICAgIHJldHVybiBTdHJpbmcoYSkgPT09IFN0cmluZyhiKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbmZ1bmN0aW9uIGxvb3NlSW5kZXhPZiAoYXJyLCB2YWwpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAobG9vc2VFcXVhbChhcnJbaV0sIHZhbCkpIHsgcmV0dXJuIGkgfVxuICB9XG4gIHJldHVybiAtMVxufVxuXG4vKipcbiAqIEVuc3VyZSBhIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbmx5IG9uY2UuXG4gKi9cbmZ1bmN0aW9uIG9uY2UgKGZuKSB7XG4gIHZhciBjYWxsZWQgPSBmYWxzZTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIWNhbGxlZCkge1xuICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9XG59XG5cbnZhciBTU1JfQVRUUiA9ICdkYXRhLXNlcnZlci1yZW5kZXJlZCc7XG5cbnZhciBBU1NFVF9UWVBFUyA9IFtcbiAgJ2NvbXBvbmVudCcsXG4gICdkaXJlY3RpdmUnLFxuICAnZmlsdGVyJ1xuXTtcblxudmFyIExJRkVDWUNMRV9IT09LUyA9IFtcbiAgJ2JlZm9yZUNyZWF0ZScsXG4gICdjcmVhdGVkJyxcbiAgJ2JlZm9yZU1vdW50JyxcbiAgJ21vdW50ZWQnLFxuICAnYmVmb3JlVXBkYXRlJyxcbiAgJ3VwZGF0ZWQnLFxuICAnYmVmb3JlRGVzdHJveScsXG4gICdkZXN0cm95ZWQnLFxuICAnYWN0aXZhdGVkJyxcbiAgJ2RlYWN0aXZhdGVkJyxcbiAgJ2Vycm9yQ2FwdHVyZWQnXG5dO1xuXG4vKiAgKi9cblxudmFyIGNvbmZpZyA9ICh7XG4gIC8qKlxuICAgKiBPcHRpb24gbWVyZ2Ugc3RyYXRlZ2llcyAodXNlZCBpbiBjb3JlL3V0aWwvb3B0aW9ucylcbiAgICovXG4gIC8vICRmbG93LWRpc2FibGUtbGluZVxuICBvcHRpb25NZXJnZVN0cmF0ZWdpZXM6IE9iamVjdC5jcmVhdGUobnVsbCksXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gc3VwcHJlc3Mgd2FybmluZ3MuXG4gICAqL1xuICBzaWxlbnQ6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBTaG93IHByb2R1Y3Rpb24gbW9kZSB0aXAgbWVzc2FnZSBvbiBib290P1xuICAgKi9cbiAgcHJvZHVjdGlvblRpcDogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyxcblxuICAvKipcbiAgICogV2hldGhlciB0byBlbmFibGUgZGV2dG9vbHNcbiAgICovXG4gIGRldnRvb2xzOiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHJlY29yZCBwZXJmXG4gICAqL1xuICBwZXJmb3JtYW5jZTogZmFsc2UsXG5cbiAgLyoqXG4gICAqIEVycm9yIGhhbmRsZXIgZm9yIHdhdGNoZXIgZXJyb3JzXG4gICAqL1xuICBlcnJvckhhbmRsZXI6IG51bGwsXG5cbiAgLyoqXG4gICAqIFdhcm4gaGFuZGxlciBmb3Igd2F0Y2hlciB3YXJuc1xuICAgKi9cbiAgd2FybkhhbmRsZXI6IG51bGwsXG5cbiAgLyoqXG4gICAqIElnbm9yZSBjZXJ0YWluIGN1c3RvbSBlbGVtZW50c1xuICAgKi9cbiAgaWdub3JlZEVsZW1lbnRzOiBbXSxcblxuICAvKipcbiAgICogQ3VzdG9tIHVzZXIga2V5IGFsaWFzZXMgZm9yIHYtb25cbiAgICovXG4gIC8vICRmbG93LWRpc2FibGUtbGluZVxuICBrZXlDb2RlczogT2JqZWN0LmNyZWF0ZShudWxsKSxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYSB0YWcgaXMgcmVzZXJ2ZWQgc28gdGhhdCBpdCBjYW5ub3QgYmUgcmVnaXN0ZXJlZCBhcyBhXG4gICAqIGNvbXBvbmVudC4gVGhpcyBpcyBwbGF0Zm9ybS1kZXBlbmRlbnQgYW5kIG1heSBiZSBvdmVyd3JpdHRlbi5cbiAgICovXG4gIGlzUmVzZXJ2ZWRUYWc6IG5vLFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhbiBhdHRyaWJ1dGUgaXMgcmVzZXJ2ZWQgc28gdGhhdCBpdCBjYW5ub3QgYmUgdXNlZCBhcyBhIGNvbXBvbmVudFxuICAgKiBwcm9wLiBUaGlzIGlzIHBsYXRmb3JtLWRlcGVuZGVudCBhbmQgbWF5IGJlIG92ZXJ3cml0dGVuLlxuICAgKi9cbiAgaXNSZXNlcnZlZEF0dHI6IG5vLFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIHRhZyBpcyBhbiB1bmtub3duIGVsZW1lbnQuXG4gICAqIFBsYXRmb3JtLWRlcGVuZGVudC5cbiAgICovXG4gIGlzVW5rbm93bkVsZW1lbnQ6IG5vLFxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG5hbWVzcGFjZSBvZiBhbiBlbGVtZW50XG4gICAqL1xuICBnZXRUYWdOYW1lc3BhY2U6IG5vb3AsXG5cbiAgLyoqXG4gICAqIFBhcnNlIHRoZSByZWFsIHRhZyBuYW1lIGZvciB0aGUgc3BlY2lmaWMgcGxhdGZvcm0uXG4gICAqL1xuICBwYXJzZVBsYXRmb3JtVGFnTmFtZTogaWRlbnRpdHksXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGFuIGF0dHJpYnV0ZSBtdXN0IGJlIGJvdW5kIHVzaW5nIHByb3BlcnR5LCBlLmcuIHZhbHVlXG4gICAqIFBsYXRmb3JtLWRlcGVuZGVudC5cbiAgICovXG4gIG11c3RVc2VQcm9wOiBubyxcblxuICAvKipcbiAgICogRXhwb3NlZCBmb3IgbGVnYWN5IHJlYXNvbnNcbiAgICovXG4gIF9saWZlY3ljbGVIb29rczogTElGRUNZQ0xFX0hPT0tTXG59KTtcblxuLyogICovXG5cbi8qKlxuICogQ2hlY2sgaWYgYSBzdHJpbmcgc3RhcnRzIHdpdGggJCBvciBfXG4gKi9cbmZ1bmN0aW9uIGlzUmVzZXJ2ZWQgKHN0cikge1xuICB2YXIgYyA9IChzdHIgKyAnJykuY2hhckNvZGVBdCgwKTtcbiAgcmV0dXJuIGMgPT09IDB4MjQgfHwgYyA9PT0gMHg1RlxufVxuXG4vKipcbiAqIERlZmluZSBhIHByb3BlcnR5LlxuICovXG5mdW5jdGlvbiBkZWYgKG9iaiwga2V5LCB2YWwsIGVudW1lcmFibGUpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgdmFsdWU6IHZhbCxcbiAgICBlbnVtZXJhYmxlOiAhIWVudW1lcmFibGUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG4vKipcbiAqIFBhcnNlIHNpbXBsZSBwYXRoLlxuICovXG52YXIgYmFpbFJFID0gL1teXFx3LiRdLztcbmZ1bmN0aW9uIHBhcnNlUGF0aCAocGF0aCkge1xuICBpZiAoYmFpbFJFLnRlc3QocGF0aCkpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgc2VnbWVudHMgPSBwYXRoLnNwbGl0KCcuJyk7XG4gIHJldHVybiBmdW5jdGlvbiAob2JqKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFvYmopIHsgcmV0dXJuIH1cbiAgICAgIG9iaiA9IG9ialtzZWdtZW50c1tpXV07XG4gICAgfVxuICAgIHJldHVybiBvYmpcbiAgfVxufVxuXG4vKiAgKi9cblxuXG4vLyBjYW4gd2UgdXNlIF9fcHJvdG9fXz9cbnZhciBoYXNQcm90byA9ICdfX3Byb3RvX18nIGluIHt9O1xuXG4vLyBCcm93c2VyIGVudmlyb25tZW50IHNuaWZmaW5nXG52YXIgaW5Ccm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCc7XG52YXIgaW5XZWV4ID0gdHlwZW9mIFdYRW52aXJvbm1lbnQgIT09ICd1bmRlZmluZWQnICYmICEhV1hFbnZpcm9ubWVudC5wbGF0Zm9ybTtcbnZhciB3ZWV4UGxhdGZvcm0gPSBpbldlZXggJiYgV1hFbnZpcm9ubWVudC5wbGF0Zm9ybS50b0xvd2VyQ2FzZSgpO1xudmFyIFVBID0gaW5Ccm93c2VyICYmIHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCk7XG52YXIgaXNJRSA9IFVBICYmIC9tc2llfHRyaWRlbnQvLnRlc3QoVUEpO1xudmFyIGlzSUU5ID0gVUEgJiYgVUEuaW5kZXhPZignbXNpZSA5LjAnKSA+IDA7XG52YXIgaXNFZGdlID0gVUEgJiYgVUEuaW5kZXhPZignZWRnZS8nKSA+IDA7XG52YXIgaXNBbmRyb2lkID0gKFVBICYmIFVBLmluZGV4T2YoJ2FuZHJvaWQnKSA+IDApIHx8ICh3ZWV4UGxhdGZvcm0gPT09ICdhbmRyb2lkJyk7XG52YXIgaXNJT1MgPSAoVUEgJiYgL2lwaG9uZXxpcGFkfGlwb2R8aW9zLy50ZXN0KFVBKSkgfHwgKHdlZXhQbGF0Zm9ybSA9PT0gJ2lvcycpO1xudmFyIGlzQ2hyb21lID0gVUEgJiYgL2Nocm9tZVxcL1xcZCsvLnRlc3QoVUEpICYmICFpc0VkZ2U7XG5cbi8vIEZpcmVmb3ggaGFzIGEgXCJ3YXRjaFwiIGZ1bmN0aW9uIG9uIE9iamVjdC5wcm90b3R5cGUuLi5cbnZhciBuYXRpdmVXYXRjaCA9ICh7fSkud2F0Y2g7XG5cbnZhciBzdXBwb3J0c1Bhc3NpdmUgPSBmYWxzZTtcbmlmIChpbkJyb3dzZXIpIHtcbiAgdHJ5IHtcbiAgICB2YXIgb3B0cyA9IHt9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvcHRzLCAncGFzc2l2ZScsICh7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCAoKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHN1cHBvcnRzUGFzc2l2ZSA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpOyAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmxvdy9pc3N1ZXMvMjg1XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3QtcGFzc2l2ZScsIG51bGwsIG9wdHMpO1xuICB9IGNhdGNoIChlKSB7fVxufVxuXG4vLyB0aGlzIG5lZWRzIHRvIGJlIGxhenktZXZhbGVkIGJlY2F1c2UgdnVlIG1heSBiZSByZXF1aXJlZCBiZWZvcmVcbi8vIHZ1ZS1zZXJ2ZXItcmVuZGVyZXIgY2FuIHNldCBWVUVfRU5WXG52YXIgX2lzU2VydmVyO1xudmFyIGlzU2VydmVyUmVuZGVyaW5nID0gZnVuY3Rpb24gKCkge1xuICBpZiAoX2lzU2VydmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWluQnJvd3NlciAmJiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gZGV0ZWN0IHByZXNlbmNlIG9mIHZ1ZS1zZXJ2ZXItcmVuZGVyZXIgYW5kIGF2b2lkXG4gICAgICAvLyBXZWJwYWNrIHNoaW1taW5nIHRoZSBwcm9jZXNzXG4gICAgICBfaXNTZXJ2ZXIgPSBnbG9iYWxbJ3Byb2Nlc3MnXS5lbnYuVlVFX0VOViA9PT0gJ3NlcnZlcic7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9pc1NlcnZlciA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gX2lzU2VydmVyXG59O1xuXG4vLyBkZXRlY3QgZGV2dG9vbHNcbnZhciBkZXZ0b29scyA9IGluQnJvd3NlciAmJiB3aW5kb3cuX19WVUVfREVWVE9PTFNfR0xPQkFMX0hPT0tfXztcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIGlzTmF0aXZlIChDdG9yKSB7XG4gIHJldHVybiB0eXBlb2YgQ3RvciA9PT0gJ2Z1bmN0aW9uJyAmJiAvbmF0aXZlIGNvZGUvLnRlc3QoQ3Rvci50b1N0cmluZygpKVxufVxuXG52YXIgaGFzU3ltYm9sID1cbiAgdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoU3ltYm9sKSAmJlxuICB0eXBlb2YgUmVmbGVjdCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoUmVmbGVjdC5vd25LZXlzKTtcblxudmFyIF9TZXQ7XG4vKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi8gLy8gJGZsb3ctZGlzYWJsZS1saW5lXG5pZiAodHlwZW9mIFNldCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoU2V0KSkge1xuICAvLyB1c2UgbmF0aXZlIFNldCB3aGVuIGF2YWlsYWJsZS5cbiAgX1NldCA9IFNldDtcbn0gZWxzZSB7XG4gIC8vIGEgbm9uLXN0YW5kYXJkIFNldCBwb2x5ZmlsbCB0aGF0IG9ubHkgd29ya3Mgd2l0aCBwcmltaXRpdmUga2V5cy5cbiAgX1NldCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2V0ICgpIHtcbiAgICAgIHRoaXMuc2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB9XG4gICAgU2V0LnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiBoYXMgKGtleSkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0W2tleV0gPT09IHRydWVcbiAgICB9O1xuICAgIFNldC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkIChrZXkpIHtcbiAgICAgIHRoaXMuc2V0W2tleV0gPSB0cnVlO1xuICAgIH07XG4gICAgU2V0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyICgpIHtcbiAgICAgIHRoaXMuc2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFNldDtcbiAgfSgpKTtcbn1cblxuLyogICovXG5cbnZhciB3YXJuID0gbm9vcDtcbnZhciB0aXAgPSBub29wO1xudmFyIGdlbmVyYXRlQ29tcG9uZW50VHJhY2UgPSAobm9vcCk7IC8vIHdvcmsgYXJvdW5kIGZsb3cgY2hlY2tcbnZhciBmb3JtYXRDb21wb25lbnROYW1lID0gKG5vb3ApO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgaGFzQ29uc29sZSA9IHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJztcbiAgdmFyIGNsYXNzaWZ5UkUgPSAvKD86XnxbLV9dKShcXHcpL2c7XG4gIHZhciBjbGFzc2lmeSA9IGZ1bmN0aW9uIChzdHIpIHsgcmV0dXJuIHN0clxuICAgIC5yZXBsYWNlKGNsYXNzaWZ5UkUsIGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLnRvVXBwZXJDYXNlKCk7IH0pXG4gICAgLnJlcGxhY2UoL1stX10vZywgJycpOyB9O1xuXG4gIHdhcm4gPSBmdW5jdGlvbiAobXNnLCB2bSkge1xuICAgIHZhciB0cmFjZSA9IHZtID8gZ2VuZXJhdGVDb21wb25lbnRUcmFjZSh2bSkgOiAnJztcblxuICAgIGlmIChjb25maWcud2FybkhhbmRsZXIpIHtcbiAgICAgIGNvbmZpZy53YXJuSGFuZGxlci5jYWxsKG51bGwsIG1zZywgdm0sIHRyYWNlKTtcbiAgICB9IGVsc2UgaWYgKGhhc0NvbnNvbGUgJiYgKCFjb25maWcuc2lsZW50KSkge1xuICAgICAgY29uc29sZS5lcnJvcigoXCJbVnVlIHdhcm5dOiBcIiArIG1zZyArIHRyYWNlKSk7XG4gICAgfVxuICB9O1xuXG4gIHRpcCA9IGZ1bmN0aW9uIChtc2csIHZtKSB7XG4gICAgaWYgKGhhc0NvbnNvbGUgJiYgKCFjb25maWcuc2lsZW50KSkge1xuICAgICAgY29uc29sZS53YXJuKFwiW1Z1ZSB0aXBdOiBcIiArIG1zZyArIChcbiAgICAgICAgdm0gPyBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlKHZtKSA6ICcnXG4gICAgICApKTtcbiAgICB9XG4gIH07XG5cbiAgZm9ybWF0Q29tcG9uZW50TmFtZSA9IGZ1bmN0aW9uICh2bSwgaW5jbHVkZUZpbGUpIHtcbiAgICBpZiAodm0uJHJvb3QgPT09IHZtKSB7XG4gICAgICByZXR1cm4gJzxSb290PidcbiAgICB9XG4gICAgdmFyIG9wdGlvbnMgPSB0eXBlb2Ygdm0gPT09ICdmdW5jdGlvbicgJiYgdm0uY2lkICE9IG51bGxcbiAgICAgID8gdm0ub3B0aW9uc1xuICAgICAgOiB2bS5faXNWdWVcbiAgICAgICAgPyB2bS4kb3B0aW9ucyB8fCB2bS5jb25zdHJ1Y3Rvci5vcHRpb25zXG4gICAgICAgIDogdm0gfHwge307XG4gICAgdmFyIG5hbWUgPSBvcHRpb25zLm5hbWUgfHwgb3B0aW9ucy5fY29tcG9uZW50VGFnO1xuICAgIHZhciBmaWxlID0gb3B0aW9ucy5fX2ZpbGU7XG4gICAgaWYgKCFuYW1lICYmIGZpbGUpIHtcbiAgICAgIHZhciBtYXRjaCA9IGZpbGUubWF0Y2goLyhbXi9cXFxcXSspXFwudnVlJC8pO1xuICAgICAgbmFtZSA9IG1hdGNoICYmIG1hdGNoWzFdO1xuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICAobmFtZSA/IChcIjxcIiArIChjbGFzc2lmeShuYW1lKSkgKyBcIj5cIikgOiBcIjxBbm9ueW1vdXM+XCIpICtcbiAgICAgIChmaWxlICYmIGluY2x1ZGVGaWxlICE9PSBmYWxzZSA/IChcIiBhdCBcIiArIGZpbGUpIDogJycpXG4gICAgKVxuICB9O1xuXG4gIHZhciByZXBlYXQgPSBmdW5jdGlvbiAoc3RyLCBuKSB7XG4gICAgdmFyIHJlcyA9ICcnO1xuICAgIHdoaWxlIChuKSB7XG4gICAgICBpZiAobiAlIDIgPT09IDEpIHsgcmVzICs9IHN0cjsgfVxuICAgICAgaWYgKG4gPiAxKSB7IHN0ciArPSBzdHI7IH1cbiAgICAgIG4gPj49IDE7XG4gICAgfVxuICAgIHJldHVybiByZXNcbiAgfTtcblxuICBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlID0gZnVuY3Rpb24gKHZtKSB7XG4gICAgaWYgKHZtLl9pc1Z1ZSAmJiB2bS4kcGFyZW50KSB7XG4gICAgICB2YXIgdHJlZSA9IFtdO1xuICAgICAgdmFyIGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSA9IDA7XG4gICAgICB3aGlsZSAodm0pIHtcbiAgICAgICAgaWYgKHRyZWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHZhciBsYXN0ID0gdHJlZVt0cmVlLmxlbmd0aCAtIDFdO1xuICAgICAgICAgIGlmIChsYXN0LmNvbnN0cnVjdG9yID09PSB2bS5jb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlKys7XG4gICAgICAgICAgICB2bSA9IHZtLiRwYXJlbnQ7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH0gZWxzZSBpZiAoY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlID4gMCkge1xuICAgICAgICAgICAgdHJlZVt0cmVlLmxlbmd0aCAtIDFdID0gW2xhc3QsIGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZV07XG4gICAgICAgICAgICBjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0cmVlLnB1c2godm0pO1xuICAgICAgICB2bSA9IHZtLiRwYXJlbnQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gJ1xcblxcbmZvdW5kIGluXFxuXFxuJyArIHRyZWVcbiAgICAgICAgLm1hcChmdW5jdGlvbiAodm0sIGkpIHsgcmV0dXJuIChcIlwiICsgKGkgPT09IDAgPyAnLS0tPiAnIDogcmVwZWF0KCcgJywgNSArIGkgKiAyKSkgKyAoQXJyYXkuaXNBcnJheSh2bSlcbiAgICAgICAgICAgID8gKChmb3JtYXRDb21wb25lbnROYW1lKHZtWzBdKSkgKyBcIi4uLiAoXCIgKyAodm1bMV0pICsgXCIgcmVjdXJzaXZlIGNhbGxzKVwiKVxuICAgICAgICAgICAgOiBmb3JtYXRDb21wb25lbnROYW1lKHZtKSkpOyB9KVxuICAgICAgICAuam9pbignXFxuJylcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIChcIlxcblxcbihmb3VuZCBpbiBcIiArIChmb3JtYXRDb21wb25lbnROYW1lKHZtKSkgKyBcIilcIilcbiAgICB9XG4gIH07XG59XG5cbi8qICAqL1xuXG5cbnZhciB1aWQkMSA9IDA7XG5cbi8qKlxuICogQSBkZXAgaXMgYW4gb2JzZXJ2YWJsZSB0aGF0IGNhbiBoYXZlIG11bHRpcGxlXG4gKiBkaXJlY3RpdmVzIHN1YnNjcmliaW5nIHRvIGl0LlxuICovXG52YXIgRGVwID0gZnVuY3Rpb24gRGVwICgpIHtcbiAgdGhpcy5pZCA9IHVpZCQxKys7XG4gIHRoaXMuc3VicyA9IFtdO1xufTtcblxuRGVwLnByb3RvdHlwZS5hZGRTdWIgPSBmdW5jdGlvbiBhZGRTdWIgKHN1Yikge1xuICB0aGlzLnN1YnMucHVzaChzdWIpO1xufTtcblxuRGVwLnByb3RvdHlwZS5yZW1vdmVTdWIgPSBmdW5jdGlvbiByZW1vdmVTdWIgKHN1Yikge1xuICByZW1vdmUodGhpcy5zdWJzLCBzdWIpO1xufTtcblxuRGVwLnByb3RvdHlwZS5kZXBlbmQgPSBmdW5jdGlvbiBkZXBlbmQgKCkge1xuICBpZiAoRGVwLnRhcmdldCkge1xuICAgIERlcC50YXJnZXQuYWRkRGVwKHRoaXMpO1xuICB9XG59O1xuXG5EZXAucHJvdG90eXBlLm5vdGlmeSA9IGZ1bmN0aW9uIG5vdGlmeSAoKSB7XG4gIC8vIHN0YWJpbGl6ZSB0aGUgc3Vic2NyaWJlciBsaXN0IGZpcnN0XG4gIHZhciBzdWJzID0gdGhpcy5zdWJzLnNsaWNlKCk7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gc3Vicy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBzdWJzW2ldLnVwZGF0ZSgpO1xuICB9XG59O1xuXG4vLyB0aGUgY3VycmVudCB0YXJnZXQgd2F0Y2hlciBiZWluZyBldmFsdWF0ZWQuXG4vLyB0aGlzIGlzIGdsb2JhbGx5IHVuaXF1ZSBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG9ubHkgb25lXG4vLyB3YXRjaGVyIGJlaW5nIGV2YWx1YXRlZCBhdCBhbnkgdGltZS5cbkRlcC50YXJnZXQgPSBudWxsO1xudmFyIHRhcmdldFN0YWNrID0gW107XG5cbmZ1bmN0aW9uIHB1c2hUYXJnZXQgKF90YXJnZXQpIHtcbiAgaWYgKERlcC50YXJnZXQpIHsgdGFyZ2V0U3RhY2sucHVzaChEZXAudGFyZ2V0KTsgfVxuICBEZXAudGFyZ2V0ID0gX3RhcmdldDtcbn1cblxuZnVuY3Rpb24gcG9wVGFyZ2V0ICgpIHtcbiAgRGVwLnRhcmdldCA9IHRhcmdldFN0YWNrLnBvcCgpO1xufVxuXG4vKiAgKi9cblxudmFyIFZOb2RlID0gZnVuY3Rpb24gVk5vZGUgKFxuICB0YWcsXG4gIGRhdGEsXG4gIGNoaWxkcmVuLFxuICB0ZXh0LFxuICBlbG0sXG4gIGNvbnRleHQsXG4gIGNvbXBvbmVudE9wdGlvbnMsXG4gIGFzeW5jRmFjdG9yeVxuKSB7XG4gIHRoaXMudGFnID0gdGFnO1xuICB0aGlzLmRhdGEgPSBkYXRhO1xuICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIHRoaXMudGV4dCA9IHRleHQ7XG4gIHRoaXMuZWxtID0gZWxtO1xuICB0aGlzLm5zID0gdW5kZWZpbmVkO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLmZuQ29udGV4dCA9IHVuZGVmaW5lZDtcbiAgdGhpcy5mbk9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gIHRoaXMuZm5TY29wZUlkID0gdW5kZWZpbmVkO1xuICB0aGlzLmtleSA9IGRhdGEgJiYgZGF0YS5rZXk7XG4gIHRoaXMuY29tcG9uZW50T3B0aW9ucyA9IGNvbXBvbmVudE9wdGlvbnM7XG4gIHRoaXMuY29tcG9uZW50SW5zdGFuY2UgPSB1bmRlZmluZWQ7XG4gIHRoaXMucGFyZW50ID0gdW5kZWZpbmVkO1xuICB0aGlzLnJhdyA9IGZhbHNlO1xuICB0aGlzLmlzU3RhdGljID0gZmFsc2U7XG4gIHRoaXMuaXNSb290SW5zZXJ0ID0gdHJ1ZTtcbiAgdGhpcy5pc0NvbW1lbnQgPSBmYWxzZTtcbiAgdGhpcy5pc0Nsb25lZCA9IGZhbHNlO1xuICB0aGlzLmlzT25jZSA9IGZhbHNlO1xuICB0aGlzLmFzeW5jRmFjdG9yeSA9IGFzeW5jRmFjdG9yeTtcbiAgdGhpcy5hc3luY01ldGEgPSB1bmRlZmluZWQ7XG4gIHRoaXMuaXNBc3luY1BsYWNlaG9sZGVyID0gZmFsc2U7XG59O1xuXG52YXIgcHJvdG90eXBlQWNjZXNzb3JzID0geyBjaGlsZDogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuXG4vLyBERVBSRUNBVEVEOiBhbGlhcyBmb3IgY29tcG9uZW50SW5zdGFuY2UgZm9yIGJhY2t3YXJkcyBjb21wYXQuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xucHJvdG90eXBlQWNjZXNzb3JzLmNoaWxkLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuY29tcG9uZW50SW5zdGFuY2Vcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBWTm9kZS5wcm90b3R5cGUsIHByb3RvdHlwZUFjY2Vzc29ycyApO1xuXG52YXIgY3JlYXRlRW1wdHlWTm9kZSA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gIGlmICggdGV4dCA9PT0gdm9pZCAwICkgdGV4dCA9ICcnO1xuXG4gIHZhciBub2RlID0gbmV3IFZOb2RlKCk7XG4gIG5vZGUudGV4dCA9IHRleHQ7XG4gIG5vZGUuaXNDb21tZW50ID0gdHJ1ZTtcbiAgcmV0dXJuIG5vZGVcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZVRleHRWTm9kZSAodmFsKSB7XG4gIHJldHVybiBuZXcgVk5vZGUodW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgU3RyaW5nKHZhbCkpXG59XG5cbi8vIG9wdGltaXplZCBzaGFsbG93IGNsb25lXG4vLyB1c2VkIGZvciBzdGF0aWMgbm9kZXMgYW5kIHNsb3Qgbm9kZXMgYmVjYXVzZSB0aGV5IG1heSBiZSByZXVzZWQgYWNyb3NzXG4vLyBtdWx0aXBsZSByZW5kZXJzLCBjbG9uaW5nIHRoZW0gYXZvaWRzIGVycm9ycyB3aGVuIERPTSBtYW5pcHVsYXRpb25zIHJlbHlcbi8vIG9uIHRoZWlyIGVsbSByZWZlcmVuY2UuXG5mdW5jdGlvbiBjbG9uZVZOb2RlICh2bm9kZSwgZGVlcCkge1xuICB2YXIgY29tcG9uZW50T3B0aW9ucyA9IHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gIHZhciBjbG9uZWQgPSBuZXcgVk5vZGUoXG4gICAgdm5vZGUudGFnLFxuICAgIHZub2RlLmRhdGEsXG4gICAgdm5vZGUuY2hpbGRyZW4sXG4gICAgdm5vZGUudGV4dCxcbiAgICB2bm9kZS5lbG0sXG4gICAgdm5vZGUuY29udGV4dCxcbiAgICBjb21wb25lbnRPcHRpb25zLFxuICAgIHZub2RlLmFzeW5jRmFjdG9yeVxuICApO1xuICBjbG9uZWQubnMgPSB2bm9kZS5ucztcbiAgY2xvbmVkLmlzU3RhdGljID0gdm5vZGUuaXNTdGF0aWM7XG4gIGNsb25lZC5rZXkgPSB2bm9kZS5rZXk7XG4gIGNsb25lZC5pc0NvbW1lbnQgPSB2bm9kZS5pc0NvbW1lbnQ7XG4gIGNsb25lZC5mbkNvbnRleHQgPSB2bm9kZS5mbkNvbnRleHQ7XG4gIGNsb25lZC5mbk9wdGlvbnMgPSB2bm9kZS5mbk9wdGlvbnM7XG4gIGNsb25lZC5mblNjb3BlSWQgPSB2bm9kZS5mblNjb3BlSWQ7XG4gIGNsb25lZC5pc0Nsb25lZCA9IHRydWU7XG4gIGlmIChkZWVwKSB7XG4gICAgaWYgKHZub2RlLmNoaWxkcmVuKSB7XG4gICAgICBjbG9uZWQuY2hpbGRyZW4gPSBjbG9uZVZOb2Rlcyh2bm9kZS5jaGlsZHJlbiwgdHJ1ZSk7XG4gICAgfVxuICAgIGlmIChjb21wb25lbnRPcHRpb25zICYmIGNvbXBvbmVudE9wdGlvbnMuY2hpbGRyZW4pIHtcbiAgICAgIGNvbXBvbmVudE9wdGlvbnMuY2hpbGRyZW4gPSBjbG9uZVZOb2Rlcyhjb21wb25lbnRPcHRpb25zLmNoaWxkcmVuLCB0cnVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNsb25lZFxufVxuXG5mdW5jdGlvbiBjbG9uZVZOb2RlcyAodm5vZGVzLCBkZWVwKSB7XG4gIHZhciBsZW4gPSB2bm9kZXMubGVuZ3RoO1xuICB2YXIgcmVzID0gbmV3IEFycmF5KGxlbik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICByZXNbaV0gPSBjbG9uZVZOb2RlKHZub2Rlc1tpXSwgZGVlcCk7XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKlxuICogbm90IHR5cGUgY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgZmxvdyBkb2Vzbid0IHBsYXkgd2VsbCB3aXRoXG4gKiBkeW5hbWljYWxseSBhY2Nlc3NpbmcgbWV0aG9kcyBvbiBBcnJheSBwcm90b3R5cGVcbiAqL1xuXG52YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcbnZhciBhcnJheU1ldGhvZHMgPSBPYmplY3QuY3JlYXRlKGFycmF5UHJvdG8pO1tcbiAgJ3B1c2gnLFxuICAncG9wJyxcbiAgJ3NoaWZ0JyxcbiAgJ3Vuc2hpZnQnLFxuICAnc3BsaWNlJyxcbiAgJ3NvcnQnLFxuICAncmV2ZXJzZSdcbl0uZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gIC8vIGNhY2hlIG9yaWdpbmFsIG1ldGhvZFxuICB2YXIgb3JpZ2luYWwgPSBhcnJheVByb3RvW21ldGhvZF07XG4gIGRlZihhcnJheU1ldGhvZHMsIG1ldGhvZCwgZnVuY3Rpb24gbXV0YXRvciAoKSB7XG4gICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgdmFyIHJlc3VsdCA9IG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIHZhciBvYiA9IHRoaXMuX19vYl9fO1xuICAgIHZhciBpbnNlcnRlZDtcbiAgICBzd2l0Y2ggKG1ldGhvZCkge1xuICAgICAgY2FzZSAncHVzaCc6XG4gICAgICBjYXNlICd1bnNoaWZ0JzpcbiAgICAgICAgaW5zZXJ0ZWQgPSBhcmdzO1xuICAgICAgICBicmVha1xuICAgICAgY2FzZSAnc3BsaWNlJzpcbiAgICAgICAgaW5zZXJ0ZWQgPSBhcmdzLnNsaWNlKDIpO1xuICAgICAgICBicmVha1xuICAgIH1cbiAgICBpZiAoaW5zZXJ0ZWQpIHsgb2Iub2JzZXJ2ZUFycmF5KGluc2VydGVkKTsgfVxuICAgIC8vIG5vdGlmeSBjaGFuZ2VcbiAgICBvYi5kZXAubm90aWZ5KCk7XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9KTtcbn0pO1xuXG4vKiAgKi9cblxudmFyIGFycmF5S2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGFycmF5TWV0aG9kcyk7XG5cbi8qKlxuICogQnkgZGVmYXVsdCwgd2hlbiBhIHJlYWN0aXZlIHByb3BlcnR5IGlzIHNldCwgdGhlIG5ldyB2YWx1ZSBpc1xuICogYWxzbyBjb252ZXJ0ZWQgdG8gYmVjb21lIHJlYWN0aXZlLiBIb3dldmVyIHdoZW4gcGFzc2luZyBkb3duIHByb3BzLFxuICogd2UgZG9uJ3Qgd2FudCB0byBmb3JjZSBjb252ZXJzaW9uIGJlY2F1c2UgdGhlIHZhbHVlIG1heSBiZSBhIG5lc3RlZCB2YWx1ZVxuICogdW5kZXIgYSBmcm96ZW4gZGF0YSBzdHJ1Y3R1cmUuIENvbnZlcnRpbmcgaXQgd291bGQgZGVmZWF0IHRoZSBvcHRpbWl6YXRpb24uXG4gKi9cbnZhciBvYnNlcnZlclN0YXRlID0ge1xuICBzaG91bGRDb252ZXJ0OiB0cnVlXG59O1xuXG4vKipcbiAqIE9ic2VydmVyIGNsYXNzIHRoYXQgYXJlIGF0dGFjaGVkIHRvIGVhY2ggb2JzZXJ2ZWRcbiAqIG9iamVjdC4gT25jZSBhdHRhY2hlZCwgdGhlIG9ic2VydmVyIGNvbnZlcnRzIHRhcmdldFxuICogb2JqZWN0J3MgcHJvcGVydHkga2V5cyBpbnRvIGdldHRlci9zZXR0ZXJzIHRoYXRcbiAqIGNvbGxlY3QgZGVwZW5kZW5jaWVzIGFuZCBkaXNwYXRjaGVzIHVwZGF0ZXMuXG4gKi9cbnZhciBPYnNlcnZlciA9IGZ1bmN0aW9uIE9ic2VydmVyICh2YWx1ZSkge1xuICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gIHRoaXMuZGVwID0gbmV3IERlcCgpO1xuICB0aGlzLnZtQ291bnQgPSAwO1xuICBkZWYodmFsdWUsICdfX29iX18nLCB0aGlzKTtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgdmFyIGF1Z21lbnQgPSBoYXNQcm90b1xuICAgICAgPyBwcm90b0F1Z21lbnRcbiAgICAgIDogY29weUF1Z21lbnQ7XG4gICAgYXVnbWVudCh2YWx1ZSwgYXJyYXlNZXRob2RzLCBhcnJheUtleXMpO1xuICAgIHRoaXMub2JzZXJ2ZUFycmF5KHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLndhbGsodmFsdWUpO1xuICB9XG59O1xuXG4vKipcbiAqIFdhbGsgdGhyb3VnaCBlYWNoIHByb3BlcnR5IGFuZCBjb252ZXJ0IHRoZW0gaW50b1xuICogZ2V0dGVyL3NldHRlcnMuIFRoaXMgbWV0aG9kIHNob3VsZCBvbmx5IGJlIGNhbGxlZCB3aGVuXG4gKiB2YWx1ZSB0eXBlIGlzIE9iamVjdC5cbiAqL1xuT2JzZXJ2ZXIucHJvdG90eXBlLndhbGsgPSBmdW5jdGlvbiB3YWxrIChvYmopIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBkZWZpbmVSZWFjdGl2ZShvYmosIGtleXNbaV0sIG9ialtrZXlzW2ldXSk7XG4gIH1cbn07XG5cbi8qKlxuICogT2JzZXJ2ZSBhIGxpc3Qgb2YgQXJyYXkgaXRlbXMuXG4gKi9cbk9ic2VydmVyLnByb3RvdHlwZS5vYnNlcnZlQXJyYXkgPSBmdW5jdGlvbiBvYnNlcnZlQXJyYXkgKGl0ZW1zKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gaXRlbXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgb2JzZXJ2ZShpdGVtc1tpXSk7XG4gIH1cbn07XG5cbi8vIGhlbHBlcnNcblxuLyoqXG4gKiBBdWdtZW50IGFuIHRhcmdldCBPYmplY3Qgb3IgQXJyYXkgYnkgaW50ZXJjZXB0aW5nXG4gKiB0aGUgcHJvdG90eXBlIGNoYWluIHVzaW5nIF9fcHJvdG9fX1xuICovXG5mdW5jdGlvbiBwcm90b0F1Z21lbnQgKHRhcmdldCwgc3JjLCBrZXlzKSB7XG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG4gIHRhcmdldC5fX3Byb3RvX18gPSBzcmM7XG4gIC8qIGVzbGludC1lbmFibGUgbm8tcHJvdG8gKi9cbn1cblxuLyoqXG4gKiBBdWdtZW50IGFuIHRhcmdldCBPYmplY3Qgb3IgQXJyYXkgYnkgZGVmaW5pbmdcbiAqIGhpZGRlbiBwcm9wZXJ0aWVzLlxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gY29weUF1Z21lbnQgKHRhcmdldCwgc3JjLCBrZXlzKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICBkZWYodGFyZ2V0LCBrZXksIHNyY1trZXldKTtcbiAgfVxufVxuXG4vKipcbiAqIEF0dGVtcHQgdG8gY3JlYXRlIGFuIG9ic2VydmVyIGluc3RhbmNlIGZvciBhIHZhbHVlLFxuICogcmV0dXJucyB0aGUgbmV3IG9ic2VydmVyIGlmIHN1Y2Nlc3NmdWxseSBvYnNlcnZlZCxcbiAqIG9yIHRoZSBleGlzdGluZyBvYnNlcnZlciBpZiB0aGUgdmFsdWUgYWxyZWFkeSBoYXMgb25lLlxuICovXG5mdW5jdGlvbiBvYnNlcnZlICh2YWx1ZSwgYXNSb290RGF0YSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSB8fCB2YWx1ZSBpbnN0YW5jZW9mIFZOb2RlKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIG9iO1xuICBpZiAoaGFzT3duKHZhbHVlLCAnX19vYl9fJykgJiYgdmFsdWUuX19vYl9fIGluc3RhbmNlb2YgT2JzZXJ2ZXIpIHtcbiAgICBvYiA9IHZhbHVlLl9fb2JfXztcbiAgfSBlbHNlIGlmIChcbiAgICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgJiZcbiAgICAhaXNTZXJ2ZXJSZW5kZXJpbmcoKSAmJlxuICAgIChBcnJheS5pc0FycmF5KHZhbHVlKSB8fCBpc1BsYWluT2JqZWN0KHZhbHVlKSkgJiZcbiAgICBPYmplY3QuaXNFeHRlbnNpYmxlKHZhbHVlKSAmJlxuICAgICF2YWx1ZS5faXNWdWVcbiAgKSB7XG4gICAgb2IgPSBuZXcgT2JzZXJ2ZXIodmFsdWUpO1xuICB9XG4gIGlmIChhc1Jvb3REYXRhICYmIG9iKSB7XG4gICAgb2Iudm1Db3VudCsrO1xuICB9XG4gIHJldHVybiBvYlxufVxuXG4vKipcbiAqIERlZmluZSBhIHJlYWN0aXZlIHByb3BlcnR5IG9uIGFuIE9iamVjdC5cbiAqL1xuZnVuY3Rpb24gZGVmaW5lUmVhY3RpdmUgKFxuICBvYmosXG4gIGtleSxcbiAgdmFsLFxuICBjdXN0b21TZXR0ZXIsXG4gIHNoYWxsb3dcbikge1xuICB2YXIgZGVwID0gbmV3IERlcCgpO1xuXG4gIHZhciBwcm9wZXJ0eSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpO1xuICBpZiAocHJvcGVydHkgJiYgcHJvcGVydHkuY29uZmlndXJhYmxlID09PSBmYWxzZSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLy8gY2F0ZXIgZm9yIHByZS1kZWZpbmVkIGdldHRlci9zZXR0ZXJzXG4gIHZhciBnZXR0ZXIgPSBwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5nZXQ7XG4gIHZhciBzZXR0ZXIgPSBwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5zZXQ7XG5cbiAgdmFyIGNoaWxkT2IgPSAhc2hhbGxvdyAmJiBvYnNlcnZlKHZhbCk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gcmVhY3RpdmVHZXR0ZXIgKCkge1xuICAgICAgdmFyIHZhbHVlID0gZ2V0dGVyID8gZ2V0dGVyLmNhbGwob2JqKSA6IHZhbDtcbiAgICAgIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgICAgIGRlcC5kZXBlbmQoKTtcbiAgICAgICAgaWYgKGNoaWxkT2IpIHtcbiAgICAgICAgICBjaGlsZE9iLmRlcC5kZXBlbmQoKTtcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGRlcGVuZEFycmF5KHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZVxuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiByZWFjdGl2ZVNldHRlciAobmV3VmFsKSB7XG4gICAgICB2YXIgdmFsdWUgPSBnZXR0ZXIgPyBnZXR0ZXIuY2FsbChvYmopIDogdmFsO1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tc2VsZi1jb21wYXJlICovXG4gICAgICBpZiAobmV3VmFsID09PSB2YWx1ZSB8fCAobmV3VmFsICE9PSBuZXdWYWwgJiYgdmFsdWUgIT09IHZhbHVlKSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tc2VsZi1jb21wYXJlICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjdXN0b21TZXR0ZXIpIHtcbiAgICAgICAgY3VzdG9tU2V0dGVyKCk7XG4gICAgICB9XG4gICAgICBpZiAoc2V0dGVyKSB7XG4gICAgICAgIHNldHRlci5jYWxsKG9iaiwgbmV3VmFsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbCA9IG5ld1ZhbDtcbiAgICAgIH1cbiAgICAgIGNoaWxkT2IgPSAhc2hhbGxvdyAmJiBvYnNlcnZlKG5ld1ZhbCk7XG4gICAgICBkZXAubm90aWZ5KCk7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBTZXQgYSBwcm9wZXJ0eSBvbiBhbiBvYmplY3QuIEFkZHMgdGhlIG5ldyBwcm9wZXJ0eSBhbmRcbiAqIHRyaWdnZXJzIGNoYW5nZSBub3RpZmljYXRpb24gaWYgdGhlIHByb3BlcnR5IGRvZXNuJ3RcbiAqIGFscmVhZHkgZXhpc3QuXG4gKi9cbmZ1bmN0aW9uIHNldCAodGFyZ2V0LCBrZXksIHZhbCkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpICYmIGlzVmFsaWRBcnJheUluZGV4KGtleSkpIHtcbiAgICB0YXJnZXQubGVuZ3RoID0gTWF0aC5tYXgodGFyZ2V0Lmxlbmd0aCwga2V5KTtcbiAgICB0YXJnZXQuc3BsaWNlKGtleSwgMSwgdmFsKTtcbiAgICByZXR1cm4gdmFsXG4gIH1cbiAgaWYgKGtleSBpbiB0YXJnZXQgJiYgIShrZXkgaW4gT2JqZWN0LnByb3RvdHlwZSkpIHtcbiAgICB0YXJnZXRba2V5XSA9IHZhbDtcbiAgICByZXR1cm4gdmFsXG4gIH1cbiAgdmFyIG9iID0gKHRhcmdldCkuX19vYl9fO1xuICBpZiAodGFyZ2V0Ll9pc1Z1ZSB8fCAob2IgJiYgb2Iudm1Db3VudCkpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAnQXZvaWQgYWRkaW5nIHJlYWN0aXZlIHByb3BlcnRpZXMgdG8gYSBWdWUgaW5zdGFuY2Ugb3IgaXRzIHJvb3QgJGRhdGEgJyArXG4gICAgICAnYXQgcnVudGltZSAtIGRlY2xhcmUgaXQgdXBmcm9udCBpbiB0aGUgZGF0YSBvcHRpb24uJ1xuICAgICk7XG4gICAgcmV0dXJuIHZhbFxuICB9XG4gIGlmICghb2IpIHtcbiAgICB0YXJnZXRba2V5XSA9IHZhbDtcbiAgICByZXR1cm4gdmFsXG4gIH1cbiAgZGVmaW5lUmVhY3RpdmUob2IudmFsdWUsIGtleSwgdmFsKTtcbiAgb2IuZGVwLm5vdGlmeSgpO1xuICByZXR1cm4gdmFsXG59XG5cbi8qKlxuICogRGVsZXRlIGEgcHJvcGVydHkgYW5kIHRyaWdnZXIgY2hhbmdlIGlmIG5lY2Vzc2FyeS5cbiAqL1xuZnVuY3Rpb24gZGVsICh0YXJnZXQsIGtleSkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpICYmIGlzVmFsaWRBcnJheUluZGV4KGtleSkpIHtcbiAgICB0YXJnZXQuc3BsaWNlKGtleSwgMSk7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIG9iID0gKHRhcmdldCkuX19vYl9fO1xuICBpZiAodGFyZ2V0Ll9pc1Z1ZSB8fCAob2IgJiYgb2Iudm1Db3VudCkpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAnQXZvaWQgZGVsZXRpbmcgcHJvcGVydGllcyBvbiBhIFZ1ZSBpbnN0YW5jZSBvciBpdHMgcm9vdCAkZGF0YSAnICtcbiAgICAgICctIGp1c3Qgc2V0IGl0IHRvIG51bGwuJ1xuICAgICk7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKCFoYXNPd24odGFyZ2V0LCBrZXkpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgZGVsZXRlIHRhcmdldFtrZXldO1xuICBpZiAoIW9iKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgb2IuZGVwLm5vdGlmeSgpO1xufVxuXG4vKipcbiAqIENvbGxlY3QgZGVwZW5kZW5jaWVzIG9uIGFycmF5IGVsZW1lbnRzIHdoZW4gdGhlIGFycmF5IGlzIHRvdWNoZWQsIHNpbmNlXG4gKiB3ZSBjYW5ub3QgaW50ZXJjZXB0IGFycmF5IGVsZW1lbnQgYWNjZXNzIGxpa2UgcHJvcGVydHkgZ2V0dGVycy5cbiAqL1xuZnVuY3Rpb24gZGVwZW5kQXJyYXkgKHZhbHVlKSB7XG4gIGZvciAodmFyIGUgPSAodm9pZCAwKSwgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBlID0gdmFsdWVbaV07XG4gICAgZSAmJiBlLl9fb2JfXyAmJiBlLl9fb2JfXy5kZXAuZGVwZW5kKCk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZSkpIHtcbiAgICAgIGRlcGVuZEFycmF5KGUpO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBPcHRpb24gb3ZlcndyaXRpbmcgc3RyYXRlZ2llcyBhcmUgZnVuY3Rpb25zIHRoYXQgaGFuZGxlXG4gKiBob3cgdG8gbWVyZ2UgYSBwYXJlbnQgb3B0aW9uIHZhbHVlIGFuZCBhIGNoaWxkIG9wdGlvblxuICogdmFsdWUgaW50byB0aGUgZmluYWwgdmFsdWUuXG4gKi9cbnZhciBzdHJhdHMgPSBjb25maWcub3B0aW9uTWVyZ2VTdHJhdGVnaWVzO1xuXG4vKipcbiAqIE9wdGlvbnMgd2l0aCByZXN0cmljdGlvbnNcbiAqL1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgc3RyYXRzLmVsID0gc3RyYXRzLnByb3BzRGF0YSA9IGZ1bmN0aW9uIChwYXJlbnQsIGNoaWxkLCB2bSwga2V5KSB7XG4gICAgaWYgKCF2bSkge1xuICAgICAgd2FybihcbiAgICAgICAgXCJvcHRpb24gXFxcIlwiICsga2V5ICsgXCJcXFwiIGNhbiBvbmx5IGJlIHVzZWQgZHVyaW5nIGluc3RhbmNlIFwiICtcbiAgICAgICAgJ2NyZWF0aW9uIHdpdGggdGhlIGBuZXdgIGtleXdvcmQuJ1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlZmF1bHRTdHJhdChwYXJlbnQsIGNoaWxkKVxuICB9O1xufVxuXG4vKipcbiAqIEhlbHBlciB0aGF0IHJlY3Vyc2l2ZWx5IG1lcmdlcyB0d28gZGF0YSBvYmplY3RzIHRvZ2V0aGVyLlxuICovXG5mdW5jdGlvbiBtZXJnZURhdGEgKHRvLCBmcm9tKSB7XG4gIGlmICghZnJvbSkgeyByZXR1cm4gdG8gfVxuICB2YXIga2V5LCB0b1ZhbCwgZnJvbVZhbDtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhmcm9tKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAga2V5ID0ga2V5c1tpXTtcbiAgICB0b1ZhbCA9IHRvW2tleV07XG4gICAgZnJvbVZhbCA9IGZyb21ba2V5XTtcbiAgICBpZiAoIWhhc093bih0bywga2V5KSkge1xuICAgICAgc2V0KHRvLCBrZXksIGZyb21WYWwpO1xuICAgIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdCh0b1ZhbCkgJiYgaXNQbGFpbk9iamVjdChmcm9tVmFsKSkge1xuICAgICAgbWVyZ2VEYXRhKHRvVmFsLCBmcm9tVmFsKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRvXG59XG5cbi8qKlxuICogRGF0YVxuICovXG5mdW5jdGlvbiBtZXJnZURhdGFPckZuIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbCxcbiAgdm1cbikge1xuICBpZiAoIXZtKSB7XG4gICAgLy8gaW4gYSBWdWUuZXh0ZW5kIG1lcmdlLCBib3RoIHNob3VsZCBiZSBmdW5jdGlvbnNcbiAgICBpZiAoIWNoaWxkVmFsKSB7XG4gICAgICByZXR1cm4gcGFyZW50VmFsXG4gICAgfVxuICAgIGlmICghcGFyZW50VmFsKSB7XG4gICAgICByZXR1cm4gY2hpbGRWYWxcbiAgICB9XG4gICAgLy8gd2hlbiBwYXJlbnRWYWwgJiBjaGlsZFZhbCBhcmUgYm90aCBwcmVzZW50LFxuICAgIC8vIHdlIG5lZWQgdG8gcmV0dXJuIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZVxuICAgIC8vIG1lcmdlZCByZXN1bHQgb2YgYm90aCBmdW5jdGlvbnMuLi4gbm8gbmVlZCB0b1xuICAgIC8vIGNoZWNrIGlmIHBhcmVudFZhbCBpcyBhIGZ1bmN0aW9uIGhlcmUgYmVjYXVzZVxuICAgIC8vIGl0IGhhcyB0byBiZSBhIGZ1bmN0aW9uIHRvIHBhc3MgcHJldmlvdXMgbWVyZ2VzLlxuICAgIHJldHVybiBmdW5jdGlvbiBtZXJnZWREYXRhRm4gKCkge1xuICAgICAgcmV0dXJuIG1lcmdlRGF0YShcbiAgICAgICAgdHlwZW9mIGNoaWxkVmFsID09PSAnZnVuY3Rpb24nID8gY2hpbGRWYWwuY2FsbCh0aGlzLCB0aGlzKSA6IGNoaWxkVmFsLFxuICAgICAgICB0eXBlb2YgcGFyZW50VmFsID09PSAnZnVuY3Rpb24nID8gcGFyZW50VmFsLmNhbGwodGhpcywgdGhpcykgOiBwYXJlbnRWYWxcbiAgICAgIClcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlZEluc3RhbmNlRGF0YUZuICgpIHtcbiAgICAgIC8vIGluc3RhbmNlIG1lcmdlXG4gICAgICB2YXIgaW5zdGFuY2VEYXRhID0gdHlwZW9mIGNoaWxkVmFsID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gY2hpbGRWYWwuY2FsbCh2bSwgdm0pXG4gICAgICAgIDogY2hpbGRWYWw7XG4gICAgICB2YXIgZGVmYXVsdERhdGEgPSB0eXBlb2YgcGFyZW50VmFsID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gcGFyZW50VmFsLmNhbGwodm0sIHZtKVxuICAgICAgICA6IHBhcmVudFZhbDtcbiAgICAgIGlmIChpbnN0YW5jZURhdGEpIHtcbiAgICAgICAgcmV0dXJuIG1lcmdlRGF0YShpbnN0YW5jZURhdGEsIGRlZmF1bHREYXRhKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHREYXRhXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnN0cmF0cy5kYXRhID0gZnVuY3Rpb24gKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsLFxuICB2bVxuKSB7XG4gIGlmICghdm0pIHtcbiAgICBpZiAoY2hpbGRWYWwgJiYgdHlwZW9mIGNoaWxkVmFsICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgICdUaGUgXCJkYXRhXCIgb3B0aW9uIHNob3VsZCBiZSBhIGZ1bmN0aW9uICcgK1xuICAgICAgICAndGhhdCByZXR1cm5zIGEgcGVyLWluc3RhbmNlIHZhbHVlIGluIGNvbXBvbmVudCAnICtcbiAgICAgICAgJ2RlZmluaXRpb25zLicsXG4gICAgICAgIHZtXG4gICAgICApO1xuXG4gICAgICByZXR1cm4gcGFyZW50VmFsXG4gICAgfVxuICAgIHJldHVybiBtZXJnZURhdGFPckZuKHBhcmVudFZhbCwgY2hpbGRWYWwpXG4gIH1cblxuICByZXR1cm4gbWVyZ2VEYXRhT3JGbihwYXJlbnRWYWwsIGNoaWxkVmFsLCB2bSlcbn07XG5cbi8qKlxuICogSG9va3MgYW5kIHByb3BzIGFyZSBtZXJnZWQgYXMgYXJyYXlzLlxuICovXG5mdW5jdGlvbiBtZXJnZUhvb2sgKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsXG4pIHtcbiAgcmV0dXJuIGNoaWxkVmFsXG4gICAgPyBwYXJlbnRWYWxcbiAgICAgID8gcGFyZW50VmFsLmNvbmNhdChjaGlsZFZhbClcbiAgICAgIDogQXJyYXkuaXNBcnJheShjaGlsZFZhbClcbiAgICAgICAgPyBjaGlsZFZhbFxuICAgICAgICA6IFtjaGlsZFZhbF1cbiAgICA6IHBhcmVudFZhbFxufVxuXG5MSUZFQ1lDTEVfSE9PS1MuZm9yRWFjaChmdW5jdGlvbiAoaG9vaykge1xuICBzdHJhdHNbaG9va10gPSBtZXJnZUhvb2s7XG59KTtcblxuLyoqXG4gKiBBc3NldHNcbiAqXG4gKiBXaGVuIGEgdm0gaXMgcHJlc2VudCAoaW5zdGFuY2UgY3JlYXRpb24pLCB3ZSBuZWVkIHRvIGRvXG4gKiBhIHRocmVlLXdheSBtZXJnZSBiZXR3ZWVuIGNvbnN0cnVjdG9yIG9wdGlvbnMsIGluc3RhbmNlXG4gKiBvcHRpb25zIGFuZCBwYXJlbnQgb3B0aW9ucy5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VBc3NldHMgKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsLFxuICB2bSxcbiAga2V5XG4pIHtcbiAgdmFyIHJlcyA9IE9iamVjdC5jcmVhdGUocGFyZW50VmFsIHx8IG51bGwpO1xuICBpZiAoY2hpbGRWYWwpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGFzc2VydE9iamVjdFR5cGUoa2V5LCBjaGlsZFZhbCwgdm0pO1xuICAgIHJldHVybiBleHRlbmQocmVzLCBjaGlsZFZhbClcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcmVzXG4gIH1cbn1cblxuQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICBzdHJhdHNbdHlwZSArICdzJ10gPSBtZXJnZUFzc2V0cztcbn0pO1xuXG4vKipcbiAqIFdhdGNoZXJzLlxuICpcbiAqIFdhdGNoZXJzIGhhc2hlcyBzaG91bGQgbm90IG92ZXJ3cml0ZSBvbmVcbiAqIGFub3RoZXIsIHNvIHdlIG1lcmdlIHRoZW0gYXMgYXJyYXlzLlxuICovXG5zdHJhdHMud2F0Y2ggPSBmdW5jdGlvbiAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWwsXG4gIHZtLFxuICBrZXlcbikge1xuICAvLyB3b3JrIGFyb3VuZCBGaXJlZm94J3MgT2JqZWN0LnByb3RvdHlwZS53YXRjaC4uLlxuICBpZiAocGFyZW50VmFsID09PSBuYXRpdmVXYXRjaCkgeyBwYXJlbnRWYWwgPSB1bmRlZmluZWQ7IH1cbiAgaWYgKGNoaWxkVmFsID09PSBuYXRpdmVXYXRjaCkgeyBjaGlsZFZhbCA9IHVuZGVmaW5lZDsgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFjaGlsZFZhbCkgeyByZXR1cm4gT2JqZWN0LmNyZWF0ZShwYXJlbnRWYWwgfHwgbnVsbCkgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGFzc2VydE9iamVjdFR5cGUoa2V5LCBjaGlsZFZhbCwgdm0pO1xuICB9XG4gIGlmICghcGFyZW50VmFsKSB7IHJldHVybiBjaGlsZFZhbCB9XG4gIHZhciByZXQgPSB7fTtcbiAgZXh0ZW5kKHJldCwgcGFyZW50VmFsKTtcbiAgZm9yICh2YXIga2V5JDEgaW4gY2hpbGRWYWwpIHtcbiAgICB2YXIgcGFyZW50ID0gcmV0W2tleSQxXTtcbiAgICB2YXIgY2hpbGQgPSBjaGlsZFZhbFtrZXkkMV07XG4gICAgaWYgKHBhcmVudCAmJiAhQXJyYXkuaXNBcnJheShwYXJlbnQpKSB7XG4gICAgICBwYXJlbnQgPSBbcGFyZW50XTtcbiAgICB9XG4gICAgcmV0W2tleSQxXSA9IHBhcmVudFxuICAgICAgPyBwYXJlbnQuY29uY2F0KGNoaWxkKVxuICAgICAgOiBBcnJheS5pc0FycmF5KGNoaWxkKSA/IGNoaWxkIDogW2NoaWxkXTtcbiAgfVxuICByZXR1cm4gcmV0XG59O1xuXG4vKipcbiAqIE90aGVyIG9iamVjdCBoYXNoZXMuXG4gKi9cbnN0cmF0cy5wcm9wcyA9XG5zdHJhdHMubWV0aG9kcyA9XG5zdHJhdHMuaW5qZWN0ID1cbnN0cmF0cy5jb21wdXRlZCA9IGZ1bmN0aW9uIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbCxcbiAgdm0sXG4gIGtleVxuKSB7XG4gIGlmIChjaGlsZFZhbCAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYXNzZXJ0T2JqZWN0VHlwZShrZXksIGNoaWxkVmFsLCB2bSk7XG4gIH1cbiAgaWYgKCFwYXJlbnRWYWwpIHsgcmV0dXJuIGNoaWxkVmFsIH1cbiAgdmFyIHJldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGV4dGVuZChyZXQsIHBhcmVudFZhbCk7XG4gIGlmIChjaGlsZFZhbCkgeyBleHRlbmQocmV0LCBjaGlsZFZhbCk7IH1cbiAgcmV0dXJuIHJldFxufTtcbnN0cmF0cy5wcm92aWRlID0gbWVyZ2VEYXRhT3JGbjtcblxuLyoqXG4gKiBEZWZhdWx0IHN0cmF0ZWd5LlxuICovXG52YXIgZGVmYXVsdFN0cmF0ID0gZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcbiAgcmV0dXJuIGNoaWxkVmFsID09PSB1bmRlZmluZWRcbiAgICA/IHBhcmVudFZhbFxuICAgIDogY2hpbGRWYWxcbn07XG5cbi8qKlxuICogVmFsaWRhdGUgY29tcG9uZW50IG5hbWVzXG4gKi9cbmZ1bmN0aW9uIGNoZWNrQ29tcG9uZW50cyAob3B0aW9ucykge1xuICBmb3IgKHZhciBrZXkgaW4gb3B0aW9ucy5jb21wb25lbnRzKSB7XG4gICAgdmFsaWRhdGVDb21wb25lbnROYW1lKGtleSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVDb21wb25lbnROYW1lIChuYW1lKSB7XG4gIGlmICghL15bYS16QS1aXVtcXHctXSokLy50ZXN0KG5hbWUpKSB7XG4gICAgd2FybihcbiAgICAgICdJbnZhbGlkIGNvbXBvbmVudCBuYW1lOiBcIicgKyBuYW1lICsgJ1wiLiBDb21wb25lbnQgbmFtZXMgJyArXG4gICAgICAnY2FuIG9ubHkgY29udGFpbiBhbHBoYW51bWVyaWMgY2hhcmFjdGVycyBhbmQgdGhlIGh5cGhlbiwgJyArXG4gICAgICAnYW5kIG11c3Qgc3RhcnQgd2l0aCBhIGxldHRlci4nXG4gICAgKTtcbiAgfVxuICBpZiAoaXNCdWlsdEluVGFnKG5hbWUpIHx8IGNvbmZpZy5pc1Jlc2VydmVkVGFnKG5hbWUpKSB7XG4gICAgd2FybihcbiAgICAgICdEbyBub3QgdXNlIGJ1aWx0LWluIG9yIHJlc2VydmVkIEhUTUwgZWxlbWVudHMgYXMgY29tcG9uZW50ICcgK1xuICAgICAgJ2lkOiAnICsgbmFtZVxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBFbnN1cmUgYWxsIHByb3BzIG9wdGlvbiBzeW50YXggYXJlIG5vcm1hbGl6ZWQgaW50byB0aGVcbiAqIE9iamVjdC1iYXNlZCBmb3JtYXQuXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZVByb3BzIChvcHRpb25zLCB2bSkge1xuICB2YXIgcHJvcHMgPSBvcHRpb25zLnByb3BzO1xuICBpZiAoIXByb3BzKSB7IHJldHVybiB9XG4gIHZhciByZXMgPSB7fTtcbiAgdmFyIGksIHZhbCwgbmFtZTtcbiAgaWYgKEFycmF5LmlzQXJyYXkocHJvcHMpKSB7XG4gICAgaSA9IHByb3BzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB2YWwgPSBwcm9wc1tpXTtcbiAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgICAgICBuYW1lID0gY2FtZWxpemUodmFsKTtcbiAgICAgICAgcmVzW25hbWVdID0geyB0eXBlOiBudWxsIH07XG4gICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgd2FybigncHJvcHMgbXVzdCBiZSBzdHJpbmdzIHdoZW4gdXNpbmcgYXJyYXkgc3ludGF4LicpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHByb3BzKSkge1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgICAgdmFsID0gcHJvcHNba2V5XTtcbiAgICAgIG5hbWUgPSBjYW1lbGl6ZShrZXkpO1xuICAgICAgcmVzW25hbWVdID0gaXNQbGFpbk9iamVjdCh2YWwpXG4gICAgICAgID8gdmFsXG4gICAgICAgIDogeyB0eXBlOiB2YWwgfTtcbiAgICB9XG4gIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHdhcm4oXG4gICAgICBcIkludmFsaWQgdmFsdWUgZm9yIG9wdGlvbiBcXFwicHJvcHNcXFwiOiBleHBlY3RlZCBhbiBBcnJheSBvciBhbiBPYmplY3QsIFwiICtcbiAgICAgIFwiYnV0IGdvdCBcIiArICh0b1Jhd1R5cGUocHJvcHMpKSArIFwiLlwiLFxuICAgICAgdm1cbiAgICApO1xuICB9XG4gIG9wdGlvbnMucHJvcHMgPSByZXM7XG59XG5cbi8qKlxuICogTm9ybWFsaXplIGFsbCBpbmplY3Rpb25zIGludG8gT2JqZWN0LWJhc2VkIGZvcm1hdFxuICovXG5mdW5jdGlvbiBub3JtYWxpemVJbmplY3QgKG9wdGlvbnMsIHZtKSB7XG4gIHZhciBpbmplY3QgPSBvcHRpb25zLmluamVjdDtcbiAgaWYgKCFpbmplY3QpIHsgcmV0dXJuIH1cbiAgdmFyIG5vcm1hbGl6ZWQgPSBvcHRpb25zLmluamVjdCA9IHt9O1xuICBpZiAoQXJyYXkuaXNBcnJheShpbmplY3QpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmplY3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIG5vcm1hbGl6ZWRbaW5qZWN0W2ldXSA9IHsgZnJvbTogaW5qZWN0W2ldIH07XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QoaW5qZWN0KSkge1xuICAgIGZvciAodmFyIGtleSBpbiBpbmplY3QpIHtcbiAgICAgIHZhciB2YWwgPSBpbmplY3Rba2V5XTtcbiAgICAgIG5vcm1hbGl6ZWRba2V5XSA9IGlzUGxhaW5PYmplY3QodmFsKVxuICAgICAgICA/IGV4dGVuZCh7IGZyb206IGtleSB9LCB2YWwpXG4gICAgICAgIDogeyBmcm9tOiB2YWwgfTtcbiAgICB9XG4gIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHdhcm4oXG4gICAgICBcIkludmFsaWQgdmFsdWUgZm9yIG9wdGlvbiBcXFwiaW5qZWN0XFxcIjogZXhwZWN0ZWQgYW4gQXJyYXkgb3IgYW4gT2JqZWN0LCBcIiArXG4gICAgICBcImJ1dCBnb3QgXCIgKyAodG9SYXdUeXBlKGluamVjdCkpICsgXCIuXCIsXG4gICAgICB2bVxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgcmF3IGZ1bmN0aW9uIGRpcmVjdGl2ZXMgaW50byBvYmplY3QgZm9ybWF0LlxuICovXG5mdW5jdGlvbiBub3JtYWxpemVEaXJlY3RpdmVzIChvcHRpb25zKSB7XG4gIHZhciBkaXJzID0gb3B0aW9ucy5kaXJlY3RpdmVzO1xuICBpZiAoZGlycykge1xuICAgIGZvciAodmFyIGtleSBpbiBkaXJzKSB7XG4gICAgICB2YXIgZGVmID0gZGlyc1trZXldO1xuICAgICAgaWYgKHR5cGVvZiBkZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZGlyc1trZXldID0geyBiaW5kOiBkZWYsIHVwZGF0ZTogZGVmIH07XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2VydE9iamVjdFR5cGUgKG5hbWUsIHZhbHVlLCB2bSkge1xuICBpZiAoIWlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgd2FybihcbiAgICAgIFwiSW52YWxpZCB2YWx1ZSBmb3Igb3B0aW9uIFxcXCJcIiArIG5hbWUgKyBcIlxcXCI6IGV4cGVjdGVkIGFuIE9iamVjdCwgXCIgK1xuICAgICAgXCJidXQgZ290IFwiICsgKHRvUmF3VHlwZSh2YWx1ZSkpICsgXCIuXCIsXG4gICAgICB2bVxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBNZXJnZSB0d28gb3B0aW9uIG9iamVjdHMgaW50byBhIG5ldyBvbmUuXG4gKiBDb3JlIHV0aWxpdHkgdXNlZCBpbiBib3RoIGluc3RhbnRpYXRpb24gYW5kIGluaGVyaXRhbmNlLlxuICovXG5mdW5jdGlvbiBtZXJnZU9wdGlvbnMgKFxuICBwYXJlbnQsXG4gIGNoaWxkLFxuICB2bVxuKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgY2hlY2tDb21wb25lbnRzKGNoaWxkKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgY2hpbGQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjaGlsZCA9IGNoaWxkLm9wdGlvbnM7XG4gIH1cblxuICBub3JtYWxpemVQcm9wcyhjaGlsZCwgdm0pO1xuICBub3JtYWxpemVJbmplY3QoY2hpbGQsIHZtKTtcbiAgbm9ybWFsaXplRGlyZWN0aXZlcyhjaGlsZCk7XG4gIHZhciBleHRlbmRzRnJvbSA9IGNoaWxkLmV4dGVuZHM7XG4gIGlmIChleHRlbmRzRnJvbSkge1xuICAgIHBhcmVudCA9IG1lcmdlT3B0aW9ucyhwYXJlbnQsIGV4dGVuZHNGcm9tLCB2bSk7XG4gIH1cbiAgaWYgKGNoaWxkLm1peGlucykge1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGQubWl4aW5zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgcGFyZW50ID0gbWVyZ2VPcHRpb25zKHBhcmVudCwgY2hpbGQubWl4aW5zW2ldLCB2bSk7XG4gICAgfVxuICB9XG4gIHZhciBvcHRpb25zID0ge307XG4gIHZhciBrZXk7XG4gIGZvciAoa2V5IGluIHBhcmVudCkge1xuICAgIG1lcmdlRmllbGQoa2V5KTtcbiAgfVxuICBmb3IgKGtleSBpbiBjaGlsZCkge1xuICAgIGlmICghaGFzT3duKHBhcmVudCwga2V5KSkge1xuICAgICAgbWVyZ2VGaWVsZChrZXkpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBtZXJnZUZpZWxkIChrZXkpIHtcbiAgICB2YXIgc3RyYXQgPSBzdHJhdHNba2V5XSB8fCBkZWZhdWx0U3RyYXQ7XG4gICAgb3B0aW9uc1trZXldID0gc3RyYXQocGFyZW50W2tleV0sIGNoaWxkW2tleV0sIHZtLCBrZXkpO1xuICB9XG4gIHJldHVybiBvcHRpb25zXG59XG5cbi8qKlxuICogUmVzb2x2ZSBhbiBhc3NldC5cbiAqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCBiZWNhdXNlIGNoaWxkIGluc3RhbmNlcyBuZWVkIGFjY2Vzc1xuICogdG8gYXNzZXRzIGRlZmluZWQgaW4gaXRzIGFuY2VzdG9yIGNoYWluLlxuICovXG5mdW5jdGlvbiByZXNvbHZlQXNzZXQgKFxuICBvcHRpb25zLFxuICB0eXBlLFxuICBpZCxcbiAgd2Fybk1pc3Npbmdcbikge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHR5cGVvZiBpZCAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgYXNzZXRzID0gb3B0aW9uc1t0eXBlXTtcbiAgLy8gY2hlY2sgbG9jYWwgcmVnaXN0cmF0aW9uIHZhcmlhdGlvbnMgZmlyc3RcbiAgaWYgKGhhc093bihhc3NldHMsIGlkKSkgeyByZXR1cm4gYXNzZXRzW2lkXSB9XG4gIHZhciBjYW1lbGl6ZWRJZCA9IGNhbWVsaXplKGlkKTtcbiAgaWYgKGhhc093bihhc3NldHMsIGNhbWVsaXplZElkKSkgeyByZXR1cm4gYXNzZXRzW2NhbWVsaXplZElkXSB9XG4gIHZhciBQYXNjYWxDYXNlSWQgPSBjYXBpdGFsaXplKGNhbWVsaXplZElkKTtcbiAgaWYgKGhhc093bihhc3NldHMsIFBhc2NhbENhc2VJZCkpIHsgcmV0dXJuIGFzc2V0c1tQYXNjYWxDYXNlSWRdIH1cbiAgLy8gZmFsbGJhY2sgdG8gcHJvdG90eXBlIGNoYWluXG4gIHZhciByZXMgPSBhc3NldHNbaWRdIHx8IGFzc2V0c1tjYW1lbGl6ZWRJZF0gfHwgYXNzZXRzW1Bhc2NhbENhc2VJZF07XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm5NaXNzaW5nICYmICFyZXMpIHtcbiAgICB3YXJuKFxuICAgICAgJ0ZhaWxlZCB0byByZXNvbHZlICcgKyB0eXBlLnNsaWNlKDAsIC0xKSArICc6ICcgKyBpZCxcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcCAoXG4gIGtleSxcbiAgcHJvcE9wdGlvbnMsXG4gIHByb3BzRGF0YSxcbiAgdm1cbikge1xuICB2YXIgcHJvcCA9IHByb3BPcHRpb25zW2tleV07XG4gIHZhciBhYnNlbnQgPSAhaGFzT3duKHByb3BzRGF0YSwga2V5KTtcbiAgdmFyIHZhbHVlID0gcHJvcHNEYXRhW2tleV07XG4gIC8vIGhhbmRsZSBib29sZWFuIHByb3BzXG4gIGlmIChpc1R5cGUoQm9vbGVhbiwgcHJvcC50eXBlKSkge1xuICAgIGlmIChhYnNlbnQgJiYgIWhhc093bihwcm9wLCAnZGVmYXVsdCcpKSB7XG4gICAgICB2YWx1ZSA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoIWlzVHlwZShTdHJpbmcsIHByb3AudHlwZSkgJiYgKHZhbHVlID09PSAnJyB8fCB2YWx1ZSA9PT0gaHlwaGVuYXRlKGtleSkpKSB7XG4gICAgICB2YWx1ZSA9IHRydWU7XG4gICAgfVxuICB9XG4gIC8vIGNoZWNrIGRlZmF1bHQgdmFsdWVcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICB2YWx1ZSA9IGdldFByb3BEZWZhdWx0VmFsdWUodm0sIHByb3AsIGtleSk7XG4gICAgLy8gc2luY2UgdGhlIGRlZmF1bHQgdmFsdWUgaXMgYSBmcmVzaCBjb3B5LFxuICAgIC8vIG1ha2Ugc3VyZSB0byBvYnNlcnZlIGl0LlxuICAgIHZhciBwcmV2U2hvdWxkQ29udmVydCA9IG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydDtcbiAgICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSB0cnVlO1xuICAgIG9ic2VydmUodmFsdWUpO1xuICAgIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCA9IHByZXZTaG91bGRDb252ZXJ0O1xuICB9XG4gIGlmIChcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgLy8gc2tpcCB2YWxpZGF0aW9uIGZvciB3ZWV4IHJlY3ljbGUtbGlzdCBjaGlsZCBjb21wb25lbnQgcHJvcHNcbiAgICAhKGZhbHNlICYmIGlzT2JqZWN0KHZhbHVlKSAmJiAoJ0BiaW5kaW5nJyBpbiB2YWx1ZSkpXG4gICkge1xuICAgIGFzc2VydFByb3AocHJvcCwga2V5LCB2YWx1ZSwgdm0sIGFic2VudCk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlXG59XG5cbi8qKlxuICogR2V0IHRoZSBkZWZhdWx0IHZhbHVlIG9mIGEgcHJvcC5cbiAqL1xuZnVuY3Rpb24gZ2V0UHJvcERlZmF1bHRWYWx1ZSAodm0sIHByb3AsIGtleSkge1xuICAvLyBubyBkZWZhdWx0LCByZXR1cm4gdW5kZWZpbmVkXG4gIGlmICghaGFzT3duKHByb3AsICdkZWZhdWx0JykpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH1cbiAgdmFyIGRlZiA9IHByb3AuZGVmYXVsdDtcbiAgLy8gd2FybiBhZ2FpbnN0IG5vbi1mYWN0b3J5IGRlZmF1bHRzIGZvciBPYmplY3QgJiBBcnJheVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBpc09iamVjdChkZWYpKSB7XG4gICAgd2FybihcbiAgICAgICdJbnZhbGlkIGRlZmF1bHQgdmFsdWUgZm9yIHByb3AgXCInICsga2V5ICsgJ1wiOiAnICtcbiAgICAgICdQcm9wcyB3aXRoIHR5cGUgT2JqZWN0L0FycmF5IG11c3QgdXNlIGEgZmFjdG9yeSBmdW5jdGlvbiAnICtcbiAgICAgICd0byByZXR1cm4gdGhlIGRlZmF1bHQgdmFsdWUuJyxcbiAgICAgIHZtXG4gICAgKTtcbiAgfVxuICAvLyB0aGUgcmF3IHByb3AgdmFsdWUgd2FzIGFsc28gdW5kZWZpbmVkIGZyb20gcHJldmlvdXMgcmVuZGVyLFxuICAvLyByZXR1cm4gcHJldmlvdXMgZGVmYXVsdCB2YWx1ZSB0byBhdm9pZCB1bm5lY2Vzc2FyeSB3YXRjaGVyIHRyaWdnZXJcbiAgaWYgKHZtICYmIHZtLiRvcHRpb25zLnByb3BzRGF0YSAmJlxuICAgIHZtLiRvcHRpb25zLnByb3BzRGF0YVtrZXldID09PSB1bmRlZmluZWQgJiZcbiAgICB2bS5fcHJvcHNba2V5XSAhPT0gdW5kZWZpbmVkXG4gICkge1xuICAgIHJldHVybiB2bS5fcHJvcHNba2V5XVxuICB9XG4gIC8vIGNhbGwgZmFjdG9yeSBmdW5jdGlvbiBmb3Igbm9uLUZ1bmN0aW9uIHR5cGVzXG4gIC8vIGEgdmFsdWUgaXMgRnVuY3Rpb24gaWYgaXRzIHByb3RvdHlwZSBpcyBmdW5jdGlvbiBldmVuIGFjcm9zcyBkaWZmZXJlbnQgZXhlY3V0aW9uIGNvbnRleHRcbiAgcmV0dXJuIHR5cGVvZiBkZWYgPT09ICdmdW5jdGlvbicgJiYgZ2V0VHlwZShwcm9wLnR5cGUpICE9PSAnRnVuY3Rpb24nXG4gICAgPyBkZWYuY2FsbCh2bSlcbiAgICA6IGRlZlxufVxuXG4vKipcbiAqIEFzc2VydCB3aGV0aGVyIGEgcHJvcCBpcyB2YWxpZC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0UHJvcCAoXG4gIHByb3AsXG4gIG5hbWUsXG4gIHZhbHVlLFxuICB2bSxcbiAgYWJzZW50XG4pIHtcbiAgaWYgKHByb3AucmVxdWlyZWQgJiYgYWJzZW50KSB7XG4gICAgd2FybihcbiAgICAgICdNaXNzaW5nIHJlcXVpcmVkIHByb3A6IFwiJyArIG5hbWUgKyAnXCInLFxuICAgICAgdm1cbiAgICApO1xuICAgIHJldHVyblxuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsICYmICFwcm9wLnJlcXVpcmVkKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHR5cGUgPSBwcm9wLnR5cGU7XG4gIHZhciB2YWxpZCA9ICF0eXBlIHx8IHR5cGUgPT09IHRydWU7XG4gIHZhciBleHBlY3RlZFR5cGVzID0gW107XG4gIGlmICh0eXBlKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHR5cGUpKSB7XG4gICAgICB0eXBlID0gW3R5cGVdO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGUubGVuZ3RoICYmICF2YWxpZDsgaSsrKSB7XG4gICAgICB2YXIgYXNzZXJ0ZWRUeXBlID0gYXNzZXJ0VHlwZSh2YWx1ZSwgdHlwZVtpXSk7XG4gICAgICBleHBlY3RlZFR5cGVzLnB1c2goYXNzZXJ0ZWRUeXBlLmV4cGVjdGVkVHlwZSB8fCAnJyk7XG4gICAgICB2YWxpZCA9IGFzc2VydGVkVHlwZS52YWxpZDtcbiAgICB9XG4gIH1cbiAgaWYgKCF2YWxpZCkge1xuICAgIHdhcm4oXG4gICAgICBcIkludmFsaWQgcHJvcDogdHlwZSBjaGVjayBmYWlsZWQgZm9yIHByb3AgXFxcIlwiICsgbmFtZSArIFwiXFxcIi5cIiArXG4gICAgICBcIiBFeHBlY3RlZCBcIiArIChleHBlY3RlZFR5cGVzLm1hcChjYXBpdGFsaXplKS5qb2luKCcsICcpKSArXG4gICAgICBcIiwgZ290IFwiICsgKHRvUmF3VHlwZSh2YWx1ZSkpICsgXCIuXCIsXG4gICAgICB2bVxuICAgICk7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHZhbGlkYXRvciA9IHByb3AudmFsaWRhdG9yO1xuICBpZiAodmFsaWRhdG9yKSB7XG4gICAgaWYgKCF2YWxpZGF0b3IodmFsdWUpKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnSW52YWxpZCBwcm9wOiBjdXN0b20gdmFsaWRhdG9yIGNoZWNrIGZhaWxlZCBmb3IgcHJvcCBcIicgKyBuYW1lICsgJ1wiLicsXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuXG52YXIgc2ltcGxlQ2hlY2tSRSA9IC9eKFN0cmluZ3xOdW1iZXJ8Qm9vbGVhbnxGdW5jdGlvbnxTeW1ib2wpJC87XG5cbmZ1bmN0aW9uIGFzc2VydFR5cGUgKHZhbHVlLCB0eXBlKSB7XG4gIHZhciB2YWxpZDtcbiAgdmFyIGV4cGVjdGVkVHlwZSA9IGdldFR5cGUodHlwZSk7XG4gIGlmIChzaW1wbGVDaGVja1JFLnRlc3QoZXhwZWN0ZWRUeXBlKSkge1xuICAgIHZhciB0ID0gdHlwZW9mIHZhbHVlO1xuICAgIHZhbGlkID0gdCA9PT0gZXhwZWN0ZWRUeXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgLy8gZm9yIHByaW1pdGl2ZSB3cmFwcGVyIG9iamVjdHNcbiAgICBpZiAoIXZhbGlkICYmIHQgPT09ICdvYmplY3QnKSB7XG4gICAgICB2YWxpZCA9IHZhbHVlIGluc3RhbmNlb2YgdHlwZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSAnT2JqZWN0Jykge1xuICAgIHZhbGlkID0gaXNQbGFpbk9iamVjdCh2YWx1ZSk7XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSAnQXJyYXknKSB7XG4gICAgdmFsaWQgPSBBcnJheS5pc0FycmF5KHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICB2YWxpZCA9IHZhbHVlIGluc3RhbmNlb2YgdHlwZTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHZhbGlkOiB2YWxpZCxcbiAgICBleHBlY3RlZFR5cGU6IGV4cGVjdGVkVHlwZVxuICB9XG59XG5cbi8qKlxuICogVXNlIGZ1bmN0aW9uIHN0cmluZyBuYW1lIHRvIGNoZWNrIGJ1aWx0LWluIHR5cGVzLFxuICogYmVjYXVzZSBhIHNpbXBsZSBlcXVhbGl0eSBjaGVjayB3aWxsIGZhaWwgd2hlbiBydW5uaW5nXG4gKiBhY3Jvc3MgZGlmZmVyZW50IHZtcyAvIGlmcmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGdldFR5cGUgKGZuKSB7XG4gIHZhciBtYXRjaCA9IGZuICYmIGZuLnRvU3RyaW5nKCkubWF0Y2goL15cXHMqZnVuY3Rpb24gKFxcdyspLyk7XG4gIHJldHVybiBtYXRjaCA/IG1hdGNoWzFdIDogJydcbn1cblxuZnVuY3Rpb24gaXNUeXBlICh0eXBlLCBmbikge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoZm4pKSB7XG4gICAgcmV0dXJuIGdldFR5cGUoZm4pID09PSBnZXRUeXBlKHR5cGUpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGZuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGdldFR5cGUoZm5baV0pID09PSBnZXRUeXBlKHR5cGUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICByZXR1cm4gZmFsc2Vcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGhhbmRsZUVycm9yIChlcnIsIHZtLCBpbmZvKSB7XG4gIGlmICh2bSkge1xuICAgIHZhciBjdXIgPSB2bTtcbiAgICB3aGlsZSAoKGN1ciA9IGN1ci4kcGFyZW50KSkge1xuICAgICAgdmFyIGhvb2tzID0gY3VyLiRvcHRpb25zLmVycm9yQ2FwdHVyZWQ7XG4gICAgICBpZiAoaG9va3MpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBob29rcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgY2FwdHVyZSA9IGhvb2tzW2ldLmNhbGwoY3VyLCBlcnIsIHZtLCBpbmZvKSA9PT0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoY2FwdHVyZSkgeyByZXR1cm4gfVxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGdsb2JhbEhhbmRsZUVycm9yKGUsIGN1ciwgJ2Vycm9yQ2FwdHVyZWQgaG9vaycpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBnbG9iYWxIYW5kbGVFcnJvcihlcnIsIHZtLCBpbmZvKTtcbn1cblxuZnVuY3Rpb24gZ2xvYmFsSGFuZGxlRXJyb3IgKGVyciwgdm0sIGluZm8pIHtcbiAgaWYgKGNvbmZpZy5lcnJvckhhbmRsZXIpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGNvbmZpZy5lcnJvckhhbmRsZXIuY2FsbChudWxsLCBlcnIsIHZtLCBpbmZvKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGxvZ0Vycm9yKGUsIG51bGwsICdjb25maWcuZXJyb3JIYW5kbGVyJyk7XG4gICAgfVxuICB9XG4gIGxvZ0Vycm9yKGVyciwgdm0sIGluZm8pO1xufVxuXG5mdW5jdGlvbiBsb2dFcnJvciAoZXJyLCB2bSwgaW5mbykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHdhcm4oKFwiRXJyb3IgaW4gXCIgKyBpbmZvICsgXCI6IFxcXCJcIiArIChlcnIudG9TdHJpbmcoKSkgKyBcIlxcXCJcIiksIHZtKTtcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoKGluQnJvd3NlciB8fCBpbldlZXgpICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBlcnJcbiAgfVxufVxuXG4vKiAgKi9cbi8qIGdsb2JhbHMgTWVzc2FnZUNoYW5uZWwgKi9cblxudmFyIGNhbGxiYWNrcyA9IFtdO1xudmFyIHBlbmRpbmcgPSBmYWxzZTtcblxuZnVuY3Rpb24gZmx1c2hDYWxsYmFja3MgKCkge1xuICBwZW5kaW5nID0gZmFsc2U7XG4gIHZhciBjb3BpZXMgPSBjYWxsYmFja3Muc2xpY2UoMCk7XG4gIGNhbGxiYWNrcy5sZW5ndGggPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNvcGllcy5sZW5ndGg7IGkrKykge1xuICAgIGNvcGllc1tpXSgpO1xuICB9XG59XG5cbi8vIEhlcmUgd2UgaGF2ZSBhc3luYyBkZWZlcnJpbmcgd3JhcHBlcnMgdXNpbmcgYm90aCBtaWNybyBhbmQgbWFjcm8gdGFza3MuXG4vLyBJbiA8IDIuNCB3ZSB1c2VkIG1pY3JvIHRhc2tzIGV2ZXJ5d2hlcmUsIGJ1dCB0aGVyZSBhcmUgc29tZSBzY2VuYXJpb3Mgd2hlcmVcbi8vIG1pY3JvIHRhc2tzIGhhdmUgdG9vIGhpZ2ggYSBwcmlvcml0eSBhbmQgZmlyZXMgaW4gYmV0d2VlbiBzdXBwb3NlZGx5XG4vLyBzZXF1ZW50aWFsIGV2ZW50cyAoZS5nLiAjNDUyMSwgIzY2OTApIG9yIGV2ZW4gYmV0d2VlbiBidWJibGluZyBvZiB0aGUgc2FtZVxuLy8gZXZlbnQgKCM2NTY2KS4gSG93ZXZlciwgdXNpbmcgbWFjcm8gdGFza3MgZXZlcnl3aGVyZSBhbHNvIGhhcyBzdWJ0bGUgcHJvYmxlbXNcbi8vIHdoZW4gc3RhdGUgaXMgY2hhbmdlZCByaWdodCBiZWZvcmUgcmVwYWludCAoZS5nLiAjNjgxMywgb3V0LWluIHRyYW5zaXRpb25zKS5cbi8vIEhlcmUgd2UgdXNlIG1pY3JvIHRhc2sgYnkgZGVmYXVsdCwgYnV0IGV4cG9zZSBhIHdheSB0byBmb3JjZSBtYWNybyB0YXNrIHdoZW5cbi8vIG5lZWRlZCAoZS5nLiBpbiBldmVudCBoYW5kbGVycyBhdHRhY2hlZCBieSB2LW9uKS5cbnZhciBtaWNyb1RpbWVyRnVuYztcbnZhciBtYWNyb1RpbWVyRnVuYztcbnZhciB1c2VNYWNyb1Rhc2sgPSBmYWxzZTtcblxuLy8gRGV0ZXJtaW5lIChtYWNybykgVGFzayBkZWZlciBpbXBsZW1lbnRhdGlvbi5cbi8vIFRlY2huaWNhbGx5IHNldEltbWVkaWF0ZSBzaG91bGQgYmUgdGhlIGlkZWFsIGNob2ljZSwgYnV0IGl0J3Mgb25seSBhdmFpbGFibGVcbi8vIGluIElFLiBUaGUgb25seSBwb2x5ZmlsbCB0aGF0IGNvbnNpc3RlbnRseSBxdWV1ZXMgdGhlIGNhbGxiYWNrIGFmdGVyIGFsbCBET01cbi8vIGV2ZW50cyB0cmlnZ2VyZWQgaW4gdGhlIHNhbWUgbG9vcCBpcyBieSB1c2luZyBNZXNzYWdlQ2hhbm5lbC5cbi8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuaWYgKHR5cGVvZiBzZXRJbW1lZGlhdGUgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKHNldEltbWVkaWF0ZSkpIHtcbiAgbWFjcm9UaW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgc2V0SW1tZWRpYXRlKGZsdXNoQ2FsbGJhY2tzKTtcbiAgfTtcbn0gZWxzZSBpZiAodHlwZW9mIE1lc3NhZ2VDaGFubmVsICE9PSAndW5kZWZpbmVkJyAmJiAoXG4gIGlzTmF0aXZlKE1lc3NhZ2VDaGFubmVsKSB8fFxuICAvLyBQaGFudG9tSlNcbiAgTWVzc2FnZUNoYW5uZWwudG9TdHJpbmcoKSA9PT0gJ1tvYmplY3QgTWVzc2FnZUNoYW5uZWxDb25zdHJ1Y3Rvcl0nXG4pKSB7XG4gIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gIHZhciBwb3J0ID0gY2hhbm5lbC5wb3J0MjtcbiAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBmbHVzaENhbGxiYWNrcztcbiAgbWFjcm9UaW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcG9ydC5wb3N0TWVzc2FnZSgxKTtcbiAgfTtcbn0gZWxzZSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIG1hY3JvVGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgIHNldFRpbWVvdXQoZmx1c2hDYWxsYmFja3MsIDApO1xuICB9O1xufVxuXG4vLyBEZXRlcm1pbmUgTWljcm9UYXNrIGRlZmVyIGltcGxlbWVudGF0aW9uLlxuLyogaXN0YW5idWwgaWdub3JlIG5leHQsICRmbG93LWRpc2FibGUtbGluZSAqL1xuaWYgKHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShQcm9taXNlKSkge1xuICB2YXIgcCA9IFByb21pc2UucmVzb2x2ZSgpO1xuICBtaWNyb1RpbWVyRnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICBwLnRoZW4oZmx1c2hDYWxsYmFja3MpO1xuICAgIC8vIGluIHByb2JsZW1hdGljIFVJV2ViVmlld3MsIFByb21pc2UudGhlbiBkb2Vzbid0IGNvbXBsZXRlbHkgYnJlYWssIGJ1dFxuICAgIC8vIGl0IGNhbiBnZXQgc3R1Y2sgaW4gYSB3ZWlyZCBzdGF0ZSB3aGVyZSBjYWxsYmFja3MgYXJlIHB1c2hlZCBpbnRvIHRoZVxuICAgIC8vIG1pY3JvdGFzayBxdWV1ZSBidXQgdGhlIHF1ZXVlIGlzbid0IGJlaW5nIGZsdXNoZWQsIHVudGlsIHRoZSBicm93c2VyXG4gICAgLy8gbmVlZHMgdG8gZG8gc29tZSBvdGhlciB3b3JrLCBlLmcuIGhhbmRsZSBhIHRpbWVyLiBUaGVyZWZvcmUgd2UgY2FuXG4gICAgLy8gXCJmb3JjZVwiIHRoZSBtaWNyb3Rhc2sgcXVldWUgdG8gYmUgZmx1c2hlZCBieSBhZGRpbmcgYW4gZW1wdHkgdGltZXIuXG4gICAgaWYgKGlzSU9TKSB7IHNldFRpbWVvdXQobm9vcCk7IH1cbiAgfTtcbn0gZWxzZSB7XG4gIC8vIGZhbGxiYWNrIHRvIG1hY3JvXG4gIG1pY3JvVGltZXJGdW5jID0gbWFjcm9UaW1lckZ1bmM7XG59XG5cbi8qKlxuICogV3JhcCBhIGZ1bmN0aW9uIHNvIHRoYXQgaWYgYW55IGNvZGUgaW5zaWRlIHRyaWdnZXJzIHN0YXRlIGNoYW5nZSxcbiAqIHRoZSBjaGFuZ2VzIGFyZSBxdWV1ZWQgdXNpbmcgYSBUYXNrIGluc3RlYWQgb2YgYSBNaWNyb1Rhc2suXG4gKi9cbmZ1bmN0aW9uIHdpdGhNYWNyb1Rhc2sgKGZuKSB7XG4gIHJldHVybiBmbi5fd2l0aFRhc2sgfHwgKGZuLl93aXRoVGFzayA9IGZ1bmN0aW9uICgpIHtcbiAgICB1c2VNYWNyb1Rhc2sgPSB0cnVlO1xuICAgIHZhciByZXMgPSBmbi5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIHVzZU1hY3JvVGFzayA9IGZhbHNlO1xuICAgIHJldHVybiByZXNcbiAgfSlcbn1cblxuZnVuY3Rpb24gbmV4dFRpY2sgKGNiLCBjdHgpIHtcbiAgdmFyIF9yZXNvbHZlO1xuICBjYWxsYmFja3MucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGNiKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjYi5jYWxsKGN0eCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGhhbmRsZUVycm9yKGUsIGN0eCwgJ25leHRUaWNrJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChfcmVzb2x2ZSkge1xuICAgICAgX3Jlc29sdmUoY3R4KTtcbiAgICB9XG4gIH0pO1xuICBpZiAoIXBlbmRpbmcpIHtcbiAgICBwZW5kaW5nID0gdHJ1ZTtcbiAgICBpZiAodXNlTWFjcm9UYXNrKSB7XG4gICAgICBtYWNyb1RpbWVyRnVuYygpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtaWNyb1RpbWVyRnVuYygpO1xuICAgIH1cbiAgfVxuICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgaWYgKCFjYiAmJiB0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgIF9yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICB9KVxuICB9XG59XG5cbi8qICAqL1xuXG4vKiBub3QgdHlwZSBjaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBmbG93IGRvZXNuJ3QgcGxheSB3ZWxsIHdpdGggUHJveHkgKi9cblxudmFyIGluaXRQcm94eTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIGFsbG93ZWRHbG9iYWxzID0gbWFrZU1hcChcbiAgICAnSW5maW5pdHksdW5kZWZpbmVkLE5hTixpc0Zpbml0ZSxpc05hTiwnICtcbiAgICAncGFyc2VGbG9hdCxwYXJzZUludCxkZWNvZGVVUkksZGVjb2RlVVJJQ29tcG9uZW50LGVuY29kZVVSSSxlbmNvZGVVUklDb21wb25lbnQsJyArXG4gICAgJ01hdGgsTnVtYmVyLERhdGUsQXJyYXksT2JqZWN0LEJvb2xlYW4sU3RyaW5nLFJlZ0V4cCxNYXAsU2V0LEpTT04sSW50bCwnICtcbiAgICAncmVxdWlyZScgLy8gZm9yIFdlYnBhY2svQnJvd3NlcmlmeVxuICApO1xuXG4gIHZhciB3YXJuTm9uUHJlc2VudCA9IGZ1bmN0aW9uICh0YXJnZXQsIGtleSkge1xuICAgIHdhcm4oXG4gICAgICBcIlByb3BlcnR5IG9yIG1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaXMgbm90IGRlZmluZWQgb24gdGhlIGluc3RhbmNlIGJ1dCBcIiArXG4gICAgICAncmVmZXJlbmNlZCBkdXJpbmcgcmVuZGVyLiBNYWtlIHN1cmUgdGhhdCB0aGlzIHByb3BlcnR5IGlzIHJlYWN0aXZlLCAnICtcbiAgICAgICdlaXRoZXIgaW4gdGhlIGRhdGEgb3B0aW9uLCBvciBmb3IgY2xhc3MtYmFzZWQgY29tcG9uZW50cywgYnkgJyArXG4gICAgICAnaW5pdGlhbGl6aW5nIHRoZSBwcm9wZXJ0eS4gJyArXG4gICAgICAnU2VlOiBodHRwczovL3Z1ZWpzLm9yZy92Mi9ndWlkZS9yZWFjdGl2aXR5Lmh0bWwjRGVjbGFyaW5nLVJlYWN0aXZlLVByb3BlcnRpZXMuJyxcbiAgICAgIHRhcmdldFxuICAgICk7XG4gIH07XG5cbiAgdmFyIGhhc1Byb3h5ID1cbiAgICB0eXBlb2YgUHJveHkgIT09ICd1bmRlZmluZWQnICYmXG4gICAgUHJveHkudG9TdHJpbmcoKS5tYXRjaCgvbmF0aXZlIGNvZGUvKTtcblxuICBpZiAoaGFzUHJveHkpIHtcbiAgICB2YXIgaXNCdWlsdEluTW9kaWZpZXIgPSBtYWtlTWFwKCdzdG9wLHByZXZlbnQsc2VsZixjdHJsLHNoaWZ0LGFsdCxtZXRhLGV4YWN0Jyk7XG4gICAgY29uZmlnLmtleUNvZGVzID0gbmV3IFByb3h5KGNvbmZpZy5rZXlDb2Rlcywge1xuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQgKHRhcmdldCwga2V5LCB2YWx1ZSkge1xuICAgICAgICBpZiAoaXNCdWlsdEluTW9kaWZpZXIoa2V5KSkge1xuICAgICAgICAgIHdhcm4oKFwiQXZvaWQgb3ZlcndyaXRpbmcgYnVpbHQtaW4gbW9kaWZpZXIgaW4gY29uZmlnLmtleUNvZGVzOiAuXCIgKyBrZXkpKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHZhbHVlO1xuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHZhciBoYXNIYW5kbGVyID0ge1xuICAgIGhhczogZnVuY3Rpb24gaGFzICh0YXJnZXQsIGtleSkge1xuICAgICAgdmFyIGhhcyA9IGtleSBpbiB0YXJnZXQ7XG4gICAgICB2YXIgaXNBbGxvd2VkID0gYWxsb3dlZEdsb2JhbHMoa2V5KSB8fCBrZXkuY2hhckF0KDApID09PSAnXyc7XG4gICAgICBpZiAoIWhhcyAmJiAhaXNBbGxvd2VkKSB7XG4gICAgICAgIHdhcm5Ob25QcmVzZW50KHRhcmdldCwga2V5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBoYXMgfHwgIWlzQWxsb3dlZFxuICAgIH1cbiAgfTtcblxuICB2YXIgZ2V0SGFuZGxlciA9IHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCAodGFyZ2V0LCBrZXkpIHtcbiAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyAmJiAhKGtleSBpbiB0YXJnZXQpKSB7XG4gICAgICAgIHdhcm5Ob25QcmVzZW50KHRhcmdldCwga2V5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0YXJnZXRba2V5XVxuICAgIH1cbiAgfTtcblxuICBpbml0UHJveHkgPSBmdW5jdGlvbiBpbml0UHJveHkgKHZtKSB7XG4gICAgaWYgKGhhc1Byb3h5KSB7XG4gICAgICAvLyBkZXRlcm1pbmUgd2hpY2ggcHJveHkgaGFuZGxlciB0byB1c2VcbiAgICAgIHZhciBvcHRpb25zID0gdm0uJG9wdGlvbnM7XG4gICAgICB2YXIgaGFuZGxlcnMgPSBvcHRpb25zLnJlbmRlciAmJiBvcHRpb25zLnJlbmRlci5fd2l0aFN0cmlwcGVkXG4gICAgICAgID8gZ2V0SGFuZGxlclxuICAgICAgICA6IGhhc0hhbmRsZXI7XG4gICAgICB2bS5fcmVuZGVyUHJveHkgPSBuZXcgUHJveHkodm0sIGhhbmRsZXJzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm0uX3JlbmRlclByb3h5ID0gdm07XG4gICAgfVxuICB9O1xufVxuXG4vKiAgKi9cblxudmFyIHNlZW5PYmplY3RzID0gbmV3IF9TZXQoKTtcblxuLyoqXG4gKiBSZWN1cnNpdmVseSB0cmF2ZXJzZSBhbiBvYmplY3QgdG8gZXZva2UgYWxsIGNvbnZlcnRlZFxuICogZ2V0dGVycywgc28gdGhhdCBldmVyeSBuZXN0ZWQgcHJvcGVydHkgaW5zaWRlIHRoZSBvYmplY3RcbiAqIGlzIGNvbGxlY3RlZCBhcyBhIFwiZGVlcFwiIGRlcGVuZGVuY3kuXG4gKi9cbmZ1bmN0aW9uIHRyYXZlcnNlICh2YWwpIHtcbiAgX3RyYXZlcnNlKHZhbCwgc2Vlbk9iamVjdHMpO1xuICBzZWVuT2JqZWN0cy5jbGVhcigpO1xufVxuXG5mdW5jdGlvbiBfdHJhdmVyc2UgKHZhbCwgc2Vlbikge1xuICB2YXIgaSwga2V5cztcbiAgdmFyIGlzQSA9IEFycmF5LmlzQXJyYXkodmFsKTtcbiAgaWYgKCghaXNBICYmICFpc09iamVjdCh2YWwpKSB8fCBPYmplY3QuaXNGcm96ZW4odmFsKSkge1xuICAgIHJldHVyblxuICB9XG4gIGlmICh2YWwuX19vYl9fKSB7XG4gICAgdmFyIGRlcElkID0gdmFsLl9fb2JfXy5kZXAuaWQ7XG4gICAgaWYgKHNlZW4uaGFzKGRlcElkKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHNlZW4uYWRkKGRlcElkKTtcbiAgfVxuICBpZiAoaXNBKSB7XG4gICAgaSA9IHZhbC5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkgeyBfdHJhdmVyc2UodmFsW2ldLCBzZWVuKTsgfVxuICB9IGVsc2Uge1xuICAgIGtleXMgPSBPYmplY3Qua2V5cyh2YWwpO1xuICAgIGkgPSBrZXlzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7IF90cmF2ZXJzZSh2YWxba2V5c1tpXV0sIHNlZW4pOyB9XG4gIH1cbn1cblxudmFyIG1hcms7XG52YXIgbWVhc3VyZTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIHBlcmYgPSBpbkJyb3dzZXIgJiYgd2luZG93LnBlcmZvcm1hbmNlO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKFxuICAgIHBlcmYgJiZcbiAgICBwZXJmLm1hcmsgJiZcbiAgICBwZXJmLm1lYXN1cmUgJiZcbiAgICBwZXJmLmNsZWFyTWFya3MgJiZcbiAgICBwZXJmLmNsZWFyTWVhc3VyZXNcbiAgKSB7XG4gICAgbWFyayA9IGZ1bmN0aW9uICh0YWcpIHsgcmV0dXJuIHBlcmYubWFyayh0YWcpOyB9O1xuICAgIG1lYXN1cmUgPSBmdW5jdGlvbiAobmFtZSwgc3RhcnRUYWcsIGVuZFRhZykge1xuICAgICAgcGVyZi5tZWFzdXJlKG5hbWUsIHN0YXJ0VGFnLCBlbmRUYWcpO1xuICAgICAgcGVyZi5jbGVhck1hcmtzKHN0YXJ0VGFnKTtcbiAgICAgIHBlcmYuY2xlYXJNYXJrcyhlbmRUYWcpO1xuICAgICAgcGVyZi5jbGVhck1lYXN1cmVzKG5hbWUpO1xuICAgIH07XG4gIH1cbn1cblxuLyogICovXG5cbnZhciBub3JtYWxpemVFdmVudCA9IGNhY2hlZChmdW5jdGlvbiAobmFtZSkge1xuICB2YXIgcGFzc2l2ZSA9IG5hbWUuY2hhckF0KDApID09PSAnJic7XG4gIG5hbWUgPSBwYXNzaXZlID8gbmFtZS5zbGljZSgxKSA6IG5hbWU7XG4gIHZhciBvbmNlJCQxID0gbmFtZS5jaGFyQXQoMCkgPT09ICd+JzsgLy8gUHJlZml4ZWQgbGFzdCwgY2hlY2tlZCBmaXJzdFxuICBuYW1lID0gb25jZSQkMSA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lO1xuICB2YXIgY2FwdHVyZSA9IG5hbWUuY2hhckF0KDApID09PSAnISc7XG4gIG5hbWUgPSBjYXB0dXJlID8gbmFtZS5zbGljZSgxKSA6IG5hbWU7XG4gIHJldHVybiB7XG4gICAgbmFtZTogbmFtZSxcbiAgICBvbmNlOiBvbmNlJCQxLFxuICAgIGNhcHR1cmU6IGNhcHR1cmUsXG4gICAgcGFzc2l2ZTogcGFzc2l2ZVxuICB9XG59KTtcblxuZnVuY3Rpb24gY3JlYXRlRm5JbnZva2VyIChmbnMpIHtcbiAgZnVuY3Rpb24gaW52b2tlciAoKSB7XG4gICAgdmFyIGFyZ3VtZW50cyQxID0gYXJndW1lbnRzO1xuXG4gICAgdmFyIGZucyA9IGludm9rZXIuZm5zO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGZucykpIHtcbiAgICAgIHZhciBjbG9uZWQgPSBmbnMuc2xpY2UoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2xvbmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNsb25lZFtpXS5hcHBseShudWxsLCBhcmd1bWVudHMkMSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHJldHVybiBoYW5kbGVyIHJldHVybiB2YWx1ZSBmb3Igc2luZ2xlIGhhbmRsZXJzXG4gICAgICByZXR1cm4gZm5zLmFwcGx5KG51bGwsIGFyZ3VtZW50cylcbiAgICB9XG4gIH1cbiAgaW52b2tlci5mbnMgPSBmbnM7XG4gIHJldHVybiBpbnZva2VyXG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUxpc3RlbmVycyAoXG4gIG9uLFxuICBvbGRPbixcbiAgYWRkLFxuICByZW1vdmUkJDEsXG4gIHZtXG4pIHtcbiAgdmFyIG5hbWUsIGRlZiwgY3VyLCBvbGQsIGV2ZW50O1xuICBmb3IgKG5hbWUgaW4gb24pIHtcbiAgICBkZWYgPSBjdXIgPSBvbltuYW1lXTtcbiAgICBvbGQgPSBvbGRPbltuYW1lXTtcbiAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50KG5hbWUpO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChpc1VuZGVmKGN1cikpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgXCJJbnZhbGlkIGhhbmRsZXIgZm9yIGV2ZW50IFxcXCJcIiArIChldmVudC5uYW1lKSArIFwiXFxcIjogZ290IFwiICsgU3RyaW5nKGN1ciksXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoaXNVbmRlZihvbGQpKSB7XG4gICAgICBpZiAoaXNVbmRlZihjdXIuZm5zKSkge1xuICAgICAgICBjdXIgPSBvbltuYW1lXSA9IGNyZWF0ZUZuSW52b2tlcihjdXIpO1xuICAgICAgfVxuICAgICAgYWRkKGV2ZW50Lm5hbWUsIGN1ciwgZXZlbnQub25jZSwgZXZlbnQuY2FwdHVyZSwgZXZlbnQucGFzc2l2ZSwgZXZlbnQucGFyYW1zKTtcbiAgICB9IGVsc2UgaWYgKGN1ciAhPT0gb2xkKSB7XG4gICAgICBvbGQuZm5zID0gY3VyO1xuICAgICAgb25bbmFtZV0gPSBvbGQ7XG4gICAgfVxuICB9XG4gIGZvciAobmFtZSBpbiBvbGRPbikge1xuICAgIGlmIChpc1VuZGVmKG9uW25hbWVdKSkge1xuICAgICAgZXZlbnQgPSBub3JtYWxpemVFdmVudChuYW1lKTtcbiAgICAgIHJlbW92ZSQkMShldmVudC5uYW1lLCBvbGRPbltuYW1lXSwgZXZlbnQuY2FwdHVyZSk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBtZXJnZVZOb2RlSG9vayAoZGVmLCBob29rS2V5LCBob29rKSB7XG4gIGlmIChkZWYgaW5zdGFuY2VvZiBWTm9kZSkge1xuICAgIGRlZiA9IGRlZi5kYXRhLmhvb2sgfHwgKGRlZi5kYXRhLmhvb2sgPSB7fSk7XG4gIH1cbiAgdmFyIGludm9rZXI7XG4gIHZhciBvbGRIb29rID0gZGVmW2hvb2tLZXldO1xuXG4gIGZ1bmN0aW9uIHdyYXBwZWRIb29rICgpIHtcbiAgICBob29rLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgLy8gaW1wb3J0YW50OiByZW1vdmUgbWVyZ2VkIGhvb2sgdG8gZW5zdXJlIGl0J3MgY2FsbGVkIG9ubHkgb25jZVxuICAgIC8vIGFuZCBwcmV2ZW50IG1lbW9yeSBsZWFrXG4gICAgcmVtb3ZlKGludm9rZXIuZm5zLCB3cmFwcGVkSG9vayk7XG4gIH1cblxuICBpZiAoaXNVbmRlZihvbGRIb29rKSkge1xuICAgIC8vIG5vIGV4aXN0aW5nIGhvb2tcbiAgICBpbnZva2VyID0gY3JlYXRlRm5JbnZva2VyKFt3cmFwcGVkSG9va10pO1xuICB9IGVsc2Uge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChpc0RlZihvbGRIb29rLmZucykgJiYgaXNUcnVlKG9sZEhvb2subWVyZ2VkKSkge1xuICAgICAgLy8gYWxyZWFkeSBhIG1lcmdlZCBpbnZva2VyXG4gICAgICBpbnZva2VyID0gb2xkSG9vaztcbiAgICAgIGludm9rZXIuZm5zLnB1c2god3JhcHBlZEhvb2spO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBleGlzdGluZyBwbGFpbiBob29rXG4gICAgICBpbnZva2VyID0gY3JlYXRlRm5JbnZva2VyKFtvbGRIb29rLCB3cmFwcGVkSG9va10pO1xuICAgIH1cbiAgfVxuXG4gIGludm9rZXIubWVyZ2VkID0gdHJ1ZTtcbiAgZGVmW2hvb2tLZXldID0gaW52b2tlcjtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGV4dHJhY3RQcm9wc0Zyb21WTm9kZURhdGEgKFxuICBkYXRhLFxuICBDdG9yLFxuICB0YWdcbikge1xuICAvLyB3ZSBhcmUgb25seSBleHRyYWN0aW5nIHJhdyB2YWx1ZXMgaGVyZS5cbiAgLy8gdmFsaWRhdGlvbiBhbmQgZGVmYXVsdCB2YWx1ZXMgYXJlIGhhbmRsZWQgaW4gdGhlIGNoaWxkXG4gIC8vIGNvbXBvbmVudCBpdHNlbGYuXG4gIHZhciBwcm9wT3B0aW9ucyA9IEN0b3Iub3B0aW9ucy5wcm9wcztcbiAgaWYgKGlzVW5kZWYocHJvcE9wdGlvbnMpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHJlcyA9IHt9O1xuICB2YXIgYXR0cnMgPSBkYXRhLmF0dHJzO1xuICB2YXIgcHJvcHMgPSBkYXRhLnByb3BzO1xuICBpZiAoaXNEZWYoYXR0cnMpIHx8IGlzRGVmKHByb3BzKSkge1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wT3B0aW9ucykge1xuICAgICAgdmFyIGFsdEtleSA9IGh5cGhlbmF0ZShrZXkpO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdmFyIGtleUluTG93ZXJDYXNlID0ga2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBrZXkgIT09IGtleUluTG93ZXJDYXNlICYmXG4gICAgICAgICAgYXR0cnMgJiYgaGFzT3duKGF0dHJzLCBrZXlJbkxvd2VyQ2FzZSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgdGlwKFxuICAgICAgICAgICAgXCJQcm9wIFxcXCJcIiArIGtleUluTG93ZXJDYXNlICsgXCJcXFwiIGlzIHBhc3NlZCB0byBjb21wb25lbnQgXCIgK1xuICAgICAgICAgICAgKGZvcm1hdENvbXBvbmVudE5hbWUodGFnIHx8IEN0b3IpKSArIFwiLCBidXQgdGhlIGRlY2xhcmVkIHByb3AgbmFtZSBpc1wiICtcbiAgICAgICAgICAgIFwiIFxcXCJcIiArIGtleSArIFwiXFxcIi4gXCIgK1xuICAgICAgICAgICAgXCJOb3RlIHRoYXQgSFRNTCBhdHRyaWJ1dGVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlIGFuZCBjYW1lbENhc2VkIFwiICtcbiAgICAgICAgICAgIFwicHJvcHMgbmVlZCB0byB1c2UgdGhlaXIga2ViYWItY2FzZSBlcXVpdmFsZW50cyB3aGVuIHVzaW5nIGluLURPTSBcIiArXG4gICAgICAgICAgICBcInRlbXBsYXRlcy4gWW91IHNob3VsZCBwcm9iYWJseSB1c2UgXFxcIlwiICsgYWx0S2V5ICsgXCJcXFwiIGluc3RlYWQgb2YgXFxcIlwiICsga2V5ICsgXCJcXFwiLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY2hlY2tQcm9wKHJlcywgcHJvcHMsIGtleSwgYWx0S2V5LCB0cnVlKSB8fFxuICAgICAgY2hlY2tQcm9wKHJlcywgYXR0cnMsIGtleSwgYWx0S2V5LCBmYWxzZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gY2hlY2tQcm9wIChcbiAgcmVzLFxuICBoYXNoLFxuICBrZXksXG4gIGFsdEtleSxcbiAgcHJlc2VydmVcbikge1xuICBpZiAoaXNEZWYoaGFzaCkpIHtcbiAgICBpZiAoaGFzT3duKGhhc2gsIGtleSkpIHtcbiAgICAgIHJlc1trZXldID0gaGFzaFtrZXldO1xuICAgICAgaWYgKCFwcmVzZXJ2ZSkge1xuICAgICAgICBkZWxldGUgaGFzaFtrZXldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9IGVsc2UgaWYgKGhhc093bihoYXNoLCBhbHRLZXkpKSB7XG4gICAgICByZXNba2V5XSA9IGhhc2hbYWx0S2V5XTtcbiAgICAgIGlmICghcHJlc2VydmUpIHtcbiAgICAgICAgZGVsZXRlIGhhc2hbYWx0S2V5XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG4vKiAgKi9cblxuLy8gVGhlIHRlbXBsYXRlIGNvbXBpbGVyIGF0dGVtcHRzIHRvIG1pbmltaXplIHRoZSBuZWVkIGZvciBub3JtYWxpemF0aW9uIGJ5XG4vLyBzdGF0aWNhbGx5IGFuYWx5emluZyB0aGUgdGVtcGxhdGUgYXQgY29tcGlsZSB0aW1lLlxuLy9cbi8vIEZvciBwbGFpbiBIVE1MIG1hcmt1cCwgbm9ybWFsaXphdGlvbiBjYW4gYmUgY29tcGxldGVseSBza2lwcGVkIGJlY2F1c2UgdGhlXG4vLyBnZW5lcmF0ZWQgcmVuZGVyIGZ1bmN0aW9uIGlzIGd1YXJhbnRlZWQgdG8gcmV0dXJuIEFycmF5PFZOb2RlPi4gVGhlcmUgYXJlXG4vLyB0d28gY2FzZXMgd2hlcmUgZXh0cmEgbm9ybWFsaXphdGlvbiBpcyBuZWVkZWQ6XG5cbi8vIDEuIFdoZW4gdGhlIGNoaWxkcmVuIGNvbnRhaW5zIGNvbXBvbmVudHMgLSBiZWNhdXNlIGEgZnVuY3Rpb25hbCBjb21wb25lbnRcbi8vIG1heSByZXR1cm4gYW4gQXJyYXkgaW5zdGVhZCBvZiBhIHNpbmdsZSByb290LiBJbiB0aGlzIGNhc2UsIGp1c3QgYSBzaW1wbGVcbi8vIG5vcm1hbGl6YXRpb24gaXMgbmVlZGVkIC0gaWYgYW55IGNoaWxkIGlzIGFuIEFycmF5LCB3ZSBmbGF0dGVuIHRoZSB3aG9sZVxuLy8gdGhpbmcgd2l0aCBBcnJheS5wcm90b3R5cGUuY29uY2F0LiBJdCBpcyBndWFyYW50ZWVkIHRvIGJlIG9ubHkgMS1sZXZlbCBkZWVwXG4vLyBiZWNhdXNlIGZ1bmN0aW9uYWwgY29tcG9uZW50cyBhbHJlYWR5IG5vcm1hbGl6ZSB0aGVpciBvd24gY2hpbGRyZW4uXG5mdW5jdGlvbiBzaW1wbGVOb3JtYWxpemVDaGlsZHJlbiAoY2hpbGRyZW4pIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuW2ldKSkge1xuICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIGNoaWxkcmVuKVxuICAgIH1cbiAgfVxuICByZXR1cm4gY2hpbGRyZW5cbn1cblxuLy8gMi4gV2hlbiB0aGUgY2hpbGRyZW4gY29udGFpbnMgY29uc3RydWN0cyB0aGF0IGFsd2F5cyBnZW5lcmF0ZWQgbmVzdGVkIEFycmF5cyxcbi8vIGUuZy4gPHRlbXBsYXRlPiwgPHNsb3Q+LCB2LWZvciwgb3Igd2hlbiB0aGUgY2hpbGRyZW4gaXMgcHJvdmlkZWQgYnkgdXNlclxuLy8gd2l0aCBoYW5kLXdyaXR0ZW4gcmVuZGVyIGZ1bmN0aW9ucyAvIEpTWC4gSW4gc3VjaCBjYXNlcyBhIGZ1bGwgbm9ybWFsaXphdGlvblxuLy8gaXMgbmVlZGVkIHRvIGNhdGVyIHRvIGFsbCBwb3NzaWJsZSB0eXBlcyBvZiBjaGlsZHJlbiB2YWx1ZXMuXG5mdW5jdGlvbiBub3JtYWxpemVDaGlsZHJlbiAoY2hpbGRyZW4pIHtcbiAgcmV0dXJuIGlzUHJpbWl0aXZlKGNoaWxkcmVuKVxuICAgID8gW2NyZWF0ZVRleHRWTm9kZShjaGlsZHJlbildXG4gICAgOiBBcnJheS5pc0FycmF5KGNoaWxkcmVuKVxuICAgICAgPyBub3JtYWxpemVBcnJheUNoaWxkcmVuKGNoaWxkcmVuKVxuICAgICAgOiB1bmRlZmluZWRcbn1cblxuZnVuY3Rpb24gaXNUZXh0Tm9kZSAobm9kZSkge1xuICByZXR1cm4gaXNEZWYobm9kZSkgJiYgaXNEZWYobm9kZS50ZXh0KSAmJiBpc0ZhbHNlKG5vZGUuaXNDb21tZW50KVxufVxuXG5mdW5jdGlvbiBub3JtYWxpemVBcnJheUNoaWxkcmVuIChjaGlsZHJlbiwgbmVzdGVkSW5kZXgpIHtcbiAgdmFyIHJlcyA9IFtdO1xuICB2YXIgaSwgYywgbGFzdEluZGV4LCBsYXN0O1xuICBmb3IgKGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBjID0gY2hpbGRyZW5baV07XG4gICAgaWYgKGlzVW5kZWYoYykgfHwgdHlwZW9mIGMgPT09ICdib29sZWFuJykgeyBjb250aW51ZSB9XG4gICAgbGFzdEluZGV4ID0gcmVzLmxlbmd0aCAtIDE7XG4gICAgbGFzdCA9IHJlc1tsYXN0SW5kZXhdO1xuICAgIC8vICBuZXN0ZWRcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjKSkge1xuICAgICAgaWYgKGMubGVuZ3RoID4gMCkge1xuICAgICAgICBjID0gbm9ybWFsaXplQXJyYXlDaGlsZHJlbihjLCAoKG5lc3RlZEluZGV4IHx8ICcnKSArIFwiX1wiICsgaSkpO1xuICAgICAgICAvLyBtZXJnZSBhZGphY2VudCB0ZXh0IG5vZGVzXG4gICAgICAgIGlmIChpc1RleHROb2RlKGNbMF0pICYmIGlzVGV4dE5vZGUobGFzdCkpIHtcbiAgICAgICAgICByZXNbbGFzdEluZGV4XSA9IGNyZWF0ZVRleHRWTm9kZShsYXN0LnRleHQgKyAoY1swXSkudGV4dCk7XG4gICAgICAgICAgYy5zaGlmdCgpO1xuICAgICAgICB9XG4gICAgICAgIHJlcy5wdXNoLmFwcGx5KHJlcywgYyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1ByaW1pdGl2ZShjKSkge1xuICAgICAgaWYgKGlzVGV4dE5vZGUobGFzdCkpIHtcbiAgICAgICAgLy8gbWVyZ2UgYWRqYWNlbnQgdGV4dCBub2Rlc1xuICAgICAgICAvLyB0aGlzIGlzIG5lY2Vzc2FyeSBmb3IgU1NSIGh5ZHJhdGlvbiBiZWNhdXNlIHRleHQgbm9kZXMgYXJlXG4gICAgICAgIC8vIGVzc2VudGlhbGx5IG1lcmdlZCB3aGVuIHJlbmRlcmVkIHRvIEhUTUwgc3RyaW5nc1xuICAgICAgICByZXNbbGFzdEluZGV4XSA9IGNyZWF0ZVRleHRWTm9kZShsYXN0LnRleHQgKyBjKTtcbiAgICAgIH0gZWxzZSBpZiAoYyAhPT0gJycpIHtcbiAgICAgICAgLy8gY29udmVydCBwcmltaXRpdmUgdG8gdm5vZGVcbiAgICAgICAgcmVzLnB1c2goY3JlYXRlVGV4dFZOb2RlKGMpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGlzVGV4dE5vZGUoYykgJiYgaXNUZXh0Tm9kZShsYXN0KSkge1xuICAgICAgICAvLyBtZXJnZSBhZGphY2VudCB0ZXh0IG5vZGVzXG4gICAgICAgIHJlc1tsYXN0SW5kZXhdID0gY3JlYXRlVGV4dFZOb2RlKGxhc3QudGV4dCArIGMudGV4dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkZWZhdWx0IGtleSBmb3IgbmVzdGVkIGFycmF5IGNoaWxkcmVuIChsaWtlbHkgZ2VuZXJhdGVkIGJ5IHYtZm9yKVxuICAgICAgICBpZiAoaXNUcnVlKGNoaWxkcmVuLl9pc1ZMaXN0KSAmJlxuICAgICAgICAgIGlzRGVmKGMudGFnKSAmJlxuICAgICAgICAgIGlzVW5kZWYoYy5rZXkpICYmXG4gICAgICAgICAgaXNEZWYobmVzdGVkSW5kZXgpKSB7XG4gICAgICAgICAgYy5rZXkgPSBcIl9fdmxpc3RcIiArIG5lc3RlZEluZGV4ICsgXCJfXCIgKyBpICsgXCJfX1wiO1xuICAgICAgICB9XG4gICAgICAgIHJlcy5wdXNoKGMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBlbnN1cmVDdG9yIChjb21wLCBiYXNlKSB7XG4gIGlmIChcbiAgICBjb21wLl9fZXNNb2R1bGUgfHxcbiAgICAoaGFzU3ltYm9sICYmIGNvbXBbU3ltYm9sLnRvU3RyaW5nVGFnXSA9PT0gJ01vZHVsZScpXG4gICkge1xuICAgIGNvbXAgPSBjb21wLmRlZmF1bHQ7XG4gIH1cbiAgcmV0dXJuIGlzT2JqZWN0KGNvbXApXG4gICAgPyBiYXNlLmV4dGVuZChjb21wKVxuICAgIDogY29tcFxufVxuXG5mdW5jdGlvbiBjcmVhdGVBc3luY1BsYWNlaG9sZGVyIChcbiAgZmFjdG9yeSxcbiAgZGF0YSxcbiAgY29udGV4dCxcbiAgY2hpbGRyZW4sXG4gIHRhZ1xuKSB7XG4gIHZhciBub2RlID0gY3JlYXRlRW1wdHlWTm9kZSgpO1xuICBub2RlLmFzeW5jRmFjdG9yeSA9IGZhY3Rvcnk7XG4gIG5vZGUuYXN5bmNNZXRhID0geyBkYXRhOiBkYXRhLCBjb250ZXh0OiBjb250ZXh0LCBjaGlsZHJlbjogY2hpbGRyZW4sIHRhZzogdGFnIH07XG4gIHJldHVybiBub2RlXG59XG5cbmZ1bmN0aW9uIHJlc29sdmVBc3luY0NvbXBvbmVudCAoXG4gIGZhY3RvcnksXG4gIGJhc2VDdG9yLFxuICBjb250ZXh0XG4pIHtcbiAgaWYgKGlzVHJ1ZShmYWN0b3J5LmVycm9yKSAmJiBpc0RlZihmYWN0b3J5LmVycm9yQ29tcCkpIHtcbiAgICByZXR1cm4gZmFjdG9yeS5lcnJvckNvbXBcbiAgfVxuXG4gIGlmIChpc0RlZihmYWN0b3J5LnJlc29sdmVkKSkge1xuICAgIHJldHVybiBmYWN0b3J5LnJlc29sdmVkXG4gIH1cblxuICBpZiAoaXNUcnVlKGZhY3RvcnkubG9hZGluZykgJiYgaXNEZWYoZmFjdG9yeS5sb2FkaW5nQ29tcCkpIHtcbiAgICByZXR1cm4gZmFjdG9yeS5sb2FkaW5nQ29tcFxuICB9XG5cbiAgaWYgKGlzRGVmKGZhY3RvcnkuY29udGV4dHMpKSB7XG4gICAgLy8gYWxyZWFkeSBwZW5kaW5nXG4gICAgZmFjdG9yeS5jb250ZXh0cy5wdXNoKGNvbnRleHQpO1xuICB9IGVsc2Uge1xuICAgIHZhciBjb250ZXh0cyA9IGZhY3RvcnkuY29udGV4dHMgPSBbY29udGV4dF07XG4gICAgdmFyIHN5bmMgPSB0cnVlO1xuXG4gICAgdmFyIGZvcmNlUmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjb250ZXh0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgY29udGV4dHNbaV0uJGZvcmNlVXBkYXRlKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciByZXNvbHZlID0gb25jZShmdW5jdGlvbiAocmVzKSB7XG4gICAgICAvLyBjYWNoZSByZXNvbHZlZFxuICAgICAgZmFjdG9yeS5yZXNvbHZlZCA9IGVuc3VyZUN0b3IocmVzLCBiYXNlQ3Rvcik7XG4gICAgICAvLyBpbnZva2UgY2FsbGJhY2tzIG9ubHkgaWYgdGhpcyBpcyBub3QgYSBzeW5jaHJvbm91cyByZXNvbHZlXG4gICAgICAvLyAoYXN5bmMgcmVzb2x2ZXMgYXJlIHNoaW1tZWQgYXMgc3luY2hyb25vdXMgZHVyaW5nIFNTUilcbiAgICAgIGlmICghc3luYykge1xuICAgICAgICBmb3JjZVJlbmRlcigpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIHJlamVjdCA9IG9uY2UoZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICBcIkZhaWxlZCB0byByZXNvbHZlIGFzeW5jIGNvbXBvbmVudDogXCIgKyAoU3RyaW5nKGZhY3RvcnkpKSArXG4gICAgICAgIChyZWFzb24gPyAoXCJcXG5SZWFzb246IFwiICsgcmVhc29uKSA6ICcnKVxuICAgICAgKTtcbiAgICAgIGlmIChpc0RlZihmYWN0b3J5LmVycm9yQ29tcCkpIHtcbiAgICAgICAgZmFjdG9yeS5lcnJvciA9IHRydWU7XG4gICAgICAgIGZvcmNlUmVuZGVyKCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgcmVzID0gZmFjdG9yeShyZXNvbHZlLCByZWplY3QpO1xuXG4gICAgaWYgKGlzT2JqZWN0KHJlcykpIHtcbiAgICAgIGlmICh0eXBlb2YgcmVzLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gKCkgPT4gUHJvbWlzZVxuICAgICAgICBpZiAoaXNVbmRlZihmYWN0b3J5LnJlc29sdmVkKSkge1xuICAgICAgICAgIHJlcy50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYocmVzLmNvbXBvbmVudCkgJiYgdHlwZW9mIHJlcy5jb21wb25lbnQudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXMuY29tcG9uZW50LnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcblxuICAgICAgICBpZiAoaXNEZWYocmVzLmVycm9yKSkge1xuICAgICAgICAgIGZhY3RvcnkuZXJyb3JDb21wID0gZW5zdXJlQ3RvcihyZXMuZXJyb3IsIGJhc2VDdG9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0RlZihyZXMubG9hZGluZykpIHtcbiAgICAgICAgICBmYWN0b3J5LmxvYWRpbmdDb21wID0gZW5zdXJlQ3RvcihyZXMubG9hZGluZywgYmFzZUN0b3IpO1xuICAgICAgICAgIGlmIChyZXMuZGVsYXkgPT09IDApIHtcbiAgICAgICAgICAgIGZhY3RvcnkubG9hZGluZyA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBpZiAoaXNVbmRlZihmYWN0b3J5LnJlc29sdmVkKSAmJiBpc1VuZGVmKGZhY3RvcnkuZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgZmFjdG9yeS5sb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBmb3JjZVJlbmRlcigpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCByZXMuZGVsYXkgfHwgMjAwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNEZWYocmVzLnRpbWVvdXQpKSB7XG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoaXNVbmRlZihmYWN0b3J5LnJlc29sdmVkKSkge1xuICAgICAgICAgICAgICByZWplY3QoXG4gICAgICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJ1xuICAgICAgICAgICAgICAgICAgPyAoXCJ0aW1lb3V0IChcIiArIChyZXMudGltZW91dCkgKyBcIm1zKVwiKVxuICAgICAgICAgICAgICAgICAgOiBudWxsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgcmVzLnRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3luYyA9IGZhbHNlO1xuICAgIC8vIHJldHVybiBpbiBjYXNlIHJlc29sdmVkIHN5bmNocm9ub3VzbHlcbiAgICByZXR1cm4gZmFjdG9yeS5sb2FkaW5nXG4gICAgICA/IGZhY3RvcnkubG9hZGluZ0NvbXBcbiAgICAgIDogZmFjdG9yeS5yZXNvbHZlZFxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpc0FzeW5jUGxhY2Vob2xkZXIgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUuaXNDb21tZW50ICYmIG5vZGUuYXN5bmNGYWN0b3J5XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBnZXRGaXJzdENvbXBvbmVudENoaWxkIChjaGlsZHJlbikge1xuICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYyA9IGNoaWxkcmVuW2ldO1xuICAgICAgaWYgKGlzRGVmKGMpICYmIChpc0RlZihjLmNvbXBvbmVudE9wdGlvbnMpIHx8IGlzQXN5bmNQbGFjZWhvbGRlcihjKSkpIHtcbiAgICAgICAgcmV0dXJuIGNcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0RXZlbnRzICh2bSkge1xuICB2bS5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdm0uX2hhc0hvb2tFdmVudCA9IGZhbHNlO1xuICAvLyBpbml0IHBhcmVudCBhdHRhY2hlZCBldmVudHNcbiAgdmFyIGxpc3RlbmVycyA9IHZtLiRvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnM7XG4gIGlmIChsaXN0ZW5lcnMpIHtcbiAgICB1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnModm0sIGxpc3RlbmVycyk7XG4gIH1cbn1cblxudmFyIHRhcmdldDtcblxuZnVuY3Rpb24gYWRkIChldmVudCwgZm4sIG9uY2UpIHtcbiAgaWYgKG9uY2UpIHtcbiAgICB0YXJnZXQuJG9uY2UoZXZlbnQsIGZuKTtcbiAgfSBlbHNlIHtcbiAgICB0YXJnZXQuJG9uKGV2ZW50LCBmbik7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlJDEgKGV2ZW50LCBmbikge1xuICB0YXJnZXQuJG9mZihldmVudCwgZm4pO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnMgKFxuICB2bSxcbiAgbGlzdGVuZXJzLFxuICBvbGRMaXN0ZW5lcnNcbikge1xuICB0YXJnZXQgPSB2bTtcbiAgdXBkYXRlTGlzdGVuZXJzKGxpc3RlbmVycywgb2xkTGlzdGVuZXJzIHx8IHt9LCBhZGQsIHJlbW92ZSQxLCB2bSk7XG4gIHRhcmdldCA9IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gZXZlbnRzTWl4aW4gKFZ1ZSkge1xuICB2YXIgaG9va1JFID0gL15ob29rOi87XG4gIFZ1ZS5wcm90b3R5cGUuJG9uID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShldmVudCkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gZXZlbnQubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHRoaXMkMS4kb24oZXZlbnRbaV0sIGZuKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgKHZtLl9ldmVudHNbZXZlbnRdIHx8ICh2bS5fZXZlbnRzW2V2ZW50XSA9IFtdKSkucHVzaChmbik7XG4gICAgICAvLyBvcHRpbWl6ZSBob29rOmV2ZW50IGNvc3QgYnkgdXNpbmcgYSBib29sZWFuIGZsYWcgbWFya2VkIGF0IHJlZ2lzdHJhdGlvblxuICAgICAgLy8gaW5zdGVhZCBvZiBhIGhhc2ggbG9va3VwXG4gICAgICBpZiAoaG9va1JFLnRlc3QoZXZlbnQpKSB7XG4gICAgICAgIHZtLl9oYXNIb29rRXZlbnQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdm1cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRvbmNlID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgZnVuY3Rpb24gb24gKCkge1xuICAgICAgdm0uJG9mZihldmVudCwgb24pO1xuICAgICAgZm4uYXBwbHkodm0sIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIG9uLmZuID0gZm47XG4gICAgdm0uJG9uKGV2ZW50LCBvbik7XG4gICAgcmV0dXJuIHZtXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kb2ZmID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHZtID0gdGhpcztcbiAgICAvLyBhbGxcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHZtLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgcmV0dXJuIHZtXG4gICAgfVxuICAgIC8vIGFycmF5IG9mIGV2ZW50c1xuICAgIGlmIChBcnJheS5pc0FycmF5KGV2ZW50KSkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBldmVudC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdGhpcyQxLiRvZmYoZXZlbnRbaV0sIGZuKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2bVxuICAgIH1cbiAgICAvLyBzcGVjaWZpYyBldmVudFxuICAgIHZhciBjYnMgPSB2bS5fZXZlbnRzW2V2ZW50XTtcbiAgICBpZiAoIWNicykge1xuICAgICAgcmV0dXJuIHZtXG4gICAgfVxuICAgIGlmICghZm4pIHtcbiAgICAgIHZtLl9ldmVudHNbZXZlbnRdID0gbnVsbDtcbiAgICAgIHJldHVybiB2bVxuICAgIH1cbiAgICBpZiAoZm4pIHtcbiAgICAgIC8vIHNwZWNpZmljIGhhbmRsZXJcbiAgICAgIHZhciBjYjtcbiAgICAgIHZhciBpJDEgPSBjYnMubGVuZ3RoO1xuICAgICAgd2hpbGUgKGkkMS0tKSB7XG4gICAgICAgIGNiID0gY2JzW2kkMV07XG4gICAgICAgIGlmIChjYiA9PT0gZm4gfHwgY2IuZm4gPT09IGZuKSB7XG4gICAgICAgICAgY2JzLnNwbGljZShpJDEsIDEpO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZtXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kZW1pdCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBsb3dlckNhc2VFdmVudCA9IGV2ZW50LnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZiAobG93ZXJDYXNlRXZlbnQgIT09IGV2ZW50ICYmIHZtLl9ldmVudHNbbG93ZXJDYXNlRXZlbnRdKSB7XG4gICAgICAgIHRpcChcbiAgICAgICAgICBcIkV2ZW50IFxcXCJcIiArIGxvd2VyQ2FzZUV2ZW50ICsgXCJcXFwiIGlzIGVtaXR0ZWQgaW4gY29tcG9uZW50IFwiICtcbiAgICAgICAgICAoZm9ybWF0Q29tcG9uZW50TmFtZSh2bSkpICsgXCIgYnV0IHRoZSBoYW5kbGVyIGlzIHJlZ2lzdGVyZWQgZm9yIFxcXCJcIiArIGV2ZW50ICsgXCJcXFwiLiBcIiArXG4gICAgICAgICAgXCJOb3RlIHRoYXQgSFRNTCBhdHRyaWJ1dGVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlIGFuZCB5b3UgY2Fubm90IHVzZSBcIiArXG4gICAgICAgICAgXCJ2LW9uIHRvIGxpc3RlbiB0byBjYW1lbENhc2UgZXZlbnRzIHdoZW4gdXNpbmcgaW4tRE9NIHRlbXBsYXRlcy4gXCIgK1xuICAgICAgICAgIFwiWW91IHNob3VsZCBwcm9iYWJseSB1c2UgXFxcIlwiICsgKGh5cGhlbmF0ZShldmVudCkpICsgXCJcXFwiIGluc3RlYWQgb2YgXFxcIlwiICsgZXZlbnQgKyBcIlxcXCIuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGNicyA9IHZtLl9ldmVudHNbZXZlbnRdO1xuICAgIGlmIChjYnMpIHtcbiAgICAgIGNicyA9IGNicy5sZW5ndGggPiAxID8gdG9BcnJheShjYnMpIDogY2JzO1xuICAgICAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cywgMSk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNicy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjYnNbaV0uYXBwbHkodm0sIGFyZ3MpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIChcImV2ZW50IGhhbmRsZXIgZm9yIFxcXCJcIiArIGV2ZW50ICsgXCJcXFwiXCIpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdm1cbiAgfTtcbn1cblxuLyogICovXG5cblxuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZXNvbHZpbmcgcmF3IGNoaWxkcmVuIFZOb2RlcyBpbnRvIGEgc2xvdCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVTbG90cyAoXG4gIGNoaWxkcmVuLFxuICBjb250ZXh0XG4pIHtcbiAgdmFyIHNsb3RzID0ge307XG4gIGlmICghY2hpbGRyZW4pIHtcbiAgICByZXR1cm4gc2xvdHNcbiAgfVxuICBmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgIHZhciBkYXRhID0gY2hpbGQuZGF0YTtcbiAgICAvLyByZW1vdmUgc2xvdCBhdHRyaWJ1dGUgaWYgdGhlIG5vZGUgaXMgcmVzb2x2ZWQgYXMgYSBWdWUgc2xvdCBub2RlXG4gICAgaWYgKGRhdGEgJiYgZGF0YS5hdHRycyAmJiBkYXRhLmF0dHJzLnNsb3QpIHtcbiAgICAgIGRlbGV0ZSBkYXRhLmF0dHJzLnNsb3Q7XG4gICAgfVxuICAgIC8vIG5hbWVkIHNsb3RzIHNob3VsZCBvbmx5IGJlIHJlc3BlY3RlZCBpZiB0aGUgdm5vZGUgd2FzIHJlbmRlcmVkIGluIHRoZVxuICAgIC8vIHNhbWUgY29udGV4dC5cbiAgICBpZiAoKGNoaWxkLmNvbnRleHQgPT09IGNvbnRleHQgfHwgY2hpbGQuZm5Db250ZXh0ID09PSBjb250ZXh0KSAmJlxuICAgICAgZGF0YSAmJiBkYXRhLnNsb3QgIT0gbnVsbFxuICAgICkge1xuICAgICAgdmFyIG5hbWUgPSBkYXRhLnNsb3Q7XG4gICAgICB2YXIgc2xvdCA9IChzbG90c1tuYW1lXSB8fCAoc2xvdHNbbmFtZV0gPSBbXSkpO1xuICAgICAgaWYgKGNoaWxkLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xuICAgICAgICBzbG90LnB1c2guYXBwbHkoc2xvdCwgY2hpbGQuY2hpbGRyZW4gfHwgW10pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2xvdC5wdXNoKGNoaWxkKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgKHNsb3RzLmRlZmF1bHQgfHwgKHNsb3RzLmRlZmF1bHQgPSBbXSkpLnB1c2goY2hpbGQpO1xuICAgIH1cbiAgfVxuICAvLyBpZ25vcmUgc2xvdHMgdGhhdCBjb250YWlucyBvbmx5IHdoaXRlc3BhY2VcbiAgZm9yICh2YXIgbmFtZSQxIGluIHNsb3RzKSB7XG4gICAgaWYgKHNsb3RzW25hbWUkMV0uZXZlcnkoaXNXaGl0ZXNwYWNlKSkge1xuICAgICAgZGVsZXRlIHNsb3RzW25hbWUkMV07XG4gICAgfVxuICB9XG4gIHJldHVybiBzbG90c1xufVxuXG5mdW5jdGlvbiBpc1doaXRlc3BhY2UgKG5vZGUpIHtcbiAgcmV0dXJuIChub2RlLmlzQ29tbWVudCAmJiAhbm9kZS5hc3luY0ZhY3RvcnkpIHx8IG5vZGUudGV4dCA9PT0gJyAnXG59XG5cbmZ1bmN0aW9uIHJlc29sdmVTY29wZWRTbG90cyAoXG4gIGZucywgLy8gc2VlIGZsb3cvdm5vZGVcbiAgcmVzXG4pIHtcbiAgcmVzID0gcmVzIHx8IHt9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGZucy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGZuc1tpXSkpIHtcbiAgICAgIHJlc29sdmVTY29wZWRTbG90cyhmbnNbaV0sIHJlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc1tmbnNbaV0ua2V5XSA9IGZuc1tpXS5mbjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxudmFyIGFjdGl2ZUluc3RhbmNlID0gbnVsbDtcbnZhciBpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgPSBmYWxzZTtcblxuZnVuY3Rpb24gaW5pdExpZmVjeWNsZSAodm0pIHtcbiAgdmFyIG9wdGlvbnMgPSB2bS4kb3B0aW9ucztcblxuICAvLyBsb2NhdGUgZmlyc3Qgbm9uLWFic3RyYWN0IHBhcmVudFxuICB2YXIgcGFyZW50ID0gb3B0aW9ucy5wYXJlbnQ7XG4gIGlmIChwYXJlbnQgJiYgIW9wdGlvbnMuYWJzdHJhY3QpIHtcbiAgICB3aGlsZSAocGFyZW50LiRvcHRpb25zLmFic3RyYWN0ICYmIHBhcmVudC4kcGFyZW50KSB7XG4gICAgICBwYXJlbnQgPSBwYXJlbnQuJHBhcmVudDtcbiAgICB9XG4gICAgcGFyZW50LiRjaGlsZHJlbi5wdXNoKHZtKTtcbiAgfVxuXG4gIHZtLiRwYXJlbnQgPSBwYXJlbnQ7XG4gIHZtLiRyb290ID0gcGFyZW50ID8gcGFyZW50LiRyb290IDogdm07XG5cbiAgdm0uJGNoaWxkcmVuID0gW107XG4gIHZtLiRyZWZzID0ge307XG5cbiAgdm0uX3dhdGNoZXIgPSBudWxsO1xuICB2bS5faW5hY3RpdmUgPSBudWxsO1xuICB2bS5fZGlyZWN0SW5hY3RpdmUgPSBmYWxzZTtcbiAgdm0uX2lzTW91bnRlZCA9IGZhbHNlO1xuICB2bS5faXNEZXN0cm95ZWQgPSBmYWxzZTtcbiAgdm0uX2lzQmVpbmdEZXN0cm95ZWQgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gbGlmZWN5Y2xlTWl4aW4gKFZ1ZSkge1xuICBWdWUucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAodm5vZGUsIGh5ZHJhdGluZykge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKHZtLl9pc01vdW50ZWQpIHtcbiAgICAgIGNhbGxIb29rKHZtLCAnYmVmb3JlVXBkYXRlJyk7XG4gICAgfVxuICAgIHZhciBwcmV2RWwgPSB2bS4kZWw7XG4gICAgdmFyIHByZXZWbm9kZSA9IHZtLl92bm9kZTtcbiAgICB2YXIgcHJldkFjdGl2ZUluc3RhbmNlID0gYWN0aXZlSW5zdGFuY2U7XG4gICAgYWN0aXZlSW5zdGFuY2UgPSB2bTtcbiAgICB2bS5fdm5vZGUgPSB2bm9kZTtcbiAgICAvLyBWdWUucHJvdG90eXBlLl9fcGF0Y2hfXyBpcyBpbmplY3RlZCBpbiBlbnRyeSBwb2ludHNcbiAgICAvLyBiYXNlZCBvbiB0aGUgcmVuZGVyaW5nIGJhY2tlbmQgdXNlZC5cbiAgICBpZiAoIXByZXZWbm9kZSkge1xuICAgICAgLy8gaW5pdGlhbCByZW5kZXJcbiAgICAgIHZtLiRlbCA9IHZtLl9fcGF0Y2hfXyhcbiAgICAgICAgdm0uJGVsLCB2bm9kZSwgaHlkcmF0aW5nLCBmYWxzZSAvKiByZW1vdmVPbmx5ICovLFxuICAgICAgICB2bS4kb3B0aW9ucy5fcGFyZW50RWxtLFxuICAgICAgICB2bS4kb3B0aW9ucy5fcmVmRWxtXG4gICAgICApO1xuICAgICAgLy8gbm8gbmVlZCBmb3IgdGhlIHJlZiBub2RlcyBhZnRlciBpbml0aWFsIHBhdGNoXG4gICAgICAvLyB0aGlzIHByZXZlbnRzIGtlZXBpbmcgYSBkZXRhY2hlZCBET00gdHJlZSBpbiBtZW1vcnkgKCM1ODUxKVxuICAgICAgdm0uJG9wdGlvbnMuX3BhcmVudEVsbSA9IHZtLiRvcHRpb25zLl9yZWZFbG0gPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB1cGRhdGVzXG4gICAgICB2bS4kZWwgPSB2bS5fX3BhdGNoX18ocHJldlZub2RlLCB2bm9kZSk7XG4gICAgfVxuICAgIGFjdGl2ZUluc3RhbmNlID0gcHJldkFjdGl2ZUluc3RhbmNlO1xuICAgIC8vIHVwZGF0ZSBfX3Z1ZV9fIHJlZmVyZW5jZVxuICAgIGlmIChwcmV2RWwpIHtcbiAgICAgIHByZXZFbC5fX3Z1ZV9fID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHZtLiRlbCkge1xuICAgICAgdm0uJGVsLl9fdnVlX18gPSB2bTtcbiAgICB9XG4gICAgLy8gaWYgcGFyZW50IGlzIGFuIEhPQywgdXBkYXRlIGl0cyAkZWwgYXMgd2VsbFxuICAgIGlmICh2bS4kdm5vZGUgJiYgdm0uJHBhcmVudCAmJiB2bS4kdm5vZGUgPT09IHZtLiRwYXJlbnQuX3Zub2RlKSB7XG4gICAgICB2bS4kcGFyZW50LiRlbCA9IHZtLiRlbDtcbiAgICB9XG4gICAgLy8gdXBkYXRlZCBob29rIGlzIGNhbGxlZCBieSB0aGUgc2NoZWR1bGVyIHRvIGVuc3VyZSB0aGF0IGNoaWxkcmVuIGFyZVxuICAgIC8vIHVwZGF0ZWQgaW4gYSBwYXJlbnQncyB1cGRhdGVkIGhvb2suXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kZm9yY2VVcGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAodm0uX3dhdGNoZXIpIHtcbiAgICAgIHZtLl93YXRjaGVyLnVwZGF0ZSgpO1xuICAgIH1cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRkZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKHZtLl9pc0JlaW5nRGVzdHJveWVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgY2FsbEhvb2sodm0sICdiZWZvcmVEZXN0cm95Jyk7XG4gICAgdm0uX2lzQmVpbmdEZXN0cm95ZWQgPSB0cnVlO1xuICAgIC8vIHJlbW92ZSBzZWxmIGZyb20gcGFyZW50XG4gICAgdmFyIHBhcmVudCA9IHZtLiRwYXJlbnQ7XG4gICAgaWYgKHBhcmVudCAmJiAhcGFyZW50Ll9pc0JlaW5nRGVzdHJveWVkICYmICF2bS4kb3B0aW9ucy5hYnN0cmFjdCkge1xuICAgICAgcmVtb3ZlKHBhcmVudC4kY2hpbGRyZW4sIHZtKTtcbiAgICB9XG4gICAgLy8gdGVhcmRvd24gd2F0Y2hlcnNcbiAgICBpZiAodm0uX3dhdGNoZXIpIHtcbiAgICAgIHZtLl93YXRjaGVyLnRlYXJkb3duKCk7XG4gICAgfVxuICAgIHZhciBpID0gdm0uX3dhdGNoZXJzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB2bS5fd2F0Y2hlcnNbaV0udGVhcmRvd24oKTtcbiAgICB9XG4gICAgLy8gcmVtb3ZlIHJlZmVyZW5jZSBmcm9tIGRhdGEgb2JcbiAgICAvLyBmcm96ZW4gb2JqZWN0IG1heSBub3QgaGF2ZSBvYnNlcnZlci5cbiAgICBpZiAodm0uX2RhdGEuX19vYl9fKSB7XG4gICAgICB2bS5fZGF0YS5fX29iX18udm1Db3VudC0tO1xuICAgIH1cbiAgICAvLyBjYWxsIHRoZSBsYXN0IGhvb2suLi5cbiAgICB2bS5faXNEZXN0cm95ZWQgPSB0cnVlO1xuICAgIC8vIGludm9rZSBkZXN0cm95IGhvb2tzIG9uIGN1cnJlbnQgcmVuZGVyZWQgdHJlZVxuICAgIHZtLl9fcGF0Y2hfXyh2bS5fdm5vZGUsIG51bGwpO1xuICAgIC8vIGZpcmUgZGVzdHJveWVkIGhvb2tcbiAgICBjYWxsSG9vayh2bSwgJ2Rlc3Ryb3llZCcpO1xuICAgIC8vIHR1cm4gb2ZmIGFsbCBpbnN0YW5jZSBsaXN0ZW5lcnMuXG4gICAgdm0uJG9mZigpO1xuICAgIC8vIHJlbW92ZSBfX3Z1ZV9fIHJlZmVyZW5jZVxuICAgIGlmICh2bS4kZWwpIHtcbiAgICAgIHZtLiRlbC5fX3Z1ZV9fID0gbnVsbDtcbiAgICB9XG4gICAgLy8gcmVsZWFzZSBjaXJjdWxhciByZWZlcmVuY2UgKCM2NzU5KVxuICAgIGlmICh2bS4kdm5vZGUpIHtcbiAgICAgIHZtLiR2bm9kZS5wYXJlbnQgPSBudWxsO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gbW91bnRDb21wb25lbnQgKFxuICB2bSxcbiAgZWwsXG4gIGh5ZHJhdGluZ1xuKSB7XG4gIHZtLiRlbCA9IGVsO1xuICBpZiAoIXZtLiRvcHRpb25zLnJlbmRlcikge1xuICAgIHZtLiRvcHRpb25zLnJlbmRlciA9IGNyZWF0ZUVtcHR5Vk5vZGU7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKCh2bS4kb3B0aW9ucy50ZW1wbGF0ZSAmJiB2bS4kb3B0aW9ucy50ZW1wbGF0ZS5jaGFyQXQoMCkgIT09ICcjJykgfHxcbiAgICAgICAgdm0uJG9wdGlvbnMuZWwgfHwgZWwpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnWW91IGFyZSB1c2luZyB0aGUgcnVudGltZS1vbmx5IGJ1aWxkIG9mIFZ1ZSB3aGVyZSB0aGUgdGVtcGxhdGUgJyArXG4gICAgICAgICAgJ2NvbXBpbGVyIGlzIG5vdCBhdmFpbGFibGUuIEVpdGhlciBwcmUtY29tcGlsZSB0aGUgdGVtcGxhdGVzIGludG8gJyArXG4gICAgICAgICAgJ3JlbmRlciBmdW5jdGlvbnMsIG9yIHVzZSB0aGUgY29tcGlsZXItaW5jbHVkZWQgYnVpbGQuJyxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnRmFpbGVkIHRvIG1vdW50IGNvbXBvbmVudDogdGVtcGxhdGUgb3IgcmVuZGVyIGZ1bmN0aW9uIG5vdCBkZWZpbmVkLicsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY2FsbEhvb2sodm0sICdiZWZvcmVNb3VudCcpO1xuXG4gIHZhciB1cGRhdGVDb21wb25lbnQ7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgIHVwZGF0ZUNvbXBvbmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBuYW1lID0gdm0uX25hbWU7XG4gICAgICB2YXIgaWQgPSB2bS5fdWlkO1xuICAgICAgdmFyIHN0YXJ0VGFnID0gXCJ2dWUtcGVyZi1zdGFydDpcIiArIGlkO1xuICAgICAgdmFyIGVuZFRhZyA9IFwidnVlLXBlcmYtZW5kOlwiICsgaWQ7XG5cbiAgICAgIG1hcmsoc3RhcnRUYWcpO1xuICAgICAgdmFyIHZub2RlID0gdm0uX3JlbmRlcigpO1xuICAgICAgbWFyayhlbmRUYWcpO1xuICAgICAgbWVhc3VyZSgoXCJ2dWUgXCIgKyBuYW1lICsgXCIgcmVuZGVyXCIpLCBzdGFydFRhZywgZW5kVGFnKTtcblxuICAgICAgbWFyayhzdGFydFRhZyk7XG4gICAgICB2bS5fdXBkYXRlKHZub2RlLCBoeWRyYXRpbmcpO1xuICAgICAgbWFyayhlbmRUYWcpO1xuICAgICAgbWVhc3VyZSgoXCJ2dWUgXCIgKyBuYW1lICsgXCIgcGF0Y2hcIiksIHN0YXJ0VGFnLCBlbmRUYWcpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgdXBkYXRlQ29tcG9uZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdm0uX3VwZGF0ZSh2bS5fcmVuZGVyKCksIGh5ZHJhdGluZyk7XG4gICAgfTtcbiAgfVxuXG4gIC8vIHdlIHNldCB0aGlzIHRvIHZtLl93YXRjaGVyIGluc2lkZSB0aGUgd2F0Y2hlcidzIGNvbnN0cnVjdG9yXG4gIC8vIHNpbmNlIHRoZSB3YXRjaGVyJ3MgaW5pdGlhbCBwYXRjaCBtYXkgY2FsbCAkZm9yY2VVcGRhdGUgKGUuZy4gaW5zaWRlIGNoaWxkXG4gIC8vIGNvbXBvbmVudCdzIG1vdW50ZWQgaG9vayksIHdoaWNoIHJlbGllcyBvbiB2bS5fd2F0Y2hlciBiZWluZyBhbHJlYWR5IGRlZmluZWRcbiAgbmV3IFdhdGNoZXIodm0sIHVwZGF0ZUNvbXBvbmVudCwgbm9vcCwgbnVsbCwgdHJ1ZSAvKiBpc1JlbmRlcldhdGNoZXIgKi8pO1xuICBoeWRyYXRpbmcgPSBmYWxzZTtcblxuICAvLyBtYW51YWxseSBtb3VudGVkIGluc3RhbmNlLCBjYWxsIG1vdW50ZWQgb24gc2VsZlxuICAvLyBtb3VudGVkIGlzIGNhbGxlZCBmb3IgcmVuZGVyLWNyZWF0ZWQgY2hpbGQgY29tcG9uZW50cyBpbiBpdHMgaW5zZXJ0ZWQgaG9va1xuICBpZiAodm0uJHZub2RlID09IG51bGwpIHtcbiAgICB2bS5faXNNb3VudGVkID0gdHJ1ZTtcbiAgICBjYWxsSG9vayh2bSwgJ21vdW50ZWQnKTtcbiAgfVxuICByZXR1cm4gdm1cbn1cblxuZnVuY3Rpb24gdXBkYXRlQ2hpbGRDb21wb25lbnQgKFxuICB2bSxcbiAgcHJvcHNEYXRhLFxuICBsaXN0ZW5lcnMsXG4gIHBhcmVudFZub2RlLFxuICByZW5kZXJDaGlsZHJlblxuKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIGRldGVybWluZSB3aGV0aGVyIGNvbXBvbmVudCBoYXMgc2xvdCBjaGlsZHJlblxuICAvLyB3ZSBuZWVkIHRvIGRvIHRoaXMgYmVmb3JlIG92ZXJ3cml0aW5nICRvcHRpb25zLl9yZW5kZXJDaGlsZHJlblxuICB2YXIgaGFzQ2hpbGRyZW4gPSAhIShcbiAgICByZW5kZXJDaGlsZHJlbiB8fCAgICAgICAgICAgICAgIC8vIGhhcyBuZXcgc3RhdGljIHNsb3RzXG4gICAgdm0uJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuIHx8ICAvLyBoYXMgb2xkIHN0YXRpYyBzbG90c1xuICAgIHBhcmVudFZub2RlLmRhdGEuc2NvcGVkU2xvdHMgfHwgLy8gaGFzIG5ldyBzY29wZWQgc2xvdHNcbiAgICB2bS4kc2NvcGVkU2xvdHMgIT09IGVtcHR5T2JqZWN0IC8vIGhhcyBvbGQgc2NvcGVkIHNsb3RzXG4gICk7XG5cbiAgdm0uJG9wdGlvbnMuX3BhcmVudFZub2RlID0gcGFyZW50Vm5vZGU7XG4gIHZtLiR2bm9kZSA9IHBhcmVudFZub2RlOyAvLyB1cGRhdGUgdm0ncyBwbGFjZWhvbGRlciBub2RlIHdpdGhvdXQgcmUtcmVuZGVyXG5cbiAgaWYgKHZtLl92bm9kZSkgeyAvLyB1cGRhdGUgY2hpbGQgdHJlZSdzIHBhcmVudFxuICAgIHZtLl92bm9kZS5wYXJlbnQgPSBwYXJlbnRWbm9kZTtcbiAgfVxuICB2bS4kb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4gPSByZW5kZXJDaGlsZHJlbjtcblxuICAvLyB1cGRhdGUgJGF0dHJzIGFuZCAkbGlzdGVuZXJzIGhhc2hcbiAgLy8gdGhlc2UgYXJlIGFsc28gcmVhY3RpdmUgc28gdGhleSBtYXkgdHJpZ2dlciBjaGlsZCB1cGRhdGUgaWYgdGhlIGNoaWxkXG4gIC8vIHVzZWQgdGhlbSBkdXJpbmcgcmVuZGVyXG4gIHZtLiRhdHRycyA9IChwYXJlbnRWbm9kZS5kYXRhICYmIHBhcmVudFZub2RlLmRhdGEuYXR0cnMpIHx8IGVtcHR5T2JqZWN0O1xuICB2bS4kbGlzdGVuZXJzID0gbGlzdGVuZXJzIHx8IGVtcHR5T2JqZWN0O1xuXG4gIC8vIHVwZGF0ZSBwcm9wc1xuICBpZiAocHJvcHNEYXRhICYmIHZtLiRvcHRpb25zLnByb3BzKSB7XG4gICAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gZmFsc2U7XG4gICAgdmFyIHByb3BzID0gdm0uX3Byb3BzO1xuICAgIHZhciBwcm9wS2V5cyA9IHZtLiRvcHRpb25zLl9wcm9wS2V5cyB8fCBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0gcHJvcEtleXNbaV07XG4gICAgICBwcm9wc1trZXldID0gdmFsaWRhdGVQcm9wKGtleSwgdm0uJG9wdGlvbnMucHJvcHMsIHByb3BzRGF0YSwgdm0pO1xuICAgIH1cbiAgICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSB0cnVlO1xuICAgIC8vIGtlZXAgYSBjb3B5IG9mIHJhdyBwcm9wc0RhdGFcbiAgICB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgPSBwcm9wc0RhdGE7XG4gIH1cblxuICAvLyB1cGRhdGUgbGlzdGVuZXJzXG4gIGlmIChsaXN0ZW5lcnMpIHtcbiAgICB2YXIgb2xkTGlzdGVuZXJzID0gdm0uJG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcbiAgICB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzID0gbGlzdGVuZXJzO1xuICAgIHVwZGF0ZUNvbXBvbmVudExpc3RlbmVycyh2bSwgbGlzdGVuZXJzLCBvbGRMaXN0ZW5lcnMpO1xuICB9XG4gIC8vIHJlc29sdmUgc2xvdHMgKyBmb3JjZSB1cGRhdGUgaWYgaGFzIGNoaWxkcmVuXG4gIGlmIChoYXNDaGlsZHJlbikge1xuICAgIHZtLiRzbG90cyA9IHJlc29sdmVTbG90cyhyZW5kZXJDaGlsZHJlbiwgcGFyZW50Vm5vZGUuY29udGV4dCk7XG4gICAgdm0uJGZvcmNlVXBkYXRlKCk7XG4gIH1cblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCA9IGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzSW5JbmFjdGl2ZVRyZWUgKHZtKSB7XG4gIHdoaWxlICh2bSAmJiAodm0gPSB2bS4kcGFyZW50KSkge1xuICAgIGlmICh2bS5faW5hY3RpdmUpIHsgcmV0dXJuIHRydWUgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50ICh2bSwgZGlyZWN0KSB7XG4gIGlmIChkaXJlY3QpIHtcbiAgICB2bS5fZGlyZWN0SW5hY3RpdmUgPSBmYWxzZTtcbiAgICBpZiAoaXNJbkluYWN0aXZlVHJlZSh2bSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgfSBlbHNlIGlmICh2bS5fZGlyZWN0SW5hY3RpdmUpIHtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAodm0uX2luYWN0aXZlIHx8IHZtLl9pbmFjdGl2ZSA9PT0gbnVsbCkge1xuICAgIHZtLl9pbmFjdGl2ZSA9IGZhbHNlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdm0uJGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHZtLiRjaGlsZHJlbltpXSk7XG4gICAgfVxuICAgIGNhbGxIb29rKHZtLCAnYWN0aXZhdGVkJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50ICh2bSwgZGlyZWN0KSB7XG4gIGlmIChkaXJlY3QpIHtcbiAgICB2bS5fZGlyZWN0SW5hY3RpdmUgPSB0cnVlO1xuICAgIGlmIChpc0luSW5hY3RpdmVUcmVlKHZtKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICB9XG4gIGlmICghdm0uX2luYWN0aXZlKSB7XG4gICAgdm0uX2luYWN0aXZlID0gdHJ1ZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZtLiRjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHZtLiRjaGlsZHJlbltpXSk7XG4gICAgfVxuICAgIGNhbGxIb29rKHZtLCAnZGVhY3RpdmF0ZWQnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYWxsSG9vayAodm0sIGhvb2spIHtcbiAgdmFyIGhhbmRsZXJzID0gdm0uJG9wdGlvbnNbaG9va107XG4gIGlmIChoYW5kbGVycykge1xuICAgIGZvciAodmFyIGkgPSAwLCBqID0gaGFuZGxlcnMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgICB0cnkge1xuICAgICAgICBoYW5kbGVyc1tpXS5jYWxsKHZtKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIChob29rICsgXCIgaG9va1wiKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICh2bS5faGFzSG9va0V2ZW50KSB7XG4gICAgdm0uJGVtaXQoJ2hvb2s6JyArIGhvb2spO1xuICB9XG59XG5cbi8qICAqL1xuXG5cbnZhciBNQVhfVVBEQVRFX0NPVU5UID0gMTAwO1xuXG52YXIgcXVldWUgPSBbXTtcbnZhciBhY3RpdmF0ZWRDaGlsZHJlbiA9IFtdO1xudmFyIGhhcyA9IHt9O1xudmFyIGNpcmN1bGFyID0ge307XG52YXIgd2FpdGluZyA9IGZhbHNlO1xudmFyIGZsdXNoaW5nID0gZmFsc2U7XG52YXIgaW5kZXggPSAwO1xuXG4vKipcbiAqIFJlc2V0IHRoZSBzY2hlZHVsZXIncyBzdGF0ZS5cbiAqL1xuZnVuY3Rpb24gcmVzZXRTY2hlZHVsZXJTdGF0ZSAoKSB7XG4gIGluZGV4ID0gcXVldWUubGVuZ3RoID0gYWN0aXZhdGVkQ2hpbGRyZW4ubGVuZ3RoID0gMDtcbiAgaGFzID0ge307XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgY2lyY3VsYXIgPSB7fTtcbiAgfVxuICB3YWl0aW5nID0gZmx1c2hpbmcgPSBmYWxzZTtcbn1cblxuLyoqXG4gKiBGbHVzaCBib3RoIHF1ZXVlcyBhbmQgcnVuIHRoZSB3YXRjaGVycy5cbiAqL1xuZnVuY3Rpb24gZmx1c2hTY2hlZHVsZXJRdWV1ZSAoKSB7XG4gIGZsdXNoaW5nID0gdHJ1ZTtcbiAgdmFyIHdhdGNoZXIsIGlkO1xuXG4gIC8vIFNvcnQgcXVldWUgYmVmb3JlIGZsdXNoLlxuICAvLyBUaGlzIGVuc3VyZXMgdGhhdDpcbiAgLy8gMS4gQ29tcG9uZW50cyBhcmUgdXBkYXRlZCBmcm9tIHBhcmVudCB0byBjaGlsZC4gKGJlY2F1c2UgcGFyZW50IGlzIGFsd2F5c1xuICAvLyAgICBjcmVhdGVkIGJlZm9yZSB0aGUgY2hpbGQpXG4gIC8vIDIuIEEgY29tcG9uZW50J3MgdXNlciB3YXRjaGVycyBhcmUgcnVuIGJlZm9yZSBpdHMgcmVuZGVyIHdhdGNoZXIgKGJlY2F1c2VcbiAgLy8gICAgdXNlciB3YXRjaGVycyBhcmUgY3JlYXRlZCBiZWZvcmUgdGhlIHJlbmRlciB3YXRjaGVyKVxuICAvLyAzLiBJZiBhIGNvbXBvbmVudCBpcyBkZXN0cm95ZWQgZHVyaW5nIGEgcGFyZW50IGNvbXBvbmVudCdzIHdhdGNoZXIgcnVuLFxuICAvLyAgICBpdHMgd2F0Y2hlcnMgY2FuIGJlIHNraXBwZWQuXG4gIHF1ZXVlLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEuaWQgLSBiLmlkOyB9KTtcblxuICAvLyBkbyBub3QgY2FjaGUgbGVuZ3RoIGJlY2F1c2UgbW9yZSB3YXRjaGVycyBtaWdodCBiZSBwdXNoZWRcbiAgLy8gYXMgd2UgcnVuIGV4aXN0aW5nIHdhdGNoZXJzXG4gIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IHF1ZXVlLmxlbmd0aDsgaW5kZXgrKykge1xuICAgIHdhdGNoZXIgPSBxdWV1ZVtpbmRleF07XG4gICAgaWQgPSB3YXRjaGVyLmlkO1xuICAgIGhhc1tpZF0gPSBudWxsO1xuICAgIHdhdGNoZXIucnVuKCk7XG4gICAgLy8gaW4gZGV2IGJ1aWxkLCBjaGVjayBhbmQgc3RvcCBjaXJjdWxhciB1cGRhdGVzLlxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGhhc1tpZF0gIT0gbnVsbCkge1xuICAgICAgY2lyY3VsYXJbaWRdID0gKGNpcmN1bGFyW2lkXSB8fCAwKSArIDE7XG4gICAgICBpZiAoY2lyY3VsYXJbaWRdID4gTUFYX1VQREFURV9DT1VOVCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdZb3UgbWF5IGhhdmUgYW4gaW5maW5pdGUgdXBkYXRlIGxvb3AgJyArIChcbiAgICAgICAgICAgIHdhdGNoZXIudXNlclxuICAgICAgICAgICAgICA/IChcImluIHdhdGNoZXIgd2l0aCBleHByZXNzaW9uIFxcXCJcIiArICh3YXRjaGVyLmV4cHJlc3Npb24pICsgXCJcXFwiXCIpXG4gICAgICAgICAgICAgIDogXCJpbiBhIGNvbXBvbmVudCByZW5kZXIgZnVuY3Rpb24uXCJcbiAgICAgICAgICApLFxuICAgICAgICAgIHdhdGNoZXIudm1cbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBrZWVwIGNvcGllcyBvZiBwb3N0IHF1ZXVlcyBiZWZvcmUgcmVzZXR0aW5nIHN0YXRlXG4gIHZhciBhY3RpdmF0ZWRRdWV1ZSA9IGFjdGl2YXRlZENoaWxkcmVuLnNsaWNlKCk7XG4gIHZhciB1cGRhdGVkUXVldWUgPSBxdWV1ZS5zbGljZSgpO1xuXG4gIHJlc2V0U2NoZWR1bGVyU3RhdGUoKTtcblxuICAvLyBjYWxsIGNvbXBvbmVudCB1cGRhdGVkIGFuZCBhY3RpdmF0ZWQgaG9va3NcbiAgY2FsbEFjdGl2YXRlZEhvb2tzKGFjdGl2YXRlZFF1ZXVlKTtcbiAgY2FsbFVwZGF0ZWRIb29rcyh1cGRhdGVkUXVldWUpO1xuXG4gIC8vIGRldnRvb2wgaG9va1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGRldnRvb2xzICYmIGNvbmZpZy5kZXZ0b29scykge1xuICAgIGRldnRvb2xzLmVtaXQoJ2ZsdXNoJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FsbFVwZGF0ZWRIb29rcyAocXVldWUpIHtcbiAgdmFyIGkgPSBxdWV1ZS5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICB2YXIgd2F0Y2hlciA9IHF1ZXVlW2ldO1xuICAgIHZhciB2bSA9IHdhdGNoZXIudm07XG4gICAgaWYgKHZtLl93YXRjaGVyID09PSB3YXRjaGVyICYmIHZtLl9pc01vdW50ZWQpIHtcbiAgICAgIGNhbGxIb29rKHZtLCAndXBkYXRlZCcpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFF1ZXVlIGEga2VwdC1hbGl2ZSBjb21wb25lbnQgdGhhdCB3YXMgYWN0aXZhdGVkIGR1cmluZyBwYXRjaC5cbiAqIFRoZSBxdWV1ZSB3aWxsIGJlIHByb2Nlc3NlZCBhZnRlciB0aGUgZW50aXJlIHRyZWUgaGFzIGJlZW4gcGF0Y2hlZC5cbiAqL1xuZnVuY3Rpb24gcXVldWVBY3RpdmF0ZWRDb21wb25lbnQgKHZtKSB7XG4gIC8vIHNldHRpbmcgX2luYWN0aXZlIHRvIGZhbHNlIGhlcmUgc28gdGhhdCBhIHJlbmRlciBmdW5jdGlvbiBjYW5cbiAgLy8gcmVseSBvbiBjaGVja2luZyB3aGV0aGVyIGl0J3MgaW4gYW4gaW5hY3RpdmUgdHJlZSAoZS5nLiByb3V0ZXItdmlldylcbiAgdm0uX2luYWN0aXZlID0gZmFsc2U7XG4gIGFjdGl2YXRlZENoaWxkcmVuLnB1c2godm0pO1xufVxuXG5mdW5jdGlvbiBjYWxsQWN0aXZhdGVkSG9va3MgKHF1ZXVlKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICBxdWV1ZVtpXS5faW5hY3RpdmUgPSB0cnVlO1xuICAgIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQocXVldWVbaV0sIHRydWUgLyogdHJ1ZSAqLyk7XG4gIH1cbn1cblxuLyoqXG4gKiBQdXNoIGEgd2F0Y2hlciBpbnRvIHRoZSB3YXRjaGVyIHF1ZXVlLlxuICogSm9icyB3aXRoIGR1cGxpY2F0ZSBJRHMgd2lsbCBiZSBza2lwcGVkIHVubGVzcyBpdCdzXG4gKiBwdXNoZWQgd2hlbiB0aGUgcXVldWUgaXMgYmVpbmcgZmx1c2hlZC5cbiAqL1xuZnVuY3Rpb24gcXVldWVXYXRjaGVyICh3YXRjaGVyKSB7XG4gIHZhciBpZCA9IHdhdGNoZXIuaWQ7XG4gIGlmIChoYXNbaWRdID09IG51bGwpIHtcbiAgICBoYXNbaWRdID0gdHJ1ZTtcbiAgICBpZiAoIWZsdXNoaW5nKSB7XG4gICAgICBxdWV1ZS5wdXNoKHdhdGNoZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpZiBhbHJlYWR5IGZsdXNoaW5nLCBzcGxpY2UgdGhlIHdhdGNoZXIgYmFzZWQgb24gaXRzIGlkXG4gICAgICAvLyBpZiBhbHJlYWR5IHBhc3QgaXRzIGlkLCBpdCB3aWxsIGJlIHJ1biBuZXh0IGltbWVkaWF0ZWx5LlxuICAgICAgdmFyIGkgPSBxdWV1ZS5sZW5ndGggLSAxO1xuICAgICAgd2hpbGUgKGkgPiBpbmRleCAmJiBxdWV1ZVtpXS5pZCA+IHdhdGNoZXIuaWQpIHtcbiAgICAgICAgaS0tO1xuICAgICAgfVxuICAgICAgcXVldWUuc3BsaWNlKGkgKyAxLCAwLCB3YXRjaGVyKTtcbiAgICB9XG4gICAgLy8gcXVldWUgdGhlIGZsdXNoXG4gICAgaWYgKCF3YWl0aW5nKSB7XG4gICAgICB3YWl0aW5nID0gdHJ1ZTtcbiAgICAgIG5leHRUaWNrKGZsdXNoU2NoZWR1bGVyUXVldWUpO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIHVpZCQyID0gMDtcblxuLyoqXG4gKiBBIHdhdGNoZXIgcGFyc2VzIGFuIGV4cHJlc3Npb24sIGNvbGxlY3RzIGRlcGVuZGVuY2llcyxcbiAqIGFuZCBmaXJlcyBjYWxsYmFjayB3aGVuIHRoZSBleHByZXNzaW9uIHZhbHVlIGNoYW5nZXMuXG4gKiBUaGlzIGlzIHVzZWQgZm9yIGJvdGggdGhlICR3YXRjaCgpIGFwaSBhbmQgZGlyZWN0aXZlcy5cbiAqL1xudmFyIFdhdGNoZXIgPSBmdW5jdGlvbiBXYXRjaGVyIChcbiAgdm0sXG4gIGV4cE9yRm4sXG4gIGNiLFxuICBvcHRpb25zLFxuICBpc1JlbmRlcldhdGNoZXJcbikge1xuICB0aGlzLnZtID0gdm07XG4gIGlmIChpc1JlbmRlcldhdGNoZXIpIHtcbiAgICB2bS5fd2F0Y2hlciA9IHRoaXM7XG4gIH1cbiAgdm0uX3dhdGNoZXJzLnB1c2godGhpcyk7XG4gIC8vIG9wdGlvbnNcbiAgaWYgKG9wdGlvbnMpIHtcbiAgICB0aGlzLmRlZXAgPSAhIW9wdGlvbnMuZGVlcDtcbiAgICB0aGlzLnVzZXIgPSAhIW9wdGlvbnMudXNlcjtcbiAgICB0aGlzLmxhenkgPSAhIW9wdGlvbnMubGF6eTtcbiAgICB0aGlzLnN5bmMgPSAhIW9wdGlvbnMuc3luYztcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmRlZXAgPSB0aGlzLnVzZXIgPSB0aGlzLmxhenkgPSB0aGlzLnN5bmMgPSBmYWxzZTtcbiAgfVxuICB0aGlzLmNiID0gY2I7XG4gIHRoaXMuaWQgPSArK3VpZCQyOyAvLyB1aWQgZm9yIGJhdGNoaW5nXG4gIHRoaXMuYWN0aXZlID0gdHJ1ZTtcbiAgdGhpcy5kaXJ0eSA9IHRoaXMubGF6eTsgLy8gZm9yIGxhenkgd2F0Y2hlcnNcbiAgdGhpcy5kZXBzID0gW107XG4gIHRoaXMubmV3RGVwcyA9IFtdO1xuICB0aGlzLmRlcElkcyA9IG5ldyBfU2V0KCk7XG4gIHRoaXMubmV3RGVwSWRzID0gbmV3IF9TZXQoKTtcbiAgdGhpcy5leHByZXNzaW9uID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJ1xuICAgID8gZXhwT3JGbi50b1N0cmluZygpXG4gICAgOiAnJztcbiAgLy8gcGFyc2UgZXhwcmVzc2lvbiBmb3IgZ2V0dGVyXG4gIGlmICh0eXBlb2YgZXhwT3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRoaXMuZ2V0dGVyID0gZXhwT3JGbjtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmdldHRlciA9IHBhcnNlUGF0aChleHBPckZuKTtcbiAgICBpZiAoIXRoaXMuZ2V0dGVyKSB7XG4gICAgICB0aGlzLmdldHRlciA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICBcIkZhaWxlZCB3YXRjaGluZyBwYXRoOiBcXFwiXCIgKyBleHBPckZuICsgXCJcXFwiIFwiICtcbiAgICAgICAgJ1dhdGNoZXIgb25seSBhY2NlcHRzIHNpbXBsZSBkb3QtZGVsaW1pdGVkIHBhdGhzLiAnICtcbiAgICAgICAgJ0ZvciBmdWxsIGNvbnRyb2wsIHVzZSBhIGZ1bmN0aW9uIGluc3RlYWQuJyxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuICB9XG4gIHRoaXMudmFsdWUgPSB0aGlzLmxhenlcbiAgICA/IHVuZGVmaW5lZFxuICAgIDogdGhpcy5nZXQoKTtcbn07XG5cbi8qKlxuICogRXZhbHVhdGUgdGhlIGdldHRlciwgYW5kIHJlLWNvbGxlY3QgZGVwZW5kZW5jaWVzLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKCkge1xuICBwdXNoVGFyZ2V0KHRoaXMpO1xuICB2YXIgdmFsdWU7XG4gIHZhciB2bSA9IHRoaXMudm07XG4gIHRyeSB7XG4gICAgdmFsdWUgPSB0aGlzLmdldHRlci5jYWxsKHZtLCB2bSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAodGhpcy51c2VyKSB7XG4gICAgICBoYW5kbGVFcnJvcihlLCB2bSwgKFwiZ2V0dGVyIGZvciB3YXRjaGVyIFxcXCJcIiArICh0aGlzLmV4cHJlc3Npb24pICsgXCJcXFwiXCIpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZVxuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICAvLyBcInRvdWNoXCIgZXZlcnkgcHJvcGVydHkgc28gdGhleSBhcmUgYWxsIHRyYWNrZWQgYXNcbiAgICAvLyBkZXBlbmRlbmNpZXMgZm9yIGRlZXAgd2F0Y2hpbmdcbiAgICBpZiAodGhpcy5kZWVwKSB7XG4gICAgICB0cmF2ZXJzZSh2YWx1ZSk7XG4gICAgfVxuICAgIHBvcFRhcmdldCgpO1xuICAgIHRoaXMuY2xlYW51cERlcHMoKTtcbiAgfVxuICByZXR1cm4gdmFsdWVcbn07XG5cbi8qKlxuICogQWRkIGEgZGVwZW5kZW5jeSB0byB0aGlzIGRpcmVjdGl2ZS5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuYWRkRGVwID0gZnVuY3Rpb24gYWRkRGVwIChkZXApIHtcbiAgdmFyIGlkID0gZGVwLmlkO1xuICBpZiAoIXRoaXMubmV3RGVwSWRzLmhhcyhpZCkpIHtcbiAgICB0aGlzLm5ld0RlcElkcy5hZGQoaWQpO1xuICAgIHRoaXMubmV3RGVwcy5wdXNoKGRlcCk7XG4gICAgaWYgKCF0aGlzLmRlcElkcy5oYXMoaWQpKSB7XG4gICAgICBkZXAuYWRkU3ViKHRoaXMpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBDbGVhbiB1cCBmb3IgZGVwZW5kZW5jeSBjb2xsZWN0aW9uLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5jbGVhbnVwRGVwcyA9IGZ1bmN0aW9uIGNsZWFudXBEZXBzICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICB2YXIgZGVwID0gdGhpcyQxLmRlcHNbaV07XG4gICAgaWYgKCF0aGlzJDEubmV3RGVwSWRzLmhhcyhkZXAuaWQpKSB7XG4gICAgICBkZXAucmVtb3ZlU3ViKHRoaXMkMSk7XG4gICAgfVxuICB9XG4gIHZhciB0bXAgPSB0aGlzLmRlcElkcztcbiAgdGhpcy5kZXBJZHMgPSB0aGlzLm5ld0RlcElkcztcbiAgdGhpcy5uZXdEZXBJZHMgPSB0bXA7XG4gIHRoaXMubmV3RGVwSWRzLmNsZWFyKCk7XG4gIHRtcCA9IHRoaXMuZGVwcztcbiAgdGhpcy5kZXBzID0gdGhpcy5uZXdEZXBzO1xuICB0aGlzLm5ld0RlcHMgPSB0bXA7XG4gIHRoaXMubmV3RGVwcy5sZW5ndGggPSAwO1xufTtcblxuLyoqXG4gKiBTdWJzY3JpYmVyIGludGVyZmFjZS5cbiAqIFdpbGwgYmUgY2FsbGVkIHdoZW4gYSBkZXBlbmRlbmN5IGNoYW5nZXMuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSAoKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmICh0aGlzLmxhenkpIHtcbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgfSBlbHNlIGlmICh0aGlzLnN5bmMpIHtcbiAgICB0aGlzLnJ1bigpO1xuICB9IGVsc2Uge1xuICAgIHF1ZXVlV2F0Y2hlcih0aGlzKTtcbiAgfVxufTtcblxuLyoqXG4gKiBTY2hlZHVsZXIgam9iIGludGVyZmFjZS5cbiAqIFdpbGwgYmUgY2FsbGVkIGJ5IHRoZSBzY2hlZHVsZXIuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uIHJ1biAoKSB7XG4gIGlmICh0aGlzLmFjdGl2ZSkge1xuICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0KCk7XG4gICAgaWYgKFxuICAgICAgdmFsdWUgIT09IHRoaXMudmFsdWUgfHxcbiAgICAgIC8vIERlZXAgd2F0Y2hlcnMgYW5kIHdhdGNoZXJzIG9uIE9iamVjdC9BcnJheXMgc2hvdWxkIGZpcmUgZXZlblxuICAgICAgLy8gd2hlbiB0aGUgdmFsdWUgaXMgdGhlIHNhbWUsIGJlY2F1c2UgdGhlIHZhbHVlIG1heVxuICAgICAgLy8gaGF2ZSBtdXRhdGVkLlxuICAgICAgaXNPYmplY3QodmFsdWUpIHx8XG4gICAgICB0aGlzLmRlZXBcbiAgICApIHtcbiAgICAgIC8vIHNldCBuZXcgdmFsdWVcbiAgICAgIHZhciBvbGRWYWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICBpZiAodGhpcy51c2VyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhpcy5jYi5jYWxsKHRoaXMudm0sIHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBoYW5kbGVFcnJvcihlLCB0aGlzLnZtLCAoXCJjYWxsYmFjayBmb3Igd2F0Y2hlciBcXFwiXCIgKyAodGhpcy5leHByZXNzaW9uKSArIFwiXFxcIlwiKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY2IuY2FsbCh0aGlzLnZtLCB2YWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBFdmFsdWF0ZSB0aGUgdmFsdWUgb2YgdGhlIHdhdGNoZXIuXG4gKiBUaGlzIG9ubHkgZ2V0cyBjYWxsZWQgZm9yIGxhenkgd2F0Y2hlcnMuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gZXZhbHVhdGUgKCkge1xuICB0aGlzLnZhbHVlID0gdGhpcy5nZXQoKTtcbiAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiBEZXBlbmQgb24gYWxsIGRlcHMgY29sbGVjdGVkIGJ5IHRoaXMgd2F0Y2hlci5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuZGVwZW5kID0gZnVuY3Rpb24gZGVwZW5kICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICB0aGlzJDEuZGVwc1tpXS5kZXBlbmQoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZW1vdmUgc2VsZiBmcm9tIGFsbCBkZXBlbmRlbmNpZXMnIHN1YnNjcmliZXIgbGlzdC5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUudGVhcmRvd24gPSBmdW5jdGlvbiB0ZWFyZG93biAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgaWYgKHRoaXMuYWN0aXZlKSB7XG4gICAgLy8gcmVtb3ZlIHNlbGYgZnJvbSB2bSdzIHdhdGNoZXIgbGlzdFxuICAgIC8vIHRoaXMgaXMgYSBzb21ld2hhdCBleHBlbnNpdmUgb3BlcmF0aW9uIHNvIHdlIHNraXAgaXRcbiAgICAvLyBpZiB0aGUgdm0gaXMgYmVpbmcgZGVzdHJveWVkLlxuICAgIGlmICghdGhpcy52bS5faXNCZWluZ0Rlc3Ryb3llZCkge1xuICAgICAgcmVtb3ZlKHRoaXMudm0uX3dhdGNoZXJzLCB0aGlzKTtcbiAgICB9XG4gICAgdmFyIGkgPSB0aGlzLmRlcHMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHRoaXMkMS5kZXBzW2ldLnJlbW92ZVN1Yih0aGlzJDEpO1xuICAgIH1cbiAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICB9XG59O1xuXG4vKiAgKi9cblxudmFyIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbiA9IHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBnZXQ6IG5vb3AsXG4gIHNldDogbm9vcFxufTtcblxuZnVuY3Rpb24gcHJveHkgKHRhcmdldCwgc291cmNlS2V5LCBrZXkpIHtcbiAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLmdldCA9IGZ1bmN0aW9uIHByb3h5R2V0dGVyICgpIHtcbiAgICByZXR1cm4gdGhpc1tzb3VyY2VLZXldW2tleV1cbiAgfTtcbiAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IGZ1bmN0aW9uIHByb3h5U2V0dGVyICh2YWwpIHtcbiAgICB0aGlzW3NvdXJjZUtleV1ba2V5XSA9IHZhbDtcbiAgfTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24pO1xufVxuXG5mdW5jdGlvbiBpbml0U3RhdGUgKHZtKSB7XG4gIHZtLl93YXRjaGVycyA9IFtdO1xuICB2YXIgb3B0cyA9IHZtLiRvcHRpb25zO1xuICBpZiAob3B0cy5wcm9wcykgeyBpbml0UHJvcHModm0sIG9wdHMucHJvcHMpOyB9XG4gIGlmIChvcHRzLm1ldGhvZHMpIHsgaW5pdE1ldGhvZHModm0sIG9wdHMubWV0aG9kcyk7IH1cbiAgaWYgKG9wdHMuZGF0YSkge1xuICAgIGluaXREYXRhKHZtKTtcbiAgfSBlbHNlIHtcbiAgICBvYnNlcnZlKHZtLl9kYXRhID0ge30sIHRydWUgLyogYXNSb290RGF0YSAqLyk7XG4gIH1cbiAgaWYgKG9wdHMuY29tcHV0ZWQpIHsgaW5pdENvbXB1dGVkKHZtLCBvcHRzLmNvbXB1dGVkKTsgfVxuICBpZiAob3B0cy53YXRjaCAmJiBvcHRzLndhdGNoICE9PSBuYXRpdmVXYXRjaCkge1xuICAgIGluaXRXYXRjaCh2bSwgb3B0cy53YXRjaCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdFByb3BzICh2bSwgcHJvcHNPcHRpb25zKSB7XG4gIHZhciBwcm9wc0RhdGEgPSB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgfHwge307XG4gIHZhciBwcm9wcyA9IHZtLl9wcm9wcyA9IHt9O1xuICAvLyBjYWNoZSBwcm9wIGtleXMgc28gdGhhdCBmdXR1cmUgcHJvcHMgdXBkYXRlcyBjYW4gaXRlcmF0ZSB1c2luZyBBcnJheVxuICAvLyBpbnN0ZWFkIG9mIGR5bmFtaWMgb2JqZWN0IGtleSBlbnVtZXJhdGlvbi5cbiAgdmFyIGtleXMgPSB2bS4kb3B0aW9ucy5fcHJvcEtleXMgPSBbXTtcbiAgdmFyIGlzUm9vdCA9ICF2bS4kcGFyZW50O1xuICAvLyByb290IGluc3RhbmNlIHByb3BzIHNob3VsZCBiZSBjb252ZXJ0ZWRcbiAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gaXNSb290O1xuICB2YXIgbG9vcCA9IGZ1bmN0aW9uICgga2V5ICkge1xuICAgIGtleXMucHVzaChrZXkpO1xuICAgIHZhciB2YWx1ZSA9IHZhbGlkYXRlUHJvcChrZXksIHByb3BzT3B0aW9ucywgcHJvcHNEYXRhLCB2bSk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIGh5cGhlbmF0ZWRLZXkgPSBoeXBoZW5hdGUoa2V5KTtcbiAgICAgIGlmIChpc1Jlc2VydmVkQXR0cmlidXRlKGh5cGhlbmF0ZWRLZXkpIHx8XG4gICAgICAgICAgY29uZmlnLmlzUmVzZXJ2ZWRBdHRyKGh5cGhlbmF0ZWRLZXkpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgKFwiXFxcIlwiICsgaHlwaGVuYXRlZEtleSArIFwiXFxcIiBpcyBhIHJlc2VydmVkIGF0dHJpYnV0ZSBhbmQgY2Fubm90IGJlIHVzZWQgYXMgY29tcG9uZW50IHByb3AuXCIpLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBkZWZpbmVSZWFjdGl2ZShwcm9wcywga2V5LCB2YWx1ZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodm0uJHBhcmVudCAmJiAhaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50KSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgIFwiQXZvaWQgbXV0YXRpbmcgYSBwcm9wIGRpcmVjdGx5IHNpbmNlIHRoZSB2YWx1ZSB3aWxsIGJlIFwiICtcbiAgICAgICAgICAgIFwib3ZlcndyaXR0ZW4gd2hlbmV2ZXIgdGhlIHBhcmVudCBjb21wb25lbnQgcmUtcmVuZGVycy4gXCIgK1xuICAgICAgICAgICAgXCJJbnN0ZWFkLCB1c2UgYSBkYXRhIG9yIGNvbXB1dGVkIHByb3BlcnR5IGJhc2VkIG9uIHRoZSBwcm9wJ3MgXCIgK1xuICAgICAgICAgICAgXCJ2YWx1ZS4gUHJvcCBiZWluZyBtdXRhdGVkOiBcXFwiXCIgKyBrZXkgKyBcIlxcXCJcIixcbiAgICAgICAgICAgIHZtXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlZmluZVJlYWN0aXZlKHByb3BzLCBrZXksIHZhbHVlKTtcbiAgICB9XG4gICAgLy8gc3RhdGljIHByb3BzIGFyZSBhbHJlYWR5IHByb3hpZWQgb24gdGhlIGNvbXBvbmVudCdzIHByb3RvdHlwZVxuICAgIC8vIGR1cmluZyBWdWUuZXh0ZW5kKCkuIFdlIG9ubHkgbmVlZCB0byBwcm94eSBwcm9wcyBkZWZpbmVkIGF0XG4gICAgLy8gaW5zdGFudGlhdGlvbiBoZXJlLlxuICAgIGlmICghKGtleSBpbiB2bSkpIHtcbiAgICAgIHByb3h5KHZtLCBcIl9wcm9wc1wiLCBrZXkpO1xuICAgIH1cbiAgfTtcblxuICBmb3IgKHZhciBrZXkgaW4gcHJvcHNPcHRpb25zKSBsb29wKCBrZXkgKTtcbiAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaW5pdERhdGEgKHZtKSB7XG4gIHZhciBkYXRhID0gdm0uJG9wdGlvbnMuZGF0YTtcbiAgZGF0YSA9IHZtLl9kYXRhID0gdHlwZW9mIGRhdGEgPT09ICdmdW5jdGlvbidcbiAgICA/IGdldERhdGEoZGF0YSwgdm0pXG4gICAgOiBkYXRhIHx8IHt9O1xuICBpZiAoIWlzUGxhaW5PYmplY3QoZGF0YSkpIHtcbiAgICBkYXRhID0ge307XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgJ2RhdGEgZnVuY3Rpb25zIHNob3VsZCByZXR1cm4gYW4gb2JqZWN0OlxcbicgK1xuICAgICAgJ2h0dHBzOi8vdnVlanMub3JnL3YyL2d1aWRlL2NvbXBvbmVudHMuaHRtbCNkYXRhLU11c3QtQmUtYS1GdW5jdGlvbicsXG4gICAgICB2bVxuICAgICk7XG4gIH1cbiAgLy8gcHJveHkgZGF0YSBvbiBpbnN0YW5jZVxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGRhdGEpO1xuICB2YXIgcHJvcHMgPSB2bS4kb3B0aW9ucy5wcm9wcztcbiAgdmFyIG1ldGhvZHMgPSB2bS4kb3B0aW9ucy5tZXRob2RzO1xuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChtZXRob2RzICYmIGhhc093bihtZXRob2RzLCBrZXkpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgKFwiTWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBoYXMgYWxyZWFkeSBiZWVuIGRlZmluZWQgYXMgYSBkYXRhIHByb3BlcnR5LlwiKSxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocHJvcHMgJiYgaGFzT3duKHByb3BzLCBrZXkpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgIFwiVGhlIGRhdGEgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIGFscmVhZHkgZGVjbGFyZWQgYXMgYSBwcm9wLiBcIiArXG4gICAgICAgIFwiVXNlIHByb3AgZGVmYXVsdCB2YWx1ZSBpbnN0ZWFkLlwiLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKCFpc1Jlc2VydmVkKGtleSkpIHtcbiAgICAgIHByb3h5KHZtLCBcIl9kYXRhXCIsIGtleSk7XG4gICAgfVxuICB9XG4gIC8vIG9ic2VydmUgZGF0YVxuICBvYnNlcnZlKGRhdGEsIHRydWUgLyogYXNSb290RGF0YSAqLyk7XG59XG5cbmZ1bmN0aW9uIGdldERhdGEgKGRhdGEsIHZtKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGRhdGEuY2FsbCh2bSwgdm0pXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBoYW5kbGVFcnJvcihlLCB2bSwgXCJkYXRhKClcIik7XG4gICAgcmV0dXJuIHt9XG4gIH1cbn1cblxudmFyIGNvbXB1dGVkV2F0Y2hlck9wdGlvbnMgPSB7IGxhenk6IHRydWUgfTtcblxuZnVuY3Rpb24gaW5pdENvbXB1dGVkICh2bSwgY29tcHV0ZWQpIHtcbiAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gIHZhciB3YXRjaGVycyA9IHZtLl9jb21wdXRlZFdhdGNoZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgLy8gY29tcHV0ZWQgcHJvcGVydGllcyBhcmUganVzdCBnZXR0ZXJzIGR1cmluZyBTU1JcbiAgdmFyIGlzU1NSID0gaXNTZXJ2ZXJSZW5kZXJpbmcoKTtcblxuICBmb3IgKHZhciBrZXkgaW4gY29tcHV0ZWQpIHtcbiAgICB2YXIgdXNlckRlZiA9IGNvbXB1dGVkW2tleV07XG4gICAgdmFyIGdldHRlciA9IHR5cGVvZiB1c2VyRGVmID09PSAnZnVuY3Rpb24nID8gdXNlckRlZiA6IHVzZXJEZWYuZ2V0O1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGdldHRlciA9PSBudWxsKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAoXCJHZXR0ZXIgaXMgbWlzc2luZyBmb3IgY29tcHV0ZWQgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiLlwiKSxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKCFpc1NTUikge1xuICAgICAgLy8gY3JlYXRlIGludGVybmFsIHdhdGNoZXIgZm9yIHRoZSBjb21wdXRlZCBwcm9wZXJ0eS5cbiAgICAgIHdhdGNoZXJzW2tleV0gPSBuZXcgV2F0Y2hlcihcbiAgICAgICAgdm0sXG4gICAgICAgIGdldHRlciB8fCBub29wLFxuICAgICAgICBub29wLFxuICAgICAgICBjb21wdXRlZFdhdGNoZXJPcHRpb25zXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIGNvbXBvbmVudC1kZWZpbmVkIGNvbXB1dGVkIHByb3BlcnRpZXMgYXJlIGFscmVhZHkgZGVmaW5lZCBvbiB0aGVcbiAgICAvLyBjb21wb25lbnQgcHJvdG90eXBlLiBXZSBvbmx5IG5lZWQgdG8gZGVmaW5lIGNvbXB1dGVkIHByb3BlcnRpZXMgZGVmaW5lZFxuICAgIC8vIGF0IGluc3RhbnRpYXRpb24gaGVyZS5cbiAgICBpZiAoIShrZXkgaW4gdm0pKSB7XG4gICAgICBkZWZpbmVDb21wdXRlZCh2bSwga2V5LCB1c2VyRGVmKTtcbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChrZXkgaW4gdm0uJGRhdGEpIHtcbiAgICAgICAgd2FybigoXCJUaGUgY29tcHV0ZWQgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIGFscmVhZHkgZGVmaW5lZCBpbiBkYXRhLlwiKSwgdm0pO1xuICAgICAgfSBlbHNlIGlmICh2bS4kb3B0aW9ucy5wcm9wcyAmJiBrZXkgaW4gdm0uJG9wdGlvbnMucHJvcHMpIHtcbiAgICAgICAgd2FybigoXCJUaGUgY29tcHV0ZWQgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIGFscmVhZHkgZGVmaW5lZCBhcyBhIHByb3AuXCIpLCB2bSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZUNvbXB1dGVkIChcbiAgdGFyZ2V0LFxuICBrZXksXG4gIHVzZXJEZWZcbikge1xuICB2YXIgc2hvdWxkQ2FjaGUgPSAhaXNTZXJ2ZXJSZW5kZXJpbmcoKTtcbiAgaWYgKHR5cGVvZiB1c2VyRGVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLmdldCA9IHNob3VsZENhY2hlXG4gICAgICA/IGNyZWF0ZUNvbXB1dGVkR2V0dGVyKGtleSlcbiAgICAgIDogdXNlckRlZjtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gbm9vcDtcbiAgfSBlbHNlIHtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uZ2V0ID0gdXNlckRlZi5nZXRcbiAgICAgID8gc2hvdWxkQ2FjaGUgJiYgdXNlckRlZi5jYWNoZSAhPT0gZmFsc2VcbiAgICAgICAgPyBjcmVhdGVDb21wdXRlZEdldHRlcihrZXkpXG4gICAgICAgIDogdXNlckRlZi5nZXRcbiAgICAgIDogbm9vcDtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gdXNlckRlZi5zZXRcbiAgICAgID8gdXNlckRlZi5zZXRcbiAgICAgIDogbm9vcDtcbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9PT0gbm9vcCkge1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAoXCJDb21wdXRlZCBwcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgd2FzIGFzc2lnbmVkIHRvIGJ1dCBpdCBoYXMgbm8gc2V0dGVyLlwiKSxcbiAgICAgICAgdGhpc1xuICAgICAgKTtcbiAgICB9O1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tcHV0ZWRHZXR0ZXIgKGtleSkge1xuICByZXR1cm4gZnVuY3Rpb24gY29tcHV0ZWRHZXR0ZXIgKCkge1xuICAgIHZhciB3YXRjaGVyID0gdGhpcy5fY29tcHV0ZWRXYXRjaGVycyAmJiB0aGlzLl9jb21wdXRlZFdhdGNoZXJzW2tleV07XG4gICAgaWYgKHdhdGNoZXIpIHtcbiAgICAgIGlmICh3YXRjaGVyLmRpcnR5KSB7XG4gICAgICAgIHdhdGNoZXIuZXZhbHVhdGUoKTtcbiAgICAgIH1cbiAgICAgIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgICAgIHdhdGNoZXIuZGVwZW5kKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gd2F0Y2hlci52YWx1ZVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0TWV0aG9kcyAodm0sIG1ldGhvZHMpIHtcbiAgdmFyIHByb3BzID0gdm0uJG9wdGlvbnMucHJvcHM7XG4gIGZvciAodmFyIGtleSBpbiBtZXRob2RzKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChtZXRob2RzW2tleV0gPT0gbnVsbCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwiTWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBoYXMgYW4gdW5kZWZpbmVkIHZhbHVlIGluIHRoZSBjb21wb25lbnQgZGVmaW5pdGlvbi4gXCIgK1xuICAgICAgICAgIFwiRGlkIHlvdSByZWZlcmVuY2UgdGhlIGZ1bmN0aW9uIGNvcnJlY3RseT9cIixcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKHByb3BzICYmIGhhc093bihwcm9wcywga2V5KSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIChcIk1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaGFzIGFscmVhZHkgYmVlbiBkZWZpbmVkIGFzIGEgcHJvcC5cIiksXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmICgoa2V5IGluIHZtKSAmJiBpc1Jlc2VydmVkKGtleSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBcIk1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgY29uZmxpY3RzIHdpdGggYW4gZXhpc3RpbmcgVnVlIGluc3RhbmNlIG1ldGhvZC4gXCIgK1xuICAgICAgICAgIFwiQXZvaWQgZGVmaW5pbmcgY29tcG9uZW50IG1ldGhvZHMgdGhhdCBzdGFydCB3aXRoIF8gb3IgJC5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICB2bVtrZXldID0gbWV0aG9kc1trZXldID09IG51bGwgPyBub29wIDogYmluZChtZXRob2RzW2tleV0sIHZtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0V2F0Y2ggKHZtLCB3YXRjaCkge1xuICBmb3IgKHZhciBrZXkgaW4gd2F0Y2gpIHtcbiAgICB2YXIgaGFuZGxlciA9IHdhdGNoW2tleV07XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaGFuZGxlcikpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGFuZGxlci5sZW5ndGg7IGkrKykge1xuICAgICAgICBjcmVhdGVXYXRjaGVyKHZtLCBrZXksIGhhbmRsZXJbaV0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjcmVhdGVXYXRjaGVyKHZtLCBrZXksIGhhbmRsZXIpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVXYXRjaGVyIChcbiAgdm0sXG4gIGtleU9yRm4sXG4gIGhhbmRsZXIsXG4gIG9wdGlvbnNcbikge1xuICBpZiAoaXNQbGFpbk9iamVjdChoYW5kbGVyKSkge1xuICAgIG9wdGlvbnMgPSBoYW5kbGVyO1xuICAgIGhhbmRsZXIgPSBoYW5kbGVyLmhhbmRsZXI7XG4gIH1cbiAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnc3RyaW5nJykge1xuICAgIGhhbmRsZXIgPSB2bVtoYW5kbGVyXTtcbiAgfVxuICByZXR1cm4gdm0uJHdhdGNoKGtleU9yRm4sIGhhbmRsZXIsIG9wdGlvbnMpXG59XG5cbmZ1bmN0aW9uIHN0YXRlTWl4aW4gKFZ1ZSkge1xuICAvLyBmbG93IHNvbWVob3cgaGFzIHByb2JsZW1zIHdpdGggZGlyZWN0bHkgZGVjbGFyZWQgZGVmaW5pdGlvbiBvYmplY3RcbiAgLy8gd2hlbiB1c2luZyBPYmplY3QuZGVmaW5lUHJvcGVydHksIHNvIHdlIGhhdmUgdG8gcHJvY2VkdXJhbGx5IGJ1aWxkIHVwXG4gIC8vIHRoZSBvYmplY3QgaGVyZS5cbiAgdmFyIGRhdGFEZWYgPSB7fTtcbiAgZGF0YURlZi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kYXRhIH07XG4gIHZhciBwcm9wc0RlZiA9IHt9O1xuICBwcm9wc0RlZi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9wcm9wcyB9O1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGRhdGFEZWYuc2V0ID0gZnVuY3Rpb24gKG5ld0RhdGEpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdBdm9pZCByZXBsYWNpbmcgaW5zdGFuY2Ugcm9vdCAkZGF0YS4gJyArXG4gICAgICAgICdVc2UgbmVzdGVkIGRhdGEgcHJvcGVydGllcyBpbnN0ZWFkLicsXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgfTtcbiAgICBwcm9wc0RlZi5zZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB3YXJuKFwiJHByb3BzIGlzIHJlYWRvbmx5LlwiLCB0aGlzKTtcbiAgICB9O1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJGRhdGEnLCBkYXRhRGVmKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckcHJvcHMnLCBwcm9wc0RlZik7XG5cbiAgVnVlLnByb3RvdHlwZS4kc2V0ID0gc2V0O1xuICBWdWUucHJvdG90eXBlLiRkZWxldGUgPSBkZWw7XG5cbiAgVnVlLnByb3RvdHlwZS4kd2F0Y2ggPSBmdW5jdGlvbiAoXG4gICAgZXhwT3JGbixcbiAgICBjYixcbiAgICBvcHRpb25zXG4gICkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKGlzUGxhaW5PYmplY3QoY2IpKSB7XG4gICAgICByZXR1cm4gY3JlYXRlV2F0Y2hlcih2bSwgZXhwT3JGbiwgY2IsIG9wdGlvbnMpXG4gICAgfVxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIG9wdGlvbnMudXNlciA9IHRydWU7XG4gICAgdmFyIHdhdGNoZXIgPSBuZXcgV2F0Y2hlcih2bSwgZXhwT3JGbiwgY2IsIG9wdGlvbnMpO1xuICAgIGlmIChvcHRpb25zLmltbWVkaWF0ZSkge1xuICAgICAgY2IuY2FsbCh2bSwgd2F0Y2hlci52YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiB1bndhdGNoRm4gKCkge1xuICAgICAgd2F0Y2hlci50ZWFyZG93bigpO1xuICAgIH1cbiAgfTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRQcm92aWRlICh2bSkge1xuICB2YXIgcHJvdmlkZSA9IHZtLiRvcHRpb25zLnByb3ZpZGU7XG4gIGlmIChwcm92aWRlKSB7XG4gICAgdm0uX3Byb3ZpZGVkID0gdHlwZW9mIHByb3ZpZGUgPT09ICdmdW5jdGlvbidcbiAgICAgID8gcHJvdmlkZS5jYWxsKHZtKVxuICAgICAgOiBwcm92aWRlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRJbmplY3Rpb25zICh2bSkge1xuICB2YXIgcmVzdWx0ID0gcmVzb2x2ZUluamVjdCh2bS4kb3B0aW9ucy5pbmplY3QsIHZtKTtcbiAgaWYgKHJlc3VsdCkge1xuICAgIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCA9IGZhbHNlO1xuICAgIE9iamVjdC5rZXlzKHJlc3VsdCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgZGVmaW5lUmVhY3RpdmUodm0sIGtleSwgcmVzdWx0W2tleV0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgXCJBdm9pZCBtdXRhdGluZyBhbiBpbmplY3RlZCB2YWx1ZSBkaXJlY3RseSBzaW5jZSB0aGUgY2hhbmdlcyB3aWxsIGJlIFwiICtcbiAgICAgICAgICAgIFwib3ZlcndyaXR0ZW4gd2hlbmV2ZXIgdGhlIHByb3ZpZGVkIGNvbXBvbmVudCByZS1yZW5kZXJzLiBcIiArXG4gICAgICAgICAgICBcImluamVjdGlvbiBiZWluZyBtdXRhdGVkOiBcXFwiXCIgKyBrZXkgKyBcIlxcXCJcIixcbiAgICAgICAgICAgIHZtXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWZpbmVSZWFjdGl2ZSh2bSwga2V5LCByZXN1bHRba2V5XSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXNvbHZlSW5qZWN0IChpbmplY3QsIHZtKSB7XG4gIGlmIChpbmplY3QpIHtcbiAgICAvLyBpbmplY3QgaXMgOmFueSBiZWNhdXNlIGZsb3cgaXMgbm90IHNtYXJ0IGVub3VnaCB0byBmaWd1cmUgb3V0IGNhY2hlZFxuICAgIHZhciByZXN1bHQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHZhciBrZXlzID0gaGFzU3ltYm9sXG4gICAgICA/IFJlZmxlY3Qub3duS2V5cyhpbmplY3QpLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGluamVjdCwga2V5KS5lbnVtZXJhYmxlXG4gICAgICB9KVxuICAgICAgOiBPYmplY3Qua2V5cyhpbmplY3QpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgIHZhciBwcm92aWRlS2V5ID0gaW5qZWN0W2tleV0uZnJvbTtcbiAgICAgIHZhciBzb3VyY2UgPSB2bTtcbiAgICAgIHdoaWxlIChzb3VyY2UpIHtcbiAgICAgICAgaWYgKHNvdXJjZS5fcHJvdmlkZWQgJiYgcHJvdmlkZUtleSBpbiBzb3VyY2UuX3Byb3ZpZGVkKSB7XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSBzb3VyY2UuX3Byb3ZpZGVkW3Byb3ZpZGVLZXldO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgc291cmNlID0gc291cmNlLiRwYXJlbnQ7XG4gICAgICB9XG4gICAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgICBpZiAoJ2RlZmF1bHQnIGluIGluamVjdFtrZXldKSB7XG4gICAgICAgICAgdmFyIHByb3ZpZGVEZWZhdWx0ID0gaW5qZWN0W2tleV0uZGVmYXVsdDtcbiAgICAgICAgICByZXN1bHRba2V5XSA9IHR5cGVvZiBwcm92aWRlRGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgPyBwcm92aWRlRGVmYXVsdC5jYWxsKHZtKVxuICAgICAgICAgICAgOiBwcm92aWRlRGVmYXVsdDtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgd2FybigoXCJJbmplY3Rpb24gXFxcIlwiICsga2V5ICsgXCJcXFwiIG5vdCBmb3VuZFwiKSwgdm0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIHYtZm9yIGxpc3RzLlxuICovXG5mdW5jdGlvbiByZW5kZXJMaXN0IChcbiAgdmFsLFxuICByZW5kZXJcbikge1xuICB2YXIgcmV0LCBpLCBsLCBrZXlzLCBrZXk7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbCkgfHwgdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICByZXQgPSBuZXcgQXJyYXkodmFsLmxlbmd0aCk7XG4gICAgZm9yIChpID0gMCwgbCA9IHZhbC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHJldFtpXSA9IHJlbmRlcih2YWxbaV0sIGkpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHJldCA9IG5ldyBBcnJheSh2YWwpO1xuICAgIGZvciAoaSA9IDA7IGkgPCB2YWw7IGkrKykge1xuICAgICAgcmV0W2ldID0gcmVuZGVyKGkgKyAxLCBpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QodmFsKSkge1xuICAgIGtleXMgPSBPYmplY3Qua2V5cyh2YWwpO1xuICAgIHJldCA9IG5ldyBBcnJheShrZXlzLmxlbmd0aCk7XG4gICAgZm9yIChpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgcmV0W2ldID0gcmVuZGVyKHZhbFtrZXldLCBrZXksIGkpO1xuICAgIH1cbiAgfVxuICBpZiAoaXNEZWYocmV0KSkge1xuICAgIChyZXQpLl9pc1ZMaXN0ID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZW5kZXJpbmcgPHNsb3Q+XG4gKi9cbmZ1bmN0aW9uIHJlbmRlclNsb3QgKFxuICBuYW1lLFxuICBmYWxsYmFjayxcbiAgcHJvcHMsXG4gIGJpbmRPYmplY3Rcbikge1xuICB2YXIgc2NvcGVkU2xvdEZuID0gdGhpcy4kc2NvcGVkU2xvdHNbbmFtZV07XG4gIHZhciBub2RlcztcbiAgaWYgKHNjb3BlZFNsb3RGbikgeyAvLyBzY29wZWQgc2xvdFxuICAgIHByb3BzID0gcHJvcHMgfHwge307XG4gICAgaWYgKGJpbmRPYmplY3QpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICFpc09iamVjdChiaW5kT2JqZWN0KSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdzbG90IHYtYmluZCB3aXRob3V0IGFyZ3VtZW50IGV4cGVjdHMgYW4gT2JqZWN0JyxcbiAgICAgICAgICB0aGlzXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBwcm9wcyA9IGV4dGVuZChleHRlbmQoe30sIGJpbmRPYmplY3QpLCBwcm9wcyk7XG4gICAgfVxuICAgIG5vZGVzID0gc2NvcGVkU2xvdEZuKHByb3BzKSB8fCBmYWxsYmFjaztcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2xvdE5vZGVzID0gdGhpcy4kc2xvdHNbbmFtZV07XG4gICAgLy8gd2FybiBkdXBsaWNhdGUgc2xvdCB1c2FnZVxuICAgIGlmIChzbG90Tm9kZXMpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHNsb3ROb2Rlcy5fcmVuZGVyZWQpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBcIkR1cGxpY2F0ZSBwcmVzZW5jZSBvZiBzbG90IFxcXCJcIiArIG5hbWUgKyBcIlxcXCIgZm91bmQgaW4gdGhlIHNhbWUgcmVuZGVyIHRyZWUgXCIgK1xuICAgICAgICAgIFwiLSB0aGlzIHdpbGwgbGlrZWx5IGNhdXNlIHJlbmRlciBlcnJvcnMuXCIsXG4gICAgICAgICAgdGhpc1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgc2xvdE5vZGVzLl9yZW5kZXJlZCA9IHRydWU7XG4gICAgfVxuICAgIG5vZGVzID0gc2xvdE5vZGVzIHx8IGZhbGxiYWNrO1xuICB9XG5cbiAgdmFyIHRhcmdldCA9IHByb3BzICYmIHByb3BzLnNsb3Q7XG4gIGlmICh0YXJnZXQpIHtcbiAgICByZXR1cm4gdGhpcy4kY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnLCB7IHNsb3Q6IHRhcmdldCB9LCBub2RlcylcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbm9kZXNcbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVzb2x2aW5nIGZpbHRlcnNcbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZUZpbHRlciAoaWQpIHtcbiAgcmV0dXJuIHJlc29sdmVBc3NldCh0aGlzLiRvcHRpb25zLCAnZmlsdGVycycsIGlkLCB0cnVlKSB8fCBpZGVudGl0eVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgY2hlY2tpbmcga2V5Q29kZXMgZnJvbSBjb25maWcuXG4gKiBleHBvc2VkIGFzIFZ1ZS5wcm90b3R5cGUuX2tcbiAqIHBhc3NpbmcgaW4gZXZlbnRLZXlOYW1lIGFzIGxhc3QgYXJndW1lbnQgc2VwYXJhdGVseSBmb3IgYmFja3dhcmRzIGNvbXBhdFxuICovXG5mdW5jdGlvbiBjaGVja0tleUNvZGVzIChcbiAgZXZlbnRLZXlDb2RlLFxuICBrZXksXG4gIGJ1aWx0SW5BbGlhcyxcbiAgZXZlbnRLZXlOYW1lXG4pIHtcbiAgdmFyIGtleUNvZGVzID0gY29uZmlnLmtleUNvZGVzW2tleV0gfHwgYnVpbHRJbkFsaWFzO1xuICBpZiAoa2V5Q29kZXMpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShrZXlDb2RlcykpIHtcbiAgICAgIHJldHVybiBrZXlDb2Rlcy5pbmRleE9mKGV2ZW50S2V5Q29kZSkgPT09IC0xXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBrZXlDb2RlcyAhPT0gZXZlbnRLZXlDb2RlXG4gICAgfVxuICB9IGVsc2UgaWYgKGV2ZW50S2V5TmFtZSkge1xuICAgIHJldHVybiBoeXBoZW5hdGUoZXZlbnRLZXlOYW1lKSAhPT0ga2V5XG4gIH1cbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIG1lcmdpbmcgdi1iaW5kPVwib2JqZWN0XCIgaW50byBhIFZOb2RlJ3MgZGF0YS5cbiAqL1xuZnVuY3Rpb24gYmluZE9iamVjdFByb3BzIChcbiAgZGF0YSxcbiAgdGFnLFxuICB2YWx1ZSxcbiAgYXNQcm9wLFxuICBpc1N5bmNcbikge1xuICBpZiAodmFsdWUpIHtcbiAgICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICAndi1iaW5kIHdpdGhvdXQgYXJndW1lbnQgZXhwZWN0cyBhbiBPYmplY3Qgb3IgQXJyYXkgdmFsdWUnLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUgPSB0b09iamVjdCh2YWx1ZSk7XG4gICAgICB9XG4gICAgICB2YXIgaGFzaDtcbiAgICAgIHZhciBsb29wID0gZnVuY3Rpb24gKCBrZXkgKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBrZXkgPT09ICdjbGFzcycgfHxcbiAgICAgICAgICBrZXkgPT09ICdzdHlsZScgfHxcbiAgICAgICAgICBpc1Jlc2VydmVkQXR0cmlidXRlKGtleSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgaGFzaCA9IGRhdGE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHR5cGUgPSBkYXRhLmF0dHJzICYmIGRhdGEuYXR0cnMudHlwZTtcbiAgICAgICAgICBoYXNoID0gYXNQcm9wIHx8IGNvbmZpZy5tdXN0VXNlUHJvcCh0YWcsIHR5cGUsIGtleSlcbiAgICAgICAgICAgID8gZGF0YS5kb21Qcm9wcyB8fCAoZGF0YS5kb21Qcm9wcyA9IHt9KVxuICAgICAgICAgICAgOiBkYXRhLmF0dHJzIHx8IChkYXRhLmF0dHJzID0ge30pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKGtleSBpbiBoYXNoKSkge1xuICAgICAgICAgIGhhc2hba2V5XSA9IHZhbHVlW2tleV07XG5cbiAgICAgICAgICBpZiAoaXNTeW5jKSB7XG4gICAgICAgICAgICB2YXIgb24gPSBkYXRhLm9uIHx8IChkYXRhLm9uID0ge30pO1xuICAgICAgICAgICAgb25bKFwidXBkYXRlOlwiICsga2V5KV0gPSBmdW5jdGlvbiAoJGV2ZW50KSB7XG4gICAgICAgICAgICAgIHZhbHVlW2tleV0gPSAkZXZlbnQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIHZhbHVlKSBsb29wKCBrZXkgKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlbmRlcmluZyBzdGF0aWMgdHJlZXMuXG4gKi9cbmZ1bmN0aW9uIHJlbmRlclN0YXRpYyAoXG4gIGluZGV4LFxuICBpc0luRm9yXG4pIHtcbiAgdmFyIGNhY2hlZCA9IHRoaXMuX3N0YXRpY1RyZWVzIHx8ICh0aGlzLl9zdGF0aWNUcmVlcyA9IFtdKTtcbiAgdmFyIHRyZWUgPSBjYWNoZWRbaW5kZXhdO1xuICAvLyBpZiBoYXMgYWxyZWFkeS1yZW5kZXJlZCBzdGF0aWMgdHJlZSBhbmQgbm90IGluc2lkZSB2LWZvcixcbiAgLy8gd2UgY2FuIHJldXNlIHRoZSBzYW1lIHRyZWUgYnkgZG9pbmcgYSBzaGFsbG93IGNsb25lLlxuICBpZiAodHJlZSAmJiAhaXNJbkZvcikge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHRyZWUpXG4gICAgICA/IGNsb25lVk5vZGVzKHRyZWUpXG4gICAgICA6IGNsb25lVk5vZGUodHJlZSlcbiAgfVxuICAvLyBvdGhlcndpc2UsIHJlbmRlciBhIGZyZXNoIHRyZWUuXG4gIHRyZWUgPSBjYWNoZWRbaW5kZXhdID0gdGhpcy4kb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnNbaW5kZXhdLmNhbGwoXG4gICAgdGhpcy5fcmVuZGVyUHJveHksXG4gICAgbnVsbCxcbiAgICB0aGlzIC8vIGZvciByZW5kZXIgZm5zIGdlbmVyYXRlZCBmb3IgZnVuY3Rpb25hbCBjb21wb25lbnQgdGVtcGxhdGVzXG4gICk7XG4gIG1hcmtTdGF0aWModHJlZSwgKFwiX19zdGF0aWNfX1wiICsgaW5kZXgpLCBmYWxzZSk7XG4gIHJldHVybiB0cmVlXG59XG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHYtb25jZS5cbiAqIEVmZmVjdGl2ZWx5IGl0IG1lYW5zIG1hcmtpbmcgdGhlIG5vZGUgYXMgc3RhdGljIHdpdGggYSB1bmlxdWUga2V5LlxuICovXG5mdW5jdGlvbiBtYXJrT25jZSAoXG4gIHRyZWUsXG4gIGluZGV4LFxuICBrZXlcbikge1xuICBtYXJrU3RhdGljKHRyZWUsIChcIl9fb25jZV9fXCIgKyBpbmRleCArIChrZXkgPyAoXCJfXCIgKyBrZXkpIDogXCJcIikpLCB0cnVlKTtcbiAgcmV0dXJuIHRyZWVcbn1cblxuZnVuY3Rpb24gbWFya1N0YXRpYyAoXG4gIHRyZWUsXG4gIGtleSxcbiAgaXNPbmNlXG4pIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodHJlZSkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyZWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0cmVlW2ldICYmIHR5cGVvZiB0cmVlW2ldICE9PSAnc3RyaW5nJykge1xuICAgICAgICBtYXJrU3RhdGljTm9kZSh0cmVlW2ldLCAoa2V5ICsgXCJfXCIgKyBpKSwgaXNPbmNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbWFya1N0YXRpY05vZGUodHJlZSwga2V5LCBpc09uY2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hcmtTdGF0aWNOb2RlIChub2RlLCBrZXksIGlzT25jZSkge1xuICBub2RlLmlzU3RhdGljID0gdHJ1ZTtcbiAgbm9kZS5rZXkgPSBrZXk7XG4gIG5vZGUuaXNPbmNlID0gaXNPbmNlO1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gYmluZE9iamVjdExpc3RlbmVycyAoZGF0YSwgdmFsdWUpIHtcbiAgaWYgKHZhbHVlKSB7XG4gICAgaWYgKCFpc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICAndi1vbiB3aXRob3V0IGFyZ3VtZW50IGV4cGVjdHMgYW4gT2JqZWN0IHZhbHVlJyxcbiAgICAgICAgdGhpc1xuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG9uID0gZGF0YS5vbiA9IGRhdGEub24gPyBleHRlbmQoe30sIGRhdGEub24pIDoge307XG4gICAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICAgICAgdmFyIGV4aXN0aW5nID0gb25ba2V5XTtcbiAgICAgICAgdmFyIG91cnMgPSB2YWx1ZVtrZXldO1xuICAgICAgICBvbltrZXldID0gZXhpc3RpbmcgPyBbXS5jb25jYXQoZXhpc3RpbmcsIG91cnMpIDogb3VycztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluc3RhbGxSZW5kZXJIZWxwZXJzICh0YXJnZXQpIHtcbiAgdGFyZ2V0Ll9vID0gbWFya09uY2U7XG4gIHRhcmdldC5fbiA9IHRvTnVtYmVyO1xuICB0YXJnZXQuX3MgPSB0b1N0cmluZztcbiAgdGFyZ2V0Ll9sID0gcmVuZGVyTGlzdDtcbiAgdGFyZ2V0Ll90ID0gcmVuZGVyU2xvdDtcbiAgdGFyZ2V0Ll9xID0gbG9vc2VFcXVhbDtcbiAgdGFyZ2V0Ll9pID0gbG9vc2VJbmRleE9mO1xuICB0YXJnZXQuX20gPSByZW5kZXJTdGF0aWM7XG4gIHRhcmdldC5fZiA9IHJlc29sdmVGaWx0ZXI7XG4gIHRhcmdldC5fayA9IGNoZWNrS2V5Q29kZXM7XG4gIHRhcmdldC5fYiA9IGJpbmRPYmplY3RQcm9wcztcbiAgdGFyZ2V0Ll92ID0gY3JlYXRlVGV4dFZOb2RlO1xuICB0YXJnZXQuX2UgPSBjcmVhdGVFbXB0eVZOb2RlO1xuICB0YXJnZXQuX3UgPSByZXNvbHZlU2NvcGVkU2xvdHM7XG4gIHRhcmdldC5fZyA9IGJpbmRPYmplY3RMaXN0ZW5lcnM7XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBGdW5jdGlvbmFsUmVuZGVyQ29udGV4dCAoXG4gIGRhdGEsXG4gIHByb3BzLFxuICBjaGlsZHJlbixcbiAgcGFyZW50LFxuICBDdG9yXG4pIHtcbiAgdmFyIG9wdGlvbnMgPSBDdG9yLm9wdGlvbnM7XG4gIHRoaXMuZGF0YSA9IGRhdGE7XG4gIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgdGhpcy5saXN0ZW5lcnMgPSBkYXRhLm9uIHx8IGVtcHR5T2JqZWN0O1xuICB0aGlzLmluamVjdGlvbnMgPSByZXNvbHZlSW5qZWN0KG9wdGlvbnMuaW5qZWN0LCBwYXJlbnQpO1xuICB0aGlzLnNsb3RzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVzb2x2ZVNsb3RzKGNoaWxkcmVuLCBwYXJlbnQpOyB9O1xuXG4gIC8vIGVuc3VyZSB0aGUgY3JlYXRlRWxlbWVudCBmdW5jdGlvbiBpbiBmdW5jdGlvbmFsIGNvbXBvbmVudHNcbiAgLy8gZ2V0cyBhIHVuaXF1ZSBjb250ZXh0IC0gdGhpcyBpcyBuZWNlc3NhcnkgZm9yIGNvcnJlY3QgbmFtZWQgc2xvdCBjaGVja1xuICB2YXIgY29udGV4dFZtID0gT2JqZWN0LmNyZWF0ZShwYXJlbnQpO1xuICB2YXIgaXNDb21waWxlZCA9IGlzVHJ1ZShvcHRpb25zLl9jb21waWxlZCk7XG4gIHZhciBuZWVkTm9ybWFsaXphdGlvbiA9ICFpc0NvbXBpbGVkO1xuXG4gIC8vIHN1cHBvcnQgZm9yIGNvbXBpbGVkIGZ1bmN0aW9uYWwgdGVtcGxhdGVcbiAgaWYgKGlzQ29tcGlsZWQpIHtcbiAgICAvLyBleHBvc2luZyAkb3B0aW9ucyBmb3IgcmVuZGVyU3RhdGljKClcbiAgICB0aGlzLiRvcHRpb25zID0gb3B0aW9ucztcbiAgICAvLyBwcmUtcmVzb2x2ZSBzbG90cyBmb3IgcmVuZGVyU2xvdCgpXG4gICAgdGhpcy4kc2xvdHMgPSB0aGlzLnNsb3RzKCk7XG4gICAgdGhpcy4kc2NvcGVkU2xvdHMgPSBkYXRhLnNjb3BlZFNsb3RzIHx8IGVtcHR5T2JqZWN0O1xuICB9XG5cbiAgaWYgKG9wdGlvbnMuX3Njb3BlSWQpIHtcbiAgICB0aGlzLl9jID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHtcbiAgICAgIHZhciB2bm9kZSA9IGNyZWF0ZUVsZW1lbnQoY29udGV4dFZtLCBhLCBiLCBjLCBkLCBuZWVkTm9ybWFsaXphdGlvbik7XG4gICAgICBpZiAodm5vZGUpIHtcbiAgICAgICAgdm5vZGUuZm5TY29wZUlkID0gb3B0aW9ucy5fc2NvcGVJZDtcbiAgICAgICAgdm5vZGUuZm5Db250ZXh0ID0gcGFyZW50O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZub2RlXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9jID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHsgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoY29udGV4dFZtLCBhLCBiLCBjLCBkLCBuZWVkTm9ybWFsaXphdGlvbik7IH07XG4gIH1cbn1cblxuaW5zdGFsbFJlbmRlckhlbHBlcnMoRnVuY3Rpb25hbFJlbmRlckNvbnRleHQucHJvdG90eXBlKTtcblxuZnVuY3Rpb24gY3JlYXRlRnVuY3Rpb25hbENvbXBvbmVudCAoXG4gIEN0b3IsXG4gIHByb3BzRGF0YSxcbiAgZGF0YSxcbiAgY29udGV4dFZtLFxuICBjaGlsZHJlblxuKSB7XG4gIHZhciBvcHRpb25zID0gQ3Rvci5vcHRpb25zO1xuICB2YXIgcHJvcHMgPSB7fTtcbiAgdmFyIHByb3BPcHRpb25zID0gb3B0aW9ucy5wcm9wcztcbiAgaWYgKGlzRGVmKHByb3BPcHRpb25zKSkge1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wT3B0aW9ucykge1xuICAgICAgcHJvcHNba2V5XSA9IHZhbGlkYXRlUHJvcChrZXksIHByb3BPcHRpb25zLCBwcm9wc0RhdGEgfHwgZW1wdHlPYmplY3QpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoaXNEZWYoZGF0YS5hdHRycykpIHsgbWVyZ2VQcm9wcyhwcm9wcywgZGF0YS5hdHRycyk7IH1cbiAgICBpZiAoaXNEZWYoZGF0YS5wcm9wcykpIHsgbWVyZ2VQcm9wcyhwcm9wcywgZGF0YS5wcm9wcyk7IH1cbiAgfVxuXG4gIHZhciByZW5kZXJDb250ZXh0ID0gbmV3IEZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0KFxuICAgIGRhdGEsXG4gICAgcHJvcHMsXG4gICAgY2hpbGRyZW4sXG4gICAgY29udGV4dFZtLFxuICAgIEN0b3JcbiAgKTtcblxuICB2YXIgdm5vZGUgPSBvcHRpb25zLnJlbmRlci5jYWxsKG51bGwsIHJlbmRlckNvbnRleHQuX2MsIHJlbmRlckNvbnRleHQpO1xuXG4gIGlmICh2bm9kZSBpbnN0YW5jZW9mIFZOb2RlKSB7XG4gICAgdm5vZGUuZm5Db250ZXh0ID0gY29udGV4dFZtO1xuICAgIHZub2RlLmZuT3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgaWYgKGRhdGEuc2xvdCkge1xuICAgICAgKHZub2RlLmRhdGEgfHwgKHZub2RlLmRhdGEgPSB7fSkpLnNsb3QgPSBkYXRhLnNsb3Q7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHZub2RlXG59XG5cbmZ1bmN0aW9uIG1lcmdlUHJvcHMgKHRvLCBmcm9tKSB7XG4gIGZvciAodmFyIGtleSBpbiBmcm9tKSB7XG4gICAgdG9bY2FtZWxpemUoa2V5KV0gPSBmcm9tW2tleV07XG4gIH1cbn1cblxuLyogICovXG5cblxuXG5cbi8vIFJlZ2lzdGVyIHRoZSBjb21wb25lbnQgaG9vayB0byB3ZWV4IG5hdGl2ZSByZW5kZXIgZW5naW5lLlxuLy8gVGhlIGhvb2sgd2lsbCBiZSB0cmlnZ2VyZWQgYnkgbmF0aXZlLCBub3QgamF2YXNjcmlwdC5cblxuXG4vLyBVcGRhdGVzIHRoZSBzdGF0ZSBvZiB0aGUgY29tcG9uZW50IHRvIHdlZXggbmF0aXZlIHJlbmRlciBlbmdpbmUuXG5cbi8qICAqL1xuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vSGFua3MxMDEwMC93ZWV4LW5hdGl2ZS1kaXJlY3RpdmUvdHJlZS9tYXN0ZXIvY29tcG9uZW50XG5cbi8vIGxpc3RlbmluZyBvbiBuYXRpdmUgY2FsbGJhY2tcblxuLyogICovXG5cbi8qICAqL1xuXG4vLyBob29rcyB0byBiZSBpbnZva2VkIG9uIGNvbXBvbmVudCBWTm9kZXMgZHVyaW5nIHBhdGNoXG52YXIgY29tcG9uZW50Vk5vZGVIb29rcyA9IHtcbiAgaW5pdDogZnVuY3Rpb24gaW5pdCAoXG4gICAgdm5vZGUsXG4gICAgaHlkcmF0aW5nLFxuICAgIHBhcmVudEVsbSxcbiAgICByZWZFbG1cbiAgKSB7XG4gICAgaWYgKCF2bm9kZS5jb21wb25lbnRJbnN0YW5jZSB8fCB2bm9kZS5jb21wb25lbnRJbnN0YW5jZS5faXNEZXN0cm95ZWQpIHtcbiAgICAgIHZhciBjaGlsZCA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gY3JlYXRlQ29tcG9uZW50SW5zdGFuY2VGb3JWbm9kZShcbiAgICAgICAgdm5vZGUsXG4gICAgICAgIGFjdGl2ZUluc3RhbmNlLFxuICAgICAgICBwYXJlbnRFbG0sXG4gICAgICAgIHJlZkVsbVxuICAgICAgKTtcbiAgICAgIGNoaWxkLiRtb3VudChoeWRyYXRpbmcgPyB2bm9kZS5lbG0gOiB1bmRlZmluZWQsIGh5ZHJhdGluZyk7XG4gICAgfSBlbHNlIGlmICh2bm9kZS5kYXRhLmtlZXBBbGl2ZSkge1xuICAgICAgLy8ga2VwdC1hbGl2ZSBjb21wb25lbnRzLCB0cmVhdCBhcyBhIHBhdGNoXG4gICAgICB2YXIgbW91bnRlZE5vZGUgPSB2bm9kZTsgLy8gd29yayBhcm91bmQgZmxvd1xuICAgICAgY29tcG9uZW50Vk5vZGVIb29rcy5wcmVwYXRjaChtb3VudGVkTm9kZSwgbW91bnRlZE5vZGUpO1xuICAgIH1cbiAgfSxcblxuICBwcmVwYXRjaDogZnVuY3Rpb24gcHJlcGF0Y2ggKG9sZFZub2RlLCB2bm9kZSkge1xuICAgIHZhciBvcHRpb25zID0gdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgICB2YXIgY2hpbGQgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IG9sZFZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgIHVwZGF0ZUNoaWxkQ29tcG9uZW50KFxuICAgICAgY2hpbGQsXG4gICAgICBvcHRpb25zLnByb3BzRGF0YSwgLy8gdXBkYXRlZCBwcm9wc1xuICAgICAgb3B0aW9ucy5saXN0ZW5lcnMsIC8vIHVwZGF0ZWQgbGlzdGVuZXJzXG4gICAgICB2bm9kZSwgLy8gbmV3IHBhcmVudCB2bm9kZVxuICAgICAgb3B0aW9ucy5jaGlsZHJlbiAvLyBuZXcgY2hpbGRyZW5cbiAgICApO1xuICB9LFxuXG4gIGluc2VydDogZnVuY3Rpb24gaW5zZXJ0ICh2bm9kZSkge1xuICAgIHZhciBjb250ZXh0ID0gdm5vZGUuY29udGV4dDtcbiAgICB2YXIgY29tcG9uZW50SW5zdGFuY2UgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICBpZiAoIWNvbXBvbmVudEluc3RhbmNlLl9pc01vdW50ZWQpIHtcbiAgICAgIGNvbXBvbmVudEluc3RhbmNlLl9pc01vdW50ZWQgPSB0cnVlO1xuICAgICAgY2FsbEhvb2soY29tcG9uZW50SW5zdGFuY2UsICdtb3VudGVkJyk7XG4gICAgfVxuICAgIGlmICh2bm9kZS5kYXRhLmtlZXBBbGl2ZSkge1xuICAgICAgaWYgKGNvbnRleHQuX2lzTW91bnRlZCkge1xuICAgICAgICAvLyB2dWUtcm91dGVyIzEyMTJcbiAgICAgICAgLy8gRHVyaW5nIHVwZGF0ZXMsIGEga2VwdC1hbGl2ZSBjb21wb25lbnQncyBjaGlsZCBjb21wb25lbnRzIG1heVxuICAgICAgICAvLyBjaGFuZ2UsIHNvIGRpcmVjdGx5IHdhbGtpbmcgdGhlIHRyZWUgaGVyZSBtYXkgY2FsbCBhY3RpdmF0ZWQgaG9va3NcbiAgICAgICAgLy8gb24gaW5jb3JyZWN0IGNoaWxkcmVuLiBJbnN0ZWFkIHdlIHB1c2ggdGhlbSBpbnRvIGEgcXVldWUgd2hpY2ggd2lsbFxuICAgICAgICAvLyBiZSBwcm9jZXNzZWQgYWZ0ZXIgdGhlIHdob2xlIHBhdGNoIHByb2Nlc3MgZW5kZWQuXG4gICAgICAgIHF1ZXVlQWN0aXZhdGVkQ29tcG9uZW50KGNvbXBvbmVudEluc3RhbmNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQoY29tcG9uZW50SW5zdGFuY2UsIHRydWUgLyogZGlyZWN0ICovKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSAodm5vZGUpIHtcbiAgICB2YXIgY29tcG9uZW50SW5zdGFuY2UgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICBpZiAoIWNvbXBvbmVudEluc3RhbmNlLl9pc0Rlc3Ryb3llZCkge1xuICAgICAgaWYgKCF2bm9kZS5kYXRhLmtlZXBBbGl2ZSkge1xuICAgICAgICBjb21wb25lbnRJbnN0YW5jZS4kZGVzdHJveSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KGNvbXBvbmVudEluc3RhbmNlLCB0cnVlIC8qIGRpcmVjdCAqLyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG52YXIgaG9va3NUb01lcmdlID0gT2JqZWN0LmtleXMoY29tcG9uZW50Vk5vZGVIb29rcyk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudCAoXG4gIEN0b3IsXG4gIGRhdGEsXG4gIGNvbnRleHQsXG4gIGNoaWxkcmVuLFxuICB0YWdcbikge1xuICBpZiAoaXNVbmRlZihDdG9yKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGJhc2VDdG9yID0gY29udGV4dC4kb3B0aW9ucy5fYmFzZTtcblxuICAvLyBwbGFpbiBvcHRpb25zIG9iamVjdDogdHVybiBpdCBpbnRvIGEgY29uc3RydWN0b3JcbiAgaWYgKGlzT2JqZWN0KEN0b3IpKSB7XG4gICAgQ3RvciA9IGJhc2VDdG9yLmV4dGVuZChDdG9yKTtcbiAgfVxuXG4gIC8vIGlmIGF0IHRoaXMgc3RhZ2UgaXQncyBub3QgYSBjb25zdHJ1Y3RvciBvciBhbiBhc3luYyBjb21wb25lbnQgZmFjdG9yeSxcbiAgLy8gcmVqZWN0LlxuICBpZiAodHlwZW9mIEN0b3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgd2FybigoXCJJbnZhbGlkIENvbXBvbmVudCBkZWZpbml0aW9uOiBcIiArIChTdHJpbmcoQ3RvcikpKSwgY29udGV4dCk7XG4gICAgfVxuICAgIHJldHVyblxuICB9XG5cbiAgLy8gYXN5bmMgY29tcG9uZW50XG4gIHZhciBhc3luY0ZhY3Rvcnk7XG4gIGlmIChpc1VuZGVmKEN0b3IuY2lkKSkge1xuICAgIGFzeW5jRmFjdG9yeSA9IEN0b3I7XG4gICAgQ3RvciA9IHJlc29sdmVBc3luY0NvbXBvbmVudChhc3luY0ZhY3RvcnksIGJhc2VDdG9yLCBjb250ZXh0KTtcbiAgICBpZiAoQ3RvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyByZXR1cm4gYSBwbGFjZWhvbGRlciBub2RlIGZvciBhc3luYyBjb21wb25lbnQsIHdoaWNoIGlzIHJlbmRlcmVkXG4gICAgICAvLyBhcyBhIGNvbW1lbnQgbm9kZSBidXQgcHJlc2VydmVzIGFsbCB0aGUgcmF3IGluZm9ybWF0aW9uIGZvciB0aGUgbm9kZS5cbiAgICAgIC8vIHRoZSBpbmZvcm1hdGlvbiB3aWxsIGJlIHVzZWQgZm9yIGFzeW5jIHNlcnZlci1yZW5kZXJpbmcgYW5kIGh5ZHJhdGlvbi5cbiAgICAgIHJldHVybiBjcmVhdGVBc3luY1BsYWNlaG9sZGVyKFxuICAgICAgICBhc3luY0ZhY3RvcnksXG4gICAgICAgIGRhdGEsXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGNoaWxkcmVuLFxuICAgICAgICB0YWdcbiAgICAgIClcbiAgICB9XG4gIH1cblxuICBkYXRhID0gZGF0YSB8fCB7fTtcblxuICAvLyByZXNvbHZlIGNvbnN0cnVjdG9yIG9wdGlvbnMgaW4gY2FzZSBnbG9iYWwgbWl4aW5zIGFyZSBhcHBsaWVkIGFmdGVyXG4gIC8vIGNvbXBvbmVudCBjb25zdHJ1Y3RvciBjcmVhdGlvblxuICByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKEN0b3IpO1xuXG4gIC8vIHRyYW5zZm9ybSBjb21wb25lbnQgdi1tb2RlbCBkYXRhIGludG8gcHJvcHMgJiBldmVudHNcbiAgaWYgKGlzRGVmKGRhdGEubW9kZWwpKSB7XG4gICAgdHJhbnNmb3JtTW9kZWwoQ3Rvci5vcHRpb25zLCBkYXRhKTtcbiAgfVxuXG4gIC8vIGV4dHJhY3QgcHJvcHNcbiAgdmFyIHByb3BzRGF0YSA9IGV4dHJhY3RQcm9wc0Zyb21WTm9kZURhdGEoZGF0YSwgQ3RvciwgdGFnKTtcblxuICAvLyBmdW5jdGlvbmFsIGNvbXBvbmVudFxuICBpZiAoaXNUcnVlKEN0b3Iub3B0aW9ucy5mdW5jdGlvbmFsKSkge1xuICAgIHJldHVybiBjcmVhdGVGdW5jdGlvbmFsQ29tcG9uZW50KEN0b3IsIHByb3BzRGF0YSwgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4pXG4gIH1cblxuICAvLyBleHRyYWN0IGxpc3RlbmVycywgc2luY2UgdGhlc2UgbmVlZHMgdG8gYmUgdHJlYXRlZCBhc1xuICAvLyBjaGlsZCBjb21wb25lbnQgbGlzdGVuZXJzIGluc3RlYWQgb2YgRE9NIGxpc3RlbmVyc1xuICB2YXIgbGlzdGVuZXJzID0gZGF0YS5vbjtcbiAgLy8gcmVwbGFjZSB3aXRoIGxpc3RlbmVycyB3aXRoIC5uYXRpdmUgbW9kaWZpZXJcbiAgLy8gc28gaXQgZ2V0cyBwcm9jZXNzZWQgZHVyaW5nIHBhcmVudCBjb21wb25lbnQgcGF0Y2guXG4gIGRhdGEub24gPSBkYXRhLm5hdGl2ZU9uO1xuXG4gIGlmIChpc1RydWUoQ3Rvci5vcHRpb25zLmFic3RyYWN0KSkge1xuICAgIC8vIGFic3RyYWN0IGNvbXBvbmVudHMgZG8gbm90IGtlZXAgYW55dGhpbmdcbiAgICAvLyBvdGhlciB0aGFuIHByb3BzICYgbGlzdGVuZXJzICYgc2xvdFxuXG4gICAgLy8gd29yayBhcm91bmQgZmxvd1xuICAgIHZhciBzbG90ID0gZGF0YS5zbG90O1xuICAgIGRhdGEgPSB7fTtcbiAgICBpZiAoc2xvdCkge1xuICAgICAgZGF0YS5zbG90ID0gc2xvdDtcbiAgICB9XG4gIH1cblxuICAvLyBtZXJnZSBjb21wb25lbnQgbWFuYWdlbWVudCBob29rcyBvbnRvIHRoZSBwbGFjZWhvbGRlciBub2RlXG4gIG1lcmdlSG9va3MoZGF0YSk7XG5cbiAgLy8gcmV0dXJuIGEgcGxhY2Vob2xkZXIgdm5vZGVcbiAgdmFyIG5hbWUgPSBDdG9yLm9wdGlvbnMubmFtZSB8fCB0YWc7XG4gIHZhciB2bm9kZSA9IG5ldyBWTm9kZShcbiAgICAoXCJ2dWUtY29tcG9uZW50LVwiICsgKEN0b3IuY2lkKSArIChuYW1lID8gKFwiLVwiICsgbmFtZSkgOiAnJykpLFxuICAgIGRhdGEsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbnRleHQsXG4gICAgeyBDdG9yOiBDdG9yLCBwcm9wc0RhdGE6IHByb3BzRGF0YSwgbGlzdGVuZXJzOiBsaXN0ZW5lcnMsIHRhZzogdGFnLCBjaGlsZHJlbjogY2hpbGRyZW4gfSxcbiAgICBhc3luY0ZhY3RvcnlcbiAgKTtcblxuICAvLyBXZWV4IHNwZWNpZmljOiBpbnZva2UgcmVjeWNsZS1saXN0IG9wdGltaXplZCBAcmVuZGVyIGZ1bmN0aW9uIGZvclxuICAvLyBleHRyYWN0aW5nIGNlbGwtc2xvdCB0ZW1wbGF0ZS5cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL0hhbmtzMTAxMDAvd2VleC1uYXRpdmUtZGlyZWN0aXZlL3RyZWUvbWFzdGVyL2NvbXBvbmVudFxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgcmV0dXJuIHZub2RlXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlRm9yVm5vZGUgKFxuICB2bm9kZSwgLy8gd2Uga25vdyBpdCdzIE1vdW50ZWRDb21wb25lbnRWTm9kZSBidXQgZmxvdyBkb2Vzbid0XG4gIHBhcmVudCwgLy8gYWN0aXZlSW5zdGFuY2UgaW4gbGlmZWN5Y2xlIHN0YXRlXG4gIHBhcmVudEVsbSxcbiAgcmVmRWxtXG4pIHtcbiAgdmFyIG9wdGlvbnMgPSB7XG4gICAgX2lzQ29tcG9uZW50OiB0cnVlLFxuICAgIHBhcmVudDogcGFyZW50LFxuICAgIF9wYXJlbnRWbm9kZTogdm5vZGUsXG4gICAgX3BhcmVudEVsbTogcGFyZW50RWxtIHx8IG51bGwsXG4gICAgX3JlZkVsbTogcmVmRWxtIHx8IG51bGxcbiAgfTtcbiAgLy8gY2hlY2sgaW5saW5lLXRlbXBsYXRlIHJlbmRlciBmdW5jdGlvbnNcbiAgdmFyIGlubGluZVRlbXBsYXRlID0gdm5vZGUuZGF0YS5pbmxpbmVUZW1wbGF0ZTtcbiAgaWYgKGlzRGVmKGlubGluZVRlbXBsYXRlKSkge1xuICAgIG9wdGlvbnMucmVuZGVyID0gaW5saW5lVGVtcGxhdGUucmVuZGVyO1xuICAgIG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zID0gaW5saW5lVGVtcGxhdGUuc3RhdGljUmVuZGVyRm5zO1xuICB9XG4gIHJldHVybiBuZXcgdm5vZGUuY29tcG9uZW50T3B0aW9ucy5DdG9yKG9wdGlvbnMpXG59XG5cbmZ1bmN0aW9uIG1lcmdlSG9va3MgKGRhdGEpIHtcbiAgaWYgKCFkYXRhLmhvb2spIHtcbiAgICBkYXRhLmhvb2sgPSB7fTtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGhvb2tzVG9NZXJnZS5sZW5ndGg7IGkrKykge1xuICAgIHZhciBrZXkgPSBob29rc1RvTWVyZ2VbaV07XG4gICAgdmFyIGZyb21QYXJlbnQgPSBkYXRhLmhvb2tba2V5XTtcbiAgICB2YXIgb3VycyA9IGNvbXBvbmVudFZOb2RlSG9va3Nba2V5XTtcbiAgICBkYXRhLmhvb2tba2V5XSA9IGZyb21QYXJlbnQgPyBtZXJnZUhvb2skMShvdXJzLCBmcm9tUGFyZW50KSA6IG91cnM7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWVyZ2VIb29rJDEgKG9uZSwgdHdvKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoYSwgYiwgYywgZCkge1xuICAgIG9uZShhLCBiLCBjLCBkKTtcbiAgICB0d28oYSwgYiwgYywgZCk7XG4gIH1cbn1cblxuLy8gdHJhbnNmb3JtIGNvbXBvbmVudCB2LW1vZGVsIGluZm8gKHZhbHVlIGFuZCBjYWxsYmFjaykgaW50b1xuLy8gcHJvcCBhbmQgZXZlbnQgaGFuZGxlciByZXNwZWN0aXZlbHkuXG5mdW5jdGlvbiB0cmFuc2Zvcm1Nb2RlbCAob3B0aW9ucywgZGF0YSkge1xuICB2YXIgcHJvcCA9IChvcHRpb25zLm1vZGVsICYmIG9wdGlvbnMubW9kZWwucHJvcCkgfHwgJ3ZhbHVlJztcbiAgdmFyIGV2ZW50ID0gKG9wdGlvbnMubW9kZWwgJiYgb3B0aW9ucy5tb2RlbC5ldmVudCkgfHwgJ2lucHV0JzsoZGF0YS5wcm9wcyB8fCAoZGF0YS5wcm9wcyA9IHt9KSlbcHJvcF0gPSBkYXRhLm1vZGVsLnZhbHVlO1xuICB2YXIgb24gPSBkYXRhLm9uIHx8IChkYXRhLm9uID0ge30pO1xuICBpZiAoaXNEZWYob25bZXZlbnRdKSkge1xuICAgIG9uW2V2ZW50XSA9IFtkYXRhLm1vZGVsLmNhbGxiYWNrXS5jb25jYXQob25bZXZlbnRdKTtcbiAgfSBlbHNlIHtcbiAgICBvbltldmVudF0gPSBkYXRhLm1vZGVsLmNhbGxiYWNrO1xuICB9XG59XG5cbi8qICAqL1xuXG52YXIgU0lNUExFX05PUk1BTElaRSA9IDE7XG52YXIgQUxXQVlTX05PUk1BTElaRSA9IDI7XG5cbi8vIHdyYXBwZXIgZnVuY3Rpb24gZm9yIHByb3ZpZGluZyBhIG1vcmUgZmxleGlibGUgaW50ZXJmYWNlXG4vLyB3aXRob3V0IGdldHRpbmcgeWVsbGVkIGF0IGJ5IGZsb3dcbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQgKFxuICBjb250ZXh0LFxuICB0YWcsXG4gIGRhdGEsXG4gIGNoaWxkcmVuLFxuICBub3JtYWxpemF0aW9uVHlwZSxcbiAgYWx3YXlzTm9ybWFsaXplXG4pIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkgfHwgaXNQcmltaXRpdmUoZGF0YSkpIHtcbiAgICBub3JtYWxpemF0aW9uVHlwZSA9IGNoaWxkcmVuO1xuICAgIGNoaWxkcmVuID0gZGF0YTtcbiAgICBkYXRhID0gdW5kZWZpbmVkO1xuICB9XG4gIGlmIChpc1RydWUoYWx3YXlzTm9ybWFsaXplKSkge1xuICAgIG5vcm1hbGl6YXRpb25UeXBlID0gQUxXQVlTX05PUk1BTElaRTtcbiAgfVxuICByZXR1cm4gX2NyZWF0ZUVsZW1lbnQoY29udGV4dCwgdGFnLCBkYXRhLCBjaGlsZHJlbiwgbm9ybWFsaXphdGlvblR5cGUpXG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVFbGVtZW50IChcbiAgY29udGV4dCxcbiAgdGFnLFxuICBkYXRhLFxuICBjaGlsZHJlbixcbiAgbm9ybWFsaXphdGlvblR5cGVcbikge1xuICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNEZWYoKGRhdGEpLl9fb2JfXykpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICBcIkF2b2lkIHVzaW5nIG9ic2VydmVkIGRhdGEgb2JqZWN0IGFzIHZub2RlIGRhdGE6IFwiICsgKEpTT04uc3RyaW5naWZ5KGRhdGEpKSArIFwiXFxuXCIgK1xuICAgICAgJ0Fsd2F5cyBjcmVhdGUgZnJlc2ggdm5vZGUgZGF0YSBvYmplY3RzIGluIGVhY2ggcmVuZGVyIScsXG4gICAgICBjb250ZXh0XG4gICAgKTtcbiAgICByZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpXG4gIH1cbiAgLy8gb2JqZWN0IHN5bnRheCBpbiB2LWJpbmRcbiAgaWYgKGlzRGVmKGRhdGEpICYmIGlzRGVmKGRhdGEuaXMpKSB7XG4gICAgdGFnID0gZGF0YS5pcztcbiAgfVxuICBpZiAoIXRhZykge1xuICAgIC8vIGluIGNhc2Ugb2YgY29tcG9uZW50IDppcyBzZXQgdG8gZmFsc3kgdmFsdWVcbiAgICByZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpXG4gIH1cbiAgLy8gd2FybiBhZ2FpbnN0IG5vbi1wcmltaXRpdmUga2V5XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgaXNEZWYoZGF0YSkgJiYgaXNEZWYoZGF0YS5rZXkpICYmICFpc1ByaW1pdGl2ZShkYXRhLmtleSlcbiAgKSB7XG4gICAge1xuICAgICAgd2FybihcbiAgICAgICAgJ0F2b2lkIHVzaW5nIG5vbi1wcmltaXRpdmUgdmFsdWUgYXMga2V5LCAnICtcbiAgICAgICAgJ3VzZSBzdHJpbmcvbnVtYmVyIHZhbHVlIGluc3RlYWQuJyxcbiAgICAgICAgY29udGV4dFxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgLy8gc3VwcG9ydCBzaW5nbGUgZnVuY3Rpb24gY2hpbGRyZW4gYXMgZGVmYXVsdCBzY29wZWQgc2xvdFxuICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikgJiZcbiAgICB0eXBlb2YgY2hpbGRyZW5bMF0gPT09ICdmdW5jdGlvbidcbiAgKSB7XG4gICAgZGF0YSA9IGRhdGEgfHwge307XG4gICAgZGF0YS5zY29wZWRTbG90cyA9IHsgZGVmYXVsdDogY2hpbGRyZW5bMF0gfTtcbiAgICBjaGlsZHJlbi5sZW5ndGggPSAwO1xuICB9XG4gIGlmIChub3JtYWxpemF0aW9uVHlwZSA9PT0gQUxXQVlTX05PUk1BTElaRSkge1xuICAgIGNoaWxkcmVuID0gbm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pO1xuICB9IGVsc2UgaWYgKG5vcm1hbGl6YXRpb25UeXBlID09PSBTSU1QTEVfTk9STUFMSVpFKSB7XG4gICAgY2hpbGRyZW4gPSBzaW1wbGVOb3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbik7XG4gIH1cbiAgdmFyIHZub2RlLCBucztcbiAgaWYgKHR5cGVvZiB0YWcgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIEN0b3I7XG4gICAgbnMgPSAoY29udGV4dC4kdm5vZGUgJiYgY29udGV4dC4kdm5vZGUubnMpIHx8IGNvbmZpZy5nZXRUYWdOYW1lc3BhY2UodGFnKTtcbiAgICBpZiAoY29uZmlnLmlzUmVzZXJ2ZWRUYWcodGFnKSkge1xuICAgICAgLy8gcGxhdGZvcm0gYnVpbHQtaW4gZWxlbWVudHNcbiAgICAgIHZub2RlID0gbmV3IFZOb2RlKFxuICAgICAgICBjb25maWcucGFyc2VQbGF0Zm9ybVRhZ05hbWUodGFnKSwgZGF0YSwgY2hpbGRyZW4sXG4gICAgICAgIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0XG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoaXNEZWYoQ3RvciA9IHJlc29sdmVBc3NldChjb250ZXh0LiRvcHRpb25zLCAnY29tcG9uZW50cycsIHRhZykpKSB7XG4gICAgICAvLyBjb21wb25lbnRcbiAgICAgIHZub2RlID0gY3JlYXRlQ29tcG9uZW50KEN0b3IsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuLCB0YWcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB1bmtub3duIG9yIHVubGlzdGVkIG5hbWVzcGFjZWQgZWxlbWVudHNcbiAgICAgIC8vIGNoZWNrIGF0IHJ1bnRpbWUgYmVjYXVzZSBpdCBtYXkgZ2V0IGFzc2lnbmVkIGEgbmFtZXNwYWNlIHdoZW4gaXRzXG4gICAgICAvLyBwYXJlbnQgbm9ybWFsaXplcyBjaGlsZHJlblxuICAgICAgdm5vZGUgPSBuZXcgVk5vZGUoXG4gICAgICAgIHRhZywgZGF0YSwgY2hpbGRyZW4sXG4gICAgICAgIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0XG4gICAgICApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBkaXJlY3QgY29tcG9uZW50IG9wdGlvbnMgLyBjb25zdHJ1Y3RvclxuICAgIHZub2RlID0gY3JlYXRlQ29tcG9uZW50KHRhZywgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4pO1xuICB9XG4gIGlmIChpc0RlZih2bm9kZSkpIHtcbiAgICBpZiAobnMpIHsgYXBwbHlOUyh2bm9kZSwgbnMpOyB9XG4gICAgcmV0dXJuIHZub2RlXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNyZWF0ZUVtcHR5Vk5vZGUoKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFwcGx5TlMgKHZub2RlLCBucywgZm9yY2UpIHtcbiAgdm5vZGUubnMgPSBucztcbiAgaWYgKHZub2RlLnRhZyA9PT0gJ2ZvcmVpZ25PYmplY3QnKSB7XG4gICAgLy8gdXNlIGRlZmF1bHQgbmFtZXNwYWNlIGluc2lkZSBmb3JlaWduT2JqZWN0XG4gICAgbnMgPSB1bmRlZmluZWQ7XG4gICAgZm9yY2UgPSB0cnVlO1xuICB9XG4gIGlmIChpc0RlZih2bm9kZS5jaGlsZHJlbikpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHZub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gdm5vZGUuY2hpbGRyZW5baV07XG4gICAgICBpZiAoaXNEZWYoY2hpbGQudGFnKSAmJiAoaXNVbmRlZihjaGlsZC5ucykgfHwgaXNUcnVlKGZvcmNlKSkpIHtcbiAgICAgICAgYXBwbHlOUyhjaGlsZCwgbnMsIGZvcmNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRSZW5kZXIgKHZtKSB7XG4gIHZtLl92bm9kZSA9IG51bGw7IC8vIHRoZSByb290IG9mIHRoZSBjaGlsZCB0cmVlXG4gIHZtLl9zdGF0aWNUcmVlcyA9IG51bGw7IC8vIHYtb25jZSBjYWNoZWQgdHJlZXNcbiAgdmFyIG9wdGlvbnMgPSB2bS4kb3B0aW9ucztcbiAgdmFyIHBhcmVudFZub2RlID0gdm0uJHZub2RlID0gb3B0aW9ucy5fcGFyZW50Vm5vZGU7IC8vIHRoZSBwbGFjZWhvbGRlciBub2RlIGluIHBhcmVudCB0cmVlXG4gIHZhciByZW5kZXJDb250ZXh0ID0gcGFyZW50Vm5vZGUgJiYgcGFyZW50Vm5vZGUuY29udGV4dDtcbiAgdm0uJHNsb3RzID0gcmVzb2x2ZVNsb3RzKG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuLCByZW5kZXJDb250ZXh0KTtcbiAgdm0uJHNjb3BlZFNsb3RzID0gZW1wdHlPYmplY3Q7XG4gIC8vIGJpbmQgdGhlIGNyZWF0ZUVsZW1lbnQgZm4gdG8gdGhpcyBpbnN0YW5jZVxuICAvLyBzbyB0aGF0IHdlIGdldCBwcm9wZXIgcmVuZGVyIGNvbnRleHQgaW5zaWRlIGl0LlxuICAvLyBhcmdzIG9yZGVyOiB0YWcsIGRhdGEsIGNoaWxkcmVuLCBub3JtYWxpemF0aW9uVHlwZSwgYWx3YXlzTm9ybWFsaXplXG4gIC8vIGludGVybmFsIHZlcnNpb24gaXMgdXNlZCBieSByZW5kZXIgZnVuY3Rpb25zIGNvbXBpbGVkIGZyb20gdGVtcGxhdGVzXG4gIHZtLl9jID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHsgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodm0sIGEsIGIsIGMsIGQsIGZhbHNlKTsgfTtcbiAgLy8gbm9ybWFsaXphdGlvbiBpcyBhbHdheXMgYXBwbGllZCBmb3IgdGhlIHB1YmxpYyB2ZXJzaW9uLCB1c2VkIGluXG4gIC8vIHVzZXItd3JpdHRlbiByZW5kZXIgZnVuY3Rpb25zLlxuICB2bS4kY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7IHJldHVybiBjcmVhdGVFbGVtZW50KHZtLCBhLCBiLCBjLCBkLCB0cnVlKTsgfTtcblxuICAvLyAkYXR0cnMgJiAkbGlzdGVuZXJzIGFyZSBleHBvc2VkIGZvciBlYXNpZXIgSE9DIGNyZWF0aW9uLlxuICAvLyB0aGV5IG5lZWQgdG8gYmUgcmVhY3RpdmUgc28gdGhhdCBIT0NzIHVzaW5nIHRoZW0gYXJlIGFsd2F5cyB1cGRhdGVkXG4gIHZhciBwYXJlbnREYXRhID0gcGFyZW50Vm5vZGUgJiYgcGFyZW50Vm5vZGUuZGF0YTtcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGRlZmluZVJlYWN0aXZlKHZtLCAnJGF0dHJzJywgcGFyZW50RGF0YSAmJiBwYXJlbnREYXRhLmF0dHJzIHx8IGVtcHR5T2JqZWN0LCBmdW5jdGlvbiAoKSB7XG4gICAgICAhaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ICYmIHdhcm4oXCIkYXR0cnMgaXMgcmVhZG9ubHkuXCIsIHZtKTtcbiAgICB9LCB0cnVlKTtcbiAgICBkZWZpbmVSZWFjdGl2ZSh2bSwgJyRsaXN0ZW5lcnMnLCBvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnMgfHwgZW1wdHlPYmplY3QsIGZ1bmN0aW9uICgpIHtcbiAgICAgICFpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgJiYgd2FybihcIiRsaXN0ZW5lcnMgaXMgcmVhZG9ubHkuXCIsIHZtKTtcbiAgICB9LCB0cnVlKTtcbiAgfSBlbHNlIHtcbiAgICBkZWZpbmVSZWFjdGl2ZSh2bSwgJyRhdHRycycsIHBhcmVudERhdGEgJiYgcGFyZW50RGF0YS5hdHRycyB8fCBlbXB0eU9iamVjdCwgbnVsbCwgdHJ1ZSk7XG4gICAgZGVmaW5lUmVhY3RpdmUodm0sICckbGlzdGVuZXJzJywgb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzIHx8IGVtcHR5T2JqZWN0LCBudWxsLCB0cnVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW5kZXJNaXhpbiAoVnVlKSB7XG4gIC8vIGluc3RhbGwgcnVudGltZSBjb252ZW5pZW5jZSBoZWxwZXJzXG4gIGluc3RhbGxSZW5kZXJIZWxwZXJzKFZ1ZS5wcm90b3R5cGUpO1xuXG4gIFZ1ZS5wcm90b3R5cGUuJG5leHRUaWNrID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgcmV0dXJuIG5leHRUaWNrKGZuLCB0aGlzKVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuX3JlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIHZhciByZWYgPSB2bS4kb3B0aW9ucztcbiAgICB2YXIgcmVuZGVyID0gcmVmLnJlbmRlcjtcbiAgICB2YXIgX3BhcmVudFZub2RlID0gcmVmLl9wYXJlbnRWbm9kZTtcblxuICAgIGlmICh2bS5faXNNb3VudGVkKSB7XG4gICAgICAvLyBpZiB0aGUgcGFyZW50IGRpZG4ndCB1cGRhdGUsIHRoZSBzbG90IG5vZGVzIHdpbGwgYmUgdGhlIG9uZXMgZnJvbVxuICAgICAgLy8gbGFzdCByZW5kZXIuIFRoZXkgbmVlZCB0byBiZSBjbG9uZWQgdG8gZW5zdXJlIFwiZnJlc2huZXNzXCIgZm9yIHRoaXMgcmVuZGVyLlxuICAgICAgZm9yICh2YXIga2V5IGluIHZtLiRzbG90cykge1xuICAgICAgICB2YXIgc2xvdCA9IHZtLiRzbG90c1trZXldO1xuICAgICAgICAvLyBfcmVuZGVyZWQgaXMgYSBmbGFnIGFkZGVkIGJ5IHJlbmRlclNsb3QsIGJ1dCBtYXkgbm90IGJlIHByZXNlbnRcbiAgICAgICAgLy8gaWYgdGhlIHNsb3QgaXMgcGFzc2VkIGZyb20gbWFudWFsbHkgd3JpdHRlbiByZW5kZXIgZnVuY3Rpb25zXG4gICAgICAgIGlmIChzbG90Ll9yZW5kZXJlZCB8fCAoc2xvdFswXSAmJiBzbG90WzBdLmVsbSkpIHtcbiAgICAgICAgICB2bS4kc2xvdHNba2V5XSA9IGNsb25lVk5vZGVzKHNsb3QsIHRydWUgLyogZGVlcCAqLyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2bS4kc2NvcGVkU2xvdHMgPSAoX3BhcmVudFZub2RlICYmIF9wYXJlbnRWbm9kZS5kYXRhLnNjb3BlZFNsb3RzKSB8fCBlbXB0eU9iamVjdDtcblxuICAgIC8vIHNldCBwYXJlbnQgdm5vZGUuIHRoaXMgYWxsb3dzIHJlbmRlciBmdW5jdGlvbnMgdG8gaGF2ZSBhY2Nlc3NcbiAgICAvLyB0byB0aGUgZGF0YSBvbiB0aGUgcGxhY2Vob2xkZXIgbm9kZS5cbiAgICB2bS4kdm5vZGUgPSBfcGFyZW50Vm5vZGU7XG4gICAgLy8gcmVuZGVyIHNlbGZcbiAgICB2YXIgdm5vZGU7XG4gICAgdHJ5IHtcbiAgICAgIHZub2RlID0gcmVuZGVyLmNhbGwodm0uX3JlbmRlclByb3h5LCB2bS4kY3JlYXRlRWxlbWVudCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIFwicmVuZGVyXCIpO1xuICAgICAgLy8gcmV0dXJuIGVycm9yIHJlbmRlciByZXN1bHQsXG4gICAgICAvLyBvciBwcmV2aW91cyB2bm9kZSB0byBwcmV2ZW50IHJlbmRlciBlcnJvciBjYXVzaW5nIGJsYW5rIGNvbXBvbmVudFxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmICh2bS4kb3B0aW9ucy5yZW5kZXJFcnJvcikge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2bm9kZSA9IHZtLiRvcHRpb25zLnJlbmRlckVycm9yLmNhbGwodm0uX3JlbmRlclByb3h5LCB2bS4kY3JlYXRlRWxlbWVudCwgZSk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIFwicmVuZGVyRXJyb3JcIik7XG4gICAgICAgICAgICB2bm9kZSA9IHZtLl92bm9kZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdm5vZGUgPSB2bS5fdm5vZGU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZub2RlID0gdm0uX3Zub2RlO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyByZXR1cm4gZW1wdHkgdm5vZGUgaW4gY2FzZSB0aGUgcmVuZGVyIGZ1bmN0aW9uIGVycm9yZWQgb3V0XG4gICAgaWYgKCEodm5vZGUgaW5zdGFuY2VvZiBWTm9kZSkpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIEFycmF5LmlzQXJyYXkodm5vZGUpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ011bHRpcGxlIHJvb3Qgbm9kZXMgcmV0dXJuZWQgZnJvbSByZW5kZXIgZnVuY3Rpb24uIFJlbmRlciBmdW5jdGlvbiAnICtcbiAgICAgICAgICAnc2hvdWxkIHJldHVybiBhIHNpbmdsZSByb290IG5vZGUuJyxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdm5vZGUgPSBjcmVhdGVFbXB0eVZOb2RlKCk7XG4gICAgfVxuICAgIC8vIHNldCBwYXJlbnRcbiAgICB2bm9kZS5wYXJlbnQgPSBfcGFyZW50Vm5vZGU7XG4gICAgcmV0dXJuIHZub2RlXG4gIH07XG59XG5cbi8qICAqL1xuXG52YXIgdWlkID0gMDtcblxuZnVuY3Rpb24gaW5pdE1peGluIChWdWUpIHtcbiAgVnVlLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICAvLyBhIHVpZFxuICAgIHZtLl91aWQgPSB1aWQrKztcblxuICAgIHZhciBzdGFydFRhZywgZW5kVGFnO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgICBzdGFydFRhZyA9IFwidnVlLXBlcmYtc3RhcnQ6XCIgKyAodm0uX3VpZCk7XG4gICAgICBlbmRUYWcgPSBcInZ1ZS1wZXJmLWVuZDpcIiArICh2bS5fdWlkKTtcbiAgICAgIG1hcmsoc3RhcnRUYWcpO1xuICAgIH1cblxuICAgIC8vIGEgZmxhZyB0byBhdm9pZCB0aGlzIGJlaW5nIG9ic2VydmVkXG4gICAgdm0uX2lzVnVlID0gdHJ1ZTtcbiAgICAvLyBtZXJnZSBvcHRpb25zXG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5faXNDb21wb25lbnQpIHtcbiAgICAgIC8vIG9wdGltaXplIGludGVybmFsIGNvbXBvbmVudCBpbnN0YW50aWF0aW9uXG4gICAgICAvLyBzaW5jZSBkeW5hbWljIG9wdGlvbnMgbWVyZ2luZyBpcyBwcmV0dHkgc2xvdywgYW5kIG5vbmUgb2YgdGhlXG4gICAgICAvLyBpbnRlcm5hbCBjb21wb25lbnQgb3B0aW9ucyBuZWVkcyBzcGVjaWFsIHRyZWF0bWVudC5cbiAgICAgIGluaXRJbnRlcm5hbENvbXBvbmVudCh2bSwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZtLiRvcHRpb25zID0gbWVyZ2VPcHRpb25zKFxuICAgICAgICByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKHZtLmNvbnN0cnVjdG9yKSxcbiAgICAgICAgb3B0aW9ucyB8fCB7fSxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGluaXRQcm94eSh2bSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZtLl9yZW5kZXJQcm94eSA9IHZtO1xuICAgIH1cbiAgICAvLyBleHBvc2UgcmVhbCBzZWxmXG4gICAgdm0uX3NlbGYgPSB2bTtcbiAgICBpbml0TGlmZWN5Y2xlKHZtKTtcbiAgICBpbml0RXZlbnRzKHZtKTtcbiAgICBpbml0UmVuZGVyKHZtKTtcbiAgICBjYWxsSG9vayh2bSwgJ2JlZm9yZUNyZWF0ZScpO1xuICAgIGluaXRJbmplY3Rpb25zKHZtKTsgLy8gcmVzb2x2ZSBpbmplY3Rpb25zIGJlZm9yZSBkYXRhL3Byb3BzXG4gICAgaW5pdFN0YXRlKHZtKTtcbiAgICBpbml0UHJvdmlkZSh2bSk7IC8vIHJlc29sdmUgcHJvdmlkZSBhZnRlciBkYXRhL3Byb3BzXG4gICAgY2FsbEhvb2sodm0sICdjcmVhdGVkJyk7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgICAgdm0uX25hbWUgPSBmb3JtYXRDb21wb25lbnROYW1lKHZtLCBmYWxzZSk7XG4gICAgICBtYXJrKGVuZFRhZyk7XG4gICAgICBtZWFzdXJlKChcInZ1ZSBcIiArICh2bS5fbmFtZSkgKyBcIiBpbml0XCIpLCBzdGFydFRhZywgZW5kVGFnKTtcbiAgICB9XG5cbiAgICBpZiAodm0uJG9wdGlvbnMuZWwpIHtcbiAgICAgIHZtLiRtb3VudCh2bS4kb3B0aW9ucy5lbCk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBpbml0SW50ZXJuYWxDb21wb25lbnQgKHZtLCBvcHRpb25zKSB7XG4gIHZhciBvcHRzID0gdm0uJG9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKHZtLmNvbnN0cnVjdG9yLm9wdGlvbnMpO1xuICAvLyBkb2luZyB0aGlzIGJlY2F1c2UgaXQncyBmYXN0ZXIgdGhhbiBkeW5hbWljIGVudW1lcmF0aW9uLlxuICB2YXIgcGFyZW50Vm5vZGUgPSBvcHRpb25zLl9wYXJlbnRWbm9kZTtcbiAgb3B0cy5wYXJlbnQgPSBvcHRpb25zLnBhcmVudDtcbiAgb3B0cy5fcGFyZW50Vm5vZGUgPSBwYXJlbnRWbm9kZTtcbiAgb3B0cy5fcGFyZW50RWxtID0gb3B0aW9ucy5fcGFyZW50RWxtO1xuICBvcHRzLl9yZWZFbG0gPSBvcHRpb25zLl9yZWZFbG07XG5cbiAgdmFyIHZub2RlQ29tcG9uZW50T3B0aW9ucyA9IHBhcmVudFZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gIG9wdHMucHJvcHNEYXRhID0gdm5vZGVDb21wb25lbnRPcHRpb25zLnByb3BzRGF0YTtcbiAgb3B0cy5fcGFyZW50TGlzdGVuZXJzID0gdm5vZGVDb21wb25lbnRPcHRpb25zLmxpc3RlbmVycztcbiAgb3B0cy5fcmVuZGVyQ2hpbGRyZW4gPSB2bm9kZUNvbXBvbmVudE9wdGlvbnMuY2hpbGRyZW47XG4gIG9wdHMuX2NvbXBvbmVudFRhZyA9IHZub2RlQ29tcG9uZW50T3B0aW9ucy50YWc7XG5cbiAgaWYgKG9wdGlvbnMucmVuZGVyKSB7XG4gICAgb3B0cy5yZW5kZXIgPSBvcHRpb25zLnJlbmRlcjtcbiAgICBvcHRzLnN0YXRpY1JlbmRlckZucyA9IG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMgKEN0b3IpIHtcbiAgdmFyIG9wdGlvbnMgPSBDdG9yLm9wdGlvbnM7XG4gIGlmIChDdG9yLnN1cGVyKSB7XG4gICAgdmFyIHN1cGVyT3B0aW9ucyA9IHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMoQ3Rvci5zdXBlcik7XG4gICAgdmFyIGNhY2hlZFN1cGVyT3B0aW9ucyA9IEN0b3Iuc3VwZXJPcHRpb25zO1xuICAgIGlmIChzdXBlck9wdGlvbnMgIT09IGNhY2hlZFN1cGVyT3B0aW9ucykge1xuICAgICAgLy8gc3VwZXIgb3B0aW9uIGNoYW5nZWQsXG4gICAgICAvLyBuZWVkIHRvIHJlc29sdmUgbmV3IG9wdGlvbnMuXG4gICAgICBDdG9yLnN1cGVyT3B0aW9ucyA9IHN1cGVyT3B0aW9ucztcbiAgICAgIC8vIGNoZWNrIGlmIHRoZXJlIGFyZSBhbnkgbGF0ZS1tb2RpZmllZC9hdHRhY2hlZCBvcHRpb25zICgjNDk3NilcbiAgICAgIHZhciBtb2RpZmllZE9wdGlvbnMgPSByZXNvbHZlTW9kaWZpZWRPcHRpb25zKEN0b3IpO1xuICAgICAgLy8gdXBkYXRlIGJhc2UgZXh0ZW5kIG9wdGlvbnNcbiAgICAgIGlmIChtb2RpZmllZE9wdGlvbnMpIHtcbiAgICAgICAgZXh0ZW5kKEN0b3IuZXh0ZW5kT3B0aW9ucywgbW9kaWZpZWRPcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIG9wdGlvbnMgPSBDdG9yLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoc3VwZXJPcHRpb25zLCBDdG9yLmV4dGVuZE9wdGlvbnMpO1xuICAgICAgaWYgKG9wdGlvbnMubmFtZSkge1xuICAgICAgICBvcHRpb25zLmNvbXBvbmVudHNbb3B0aW9ucy5uYW1lXSA9IEN0b3I7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBvcHRpb25zXG59XG5cbmZ1bmN0aW9uIHJlc29sdmVNb2RpZmllZE9wdGlvbnMgKEN0b3IpIHtcbiAgdmFyIG1vZGlmaWVkO1xuICB2YXIgbGF0ZXN0ID0gQ3Rvci5vcHRpb25zO1xuICB2YXIgZXh0ZW5kZWQgPSBDdG9yLmV4dGVuZE9wdGlvbnM7XG4gIHZhciBzZWFsZWQgPSBDdG9yLnNlYWxlZE9wdGlvbnM7XG4gIGZvciAodmFyIGtleSBpbiBsYXRlc3QpIHtcbiAgICBpZiAobGF0ZXN0W2tleV0gIT09IHNlYWxlZFtrZXldKSB7XG4gICAgICBpZiAoIW1vZGlmaWVkKSB7IG1vZGlmaWVkID0ge307IH1cbiAgICAgIG1vZGlmaWVkW2tleV0gPSBkZWR1cGUobGF0ZXN0W2tleV0sIGV4dGVuZGVkW2tleV0sIHNlYWxlZFtrZXldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1vZGlmaWVkXG59XG5cbmZ1bmN0aW9uIGRlZHVwZSAobGF0ZXN0LCBleHRlbmRlZCwgc2VhbGVkKSB7XG4gIC8vIGNvbXBhcmUgbGF0ZXN0IGFuZCBzZWFsZWQgdG8gZW5zdXJlIGxpZmVjeWNsZSBob29rcyB3b24ndCBiZSBkdXBsaWNhdGVkXG4gIC8vIGJldHdlZW4gbWVyZ2VzXG4gIGlmIChBcnJheS5pc0FycmF5KGxhdGVzdCkpIHtcbiAgICB2YXIgcmVzID0gW107XG4gICAgc2VhbGVkID0gQXJyYXkuaXNBcnJheShzZWFsZWQpID8gc2VhbGVkIDogW3NlYWxlZF07XG4gICAgZXh0ZW5kZWQgPSBBcnJheS5pc0FycmF5KGV4dGVuZGVkKSA/IGV4dGVuZGVkIDogW2V4dGVuZGVkXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhdGVzdC5sZW5ndGg7IGkrKykge1xuICAgICAgLy8gcHVzaCBvcmlnaW5hbCBvcHRpb25zIGFuZCBub3Qgc2VhbGVkIG9wdGlvbnMgdG8gZXhjbHVkZSBkdXBsaWNhdGVkIG9wdGlvbnNcbiAgICAgIGlmIChleHRlbmRlZC5pbmRleE9mKGxhdGVzdFtpXSkgPj0gMCB8fCBzZWFsZWQuaW5kZXhPZihsYXRlc3RbaV0pIDwgMCkge1xuICAgICAgICByZXMucHVzaChsYXRlc3RbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGxhdGVzdFxuICB9XG59XG5cbmZ1bmN0aW9uIFZ1ZSQzIChvcHRpb25zKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgISh0aGlzIGluc3RhbmNlb2YgVnVlJDMpXG4gICkge1xuICAgIHdhcm4oJ1Z1ZSBpcyBhIGNvbnN0cnVjdG9yIGFuZCBzaG91bGQgYmUgY2FsbGVkIHdpdGggdGhlIGBuZXdgIGtleXdvcmQnKTtcbiAgfVxuICB0aGlzLl9pbml0KG9wdGlvbnMpO1xufVxuXG5pbml0TWl4aW4oVnVlJDMpO1xuc3RhdGVNaXhpbihWdWUkMyk7XG5ldmVudHNNaXhpbihWdWUkMyk7XG5saWZlY3ljbGVNaXhpbihWdWUkMyk7XG5yZW5kZXJNaXhpbihWdWUkMyk7XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0VXNlIChWdWUpIHtcbiAgVnVlLnVzZSA9IGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgICB2YXIgaW5zdGFsbGVkUGx1Z2lucyA9ICh0aGlzLl9pbnN0YWxsZWRQbHVnaW5zIHx8ICh0aGlzLl9pbnN0YWxsZWRQbHVnaW5zID0gW10pKTtcbiAgICBpZiAoaW5zdGFsbGVkUGx1Z2lucy5pbmRleE9mKHBsdWdpbikgPiAtMSkge1xuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICAvLyBhZGRpdGlvbmFsIHBhcmFtZXRlcnNcbiAgICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzLCAxKTtcbiAgICBhcmdzLnVuc2hpZnQodGhpcyk7XG4gICAgaWYgKHR5cGVvZiBwbHVnaW4uaW5zdGFsbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcGx1Z2luLmluc3RhbGwuYXBwbHkocGx1Z2luLCBhcmdzKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBwbHVnaW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHBsdWdpbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICB9XG4gICAgaW5zdGFsbGVkUGx1Z2lucy5wdXNoKHBsdWdpbik7XG4gICAgcmV0dXJuIHRoaXNcbiAgfTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRNaXhpbiQxIChWdWUpIHtcbiAgVnVlLm1peGluID0gZnVuY3Rpb24gKG1peGluKSB7XG4gICAgdGhpcy5vcHRpb25zID0gbWVyZ2VPcHRpb25zKHRoaXMub3B0aW9ucywgbWl4aW4pO1xuICAgIHJldHVybiB0aGlzXG4gIH07XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0RXh0ZW5kIChWdWUpIHtcbiAgLyoqXG4gICAqIEVhY2ggaW5zdGFuY2UgY29uc3RydWN0b3IsIGluY2x1ZGluZyBWdWUsIGhhcyBhIHVuaXF1ZVxuICAgKiBjaWQuIFRoaXMgZW5hYmxlcyB1cyB0byBjcmVhdGUgd3JhcHBlZCBcImNoaWxkXG4gICAqIGNvbnN0cnVjdG9yc1wiIGZvciBwcm90b3R5cGFsIGluaGVyaXRhbmNlIGFuZCBjYWNoZSB0aGVtLlxuICAgKi9cbiAgVnVlLmNpZCA9IDA7XG4gIHZhciBjaWQgPSAxO1xuXG4gIC8qKlxuICAgKiBDbGFzcyBpbmhlcml0YW5jZVxuICAgKi9cbiAgVnVlLmV4dGVuZCA9IGZ1bmN0aW9uIChleHRlbmRPcHRpb25zKSB7XG4gICAgZXh0ZW5kT3B0aW9ucyA9IGV4dGVuZE9wdGlvbnMgfHwge307XG4gICAgdmFyIFN1cGVyID0gdGhpcztcbiAgICB2YXIgU3VwZXJJZCA9IFN1cGVyLmNpZDtcbiAgICB2YXIgY2FjaGVkQ3RvcnMgPSBleHRlbmRPcHRpb25zLl9DdG9yIHx8IChleHRlbmRPcHRpb25zLl9DdG9yID0ge30pO1xuICAgIGlmIChjYWNoZWRDdG9yc1tTdXBlcklkXSkge1xuICAgICAgcmV0dXJuIGNhY2hlZEN0b3JzW1N1cGVySWRdXG4gICAgfVxuXG4gICAgdmFyIG5hbWUgPSBleHRlbmRPcHRpb25zLm5hbWUgfHwgU3VwZXIub3B0aW9ucy5uYW1lO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIG5hbWUpIHtcbiAgICAgIHZhbGlkYXRlQ29tcG9uZW50TmFtZShuYW1lKTtcbiAgICB9XG5cbiAgICB2YXIgU3ViID0gZnVuY3Rpb24gVnVlQ29tcG9uZW50IChvcHRpb25zKSB7XG4gICAgICB0aGlzLl9pbml0KG9wdGlvbnMpO1xuICAgIH07XG4gICAgU3ViLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU3VwZXIucHJvdG90eXBlKTtcbiAgICBTdWIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3ViO1xuICAgIFN1Yi5jaWQgPSBjaWQrKztcbiAgICBTdWIub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhcbiAgICAgIFN1cGVyLm9wdGlvbnMsXG4gICAgICBleHRlbmRPcHRpb25zXG4gICAgKTtcbiAgICBTdWJbJ3N1cGVyJ10gPSBTdXBlcjtcblxuICAgIC8vIEZvciBwcm9wcyBhbmQgY29tcHV0ZWQgcHJvcGVydGllcywgd2UgZGVmaW5lIHRoZSBwcm94eSBnZXR0ZXJzIG9uXG4gICAgLy8gdGhlIFZ1ZSBpbnN0YW5jZXMgYXQgZXh0ZW5zaW9uIHRpbWUsIG9uIHRoZSBleHRlbmRlZCBwcm90b3R5cGUuIFRoaXNcbiAgICAvLyBhdm9pZHMgT2JqZWN0LmRlZmluZVByb3BlcnR5IGNhbGxzIGZvciBlYWNoIGluc3RhbmNlIGNyZWF0ZWQuXG4gICAgaWYgKFN1Yi5vcHRpb25zLnByb3BzKSB7XG4gICAgICBpbml0UHJvcHMkMShTdWIpO1xuICAgIH1cbiAgICBpZiAoU3ViLm9wdGlvbnMuY29tcHV0ZWQpIHtcbiAgICAgIGluaXRDb21wdXRlZCQxKFN1Yik7XG4gICAgfVxuXG4gICAgLy8gYWxsb3cgZnVydGhlciBleHRlbnNpb24vbWl4aW4vcGx1Z2luIHVzYWdlXG4gICAgU3ViLmV4dGVuZCA9IFN1cGVyLmV4dGVuZDtcbiAgICBTdWIubWl4aW4gPSBTdXBlci5taXhpbjtcbiAgICBTdWIudXNlID0gU3VwZXIudXNlO1xuXG4gICAgLy8gY3JlYXRlIGFzc2V0IHJlZ2lzdGVycywgc28gZXh0ZW5kZWQgY2xhc3Nlc1xuICAgIC8vIGNhbiBoYXZlIHRoZWlyIHByaXZhdGUgYXNzZXRzIHRvby5cbiAgICBBU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICBTdWJbdHlwZV0gPSBTdXBlclt0eXBlXTtcbiAgICB9KTtcbiAgICAvLyBlbmFibGUgcmVjdXJzaXZlIHNlbGYtbG9va3VwXG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIFN1Yi5vcHRpb25zLmNvbXBvbmVudHNbbmFtZV0gPSBTdWI7XG4gICAgfVxuXG4gICAgLy8ga2VlcCBhIHJlZmVyZW5jZSB0byB0aGUgc3VwZXIgb3B0aW9ucyBhdCBleHRlbnNpb24gdGltZS5cbiAgICAvLyBsYXRlciBhdCBpbnN0YW50aWF0aW9uIHdlIGNhbiBjaGVjayBpZiBTdXBlcidzIG9wdGlvbnMgaGF2ZVxuICAgIC8vIGJlZW4gdXBkYXRlZC5cbiAgICBTdWIuc3VwZXJPcHRpb25zID0gU3VwZXIub3B0aW9ucztcbiAgICBTdWIuZXh0ZW5kT3B0aW9ucyA9IGV4dGVuZE9wdGlvbnM7XG4gICAgU3ViLnNlYWxlZE9wdGlvbnMgPSBleHRlbmQoe30sIFN1Yi5vcHRpb25zKTtcblxuICAgIC8vIGNhY2hlIGNvbnN0cnVjdG9yXG4gICAgY2FjaGVkQ3RvcnNbU3VwZXJJZF0gPSBTdWI7XG4gICAgcmV0dXJuIFN1YlxuICB9O1xufVxuXG5mdW5jdGlvbiBpbml0UHJvcHMkMSAoQ29tcCkge1xuICB2YXIgcHJvcHMgPSBDb21wLm9wdGlvbnMucHJvcHM7XG4gIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgIHByb3h5KENvbXAucHJvdG90eXBlLCBcIl9wcm9wc1wiLCBrZXkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRDb21wdXRlZCQxIChDb21wKSB7XG4gIHZhciBjb21wdXRlZCA9IENvbXAub3B0aW9ucy5jb21wdXRlZDtcbiAgZm9yICh2YXIga2V5IGluIGNvbXB1dGVkKSB7XG4gICAgZGVmaW5lQ29tcHV0ZWQoQ29tcC5wcm90b3R5cGUsIGtleSwgY29tcHV0ZWRba2V5XSk7XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRBc3NldFJlZ2lzdGVycyAoVnVlKSB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYXNzZXQgcmVnaXN0cmF0aW9uIG1ldGhvZHMuXG4gICAqL1xuICBBU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgVnVlW3R5cGVdID0gZnVuY3Rpb24gKFxuICAgICAgaWQsXG4gICAgICBkZWZpbml0aW9uXG4gICAgKSB7XG4gICAgICBpZiAoIWRlZmluaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uc1t0eXBlICsgJ3MnXVtpZF1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB0eXBlID09PSAnY29tcG9uZW50Jykge1xuICAgICAgICAgIHZhbGlkYXRlQ29tcG9uZW50TmFtZShpZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09ICdjb21wb25lbnQnICYmIGlzUGxhaW5PYmplY3QoZGVmaW5pdGlvbikpIHtcbiAgICAgICAgICBkZWZpbml0aW9uLm5hbWUgPSBkZWZpbml0aW9uLm5hbWUgfHwgaWQ7XG4gICAgICAgICAgZGVmaW5pdGlvbiA9IHRoaXMub3B0aW9ucy5fYmFzZS5leHRlbmQoZGVmaW5pdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09ICdkaXJlY3RpdmUnICYmIHR5cGVvZiBkZWZpbml0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgZGVmaW5pdGlvbiA9IHsgYmluZDogZGVmaW5pdGlvbiwgdXBkYXRlOiBkZWZpbml0aW9uIH07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vcHRpb25zW3R5cGUgKyAncyddW2lkXSA9IGRlZmluaXRpb247XG4gICAgICAgIHJldHVybiBkZWZpbml0aW9uXG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lIChvcHRzKSB7XG4gIHJldHVybiBvcHRzICYmIChvcHRzLkN0b3Iub3B0aW9ucy5uYW1lIHx8IG9wdHMudGFnKVxufVxuXG5mdW5jdGlvbiBtYXRjaGVzIChwYXR0ZXJuLCBuYW1lKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHBhdHRlcm4pKSB7XG4gICAgcmV0dXJuIHBhdHRlcm4uaW5kZXhPZihuYW1lKSA+IC0xXG4gIH0gZWxzZSBpZiAodHlwZW9mIHBhdHRlcm4gPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHBhdHRlcm4uc3BsaXQoJywnKS5pbmRleE9mKG5hbWUpID4gLTFcbiAgfSBlbHNlIGlmIChpc1JlZ0V4cChwYXR0ZXJuKSkge1xuICAgIHJldHVybiBwYXR0ZXJuLnRlc3QobmFtZSlcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gcHJ1bmVDYWNoZSAoa2VlcEFsaXZlSW5zdGFuY2UsIGZpbHRlcikge1xuICB2YXIgY2FjaGUgPSBrZWVwQWxpdmVJbnN0YW5jZS5jYWNoZTtcbiAgdmFyIGtleXMgPSBrZWVwQWxpdmVJbnN0YW5jZS5rZXlzO1xuICB2YXIgX3Zub2RlID0ga2VlcEFsaXZlSW5zdGFuY2UuX3Zub2RlO1xuICBmb3IgKHZhciBrZXkgaW4gY2FjaGUpIHtcbiAgICB2YXIgY2FjaGVkTm9kZSA9IGNhY2hlW2tleV07XG4gICAgaWYgKGNhY2hlZE5vZGUpIHtcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShjYWNoZWROb2RlLmNvbXBvbmVudE9wdGlvbnMpO1xuICAgICAgaWYgKG5hbWUgJiYgIWZpbHRlcihuYW1lKSkge1xuICAgICAgICBwcnVuZUNhY2hlRW50cnkoY2FjaGUsIGtleSwga2V5cywgX3Zub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJ1bmVDYWNoZUVudHJ5IChcbiAgY2FjaGUsXG4gIGtleSxcbiAga2V5cyxcbiAgY3VycmVudFxuKSB7XG4gIHZhciBjYWNoZWQkJDEgPSBjYWNoZVtrZXldO1xuICBpZiAoY2FjaGVkJCQxICYmICghY3VycmVudCB8fCBjYWNoZWQkJDEudGFnICE9PSBjdXJyZW50LnRhZykpIHtcbiAgICBjYWNoZWQkJDEuY29tcG9uZW50SW5zdGFuY2UuJGRlc3Ryb3koKTtcbiAgfVxuICBjYWNoZVtrZXldID0gbnVsbDtcbiAgcmVtb3ZlKGtleXMsIGtleSk7XG59XG5cbnZhciBwYXR0ZXJuVHlwZXMgPSBbU3RyaW5nLCBSZWdFeHAsIEFycmF5XTtcblxudmFyIEtlZXBBbGl2ZSA9IHtcbiAgbmFtZTogJ2tlZXAtYWxpdmUnLFxuICBhYnN0cmFjdDogdHJ1ZSxcblxuICBwcm9wczoge1xuICAgIGluY2x1ZGU6IHBhdHRlcm5UeXBlcyxcbiAgICBleGNsdWRlOiBwYXR0ZXJuVHlwZXMsXG4gICAgbWF4OiBbU3RyaW5nLCBOdW1iZXJdXG4gIH0sXG5cbiAgY3JlYXRlZDogZnVuY3Rpb24gY3JlYXRlZCAoKSB7XG4gICAgdGhpcy5jYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5rZXlzID0gW107XG4gIH0sXG5cbiAgZGVzdHJveWVkOiBmdW5jdGlvbiBkZXN0cm95ZWQgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgZm9yICh2YXIga2V5IGluIHRoaXMkMS5jYWNoZSkge1xuICAgICAgcHJ1bmVDYWNoZUVudHJ5KHRoaXMkMS5jYWNoZSwga2V5LCB0aGlzJDEua2V5cyk7XG4gICAgfVxuICB9LFxuXG4gIHdhdGNoOiB7XG4gICAgaW5jbHVkZTogZnVuY3Rpb24gaW5jbHVkZSAodmFsKSB7XG4gICAgICBwcnVuZUNhY2hlKHRoaXMsIGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBtYXRjaGVzKHZhbCwgbmFtZSk7IH0pO1xuICAgIH0sXG4gICAgZXhjbHVkZTogZnVuY3Rpb24gZXhjbHVkZSAodmFsKSB7XG4gICAgICBwcnVuZUNhY2hlKHRoaXMsIGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiAhbWF0Y2hlcyh2YWwsIG5hbWUpOyB9KTtcbiAgICB9XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKCkge1xuICAgIHZhciBzbG90ID0gdGhpcy4kc2xvdHMuZGVmYXVsdDtcbiAgICB2YXIgdm5vZGUgPSBnZXRGaXJzdENvbXBvbmVudENoaWxkKHNsb3QpO1xuICAgIHZhciBjb21wb25lbnRPcHRpb25zID0gdm5vZGUgJiYgdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgICBpZiAoY29tcG9uZW50T3B0aW9ucykge1xuICAgICAgLy8gY2hlY2sgcGF0dGVyblxuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKGNvbXBvbmVudE9wdGlvbnMpO1xuICAgICAgdmFyIHJlZiA9IHRoaXM7XG4gICAgICB2YXIgaW5jbHVkZSA9IHJlZi5pbmNsdWRlO1xuICAgICAgdmFyIGV4Y2x1ZGUgPSByZWYuZXhjbHVkZTtcbiAgICAgIGlmIChcbiAgICAgICAgLy8gbm90IGluY2x1ZGVkXG4gICAgICAgIChpbmNsdWRlICYmICghbmFtZSB8fCAhbWF0Y2hlcyhpbmNsdWRlLCBuYW1lKSkpIHx8XG4gICAgICAgIC8vIGV4Y2x1ZGVkXG4gICAgICAgIChleGNsdWRlICYmIG5hbWUgJiYgbWF0Y2hlcyhleGNsdWRlLCBuYW1lKSlcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gdm5vZGVcbiAgICAgIH1cblxuICAgICAgdmFyIHJlZiQxID0gdGhpcztcbiAgICAgIHZhciBjYWNoZSA9IHJlZiQxLmNhY2hlO1xuICAgICAgdmFyIGtleXMgPSByZWYkMS5rZXlzO1xuICAgICAgdmFyIGtleSA9IHZub2RlLmtleSA9PSBudWxsXG4gICAgICAgIC8vIHNhbWUgY29uc3RydWN0b3IgbWF5IGdldCByZWdpc3RlcmVkIGFzIGRpZmZlcmVudCBsb2NhbCBjb21wb25lbnRzXG4gICAgICAgIC8vIHNvIGNpZCBhbG9uZSBpcyBub3QgZW5vdWdoICgjMzI2OSlcbiAgICAgICAgPyBjb21wb25lbnRPcHRpb25zLkN0b3IuY2lkICsgKGNvbXBvbmVudE9wdGlvbnMudGFnID8gKFwiOjpcIiArIChjb21wb25lbnRPcHRpb25zLnRhZykpIDogJycpXG4gICAgICAgIDogdm5vZGUua2V5O1xuICAgICAgaWYgKGNhY2hlW2tleV0pIHtcbiAgICAgICAgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBjYWNoZVtrZXldLmNvbXBvbmVudEluc3RhbmNlO1xuICAgICAgICAvLyBtYWtlIGN1cnJlbnQga2V5IGZyZXNoZXN0XG4gICAgICAgIHJlbW92ZShrZXlzLCBrZXkpO1xuICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhY2hlW2tleV0gPSB2bm9kZTtcbiAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgIC8vIHBydW5lIG9sZGVzdCBlbnRyeVxuICAgICAgICBpZiAodGhpcy5tYXggJiYga2V5cy5sZW5ndGggPiBwYXJzZUludCh0aGlzLm1heCkpIHtcbiAgICAgICAgICBwcnVuZUNhY2hlRW50cnkoY2FjaGUsIGtleXNbMF0sIGtleXMsIHRoaXMuX3Zub2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2bm9kZS5kYXRhLmtlZXBBbGl2ZSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiB2bm9kZSB8fCAoc2xvdCAmJiBzbG90WzBdKVxuICB9XG59O1xuXG52YXIgYnVpbHRJbkNvbXBvbmVudHMgPSB7XG4gIEtlZXBBbGl2ZTogS2VlcEFsaXZlXG59O1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEdsb2JhbEFQSSAoVnVlKSB7XG4gIC8vIGNvbmZpZ1xuICB2YXIgY29uZmlnRGVmID0ge307XG4gIGNvbmZpZ0RlZi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25maWc7IH07XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgY29uZmlnRGVmLnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdEbyBub3QgcmVwbGFjZSB0aGUgVnVlLmNvbmZpZyBvYmplY3QsIHNldCBpbmRpdmlkdWFsIGZpZWxkcyBpbnN0ZWFkLidcbiAgICAgICk7XG4gICAgfTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLCAnY29uZmlnJywgY29uZmlnRGVmKTtcblxuICAvLyBleHBvc2VkIHV0aWwgbWV0aG9kcy5cbiAgLy8gTk9URTogdGhlc2UgYXJlIG5vdCBjb25zaWRlcmVkIHBhcnQgb2YgdGhlIHB1YmxpYyBBUEkgLSBhdm9pZCByZWx5aW5nIG9uXG4gIC8vIHRoZW0gdW5sZXNzIHlvdSBhcmUgYXdhcmUgb2YgdGhlIHJpc2suXG4gIFZ1ZS51dGlsID0ge1xuICAgIHdhcm46IHdhcm4sXG4gICAgZXh0ZW5kOiBleHRlbmQsXG4gICAgbWVyZ2VPcHRpb25zOiBtZXJnZU9wdGlvbnMsXG4gICAgZGVmaW5lUmVhY3RpdmU6IGRlZmluZVJlYWN0aXZlXG4gIH07XG5cbiAgVnVlLnNldCA9IHNldDtcbiAgVnVlLmRlbGV0ZSA9IGRlbDtcbiAgVnVlLm5leHRUaWNrID0gbmV4dFRpY2s7XG5cbiAgVnVlLm9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBBU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgVnVlLm9wdGlvbnNbdHlwZSArICdzJ10gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9KTtcblxuICAvLyB0aGlzIGlzIHVzZWQgdG8gaWRlbnRpZnkgdGhlIFwiYmFzZVwiIGNvbnN0cnVjdG9yIHRvIGV4dGVuZCBhbGwgcGxhaW4tb2JqZWN0XG4gIC8vIGNvbXBvbmVudHMgd2l0aCBpbiBXZWV4J3MgbXVsdGktaW5zdGFuY2Ugc2NlbmFyaW9zLlxuICBWdWUub3B0aW9ucy5fYmFzZSA9IFZ1ZTtcblxuICBleHRlbmQoVnVlLm9wdGlvbnMuY29tcG9uZW50cywgYnVpbHRJbkNvbXBvbmVudHMpO1xuXG4gIGluaXRVc2UoVnVlKTtcbiAgaW5pdE1peGluJDEoVnVlKTtcbiAgaW5pdEV4dGVuZChWdWUpO1xuICBpbml0QXNzZXRSZWdpc3RlcnMoVnVlKTtcbn1cblxuaW5pdEdsb2JhbEFQSShWdWUkMyk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUkMy5wcm90b3R5cGUsICckaXNTZXJ2ZXInLCB7XG4gIGdldDogaXNTZXJ2ZXJSZW5kZXJpbmdcbn0pO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlJDMucHJvdG90eXBlLCAnJHNzckNvbnRleHQnLCB7XG4gIGdldDogZnVuY3Rpb24gZ2V0ICgpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHJldHVybiB0aGlzLiR2bm9kZSAmJiB0aGlzLiR2bm9kZS5zc3JDb250ZXh0XG4gIH1cbn0pO1xuXG5WdWUkMy52ZXJzaW9uID0gJzIuNS4xMyc7XG5cbi8qICAqL1xuXG4vLyB0aGVzZSBhcmUgcmVzZXJ2ZWQgZm9yIHdlYiBiZWNhdXNlIHRoZXkgYXJlIGRpcmVjdGx5IGNvbXBpbGVkIGF3YXlcbi8vIGR1cmluZyB0ZW1wbGF0ZSBjb21waWxhdGlvblxudmFyIGlzUmVzZXJ2ZWRBdHRyID0gbWFrZU1hcCgnc3R5bGUsY2xhc3MnKTtcblxuLy8gYXR0cmlidXRlcyB0aGF0IHNob3VsZCBiZSB1c2luZyBwcm9wcyBmb3IgYmluZGluZ1xudmFyIGFjY2VwdFZhbHVlID0gbWFrZU1hcCgnaW5wdXQsdGV4dGFyZWEsb3B0aW9uLHNlbGVjdCxwcm9ncmVzcycpO1xudmFyIG11c3RVc2VQcm9wID0gZnVuY3Rpb24gKHRhZywgdHlwZSwgYXR0cikge1xuICByZXR1cm4gKFxuICAgIChhdHRyID09PSAndmFsdWUnICYmIGFjY2VwdFZhbHVlKHRhZykpICYmIHR5cGUgIT09ICdidXR0b24nIHx8XG4gICAgKGF0dHIgPT09ICdzZWxlY3RlZCcgJiYgdGFnID09PSAnb3B0aW9uJykgfHxcbiAgICAoYXR0ciA9PT0gJ2NoZWNrZWQnICYmIHRhZyA9PT0gJ2lucHV0JykgfHxcbiAgICAoYXR0ciA9PT0gJ211dGVkJyAmJiB0YWcgPT09ICd2aWRlbycpXG4gIClcbn07XG5cbnZhciBpc0VudW1lcmF0ZWRBdHRyID0gbWFrZU1hcCgnY29udGVudGVkaXRhYmxlLGRyYWdnYWJsZSxzcGVsbGNoZWNrJyk7XG5cbnZhciBpc0Jvb2xlYW5BdHRyID0gbWFrZU1hcChcbiAgJ2FsbG93ZnVsbHNjcmVlbixhc3luYyxhdXRvZm9jdXMsYXV0b3BsYXksY2hlY2tlZCxjb21wYWN0LGNvbnRyb2xzLGRlY2xhcmUsJyArXG4gICdkZWZhdWx0LGRlZmF1bHRjaGVja2VkLGRlZmF1bHRtdXRlZCxkZWZhdWx0c2VsZWN0ZWQsZGVmZXIsZGlzYWJsZWQsJyArXG4gICdlbmFibGVkLGZvcm1ub3ZhbGlkYXRlLGhpZGRlbixpbmRldGVybWluYXRlLGluZXJ0LGlzbWFwLGl0ZW1zY29wZSxsb29wLG11bHRpcGxlLCcgK1xuICAnbXV0ZWQsbm9ocmVmLG5vcmVzaXplLG5vc2hhZGUsbm92YWxpZGF0ZSxub3dyYXAsb3BlbixwYXVzZW9uZXhpdCxyZWFkb25seSwnICtcbiAgJ3JlcXVpcmVkLHJldmVyc2VkLHNjb3BlZCxzZWFtbGVzcyxzZWxlY3RlZCxzb3J0YWJsZSx0cmFuc2xhdGUsJyArXG4gICd0cnVlc3BlZWQsdHlwZW11c3RtYXRjaCx2aXNpYmxlJ1xuKTtcblxudmFyIHhsaW5rTlMgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayc7XG5cbnZhciBpc1hsaW5rID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIG5hbWUuY2hhckF0KDUpID09PSAnOicgJiYgbmFtZS5zbGljZSgwLCA1KSA9PT0gJ3hsaW5rJ1xufTtcblxudmFyIGdldFhsaW5rUHJvcCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBpc1hsaW5rKG5hbWUpID8gbmFtZS5zbGljZSg2LCBuYW1lLmxlbmd0aCkgOiAnJ1xufTtcblxudmFyIGlzRmFsc3lBdHRyVmFsdWUgPSBmdW5jdGlvbiAodmFsKSB7XG4gIHJldHVybiB2YWwgPT0gbnVsbCB8fCB2YWwgPT09IGZhbHNlXG59O1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gZ2VuQ2xhc3NGb3JWbm9kZSAodm5vZGUpIHtcbiAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICB2YXIgcGFyZW50Tm9kZSA9IHZub2RlO1xuICB2YXIgY2hpbGROb2RlID0gdm5vZGU7XG4gIHdoaWxlIChpc0RlZihjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UpKSB7XG4gICAgY2hpbGROb2RlID0gY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICBpZiAoY2hpbGROb2RlICYmIGNoaWxkTm9kZS5kYXRhKSB7XG4gICAgICBkYXRhID0gbWVyZ2VDbGFzc0RhdGEoY2hpbGROb2RlLmRhdGEsIGRhdGEpO1xuICAgIH1cbiAgfVxuICB3aGlsZSAoaXNEZWYocGFyZW50Tm9kZSA9IHBhcmVudE5vZGUucGFyZW50KSkge1xuICAgIGlmIChwYXJlbnROb2RlICYmIHBhcmVudE5vZGUuZGF0YSkge1xuICAgICAgZGF0YSA9IG1lcmdlQ2xhc3NEYXRhKGRhdGEsIHBhcmVudE5vZGUuZGF0YSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZW5kZXJDbGFzcyhkYXRhLnN0YXRpY0NsYXNzLCBkYXRhLmNsYXNzKVxufVxuXG5mdW5jdGlvbiBtZXJnZUNsYXNzRGF0YSAoY2hpbGQsIHBhcmVudCkge1xuICByZXR1cm4ge1xuICAgIHN0YXRpY0NsYXNzOiBjb25jYXQoY2hpbGQuc3RhdGljQ2xhc3MsIHBhcmVudC5zdGF0aWNDbGFzcyksXG4gICAgY2xhc3M6IGlzRGVmKGNoaWxkLmNsYXNzKVxuICAgICAgPyBbY2hpbGQuY2xhc3MsIHBhcmVudC5jbGFzc11cbiAgICAgIDogcGFyZW50LmNsYXNzXG4gIH1cbn1cblxuZnVuY3Rpb24gcmVuZGVyQ2xhc3MgKFxuICBzdGF0aWNDbGFzcyxcbiAgZHluYW1pY0NsYXNzXG4pIHtcbiAgaWYgKGlzRGVmKHN0YXRpY0NsYXNzKSB8fCBpc0RlZihkeW5hbWljQ2xhc3MpKSB7XG4gICAgcmV0dXJuIGNvbmNhdChzdGF0aWNDbGFzcywgc3RyaW5naWZ5Q2xhc3MoZHluYW1pY0NsYXNzKSlcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICByZXR1cm4gJydcbn1cblxuZnVuY3Rpb24gY29uY2F0IChhLCBiKSB7XG4gIHJldHVybiBhID8gYiA/IChhICsgJyAnICsgYikgOiBhIDogKGIgfHwgJycpXG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeUNsYXNzICh2YWx1ZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gc3RyaW5naWZ5QXJyYXkodmFsdWUpXG4gIH1cbiAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiBzdHJpbmdpZnlPYmplY3QodmFsdWUpXG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICByZXR1cm4gJydcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5QXJyYXkgKHZhbHVlKSB7XG4gIHZhciByZXMgPSAnJztcbiAgdmFyIHN0cmluZ2lmaWVkO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmIChpc0RlZihzdHJpbmdpZmllZCA9IHN0cmluZ2lmeUNsYXNzKHZhbHVlW2ldKSkgJiYgc3RyaW5naWZpZWQgIT09ICcnKSB7XG4gICAgICBpZiAocmVzKSB7IHJlcyArPSAnICc7IH1cbiAgICAgIHJlcyArPSBzdHJpbmdpZmllZDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnlPYmplY3QgKHZhbHVlKSB7XG4gIHZhciByZXMgPSAnJztcbiAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlW2tleV0pIHtcbiAgICAgIGlmIChyZXMpIHsgcmVzICs9ICcgJzsgfVxuICAgICAgcmVzICs9IGtleTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxudmFyIG5hbWVzcGFjZU1hcCA9IHtcbiAgc3ZnOiAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLFxuICBtYXRoOiAnaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTCdcbn07XG5cbnZhciBpc0hUTUxUYWcgPSBtYWtlTWFwKFxuICAnaHRtbCxib2R5LGJhc2UsaGVhZCxsaW5rLG1ldGEsc3R5bGUsdGl0bGUsJyArXG4gICdhZGRyZXNzLGFydGljbGUsYXNpZGUsZm9vdGVyLGhlYWRlcixoMSxoMixoMyxoNCxoNSxoNixoZ3JvdXAsbmF2LHNlY3Rpb24sJyArXG4gICdkaXYsZGQsZGwsZHQsZmlnY2FwdGlvbixmaWd1cmUscGljdHVyZSxocixpbWcsbGksbWFpbixvbCxwLHByZSx1bCwnICtcbiAgJ2EsYixhYmJyLGJkaSxiZG8sYnIsY2l0ZSxjb2RlLGRhdGEsZGZuLGVtLGksa2JkLG1hcmsscSxycCxydCxydGMscnVieSwnICtcbiAgJ3Msc2FtcCxzbWFsbCxzcGFuLHN0cm9uZyxzdWIsc3VwLHRpbWUsdSx2YXIsd2JyLGFyZWEsYXVkaW8sbWFwLHRyYWNrLHZpZGVvLCcgK1xuICAnZW1iZWQsb2JqZWN0LHBhcmFtLHNvdXJjZSxjYW52YXMsc2NyaXB0LG5vc2NyaXB0LGRlbCxpbnMsJyArXG4gICdjYXB0aW9uLGNvbCxjb2xncm91cCx0YWJsZSx0aGVhZCx0Ym9keSx0ZCx0aCx0ciwnICtcbiAgJ2J1dHRvbixkYXRhbGlzdCxmaWVsZHNldCxmb3JtLGlucHV0LGxhYmVsLGxlZ2VuZCxtZXRlcixvcHRncm91cCxvcHRpb24sJyArXG4gICdvdXRwdXQscHJvZ3Jlc3Msc2VsZWN0LHRleHRhcmVhLCcgK1xuICAnZGV0YWlscyxkaWFsb2csbWVudSxtZW51aXRlbSxzdW1tYXJ5LCcgK1xuICAnY29udGVudCxlbGVtZW50LHNoYWRvdyx0ZW1wbGF0ZSxibG9ja3F1b3RlLGlmcmFtZSx0Zm9vdCdcbik7XG5cbi8vIHRoaXMgbWFwIGlzIGludGVudGlvbmFsbHkgc2VsZWN0aXZlLCBvbmx5IGNvdmVyaW5nIFNWRyBlbGVtZW50cyB0aGF0IG1heVxuLy8gY29udGFpbiBjaGlsZCBlbGVtZW50cy5cbnZhciBpc1NWRyA9IG1ha2VNYXAoXG4gICdzdmcsYW5pbWF0ZSxjaXJjbGUsY2xpcHBhdGgsY3Vyc29yLGRlZnMsZGVzYyxlbGxpcHNlLGZpbHRlcixmb250LWZhY2UsJyArXG4gICdmb3JlaWduT2JqZWN0LGcsZ2x5cGgsaW1hZ2UsbGluZSxtYXJrZXIsbWFzayxtaXNzaW5nLWdseXBoLHBhdGgscGF0dGVybiwnICtcbiAgJ3BvbHlnb24scG9seWxpbmUscmVjdCxzd2l0Y2gsc3ltYm9sLHRleHQsdGV4dHBhdGgsdHNwYW4sdXNlLHZpZXcnLFxuICB0cnVlXG4pO1xuXG5cblxudmFyIGlzUmVzZXJ2ZWRUYWcgPSBmdW5jdGlvbiAodGFnKSB7XG4gIHJldHVybiBpc0hUTUxUYWcodGFnKSB8fCBpc1NWRyh0YWcpXG59O1xuXG5mdW5jdGlvbiBnZXRUYWdOYW1lc3BhY2UgKHRhZykge1xuICBpZiAoaXNTVkcodGFnKSkge1xuICAgIHJldHVybiAnc3ZnJ1xuICB9XG4gIC8vIGJhc2ljIHN1cHBvcnQgZm9yIE1hdGhNTFxuICAvLyBub3RlIGl0IGRvZXNuJ3Qgc3VwcG9ydCBvdGhlciBNYXRoTUwgZWxlbWVudHMgYmVpbmcgY29tcG9uZW50IHJvb3RzXG4gIGlmICh0YWcgPT09ICdtYXRoJykge1xuICAgIHJldHVybiAnbWF0aCdcbiAgfVxufVxuXG52YXIgdW5rbm93bkVsZW1lbnRDYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5mdW5jdGlvbiBpc1Vua25vd25FbGVtZW50ICh0YWcpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICghaW5Ccm93c2VyKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICBpZiAoaXNSZXNlcnZlZFRhZyh0YWcpKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgdGFnID0gdGFnLnRvTG93ZXJDYXNlKCk7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAodW5rbm93bkVsZW1lbnRDYWNoZVt0YWddICE9IG51bGwpIHtcbiAgICByZXR1cm4gdW5rbm93bkVsZW1lbnRDYWNoZVt0YWddXG4gIH1cbiAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICBpZiAodGFnLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjgyMTAzNjQvMTA3MDI0NFxuICAgIHJldHVybiAodW5rbm93bkVsZW1lbnRDYWNoZVt0YWddID0gKFxuICAgICAgZWwuY29uc3RydWN0b3IgPT09IHdpbmRvdy5IVE1MVW5rbm93bkVsZW1lbnQgfHxcbiAgICAgIGVsLmNvbnN0cnVjdG9yID09PSB3aW5kb3cuSFRNTEVsZW1lbnRcbiAgICApKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiAodW5rbm93bkVsZW1lbnRDYWNoZVt0YWddID0gL0hUTUxVbmtub3duRWxlbWVudC8udGVzdChlbC50b1N0cmluZygpKSlcbiAgfVxufVxuXG52YXIgaXNUZXh0SW5wdXRUeXBlID0gbWFrZU1hcCgndGV4dCxudW1iZXIscGFzc3dvcmQsc2VhcmNoLGVtYWlsLHRlbCx1cmwnKTtcblxuLyogICovXG5cbi8qKlxuICogUXVlcnkgYW4gZWxlbWVudCBzZWxlY3RvciBpZiBpdCdzIG5vdCBhbiBlbGVtZW50IGFscmVhZHkuXG4gKi9cbmZ1bmN0aW9uIHF1ZXJ5IChlbCkge1xuICBpZiAodHlwZW9mIGVsID09PSAnc3RyaW5nJykge1xuICAgIHZhciBzZWxlY3RlZCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoZWwpO1xuICAgIGlmICghc2VsZWN0ZWQpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgJ0Nhbm5vdCBmaW5kIGVsZW1lbnQ6ICcgKyBlbFxuICAgICAgKTtcbiAgICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgIH1cbiAgICByZXR1cm4gc2VsZWN0ZWRcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZWxcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCQxICh0YWdOYW1lLCB2bm9kZSkge1xuICB2YXIgZWxtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcbiAgaWYgKHRhZ05hbWUgIT09ICdzZWxlY3QnKSB7XG4gICAgcmV0dXJuIGVsbVxuICB9XG4gIC8vIGZhbHNlIG9yIG51bGwgd2lsbCByZW1vdmUgdGhlIGF0dHJpYnV0ZSBidXQgdW5kZWZpbmVkIHdpbGwgbm90XG4gIGlmICh2bm9kZS5kYXRhICYmIHZub2RlLmRhdGEuYXR0cnMgJiYgdm5vZGUuZGF0YS5hdHRycy5tdWx0aXBsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZWxtLnNldEF0dHJpYnV0ZSgnbXVsdGlwbGUnLCAnbXVsdGlwbGUnKTtcbiAgfVxuICByZXR1cm4gZWxtXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnROUyAobmFtZXNwYWNlLCB0YWdOYW1lKSB7XG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobmFtZXNwYWNlTWFwW25hbWVzcGFjZV0sIHRhZ05hbWUpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRleHROb2RlICh0ZXh0KSB7XG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0ZXh0KVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21tZW50ICh0ZXh0KSB7XG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVDb21tZW50KHRleHQpXG59XG5cbmZ1bmN0aW9uIGluc2VydEJlZm9yZSAocGFyZW50Tm9kZSwgbmV3Tm9kZSwgcmVmZXJlbmNlTm9kZSkge1xuICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShuZXdOb2RlLCByZWZlcmVuY2VOb2RlKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlQ2hpbGQgKG5vZGUsIGNoaWxkKSB7XG4gIG5vZGUucmVtb3ZlQ2hpbGQoY2hpbGQpO1xufVxuXG5mdW5jdGlvbiBhcHBlbmRDaGlsZCAobm9kZSwgY2hpbGQpIHtcbiAgbm9kZS5hcHBlbmRDaGlsZChjaGlsZCk7XG59XG5cbmZ1bmN0aW9uIHBhcmVudE5vZGUgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUucGFyZW50Tm9kZVxufVxuXG5mdW5jdGlvbiBuZXh0U2libGluZyAobm9kZSkge1xuICByZXR1cm4gbm9kZS5uZXh0U2libGluZ1xufVxuXG5mdW5jdGlvbiB0YWdOYW1lIChub2RlKSB7XG4gIHJldHVybiBub2RlLnRhZ05hbWVcbn1cblxuZnVuY3Rpb24gc2V0VGV4dENvbnRlbnQgKG5vZGUsIHRleHQpIHtcbiAgbm9kZS50ZXh0Q29udGVudCA9IHRleHQ7XG59XG5cbmZ1bmN0aW9uIHNldEF0dHJpYnV0ZSAobm9kZSwga2V5LCB2YWwpIHtcbiAgbm9kZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWwpO1xufVxuXG5cbnZhciBub2RlT3BzID0gT2JqZWN0LmZyZWV6ZSh7XG5cdGNyZWF0ZUVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnQkMSxcblx0Y3JlYXRlRWxlbWVudE5TOiBjcmVhdGVFbGVtZW50TlMsXG5cdGNyZWF0ZVRleHROb2RlOiBjcmVhdGVUZXh0Tm9kZSxcblx0Y3JlYXRlQ29tbWVudDogY3JlYXRlQ29tbWVudCxcblx0aW5zZXJ0QmVmb3JlOiBpbnNlcnRCZWZvcmUsXG5cdHJlbW92ZUNoaWxkOiByZW1vdmVDaGlsZCxcblx0YXBwZW5kQ2hpbGQ6IGFwcGVuZENoaWxkLFxuXHRwYXJlbnROb2RlOiBwYXJlbnROb2RlLFxuXHRuZXh0U2libGluZzogbmV4dFNpYmxpbmcsXG5cdHRhZ05hbWU6IHRhZ05hbWUsXG5cdHNldFRleHRDb250ZW50OiBzZXRUZXh0Q29udGVudCxcblx0c2V0QXR0cmlidXRlOiBzZXRBdHRyaWJ1dGVcbn0pO1xuXG4vKiAgKi9cblxudmFyIHJlZiA9IHtcbiAgY3JlYXRlOiBmdW5jdGlvbiBjcmVhdGUgKF8sIHZub2RlKSB7XG4gICAgcmVnaXN0ZXJSZWYodm5vZGUpO1xuICB9LFxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSAob2xkVm5vZGUsIHZub2RlKSB7XG4gICAgaWYgKG9sZFZub2RlLmRhdGEucmVmICE9PSB2bm9kZS5kYXRhLnJlZikge1xuICAgICAgcmVnaXN0ZXJSZWYob2xkVm5vZGUsIHRydWUpO1xuICAgICAgcmVnaXN0ZXJSZWYodm5vZGUpO1xuICAgIH1cbiAgfSxcbiAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSAodm5vZGUpIHtcbiAgICByZWdpc3RlclJlZih2bm9kZSwgdHJ1ZSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHJlZ2lzdGVyUmVmICh2bm9kZSwgaXNSZW1vdmFsKSB7XG4gIHZhciBrZXkgPSB2bm9kZS5kYXRhLnJlZjtcbiAgaWYgKCFrZXkpIHsgcmV0dXJuIH1cblxuICB2YXIgdm0gPSB2bm9kZS5jb250ZXh0O1xuICB2YXIgcmVmID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgfHwgdm5vZGUuZWxtO1xuICB2YXIgcmVmcyA9IHZtLiRyZWZzO1xuICBpZiAoaXNSZW1vdmFsKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocmVmc1trZXldKSkge1xuICAgICAgcmVtb3ZlKHJlZnNba2V5XSwgcmVmKTtcbiAgICB9IGVsc2UgaWYgKHJlZnNba2V5XSA9PT0gcmVmKSB7XG4gICAgICByZWZzW2tleV0gPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICh2bm9kZS5kYXRhLnJlZkluRm9yKSB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkocmVmc1trZXldKSkge1xuICAgICAgICByZWZzW2tleV0gPSBbcmVmXTtcbiAgICAgIH0gZWxzZSBpZiAocmVmc1trZXldLmluZGV4T2YocmVmKSA8IDApIHtcbiAgICAgICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgICAgIHJlZnNba2V5XS5wdXNoKHJlZik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlZnNba2V5XSA9IHJlZjtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBWaXJ0dWFsIERPTSBwYXRjaGluZyBhbGdvcml0aG0gYmFzZWQgb24gU25hYmJkb20gYnlcbiAqIFNpbW9uIEZyaWlzIFZpbmR1bSAoQHBhbGRlcGluZClcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICogaHR0cHM6Ly9naXRodWIuY29tL3BhbGRlcGluZC9zbmFiYmRvbS9ibG9iL21hc3Rlci9MSUNFTlNFXG4gKlxuICogbW9kaWZpZWQgYnkgRXZhbiBZb3UgKEB5eXg5OTA4MDMpXG4gKlxuICogTm90IHR5cGUtY2hlY2tpbmcgdGhpcyBiZWNhdXNlIHRoaXMgZmlsZSBpcyBwZXJmLWNyaXRpY2FsIGFuZCB0aGUgY29zdFxuICogb2YgbWFraW5nIGZsb3cgdW5kZXJzdGFuZCBpdCBpcyBub3Qgd29ydGggaXQuXG4gKi9cblxudmFyIGVtcHR5Tm9kZSA9IG5ldyBWTm9kZSgnJywge30sIFtdKTtcblxudmFyIGhvb2tzID0gWydjcmVhdGUnLCAnYWN0aXZhdGUnLCAndXBkYXRlJywgJ3JlbW92ZScsICdkZXN0cm95J107XG5cbmZ1bmN0aW9uIHNhbWVWbm9kZSAoYSwgYikge1xuICByZXR1cm4gKFxuICAgIGEua2V5ID09PSBiLmtleSAmJiAoXG4gICAgICAoXG4gICAgICAgIGEudGFnID09PSBiLnRhZyAmJlxuICAgICAgICBhLmlzQ29tbWVudCA9PT0gYi5pc0NvbW1lbnQgJiZcbiAgICAgICAgaXNEZWYoYS5kYXRhKSA9PT0gaXNEZWYoYi5kYXRhKSAmJlxuICAgICAgICBzYW1lSW5wdXRUeXBlKGEsIGIpXG4gICAgICApIHx8IChcbiAgICAgICAgaXNUcnVlKGEuaXNBc3luY1BsYWNlaG9sZGVyKSAmJlxuICAgICAgICBhLmFzeW5jRmFjdG9yeSA9PT0gYi5hc3luY0ZhY3RvcnkgJiZcbiAgICAgICAgaXNVbmRlZihiLmFzeW5jRmFjdG9yeS5lcnJvcilcbiAgICAgIClcbiAgICApXG4gIClcbn1cblxuZnVuY3Rpb24gc2FtZUlucHV0VHlwZSAoYSwgYikge1xuICBpZiAoYS50YWcgIT09ICdpbnB1dCcpIHsgcmV0dXJuIHRydWUgfVxuICB2YXIgaTtcbiAgdmFyIHR5cGVBID0gaXNEZWYoaSA9IGEuZGF0YSkgJiYgaXNEZWYoaSA9IGkuYXR0cnMpICYmIGkudHlwZTtcbiAgdmFyIHR5cGVCID0gaXNEZWYoaSA9IGIuZGF0YSkgJiYgaXNEZWYoaSA9IGkuYXR0cnMpICYmIGkudHlwZTtcbiAgcmV0dXJuIHR5cGVBID09PSB0eXBlQiB8fCBpc1RleHRJbnB1dFR5cGUodHlwZUEpICYmIGlzVGV4dElucHV0VHlwZSh0eXBlQilcbn1cblxuZnVuY3Rpb24gY3JlYXRlS2V5VG9PbGRJZHggKGNoaWxkcmVuLCBiZWdpbklkeCwgZW5kSWR4KSB7XG4gIHZhciBpLCBrZXk7XG4gIHZhciBtYXAgPSB7fTtcbiAgZm9yIChpID0gYmVnaW5JZHg7IGkgPD0gZW5kSWR4OyArK2kpIHtcbiAgICBrZXkgPSBjaGlsZHJlbltpXS5rZXk7XG4gICAgaWYgKGlzRGVmKGtleSkpIHsgbWFwW2tleV0gPSBpOyB9XG4gIH1cbiAgcmV0dXJuIG1hcFxufVxuXG5mdW5jdGlvbiBjcmVhdGVQYXRjaEZ1bmN0aW9uIChiYWNrZW5kKSB7XG4gIHZhciBpLCBqO1xuICB2YXIgY2JzID0ge307XG5cbiAgdmFyIG1vZHVsZXMgPSBiYWNrZW5kLm1vZHVsZXM7XG4gIHZhciBub2RlT3BzID0gYmFja2VuZC5ub2RlT3BzO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBob29rcy5sZW5ndGg7ICsraSkge1xuICAgIGNic1tob29rc1tpXV0gPSBbXTtcbiAgICBmb3IgKGogPSAwOyBqIDwgbW9kdWxlcy5sZW5ndGg7ICsraikge1xuICAgICAgaWYgKGlzRGVmKG1vZHVsZXNbal1baG9va3NbaV1dKSkge1xuICAgICAgICBjYnNbaG9va3NbaV1dLnB1c2gobW9kdWxlc1tqXVtob29rc1tpXV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGVtcHR5Tm9kZUF0IChlbG0pIHtcbiAgICByZXR1cm4gbmV3IFZOb2RlKG5vZGVPcHMudGFnTmFtZShlbG0pLnRvTG93ZXJDYXNlKCksIHt9LCBbXSwgdW5kZWZpbmVkLCBlbG0pXG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVSbUNiIChjaGlsZEVsbSwgbGlzdGVuZXJzKSB7XG4gICAgZnVuY3Rpb24gcmVtb3ZlICgpIHtcbiAgICAgIGlmICgtLXJlbW92ZS5saXN0ZW5lcnMgPT09IDApIHtcbiAgICAgICAgcmVtb3ZlTm9kZShjaGlsZEVsbSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlbW92ZS5saXN0ZW5lcnMgPSBsaXN0ZW5lcnM7XG4gICAgcmV0dXJuIHJlbW92ZVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlTm9kZSAoZWwpIHtcbiAgICB2YXIgcGFyZW50ID0gbm9kZU9wcy5wYXJlbnROb2RlKGVsKTtcbiAgICAvLyBlbGVtZW50IG1heSBoYXZlIGFscmVhZHkgYmVlbiByZW1vdmVkIGR1ZSB0byB2LWh0bWwgLyB2LXRleHRcbiAgICBpZiAoaXNEZWYocGFyZW50KSkge1xuICAgICAgbm9kZU9wcy5yZW1vdmVDaGlsZChwYXJlbnQsIGVsKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc1Vua25vd25FbGVtZW50JCQxICh2bm9kZSwgaW5WUHJlKSB7XG4gICAgcmV0dXJuIChcbiAgICAgICFpblZQcmUgJiZcbiAgICAgICF2bm9kZS5ucyAmJlxuICAgICAgIShcbiAgICAgICAgY29uZmlnLmlnbm9yZWRFbGVtZW50cy5sZW5ndGggJiZcbiAgICAgICAgY29uZmlnLmlnbm9yZWRFbGVtZW50cy5zb21lKGZ1bmN0aW9uIChpZ25vcmUpIHtcbiAgICAgICAgICByZXR1cm4gaXNSZWdFeHAoaWdub3JlKVxuICAgICAgICAgICAgPyBpZ25vcmUudGVzdCh2bm9kZS50YWcpXG4gICAgICAgICAgICA6IGlnbm9yZSA9PT0gdm5vZGUudGFnXG4gICAgICAgIH0pXG4gICAgICApICYmXG4gICAgICBjb25maWcuaXNVbmtub3duRWxlbWVudCh2bm9kZS50YWcpXG4gICAgKVxuICB9XG5cbiAgdmFyIGNyZWF0aW5nRWxtSW5WUHJlID0gMDtcbiAgZnVuY3Rpb24gY3JlYXRlRWxtICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSwgbmVzdGVkKSB7XG4gICAgdm5vZGUuaXNSb290SW5zZXJ0ID0gIW5lc3RlZDsgLy8gZm9yIHRyYW5zaXRpb24gZW50ZXIgY2hlY2tcbiAgICBpZiAoY3JlYXRlQ29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgIHZhciBjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuO1xuICAgIHZhciB0YWcgPSB2bm9kZS50YWc7XG4gICAgaWYgKGlzRGVmKHRhZykpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmIChkYXRhICYmIGRhdGEucHJlKSB7XG4gICAgICAgICAgY3JlYXRpbmdFbG1JblZQcmUrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNVbmtub3duRWxlbWVudCQkMSh2bm9kZSwgY3JlYXRpbmdFbG1JblZQcmUpKSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgICdVbmtub3duIGN1c3RvbSBlbGVtZW50OiA8JyArIHRhZyArICc+IC0gZGlkIHlvdSAnICtcbiAgICAgICAgICAgICdyZWdpc3RlciB0aGUgY29tcG9uZW50IGNvcnJlY3RseT8gRm9yIHJlY3Vyc2l2ZSBjb21wb25lbnRzLCAnICtcbiAgICAgICAgICAgICdtYWtlIHN1cmUgdG8gcHJvdmlkZSB0aGUgXCJuYW1lXCIgb3B0aW9uLicsXG4gICAgICAgICAgICB2bm9kZS5jb250ZXh0XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdm5vZGUuZWxtID0gdm5vZGUubnNcbiAgICAgICAgPyBub2RlT3BzLmNyZWF0ZUVsZW1lbnROUyh2bm9kZS5ucywgdGFnKVxuICAgICAgICA6IG5vZGVPcHMuY3JlYXRlRWxlbWVudCh0YWcsIHZub2RlKTtcbiAgICAgIHNldFNjb3BlKHZub2RlKTtcblxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICB7XG4gICAgICAgIGNyZWF0ZUNoaWxkcmVuKHZub2RlLCBjaGlsZHJlbiwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICAgICAgaW52b2tlQ3JlYXRlSG9va3Modm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBkYXRhICYmIGRhdGEucHJlKSB7XG4gICAgICAgIGNyZWF0aW5nRWxtSW5WUHJlLS07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1RydWUodm5vZGUuaXNDb21tZW50KSkge1xuICAgICAgdm5vZGUuZWxtID0gbm9kZU9wcy5jcmVhdGVDb21tZW50KHZub2RlLnRleHQpO1xuICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2bm9kZS5lbG0gPSBub2RlT3BzLmNyZWF0ZVRleHROb2RlKHZub2RlLnRleHQpO1xuICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudCAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pIHtcbiAgICB2YXIgaSA9IHZub2RlLmRhdGE7XG4gICAgaWYgKGlzRGVmKGkpKSB7XG4gICAgICB2YXIgaXNSZWFjdGl2YXRlZCA9IGlzRGVmKHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSAmJiBpLmtlZXBBbGl2ZTtcbiAgICAgIGlmIChpc0RlZihpID0gaS5ob29rKSAmJiBpc0RlZihpID0gaS5pbml0KSkge1xuICAgICAgICBpKHZub2RlLCBmYWxzZSAvKiBoeWRyYXRpbmcgKi8sIHBhcmVudEVsbSwgcmVmRWxtKTtcbiAgICAgIH1cbiAgICAgIC8vIGFmdGVyIGNhbGxpbmcgdGhlIGluaXQgaG9vaywgaWYgdGhlIHZub2RlIGlzIGEgY2hpbGQgY29tcG9uZW50XG4gICAgICAvLyBpdCBzaG91bGQndmUgY3JlYXRlZCBhIGNoaWxkIGluc3RhbmNlIGFuZCBtb3VudGVkIGl0LiB0aGUgY2hpbGRcbiAgICAgIC8vIGNvbXBvbmVudCBhbHNvIGhhcyBzZXQgdGhlIHBsYWNlaG9sZGVyIHZub2RlJ3MgZWxtLlxuICAgICAgLy8gaW4gdGhhdCBjYXNlIHdlIGNhbiBqdXN0IHJldHVybiB0aGUgZWxlbWVudCBhbmQgYmUgZG9uZS5cbiAgICAgIGlmIChpc0RlZih2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcbiAgICAgICAgaW5pdENvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgaWYgKGlzVHJ1ZShpc1JlYWN0aXZhdGVkKSkge1xuICAgICAgICAgIHJlYWN0aXZhdGVDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW5pdENvbXBvbmVudCAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIGlmIChpc0RlZih2bm9kZS5kYXRhLnBlbmRpbmdJbnNlcnQpKSB7XG4gICAgICBpbnNlcnRlZFZub2RlUXVldWUucHVzaC5hcHBseShpbnNlcnRlZFZub2RlUXVldWUsIHZub2RlLmRhdGEucGVuZGluZ0luc2VydCk7XG4gICAgICB2bm9kZS5kYXRhLnBlbmRpbmdJbnNlcnQgPSBudWxsO1xuICAgIH1cbiAgICB2bm9kZS5lbG0gPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZS4kZWw7XG4gICAgaWYgKGlzUGF0Y2hhYmxlKHZub2RlKSkge1xuICAgICAgaW52b2tlQ3JlYXRlSG9va3Modm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICBzZXRTY29wZSh2bm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGVtcHR5IGNvbXBvbmVudCByb290LlxuICAgICAgLy8gc2tpcCBhbGwgZWxlbWVudC1yZWxhdGVkIG1vZHVsZXMgZXhjZXB0IGZvciByZWYgKCMzNDU1KVxuICAgICAgcmVnaXN0ZXJSZWYodm5vZGUpO1xuICAgICAgLy8gbWFrZSBzdXJlIHRvIGludm9rZSB0aGUgaW5zZXJ0IGhvb2tcbiAgICAgIGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoKHZub2RlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFjdGl2YXRlQ29tcG9uZW50ICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSkge1xuICAgIHZhciBpO1xuICAgIC8vIGhhY2sgZm9yICM0MzM5OiBhIHJlYWN0aXZhdGVkIGNvbXBvbmVudCB3aXRoIGlubmVyIHRyYW5zaXRpb25cbiAgICAvLyBkb2VzIG5vdCB0cmlnZ2VyIGJlY2F1c2UgdGhlIGlubmVyIG5vZGUncyBjcmVhdGVkIGhvb2tzIGFyZSBub3QgY2FsbGVkXG4gICAgLy8gYWdhaW4uIEl0J3Mgbm90IGlkZWFsIHRvIGludm9sdmUgbW9kdWxlLXNwZWNpZmljIGxvZ2ljIGluIGhlcmUgYnV0XG4gICAgLy8gdGhlcmUgZG9lc24ndCBzZWVtIHRvIGJlIGEgYmV0dGVyIHdheSB0byBkbyBpdC5cbiAgICB2YXIgaW5uZXJOb2RlID0gdm5vZGU7XG4gICAgd2hpbGUgKGlubmVyTm9kZS5jb21wb25lbnRJbnN0YW5jZSkge1xuICAgICAgaW5uZXJOb2RlID0gaW5uZXJOb2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICAgIGlmIChpc0RlZihpID0gaW5uZXJOb2RlLmRhdGEpICYmIGlzRGVmKGkgPSBpLnRyYW5zaXRpb24pKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMuYWN0aXZhdGUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBjYnMuYWN0aXZhdGVbaV0oZW1wdHlOb2RlLCBpbm5lck5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoKGlubmVyTm9kZSk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICAgIC8vIHVubGlrZSBhIG5ld2x5IGNyZWF0ZWQgY29tcG9uZW50LFxuICAgIC8vIGEgcmVhY3RpdmF0ZWQga2VlcC1hbGl2ZSBjb21wb25lbnQgZG9lc24ndCBpbnNlcnQgaXRzZWxmXG4gICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5zZXJ0IChwYXJlbnQsIGVsbSwgcmVmJCQxKSB7XG4gICAgaWYgKGlzRGVmKHBhcmVudCkpIHtcbiAgICAgIGlmIChpc0RlZihyZWYkJDEpKSB7XG4gICAgICAgIGlmIChyZWYkJDEucGFyZW50Tm9kZSA9PT0gcGFyZW50KSB7XG4gICAgICAgICAgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50LCBlbG0sIHJlZiQkMSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGVPcHMuYXBwZW5kQ2hpbGQocGFyZW50LCBlbG0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNoaWxkcmVuICh2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgY2hlY2tEdXBsaWNhdGVLZXlzKGNoaWxkcmVuKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY3JlYXRlRWxtKGNoaWxkcmVuW2ldLCBpbnNlcnRlZFZub2RlUXVldWUsIHZub2RlLmVsbSwgbnVsbCwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1ByaW1pdGl2ZSh2bm9kZS50ZXh0KSkge1xuICAgICAgbm9kZU9wcy5hcHBlbmRDaGlsZCh2bm9kZS5lbG0sIG5vZGVPcHMuY3JlYXRlVGV4dE5vZGUoU3RyaW5nKHZub2RlLnRleHQpKSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNQYXRjaGFibGUgKHZub2RlKSB7XG4gICAgd2hpbGUgKHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgICB2bm9kZSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIGlzRGVmKHZub2RlLnRhZylcbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZUNyZWF0ZUhvb2tzICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgY2JzLmNyZWF0ZS5sZW5ndGg7ICsraSQxKSB7XG4gICAgICBjYnMuY3JlYXRlW2kkMV0oZW1wdHlOb2RlLCB2bm9kZSk7XG4gICAgfVxuICAgIGkgPSB2bm9kZS5kYXRhLmhvb2s7IC8vIFJldXNlIHZhcmlhYmxlXG4gICAgaWYgKGlzRGVmKGkpKSB7XG4gICAgICBpZiAoaXNEZWYoaS5jcmVhdGUpKSB7IGkuY3JlYXRlKGVtcHR5Tm9kZSwgdm5vZGUpOyB9XG4gICAgICBpZiAoaXNEZWYoaS5pbnNlcnQpKSB7IGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoKHZub2RlKTsgfVxuICAgIH1cbiAgfVxuXG4gIC8vIHNldCBzY29wZSBpZCBhdHRyaWJ1dGUgZm9yIHNjb3BlZCBDU1MuXG4gIC8vIHRoaXMgaXMgaW1wbGVtZW50ZWQgYXMgYSBzcGVjaWFsIGNhc2UgdG8gYXZvaWQgdGhlIG92ZXJoZWFkXG4gIC8vIG9mIGdvaW5nIHRocm91Z2ggdGhlIG5vcm1hbCBhdHRyaWJ1dGUgcGF0Y2hpbmcgcHJvY2Vzcy5cbiAgZnVuY3Rpb24gc2V0U2NvcGUgKHZub2RlKSB7XG4gICAgdmFyIGk7XG4gICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5mblNjb3BlSWQpKSB7XG4gICAgICBub2RlT3BzLnNldEF0dHJpYnV0ZSh2bm9kZS5lbG0sIGksICcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGFuY2VzdG9yID0gdm5vZGU7XG4gICAgICB3aGlsZSAoYW5jZXN0b3IpIHtcbiAgICAgICAgaWYgKGlzRGVmKGkgPSBhbmNlc3Rvci5jb250ZXh0KSAmJiBpc0RlZihpID0gaS4kb3B0aW9ucy5fc2NvcGVJZCkpIHtcbiAgICAgICAgICBub2RlT3BzLnNldEF0dHJpYnV0ZSh2bm9kZS5lbG0sIGksICcnKTtcbiAgICAgICAgfVxuICAgICAgICBhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudDtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gZm9yIHNsb3QgY29udGVudCB0aGV5IHNob3VsZCBhbHNvIGdldCB0aGUgc2NvcGVJZCBmcm9tIHRoZSBob3N0IGluc3RhbmNlLlxuICAgIGlmIChpc0RlZihpID0gYWN0aXZlSW5zdGFuY2UpICYmXG4gICAgICBpICE9PSB2bm9kZS5jb250ZXh0ICYmXG4gICAgICBpICE9PSB2bm9kZS5mbkNvbnRleHQgJiZcbiAgICAgIGlzRGVmKGkgPSBpLiRvcHRpb25zLl9zY29wZUlkKVxuICAgICkge1xuICAgICAgbm9kZU9wcy5zZXRBdHRyaWJ1dGUodm5vZGUuZWxtLCBpLCAnJyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYWRkVm5vZGVzIChwYXJlbnRFbG0sIHJlZkVsbSwgdm5vZGVzLCBzdGFydElkeCwgZW5kSWR4LCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBmb3IgKDsgc3RhcnRJZHggPD0gZW5kSWR4OyArK3N0YXJ0SWR4KSB7XG4gICAgICBjcmVhdGVFbG0odm5vZGVzW3N0YXJ0SWR4XSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW52b2tlRGVzdHJveUhvb2sgKHZub2RlKSB7XG4gICAgdmFyIGksIGo7XG4gICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLmRlc3Ryb3kpKSB7IGkodm5vZGUpOyB9XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLmRlc3Ryb3kubGVuZ3RoOyArK2kpIHsgY2JzLmRlc3Ryb3lbaV0odm5vZGUpOyB9XG4gICAgfVxuICAgIGlmIChpc0RlZihpID0gdm5vZGUuY2hpbGRyZW4pKSB7XG4gICAgICBmb3IgKGogPSAwOyBqIDwgdm5vZGUuY2hpbGRyZW4ubGVuZ3RoOyArK2opIHtcbiAgICAgICAgaW52b2tlRGVzdHJveUhvb2sodm5vZGUuY2hpbGRyZW5bal0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZVZub2RlcyAocGFyZW50RWxtLCB2bm9kZXMsIHN0YXJ0SWR4LCBlbmRJZHgpIHtcbiAgICBmb3IgKDsgc3RhcnRJZHggPD0gZW5kSWR4OyArK3N0YXJ0SWR4KSB7XG4gICAgICB2YXIgY2ggPSB2bm9kZXNbc3RhcnRJZHhdO1xuICAgICAgaWYgKGlzRGVmKGNoKSkge1xuICAgICAgICBpZiAoaXNEZWYoY2gudGFnKSkge1xuICAgICAgICAgIHJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2soY2gpO1xuICAgICAgICAgIGludm9rZURlc3Ryb3lIb29rKGNoKTtcbiAgICAgICAgfSBlbHNlIHsgLy8gVGV4dCBub2RlXG4gICAgICAgICAgcmVtb3ZlTm9kZShjaC5lbG0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlQW5kSW52b2tlUmVtb3ZlSG9vayAodm5vZGUsIHJtKSB7XG4gICAgaWYgKGlzRGVmKHJtKSB8fCBpc0RlZih2bm9kZS5kYXRhKSkge1xuICAgICAgdmFyIGk7XG4gICAgICB2YXIgbGlzdGVuZXJzID0gY2JzLnJlbW92ZS5sZW5ndGggKyAxO1xuICAgICAgaWYgKGlzRGVmKHJtKSkge1xuICAgICAgICAvLyB3ZSBoYXZlIGEgcmVjdXJzaXZlbHkgcGFzc2VkIGRvd24gcm0gY2FsbGJhY2tcbiAgICAgICAgLy8gaW5jcmVhc2UgdGhlIGxpc3RlbmVycyBjb3VudFxuICAgICAgICBybS5saXN0ZW5lcnMgKz0gbGlzdGVuZXJzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZGlyZWN0bHkgcmVtb3ZpbmdcbiAgICAgICAgcm0gPSBjcmVhdGVSbUNiKHZub2RlLmVsbSwgbGlzdGVuZXJzKTtcbiAgICAgIH1cbiAgICAgIC8vIHJlY3Vyc2l2ZWx5IGludm9rZSBob29rcyBvbiBjaGlsZCBjb21wb25lbnQgcm9vdCBub2RlXG4gICAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSAmJiBpc0RlZihpID0gaS5fdm5vZGUpICYmIGlzRGVmKGkuZGF0YSkpIHtcbiAgICAgICAgcmVtb3ZlQW5kSW52b2tlUmVtb3ZlSG9vayhpLCBybSk7XG4gICAgICB9XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLnJlbW92ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICBjYnMucmVtb3ZlW2ldKHZub2RlLCBybSk7XG4gICAgICB9XG4gICAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkucmVtb3ZlKSkge1xuICAgICAgICBpKHZub2RlLCBybSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBybSgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZW1vdmVOb2RlKHZub2RlLmVsbSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlQ2hpbGRyZW4gKHBhcmVudEVsbSwgb2xkQ2gsIG5ld0NoLCBpbnNlcnRlZFZub2RlUXVldWUsIHJlbW92ZU9ubHkpIHtcbiAgICB2YXIgb2xkU3RhcnRJZHggPSAwO1xuICAgIHZhciBuZXdTdGFydElkeCA9IDA7XG4gICAgdmFyIG9sZEVuZElkeCA9IG9sZENoLmxlbmd0aCAtIDE7XG4gICAgdmFyIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFswXTtcbiAgICB2YXIgb2xkRW5kVm5vZGUgPSBvbGRDaFtvbGRFbmRJZHhdO1xuICAgIHZhciBuZXdFbmRJZHggPSBuZXdDaC5sZW5ndGggLSAxO1xuICAgIHZhciBuZXdTdGFydFZub2RlID0gbmV3Q2hbMF07XG4gICAgdmFyIG5ld0VuZFZub2RlID0gbmV3Q2hbbmV3RW5kSWR4XTtcbiAgICB2YXIgb2xkS2V5VG9JZHgsIGlkeEluT2xkLCB2bm9kZVRvTW92ZSwgcmVmRWxtO1xuXG4gICAgLy8gcmVtb3ZlT25seSBpcyBhIHNwZWNpYWwgZmxhZyB1c2VkIG9ubHkgYnkgPHRyYW5zaXRpb24tZ3JvdXA+XG4gICAgLy8gdG8gZW5zdXJlIHJlbW92ZWQgZWxlbWVudHMgc3RheSBpbiBjb3JyZWN0IHJlbGF0aXZlIHBvc2l0aW9uc1xuICAgIC8vIGR1cmluZyBsZWF2aW5nIHRyYW5zaXRpb25zXG4gICAgdmFyIGNhbk1vdmUgPSAhcmVtb3ZlT25seTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBjaGVja0R1cGxpY2F0ZUtleXMobmV3Q2gpO1xuICAgIH1cblxuICAgIHdoaWxlIChvbGRTdGFydElkeCA8PSBvbGRFbmRJZHggJiYgbmV3U3RhcnRJZHggPD0gbmV3RW5kSWR4KSB7XG4gICAgICBpZiAoaXNVbmRlZihvbGRTdGFydFZub2RlKSkge1xuICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07IC8vIFZub2RlIGhhcyBiZWVuIG1vdmVkIGxlZnRcbiAgICAgIH0gZWxzZSBpZiAoaXNVbmRlZihvbGRFbmRWbm9kZSkpIHtcbiAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRTdGFydFZub2RlLCBuZXdTdGFydFZub2RlKSkge1xuICAgICAgICBwYXRjaFZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTtcbiAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkRW5kVm5vZGUsIG5ld0VuZFZub2RlKSkge1xuICAgICAgICBwYXRjaFZub2RlKG9sZEVuZFZub2RlLCBuZXdFbmRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICAgIG5ld0VuZFZub2RlID0gbmV3Q2hbLS1uZXdFbmRJZHhdO1xuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3RW5kVm5vZGUpKSB7IC8vIFZub2RlIG1vdmVkIHJpZ2h0XG4gICAgICAgIHBhdGNoVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3RW5kVm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIGNhbk1vdmUgJiYgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBvbGRTdGFydFZub2RlLmVsbSwgbm9kZU9wcy5uZXh0U2libGluZyhvbGRFbmRWbm9kZS5lbG0pKTtcbiAgICAgICAgb2xkU3RhcnRWbm9kZSA9IG9sZENoWysrb2xkU3RhcnRJZHhdO1xuICAgICAgICBuZXdFbmRWbm9kZSA9IG5ld0NoWy0tbmV3RW5kSWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZEVuZFZub2RlLCBuZXdTdGFydFZub2RlKSkgeyAvLyBWbm9kZSBtb3ZlZCBsZWZ0XG4gICAgICAgIHBhdGNoVm5vZGUob2xkRW5kVm5vZGUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIGNhbk1vdmUgJiYgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBvbGRFbmRWbm9kZS5lbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcbiAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc1VuZGVmKG9sZEtleVRvSWR4KSkgeyBvbGRLZXlUb0lkeCA9IGNyZWF0ZUtleVRvT2xkSWR4KG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTsgfVxuICAgICAgICBpZHhJbk9sZCA9IGlzRGVmKG5ld1N0YXJ0Vm5vZGUua2V5KVxuICAgICAgICAgID8gb2xkS2V5VG9JZHhbbmV3U3RhcnRWbm9kZS5rZXldXG4gICAgICAgICAgOiBmaW5kSWR4SW5PbGQobmV3U3RhcnRWbm9kZSwgb2xkQ2gsIG9sZFN0YXJ0SWR4LCBvbGRFbmRJZHgpO1xuICAgICAgICBpZiAoaXNVbmRlZihpZHhJbk9sZCkpIHsgLy8gTmV3IGVsZW1lbnRcbiAgICAgICAgICBjcmVhdGVFbG0obmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2bm9kZVRvTW92ZSA9IG9sZENoW2lkeEluT2xkXTtcbiAgICAgICAgICBpZiAoc2FtZVZub2RlKHZub2RlVG9Nb3ZlLCBuZXdTdGFydFZub2RlKSkge1xuICAgICAgICAgICAgcGF0Y2hWbm9kZSh2bm9kZVRvTW92ZSwgbmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgICAgIG9sZENoW2lkeEluT2xkXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNhbk1vdmUgJiYgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCB2bm9kZVRvTW92ZS5lbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gc2FtZSBrZXkgYnV0IGRpZmZlcmVudCBlbGVtZW50LiB0cmVhdCBhcyBuZXcgZWxlbWVudFxuICAgICAgICAgICAgY3JlYXRlRWxtKG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCBvbGRTdGFydFZub2RlLmVsbSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9sZFN0YXJ0SWR4ID4gb2xkRW5kSWR4KSB7XG4gICAgICByZWZFbG0gPSBpc1VuZGVmKG5ld0NoW25ld0VuZElkeCArIDFdKSA/IG51bGwgOiBuZXdDaFtuZXdFbmRJZHggKyAxXS5lbG07XG4gICAgICBhZGRWbm9kZXMocGFyZW50RWxtLCByZWZFbG0sIG5ld0NoLCBuZXdTdGFydElkeCwgbmV3RW5kSWR4LCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgIH0gZWxzZSBpZiAobmV3U3RhcnRJZHggPiBuZXdFbmRJZHgpIHtcbiAgICAgIHJlbW92ZVZub2RlcyhwYXJlbnRFbG0sIG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja0R1cGxpY2F0ZUtleXMgKGNoaWxkcmVuKSB7XG4gICAgdmFyIHNlZW5LZXlzID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHZub2RlID0gY2hpbGRyZW5baV07XG4gICAgICB2YXIga2V5ID0gdm5vZGUua2V5O1xuICAgICAgaWYgKGlzRGVmKGtleSkpIHtcbiAgICAgICAgaWYgKHNlZW5LZXlzW2tleV0pIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgKFwiRHVwbGljYXRlIGtleXMgZGV0ZWN0ZWQ6ICdcIiArIGtleSArIFwiJy4gVGhpcyBtYXkgY2F1c2UgYW4gdXBkYXRlIGVycm9yLlwiKSxcbiAgICAgICAgICAgIHZub2RlLmNvbnRleHRcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlZW5LZXlzW2tleV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZmluZElkeEluT2xkIChub2RlLCBvbGRDaCwgc3RhcnQsIGVuZCkge1xuICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICB2YXIgYyA9IG9sZENoW2ldO1xuICAgICAgaWYgKGlzRGVmKGMpICYmIHNhbWVWbm9kZShub2RlLCBjKSkgeyByZXR1cm4gaSB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGF0Y2hWbm9kZSAob2xkVm5vZGUsIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHJlbW92ZU9ubHkpIHtcbiAgICBpZiAob2xkVm5vZGUgPT09IHZub2RlKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgZWxtID0gdm5vZGUuZWxtID0gb2xkVm5vZGUuZWxtO1xuXG4gICAgaWYgKGlzVHJ1ZShvbGRWbm9kZS5pc0FzeW5jUGxhY2Vob2xkZXIpKSB7XG4gICAgICBpZiAoaXNEZWYodm5vZGUuYXN5bmNGYWN0b3J5LnJlc29sdmVkKSkge1xuICAgICAgICBoeWRyYXRlKG9sZFZub2RlLmVsbSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2bm9kZS5pc0FzeW5jUGxhY2Vob2xkZXIgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gcmV1c2UgZWxlbWVudCBmb3Igc3RhdGljIHRyZWVzLlxuICAgIC8vIG5vdGUgd2Ugb25seSBkbyB0aGlzIGlmIHRoZSB2bm9kZSBpcyBjbG9uZWQgLVxuICAgIC8vIGlmIHRoZSBuZXcgbm9kZSBpcyBub3QgY2xvbmVkIGl0IG1lYW5zIHRoZSByZW5kZXIgZnVuY3Rpb25zIGhhdmUgYmVlblxuICAgIC8vIHJlc2V0IGJ5IHRoZSBob3QtcmVsb2FkLWFwaSBhbmQgd2UgbmVlZCB0byBkbyBhIHByb3BlciByZS1yZW5kZXIuXG4gICAgaWYgKGlzVHJ1ZSh2bm9kZS5pc1N0YXRpYykgJiZcbiAgICAgIGlzVHJ1ZShvbGRWbm9kZS5pc1N0YXRpYykgJiZcbiAgICAgIHZub2RlLmtleSA9PT0gb2xkVm5vZGUua2V5ICYmXG4gICAgICAoaXNUcnVlKHZub2RlLmlzQ2xvbmVkKSB8fCBpc1RydWUodm5vZGUuaXNPbmNlKSlcbiAgICApIHtcbiAgICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gb2xkVm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgaTtcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgaWYgKGlzRGVmKGRhdGEpICYmIGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnByZXBhdGNoKSkge1xuICAgICAgaShvbGRWbm9kZSwgdm5vZGUpO1xuICAgIH1cblxuICAgIHZhciBvbGRDaCA9IG9sZFZub2RlLmNoaWxkcmVuO1xuICAgIHZhciBjaCA9IHZub2RlLmNoaWxkcmVuO1xuICAgIGlmIChpc0RlZihkYXRhKSAmJiBpc1BhdGNoYWJsZSh2bm9kZSkpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMudXBkYXRlLmxlbmd0aDsgKytpKSB7IGNicy51cGRhdGVbaV0ob2xkVm5vZGUsIHZub2RlKTsgfVxuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnVwZGF0ZSkpIHsgaShvbGRWbm9kZSwgdm5vZGUpOyB9XG4gICAgfVxuICAgIGlmIChpc1VuZGVmKHZub2RlLnRleHQpKSB7XG4gICAgICBpZiAoaXNEZWYob2xkQ2gpICYmIGlzRGVmKGNoKSkge1xuICAgICAgICBpZiAob2xkQ2ggIT09IGNoKSB7IHVwZGF0ZUNoaWxkcmVuKGVsbSwgb2xkQ2gsIGNoLCBpbnNlcnRlZFZub2RlUXVldWUsIHJlbW92ZU9ubHkpOyB9XG4gICAgICB9IGVsc2UgaWYgKGlzRGVmKGNoKSkge1xuICAgICAgICBpZiAoaXNEZWYob2xkVm5vZGUudGV4dCkpIHsgbm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sICcnKTsgfVxuICAgICAgICBhZGRWbm9kZXMoZWxtLCBudWxsLCBjaCwgMCwgY2gubGVuZ3RoIC0gMSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkQ2gpKSB7XG4gICAgICAgIHJlbW92ZVZub2RlcyhlbG0sIG9sZENoLCAwLCBvbGRDaC5sZW5ndGggLSAxKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkVm5vZGUudGV4dCkpIHtcbiAgICAgICAgbm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sICcnKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9sZFZub2RlLnRleHQgIT09IHZub2RlLnRleHQpIHtcbiAgICAgIG5vZGVPcHMuc2V0VGV4dENvbnRlbnQoZWxtLCB2bm9kZS50ZXh0KTtcbiAgICB9XG4gICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkucG9zdHBhdGNoKSkgeyBpKG9sZFZub2RlLCB2bm9kZSk7IH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VJbnNlcnRIb29rICh2bm9kZSwgcXVldWUsIGluaXRpYWwpIHtcbiAgICAvLyBkZWxheSBpbnNlcnQgaG9va3MgZm9yIGNvbXBvbmVudCByb290IG5vZGVzLCBpbnZva2UgdGhlbSBhZnRlciB0aGVcbiAgICAvLyBlbGVtZW50IGlzIHJlYWxseSBpbnNlcnRlZFxuICAgIGlmIChpc1RydWUoaW5pdGlhbCkgJiYgaXNEZWYodm5vZGUucGFyZW50KSkge1xuICAgICAgdm5vZGUucGFyZW50LmRhdGEucGVuZGluZ0luc2VydCA9IHF1ZXVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHF1ZXVlW2ldLmRhdGEuaG9vay5pbnNlcnQocXVldWVbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBoeWRyYXRpb25CYWlsZWQgPSBmYWxzZTtcbiAgLy8gbGlzdCBvZiBtb2R1bGVzIHRoYXQgY2FuIHNraXAgY3JlYXRlIGhvb2sgZHVyaW5nIGh5ZHJhdGlvbiBiZWNhdXNlIHRoZXlcbiAgLy8gYXJlIGFscmVhZHkgcmVuZGVyZWQgb24gdGhlIGNsaWVudCBvciBoYXMgbm8gbmVlZCBmb3IgaW5pdGlhbGl6YXRpb25cbiAgLy8gTm90ZTogc3R5bGUgaXMgZXhjbHVkZWQgYmVjYXVzZSBpdCByZWxpZXMgb24gaW5pdGlhbCBjbG9uZSBmb3IgZnV0dXJlXG4gIC8vIGRlZXAgdXBkYXRlcyAoIzcwNjMpLlxuICB2YXIgaXNSZW5kZXJlZE1vZHVsZSA9IG1ha2VNYXAoJ2F0dHJzLGNsYXNzLHN0YXRpY0NsYXNzLHN0YXRpY1N0eWxlLGtleScpO1xuXG4gIC8vIE5vdGU6IHRoaXMgaXMgYSBicm93c2VyLW9ubHkgZnVuY3Rpb24gc28gd2UgY2FuIGFzc3VtZSBlbG1zIGFyZSBET00gbm9kZXMuXG4gIGZ1bmN0aW9uIGh5ZHJhdGUgKGVsbSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgaW5WUHJlKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIHRhZyA9IHZub2RlLnRhZztcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgdmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW47XG4gICAgaW5WUHJlID0gaW5WUHJlIHx8IChkYXRhICYmIGRhdGEucHJlKTtcbiAgICB2bm9kZS5lbG0gPSBlbG07XG5cbiAgICBpZiAoaXNUcnVlKHZub2RlLmlzQ29tbWVudCkgJiYgaXNEZWYodm5vZGUuYXN5bmNGYWN0b3J5KSkge1xuICAgICAgdm5vZGUuaXNBc3luY1BsYWNlaG9sZGVyID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIC8vIGFzc2VydCBub2RlIG1hdGNoXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICghYXNzZXJ0Tm9kZU1hdGNoKGVsbSwgdm5vZGUsIGluVlByZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLmluaXQpKSB7IGkodm5vZGUsIHRydWUgLyogaHlkcmF0aW5nICovKTsgfVxuICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcbiAgICAgICAgLy8gY2hpbGQgY29tcG9uZW50LiBpdCBzaG91bGQgaGF2ZSBoeWRyYXRlZCBpdHMgb3duIHRyZWUuXG4gICAgICAgIGluaXRDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc0RlZih0YWcpKSB7XG4gICAgICBpZiAoaXNEZWYoY2hpbGRyZW4pKSB7XG4gICAgICAgIC8vIGVtcHR5IGVsZW1lbnQsIGFsbG93IGNsaWVudCB0byBwaWNrIHVwIGFuZCBwb3B1bGF0ZSBjaGlsZHJlblxuICAgICAgICBpZiAoIWVsbS5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgICAgICBjcmVhdGVDaGlsZHJlbih2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gdi1odG1sIGFuZCBkb21Qcm9wczogaW5uZXJIVE1MXG4gICAgICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhKSAmJiBpc0RlZihpID0gaS5kb21Qcm9wcykgJiYgaXNEZWYoaSA9IGkuaW5uZXJIVE1MKSkge1xuICAgICAgICAgICAgaWYgKGkgIT09IGVsbS5pbm5lckhUTUwpIHtcbiAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAgICAgIWh5ZHJhdGlvbkJhaWxlZFxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBoeWRyYXRpb25CYWlsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignUGFyZW50OiAnLCBlbG0pO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2Fybignc2VydmVyIGlubmVySFRNTDogJywgaSk7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdjbGllbnQgaW5uZXJIVE1MOiAnLCBlbG0uaW5uZXJIVE1MKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gaXRlcmF0ZSBhbmQgY29tcGFyZSBjaGlsZHJlbiBsaXN0c1xuICAgICAgICAgICAgdmFyIGNoaWxkcmVuTWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgdmFyIGNoaWxkTm9kZSA9IGVsbS5maXJzdENoaWxkO1xuICAgICAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgY2hpbGRyZW4ubGVuZ3RoOyBpJDErKykge1xuICAgICAgICAgICAgICBpZiAoIWNoaWxkTm9kZSB8fCAhaHlkcmF0ZShjaGlsZE5vZGUsIGNoaWxkcmVuW2kkMV0sIGluc2VydGVkVm5vZGVRdWV1ZSwgaW5WUHJlKSkge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuTWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZS5uZXh0U2libGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmIGNoaWxkTm9kZSBpcyBub3QgbnVsbCwgaXQgbWVhbnMgdGhlIGFjdHVhbCBjaGlsZE5vZGVzIGxpc3QgaXNcbiAgICAgICAgICAgIC8vIGxvbmdlciB0aGFuIHRoZSB2aXJ0dWFsIGNoaWxkcmVuIGxpc3QuXG4gICAgICAgICAgICBpZiAoIWNoaWxkcmVuTWF0Y2ggfHwgY2hpbGROb2RlKSB7XG4gICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgICAgICFoeWRyYXRpb25CYWlsZWRcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgaHlkcmF0aW9uQmFpbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1BhcmVudDogJywgZWxtKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ01pc21hdGNoaW5nIGNoaWxkTm9kZXMgdnMuIFZOb2RlczogJywgZWxtLmNoaWxkTm9kZXMsIGNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgICB2YXIgZnVsbEludm9rZSA9IGZhbHNlO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gZGF0YSkge1xuICAgICAgICAgIGlmICghaXNSZW5kZXJlZE1vZHVsZShrZXkpKSB7XG4gICAgICAgICAgICBmdWxsSW52b2tlID0gdHJ1ZTtcbiAgICAgICAgICAgIGludm9rZUNyZWF0ZUhvb2tzKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFmdWxsSW52b2tlICYmIGRhdGFbJ2NsYXNzJ10pIHtcbiAgICAgICAgICAvLyBlbnN1cmUgY29sbGVjdGluZyBkZXBzIGZvciBkZWVwIGNsYXNzIGJpbmRpbmdzIGZvciBmdXR1cmUgdXBkYXRlc1xuICAgICAgICAgIHRyYXZlcnNlKGRhdGFbJ2NsYXNzJ10pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChlbG0uZGF0YSAhPT0gdm5vZGUudGV4dCkge1xuICAgICAgZWxtLmRhdGEgPSB2bm9kZS50ZXh0O1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgZnVuY3Rpb24gYXNzZXJ0Tm9kZU1hdGNoIChub2RlLCB2bm9kZSwgaW5WUHJlKSB7XG4gICAgaWYgKGlzRGVmKHZub2RlLnRhZykpIHtcbiAgICAgIHJldHVybiB2bm9kZS50YWcuaW5kZXhPZigndnVlLWNvbXBvbmVudCcpID09PSAwIHx8IChcbiAgICAgICAgIWlzVW5rbm93bkVsZW1lbnQkJDEodm5vZGUsIGluVlByZSkgJiZcbiAgICAgICAgdm5vZGUudGFnLnRvTG93ZXJDYXNlKCkgPT09IChub2RlLnRhZ05hbWUgJiYgbm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkpXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBub2RlLm5vZGVUeXBlID09PSAodm5vZGUuaXNDb21tZW50ID8gOCA6IDMpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHBhdGNoIChvbGRWbm9kZSwgdm5vZGUsIGh5ZHJhdGluZywgcmVtb3ZlT25seSwgcGFyZW50RWxtLCByZWZFbG0pIHtcbiAgICBpZiAoaXNVbmRlZih2bm9kZSkpIHtcbiAgICAgIGlmIChpc0RlZihvbGRWbm9kZSkpIHsgaW52b2tlRGVzdHJveUhvb2sob2xkVm5vZGUpOyB9XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgaXNJbml0aWFsUGF0Y2ggPSBmYWxzZTtcbiAgICB2YXIgaW5zZXJ0ZWRWbm9kZVF1ZXVlID0gW107XG5cbiAgICBpZiAoaXNVbmRlZihvbGRWbm9kZSkpIHtcbiAgICAgIC8vIGVtcHR5IG1vdW50IChsaWtlbHkgYXMgY29tcG9uZW50KSwgY3JlYXRlIG5ldyByb290IGVsZW1lbnRcbiAgICAgIGlzSW5pdGlhbFBhdGNoID0gdHJ1ZTtcbiAgICAgIGNyZWF0ZUVsbSh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBpc1JlYWxFbGVtZW50ID0gaXNEZWYob2xkVm5vZGUubm9kZVR5cGUpO1xuICAgICAgaWYgKCFpc1JlYWxFbGVtZW50ICYmIHNhbWVWbm9kZShvbGRWbm9kZSwgdm5vZGUpKSB7XG4gICAgICAgIC8vIHBhdGNoIGV4aXN0aW5nIHJvb3Qgbm9kZVxuICAgICAgICBwYXRjaFZub2RlKG9sZFZub2RlLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCByZW1vdmVPbmx5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc1JlYWxFbGVtZW50KSB7XG4gICAgICAgICAgLy8gbW91bnRpbmcgdG8gYSByZWFsIGVsZW1lbnRcbiAgICAgICAgICAvLyBjaGVjayBpZiB0aGlzIGlzIHNlcnZlci1yZW5kZXJlZCBjb250ZW50IGFuZCBpZiB3ZSBjYW4gcGVyZm9ybVxuICAgICAgICAgIC8vIGEgc3VjY2Vzc2Z1bCBoeWRyYXRpb24uXG4gICAgICAgICAgaWYgKG9sZFZub2RlLm5vZGVUeXBlID09PSAxICYmIG9sZFZub2RlLmhhc0F0dHJpYnV0ZShTU1JfQVRUUikpIHtcbiAgICAgICAgICAgIG9sZFZub2RlLnJlbW92ZUF0dHJpYnV0ZShTU1JfQVRUUik7XG4gICAgICAgICAgICBoeWRyYXRpbmcgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNUcnVlKGh5ZHJhdGluZykpIHtcbiAgICAgICAgICAgIGlmIChoeWRyYXRlKG9sZFZub2RlLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSkge1xuICAgICAgICAgICAgICBpbnZva2VJbnNlcnRIb29rKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHRydWUpO1xuICAgICAgICAgICAgICByZXR1cm4gb2xkVm5vZGVcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAgICdUaGUgY2xpZW50LXNpZGUgcmVuZGVyZWQgdmlydHVhbCBET00gdHJlZSBpcyBub3QgbWF0Y2hpbmcgJyArXG4gICAgICAgICAgICAgICAgJ3NlcnZlci1yZW5kZXJlZCBjb250ZW50LiBUaGlzIGlzIGxpa2VseSBjYXVzZWQgYnkgaW5jb3JyZWN0ICcgK1xuICAgICAgICAgICAgICAgICdIVE1MIG1hcmt1cCwgZm9yIGV4YW1wbGUgbmVzdGluZyBibG9jay1sZXZlbCBlbGVtZW50cyBpbnNpZGUgJyArXG4gICAgICAgICAgICAgICAgJzxwPiwgb3IgbWlzc2luZyA8dGJvZHk+LiBCYWlsaW5nIGh5ZHJhdGlvbiBhbmQgcGVyZm9ybWluZyAnICtcbiAgICAgICAgICAgICAgICAnZnVsbCBjbGllbnQtc2lkZSByZW5kZXIuJ1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBlaXRoZXIgbm90IHNlcnZlci1yZW5kZXJlZCwgb3IgaHlkcmF0aW9uIGZhaWxlZC5cbiAgICAgICAgICAvLyBjcmVhdGUgYW4gZW1wdHkgbm9kZSBhbmQgcmVwbGFjZSBpdFxuICAgICAgICAgIG9sZFZub2RlID0gZW1wdHlOb2RlQXQob2xkVm5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVwbGFjaW5nIGV4aXN0aW5nIGVsZW1lbnRcbiAgICAgICAgdmFyIG9sZEVsbSA9IG9sZFZub2RlLmVsbTtcbiAgICAgICAgdmFyIHBhcmVudEVsbSQxID0gbm9kZU9wcy5wYXJlbnROb2RlKG9sZEVsbSk7XG5cbiAgICAgICAgLy8gY3JlYXRlIG5ldyBub2RlXG4gICAgICAgIGNyZWF0ZUVsbShcbiAgICAgICAgICB2bm9kZSxcbiAgICAgICAgICBpbnNlcnRlZFZub2RlUXVldWUsXG4gICAgICAgICAgLy8gZXh0cmVtZWx5IHJhcmUgZWRnZSBjYXNlOiBkbyBub3QgaW5zZXJ0IGlmIG9sZCBlbGVtZW50IGlzIGluIGFcbiAgICAgICAgICAvLyBsZWF2aW5nIHRyYW5zaXRpb24uIE9ubHkgaGFwcGVucyB3aGVuIGNvbWJpbmluZyB0cmFuc2l0aW9uICtcbiAgICAgICAgICAvLyBrZWVwLWFsaXZlICsgSE9Dcy4gKCM0NTkwKVxuICAgICAgICAgIG9sZEVsbS5fbGVhdmVDYiA/IG51bGwgOiBwYXJlbnRFbG0kMSxcbiAgICAgICAgICBub2RlT3BzLm5leHRTaWJsaW5nKG9sZEVsbSlcbiAgICAgICAgKTtcblxuICAgICAgICAvLyB1cGRhdGUgcGFyZW50IHBsYWNlaG9sZGVyIG5vZGUgZWxlbWVudCwgcmVjdXJzaXZlbHlcbiAgICAgICAgaWYgKGlzRGVmKHZub2RlLnBhcmVudCkpIHtcbiAgICAgICAgICB2YXIgYW5jZXN0b3IgPSB2bm9kZS5wYXJlbnQ7XG4gICAgICAgICAgdmFyIHBhdGNoYWJsZSA9IGlzUGF0Y2hhYmxlKHZub2RlKTtcbiAgICAgICAgICB3aGlsZSAoYW5jZXN0b3IpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2JzLmRlc3Ryb3kubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgY2JzLmRlc3Ryb3lbaV0oYW5jZXN0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYW5jZXN0b3IuZWxtID0gdm5vZGUuZWxtO1xuICAgICAgICAgICAgaWYgKHBhdGNoYWJsZSkge1xuICAgICAgICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBjYnMuY3JlYXRlLmxlbmd0aDsgKytpJDEpIHtcbiAgICAgICAgICAgICAgICBjYnMuY3JlYXRlW2kkMV0oZW1wdHlOb2RlLCBhbmNlc3Rvcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gIzY1MTNcbiAgICAgICAgICAgICAgLy8gaW52b2tlIGluc2VydCBob29rcyB0aGF0IG1heSBoYXZlIGJlZW4gbWVyZ2VkIGJ5IGNyZWF0ZSBob29rcy5cbiAgICAgICAgICAgICAgLy8gZS5nLiBmb3IgZGlyZWN0aXZlcyB0aGF0IHVzZXMgdGhlIFwiaW5zZXJ0ZWRcIiBob29rLlxuICAgICAgICAgICAgICB2YXIgaW5zZXJ0ID0gYW5jZXN0b3IuZGF0YS5ob29rLmluc2VydDtcbiAgICAgICAgICAgICAgaWYgKGluc2VydC5tZXJnZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBzdGFydCBhdCBpbmRleCAxIHRvIGF2b2lkIHJlLWludm9raW5nIGNvbXBvbmVudCBtb3VudGVkIGhvb2tcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpJDIgPSAxOyBpJDIgPCBpbnNlcnQuZm5zLmxlbmd0aDsgaSQyKyspIHtcbiAgICAgICAgICAgICAgICAgIGluc2VydC5mbnNbaSQyXSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVnaXN0ZXJSZWYoYW5jZXN0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZGVzdHJveSBvbGQgbm9kZVxuICAgICAgICBpZiAoaXNEZWYocGFyZW50RWxtJDEpKSB7XG4gICAgICAgICAgcmVtb3ZlVm5vZGVzKHBhcmVudEVsbSQxLCBbb2xkVm5vZGVdLCAwLCAwKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0RlZihvbGRWbm9kZS50YWcpKSB7XG4gICAgICAgICAgaW52b2tlRGVzdHJveUhvb2sob2xkVm5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaW52b2tlSW5zZXJ0SG9vayh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBpc0luaXRpYWxQYXRjaCk7XG4gICAgcmV0dXJuIHZub2RlLmVsbVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgZGlyZWN0aXZlcyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVEaXJlY3RpdmVzLFxuICB1cGRhdGU6IHVwZGF0ZURpcmVjdGl2ZXMsXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uIHVuYmluZERpcmVjdGl2ZXMgKHZub2RlKSB7XG4gICAgdXBkYXRlRGlyZWN0aXZlcyh2bm9kZSwgZW1wdHlOb2RlKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gdXBkYXRlRGlyZWN0aXZlcyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIGlmIChvbGRWbm9kZS5kYXRhLmRpcmVjdGl2ZXMgfHwgdm5vZGUuZGF0YS5kaXJlY3RpdmVzKSB7XG4gICAgX3VwZGF0ZShvbGRWbm9kZSwgdm5vZGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF91cGRhdGUgKG9sZFZub2RlLCB2bm9kZSkge1xuICB2YXIgaXNDcmVhdGUgPSBvbGRWbm9kZSA9PT0gZW1wdHlOb2RlO1xuICB2YXIgaXNEZXN0cm95ID0gdm5vZGUgPT09IGVtcHR5Tm9kZTtcbiAgdmFyIG9sZERpcnMgPSBub3JtYWxpemVEaXJlY3RpdmVzJDEob2xkVm5vZGUuZGF0YS5kaXJlY3RpdmVzLCBvbGRWbm9kZS5jb250ZXh0KTtcbiAgdmFyIG5ld0RpcnMgPSBub3JtYWxpemVEaXJlY3RpdmVzJDEodm5vZGUuZGF0YS5kaXJlY3RpdmVzLCB2bm9kZS5jb250ZXh0KTtcblxuICB2YXIgZGlyc1dpdGhJbnNlcnQgPSBbXTtcbiAgdmFyIGRpcnNXaXRoUG9zdHBhdGNoID0gW107XG5cbiAgdmFyIGtleSwgb2xkRGlyLCBkaXI7XG4gIGZvciAoa2V5IGluIG5ld0RpcnMpIHtcbiAgICBvbGREaXIgPSBvbGREaXJzW2tleV07XG4gICAgZGlyID0gbmV3RGlyc1trZXldO1xuICAgIGlmICghb2xkRGlyKSB7XG4gICAgICAvLyBuZXcgZGlyZWN0aXZlLCBiaW5kXG4gICAgICBjYWxsSG9vayQxKGRpciwgJ2JpbmQnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgaWYgKGRpci5kZWYgJiYgZGlyLmRlZi5pbnNlcnRlZCkge1xuICAgICAgICBkaXJzV2l0aEluc2VydC5wdXNoKGRpcik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGV4aXN0aW5nIGRpcmVjdGl2ZSwgdXBkYXRlXG4gICAgICBkaXIub2xkVmFsdWUgPSBvbGREaXIudmFsdWU7XG4gICAgICBjYWxsSG9vayQxKGRpciwgJ3VwZGF0ZScsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICBpZiAoZGlyLmRlZiAmJiBkaXIuZGVmLmNvbXBvbmVudFVwZGF0ZWQpIHtcbiAgICAgICAgZGlyc1dpdGhQb3N0cGF0Y2gucHVzaChkaXIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChkaXJzV2l0aEluc2VydC5sZW5ndGgpIHtcbiAgICB2YXIgY2FsbEluc2VydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlyc1dpdGhJbnNlcnQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2FsbEhvb2skMShkaXJzV2l0aEluc2VydFtpXSwgJ2luc2VydGVkJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmIChpc0NyZWF0ZSkge1xuICAgICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUsICdpbnNlcnQnLCBjYWxsSW5zZXJ0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbEluc2VydCgpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChkaXJzV2l0aFBvc3RwYXRjaC5sZW5ndGgpIHtcbiAgICBtZXJnZVZOb2RlSG9vayh2bm9kZSwgJ3Bvc3RwYXRjaCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlyc1dpdGhQb3N0cGF0Y2gubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2FsbEhvb2skMShkaXJzV2l0aFBvc3RwYXRjaFtpXSwgJ2NvbXBvbmVudFVwZGF0ZWQnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgaWYgKCFpc0NyZWF0ZSkge1xuICAgIGZvciAoa2V5IGluIG9sZERpcnMpIHtcbiAgICAgIGlmICghbmV3RGlyc1trZXldKSB7XG4gICAgICAgIC8vIG5vIGxvbmdlciBwcmVzZW50LCB1bmJpbmRcbiAgICAgICAgY2FsbEhvb2skMShvbGREaXJzW2tleV0sICd1bmJpbmQnLCBvbGRWbm9kZSwgb2xkVm5vZGUsIGlzRGVzdHJveSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBlbXB0eU1vZGlmaWVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZURpcmVjdGl2ZXMkMSAoXG4gIGRpcnMsXG4gIHZtXG4pIHtcbiAgdmFyIHJlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGlmICghZGlycykge1xuICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgIHJldHVybiByZXNcbiAgfVxuICB2YXIgaSwgZGlyO1xuICBmb3IgKGkgPSAwOyBpIDwgZGlycy5sZW5ndGg7IGkrKykge1xuICAgIGRpciA9IGRpcnNbaV07XG4gICAgaWYgKCFkaXIubW9kaWZpZXJzKSB7XG4gICAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICAgIGRpci5tb2RpZmllcnMgPSBlbXB0eU1vZGlmaWVycztcbiAgICB9XG4gICAgcmVzW2dldFJhd0Rpck5hbWUoZGlyKV0gPSBkaXI7XG4gICAgZGlyLmRlZiA9IHJlc29sdmVBc3NldCh2bS4kb3B0aW9ucywgJ2RpcmVjdGl2ZXMnLCBkaXIubmFtZSwgdHJ1ZSk7XG4gIH1cbiAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gZ2V0UmF3RGlyTmFtZSAoZGlyKSB7XG4gIHJldHVybiBkaXIucmF3TmFtZSB8fCAoKGRpci5uYW1lKSArIFwiLlwiICsgKE9iamVjdC5rZXlzKGRpci5tb2RpZmllcnMgfHwge30pLmpvaW4oJy4nKSkpXG59XG5cbmZ1bmN0aW9uIGNhbGxIb29rJDEgKGRpciwgaG9vaywgdm5vZGUsIG9sZFZub2RlLCBpc0Rlc3Ryb3kpIHtcbiAgdmFyIGZuID0gZGlyLmRlZiAmJiBkaXIuZGVmW2hvb2tdO1xuICBpZiAoZm4pIHtcbiAgICB0cnkge1xuICAgICAgZm4odm5vZGUuZWxtLCBkaXIsIHZub2RlLCBvbGRWbm9kZSwgaXNEZXN0cm95KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBoYW5kbGVFcnJvcihlLCB2bm9kZS5jb250ZXh0LCAoXCJkaXJlY3RpdmUgXCIgKyAoZGlyLm5hbWUpICsgXCIgXCIgKyBob29rICsgXCIgaG9va1wiKSk7XG4gICAgfVxuICB9XG59XG5cbnZhciBiYXNlTW9kdWxlcyA9IFtcbiAgcmVmLFxuICBkaXJlY3RpdmVzXG5dO1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gdXBkYXRlQXR0cnMgKG9sZFZub2RlLCB2bm9kZSkge1xuICB2YXIgb3B0cyA9IHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gIGlmIChpc0RlZihvcHRzKSAmJiBvcHRzLkN0b3Iub3B0aW9ucy5pbmhlcml0QXR0cnMgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKGlzVW5kZWYob2xkVm5vZGUuZGF0YS5hdHRycykgJiYgaXNVbmRlZih2bm9kZS5kYXRhLmF0dHJzKSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBrZXksIGN1ciwgb2xkO1xuICB2YXIgZWxtID0gdm5vZGUuZWxtO1xuICB2YXIgb2xkQXR0cnMgPSBvbGRWbm9kZS5kYXRhLmF0dHJzIHx8IHt9O1xuICB2YXIgYXR0cnMgPSB2bm9kZS5kYXRhLmF0dHJzIHx8IHt9O1xuICAvLyBjbG9uZSBvYnNlcnZlZCBvYmplY3RzLCBhcyB0aGUgdXNlciBwcm9iYWJseSB3YW50cyB0byBtdXRhdGUgaXRcbiAgaWYgKGlzRGVmKGF0dHJzLl9fb2JfXykpIHtcbiAgICBhdHRycyA9IHZub2RlLmRhdGEuYXR0cnMgPSBleHRlbmQoe30sIGF0dHJzKTtcbiAgfVxuXG4gIGZvciAoa2V5IGluIGF0dHJzKSB7XG4gICAgY3VyID0gYXR0cnNba2V5XTtcbiAgICBvbGQgPSBvbGRBdHRyc1trZXldO1xuICAgIGlmIChvbGQgIT09IGN1cikge1xuICAgICAgc2V0QXR0cihlbG0sIGtleSwgY3VyKTtcbiAgICB9XG4gIH1cbiAgLy8gIzQzOTE6IGluIElFOSwgc2V0dGluZyB0eXBlIGNhbiByZXNldCB2YWx1ZSBmb3IgaW5wdXRbdHlwZT1yYWRpb11cbiAgLy8gIzY2NjY6IElFL0VkZ2UgZm9yY2VzIHByb2dyZXNzIHZhbHVlIGRvd24gdG8gMSBiZWZvcmUgc2V0dGluZyBhIG1heFxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKChpc0lFIHx8IGlzRWRnZSkgJiYgYXR0cnMudmFsdWUgIT09IG9sZEF0dHJzLnZhbHVlKSB7XG4gICAgc2V0QXR0cihlbG0sICd2YWx1ZScsIGF0dHJzLnZhbHVlKTtcbiAgfVxuICBmb3IgKGtleSBpbiBvbGRBdHRycykge1xuICAgIGlmIChpc1VuZGVmKGF0dHJzW2tleV0pKSB7XG4gICAgICBpZiAoaXNYbGluayhrZXkpKSB7XG4gICAgICAgIGVsbS5yZW1vdmVBdHRyaWJ1dGVOUyh4bGlua05TLCBnZXRYbGlua1Byb3Aoa2V5KSk7XG4gICAgICB9IGVsc2UgaWYgKCFpc0VudW1lcmF0ZWRBdHRyKGtleSkpIHtcbiAgICAgICAgZWxtLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzZXRBdHRyIChlbCwga2V5LCB2YWx1ZSkge1xuICBpZiAoaXNCb29sZWFuQXR0cihrZXkpKSB7XG4gICAgLy8gc2V0IGF0dHJpYnV0ZSBmb3IgYmxhbmsgdmFsdWVcbiAgICAvLyBlLmcuIDxvcHRpb24gZGlzYWJsZWQ+U2VsZWN0IG9uZTwvb3B0aW9uPlxuICAgIGlmIChpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHRlY2huaWNhbGx5IGFsbG93ZnVsbHNjcmVlbiBpcyBhIGJvb2xlYW4gYXR0cmlidXRlIGZvciA8aWZyYW1lPixcbiAgICAgIC8vIGJ1dCBGbGFzaCBleHBlY3RzIGEgdmFsdWUgb2YgXCJ0cnVlXCIgd2hlbiB1c2VkIG9uIDxlbWJlZD4gdGFnXG4gICAgICB2YWx1ZSA9IGtleSA9PT0gJ2FsbG93ZnVsbHNjcmVlbicgJiYgZWwudGFnTmFtZSA9PT0gJ0VNQkVEJ1xuICAgICAgICA/ICd0cnVlJ1xuICAgICAgICA6IGtleTtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNFbnVtZXJhdGVkQXR0cihrZXkpKSB7XG4gICAgZWwuc2V0QXR0cmlidXRlKGtleSwgaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkgfHwgdmFsdWUgPT09ICdmYWxzZScgPyAnZmFsc2UnIDogJ3RydWUnKTtcbiAgfSBlbHNlIGlmIChpc1hsaW5rKGtleSkpIHtcbiAgICBpZiAoaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZU5TKHhsaW5rTlMsIGdldFhsaW5rUHJvcChrZXkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc2V0QXR0cmlidXRlTlMoeGxpbmtOUywga2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vICM3MTM4OiBJRTEwICYgMTEgZmlyZXMgaW5wdXQgZXZlbnQgd2hlbiBzZXR0aW5nIHBsYWNlaG9sZGVyIG9uXG4gICAgICAvLyA8dGV4dGFyZWE+Li4uIGJsb2NrIHRoZSBmaXJzdCBpbnB1dCBldmVudCBhbmQgcmVtb3ZlIHRoZSBibG9ja2VyXG4gICAgICAvLyBpbW1lZGlhdGVseS5cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKFxuICAgICAgICBpc0lFICYmICFpc0lFOSAmJlxuICAgICAgICBlbC50YWdOYW1lID09PSAnVEVYVEFSRUEnICYmXG4gICAgICAgIGtleSA9PT0gJ3BsYWNlaG9sZGVyJyAmJiAhZWwuX19pZXBoXG4gICAgICApIHtcbiAgICAgICAgdmFyIGJsb2NrZXIgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignaW5wdXQnLCBibG9ja2VyKTtcbiAgICAgICAgfTtcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCBibG9ja2VyKTtcbiAgICAgICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgICAgIGVsLl9faWVwaCA9IHRydWU7IC8qIElFIHBsYWNlaG9sZGVyIHBhdGNoZWQgKi9cbiAgICAgIH1cbiAgICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIGF0dHJzID0ge1xuICBjcmVhdGU6IHVwZGF0ZUF0dHJzLFxuICB1cGRhdGU6IHVwZGF0ZUF0dHJzXG59O1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gdXBkYXRlQ2xhc3MgKG9sZFZub2RlLCB2bm9kZSkge1xuICB2YXIgZWwgPSB2bm9kZS5lbG07XG4gIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgdmFyIG9sZERhdGEgPSBvbGRWbm9kZS5kYXRhO1xuICBpZiAoXG4gICAgaXNVbmRlZihkYXRhLnN0YXRpY0NsYXNzKSAmJlxuICAgIGlzVW5kZWYoZGF0YS5jbGFzcykgJiYgKFxuICAgICAgaXNVbmRlZihvbGREYXRhKSB8fCAoXG4gICAgICAgIGlzVW5kZWYob2xkRGF0YS5zdGF0aWNDbGFzcykgJiZcbiAgICAgICAgaXNVbmRlZihvbGREYXRhLmNsYXNzKVxuICAgICAgKVxuICAgIClcbiAgKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY2xzID0gZ2VuQ2xhc3NGb3JWbm9kZSh2bm9kZSk7XG5cbiAgLy8gaGFuZGxlIHRyYW5zaXRpb24gY2xhc3Nlc1xuICB2YXIgdHJhbnNpdGlvbkNsYXNzID0gZWwuX3RyYW5zaXRpb25DbGFzc2VzO1xuICBpZiAoaXNEZWYodHJhbnNpdGlvbkNsYXNzKSkge1xuICAgIGNscyA9IGNvbmNhdChjbHMsIHN0cmluZ2lmeUNsYXNzKHRyYW5zaXRpb25DbGFzcykpO1xuICB9XG5cbiAgLy8gc2V0IHRoZSBjbGFzc1xuICBpZiAoY2xzICE9PSBlbC5fcHJldkNsYXNzKSB7XG4gICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIGNscyk7XG4gICAgZWwuX3ByZXZDbGFzcyA9IGNscztcbiAgfVxufVxuXG52YXIga2xhc3MgPSB7XG4gIGNyZWF0ZTogdXBkYXRlQ2xhc3MsXG4gIHVwZGF0ZTogdXBkYXRlQ2xhc3Ncbn07XG5cbi8qICAqL1xuXG4vKiAgKi9cblxuXG5cblxuXG5cblxuXG5cbi8vIGFkZCBhIHJhdyBhdHRyICh1c2UgdGhpcyBpbiBwcmVUcmFuc2Zvcm1zKVxuXG5cblxuXG5cblxuXG5cbi8vIG5vdGU6IHRoaXMgb25seSByZW1vdmVzIHRoZSBhdHRyIGZyb20gdGhlIEFycmF5IChhdHRyc0xpc3QpIHNvIHRoYXQgaXRcbi8vIGRvZXNuJ3QgZ2V0IHByb2Nlc3NlZCBieSBwcm9jZXNzQXR0cnMuXG4vLyBCeSBkZWZhdWx0IGl0IGRvZXMgTk9UIHJlbW92ZSBpdCBmcm9tIHRoZSBtYXAgKGF0dHJzTWFwKSBiZWNhdXNlIHRoZSBtYXAgaXNcbi8vIG5lZWRlZCBkdXJpbmcgY29kZWdlbi5cblxuLyogICovXG5cbi8qKlxuICogQ3Jvc3MtcGxhdGZvcm0gY29kZSBnZW5lcmF0aW9uIGZvciBjb21wb25lbnQgdi1tb2RlbFxuICovXG5cblxuLyoqXG4gKiBDcm9zcy1wbGF0Zm9ybSBjb2RlZ2VuIGhlbHBlciBmb3IgZ2VuZXJhdGluZyB2LW1vZGVsIHZhbHVlIGFzc2lnbm1lbnQgY29kZS5cbiAqL1xuXG4vKiAgKi9cblxuLy8gaW4gc29tZSBjYXNlcywgdGhlIGV2ZW50IHVzZWQgaGFzIHRvIGJlIGRldGVybWluZWQgYXQgcnVudGltZVxuLy8gc28gd2UgdXNlZCBzb21lIHJlc2VydmVkIHRva2VucyBkdXJpbmcgY29tcGlsZS5cbnZhciBSQU5HRV9UT0tFTiA9ICdfX3InO1xudmFyIENIRUNLQk9YX1JBRElPX1RPS0VOID0gJ19fYyc7XG5cbi8qICAqL1xuXG4vLyBub3JtYWxpemUgdi1tb2RlbCBldmVudCB0b2tlbnMgdGhhdCBjYW4gb25seSBiZSBkZXRlcm1pbmVkIGF0IHJ1bnRpbWUuXG4vLyBpdCdzIGltcG9ydGFudCB0byBwbGFjZSB0aGUgZXZlbnQgYXMgdGhlIGZpcnN0IGluIHRoZSBhcnJheSBiZWNhdXNlXG4vLyB0aGUgd2hvbGUgcG9pbnQgaXMgZW5zdXJpbmcgdGhlIHYtbW9kZWwgY2FsbGJhY2sgZ2V0cyBjYWxsZWQgYmVmb3JlXG4vLyB1c2VyLWF0dGFjaGVkIGhhbmRsZXJzLlxuZnVuY3Rpb24gbm9ybWFsaXplRXZlbnRzIChvbikge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGlzRGVmKG9uW1JBTkdFX1RPS0VOXSkpIHtcbiAgICAvLyBJRSBpbnB1dFt0eXBlPXJhbmdlXSBvbmx5IHN1cHBvcnRzIGBjaGFuZ2VgIGV2ZW50XG4gICAgdmFyIGV2ZW50ID0gaXNJRSA/ICdjaGFuZ2UnIDogJ2lucHV0JztcbiAgICBvbltldmVudF0gPSBbXS5jb25jYXQob25bUkFOR0VfVE9LRU5dLCBvbltldmVudF0gfHwgW10pO1xuICAgIGRlbGV0ZSBvbltSQU5HRV9UT0tFTl07XG4gIH1cbiAgLy8gVGhpcyB3YXMgb3JpZ2luYWxseSBpbnRlbmRlZCB0byBmaXggIzQ1MjEgYnV0IG5vIGxvbmdlciBuZWNlc3NhcnlcbiAgLy8gYWZ0ZXIgMi41LiBLZWVwaW5nIGl0IGZvciBiYWNrd2FyZHMgY29tcGF0IHdpdGggZ2VuZXJhdGVkIGNvZGUgZnJvbSA8IDIuNFxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGlzRGVmKG9uW0NIRUNLQk9YX1JBRElPX1RPS0VOXSkpIHtcbiAgICBvbi5jaGFuZ2UgPSBbXS5jb25jYXQob25bQ0hFQ0tCT1hfUkFESU9fVE9LRU5dLCBvbi5jaGFuZ2UgfHwgW10pO1xuICAgIGRlbGV0ZSBvbltDSEVDS0JPWF9SQURJT19UT0tFTl07XG4gIH1cbn1cblxudmFyIHRhcmdldCQxO1xuXG5mdW5jdGlvbiBjcmVhdGVPbmNlSGFuZGxlciAoaGFuZGxlciwgZXZlbnQsIGNhcHR1cmUpIHtcbiAgdmFyIF90YXJnZXQgPSB0YXJnZXQkMTsgLy8gc2F2ZSBjdXJyZW50IHRhcmdldCBlbGVtZW50IGluIGNsb3N1cmVcbiAgcmV0dXJuIGZ1bmN0aW9uIG9uY2VIYW5kbGVyICgpIHtcbiAgICB2YXIgcmVzID0gaGFuZGxlci5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIGlmIChyZXMgIT09IG51bGwpIHtcbiAgICAgIHJlbW92ZSQyKGV2ZW50LCBvbmNlSGFuZGxlciwgY2FwdHVyZSwgX3RhcmdldCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFkZCQxIChcbiAgZXZlbnQsXG4gIGhhbmRsZXIsXG4gIG9uY2UkJDEsXG4gIGNhcHR1cmUsXG4gIHBhc3NpdmVcbikge1xuICBoYW5kbGVyID0gd2l0aE1hY3JvVGFzayhoYW5kbGVyKTtcbiAgaWYgKG9uY2UkJDEpIHsgaGFuZGxlciA9IGNyZWF0ZU9uY2VIYW5kbGVyKGhhbmRsZXIsIGV2ZW50LCBjYXB0dXJlKTsgfVxuICB0YXJnZXQkMS5hZGRFdmVudExpc3RlbmVyKFxuICAgIGV2ZW50LFxuICAgIGhhbmRsZXIsXG4gICAgc3VwcG9ydHNQYXNzaXZlXG4gICAgICA/IHsgY2FwdHVyZTogY2FwdHVyZSwgcGFzc2l2ZTogcGFzc2l2ZSB9XG4gICAgICA6IGNhcHR1cmVcbiAgKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlJDIgKFxuICBldmVudCxcbiAgaGFuZGxlcixcbiAgY2FwdHVyZSxcbiAgX3RhcmdldFxuKSB7XG4gIChfdGFyZ2V0IHx8IHRhcmdldCQxKS5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgIGV2ZW50LFxuICAgIGhhbmRsZXIuX3dpdGhUYXNrIHx8IGhhbmRsZXIsXG4gICAgY2FwdHVyZVxuICApO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVET01MaXN0ZW5lcnMgKG9sZFZub2RlLCB2bm9kZSkge1xuICBpZiAoaXNVbmRlZihvbGRWbm9kZS5kYXRhLm9uKSAmJiBpc1VuZGVmKHZub2RlLmRhdGEub24pKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIG9uID0gdm5vZGUuZGF0YS5vbiB8fCB7fTtcbiAgdmFyIG9sZE9uID0gb2xkVm5vZGUuZGF0YS5vbiB8fCB7fTtcbiAgdGFyZ2V0JDEgPSB2bm9kZS5lbG07XG4gIG5vcm1hbGl6ZUV2ZW50cyhvbik7XG4gIHVwZGF0ZUxpc3RlbmVycyhvbiwgb2xkT24sIGFkZCQxLCByZW1vdmUkMiwgdm5vZGUuY29udGV4dCk7XG4gIHRhcmdldCQxID0gdW5kZWZpbmVkO1xufVxuXG52YXIgZXZlbnRzID0ge1xuICBjcmVhdGU6IHVwZGF0ZURPTUxpc3RlbmVycyxcbiAgdXBkYXRlOiB1cGRhdGVET01MaXN0ZW5lcnNcbn07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB1cGRhdGVET01Qcm9wcyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIGlmIChpc1VuZGVmKG9sZFZub2RlLmRhdGEuZG9tUHJvcHMpICYmIGlzVW5kZWYodm5vZGUuZGF0YS5kb21Qcm9wcykpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIga2V5LCBjdXI7XG4gIHZhciBlbG0gPSB2bm9kZS5lbG07XG4gIHZhciBvbGRQcm9wcyA9IG9sZFZub2RlLmRhdGEuZG9tUHJvcHMgfHwge307XG4gIHZhciBwcm9wcyA9IHZub2RlLmRhdGEuZG9tUHJvcHMgfHwge307XG4gIC8vIGNsb25lIG9ic2VydmVkIG9iamVjdHMsIGFzIHRoZSB1c2VyIHByb2JhYmx5IHdhbnRzIHRvIG11dGF0ZSBpdFxuICBpZiAoaXNEZWYocHJvcHMuX19vYl9fKSkge1xuICAgIHByb3BzID0gdm5vZGUuZGF0YS5kb21Qcm9wcyA9IGV4dGVuZCh7fSwgcHJvcHMpO1xuICB9XG5cbiAgZm9yIChrZXkgaW4gb2xkUHJvcHMpIHtcbiAgICBpZiAoaXNVbmRlZihwcm9wc1trZXldKSkge1xuICAgICAgZWxtW2tleV0gPSAnJztcbiAgICB9XG4gIH1cbiAgZm9yIChrZXkgaW4gcHJvcHMpIHtcbiAgICBjdXIgPSBwcm9wc1trZXldO1xuICAgIC8vIGlnbm9yZSBjaGlsZHJlbiBpZiB0aGUgbm9kZSBoYXMgdGV4dENvbnRlbnQgb3IgaW5uZXJIVE1MLFxuICAgIC8vIGFzIHRoZXNlIHdpbGwgdGhyb3cgYXdheSBleGlzdGluZyBET00gbm9kZXMgYW5kIGNhdXNlIHJlbW92YWwgZXJyb3JzXG4gICAgLy8gb24gc3Vic2VxdWVudCBwYXRjaGVzICgjMzM2MClcbiAgICBpZiAoa2V5ID09PSAndGV4dENvbnRlbnQnIHx8IGtleSA9PT0gJ2lubmVySFRNTCcpIHtcbiAgICAgIGlmICh2bm9kZS5jaGlsZHJlbikgeyB2bm9kZS5jaGlsZHJlbi5sZW5ndGggPSAwOyB9XG4gICAgICBpZiAoY3VyID09PSBvbGRQcm9wc1trZXldKSB7IGNvbnRpbnVlIH1cbiAgICAgIC8vICM2NjAxIHdvcmsgYXJvdW5kIENocm9tZSB2ZXJzaW9uIDw9IDU1IGJ1ZyB3aGVyZSBzaW5nbGUgdGV4dE5vZGVcbiAgICAgIC8vIHJlcGxhY2VkIGJ5IGlubmVySFRNTC90ZXh0Q29udGVudCByZXRhaW5zIGl0cyBwYXJlbnROb2RlIHByb3BlcnR5XG4gICAgICBpZiAoZWxtLmNoaWxkTm9kZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGVsbS5yZW1vdmVDaGlsZChlbG0uY2hpbGROb2Rlc1swXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGtleSA9PT0gJ3ZhbHVlJykge1xuICAgICAgLy8gc3RvcmUgdmFsdWUgYXMgX3ZhbHVlIGFzIHdlbGwgc2luY2VcbiAgICAgIC8vIG5vbi1zdHJpbmcgdmFsdWVzIHdpbGwgYmUgc3RyaW5naWZpZWRcbiAgICAgIGVsbS5fdmFsdWUgPSBjdXI7XG4gICAgICAvLyBhdm9pZCByZXNldHRpbmcgY3Vyc29yIHBvc2l0aW9uIHdoZW4gdmFsdWUgaXMgdGhlIHNhbWVcbiAgICAgIHZhciBzdHJDdXIgPSBpc1VuZGVmKGN1cikgPyAnJyA6IFN0cmluZyhjdXIpO1xuICAgICAgaWYgKHNob3VsZFVwZGF0ZVZhbHVlKGVsbSwgc3RyQ3VyKSkge1xuICAgICAgICBlbG0udmFsdWUgPSBzdHJDdXI7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsbVtrZXldID0gY3VyO1xuICAgIH1cbiAgfVxufVxuXG4vLyBjaGVjayBwbGF0Zm9ybXMvd2ViL3V0aWwvYXR0cnMuanMgYWNjZXB0VmFsdWVcblxuXG5mdW5jdGlvbiBzaG91bGRVcGRhdGVWYWx1ZSAoZWxtLCBjaGVja1ZhbCkge1xuICByZXR1cm4gKCFlbG0uY29tcG9zaW5nICYmIChcbiAgICBlbG0udGFnTmFtZSA9PT0gJ09QVElPTicgfHxcbiAgICBpc05vdEluRm9jdXNBbmREaXJ0eShlbG0sIGNoZWNrVmFsKSB8fFxuICAgIGlzRGlydHlXaXRoTW9kaWZpZXJzKGVsbSwgY2hlY2tWYWwpXG4gICkpXG59XG5cbmZ1bmN0aW9uIGlzTm90SW5Gb2N1c0FuZERpcnR5IChlbG0sIGNoZWNrVmFsKSB7XG4gIC8vIHJldHVybiB0cnVlIHdoZW4gdGV4dGJveCAoLm51bWJlciBhbmQgLnRyaW0pIGxvc2VzIGZvY3VzIGFuZCBpdHMgdmFsdWUgaXNcbiAgLy8gbm90IGVxdWFsIHRvIHRoZSB1cGRhdGVkIHZhbHVlXG4gIHZhciBub3RJbkZvY3VzID0gdHJ1ZTtcbiAgLy8gIzYxNTdcbiAgLy8gd29yayBhcm91bmQgSUUgYnVnIHdoZW4gYWNjZXNzaW5nIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgaW4gYW4gaWZyYW1lXG4gIHRyeSB7IG5vdEluRm9jdXMgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICE9PSBlbG07IH0gY2F0Y2ggKGUpIHt9XG4gIHJldHVybiBub3RJbkZvY3VzICYmIGVsbS52YWx1ZSAhPT0gY2hlY2tWYWxcbn1cblxuZnVuY3Rpb24gaXNEaXJ0eVdpdGhNb2RpZmllcnMgKGVsbSwgbmV3VmFsKSB7XG4gIHZhciB2YWx1ZSA9IGVsbS52YWx1ZTtcbiAgdmFyIG1vZGlmaWVycyA9IGVsbS5fdk1vZGlmaWVyczsgLy8gaW5qZWN0ZWQgYnkgdi1tb2RlbCBydW50aW1lXG4gIGlmIChpc0RlZihtb2RpZmllcnMpKSB7XG4gICAgaWYgKG1vZGlmaWVycy5sYXp5KSB7XG4gICAgICAvLyBpbnB1dHMgd2l0aCBsYXp5IHNob3VsZCBvbmx5IGJlIHVwZGF0ZWQgd2hlbiBub3QgaW4gZm9jdXNcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICBpZiAobW9kaWZpZXJzLm51bWJlcikge1xuICAgICAgcmV0dXJuIHRvTnVtYmVyKHZhbHVlKSAhPT0gdG9OdW1iZXIobmV3VmFsKVxuICAgIH1cbiAgICBpZiAobW9kaWZpZXJzLnRyaW0pIHtcbiAgICAgIHJldHVybiB2YWx1ZS50cmltKCkgIT09IG5ld1ZhbC50cmltKClcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZhbHVlICE9PSBuZXdWYWxcbn1cblxudmFyIGRvbVByb3BzID0ge1xuICBjcmVhdGU6IHVwZGF0ZURPTVByb3BzLFxuICB1cGRhdGU6IHVwZGF0ZURPTVByb3BzXG59O1xuXG4vKiAgKi9cblxudmFyIHBhcnNlU3R5bGVUZXh0ID0gY2FjaGVkKGZ1bmN0aW9uIChjc3NUZXh0KSB7XG4gIHZhciByZXMgPSB7fTtcbiAgdmFyIGxpc3REZWxpbWl0ZXIgPSAvOyg/IVteKF0qXFwpKS9nO1xuICB2YXIgcHJvcGVydHlEZWxpbWl0ZXIgPSAvOiguKykvO1xuICBjc3NUZXh0LnNwbGl0KGxpc3REZWxpbWl0ZXIpLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICBpZiAoaXRlbSkge1xuICAgICAgdmFyIHRtcCA9IGl0ZW0uc3BsaXQocHJvcGVydHlEZWxpbWl0ZXIpO1xuICAgICAgdG1wLmxlbmd0aCA+IDEgJiYgKHJlc1t0bXBbMF0udHJpbSgpXSA9IHRtcFsxXS50cmltKCkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXNcbn0pO1xuXG4vLyBtZXJnZSBzdGF0aWMgYW5kIGR5bmFtaWMgc3R5bGUgZGF0YSBvbiB0aGUgc2FtZSB2bm9kZVxuZnVuY3Rpb24gbm9ybWFsaXplU3R5bGVEYXRhIChkYXRhKSB7XG4gIHZhciBzdHlsZSA9IG5vcm1hbGl6ZVN0eWxlQmluZGluZyhkYXRhLnN0eWxlKTtcbiAgLy8gc3RhdGljIHN0eWxlIGlzIHByZS1wcm9jZXNzZWQgaW50byBhbiBvYmplY3QgZHVyaW5nIGNvbXBpbGF0aW9uXG4gIC8vIGFuZCBpcyBhbHdheXMgYSBmcmVzaCBvYmplY3QsIHNvIGl0J3Mgc2FmZSB0byBtZXJnZSBpbnRvIGl0XG4gIHJldHVybiBkYXRhLnN0YXRpY1N0eWxlXG4gICAgPyBleHRlbmQoZGF0YS5zdGF0aWNTdHlsZSwgc3R5bGUpXG4gICAgOiBzdHlsZVxufVxuXG4vLyBub3JtYWxpemUgcG9zc2libGUgYXJyYXkgLyBzdHJpbmcgdmFsdWVzIGludG8gT2JqZWN0XG5mdW5jdGlvbiBub3JtYWxpemVTdHlsZUJpbmRpbmcgKGJpbmRpbmdTdHlsZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShiaW5kaW5nU3R5bGUpKSB7XG4gICAgcmV0dXJuIHRvT2JqZWN0KGJpbmRpbmdTdHlsZSlcbiAgfVxuICBpZiAodHlwZW9mIGJpbmRpbmdTdHlsZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gcGFyc2VTdHlsZVRleHQoYmluZGluZ1N0eWxlKVxuICB9XG4gIHJldHVybiBiaW5kaW5nU3R5bGVcbn1cblxuLyoqXG4gKiBwYXJlbnQgY29tcG9uZW50IHN0eWxlIHNob3VsZCBiZSBhZnRlciBjaGlsZCdzXG4gKiBzbyB0aGF0IHBhcmVudCBjb21wb25lbnQncyBzdHlsZSBjb3VsZCBvdmVycmlkZSBpdFxuICovXG5mdW5jdGlvbiBnZXRTdHlsZSAodm5vZGUsIGNoZWNrQ2hpbGQpIHtcbiAgdmFyIHJlcyA9IHt9O1xuICB2YXIgc3R5bGVEYXRhO1xuXG4gIGlmIChjaGVja0NoaWxkKSB7XG4gICAgdmFyIGNoaWxkTm9kZSA9IHZub2RlO1xuICAgIHdoaWxlIChjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UpIHtcbiAgICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XG4gICAgICBpZiAoXG4gICAgICAgIGNoaWxkTm9kZSAmJiBjaGlsZE5vZGUuZGF0YSAmJlxuICAgICAgICAoc3R5bGVEYXRhID0gbm9ybWFsaXplU3R5bGVEYXRhKGNoaWxkTm9kZS5kYXRhKSlcbiAgICAgICkge1xuICAgICAgICBleHRlbmQocmVzLCBzdHlsZURhdGEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICgoc3R5bGVEYXRhID0gbm9ybWFsaXplU3R5bGVEYXRhKHZub2RlLmRhdGEpKSkge1xuICAgIGV4dGVuZChyZXMsIHN0eWxlRGF0YSk7XG4gIH1cblxuICB2YXIgcGFyZW50Tm9kZSA9IHZub2RlO1xuICB3aGlsZSAoKHBhcmVudE5vZGUgPSBwYXJlbnROb2RlLnBhcmVudCkpIHtcbiAgICBpZiAocGFyZW50Tm9kZS5kYXRhICYmIChzdHlsZURhdGEgPSBub3JtYWxpemVTdHlsZURhdGEocGFyZW50Tm9kZS5kYXRhKSkpIHtcbiAgICAgIGV4dGVuZChyZXMsIHN0eWxlRGF0YSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbnZhciBjc3NWYXJSRSA9IC9eLS0vO1xudmFyIGltcG9ydGFudFJFID0gL1xccyohaW1wb3J0YW50JC87XG52YXIgc2V0UHJvcCA9IGZ1bmN0aW9uIChlbCwgbmFtZSwgdmFsKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoY3NzVmFyUkUudGVzdChuYW1lKSkge1xuICAgIGVsLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHZhbCk7XG4gIH0gZWxzZSBpZiAoaW1wb3J0YW50UkUudGVzdCh2YWwpKSB7XG4gICAgZWwuc3R5bGUuc2V0UHJvcGVydHkobmFtZSwgdmFsLnJlcGxhY2UoaW1wb3J0YW50UkUsICcnKSwgJ2ltcG9ydGFudCcpO1xuICB9IGVsc2Uge1xuICAgIHZhciBub3JtYWxpemVkTmFtZSA9IG5vcm1hbGl6ZShuYW1lKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICAvLyBTdXBwb3J0IHZhbHVlcyBhcnJheSBjcmVhdGVkIGJ5IGF1dG9wcmVmaXhlciwgZS5nLlxuICAgICAgLy8ge2Rpc3BsYXk6IFtcIi13ZWJraXQtYm94XCIsIFwiLW1zLWZsZXhib3hcIiwgXCJmbGV4XCJdfVxuICAgICAgLy8gU2V0IHRoZW0gb25lIGJ5IG9uZSwgYW5kIHRoZSBicm93c2VyIHdpbGwgb25seSBzZXQgdGhvc2UgaXQgY2FuIHJlY29nbml6ZVxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHZhbC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBlbC5zdHlsZVtub3JtYWxpemVkTmFtZV0gPSB2YWxbaV07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnN0eWxlW25vcm1hbGl6ZWROYW1lXSA9IHZhbDtcbiAgICB9XG4gIH1cbn07XG5cbnZhciB2ZW5kb3JOYW1lcyA9IFsnV2Via2l0JywgJ01veicsICdtcyddO1xuXG52YXIgZW1wdHlTdHlsZTtcbnZhciBub3JtYWxpemUgPSBjYWNoZWQoZnVuY3Rpb24gKHByb3ApIHtcbiAgZW1wdHlTdHlsZSA9IGVtcHR5U3R5bGUgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jykuc3R5bGU7XG4gIHByb3AgPSBjYW1lbGl6ZShwcm9wKTtcbiAgaWYgKHByb3AgIT09ICdmaWx0ZXInICYmIChwcm9wIGluIGVtcHR5U3R5bGUpKSB7XG4gICAgcmV0dXJuIHByb3BcbiAgfVxuICB2YXIgY2FwTmFtZSA9IHByb3AuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBwcm9wLnNsaWNlKDEpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHZlbmRvck5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG5hbWUgPSB2ZW5kb3JOYW1lc1tpXSArIGNhcE5hbWU7XG4gICAgaWYgKG5hbWUgaW4gZW1wdHlTdHlsZSkge1xuICAgICAgcmV0dXJuIG5hbWVcbiAgICB9XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiB1cGRhdGVTdHlsZSAob2xkVm5vZGUsIHZub2RlKSB7XG4gIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgdmFyIG9sZERhdGEgPSBvbGRWbm9kZS5kYXRhO1xuXG4gIGlmIChpc1VuZGVmKGRhdGEuc3RhdGljU3R5bGUpICYmIGlzVW5kZWYoZGF0YS5zdHlsZSkgJiZcbiAgICBpc1VuZGVmKG9sZERhdGEuc3RhdGljU3R5bGUpICYmIGlzVW5kZWYob2xkRGF0YS5zdHlsZSlcbiAgKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY3VyLCBuYW1lO1xuICB2YXIgZWwgPSB2bm9kZS5lbG07XG4gIHZhciBvbGRTdGF0aWNTdHlsZSA9IG9sZERhdGEuc3RhdGljU3R5bGU7XG4gIHZhciBvbGRTdHlsZUJpbmRpbmcgPSBvbGREYXRhLm5vcm1hbGl6ZWRTdHlsZSB8fCBvbGREYXRhLnN0eWxlIHx8IHt9O1xuXG4gIC8vIGlmIHN0YXRpYyBzdHlsZSBleGlzdHMsIHN0eWxlYmluZGluZyBhbHJlYWR5IG1lcmdlZCBpbnRvIGl0IHdoZW4gZG9pbmcgbm9ybWFsaXplU3R5bGVEYXRhXG4gIHZhciBvbGRTdHlsZSA9IG9sZFN0YXRpY1N0eWxlIHx8IG9sZFN0eWxlQmluZGluZztcblxuICB2YXIgc3R5bGUgPSBub3JtYWxpemVTdHlsZUJpbmRpbmcodm5vZGUuZGF0YS5zdHlsZSkgfHwge307XG5cbiAgLy8gc3RvcmUgbm9ybWFsaXplZCBzdHlsZSB1bmRlciBhIGRpZmZlcmVudCBrZXkgZm9yIG5leHQgZGlmZlxuICAvLyBtYWtlIHN1cmUgdG8gY2xvbmUgaXQgaWYgaXQncyByZWFjdGl2ZSwgc2luY2UgdGhlIHVzZXIgbGlrZWx5IHdhbnRzXG4gIC8vIHRvIG11dGF0ZSBpdC5cbiAgdm5vZGUuZGF0YS5ub3JtYWxpemVkU3R5bGUgPSBpc0RlZihzdHlsZS5fX29iX18pXG4gICAgPyBleHRlbmQoe30sIHN0eWxlKVxuICAgIDogc3R5bGU7XG5cbiAgdmFyIG5ld1N0eWxlID0gZ2V0U3R5bGUodm5vZGUsIHRydWUpO1xuXG4gIGZvciAobmFtZSBpbiBvbGRTdHlsZSkge1xuICAgIGlmIChpc1VuZGVmKG5ld1N0eWxlW25hbWVdKSkge1xuICAgICAgc2V0UHJvcChlbCwgbmFtZSwgJycpO1xuICAgIH1cbiAgfVxuICBmb3IgKG5hbWUgaW4gbmV3U3R5bGUpIHtcbiAgICBjdXIgPSBuZXdTdHlsZVtuYW1lXTtcbiAgICBpZiAoY3VyICE9PSBvbGRTdHlsZVtuYW1lXSkge1xuICAgICAgLy8gaWU5IHNldHRpbmcgdG8gbnVsbCBoYXMgbm8gZWZmZWN0LCBtdXN0IHVzZSBlbXB0eSBzdHJpbmdcbiAgICAgIHNldFByb3AoZWwsIG5hbWUsIGN1ciA9PSBudWxsID8gJycgOiBjdXIpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgc3R5bGUgPSB7XG4gIGNyZWF0ZTogdXBkYXRlU3R5bGUsXG4gIHVwZGF0ZTogdXBkYXRlU3R5bGVcbn07XG5cbi8qICAqL1xuXG4vKipcbiAqIEFkZCBjbGFzcyB3aXRoIGNvbXBhdGliaWxpdHkgZm9yIFNWRyBzaW5jZSBjbGFzc0xpc3QgaXMgbm90IHN1cHBvcnRlZCBvblxuICogU1ZHIGVsZW1lbnRzIGluIElFXG4gKi9cbmZ1bmN0aW9uIGFkZENsYXNzIChlbCwgY2xzKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWNscyB8fCAhKGNscyA9IGNscy50cmltKCkpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoZWwuY2xhc3NMaXN0KSB7XG4gICAgaWYgKGNscy5pbmRleE9mKCcgJykgPiAtMSkge1xuICAgICAgY2xzLnNwbGl0KC9cXHMrLykuZm9yRWFjaChmdW5jdGlvbiAoYykgeyByZXR1cm4gZWwuY2xhc3NMaXN0LmFkZChjKTsgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLmNsYXNzTGlzdC5hZGQoY2xzKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGN1ciA9IFwiIFwiICsgKGVsLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSB8fCAnJykgKyBcIiBcIjtcbiAgICBpZiAoY3VyLmluZGV4T2YoJyAnICsgY2xzICsgJyAnKSA8IDApIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAoY3VyICsgY2xzKS50cmltKCkpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZSBjbGFzcyB3aXRoIGNvbXBhdGliaWxpdHkgZm9yIFNWRyBzaW5jZSBjbGFzc0xpc3QgaXMgbm90IHN1cHBvcnRlZCBvblxuICogU1ZHIGVsZW1lbnRzIGluIElFXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUNsYXNzIChlbCwgY2xzKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWNscyB8fCAhKGNscyA9IGNscy50cmltKCkpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoZWwuY2xhc3NMaXN0KSB7XG4gICAgaWYgKGNscy5pbmRleE9mKCcgJykgPiAtMSkge1xuICAgICAgY2xzLnNwbGl0KC9cXHMrLykuZm9yRWFjaChmdW5jdGlvbiAoYykgeyByZXR1cm4gZWwuY2xhc3NMaXN0LnJlbW92ZShjKTsgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoY2xzKTtcbiAgICB9XG4gICAgaWYgKCFlbC5jbGFzc0xpc3QubGVuZ3RoKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ2NsYXNzJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBjdXIgPSBcIiBcIiArIChlbC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgfHwgJycpICsgXCIgXCI7XG4gICAgdmFyIHRhciA9ICcgJyArIGNscyArICcgJztcbiAgICB3aGlsZSAoY3VyLmluZGV4T2YodGFyKSA+PSAwKSB7XG4gICAgICBjdXIgPSBjdXIucmVwbGFjZSh0YXIsICcgJyk7XG4gICAgfVxuICAgIGN1ciA9IGN1ci50cmltKCk7XG4gICAgaWYgKGN1cikge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIGN1cik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgnY2xhc3MnKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIHJlc29sdmVUcmFuc2l0aW9uIChkZWYpIHtcbiAgaWYgKCFkZWYpIHtcbiAgICByZXR1cm5cbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAodHlwZW9mIGRlZiA9PT0gJ29iamVjdCcpIHtcbiAgICB2YXIgcmVzID0ge307XG4gICAgaWYgKGRlZi5jc3MgIT09IGZhbHNlKSB7XG4gICAgICBleHRlbmQocmVzLCBhdXRvQ3NzVHJhbnNpdGlvbihkZWYubmFtZSB8fCAndicpKTtcbiAgICB9XG4gICAgZXh0ZW5kKHJlcywgZGVmKTtcbiAgICByZXR1cm4gcmVzXG4gIH0gZWxzZSBpZiAodHlwZW9mIGRlZiA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gYXV0b0Nzc1RyYW5zaXRpb24oZGVmKVxuICB9XG59XG5cbnZhciBhdXRvQ3NzVHJhbnNpdGlvbiA9IGNhY2hlZChmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4ge1xuICAgIGVudGVyQ2xhc3M6IChuYW1lICsgXCItZW50ZXJcIiksXG4gICAgZW50ZXJUb0NsYXNzOiAobmFtZSArIFwiLWVudGVyLXRvXCIpLFxuICAgIGVudGVyQWN0aXZlQ2xhc3M6IChuYW1lICsgXCItZW50ZXItYWN0aXZlXCIpLFxuICAgIGxlYXZlQ2xhc3M6IChuYW1lICsgXCItbGVhdmVcIiksXG4gICAgbGVhdmVUb0NsYXNzOiAobmFtZSArIFwiLWxlYXZlLXRvXCIpLFxuICAgIGxlYXZlQWN0aXZlQ2xhc3M6IChuYW1lICsgXCItbGVhdmUtYWN0aXZlXCIpXG4gIH1cbn0pO1xuXG52YXIgaGFzVHJhbnNpdGlvbiA9IGluQnJvd3NlciAmJiAhaXNJRTk7XG52YXIgVFJBTlNJVElPTiA9ICd0cmFuc2l0aW9uJztcbnZhciBBTklNQVRJT04gPSAnYW5pbWF0aW9uJztcblxuLy8gVHJhbnNpdGlvbiBwcm9wZXJ0eS9ldmVudCBzbmlmZmluZ1xudmFyIHRyYW5zaXRpb25Qcm9wID0gJ3RyYW5zaXRpb24nO1xudmFyIHRyYW5zaXRpb25FbmRFdmVudCA9ICd0cmFuc2l0aW9uZW5kJztcbnZhciBhbmltYXRpb25Qcm9wID0gJ2FuaW1hdGlvbic7XG52YXIgYW5pbWF0aW9uRW5kRXZlbnQgPSAnYW5pbWF0aW9uZW5kJztcbmlmIChoYXNUcmFuc2l0aW9uKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAod2luZG93Lm9udHJhbnNpdGlvbmVuZCA9PT0gdW5kZWZpbmVkICYmXG4gICAgd2luZG93Lm9ud2Via2l0dHJhbnNpdGlvbmVuZCAhPT0gdW5kZWZpbmVkXG4gICkge1xuICAgIHRyYW5zaXRpb25Qcm9wID0gJ1dlYmtpdFRyYW5zaXRpb24nO1xuICAgIHRyYW5zaXRpb25FbmRFdmVudCA9ICd3ZWJraXRUcmFuc2l0aW9uRW5kJztcbiAgfVxuICBpZiAod2luZG93Lm9uYW5pbWF0aW9uZW5kID09PSB1bmRlZmluZWQgJiZcbiAgICB3aW5kb3cub253ZWJraXRhbmltYXRpb25lbmQgIT09IHVuZGVmaW5lZFxuICApIHtcbiAgICBhbmltYXRpb25Qcm9wID0gJ1dlYmtpdEFuaW1hdGlvbic7XG4gICAgYW5pbWF0aW9uRW5kRXZlbnQgPSAnd2Via2l0QW5pbWF0aW9uRW5kJztcbiAgfVxufVxuXG4vLyBiaW5kaW5nIHRvIHdpbmRvdyBpcyBuZWNlc3NhcnkgdG8gbWFrZSBob3QgcmVsb2FkIHdvcmsgaW4gSUUgaW4gc3RyaWN0IG1vZGVcbnZhciByYWYgPSBpbkJyb3dzZXJcbiAgPyB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gICAgPyB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lLmJpbmQod2luZG93KVxuICAgIDogc2V0VGltZW91dFxuICA6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIGZ1bmN0aW9uIChmbikgeyByZXR1cm4gZm4oKTsgfTtcblxuZnVuY3Rpb24gbmV4dEZyYW1lIChmbikge1xuICByYWYoZnVuY3Rpb24gKCkge1xuICAgIHJhZihmbik7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBhZGRUcmFuc2l0aW9uQ2xhc3MgKGVsLCBjbHMpIHtcbiAgdmFyIHRyYW5zaXRpb25DbGFzc2VzID0gZWwuX3RyYW5zaXRpb25DbGFzc2VzIHx8IChlbC5fdHJhbnNpdGlvbkNsYXNzZXMgPSBbXSk7XG4gIGlmICh0cmFuc2l0aW9uQ2xhc3Nlcy5pbmRleE9mKGNscykgPCAwKSB7XG4gICAgdHJhbnNpdGlvbkNsYXNzZXMucHVzaChjbHMpO1xuICAgIGFkZENsYXNzKGVsLCBjbHMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVRyYW5zaXRpb25DbGFzcyAoZWwsIGNscykge1xuICBpZiAoZWwuX3RyYW5zaXRpb25DbGFzc2VzKSB7XG4gICAgcmVtb3ZlKGVsLl90cmFuc2l0aW9uQ2xhc3NlcywgY2xzKTtcbiAgfVxuICByZW1vdmVDbGFzcyhlbCwgY2xzKTtcbn1cblxuZnVuY3Rpb24gd2hlblRyYW5zaXRpb25FbmRzIChcbiAgZWwsXG4gIGV4cGVjdGVkVHlwZSxcbiAgY2Jcbikge1xuICB2YXIgcmVmID0gZ2V0VHJhbnNpdGlvbkluZm8oZWwsIGV4cGVjdGVkVHlwZSk7XG4gIHZhciB0eXBlID0gcmVmLnR5cGU7XG4gIHZhciB0aW1lb3V0ID0gcmVmLnRpbWVvdXQ7XG4gIHZhciBwcm9wQ291bnQgPSByZWYucHJvcENvdW50O1xuICBpZiAoIXR5cGUpIHsgcmV0dXJuIGNiKCkgfVxuICB2YXIgZXZlbnQgPSB0eXBlID09PSBUUkFOU0lUSU9OID8gdHJhbnNpdGlvbkVuZEV2ZW50IDogYW5pbWF0aW9uRW5kRXZlbnQ7XG4gIHZhciBlbmRlZCA9IDA7XG4gIHZhciBlbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgb25FbmQpO1xuICAgIGNiKCk7XG4gIH07XG4gIHZhciBvbkVuZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUudGFyZ2V0ID09PSBlbCkge1xuICAgICAgaWYgKCsrZW5kZWQgPj0gcHJvcENvdW50KSB7XG4gICAgICAgIGVuZCgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGVuZGVkIDwgcHJvcENvdW50KSB7XG4gICAgICBlbmQoKTtcbiAgICB9XG4gIH0sIHRpbWVvdXQgKyAxKTtcbiAgZWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgb25FbmQpO1xufVxuXG52YXIgdHJhbnNmb3JtUkUgPSAvXFxiKHRyYW5zZm9ybXxhbGwpKCx8JCkvO1xuXG5mdW5jdGlvbiBnZXRUcmFuc2l0aW9uSW5mbyAoZWwsIGV4cGVjdGVkVHlwZSkge1xuICB2YXIgc3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpO1xuICB2YXIgdHJhbnNpdGlvbkRlbGF5cyA9IHN0eWxlc1t0cmFuc2l0aW9uUHJvcCArICdEZWxheSddLnNwbGl0KCcsICcpO1xuICB2YXIgdHJhbnNpdGlvbkR1cmF0aW9ucyA9IHN0eWxlc1t0cmFuc2l0aW9uUHJvcCArICdEdXJhdGlvbiddLnNwbGl0KCcsICcpO1xuICB2YXIgdHJhbnNpdGlvblRpbWVvdXQgPSBnZXRUaW1lb3V0KHRyYW5zaXRpb25EZWxheXMsIHRyYW5zaXRpb25EdXJhdGlvbnMpO1xuICB2YXIgYW5pbWF0aW9uRGVsYXlzID0gc3R5bGVzW2FuaW1hdGlvblByb3AgKyAnRGVsYXknXS5zcGxpdCgnLCAnKTtcbiAgdmFyIGFuaW1hdGlvbkR1cmF0aW9ucyA9IHN0eWxlc1thbmltYXRpb25Qcm9wICsgJ0R1cmF0aW9uJ10uc3BsaXQoJywgJyk7XG4gIHZhciBhbmltYXRpb25UaW1lb3V0ID0gZ2V0VGltZW91dChhbmltYXRpb25EZWxheXMsIGFuaW1hdGlvbkR1cmF0aW9ucyk7XG5cbiAgdmFyIHR5cGU7XG4gIHZhciB0aW1lb3V0ID0gMDtcbiAgdmFyIHByb3BDb3VudCA9IDA7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoZXhwZWN0ZWRUeXBlID09PSBUUkFOU0lUSU9OKSB7XG4gICAgaWYgKHRyYW5zaXRpb25UaW1lb3V0ID4gMCkge1xuICAgICAgdHlwZSA9IFRSQU5TSVRJT047XG4gICAgICB0aW1lb3V0ID0gdHJhbnNpdGlvblRpbWVvdXQ7XG4gICAgICBwcm9wQ291bnQgPSB0cmFuc2l0aW9uRHVyYXRpb25zLmxlbmd0aDtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSBBTklNQVRJT04pIHtcbiAgICBpZiAoYW5pbWF0aW9uVGltZW91dCA+IDApIHtcbiAgICAgIHR5cGUgPSBBTklNQVRJT047XG4gICAgICB0aW1lb3V0ID0gYW5pbWF0aW9uVGltZW91dDtcbiAgICAgIHByb3BDb3VudCA9IGFuaW1hdGlvbkR1cmF0aW9ucy5sZW5ndGg7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRpbWVvdXQgPSBNYXRoLm1heCh0cmFuc2l0aW9uVGltZW91dCwgYW5pbWF0aW9uVGltZW91dCk7XG4gICAgdHlwZSA9IHRpbWVvdXQgPiAwXG4gICAgICA/IHRyYW5zaXRpb25UaW1lb3V0ID4gYW5pbWF0aW9uVGltZW91dFxuICAgICAgICA/IFRSQU5TSVRJT05cbiAgICAgICAgOiBBTklNQVRJT05cbiAgICAgIDogbnVsbDtcbiAgICBwcm9wQ291bnQgPSB0eXBlXG4gICAgICA/IHR5cGUgPT09IFRSQU5TSVRJT05cbiAgICAgICAgPyB0cmFuc2l0aW9uRHVyYXRpb25zLmxlbmd0aFxuICAgICAgICA6IGFuaW1hdGlvbkR1cmF0aW9ucy5sZW5ndGhcbiAgICAgIDogMDtcbiAgfVxuICB2YXIgaGFzVHJhbnNmb3JtID1cbiAgICB0eXBlID09PSBUUkFOU0lUSU9OICYmXG4gICAgdHJhbnNmb3JtUkUudGVzdChzdHlsZXNbdHJhbnNpdGlvblByb3AgKyAnUHJvcGVydHknXSk7XG4gIHJldHVybiB7XG4gICAgdHlwZTogdHlwZSxcbiAgICB0aW1lb3V0OiB0aW1lb3V0LFxuICAgIHByb3BDb3VudDogcHJvcENvdW50LFxuICAgIGhhc1RyYW5zZm9ybTogaGFzVHJhbnNmb3JtXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0VGltZW91dCAoZGVsYXlzLCBkdXJhdGlvbnMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgd2hpbGUgKGRlbGF5cy5sZW5ndGggPCBkdXJhdGlvbnMubGVuZ3RoKSB7XG4gICAgZGVsYXlzID0gZGVsYXlzLmNvbmNhdChkZWxheXMpO1xuICB9XG5cbiAgcmV0dXJuIE1hdGgubWF4LmFwcGx5KG51bGwsIGR1cmF0aW9ucy5tYXAoZnVuY3Rpb24gKGQsIGkpIHtcbiAgICByZXR1cm4gdG9NcyhkKSArIHRvTXMoZGVsYXlzW2ldKVxuICB9KSlcbn1cblxuZnVuY3Rpb24gdG9NcyAocykge1xuICByZXR1cm4gTnVtYmVyKHMuc2xpY2UoMCwgLTEpKSAqIDEwMDBcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGVudGVyICh2bm9kZSwgdG9nZ2xlRGlzcGxheSkge1xuICB2YXIgZWwgPSB2bm9kZS5lbG07XG5cbiAgLy8gY2FsbCBsZWF2ZSBjYWxsYmFjayBub3dcbiAgaWYgKGlzRGVmKGVsLl9sZWF2ZUNiKSkge1xuICAgIGVsLl9sZWF2ZUNiLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgZWwuX2xlYXZlQ2IoKTtcbiAgfVxuXG4gIHZhciBkYXRhID0gcmVzb2x2ZVRyYW5zaXRpb24odm5vZGUuZGF0YS50cmFuc2l0aW9uKTtcbiAgaWYgKGlzVW5kZWYoZGF0YSkpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNEZWYoZWwuX2VudGVyQ2IpIHx8IGVsLm5vZGVUeXBlICE9PSAxKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY3NzID0gZGF0YS5jc3M7XG4gIHZhciB0eXBlID0gZGF0YS50eXBlO1xuICB2YXIgZW50ZXJDbGFzcyA9IGRhdGEuZW50ZXJDbGFzcztcbiAgdmFyIGVudGVyVG9DbGFzcyA9IGRhdGEuZW50ZXJUb0NsYXNzO1xuICB2YXIgZW50ZXJBY3RpdmVDbGFzcyA9IGRhdGEuZW50ZXJBY3RpdmVDbGFzcztcbiAgdmFyIGFwcGVhckNsYXNzID0gZGF0YS5hcHBlYXJDbGFzcztcbiAgdmFyIGFwcGVhclRvQ2xhc3MgPSBkYXRhLmFwcGVhclRvQ2xhc3M7XG4gIHZhciBhcHBlYXJBY3RpdmVDbGFzcyA9IGRhdGEuYXBwZWFyQWN0aXZlQ2xhc3M7XG4gIHZhciBiZWZvcmVFbnRlciA9IGRhdGEuYmVmb3JlRW50ZXI7XG4gIHZhciBlbnRlciA9IGRhdGEuZW50ZXI7XG4gIHZhciBhZnRlckVudGVyID0gZGF0YS5hZnRlckVudGVyO1xuICB2YXIgZW50ZXJDYW5jZWxsZWQgPSBkYXRhLmVudGVyQ2FuY2VsbGVkO1xuICB2YXIgYmVmb3JlQXBwZWFyID0gZGF0YS5iZWZvcmVBcHBlYXI7XG4gIHZhciBhcHBlYXIgPSBkYXRhLmFwcGVhcjtcbiAgdmFyIGFmdGVyQXBwZWFyID0gZGF0YS5hZnRlckFwcGVhcjtcbiAgdmFyIGFwcGVhckNhbmNlbGxlZCA9IGRhdGEuYXBwZWFyQ2FuY2VsbGVkO1xuICB2YXIgZHVyYXRpb24gPSBkYXRhLmR1cmF0aW9uO1xuXG4gIC8vIGFjdGl2ZUluc3RhbmNlIHdpbGwgYWx3YXlzIGJlIHRoZSA8dHJhbnNpdGlvbj4gY29tcG9uZW50IG1hbmFnaW5nIHRoaXNcbiAgLy8gdHJhbnNpdGlvbi4gT25lIGVkZ2UgY2FzZSB0byBjaGVjayBpcyB3aGVuIHRoZSA8dHJhbnNpdGlvbj4gaXMgcGxhY2VkXG4gIC8vIGFzIHRoZSByb290IG5vZGUgb2YgYSBjaGlsZCBjb21wb25lbnQuIEluIHRoYXQgY2FzZSB3ZSBuZWVkIHRvIGNoZWNrXG4gIC8vIDx0cmFuc2l0aW9uPidzIHBhcmVudCBmb3IgYXBwZWFyIGNoZWNrLlxuICB2YXIgY29udGV4dCA9IGFjdGl2ZUluc3RhbmNlO1xuICB2YXIgdHJhbnNpdGlvbk5vZGUgPSBhY3RpdmVJbnN0YW5jZS4kdm5vZGU7XG4gIHdoaWxlICh0cmFuc2l0aW9uTm9kZSAmJiB0cmFuc2l0aW9uTm9kZS5wYXJlbnQpIHtcbiAgICB0cmFuc2l0aW9uTm9kZSA9IHRyYW5zaXRpb25Ob2RlLnBhcmVudDtcbiAgICBjb250ZXh0ID0gdHJhbnNpdGlvbk5vZGUuY29udGV4dDtcbiAgfVxuXG4gIHZhciBpc0FwcGVhciA9ICFjb250ZXh0Ll9pc01vdW50ZWQgfHwgIXZub2RlLmlzUm9vdEluc2VydDtcblxuICBpZiAoaXNBcHBlYXIgJiYgIWFwcGVhciAmJiBhcHBlYXIgIT09ICcnKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgc3RhcnRDbGFzcyA9IGlzQXBwZWFyICYmIGFwcGVhckNsYXNzXG4gICAgPyBhcHBlYXJDbGFzc1xuICAgIDogZW50ZXJDbGFzcztcbiAgdmFyIGFjdGl2ZUNsYXNzID0gaXNBcHBlYXIgJiYgYXBwZWFyQWN0aXZlQ2xhc3NcbiAgICA/IGFwcGVhckFjdGl2ZUNsYXNzXG4gICAgOiBlbnRlckFjdGl2ZUNsYXNzO1xuICB2YXIgdG9DbGFzcyA9IGlzQXBwZWFyICYmIGFwcGVhclRvQ2xhc3NcbiAgICA/IGFwcGVhclRvQ2xhc3NcbiAgICA6IGVudGVyVG9DbGFzcztcblxuICB2YXIgYmVmb3JlRW50ZXJIb29rID0gaXNBcHBlYXJcbiAgICA/IChiZWZvcmVBcHBlYXIgfHwgYmVmb3JlRW50ZXIpXG4gICAgOiBiZWZvcmVFbnRlcjtcbiAgdmFyIGVudGVySG9vayA9IGlzQXBwZWFyXG4gICAgPyAodHlwZW9mIGFwcGVhciA9PT0gJ2Z1bmN0aW9uJyA/IGFwcGVhciA6IGVudGVyKVxuICAgIDogZW50ZXI7XG4gIHZhciBhZnRlckVudGVySG9vayA9IGlzQXBwZWFyXG4gICAgPyAoYWZ0ZXJBcHBlYXIgfHwgYWZ0ZXJFbnRlcilcbiAgICA6IGFmdGVyRW50ZXI7XG4gIHZhciBlbnRlckNhbmNlbGxlZEhvb2sgPSBpc0FwcGVhclxuICAgID8gKGFwcGVhckNhbmNlbGxlZCB8fCBlbnRlckNhbmNlbGxlZClcbiAgICA6IGVudGVyQ2FuY2VsbGVkO1xuXG4gIHZhciBleHBsaWNpdEVudGVyRHVyYXRpb24gPSB0b051bWJlcihcbiAgICBpc09iamVjdChkdXJhdGlvbilcbiAgICAgID8gZHVyYXRpb24uZW50ZXJcbiAgICAgIDogZHVyYXRpb25cbiAgKTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBleHBsaWNpdEVudGVyRHVyYXRpb24gIT0gbnVsbCkge1xuICAgIGNoZWNrRHVyYXRpb24oZXhwbGljaXRFbnRlckR1cmF0aW9uLCAnZW50ZXInLCB2bm9kZSk7XG4gIH1cblxuICB2YXIgZXhwZWN0c0NTUyA9IGNzcyAhPT0gZmFsc2UgJiYgIWlzSUU5O1xuICB2YXIgdXNlcldhbnRzQ29udHJvbCA9IGdldEhvb2tBcmd1bWVudHNMZW5ndGgoZW50ZXJIb29rKTtcblxuICB2YXIgY2IgPSBlbC5fZW50ZXJDYiA9IG9uY2UoZnVuY3Rpb24gKCkge1xuICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIHRvQ2xhc3MpO1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBhY3RpdmVDbGFzcyk7XG4gICAgfVxuICAgIGlmIChjYi5jYW5jZWxsZWQpIHtcbiAgICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgc3RhcnRDbGFzcyk7XG4gICAgICB9XG4gICAgICBlbnRlckNhbmNlbGxlZEhvb2sgJiYgZW50ZXJDYW5jZWxsZWRIb29rKGVsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWZ0ZXJFbnRlckhvb2sgJiYgYWZ0ZXJFbnRlckhvb2soZWwpO1xuICAgIH1cbiAgICBlbC5fZW50ZXJDYiA9IG51bGw7XG4gIH0pO1xuXG4gIGlmICghdm5vZGUuZGF0YS5zaG93KSB7XG4gICAgLy8gcmVtb3ZlIHBlbmRpbmcgbGVhdmUgZWxlbWVudCBvbiBlbnRlciBieSBpbmplY3RpbmcgYW4gaW5zZXJ0IGhvb2tcbiAgICBtZXJnZVZOb2RlSG9vayh2bm9kZSwgJ2luc2VydCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBwYXJlbnQgPSBlbC5wYXJlbnROb2RlO1xuICAgICAgdmFyIHBlbmRpbmdOb2RlID0gcGFyZW50ICYmIHBhcmVudC5fcGVuZGluZyAmJiBwYXJlbnQuX3BlbmRpbmdbdm5vZGUua2V5XTtcbiAgICAgIGlmIChwZW5kaW5nTm9kZSAmJlxuICAgICAgICBwZW5kaW5nTm9kZS50YWcgPT09IHZub2RlLnRhZyAmJlxuICAgICAgICBwZW5kaW5nTm9kZS5lbG0uX2xlYXZlQ2JcbiAgICAgICkge1xuICAgICAgICBwZW5kaW5nTm9kZS5lbG0uX2xlYXZlQ2IoKTtcbiAgICAgIH1cbiAgICAgIGVudGVySG9vayAmJiBlbnRlckhvb2soZWwsIGNiKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIHN0YXJ0IGVudGVyIHRyYW5zaXRpb25cbiAgYmVmb3JlRW50ZXJIb29rICYmIGJlZm9yZUVudGVySG9vayhlbCk7XG4gIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBzdGFydENsYXNzKTtcbiAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGFjdGl2ZUNsYXNzKTtcbiAgICBuZXh0RnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCB0b0NsYXNzKTtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgc3RhcnRDbGFzcyk7XG4gICAgICBpZiAoIWNiLmNhbmNlbGxlZCAmJiAhdXNlcldhbnRzQ29udHJvbCkge1xuICAgICAgICBpZiAoaXNWYWxpZER1cmF0aW9uKGV4cGxpY2l0RW50ZXJEdXJhdGlvbikpIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KGNiLCBleHBsaWNpdEVudGVyRHVyYXRpb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdoZW5UcmFuc2l0aW9uRW5kcyhlbCwgdHlwZSwgY2IpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBpZiAodm5vZGUuZGF0YS5zaG93KSB7XG4gICAgdG9nZ2xlRGlzcGxheSAmJiB0b2dnbGVEaXNwbGF5KCk7XG4gICAgZW50ZXJIb29rICYmIGVudGVySG9vayhlbCwgY2IpO1xuICB9XG5cbiAgaWYgKCFleHBlY3RzQ1NTICYmICF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgY2IoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBsZWF2ZSAodm5vZGUsIHJtKSB7XG4gIHZhciBlbCA9IHZub2RlLmVsbTtcblxuICAvLyBjYWxsIGVudGVyIGNhbGxiYWNrIG5vd1xuICBpZiAoaXNEZWYoZWwuX2VudGVyQ2IpKSB7XG4gICAgZWwuX2VudGVyQ2IuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICBlbC5fZW50ZXJDYigpO1xuICB9XG5cbiAgdmFyIGRhdGEgPSByZXNvbHZlVHJhbnNpdGlvbih2bm9kZS5kYXRhLnRyYW5zaXRpb24pO1xuICBpZiAoaXNVbmRlZihkYXRhKSB8fCBlbC5ub2RlVHlwZSAhPT0gMSkge1xuICAgIHJldHVybiBybSgpXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGlzRGVmKGVsLl9sZWF2ZUNiKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGNzcyA9IGRhdGEuY3NzO1xuICB2YXIgdHlwZSA9IGRhdGEudHlwZTtcbiAgdmFyIGxlYXZlQ2xhc3MgPSBkYXRhLmxlYXZlQ2xhc3M7XG4gIHZhciBsZWF2ZVRvQ2xhc3MgPSBkYXRhLmxlYXZlVG9DbGFzcztcbiAgdmFyIGxlYXZlQWN0aXZlQ2xhc3MgPSBkYXRhLmxlYXZlQWN0aXZlQ2xhc3M7XG4gIHZhciBiZWZvcmVMZWF2ZSA9IGRhdGEuYmVmb3JlTGVhdmU7XG4gIHZhciBsZWF2ZSA9IGRhdGEubGVhdmU7XG4gIHZhciBhZnRlckxlYXZlID0gZGF0YS5hZnRlckxlYXZlO1xuICB2YXIgbGVhdmVDYW5jZWxsZWQgPSBkYXRhLmxlYXZlQ2FuY2VsbGVkO1xuICB2YXIgZGVsYXlMZWF2ZSA9IGRhdGEuZGVsYXlMZWF2ZTtcbiAgdmFyIGR1cmF0aW9uID0gZGF0YS5kdXJhdGlvbjtcblxuICB2YXIgZXhwZWN0c0NTUyA9IGNzcyAhPT0gZmFsc2UgJiYgIWlzSUU5O1xuICB2YXIgdXNlcldhbnRzQ29udHJvbCA9IGdldEhvb2tBcmd1bWVudHNMZW5ndGgobGVhdmUpO1xuXG4gIHZhciBleHBsaWNpdExlYXZlRHVyYXRpb24gPSB0b051bWJlcihcbiAgICBpc09iamVjdChkdXJhdGlvbilcbiAgICAgID8gZHVyYXRpb24ubGVhdmVcbiAgICAgIDogZHVyYXRpb25cbiAgKTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBpc0RlZihleHBsaWNpdExlYXZlRHVyYXRpb24pKSB7XG4gICAgY2hlY2tEdXJhdGlvbihleHBsaWNpdExlYXZlRHVyYXRpb24sICdsZWF2ZScsIHZub2RlKTtcbiAgfVxuXG4gIHZhciBjYiA9IGVsLl9sZWF2ZUNiID0gb25jZShmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGVsLnBhcmVudE5vZGUgJiYgZWwucGFyZW50Tm9kZS5fcGVuZGluZykge1xuICAgICAgZWwucGFyZW50Tm9kZS5fcGVuZGluZ1t2bm9kZS5rZXldID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVUb0NsYXNzKTtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVBY3RpdmVDbGFzcyk7XG4gICAgfVxuICAgIGlmIChjYi5jYW5jZWxsZWQpIHtcbiAgICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVDbGFzcyk7XG4gICAgICB9XG4gICAgICBsZWF2ZUNhbmNlbGxlZCAmJiBsZWF2ZUNhbmNlbGxlZChlbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJtKCk7XG4gICAgICBhZnRlckxlYXZlICYmIGFmdGVyTGVhdmUoZWwpO1xuICAgIH1cbiAgICBlbC5fbGVhdmVDYiA9IG51bGw7XG4gIH0pO1xuXG4gIGlmIChkZWxheUxlYXZlKSB7XG4gICAgZGVsYXlMZWF2ZShwZXJmb3JtTGVhdmUpO1xuICB9IGVsc2Uge1xuICAgIHBlcmZvcm1MZWF2ZSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVyZm9ybUxlYXZlICgpIHtcbiAgICAvLyB0aGUgZGVsYXllZCBsZWF2ZSBtYXkgaGF2ZSBhbHJlYWR5IGJlZW4gY2FuY2VsbGVkXG4gICAgaWYgKGNiLmNhbmNlbGxlZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIC8vIHJlY29yZCBsZWF2aW5nIGVsZW1lbnRcbiAgICBpZiAoIXZub2RlLmRhdGEuc2hvdykge1xuICAgICAgKGVsLnBhcmVudE5vZGUuX3BlbmRpbmcgfHwgKGVsLnBhcmVudE5vZGUuX3BlbmRpbmcgPSB7fSkpWyh2bm9kZS5rZXkpXSA9IHZub2RlO1xuICAgIH1cbiAgICBiZWZvcmVMZWF2ZSAmJiBiZWZvcmVMZWF2ZShlbCk7XG4gICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVDbGFzcyk7XG4gICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQWN0aXZlQ2xhc3MpO1xuICAgICAgbmV4dEZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZVRvQ2xhc3MpO1xuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQ2xhc3MpO1xuICAgICAgICBpZiAoIWNiLmNhbmNlbGxlZCAmJiAhdXNlcldhbnRzQ29udHJvbCkge1xuICAgICAgICAgIGlmIChpc1ZhbGlkRHVyYXRpb24oZXhwbGljaXRMZWF2ZUR1cmF0aW9uKSkge1xuICAgICAgICAgICAgc2V0VGltZW91dChjYiwgZXhwbGljaXRMZWF2ZUR1cmF0aW9uKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2hlblRyYW5zaXRpb25FbmRzKGVsLCB0eXBlLCBjYik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgbGVhdmUgJiYgbGVhdmUoZWwsIGNiKTtcbiAgICBpZiAoIWV4cGVjdHNDU1MgJiYgIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICAgIGNiKCk7XG4gICAgfVxuICB9XG59XG5cbi8vIG9ubHkgdXNlZCBpbiBkZXYgbW9kZVxuZnVuY3Rpb24gY2hlY2tEdXJhdGlvbiAodmFsLCBuYW1lLCB2bm9kZSkge1xuICBpZiAodHlwZW9mIHZhbCAhPT0gJ251bWJlcicpIHtcbiAgICB3YXJuKFxuICAgICAgXCI8dHJhbnNpdGlvbj4gZXhwbGljaXQgXCIgKyBuYW1lICsgXCIgZHVyYXRpb24gaXMgbm90IGEgdmFsaWQgbnVtYmVyIC0gXCIgK1xuICAgICAgXCJnb3QgXCIgKyAoSlNPTi5zdHJpbmdpZnkodmFsKSkgKyBcIi5cIixcbiAgICAgIHZub2RlLmNvbnRleHRcbiAgICApO1xuICB9IGVsc2UgaWYgKGlzTmFOKHZhbCkpIHtcbiAgICB3YXJuKFxuICAgICAgXCI8dHJhbnNpdGlvbj4gZXhwbGljaXQgXCIgKyBuYW1lICsgXCIgZHVyYXRpb24gaXMgTmFOIC0gXCIgK1xuICAgICAgJ3RoZSBkdXJhdGlvbiBleHByZXNzaW9uIG1pZ2h0IGJlIGluY29ycmVjdC4nLFxuICAgICAgdm5vZGUuY29udGV4dFxuICAgICk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNWYWxpZER1cmF0aW9uICh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdudW1iZXInICYmICFpc05hTih2YWwpXG59XG5cbi8qKlxuICogTm9ybWFsaXplIGEgdHJhbnNpdGlvbiBob29rJ3MgYXJndW1lbnQgbGVuZ3RoLiBUaGUgaG9vayBtYXkgYmU6XG4gKiAtIGEgbWVyZ2VkIGhvb2sgKGludm9rZXIpIHdpdGggdGhlIG9yaWdpbmFsIGluIC5mbnNcbiAqIC0gYSB3cmFwcGVkIGNvbXBvbmVudCBtZXRob2QgKGNoZWNrIC5fbGVuZ3RoKVxuICogLSBhIHBsYWluIGZ1bmN0aW9uICgubGVuZ3RoKVxuICovXG5mdW5jdGlvbiBnZXRIb29rQXJndW1lbnRzTGVuZ3RoIChmbikge1xuICBpZiAoaXNVbmRlZihmbikpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICB2YXIgaW52b2tlckZucyA9IGZuLmZucztcbiAgaWYgKGlzRGVmKGludm9rZXJGbnMpKSB7XG4gICAgLy8gaW52b2tlclxuICAgIHJldHVybiBnZXRIb29rQXJndW1lbnRzTGVuZ3RoKFxuICAgICAgQXJyYXkuaXNBcnJheShpbnZva2VyRm5zKVxuICAgICAgICA/IGludm9rZXJGbnNbMF1cbiAgICAgICAgOiBpbnZva2VyRm5zXG4gICAgKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiAoZm4uX2xlbmd0aCB8fCBmbi5sZW5ndGgpID4gMVxuICB9XG59XG5cbmZ1bmN0aW9uIF9lbnRlciAoXywgdm5vZGUpIHtcbiAgaWYgKHZub2RlLmRhdGEuc2hvdyAhPT0gdHJ1ZSkge1xuICAgIGVudGVyKHZub2RlKTtcbiAgfVxufVxuXG52YXIgdHJhbnNpdGlvbiA9IGluQnJvd3NlciA/IHtcbiAgY3JlYXRlOiBfZW50ZXIsXG4gIGFjdGl2YXRlOiBfZW50ZXIsXG4gIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlJCQxICh2bm9kZSwgcm0pIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmICh2bm9kZS5kYXRhLnNob3cgIT09IHRydWUpIHtcbiAgICAgIGxlYXZlKHZub2RlLCBybSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJtKCk7XG4gICAgfVxuICB9XG59IDoge307XG5cbnZhciBwbGF0Zm9ybU1vZHVsZXMgPSBbXG4gIGF0dHJzLFxuICBrbGFzcyxcbiAgZXZlbnRzLFxuICBkb21Qcm9wcyxcbiAgc3R5bGUsXG4gIHRyYW5zaXRpb25cbl07XG5cbi8qICAqL1xuXG4vLyB0aGUgZGlyZWN0aXZlIG1vZHVsZSBzaG91bGQgYmUgYXBwbGllZCBsYXN0LCBhZnRlciBhbGxcbi8vIGJ1aWx0LWluIG1vZHVsZXMgaGF2ZSBiZWVuIGFwcGxpZWQuXG52YXIgbW9kdWxlcyA9IHBsYXRmb3JtTW9kdWxlcy5jb25jYXQoYmFzZU1vZHVsZXMpO1xuXG52YXIgcGF0Y2ggPSBjcmVhdGVQYXRjaEZ1bmN0aW9uKHsgbm9kZU9wczogbm9kZU9wcywgbW9kdWxlczogbW9kdWxlcyB9KTtcblxuLyoqXG4gKiBOb3QgdHlwZSBjaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBmbG93IGRvZXNuJ3QgbGlrZSBhdHRhY2hpbmdcbiAqIHByb3BlcnRpZXMgdG8gRWxlbWVudHMuXG4gKi9cblxuLyogaXN0YW5idWwgaWdub3JlIGlmICovXG5pZiAoaXNJRTkpIHtcbiAgLy8gaHR0cDovL3d3dy5tYXR0czQxMS5jb20vcG9zdC9pbnRlcm5ldC1leHBsb3Jlci05LW9uaW5wdXQvXG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3NlbGVjdGlvbmNoYW5nZScsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZWwgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgIGlmIChlbCAmJiBlbC52bW9kZWwpIHtcbiAgICAgIHRyaWdnZXIoZWwsICdpbnB1dCcpO1xuICAgIH1cbiAgfSk7XG59XG5cbnZhciBkaXJlY3RpdmUgPSB7XG4gIGluc2VydGVkOiBmdW5jdGlvbiBpbnNlcnRlZCAoZWwsIGJpbmRpbmcsIHZub2RlLCBvbGRWbm9kZSkge1xuICAgIGlmICh2bm9kZS50YWcgPT09ICdzZWxlY3QnKSB7XG4gICAgICAvLyAjNjkwM1xuICAgICAgaWYgKG9sZFZub2RlLmVsbSAmJiAhb2xkVm5vZGUuZWxtLl92T3B0aW9ucykge1xuICAgICAgICBtZXJnZVZOb2RlSG9vayh2bm9kZSwgJ3Bvc3RwYXRjaCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBkaXJlY3RpdmUuY29tcG9uZW50VXBkYXRlZChlbCwgYmluZGluZywgdm5vZGUpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldFNlbGVjdGVkKGVsLCBiaW5kaW5nLCB2bm9kZS5jb250ZXh0KTtcbiAgICAgIH1cbiAgICAgIGVsLl92T3B0aW9ucyA9IFtdLm1hcC5jYWxsKGVsLm9wdGlvbnMsIGdldFZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHZub2RlLnRhZyA9PT0gJ3RleHRhcmVhJyB8fCBpc1RleHRJbnB1dFR5cGUoZWwudHlwZSkpIHtcbiAgICAgIGVsLl92TW9kaWZpZXJzID0gYmluZGluZy5tb2RpZmllcnM7XG4gICAgICBpZiAoIWJpbmRpbmcubW9kaWZpZXJzLmxhenkpIHtcbiAgICAgICAgLy8gU2FmYXJpIDwgMTAuMiAmIFVJV2ViVmlldyBkb2Vzbid0IGZpcmUgY29tcG9zaXRpb25lbmQgd2hlblxuICAgICAgICAvLyBzd2l0Y2hpbmcgZm9jdXMgYmVmb3JlIGNvbmZpcm1pbmcgY29tcG9zaXRpb24gY2hvaWNlXG4gICAgICAgIC8vIHRoaXMgYWxzbyBmaXhlcyB0aGUgaXNzdWUgd2hlcmUgc29tZSBicm93c2VycyBlLmcuIGlPUyBDaHJvbWVcbiAgICAgICAgLy8gZmlyZXMgXCJjaGFuZ2VcIiBpbnN0ZWFkIG9mIFwiaW5wdXRcIiBvbiBhdXRvY29tcGxldGUuXG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIG9uQ29tcG9zaXRpb25FbmQpO1xuICAgICAgICBpZiAoIWlzQW5kcm9pZCkge1xuICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbXBvc2l0aW9uc3RhcnQnLCBvbkNvbXBvc2l0aW9uU3RhcnQpO1xuICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbXBvc2l0aW9uZW5kJywgb25Db21wb3NpdGlvbkVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmIChpc0lFOSkge1xuICAgICAgICAgIGVsLnZtb2RlbCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgY29tcG9uZW50VXBkYXRlZDogZnVuY3Rpb24gY29tcG9uZW50VXBkYXRlZCAoZWwsIGJpbmRpbmcsIHZub2RlKSB7XG4gICAgaWYgKHZub2RlLnRhZyA9PT0gJ3NlbGVjdCcpIHtcbiAgICAgIHNldFNlbGVjdGVkKGVsLCBiaW5kaW5nLCB2bm9kZS5jb250ZXh0KTtcbiAgICAgIC8vIGluIGNhc2UgdGhlIG9wdGlvbnMgcmVuZGVyZWQgYnkgdi1mb3IgaGF2ZSBjaGFuZ2VkLFxuICAgICAgLy8gaXQncyBwb3NzaWJsZSB0aGF0IHRoZSB2YWx1ZSBpcyBvdXQtb2Ytc3luYyB3aXRoIHRoZSByZW5kZXJlZCBvcHRpb25zLlxuICAgICAgLy8gZGV0ZWN0IHN1Y2ggY2FzZXMgYW5kIGZpbHRlciBvdXQgdmFsdWVzIHRoYXQgbm8gbG9uZ2VyIGhhcyBhIG1hdGNoaW5nXG4gICAgICAvLyBvcHRpb24gaW4gdGhlIERPTS5cbiAgICAgIHZhciBwcmV2T3B0aW9ucyA9IGVsLl92T3B0aW9ucztcbiAgICAgIHZhciBjdXJPcHRpb25zID0gZWwuX3ZPcHRpb25zID0gW10ubWFwLmNhbGwoZWwub3B0aW9ucywgZ2V0VmFsdWUpO1xuICAgICAgaWYgKGN1ck9wdGlvbnMuc29tZShmdW5jdGlvbiAobywgaSkgeyByZXR1cm4gIWxvb3NlRXF1YWwobywgcHJldk9wdGlvbnNbaV0pOyB9KSkge1xuICAgICAgICAvLyB0cmlnZ2VyIGNoYW5nZSBldmVudCBpZlxuICAgICAgICAvLyBubyBtYXRjaGluZyBvcHRpb24gZm91bmQgZm9yIGF0IGxlYXN0IG9uZSB2YWx1ZVxuICAgICAgICB2YXIgbmVlZFJlc2V0ID0gZWwubXVsdGlwbGVcbiAgICAgICAgICA/IGJpbmRpbmcudmFsdWUuc29tZShmdW5jdGlvbiAodikgeyByZXR1cm4gaGFzTm9NYXRjaGluZ09wdGlvbih2LCBjdXJPcHRpb25zKTsgfSlcbiAgICAgICAgICA6IGJpbmRpbmcudmFsdWUgIT09IGJpbmRpbmcub2xkVmFsdWUgJiYgaGFzTm9NYXRjaGluZ09wdGlvbihiaW5kaW5nLnZhbHVlLCBjdXJPcHRpb25zKTtcbiAgICAgICAgaWYgKG5lZWRSZXNldCkge1xuICAgICAgICAgIHRyaWdnZXIoZWwsICdjaGFuZ2UnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gc2V0U2VsZWN0ZWQgKGVsLCBiaW5kaW5nLCB2bSkge1xuICBhY3R1YWxseVNldFNlbGVjdGVkKGVsLCBiaW5kaW5nLCB2bSk7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNJRSB8fCBpc0VkZ2UpIHtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGFjdHVhbGx5U2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZtKTtcbiAgICB9LCAwKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhY3R1YWxseVNldFNlbGVjdGVkIChlbCwgYmluZGluZywgdm0pIHtcbiAgdmFyIHZhbHVlID0gYmluZGluZy52YWx1ZTtcbiAgdmFyIGlzTXVsdGlwbGUgPSBlbC5tdWx0aXBsZTtcbiAgaWYgKGlzTXVsdGlwbGUgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgXCI8c2VsZWN0IG11bHRpcGxlIHYtbW9kZWw9XFxcIlwiICsgKGJpbmRpbmcuZXhwcmVzc2lvbikgKyBcIlxcXCI+IFwiICtcbiAgICAgIFwiZXhwZWN0cyBhbiBBcnJheSB2YWx1ZSBmb3IgaXRzIGJpbmRpbmcsIGJ1dCBnb3QgXCIgKyAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKS5zbGljZSg4LCAtMSkpLFxuICAgICAgdm1cbiAgICApO1xuICAgIHJldHVyblxuICB9XG4gIHZhciBzZWxlY3RlZCwgb3B0aW9uO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGVsLm9wdGlvbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgb3B0aW9uID0gZWwub3B0aW9uc1tpXTtcbiAgICBpZiAoaXNNdWx0aXBsZSkge1xuICAgICAgc2VsZWN0ZWQgPSBsb29zZUluZGV4T2YodmFsdWUsIGdldFZhbHVlKG9wdGlvbikpID4gLTE7XG4gICAgICBpZiAob3B0aW9uLnNlbGVjdGVkICE9PSBzZWxlY3RlZCkge1xuICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSBzZWxlY3RlZDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGxvb3NlRXF1YWwoZ2V0VmFsdWUob3B0aW9uKSwgdmFsdWUpKSB7XG4gICAgICAgIGlmIChlbC5zZWxlY3RlZEluZGV4ICE9PSBpKSB7XG4gICAgICAgICAgZWwuc2VsZWN0ZWRJbmRleCA9IGk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICghaXNNdWx0aXBsZSkge1xuICAgIGVsLnNlbGVjdGVkSW5kZXggPSAtMTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYXNOb01hdGNoaW5nT3B0aW9uICh2YWx1ZSwgb3B0aW9ucykge1xuICByZXR1cm4gb3B0aW9ucy5ldmVyeShmdW5jdGlvbiAobykgeyByZXR1cm4gIWxvb3NlRXF1YWwobywgdmFsdWUpOyB9KVxufVxuXG5mdW5jdGlvbiBnZXRWYWx1ZSAob3B0aW9uKSB7XG4gIHJldHVybiAnX3ZhbHVlJyBpbiBvcHRpb25cbiAgICA/IG9wdGlvbi5fdmFsdWVcbiAgICA6IG9wdGlvbi52YWx1ZVxufVxuXG5mdW5jdGlvbiBvbkNvbXBvc2l0aW9uU3RhcnQgKGUpIHtcbiAgZS50YXJnZXQuY29tcG9zaW5nID0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gb25Db21wb3NpdGlvbkVuZCAoZSkge1xuICAvLyBwcmV2ZW50IHRyaWdnZXJpbmcgYW4gaW5wdXQgZXZlbnQgZm9yIG5vIHJlYXNvblxuICBpZiAoIWUudGFyZ2V0LmNvbXBvc2luZykgeyByZXR1cm4gfVxuICBlLnRhcmdldC5jb21wb3NpbmcgPSBmYWxzZTtcbiAgdHJpZ2dlcihlLnRhcmdldCwgJ2lucHV0Jyk7XG59XG5cbmZ1bmN0aW9uIHRyaWdnZXIgKGVsLCB0eXBlKSB7XG4gIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0hUTUxFdmVudHMnKTtcbiAgZS5pbml0RXZlbnQodHlwZSwgdHJ1ZSwgdHJ1ZSk7XG4gIGVsLmRpc3BhdGNoRXZlbnQoZSk7XG59XG5cbi8qICAqL1xuXG4vLyByZWN1cnNpdmVseSBzZWFyY2ggZm9yIHBvc3NpYmxlIHRyYW5zaXRpb24gZGVmaW5lZCBpbnNpZGUgdGhlIGNvbXBvbmVudCByb290XG5mdW5jdGlvbiBsb2NhdGVOb2RlICh2bm9kZSkge1xuICByZXR1cm4gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgJiYgKCF2bm9kZS5kYXRhIHx8ICF2bm9kZS5kYXRhLnRyYW5zaXRpb24pXG4gICAgPyBsb2NhdGVOb2RlKHZub2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZSlcbiAgICA6IHZub2RlXG59XG5cbnZhciBzaG93ID0ge1xuICBiaW5kOiBmdW5jdGlvbiBiaW5kIChlbCwgcmVmLCB2bm9kZSkge1xuICAgIHZhciB2YWx1ZSA9IHJlZi52YWx1ZTtcblxuICAgIHZub2RlID0gbG9jYXRlTm9kZSh2bm9kZSk7XG4gICAgdmFyIHRyYW5zaXRpb24kJDEgPSB2bm9kZS5kYXRhICYmIHZub2RlLmRhdGEudHJhbnNpdGlvbjtcbiAgICB2YXIgb3JpZ2luYWxEaXNwbGF5ID0gZWwuX192T3JpZ2luYWxEaXNwbGF5ID1cbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPT09ICdub25lJyA/ICcnIDogZWwuc3R5bGUuZGlzcGxheTtcbiAgICBpZiAodmFsdWUgJiYgdHJhbnNpdGlvbiQkMSkge1xuICAgICAgdm5vZGUuZGF0YS5zaG93ID0gdHJ1ZTtcbiAgICAgIGVudGVyKHZub2RlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBvcmlnaW5hbERpc3BsYXk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IHZhbHVlID8gb3JpZ2luYWxEaXNwbGF5IDogJ25vbmUnO1xuICAgIH1cbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSAoZWwsIHJlZiwgdm5vZGUpIHtcbiAgICB2YXIgdmFsdWUgPSByZWYudmFsdWU7XG4gICAgdmFyIG9sZFZhbHVlID0gcmVmLm9sZFZhbHVlO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHZhbHVlID09PSBvbGRWYWx1ZSkgeyByZXR1cm4gfVxuICAgIHZub2RlID0gbG9jYXRlTm9kZSh2bm9kZSk7XG4gICAgdmFyIHRyYW5zaXRpb24kJDEgPSB2bm9kZS5kYXRhICYmIHZub2RlLmRhdGEudHJhbnNpdGlvbjtcbiAgICBpZiAodHJhbnNpdGlvbiQkMSkge1xuICAgICAgdm5vZGUuZGF0YS5zaG93ID0gdHJ1ZTtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBlbnRlcih2bm9kZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBlbC5fX3ZPcmlnaW5hbERpc3BsYXk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGVhdmUodm5vZGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IHZhbHVlID8gZWwuX192T3JpZ2luYWxEaXNwbGF5IDogJ25vbmUnO1xuICAgIH1cbiAgfSxcblxuICB1bmJpbmQ6IGZ1bmN0aW9uIHVuYmluZCAoXG4gICAgZWwsXG4gICAgYmluZGluZyxcbiAgICB2bm9kZSxcbiAgICBvbGRWbm9kZSxcbiAgICBpc0Rlc3Ryb3lcbiAgKSB7XG4gICAgaWYgKCFpc0Rlc3Ryb3kpIHtcbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBlbC5fX3ZPcmlnaW5hbERpc3BsYXk7XG4gICAgfVxuICB9XG59O1xuXG52YXIgcGxhdGZvcm1EaXJlY3RpdmVzID0ge1xuICBtb2RlbDogZGlyZWN0aXZlLFxuICBzaG93OiBzaG93XG59O1xuXG4vKiAgKi9cblxuLy8gUHJvdmlkZXMgdHJhbnNpdGlvbiBzdXBwb3J0IGZvciBhIHNpbmdsZSBlbGVtZW50L2NvbXBvbmVudC5cbi8vIHN1cHBvcnRzIHRyYW5zaXRpb24gbW9kZSAob3V0LWluIC8gaW4tb3V0KVxuXG52YXIgdHJhbnNpdGlvblByb3BzID0ge1xuICBuYW1lOiBTdHJpbmcsXG4gIGFwcGVhcjogQm9vbGVhbixcbiAgY3NzOiBCb29sZWFuLFxuICBtb2RlOiBTdHJpbmcsXG4gIHR5cGU6IFN0cmluZyxcbiAgZW50ZXJDbGFzczogU3RyaW5nLFxuICBsZWF2ZUNsYXNzOiBTdHJpbmcsXG4gIGVudGVyVG9DbGFzczogU3RyaW5nLFxuICBsZWF2ZVRvQ2xhc3M6IFN0cmluZyxcbiAgZW50ZXJBY3RpdmVDbGFzczogU3RyaW5nLFxuICBsZWF2ZUFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gIGFwcGVhckNsYXNzOiBTdHJpbmcsXG4gIGFwcGVhckFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gIGFwcGVhclRvQ2xhc3M6IFN0cmluZyxcbiAgZHVyYXRpb246IFtOdW1iZXIsIFN0cmluZywgT2JqZWN0XVxufTtcblxuLy8gaW4gY2FzZSB0aGUgY2hpbGQgaXMgYWxzbyBhbiBhYnN0cmFjdCBjb21wb25lbnQsIGUuZy4gPGtlZXAtYWxpdmU+XG4vLyB3ZSB3YW50IHRvIHJlY3Vyc2l2ZWx5IHJldHJpZXZlIHRoZSByZWFsIGNvbXBvbmVudCB0byBiZSByZW5kZXJlZFxuZnVuY3Rpb24gZ2V0UmVhbENoaWxkICh2bm9kZSkge1xuICB2YXIgY29tcE9wdGlvbnMgPSB2bm9kZSAmJiB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICBpZiAoY29tcE9wdGlvbnMgJiYgY29tcE9wdGlvbnMuQ3Rvci5vcHRpb25zLmFic3RyYWN0KSB7XG4gICAgcmV0dXJuIGdldFJlYWxDaGlsZChnZXRGaXJzdENvbXBvbmVudENoaWxkKGNvbXBPcHRpb25zLmNoaWxkcmVuKSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdm5vZGVcbiAgfVxufVxuXG5mdW5jdGlvbiBleHRyYWN0VHJhbnNpdGlvbkRhdGEgKGNvbXApIHtcbiAgdmFyIGRhdGEgPSB7fTtcbiAgdmFyIG9wdGlvbnMgPSBjb21wLiRvcHRpb25zO1xuICAvLyBwcm9wc1xuICBmb3IgKHZhciBrZXkgaW4gb3B0aW9ucy5wcm9wc0RhdGEpIHtcbiAgICBkYXRhW2tleV0gPSBjb21wW2tleV07XG4gIH1cbiAgLy8gZXZlbnRzLlxuICAvLyBleHRyYWN0IGxpc3RlbmVycyBhbmQgcGFzcyB0aGVtIGRpcmVjdGx5IHRvIHRoZSB0cmFuc2l0aW9uIG1ldGhvZHNcbiAgdmFyIGxpc3RlbmVycyA9IG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcbiAgZm9yICh2YXIga2V5JDEgaW4gbGlzdGVuZXJzKSB7XG4gICAgZGF0YVtjYW1lbGl6ZShrZXkkMSldID0gbGlzdGVuZXJzW2tleSQxXTtcbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG5mdW5jdGlvbiBwbGFjZWhvbGRlciAoaCwgcmF3Q2hpbGQpIHtcbiAgaWYgKC9cXGQta2VlcC1hbGl2ZSQvLnRlc3QocmF3Q2hpbGQudGFnKSkge1xuICAgIHJldHVybiBoKCdrZWVwLWFsaXZlJywge1xuICAgICAgcHJvcHM6IHJhd0NoaWxkLmNvbXBvbmVudE9wdGlvbnMucHJvcHNEYXRhXG4gICAgfSlcbiAgfVxufVxuXG5mdW5jdGlvbiBoYXNQYXJlbnRUcmFuc2l0aW9uICh2bm9kZSkge1xuICB3aGlsZSAoKHZub2RlID0gdm5vZGUucGFyZW50KSkge1xuICAgIGlmICh2bm9kZS5kYXRhLnRyYW5zaXRpb24pIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzU2FtZUNoaWxkIChjaGlsZCwgb2xkQ2hpbGQpIHtcbiAgcmV0dXJuIG9sZENoaWxkLmtleSA9PT0gY2hpbGQua2V5ICYmIG9sZENoaWxkLnRhZyA9PT0gY2hpbGQudGFnXG59XG5cbnZhciBUcmFuc2l0aW9uID0ge1xuICBuYW1lOiAndHJhbnNpdGlvbicsXG4gIHByb3BzOiB0cmFuc2l0aW9uUHJvcHMsXG4gIGFic3RyYWN0OiB0cnVlLFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyIChoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLiRzbG90cy5kZWZhdWx0O1xuICAgIGlmICghY2hpbGRyZW4pIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIGZpbHRlciBvdXQgdGV4dCBub2RlcyAocG9zc2libGUgd2hpdGVzcGFjZXMpXG4gICAgY2hpbGRyZW4gPSBjaGlsZHJlbi5maWx0ZXIoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMudGFnIHx8IGlzQXN5bmNQbGFjZWhvbGRlcihjKTsgfSk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIHdhcm4gbXVsdGlwbGUgZWxlbWVudHNcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjaGlsZHJlbi5sZW5ndGggPiAxKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnPHRyYW5zaXRpb24+IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBzaW5nbGUgZWxlbWVudC4gVXNlICcgK1xuICAgICAgICAnPHRyYW5zaXRpb24tZ3JvdXA+IGZvciBsaXN0cy4nLFxuICAgICAgICB0aGlzLiRwYXJlbnRcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdmFyIG1vZGUgPSB0aGlzLm1vZGU7XG5cbiAgICAvLyB3YXJuIGludmFsaWQgbW9kZVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICBtb2RlICYmIG1vZGUgIT09ICdpbi1vdXQnICYmIG1vZGUgIT09ICdvdXQtaW4nXG4gICAgKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnaW52YWxpZCA8dHJhbnNpdGlvbj4gbW9kZTogJyArIG1vZGUsXG4gICAgICAgIHRoaXMuJHBhcmVudFxuICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgcmF3Q2hpbGQgPSBjaGlsZHJlblswXTtcblxuICAgIC8vIGlmIHRoaXMgaXMgYSBjb21wb25lbnQgcm9vdCBub2RlIGFuZCB0aGUgY29tcG9uZW50J3NcbiAgICAvLyBwYXJlbnQgY29udGFpbmVyIG5vZGUgYWxzbyBoYXMgdHJhbnNpdGlvbiwgc2tpcC5cbiAgICBpZiAoaGFzUGFyZW50VHJhbnNpdGlvbih0aGlzLiR2bm9kZSkpIHtcbiAgICAgIHJldHVybiByYXdDaGlsZFxuICAgIH1cblxuICAgIC8vIGFwcGx5IHRyYW5zaXRpb24gZGF0YSB0byBjaGlsZFxuICAgIC8vIHVzZSBnZXRSZWFsQ2hpbGQoKSB0byBpZ25vcmUgYWJzdHJhY3QgY29tcG9uZW50cyBlLmcuIGtlZXAtYWxpdmVcbiAgICB2YXIgY2hpbGQgPSBnZXRSZWFsQ2hpbGQocmF3Q2hpbGQpO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghY2hpbGQpIHtcbiAgICAgIHJldHVybiByYXdDaGlsZFxuICAgIH1cblxuICAgIGlmICh0aGlzLl9sZWF2aW5nKSB7XG4gICAgICByZXR1cm4gcGxhY2Vob2xkZXIoaCwgcmF3Q2hpbGQpXG4gICAgfVxuXG4gICAgLy8gZW5zdXJlIGEga2V5IHRoYXQgaXMgdW5pcXVlIHRvIHRoZSB2bm9kZSB0eXBlIGFuZCB0byB0aGlzIHRyYW5zaXRpb25cbiAgICAvLyBjb21wb25lbnQgaW5zdGFuY2UuIFRoaXMga2V5IHdpbGwgYmUgdXNlZCB0byByZW1vdmUgcGVuZGluZyBsZWF2aW5nIG5vZGVzXG4gICAgLy8gZHVyaW5nIGVudGVyaW5nLlxuICAgIHZhciBpZCA9IFwiX190cmFuc2l0aW9uLVwiICsgKHRoaXMuX3VpZCkgKyBcIi1cIjtcbiAgICBjaGlsZC5rZXkgPSBjaGlsZC5rZXkgPT0gbnVsbFxuICAgICAgPyBjaGlsZC5pc0NvbW1lbnRcbiAgICAgICAgPyBpZCArICdjb21tZW50J1xuICAgICAgICA6IGlkICsgY2hpbGQudGFnXG4gICAgICA6IGlzUHJpbWl0aXZlKGNoaWxkLmtleSlcbiAgICAgICAgPyAoU3RyaW5nKGNoaWxkLmtleSkuaW5kZXhPZihpZCkgPT09IDAgPyBjaGlsZC5rZXkgOiBpZCArIGNoaWxkLmtleSlcbiAgICAgICAgOiBjaGlsZC5rZXk7XG5cbiAgICB2YXIgZGF0YSA9IChjaGlsZC5kYXRhIHx8IChjaGlsZC5kYXRhID0ge30pKS50cmFuc2l0aW9uID0gZXh0cmFjdFRyYW5zaXRpb25EYXRhKHRoaXMpO1xuICAgIHZhciBvbGRSYXdDaGlsZCA9IHRoaXMuX3Zub2RlO1xuICAgIHZhciBvbGRDaGlsZCA9IGdldFJlYWxDaGlsZChvbGRSYXdDaGlsZCk7XG5cbiAgICAvLyBtYXJrIHYtc2hvd1xuICAgIC8vIHNvIHRoYXQgdGhlIHRyYW5zaXRpb24gbW9kdWxlIGNhbiBoYW5kIG92ZXIgdGhlIGNvbnRyb2wgdG8gdGhlIGRpcmVjdGl2ZVxuICAgIGlmIChjaGlsZC5kYXRhLmRpcmVjdGl2ZXMgJiYgY2hpbGQuZGF0YS5kaXJlY3RpdmVzLnNvbWUoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQubmFtZSA9PT0gJ3Nob3cnOyB9KSkge1xuICAgICAgY2hpbGQuZGF0YS5zaG93ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICBvbGRDaGlsZCAmJlxuICAgICAgb2xkQ2hpbGQuZGF0YSAmJlxuICAgICAgIWlzU2FtZUNoaWxkKGNoaWxkLCBvbGRDaGlsZCkgJiZcbiAgICAgICFpc0FzeW5jUGxhY2Vob2xkZXIob2xkQ2hpbGQpICYmXG4gICAgICAvLyAjNjY4NyBjb21wb25lbnQgcm9vdCBpcyBhIGNvbW1lbnQgbm9kZVxuICAgICAgIShvbGRDaGlsZC5jb21wb25lbnRJbnN0YW5jZSAmJiBvbGRDaGlsZC5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGUuaXNDb21tZW50KVxuICAgICkge1xuICAgICAgLy8gcmVwbGFjZSBvbGQgY2hpbGQgdHJhbnNpdGlvbiBkYXRhIHdpdGggZnJlc2ggb25lXG4gICAgICAvLyBpbXBvcnRhbnQgZm9yIGR5bmFtaWMgdHJhbnNpdGlvbnMhXG4gICAgICB2YXIgb2xkRGF0YSA9IG9sZENoaWxkLmRhdGEudHJhbnNpdGlvbiA9IGV4dGVuZCh7fSwgZGF0YSk7XG4gICAgICAvLyBoYW5kbGUgdHJhbnNpdGlvbiBtb2RlXG4gICAgICBpZiAobW9kZSA9PT0gJ291dC1pbicpIHtcbiAgICAgICAgLy8gcmV0dXJuIHBsYWNlaG9sZGVyIG5vZGUgYW5kIHF1ZXVlIHVwZGF0ZSB3aGVuIGxlYXZlIGZpbmlzaGVzXG4gICAgICAgIHRoaXMuX2xlYXZpbmcgPSB0cnVlO1xuICAgICAgICBtZXJnZVZOb2RlSG9vayhvbGREYXRhLCAnYWZ0ZXJMZWF2ZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGlzJDEuX2xlYXZpbmcgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzJDEuJGZvcmNlVXBkYXRlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcGxhY2Vob2xkZXIoaCwgcmF3Q2hpbGQpXG4gICAgICB9IGVsc2UgaWYgKG1vZGUgPT09ICdpbi1vdXQnKSB7XG4gICAgICAgIGlmIChpc0FzeW5jUGxhY2Vob2xkZXIoY2hpbGQpKSB7XG4gICAgICAgICAgcmV0dXJuIG9sZFJhd0NoaWxkXG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRlbGF5ZWRMZWF2ZTtcbiAgICAgICAgdmFyIHBlcmZvcm1MZWF2ZSA9IGZ1bmN0aW9uICgpIHsgZGVsYXllZExlYXZlKCk7IH07XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKGRhdGEsICdhZnRlckVudGVyJywgcGVyZm9ybUxlYXZlKTtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2soZGF0YSwgJ2VudGVyQ2FuY2VsbGVkJywgcGVyZm9ybUxlYXZlKTtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2sob2xkRGF0YSwgJ2RlbGF5TGVhdmUnLCBmdW5jdGlvbiAobGVhdmUpIHsgZGVsYXllZExlYXZlID0gbGVhdmU7IH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByYXdDaGlsZFxuICB9XG59O1xuXG4vKiAgKi9cblxuLy8gUHJvdmlkZXMgdHJhbnNpdGlvbiBzdXBwb3J0IGZvciBsaXN0IGl0ZW1zLlxuLy8gc3VwcG9ydHMgbW92ZSB0cmFuc2l0aW9ucyB1c2luZyB0aGUgRkxJUCB0ZWNobmlxdWUuXG5cbi8vIEJlY2F1c2UgdGhlIHZkb20ncyBjaGlsZHJlbiB1cGRhdGUgYWxnb3JpdGhtIGlzIFwidW5zdGFibGVcIiAtIGkuZS5cbi8vIGl0IGRvZXNuJ3QgZ3VhcmFudGVlIHRoZSByZWxhdGl2ZSBwb3NpdGlvbmluZyBvZiByZW1vdmVkIGVsZW1lbnRzLFxuLy8gd2UgZm9yY2UgdHJhbnNpdGlvbi1ncm91cCB0byB1cGRhdGUgaXRzIGNoaWxkcmVuIGludG8gdHdvIHBhc3Nlczpcbi8vIGluIHRoZSBmaXJzdCBwYXNzLCB3ZSByZW1vdmUgYWxsIG5vZGVzIHRoYXQgbmVlZCB0byBiZSByZW1vdmVkLFxuLy8gdHJpZ2dlcmluZyB0aGVpciBsZWF2aW5nIHRyYW5zaXRpb247IGluIHRoZSBzZWNvbmQgcGFzcywgd2UgaW5zZXJ0L21vdmVcbi8vIGludG8gdGhlIGZpbmFsIGRlc2lyZWQgc3RhdGUuIFRoaXMgd2F5IGluIHRoZSBzZWNvbmQgcGFzcyByZW1vdmVkXG4vLyBub2RlcyB3aWxsIHJlbWFpbiB3aGVyZSB0aGV5IHNob3VsZCBiZS5cblxudmFyIHByb3BzID0gZXh0ZW5kKHtcbiAgdGFnOiBTdHJpbmcsXG4gIG1vdmVDbGFzczogU3RyaW5nXG59LCB0cmFuc2l0aW9uUHJvcHMpO1xuXG5kZWxldGUgcHJvcHMubW9kZTtcblxudmFyIFRyYW5zaXRpb25Hcm91cCA9IHtcbiAgcHJvcHM6IHByb3BzLFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyIChoKSB7XG4gICAgdmFyIHRhZyA9IHRoaXMudGFnIHx8IHRoaXMuJHZub2RlLmRhdGEudGFnIHx8ICdzcGFuJztcbiAgICB2YXIgbWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB2YXIgcHJldkNoaWxkcmVuID0gdGhpcy5wcmV2Q2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuICAgIHZhciByYXdDaGlsZHJlbiA9IHRoaXMuJHNsb3RzLmRlZmF1bHQgfHwgW107XG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgIHZhciB0cmFuc2l0aW9uRGF0YSA9IGV4dHJhY3RUcmFuc2l0aW9uRGF0YSh0aGlzKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmF3Q2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjID0gcmF3Q2hpbGRyZW5baV07XG4gICAgICBpZiAoYy50YWcpIHtcbiAgICAgICAgaWYgKGMua2V5ICE9IG51bGwgJiYgU3RyaW5nKGMua2V5KS5pbmRleE9mKCdfX3ZsaXN0JykgIT09IDApIHtcbiAgICAgICAgICBjaGlsZHJlbi5wdXNoKGMpO1xuICAgICAgICAgIG1hcFtjLmtleV0gPSBjXG4gICAgICAgICAgOyhjLmRhdGEgfHwgKGMuZGF0YSA9IHt9KSkudHJhbnNpdGlvbiA9IHRyYW5zaXRpb25EYXRhO1xuICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICB2YXIgb3B0cyA9IGMuY29tcG9uZW50T3B0aW9ucztcbiAgICAgICAgICB2YXIgbmFtZSA9IG9wdHMgPyAob3B0cy5DdG9yLm9wdGlvbnMubmFtZSB8fCBvcHRzLnRhZyB8fCAnJykgOiBjLnRhZztcbiAgICAgICAgICB3YXJuKChcIjx0cmFuc2l0aW9uLWdyb3VwPiBjaGlsZHJlbiBtdXN0IGJlIGtleWVkOiA8XCIgKyBuYW1lICsgXCI+XCIpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwcmV2Q2hpbGRyZW4pIHtcbiAgICAgIHZhciBrZXB0ID0gW107XG4gICAgICB2YXIgcmVtb3ZlZCA9IFtdO1xuICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgcHJldkNoaWxkcmVuLmxlbmd0aDsgaSQxKyspIHtcbiAgICAgICAgdmFyIGMkMSA9IHByZXZDaGlsZHJlbltpJDFdO1xuICAgICAgICBjJDEuZGF0YS50cmFuc2l0aW9uID0gdHJhbnNpdGlvbkRhdGE7XG4gICAgICAgIGMkMS5kYXRhLnBvcyA9IGMkMS5lbG0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGlmIChtYXBbYyQxLmtleV0pIHtcbiAgICAgICAgICBrZXB0LnB1c2goYyQxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZW1vdmVkLnB1c2goYyQxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5rZXB0ID0gaCh0YWcsIG51bGwsIGtlcHQpO1xuICAgICAgdGhpcy5yZW1vdmVkID0gcmVtb3ZlZDtcbiAgICB9XG5cbiAgICByZXR1cm4gaCh0YWcsIG51bGwsIGNoaWxkcmVuKVxuICB9LFxuXG4gIGJlZm9yZVVwZGF0ZTogZnVuY3Rpb24gYmVmb3JlVXBkYXRlICgpIHtcbiAgICAvLyBmb3JjZSByZW1vdmluZyBwYXNzXG4gICAgdGhpcy5fX3BhdGNoX18oXG4gICAgICB0aGlzLl92bm9kZSxcbiAgICAgIHRoaXMua2VwdCxcbiAgICAgIGZhbHNlLCAvLyBoeWRyYXRpbmdcbiAgICAgIHRydWUgLy8gcmVtb3ZlT25seSAoIWltcG9ydGFudCBhdm9pZHMgdW5uZWNlc3NhcnkgbW92ZXMpXG4gICAgKTtcbiAgICB0aGlzLl92bm9kZSA9IHRoaXMua2VwdDtcbiAgfSxcblxuICB1cGRhdGVkOiBmdW5jdGlvbiB1cGRhdGVkICgpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLnByZXZDaGlsZHJlbjtcbiAgICB2YXIgbW92ZUNsYXNzID0gdGhpcy5tb3ZlQ2xhc3MgfHwgKCh0aGlzLm5hbWUgfHwgJ3YnKSArICctbW92ZScpO1xuICAgIGlmICghY2hpbGRyZW4ubGVuZ3RoIHx8ICF0aGlzLmhhc01vdmUoY2hpbGRyZW5bMF0uZWxtLCBtb3ZlQ2xhc3MpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyB3ZSBkaXZpZGUgdGhlIHdvcmsgaW50byB0aHJlZSBsb29wcyB0byBhdm9pZCBtaXhpbmcgRE9NIHJlYWRzIGFuZCB3cml0ZXNcbiAgICAvLyBpbiBlYWNoIGl0ZXJhdGlvbiAtIHdoaWNoIGhlbHBzIHByZXZlbnQgbGF5b3V0IHRocmFzaGluZy5cbiAgICBjaGlsZHJlbi5mb3JFYWNoKGNhbGxQZW5kaW5nQ2JzKTtcbiAgICBjaGlsZHJlbi5mb3JFYWNoKHJlY29yZFBvc2l0aW9uKTtcbiAgICBjaGlsZHJlbi5mb3JFYWNoKGFwcGx5VHJhbnNsYXRpb24pO1xuXG4gICAgLy8gZm9yY2UgcmVmbG93IHRvIHB1dCBldmVyeXRoaW5nIGluIHBvc2l0aW9uXG4gICAgLy8gYXNzaWduIHRvIHRoaXMgdG8gYXZvaWQgYmVpbmcgcmVtb3ZlZCBpbiB0cmVlLXNoYWtpbmdcbiAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICB0aGlzLl9yZWZsb3cgPSBkb2N1bWVudC5ib2R5Lm9mZnNldEhlaWdodDtcblxuICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgIGlmIChjLmRhdGEubW92ZWQpIHtcbiAgICAgICAgdmFyIGVsID0gYy5lbG07XG4gICAgICAgIHZhciBzID0gZWwuc3R5bGU7XG4gICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbW92ZUNsYXNzKTtcbiAgICAgICAgcy50cmFuc2Zvcm0gPSBzLldlYmtpdFRyYW5zZm9ybSA9IHMudHJhbnNpdGlvbkR1cmF0aW9uID0gJyc7XG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIodHJhbnNpdGlvbkVuZEV2ZW50LCBlbC5fbW92ZUNiID0gZnVuY3Rpb24gY2IgKGUpIHtcbiAgICAgICAgICBpZiAoIWUgfHwgL3RyYW5zZm9ybSQvLnRlc3QoZS5wcm9wZXJ0eU5hbWUpKSB7XG4gICAgICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKHRyYW5zaXRpb25FbmRFdmVudCwgY2IpO1xuICAgICAgICAgICAgZWwuX21vdmVDYiA9IG51bGw7XG4gICAgICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIG1vdmVDbGFzcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICBtZXRob2RzOiB7XG4gICAgaGFzTW92ZTogZnVuY3Rpb24gaGFzTW92ZSAoZWwsIG1vdmVDbGFzcykge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoIWhhc1RyYW5zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmICh0aGlzLl9oYXNNb3ZlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oYXNNb3ZlXG4gICAgICB9XG4gICAgICAvLyBEZXRlY3Qgd2hldGhlciBhbiBlbGVtZW50IHdpdGggdGhlIG1vdmUgY2xhc3MgYXBwbGllZCBoYXNcbiAgICAgIC8vIENTUyB0cmFuc2l0aW9ucy4gU2luY2UgdGhlIGVsZW1lbnQgbWF5IGJlIGluc2lkZSBhbiBlbnRlcmluZ1xuICAgICAgLy8gdHJhbnNpdGlvbiBhdCB0aGlzIHZlcnkgbW9tZW50LCB3ZSBtYWtlIGEgY2xvbmUgb2YgaXQgYW5kIHJlbW92ZVxuICAgICAgLy8gYWxsIG90aGVyIHRyYW5zaXRpb24gY2xhc3NlcyBhcHBsaWVkIHRvIGVuc3VyZSBvbmx5IHRoZSBtb3ZlIGNsYXNzXG4gICAgICAvLyBpcyBhcHBsaWVkLlxuICAgICAgdmFyIGNsb25lID0gZWwuY2xvbmVOb2RlKCk7XG4gICAgICBpZiAoZWwuX3RyYW5zaXRpb25DbGFzc2VzKSB7XG4gICAgICAgIGVsLl90cmFuc2l0aW9uQ2xhc3Nlcy5mb3JFYWNoKGZ1bmN0aW9uIChjbHMpIHsgcmVtb3ZlQ2xhc3MoY2xvbmUsIGNscyk7IH0pO1xuICAgICAgfVxuICAgICAgYWRkQ2xhc3MoY2xvbmUsIG1vdmVDbGFzcyk7XG4gICAgICBjbG9uZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgdGhpcy4kZWwuYXBwZW5kQ2hpbGQoY2xvbmUpO1xuICAgICAgdmFyIGluZm8gPSBnZXRUcmFuc2l0aW9uSW5mbyhjbG9uZSk7XG4gICAgICB0aGlzLiRlbC5yZW1vdmVDaGlsZChjbG9uZSk7XG4gICAgICByZXR1cm4gKHRoaXMuX2hhc01vdmUgPSBpbmZvLmhhc1RyYW5zZm9ybSlcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGNhbGxQZW5kaW5nQ2JzIChjKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoYy5lbG0uX21vdmVDYikge1xuICAgIGMuZWxtLl9tb3ZlQ2IoKTtcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGMuZWxtLl9lbnRlckNiKSB7XG4gICAgYy5lbG0uX2VudGVyQ2IoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZWNvcmRQb3NpdGlvbiAoYykge1xuICBjLmRhdGEubmV3UG9zID0gYy5lbG0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG59XG5cbmZ1bmN0aW9uIGFwcGx5VHJhbnNsYXRpb24gKGMpIHtcbiAgdmFyIG9sZFBvcyA9IGMuZGF0YS5wb3M7XG4gIHZhciBuZXdQb3MgPSBjLmRhdGEubmV3UG9zO1xuICB2YXIgZHggPSBvbGRQb3MubGVmdCAtIG5ld1Bvcy5sZWZ0O1xuICB2YXIgZHkgPSBvbGRQb3MudG9wIC0gbmV3UG9zLnRvcDtcbiAgaWYgKGR4IHx8IGR5KSB7XG4gICAgYy5kYXRhLm1vdmVkID0gdHJ1ZTtcbiAgICB2YXIgcyA9IGMuZWxtLnN0eWxlO1xuICAgIHMudHJhbnNmb3JtID0gcy5XZWJraXRUcmFuc2Zvcm0gPSBcInRyYW5zbGF0ZShcIiArIGR4ICsgXCJweCxcIiArIGR5ICsgXCJweClcIjtcbiAgICBzLnRyYW5zaXRpb25EdXJhdGlvbiA9ICcwcyc7XG4gIH1cbn1cblxudmFyIHBsYXRmb3JtQ29tcG9uZW50cyA9IHtcbiAgVHJhbnNpdGlvbjogVHJhbnNpdGlvbixcbiAgVHJhbnNpdGlvbkdyb3VwOiBUcmFuc2l0aW9uR3JvdXBcbn07XG5cbi8qICAqL1xuXG4vLyBpbnN0YWxsIHBsYXRmb3JtIHNwZWNpZmljIHV0aWxzXG5WdWUkMy5jb25maWcubXVzdFVzZVByb3AgPSBtdXN0VXNlUHJvcDtcblZ1ZSQzLmNvbmZpZy5pc1Jlc2VydmVkVGFnID0gaXNSZXNlcnZlZFRhZztcblZ1ZSQzLmNvbmZpZy5pc1Jlc2VydmVkQXR0ciA9IGlzUmVzZXJ2ZWRBdHRyO1xuVnVlJDMuY29uZmlnLmdldFRhZ05hbWVzcGFjZSA9IGdldFRhZ05hbWVzcGFjZTtcblZ1ZSQzLmNvbmZpZy5pc1Vua25vd25FbGVtZW50ID0gaXNVbmtub3duRWxlbWVudDtcblxuLy8gaW5zdGFsbCBwbGF0Zm9ybSBydW50aW1lIGRpcmVjdGl2ZXMgJiBjb21wb25lbnRzXG5leHRlbmQoVnVlJDMub3B0aW9ucy5kaXJlY3RpdmVzLCBwbGF0Zm9ybURpcmVjdGl2ZXMpO1xuZXh0ZW5kKFZ1ZSQzLm9wdGlvbnMuY29tcG9uZW50cywgcGxhdGZvcm1Db21wb25lbnRzKTtcblxuLy8gaW5zdGFsbCBwbGF0Zm9ybSBwYXRjaCBmdW5jdGlvblxuVnVlJDMucHJvdG90eXBlLl9fcGF0Y2hfXyA9IGluQnJvd3NlciA/IHBhdGNoIDogbm9vcDtcblxuLy8gcHVibGljIG1vdW50IG1ldGhvZFxuVnVlJDMucHJvdG90eXBlLiRtb3VudCA9IGZ1bmN0aW9uIChcbiAgZWwsXG4gIGh5ZHJhdGluZ1xuKSB7XG4gIGVsID0gZWwgJiYgaW5Ccm93c2VyID8gcXVlcnkoZWwpIDogdW5kZWZpbmVkO1xuICByZXR1cm4gbW91bnRDb21wb25lbnQodGhpcywgZWwsIGh5ZHJhdGluZylcbn07XG5cbi8vIGRldnRvb2xzIGdsb2JhbCBob29rXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuVnVlJDMubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICBpZiAoY29uZmlnLmRldnRvb2xzKSB7XG4gICAgaWYgKGRldnRvb2xzKSB7XG4gICAgICBkZXZ0b29scy5lbWl0KCdpbml0JywgVnVlJDMpO1xuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBpc0Nocm9tZSkge1xuICAgICAgY29uc29sZVtjb25zb2xlLmluZm8gPyAnaW5mbycgOiAnbG9nJ10oXG4gICAgICAgICdEb3dubG9hZCB0aGUgVnVlIERldnRvb2xzIGV4dGVuc2lvbiBmb3IgYSBiZXR0ZXIgZGV2ZWxvcG1lbnQgZXhwZXJpZW5jZTpcXG4nICtcbiAgICAgICAgJ2h0dHBzOi8vZ2l0aHViLmNvbS92dWVqcy92dWUtZGV2dG9vbHMnXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgIGNvbmZpZy5wcm9kdWN0aW9uVGlwICE9PSBmYWxzZSAmJlxuICAgIGluQnJvd3NlciAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCdcbiAgKSB7XG4gICAgY29uc29sZVtjb25zb2xlLmluZm8gPyAnaW5mbycgOiAnbG9nJ10oXG4gICAgICBcIllvdSBhcmUgcnVubmluZyBWdWUgaW4gZGV2ZWxvcG1lbnQgbW9kZS5cXG5cIiArXG4gICAgICBcIk1ha2Ugc3VyZSB0byB0dXJuIG9uIHByb2R1Y3Rpb24gbW9kZSB3aGVuIGRlcGxveWluZyBmb3IgcHJvZHVjdGlvbi5cXG5cIiArXG4gICAgICBcIlNlZSBtb3JlIHRpcHMgYXQgaHR0cHM6Ly92dWVqcy5vcmcvZ3VpZGUvZGVwbG95bWVudC5odG1sXCJcbiAgICApO1xuICB9XG59LCAwKTtcblxuLyogICovXG5cbm1vZHVsZS5leHBvcnRzID0gVnVlJDM7XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogU2ltaWxhciB0byBpbnZhcmlhbnQgYnV0IG9ubHkgbG9ncyBhIHdhcm5pbmcgaWYgdGhlIGNvbmRpdGlvbiBpcyBub3QgbWV0LlxuICogVGhpcyBjYW4gYmUgdXNlZCB0byBsb2cgaXNzdWVzIGluIGRldmVsb3BtZW50IGVudmlyb25tZW50cyBpbiBjcml0aWNhbFxuICogcGF0aHMuIFJlbW92aW5nIHRoZSBsb2dnaW5nIGNvZGUgZm9yIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRzIHdpbGwga2VlcCB0aGVcbiAqIHNhbWUgbG9naWMgYW5kIGZvbGxvdyB0aGUgc2FtZSBjb2RlIHBhdGhzLlxuICovXG5cbnZhciB3YXJuaW5nID0gZnVuY3Rpb24oKSB7fTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgd2FybmluZyA9IGZ1bmN0aW9uKGNvbmRpdGlvbiwgZm9ybWF0LCBhcmdzKSB7XG4gICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgYXJncyA9IG5ldyBBcnJheShsZW4gPiAyID8gbGVuIC0gMiA6IDApO1xuICAgIGZvciAodmFyIGtleSA9IDI7IGtleSA8IGxlbjsga2V5KyspIHtcbiAgICAgIGFyZ3Nba2V5IC0gMl0gPSBhcmd1bWVudHNba2V5XTtcbiAgICB9XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdgd2FybmluZyhjb25kaXRpb24sIGZvcm1hdCwgLi4uYXJncylgIHJlcXVpcmVzIGEgd2FybmluZyAnICtcbiAgICAgICAgJ21lc3NhZ2UgYXJndW1lbnQnXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChmb3JtYXQubGVuZ3RoIDwgMTAgfHwgKC9eW3NcXFddKiQvKS50ZXN0KGZvcm1hdCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1RoZSB3YXJuaW5nIGZvcm1hdCBzaG91bGQgYmUgYWJsZSB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzICcgK1xuICAgICAgICAnd2FybmluZy4gUGxlYXNlLCB1c2UgYSBtb3JlIGRlc2NyaXB0aXZlIGZvcm1hdCB0aGFuOiAnICsgZm9ybWF0XG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArXG4gICAgICAgIGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gYXJnc1thcmdJbmRleCsrXTtcbiAgICAgICAgfSk7XG4gICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IHlvdSBjYW4gdXNlIHRoaXMgc3RhY2tcbiAgICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgIH0gY2F0Y2goeCkge31cbiAgICB9XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gd2FybmluZztcbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCJuYW1lXCI6IFwiQGt5bmlrb3Mvd2lraS1tb25rZXlcIixcbiAgXCJ2ZXJzaW9uXCI6IFwiNC4xLjBcIixcbiAgXCJhdXRob3JcIjogXCJEYXJpbyBHaW92YW5uZXR0aVwiLFxuICBcImRlc2NyaXB0aW9uXCI6IFwiTWVkaWFXaWtpIGJvdCBhbmQgZWRpdG9yLWFzc2lzdGFudCB1c2VyIHNjcmlwdC5cIixcbiAgXCJsaWNlbnNlXCI6IFwiR1BMLTMuMFwiLFxuICBcInJlcG9zaXRvcnlcIjoge1xuICAgIFwidHlwZVwiOiBcImdpdFwiLFxuICAgIFwidXJsXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL2t5bmlrb3Mvd2lraS1tb25rZXkuZ2l0XCJcbiAgfSxcbiAgXCJrZXl3b3Jkc1wiOiBbXG4gICAgXCJ3aWtpIG1lZGlhd2lraSBib3RcIlxuICBdLFxuICBcImRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJAa3luaWtvcy9taXNjXCI6IFwiXjAuMS4zXCIsXG4gICAgXCJiYWJlbC1wb2x5ZmlsbFwiOiBcIl42LjI2LjBcIixcbiAgICBcImh5cGVyc2NyaXB0XCI6IFwiXjIuMC4yXCIsXG4gICAgXCJoeXBlcnNjcmlwdC1oZWxwZXJzXCI6IFwiXjMuMC4zXCIsXG4gICAgXCJqc3NcIjogXCJeOS41LjFcIixcbiAgICBcImpzcy1wcmVzZXQtZGVmYXVsdFwiOiBcIl40LjEuMFwiLFxuICAgIFwibW9tZW50XCI6IFwiXjIuMjAuMVwiLFxuICAgIFwidnVlXCI6IFwiXjIuNS4xM1wiXG4gIH0sXG4gIFwiZGV2RGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcIkBreW5pa29zL2Jyb3dzZXJpZnktaGVscGVyc1wiOiBcIl4xLjAuOFwiLFxuICAgIFwiYmFiZWwtY29yZVwiOiBcIl42LjI2LjBcIixcbiAgICBcImJhYmVsLXByZXNldC1lbnZcIjogXCJeMS42LjFcIixcbiAgICBcImNvZmZlZWxpbnRcIjogXCJeMi4wLjdcIixcbiAgICBcImNvZmZlZXNjcmlwdFwiOiBcIl4yLjEuMVwiLFxuICAgIFwiaHR0cC1zZXJ2ZXJcIjogXCJeMC4xMS4xXCJcbiAgfVxufVxuIiwiIyBXaWtpIE1vbmtleSAtIE1lZGlhV2lraSBib3QgYW5kIGVkaXRvci1hc3Npc3RhbnQgdXNlciBzY3JpcHRcbiMgQ29weXJpZ2h0IChDKSAyMDExIERhcmlvIEdpb3Zhbm5ldHRpIDxkZXZAZGFyaW9naW92YW5uZXR0aS5uZXQ+XG4jXG4jIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFdpa2kgTW9ua2V5LlxuI1xuIyBXaWtpIE1vbmtleSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4jIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4jIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4jIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4jXG4jIFdpa2kgTW9ua2V5IGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4jIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4jIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiMgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbiNcbiMgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiMgYWxvbmcgd2l0aCBXaWtpIE1vbmtleS4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cblxue1dpa2lNb25rZXl9ID0gcmVxdWlyZSgnLi9tb2R1bGVzJylcblxubmV3IFdpa2lNb25rZXkoXG4gICAgXCJBcmNoV2lraVwiLFxuXG4gICAgIyBUaGUgcmVxdWlyZSBwYXRocyBjYW4ndCBiZSBjb25zdHJ1Y3RlZCBkeW5hbWljYWxseSwgb3IgYnJvd3NlcmlmeSB3b24ndFxuICAgICMgdW5kZXJzdGFuZCBhbmQgaW1wb3J0IHRoZW1cbiAgICByZXF1aXJlKFwiLi9wbHVnaW5zL0FyY2hXaWtpRml4SGVhZGVyXCIpLFxuICAgIHJlcXVpcmUoXCIuL3BsdWdpbnMvQXJjaFdpa2lGaXhIZWFkaW5nc1wiKSxcbiAgICByZXF1aXJlKFwiLi9wbHVnaW5zL0FyY2hXaWtpRml4TGlua3NcIiksXG4gICAgcmVxdWlyZShcIi4vcGx1Z2lucy9BcmNoV2lraU5ld1RlbXBsYXRlc1wiKSxcbiAgICByZXF1aXJlKFwiLi9wbHVnaW5zL0FyY2hXaWtpTlBGaWx0ZXJcIiksXG4gICAgcmVxdWlyZShcIi4vcGx1Z2lucy9BcmNoV2lraVJDRmlsdGVyXCIpLFxuICAgIHJlcXVpcmUoXCIuL3BsdWdpbnMvQXJjaFdpa2lTYXZlVGFsa1wiKSxcbiAgICByZXF1aXJlKFwiLi9wbHVnaW5zL0FyY2hXaWtpU29ydENvbnRhY3RzXCIpLFxuICAgICMgVGhlIEFyY2hQYWNrYWdlcyBtb2R1bGUgaXMgY3VycmVudGx5IHVudXNhYmxlXG4gICAgI3JlcXVpcmUoXCIuL3BsdWdpbnMvQXJjaFdpa2lVcGRhdGVQYWNrYWdlVGVtcGxhdGVzXCIpLFxuICAgIHJlcXVpcmUoXCIuL3BsdWdpbnMvQXJjaFdpa2lXYW50ZWRDYXRlZ29yaWVzXCIpLFxuICAgIHJlcXVpcmUoXCIuL3BsdWdpbnMvRGVsZXRlUGFnZXNcIiksXG4gICAgcmVxdWlyZShcIi4vcGx1Z2lucy9FeHBhbmRDb250cmFjdGlvbnNcIiksXG4gICAgcmVxdWlyZShcIi4vcGx1Z2lucy9GaXhCYWNrbGlua0ZyYWdtZW50c1wiKSxcbiAgICByZXF1aXJlKFwiLi9wbHVnaW5zL0ZpeERvdWJsZVJlZGlyZWN0c1wiKSxcbiAgICByZXF1aXJlKFwiLi9wbHVnaW5zL0ZpeEZyYWdtZW50c1wiKSxcbiAgICByZXF1aXJlKFwiLi9wbHVnaW5zL0ZpeExpbmtGcmFnbWVudHNcIiksXG4gICAgcmVxdWlyZShcIi4vcGx1Z2lucy9NdWx0aXBsZUxpbmVCcmVha3NcIiksXG4gICAgcmVxdWlyZShcIi4vcGx1Z2lucy9TaW1wbGVSZXBsYWNlXCIpLFxuICAgIHJlcXVpcmUoXCIuL3BsdWdpbnMvU3luY2hyb25pemVJbnRlcmxhbmd1YWdlTGlua3NcIiksXG4gICAgcmVxdWlyZShcIi4vcGx1Z2lucy9VcGRhdGVDYXRlZ29yeVRyZWVcIiksXG4pXG4iLCIjIFdpa2kgTW9ua2V5IC0gTWVkaWFXaWtpIGJvdCBhbmQgZWRpdG9yLWFzc2lzdGFudCB1c2VyIHNjcmlwdFxuIyBDb3B5cmlnaHQgKEMpIDIwMTEgRGFyaW8gR2lvdmFubmV0dGkgPGRldkBkYXJpb2dpb3Zhbm5ldHRpLm5ldD5cbiNcbiMgVGhpcyBmaWxlIGlzIHBhcnQgb2YgV2lraSBNb25rZXkuXG4jXG4jIFdpa2kgTW9ua2V5IGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiMgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiMgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiMgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbiNcbiMgV2lraSBNb25rZXkgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiMgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiMgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuIyBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuI1xuIyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuIyBhbG9uZyB3aXRoIFdpa2kgTW9ua2V5LiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuXG57anNzY30gPSByZXF1aXJlKCcuLi9tb2R1bGVzL2xpYnMnKVxuV00gPSByZXF1aXJlKCcuLi9tb2R1bGVzJylcbkFwcCA9IHJlcXVpcmUoJy4vaW5kZXgnKVxuXG5cbmNsYXNzIG1vZHVsZS5leHBvcnRzXG4gICAgY29uc3RydWN0b3I6IChAV00sIGZ1bmN0aW9ucywgbGlzdHMpIC0+XG4gICAgICAgIEBjb25maWd1cmF0aW9uID1cbiAgICAgICAgICAgIHBsdWdpbl9uYW1lOiBudWxsXG4gICAgICAgICAgICBmdW5jdGlvbl86IC0+XG4gICAgICAgICAgICBmaWx0ZXJzOiBbXVxuICAgICAgICAgICAgbGlzdDpcbiAgICAgICAgICAgICAgICBjdXJyZW50OiBudWxsXG4gICAgICAgICAgICAgICAgcHJldmlvdXM6IG51bGxcbiAgICAgICAgICAgIHZpc2l0ZWQ6IFtdXG5cbiAgICAgICAgIyBsb2NhbFN0b3JhZ2UgY2FuIG9ubHkgc3RvcmUgc3RyaW5nc1xuICAgICAgICBAYm90VG9rZW4gPSBcIjBcIlxuXG4gICAgICAgIGRpdkNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgICAgIGRpdkNvbnRhaW5lci5pZCA9ICdXaWtpTW9ua2V5Qm90J1xuXG4gICAgICAgIHtjbGFzc2VzfSA9IGpzc2MoXG4gICAgICAgICAgICBwbHVnaW5TZWxlY3Q6XG4gICAgICAgICAgICAgICAgd2lkdGg6ICcxMDAlJ1xuICAgICAgICAgICAgICAgIG1hcmdpbkJvdHRvbTogJzFlbSdcblxuICAgICAgICAgICAgbGlzdFNlbGVjdDpcbiAgICAgICAgICAgICAgICBtYXJnaW5Cb3R0b206ICcxZW0nXG5cbiAgICAgICAgICAgIGJvdEZpbHRlcjpcbiAgICAgICAgICAgICAgICBoZWlnaHQ6ICc2ZW0nXG4gICAgICAgICAgICAgICAgbWFyZ2luQm90dG9tOiAnMWVtJ1xuICAgICAgICAgICAgICAgIHJlc2l6ZTogJ3ZlcnRpY2FsJ1xuXG4gICAgICAgICAgICBib3RTdGFydFN0b3A6XG4gICAgICAgICAgICAgICAgbWFyZ2luUmlnaHQ6ICcwLjMzZW0nXG4gICAgICAgICAgICAgICAgbWFyZ2luQm90dG9tOiAnMWVtJ1xuICAgICAgICAgICAgICAgIGZvbnRXZWlnaHQ6ICdib2xkJ1xuXG4gICAgICAgICAgICBib3RTZWxlY3RlZDpcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICcjZmFhJ1xuICAgICAgICAgICAgICAgIHBhZGRpbmc6ICcwLjJlbSAwLjRlbSdcblxuICAgICAgICAgICAgYm90UHJvY2Vzc2luZzpcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICcjZmY4J1xuICAgICAgICAgICAgICAgIHBhZGRpbmc6ICcwLjJlbSAwLjRlbSdcblxuICAgICAgICAgICAgYm90Q2hhbmdlZDpcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICcjYWZhJ1xuICAgICAgICAgICAgICAgIHBhZGRpbmc6ICcwLjJlbSAwLjRlbSdcblxuICAgICAgICAgICAgYm90VW5jaGFuZ2VkOlxuICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJyNhYWYnXG4gICAgICAgICAgICAgICAgcGFkZGluZzogJzAuMmVtIDAuNGVtJ1xuXG4gICAgICAgICAgICBib3RCeXBhc3NlZDpcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdvcmFuZ2VyZWQnXG4gICAgICAgICAgICAgICAgcGFkZGluZzogJzAuMmVtIDAuNGVtJ1xuXG4gICAgICAgICAgICBib3RGYWlsZWQ6XG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAncmVkJ1xuICAgICAgICAgICAgICAgIHBhZGRpbmc6ICcwLjJlbSAwLjRlbSdcbiAgICAgICAgKVxuICAgICAgICBAY2xhc3NlcyA9IGNsYXNzZXNcblxuICAgICAgICBmZGl2ID0gQG1ha2VGdW5jdGlvblVJKGZ1bmN0aW9ucylcblxuICAgICAgICBpZiBmZGl2XG4gICAgICAgICAgICBkaXZDb250YWluZXIuYXBwZW5kQ2hpbGQoZmRpdilcbiAgICAgICAgICAgIGRpdkNvbnRhaW5lci5hcHBlbmRDaGlsZChAbWFrZUNvbmZVSShsaXN0cykpXG4gICAgICAgICAgICByZXR1cm4gZGl2Q29udGFpbmVyXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuXG4gICAgbWFrZUZ1bmN0aW9uVUk6IChmdW5jdGlvbnMpIC0+XG4gICAgICAgIHNlbGYgPSB0aGlzXG4gICAgICAgIGZpZWxkc2V0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZmllbGRzZXQnKVxuXG4gICAgICAgIGxlZ2VuZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xlZ2VuZCcpXG4gICAgICAgIGxlZ2VuZC5pbm5lckhUTUwgPSAnUGx1Z2luJ1xuXG4gICAgICAgIHNlbGVjdEZ1bmN0aW9ucyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NlbGVjdCcpXG4gICAgICAgIHNlbGVjdEZ1bmN0aW9ucy5pZCA9ICdXaWtpTW9ua2V5Qm90LVBsdWdpblNlbGVjdCdcbiAgICAgICAgc2VsZWN0RnVuY3Rpb25zLmNsYXNzTmFtZSA9IEBjbGFzc2VzLnBsdWdpblNlbGVjdFxuXG4gICAgICAgIGZmdW5jdGlvbnMgPSBbXVxuXG4gICAgICAgIGZvciBQbHVnaW4gaW4gZnVuY3Rpb25zXG4gICAgICAgICAgICBwbHVnaW4gPSBuZXcgUGx1Z2luKEBXTSlcbiAgICAgICAgICAgIHBsdWdpbkluc3QgPSBwbHVnaW4uY29uZi5ib3RfbGFiZWxcblxuICAgICAgICAgICAgIyBUaGlzIGFsbG93cyB0byBkaXNhYmxlIGFuIGVudHJ5IGJ5IGdpdmluZyBpdCBhbnkgc2Vjb25kXG4gICAgICAgICAgICAjIHBhcmFtZXRlciB0aGF0IGV2YWx1YXRlcyB0byBmYWxzZVxuICAgICAgICAgICAgaWYgbm90IHBsdWdpbkluc3Qgb3Igbm90IHBsdWdpbkluc3QubGVuZ3RoXG4gICAgICAgICAgICAgICAgY29udGludWVcblxuICAgICAgICAgICAgZmZ1bmN0aW9ucy5wdXNoKHBsdWdpbilcbiAgICAgICAgICAgIG9wdGlvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ29wdGlvbicpXG4gICAgICAgICAgICBvcHRpb24uaW5uZXJIVE1MID0gcGx1Z2luSW5zdFxuXG4gICAgICAgICAgICBpZiBwbHVnaW4uY29uc3RydWN0b3IubmFtZSBpcyBXTS5jb25mLmRlZmF1bHRfYm90X3BsdWdpblxuICAgICAgICAgICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IHRydWVcblxuICAgICAgICAgICAgc2VsZWN0RnVuY3Rpb25zLmFwcGVuZENoaWxkKG9wdGlvbilcblxuICAgICAgICBpZiBmZnVuY3Rpb25zLmxlbmd0aFxuICAgICAgICAgICAgc2VsZWN0RnVuY3Rpb25zLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgKCAoZmZ1bmN0aW9ucykgLT5cbiAgICAgICAgICAgICAgICByZXR1cm4gLT5cbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnV2lraU1vbmtleUJvdC1QbHVnaW5TZWxlY3QnKVxuICAgICAgICAgICAgICAgICAgICBpZCA9IHNlbGVjdC5zZWxlY3RlZEluZGV4XG4gICAgICAgICAgICAgICAgICAgIFVJID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ1dpa2lNb25rZXlCb3RGdW5jdGlvbicpXG4gICAgICAgICAgICAgICAgICAgIHBsdWdpbiA9IGZmdW5jdGlvbnNbaWRdXG4gICAgICAgICAgICAgICAgICAgICMgWzFdIE5vdGUgdGhhdCB0aGlzIG11c3QgYWxzbyBiZSBleGVjdXRlZCBpbW1lZGlhdGVseSxcbiAgICAgICAgICAgICAgICAgICAgIyAgIHNlZSBbMl1cbiAgICAgICAgICAgICAgICAgICAgbWFrZVVJID0gcGx1Z2luLm1ha2VCb3RVSVxuICAgICAgICAgICAgICAgICAgICBpZiBtYWtlVUkgaW5zdGFuY2VvZiBGdW5jdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgVUkucmVwbGFjZUNoaWxkKG1ha2VVSSgpLCBVSS5maXJzdENoaWxkKVxuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAjIERvbid0IHJlbW92ZUNoaWxkLCBvdGhlcndpc2UgaWYgYW5vdGhlciBwbHVnaW4gd2l0aFxuICAgICAgICAgICAgICAgICAgICAgICAgIyBpbnRlcmZhY2UgaXMgc2VsZWN0ZWQsIHJlcGxhY2VDaGlsZCB3b24ndCB3b3JrXG4gICAgICAgICAgICAgICAgICAgICAgICBVSS5yZXBsYWNlQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVUkuZmlyc3RDaGlsZClcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jb25maWd1cmF0aW9uLnBsdWdpbl9uYW1lID0gcGx1Z2luLmNvbnN0cnVjdG9yLm5hbWVcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jb25maWd1cmF0aW9uLmZ1bmN0aW9uXyA9ICh0aXRsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsQ29udGludWUsIGNoYWluQXJncykgLT5cbiAgICAgICAgICAgICAgICAgICAgICAgIHBsdWdpbi5tYWluX2JvdCh0aXRsZSwgY2FsbENvbnRpbnVlLCBjaGFpbkFyZ3MpXG4gICAgICAgICAgICApKGZmdW5jdGlvbnMpLCBmYWxzZSlcblxuICAgICAgICAgICAgZGl2RnVuY3Rpb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgICAgICAgICAgZGl2RnVuY3Rpb24uaWQgPSBcIldpa2lNb25rZXlCb3RGdW5jdGlvblwiXG5cbiAgICAgICAgICAgIHBsdWdpbiA9IGZmdW5jdGlvbnNbc2VsZWN0RnVuY3Rpb25zLnNlbGVjdGVkSW5kZXhdXG5cbiAgICAgICAgICAgICMgWzJdIE5vdGUgdGhhdCB0aGlzIGlzIGFsc28gZXhlY3V0ZWQgb25jaGFuZ2UsIHNlZSBbMV1cbiAgICAgICAgICAgIG1ha2VVSSA9IHBsdWdpbi5tYWtlQm90VUlcbiAgICAgICAgICAgIGlmIG1ha2VVSSBpbnN0YW5jZW9mIEZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgZGl2RnVuY3Rpb24uYXBwZW5kQ2hpbGQobWFrZVVJKCkpXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgZGl2RnVuY3Rpb24uYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JykpXG4gICAgICAgICAgICBAY29uZmlndXJhdGlvbi5wbHVnaW5fbmFtZSA9IHBsdWdpbi5jb25zdHJ1Y3Rvci5uYW1lXG4gICAgICAgICAgICBAY29uZmlndXJhdGlvbi5mdW5jdGlvbl8gPSAodGl0bGUsIGNhbGxDb250aW51ZSwgY2hhaW5BcmdzKSAtPlxuICAgICAgICAgICAgICAgIHBsdWdpbi5tYWluX2JvdCh0aXRsZSwgY2FsbENvbnRpbnVlLCBjaGFpbkFyZ3MpXG5cbiAgICAgICAgICAgIGZpZWxkc2V0LmFwcGVuZENoaWxkKGxlZ2VuZClcbiAgICAgICAgICAgIGZpZWxkc2V0LmFwcGVuZENoaWxkKHNlbGVjdEZ1bmN0aW9ucylcbiAgICAgICAgICAgIGZpZWxkc2V0LmFwcGVuZENoaWxkKGRpdkZ1bmN0aW9uKVxuXG4gICAgICAgICAgICByZXR1cm4gZmllbGRzZXRcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG5cbiAgICBtYWtlTGlzdFNlbGVjdG9yOiAobGlzdHMpIC0+XG4gICAgICAgIHNlbGYgPSB0aGlzXG4gICAgICAgIHNlbGVjdExpc3RzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2VsZWN0JylcbiAgICAgICAgc2VsZWN0TGlzdHMuaWQgPSAnV2lraU1vbmtleUJvdC1MaXN0U2VsZWN0J1xuICAgICAgICBzZWxlY3RMaXN0cy5jbGFzc05hbWUgPSBAY2xhc3Nlcy5saXN0U2VsZWN0XG5cbiAgICAgICAgZm9yIGxpc3QgaW4gbGlzdHNcbiAgICAgICAgICAgIGlmIGxpc3RbMF1cbiAgICAgICAgICAgICAgICBvcHRpb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdvcHRpb24nKVxuICAgICAgICAgICAgICAgIG9wdGlvbi5pbm5lckhUTUwgPSBsaXN0WzJdXG4gICAgICAgICAgICAgICAgc2VsZWN0TGlzdHMuYXBwZW5kQ2hpbGQob3B0aW9uKVxuXG4gICAgICAgICAgICAgICAgaWYgbm90IEBjb25maWd1cmF0aW9uLmxpc3QuY3VycmVudFxuICAgICAgICAgICAgICAgICAgICAjIFsxXSBOb3RlIHRoYXQgdGhpcyBpcyBhbHNvIGV4ZWN1dGVkIG9uY2hhbmdlLCBzZWUgWzJdXG4gICAgICAgICAgICAgICAgICAgIEBjb25maWd1cmF0aW9uLmxpc3QuY3VycmVudCA9IGxpc3RcblxuICAgICAgICBzZWxlY3RMaXN0cy5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsICggKGxzcykgLT5cbiAgICAgICAgICAgIHJldHVybiAtPlxuICAgICAgICAgICAgICAgIHNlbGVjdCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdXaWtpTW9ua2V5Qm90LUxpc3RTZWxlY3QnKVxuICAgICAgICAgICAgICAgIGlkID0gc2VsZWN0LnNlbGVjdGVkSW5kZXhcbiAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZ3VyYXRpb24ubGlzdC5wcmV2aW91cyA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29uZmlndXJhdGlvbi5saXN0LmN1cnJlbnRcbiAgICAgICAgICAgICAgICAjIFsyXSBOb3RlIHRoYXQgdGhpcyBtdXN0IGFsc28gYmUgZXhlY3V0ZWQgaW1tZWRpYXRlbHksXG4gICAgICAgICAgICAgICAgIyAgIHNlZSBbMV1cbiAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZ3VyYXRpb24ubGlzdC5jdXJyZW50ID0gbHNzW2lkXVxuICAgICAgICApKGxpc3RzKSwgZmFsc2UpXG5cbiAgICAgICAgcmV0dXJuIHNlbGVjdExpc3RzXG5cbiAgICBtYWtlQ29uZlVJOiAobGlzdHMpIC0+XG4gICAgICAgIHNlbGYgPSB0aGlzXG4gICAgICAgIGJvdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG5cbiAgICAgICAgZmllbGRzZXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdmaWVsZHNldCcpXG5cbiAgICAgICAgbGVnZW5kID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGVnZW5kJylcbiAgICAgICAgbGVnZW5kLmlubmVySFRNTCA9ICdGaWx0ZXInXG5cbiAgICAgICAgbGlzdFNlbGVjdCA9IEBtYWtlTGlzdFNlbGVjdG9yKGxpc3RzKVxuXG4gICAgICAgIGZpbHRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RleHRhcmVhJylcbiAgICAgICAgZmlsdGVyLmlkID0gJ1dpa2lNb25rZXlCb3RGaWx0ZXInXG4gICAgICAgIGZpbHRlci5jbGFzc05hbWUgPSBAY2xhc3Nlcy5ib3RGaWx0ZXJcblxuICAgICAgICBwcmV2aWV3ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKVxuICAgICAgICBwcmV2aWV3LmlkID0gJ1dpa2lNb25rZXlCb3RQcmV2aWV3J1xuICAgICAgICBwcmV2aWV3LnR5cGUgPSAnYnV0dG9uJ1xuICAgICAgICBwcmV2aWV3LnZhbHVlID0gJ1ByZXZpZXcnXG5cbiAgICAgICAgZHVwbGljYXRlcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0JylcbiAgICAgICAgZHVwbGljYXRlcy50eXBlID0gJ2NoZWNrYm94J1xuICAgICAgICBkdXBsaWNhdGVzLmlkID0gJ1dpa2lNb25rZXlCb3REdXBsaWNhdGVzJ1xuXG4gICAgICAgIGludmVyc2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpXG4gICAgICAgIGludmVyc2UudHlwZSA9ICdjaGVja2JveCdcbiAgICAgICAgaW52ZXJzZS5pZCA9ICdXaWtpTW9ua2V5Qm90SW52ZXJzZSdcblxuICAgICAgICBlbGVtcyA9IFtmaWx0ZXIsIGR1cGxpY2F0ZXMsIGludmVyc2VdXG5cbiAgICAgICAgZm9yIGVsZW0gaW4gZWxlbXNcbiAgICAgICAgICAgIGVsZW0uYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCAtPlxuICAgICAgICAgICAgICAgIHNlbGYuX2Rpc2FibGVTdGFydEJvdChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0ZpbHRlcnMgaGF2ZSBjaGFuZ2VkLCBwcmV2aWV3IHRoZSBzZWxlY3Rpb24nKVxuICAgICAgICAgICAgLCBmYWxzZSlcblxuICAgICAgICBkdXBsaWNhdGVzdGFnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpXG4gICAgICAgIGR1cGxpY2F0ZXN0YWcuaW5uZXJIVE1MID0gJ0R1cGxpY2F0ZXMnXG5cbiAgICAgICAgaW52ZXJzZXRhZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKVxuICAgICAgICBpbnZlcnNldGFnLmlubmVySFRNTCA9ICdJbnZlcnNlJ1xuXG4gICAgICAgIHByZXZpZXcuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIEBfcHJldmlld0ZpbHRlciwgZmFsc2UpXG5cbiAgICAgICAgZmllbGRzZXQuYXBwZW5kQ2hpbGQobGVnZW5kKVxuICAgICAgICBpZiBsaXN0U2VsZWN0Lmxlbmd0aCA+IDFcbiAgICAgICAgICAgIGZpZWxkc2V0LmFwcGVuZENoaWxkKGxpc3RTZWxlY3QpXG4gICAgICAgIGZpZWxkc2V0LmFwcGVuZENoaWxkKGZpbHRlcilcbiAgICAgICAgZmllbGRzZXQuYXBwZW5kQ2hpbGQocHJldmlldylcbiAgICAgICAgZmllbGRzZXQuYXBwZW5kQ2hpbGQoZHVwbGljYXRlcylcbiAgICAgICAgZmllbGRzZXQuYXBwZW5kQ2hpbGQoZHVwbGljYXRlc3RhZylcbiAgICAgICAgZmllbGRzZXQuYXBwZW5kQ2hpbGQoaW52ZXJzZSlcbiAgICAgICAgZmllbGRzZXQuYXBwZW5kQ2hpbGQoaW52ZXJzZXRhZylcblxuICAgICAgICBzdGFydCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0JylcbiAgICAgICAgc3RhcnQudHlwZSA9ICdidXR0b24nXG4gICAgICAgIHN0YXJ0LnZhbHVlID0gJ1N0YXJ0IGJvdCdcbiAgICAgICAgc3RhcnQuaWQgPSAnV2lraU1vbmtleUJvdFN0YXJ0J1xuICAgICAgICBzdGFydC5jbGFzc05hbWUgPSBAY2xhc3Nlcy5ib3RTdGFydFN0b3BcblxuICAgICAgICBzdGFydC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgQF9zdGFydEF1dG9tYXRpYywgZmFsc2UpXG5cbiAgICAgICAgc3RhcnQuZGlzYWJsZWQgPSB0cnVlXG5cbiAgICAgICAgc3RhcnRNc2cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJylcbiAgICAgICAgc3RhcnRNc2cuaW5uZXJIVE1MID0gJ1NldCBhbmQgcHJldmlldyB0aGUgZmlsdGVyIGZpcnN0J1xuICAgICAgICBzdGFydE1zZy5pZCA9ICdXaWtpTW9ua2V5Qm90U3RhcnRNc2cnXG5cbiAgICAgICAgZm9yY2VTdGFydCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKVxuICAgICAgICBmb3JjZVN0YXJ0LmlkID0gJ1dpa2lNb25rZXlCb3RGb3JjZVN0YXJ0J1xuXG4gICAgICAgIGZvcmNlU3RhcnRDQiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0JylcbiAgICAgICAgZm9yY2VTdGFydENCLnR5cGUgPSAnY2hlY2tib3gnXG4gICAgICAgIGZvcmNlU3RhcnRDQi5kaXNhYmxlZCA9IHRydWVcblxuICAgICAgICBmb3JjZVN0YXJ0TGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJylcbiAgICAgICAgZm9yY2VTdGFydExhYmVsLmlubmVySFRNTCA9ICdGb3JjZSBzdGFydCwgc3RvcHBpbmcgYW55IG90aGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudGx5IHJ1bm5pbmcgYm90cydcblxuICAgICAgICBmb3JjZVN0YXJ0LnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIlxuICAgICAgICBmb3JjZVN0YXJ0LmFwcGVuZENoaWxkKGZvcmNlU3RhcnRDQilcbiAgICAgICAgZm9yY2VTdGFydC5hcHBlbmRDaGlsZChmb3JjZVN0YXJ0TGFiZWwpXG5cbiAgICAgICAgYm90LmFwcGVuZENoaWxkKGZpZWxkc2V0KVxuICAgICAgICBib3QuYXBwZW5kQ2hpbGQoc3RhcnQpXG4gICAgICAgIGJvdC5hcHBlbmRDaGlsZChzdGFydE1zZylcbiAgICAgICAgYm90LmFwcGVuZENoaWxkKGZvcmNlU3RhcnQpXG5cbiAgICAgICAgcmV0dXJuIGJvdFxuXG4gICAgX2VuYWJsZVN0YXJ0Qm90OiAtPlxuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnV2lraU1vbmtleUJvdFN0YXJ0TXNnJykuaW5uZXJIVE1MID0gJydcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ1dpa2lNb25rZXlCb3RTdGFydCcpLmRpc2FibGVkID0gZmFsc2VcblxuICAgIF9kaXNhYmxlU3RhcnRCb3Q6IChtZXNzYWdlKSAtPlxuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnV2lraU1vbmtleUJvdFN0YXJ0TXNnJykuaW5uZXJIVE1MID0gbWVzc2FnZVxuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnV2lraU1vbmtleUJvdFN0YXJ0JykuZGlzYWJsZWQgPSB0cnVlXG5cbiAgICBfZW5hYmxlU3RvcEJvdDogKHN0b3BJZCkgLT5cbiAgICAgICAgc2VsZiA9IHRoaXNcbiAgICAgICAgc3RvcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0JylcbiAgICAgICAgc3RvcC50eXBlID0gJ2J1dHRvbidcbiAgICAgICAgc3RvcC52YWx1ZSA9ICdTdG9wIGJvdCdcbiAgICAgICAgc3RvcC5pZCA9ICdXaWtpTW9ua2V5Qm90U3RvcCdcbiAgICAgICAgc3RvcC5jbGFzc05hbWUgPSBAY2xhc3Nlcy5ib3RTdGFydFN0b3BcblxuICAgICAgICBzdG9wLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoIChpZCkgLT5cbiAgICAgICAgICAgIHJldHVybiAtPlxuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChpZClcbiAgICAgICAgICAgICAgICAjIHJ1biBfZGlzYWJsZVN0b3BCb3QoKSBoZXJlLCBub3QgaW4gX2VuZEF1dG9tYXRpYygpXG4gICAgICAgICAgICAgICAgc2VsZi5fZGlzYWJsZVN0b3BCb3QoKVxuICAgICAgICAgICAgICAgIHNlbGYuX2VuZEF1dG9tYXRpYyh0cnVlKVxuICAgICAgICAgICAgICAgIEFwcC5sb2cubG9nSW5mbygnQm90IHN0b3BwZWQgbWFudWFsbHknKVxuICAgICAgICApKHN0b3BJZCksIGZhbHNlKVxuXG4gICAgICAgIHN0YXJ0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ1dpa2lNb25rZXlCb3RTdGFydCcpXG4gICAgICAgIHN0YXJ0LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHN0b3AsIHN0YXJ0KVxuICAgICAgICBzdGFydC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnXG5cbiAgICBfZGlzYWJsZVN0b3BCb3Q6IC0+XG4gICAgICAgIHN0b3AgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnV2lraU1vbmtleUJvdFN0b3AnKVxuICAgICAgICBzdG9wLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3RvcClcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ1dpa2lNb25rZXlCb3RTdGFydCcpLnN0eWxlLmRpc3BsYXkgPSAnaW5saW5lJ1xuXG4gICAgX2Rpc2FibGVDb250cm9sczogLT5cbiAgICAgICAgQF9zZXRFbmFibGVDb250cm9scyh0cnVlKVxuXG4gICAgX3JlRW5hYmxlQ29udHJvbHM6IC0+XG4gICAgICAgIEBfc2V0RW5hYmxlQ29udHJvbHMoZmFsc2UpXG5cbiAgICBfc2V0RW5hYmxlQ29udHJvbHM6IChmbGFnKSAtPlxuICAgICAgICBmc2V0cyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdXaWtpTW9ua2V5Qm90JylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdmaWVsZHNldCcpXG4gICAgICAgIGZvciBmc2V0IGluIGZzZXRzXG4gICAgICAgICAgICAjIEhUTUw1LWNvbXBsaWFudFxuICAgICAgICAgICAgZnNldC5kaXNhYmxlZCA9IGZsYWdcblxuICAgIF9lbmFibGVGb3JjZVN0YXJ0OiAtPlxuICAgICAgICBmb3JjZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdXaWtpTW9ua2V5Qm90Rm9yY2VTdGFydCcpXG4gICAgICAgIGZvcmNlLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdpbnB1dCcpWzBdLmRpc2FibGVkID0gZmFsc2VcbiAgICAgICAgZm9yY2Uuc3R5bGUuZGlzcGxheSA9ICdpbmxpbmUnXG5cbiAgICBfZGlzYWJsZUZvcmNlU3RhcnQ6IC0+XG4gICAgICAgIGZvcmNlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ1dpa2lNb25rZXlCb3RGb3JjZVN0YXJ0JylcbiAgICAgICAgZm9yY2UuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2lucHV0JylbMF0uY2hlY2tlZCA9IGZhbHNlXG4gICAgICAgIGZvcmNlLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdpbnB1dCcpWzBdLmRpc2FibGVkID0gdHJ1ZVxuICAgICAgICBmb3JjZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnXG5cbiAgICBfY2FuRm9yY2VTdGFydDogLT5cbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdXaWtpTW9ua2V5Qm90Rm9yY2VTdGFydCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2lucHV0JylbMF0uY2hlY2tlZFxuXG4gICAgbWFrZUZpbHRlcnM6IC0+XG4gICAgICAgIEBjb25maWd1cmF0aW9uLmZpbHRlcnMgPSBbXVxuICAgICAgICBmaWx0ZXJzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ1dpa2lNb25rZXlCb3RGaWx0ZXInKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAudmFsdWUuc3BsaXQoJ1xcbicpXG5cbiAgICAgICAgZm9yIGZpbHRlciBpbiBmaWx0ZXJzXG4gICAgICAgICAgICAjIGZpbHRlciBjb3VsZCBiZSBhbiBlbXB0eSBzdHJpbmdcbiAgICAgICAgICAgIGlmIGZpbHRlclxuICAgICAgICAgICAgICAgIGZpcnN0U2xhc2ggPSBmaWx0ZXIuaW5kZXhPZignLycpXG4gICAgICAgICAgICAgICAgbGFzdFNsYXNoID0gZmlsdGVyLmxhc3RJbmRleE9mKCcvJylcbiAgICAgICAgICAgICAgICBwYXR0ZXJuID0gZmlsdGVyLnN1YnN0cmluZyhmaXJzdFNsYXNoICsgMSwgbGFzdFNsYXNoKVxuICAgICAgICAgICAgICAgIG1vZGlmaWVycyA9IGZpbHRlci5zdWJzdHJpbmcobGFzdFNsYXNoICsgMSlcbiAgICAgICAgICAgICAgICBuZWdhdGl2ZSA9IGZpbHRlci5jaGFyQXQoMCkgPT0gJyEnXG5cbiAgICAgICAgICAgICAgICB0cnlcbiAgICAgICAgICAgICAgICAgICAgcmVnZXhwID0gbmV3IFJlZ0V4cChwYXR0ZXJuLCBtb2RpZmllcnMpXG4gICAgICAgICAgICAgICAgY2F0Y2ggZXhjXG4gICAgICAgICAgICAgICAgICAgIEFwcC5sb2cubG9nRXJyb3IoJ0ludmFsaWQgcmVnZXhwOiAnICsgZXhjKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcblxuICAgICAgICAgICAgICAgIEBjb25maWd1cmF0aW9uLmZpbHRlcnMucHVzaChbcmVnZXhwLCBuZWdhdGl2ZV0pXG4gICAgICAgICAgICAgICAgIyBEbyBub3QgcmV0dXJuIG5vciBicmVhaywgc28gdGhhdCBpZiBhbW9uZyB0aGUgZmlsdGVyc1xuICAgICAgICAgICAgICAgICMgICB0aGVyZSdzIGFuIGludmFsaWQgcmVnZXhwIHRoZSBmdW5jdGlvbiByZXR1cm5zIGZhbHNlXG5cbiAgICAgICAgcmV0dXJuIHRydWVcblxuICAgIGNhblByb2Nlc3NQYWdlOiAobGluaykgLT5cbiAgICAgICAgIyBFeGNsdWRlIHJlZCBsaW5rcyAodGhleSBjYW4gYmUgZm91bmQgaW4gc29tZSBzcGVjaWFsIHBhZ2VzKVxuICAgICAgICBpZiBsaW5rLmNsYXNzTmFtZS5zcGxpdChcIiBcIikuaW5kZXhPZihcIm5ld1wiKSA8IDBcbiAgICAgICAgICAgICMgRG9uJ3QgdXNlIGxpbmsudGl0bGUgYmVjYXVzZSBmb3IgZXhhbXBsZSBpbiBDYXRlZ29yeSBwYWdlcyBhbGxcbiAgICAgICAgICAgICMgICBzdWJwYWdlcyB3b3VsZCBpbmNsdWRlIFwiQ2F0ZWdvcnk6XCIsIHRodXMgYWx3YXlzIG1hdGNoaW5nXG4gICAgICAgICAgICAjICAgZmlsdGVycyBsaWtlIFwiL2EvXCIsIFwiL3QvXCIgZXRjLlxuICAgICAgICAgICAgdGl0bGUgPSBsaW5rLmlubmVySFRNTFxuICAgICAgICAgICAgZHVwbGljYXRlcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdXaWtpTW9ua2V5Qm90RHVwbGljYXRlcycpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jaGVja2VkXG5cbiAgICAgICAgICAgIGlmIGR1cGxpY2F0ZXMgb3IgQGNvbmZpZ3VyYXRpb24udmlzaXRlZC5pbmRleE9mKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlKSA8IDBcbiAgICAgICAgICAgICAgICBAY29uZmlndXJhdGlvbi52aXNpdGVkLnB1c2godGl0bGUpXG4gICAgICAgICAgICAgICAgZmlsdGVycyA9IEBjb25maWd1cmF0aW9uLmZpbHRlcnNcbiAgICAgICAgICAgICAgICBpbnZlcnNlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ1dpa2lNb25rZXlCb3RJbnZlcnNlJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNoZWNrZWRcblxuICAgICAgICAgICAgICAgIGlmIGZpbHRlcnMubGVuZ3RoID4gMFxuICAgICAgICAgICAgICAgICAgICBmb3IgZmlsdGVyIGluIGZpbHRlcnNcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2V4cCA9IGZpbHRlclswXVxuICAgICAgICAgICAgICAgICAgICAgICAgbmVnYXRpdmUgPSBmaWx0ZXJbMV1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRlc3QgPSByZWdleHAudGVzdCh0aXRsZSlcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgdGVzdCAhPSBuZWdhdGl2ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpZiBpbnZlcnNlIHRoZW4gZmFsc2UgZWxzZSB0cnVlXG5cbiAgICAgICAgICAgICAgICAgICAgIyBObyAodGVzdCAhPSBuZWdhdGl2ZSkgY29uZGl0aW9uIGhhcyBiZWVuIG1ldCBpbiB0aGUgbG9vcFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWYgaW52ZXJzZSB0aGVuIHRydWUgZWxzZSBmYWxzZVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlmIGludmVyc2UgdGhlbiBmYWxzZSBlbHNlIHRydWVcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG5cbiAgICBjaGFuZ2VXaWtpTW9ua2V5TGlua0NsYXNzTmFtZTogKGNsYXNzTmFtZSwgbmV3Q2xhc3MpIC0+XG4gICAgICAgIGNsYXNzZXMgPSBjbGFzc05hbWUuc3BsaXQoXCIgXCIpXG4gICAgICAgIG5ld0NsYXNzZXMgPSBbXVxuXG4gICAgICAgIGZvciBjbHMgaW4gY2xhc3Nlc1xuICAgICAgICAgICAgaWYgY2xzLmluZGV4T2YoXCJXaWtpTW9ua2V5XCIpIDwgMFxuICAgICAgICAgICAgICAgIG5ld0NsYXNzZXMucHVzaChjbHMpXG5cbiAgICAgICAgIyBEb24ndCBwdXNoIGluIGFuIGVsc2UgYmxvY2sgaW5zaWRlIHRoZSBsb29wLCBzbyB0aGF0IGlmIHRoZXJlIHdhc1xuICAgICAgICAjIG5vIFdpa2lNb25rZXkgY2xhc3Mgc2V0LCBpdCB3aWxsIGJlIGFkZGVkXG4gICAgICAgIG5ld0NsYXNzZXMucHVzaChuZXdDbGFzcylcblxuICAgICAgICByZXR1cm4gbmV3Q2xhc3Nlcy5qb2luKFwiIFwiKVxuXG4gICAgcmVzdG9yZU9yaWdpbmFsTGlua0NsYXNzTmFtZTogKGNsYXNzTmFtZSkgLT5cbiAgICAgICAgY2xhc3NlcyA9IGNsYXNzTmFtZS5zcGxpdChcIiBcIilcbiAgICAgICAgb3JpZ0NsYXNzZXMgPSBbXVxuXG4gICAgICAgIGZvciBjbHMgaW4gY2xhc3Nlc1xuICAgICAgICAgICAgaWYgY2xzLmluZGV4T2YoXCJXaWtpTW9ua2V5XCIpIDwgMFxuICAgICAgICAgICAgICAgIG9yaWdDbGFzc2VzLnB1c2goY2xzKVxuXG4gICAgICAgIHJldHVybiBvcmlnQ2xhc3Nlcy5qb2luKFwiIFwiKVxuXG4gICAgX3ByZXZpZXdGaWx0ZXI6ID0+XG4gICAgICAgIEFwcC5sb2cubG9nSW5mbygnVXBkYXRpbmcgZmlsdGVyIHByZXZpZXcsIHBsZWFzZSB3YWl0IC4uLicpXG4gICAgICAgIEBfZGlzYWJsZVN0YXJ0Qm90KCdVcGRhdGluZyBmaWx0ZXIgcHJldmlldyAuLi4nKVxuXG4gICAgICAgIGlmIEBjb25maWd1cmF0aW9uLmxpc3QucHJldmlvdXNcbiAgICAgICAgICAgIGlmIEBjb25maWd1cmF0aW9uLmxpc3QuY3VycmVudFswXS5ub2RlTmFtZSA9PSAnVEJPRFknXG4gICAgICAgICAgICAgICAgaXRlbXMgPSBAY29uZmlndXJhdGlvbi5saXN0LnByZXZpb3VzWzBdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3RkJylcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBpdGVtcyA9IEBjb25maWd1cmF0aW9uLmxpc3QucHJldmlvdXNbMF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnbGknKVxuICAgICAgICAgICAgbGlua0lkID0gQGNvbmZpZ3VyYXRpb24ubGlzdC5wcmV2aW91c1sxXVxuXG4gICAgICAgICAgICBmb3IgaXRlbSBpbiBpdGVtc1xuICAgICAgICAgICAgICAgIGxpbmsgPSBpdGVtLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdhJylbbGlua0lkXVxuXG4gICAgICAgICAgICAgICAgIyBUaGUgbGlzdCBpdGVtIGNvdWxkIHJlZmVyIHRvIGFuIGludmFsaWQgdGl0bGUsIHJlcHJlc2VudGVkXG4gICAgICAgICAgICAgICAgIyBieSBlLmcuIDxzcGFuIGNsYXNzPVwibXctaW52YWxpZHRpdGxlXCI+SW52YWxpZCB0aXRsZSB3aXRoXG4gICAgICAgICAgICAgICAgIyBuYW1lc3BhY2UgXCJDYXRlZ29yeVwiIGFuZCB0ZXh0IFwiXCI8L3NwYW4+XG4gICAgICAgICAgICAgICAgaWYgbGlua1xuICAgICAgICAgICAgICAgICAgICBsaW5rLmNsYXNzTmFtZSA9IEByZXN0b3JlT3JpZ2luYWxMaW5rQ2xhc3NOYW1lKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluay5jbGFzc05hbWUpXG5cbiAgICAgICAgQGNvbmZpZ3VyYXRpb24udmlzaXRlZCA9IFtdXG5cbiAgICAgICAgbGlua0lkID0gQGNvbmZpZ3VyYXRpb24ubGlzdC5jdXJyZW50WzFdXG4gICAgICAgIGVuYWJsZSA9IGZhbHNlXG4gICAgICAgIE4gPSAwXG5cbiAgICAgICAgaWYgQG1ha2VGaWx0ZXJzKClcbiAgICAgICAgICAgIGlmIEBjb25maWd1cmF0aW9uLmxpc3QuY3VycmVudFswXS5ub2RlTmFtZSA9PSAnVEJPRFknXG4gICAgICAgICAgICAgICAgaXRlbXMgPVxuICAgICAgICAgICAgICAgICAgICBAY29uZmlndXJhdGlvbi5saXN0LmN1cnJlbnRbMF0uZ2V0RWxlbWVudHNCeVRhZ05hbWUoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAndGQnKVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGl0ZW1zID1cbiAgICAgICAgICAgICAgICAgICAgQGNvbmZpZ3VyYXRpb24ubGlzdC5jdXJyZW50WzBdLmdldEVsZW1lbnRzQnlUYWdOYW1lKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2xpJylcblxuICAgICAgICAgICAgZm9yIGl0ZW0gaW4gaXRlbXNcbiAgICAgICAgICAgICAgICBsaW5rID0gaXRlbS5nZXRFbGVtZW50c0J5VGFnTmFtZSgnYScpW2xpbmtJZF1cblxuICAgICAgICAgICAgICAgICMgQWxzbyB0ZXN0ICdsaW5rJyBpdHNlbGYsIGJlY2F1c2UgdGhlIGxpc3QgaXRlbSBjb3VsZCByZWZlclxuICAgICAgICAgICAgICAgICMgdG8gYW4gaW52YWxpZCB0aXRsZSwgcmVwcmVzZW50ZWQgYnkgZS5nLlxuICAgICAgICAgICAgICAgICMgPHNwYW4gY2xhc3M9XCJtdy1pbnZhbGlkdGl0bGVcIj5JbnZhbGlkIHRpdGxlIHdpdGggbmFtZXNwYWNlXG4gICAgICAgICAgICAgICAgIyBcIkNhdGVnb3J5XCIgYW5kIHRleHQgXCJcIjwvc3Bhbj5cbiAgICAgICAgICAgICAgICBpZiBsaW5rXG4gICAgICAgICAgICAgICAgICAgIGlmIEBjYW5Qcm9jZXNzUGFnZShsaW5rKVxuICAgICAgICAgICAgICAgICAgICAgICAgbGluay5jbGFzc05hbWUgPSBAY2hhbmdlV2lraU1vbmtleUxpbmtDbGFzc05hbWUoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rLmNsYXNzTmFtZSwgQGNsYXNzZXMuYm90U2VsZWN0ZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmFibGUgPSB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICBOKytcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgbGluay5jbGFzc05hbWUgPSBAcmVzdG9yZU9yaWdpbmFsTGlua0NsYXNzTmFtZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmsuY2xhc3NOYW1lKVxuXG4gICAgICAgIEFwcC5sb2cubG9nSW5mbygnUHJldmlldyB1cGRhdGVkICgnICsgTiArICcgcGFnZXMgc2VsZWN0ZWQpJylcblxuICAgICAgICBpZiBlbmFibGVcbiAgICAgICAgICAgIEBfZW5hYmxlU3RhcnRCb3QoKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICBAX2Rpc2FibGVTdGFydEJvdChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnTm8gcGFnZXMgc2VsZWN0ZWQsIHJlc2V0IGFuZCBwcmV2aWV3IHRoZSBmaWx0ZXInKVxuXG4gICAgX3NldEJvdFRva2VuOiAtPlxuICAgICAgICBkYXRlID0gbmV3IERhdGUoKVxuICAgICAgICB0b2tlbiA9IGRhdGUuZ2V0VGltZSgpICsgXCJcIlxuICAgICAgICBAYm90VG9rZW4gPSB0b2tlblxuICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnV2lraU1vbmtleUJvdFRva2VuJywgdG9rZW4pXG5cbiAgICBfcmVzZXRCb3RUb2tlbjogKHJlc2V0KSAtPlxuICAgICAgICBAYm90VG9rZW4gPSBcIjBcIlxuICAgICAgICBpZiByZXNldFxuICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ1dpa2lNb25rZXlCb3RUb2tlbicsIFwiMFwiKVxuXG4gICAgX2dldEJvdFRva2VuOiAtPlxuICAgICAgICByZXR1cm4gQGJvdFRva2VuXG5cbiAgICBfY2hlY2tPdGhlckJvdHNSdW5uaW5nOiAtPlxuICAgICAgICB2YWx1ZSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdXaWtpTW9ua2V5Qm90VG9rZW4nKVxuXG4gICAgICAgICMgdmFsdWUgbWF5IGJlIG51bGwgaWYgaXQncyBuZXZlciBiZWVuIHN0b3JlZCBpbiBsb2NhbFN0b3JhZ2VcbiAgICAgICAgcmV0dXJuIHZhbHVlIGFuZCB2YWx1ZSAhPSBcIjBcIiBhbmQgdmFsdWUgIT0gQF9nZXRCb3RUb2tlbigpXG5cbiAgICBfc3RhcnRBdXRvbWF0aWM6ID0+XG4gICAgICAgIGlmIEBfY2hlY2tPdGhlckJvdHNSdW5uaW5nKCkgYW5kIG5vdCBAX2NhbkZvcmNlU3RhcnQoKVxuICAgICAgICAgICAgQXBwLmxvZy5sb2dFcnJvcihcIkl0J3Mgbm90IHBvc3NpYmxlIHRvIHN0YXJ0IHRoZSBib3QgKHdpdGhvdXRcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcmNpbmcgaXQpIGZvciBvbmUgb2YgdGhlIGZvbGxvd2luZyByZWFzb25zOjxicj5cbiAgICAgICAgICAgICAgICAgICAgICAgICogYW5vdGhlciBib3QgaW5zdGFuY2UgaXMgY3VycmVudGx5IHJ1bm5pbmc8YnI+XG4gICAgICAgICAgICAgICAgICAgICAgICAqIGEgcHJldmlvdXNseSBydW5uaW5nIGJvdCBoYXMgc3RvcHBlZCBkdWUgdG8gYVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFnZSBwcm9jZXNzaW5nIGVycm9yPGJyPlxuICAgICAgICAgICAgICAgICAgICAgICAgKiBhIHByZXZpb3VzbHkgcnVubmluZyBib3QgaGFzIHN0b3BwZWQgZHVlIHRvIGFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBKYXZhc2NyaXB0IGVycm9yPGJyPlxuICAgICAgICAgICAgICAgICAgICAgICAgKiBhIHByZXZpb3VzbHkgcnVubmluZyBib3QgaGFzIGJlZW4gaW50ZXJydXB0ZWQgYnlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhIGJyb3dzZXIgcGFnZSByZWZyZXNoXCIpXG4gICAgICAgICAgICBAX2VuYWJsZUZvcmNlU3RhcnQoKVxuICAgICAgICBlbHNlIGlmIEBtYWtlRmlsdGVycygpXG4gICAgICAgICAgICBpZiBAY29uZmlndXJhdGlvbi5saXN0LmN1cnJlbnRbMF0ubm9kZU5hbWUgPT0gJ1RCT0RZJ1xuICAgICAgICAgICAgICAgIGl0ZW1zRE9NID0gQGNvbmZpZ3VyYXRpb24ubGlzdC5jdXJyZW50WzBdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3RkJylcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBpdGVtc0RPTSA9IEBjb25maWd1cmF0aW9uLmxpc3QuY3VycmVudFswXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdsaScpXG5cbiAgICAgICAgICAgICMgUGFzc2luZyB0aGUgbGl2ZSBjb2xsZWN0aW9uIHdpdGggdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHdhc1xuICAgICAgICAgICAgIyAgIGNhdXNpbmcgaXQgdG8gYmUgbG9zdCBpbiBhbiBhcHBhcmVudGx5IHJhbmRvbSBtYW5uZXJcbiAgICAgICAgICAgIGl0ZW1zID0gW11cblxuICAgICAgICAgICAgZm9yIGl0ZW0gaW4gaXRlbXNET01cbiAgICAgICAgICAgICAgICBpdGVtcy5wdXNoKGl0ZW0pXG5cbiAgICAgICAgICAgIGxpbmtJZCA9IEBjb25maWd1cmF0aW9uLmxpc3QuY3VycmVudFsxXVxuXG4gICAgICAgICAgICBAX2Rpc2FibGVGb3JjZVN0YXJ0KClcbiAgICAgICAgICAgIEBfc2V0Qm90VG9rZW4oKVxuICAgICAgICAgICAgQXBwLmxvZy5sb2dJbmZvKCdTdGFydGluZyBib3QgLi4uJylcbiAgICAgICAgICAgIEFwcC5sb2cubG9nSGlkZGVuKFwiUGx1Z2luOiBcIiArIEBjb25maWd1cmF0aW9uLnBsdWdpbl9uYW1lKVxuICAgICAgICAgICAgQXBwLmxvZy5sb2dIaWRkZW4oXCJGaWx0ZXI6IFwiICsgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnV2lraU1vbmtleUJvdEZpbHRlcicpLnZhbHVlKVxuICAgICAgICAgICAgQF9kaXNhYmxlU3RhcnRCb3QoJ0JvdCBpcyBydW5uaW5nIC4uLicpXG4gICAgICAgICAgICBAX2Rpc2FibGVDb250cm9scygpXG4gICAgICAgICAgICBAY29uZmlndXJhdGlvbi52aXNpdGVkID0gW11cblxuICAgICAgICAgICAgQFdNLk1XLmlzVXNlckJvdChAX3N0YXJ0QXV0b21hdGljQ29udGludWUsIFtpdGVtcywgbGlua0lkXSlcblxuICAgIF9zdGFydEF1dG9tYXRpY0NvbnRpbnVlOiAoYm90VGVzdCwgYXJncykgPT5cbiAgICAgICAgaXRlbXMgPSBhcmdzWzBdXG4gICAgICAgIGxpbmtJZCA9IGFyZ3NbMV1cblxuICAgICAgICBAY29uZmlndXJhdGlvbi5pbnRlcnZhbCA9IGlmIGJvdFRlc3QgdGhlbiAzMDAwIGVsc2UgMzAwMDBcbiAgICAgICAgQF9wcm9jZXNzSXRlbSgwLCBpdGVtcywgMCwgbGlua0lkLCBudWxsKVxuXG4gICAgbWFrZUNhbGxDb250aW51ZTogKGxpcywgaWQsIGxpbmtJZCwgbG4sIGFydGljbGUpIC0+XG4gICAgICAgIHNlbGYgPSB0aGlzXG4gICAgICAgIHJldHVybiAoc3RhdHVzLCByZXNBcmdzKSAtPlxuICAgICAgICAgICAgc3dpdGNoIHN0YXR1c1xuICAgICAgICAgICAgICAgICMgVGhlIGFydGljbGUgaGFzbid0IGJlZW4gc2F2ZWRcbiAgICAgICAgICAgICAgICB3aGVuIDBcbiAgICAgICAgICAgICAgICAgICAgbG4uY2xhc3NOYW1lID0gc2VsZi5jaGFuZ2VXaWtpTW9ua2V5TGlua0NsYXNzTmFtZShsbi5jbGFzc05hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQGNsYXNzZXMuYm90VW5jaGFuZ2VkKVxuICAgICAgICAgICAgICAgICAgICBBcHAubG9nLmxvZ0luZm8oQXBwLmxvZy5saW5rVG9XaWtpUGFnZShhcnRpY2xlLCBhcnRpY2xlKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgcHJvY2Vzc2VkICh1bmNoYW5nZWQpXCIpXG4gICAgICAgICAgICAgICAgICAgIGlkKytcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fcHJvY2Vzc0l0ZW0oc3RhdHVzLCBsaXMsIGlkLCBsaW5rSWQsIHJlc0FyZ3MpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgIyBUaGUgYXJ0aWNsZSBoYXMgYmVlbiBzYXZlZFxuICAgICAgICAgICAgICAgIHdoZW4gMVxuICAgICAgICAgICAgICAgICAgICBsbi5jbGFzc05hbWUgPSBzZWxmLmNoYW5nZVdpa2lNb25rZXlMaW5rQ2xhc3NOYW1lKGxuLmNsYXNzTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBAY2xhc3Nlcy5ib3RDaGFuZ2VkKVxuICAgICAgICAgICAgICAgICAgICBBcHAubG9nLmxvZ0luZm8oQXBwLmxvZy5saW5rVG9XaWtpUGFnZShhcnRpY2xlLCBhcnRpY2xlKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgcHJvY2Vzc2VkIChjaGFuZ2VkKVwiKVxuICAgICAgICAgICAgICAgICAgICBpZCsrXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX3Byb2Nlc3NJdGVtKHN0YXR1cywgbGlzLCBpZCwgbGlua0lkLCByZXNBcmdzKVxuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICMgVGhlIHBsdWdpbiBoYXMgZW5jb3VudGVyZWQgYSBwcm90ZWN0ZWRwYWdlIGVycm9yXG4gICAgICAgICAgICAgICAgd2hlbiAncHJvdGVjdGVkcGFnZSdcbiAgICAgICAgICAgICAgICAgICAgbG4uY2xhc3NOYW1lID0gc2VsZi5jaGFuZ2VXaWtpTW9ua2V5TGlua0NsYXNzTmFtZShsbi5jbGFzc05hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQGNsYXNzZXMuYm90QnlwYXNzZWQpXG4gICAgICAgICAgICAgICAgICAgIEFwcC5sb2cubG9nV2FybmluZyhcIlRoaXMgdXNlciBkb2Vzbid0IGhhdmUgdGhlIHJpZ2h0cyB0byBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImVkaXQgXCIgKyBBcHAubG9nLmxpbmtUb1dpa2lQYWdlKGFydGljbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnRpY2xlKSArIFwiLCBieXBhc3NpbmcgaXQgLi4uXCIpXG4gICAgICAgICAgICAgICAgICAgIGlkKytcbiAgICAgICAgICAgICAgICAgICAgIyBDaGFuZ2Ugc3RhdHVzIHRvIDAgKHBhZ2Ugbm90IGNoYW5nZWQpXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX3Byb2Nlc3NJdGVtKDAsIGxpcywgaWQsIGxpbmtJZCwgcmVzQXJncylcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAjIFRoZSBwbHVnaW4gaGFzIGVuY291bnRlcmVkIGEgY3JpdGljYWwgZXJyb3JcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGxuLmNsYXNzTmFtZSA9IHNlbGYuY2hhbmdlV2lraU1vbmtleUxpbmtDbGFzc05hbWUobG4uY2xhc3NOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBAY2xhc3Nlcy5ib3RGYWlsZWQpXG4gICAgICAgICAgICAgICAgICAgIEFwcC5sb2cubG9nRXJyb3IoXCJFcnJvciBwcm9jZXNzaW5nIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFwcC5sb2cubGlua1RvV2lraVBhZ2UoYXJ0aWNsZSwgYXJ0aWNsZSkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsIHN0b3BwaW5nIHRoZSBib3RcIilcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fZW5kQXV0b21hdGljKHRydWUpXG5cbiAgICBfcHJvY2Vzc0l0ZW06IChzdGF0dXMsIGl0ZW1zLCBpbmRleCwgbGlua0lkLCBjaGFpbkFyZ3MpIC0+XG4gICAgICAgIHNlbGYgPSB0aGlzXG4gICAgICAgIGlmIGl0ZW1zW2luZGV4XVxuICAgICAgICAgICAgbGluayA9IGl0ZW1zW2luZGV4XS5nZXRFbGVtZW50c0J5VGFnTmFtZSgnYScpW2xpbmtJZF1cblxuICAgICAgICAgICAgIyBBbHNvIHRlc3QgJ2xpbmsnIGl0c2VsZiwgYmVjYXVzZSB0aGUgbGlzdCBpdGVtIGNvdWxkIHJlZmVyIHRvIGFuXG4gICAgICAgICAgICAjIGludmFsaWQgdGl0bGUsIHJlcHJlc2VudGVkIGJ5IGUuZy5cbiAgICAgICAgICAgICMgPHNwYW4gY2xhc3M9XCJtdy1pbnZhbGlkdGl0bGVcIj5JbnZhbGlkIHRpdGxlIHdpdGggbmFtZXNwYWNlXG4gICAgICAgICAgICAjIFwiQ2F0ZWdvcnlcIiBhbmQgdGV4dCBcIlwiPC9zcGFuPlxuICAgICAgICAgICAgaWYgbGluayBhbmQgQGNhblByb2Nlc3NQYWdlKGxpbmspXG4gICAgICAgICAgICAgICAgdGl0bGUgPSBsaW5rLnRpdGxlXG5cbiAgICAgICAgICAgICAgICBpZiBzdGF0dXMgPT0gMFxuICAgICAgICAgICAgICAgICAgICBpbnRlcnZhbCA9IDEwMDBcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGludGVydmFsID0gQGNvbmZpZ3VyYXRpb24uaW50ZXJ2YWxcblxuICAgICAgICAgICAgICAgIEFwcC5sb2cubG9nSW5mbygnV2FpdGluZyAnICsgKGludGVydmFsIC8gMTAwMCkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyBzZWNvbmRzIC4uLicpXG5cbiAgICAgICAgICAgICAgICBzdG9wSWQgPSBzZXRUaW1lb3V0KCggKGxpcywgaWQsIGxuLCBhcnRpY2xlLCBjaGFpbkFyZ3MpIC0+XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtPlxuICAgICAgICAgICAgICAgICAgICAgICAgIyBTdG9wIG11c3QgYmUgZGlzYWJsZWQgYmVmb3JlIGFueSBjaGVjayBpcyBwZXJmb3JtZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX2Rpc2FibGVTdG9wQm90KClcblxuICAgICAgICAgICAgICAgICAgICAgICAgIyBDaGVjayBoZXJlIGlmIG90aGVyIGJvdHMgaGF2ZSBiZWVuIHN0YXJ0ZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAjIF9ub3RfIGJlZm9yZSBzZXRUaW1lb3V0IVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgbm90IHNlbGYuX2NoZWNrT3RoZXJCb3RzUnVubmluZygpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG4uY2xhc3NOYW1lID0gc2VsZi5jaGFuZ2VXaWtpTW9ua2V5TGlua0NsYXNzTmFtZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxuLmNsYXNzTmFtZSwgQGNsYXNzZXMuYm90UHJvY2Vzc2luZylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBBcHAubG9nLmxvZ0luZm8oXCJQcm9jZXNzaW5nIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFwcC5sb2cubGlua1RvV2lraVBhZ2UoYXJ0aWNsZSwgYXJ0aWNsZSkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgLi4uXCIpXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZ3VyYXRpb24uZnVuY3Rpb25fKGFydGljbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYubWFrZUNhbGxDb250aW51ZShsaXMsIGlkLCBsaW5rSWQsIGxuLCBhcnRpY2xlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhaW5BcmdzKVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFwcC5sb2cubG9nRXJyb3IoJ0Fub3RoZXIgYm90IGhhcyBiZWVuICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2ZvcmNlLXN0YXJ0ZWQsIHN0b3BwaW5nIC4uLicpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fZW5kQXV0b21hdGljKGZhbHNlKVxuICAgICAgICAgICAgICAgICkoaXRlbXMsIGluZGV4LCBsaW5rLCB0aXRsZSwgY2hhaW5BcmdzKSwgaW50ZXJ2YWwpXG5cbiAgICAgICAgICAgICAgICBAX2VuYWJsZVN0b3BCb3Qoc3RvcElkKVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGluZGV4KytcbiAgICAgICAgICAgICAgICBAX3Byb2Nlc3NJdGVtKHN0YXR1cywgaXRlbXMsIGluZGV4LCBsaW5rSWQsIGNoYWluQXJncylcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgQF9lbmRBdXRvbWF0aWModHJ1ZSlcblxuICAgIF9lbmRBdXRvbWF0aWM6IChyZXNldCkgLT5cbiAgICAgICAgQF9yZXNldEJvdFRva2VuKHJlc2V0KVxuICAgICAgICBBcHAubG9nLmxvZ0luZm8oJ0JvdCBvcGVyYXRpb25zIGNvbXBsZXRlZCAoY2hlY2sgdGhlIGxvZyBmb3IgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICd3YXJuaW5ncyBvciBlcnJvcnMpJylcbiAgICAgICAgQF9kaXNhYmxlU3RhcnRCb3QoJ0JvdCBvcGVyYXRpb25zIGNvbXBsZXRlZCwgcmVzZXQgYW5kIHByZXZpZXcgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3RoZSBmaWx0ZXInKVxuICAgICAgICBAX3JlRW5hYmxlQ29udHJvbHMoKVxuIiwiIyBXaWtpIE1vbmtleSAtIE1lZGlhV2lraSBib3QgYW5kIGVkaXRvci1hc3Npc3RhbnQgdXNlciBzY3JpcHRcbiMgQ29weXJpZ2h0IChDKSAyMDExIERhcmlvIEdpb3Zhbm5ldHRpIDxkZXZAZGFyaW9naW92YW5uZXR0aS5uZXQ+XG4jXG4jIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFdpa2kgTW9ua2V5LlxuI1xuIyBXaWtpIE1vbmtleSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4jIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4jIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4jIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4jXG4jIFdpa2kgTW9ua2V5IGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4jIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4jIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiMgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbiNcbiMgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiMgYWxvbmcgd2l0aCBXaWtpIE1vbmtleS4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cblxue2pzc2N9ID0gcmVxdWlyZSgnLi4vbW9kdWxlcy9saWJzJylcbldNID0gcmVxdWlyZSgnLi4vbW9kdWxlcycpXG5cblxuY2xhc3MgbW9kdWxlLmV4cG9ydHNcbiAgICBjb25zdHJ1Y3RvcjogKEBXTSwgQHBhZ2VfdHlwZSwgcGx1Z2lucykgLT5cbiAgICAgICAge2NsYXNzZXN9ID0ganNzYyhcbiAgICAgICAgICAgIGNvbW1hbmRzOlxuICAgICAgICAgICAgICAgIGRpc3BsYXk6ICdmbGV4J1xuICAgICAgICAgICAgICAgIGFsaWduSXRlbXM6ICdjZW50ZXInXG4gICAgICAgICAgICAgICAganVzdGlmeUNvbnRlbnQ6ICdzcGFjZS1iZXR3ZWVuJ1xuXG4gICAgICAgICAgICAgICAgJyYgPiBzZWxlY3QnOlxuICAgICAgICAgICAgICAgICAgICBmbGV4OiAnYXV0bydcbiAgICAgICAgICAgICAgICAgICAgbWFyZ2luUmlnaHQ6ICcxZW0nXG5cbiAgICAgICAgICAgICAgICBcIiYgPiBpbnB1dFt0eXBlPSdidXR0b24nXVwiOlxuICAgICAgICAgICAgICAgICAgICBtYXJnaW5SaWdodDogJzFlbSdcblxuICAgICAgICAgICAgICAgIFwiJiBpbnB1dFt0eXBlPSdjaGVja2JveCddXCI6XG4gICAgICAgICAgICAgICAgICAgIG1hcmdpblJpZ2h0OiAnMC40ZW0nXG4gICAgICAgIClcblxuICAgICAgICBmaWx0ZXJzID0gW11cbiAgICAgICAgc2VsZWN0RmlsdGVyID0gJCgnPHNlbGVjdC8+JykuY2hhbmdlKEB1cGRhdGVGaWx0ZXJVSShmaWx0ZXJzKSlcblxuICAgICAgICBmb3IgUGx1Z2luIGluIHBsdWdpbnNcbiAgICAgICAgICAgIHBsdWdpbiA9IG5ldyBQbHVnaW4oQFdNKVxuICAgICAgICAgICAgcGx1Z2luSW5zdCA9IHBsdWdpbi5jb25mLmZpbHRlcl9sYWJlbFxuXG4gICAgICAgICAgICAjIFRoaXMgYWxsb3dzIHRvIGRpc2FibGUgYW4gZW50cnkgYnkgZ2l2aW5nIGl0IGFueSBzZWNvbmRcbiAgICAgICAgICAgICMgcGFyYW1ldGVyIHRoYXQgZXZhbHVhdGVzIHRvIGZhbHNlXG4gICAgICAgICAgICBpZiBub3QgcGx1Z2luSW5zdFxuICAgICAgICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgICAgIGZpbHRlcnMucHVzaChwbHVnaW4pXG4gICAgICAgICAgICBvcHRpb24gPSAkKCc8b3B0aW9uLz4nKS50ZXh0KHBsdWdpbkluc3QpXG5cbiAgICAgICAgICAgIGlmIHBsdWdpbi5jb25zdHJ1Y3Rvci5uYW1lIGlzIFdNLmNvbmZbXCJkZWZhdWx0XyN7QHBhZ2VfdHlwZX1fcGx1Z2luXCJdXG4gICAgICAgICAgICAgICAgb3B0aW9uWzBdLnNlbGVjdGVkID0gdHJ1ZVxuXG4gICAgICAgICAgICBvcHRpb24uYXBwZW5kVG8oc2VsZWN0RmlsdGVyKVxuXG4gICAgICAgIGlmIGZpbHRlcnMubGVuZ3RoXG4gICAgICAgICAgICBjb21tYW5kc0ZpbHRlckRpdiA9ICQoJzxkaXYvPicpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2lkJywgJ1dpa2lNb25rZXlGaWx0ZXJzLUNvbW1hbmRzJylcbiAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoY2xhc3Nlcy5jb21tYW5kcylcblxuICAgICAgICAgICAgY29tbWFuZHNGaWx0ZXJEaXYuYXBwZW5kKHNlbGVjdEZpbHRlcilcblxuICAgICAgICAgICAgJCgnPGlucHV0Lz4nKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd0eXBlJywgJ2J1dHRvbicpXG4gICAgICAgICAgICAgICAgLnZhbCgnQXBwbHkgZmlsdGVyJylcbiAgICAgICAgICAgICAgICAuY2xpY2soQGV4ZWN1dGVQbHVnaW4oZmlsdGVycykpXG4gICAgICAgICAgICAgICAgLmFwcGVuZFRvKGNvbW1hbmRzRmlsdGVyRGl2KVxuXG4gICAgICAgICAgICAkKCc8aW5wdXQvPicpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3R5cGUnLCAnY2hlY2tib3gnKVxuICAgICAgICAgICAgICAgIC5jaGFuZ2UoQHRvZ2dsZUxvZylcbiAgICAgICAgICAgICAgICAuYXBwZW5kVG8oY29tbWFuZHNGaWx0ZXJEaXYpXG5cbiAgICAgICAgICAgICQoJzxzcGFuLz4nKVxuICAgICAgICAgICAgICAgIC50ZXh0KCdTaG93IExvZycpXG4gICAgICAgICAgICAgICAgLmFwcGVuZFRvKGNvbW1hbmRzRmlsdGVyRGl2KVxuXG4gICAgICAgICAgICBkaXZGaWx0ZXIgPSAkKCc8ZGl2Lz4nKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdpZCcsIFwiV2lraU1vbmtleUZpbHRlcnMtT3B0aW9uc1wiKVxuXG4gICAgICAgICAgICAjIFRoaXMgYWxsb3dzIHVwZGF0ZUZpbHRlclVJIHJlcGxhY2UgaXQgdGhlIGZpcnN0IHRpbWVcbiAgICAgICAgICAgICQoJzxkaXYvPicpLmFwcGVuZFRvKGRpdkZpbHRlcilcbiAgICAgICAgICAgIEBkb1VwZGF0ZUZpbHRlclVJKGRpdkZpbHRlciwgZmlsdGVycywgc2VsZWN0RmlsdGVyWzBdLnNlbGVjdGVkSW5kZXgpXG5cbiAgICAgICAgICAgIGRpdiA9ICQoJzxkaXYvPicpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2lkJywgJ1dpa2lNb25rZXlGaWx0ZXJzJylcbiAgICAgICAgICAgICAgICAuYXBwZW5kKGNvbW1hbmRzRmlsdGVyRGl2KVxuICAgICAgICAgICAgICAgIC5hcHBlbmQoZGl2RmlsdGVyKVxuICAgICAgICAgICAgcmV0dXJuIGRpdlswXVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcblxuICAgIHVwZGF0ZUZpbHRlclVJOiAoZmlsdGVycykgPT5cbiAgICAgICAgcmV0dXJuIChldmVudCkgPT5cbiAgICAgICAgICAgIFVJID0gJCgnI1dpa2lNb25rZXlGaWx0ZXJzLU9wdGlvbnMnKVxuICAgICAgICAgICAgc2VsZWN0ID0gJCgnI1dpa2lNb25rZXlGaWx0ZXJzLUNvbW1hbmRzJylcbiAgICAgICAgICAgICAgICAuZmluZCgnc2VsZWN0JylcbiAgICAgICAgICAgICAgICAuZmlyc3QoKVxuICAgICAgICAgICAgaWQgPSBzZWxlY3RbMF0uc2VsZWN0ZWRJbmRleFxuXG4gICAgICAgICAgICBAZG9VcGRhdGVGaWx0ZXJVSShVSSwgZmlsdGVycywgaWQpXG5cbiAgICBkb1VwZGF0ZUZpbHRlclVJOiAoVUksIGZpbHRlcnMsIGlkKSAtPlxuICAgICAgICBtYWtlVUkgPSBmaWx0ZXJzW2lkXS5tYWtlVUlcblxuICAgICAgICBpZiBtYWtlVUkgaW5zdGFuY2VvZiBGdW5jdGlvblxuICAgICAgICAgICAgVUkuY2hpbGRyZW4oKS5maXJzdCgpLnJlcGxhY2VXaXRoKG1ha2VVSSgpKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICAjIERvbid0IHJlbW92ZSwgb3RoZXJ3aXNlIGlmIGFub3RoZXIgcGx1Z2luIHdpdGggaW50ZXJmYWNlIGlzXG4gICAgICAgICAgICAjIHNlbGVjdGVkLCByZXBsYWNlV2l0aCB3b24ndCB3b3JrXG4gICAgICAgICAgICBVSS5jaGlsZHJlbigpLmZpcnN0KCkucmVwbGFjZVdpdGgoJCgnPGRpdi8+JykpXG5cbiAgICBleGVjdXRlUGx1Z2luOiAoZmlsdGVycykgPT5cbiAgICAgICAgcmV0dXJuIChldmVudCkgPT5cbiAgICAgICAgICAgIHNlbGVjdCA9ICQoJyNXaWtpTW9ua2V5RmlsdGVycy1Db21tYW5kcycpXG4gICAgICAgICAgICAgICAgLmZpbmQoJ3NlbGVjdCcpXG4gICAgICAgICAgICAgICAgLmZpcnN0KClcbiAgICAgICAgICAgIGlkID0gc2VsZWN0WzBdLnNlbGVjdGVkSW5kZXhcblxuICAgICAgICAgICAgZmlsdGVyc1tpZF1bXCJtYWluXyN7QHBhZ2VfdHlwZX1cIl0oKVxuXG4gICAgICAgICAgICBldmVudC50YXJnZXQuZGlzYWJsZWQgPSB0cnVlXG5cbiAgICB0b2dnbGVMb2c6IChldmVudCkgLT5cbiAgICAgICAgaWYgQGNoZWNrZWRcbiAgICAgICAgICAgICQoJyNXaWtpTW9ua2V5TG9nJykuc2hvdygpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgICQoJyNXaWtpTW9ua2V5TG9nJykuaGlkZSgpXG4iLCIjIFdpa2kgTW9ua2V5IC0gTWVkaWFXaWtpIGJvdCBhbmQgZWRpdG9yLWFzc2lzdGFudCB1c2VyIHNjcmlwdFxuIyBDb3B5cmlnaHQgKEMpIDIwMTEgRGFyaW8gR2lvdmFubmV0dGkgPGRldkBkYXJpb2dpb3Zhbm5ldHRpLm5ldD5cbiNcbiMgVGhpcyBmaWxlIGlzIHBhcnQgb2YgV2lraSBNb25rZXkuXG4jXG4jIFdpa2kgTW9ua2V5IGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiMgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiMgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiMgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbiNcbiMgV2lraSBNb25rZXkgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiMgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiMgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuIyBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuI1xuIyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuIyBhbG9uZyB3aXRoIFdpa2kgTW9ua2V5LiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuXG57anNzY30gPSByZXF1aXJlKCcuLi9tb2R1bGVzL2xpYnMnKVxuV00gPSByZXF1aXJlKCcuLi9tb2R1bGVzJylcblN0ciA9IHJlcXVpcmUoJ0BreW5pa29zL21pc2MvZGlzdC9TdHInKVxuXG5cbmNsYXNzIG1vZHVsZS5leHBvcnRzXG4gICAgY29uc3RydWN0b3I6IC0+XG4gICAgICAgIEBfY3VycmVudEluZm9EaXNwbGF5U3RhdGUgPSB0cnVlXG5cbiAgICAgICAgIyBUaGUgLndhcm5pbmcgYW5kIC5lcnJvciBjbGFzc2VzIGFyZSBhbHJlYWR5IHVzZWQgYnlcbiAgICAgICAgIyBNZWRpYVdpa2ksIHdpdGhvdXQgYXNzb2NpYXRpbmcgdGhlbSB3aXRoIGFuIGlkIGFuZCBhIHRhZ1xuICAgICAgICB7Y2xhc3Nlc30gPSBqc3NjKFxuICAgICAgICAgICAgbG9nOlxuICAgICAgICAgICAgICAgIGhlaWdodDogJzEwZW0nXG4gICAgICAgICAgICAgICAgYm9yZGVyOiAnMnB4IHNvbGlkICMwN2InXG4gICAgICAgICAgICAgICAgcGFkZGluZzogJzAuNWVtJ1xuICAgICAgICAgICAgICAgIG92ZXJmbG93OiAnYXV0bydcbiAgICAgICAgICAgICAgICByZXNpemU6ICd2ZXJ0aWNhbCdcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICcjMTExJ1xuXG4gICAgICAgICAgICAgICAgJyYgcC50aW1lc3RhbXAsICYgcC5tZXNzYWdlJzpcbiAgICAgICAgICAgICAgICAgICAgYm9yZGVyOiAnbm9uZSdcbiAgICAgICAgICAgICAgICAgICAgcGFkZGluZzogMFxuICAgICAgICAgICAgICAgICAgICBmb250RmFtaWx5OiAnbW9ub3NwYWNlJ1xuICAgICAgICAgICAgICAgICAgICBjb2xvcjogJyNlZWUnXG5cbiAgICAgICAgICAgICAgICAnJiBwLnRpbWVzdGFtcCc6XG4gICAgICAgICAgICAgICAgICAgIG1hcmdpbjogJzAgMWVtIDAgMCdcbiAgICAgICAgICAgICAgICAgICAgd2hpdGVTcGFjZTogJ25vd3JhcCdcblxuICAgICAgICAgICAgICAgICcmIHAubWVzc2FnZSc6XG4gICAgICAgICAgICAgICAgICAgIG1hcmdpbjogMFxuXG4gICAgICAgICAgICAgICAgJyYgZGl2Lm1kZWJ1ZywgJiBkaXYubWluZm8sICYgZGl2Lm13YXJuaW5nLCAmIGRpdi5tZXJyb3InOlxuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiAnZmxleCdcblxuICAgICAgICAgICAgICAgICcmIGRpdi5taGlkZGVuJzpcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogJ25vbmUnXG5cbiAgICAgICAgICAgICAgICAnJiBkaXYubWpzb24nOlxuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiAnbm9uZSdcblxuICAgICAgICAgICAgICAgICcmIGRpdi5tZGVidWcgcC5tZXNzYWdlJzpcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6ICdjeWFuJ1xuXG4gICAgICAgICAgICAgICAgJyYgZGl2Lm13YXJuaW5nIHAubWVzc2FnZSc6XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiAnZ29sZCdcblxuICAgICAgICAgICAgICAgICcmIGRpdi5tZXJyb3IgcC5tZXNzYWdlJzpcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6ICdyZWQnXG5cbiAgICAgICAgICAgICAgICAnJiBhJzpcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6ICdpbmhlcml0J1xuICAgICAgICAgICAgICAgICAgICB0ZXh0RGVjb3JhdGlvbjogJ3VuZGVybGluZSdcbiAgICAgICAgKVxuXG4gICAgICAgIEBhcmVhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICAgICAgQGFyZWEuaWQgPSAnV2lraU1vbmtleUxvZydcblxuICAgICAgICBwYXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwJylcbiAgICAgICAgcGFyLmFwcGVuZENoaWxkKEBtYWtlRmlsdGVyTGluaygpKVxuICAgICAgICBwYXIuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJyAnKSlcbiAgICAgICAgcGFyLmFwcGVuZENoaWxkKEBtYWtlU2F2ZUxpbmsoKSlcbiAgICAgICAgQGFyZWEuYXBwZW5kQ2hpbGQocGFyKVxuXG4gICAgICAgIEBsb2dhcmVhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICAgICAgQGxvZ2FyZWEuY2xhc3NOYW1lID0gY2xhc3Nlcy5sb2dcbiAgICAgICAgQGFyZWEuYXBwZW5kQ2hpbGQoQGxvZ2FyZWEpXG5cbiAgICBtYWtlRmlsdGVyTGluazogLT5cbiAgICAgICAgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKVxuICAgICAgICBsaW5rLmhyZWYgPSAnI1dpa2lNb25rZXknXG4gICAgICAgIGxpbmsuaW5uZXJIVE1MID0gQGNvbXB1dGVGaWx0ZXJMaW5rQW5jaG9yKClcblxuICAgICAgICBsaW5rLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoZXZlbnQpID0+XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgICAgICAjIENoYW5nZSBfY3VycmVudEluZm9EaXNwbGF5U3RhdGUgKmJlZm9yZSogdGhlIGxvb3AsIHRvIHByZXZlbnRcbiAgICAgICAgICAgICMgcmFjZSBidWdzXG4gICAgICAgICAgICBAX2N1cnJlbnRJbmZvRGlzcGxheVN0YXRlID0gbm90IEBfY3VycmVudEluZm9EaXNwbGF5U3RhdGVcbiAgICAgICAgICAgIGxpbmsuaW5uZXJIVE1MID0gQGNvbXB1dGVGaWx0ZXJMaW5rQW5jaG9yKClcblxuICAgICAgICAgICAgbXNncyA9IEBsb2dhcmVhLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ21pbmZvJylcblxuICAgICAgICAgICAgZm9yIG1zZyBpbiBtc2dzXG4gICAgICAgICAgICAgICAgbXNnLnN0eWxlLmRpc3BsYXkgPSBAY29tcHV0ZUluZm9EaXNwbGF5U3R5bGUoKVxuXG4gICAgICAgICAgICBAc2Nyb2xsVG9Cb3R0b20oKVxuICAgICAgICAsIGZhbHNlKVxuXG4gICAgICAgIHJldHVybiBsaW5rXG5cbiAgICBtYWtlU2F2ZUxpbms6IC0+XG4gICAgICAgIGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJylcbiAgICAgICAgbGluay5ocmVmID0gJyMnXG4gICAgICAgIGxpbmsuZG93bmxvYWQgPSAnV2lraU1vbmtleS5sb2cnXG4gICAgICAgIGxpbmsuaW5uZXJIVE1MID0gJ1tzYXZlIGxvZ10nXG4gICAgICAgIGxpbmsuaWQgPSAnV2lraU1vbmtleUxvZy1TYXZlJ1xuXG4gICAgICAgIGxpbmsuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsID0+XG4gICAgICAgICAgICBsaW5rLmhyZWYgPSAnZGF0YTp0ZXh0L3BsYWluO2NoYXJzZXQ9dXRmLTgsJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoQGNvbXBvc2VTYXZlTG9nVGV4dCgpKVxuICAgICAgICAgICAgbGluay5kb3dubG9hZCA9IEBjb21wb3NlU2F2ZUxvZ0ZpbGVuYW1lKClcbiAgICAgICAgLCBmYWxzZSlcblxuICAgICAgICByZXR1cm4gbGlua1xuXG4gICAgY2xhc3Nlc1RvTGV2ZWxzID1cbiAgICAgICAgJ21oaWRkZW4nOiAnSEROJ1xuICAgICAgICAnbWpzb24nOiAnSlNOJ1xuICAgICAgICAnbWRlYnVnJzogJ0RCRydcbiAgICAgICAgJ21pbmZvJzogJ0lORidcbiAgICAgICAgJ213YXJuaW5nJzogJ1dSTidcbiAgICAgICAgJ21lcnJvcic6ICdFUlInXG5cbiAgICBjb21wb3NlU2F2ZUxvZ1RleHQ6IC0+XG4gICAgICAgIGRpdnMgPSBAbG9nYXJlYS5nZXRFbGVtZW50c0J5VGFnTmFtZSgnZGl2JylcbiAgICAgICAgdGV4dCA9ICcnXG5cbiAgICAgICAgZm9yIGRpdiBpbiBkaXZzXG4gICAgICAgICAgICBwcyA9IGRpdi5nZXRFbGVtZW50c0J5VGFnTmFtZSgncCcpXG4gICAgICAgICAgICB0c3RhbXAgPSBwc1swXS5pbm5lckhUTUxcbiAgICAgICAgICAgIGxldmVsID0gY2xhc3Nlc1RvTGV2ZWxzW2Rpdi5jbGFzc05hbWVdXG4gICAgICAgICAgICBtZXNzYWdlID0gcHNbMV0uaW5uZXJIVE1MXG5cbiAgICAgICAgICAgIHRleHQgKz0gdHN0YW1wICsgJ1xcdCcgKyBsZXZlbCArICdcXHQnICsgbWVzc2FnZSArICdcXG4nXG5cbiAgICAgICAgcmV0dXJuIHRleHRcblxuICAgIGNvbXBvc2VTYXZlTG9nRmlsZW5hbWU6IC0+XG4gICAgICAgIGRhdGUgPSBuZXcgRGF0ZSgpXG4gICAgICAgIHJldHVybiAnV2lraU1vbmtleS0nICsgZGF0ZS5nZXRGdWxsWWVhcigpICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFN0ci5wYWRMZWZ0KFN0cmluZyhkYXRlLmdldE1vbnRoKCkgKyAxKSwgJzAnLCAyKSArXG4gICAgICAgICAgICAgICAgICAgICAgICBTdHIucGFkTGVmdChTdHJpbmcoZGF0ZS5nZXREYXRlKCkpLCAnMCcsIDIpICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFN0ci5wYWRMZWZ0KFN0cmluZyhkYXRlLmdldEhvdXJzKCkpLCAnMCcsIDIpICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFN0ci5wYWRMZWZ0KFN0cmluZyhkYXRlLmdldE1pbnV0ZXMoKSksICcwJywgMikgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJy5sb2cnXG5cbiAgICBjb21wdXRlSW5mb0Rpc3BsYXlTdHlsZTogLT5cbiAgICAgICAgcmV0dXJuIGlmIEBfY3VycmVudEluZm9EaXNwbGF5U3RhdGUgdGhlbiAnZmxleCcgZWxzZSAnbm9uZSdcblxuICAgIGNvbXB1dGVGaWx0ZXJMaW5rQW5jaG9yOiAtPlxuICAgICAgICByZXR1cm4gaWYgQF9jdXJyZW50SW5mb0Rpc3BsYXlTdGF0ZSB0aGVuICdbaGlkZSBpbmZvIG1lc3NhZ2VzXScgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnW3Nob3cgaW5mbyBtZXNzYWdlc10nXG5cbiAgICBzY3JvbGxUb0JvdHRvbTogLT5cbiAgICAgICAgQGxvZ2FyZWEuc2Nyb2xsVG9wID0gQGxvZ2FyZWEuc2Nyb2xsSGVpZ2h0IC0gQGxvZ2FyZWEuY2xpZW50SGVpZ2h0XG5cbiAgICBhcHBlbmRNZXNzYWdlOiAodGV4dCwgdHlwZSkgLT5cbiAgICAgICAgdHN0YW1wID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncCcpXG4gICAgICAgIHRzdGFtcC5jbGFzc05hbWUgPSAndGltZXN0YW1wJ1xuICAgICAgICBub3cgPSBuZXcgRGF0ZSgpXG4gICAgICAgIHRzdGFtcC5pbm5lckhUTUwgPSBub3cudG9Mb2NhbGVUaW1lU3RyaW5nKClcblxuICAgICAgICBtc2cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwJylcbiAgICAgICAgbXNnLmNsYXNzTmFtZSA9ICdtZXNzYWdlJ1xuICAgICAgICAjIERvIG5vdCBhbGxvdyB0aGUgZW1wdHkgc3RyaW5nLCBvdGhlcndpc2UgdGhlIHJlc3VsdGluZyBodG1sIGVsZW1lbnRcbiAgICAgICAgIyBtYXkgbm90IGJlIHJlbmRlcmVkIGJ5IHRoZSBicm93c2VyXG4gICAgICAgIG1zZy5pbm5lckhUTUwgPSBpZiB0ZXh0IHRoZW4gdGV4dCBlbHNlIFwiIFwiXG5cbiAgICAgICAgbGluZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgICAgIGxpbmUuYXBwZW5kQ2hpbGQodHN0YW1wKVxuICAgICAgICBsaW5lLmFwcGVuZENoaWxkKG1zZylcbiAgICAgICAgbGluZS5jbGFzc05hbWUgPSB0eXBlXG5cbiAgICAgICAgaWYgdHlwZSA9PSAnbWluZm8nXG4gICAgICAgICAgICBsaW5lLnN0eWxlLmRpc3BsYXkgPSBAY29tcHV0ZUluZm9EaXNwbGF5U3R5bGUoKVxuXG4gICAgICAgICMgVGhpcyB0ZXN0IG11c3QgYmUgZG9uZSAqYmVmb3JlKiBhcHBlbmRpbmcgdGhlIG5ldyBsaW5lXG4gICAgICAgIHRlc3QgPSBAbG9nYXJlYS5zY3JvbGxUb3AgKyBAbG9nYXJlYS5jbGllbnRIZWlnaHQgPT0gXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQGxvZ2FyZWEuc2Nyb2xsSGVpZ2h0XG5cbiAgICAgICAgQGxvZ2FyZWEuYXBwZW5kQ2hpbGQobGluZSlcblxuICAgICAgICBpZiB0ZXN0XG4gICAgICAgICAgICBAc2Nyb2xsVG9Cb3R0b20oKVxuXG4gICAgbG9nSGlkZGVuOiAodGV4dCkgLT5cbiAgICAgICAgQGFwcGVuZE1lc3NhZ2UodGV4dCwgJ21oaWRkZW4nKVxuXG4gICAgbG9nSnNvbjogKGNvbXBvbmVudCwgZGF0YSkgLT5cbiAgICAgICAgdGV4dCA9IEpTT04uc3RyaW5naWZ5KHtcImNvbXBvbmVudFwiOiBjb21wb25lbnQsIFwiZGF0YVwiOiBkYXRhfSlcbiAgICAgICAgQGFwcGVuZE1lc3NhZ2UodGV4dCwgJ21qc29uJylcblxuICAgIGxvZ0RlYnVnOiAodGV4dCkgLT5cbiAgICAgICAgQGFwcGVuZE1lc3NhZ2UodGV4dCwgJ21kZWJ1ZycpXG5cbiAgICBsb2dJbmZvOiAodGV4dCkgLT5cbiAgICAgICAgQGFwcGVuZE1lc3NhZ2UodGV4dCwgJ21pbmZvJylcblxuICAgIGxvZ1dhcm5pbmc6ICh0ZXh0KSAtPlxuICAgICAgICBAYXBwZW5kTWVzc2FnZSh0ZXh0LCAnbXdhcm5pbmcnKVxuXG4gICAgbG9nRXJyb3I6ICh0ZXh0KSAtPlxuICAgICAgICBAYXBwZW5kTWVzc2FnZSh0ZXh0LCAnbWVycm9yJylcblxuICAgIGxpbmtUb1BhZ2U6ICh1cmwsIGFuY2hvcikgLT5cbiAgICAgICAgIyBNdXN0IHJldHVybiBhIHN0cmluZywgbm90IGEgRE9NIGVsZW1lbnRcbiAgICAgICAgcmV0dXJuIFwiPGEgaHJlZj1cXFwiXCIgKyB1cmwgKyBcIlxcXCI+XCIgKyBhbmNob3IgKyBcIjwvYT5cIlxuXG4gICAgbGlua1RvV2lraVBhZ2U6ICh0aXRsZSwgYW5jaG9yKSAtPlxuICAgICAgICAjIE11c3QgcmV0dXJuIGEgc3RyaW5nLCBub3QgYSBET00gZWxlbWVudFxuICAgICAgICAjIFVzZSBhbiBhYnNvbHV0ZSAoZnVsbCkgVVJMIHNvIGl0IHdpbGwgYmUgdXNhYmxlIGluIHRoZSBkb3dubG9hZGFibGVcbiAgICAgICAgIyAgIHZlcnNpb24gb2YgdGhlIGxvZ1xuICAgICAgICAjIERvICpub3QqIHVzZSBlbmNvZGVVUklDb21wb25lbnQodGl0bGUpIGJlY2F1c2UgdGhlIHBhc3NlZCB0aXRsZSBtYXlcbiAgICAgICAgIyAgIGhhdmUgYSBmcmFnbWVudCBvciBhIHF1ZXJ5IHN0cmluZyB0aGF0IHdvdWxkIHRoZW4gYmUgZW5jb2RlZFxuICAgICAgICAjICAgTWVkaWFXaWtpIHNob3VsZCBiZSBhYmxlIHRvIGNvcnJlY3RseSByZXNvbHZlIHRoZSB0aXRsZSBhbnl3YXlcbiAgICAgICAgd2lraVVybHMgPSBXTS5NVy5nZXRXaWtpVXJscygpXG4gICAgICAgIHJldHVybiBcIjxhIGhyZWY9XFxcIlwiICsgd2lraVVybHMuc2hvcnQgKyB0aXRsZSArIFwiXFxcIj5cIiArIGFuY2hvciArIFwiPC9hPlwiXG4iLCIjIFdpa2kgTW9ua2V5IC0gTWVkaWFXaWtpIGJvdCBhbmQgZWRpdG9yLWFzc2lzdGFudCB1c2VyIHNjcmlwdFxuIyBDb3B5cmlnaHQgKEMpIDIwMTEgRGFyaW8gR2lvdmFubmV0dGkgPGRldkBkYXJpb2dpb3Zhbm5ldHRpLm5ldD5cbiNcbiMgVGhpcyBmaWxlIGlzIHBhcnQgb2YgV2lraSBNb25rZXkuXG4jXG4jIFdpa2kgTW9ua2V5IGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiMgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiMgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiMgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbiNcbiMgV2lraSBNb25rZXkgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiMgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiMgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuIyBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuI1xuIyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuIyBhbG9uZyB3aXRoIFdpa2kgTW9ua2V5LiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuXG57anNzY30gPSByZXF1aXJlKCcuLi9tb2R1bGVzL2xpYnMnKVxuQXBwID0gcmVxdWlyZSgnLi9pbmRleCcpXG5cblxuY2xhc3MgbW9kdWxlLmV4cG9ydHNcbiAgICBjb25zdHJ1Y3RvcjogKEBXTSwgQHBhZ2VfdHlwZSwgcGx1Z2lucykgLT5cbiAgICAgICAge2NsYXNzZXN9ID0ganNzYyhcbiAgICAgICAgICAgIG1lbnU6XG4gICAgICAgICAgICAgICAgJyYgaW5wdXQubWFyZ2luJzpcbiAgICAgICAgICAgICAgICAgICAgbWFyZ2luOiBcIjAgMC4zM2VtIDAuMzNlbSAwXCJcbiAgICAgICAgKVxuXG4gICAgICAgIG1haW5EaXYgPSAkKCc8ZGl2Lz4nKVxuICAgICAgICAgICAgLmF0dHIoJ2lkJywgJ1dpa2lNb25rZXlNZW51JylcbiAgICAgICAgICAgIC5hZGRDbGFzcyhjbGFzc2VzLm1lbnUpXG4gICAgICAgIGdyb3VwQWN0aW9ucyA9IHt9XG5cbiAgICAgICAgZm9yIFBsdWdpbiBpbiBwbHVnaW5zXG4gICAgICAgICAgICBwbHVnaW4gPSBuZXcgUGx1Z2luKEBXTSlcbiAgICAgICAgICAgIHBsdWdpbkluc3QgPSBwbHVnaW4uY29uZltcIiN7QHBhZ2VfdHlwZX1fbWVudVwiXVxuXG4gICAgICAgICAgICAjIFRoaXMgYWxsb3dzIHRvIGRpc2FibGUgYW4gZW50cnkgYnkgZ2l2aW5nIGl0IGEgbWVudV9lbnRyeVxuICAgICAgICAgICAgIyBwYXJhbWV0ZXIgdGhhdCBldmFsdWF0ZXMgdG8gZmFsc2VcbiAgICAgICAgICAgIGlmIG5vdCBwbHVnaW5JbnN0IG9yIG5vdCBwbHVnaW5JbnN0Lmxlbmd0aFxuICAgICAgICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgICAgIGlmIHBsdWdpbi5tYWtlVUlcbiAgICAgICAgICAgICAgICBncm91cEFjdGlvbiA9IFtAd2FybklucHV0TmVlZGVkLCBwbHVnaW5dXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgZ3JvdXBBY3Rpb24gPSBbQGV4ZWN1dGVFbnRyeUFjdGlvbiwgcGx1Z2luXVxuXG4gICAgICAgICAgICBwbHVnaW5JbnN0LnVuc2hpZnQoXCJXaWtpTW9ua2V5TWVudVJvb3RcIilcbiAgICAgICAgICAgIGN1cnJJZCA9IGZhbHNlXG5cbiAgICAgICAgICAgIGZvciBtIGluIFswLi4ucGx1Z2luSW5zdC5sZW5ndGggLSAxXVxuICAgICAgICAgICAgICAgIHBhcmVudElkID0gY3VycklkXG4gICAgICAgICAgICAgICAgY3VycklkID0gcGx1Z2luSW5zdC5zbGljZSgwLCBtICsgMSkuam9pbihcIi1cIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvIC9nLCBcIl9cIilcblxuICAgICAgICAgICAgICAgICMgSSBjYW4ndCBzaW1wbHkgZG8gJChcIiNcIiArIGN1cnJJZCkgYmVjYXVzZSBtYWluRGl2XG4gICAgICAgICAgICAgICAgIyBoYXNuJ3QgYmVlbiBhZGRlZCB0byB0aGUgRE9NIHRyZWUgeWV0XG4gICAgICAgICAgICAgICAgbWVudVNlbCA9IG1haW5EaXYuY2hpbGRyZW4oXCJkaXZbaWQ9JyN7Y3VycklkfSddXCIpXG5cbiAgICAgICAgICAgICAgICBpZiBub3QgbWVudVNlbC5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgY3Vyck1lbnUgPSAkKFwiPGRpdi8+XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcImlkXCIsIGN1cnJJZClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5oaWRlKClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBlbmRUbyhtYWluRGl2KVxuXG4gICAgICAgICAgICAgICAgICAgIGdyb3VwQWN0aW9uc1tjdXJySWRdID0gW11cblxuICAgICAgICAgICAgICAgICAgICBpZiBtID4gMFxuICAgICAgICAgICAgICAgICAgICAgICAgIyBJIGNhbid0IHNpbXBseSBkbyAkKFwiI1wiICsgY3VycklkKSBiZWNhdXNlIG1haW5EaXZcbiAgICAgICAgICAgICAgICAgICAgICAgICMgaGFzbid0IGJlZW4gYWRkZWQgdG8gdGhlIERPTSB0cmVlIHlldFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50TWVudSA9IG1haW5EaXYuY2hpbGRyZW4oXCJkaXZbaWQ9JyN7cGFyZW50SWR9J11cIilcblxuICAgICAgICAgICAgICAgICAgICAgICAgJCgnPGlucHV0Lz4nKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0eXBlJywgJ2J1dHRvbicpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnZhbCgnPCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKCdtYXJnaW4nKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jbGljayhtYWtlQ2hhbmdlTWVudShjdXJyTWVudSwgcGFyZW50TWVudSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZFRvKGN1cnJNZW51KVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAkKCc8aW5wdXQvPicpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3R5cGUnLCAnYnV0dG9uJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudmFsKHBsdWdpbkluc3RbbV0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNsaWNrKG1ha2VHcm91cEFjdGlvbihncm91cEFjdGlvbnNbY3VycklkXSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZFRvKHBhcmVudE1lbnUpXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICQoJzxpbnB1dC8+JylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigndHlwZScsICdidXR0b24nKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC52YWwoJz4nKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcygnbWFyZ2luJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY2xpY2sobWFrZUNoYW5nZU1lbnUocGFyZW50TWVudSwgY3Vyck1lbnUpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBlbmRUbyhwYXJlbnRNZW51KVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgY3Vyck1lbnUgPSBtZW51U2VsLmZpcnN0KClcblxuICAgICAgICAgICAgICAgIGdyb3VwQWN0aW9uc1tjdXJySWRdLnB1c2goZ3JvdXBBY3Rpb24pXG5cbiAgICAgICAgICAgIGVudHJ5ID0gJChcIjxpbnB1dC8+XCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3R5cGUnLCAnYnV0dG9uJylcbiAgICAgICAgICAgICAgICAudmFsKHBsdWdpbkluc3RbcGx1Z2luSW5zdC5sZW5ndGggLSAxXSlcbiAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoJ21hcmdpbicpXG4gICAgICAgICAgICAgICAgLmFwcGVuZFRvKGN1cnJNZW51KVxuXG4gICAgICAgICAgICBpZiBwbHVnaW4ubWFrZVVJXG4gICAgICAgICAgICAgICAgZW50cnkuY2xpY2soQG1ha2VFbnRyeVVJKGN1cnJNZW51LCBwbHVnaW4pKVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGVudHJ5LmNsaWNrKEBtYWtlRW50cnlBY3Rpb24ocGx1Z2luKSlcblxuICAgICAgICBtZW51cyA9IG1haW5EaXYuY2hpbGRyZW4oKVxuXG4gICAgICAgIGlmIG1lbnVzLmxlbmd0aFxuICAgICAgICAgICAgZXhlY0FsbCA9ICQoJzxpbnB1dC8+JylcbiAgICAgICAgICAgICAgICAuYXR0cigndHlwZScsICdidXR0b24nKVxuICAgICAgICAgICAgICAgIC52YWwoXCIqXCIpXG4gICAgICAgICAgICAgICAgLmFkZENsYXNzKCdtYXJnaW4nKVxuICAgICAgICAgICAgICAgIC5jbGljayhtYWtlR3JvdXBBY3Rpb24oZ3JvdXBBY3Rpb25zW1wiV2lraU1vbmtleU1lbnVSb290XCJdKSlcblxuICAgICAgICAgICAgIyBJIGNhbid0IHNpbXBseSBkbyAkKFwiI1wiICsgY3VycklkKSBiZWNhdXNlIG1haW5EaXZcbiAgICAgICAgICAgICMgaGFzbid0IGJlZW4gYWRkZWQgdG8gdGhlIERPTSB0cmVlIHlldFxuICAgICAgICAgICAgbWFpbkRpdlxuICAgICAgICAgICAgICAgIC5jaGlsZHJlbihcImRpdltpZD0nV2lraU1vbmtleU1lbnVSb290J11cIilcbiAgICAgICAgICAgICAgICAuZmlyc3QoKVxuICAgICAgICAgICAgICAgIC5wcmVwZW5kKGV4ZWNBbGwpXG5cbiAgICAgICAgICAgIG1lbnVzLmZpcnN0KCkuc2hvdygpXG4gICAgICAgICAgICByZXR1cm4gbWFpbkRpdlswXVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcblxuICAgIG1ha2VDaGFuZ2VNZW51ID0gKGN1cnJlbnRNZW51LCBjaGFuZ2VNZW51KSAtPlxuICAgICAgICByZXR1cm4gKGV2ZW50KSAtPlxuICAgICAgICAgICAgY3VycmVudE1lbnUuaGlkZSgpXG4gICAgICAgICAgICBjaGFuZ2VNZW51LnNob3coKVxuXG4gICAgbWFrZUVudHJ5VUk6IChjdXJyTWVudSwgcGx1Z2luKSAtPlxuICAgICAgICByZXR1cm4gKGV2ZW50KSA9PlxuICAgICAgICAgICAgY3Vyck1lbnUuaGlkZSgpXG4gICAgICAgICAgICBVSWRpdiA9ICQoJzxkaXYvPicpXG5cbiAgICAgICAgICAgICQoJzxpbnB1dC8+JylcbiAgICAgICAgICAgICAgICAuYXR0cigndHlwZScsICdidXR0b24nKVxuICAgICAgICAgICAgICAgIC52YWwoJzwnKVxuICAgICAgICAgICAgICAgIC5hZGRDbGFzcygnbWFyZ2luJylcbiAgICAgICAgICAgICAgICAuY2xpY2soIChldmVudCkgLT5cbiAgICAgICAgICAgICAgICAgICAgVUlkaXYucmVtb3ZlKClcbiAgICAgICAgICAgICAgICAgICAgY3Vyck1lbnUuc2hvdygpXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIC5hcHBlbmRUbyhVSWRpdilcblxuICAgICAgICAgICAgJCgnPGlucHV0Lz4nKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd0eXBlJywgJ2J1dHRvbicpXG4gICAgICAgICAgICAgICAgLnZhbCgnRXhlY3V0ZScpXG4gICAgICAgICAgICAgICAgLmNsaWNrKEBtYWtlRW50cnlBY3Rpb24ocGx1Z2luKSlcbiAgICAgICAgICAgICAgICAuYXBwZW5kVG8oVUlkaXYpXG5cbiAgICAgICAgICAgIFVJID0gcGx1Z2luLm1ha2VVSSgpXG4gICAgICAgICAgICBVSWRpdi5hcHBlbmQoVUkpLmluc2VydEFmdGVyKGN1cnJNZW51KVxuXG4gICAgbWFrZUVudHJ5QWN0aW9uOiAocGx1Z2luKSAtPlxuICAgICAgICByZXR1cm4gKGV2ZW50KSA9PlxuICAgICAgICAgICAgQGV4ZWN1dGVFbnRyeUFjdGlvbihwbHVnaW4sIG51bGwpXG5cbiAgICBleGVjdXRlRW50cnlBY3Rpb246IChwbHVnaW4sIGNhbGxOZXh0KSA9PlxuICAgICAgICBBcHAubG9nLmxvZ0hpZGRlbihcIlBsdWdpbjogXCIgKyBwbHVnaW4uY29uc3RydWN0b3IubmFtZSlcbiAgICAgICAgcGx1Z2luW1wibWFpbl8je0BwYWdlX3R5cGV9XCJdKGNhbGxOZXh0KVxuXG4gICAgd2FybklucHV0TmVlZGVkOiAocGx1Z2luLCBjYWxsTmV4dCkgPT5cbiAgICAgICAgQXBwLmxvZy5sb2dXYXJuaW5nKFwiUGx1Z2luIFwiICsgcGx1Z2luLmNvbnN0cnVjdG9yLm5hbWUgK1xuICAgICAgICAgICAgXCIgd2FzIG5vdCBleGVjdXRlZCBiZWNhdXNlIGl0IHJlcXVpcmVzIGlucHV0IGZyb20gaXRzIGludGVyZmFjZS5cIilcblxuICAgICAgICBpZiBjYWxsTmV4dFxuICAgICAgICAgICAgY2FsbE5leHQoKVxuXG4gICAgbWFrZUdyb3VwQWN0aW9uID0gKHN1Ykdyb3VwQWN0aW9ucykgLT5cbiAgICAgICAgcmV0dXJuIChldmVudCkgLT5cbiAgICAgICAgICAgIGV4ZWN1dGVHcm91cEFjdGlvbihzdWJHcm91cEFjdGlvbnMsIC0xKVxuXG4gICAgZXhlY3V0ZUdyb3VwQWN0aW9uID0gKHN1Ykdyb3VwQWN0aW9ucywgaWQpIC0+XG4gICAgICAgIGlkKytcbiAgICAgICAgaWYgc3ViR3JvdXBBY3Rpb25zW2lkXVxuICAgICAgICAgICAgZmlkID0gc3ViR3JvdXBBY3Rpb25zW2lkXVxuICAgICAgICAgICAgY2FsbENvbnRpbnVlID0gPT5cbiAgICAgICAgICAgICAgICBleGVjdXRlR3JvdXBBY3Rpb24oc3ViR3JvdXBBY3Rpb25zLCBpZClcbiAgICAgICAgICAgIGZpZFswXShmaWRbMV0sIGNhbGxDb250aW51ZSlcbiIsIiMgV2lraSBNb25rZXkgLSBNZWRpYVdpa2kgYm90IGFuZCBlZGl0b3ItYXNzaXN0YW50IHVzZXIgc2NyaXB0XG4jIENvcHlyaWdodCAoQykgMjAxMSBEYXJpbyBHaW92YW5uZXR0aSA8ZGV2QGRhcmlvZ2lvdmFubmV0dGkubmV0PlxuI1xuIyBUaGlzIGZpbGUgaXMgcGFydCBvZiBXaWtpIE1vbmtleS5cbiNcbiMgV2lraSBNb25rZXkgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuIyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuIyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuIyAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuI1xuIyBXaWtpIE1vbmtleSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuIyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuIyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4jIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4jXG4jIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4jIGFsb25nIHdpdGggV2lraSBNb25rZXkuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG5cbntqc3NjfSA9IHJlcXVpcmUoJy4uL21vZHVsZXMvbGlicycpXG5XTSA9IHJlcXVpcmUoJy4uL21vZHVsZXMnKVxuXG5cbmNsYXNzIG1vZHVsZS5leHBvcnRzXG4gICAgY29uc3RydWN0b3I6IC0+XG5cbiAgICBkaXNhYmxlRWRpdFN1bW1hcnlTdWJtaXRPbkVudGVyID0gLT5cbiAgICAgICAgJCgnI3dwU3VtbWFyeScpLmtleWRvd24oIChldmVudCkgLT5cbiAgICAgICAgICAgICMgJ2tleUNvZGUnIGlzIGRlcHJlY2F0ZWQsIGJ1dCBub3QgYWxsIGJyb3dzZXJzIHN1cHBvcnQgJ2tleScgeWV0XG4gICAgICAgICAgICBpZiBldmVudC5rZXkgPT0gJ0VudGVyJyBvciAodHlwZW9mIGV2ZW50LmtleSA9PSAndW5kZWZpbmVkJyBhbmRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQua2V5Q29kZSA9PSAxMylcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIClcblxuICAgIGhpZGVSb2xsYmFja0xpbmtzID0gLT5cbiAgICAgICAganNzYyhcbiAgICAgICAgICAgICdAZ2xvYmFsIHNwYW4ubXctcm9sbGJhY2stbGluayc6XG4gICAgICAgICAgICAgICAgZGlzcGxheTogJ25vbmUnXG4gICAgICAgIClcblxuICAgIHNjcm9sbFRvRmlyc3RIZWFkaW5nID0gLT5cbiAgICAgICAgd2luZG93LnNjcm9sbFRvKDAsICQoJyNmaXJzdEhlYWRpbmcnKS5vZmZzZXQoKS50b3ApXG5cbiAgICBhcHBseUVkaXRvck1vZHM6IC0+XG4gICAgICAgIGlmIFdNLmNvbmYuZGlzYWJsZV9lZGl0X3N1bW1hcnlfc3VibWl0X29uX2VudGVyXG4gICAgICAgICAgICBkaXNhYmxlRWRpdFN1bW1hcnlTdWJtaXRPbkVudGVyKClcbiAgICAgICAgaWYgV00uY29uZi5zY3JvbGxfdG9fZmlyc3RfaGVhZGluZ1xuICAgICAgICAgICAgc2Nyb2xsVG9GaXJzdEhlYWRpbmcoKVxuXG4gICAgYXBwbHlSZWNlbnRDaGFuZ2VzTW9kczogLT5cbiAgICAgICAgaWYgV00uY29uZi5oaWRlX3JvbGxiYWNrX2xpbmtzXG4gICAgICAgICAgICBoaWRlUm9sbGJhY2tMaW5rcygpXG5cbiAgICBhcHBseUNvbnRyaWJ1dGlvbnNNb2RzOiAtPlxuICAgICAgICBpZiBXTS5jb25mLmhpZGVfcm9sbGJhY2tfbGlua3NcbiAgICAgICAgICAgIGhpZGVSb2xsYmFja0xpbmtzKClcbiIsIiMgV2lraSBNb25rZXkgLSBNZWRpYVdpa2kgYm90IGFuZCBlZGl0b3ItYXNzaXN0YW50IHVzZXIgc2NyaXB0XG4jIENvcHlyaWdodCAoQykgMjAxMSBEYXJpbyBHaW92YW5uZXR0aSA8ZGV2QGRhcmlvZ2lvdmFubmV0dGkubmV0PlxuI1xuIyBUaGlzIGZpbGUgaXMgcGFydCBvZiBXaWtpIE1vbmtleS5cbiNcbiMgV2lraSBNb25rZXkgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuIyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuIyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuIyAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuI1xuIyBXaWtpIE1vbmtleSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuIyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuIyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4jIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4jXG4jIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4jIGFsb25nIHdpdGggV2lraSBNb25rZXkuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG5cbntWdWUsIEEsIERpdiwgRmllbGRzZXQsIExlZ2VuZH0gPSByZXF1aXJlKCcuLi9tb2R1bGVzL2xpYnMnKVxue3ZlcnNpb259ID0gcmVxdWlyZSgnLi4vLi4vcGFja2FnZS5qc29uJylcbnJvdXRlID0gcmVxdWlyZSgnLi9yb3V0ZXInKVxuTG9nID0gcmVxdWlyZSgnLi9Mb2cnKVxuXG5cbm1vZHVsZS5leHBvcnRzLkFwcCA9IChXTXRlbXApIC0+XG4gICAge3VpLCBkaXNwbGF5LCBkaXNwbGF5TG9nLCBuZXh0Tm9kZX0gPSByb3V0ZShXTXRlbXApXG5cbiAgICBpZiBub3QgdWlcbiAgICAgICAgcmV0dXJuIGZhbHNlXG5cbiAgICBtb2R1bGUuZXhwb3J0cy5sb2cgPSBsb2cgPSBuZXcgTG9nKClcblxuICAgIHJvb3QgPSBEaXYoKVxuICAgICQobmV4dE5vZGUpLmJlZm9yZShyb290KVxuXG4gICAgbmV3IFZ1ZShcbiAgICAgICAgZWw6IHJvb3RcblxuICAgICAgICBkYXRhOlxuICAgICAgICAgICAgZGlzcGxheTogZGlzcGxheVxuXG4gICAgICAgIHJlbmRlcjogKGUpIC0+XG4gICAgICAgICAgICBzZWxmID0gdGhpc1xuXG4gICAgICAgICAgICB3bW1haW4gPSBlKCdkaXYnLCB7YXR0cnM6IHtpZDogJ1dpa2lNb25rZXlNYWluJ319KVxuXG4gICAgICAgICAgICBsZWdlbmQgPSBlKCdsZWdlbmQnLCBbXG4gICAgICAgICAgICAgICAgJ1dpa2kgTW9ua2V5ICdcbiAgICAgICAgICAgICAgICBlKCdhJ1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyczoge2hyZWY6ICcjJ31cbiAgICAgICAgICAgICAgICAgICAgICAgIG9uOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaWNrOiAoZXZlbnQpIC0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5kaXNwbGF5ID0gbm90IHNlbGYuZGlzcGxheVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIEBkaXNwbGF5IGFuZCAnW2hpZGVdJyBvciAnW3Nob3ddJ1xuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIF0pXG5cbiAgICAgICAgICAgIHJldHVybiBlKCdmaWVsZHNldCcsIHtcbiAgICAgICAgICAgICAgICBhdHRyczoge2lkOiAnV2lraU1vbmtleSd9XG4gICAgICAgICAgICB9LCBbXG4gICAgICAgICAgICAgICAgbGVnZW5kXG4gICAgICAgICAgICAgICAgd21tYWluIGlmIEBkaXNwbGF5XG4gICAgICAgICAgICBdKVxuXG4gICAgICAgIG1vdW50ZWQ6IC0+XG4gICAgICAgICAgICBpZiBub3QgZGlzcGxheUxvZ1xuICAgICAgICAgICAgICAgICQobG9nLmFyZWEpLmhpZGUoKVxuXG4gICAgICAgICAgICAkKCcjV2lraU1vbmtleU1haW4nKS5hcHBlbmQodWksIGxvZy5hcmVhKVxuXG4gICAgICAgICAgICBsb2cubG9nSGlkZGVuKFwiV2lraSBNb25rZXkgdmVyc2lvbjogI3t2ZXJzaW9ufVwiKVxuICAgICAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKClcbiAgICAgICAgICAgIGxvZy5sb2dIaWRkZW4oXCJEYXRlOiAje2RhdGUudG9TdHJpbmcoKX1cIilcbiAgICAgICAgICAgIGxvZy5sb2dIaWRkZW4oXCJVUkw6ICN7bG9jYXRpb24uaHJlZn1cIilcblxuICAgICAgICB1cGRhdGVkOiAtPlxuICAgICAgICAgICAgJHdtbWFpbiA9ICQoJyNXaWtpTW9ua2V5TWFpbicpXG4gICAgICAgICAgICBpZiBub3QgJHdtbWFpbi5jaGlsZHJlbigpLmxlbmd0aFxuICAgICAgICAgICAgICAgICR3bW1haW4uYXBwZW5kKHVpLCBsb2cuYXJlYSlcbiAgICApXG4iLCIjIFdpa2kgTW9ua2V5IC0gTWVkaWFXaWtpIGJvdCBhbmQgZWRpdG9yLWFzc2lzdGFudCB1c2VyIHNjcmlwdFxuIyBDb3B5cmlnaHQgKEMpIDIwMTEgRGFyaW8gR2lvdmFubmV0dGkgPGRldkBkYXJpb2dpb3Zhbm5ldHRpLm5ldD5cbiNcbiMgVGhpcyBmaWxlIGlzIHBhcnQgb2YgV2lraSBNb25rZXkuXG4jXG4jIFdpa2kgTW9ua2V5IGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiMgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiMgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiMgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbiNcbiMgV2lraSBNb25rZXkgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiMgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiMgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuIyBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuI1xuIyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuIyBhbG9uZyB3aXRoIFdpa2kgTW9ua2V5LiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuXG5XTSA9IHJlcXVpcmUoJy4uL21vZHVsZXMvaW5kZXgnKVxuQm90ID0gcmVxdWlyZSgnLi9Cb3QnKVxuRmlsdGVycyA9IHJlcXVpcmUoJy4vRmlsdGVycycpXG5NZW51ID0gcmVxdWlyZSgnLi9NZW51Jylcbk1vZHMgPSByZXF1aXJlKCcuL01vZHMnKVxuXG5cbm1vZHVsZS5leHBvcnRzID0gKFdNdGVtcCkgLT5cbiAgICAjIE1XIHNlZW1zIGEgYml0IHVucmVsaWFibGUgd2l0aCBjYXBpdGFsaXphdGlvbiwgZS5nLiBpdCdzXG4gICAgIyBcIlNwZWNpYWxQYWdlc1wiIGJ1dCBcIlJlY2VudGNoYW5nZXNcIlxuICAgIHNwZWNpYWxQYWdlID0gZG8gLT5cbiAgICAgICAgc3BhZ2UgPSBtdy5jb25maWcuZ2V0KCd3Z0Nhbm9uaWNhbFNwZWNpYWxQYWdlTmFtZScpXG4gICAgICAgIGlmIHNwYWdlXG4gICAgICAgICAgICByZXR1cm4gc3BhZ2UudG9Mb3dlckNhc2UoKVxuICAgICAgICByZXR1cm4gc3BhZ2VcblxuICAgIGRpc3BsYXkgPSB0cnVlXG4gICAgZGlzcGxheUxvZyA9IHRydWVcblxuICAgICMgVE9ETzogUmVjb2duaXplIHRoZSBlZGl0b3Igd2l0aCBtdy5jb25maWcuZ2V0KCd3Z0FjdGlvbicpP1xuICAgIGlmICQoJyNlZGl0Zm9ybScpLmxlbmd0aFxuICAgICAgICBuZXh0Tm9kZSA9ICQoJyN3cFN1bW1hcnlMYWJlbCcpLnBhcmVudCgpLm5leHQoKVswXVxuICAgICAgICBjb25mID0gV00uUGx1Z2lucy5lZGl0b3JcbiAgICAgICAgdWkgPSBpZiBjb25mLmxlbmd0aCB0aGVuIG5ldyBNZW51KFdNdGVtcCwgJ2VkaXRvcicsIGNvbmYpIGVsc2UgbnVsbFxuICAgICAgICBuZXcgTW9kcygpLmFwcGx5RWRpdG9yTW9kcygpXG5cbiAgICBlbHNlIGlmIG13LmNvbmZpZy5nZXQoJ3dnRGlmZk5ld0lkJylcbiAgICAgICAgbmV4dE5vZGUgPSAkKCcjYm9keUNvbnRlbnQgaDInKS5maXJzdCgpWzBdXG4gICAgICAgIGNvbmYgPSBXTS5QbHVnaW5zLmRpZmZcbiAgICAgICAgdWkgPSBpZiBjb25mLmxlbmd0aCB0aGVuIG5ldyBNZW51KFdNdGVtcCwgJ2RpZmYnLCBjb25mKSBlbHNlIG51bGxcblxuICAgIGVsc2UgaWYgbXcuY29uZmlnLmdldCgnd2dDYW5vbmljYWxOYW1lc3BhY2UnKSBpcyAnQ2F0ZWdvcnknXG4gICAgICAgIG5leHROb2RlID0gJCgnI2NvbnRlbnRTdWInKVswXVxuICAgICAgICBjb25mID0gV00uUGx1Z2lucy5ib3RcbiAgICAgICAgdWkgPSBpZiBjb25mLmxlbmd0aCBcXFxuICAgICAgICAgICAgdGhlbiBuZXcgQm90KFdNdGVtcCwgY29uZiwgW1xuICAgICAgICAgICAgICAgIFskKCcjbXctcGFnZXMnKVswXSwgMCwgXCJQYWdlc1wiXVxuICAgICAgICAgICAgICAgIFskKCcjbXctc3ViY2F0ZWdvcmllcycpWzBdLCAwLCBcIlN1YmNhdGVnb3JpZXNcIl1cbiAgICAgICAgICAgIF0pIGVsc2UgbnVsbFxuICAgICAgICBkaXNwbGF5ID0gZmFsc2VcblxuICAgIGVsc2UgaWYgc3BlY2lhbFBhZ2UgaXMgXCJ3aGF0bGlua3NoZXJlXCJcbiAgICAgICAgbmV4dE5vZGUgPSAkKCcjYm9keUNvbnRlbnQgZm9ybScpLmZpcnN0KCkubmV4dCgpWzBdXG4gICAgICAgIGNvbmYgPSBXTS5QbHVnaW5zLmJvdFxuICAgICAgICB1aSA9IGlmIGNvbmYubGVuZ3RoIFxcXG4gICAgICAgICAgICB0aGVuIG5ldyBCb3QoV010ZW1wLCBjb25mLCBbXG4gICAgICAgICAgICAgICAgWyQoJyNtdy13aGF0bGlua3NoZXJlLWxpc3QnKVswXSwgMCwgXCJQYWdlc1wiXVxuICAgICAgICAgICAgXSkgZWxzZSBudWxsXG4gICAgICAgIGRpc3BsYXkgPSBmYWxzZVxuXG4gICAgZWxzZSBpZiBzcGVjaWFsUGFnZSBpcyBcImxpbmtzZWFyY2hcIiBhbmRcbiAgICAgICAgICAgICQoJyNtdy1jb250ZW50LXRleHQgZGl2Lm13LXNwY29udGVudCcpLmxlbmd0aFxuICAgICAgICBuZXh0Tm9kZSA9ICQoJyNtdy1jb250ZW50LXRleHQgZGl2Lm13LXNwY29udGVudCcpLmZpcnN0KClbMF1cbiAgICAgICAgY29uZiA9IFdNLlBsdWdpbnMuYm90XG4gICAgICAgIHVpID0gaWYgY29uZi5sZW5ndGggXFxcbiAgICAgICAgICAgIHRoZW4gbmV3IEJvdChXTXRlbXAsIGNvbmYsIFtcbiAgICAgICAgICAgICAgICBbJChuZXh0Tm9kZSkuZmlyc3QoJ29sLnNwZWNpYWwnKS5maXJzdCgpWzBdLCAxLCBcIlBhZ2VzXCJdXG4gICAgICAgICAgICBdKSBlbHNlIG51bGxcbiAgICAgICAgZGlzcGxheSA9IGZhbHNlXG5cbiAgICBlbHNlIGlmIHNwZWNpYWxQYWdlIGlzIFwicHJlZml4aW5kZXhcIlxuICAgICAgICBuZXh0Tm9kZSA9ICQoJyNtdy1jb250ZW50LXRleHQgZGl2Lm13LXByZWZpeGluZGV4LWJvZHknKS5maXJzdCgpWzBdXG4gICAgICAgIGNvbmYgPSBXTS5QbHVnaW5zLmJvdFxuICAgICAgICB1aSA9IGlmIGNvbmYubGVuZ3RoIFxcXG4gICAgICAgICAgICB0aGVuIG5ldyBCb3QoV010ZW1wLCBjb25mLCBbXG4gICAgICAgICAgICAgICAgWyQobmV4dE5vZGUpLmZpbmQoJ3VsLm13LXByZWZpeGluZGV4LWxpc3QnKS5maXJzdCgpWzBdXG4gICAgICAgICAgICAgICAgIDAsIFwiUGFnZXNcIl1cbiAgICAgICAgICAgIF0pIGVsc2UgbnVsbFxuICAgICAgICBkaXNwbGF5ID0gZmFsc2VcblxuICAgIGVsc2UgaWYgc3BlY2lhbFBhZ2UgaXMgXCJzcGVjaWFscGFnZXNcIlxuICAgICAgICBuZXh0Tm9kZSA9ICQoJyNjb250ZW50U3ViJylbMF1cbiAgICAgICAgY29uZiA9IFdNLlBsdWdpbnMuc3BlY2lhbFxuICAgICAgICB1aSA9IGlmIGNvbmYubGVuZ3RoIFxcXG4gICAgICAgICAgICB0aGVuIG5ldyBNZW51KFdNdGVtcCwgJ3NwZWNpYWwnLCBjb25mKSBlbHNlIG51bGxcblxuICAgIGVsc2UgaWYgc3BlY2lhbFBhZ2UgaXMgXCJyZWNlbnRjaGFuZ2VzXCJcbiAgICAgICAgbmV4dE5vZGUgPSAkKCcjbXctY29udGVudC10ZXh0IGg0JykuZmlyc3QoKVswXVxuICAgICAgICBjb25mID0gV00uUGx1Z2lucy5yZWNlbnRjaGFuZ2VzXG4gICAgICAgIHVpID0gaWYgY29uZi5sZW5ndGggXFxcbiAgICAgICAgICAgIHRoZW4gbmV3IEZpbHRlcnMoV010ZW1wLCAncmVjZW50Y2hhbmdlcycsIGNvbmYpIFxcXG4gICAgICAgICAgICBlbHNlIG51bGxcbiAgICAgICAgZGlzcGxheUxvZyA9IGZhbHNlXG4gICAgICAgIG5ldyBNb2RzKCkuYXBwbHlSZWNlbnRDaGFuZ2VzTW9kcygpXG5cbiAgICBlbHNlIGlmIHNwZWNpYWxQYWdlIGlzIFwibmV3cGFnZXNcIlxuICAgICAgICBuZXh0Tm9kZSA9ICQoJyNtdy1jb250ZW50LXRleHQgdWwnKS5maXJzdCgpWzBdXG4gICAgICAgIGNvbmYgPSBXTS5QbHVnaW5zLm5ld3BhZ2VzXG4gICAgICAgIHVpID0gaWYgY29uZi5sZW5ndGggXFxcbiAgICAgICAgICAgIHRoZW4gbmV3IEZpbHRlcnMoV010ZW1wLCAnbmV3cGFnZXMnLCBjb25mKSBlbHNlIG51bGxcbiAgICAgICAgZGlzcGxheUxvZyA9IGZhbHNlXG5cbiAgICBlbHNlIGlmIHNwZWNpYWxQYWdlIGlzIFwicHJvdGVjdGVkcGFnZXNcIlxuICAgICAgICBuZXh0Tm9kZSA9ICQoJyNtdy1jb250ZW50LXRleHQgdGFibGUubXctcHJvdGVjdGVkcGFnZXMnKS5maXJzdCgpWzBdXG4gICAgICAgIGNvbmYgPSBXTS5QbHVnaW5zLmJvdFxuICAgICAgICB1aSA9IGlmIGNvbmYubGVuZ3RoIFxcXG4gICAgICAgICAgICB0aGVuIG5ldyBCb3QoV010ZW1wLCBjb25mLCBbXG4gICAgICAgICAgICAgICAgWyQobmV4dE5vZGUpLmZpbmQoJ3Rib2R5JykuZmlyc3QoKVswXSwgMCwgXCJQYWdlc1wiXVxuICAgICAgICAgICAgXSkgZWxzZSBudWxsXG4gICAgICAgIGRpc3BsYXkgPSBmYWxzZVxuXG4gICAgZWxzZSBpZiBzcGVjaWFsUGFnZSBpcyBcImNvbnRyaWJ1dGlvbnNcIlxuICAgICAgICBuZXcgTW9kcygpLmFwcGx5Q29udHJpYnV0aW9uc01vZHMoKVxuXG4gICAgZWxzZSBpZiBzcGVjaWFsUGFnZSBpbiBbXG4gICAgICAgIFwiYW5jaWVudHBhZ2VzXCJcbiAgICAgICAgXCJicm9rZW5yZWRpcmVjdHNcIlxuICAgICAgICBcImRlYWRlbmRwYWdlc1wiXG4gICAgICAgIFwiZG91YmxlcmVkaXJlY3RzXCJcbiAgICAgICAgXCJmZXdlc3RyZXZpc2lvbnNcIlxuICAgICAgICBcImxvbmVseXBhZ2VzXCJcbiAgICAgICAgXCJ1bmNhdGVnb3JpemVkY2F0ZWdvcmllc1wiXG4gICAgICAgIFwidW5jYXRlZ29yaXplZHBhZ2VzXCJcbiAgICAgICAgXCJ1bmNhdGVnb3JpemVkdGVtcGxhdGVzXCJcbiAgICAgICAgXCJ1bnVzZWRjYXRlZ29yaWVzXCJcbiAgICAgICAgXCJ1bndhdGNoZWRwYWdlc1wiXG4gICAgXVxuICAgICAgICBuZXh0Tm9kZSA9ICQoJyNtdy1jb250ZW50LXRleHQgZGl2Lm13LXNwY29udGVudCcpLmZpcnN0KClbMF1cbiAgICAgICAgY29uZiA9IFdNLlBsdWdpbnMuYm90XG4gICAgICAgIHVpID0gaWYgY29uZi5sZW5ndGggXFxcbiAgICAgICAgICAgIHRoZW4gbmV3IEJvdChXTXRlbXAsIGNvbmYsIFtcbiAgICAgICAgICAgICAgICBbJChuZXh0Tm9kZSkuZmluZCgnb2wnKS5maXJzdCgpWzBdLCAwLCBcIlBhZ2VzXCJdXG4gICAgICAgICAgICBdKSBlbHNlIG51bGxcbiAgICAgICAgZGlzcGxheSA9IGZhbHNlXG5cbiAgICBlbHNlIGlmIHNwZWNpYWxQYWdlIGluIFtcbiAgICAgICAgXCJsb25ncGFnZXNcIlxuICAgICAgICBcInNob3J0cGFnZXNcIlxuICAgIF1cbiAgICAgICAgbmV4dE5vZGUgPSAkKCcjbXctY29udGVudC10ZXh0IGRpdi5tdy1zcGNvbnRlbnQnKS5maXJzdCgpWzBdXG4gICAgICAgIGNvbmYgPSBXTS5QbHVnaW5zLmJvdFxuICAgICAgICB1aSA9IGlmIGNvbmYubGVuZ3RoIFxcXG4gICAgICAgICAgICB0aGVuIG5ldyBCb3QoV010ZW1wLCBjb25mLCBbXG4gICAgICAgICAgICAgICAgWyQobmV4dE5vZGUpLmZpbmQoJ29sJykuZmlyc3QoKVswXSwgMSwgXCJQYWdlc1wiXVxuICAgICAgICAgICAgXSkgZWxzZSBudWxsXG4gICAgICAgIGRpc3BsYXkgPSBmYWxzZVxuXG4gICAgZWxzZSBpZiBzcGVjaWFsUGFnZSBpcyBcIndpdGhvdXRpbnRlcndpa2lcIlxuICAgICAgICBuZXh0Tm9kZSA9ICQoJyNtdy1jb250ZW50LXRleHQgZGl2Lm13LXNwY29udGVudCA+IHAnKS5maXJzdCgpWzBdXG4gICAgICAgIGNvbmYgPSBXTS5QbHVnaW5zLmJvdFxuICAgICAgICB1aSA9IGlmIGNvbmYubGVuZ3RoIFxcXG4gICAgICAgICAgICB0aGVuIG5ldyBCb3QoV010ZW1wLCBjb25mLCBbXG4gICAgICAgICAgICAgICAgWyQobmV4dE5vZGUpLm5leHRBbGwoJ29sJykuZmlyc3QoKVswXSwgMCwgXCJQYWdlc1wiXVxuICAgICAgICAgICAgXSkgZWxzZSBudWxsXG4gICAgICAgIGRpc3BsYXkgPSBmYWxzZVxuXG4gICAgZWxzZSBpZiBzcGVjaWFsUGFnZSBpcyBcImFsbHBhZ2VzXCJcbiAgICAgICAgbmV4dE5vZGUgPSAkKCcjbXctY29udGVudC10ZXh0IGRpdi5tdy1hbGxwYWdlcy1uYXYnKS5maXJzdCgpWzBdXG4gICAgICAgIGNvbmYgPSBXTS5QbHVnaW5zLmJvdFxuICAgICAgICB1aSA9IGlmIGNvbmYubGVuZ3RoIFxcXG4gICAgICAgICAgICB0aGVuIG5ldyBCb3QoV010ZW1wLCBjb25mLCBbXG4gICAgICAgICAgICAgICAgWyQobmV4dE5vZGUpLm5leHRBbGwoJ2Rpdi5tdy1hbGxwYWdlcy1ib2R5JykuZmlyc3QoKVxuICAgICAgICAgICAgICAgICAgICAuZmluZCgndWwnKS5maXJzdCgpWzBdXG4gICAgICAgICAgICAgICAgIDAsIFwiUGFnZXNcIl1cbiAgICAgICAgICAgIF0pIGVsc2UgbnVsbFxuICAgICAgICBkaXNwbGF5ID0gZmFsc2VcblxuICAgIHJldHVybiB7dWksIGRpc3BsYXksIGRpc3BsYXlMb2csIG5leHROb2RlfVxuIiwiIyBXaWtpIE1vbmtleSAtIE1lZGlhV2lraSBib3QgYW5kIGVkaXRvci1hc3Npc3RhbnQgdXNlciBzY3JpcHRcbiMgQ29weXJpZ2h0IChDKSAyMDExIERhcmlvIEdpb3Zhbm5ldHRpIDxkZXZAZGFyaW9naW92YW5uZXR0aS5uZXQ+XG4jXG4jIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFdpa2kgTW9ua2V5LlxuI1xuIyBXaWtpIE1vbmtleSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4jIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4jIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4jIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4jXG4jIFdpa2kgTW9ua2V5IGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4jIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4jIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiMgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbiNcbiMgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiMgYWxvbmcgd2l0aCBXaWtpIE1vbmtleS4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cblxuXG5jbGFzcyBtb2R1bGUuZXhwb3J0c1xuICAgIGNvbnN0cnVjdG9yOiAoQFdNKSAtPlxuXG4gICAgbGFuZ3VhZ2VzID0ge1xuICAgICAgICBsb2NhbDogXCJFbmdsaXNoXCIsXG4gICAgICAgIG5hbWVzOiB7XG4gICAgICAgICAgICBcItin2YTYudix2KjZitipXCI6IHtzdWJ0YWc6IFwiYXJcIiwgZW5nbGlzaDogXCJBcmFiaWNcIn0sXG4gICAgICAgICAgICBcItCR0YrQu9Cz0LDRgNGB0LrQuFwiOiB7c3VidGFnOiBcImJnXCIsIGVuZ2xpc2g6IFwiQnVsZ2FyaWFuXCJ9LFxuICAgICAgICAgICAgXCJDYXRhbMOgXCI6IHtzdWJ0YWc6IFwiY2FcIiwgZW5nbGlzaDogXCJDYXRhbGFuXCJ9LFxuICAgICAgICAgICAgXCLEjGVza3lcIjoge3N1YnRhZzogXCJjc1wiLCBlbmdsaXNoOiBcIkN6ZWNoXCJ9LFxuICAgICAgICAgICAgXCJEYW5za1wiOiB7c3VidGFnOiBcImRhXCIsIGVuZ2xpc2g6IFwiRGFuaXNoXCJ9LFxuICAgICAgICAgICAgXCJEZXV0c2NoXCI6IHtzdWJ0YWc6IFwiZGVcIiwgZW5nbGlzaDogXCJHZXJtYW5cIn0sXG4gICAgICAgICAgICBcIs6VzrvOu863zr3Ouc66zqxcIjoge3N1YnRhZzogXCJlbFwiLCBlbmdsaXNoOiBcIkdyZWVrXCJ9LFxuICAgICAgICAgICAgXCJFbmdsaXNoXCI6IHtzdWJ0YWc6IFwiZW5cIiwgZW5nbGlzaDogXCJFbmdsaXNoXCJ9LFxuICAgICAgICAgICAgXCJFc3BlcmFudG9cIjoge3N1YnRhZzogXCJlb1wiLCBlbmdsaXNoOiBcIkVzcGVyYW50b1wifSxcbiAgICAgICAgICAgIFwiRXNwYcOxb2xcIjoge3N1YnRhZzogXCJlc1wiLCBlbmdsaXNoOiBcIlNwYW5pc2hcIn0sXG4gICAgICAgICAgICBcItmB2KfYsdiz24xcIjoge3N1YnRhZzogXCJmYVwiLCBlbmdsaXNoOiBcIlBlcnNpYW5cIn0sXG4gICAgICAgICAgICBcIlN1b21pXCI6IHtzdWJ0YWc6IFwiZmlcIiwgZW5nbGlzaDogXCJGaW5uaXNoXCJ9LFxuICAgICAgICAgICAgXCJGcmFuw6dhaXNcIjoge3N1YnRhZzogXCJmclwiLCBlbmdsaXNoOiBcIkZyZW5jaFwifSxcbiAgICAgICAgICAgIFwi16LXkdeo15nXqlwiOiB7c3VidGFnOiBcImhlXCIsIGVuZ2xpc2g6IFwiSGVicmV3XCJ9LFxuICAgICAgICAgICAgXCJIcnZhdHNraVwiOiB7c3VidGFnOiBcImhyXCIsIGVuZ2xpc2g6IFwiQ3JvYXRpYW5cIn0sXG4gICAgICAgICAgICBcIk1hZ3lhclwiOiB7c3VidGFnOiBcImh1XCIsIGVuZ2xpc2g6IFwiSHVuZ2FyaWFuXCJ9LFxuICAgICAgICAgICAgXCJJbmRvbmVzaWFcIjoge3N1YnRhZzogXCJpZFwiLCBlbmdsaXNoOiBcIkluZG9uZXNpYW5cIn0sXG4gICAgICAgICAgICBcIkl0YWxpYW5vXCI6IHtzdWJ0YWc6IFwiaXRcIiwgZW5nbGlzaDogXCJJdGFsaWFuXCJ9LFxuICAgICAgICAgICAgXCLml6XmnKzoqp5cIjoge3N1YnRhZzogXCJqYVwiLCBlbmdsaXNoOiBcIkphcGFuZXNlXCJ9LFxuICAgICAgICAgICAgXCLtlZzqta3slrRcIjoge3N1YnRhZzogXCJrb1wiLCBlbmdsaXNoOiBcIktvcmVhblwifSxcbiAgICAgICAgICAgIFwiTGlldHV2acWha2FpXCI6IHtzdWJ0YWc6IFwibHRcIiwgZW5nbGlzaDogXCJMaXRodWFuaWFuXCJ9LFxuICAgICAgICAgICAgXCJOb3JzayBCb2ttw6VsXCI6IHtzdWJ0YWc6IFwibmJcIiwgZW5nbGlzaDogXCJOb3J3ZWdpYW4gKEJva23DpWwpXCJ9LFxuICAgICAgICAgICAgXCJOZWRlcmxhbmRzXCI6IHtzdWJ0YWc6IFwibmxcIiwgZW5nbGlzaDogXCJEdXRjaFwifSxcbiAgICAgICAgICAgIFwiUG9sc2tpXCI6IHtzdWJ0YWc6IFwicGxcIiwgZW5nbGlzaDogXCJQb2xpc2hcIn0sXG4gICAgICAgICAgICBcIlBvcnR1Z3XDqnNcIjoge3N1YnRhZzogXCJwdFwiLCBlbmdsaXNoOiBcIlBvcnR1Z3Vlc2VcIn0sXG4gICAgICAgICAgICBcIlJvbcOibsSDXCI6IHtzdWJ0YWc6IFwicm9cIiwgZW5nbGlzaDogXCJSb21hbmlhblwifSxcbiAgICAgICAgICAgIFwi0KDRg9GB0YHQutC40LlcIjoge3N1YnRhZzogXCJydVwiLCBlbmdsaXNoOiBcIlJ1c3NpYW5cIn0sXG4gICAgICAgICAgICBcIlNsb3ZlbnNrw71cIjoge3N1YnRhZzogXCJza1wiLCBlbmdsaXNoOiBcIlNsb3Zha1wifSxcbiAgICAgICAgICAgIFwi0KHRgNC/0YHQutC4XCI6IHtzdWJ0YWc6IFwic3JcIiwgZW5nbGlzaDogXCJTZXJiaWFuXCJ9LFxuICAgICAgICAgICAgXCJTdmVuc2thXCI6IHtzdWJ0YWc6IFwic3ZcIiwgZW5nbGlzaDogXCJTd2VkaXNoXCJ9LFxuICAgICAgICAgICAgXCLguYTguJfguKJcIjoge3N1YnRhZzogXCJ0aFwiLCBlbmdsaXNoOiBcIlRoYWlcIn0sXG4gICAgICAgICAgICBcIlTDvHJrw6dlXCI6IHtzdWJ0YWc6IFwidHJcIiwgZW5nbGlzaDogXCJUdXJraXNoXCJ9LFxuICAgICAgICAgICAgXCLQo9C60YDQsNGX0L3RgdGM0LrQsFwiOiB7c3VidGFnOiBcInVrXCIsIGVuZ2xpc2g6IFwiVWtyYWluaWFuXCJ9LFxuICAgICAgICAgICAgXCJUaeG6v25nIFZp4buHdFwiOiB7c3VidGFnOiBcInZpXCIsIGVuZ2xpc2g6IFwiVmlldG5hbWVzZVwifSxcbiAgICAgICAgICAgIFwi566A5L2T5Lit5paHXCI6IHtzdWJ0YWc6IFwiemgtaGFuc1wiLCBlbmdsaXNoOiBcIkNoaW5lc2UgKFNpbXBsaWZpZWQpXCJ9LFxuICAgICAgICAgICAgXCLmraPpq5TkuK3mlodcIjoge3N1YnRhZzogXCJ6aC1oYW50XCIsIGVuZ2xpc2g6IFwiQ2hpbmVzZSAoVHJhZGl0aW9uYWwpXCJ9XG4gICAgICAgIH0sXG4gICAgICAgIGNhdGVnb3JpZXM6IFtcbiAgICAgICAgICAgIFwi2KfZhNi52LHYqNmK2KlcIixcbiAgICAgICAgICAgIFwi0JHRitC70LPQsNGA0YHQutC4XCIsXG4gICAgICAgICAgICBcIkNhdGFsw6BcIixcbiAgICAgICAgICAgIFwixIxlc2t5XCIsXG4gICAgICAgICAgICBcIkRhbnNrXCIsXG4gICAgICAgICAgICBcIs6VzrvOu863zr3Ouc66zqxcIixcbiAgICAgICAgICAgIFwiRW5nbGlzaFwiLFxuICAgICAgICAgICAgXCJFc3BlcmFudG9cIixcbiAgICAgICAgICAgIFwiRXNwYcOxb2xcIixcbiAgICAgICAgICAgIFwiU3VvbWlcIixcbiAgICAgICAgICAgIFwi16LXkdeo15nXqlwiLFxuICAgICAgICAgICAgXCJIcnZhdHNraVwiLFxuICAgICAgICAgICAgXCJNYWd5YXJcIixcbiAgICAgICAgICAgIFwiSW5kb25lc2lhXCIsXG4gICAgICAgICAgICBcIkl0YWxpYW5vXCIsXG4gICAgICAgICAgICBcIuaXpeacrOiqnlwiLFxuICAgICAgICAgICAgXCLtlZzqta3slrRcIixcbiAgICAgICAgICAgIFwiTGlldHV2acWha2FpXCIsXG4gICAgICAgICAgICBcIk5vcnNrIEJva23DpWxcIixcbiAgICAgICAgICAgIFwiTmVkZXJsYW5kc1wiLFxuICAgICAgICAgICAgXCJQb2xza2lcIixcbiAgICAgICAgICAgIFwiUG9ydHVndcOqc1wiLFxuICAgICAgICAgICAgXCLQoNGD0YHRgdC60LjQuVwiLFxuICAgICAgICAgICAgXCJTbG92ZW5za8O9XCIsXG4gICAgICAgICAgICBcItCh0YDQv9GB0LrQuFwiLFxuICAgICAgICAgICAgXCLguYTguJfguKJcIixcbiAgICAgICAgICAgIFwiVMO8cmvDp2VcIixcbiAgICAgICAgICAgIFwi0KPQutGA0LDRl9C90YHRjNC60LBcIixcbiAgICAgICAgICAgIFwi566A5L2T5Lit5paHXCIsXG4gICAgICAgICAgICBcIuato+mrlOS4reaWh1wiXG4gICAgICAgIF0sXG4gICAgICAgIGludGVybGFuZ3VhZ2U6IHtcbiAgICAgICAgICAgIGV4dGVybmFsOiBbXCJkZVwiLCBcImZhXCIsIFwiZnJcIiwgXCJqYVwiLCBcInJvXCJdLFxuICAgICAgICAgICAgaW50ZXJuYWw6IFtcImFyXCIsIFwiYmdcIiwgXCJjc1wiLCBcImRhXCIsIFwiZWxcIiwgXCJlblwiLCBcImVzXCIsIFwiZmlcIiwgXCJoZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICBcImhyXCIsIFwiaHVcIiwgXCJpZFwiLCBcIml0XCIsIFwia29cIiwgXCJsdFwiLCBcIm5sXCIsIFwicGxcIiwgXCJwdFwiLFxuICAgICAgICAgICAgICAgICAgICAgICBcInJ1XCIsIFwic2tcIiwgXCJzclwiLCBcInN2XCIsIFwidGhcIiwgXCJ0clwiLCBcInVrXCIsIFwiemgtaGFuc1wiLFxuICAgICAgICAgICAgICAgICAgICAgICBcInpoLWhhbnRcIl0sXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0YWJsZXNPZkNvbnRlbnRzID0ge1xuICAgICAgICBcImFyXCI6IHtcbiAgICAgICAgICAgIFwicGFnZVwiOiBcIlRhYmxlIG9mIGNvbnRlbnRzICjYp9mE2LnYsdio2YrYqSlcIixcbiAgICAgICAgICAgIFwicm9vdFwiOiBcIkNhdGVnb3J5Otin2YTYudix2KjZitipXCIsXG4gICAgICAgICAgICBcImFsc29JblwiOiBcImFsc28gaW5cIiwgICMgVE9ETzogVW50cmFuc2xhdGVkLCBSaWdodC10by1sZWZ0IHByb2JsZW1zXG4gICAgICAgICAgICBcImluZGVudFR5cGVcIjogXCI6XCIsXG4gICAgICAgICAgICBcInJlcGxhY2VcIjogW1wiWyBfXVxcXFwo2KfZhNi52LHYqNmK2KlcXFxcKVwiLCBcIlwiLCBcIlwiXSxcbiAgICAgICAgICAgIFwia2VlcEFsdE5hbWVcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwic2hvd0luZGljZXNcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwicmlnaHRUb0xlZnRcIjogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICBcImJnXCI6IHtcbiAgICAgICAgICAgIFwicGFnZVwiOiBcIlRhYmxlIG9mIGNvbnRlbnRzICjQkdGK0LvQs9Cw0YDRgdC60LgpXCIsXG4gICAgICAgICAgICBcInJvb3RcIjogXCJDYXRlZ29yeTrQkdGK0LvQs9Cw0YDRgdC60LhcIixcbiAgICAgICAgICAgIFwiYWxzb0luXCI6IFwi0YHRitGJ0L4g0LJcIiwgICMgVW5jb25maXJtZWRcbiAgICAgICAgICAgIFwiaW5kZW50VHlwZVwiOiBcIjpcIixcbiAgICAgICAgICAgIFwicmVwbGFjZVwiOiBbXCJbIF9dXFxcXCjQkdGK0LvQs9Cw0YDRgdC60LhcXFxcKVwiLCBcIlwiLCBcIlwiXSxcbiAgICAgICAgICAgIFwia2VlcEFsdE5hbWVcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwic2hvd0luZGljZXNcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwicmlnaHRUb0xlZnRcIjogZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgXCJjc1wiOiB7XG4gICAgICAgICAgICBcInBhZ2VcIjogXCJUYWJsZSBvZiBjb250ZW50cyAoxIxlc2t5KVwiLFxuICAgICAgICAgICAgXCJyb290XCI6IFwiQ2F0ZWdvcnk6xIxlc2t5XCIsXG4gICAgICAgICAgICBcImFsc29JblwiOiBcInRha8OpIHZcIixcbiAgICAgICAgICAgIFwiaW5kZW50VHlwZVwiOiBcIjpcIixcbiAgICAgICAgICAgIFwicmVwbGFjZVwiOiBbXCJbIF9dXFxcXCjEjGVza3lcXFxcKVwiLCBcIlwiLCBcIlwiXSxcbiAgICAgICAgICAgIFwia2VlcEFsdE5hbWVcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwic2hvd0luZGljZXNcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwicmlnaHRUb0xlZnRcIjogZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgXCJkYVwiOiB7XG4gICAgICAgICAgICBcInBhZ2VcIjogXCJUYWJsZSBvZiBjb250ZW50cyAoRGFuc2spXCIsXG4gICAgICAgICAgICBcInJvb3RcIjogXCJDYXRlZ29yeTpEYW5za1wiLFxuICAgICAgICAgICAgXCJhbHNvSW5cIjogXCJvZ3PDpSBpXCIsICAjIFVuY29uZmlybWVkXG4gICAgICAgICAgICBcImluZGVudFR5cGVcIjogXCI6XCIsXG4gICAgICAgICAgICBcInJlcGxhY2VcIjogW1wiWyBfXVxcXFwoRGFuc2tcXFxcKVwiLCBcIlwiLCBcIlwiXSxcbiAgICAgICAgICAgIFwia2VlcEFsdE5hbWVcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwic2hvd0luZGljZXNcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwicmlnaHRUb0xlZnRcIjogZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgXCJlbFwiOiB7XG4gICAgICAgICAgICBcInBhZ2VcIjogXCJUYWJsZSBvZiBjb250ZW50cyAozpXOu867zrfOvc65zrrOrClcIixcbiAgICAgICAgICAgIFwicm9vdFwiOiBcIkNhdGVnb3J5Os6VzrvOu863zr3Ouc66zqxcIixcbiAgICAgICAgICAgIFwiYWxzb0luXCI6IFwizrXPgM6vz4POt8+CIM+DzrVcIiwgICMgVW5jb25maXJtZWRcbiAgICAgICAgICAgIFwiaW5kZW50VHlwZVwiOiBcIjpcIixcbiAgICAgICAgICAgIFwicmVwbGFjZVwiOiBbXCJbIF9dXFxcXCjOlc67zrvOt869zrnOus6sXFxcXClcIiwgXCJcIiwgXCJcIl0sXG4gICAgICAgICAgICBcImtlZXBBbHROYW1lXCI6IHRydWUsXG4gICAgICAgICAgICBcInNob3dJbmRpY2VzXCI6IHRydWUsXG4gICAgICAgICAgICBcInJpZ2h0VG9MZWZ0XCI6IGZhbHNlXG4gICAgICAgIH0sXG4gICAgICAgIFwiZW5cIjoge1xuICAgICAgICAgICAgXCJwYWdlXCI6IFwiVGFibGUgb2YgY29udGVudHNcIixcbiAgICAgICAgICAgIFwicm9vdFwiOiBcIkNhdGVnb3J5OkVuZ2xpc2hcIixcbiAgICAgICAgICAgIFwiYWxzb0luXCI6IFwiYWxzbyBpblwiLFxuICAgICAgICAgICAgXCJpbmRlbnRUeXBlXCI6IFwiOlwiLFxuICAgICAgICAgICAgXCJyZXBsYWNlXCI6IG51bGwsXG4gICAgICAgICAgICBcImtlZXBBbHROYW1lXCI6IGZhbHNlLFxuICAgICAgICAgICAgXCJzaG93SW5kaWNlc1wiOiB0cnVlLFxuICAgICAgICAgICAgXCJyaWdodFRvTGVmdFwiOiBmYWxzZVxuICAgICAgICB9LFxuICAgICAgICBcImVzXCI6IHtcbiAgICAgICAgICAgIFwicGFnZVwiOiBcIlRhYmxlIG9mIGNvbnRlbnRzIChFc3Bhw7FvbClcIixcbiAgICAgICAgICAgIFwicm9vdFwiOiBcIkNhdGVnb3J5OkVzcGHDsW9sXCIsXG4gICAgICAgICAgICBcImFsc29JblwiOiBcInRhbWJpw6luIGVuXCIsXG4gICAgICAgICAgICBcImluZGVudFR5cGVcIjogXCI6XCIsXG4gICAgICAgICAgICBcInJlcGxhY2VcIjogW1wiWyBfXVxcXFwoRXNwYcOxb2xcXFxcKVwiLCBcIlwiLCBcIlwiXSxcbiAgICAgICAgICAgIFwia2VlcEFsdE5hbWVcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwic2hvd0luZGljZXNcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwicmlnaHRUb0xlZnRcIjogZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgXCJoZVwiOiB7XG4gICAgICAgICAgICBcInBhZ2VcIjogXCJUYWJsZSBvZiBjb250ZW50cyAo16LXkdeo15nXqilcIixcbiAgICAgICAgICAgIFwicm9vdFwiOiBcIkNhdGVnb3J5Otei15HXqNeZ16pcIixcbiAgICAgICAgICAgIFwiYWxzb0luXCI6IFwiYWxzbyBpblwiLCAgIyBUT0RPOiBVbnRyYW5zbGF0ZWQsIFJpZ2h0LXRvLWxlZnQgcHJvYmxlbXNcbiAgICAgICAgICAgIFwiaW5kZW50VHlwZVwiOiBcIjpcIixcbiAgICAgICAgICAgIFwicmVwbGFjZVwiOiBbXCJbIF9dXFxcXCjXoteR16jXmdeqXFxcXClcIiwgXCJcIiwgXCJcIl0sXG4gICAgICAgICAgICBcImtlZXBBbHROYW1lXCI6IHRydWUsXG4gICAgICAgICAgICBcInNob3dJbmRpY2VzXCI6IHRydWUsXG4gICAgICAgICAgICBcInJpZ2h0VG9MZWZ0XCI6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgXCJoclwiOiB7XG4gICAgICAgICAgICBcInBhZ2VcIjogXCJUYWJsZSBvZiBjb250ZW50cyAoSHJ2YXRza2kpXCIsXG4gICAgICAgICAgICBcInJvb3RcIjogXCJDYXRlZ29yeTpIcnZhdHNraVwiLFxuICAgICAgICAgICAgXCJhbHNvSW5cIjogXCJ0YWtvxJFlciB1XCIsICAjIFVuY29uZmlybWVkXG4gICAgICAgICAgICBcImluZGVudFR5cGVcIjogXCI6XCIsXG4gICAgICAgICAgICBcInJlcGxhY2VcIjogW1wiWyBfXVxcXFwoSHJ2YXRza2lcXFxcKVwiLCBcIlwiLCBcIlwiXSxcbiAgICAgICAgICAgIFwia2VlcEFsdE5hbWVcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwic2hvd0luZGljZXNcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwicmlnaHRUb0xlZnRcIjogZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgXCJodVwiOiB7XG4gICAgICAgICAgICBcInBhZ2VcIjogXCJUYWJsZSBvZiBjb250ZW50cyAoTWFneWFyKVwiLFxuICAgICAgICAgICAgXCJyb290XCI6IFwiQ2F0ZWdvcnk6TWFneWFyXCIsXG4gICAgICAgICAgICBcImFsc29JblwiOiBcImlzXCIsICAjIFVuY29uZmlybWVkXG4gICAgICAgICAgICBcImluZGVudFR5cGVcIjogXCI6XCIsXG4gICAgICAgICAgICBcInJlcGxhY2VcIjogW1wiWyBfXVxcXFwoTWFneWFyXFxcXClcIiwgXCJcIiwgXCJcIl0sXG4gICAgICAgICAgICBcImtlZXBBbHROYW1lXCI6IHRydWUsXG4gICAgICAgICAgICBcInNob3dJbmRpY2VzXCI6IHRydWUsXG4gICAgICAgICAgICBcInJpZ2h0VG9MZWZ0XCI6IGZhbHNlXG4gICAgICAgIH0sXG4gICAgICAgIFwiaWRcIjoge1xuICAgICAgICAgICAgXCJwYWdlXCI6IFwiVGFibGUgb2YgY29udGVudHMgKEluZG9uZXNpYSlcIixcbiAgICAgICAgICAgIFwicm9vdFwiOiBcIkNhdGVnb3J5OkluZG9uZXNpYVwiLFxuICAgICAgICAgICAgXCJhbHNvSW5cIjogXCJqdWdhIGRpXCIsICAjIFVuY29uZmlybWVkXG4gICAgICAgICAgICBcImluZGVudFR5cGVcIjogXCI6XCIsXG4gICAgICAgICAgICBcInJlcGxhY2VcIjogW1wiWyBfXVxcXFwoSW5kb25lc2lhXFxcXClcIiwgXCJcIiwgXCJcIl0sXG4gICAgICAgICAgICBcImtlZXBBbHROYW1lXCI6IHRydWUsXG4gICAgICAgICAgICBcInNob3dJbmRpY2VzXCI6IHRydWUsXG4gICAgICAgICAgICBcInJpZ2h0VG9MZWZ0XCI6IGZhbHNlXG4gICAgICAgIH0sXG4gICAgICAgIFwiaXRcIjoge1xuICAgICAgICAgICAgXCJwYWdlXCI6IFwiVGFibGUgb2YgY29udGVudHMgKEl0YWxpYW5vKVwiLFxuICAgICAgICAgICAgXCJyb290XCI6IFwiQ2F0ZWdvcnk6SXRhbGlhbm9cIixcbiAgICAgICAgICAgIFwiYWxzb0luXCI6IFwiYW5jaGUgaW5cIixcbiAgICAgICAgICAgIFwiaW5kZW50VHlwZVwiOiBcIjpcIixcbiAgICAgICAgICAgIFwicmVwbGFjZVwiOiBbXCJbIF9dXFxcXChJdGFsaWFub1xcXFwpXCIsIFwiXCIsIFwiXCJdLFxuICAgICAgICAgICAgXCJrZWVwQWx0TmFtZVwiOiB0cnVlLFxuICAgICAgICAgICAgXCJzaG93SW5kaWNlc1wiOiB0cnVlLFxuICAgICAgICAgICAgXCJyaWdodFRvTGVmdFwiOiBmYWxzZVxuICAgICAgICB9LFxuICAgICAgICBcImtvXCI6IHtcbiAgICAgICAgICAgIFwicGFnZVwiOiBcIlRhYmxlIG9mIGNvbnRlbnRzICjtlZzqta3slrQpXCIsXG4gICAgICAgICAgICBcInJvb3RcIjogXCJDYXRlZ29yeTrtlZzqta3slrRcIixcbiAgICAgICAgICAgIFwiYWxzb0luXCI6IFwi65iQ7ZWcIOyXkFwiLCAgIyBVbmNvbmZpcm1lZFxuICAgICAgICAgICAgXCJpbmRlbnRUeXBlXCI6IFwiOlwiLFxuICAgICAgICAgICAgXCJyZXBsYWNlXCI6IFtcIlsgX11cXFxcKO2VnOq1reyWtFxcXFwpXCIsIFwiXCIsIFwiXCJdLFxuICAgICAgICAgICAgXCJrZWVwQWx0TmFtZVwiOiB0cnVlLFxuICAgICAgICAgICAgXCJzaG93SW5kaWNlc1wiOiB0cnVlLFxuICAgICAgICAgICAgXCJyaWdodFRvTGVmdFwiOiBmYWxzZVxuICAgICAgICB9LFxuICAgICAgICBcImx0XCI6IHtcbiAgICAgICAgICAgIFwicGFnZVwiOiBcIlRhYmxlIG9mIGNvbnRlbnRzIChMaWV0dXZpxaFrYWkpXCIsXG4gICAgICAgICAgICBcInJvb3RcIjogXCJDYXRlZ29yeTpMaWV0dXZpxaFrYWlcIixcbiAgICAgICAgICAgIFwiYWxzb0luXCI6IFwidGFpcCBwYXQgaXJcIiwgICMgVW5jb25maXJtZWRcbiAgICAgICAgICAgIFwiaW5kZW50VHlwZVwiOiBcIjpcIixcbiAgICAgICAgICAgIFwicmVwbGFjZVwiOiBbXCJbIF9dXFxcXChMaWV0dXZpxaFrYWlcXFxcKVwiLCBcIlwiLCBcIlwiXSxcbiAgICAgICAgICAgIFwia2VlcEFsdE5hbWVcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwic2hvd0luZGljZXNcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwicmlnaHRUb0xlZnRcIjogZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgXCJubFwiOiB7XG4gICAgICAgICAgICBcInBhZ2VcIjogXCJUYWJsZSBvZiBjb250ZW50cyAoTmVkZXJsYW5kcylcIixcbiAgICAgICAgICAgIFwicm9vdFwiOiBcIkNhdGVnb3J5Ok5lZGVybGFuZHNcIixcbiAgICAgICAgICAgIFwiYWxzb0luXCI6IFwib29rIGluXCIsICAjIFVuY29uZmlybWVkXG4gICAgICAgICAgICBcImluZGVudFR5cGVcIjogXCI6XCIsXG4gICAgICAgICAgICBcInJlcGxhY2VcIjogW1wiWyBfXVxcXFwoTmVkZXJsYW5kc1xcXFwpXCIsIFwiXCIsIFwiXCJdLFxuICAgICAgICAgICAgXCJrZWVwQWx0TmFtZVwiOiB0cnVlLFxuICAgICAgICAgICAgXCJzaG93SW5kaWNlc1wiOiB0cnVlLFxuICAgICAgICAgICAgXCJyaWdodFRvTGVmdFwiOiBmYWxzZVxuICAgICAgICB9LFxuICAgICAgICBcInBsXCI6IHtcbiAgICAgICAgICAgIFwicGFnZVwiOiBcIlRhYmxlIG9mIGNvbnRlbnRzIChQb2xza2kpXCIsXG4gICAgICAgICAgICBcInJvb3RcIjogXCJDYXRlZ29yeTpQb2xza2lcIixcbiAgICAgICAgICAgIFwiYWxzb0luXCI6IFwicsOzd25pZcW8IHdcIiwgICMgVW5jb25maXJtZWRcbiAgICAgICAgICAgIFwiaW5kZW50VHlwZVwiOiBcIjpcIixcbiAgICAgICAgICAgIFwicmVwbGFjZVwiOiBbXCJbIF9dXFxcXChQb2xza2lcXFxcKVwiLCBcIlwiLCBcIlwiXSxcbiAgICAgICAgICAgIFwia2VlcEFsdE5hbWVcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwic2hvd0luZGljZXNcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwicmlnaHRUb0xlZnRcIjogZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgXCJwdFwiOiB7XG4gICAgICAgICAgICBcInBhZ2VcIjogXCJUYWJsZSBvZiBjb250ZW50cyAoUG9ydHVndcOqcylcIixcbiAgICAgICAgICAgIFwicm9vdFwiOiBcIkNhdGVnb3J5OlBvcnR1Z3XDqnNcIixcbiAgICAgICAgICAgIFwiYWxzb0luXCI6IFwidGFtYsOpbSBlbVwiLFxuICAgICAgICAgICAgXCJpbmRlbnRUeXBlXCI6IFwiOlwiLFxuICAgICAgICAgICAgXCJyZXBsYWNlXCI6IFtcIlsgX11cXFxcKFBvcnR1Z3XDqnNcXFxcKVwiLCBcIlwiLCBcIlwiXSxcbiAgICAgICAgICAgIFwia2VlcEFsdE5hbWVcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwic2hvd0luZGljZXNcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwicmlnaHRUb0xlZnRcIjogZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgXCJydVwiOiB7XG4gICAgICAgICAgICBcInBhZ2VcIjogXCJUYWJsZSBvZiBjb250ZW50cyAo0KDRg9GB0YHQutC40LkpXCIsXG4gICAgICAgICAgICBcInJvb3RcIjogXCJDYXRlZ29yeTrQoNGD0YHRgdC60LjQuVwiLFxuICAgICAgICAgICAgXCJhbHNvSW5cIjogXCLQotCw0LrQttC1INCyXCIsXG4gICAgICAgICAgICBcImluZGVudFR5cGVcIjogXCI6XCIsXG4gICAgICAgICAgICBcInJlcGxhY2VcIjogW1wiWyBfXVxcXFwo0KDRg9GB0YHQutC40LlcXFxcKVwiLCBcIlwiLCBcIlwiXSxcbiAgICAgICAgICAgIFwia2VlcEFsdE5hbWVcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwic2hvd0luZGljZXNcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwicmlnaHRUb0xlZnRcIjogZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgXCJza1wiOiB7XG4gICAgICAgICAgICBcInBhZ2VcIjogXCJUYWJsZSBvZiBjb250ZW50cyAoU2xvdmVuc2vDvSlcIixcbiAgICAgICAgICAgIFwicm9vdFwiOiBcIkNhdGVnb3J5OlNsb3ZlbnNrw71cIixcbiAgICAgICAgICAgIFwiYWxzb0luXCI6IFwidGllxb4gdlwiLFxuICAgICAgICAgICAgXCJpbmRlbnRUeXBlXCI6IFwiOlwiLFxuICAgICAgICAgICAgXCJyZXBsYWNlXCI6IFtcIlsgX11cXFxcKFNsb3ZlbnNrw71cXFxcKVwiLCBcIlwiLCBcIlwiXSxcbiAgICAgICAgICAgIFwia2VlcEFsdE5hbWVcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwic2hvd0luZGljZXNcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwicmlnaHRUb0xlZnRcIjogZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgXCJzclwiOiB7XG4gICAgICAgICAgICBcInBhZ2VcIjogXCJUYWJsZSBvZiBjb250ZW50cyAo0KHRgNC/0YHQutC4KVwiLFxuICAgICAgICAgICAgXCJyb290XCI6IFwiQ2F0ZWdvcnk60KHRgNC/0YHQutC4XCIsXG4gICAgICAgICAgICBcImFsc29JblwiOiBcItGC0LDQutC+0ZLQtSDRg1wiLCAgIyBVbmNvbmZpcm1lZFxuICAgICAgICAgICAgXCJpbmRlbnRUeXBlXCI6IFwiOlwiLFxuICAgICAgICAgICAgXCJyZXBsYWNlXCI6IFtcIlsgX11cXFxcKNCh0YDQv9GB0LrQuFxcXFwpXCIsIFwiXCIsIFwiXCJdLFxuICAgICAgICAgICAgXCJrZWVwQWx0TmFtZVwiOiB0cnVlLFxuICAgICAgICAgICAgXCJzaG93SW5kaWNlc1wiOiB0cnVlLFxuICAgICAgICAgICAgXCJyaWdodFRvTGVmdFwiOiBmYWxzZVxuICAgICAgICB9LFxuICAgICAgICBcInRoXCI6IHtcbiAgICAgICAgICAgIFwicGFnZVwiOiBcIlRhYmxlIG9mIGNvbnRlbnRzICjguYTguJfguKIpXCIsXG4gICAgICAgICAgICBcInJvb3RcIjogXCJDYXRlZ29yeTrguYTguJfguKJcIixcbiAgICAgICAgICAgIFwiYWxzb0luXCI6IFwi4Lii4Lix4LiH4Lit4Lii4Li54LmI4LmD4LiZXCIsICAjIFVuY29uZmlybWVkXG4gICAgICAgICAgICBcImluZGVudFR5cGVcIjogXCI6XCIsXG4gICAgICAgICAgICBcInJlcGxhY2VcIjogW1wiWyBfXVxcXFwo4LmE4LiX4LiiXFxcXClcIiwgXCJcIiwgXCJcIl0sXG4gICAgICAgICAgICBcImtlZXBBbHROYW1lXCI6IHRydWUsXG4gICAgICAgICAgICBcInNob3dJbmRpY2VzXCI6IHRydWUsXG4gICAgICAgICAgICBcInJpZ2h0VG9MZWZ0XCI6IGZhbHNlXG4gICAgICAgIH0sXG4gICAgICAgIFwidHJcIjoge1xuICAgICAgICAgICAgXCJwYWdlXCI6IFwiVGFibGUgb2YgY29udGVudHMgKFTDvHJrw6dlKVwiLFxuICAgICAgICAgICAgXCJyb290XCI6IFwiQ2F0ZWdvcnk6VMO8cmvDp2VcIixcbiAgICAgICAgICAgIFwiYWxzb0luXCI6IFwiYXlyxLFjYVwiLCAgIyBVbmNvbmZpcm1lZFxuICAgICAgICAgICAgXCJpbmRlbnRUeXBlXCI6IFwiOlwiLFxuICAgICAgICAgICAgXCJyZXBsYWNlXCI6IFtcIlsgX11cXFxcKFTDvHJrw6dlXFxcXClcIiwgXCJcIiwgXCJcIl0sXG4gICAgICAgICAgICBcImtlZXBBbHROYW1lXCI6IHRydWUsXG4gICAgICAgICAgICBcInNob3dJbmRpY2VzXCI6IHRydWUsXG4gICAgICAgICAgICBcInJpZ2h0VG9MZWZ0XCI6IGZhbHNlXG4gICAgICAgIH0sXG4gICAgICAgIFwidWtcIjoge1xuICAgICAgICAgICAgXCJwYWdlXCI6IFwiVGFibGUgb2YgY29udGVudHMgKNCj0LrRgNCw0ZfQvdGB0YzQutCwKVwiLFxuICAgICAgICAgICAgXCJyb290XCI6IFwiQ2F0ZWdvcnk60KPQutGA0LDRl9C90YHRjNC60LBcIixcbiAgICAgICAgICAgIFwiYWxzb0luXCI6IFwi0YLQsNC60L7QtiDQslwiLCAgIyBVbmNvbmZpcm1lZFxuICAgICAgICAgICAgXCJpbmRlbnRUeXBlXCI6IFwiOlwiLFxuICAgICAgICAgICAgXCJyZXBsYWNlXCI6IFtcIlsgX11cXFxcKNCj0LrRgNCw0ZfQvdGB0YzQutCwXFxcXClcIiwgXCJcIiwgXCJcIl0sXG4gICAgICAgICAgICBcImtlZXBBbHROYW1lXCI6IHRydWUsXG4gICAgICAgICAgICBcInNob3dJbmRpY2VzXCI6IHRydWUsXG4gICAgICAgICAgICBcInJpZ2h0VG9MZWZ0XCI6IGZhbHNlXG4gICAgICAgIH0sXG4gICAgICAgIFwiemgtaGFuc1wiOiB7XG4gICAgICAgICAgICBcInBhZ2VcIjogXCJUYWJsZSBvZiBjb250ZW50cyAo566A5L2T5Lit5paHKVwiLFxuICAgICAgICAgICAgXCJyb290XCI6IFwiQ2F0ZWdvcnk6566A5L2T5Lit5paHXCIsXG4gICAgICAgICAgICBcImFsc29JblwiOiBcIuWQjOaXtui/mOWxnuS6jlwiLFxuICAgICAgICAgICAgXCJpbmRlbnRUeXBlXCI6IFwiOlwiLFxuICAgICAgICAgICAgXCJyZXBsYWNlXCI6IFtcIlsgX11cXFxcKOeugOS9k+S4reaWh1xcXFwpXCIsIFwiXCIsIFwiXCJdLFxuICAgICAgICAgICAgXCJrZWVwQWx0TmFtZVwiOiB0cnVlLFxuICAgICAgICAgICAgXCJzaG93SW5kaWNlc1wiOiB0cnVlLFxuICAgICAgICAgICAgXCJyaWdodFRvTGVmdFwiOiBmYWxzZVxuICAgICAgICB9LFxuICAgICAgICBcInpoLWhhbnRcIjoge1xuICAgICAgICAgICAgXCJwYWdlXCI6IFwiVGFibGUgb2YgY29udGVudHMgKOato+mrlOS4reaWhylcIixcbiAgICAgICAgICAgIFwicm9vdFwiOiBcIkNhdGVnb3J5Ouato+mrlOS4reaWh1wiLFxuICAgICAgICAgICAgXCJhbHNvSW5cIjogXCLpgoTlnKhcIiwgICMgVW5jb25maXJtZWRcbiAgICAgICAgICAgIFwiaW5kZW50VHlwZVwiOiBcIjpcIixcbiAgICAgICAgICAgIFwicmVwbGFjZVwiOiBbXCJbIF9dXFxcXCjmraPpq5TkuK3mlodcXFxcKVwiLCBcIlwiLCBcIlwiXSxcbiAgICAgICAgICAgIFwia2VlcEFsdE5hbWVcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwic2hvd0luZGljZXNcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwicmlnaHRUb0xlZnRcIjogZmFsc2VcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldExvY2FsTGFuZ3VhZ2U6IC0+XG4gICAgICAgIHJldHVybiBsYW5ndWFnZXMubG9jYWxcblxuICAgIGdldENhdGVnb3J5TGFuZ3VhZ2VzOiAtPlxuICAgICAgICByZXR1cm4gbGFuZ3VhZ2VzLmNhdGVnb3JpZXNcblxuICAgIGlzQ2F0ZWdvcnlMYW5ndWFnZTogKGxhbmcpIC0+XG4gICAgICAgIHJldHVybiBsYW5ndWFnZXMuY2F0ZWdvcmllcy5pbmRleE9mKGxhbmcpID4gLTFcblxuICAgIGdldEludGVyd2lraUxhbmd1YWdlczogLT5cbiAgICAgICAgcmV0dXJuIGxhbmd1YWdlcy5pbnRlcmxhbmd1YWdlLmV4dGVybmFsLmNvbmNhdChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFuZ3VhZ2VzLmludGVybGFuZ3VhZ2UuaW50ZXJuYWwpXG5cbiAgICBpc0ludGVyd2lraUxhbmd1YWdlOiAobGFuZykgLT5cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0SW50ZXJ3aWtpTGFuZ3VhZ2VzKCkuaW5kZXhPZihsYW5nKSA+IC0xXG5cbiAgICBnZXRJbnRlcm5hbEludGVyd2lraUxhbmd1YWdlczogLT5cbiAgICAgICAgcmV0dXJuIGxhbmd1YWdlcy5pbnRlcmxhbmd1YWdlLmludGVybmFsXG5cbiAgICBpc0ludGVybmFsSW50ZXJ3aWtpTGFuZ3VhZ2U6IChsYW5nKSAtPlxuICAgICAgICByZXR1cm4gbGFuZ3VhZ2VzLmludGVybGFuZ3VhZ2UuaW50ZXJuYWwuaW5kZXhPZihsYW5nKSA+IC0xXG5cbiAgICBnZXRJbnRlcmxhbmd1YWdlVGFnOiAobGFuZ3VhZ2UpIC0+XG4gICAgICAgIHJldHVybiBsYW5ndWFnZXMubmFtZXNbbGFuZ3VhZ2VdLnN1YnRhZ1xuXG4gICAgZGV0ZWN0TGFuZ3VhZ2U6ICh0aXRsZSkgLT5cbiAgICAgICAgbWF0Y2hlcyA9IHRpdGxlLm1hdGNoKC9eKC4rPykoPzpbIF9dXFwoKFteXFwoXSspXFwpKT8kLylcbiAgICAgICAgcHVyZVRpdGxlID0gbWF0Y2hlc1sxXVxuICAgICAgICBkZXRlY3RlZExhbmd1YWdlID0gbWF0Y2hlc1syXVxuXG4gICAgICAgIGlmIG5vdCBkZXRlY3RlZExhbmd1YWdlIG9yIG5vdCBAaXNDYXRlZ29yeUxhbmd1YWdlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXRlY3RlZExhbmd1YWdlKVxuICAgICAgICAgICAgIyBMYW5ndWFnZSBjYXRlZ29yaWVzIGFyZSBleGNlcHRpb25zXG4gICAgICAgICAgICAjIERvbid0IGp1c3QgdXNlIC9eWyBfXSooLis/KVsgX10qJC8gYnV0IHJlcXVpcmUgdGhlIHdob2xlXG4gICAgICAgICAgICAjICAgbmFtZXNwYWNlK3RpdGxlIHRvIGJlIHBhc3NlZCBhcyB0aGUgYXJndW1lbnQgKGkuZS4gaW5jbHVkaW5nXG4gICAgICAgICAgICAjICAgXCJDYXRlZ29yeTpcIilcbiAgICAgICAgICAgIHRlc3RMYW5nQ2F0ID0gbWF0Y2hlc1sxXS5tYXRjaChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC9eWyBfXSpbQ2NdYXRlZ29yeVsgX10qOlsgX10qKC4rPylbIF9dKiQvKVxuICAgICAgICAgICAgaWYgdGVzdExhbmdDYXQgYW5kIEBpc0NhdGVnb3J5TGFuZ3VhZ2UodGVzdExhbmdDYXRbMV0pXG4gICAgICAgICAgICAgICAgZGV0ZWN0ZWRMYW5ndWFnZSA9IHRlc3RMYW5nQ2F0WzFdXG4gICAgICAgICAgICAgICAgcHVyZVRpdGxlID0gbWF0Y2hlc1sxXVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGRldGVjdGVkTGFuZ3VhZ2UgPSB0aGlzLmdldExvY2FsTGFuZ3VhZ2UoKVxuICAgICAgICAgICAgICAgIHB1cmVUaXRsZSA9IG1hdGNoZXNbMF1cblxuICAgICAgICByZXR1cm4gW3B1cmVUaXRsZSwgZGV0ZWN0ZWRMYW5ndWFnZV1cblxuICAgIGZpbmRBbGxJbnRlcmxhbmd1YWdlTGlua3M6IChzb3VyY2UpIC0+XG4gICAgICAgICMgU2VlIGFsc28gQFdNLlBhcnNlci5maW5kSW50ZXJsYW5ndWFnZUxpbmtzISEhXG4gICAgICAgIHJldHVybiBAV00uUGFyc2VyLmZpbmRTcGVjaWFsTGlua3Moc291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRJbnRlcndpa2lMYW5ndWFnZXMoKS5qb2luKFwifFwiKSlcblxuICAgIGZpbmRJbnRlcm5hbEludGVybGFuZ3VhZ2VMaW5rczogKHNvdXJjZSkgLT5cbiAgICAgICAgIyBTZWUgYWxzbyBAV00uUGFyc2VyLmZpbmRJbnRlcmxhbmd1YWdlTGlua3MhISFcbiAgICAgICAgcmV0dXJuIEBXTS5QYXJzZXIuZmluZFNwZWNpYWxMaW5rcyhzb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRJbnRlcm5hbEludGVyd2lraUxhbmd1YWdlcygpLmpvaW4oXCJ8XCIpKVxuXG4gICAgZ2V0VGFibGVPZkNvbnRlbnRzOiAodGFnKSAtPlxuICAgICAgICByZXR1cm4gdGFibGVzT2ZDb250ZW50c1t0YWddXG4iLCIjIFdpa2kgTW9ua2V5IC0gTWVkaWFXaWtpIGJvdCBhbmQgZWRpdG9yLWFzc2lzdGFudCB1c2VyIHNjcmlwdFxuIyBDb3B5cmlnaHQgKEMpIDIwMTEgRGFyaW8gR2lvdmFubmV0dGkgPGRldkBkYXJpb2dpb3Zhbm5ldHRpLm5ldD5cbiNcbiMgVGhpcyBmaWxlIGlzIHBhcnQgb2YgV2lraSBNb25rZXkuXG4jXG4jIFdpa2kgTW9ua2V5IGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiMgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiMgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiMgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbiNcbiMgV2lraSBNb25rZXkgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiMgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiMgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuIyBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuI1xuIyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuIyBhbG9uZyB3aXRoIFdpa2kgTW9ua2V5LiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuXG5Bc3luYyA9IHJlcXVpcmUoJ0BreW5pa29zL21pc2MvZGlzdC9Bc3luYycpXG5cblxuY2xhc3MgbW9kdWxlLmV4cG9ydHNcbiAgICBjb25zdHJ1Y3RvcjogKEBXTSkgLT5cblxuICAgIHJlY3Vyc2VUcmVlOiAocGFyYW1zKSAtPlxuICAgICAgICBwYXJhbXMuY2FsbENoaWxkcmVuID0gQF9yZWN1cnNlVHJlZUNhbGxDaGlsZHJlblxuICAgICAgICBBc3luYy5yZWN1cnNlVHJlZUFzeW5jKHBhcmFtcylcblxuICAgIHJlY3Vyc2VUcmVlQ29udGludWU6IChwYXJhbXMpIC0+XG4gICAgICAgIEFzeW5jLnJlY3Vyc2VUcmVlQXN5bmMocGFyYW1zKVxuXG4gICAgX3JlY3Vyc2VUcmVlQ2FsbENoaWxkcmVuOiAocGFyYW1zKSAtPlxuICAgICAgICBAZ2V0U3ViQ2F0ZWdvcmllcyhwYXJhbXMubm9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBAX3JlY3Vyc2VUcmVlQ2FsbENoaWxkcmVuQ29udGludWUsIHBhcmFtcylcblxuICAgIF9yZWN1cnNlVHJlZUNhbGxDaGlsZHJlbkNvbnRpbnVlOiAoc3ViQ2F0cywgcGFyYW1zKSAtPlxuICAgICAgICBmb3Igc3ViQ2F0IGluIHN1YkNhdHNcbiAgICAgICAgICAgIHBhcmFtcy5jaGlsZHJlbi5wdXNoKHN1YkNhdC50aXRsZSlcbiAgICAgICAgQXN5bmMucmVjdXJzZVRyZWVBc3luYyhwYXJhbXMpXG5cbiAgICBnZXRTdWJDYXRlZ29yaWVzOiAocGFyZW50LCBjYWxsLCBjYWxsQXJncykgLT5cbiAgICAgICAgQF9nZXRNZW1iZXJzKHBhcmVudCwgXCJzdWJjYXRcIiwgY2FsbCwgY2FsbEFyZ3MpXG5cbiAgICBnZXRBbGxNZW1iZXJzOiAocGFyZW50LCBjYWxsLCBjYWxsQXJncykgLT5cbiAgICAgICAgQF9nZXRNZW1iZXJzKHBhcmVudCwgbnVsbCwgY2FsbCwgY2FsbEFyZ3MpXG5cbiAgICBfZ2V0TWVtYmVyczogKG5hbWUsIGNtdHlwZSwgY2FsbCwgY2FsbEFyZ3MpIC0+XG4gICAgICAgIHF1ZXJ5ID1cbiAgICAgICAgICAgIGFjdGlvbjogXCJxdWVyeVwiXG4gICAgICAgICAgICBsaXN0OiBcImNhdGVnb3J5bWVtYmVyc1wiXG4gICAgICAgICAgICBjbXRpdGxlOiBuYW1lXG4gICAgICAgICAgICBjbWxpbWl0OiA1MDBcblxuICAgICAgICBpZiBjbXR5cGVcbiAgICAgICAgICAgIHF1ZXJ5LmNtdHlwZSA9IGNtdHlwZVxuXG4gICAgICAgIEBfZ2V0TWVtYmVyc0NvbnRpbnVlKHF1ZXJ5LCBjYWxsLCBjYWxsQXJncywgW10pXG5cbiAgICBfZ2V0TWVtYmVyc0NvbnRpbnVlOiAocXVlcnksIGNhbGwsIGNhbGxBcmdzLCBtZW1iZXJzKSAtPlxuICAgICAgICBAV00uTVcuY2FsbEFQSUdldChxdWVyeSwgKHJlcywgYXJncykgLT5cbiAgICAgICAgICAgIG1lbWJlcnMgPSBtZW1iZXJzLmNvbmNhdChyZXMucXVlcnkuY2F0ZWdvcnltZW1iZXJzKVxuICAgICAgICAgICAgaWYgcmVzW1wicXVlcnktY29udGludWVcIl1cbiAgICAgICAgICAgICAgICBxdWVyeS5jbWNvbnRpbnVlID0gcmVzW1wicXVlcnktY29udGludWVcIl1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jYXRlZ29yeW1lbWJlcnMuY21jb250aW51ZVxuICAgICAgICAgICAgICAgIEBfZ2V0TWVtYmVyc0NvbnRpbnVlKHF1ZXJ5LCBjYWxsLCBhcmdzLCBtZW1iZXJzKVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGNhbGwobWVtYmVycywgYXJncylcbiAgICAgICAgLFxuICAgICAgICBjYWxsQXJncywgbnVsbClcblxuICAgIGdldFBhcmVudHNBbmRJbmZvOiAobmFtZSwgY2FsbCwgY2FsbEFyZ3MpIC0+XG4gICAgICAgIHF1ZXJ5ID1cbiAgICAgICAgICAgIGFjdGlvbjogXCJxdWVyeVwiXG4gICAgICAgICAgICBwcm9wOiBcImNhdGVnb3JpZXN8Y2F0ZWdvcnlpbmZvXCJcbiAgICAgICAgICAgIHRpdGxlczogbmFtZVxuICAgICAgICAgICAgY2xwcm9wOiBcImhpZGRlblwiXG4gICAgICAgICAgICBjbGxpbWl0OiA1MDBcblxuICAgICAgICBAX2dldFBhcmVudHNBbmRJbmZvQ29udGludWUocXVlcnksIGNhbGwsIGNhbGxBcmdzLCBbXSwgbnVsbClcblxuICAgIF9nZXRQYXJlbnRzQW5kSW5mb0NvbnRpbnVlOiAocXVlcnksIGNhbGwsIGNhbGxBcmdzLCBwYXJlbnRzLCBpbmZvKSAtPlxuICAgICAgICBAV00uTVcuY2FsbEFQSUdldChxdWVyeSwgKHJlcywgYXJncykgLT5cbiAgICAgICAgICAgIHBhZ2UgPSBPYmplY3QudmFsdWVzKHJlcy5xdWVyeS5wYWdlcylbMF1cblxuICAgICAgICAgICAgaWYgcGFnZS5jYXRlZ29yaWVzXG4gICAgICAgICAgICAgICAgcGFyZW50cyA9IHBhcmVudHMuY29uY2F0KHBhZ2UuY2F0ZWdvcmllcylcblxuICAgICAgICAgICAgaWYgcGFnZS5jYXRlZ29yeWluZm9cbiAgICAgICAgICAgICAgICBpbmZvID0gcGFnZS5jYXRlZ29yeWluZm9cblxuICAgICAgICAgICAgaWYgcmVzW1wicXVlcnktY29udGludWVcIl1cbiAgICAgICAgICAgICAgICAjIFJlcXVlc3QgY2F0ZWdvcnlpbmZvIG9ubHkgb25jZVxuICAgICAgICAgICAgICAgIHF1ZXJ5LnByb3AgPSBcImNhdGVnb3JpZXNcIlxuICAgICAgICAgICAgICAgIHF1ZXJ5LmNsY29udGludWUgPSByZXNbXCJxdWVyeS1jb250aW51ZVwiXS5jYXRlZ29yaWVzLmNsY29udGludWVcbiAgICAgICAgICAgICAgICBAX2dldFBhcmVudHNBbmRJbmZvQ29udGludWUocXVlcnksIGNhbGwsIGFyZ3MsIHBhcmVudHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmZvKVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGNhbGwocGFyZW50cywgaW5mbywgYXJncylcbiAgICAgICAgLFxuICAgICAgICBjYWxsQXJncywgbnVsbClcbiIsIiMgV2lraSBNb25rZXkgLSBNZWRpYVdpa2kgYm90IGFuZCBlZGl0b3ItYXNzaXN0YW50IHVzZXIgc2NyaXB0XG4jIENvcHlyaWdodCAoQykgMjAxMSBEYXJpbyBHaW92YW5uZXR0aSA8ZGV2QGRhcmlvZ2lvdmFubmV0dGkubmV0PlxuI1xuIyBUaGlzIGZpbGUgaXMgcGFydCBvZiBXaWtpIE1vbmtleS5cbiNcbiMgV2lraSBNb25rZXkgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuIyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuIyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuIyAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuI1xuIyBXaWtpIE1vbmtleSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuIyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuIyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4jIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4jXG4jIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4jIGFsb25nIHdpdGggV2lraSBNb25rZXkuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG5cblxuY2xhc3MgbW9kdWxlLmV4cG9ydHNcbiAgICBjb25zdHJ1Y3RvcjogKEBXTSkgLT5cblxuICAgIGdldEVuZFRpbWVzdGFtcDogKGNhbGwsIGNhbGxBcmdzKSAtPlxuICAgICAgICB0aXRsZSA9IG13LmNvbmZpZy5nZXQoJ3dnUGFnZU5hbWUnKVxuICAgICAgICBkaWZmID0gbXcuY29uZmlnLmdldCgnd2dEaWZmTmV3SWQnKVxuICAgICAgICBvbGRpZCA9IG13LmNvbmZpZy5nZXQoJ3dnRGlmZk9sZElkJylcblxuICAgICAgICBnaXZlRW5kVGltZXN0YW1wID0gKHBhZ2UsIGlkKSAtPlxuICAgICAgICAgICAgY2FsbChwYWdlLnJldmlzaW9uc1tpZF0udGltZXN0YW1wLCBjYWxsQXJncylcblxuICAgICAgICBzd2l0Y2ggZGlmZlxuICAgICAgICAgICAgd2hlbiAnbmV4dCdcbiAgICAgICAgICAgICAgICBwYXJzID1cbiAgICAgICAgICAgICAgICAgICAgcHJvcDogXCJyZXZpc2lvbnNcIlxuICAgICAgICAgICAgICAgICAgICB0aXRsZXM6IHRpdGxlXG4gICAgICAgICAgICAgICAgICAgIHJ2bGltaXQ6IFwiMlwiXG4gICAgICAgICAgICAgICAgICAgIHJ2cHJvcDogXCJ0aW1lc3RhbXBcIlxuICAgICAgICAgICAgICAgICAgICBydmRpcjogXCJuZXdlclwiXG4gICAgICAgICAgICAgICAgICAgIHJ2c3RhcnRpZDogb2xkaWRcbiAgICAgICAgICAgICAgICBAV00uTVcuY2FsbFF1ZXJ5KHBhcnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnaXZlRW5kVGltZXN0YW1wLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bGwpXG4gICAgICAgICAgICB3aGVuICdwcmV2J1xuICAgICAgICAgICAgICAgIHBhcnMgPVxuICAgICAgICAgICAgICAgICAgICBwcm9wOiBcInJldmlzaW9uc1wiXG4gICAgICAgICAgICAgICAgICAgIHJldmlkczogb2xkaWRcbiAgICAgICAgICAgICAgICAgICAgcnZwcm9wOiBcInRpbWVzdGFtcFwiXG4gICAgICAgICAgICAgICAgQFdNLk1XLmNhbGxRdWVyeShwYXJzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2l2ZUVuZFRpbWVzdGFtcCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudWxsKVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHBhcnMgPVxuICAgICAgICAgICAgICAgICAgICBwcm9wOiBcInJldmlzaW9uc1wiXG4gICAgICAgICAgICAgICAgICAgIHJldmlkczogZGlmZlxuICAgICAgICAgICAgICAgICAgICBydnByb3A6IFwidGltZXN0YW1wXCJcbiAgICAgICAgICAgICAgICBAV00uTVcuY2FsbFF1ZXJ5KHBhcnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnaXZlRW5kVGltZXN0YW1wLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bGwpXG4iLCIjIFdpa2kgTW9ua2V5IC0gTWVkaWFXaWtpIGJvdCBhbmQgZWRpdG9yLWFzc2lzdGFudCB1c2VyIHNjcmlwdFxuIyBDb3B5cmlnaHQgKEMpIDIwMTEgRGFyaW8gR2lvdmFubmV0dGkgPGRldkBkYXJpb2dpb3Zhbm5ldHRpLm5ldD5cbiNcbiMgVGhpcyBmaWxlIGlzIHBhcnQgb2YgV2lraSBNb25rZXkuXG4jXG4jIFdpa2kgTW9ua2V5IGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiMgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiMgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiMgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbiNcbiMgV2lraSBNb25rZXkgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiMgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiMgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuIyBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuI1xuIyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuIyBhbG9uZyB3aXRoIFdpa2kgTW9ua2V5LiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuXG5cbmNsYXNzIG1vZHVsZS5leHBvcnRzXG4gICAgY29uc3RydWN0b3I6IChAV00pIC0+XG5cbiAgICBnZXRUaXRsZTogLT5cbiAgICAgICAgcmV0dXJuIEBXTS5QYXJzZXIuc3F1YXNoQ29udGlndW91c1doaXRlc3BhY2UoXG4gICAgICAgICAgICBtdy5jb25maWcuZ2V0KCd3Z1BhZ2VOYW1lJykpXG5cbiAgICBpc1NlY3Rpb246IC0+XG4gICAgICAgIGlmICQoJ1tuYW1lPXdwU2VjdGlvbl0nKS5lcSgwKS52YWwoKVxuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgcmV0dXJuIGZhbHNlXG5cbiAgICByZWFkU291cmNlOiAtPlxuICAgICAgICByZXR1cm4gJCgnI3dwVGV4dGJveDEnKS52YWwoKVxuXG4gICAgd3JpdGVTb3VyY2U6ICh0ZXh0KSAtPlxuICAgICAgICAkKCcjd3BUZXh0Ym94MScpLnZhbCh0ZXh0KVxuXG4gICAgcmVhZFN1bW1hcnk6IC0+XG4gICAgICAgIHJldHVybiAkKCcjd3BTdW1tYXJ5JykudmFsKClcblxuICAgIHdyaXRlU3VtbWFyeTogKHRleHQpIC0+XG4gICAgICAgICQoJyN3cFN1bW1hcnknKS52YWwodGV4dClcblxuICAgIGFwcGVuZFRvU3VtbWFyeTogKHRleHQpIC0+XG4gICAgICAgICQoJyN3cFN1bW1hcnknKS52YWwoQHJlYWRTdW1tYXJ5KCkgKyB0ZXh0KVxuIiwiIyBXaWtpIE1vbmtleSAtIE1lZGlhV2lraSBib3QgYW5kIGVkaXRvci1hc3Npc3RhbnQgdXNlciBzY3JpcHRcbiMgQ29weXJpZ2h0IChDKSAyMDExIERhcmlvIEdpb3Zhbm5ldHRpIDxkZXZAZGFyaW9naW92YW5uZXR0aS5uZXQ+XG4jXG4jIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFdpa2kgTW9ua2V5LlxuI1xuIyBXaWtpIE1vbmtleSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4jIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4jIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4jIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4jXG4jIFdpa2kgTW9ua2V5IGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4jIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4jIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiMgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbiNcbiMgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiMgYWxvbmcgd2l0aCBXaWtpIE1vbmtleS4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cblxuQXBwID0gcmVxdWlyZSgnLi4vYXBwJylcblxuXG5jbGFzcyBtb2R1bGUuZXhwb3J0c1xuICAgIGNvbnN0cnVjdG9yOiAoQFdNKSAtPlxuXG4gICAgcGFyc2VMaW5rczogKHN1cHBvcnRlZExhbmdzLCBzb3VyY2UsIGl3bWFwKSA9PlxuICAgICAgICBwYXJzZWRMaW5rcyA9IEBXTS5QYXJzZXIuZmluZFNwZWNpYWxMaW5rcyhcbiAgICAgICAgICAgIHNvdXJjZSxcbiAgICAgICAgICAgIHN1cHBvcnRlZExhbmdzLmpvaW4oXCJ8XCIpXG4gICAgICAgIClcblxuICAgICAgICBsYW5nbGlua3MgPSBbXVxuICAgICAgICBmb3IgbGluayBpbiBwYXJzZWRMaW5rc1xuICAgICAgICAgICAgIyBEbyBub3Qgc3RvcmUgdGhlIHRhZyBsb3dlcmNhc2VkLCBzaW5jZSBpdCBzaG91bGQgYmUga2VwdCBhc1xuICAgICAgICAgICAgIyBvcmlnaW5hbFxuICAgICAgICAgICAgbHRhZyA9IGxpbmsubmFtZXNwYWNlXG4gICAgICAgICAgICBsdGl0bGUgPSBsaW5rLnRpdGxlICsgKGlmIGxpbmsuZnJhZ21lbnQgdGhlbiAoXCIjXCIgKyBsaW5rLmZyYWdtZW50KSBlbHNlIFwiXCIpXG4gICAgICAgICAgICBmb3IgaXcgaW4gaXdtYXBcbiAgICAgICAgICAgICAgICBpZiBpdy5wcmVmaXgudG9Mb3dlckNhc2UoKSA9PSBsdGFnLnRvTG93ZXJDYXNlKClcbiAgICAgICAgICAgICAgICAgICAgIyBGaXggdGhlIHVybCBfYmVmb3JlXyByZXBsYWNpbmcgJDFcbiAgICAgICAgICAgICAgICAgICAgbHVybCA9IEBXTS5NVy5maXhJbnRlcndpa2lVcmwoaXcudXJsKVxuICAgICAgICAgICAgICAgICAgICBsdXJsID0gbHVybC5yZXBsYWNlKFwiJDFcIiwgZW5jb2RlVVJJQ29tcG9uZW50KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBAV00uUGFyc2VyLnNxdWFzaENvbnRpZ3VvdXNXaGl0ZXNwYWNlKGx0aXRsZSkpKVxuICAgICAgICAgICAgICAgICAgICBicmVha1xuXG4gICAgICAgICAgICBsYW5nbGlua3MucHVzaCh7bGFuZzogbHRhZywgdGl0bGU6IGx0aXRsZSwgdXJsOiBsdXJsLCBpbmRleDogbGluay5pbmRleCwgbGVuZ3RoOiBsaW5rLmxlbmd0aH0pXG5cbiAgICAgICAgcmV0dXJuIGxhbmdsaW5rc1xuXG4gICAgcXVlcnlMaW5rczogKHF1ZXJ5VGl0bGUsIHRpdGxlLCBzdXBwb3J0ZWRMYW5ncyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaXRlbGlzdCwgZmlyc3RQYWdlLCBjYWxsRW5kLCBjYWxsQXJncykgPT5cbiAgICAgICAgcXVlcnkgPVxuICAgICAgICAgICAgYWN0aW9uOiBcInF1ZXJ5XCJcbiAgICAgICAgICAgIHByb3A6IFwiaW5mb3xyZXZpc2lvbnNcIlxuICAgICAgICAgICAgcnZwcm9wOiBcImNvbnRlbnR8dGltZXN0YW1wXCJcbiAgICAgICAgICAgIGludG9rZW46IFwiZWRpdFwiXG4gICAgICAgICAgICB0aXRsZXM6IHF1ZXJ5VGl0bGVcbiAgICAgICAgICAgIG1ldGE6IFwic2l0ZWluZm9cIlxuICAgICAgICAgICAgc2lwcm9wOiBcImludGVyd2lraW1hcFwiXG4gICAgICAgICAgICBzaWZpbHRlcml3OiBcImxvY2FsXCJcblxuICAgICAgICAjIFdoZW4gY2FsbGVkIGJ5IHRoZSBib3QsIGlmIHRoZSBzdGFydCBwYWdlIGlzIGEgcmVkaXJlY3QgaXRzZWxmLCBpdFxuICAgICAgICAjIHNob3VkbG4ndCBiZSByZXNvbHZlZFxuICAgICAgICBpZiBub3QgZmlyc3RQYWdlXG4gICAgICAgICAgICBxdWVyeS5yZWRpcmVjdHMgPSBcIjFcIlxuXG4gICAgICAgIEBXTS5NVy5jYWxsQVBJR2V0KFxuICAgICAgICAgICAgcXVlcnksXG4gICAgICAgICAgICAocmVzLCBhcmdzKSA9PlxuICAgICAgICAgICAgICAgIGlmIHJlcy5xdWVyeS5wYWdlc1xuICAgICAgICAgICAgICAgICAgICBwYWdlID0gT2JqZWN0LnZhbHVlcyhyZXMucXVlcnkucGFnZXMpWzBdXG4gICAgICAgICAgICAgICAgICAgIGlmIHBhZ2UucmV2aXNpb25zXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvciA9IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZSA9IHBhZ2UucmV2aXNpb25zWzBdW1wiKlwiXVxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZXN0YW1wID0gcGFnZS5yZXZpc2lvbnNbMF0udGltZXN0YW1wXG4gICAgICAgICAgICAgICAgICAgICAgICBlZGl0dG9rZW4gPSBwYWdlLmVkaXR0b2tlblxuICAgICAgICAgICAgICAgICAgICAgICAgaXdtYXAgPSByZXMucXVlcnkuaW50ZXJ3aWtpbWFwXG4gICAgICAgICAgICAgICAgICAgICAgICBsYW5nbGlua3MgPSBAV00uSW50ZXJsYW5ndWFnZS5wYXJzZUxpbmtzKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VwcG9ydGVkTGFuZ3MsIHNvdXJjZSwgaXdtYXApXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICMgVGhlIHJlcXVlc3RlZCBhcnRpY2xlIGRvZXNuJ3QgZXhpc3RcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yID0gJ25vbmV4aXN0aW5nJ1xuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlID0gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcCA9IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBlZGl0dG9rZW4gPSBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgaXdtYXAgPSByZXMucXVlcnkuaW50ZXJ3aWtpbWFwXG4gICAgICAgICAgICAgICAgICAgICAgICBsYW5nbGlua3MgPSBmYWxzZVxuXG4gICAgICAgICAgICAgICAgZWxzZSBpZiByZXMucXVlcnkucmVkaXJlY3RzXG4gICAgICAgICAgICAgICAgICAgICMgVGhlIHJlcXVlc3RlZCBhcnRpY2xlIGlzIGFuIHVuc29sdmVkIHJlZGlyZWN0XG4gICAgICAgICAgICAgICAgICAgICMgKHJlZGlyZWN0IG92ZXIgaW50ZXJ3aWtpIGxpbms/KVxuICAgICAgICAgICAgICAgICAgICBlcnJvciA9ICd1bnNvbHZlZHJlZGlyZWN0J1xuICAgICAgICAgICAgICAgICAgICBzb3VyY2UgPSBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXAgPSBmYWxzZVxuICAgICAgICAgICAgICAgICAgICBlZGl0dG9rZW4gPSBmYWxzZVxuICAgICAgICAgICAgICAgICAgICBpd21hcCA9IHJlcy5xdWVyeS5pbnRlcndpa2ltYXBcbiAgICAgICAgICAgICAgICAgICAgbGFuZ2xpbmtzID0gZmFsc2VcblxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgIyBVbmtub3duIGVycm9yXG4gICAgICAgICAgICAgICAgICAgIGVycm9yID0gJ3Vua25vd24nXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZSA9IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcCA9IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIGVkaXR0b2tlbiA9IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIGl3bWFwID0gcmVzLnF1ZXJ5LmludGVyd2lraW1hcFxuICAgICAgICAgICAgICAgICAgICBsYW5nbGlua3MgPSBmYWxzZVxuXG4gICAgICAgICAgICAgICAgY2FsbEVuZChcbiAgICAgICAgICAgICAgICAgICAgdGl0bGUsXG4gICAgICAgICAgICAgICAgICAgIHN1cHBvcnRlZExhbmdzLFxuICAgICAgICAgICAgICAgICAgICB3aGl0ZWxpc3QsXG4gICAgICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgICAgICAgICAgbGFuZ2xpbmtzLFxuICAgICAgICAgICAgICAgICAgICBpd21hcCxcbiAgICAgICAgICAgICAgICAgICAgc291cmNlLFxuICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXAsXG4gICAgICAgICAgICAgICAgICAgIGVkaXR0b2tlbixcbiAgICAgICAgICAgICAgICAgICAgYXJnc1xuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICxcbiAgICAgICAgICAgIGNhbGxBcmdzLFxuICAgICAgICAgICAgKGFyZ3MpIC0+XG4gICAgICAgICAgICAgICAgY2FsbEVuZChcbiAgICAgICAgICAgICAgICAgICAgdGl0bGUsXG4gICAgICAgICAgICAgICAgICAgIHN1cHBvcnRlZExhbmdzLFxuICAgICAgICAgICAgICAgICAgICB3aGl0ZWxpc3QsXG4gICAgICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAndW5rbm93bicsXG4gICAgICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgYXJnc1xuICAgICAgICAgICAgICAgIClcbiAgICAgICAgKVxuXG4gICAgY3JlYXRlTmV3TGluazogKG9yaWdUYWcsIHRpdGxlLCB1cmwpID0+XG4gICAgICAgIHJldHVybiB7b3JpZ1RhZzogb3JpZ1RhZywgdGl0bGU6IHRpdGxlLCB1cmw6IHVybH1cblxuICAgIGNyZWF0ZVZpc2l0ZWRMaW5rOiAob3JpZ1RhZywgdGl0bGUsIHVybCwgaXdtYXAsIHNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcCwgZWRpdHRva2VuLCBsaW5rcykgPT5cbiAgICAgICAgZW50cnkgPVxuICAgICAgICAgICAgb3JpZ1RhZzogb3JpZ1RhZ1xuICAgICAgICAgICAgdGl0bGU6IHRpdGxlXG4gICAgICAgICAgICB1cmw6IHVybFxuICAgICAgICAgICAgaXdtYXA6IGl3bWFwXG4gICAgICAgICAgICBzb3VyY2U6IHNvdXJjZVxuICAgICAgICAgICAgdGltZXN0YW1wOiB0aW1lc3RhbXBcbiAgICAgICAgICAgIGVkaXR0b2tlbjogZWRpdHRva2VuXG4gICAgICAgICAgICBsaW5rczogW11cblxuICAgICAgICBmb3IgbGluayBpbiBsaW5rc1xuICAgICAgICAgICAgZW50cnkubGlua3MucHVzaChsaW5rKVxuXG4gICAgICAgIHJldHVybiBlbnRyeVxuXG4gICAgY29sbGVjdExpbmtzOiAodmlzaXRlZGxpbmtzLCBuZXdsaW5rcywgc3VwcG9ydGVkTGFuZ3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGl0ZWxpc3QsIGZpcnN0UGFnZSwgY2FsbEVuZCwgY2FsbEFyZ3MpID0+XG4gICAgICAgIGZvciB0YWcgb2YgbmV3bGlua3NcbiAgICAgICAgICAgIGxpbmsgPSBuZXdsaW5rc1t0YWddXG4gICAgICAgICAgICBicmVha1xuXG4gICAgICAgIGlmIGxpbmtcbiAgICAgICAgICAgIGRlbGV0ZSBuZXdsaW5rc1t0YWddXG5cbiAgICAgICAgICAgIHVybCA9IGxpbmsudXJsXG5cbiAgICAgICAgICAgICMgRG9uJ3QgdXNlIEBXTS5NVy5nZXRUaXRsZUZyb21XaWtpVXJsKGRlY29kZVVSSSh1cmwpKSBiZWNhdXNlXG4gICAgICAgICAgICAjIGl0IHdvdWxkbid0IGRlY29kZSBzb21lIGNoYXJhY3RlcnMgbGlrZSBjb2xvbnMsIHdoaWNoIGFyZVxuICAgICAgICAgICAgIyByZXF1aXJlZCB0byBiZSBkZWNvZGVkIGluc3RlYWQgd2hlbiBtYWtpbmcgYW4gQVBJIGNhbGxcbiAgICAgICAgICAgIHF1ZXJ5VGl0bGUgPSBkZWNvZGVVUklDb21wb25lbnQoQFdNLk1XLmdldFRpdGxlRnJvbVdpa2lVcmwodXJsKSlcblxuICAgICAgICAgICAgaWYgcXVlcnlUaXRsZVxuICAgICAgICAgICAgICAgIG9yaWdUYWcgPSBsaW5rLm9yaWdUYWdcbiAgICAgICAgICAgICAgICB0aXRsZSA9IGxpbmsudGl0bGVcblxuICAgICAgICAgICAgICAgICMgSWYgdGhpcyBpcyB0aGUgZmlyc3QgcHJvY2Vzc2VkIHBhZ2UsIGl0J3MgbG9jYWwgZm9yIHN1cmUsIHNvXG4gICAgICAgICAgICAgICAgIyAgIHF1ZXJ5IGl0cyBsaW5rcyBpbiBhbnkgY2FzZS4gVGhpcyBlLmcuIHByZXZlbnRzIHRoZVxuICAgICAgICAgICAgICAgICMgICBhcHBsaWNhdGlvbiBmcm9tIGNyYXNoaW5nIGluIGNhc2UgdGhlIGxvY2FsIHBhZ2UgaXMgaW4gYVxuICAgICAgICAgICAgICAgICMgICBsYW5ndWFnZSB3aG9zZSBsYW5ndWFnZSB0YWcgaXMgbm90IGluIHRoZSB3aGl0ZSBsaXN0XG4gICAgICAgICAgICAgICAgIyB0YWcgaXMgYWxyZWFkeSBsb3dlci1jYXNlZFxuICAgICAgICAgICAgICAgIGlmIGZpcnN0UGFnZSBvciB3aGl0ZWxpc3QuaW5kZXhPZih0YWcpID4gLTFcbiAgICAgICAgICAgICAgICAgICAgQXBwLmxvZy5sb2dJbmZvKFwiUmVhZGluZyBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFwcC5sb2cubGlua1RvUGFnZSh1cmwsIFwiW1tcIiArIG9yaWdUYWcgKyBcIjpcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlICsgXCJdXVwiKSArIFwiIC4uLlwiKVxuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucXVlcnlMaW5rcyhcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5VGl0bGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1cHBvcnRlZExhbmdzLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpdGVsaXN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3RQYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgQFdNLkludGVybGFuZ3VhZ2UuX2NvbGxlY3RMaW5rc0NvbnRpbnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgW3VybCwgdGFnLCBvcmlnVGFnLCB2aXNpdGVkbGlua3MsIG5ld2xpbmtzLCBjYWxsRW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsQXJnc11cbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgQFdNLkludGVybGFuZ3VhZ2UuX2NvbGxlY3RMaW5rc0NvbnRpbnVlKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdXBwb3J0ZWRMYW5ncyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaXRlbGlzdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0UGFnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdub3RpbndoaXRlbGlzdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgW3VybCwgdGFnLCBvcmlnVGFnLCB2aXNpdGVkbGlua3MsIG5ld2xpbmtzLCBjYWxsRW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsQXJnc11cbiAgICAgICAgICAgICAgICAgICAgKVxuXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgQXBwLmxvZy5sb2dXYXJuaW5nKFwiQ2Fubm90IGV4dHJhY3QgdGhlIHBhZ2UgdGl0bGUgZnJvbSBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQXBwLmxvZy5saW5rVG9QYWdlKHVybCwgZGVjb2RlVVJJKHVybCkpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIiwgcmVtb3ZpbmcgaXQgaWYgaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YXMgbGlua2VkIGZyb20gdGhlIHByb2Nlc3NlZCBhcnRpY2xlXCIpXG4gICAgICAgICAgICAgICAgQFdNLkludGVybGFuZ3VhZ2UuY29sbGVjdExpbmtzKFxuICAgICAgICAgICAgICAgICAgICB2aXNpdGVkbGlua3MsXG4gICAgICAgICAgICAgICAgICAgIG5ld2xpbmtzLFxuICAgICAgICAgICAgICAgICAgICBzdXBwb3J0ZWRMYW5ncyxcbiAgICAgICAgICAgICAgICAgICAgd2hpdGVsaXN0LFxuICAgICAgICAgICAgICAgICAgICBmaXJzdFBhZ2UsXG4gICAgICAgICAgICAgICAgICAgIGNhbGxFbmQsXG4gICAgICAgICAgICAgICAgICAgIGNhbGxBcmdzXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICBjYWxsRW5kKHZpc2l0ZWRsaW5rcywgY2FsbEFyZ3MpXG5cbiAgICBfY29sbGVjdExpbmtzQ29udGludWU6ICh0aXRsZSwgc3VwcG9ydGVkTGFuZ3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaXRlbGlzdCwgZmlyc3RQYWdlLCBlcnJvciwgbGFuZ2xpbmtzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpd21hcCwgc291cmNlLCB0aW1lc3RhbXAsIGVkaXR0b2tlbiwgYXJncykgPT5cbiAgICAgICAgdXJsID0gYXJnc1swXVxuICAgICAgICB0YWcgPSBhcmdzWzFdXG4gICAgICAgIG9yaWdUYWcgPSBhcmdzWzJdXG4gICAgICAgIHZpc2l0ZWRsaW5rcyA9IGFyZ3NbM11cbiAgICAgICAgbmV3bGlua3MgPSBhcmdzWzRdXG4gICAgICAgIGNhbGxFbmQgPSBhcmdzWzVdXG4gICAgICAgIGNhbGxBcmdzID0gYXJnc1s2XVxuXG4gICAgICAgIGlmIGVycm9yID09ICdub25leGlzdGluZydcbiAgICAgICAgICAgIEFwcC5sb2cubG9nV2FybmluZyhBcHAubG9nLmxpbmtUb1BhZ2UodXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIltbXCIgKyBvcmlnVGFnICsgXCI6XCIgKyB0aXRsZSArIFwiXV1cIikgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIiBzZWVtcyB0byBwb2ludFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byBhIG5vbi1leGlzdGluZyBhcnRpY2xlOiByZW1vdmluZyBpdCBpZlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdCB3YXMgbGlua2VkIGZyb20gdGhlIHByb2Nlc3NlZCBhcnRpY2xlXCIpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGlmIGVycm9yID09ICd1bnNvbHZlZHJlZGlyZWN0J1xuICAgICAgICAgICAgICAgIEFwcC5sb2cubG9nV2FybmluZyhBcHAubG9nLmxpbmtUb1BhZ2UodXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIltbXCIgKyBvcmlnVGFnICsgXCI6XCIgKyB0aXRsZSArIFwiXV1cIikgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIiB3aWxsIG5vdCBiZSBjaGVja2VkIGJlY2F1c2UgaXQgcG9pbnRzIHRvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuIGV4dGVybmFsIHJlZGlyZWN0XCIpXG4gICAgICAgICAgICBlbHNlIGlmIGVycm9yID09ICd1bmtub3duJ1xuICAgICAgICAgICAgICAgIEFwcC5sb2cubG9nV2FybmluZyhBcHAubG9nLmxpbmtUb1BhZ2UodXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIltbXCIgKyBvcmlnVGFnICsgXCI6XCIgKyB0aXRsZSArIFwiXV1cIikgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIiB3aWxsIG5vdCBiZSBjaGVja2VkIGJlY2F1c2Ugb2YgYW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5zcGVjaWZpZWQgcHJvYmxlbVwiKVxuICAgICAgICAgICAgZWxzZSBpZiBlcnJvciA9PSAnbm90aW53aGl0ZWxpc3QnXG4gICAgICAgICAgICAgICAgQXBwLmxvZy5sb2dXYXJuaW5nKEFwcC5sb2cubGlua1RvUGFnZSh1cmwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiW1tcIiArIG9yaWdUYWcgKyBcIjpcIiArIHRpdGxlICsgXCJdXVwiKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiIHdpbGwgbm90IGJlIGNoZWNrZWQgYmVjYXVzZSBcIiArIHRhZyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiIGlzIG5vdCBpbmNsdWRlZCBpbiB0aGUgd2hpdGVsaXN0IGRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW4gdGhlIGNvbmZpZ3VyYXRpb25cIilcblxuICAgICAgICAgICAgdmlzaXRlZGxpbmtzW3RhZ10gPSBAV00uSW50ZXJsYW5ndWFnZS5jcmVhdGVWaXNpdGVkTGluayhvcmlnVGFnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZSwgdXJsLCBpd21hcCwgc291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXAsIGVkaXR0b2tlbiwgbGFuZ2xpbmtzKVxuXG4gICAgICAgICAgICBmb3IgbGluayBpbiBsYW5nbGlua3NcbiAgICAgICAgICAgICAgICBubGluayA9IG5ld2xpbmtzW2xpbmsubGFuZy50b0xvd2VyQ2FzZSgpXVxuICAgICAgICAgICAgICAgIHZsaW5rID0gdmlzaXRlZGxpbmtzW2xpbmsubGFuZy50b0xvd2VyQ2FzZSgpXVxuXG4gICAgICAgICAgICAgICAgaWYgbm90IHZsaW5rIGFuZCBub3QgbmxpbmtcbiAgICAgICAgICAgICAgICAgICAgbmV3bGlua3NbbGluay5sYW5nLnRvTG93ZXJDYXNlKCldID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEBXTS5JbnRlcmxhbmd1YWdlLmNyZWF0ZU5ld0xpbmsobGluay5sYW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rLnRpdGxlLCBsaW5rLnVybClcbiAgICAgICAgICAgICAgICBlbHNlIGlmIHZsaW5rIGFuZCB2bGluay51cmwgIT0gbGluay51cmxcbiAgICAgICAgICAgICAgICAgICAgIyBKdXN0IGlnbm9yZSBhbnkgY29uZmxpY3RpbmcgbGlua3MgYW5kIHdhcm4gdGhlIHVzZXI6XG4gICAgICAgICAgICAgICAgICAgICMgaWYgaXQncyBhIHJlYWwgY29uZmxpY3QsIHRoZSB1c2VyIHdpbGwgaW52ZXN0aWdhdGUgaXQsXG4gICAgICAgICAgICAgICAgICAgICMgb3RoZXJ3aXNlIHRoZSB1c2VyIHdpbGwgaWdub3JlIGl0XG4gICAgICAgICAgICAgICAgICAgIEFwcC5sb2cubG9nV2FybmluZyhcIlBvc3NpYmx5IGNvbmZsaWN0aW5nIGludGVybGFuZ3VhZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmtzOiBcIiArIEFwcC5sb2cubGlua1RvUGFnZShsaW5rLnVybCwgXCJbW1wiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmsubGFuZyArIFwiOlwiICsgbGluay50aXRsZSArIFwiXV1cIikgKyBcIiBhbmQgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgQXBwLmxvZy5saW5rVG9QYWdlKHZsaW5rLnVybCwgXCJbW1wiICsgbGluay5sYW5nICsgXCI6XCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgdmlzaXRlZGxpbmtzW2xpbmsubGFuZy50b0xvd2VyQ2FzZSgpXS50aXRsZSArIFwiXV1cIikpXG5cbiAgICAgICAgICAgICAgICBlbHNlIGlmIG5saW5rIGFuZCBubGluay51cmwgIT0gbGluay51cmxcbiAgICAgICAgICAgICAgICAgICAgIyBKdXN0IGlnbm9yZSBhbnkgY29uZmxpY3RpbmcgbGlua3MgYW5kIHdhcm4gdGhlIHVzZXI6XG4gICAgICAgICAgICAgICAgICAgICMgaWYgaXQncyBhIHJlYWwgY29uZmxpY3QsIHRoZSB1c2VyIHdpbGwgaW52ZXN0aWdhdGUgaXQsXG4gICAgICAgICAgICAgICAgICAgICMgb3RoZXJ3aXNlIHRoZSB1c2VyIHdpbGwgaWdub3JlIGl0XG4gICAgICAgICAgICAgICAgICAgIEFwcC5sb2cubG9nV2FybmluZyhcIlBvc3NpYmx5IGNvbmZsaWN0aW5nIGludGVybGFuZ3VhZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmtzOiBcIiArIEFwcC5sb2cubGlua1RvUGFnZShsaW5rLnVybCwgXCJbW1wiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmsubGFuZyArIFwiOlwiICsgbGluay50aXRsZSArIFwiXV1cIikgKyBcIiBhbmQgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgQXBwLmxvZy5saW5rVG9QYWdlKG5saW5rLnVybCwgXCJbW1wiICsgbGluay5sYW5nICsgXCI6XCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3bGlua3NbbGluay5sYW5nLnRvTG93ZXJDYXNlKCldLnRpdGxlICsgXCJdXVwiKSlcblxuICAgICAgICBAV00uSW50ZXJsYW5ndWFnZS5jb2xsZWN0TGlua3MoXG4gICAgICAgICAgICB2aXNpdGVkbGlua3MsXG4gICAgICAgICAgICBuZXdsaW5rcyxcbiAgICAgICAgICAgIHN1cHBvcnRlZExhbmdzLFxuICAgICAgICAgICAgd2hpdGVsaXN0LFxuICAgICAgICAgICAgZmlyc3RQYWdlLFxuICAgICAgICAgICAgY2FsbEVuZCxcbiAgICAgICAgICAgIGNhbGxBcmdzXG4gICAgICAgIClcblxuICAgIHVwZGF0ZUxpbmtzOiAobGFuZywgdXJsLCBpd21hcCwgc291cmNlLCBvbGRsaW5rcywgbmV3bGlua3MpID0+XG4gICAgICAgIGxhbmcgPSBsYW5nLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbGlua0xpc3QgPSBbXVxuXG4gICAgICAgIGZvciB0YWcgb2YgbmV3bGlua3NcbiAgICAgICAgICAgIGlmIHRhZyAhPSBsYW5nXG4gICAgICAgICAgICAgICAgbGluayA9IG5ld2xpbmtzW3RhZ11cbiAgICAgICAgICAgICAgICB0YWdGb3VuZCA9IGZhbHNlXG5cbiAgICAgICAgICAgICAgICAjIE5ldyBsaW5rcyB0aGF0IHdlcmUgbm90IGluIHRoZSB3aGl0ZSBsaXN0IHdpbGwgaGF2ZSB0aGVcbiAgICAgICAgICAgICAgICAjIFwiaXdtYXBcIiBhdHRyaWJ1dGUgZmFsc2UsIFwidGltZXN0YW1wXCIgYW5kIFwiZWRpdHRva2VuXCIgbnVsbFxuICAgICAgICAgICAgICAgICMgYW5kIFwibGlua3NcIiBhcyBhbiBlbXB0eSBhcnJheVxuICAgICAgICAgICAgICAgICMgTm90ZSB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuICdpd21hcCcgYW5kICdsaW5rLml3bWFwJ1xuICAgICAgICAgICAgICAgIGZvciBpdyBpbiBpd21hcFxuICAgICAgICAgICAgICAgICAgICBpZiBpdy5wcmVmaXgudG9Mb3dlckNhc2UoKSA9PSB0YWcudG9Mb3dlckNhc2UoKVxuICAgICAgICAgICAgICAgICAgICAgICAgbGlua0xpc3QucHVzaChcIltbXCIgKyBsaW5rLm9yaWdUYWcgKyBcIjpcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmsudGl0bGUgKyBcIl1dXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWdGb3VuZCA9IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgICAgICAgICBpZiBub3QgdGFnRm91bmRcbiAgICAgICAgICAgICAgICAgICAgQXBwLmxvZy5sb2dXYXJuaW5nKHRhZyArIFwiIGludGVybGFuZ3VhZ2UgbGlua3MgYXJlIG5vdFxuICAgICAgICAgICAgICAgICAgICAgICAgc3VwcG9ydGVkIGluIFwiICsgQXBwLmxvZy5saW5rVG9QYWdlKHVybCwgXCJbW1wiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmsub3JpZ1RhZyArIFwiOlwiICsgbGluay50aXRsZSArIFwiXV1cIikgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCIgLCBpZ25vcmluZyB0aGVtXCIpXG5cbiAgICAgICAgbGlua0xpc3Quc29ydChcbiAgICAgICAgICAgIChhLCBiKSAtPlxuICAgICAgICAgICAgICAgICMgU29ydGluZyBpcyBjYXNlIHNlbnNpdGl2ZSBieSBkZWZhdWx0XG4gICAgICAgICAgICAgICAgaWYgYS50b0xvd2VyQ2FzZSgpID4gYi50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAxXG4gICAgICAgICAgICAgICAgaWYgYi50b0xvd2VyQ2FzZSgpID4gYS50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtMVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDBcbiAgICAgICAgKVxuXG4gICAgICAgIGNsZWFuVGV4dCA9IFwiXCJcbiAgICAgICAgdGV4dElkID0gMFxuXG4gICAgICAgIGZvciBsaW5rIGluIG9sZGxpbmtzXG4gICAgICAgICAgICBjbGVhblRleHQgKz0gc291cmNlLnN1YnN0cmluZyh0ZXh0SWQsIGxpbmsuaW5kZXgpXG4gICAgICAgICAgICB0ZXh0SWQgPSBsaW5rLmluZGV4ICsgbGluay5sZW5ndGhcblxuICAgICAgICBjbGVhblRleHQgKz0gc291cmNlLnN1YnN0cmluZyh0ZXh0SWQpXG5cbiAgICAgICAgaWYgb2xkbGlua3MubGVuZ3RoXG4gICAgICAgICAgICAjIEluc2VydCB0aGUgbmV3IGxpbmtzIGF0IHRoZSBpbmRleCBvZiB0aGUgZmlyc3QgcHJldmlvdXMgbGlua1xuICAgICAgICAgICAgZmlyc3RMaW5rID0gb2xkbGlua3NbMF0uaW5kZXhcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmlyc3RMaW5rID0gMFxuXG4gICAgICAgIHBhcnRzID0gW11cbiAgICAgICAgIyBEbyBub3QgYWRkIGVtcHR5IHN0cmluZ3MgdG8gcGFydHMsIG90aGVyd2lzZSB3aGVuIGl0J3Mgam9pbmVkXG4gICAgICAgICMgICB1bm5lY2Vzc2FyeSBsaW5lIGJyZWFrcyB3aWxsIGJlIGFkZGVkXG5cbiAgICAgICAgaGVhZCA9IGNsZWFuVGV4dC5zdWJzdHJpbmcoMCwgZmlyc3RMaW5rKS50cmltKClcblxuICAgICAgICBpZiBoZWFkXG4gICAgICAgICAgICBwYXJ0cy5wdXNoKGhlYWQpXG5cbiAgICAgICAgbGlua3MgPSBsaW5rTGlzdC5qb2luKFwiXFxuXCIpXG5cbiAgICAgICAgaWYgbGlua3NcbiAgICAgICAgICAgIHBhcnRzLnB1c2gobGlua3MpXG5cbiAgICAgICAgYm9keSA9IGNsZWFuVGV4dC5zdWJzdHIoZmlyc3RMaW5rKS50cmltKClcblxuICAgICAgICBpZiBib2R5XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKGJvZHkpXG5cbiAgICAgICAgIyBNYWtlIHN1cmUgdG8gcHJlc2VydmUgdGhlIG9yaWdpbmFsIHdoaXRlIHNwYWNlIGF0IHRoZSBlbmQsIG90aGVyd2lzZVxuICAgICAgICAjICAgdGhlIGZpbmFsIChuZXdUZXh0ICE9IHNvdXJjZSkgbWF5IHJldHVybiB0cnVlIGV2ZW4gd2hlbiBubyBhY3R1YWxcbiAgICAgICAgIyAgIGNoYW5nZSBoYXMgYmVlbiBtYWRlXG4gICAgICAgICMgTm90ZSB0aGF0IC9cXHMrJC8gd291bGQgcmV0dXJuIG51bGwgaW4gdGhlIGFic2VuY2Ugb2YgdHJhaWxpbmdcbiAgICAgICAgIyAgIHdoaXRlc3BhY2UsIHNvIGEgZnVydGhlciBjaGVjayBzaG91bGQgYmUgbWFkZSwgd2hpbGUgL1xccyokL1xuICAgICAgICAjICAgc2FmZWx5IHJldHVybnMgYW4gZW1wdHkgc3RyaW5nIGluIHRoYXQgY2FzZVxuICAgICAgICB0cmFpbHdzID0gL1xccyokL1xuXG4gICAgICAgIHJldHVybiBwYXJ0cy5qb2luKFwiXFxuXCIpICsgdHJhaWx3cy5leGVjKHNvdXJjZSlcbiIsIiMgV2lraSBNb25rZXkgLSBNZWRpYVdpa2kgYm90IGFuZCBlZGl0b3ItYXNzaXN0YW50IHVzZXIgc2NyaXB0XG4jIENvcHlyaWdodCAoQykgMjAxMSBEYXJpbyBHaW92YW5uZXR0aSA8ZGV2QGRhcmlvZ2lvdmFubmV0dGkubmV0PlxuI1xuIyBUaGlzIGZpbGUgaXMgcGFydCBvZiBXaWtpIE1vbmtleS5cbiNcbiMgV2lraSBNb25rZXkgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuIyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuIyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuIyAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuI1xuIyBXaWtpIE1vbmtleSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuIyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuIyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4jIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4jXG4jIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4jIGFsb25nIHdpdGggV2lraSBNb25rZXkuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG5cbntBfSA9IHJlcXVpcmUoJy4vbGlicycpXG5BcHAgPSByZXF1aXJlKCcuLi9hcHAnKVxuXG5cbmNsYXNzIG1vZHVsZS5leHBvcnRzXG4gICAgbG9jYWxXaWtpUGF0aHMgPSBudWxsXG4gICAgbG9jYWxXaWtpVXJscyA9IG51bGxcblxuICAgIGNvbnN0cnVjdG9yOiAoQFdNKSAtPlxuICAgICAgICBAYXBpID0gbmV3IG13LkFwaSgpXG5cbiAgICAgICAgd3BhdGhzID0gQF9nZXRXaWtpUGF0aHMobG9jYXRpb24uaHJlZilcbiAgICAgICAgaG9zdG5hbWUgPSB3cGF0aHNbMF1cblxuICAgICAgICBAdXNlckluZm8gPSBudWxsXG5cbiAgICAgICAgbG9jYWxXaWtpUGF0aHMgPSB3cGF0aHNbMV1cbiAgICAgICAgbG9jYWxXaWtpVXJscyA9IHt9XG5cbiAgICAgICAgZm9yIGtleSBvZiBsb2NhbFdpa2lQYXRoc1xuICAgICAgICAgICAgbG9jYWxXaWtpVXJsc1trZXldID0gaG9zdG5hbWUgKyBsb2NhbFdpa2lQYXRoc1trZXldXG5cbiAgICB3aWtpUGF0aHMgPVxuICAgICAgICBrbm93bjpcbiAgICAgICAgICAgIFwiXmh0dHBzPzovL1teXFwuXStcXC53aWtpcGVkaWFcXC5vcmdcIjpcbiAgICAgICAgICAgICAgICBzaG9ydDogXCIvd2lraS9cIlxuICAgICAgICAgICAgICAgIGZ1bGw6IFwiL3cvaW5kZXgucGhwXCJcbiAgICAgICAgICAgICAgICBhcGk6IFwiL3cvYXBpLnBocFwiXG4gICAgICAgICAgICBcIl5odHRwcz86Ly93aWtpXFwuYXJjaGxpbnV4XFwub3JnXCI6XG4gICAgICAgICAgICAgICAgc2hvcnQ6IFwiL2luZGV4LnBocC9cIlxuICAgICAgICAgICAgICAgIGZ1bGw6IFwiL2luZGV4LnBocFwiXG4gICAgICAgICAgICAgICAgYXBpOiBcIi9hcGkucGhwXCJcbiAgICAgICAgICAgIFwiXmh0dHBzPzovL3dpa2lcXC5hcmNobGludXhcXC5kZVwiOlxuICAgICAgICAgICAgICAgIHNob3J0OiBcIi90aXRsZS9cIlxuICAgICAgICAgICAgICAgIGZ1bGw6IFwiL2luZGV4LnBocFwiXG4gICAgICAgICAgICAgICAgYXBpOiBcIi9hcGkucGhwXCJcbiAgICAgICAgICAgIFwiXmh0dHA6Ly93aWtpXFwuYXJjaGxpbnV4XFwuZnJcIjpcbiAgICAgICAgICAgICAgICBzaG9ydDogXCIvXCJcbiAgICAgICAgICAgICAgICBmdWxsOiBcIi9pbmRleC5waHBcIlxuICAgICAgICAgICAgICAgIGFwaTogXCIvYXBpLnBocFwiXG4gICAgICAgICAgICBcIl5odHRwcz86Ly93aWtpXFwuYXJjaGxpbnV4XFwuanBcIjpcbiAgICAgICAgICAgICAgICBzaG9ydDogXCIvaW5kZXgucGhwL1wiXG4gICAgICAgICAgICAgICAgZnVsbDogXCIvaW5kZXgucGhwXCJcbiAgICAgICAgICAgICAgICBhcGk6IFwiL2FwaS5waHBcIlxuICAgICAgICAgICAgXCJeaHR0cDovL3dpa2lcXC5hcmNobGludXhcXC5yb1wiOlxuICAgICAgICAgICAgICAgIHNob3J0OiBcIi9pbmRleC5waHAvXCJcbiAgICAgICAgICAgICAgICBmdWxsOiBcIi9pbmRleC5waHBcIlxuICAgICAgICAgICAgICAgIGFwaTogXCIvYXBpLnBocFwiXG4gICAgICAgICAgICBcIl5odHRwOi8vd2lraVxcLmFyY2hsaW51eFxcLmlyXCI6XG4gICAgICAgICAgICAgICAgc2hvcnQ6IFwiL2luZGV4LnBocC9cIlxuICAgICAgICAgICAgICAgIGZ1bGw6IFwiL2luZGV4LnBocFwiXG4gICAgICAgICAgICAgICAgYXBpOiBcIi9hcGkucGhwXCJcbiAgICAgICAgZGVmYXVsdF86XG4gICAgICAgICAgICBzaG9ydDogXCIvaW5kZXgucGhwP3RpdGxlPVwiXG4gICAgICAgICAgICBmdWxsOiBcIi9pbmRleC5waHBcIlxuICAgICAgICAgICAgYXBpOiBcIi9hcGkucGhwXCJcblxuICAgIGludGVyd2lraUZpeGVzID0gW1xuICAgICAgICBbXCJodHRwczovL3dpa2kuYXJjaGxpbnV4Lm9yZy9pbmRleC5waHAvJDFfKFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImh0dHBzOi8vd2lraS5hcmNobGludXgub3JnL2luZGV4LnBocC8kMSUyMChcIl1cbiAgICBdXG5cbiAgICBfZ2V0V2lraVBhdGhzOiAoaHJlZikgLT5cbiAgICAgICAgIyBJdCdzIG5lY2Vzc2FyeSB0byBrZWVwIHRoaXMgZnVuY3Rpb24gaW4gYSBwcml2YXRlIGF0dHJpYnV0ZSxcbiAgICAgICAgIyBvdGhlcndpc2UgbG9jYWxXaWtpUGF0aHMgYW5kIGxvY2FsV2lraVVybHMgY2Fubm90IGJlIGluaXRpYWxpemVkXG4gICAgICAgIGZvciByIG9mIHdpa2lQYXRocy5rbm93blxuICAgICAgICAgICAgcmUgPSBuZXcgUmVnRXhwKHIsIFwiaVwiKVxuICAgICAgICAgICAgbWF0Y2ggPSByZS5leGVjKGhyZWYpXG5cbiAgICAgICAgICAgIGlmIG1hdGNoXG4gICAgICAgICAgICAgICAgaG9zdG5hbWUgPSBtYXRjaFswXVxuICAgICAgICAgICAgICAgIHBhdGhzID0ge31cblxuICAgICAgICAgICAgICAgIGZvciBwIG9mIHdpa2lQYXRocy5rbm93bltyXVxuICAgICAgICAgICAgICAgICAgICBwYXRoc1twXSA9IHdpa2lQYXRocy5rbm93bltyXVtwXVxuXG4gICAgICAgICAgICAgICAgYnJlYWtcblxuICAgICAgICBpZiBub3QgcGF0aHNcbiAgICAgICAgICAgIHVyaSA9IG5ldyBtdy5VcmkoaHJlZilcbiAgICAgICAgICAgIGhvc3RuYW1lID0gdXJpLmhvc3RcbiAgICAgICAgICAgIHBhdGhzID0ge31cblxuICAgICAgICAgICAgZm9yIHAgb2Ygd2lraVBhdGhzLmRlZmF1bHRfXG4gICAgICAgICAgICAgICAgcGF0aHNbcF0gPSB3aWtpUGF0aHMuZGVmYXVsdF9bcF1cblxuICAgICAgICByZXR1cm4gW2hvc3RuYW1lLCBwYXRoc11cblxuICAgIGdldFdpa2lQYXRoczogKGhyZWYpIC0+XG4gICAgICAgIGlmIGhyZWZcbiAgICAgICAgICAgIHJldHVybiBAX2dldFdpa2lQYXRocyhocmVmKVsxXVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gbG9jYWxXaWtpUGF0aHNcblxuICAgIGxpbmtBcnRpY2xlOiAocGFnZSwgbGFiZWwpIC0+XG4gICAgICAgIHJldHVybiBBKHtocmVmOiBtdy51dGlsLmdldFVybChwYWdlKX0sIGxhYmVsIG9yIHBhZ2UpXG5cbiAgICBnZXRXaWtpVXJsczogKGhyZWYpIC0+XG4gICAgICAgIGlmIGhyZWZcbiAgICAgICAgICAgIHdwYXRocyA9IEBfZ2V0V2lraVBhdGhzKGhyZWYpXG4gICAgICAgICAgICBob3N0bmFtZSA9IHdwYXRoc1swXVxuICAgICAgICAgICAgcGF0aHMgPSB3cGF0aHNbMV1cblxuICAgICAgICAgICAgdXJscyA9IHt9XG5cbiAgICAgICAgICAgIGZvciBrZXkgb2YgcGF0aHNcbiAgICAgICAgICAgICAgICB1cmxzW2tleV0gPSBob3N0bmFtZSArIHBhdGhzW2tleV1cblxuICAgICAgICAgICAgcmV0dXJuIHVybHNcblxuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gbG9jYWxXaWtpVXJsc1xuXG4gICAgZ2V0VGl0bGVGcm9tV2lraVVybDogKHVybCkgLT5cbiAgICAgICAgdXJpID0gbmV3IG13LlVyaSh1cmwpXG4gICAgICAgIHRpdGxlID0gdXJpLnF1ZXJ5LnRpdGxlXG5cbiAgICAgICAgIyBUZXN0IHRoaXMgKmJlZm9yZSogdGhlIHNob3J0IHBhdGhzLCBpbiBmYWN0IGEgc2hvcnQgcGF0aCBtYXkganVzdCBiZVxuICAgICAgICAjIHRoZSBmdWxsIG9uZSB3aXRoIHRoZSBcInRpdGxlXCIgcGFyYW1ldGVyIHByZS1hZGRlZFxuICAgICAgICBpZiBub3QgdGl0bGVcbiAgICAgICAgICAgIHBhdGhuYW1lID0gdXJpLnBhdGhcblxuICAgICAgICAgICAgZm9yIHIgb2Ygd2lraVBhdGhzLmtub3duXG4gICAgICAgICAgICAgICAgcmUgPSBuZXcgUmVnRXhwKHIsIFwiaVwiKVxuICAgICAgICAgICAgICAgIG1hdGNoID0gcmUuZXhlYyh1cmwpXG5cbiAgICAgICAgICAgICAgICBpZiBtYXRjaFxuICAgICAgICAgICAgICAgICAgICBpZiBwYXRobmFtZS5pbmRleE9mKHdpa2lQYXRocy5rbm93bltyXS5zaG9ydCkgPT0gMFxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGUgPSBwYXRobmFtZS5zdWJzdHIod2lraVBhdGhzLmtub3duW3JdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc2hvcnQubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZSA9IGZhbHNlXG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcblxuICAgICAgICAgICAgaWYgbm90IHRpdGxlXG4gICAgICAgICAgICAgICAgaWYgcGF0aG5hbWUuaW5kZXhPZih3aWtpUGF0aHMuZGVmYXVsdF8uc2hvcnQpID09IDBcbiAgICAgICAgICAgICAgICAgICAgdGl0bGUgPSBwYXRobmFtZS5zdWJzdHIod2lraVBhdGhzLmRlZmF1bHRfLnNob3J0Lmxlbmd0aClcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlID0gZmFsc2VcblxuICAgICAgICByZXR1cm4gdGl0bGVcblxuICAgIGZhaWxlZFF1ZXJ5RXJyb3I6ICh1cmwpIC0+XG4gICAgICAgIGlmIHVybFxuICAgICAgICAgICAgcmV0dXJuIFwiRmFpbGVkIHF1ZXJ5OiAje0FwcC5sb2cubGlua1RvUGFnZSh1cmwsIHVybCl9XCJcbiAgICAgICAgcmV0dXJuIFwiRmFpbGVkIHF1ZXJ5XCJcblxuICAgIGNhbGxBUElHZXQ6IChwYXJhbXMsIGNhbGwsIGNhbGxBcmdzLCBjYWxsRXJyb3IpIC0+XG4gICAgICAgIHBhcmFtcy5mb3JtYXQgPSBcImpzb25cIlxuXG4gICAgICAgIHJldHVybiBAYXBpLmdldChwYXJhbXMpXG4gICAgICAgIC5kb25lKChkYXRhLCB0ZXh0U3RhdHVzLCBqcVhIUikgPT5cbiAgICAgICAgICAgIGlmIGNhbGxcbiAgICAgICAgICAgICAgICBjYWxsKGRhdGEsIGNhbGxBcmdzKVxuICAgICAgICApLmZhaWwoKGpxWEhSLCB0ZXh0U3RhdHVzLCBlcnJvclRocm93bikgPT5cbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoanFYSFIsIHRleHRTdGF0dXMsIGVycm9yVGhyb3duKVxuICAgICAgICAgICAgQXBwLmxvZy5sb2dFcnJvcihAZmFpbGVkUXVlcnlFcnJvcigpKVxuICAgICAgICAgICAgaWYgY29uZmlybShcIldpa2kgTW9ua2V5IGVycm9yOiBGYWlsZWQgcXVlcnlcXG5cXG5EbyB5b3Ugd2FudCBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInRvIHJldHJ5P1wiKVxuICAgICAgICAgICAgICAgIEFwcC5sb2cubG9nSW5mbyhcIlJldHJ5aW5nIC4uLlwiKVxuICAgICAgICAgICAgICAgIEBjYWxsQVBJR2V0KHBhcmFtcywgY2FsbCwgY2FsbEFyZ3MsIGNhbGxFcnJvcilcbiAgICAgICAgICAgIGVsc2UgaWYgY2FsbEVycm9yXG4gICAgICAgICAgICAgICAgY2FsbEVycm9yKGNhbGxBcmdzKVxuICAgICAgICApXG5cbiAgICBjYWxsQVBJUG9zdDogKHBhcmFtcywgY2FsbCwgY2FsbEFyZ3MsIGNhbGxFcnJvcikgLT5cbiAgICAgICAgcGFyYW1zLmZvcm1hdCA9IFwianNvblwiXG5cbiAgICAgICAgcmV0dXJuIEBhcGkucG9zdChwYXJhbXMpXG4gICAgICAgIC5kb25lKChkYXRhLCB0ZXh0U3RhdHVzLCBqcVhIUikgPT5cbiAgICAgICAgICAgIGlmIGNhbGxcbiAgICAgICAgICAgICAgICBjYWxsKGRhdGEsIGNhbGxBcmdzKVxuICAgICAgICApLmZhaWwoKGpxWEhSLCB0ZXh0U3RhdHVzLCBlcnJvclRocm93bikgPT5cbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoanFYSFIsIHRleHRTdGF0dXMsIGVycm9yVGhyb3duKVxuICAgICAgICAgICAgQXBwLmxvZy5sb2dFcnJvcihAZmFpbGVkUXVlcnlFcnJvcigpKVxuICAgICAgICAgICAgaWYgY29uZmlybShcIldpa2kgTW9ua2V5IGVycm9yOiBGYWlsZWQgcXVlcnlcXG5cXG5EbyB5b3Ugd2FudCBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInRvIHJldHJ5P1wiKVxuICAgICAgICAgICAgICAgIEFwcC5sb2cubG9nSW5mbyhcIlJldHJ5aW5nIC4uLlwiKVxuICAgICAgICAgICAgICAgIEBjYWxsQVBJUG9zdChwYXJhbXMsIGNhbGwsIGNhbGxBcmdzLCBjYWxsRXJyb3IpXG5cbiAgICAgICAgICAgIGVsc2UgaWYgY2FsbEVycm9yXG4gICAgICAgICAgICAgICAgY2FsbEVycm9yKGNhbGxBcmdzKVxuICAgICAgICApXG5cbiAgICBjYWxsUXVlcnk6IChwYXJhbXMsIGNhbGwsIGNhbGxBcmdzLCBjYWxsRXJyb3IpIC0+XG4gICAgICAgIHBhcmFtcy5hY3Rpb24gPSBcInF1ZXJ5XCJcblxuICAgICAgICB0cnlcbiAgICAgICAgICAgIHJlcyA9IGF3YWl0IEBjYWxsQVBJR2V0KHBhcmFtcylcbiAgICAgICAgY2F0Y2ggZXJyb3JcbiAgICAgICAgICAgIGlmIGNhbGxFcnJvclxuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsRXJyb3IoY2FsbEFyZ3MpXG4gICAgICAgICAgICB0aHJvdyBlcnJvclxuXG4gICAgICAgIHBhZ2UgPSBPYmplY3QudmFsdWVzKHJlcy5xdWVyeS5wYWdlcylbMF1cblxuICAgICAgICBpZiBjYWxsXG4gICAgICAgICAgICByZXR1cm4gY2FsbChwYWdlLCBjYWxsQXJncylcbiAgICAgICAgcmV0dXJuIHBhZ2VcblxuICAgIGNhbGxRdWVyeUVkaXQ6ICh0aXRsZSwgY2FsbCwgY2FsbEFyZ3MpIC0+XG4gICAgICAgIHBhZ2UgPSBhd2FpdCBAY2FsbFF1ZXJ5KFxuICAgICAgICAgICAgcHJvcDogXCJpbmZvfHJldmlzaW9uc1wiXG4gICAgICAgICAgICBydnByb3A6IFwiY29udGVudHx0aW1lc3RhbXBcIlxuICAgICAgICAgICAgaW50b2tlbjogXCJlZGl0XCJcbiAgICAgICAgICAgIHRpdGxlczogdGl0bGVcbiAgICAgICAgKVxuXG4gICAgICAgIHNvdXJjZSA9IHBhZ2UucmV2aXNpb25zWzBdW1wiKlwiXVxuICAgICAgICB0aW1lc3RhbXAgPSBwYWdlLnJldmlzaW9uc1swXS50aW1lc3RhbXBcbiAgICAgICAgZWRpdHRva2VuID0gcGFnZS5lZGl0dG9rZW5cblxuICAgICAgICBpZiBjYWxsXG4gICAgICAgICAgICByZXR1cm4gY2FsbCh0aXRsZSwgc291cmNlLCB0aW1lc3RhbXAsIGVkaXR0b2tlbiwgY2FsbEFyZ3MpXG4gICAgICAgIHJldHVybiB7c291cmNlLCB0aW1lc3RhbXAsIGVkaXR0b2tlbn1cblxuICAgIGdldFVzZXJJbmZvOiAoY2FsbCkgLT5cbiAgICAgICAgc3RvcmVJbmZvID0gKHJlcywgY2FsbCkgPT5cbiAgICAgICAgICAgIEB1c2VySW5mbyA9IHJlc1xuICAgICAgICAgICAgY2FsbCgpXG5cbiAgICAgICAgaWYgbm90IEB1c2VySW5mb1xuICAgICAgICAgICAgcGFycyA9XG4gICAgICAgICAgICAgICAgYWN0aW9uOiBcInF1ZXJ5XCJcbiAgICAgICAgICAgICAgICBtZXRhOiBcInVzZXJpbmZvXCJcbiAgICAgICAgICAgICAgICB1aXByb3A6IFwiZ3JvdXBzXCJcbiAgICAgICAgICAgIEBjYWxsQVBJR2V0KHBhcnMsIHN0b3JlSW5mbywgY2FsbCwgbnVsbClcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgY2FsbCgpXG5cbiAgICBpc0xvZ2dlZEluOiAoY2FsbCwgYXJncykgLT5cbiAgICAgICAgQGdldFVzZXJJbmZvKCA9PlxuICAgICAgICAgICAgdGVzdCA9IEB1c2VySW5mby5xdWVyeS51c2VyaW5mby5pZCAhPSAwXG4gICAgICAgICAgICBjYWxsKHRlc3QsIGFyZ3MpXG4gICAgICAgIClcblxuICAgIGdldFVzZXJOYW1lOiAoY2FsbCwgYXJncykgLT5cbiAgICAgICAgQGdldFVzZXJJbmZvKCA9PlxuICAgICAgICAgICAgY2FsbChAdXNlckluZm8ucXVlcnkudXNlcmluZm8ubmFtZSwgYXJncylcbiAgICAgICAgKVxuXG4gICAgaXNVc2VyQm90OiAoY2FsbCwgYXJncykgLT5cbiAgICAgICAgQGdldFVzZXJJbmZvKCA9PlxuICAgICAgICAgICAgZ3JvdXBzID0gQHVzZXJJbmZvLnF1ZXJ5LnVzZXJpbmZvLmdyb3Vwc1xuICAgICAgICAgICAgcmVzID0gZ3JvdXBzLmluZGV4T2YoXCJib3RcIikgPiAtMVxuICAgICAgICAgICAgY2FsbChyZXMsIGFyZ3MpXG4gICAgICAgIClcblxuICAgIGdldEJhY2tsaW5rczogKGJsdGl0bGUsIGJsbmFtZXNwYWNlLCBjYWxsLCBjYWxsQXJncykgLT5cbiAgICAgICAgcXVlcnkgPVxuICAgICAgICAgICAgYWN0aW9uOiBcInF1ZXJ5XCJcbiAgICAgICAgICAgIGxpc3Q6IFwiYmFja2xpbmtzXCJcbiAgICAgICAgICAgIGJsdGl0bGU6IGJsdGl0bGVcbiAgICAgICAgICAgIGJsbGltaXQ6IDUwMFxuXG4gICAgICAgIGlmIGJsbmFtZXNwYWNlXG4gICAgICAgICAgICBxdWVyeS5ibG5hbWVzcGFjZSA9IGJsbmFtZXNwYWNlXG5cbiAgICAgICAgQF9nZXRCYWNrbGlua3NDb250aW51ZShxdWVyeSwgY2FsbCwgY2FsbEFyZ3MsIFtdKVxuXG4gICAgX2dldEJhY2tsaW5rc0NvbnRpbnVlOiAocXVlcnksIGNhbGwsIGNhbGxBcmdzLCBiYWNrbGlua3MpIC0+XG4gICAgICAgIEBjYWxsQVBJR2V0KHF1ZXJ5LCAocmVzLCBhcmdzKSA9PlxuICAgICAgICAgICAgYmFja2xpbmtzID0gYmFja2xpbmtzLmNvbmNhdChyZXMucXVlcnkuYmFja2xpbmtzKVxuICAgICAgICAgICAgaWYgcmVzW1wicXVlcnktY29udGludWVcIl1cbiAgICAgICAgICAgICAgICBxdWVyeS5ibGNvbnRpbnVlID0gcmVzW1wicXVlcnktY29udGludWVcIl0uYmFja2xpbmtzLmJsY29udGludWVcbiAgICAgICAgICAgICAgICBAX2dldEJhY2tsaW5rc0NvbnRpbnVlKHF1ZXJ5LCBjYWxsLCBhcmdzLCBiYWNrbGlua3MpXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgY2FsbChiYWNrbGlua3MsIGFyZ3MpXG4gICAgICAgICxcbiAgICAgICAgY2FsbEFyZ3MsIG51bGwpXG5cbiAgICBnZXRMYW5nbGlua3M6ICh0aXRsZSwgaXdtYXAsIGNhbGwsIGNhbGxBcmdzKSAtPlxuICAgICAgICBxdWVyeSA9XG4gICAgICAgICAgICBhY3Rpb246IFwicXVlcnlcIlxuICAgICAgICAgICAgcHJvcDogXCJsYW5nbGlua3NcIlxuICAgICAgICAgICAgdGl0bGVzOiB0aXRsZVxuICAgICAgICAgICAgbGxsaW1pdDogNTAwXG4gICAgICAgICAgICBsbHVybDogXCIxXCJcbiAgICAgICAgICAgIHJlZGlyZWN0czogXCIxXCJcblxuICAgICAgICBpZiBpd21hcFxuICAgICAgICAgICAgcXVlcnkubWV0YSA9IFwic2l0ZWluZm9cIlxuICAgICAgICAgICAgcXVlcnkuc2lwcm9wID0gXCJpbnRlcndpa2ltYXBcIlxuICAgICAgICAgICAgcXVlcnkuc2lmaWx0ZXJpdyA9IFwibG9jYWxcIlxuXG4gICAgICAgIEBfZ2V0TGFuZ2xpbmtzQ29udGludWUocXVlcnksIGNhbGwsIGNhbGxBcmdzLCBbXSwgbnVsbClcblxuICAgIF9nZXRMYW5nbGlua3NDb250aW51ZTogKHF1ZXJ5LCBjYWxsLCBjYWxsQXJncywgbGFuZ2xpbmtzLCBpd21hcCkgLT5cbiAgICAgICAgQGNhbGxBUElHZXQocXVlcnksIChyZXMsIGFyZ3MpID0+XG4gICAgICAgICAgICBwYWdlID0gT2JqZWN0LnZhbHVlcyhyZXMucXVlcnkucGFnZXMpWzBdXG4gICAgICAgICAgICBsYW5nbGlua3MgPSBsYW5nbGlua3MuY29uY2F0KHBhZ2UubGFuZ2xpbmtzKVxuXG4gICAgICAgICAgICBpZiByZXMucXVlcnkuaW50ZXJ3aWtpbWFwXG4gICAgICAgICAgICAgICAgaXdtYXAgPSByZXMucXVlcnkuaW50ZXJ3aWtpbWFwXG5cbiAgICAgICAgICAgIGlmIHF1ZXJ5Lm1ldGFcbiAgICAgICAgICAgICAgICBkZWxldGUgcXVlcnkubWV0YVxuICAgICAgICAgICAgICAgIGRlbGV0ZSBxdWVyeS5zaXByb3BcbiAgICAgICAgICAgICAgICBkZWxldGUgcXVlcnkuc2lmaWx0ZXJpd1xuXG4gICAgICAgICAgICBpZiByZXNbXCJxdWVyeS1jb250aW51ZVwiXVxuICAgICAgICAgICAgICAgIHF1ZXJ5LmxsY29udGludWUgPSByZXNbXCJxdWVyeS1jb250aW51ZVwiXS5sYW5nbGlua3MubGxjb250aW51ZVxuICAgICAgICAgICAgICAgIEBfZ2V0TGFuZ2xpbmtzQ29udGludWUocXVlcnksIGNhbGwsIGFyZ3MsIGxhbmdsaW5rcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl3bWFwKVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGNhbGwobGFuZ2xpbmtzLCBpd21hcCwgYXJncylcbiAgICAgICAgLFxuICAgICAgICBjYWxsQXJncywgbnVsbClcblxuICAgIGdldEludGVyd2lraU1hcDogKHRpdGxlKSAtPlxuICAgICAgICByZXR1cm4gQGNhbGxBUElHZXQoe1xuICAgICAgICAgICAgYWN0aW9uOiBcInF1ZXJ5XCJcbiAgICAgICAgICAgIG1ldGE6IFwic2l0ZWluZm9cIlxuICAgICAgICAgICAgc2lwcm9wOiBcImludGVyd2lraW1hcFwiXG4gICAgICAgIH0pXG5cbiAgICBnZXRMb2NhbEludGVyd2lraU1hcDogKHRpdGxlLCBjYWxsLCBjYWxsQXJncykgLT5cbiAgICAgICAgQGNhbGxBUElHZXQoXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYWN0aW9uOiBcInF1ZXJ5XCJcbiAgICAgICAgICAgICAgICBtZXRhOiBcInNpdGVpbmZvXCJcbiAgICAgICAgICAgICAgICBzaXByb3A6IFwiaW50ZXJ3aWtpbWFwXCJcbiAgICAgICAgICAgICAgICBzaWZpbHRlcml3OiBcImxvY2FsXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIChyZXMsIGFyZ3MpID0+XG4gICAgICAgICAgICAgICAgY2FsbChyZXMucXVlcnkuaW50ZXJ3aWtpbWFwLCBhcmdzKVxuICAgICAgICAgICAgY2FsbEFyZ3NcbiAgICAgICAgICAgIG51bGxcbiAgICAgICAgKVxuXG4gICAgZml4SW50ZXJ3aWtpVXJsOiAodXJsKSAtPlxuICAgICAgICBmb3IgZiBpbiBbMC4uLmludGVyd2lraUZpeGVzLmxlbmd0aF1cbiAgICAgICAgICAgIGZ1cmwgPSB1cmwucmVwbGFjZShpbnRlcndpa2lGaXhlc1tmXVswXSwgaW50ZXJ3aWtpRml4ZXNbZl1bMV0pXG5cbiAgICAgICAgICAgIGlmIGZ1cmwgIT0gdXJsXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1cmxcblxuICAgICAgICAjIFJldHVybiB0aGUgdW5tb2RpZmllZCB1cmwgaWYgbm8gcmVwbGFjZW1lbnQgaGFzIGJlZW4gZG9uZVxuICAgICAgICByZXR1cm4gdXJsXG5cbiAgICBnZXRTcGVjaWFsTGlzdDogKHFwcGFnZSwgc2lwcm9wKSAtPlxuICAgICAgICBxdWVyeSA9XG4gICAgICAgICAgICBhY3Rpb246IFwicXVlcnlcIlxuICAgICAgICAgICAgbGlzdDogXCJxdWVyeXBhZ2VcIlxuICAgICAgICAgICAgcXBwYWdlOiBxcHBhZ2VcbiAgICAgICAgICAgIHFwbGltaXQ6IDUwMFxuXG4gICAgICAgIGlmIHNpcHJvcFxuICAgICAgICAgICAgcXVlcnkubWV0YSA9IFwic2l0ZWluZm9cIlxuICAgICAgICAgICAgcXVlcnkuc2lwcm9wID0gc2lwcm9wXG5cbiAgICAgICAgcmVzdWx0cyA9IFtdXG4gICAgICAgIHNpdGVpbmZvID0ge31cblxuICAgICAgICBsb29wXG4gICAgICAgICAgICByZXMgPSBhd2FpdCBAY2FsbEFQSUdldChxdWVyeSlcbiAgICAgICAgICAgIHJlc3VsdHMgPSByZXN1bHRzLmNvbmNhdChyZXMucXVlcnkucXVlcnlwYWdlLnJlc3VsdHMpXG5cbiAgICAgICAgICAgIGZvciBrZXksIGluZm8gb2YgcmVzLnF1ZXJ5IHdoZW4ga2V5ICE9IFwicXVlcnlwYWdlXCJcbiAgICAgICAgICAgICAgICBzaXRlaW5mb1trZXldID0gaW5mb1xuXG4gICAgICAgICAgICBkZWxldGUgcXVlcnkubWV0YVxuICAgICAgICAgICAgZGVsZXRlIHF1ZXJ5LnNpcHJvcFxuXG4gICAgICAgICAgICBpZiByZXNbXCJxdWVyeS1jb250aW51ZVwiXVxuICAgICAgICAgICAgICAgIHF1ZXJ5LnFwb2Zmc2V0ID0gcmVzW1wicXVlcnktY29udGludWVcIl0ucXVlcnlwYWdlLnFwb2Zmc2V0XG4gICAgICAgICAgICAgICAgY29udGludWVcblxuICAgICAgICAgICAgcmV0dXJuIHtyZXN1bHRzLCBzaXRlaW5mb31cblxuICAgIGdldFVzZXJDb250cmliczogKHVjdXNlciwgdWNzdGFydCwgdWNlbmQsIGNhbGwsIGNhbGxBcmdzKSAtPlxuICAgICAgICBxdWVyeSA9XG4gICAgICAgICAgICBhY3Rpb246IFwicXVlcnlcIlxuICAgICAgICAgICAgbGlzdDogXCJ1c2VyY29udHJpYnNcIlxuICAgICAgICAgICAgdWN1c2VyOiB1Y3VzZXJcbiAgICAgICAgICAgIHVjcHJvcDogXCJcIlxuICAgICAgICAgICAgdWNzdGFydDogdWNzdGFydFxuICAgICAgICAgICAgdWNlbmQ6IHVjZW5kXG4gICAgICAgICAgICB1Y2xpbWl0OiA1MDBcblxuICAgICAgICBAX2dldFVzZXJDb250cmlic0NvbnRpbnVlKHF1ZXJ5LCBjYWxsLCBjYWxsQXJncywgW10pXG5cbiAgICBfZ2V0VXNlckNvbnRyaWJzQ29udGludWU6IChxdWVyeSwgY2FsbCwgY2FsbEFyZ3MsIHJlc3VsdHMpIC0+XG4gICAgICAgIEBjYWxsQVBJR2V0KHF1ZXJ5LCAocmVzLCBhcmdzKSA9PlxuICAgICAgICAgICAgcmVzdWx0cyA9IHJlc3VsdHMuY29uY2F0KHJlcy5xdWVyeS51c2VyY29udHJpYnMpXG5cbiAgICAgICAgICAgIGlmIHJlc1tcInF1ZXJ5LWNvbnRpbnVlXCJdXG4gICAgICAgICAgICAgICAgcXVlcnkudWNjb250aW51ZSA9IHJlc1tcInF1ZXJ5LWNvbnRpbnVlXCJdLnVzZXJjb250cmlic1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC51Y2NvbnRpbnVlXG4gICAgICAgICAgICAgICAgQF9nZXRVc2VyQ29udHJpYnNDb250aW51ZShxdWVyeSwgY2FsbCwgYXJncywgcmVzdWx0cylcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBjYWxsKHJlc3VsdHMsIGFyZ3MpXG4gICAgICAgICxcbiAgICAgICAgY2FsbEFyZ3MsIG51bGwpXG4iLCIjIFdpa2kgTW9ua2V5IC0gTWVkaWFXaWtpIGJvdCBhbmQgZWRpdG9yLWFzc2lzdGFudCB1c2VyIHNjcmlwdFxuIyBDb3B5cmlnaHQgKEMpIDIwMTEgRGFyaW8gR2lvdmFubmV0dGkgPGRldkBkYXJpb2dpb3Zhbm5ldHRpLm5ldD5cbiNcbiMgVGhpcyBmaWxlIGlzIHBhcnQgb2YgV2lraSBNb25rZXkuXG4jXG4jIFdpa2kgTW9ua2V5IGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiMgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiMgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiMgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbiNcbiMgV2lraSBNb25rZXkgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiMgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiMgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuIyBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuI1xuIyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuIyBhbG9uZyB3aXRoIFdpa2kgTW9ua2V5LiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuXG5SZWdFeCA9IHJlcXVpcmUoJ0BreW5pa29zL21pc2MvZGlzdC9SZWdFeCcpXG5TdHIgPSByZXF1aXJlKCdAa3luaWtvcy9taXNjL2Rpc3QvU3RyJylcbkFwcCA9IHJlcXVpcmUoJy4uL2FwcCcpXG5cblxuY2xhc3MgbW9kdWxlLmV4cG9ydHNcbiAgICBjb25zdHJ1Y3RvcjogKEBXTSkgLT5cblxuICAgIHNxdWFzaENvbnRpZ3VvdXNXaGl0ZXNwYWNlOiAodGl0bGUpIC0+XG4gICAgICAgICMgTWVkaWFXaWtpIHRyZWF0cyBjb25zZWN1dGl2ZSB3aGl0ZXNwYWNlIGNoYXJhY3RlcnMgaW4gdGl0bGVzIGFuZFxuICAgICAgICAjICAgc2VjdGlvbiBuYW1lcyBhcyBvbmVcbiAgICAgICAgIyBGb3IgZXhhbXBsZSBbW01haW4gX18gUGFnZSNGaXJzdCBfIF9zZWN0aW9uXV0gaXMgdGhlIHNhbWUgYXNcbiAgICAgICAgIyAgIFtbTWFpbiBQYWdlI0ZpcnN0IHNlY3Rpb25dXVxuICAgICAgICAjIENvbnNpZGVyIHRyaW1taW5nIHRoZSByZXR1cm5lZCB0ZXh0XG4gICAgICAgIHJldHVybiB0aXRsZS5yZXBsYWNlKC9bXyBdKy9nLCBcIiBcIilcblxuICAgIG5ldXRyYWxpemVOb3dpa2lUYWdzOiAoc291cmNlKSAtPlxuICAgICAgICAjIEVtcHR5IG5vd2lraSB0YWdzICg8bm93aWtpPjwvbm93aWtpPikgbXVzdCBiZSBuZXV0cmFsaXplZCBhcyB3ZWxsLFxuICAgICAgICAjICAgb3RoZXJ3aXNlIFRhbXBlcm1vbmtleSB3aWxsIGhhbmcsIHNlZSBhbHNvXG4gICAgICAgICMgICBodHRwczovL2dpdGh1Yi5jb20va3luaWtvcy93aWtpLW1vbmtleS9pc3N1ZXMvMTMzXG4gICAgICAgICMgTm90ZSB0aGF0IHRoZSBjb25jZXB0IG9mIFwibmVzdGluZ1wiIGRvZXNuJ3QgbWFrZSBzZW5zZSB3aXRoIDxub3dpa2k+XG4gICAgICAgICMgICB0YWdzLCBzbyBkbyAqbm90KiB1c2UgU3RyLmZpbmROZXN0ZWRFbmNsb3N1cmVzXG4gICAgICAgIE9QRU5MRU5HVEggPSA4XG4gICAgICAgIENMT1NFTEVOR1RIID0gOVxuICAgICAgICB0YWdzID0gU3RyLmZpbmRTaW1wbGVFbmNsb3N1cmVzKHNvdXJjZSwgLzxub3dpa2k+L2ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPUEVOTEVOR1RILCAvPFxcL25vd2lraT4vaSwgQ0xPU0VMRU5HVEgpXG4gICAgICAgIG1hc2tlZFRleHQgPSBcIlwiXG4gICAgICAgIHByZXZJZCA9IDBcblxuICAgICAgICBmb3IgdGFnIGluIHRhZ3NcbiAgICAgICAgICAgIGlmIHRhZ1sxXVxuICAgICAgICAgICAgICAgIG1hc2tMZW5ndGggPSB0YWdbMV0gLSB0YWdbMF0gKyBDTE9TRUxFTkdUSFxuICAgICAgICAgICAgICAgIG1hc2tTdHJpbmcgPSBTdHIucGFkUmlnaHQoXCJcIiwgXCJ4XCIsIG1hc2tMZW5ndGgpXG4gICAgICAgICAgICAgICAgbWFza2VkVGV4dCArPSBzb3VyY2Uuc3Vic3RyaW5nKHByZXZJZCwgdGFnWzBdKSArIG1hc2tTdHJpbmdcbiAgICAgICAgICAgICAgICBwcmV2SWQgPSB0YWdbMV0gKyBDTE9TRUxFTkdUSFxuICAgICAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgIyBJZiBhIDxub3dpa2k+IHRhZyBpcyBsZWZ0IG9wZW4gKG5vIGNsb3NpbmcgdGFnIGlzIGZvdW5kKSwgaXRcbiAgICAgICAgICAgICAgICAjICAgZG9lcyBpdHMgam9iIHVudGlsIHRoZSBlbmQgb2YgdGhlIHRleHRcbiAgICAgICAgICAgICAgICAjIFRoaXMgYWxzbyBuZXV0cmFsaXplcyB0aGUgZmluYWwgXFxuLCBidXQgaXQgc2hvdWxkbid0IG1hdHRlclxuICAgICAgICAgICAgICAgIG1hc2tMZW5ndGggPSBzb3VyY2Uuc3Vic3RyKHRhZ1swXSkubGVuZ3RoXG4gICAgICAgICAgICAgICAgbWFza1N0cmluZyA9IFN0ci5wYWRSaWdodChcIlwiLCBcInhcIiwgbWFza0xlbmd0aClcbiAgICAgICAgICAgICAgICBtYXNrZWRUZXh0ICs9IHNvdXJjZS5zdWJzdHJpbmcocHJldklkLCB0YWdbMF0pICsgbWFza1N0cmluZ1xuICAgICAgICAgICAgICAgIHByZXZJZCA9IHNvdXJjZS5sZW5ndGhcbiAgICAgICAgICAgICAgICBicmVha1xuXG4gICAgICAgIG1hc2tlZFRleHQgKz0gc291cmNlLnN1YnN0cmluZyhwcmV2SWQpXG5cbiAgICAgICAgcmV0dXJuIG1hc2tlZFRleHRcblxuICAgIGRvdEVuY29kZTogKHRleHQpIC0+XG4gICAgICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQodGV4dCkucmVwbGFjZSgvJS9nLCBcIi5cIilcblxuICAgIGRvdEVuY29kZUxpbmtCcmVha2luZ0ZyYWdtZW50Q2hhcmFjdGVyczogKGZyYWdtZW50KSAtPlxuICAgICAgICAjIFRoZXNlIGNoYXJhY3RlcnMgYXJlIGtub3duIHRvIGJyZWFrIGludGVybmFsIGxpbmtzIGlmIGZvdW5kIGluXG4gICAgICAgICMgICBmcmFnbWVudHNcbiAgICAgICAgIyBUaGlzIGZ1bmN0aW9uIGlzIG5vdCB0ZXN0ZWQgb24gbGluayBwYXRocyBvciBhbmNob3JzIVxuICAgICAgICBmcmFnbWVudCA9IGZyYWdtZW50LnJlcGxhY2UoL1xcWy9nLCBcIi41QlwiKVxuICAgICAgICBmcmFnbWVudCA9IGZyYWdtZW50LnJlcGxhY2UoL1xcXS9nLCBcIi41RFwiKVxuICAgICAgICBmcmFnbWVudCA9IGZyYWdtZW50LnJlcGxhY2UoL1xcey9nLCBcIi43QlwiKVxuICAgICAgICBmcmFnbWVudCA9IGZyYWdtZW50LnJlcGxhY2UoL1xcfS9nLCBcIi43RFwiKVxuICAgICAgICBmcmFnbWVudCA9IGZyYWdtZW50LnJlcGxhY2UoL1xcfC9nLCBcIi43Q1wiKVxuICAgICAgICByZXR1cm4gZnJhZ21lbnRcblxuICAgIHByZXBhcmVSZWdleHBXaGl0ZXNwYWNlID0gKHRpdGxlKSAtPlxuICAgICAgICAjIE1lZGlhV2lraSB0cmVhdHMgY29uc2VjdXRpdmUgd2hpdGVzcGFjZSBjaGFyYWN0ZXJzIGluIHRpdGxlcyBhbmRcbiAgICAgICAgIyAgIHNlY3Rpb24gbmFtZXMgYXMgb25lXG4gICAgICAgICMgRm9yIGV4YW1wbGUgW1tNYWluIF9fIFBhZ2UjRmlyc3QgXyBfc2VjdGlvbl1dIGlzIHRoZSBzYW1lIGFzXG4gICAgICAgICMgICBbW01haW4gUGFnZSNGaXJzdCBzZWN0aW9uXV1cbiAgICAgICAgIyBDb25zaWRlciB0cmltbWluZyB0aGUgdGl0bGUgYmVmb3JlIHBhc3NpbmcgaXQgaGVyZVxuICAgICAgICByZXR1cm4gdGl0bGUucmVwbGFjZSgvW18gXSsvZywgXCJbXyBdK1wiKVxuXG4gICAgcHJlcGFyZVRpdGxlQ2FzaW5nID0gKHBhdHRlcm4pIC0+XG4gICAgICAgIGZpcnN0Q2hhciA9IHBhdHRlcm4uY2hhckF0KDApXG4gICAgICAgIGZjVXBwZXIgPSBmaXJzdENoYXIudG9VcHBlckNhc2UoKVxuICAgICAgICBmY0xvd2VyID0gZmlyc3RDaGFyLnRvTG93ZXJDYXNlKClcbiAgICAgICAgaWYgZmNVcHBlciAhPSBmY0xvd2VyXG4gICAgICAgICAgICBwYXR0ZXJuID0gXCJbXCIgKyBmY1VwcGVyICsgZmNMb3dlciArIFwiXVwiICsgcGF0dGVybi5zdWJzdHIoMSlcbiAgICAgICAgcmV0dXJuIHBhdHRlcm5cblxuICAgIGNvbXBhcmVBcnRpY2xlVGl0bGVzOiAodGl0bGUxLCB0aXRsZTIpIC0+XG4gICAgICAgICMgQWN0dWFsbHkgYWxzbyBuYW1lc3BhY2VzIHNob3VsZCBiZSBrZXB0IGludG8gYWNjb3VudCxcbiAgICAgICAgIyBlLmcuICdIZWxwOlRpdGxlJyBhbmQgJ0hlbHA6dGl0bGUnIHNob3VsZCByZXR1cm4gdHJ1ZVxuICAgICAgICB0MSA9IHByZXBhcmVUaXRsZUNhc2luZyh0aGlzLnNxdWFzaENvbnRpZ3VvdXNXaGl0ZXNwYWNlKHRpdGxlMSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRyaW0oKSlcbiAgICAgICAgdDIgPSBwcmVwYXJlVGl0bGVDYXNpbmcodGhpcy5zcXVhc2hDb250aWd1b3VzV2hpdGVzcGFjZSh0aXRsZTIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50cmltKCkpXG4gICAgICAgIHJldHVybiB0MSA9PSB0MlxuXG4gICAgZmluZEJlaGF2aW9yU3dpdGNoZXM6IChzb3VyY2UsIHdvcmQpIC0+XG4gICAgICAgIHNvdXJjZSA9IHRoaXMubmV1dHJhbGl6ZU5vd2lraVRhZ3Moc291cmNlKVxuICAgICAgICByZWdFeHBcbiAgICAgICAgaWYgd29yZFxuICAgICAgICAgICAgIyBCZWhhdmlvciBzd2l0Y2hlcyBhcmVuJ3QgY2FzZS1zZW5zaXRpdmVcbiAgICAgICAgICAgIHJlZ0V4cCA9IG5ldyBSZWdFeHAoXCJfX1wiICsgbXcuUmVnRXhwLmVzY2FwZSh3b3JkKSArIFwiX19cIiwgXCJnaVwiKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICAjIEJlaGF2aW9yIHN3aXRjaGVzIGFyZW4ndCBjYXNlLXNlbnNpdGl2ZVxuICAgICAgICAgICAgcmVnRXhwID0gbmV3IFJlZ0V4cChcIl9fKFRPQ3xOT1RPQ3xGT1JDRVRPQ3xOT0VESVRTRUNUSU9OfFwiICtcbiAgICAgICAgICAgICAgICAgICAgXCJORVdTRUNUSU9OTElOS3xOT05FV1NFQ1RJT05MSU5LfE5PR0FMTEVSWXxISURERU5DQVR8XCIgK1xuICAgICAgICAgICAgICAgICAgICBcIk5PQ09OVEVOVENPTlZFUlR8Tk9DQ3xOT1RJVExFQ09OVkVSVHxOT1RDfElOREVYfFwiICtcbiAgICAgICAgICAgICAgICAgICAgXCJOT0lOREVYfFNUQVRJQ1JFRElSRUNUfFNUQVJUfEVORClfX1wiLCBcImdpXCIpXG4gICAgICAgIHJldHVybiBSZWdFeC5tYXRjaEFsbChzb3VyY2UsIHJlZ0V4cClcblxuICAgIGZpbmRMaW5rc0VuZ2luZTogKHNvdXJjZSwgdGl0bGVQYXR0ZXJuLCBzcGVjaWFsT25seSwgY2FzZVNlbnNpdGl2ZSkgLT5cbiAgICAgICAgIyBMaW5rcyBjYW5ub3QgY29udGFpbiBvdGhlciBsaW5rcywgbm90IGV2ZW4gaW4gdGhlIGFsdGVybmF0aXZlIHRleHRcbiAgICAgICAgIyAgIChvbmx5IHRoZSBpbm5lcm1vc3QgbGlua3MgYXJlIHZhbGlkKVxuICAgICAgICAjIE1ha2Ugc3VyZSB0byBwcmVwYXJlIHdoaXRlc3BhY2UgaW4gdGl0bGVQYXR0ZXJuIGxpa2UgaW5cbiAgICAgICAgIyAgIHByZXBhcmVSZWdleHBXaGl0ZXNwYWNlXG4gICAgICAgICMgRG8gKm5vdCogdXNlIHRoZSBnIGZsYWcsIG9yIHdoZW4gdXNpbmcgUmVnRXhwLmV4ZWMgdGhlIGluZGV4IHdpbGxcbiAgICAgICAgIyAgIGhhdmUgdG8gYmUgcmVzZXQgYXQgZXZlcnkgbG9vcFxuICAgICAgICBmbGFncyA9IGlmIGNhc2VTZW5zaXRpdmUgdGhlbiBcIlwiIGVsc2UgXCJpXCJcbiAgICAgICAgIyBUaGUgZm9sbG93aW5nIGNvbG9uL3NwYWNlIGNvbWJpbmF0aW9ucyBhcmUgdmFsaWRcbiAgICAgICAgIyAgIFwiW1thOmIjY3xkXV1cIlxuICAgICAgICAjICAgXCJbWyBhOmIjY3xkXV1cIlxuICAgICAgICAjICAgXCJbWyA6YTpiI2N8ZF1dXCJcbiAgICAgICAgIyAgIFwiW1sgOiBhOmIjY3xkXV1cIlxuICAgICAgICAjICAgXCJbWzphOmIjY3xkXV1cIlxuICAgICAgICAjICAgXCJbWzogYTpiI2N8ZF1dXCJcbiAgICAgICAgIyAgIFwiW1s6OmE6YiNjfGRdXVwiXG4gICAgICAgICMgICBcIltbOiA6YTpiI2N8ZF1dXCJcbiAgICAgICAgIyAgIFwiW1s6OiBhOmIjY3xkXV1cIlxuICAgICAgICAjICAgXCJbWzogOiBhOmIjY3xkXV1cIlxuICAgICAgICAjIEEgbGluayBsaWtlIFwiW1sgOjphOmIjY3xkXV1cIiBpc24ndCB2YWxpZCwgYnV0IGl0IHdvdWxkIHN0aWxsIGJlXG4gICAgICAgICMgICBmb3VuZCB3aGVuIHNwZWNpYWxPbmx5IGlzIGZhbHNlIChidWcgIzE2NilcbiAgICAgICAgc3BlY2lhbCA9IGlmIHNwZWNpYWxPbmx5IHRoZW4gXCIoPzpbIF9dKzopP1sgX10qXCIgZWxzZSBcIig/OlxcXFw6P1sgX10qKXswLDJ9XCJcbiAgICAgICAgcmVnRXhwID0gbmV3IFJlZ0V4cChcIl5cIiArIHNwZWNpYWwgKyBcIihcIiArIHRpdGxlUGF0dGVybiArIFwiKVwiICtcbiAgICAgICAgICAgICAgICAgICAgXCJbIF9dKig/OlxcXFx8W19cXFxcc10qKFtcXFxcc1xcXFxTXSs/KVtfXFxcXHNdKik/W19cXFxcc10qJFwiLCBmbGFncylcbiAgICAgICAgblNvdXJjZSA9IEBuZXV0cmFsaXplTm93aWtpVGFncyhzb3VyY2UpXG4gICAgICAgIGxpbmtzID0gW11cbiAgICAgICAgZGJyYWNlcyA9IFN0ci5maW5kSW5uZXJtb3N0RW5jbG9zdXJlcyhuU291cmNlLCBcIltbXCIsIFwiXV1cIilcblxuICAgICAgICBmb3IgZGJyYWNlIGluIGRicmFjZXNcbiAgICAgICAgICAgIGluVGV4dCA9IHNvdXJjZS5zdWJzdHJpbmcoZGJyYWNlWzBdICsgMiwgZGJyYWNlWzFdKVxuICAgICAgICAgICAgbWF0Y2ggPSByZWdFeHAuZXhlYyhpblRleHQpXG5cbiAgICAgICAgICAgIGlmIG1hdGNoXG4gICAgICAgICAgICAgICAgcHVzaCA9IHRydWVcblxuICAgICAgICAgICAgICAgIGlmIG1hdGNoWzZdXG4gICAgICAgICAgICAgICAgICAgICMgSW5jb21wbGV0ZSB0ZW1wbGF0ZXMgaW4gdGhlIGFsdGVybmF0aXZlIHRleHQgaGF2ZSBhblxuICAgICAgICAgICAgICAgICAgICAjICAgYXBwYXJlbnRseSB3ZWlyZCBiZWhhdmlvdXIsIGhhcmQgdG8gcmV2ZXJzZS1lbmdpbmVlcixcbiAgICAgICAgICAgICAgICAgICAgIyAgIHNvIGlzc3VlIGEgd2FybmluZyB3aGVuIG9uZSBpcyBmb3VuZFxuICAgICAgICAgICAgICAgICAgICAjICAgU2VlIGFsc28gdGhlIGV4YW1wbGVzIGluIEBmaW5kVHJhbnNjbHVzaW9uQXJndW1lbnRzXG4gICAgICAgICAgICAgICAgICAgICMgTm90ZSB0aGF0IHRoZSB0aXRsZSBhbHJlYWR5IGRvZXNuJ3QgYWxsb3cgXCJ7XCIgb3IgXCJ9XCJcbiAgICAgICAgICAgICAgICAgICAgblRleHQgPSBAbmV1dHJhbGl6ZU5vd2lraVRhZ3MobWF0Y2hbNl0pXG4gICAgICAgICAgICAgICAgICAgIG1hc2tlZFRleHQgPSBTdHIuZmluZE5lc3RlZEVuY2xvc3VyZXMoblRleHQsIFwie3tcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIn19XCIsIFwieFwiKVsxXVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIG1hc2tlZFRleHQuc2VhcmNoKC8oXFx7XFx7fFxcfVxcfSkvKSA+IC0xXG4gICAgICAgICAgICAgICAgICAgICAgICBBcHAubG9nLmxvZ1dhcm5pbmcoXCJbW1wiICsgbWF0Y2hbMF0gKyBcIl1dIHNlZW1zIHRvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbiBwYXJ0IG9mIGEgdGVtcGxhdGUsIGFuZCB0aGUgcmVzdWx0aW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVoYXZpb3VyIGNhbm5vdCBiZSBwcmVkaWN0ZWQgYnkgdGhpc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uLCBzbyB0aGUgbGluayB3aWxsIGJlIGlnbm9yZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbHRvZ2V0aGVyXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBwdXNoID0gZmFsc2VcblxuICAgICAgICAgICAgICAgIGlmIHB1c2hcbiAgICAgICAgICAgICAgICAgICAgbGlua3MucHVzaChcbiAgICAgICAgICAgICAgICAgICAgICAgIFwicmF3TGlua1wiOiBcIltbXCIgKyBtYXRjaFswXSArIFwiXV1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgXCJsaW5rXCI6IG1hdGNoWzFdXG4gICAgICAgICAgICAgICAgICAgICAgICBcInJhd1RpdGxlXCI6IG1hdGNoWzJdXG4gICAgICAgICAgICAgICAgICAgICAgICBcIm5hbWVzcGFjZVwiOiBtYXRjaFszXVxuICAgICAgICAgICAgICAgICAgICAgICAgXCJ0aXRsZVwiOiBtYXRjaFs0XVxuICAgICAgICAgICAgICAgICAgICAgICAgXCJmcmFnbWVudFwiOiBtYXRjaFs1XVxuICAgICAgICAgICAgICAgICAgICAgICAgXCJhbmNob3JcIjogbWF0Y2hbNl1cbiAgICAgICAgICAgICAgICAgICAgICAgIFwiaW5kZXhcIjogZGJyYWNlWzBdXG4gICAgICAgICAgICAgICAgICAgICAgICBcImxlbmd0aFwiOiBkYnJhY2VbMV0gKyAyIC0gZGJyYWNlWzBdKVxuXG4gICAgICAgIHJldHVybiBsaW5rc1xuXG4gICAgZmluZFNlY3Rpb25MaW5rczogKHNvdXJjZSkgLT5cbiAgICAgICAgIyBLZWVwIHRoZSBjYXB0dXJpbmcgZ3JvdXBzIGFzIHJlcXVpcmVkIGJ5IEBmaW5kTGlua3NFbmdpbmVcbiAgICAgICAgZnJhZ21lbnRDaGFycyA9IFwiW15cXFxcblxcXFx7XFxcXH1cXFxcW1xcXFxdXFxcXHxdKj9cIlxuICAgICAgICB0aXRsZVBhdHRlcm4gPSBcIigoKSgpKSMoXCIgKyBmcmFnbWVudENoYXJzICsgXCIpXCJcbiAgICAgICAgcmV0dXJuIEBmaW5kTGlua3NFbmdpbmUoc291cmNlLCB0aXRsZVBhdHRlcm4sIGZhbHNlLCB0cnVlKVxuXG4gICAgZmluZEludGVybmFsTGlua3M6IChzb3VyY2UsIG5hbWVzcGFjZSwgdGl0bGUpIC0+XG4gICAgICAgICMgS2VlcCB0aGUgY2FwdHVyaW5nIGdyb3VwcyBhcyByZXF1aXJlZCBieSBAZmluZExpbmtzRW5naW5lXG4gICAgICAgIG5hbWVzcGFjZUNoYXJzID0gXCJbXlxcXFxuXFxcXHtcXFxcfVxcXFxbXFxcXF1cXFxcfFxcXFw6XFxcXCNdKz9cIlxuICAgICAgICB0aXRsZUNoYXJzID0gXCJbXlxcXFxuXFxcXHtcXFxcfVxcXFxbXFxcXF1cXFxcfFxcXFwjXSs/XCJcbiAgICAgICAgZnJhZ21lbnRDaGFycyA9IFwiW15cXFxcblxcXFx7XFxcXH1cXFxcW1xcXFxdXFxcXHxdKj9cIlxuXG4gICAgICAgIGlmIG5hbWVzcGFjZVxuICAgICAgICAgICAgcmVucyA9IHByZXBhcmVSZWdleHBXaGl0ZXNwYWNlKG13LlJlZ0V4cC5lc2NhcGUobmFtZXNwYWNlKSlcblxuICAgICAgICAgICAgaWYgdGl0bGVcbiAgICAgICAgICAgICAgICByZXRpdGxlID0gcHJlcGFyZVJlZ2V4cFdoaXRlc3BhY2UobXcuUmVnRXhwLmVzY2FwZSh0aXRsZSkpXG4gICAgICAgICAgICAgICAgdGl0bGVQYXR0ZXJuID0gXCIoKFwiICsgcmVucyArIFwiKVsgX10qOlsgX10qXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiKFwiICsgcmV0aXRsZSArIFwiKSlcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIoPzpbIF9dKiMoXCIgKyBmcmFnbWVudENoYXJzICsgXCIpKT9cIlxuXG4gICAgICAgICAgICAgICAgIyBOYW1lc3BhY2VzIHdvdWxkbid0IGJlIGNhc2Utc2Vuc2l0aXZlLCBidXQgdGl0bGVzIGFyZSwgc28gYmVcbiAgICAgICAgICAgICAgICAjICAgc2FmZSBhbmQgZG9uJ3QgdXNlIHRoZSBpIGZsYWdcbiAgICAgICAgICAgICAgICBjYXNlU2Vuc2l0aXZlID0gdHJ1ZVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRpdGxlUGF0dGVybiA9IFwiKChcIiArIHJlbnMgKyBcIilbIF9dKjpbIF9dKlwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIihcIiArIHRpdGxlQ2hhcnMgKyBcIikpXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiKD86WyBfXSojKFwiICsgZnJhZ21lbnRDaGFycyArIFwiKSk/XCJcblxuICAgICAgICAgICAgICAgICMgTmFtZXNwYWNlcyBhcmVuJ3QgY2FzZS1zZW5zaXRpdmVcbiAgICAgICAgICAgICAgICBjYXNlU2Vuc2l0aXZlID0gZmFsc2VcbiAgICAgICAgZWxzZSBpZiB0aXRsZVxuICAgICAgICAgICAgcmV0aXRsZSA9IHByZXBhcmVSZWdleHBXaGl0ZXNwYWNlKG13LlJlZ0V4cC5lc2NhcGUodGl0bGUpKVxuXG4gICAgICAgICAgICAjIEtlZXAgdGhlIGNhcHR1cmluZyBncm91cHMgYXMgcmVxdWlyZWQgYnkgQGZpbmRMaW5rc0VuZ2luZVxuICAgICAgICAgICAgdGl0bGVQYXR0ZXJuID0gXCIoKCkoXCIgKyByZXRpdGxlICsgXCIpKVwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIig/OlsgX10qIyhcIiArIGZyYWdtZW50Q2hhcnMgKyBcIikpP1wiXG5cbiAgICAgICAgICAgICMgVGl0bGVzIGFyZSBjYXNlLXNlbnNpdGl2ZVxuICAgICAgICAgICAgY2FzZVNlbnNpdGl2ZSA9IHRydWVcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGl0bGVQYXR0ZXJuID0gXCIoKD86KFwiICsgbmFtZXNwYWNlQ2hhcnMgKyBcIilbIF9dKjpbIF9dKik/XCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiKFwiICsgdGl0bGVDaGFycyArIFwiKSlcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIoPzpbIF9dKiMoXCIgKyBmcmFnbWVudENoYXJzICsgXCIpKT9cIlxuICAgICAgICAgICAgY2FzZVNlbnNpdGl2ZSA9IHRydWVcblxuICAgICAgICByZXR1cm4gQGZpbmRMaW5rc0VuZ2luZShzb3VyY2UsIHRpdGxlUGF0dGVybiwgZmFsc2UsIGNhc2VTZW5zaXRpdmUpXG5cbiAgICBmaW5kSW50ZXJ3aWtpTGlua3M6IChzb3VyY2UsIHdpa2kpIC0+XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmRJbnRlcm5hbExpbmtzKHNvdXJjZSwgd2lraSlcblxuICAgIGZpbmRTcGVjaWFsTGlua3M6IChzb3VyY2UsIHBhdHRlcm4pIC0+XG4gICAgICAgICMgTWFrZSBzdXJlIHRvIHByZXBhcmUgd2hpdGVzcGFjZSBpbiBwYXR0ZXJuIGxpa2UgaW5cbiAgICAgICAgIyAgIHByZXBhcmVSZWdleHBXaGl0ZXNwYWNlXG4gICAgICAgICMgS2VlcCB0aGUgY2FwdHVyaW5nIGdyb3VwcyBhcyByZXF1aXJlZCBieSBAZmluZExpbmtzRW5naW5lXG4gICAgICAgICMgU2VlIGFsc28gV00uQXJjaFdpa2kuZmluZEFsbEludGVybGFuZ3VhZ2VMaW5rc1xuICAgICAgICB0aXRsZUNoYXJzID0gXCJbXlxcXFxuXFxcXHtcXFxcfVxcXFxbXFxcXF1cXFxcfFxcXFwjXSs/XCJcbiAgICAgICAgZnJhZ21lbnRDaGFycyA9IFwiW15cXFxcblxcXFx7XFxcXH1cXFxcW1xcXFxdXFxcXHxdKj9cIlxuICAgICAgICB0aXRsZVBhdHRlcm4gPSBcIigoXCIgKyBwYXR0ZXJuICsgXCIpWyBfXSo6WyBfXSpcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIoXCIgKyB0aXRsZUNoYXJzICsgXCIpKVwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIig/OlsgX10qIyhcIiArIGZyYWdtZW50Q2hhcnMgKyBcIikpP1wiXG4gICAgICAgICMgQ2F0ZWdvcmllcyBhbmQgbGFuZ3VhZ2UgdGFncyBhcmVuJ3QgY2FzZS1zZW5zaXRpdmVcbiAgICAgICAgcmV0dXJuIEBmaW5kTGlua3NFbmdpbmUoc291cmNlLCB0aXRsZVBhdHRlcm4sIHRydWUsIGZhbHNlKVxuXG4gICAgZmluZENhdGVnb3JpZXM6IChzb3VyY2UpIC0+XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmRTcGVjaWFsTGlua3Moc291cmNlLCBcIkNhdGVnb3J5XCIpXG5cbiAgICBmaW5kSW50ZXJsYW5ndWFnZUxpbmtzOiAoc291cmNlLCBsYW5ndWFnZSkgLT5cbiAgICAgICAgIyBTZWUgYWxzbyBXTS5BcmNoV2lraS5maW5kQWxsSW50ZXJsYW5ndWFnZUxpbmtzXG4gICAgICAgIHJldHVybiB0aGlzLmZpbmRTcGVjaWFsTGlua3Moc291cmNlLCBtdy5SZWdFeHAuZXNjYXBlKGxhbmd1YWdlKSlcblxuICAgIGZpbmRWYXJpYWJsZXM6IChzb3VyY2UsIHZhcmlhYmxlKSAtPlxuICAgICAgICAjIFRoZXJlIGRvbid0IHNlZW0gdG8gZXhpc3QgdmFyaWFibGUgbmFtZXMgd2l0aCB3aGl0ZXNwYWNlLCBhcHBseWluZ1xuICAgICAgICAjICAgcHJlcGFyZVJlZ2V4cFdoaXRlc3BhY2UgY291bGQgYmUgZGFuZ2Vyb3VzIGluIHRoaXMgY2FzZVxuICAgICAgICBwYXR0ZXJuID0gbXcuUmVnRXhwLmVzY2FwZSh2YXJpYWJsZSlcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluZFZhcmlhYmxlc1BhdHRlcm4oc291cmNlLCBwYXR0ZXJuKVxuXG4gICAgZmluZFZhcmlhYmxlc1BhdHRlcm46IChzb3VyY2UsIHBhdHRlcm4pIC0+XG4gICAgICAgICMgcGF0dGVybiBtdXN0IGJlIGEgc3RyaW5nIGFuZCBJVCBNVVNUIE5PVCBIQVZFIEFOWSBDQVBUVVJJTkdcbiAgICAgICAgIyAgIEdST1VQU1xuICAgICAgICAjIFRoZXJlIGNhbid0IGJlIGFuIHVuZGVyc2NvcmUgYmVmb3JlIHRoZSB2YXJpYWJsZSBuYW1lXG4gICAgICAgICMgVGhlcmUgY2FuJ3QgYmUgYSB3aGl0ZXNwYWNlIGJldHdlZW4gdGhlIHZhcmlhYmxlIG5hbWUgYW5kIHRoZSBjb2xvblxuICAgICAgICBuU291cmNlID0gdGhpcy5uZXV0cmFsaXplTm93aWtpVGFncyhzb3VyY2UpXG4gICAgICAgIHJlc3VsdHMgPSBbXVxuICAgICAgICBkYnJhY2tldHMgPSBTdHIuZmluZE5lc3RlZEVuY2xvc3VyZXMoblNvdXJjZSwgXCJ7e1wiLCBcIn19XCIsIFwieFwiKVswXVxuXG4gICAgICAgIGZvciBkYnJhY2tldCBpbiBkYnJhY2tldHNcbiAgICAgICAgICAgIGluVGV4dCA9IHNvdXJjZS5zdWJzdHJpbmcoZGJyYWNrZXRbMF0gKyAyLCBkYnJhY2tldFsxXSlcblxuICAgICAgICAgICAgIyBWYXJpYWJsZXMgYXJlIGNhc2Utc2Vuc2l0aXZlXG4gICAgICAgICAgICAjIERvICpub3QqIHVzZSB0aGUgZyBmbGFnLCBvciB3aGVuIHVzaW5nIFJlZ0V4cC5leGVjIHRoZSBpbmRleFxuICAgICAgICAgICAgIyAgIHdpbGwgaGF2ZSB0byBiZSByZXNldCBhdCBldmVyeSBsb29wXG4gICAgICAgICAgICByZWdFeHAgPSBuZXcgUmVnRXhwKFwiXlxcXFxzKihcIiArIHBhdHRlcm4gKyBcIilcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIoPzpcXFxcOlxcXFxzKihbXFxcXHNcXFxcU10qPykpP1xcXFxzKiRcIiwgXCJcIilcbiAgICAgICAgICAgIG1hdGNoID0gcmVnRXhwLmV4ZWMoaW5UZXh0KVxuXG4gICAgICAgICAgICBpZiBtYXRjaFxuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChcbiAgICAgICAgICAgICAgICAgICAgXCJyYXdWYXJpYWJsZVwiOiBcInt7XCIgKyBtYXRjaFswXSArIFwifX1cIlxuICAgICAgICAgICAgICAgICAgICBcIm5hbWVcIjogbWF0Y2hbMV1cbiAgICAgICAgICAgICAgICAgICAgXCJ2YWx1ZVwiOiBtYXRjaFsyXVxuICAgICAgICAgICAgICAgICAgICBcImluZGV4XCI6IGRicmFja2V0WzBdXG4gICAgICAgICAgICAgICAgICAgIFwibGVuZ3RoXCI6IGRicmFja2V0WzFdICsgMiAtIGRicmFja2V0WzBdKVxuXG4gICAgICAgIHJldHVybiByZXN1bHRzXG5cbiAgICBmaW5kVHJhbnNjbHVzaW9uc0VuZ2luZTogKHNvdXJjZSwgcGF0dGVybiwgdGVtcGxhdGVzT25seSkgLT5cbiAgICAgICAgIyBwYXR0ZXJuIG11c3QgYmUgYSBzdHJpbmcgYW5kIElUIE1VU1QgTk9UIEhBVkUgQU5ZIENBUFRVUklOR1xuICAgICAgICAjICAgR1JPVVBTXG4gICAgICAgICMgTWFrZSBzdXJlIHRvIHByZXBhcmUgd2hpdGVzcGFjZSBpbiBwYXR0ZXJuIGxpa2UgaW5cbiAgICAgICAgIyAgIHByZXBhcmVSZWdleHBXaGl0ZXNwYWNlXG4gICAgICAgICMgVGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBnZW5lcmljIHRyYW5zY2x1c2lvbnMgYW5kIHRlbXBsYXRlcyBpcyB0aGVcbiAgICAgICAgIyAgIHBvc3NpYmlsaXR5IG9mIGEgY29sb24gYmVmb3JlIHRoZSB0aXRsZSB3aGljaCBmb3JjZXMgdGhlXG4gICAgICAgICMgICB0cmFuc2NsdXNpb24gb2YgYSBwYWdlIGluc3RlYWQgb2YgYSB0ZW1wbGF0ZVxuICAgICAgICAjIFRoZXJlIGNhbid0IGJlIGFuIHVuZGVyc2NvcmUgYmVmb3JlIHRoZSBjb2xvblxuICAgICAgICAjIFRoZSB0aXRsZSBtdXN0IG5vdCBiZSBicm9rZW4gYnkgbmV3IGxpbmUgY2hhcmFjdGVyczsgYW55IHVuZGVyc2NvcmVzXG4gICAgICAgICMgICBtdXN0IGJlIGluIHRoZSBzYW1lIGxpbmUgYXMgdGhlIHRpdGxlLCBldmVuIHRob3VnaCB0aGVuIHRoZXkgYXJlXG4gICAgICAgICMgICBjb25zaWRlcmVkIGFzIHdoaXRlc3BhY2VcbiAgICAgICAgIyBUZW1wbGF0ZSBuYW1lcyBhcmUgY2FzZS1zZW5zaXRpdmUsIGp1c3QgbWFrZSBzdXJlIHRvIHByZXBhcmUgdGhlbVxuICAgICAgICAjICAgd2l0aCBwcmVwYXJlVGl0bGVDYXNpbmdcbiAgICAgICAgIyBEbyAqbm90KiB1c2UgdGhlIGcgZmxhZywgb3Igd2hlbiB1c2luZyBSZWdFeHAuZXhlYyB0aGUgaW5kZXggd2lsbFxuICAgICAgICAjICAgaGF2ZSB0byBiZSByZXNldCBhdCBldmVyeSBsb29wXG4gICAgICAgIHJlZ0V4cCA9IG5ldyBSZWdFeHAoXCJeKFxcXFxzKlwiICsgKGlmIHRlbXBsYXRlc09ubHkgdGhlbiBcIlwiIGVsc2UgXCI6P1wiKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJbXyBdKihcIiArIHBhdHRlcm4gKyBcIilbXyBdKlxcXFxzKilcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIoPzpcXFxcfChbXFxcXHNcXFxcU10qKSk/JFwiLCBcIlwiKVxuXG4gICAgICAgIG5Tb3VyY2UgPSBAbmV1dHJhbGl6ZU5vd2lraVRhZ3Moc291cmNlKVxuICAgICAgICB0cmFuc2NsdXNpb25zID0gW11cbiAgICAgICAgZGJyYWNrZXRzID0gU3RyLmZpbmROZXN0ZWRFbmNsb3N1cmVzKG5Tb3VyY2UsIFwie3tcIiwgXCJ9fVwiLCBcInhcIilbMF1cblxuICAgICAgICBmb3IgZGJyYWNrZXQgaW4gZGJyYWNrZXRzXG4gICAgICAgICAgICBpblRleHQgPSBzb3VyY2Uuc3Vic3RyaW5nKGRicmFja2V0WzBdICsgMiwgZGJyYWNrZXRbMV0pXG4gICAgICAgICAgICBtYXRjaCA9IHJlZ0V4cC5leGVjKGluVGV4dClcblxuICAgICAgICAgICAgaWYgbWF0Y2hcbiAgICAgICAgICAgICAgICAjIDMgaXMgdGhlIGxlbmd0aCBvZiBcInt7XCIgKyB0aGUgZmlyc3QgXCJ8XCJcbiAgICAgICAgICAgICAgICBhcmdJbmRleCA9IGRicmFja2V0WzBdICsgbWF0Y2hbMV0ubGVuZ3RoICsgM1xuXG4gICAgICAgICAgICAgICAgdHJhbnNjbHVzaW9ucy5wdXNoKFxuICAgICAgICAgICAgICAgICAgICBcInJhd1RyYW5zY2x1c2lvblwiOiBcInt7XCIgKyBtYXRjaFswXSArIFwifX1cIlxuICAgICAgICAgICAgICAgICAgICBcInRpdGxlXCI6IG1hdGNoWzJdXG4gICAgICAgICAgICAgICAgICAgIFwiaW5kZXhcIjogZGJyYWNrZXRbMF1cbiAgICAgICAgICAgICAgICAgICAgXCJsZW5ndGhcIjogZGJyYWNrZXRbMV0gLSBkYnJhY2tldFswXSArIDJcbiAgICAgICAgICAgICAgICAgICAgXCJhcmd1bWVudHNcIjogQGZpbmRUcmFuc2NsdXNpb25Bcmd1bWVudHMobWF0Y2gsIGFyZ0luZGV4KVxuICAgICAgICAgICAgICAgIClcblxuICAgICAgICByZXR1cm4gdHJhbnNjbHVzaW9uc1xuXG4gICAgZmluZFRyYW5zY2x1c2lvbkFyZ3VtZW50czogKG1hdGNoLCBhcmdJbmRleCkgLT5cbiAgICAgICAgcmF3QXJndW1lbnRzID0gbWF0Y2hbM11cbiAgICAgICAgYXJncyA9IFtdXG5cbiAgICAgICAgaWYgcmF3QXJndW1lbnRzXG4gICAgICAgICAgICBuQXJncyA9IEBuZXV0cmFsaXplTm93aWtpVGFncyhyYXdBcmd1bWVudHMpXG5cbiAgICAgICAgICAgICMgTWFzayBhbnkgaW5uZXIgbGlua3MsIHNvIHRoYXQgdGhlaXIgXCJ8XCIgY2hhcmFjdGVycyB3b24ndCBiZVxuICAgICAgICAgICAgIyAgIGludGVycHJldGVkIGFzIGJlbG9uZ2luZyB0byB0aGUgdGVtcGxhdGVcbiAgICAgICAgICAgICMgICBOb3RlIHRoYXQgZG91YmxlIGJyYWNlcyAoXCJbW11dXCIpIFwiZXNjYXBlXCIgYSBwaXBlIGluIGEgdGVtcGxhdGVcbiAgICAgICAgICAgICMgICBhcmd1bWVudCBldmVuIGlmIGEgbGluayBpcyBub3QgY29ycmVjdGx5IGZvcm1lZCwgZS5nLiBbW3xdXSBvclxuICAgICAgICAgICAgIyAgIHVzaW5nIHVuYWxsb3dlZCBjaGFyYWN0ZXJzIGV0Yy5cbiAgICAgICAgICAgIG1hc2tlZEFyZ3MgPSBTdHIuZmluZE5lc3RlZEVuY2xvc3VyZXMobkFyZ3MsIFwiW1tcIiwgXCJdXVwiLCBcInhcIilbMV1cblxuICAgICAgICAgICAgIyBNYXNrIGFueSBpbm5lciB0ZW1wbGF0ZXMsIHNvIHRoYXQgdGhlaXIgXCJ8XCIgY2hhcmFjdGVycyB3b24ndCBiZVxuICAgICAgICAgICAgIyAgIGludGVycHJldGVkIGFzIGJlbG9uZ2luZyB0byB0aGUgb3V0ZXIgdGVtcGxhdGVcbiAgICAgICAgICAgIG1hc2tlZEFyZ3MgPSBTdHIuZmluZE5lc3RlZEVuY2xvc3VyZXMobWFza2VkQXJncywgXCJ7e1wiLCBcIn19XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwieFwiKVsxXVxuXG4gICAgICAgICAgICAjIEFsc28gdGFibGVzIHdvdWxkIGhhdmUgcGlwZXMsIGJ1dCB1c2luZyB0YWJsZXMgaW5zaWRlIHRlbXBsYXRlc1xuICAgICAgICAgICAgIyAgIGRvZXNuJ3Qgc2VlbSB0byBiZSBzdXBwb3J0ZWQgYnkgTWVkaWFXaWtpLCBleGNlcHQgaWYgZW5jbG9zaW5nXG4gICAgICAgICAgICAjICAgdGhlbSBpbiBzcGVjaWFsIHBhcnNlciBmdW5jdGlvbnMsIGUuZy5cbiAgICAgICAgICAgICMgICBodHRwOi8vd3d3Lm1lZGlhd2lraS5vcmcvd2lraS9FeHRlbnNpb246UGlwZV9Fc2NhcGUgd2hpY2hcbiAgICAgICAgICAgICMgICB3b3VsZCB0aGVuIGJlIHNhZmVseSBtYXNrZWQgYnkgdGhlIGZ1bmN0aW9uIGFib3ZlXG5cbiAgICAgICAgICAgICMgSW5jb21wbGV0ZSBsaW5rcyBhbmQgdGVtcGxhdGVzIGluIHRoZSBhcmd1bWVudHMgdGV4dCBoYXZlIGFuXG4gICAgICAgICAgICAjICAgYXBwYXJlbnRseSB3ZWlyZCBiZWhhdmlvdXIsIGhhcmQgdG8gcmV2ZXJzZS1lbmdpbmVlciwgc28gaXNzdWVcbiAgICAgICAgICAgICMgICBhIHdhcm5pbmcgd2hlbiBvbmUgaXMgZm91bmRcbiAgICAgICAgICAgICMgICBUcnkgZm9yIGV4YW1wbGUgdGhlIGZvbGxvd2luZyBjYXNlczpcbiAgICAgICAgICAgICMgICAgIDAwMHt7aGN8QkJCW1tBQUF8WlpafX1DQ0NdXTExMVxuICAgICAgICAgICAgIyAgICAgMDAwe3toY3xCQkJbW0FBQX19Q0NDfFpaWl1dMTExXG4gICAgICAgICAgICAjICAgICAwMDBbW0JCQnt7aGN8QUFBfFpaWl1dQ0NDfX0xMTFcbiAgICAgICAgICAgICMgICAgIDAwMHt7aGN8QkJCW1tBQUF8WlpafX1bW0tLS11dMTExMDAwe3toY3xBQUF8QkJCfX0xMTFcbiAgICAgICAgICAgICMgICAgIHt7YmN8e3tBY2N1cmFjeXxbW3Rlc3R9fV1dfX1cbiAgICAgICAgICAgICMgICAgIHt7YmN8e3tBY2N1cmFjeXxbW3Rlc3R8fX1dXX19XG4gICAgICAgICAgICAjICAgICB7e0FjY3VyYWN5fFtbfX1dXVxuICAgICAgICAgICAgIyAgICAge3tBY2N1cmFjeXxbW3Rlc3R8fX1dXVxuICAgICAgICAgICAgIyAgICAgW1t7e0FjY3VyYWN5fF1dfX1cbiAgICAgICAgICAgICMgICAgIFtbdGVzdHx7e0FjY3VyYWN5fF1dfX1cbiAgICAgICAgICAgICMgICAgIFtbdGVzdHx7e0FjY3VyYWN5fF1dXG4gICAgICAgICAgICAjICAgICBbW3Rlc3R8e3tpY3xhYWFdXX19XG4gICAgICAgICAgICAjICAgTm90ZSB0aGF0IHRoZSB0aXRsZSBhbHJlYWR5IGRvZXNuJ3QgYWxsb3cgXCJ7XCIsIFwifVwiLCBcIltcIiBub3JcbiAgICAgICAgICAgICMgICAgIFwiXVwiXG4gICAgICAgICAgICBpZiBtYXNrZWRBcmdzLnNlYXJjaCgvKFxce1xce3xcXH1cXH18XFxbXFxbfFxcXVxcXSkvKSA+IC0xXG4gICAgICAgICAgICAgICAgQXBwLmxvZy5sb2dXYXJuaW5nKFwie3tcIiArIG1hdGNoWzBdICsgXCJ9fSBzZWVtcyB0b1xuICAgICAgICAgICAgICAgICAgICBjb250YWluIHBhcnQgb2YgYSBsaW5rIG9yIHRlbXBsYXRlLCBhbmQgdGhlIHJlc3VsdGluZ1xuICAgICAgICAgICAgICAgICAgICBiZWhhdmlvdXIgY2Fubm90IGJlIHByZWRpY3RlZCBieSB0aGlzIGZ1bmN0aW9uLCBzb1xuICAgICAgICAgICAgICAgICAgICB0aGUgd2hvbGUgdGVtcGxhdGUgd2lsbCBiZSBpZ25vcmVkIGFsdG9nZXRoZXJcIilcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBtQXJncyA9IG1hc2tlZEFyZ3Muc3BsaXQoXCJ8XCIpXG4gICAgICAgICAgICAgICAgcmVsSW5kZXggPSAwXG5cbiAgICAgICAgICAgICAgICBmb3IgbUFyZ3VtZW50IGluIG1BcmdzXG4gICAgICAgICAgICAgICAgICAgIGFyZ0wgPSBtQXJndW1lbnQubGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50ID0gcmF3QXJndW1lbnRzLnN1YnN0cihyZWxJbmRleCwgYXJnTClcbiAgICAgICAgICAgICAgICAgICAgZXFJbmRleCA9IG1Bcmd1bWVudC5pbmRleE9mKFwiPVwiKVxuXG4gICAgICAgICAgICAgICAgICAgICMgZXFJbmRleCBtdXN0IGJlID4gMCwgbm90IC0xLCBpbiBmYWN0IHRoZSBrZXkgbXVzdCBub3QgYmVcbiAgICAgICAgICAgICAgICAgICAgIyAgIGVtcHR5XG4gICAgICAgICAgICAgICAgICAgIGlmIGVxSW5kZXggPiAwXG4gICAgICAgICAgICAgICAgICAgICAgICByYXdLZXkgPSBhcmd1bWVudC5zdWJzdHJpbmcoMCwgZXFJbmRleClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlS2V5ID0gL14oXFxzKikoLis/KVxccyokL1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5TWF0Y2hlcyA9IHJlS2V5LmV4ZWMocmF3S2V5KVxuICAgICAgICAgICAgICAgICAgICAgICAga2V5ID0ga2V5TWF0Y2hlc1syXVxuICAgICAgICAgICAgICAgICAgICAgICAga2V5SW5kZXggPSBhcmdJbmRleCArIChpZiBrZXlNYXRjaGVzWzFdIHRoZW4ga2V5TWF0Y2hlc1sxXS5sZW5ndGggZWxzZSAwKVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAjIDEgaXMgdGhlIGxlbmd0aCBvZiBcIj1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBhcmd1bWVudC5zdWJzdHIoZXFJbmRleCArIDEpXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZUluZGV4ID0gYXJnSW5kZXggKyBrZXlNYXRjaGVzWzBdLmxlbmd0aCArIDFcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAga2V5ID0gbnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAga2V5SW5kZXggPSBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGFyZ3VtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZUluZGV4ID0gYXJnSW5kZXhcblxuICAgICAgICAgICAgICAgICAgICBhcmdzLnB1c2goXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6IGtleVxuICAgICAgICAgICAgICAgICAgICAgICAga2V5X2luZGV4OiBrZXlJbmRleFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZV9pbmRleDogdmFsdWVJbmRleFxuICAgICAgICAgICAgICAgICAgICApXG5cbiAgICAgICAgICAgICAgICAgICAgIyAxIGlzIHRoZSBsZW5ndGggb2YgXCJ8XCJcbiAgICAgICAgICAgICAgICAgICAgcmVsSW5kZXggKz0gYXJnTCArIDFcblxuICAgICAgICByZXR1cm4gYXJnc1xuXG4gICAgZmluZFRlbXBsYXRlczogKHNvdXJjZSwgdGVtcGxhdGUpIC0+XG4gICAgICAgIGlmIHRlbXBsYXRlXG4gICAgICAgICAgICBwYXR0ZXJuID0gbXcuUmVnRXhwLmVzY2FwZSh0ZW1wbGF0ZSlcbiAgICAgICAgICAgIHBhdHRlcm4gPSBwcmVwYXJlUmVnZXhwV2hpdGVzcGFjZShwYXR0ZXJuKVxuICAgICAgICAgICAgcGF0dGVybiA9IHByZXBhcmVUaXRsZUNhc2luZyhwYXR0ZXJuKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICBwYXR0ZXJuID0gXCJbXlxcXFxuXFxcXHtcXFxcfVxcXFxbXFxcXF1cXFxcfHxcXFxcI10rP1wiXG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZmluZFRlbXBsYXRlc1BhdHRlcm4oc291cmNlLCBwYXR0ZXJuKVxuXG4gICAgZmluZFRlbXBsYXRlc1BhdHRlcm46IChzb3VyY2UsIHBhdHRlcm4pIC0+XG4gICAgICAgICMgcGF0dGVybiBtdXN0IGJlIGEgc3RyaW5nIGFuZCBJVCBNVVNUIE5PVCBIQVZFIEFOWSBDQVBUVVJJTkdcbiAgICAgICAgIyAgIEdST1VQU1xuICAgICAgICAjIE1ha2Ugc3VyZSB0byBwcmVwYXJlIHdoaXRlc3BhY2UgaW4gcGF0dGVybiBsaWtlIGluXG4gICAgICAgICMgICBwcmVwYXJlUmVnZXhwV2hpdGVzcGFjZVxuICAgICAgICAjIFRlbXBsYXRlcyBjYW4ndCBiZSB0cmFuc2NsdWRlZCB3aXRoIGEgY29sb24gYmVmb3JlIHRoZSB0aXRsZVxuICAgICAgICAjIFRoZSB0aXRsZSBtdXN0IG5vdCBiZSBicm9rZW4gYnkgbmV3IGxpbmUgY2hhcmFjdGVyczsgYW55IHVuZGVyc2NvcmVzXG4gICAgICAgICMgICBtdXN0IGJlIGluIHRoZSBzYW1lIGxpbmUgYXMgdGhlIHRpdGxlLCBldmVuIHRob3VnaCB0aGVuIHRoZXkgYXJlXG4gICAgICAgICMgICBjb25zaWRlcmVkIGFzIHdoaXRlc3BhY2VcbiAgICAgICAgcmV0dXJuIEBmaW5kVHJhbnNjbHVzaW9uc0VuZ2luZShzb3VyY2UsIHBhdHRlcm4sIHRydWUpXG5cbiAgICBmaW5kVHJhbnNjbHVzaW9uczogKHNvdXJjZSwgbmFtZXNwYWNlLCB0aXRsZSkgLT5cbiAgICAgICAgIyBUaGUgZGlmZmVyZW5jZSBmcm9tIHRlbXBsYXRlcyBpcyB0aGUgcG9zc2liaWxpdHkgb2YgYSBjb2xvbiBiZWZvcmVcbiAgICAgICAgIyAgIHRoZSB0aXRsZSB3aGljaCBmb3JjZXMgdGhlIHRyYW5zY2x1c2lvbiBvZiBhIHBhZ2UgaW5zdGVhZCBvZiBhXG4gICAgICAgICMgICB0ZW1wbGF0ZVxuICAgICAgICAjIFRoZXJlIGNhbid0IGJlIGFuIHVuZGVyc2NvcmUgYmVmb3JlIHRoZSBjb2xvblxuICAgICAgICAjIFRoZSB0aXRsZSBtdXN0IG5vdCBiZSBicm9rZW4gYnkgbmV3IGxpbmUgY2hhcmFjdGVyczsgYW55IHVuZGVyc2NvcmVzXG4gICAgICAgICMgICBtdXN0IGJlIGluIHRoZSBzYW1lIGxpbmUgYXMgdGhlIHRpdGxlLCBldmVuIHRob3VnaCB0aGVuIHRoZXkgYXJlXG4gICAgICAgICMgICBjb25zaWRlcmVkIGFzIHdoaXRlc3BhY2VcbiAgICAgICAgdGl0bGVDaGFycyA9IFwiW15cXFxcblxcXFx7XFxcXH1cXFxcW1xcXFxdXFxcXHx8XFxcXCNdKz9cIlxuXG4gICAgICAgIGlmIG5hbWVzcGFjZVxuICAgICAgICAgICAgbmFtZXNwYWNlUGF0dGVybiA9IG13LlJlZ0V4cC5lc2NhcGUobmFtZXNwYWNlKVxuICAgICAgICAgICAgbmFtZXNwYWNlUGF0dGVybiA9IHByZXBhcmVSZWdleHBXaGl0ZXNwYWNlKG5hbWVzcGFjZVBhdHRlcm4pXG4gICAgICAgICAgICBuYW1lc3BhY2VQYXR0ZXJuID0gcHJlcGFyZVRpdGxlQ2FzaW5nKG5hbWVzcGFjZVBhdHRlcm4pXG5cbiAgICAgICAgaWYgdGl0bGVcbiAgICAgICAgICAgIHRpdGxlUGF0dGVybiA9IG13LlJlZ0V4cC5lc2NhcGUodGl0bGUpXG4gICAgICAgICAgICB0aXRsZVBhdHRlcm4gPSBwcmVwYXJlUmVnZXhwV2hpdGVzcGFjZSh0aXRsZVBhdHRlcm4pXG4gICAgICAgICAgICB0aXRsZVBhdHRlcm4gPSBwcmVwYXJlVGl0bGVDYXNpbmcodGl0bGVQYXR0ZXJuKVxuXG4gICAgICAgIGlmIG5hbWVzcGFjZVBhdHRlcm4gYW5kIHRpdGxlUGF0dGVyblxuICAgICAgICAgICAgcGF0dGVybiA9IG5hbWVzcGFjZVBhdHRlcm4gKyBcIlsgX10qOlsgX10qXCIgKyB0aXRsZVBhdHRlcm5cbiAgICAgICAgZWxzZSBpZiBub3QgbmFtZXNwYWNlUGF0dGVybiBhbmQgdGl0bGVQYXR0ZXJuXG4gICAgICAgICAgICBwYXR0ZXJuID0gdGl0bGVQYXR0ZXJuXG4gICAgICAgIGVsc2UgaWYgbmFtZXNwYWNlUGF0dGVybiBhbmQgbm90IHRpdGxlUGF0dGVyblxuICAgICAgICAgICAgcGF0dGVybiA9IG5hbWVzcGFjZVBhdHRlcm4gKyBcIlsgX10qOlwiICsgdGl0bGVDaGFyc1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBwYXR0ZXJuID0gdGl0bGVDaGFyc1xuXG4gICAgICAgIHJldHVybiBAZmluZFRyYW5zY2x1c2lvbnNFbmdpbmUoc291cmNlLCBwYXR0ZXJuLCBmYWxzZSlcblxuICAgIGZpbmRTZWN0aW9uSGVhZGluZ3M6IChzb3VyY2UpIC0+XG4gICAgICAgICMgPT09PT09VGl0bGU9PT09PT0gaXMgdGhlIGRlZXBlc3QgbGV2ZWwgc3VwcG9ydGVkXG4gICAgICAgIE1BWExFVkVMID0gNlxuXG4gICAgICAgIHNlY3Rpb25zID0gW11cbiAgICAgICAgbWluTGV2ZWwgPSBNQVhMRVZFTFxuICAgICAgICBtYXhUb2NMZXZlbCA9IDBcbiAgICAgICAgdG9jTGV2ZWwgPSAxXG4gICAgICAgIHJlZ0V4cCA9IC9eKFxcPSsoWyBfXSooLis/KVsgX10qKVxcPSspWyBcXHRdKiQvZ21cblxuICAgICAgICB3aGlsZSB0cnVlXG4gICAgICAgICAgICBtYXRjaCA9IHJlZ0V4cC5leGVjKHNvdXJjZSlcblxuICAgICAgICAgICAgaWYgbWF0Y2hcbiAgICAgICAgICAgICAgICBMMCA9IG1hdGNoWzBdLmxlbmd0aFxuICAgICAgICAgICAgICAgIGxpbmUgPSBtYXRjaFsxXVxuICAgICAgICAgICAgICAgIHJhd2hlYWRpbmcgPSBtYXRjaFsyXVxuICAgICAgICAgICAgICAgIGhlYWRpbmcgPSBtYXRjaFszXVxuICAgICAgICAgICAgICAgIGNsZWFuaGVhZGluZyA9IEBzcXVhc2hDb250aWd1b3VzV2hpdGVzcGFjZShoZWFkaW5nKVxuICAgICAgICAgICAgICAgIEwxID0gbGluZS5sZW5ndGhcbiAgICAgICAgICAgICAgICBsZXZlbCA9IDFcbiAgICAgICAgICAgICAgICBzdGFydCA9IFwiPVwiXG4gICAgICAgICAgICAgICAgZW5kID0gXCI9XCJcblxuICAgICAgICAgICAgICAgICMgPT1UaXRsZT09PSBhbmQgPT09VGl0bGU9PSBhcmUgYm90aCAybmQgbGV2ZWxzIGFuZCBzbyBvblxuICAgICAgICAgICAgICAgICMgKHRoZSBzaG9ydGVzdCBzZXF1ZW5jZSBvZiA9IGJldHdlZW4gdGhlIHR3byBzaWRlcyBpc1xuICAgICAgICAgICAgICAgICMgIGNvbnNpZGVyZWQpXG5cbiAgICAgICAgICAgICAgICAjID0gYW5kID09IGFyZSBub3QgdGl0bGVzXG4gICAgICAgICAgICAgICAgIyA9PT0gaXMgcmVhZCBhcyA9KD0pPSwgPT09PSBpcyByZWFkIGFzID0oPT0pPSAoYm90aCAxc3RcbiAgICAgICAgICAgICAgICAjICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXZlbHMpXG4gICAgICAgICAgICAgICAgIyA9PT09PSBpcyByZWFkIGFzID09KD0pPT0gKDJuZCBsZXZlbCkgYW5kIHNvIG9uXG5cbiAgICAgICAgICAgICAgICB3aGlsZSB0cnVlXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gbGluZS5zdWJzdHIobGV2ZWwsIDEpXG4gICAgICAgICAgICAgICAgICAgIGVuZCA9IGxpbmUuc3Vic3RyKEwxIC0gbGV2ZWwgLSAxLCAxKVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIEwxIC0gbGV2ZWwgKiAyID4gMiBhbmQgc3RhcnQgPT0gXCI9XCIgYW5kIGVuZCA9PSBcIj1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgbGV2ZWwrK1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiBsZXZlbCA+IE1BWExFVkVMXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV2ZWwgPSBNQVhMRVZFTFxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiBsZXZlbCA8IG1pbkxldmVsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluTGV2ZWwgPSBsZXZlbFxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcblxuICAgICAgICAgICAgICAgIGlmIGxldmVsID09IG1pbkxldmVsXG4gICAgICAgICAgICAgICAgICAgIHRvY0xldmVsID0gMVxuICAgICAgICAgICAgICAgICAgICBwcmV2TGV2ZWxzID0ge31cbiAgICAgICAgICAgICAgICAgICAgcHJldkxldmVsc1tsZXZlbF0gPSAxXG4gICAgICAgICAgICAgICAgICAgIHByZXZMZXZlbHMucmVsTWF4ID0gbGV2ZWxcbiAgICAgICAgICAgICAgICAgICAgaWYgbWF4VG9jTGV2ZWwgPT0gMFxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4VG9jTGV2ZWwgPSB0b2NMZXZlbFxuICAgICAgICAgICAgICAgIGVsc2UgaWYgbGV2ZWwgPiBwcmV2TGV2ZWxzLnJlbE1heFxuICAgICAgICAgICAgICAgICAgICB0b2NMZXZlbCsrXG4gICAgICAgICAgICAgICAgICAgIHByZXZMZXZlbHNbbGV2ZWxdID0gdG9jTGV2ZWxcbiAgICAgICAgICAgICAgICAgICAgcHJldkxldmVscy5yZWxNYXggPSBsZXZlbFxuICAgICAgICAgICAgICAgICAgICBpZiB0b2NMZXZlbCA+IG1heFRvY0xldmVsXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhUb2NMZXZlbCA9IHRvY0xldmVsXG4gICAgICAgICAgICAgICAgZWxzZSBpZiBsZXZlbCA8IHByZXZMZXZlbHMucmVsTWF4XG4gICAgICAgICAgICAgICAgICAgIGlmIHByZXZMZXZlbHNbbGV2ZWxdXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2NMZXZlbCA9IHByZXZMZXZlbHNbbGV2ZWxdXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICMgdG9jUGVlciBpcyB0aGUgbGV2ZWwgaW1tZWRpYXRlbHkgZ3JlYXRlciB0aGFuIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgIyBjdXJyZW50IG9uZSwgYW5kIGl0IHNob3VsZCBoYXZlIHRoZSBzYW1lIHRvY0xldmVsXG4gICAgICAgICAgICAgICAgICAgICAgICAjIEkgbXVzdCByZXNldCB0b2NQZWVyIGhlcmUgdG8gdGhlIHJlbGF0aXZlIG1heGltdW1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRvY1BlZXIgPSBwcmV2TGV2ZWxzLnJlbE1heFxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIHBMZXZlbCBpbiBwcmV2TGV2ZWxzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgcExldmVsID4gbGV2ZWwgYW5kIHBMZXZlbCA8IHRvY1BlZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9jUGVlciA9IHBMZXZlbFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9jTGV2ZWwgPSBwcmV2TGV2ZWxzW3RvY1BlZXJdXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2TGV2ZWxzW2xldmVsXSA9IHRvY0xldmVsXG4gICAgICAgICAgICAgICAgICAgIHByZXZMZXZlbHMucmVsTWF4ID0gbGV2ZWxcblxuICAgICAgICAgICAgICAgIHNlY3Rpb25zLnB1c2goXG4gICAgICAgICAgICAgICAgICAgIGxpbmU6IGxpbmVcbiAgICAgICAgICAgICAgICAgICAgcmF3aGVhZGluZzogcmF3aGVhZGluZ1xuICAgICAgICAgICAgICAgICAgICBoZWFkaW5nOiBoZWFkaW5nXG4gICAgICAgICAgICAgICAgICAgIGNsZWFuaGVhZGluZzogY2xlYW5oZWFkaW5nXG4gICAgICAgICAgICAgICAgICAgIGxldmVsOiBsZXZlbFxuICAgICAgICAgICAgICAgICAgICB0b2NMZXZlbDogdG9jTGV2ZWxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IChyZWdFeHAubGFzdEluZGV4IC0gTDApXG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aDA6IEwwXG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aDE6IEwxXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgIyBBcnRpY2xlcyB3aXRob3V0IHNlY3Rpb25zXG4gICAgICAgIGlmIG1heFRvY0xldmVsID09IDBcbiAgICAgICAgICAgIG1pbkxldmVsID0gMFxuXG4gICAgICAgIHJldHVybiB7c2VjdGlvbnM6IHNlY3Rpb25zLCBtaW5MZXZlbDogbWluTGV2ZWwsIG1heFRvY0xldmVsOiBtYXhUb2NMZXZlbH1cbiIsIiMgV2lraSBNb25rZXkgLSBNZWRpYVdpa2kgYm90IGFuZCBlZGl0b3ItYXNzaXN0YW50IHVzZXIgc2NyaXB0XG4jIENvcHlyaWdodCAoQykgMjAxMSBEYXJpbyBHaW92YW5uZXR0aSA8ZGV2QGRhcmlvZ2lvdmFubmV0dGkubmV0PlxuI1xuIyBUaGlzIGZpbGUgaXMgcGFydCBvZiBXaWtpIE1vbmtleS5cbiNcbiMgV2lraSBNb25rZXkgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuIyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuIyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuIyAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuI1xuIyBXaWtpIE1vbmtleSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuIyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuIyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4jIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4jXG4jIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4jIGFsb25nIHdpdGggV2lraSBNb25rZXkuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG5cblN0ciA9IHJlcXVpcmUoJ0BreW5pa29zL21pc2MvZGlzdC9TdHInKVxuXG5cbmNsYXNzIG1vZHVsZS5leHBvcnRzXG4gICAgY29uc3RydWN0b3I6IChAV00pIC0+XG5cbiAgICBhcHBlbmRSb3c6IChzb3VyY2UsIG1hcmssIHZhbHVlcykgLT5cbiAgICAgICAgbGFzdElkID0gc291cmNlLmxhc3RJbmRleE9mKCd8fScgKyBtYXJrKVxuICAgICAgICBlbmR0YWJsZSA9IGlmIGxhc3RJZCA+IC0xIHRoZW4gbGFzdElkIGVsc2Ugc291cmNlLmxhc3RJbmRleE9mKCd8fScpXG5cbiAgICAgICAgcm93ID0gXCJ8LVxcbnxcIiArIHZhbHVlcy5qb2luKFwiXFxufFwiKSArIFwiXFxuXCJcblxuICAgICAgICBuZXdUZXh0ID0gU3RyLmluc2VydChzb3VyY2UsIHJvdywgZW5kdGFibGUpXG5cbiAgICAgICAgcmV0dXJuIG5ld1RleHRcbiIsIiMgV2lraSBNb25rZXkgLSBNZWRpYVdpa2kgYm90IGFuZCBlZGl0b3ItYXNzaXN0YW50IHVzZXIgc2NyaXB0XG4jIENvcHlyaWdodCAoQykgMjAxMSBEYXJpbyBHaW92YW5uZXR0aSA8ZGV2QGRhcmlvZ2lvdmFubmV0dGkubmV0PlxuI1xuIyBUaGlzIGZpbGUgaXMgcGFydCBvZiBXaWtpIE1vbmtleS5cbiNcbiMgV2lraSBNb25rZXkgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuIyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuIyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuIyAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuI1xuIyBXaWtpIE1vbmtleSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuIyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuIyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4jIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4jXG4jIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4jIGFsb25nIHdpdGggV2lraSBNb25rZXkuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG5cbnttb21lbnQsIEEsIEJyLCBEaXZ9ID0gcmVxdWlyZSgnLi9saWJzJylcbnt2ZXJzaW9ufSA9IHJlcXVpcmUoJy4uLy4uL3BhY2thZ2UuanNvbicpXG5XTSA9IHJlcXVpcmUoJy4vaW5kZXgnKVxuXG5cbmNsYXNzIG1vZHVsZS5leHBvcnRzXG4gICAgUkVQT19SQVdfVVJMID0gXCJodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20va3luaWtvcy93aWtpLW1vbmtleVwiXG5cbiAgICBjb25zdHJ1Y3RvcjogKEBXTSkgLT5cbiAgICAgICAgQGNoZWNrX29ic29sZXRlX2NvbmZpZygpXG4gICAgICAgIGlmIFdNLmNvbmYudXBkYXRlX2NoZWNrX3dkYXlzXG4gICAgICAgICAgICBAY2hlY2tfYW5kX25vdGlmeSgpXG5cbiAgICBjaGVja19hbmRfbm90aWZ5OiAtPlxuICAgICAgICBpZiBAc2hvdWxkX2NoZWNrKClcbiAgICAgICAgICAgIHVwc3RyZWFtX3BhY2thZ2UgPSBhd2FpdCAkLmdldEpTT04oXG4gICAgICAgICAgICAgICAgXCIje1JFUE9fUkFXX1VSTH0vI3tXTS5jb25mLnVwZGF0ZV9jaGVja19icmFuY2h9L3BhY2thZ2UuanNvblwiKVxuICAgICAgICAgICAgIyBXZWxsLCBvaywgdGhpcyBpcyBhc3N1bWluZyB0aGF0IGlmIHRoZSB2ZXJzaW9ucyBhcmVcbiAgICAgICAgICAgICMgZGlmZmVyZW50LCB1cHN0cmVhbSBoYXMgdGhlIGxhdGVzdFxuICAgICAgICAgICAgaWYgdmVyc2lvbiAhPSB1cHN0cmVhbV9wYWNrYWdlLnZlcnNpb25cbiAgICAgICAgICAgICAgICBAZGlzcGxheV9ub3RpZmljYXRpb24oW1xuICAgICAgICAgICAgICAgICAgICBcIlZlcnNpb24gI3t1cHN0cmVhbV9wYWNrYWdlLnZlcnNpb259IGlzIGF2YWlsYWJsZS5cIlxuICAgICAgICAgICAgICAgICAgICBCcigpXG4gICAgICAgICAgICAgICAgICAgIEEoe2hyZWY6IFwiaHR0cHM6Ly9naXRodWIuY29tL2t5bmlrb3Mvd2lraS1tb25rZXkvd2lraS9DaGFuZ2Vsb2dcIn0gICMgbm9xYVxuICAgICAgICAgICAgICAgICAgICAgICAgXCJDaGFuZ2Vsb2dcIilcbiAgICAgICAgICAgICAgICAgICAgQnIoKVxuICAgICAgICAgICAgICAgICAgICBBKCdSdW4gdXBncmFkZScsIHtvbmNsaWNrOiA9PlxuICAgICAgICAgICAgICAgICAgICAgICAgQHVwZ3JhZGUodXBzdHJlYW1fcGFja2FnZS52ZXJzaW9uKVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgbXcuc3RvcmFnZS5zZXQoJ1dpa2lNb25rZXktbGFzdC11cGRhdGUtY2hlY2snLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vbWVudCgpLmZvcm1hdCgnWVlZWS1NTS1ERCcpKVxuXG4gICAgc2hvdWxkX2NoZWNrOiAtPlxuICAgICAgICBsYXN0dXBkY2hlY2sgPSBtdy5zdG9yYWdlLmdldCgnV2lraU1vbmtleS1sYXN0LXVwZGF0ZS1jaGVjaycpXG4gICAgICAgIGlmIG5vdCBsYXN0dXBkY2hlY2tcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG5cbiAgICAgICAgZGlmZiA9IG1vbWVudCgpLmRpZmYobW9tZW50KGxhc3R1cGRjaGVjayksICdkYXlzJylcbiAgICAgICAgIyBQcmVmZXJhYmx5IGNoZWNrIG9uIHRoZSBjb25maWd1cmVkIGRheSBvZiB0aGUgd2VlaywgYnV0IGRvbid0IGxldFxuICAgICAgICAjIG1vcmUgdGhhbiA3IGRheXMgcGFzcyB3aXRob3V0IGNoZWNraW5nIGluIGFueSBjYXNlXG4gICAgICAgIGlmIChkaWZmID49IDEgYW5kIG1vbWVudCgpLmRheSgpIGluXG4gICAgICAgICAgICAgICAgV00uY29uZi51cGRhdGVfY2hlY2tfd2RheXMpIG9yIGRpZmYgPj0gN1xuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgcmV0dXJuIGZhbHNlXG5cbiAgICBkaXNwbGF5X25vdGlmaWNhdGlvbjogKGNvbnRlbnQsIG9wdGlvbnNvdmVycmlkZSkgLT5cbiAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGF1dG9IaWRlOiBmYWxzZVxuICAgICAgICAgICAgdGFnOiAnV2lraU1vbmtleS11cGdyYWRlJ1xuICAgICAgICAgICAgdGl0bGU6ICdXaWtpIE1vbmtleSdcbiAgICAgICAgICAgIHR5cGU6ICdpbmZvJ1xuICAgICAgICB9XG4gICAgICAgICQuZXh0ZW5kKG9wdGlvbnMsIG9wdGlvbnNvdmVycmlkZSlcbiAgICAgICAgbXcubm90aWZpY2F0aW9uLm5vdGlmeShjb250ZW50LCBvcHRpb25zKVxuXG4gICAgdXBncmFkZTogKHVwc3RyZWFtX3ZlcnNpb24pIC0+XG4gICAgICAgIHBhZ2UgPSBcIlVzZXI6I3ttdy51c2VyLmdldE5hbWUoKX0vY29tbW9uLmpzXCJcbiAgICAgICAgcGFnZWxpbmsgPSBAV00uTVcubGlua0FydGljbGUocGFnZSlcblxuICAgICAgICBAZGlzcGxheV9ub3RpZmljYXRpb24oXCJVcGdyYWRpbmcgdG8gdmVyc2lvbiAje3Vwc3RyZWFtX3ZlcnNpb259Li4uXCIpXG5cbiAgICAgICAgIyBUaGlzIHJlZ3VsYXIgZXhwcmVzc2lvbiBtdXN0IHN1cHBvcnQgYWxsIHZlcnNpb25zLCBpbmNsdWRpbmcgdGhlXG4gICAgICAgICMgLm1pbi5qc1xuICAgICAgICAjIFRPRE86IEFsbG93IHByZXZlbnRpbmcgdXBncmFkZXMgcGVyLWxpbmUgd2l0aCAvL25vdXBncmFkZSBjb21tZW50cz9cbiAgICAgICAgIyAgICAgICBEb24ndCB1cGdyYWRlIGNvbW1lbnRlZCBsaW5lcz9cbiAgICAgICAgcmVnZXggPSAvLy9cbiAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgICBbXCInXWh0dHBzPzovLy4rPy9reW5pa29zL3dpa2ktbW9ua2V5L3ZcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICN7bXcuUmVnRXhwLmVzY2FwZSh2ZXJzaW9uKX1cbiAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgICAvZGlzdC9XaWtpTW9ua2V5LVteL10rXFwuanNbXCInXVxuICAgICAgICAgICAgKVxuICAgICAgICAvLy9nXG5cbiAgICAgICAgQFdNLk1XLmFwaS5lZGl0KHBhZ2UsIChyZXZpc2lvbikgLT5cbiAgICAgICAgICAgIG5ld3RleHQgPSByZXZpc2lvbi5jb250ZW50LnJlcGxhY2UocmVnZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiJDEje3Vwc3RyZWFtX3ZlcnNpb259JDJcIilcblxuICAgICAgICAgICAgaWYgbmV3dGV4dCBpcyByZXZpc2lvbi5jb250ZW50XG4gICAgICAgICAgICAgICAgIyBFeGVjdXRpbmcgdGhlIHF1ZXJ5IHdvdWxkIHJldHVybiBhICdub2NoYW5nZTp0cnVlJyByZXN1bHQsXG4gICAgICAgICAgICAgICAgIyBidXQgd2UgY2FuIHRlc3QgaXQgYmVmb3JlIHNlbmRpbmcgaXRcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoXG4gICAgICAgICAgICAgICAgICAgIG5ldyBFcnJvcihcIkNvdWxkIG5vdCBmaW5kIFdpa2kgTW9ua2V5IGxvYWRlciBsaW5lXCIpKVxuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHRleHQ6IG5ld3RleHQsXG4gICAgICAgICAgICAgICAgc3VtbWFyeTogXCJVcGRhdGUgV2lraSBNb25rZXkgdG8gdmVyc2lvbiAje3Vwc3RyZWFtX3ZlcnNpb259XCIsXG4gICAgICAgICAgICAgICAgYm90OiB0cnVlLFxuICAgICAgICAgICAgfVxuICAgICAgICApLmRvbmUoKHJlc3VsdCkgPT5cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHJlc3VsdClcbiAgICAgICAgICAgIEBkaXNwbGF5X25vdGlmaWNhdGlvbihbXG4gICAgICAgICAgICAgICAgXCJVcGdyYWRlIHN1Y2Nlc3NmdWw6IHlvdSBuZWVkIHRvIHJlZnJlc2ggdGhlIG9wZW4gd2lraSBwYWdlKHMpXG4gICAgICAgICAgICAgICAgaW4gb3JkZXIgdG8gdXNlIHRoZSBuZXcgdmVyc2lvbi5cIlxuICAgICAgICAgICAgICAgIEJyKClcbiAgICAgICAgICAgICAgICBBKHtocmVmOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9reW5pa29zL3dpa2ktbW9ua2V5L3dpa2kvQ2hhbmdlbG9nXCJ9XG4gICAgICAgICAgICAgICAgICBcIkNoYW5nZWxvZ1wiKVxuICAgICAgICAgICAgXSlcbiAgICAgICAgKS5mYWlsKChjb2RlLCBlcnJvcikgPT5cbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoY29kZSwgZXJyb3IpXG4gICAgICAgICAgICBAZGlzcGxheV9ub3RpZmljYXRpb24oW1xuICAgICAgICAgICAgICAgIFwiQ291bGQgbm90IGNvbXBsZXRlIHRoZSB1cGdyYWRlIHRvIHZlcnNpb25cbiAgICAgICAgICAgICAgICAje3Vwc3RyZWFtX3ZlcnNpb259OiBcIixcbiAgICAgICAgICAgICAgICBBKHtvbmNsaWNrOiA9PlxuICAgICAgICAgICAgICAgICAgICBAdXBncmFkZSh1cHN0cmVhbV92ZXJzaW9uKVxuICAgICAgICAgICAgICAgIH0sIFwicmV0cnlcIiksXG4gICAgICAgICAgICAgICAgXCIgaW4gY2FzZSBpdCB3YXMgYSB0ZW1wb3JhcnkgcHJvYmxlbTsgaXQgaXMgYWxzbyBwb3NzaWJsZVxuICAgICAgICAgICAgICAgIHRoYXQgV2lraSBNb25rZXkgaXMgaW5zdGFsbGVkIGluIGEgbm9uLXN0YW5kYXJkIHdheSBpbiBcIixcbiAgICAgICAgICAgICAgICBwYWdlbGluaywgXCIgYW5kIHRoZSB1cGdyYWRlIHNob3VsZCBiZSBleGVjdXRlZCBtYW51YWxseTtcbiAgICAgICAgICAgICAgICBmaW5hbGx5LCBpdCBpcyBwb3NzaWJsZSB0aGF0IHRoZSB1cGdyYWRlIHdhcyBhbHJlYWR5IGxhdW5jaGVkXG4gICAgICAgICAgICAgICAgYW5kIGNvbXBsZXRlZCBmcm9tIGFub3RoZXIgcGFnZTogaW4gdGhpcyBjYXNlIHJlZnJlc2ggdGhlIHBhZ2VcbiAgICAgICAgICAgICAgICB0byB2ZXJpZnkuXCJcbiAgICAgICAgICAgIF0sIHt0eXBlOiAnZXJyb3InfSlcbiAgICAgICAgKVxuXG4gICAgY2hlY2tfb2Jzb2xldGVfY29uZmlnOiAtPlxuICAgICAgICAjIFRPRE86IFJlbW92ZSBpbiBhIGxhdGVyIHZlcnNpb25cbiAgICAgICAgb2xkY29uZiA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwiV2lraU1vbmtleVwiKVxuICAgICAgICBpZiBvbGRjb25mIGlzbnQgbnVsbFxuICAgICAgICAgICAgYmxvYiA9IG5ldyBCbG9iKFtvbGRjb25mXSwge3R5cGU6ICdhcHBsaWNhdGlvbi9qc29uJ30pXG4gICAgICAgICAgICBjb25maHJlZiA9IHdpbmRvdy5VUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpXG4gICAgICAgICAgICBAZGlzcGxheV9ub3RpZmljYXRpb24oW1xuICAgICAgICAgICAgICAgIFwiV2lraSBNb25rZXkgNC4wLjAgdXNlcyBhIGNvbXBsZXRlbHkgcmV3cml0dGVuIGNvbmZpZ3VyYXRpb25cbiAgICAgICAgICAgICAgICBzeXN0ZW0uIEFmdGVyIHVwZGF0aW5nLCB5b3VyIG9sZCBjb25maWd1cmF0aW9uIHdhcyBub3RcbiAgICAgICAgICAgICAgICBhdXRvbWF0aWNhbGx5IGltcG9ydGVkLCBidXQgaXQgaXMgc3RpbGwgc2F2ZWQgaW4geW91ciBicm93c2VyJ3NcbiAgICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2UuIFlvdSBjYW4gZGVjaWRlIHRvIGV4cG9ydCBpdCBhbmQgdGhlbiBtZXJnZSBpdFxuICAgICAgICAgICAgICAgIG1hbnVhbGx5LCBvciBzaW1wbHkgcmVtb3ZlIGl0IGFuZCB1c2UgdGhlIGRlZmF1bHQgY29uZmlndXJhdGlvblxuICAgICAgICAgICAgICAgIG9wdGlvbnMuXCJcbiAgICAgICAgICAgICAgICBCcigpXG4gICAgICAgICAgICAgICAgQSh7aHJlZjogXCJodHRwczovL2dpdGh1Yi5jb20va3luaWtvcy93aWtpLW1vbmtleS93aWtpL0NvbmZpZ3VyYXRpb25cIn0gICMgbm9xYVxuICAgICAgICAgICAgICAgICAgXCJOZXcgY29uZmlndXJhdGlvbiBpbnN0cnVjdGlvbnNcIilcbiAgICAgICAgICAgICAgICBCcigpXG4gICAgICAgICAgICAgICAgQSh7aHJlZjogY29uZmhyZWZ9LCBcIlZpZXcgb2xkIGNvbmZpZ3VyYXRpb25cIilcbiAgICAgICAgICAgICAgICBCcigpXG4gICAgICAgICAgICAgICAgQSh7aHJlZjogY29uZmhyZWYsIGRvd25sb2FkOiBcIndpa2ltb25rZXlfb2xkY29uZi5qc29uXCJ9XG4gICAgICAgICAgICAgICAgICBcIkV4cG9ydCBvbGQgY29uZmlndXJhdGlvblwiKVxuICAgICAgICAgICAgICAgIEJyKClcbiAgICAgICAgICAgICAgICBBKHtvbmNsaWNrOiA9PlxuICAgICAgICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShcIldpa2lNb25rZXlcIilcbiAgICAgICAgICAgICAgICAgICAgQGRpc3BsYXlfbm90aWZpY2F0aW9uKFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJUaGUgb2xkIGNvbmZpZ3VyYXRpb24gd2FzIHN1Y2Nlc3NmdWxseSByZW1vdmVkLlwiXG4gICAgICAgICAgICAgICAgICAgICAgICB7YXV0b0hpZGU6IHRydWV9XG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICB9LCBcIkRlbGV0ZSBvbGQgY29uZmlndXJhdGlvblwiKVxuICAgICAgICAgICAgXSlcbiIsIiMgV2lraSBNb25rZXkgLSBNZWRpYVdpa2kgYm90IGFuZCBlZGl0b3ItYXNzaXN0YW50IHVzZXIgc2NyaXB0XG4jIENvcHlyaWdodCAoQykgMjAxMSBEYXJpbyBHaW92YW5uZXR0aSA8ZGV2QGRhcmlvZ2lvdmFubmV0dGkubmV0PlxuI1xuIyBUaGlzIGZpbGUgaXMgcGFydCBvZiBXaWtpIE1vbmtleS5cbiNcbiMgV2lraSBNb25rZXkgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuIyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuIyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuIyAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuI1xuIyBXaWtpIE1vbmtleSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuIyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuIyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4jIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4jXG4jIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4jIGFsb25nIHdpdGggV2lraSBNb25rZXkuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG5cblxuY2xhc3MgbW9kdWxlLmV4cG9ydHNcbiAgICBjb25zdHJ1Y3RvcjogKEBXTSkgLT5cblxuICAgIGlzV2hhdExpbmtzSGVyZVBhZ2U6IC0+XG4gICAgICAgIHJldHVybiBpZiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbXctd2hhdGxpbmtzaGVyZS1saXN0JykgdGhlbiB0cnVlIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlXG5cbiAgICBnZXRUaXRsZTogLT5cbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjb250ZW50U3ViJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdhJylbMF0udGl0bGVcbiIsIiMgV2lraSBNb25rZXkgLSBNZWRpYVdpa2kgYm90IGFuZCBlZGl0b3ItYXNzaXN0YW50IHVzZXIgc2NyaXB0XG4jIENvcHlyaWdodCAoQykgMjAxMSBEYXJpbyBHaW92YW5uZXR0aSA8ZGV2QGRhcmlvZ2lvdmFubmV0dGkubmV0PlxuI1xuIyBUaGlzIGZpbGUgaXMgcGFydCBvZiBXaWtpIE1vbmtleS5cbiNcbiMgV2lraSBNb25rZXkgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuIyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuIyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuIyAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuI1xuIyBXaWtpIE1vbmtleSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuIyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuIyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4jIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4jXG4jIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4jIGFsb25nIHdpdGggV2lraSBNb25rZXkuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG5cbm13bW9kcHJvbWlzZSA9IG13LmxvYWRlci51c2luZyhbJ21lZGlhd2lraS5hcGkuZWRpdCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ21lZGlhd2lraS5ub3RpZmljYXRpb24nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdtZWRpYXdpa2kuVXJpJ10pXG5cbiMgSW5pdGlhbGl6ZSB0aGUgbGlicmFyaWVzIGltbWVkaWF0ZWx5IChlc3BlY2lhbGx5IGJhYmVsLXBvbHlmaWxsKVxucmVxdWlyZSgnLi9saWJzJykuaW5pdCgpXG5cblVwZ3JhZGUgPSByZXF1aXJlKCcuL1VwZ3JhZGUnKVxue0FwcH0gPSByZXF1aXJlKCcuLi9hcHAnKVxuXG4jIFRoZSBBcmNoUGFja2FnZXMgbW9kdWxlIGlzIGN1cnJlbnRseSB1bnVzYWJsZVxuIyBBcmNoUGFja2FnZXMgPSByZXF1aXJlKCcuL0FyY2hQYWNrYWdlcycpXG5BcmNoV2lraSA9IHJlcXVpcmUoJy4vQXJjaFdpa2knKVxuQ2F0ID0gcmVxdWlyZSgnLi9DYXQnKVxuRGlmZiA9IHJlcXVpcmUoJy4vRGlmZicpXG5FZGl0b3IgPSByZXF1aXJlKCcuL0VkaXRvcicpXG5JbnRlcmxhbmd1YWdlID0gcmVxdWlyZSgnLi9JbnRlcmxhbmd1YWdlJylcbk1XID0gcmVxdWlyZSgnLi9NVycpXG5QYXJzZXIgPSByZXF1aXJlKCcuL1BhcnNlcicpXG5UYWJsZXMgPSByZXF1aXJlKCcuL1RhYmxlcycpXG5XaGF0TGlua3NIZXJlID0gcmVxdWlyZSgnLi9XaGF0TGlua3NIZXJlJylcblxue1BsdWdpbn0gPSByZXF1aXJlKCcuLi9wbHVnaW5zL19QbHVnaW4nKVxuXG5cbmNsYXNzIG1vZHVsZS5leHBvcnRzLldpa2lNb25rZXlcbiAgICBjb25mOlxuICAgICAgICBkZWZhdWx0X2JvdF9wbHVnaW46IFwiU2ltcGxlUmVwbGFjZVwiXG4gICAgICAgIGRlZmF1bHRfcmVjZW50Y2hhbmdlc19wbHVnaW46IG51bGxcbiAgICAgICAgZGVmYXVsdF9uZXdwYWdlc19wbHVnaW46IG51bGxcbiAgICAgICAgdXBkYXRlX2NoZWNrX3dkYXlzOiBbNl1cbiAgICAgICAgdXBkYXRlX2NoZWNrX2JyYW5jaDogJ21hc3RlcidcbiAgICAgICAgaGlkZV9yb2xsYmFja19saW5rczogdHJ1ZVxuICAgICAgICBkaXNhYmxlX2VkaXRfc3VtbWFyeV9zdWJtaXRfb25fZW50ZXI6IHRydWVcbiAgICAgICAgc2Nyb2xsX3RvX2ZpcnN0X2hlYWRpbmc6IGZhbHNlXG5cbiAgICBQbHVnaW5zOlxuICAgICAgICBib3Q6IFtdXG4gICAgICAgIGRpZmY6IFtdXG4gICAgICAgIGVkaXRvcjogW11cbiAgICAgICAgbmV3cGFnZXM6IFtdXG4gICAgICAgIHJlY2VudGNoYW5nZXM6IFtdXG4gICAgICAgIHNwZWNpYWw6IFtdXG5cbiAgICBjb25zdHJ1Y3RvcjogKEB3aWtpX25hbWUsIEBpbnN0YWxsZWRfcGx1Z2luc190ZW1wLi4uKSAtPlxuICAgICAgICBAc2V0dXAoKVxuICAgICAgICAkLndoZW4obXdtb2Rwcm9taXNlLCAkLnJlYWR5KS5kb25lKEBpbml0KVxuXG4gICAgc2V0dXA6IC0+XG4gICAgICAgICMgbXcubG9hZGVyLmxvYWQoKSBkb2Vzbid0IHJldHVybiBhIHByb21pc2Ugbm9yIHN1cHBvcnQgY2FsbGJhY2tzXG4gICAgICAgICMgbXcubG9hZGVyLnVzaW5nKCkgb25seSBzdXBwb3J0cyBNVyBtb2R1bGVzXG4gICAgICAgICMgJC5nZXRTY3JpcHQoKSBpZ25vcmVzIHRoZSBjYWNoZSBieSBkZWZhdWx0XG4gICAgICAgICMgSW4gdGhlIGVuZCB1c2luZyAkLmFqYXgoKSB3aXRoIHNldHVwIHBhcmFtZXRlcnMgd291bGQgYmUgdGhlIG9ubHlcbiAgICAgICAgIyBvcHRpb24gdG8gY29uZmlndXJlIFdNIGluIGEgY2FsbGJhY2ssIHRoZXJlZm9yZSB1c2UgYSBnbG9iYWxcbiAgICAgICAgIyBjb25maWd1cmF0aW9uIG9iamVjdCBmb3Igc2ltcGxpY2l0eVxuICAgICAgICB1c2VyX2NvbmZpZyA9IHdpbmRvdy53aWtpTW9ua2V5Q29uZmlnIG9yIHdpbmRvdy53aWtpbW9ua2V5X2NvbmZpZyBvciB7fVxuXG4gICAgICAgIGZvciBvcHRpb24sIHZhbHVlIG9mIHVzZXJfY29uZmlnIHdoZW4gb3B0aW9uIG9mIEBjb25mXG4gICAgICAgICAgICBAY29uZltvcHRpb25dID0gdmFsdWVcbiAgICAgICAgICAgIGRlbGV0ZSB1c2VyX2NvbmZpZ1tvcHRpb25dXG5cbiAgICAgICAgZm9yIHBtb2QgaW4gQGluc3RhbGxlZF9wbHVnaW5zX3RlbXBcbiAgICAgICAgICAgIGZvciBwbmFtZSwgUGx1Z2luU3ViIG9mIHBtb2QgXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoZW4gUGx1Z2luU3ViLnByb3RvdHlwZSBpbnN0YW5jZW9mIFBsdWdpblxuICAgICAgICAgICAgICAgIHRyeVxuICAgICAgICAgICAgICAgICAgICBQbHVnaW5TdWIuX19jb25maWd1cmUoQHdpa2lfbmFtZSwgdXNlcl9jb25maWcpXG4gICAgICAgICAgICAgICAgY2F0Y2ggZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgIyBUT0RPOiBQcm9wZXJseSBleHRlbmQgRXJyb3IsIGJ1dCBiZXdhcmUgdGhhdCBCYWJlbG9cbiAgICAgICAgICAgICAgICAgICAgIyAgICAgICBkb2Vzbid0IGxpa2UgaXQgd2l0aG91dCBzcGVjaWZpYyBwbHVnaW5zXG4gICAgICAgICAgICAgICAgICAgIGlmIGVycm9yLm1lc3NhZ2UgaXMgXCJQbHVnaW4gZGlzYWJsZWRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3JcblxuICAgICAgICAgICAgICAgIGZvciBpbnRlcmZhY2VfIG9mIEBQbHVnaW5zIFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hlbiBQbHVnaW5TdWI6OltcIm1haW5fI3tpbnRlcmZhY2VffVwiXVxuICAgICAgICAgICAgICAgICAgICBAUGx1Z2luc1tpbnRlcmZhY2VfXS5wdXNoKFBsdWdpblN1YilcblxuICAgICAgICBpZiBub3QgJC5pc0VtcHR5T2JqZWN0KHVzZXJfY29uZmlnKVxuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVW5rb3duIGNvbmZpZ3VyYXRpb24gb3B0aW9uc1wiLCB1c2VyX2NvbmZpZylcblxuICAgICAgICBkZWxldGUgQGluc3RhbGxlZF9wbHVnaW5zX3RlbXBcblxuICAgICAgICBPYmplY3QuYXNzaWduKG1vZHVsZS5leHBvcnRzLCB7XG4gICAgICAgICAgICBjb25mOiBAY29uZlxuICAgICAgICAgICAgUGx1Z2luczogQFBsdWdpbnNcbiAgICAgICAgfSlcblxuICAgIGluaXQ6ID0+XG4gICAgICAgICMgVGhlIEFyY2hQYWNrYWdlcyBtb2R1bGUgaXMgY3VycmVudGx5IHVudXNhYmxlXG4gICAgICAgICMgbW9kdWxlLmV4cG9ydHMuQXJjaFBhY2thZ2VzID0gbmV3IEFyY2hQYWNrYWdlcyh0aGlzKVxuICAgICAgICBtb2R1bGUuZXhwb3J0cy5BcmNoV2lraSA9IG5ldyBBcmNoV2lraSh0aGlzKVxuICAgICAgICBtb2R1bGUuZXhwb3J0cy5DYXQgPSBuZXcgQ2F0KHRoaXMpXG4gICAgICAgIG1vZHVsZS5leHBvcnRzLkRpZmYgPSBuZXcgRGlmZih0aGlzKVxuICAgICAgICBARWRpdG9yID0gbmV3IEVkaXRvcih0aGlzKVxuICAgICAgICBASW50ZXJsYW5ndWFnZSA9IG5ldyBJbnRlcmxhbmd1YWdlKHRoaXMpXG4gICAgICAgIG1vZHVsZS5leHBvcnRzLk1XID0gQE1XID0gbmV3IE1XKHRoaXMpXG4gICAgICAgIEBQYXJzZXIgPSBuZXcgUGFyc2VyKHRoaXMpXG4gICAgICAgIEBUYWJsZXMgPSBuZXcgVGFibGVzKHRoaXMpXG4gICAgICAgIEBXaGF0TGlua3NIZXJlID0gbmV3IFdoYXRMaW5rc0hlcmUodGhpcylcblxuICAgICAgICBuZXcgVXBncmFkZSh0aGlzKVxuICAgICAgICBBcHAodGhpcylcbiIsIiMgV2lraSBNb25rZXkgLSBNZWRpYVdpa2kgYm90IGFuZCBlZGl0b3ItYXNzaXN0YW50IHVzZXIgc2NyaXB0XG4jIENvcHlyaWdodCAoQykgMjAxMSBEYXJpbyBHaW92YW5uZXR0aSA8ZGV2QGRhcmlvZ2lvdmFubmV0dGkubmV0PlxuI1xuIyBUaGlzIGZpbGUgaXMgcGFydCBvZiBXaWtpIE1vbmtleS5cbiNcbiMgV2lraSBNb25rZXkgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuIyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuIyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuIyAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuI1xuIyBXaWtpIE1vbmtleSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuIyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuIyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4jIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4jXG4jIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4jIGFsb25nIHdpdGggV2lraSBNb25rZXkuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG5cbnJlcXVpcmUoJ2JhYmVsLXBvbHlmaWxsJylcblxuIyBqUXVlcnkgaXMgcHJvdmlkZWQgZ2xvYmFsbHkgYnkgTWVkaWFXaWtpXG5cbm1vZHVsZS5leHBvcnRzLmluaXQgPSAtPlxuICAgIG1vZHVsZS5leHBvcnRzLlZ1ZSA9IHJlcXVpcmUoJ3Z1ZScpXG5cbiAgICBoaCA9IHJlcXVpcmUoJ2h5cGVyc2NyaXB0LWhlbHBlcnMnKShyZXF1aXJlKCdoeXBlcnNjcmlwdCcpKVxuICAgIGZvciB0YWcsIGhlbHBlciBvZiBoaFxuICAgICAgICAjIFRPRE86IFRoaXMgY2FuIGJlIHNpbXBsaWZpZWQgYWZ0ZXJcbiAgICAgICAgIyAgICAgICBodHRwczovL2dpdGh1Yi5jb20vb2hhbmhpL2h5cGVyc2NyaXB0LWhlbHBlcnMvcHVsbC80NlxuICAgICAgICAjICAgICAgIGlzIHJlbGVhc2VkXG4gICAgICAgIG1vZHVsZS5leHBvcnRzW3RhZy5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHRhZy5zbGljZSgxKV0gPSBoZWxwZXJcblxuICAgIG1vZHVsZS5leHBvcnRzLm1vbWVudCA9IHJlcXVpcmUoJ21vbWVudCcpXG5cbiAgICBqc3MgPSByZXF1aXJlKCdqc3MnKS5kZWZhdWx0XG4gICAganNzLnNldHVwKHJlcXVpcmUoJ2pzcy1wcmVzZXQtZGVmYXVsdCcpLmRlZmF1bHQoKSlcbiAgICBtb2R1bGUuZXhwb3J0cy5qc3NjID0gKHN0eWxlcywgb3B0aW9ucykgLT5cbiAgICAgICAganNzLmNyZWF0ZVN0eWxlU2hlZXQoXG4gICAgICAgICAgICBzdHlsZXNcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjbGFzc05hbWVQcmVmaXg6IFwiV2lraU1vbmtleS1cIlxuICAgICAgICAgICAgICAgIG9wdGlvbnMuLi5cbiAgICAgICAgICAgIH1cbiAgICAgICAgKS5hdHRhY2goKVxuIiwiIyBXaWtpIE1vbmtleSAtIE1lZGlhV2lraSBib3QgYW5kIGVkaXRvci1hc3Npc3RhbnQgdXNlciBzY3JpcHRcbiMgQ29weXJpZ2h0IChDKSAyMDExIERhcmlvIEdpb3Zhbm5ldHRpIDxkZXZAZGFyaW9naW92YW5uZXR0aS5uZXQ+XG4jXG4jIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFdpa2kgTW9ua2V5LlxuI1xuIyBXaWtpIE1vbmtleSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4jIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4jIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4jIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4jXG4jIFdpa2kgTW9ua2V5IGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4jIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4jIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiMgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbiNcbiMgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiMgYWxvbmcgd2l0aCBXaWtpIE1vbmtleS4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cblxuV00gPSByZXF1aXJlKCcuLi9tb2R1bGVzJylcbkFwcCA9IHJlcXVpcmUoJy4uL2FwcCcpXG57UGx1Z2lufSA9IHJlcXVpcmUoJy4vX1BsdWdpbicpXG5cblxuY2xhc3MgbW9kdWxlLmV4cG9ydHMuQXJjaFdpa2lGaXhIZWFkZXIgZXh0ZW5kcyBQbHVnaW5cbiAgICBAY29uZl9kZWZhdWx0OlxuICAgICAgICBlbmFibGVkOiB0cnVlXG4gICAgICAgIGVkaXRvcl9tZW51OiBbXCJUZXh0IHBsdWdpbnNcIiwgXCJGaXggaGVhZGVyXCJdXG5cbiAgICBtYWluX2VkaXRvcjogKGNhbGxOZXh0KSAtPlxuICAgICAgICBzb3VyY2UgPSBAV00uRWRpdG9yLnJlYWRTb3VyY2UoKVxuXG4gICAgICAgIGxhbmd1YWdlID0gV00uQXJjaFdpa2kuZGV0ZWN0TGFuZ3VhZ2UoQFdNLkVkaXRvci5nZXRUaXRsZSgpKVsxXVxuXG4gICAgICAgIGhlYWRlciA9IFwiXCJcbiAgICAgICAgY29udGVudCA9IHNvdXJjZVxuXG4gICAgICAgICMgPG5vaW5jbHVkZT5cbiAgICAgICAgY29udGVudCA9IGNvbnRlbnQucmVwbGFjZSgvXlxccyo8bm9pbmNsdWRlPi8sIFwiXCIpXG4gICAgICAgIGlmIGNvbnRlbnQgIT0gc291cmNlXG4gICAgICAgICAgICBoZWFkZXIgKz0gXCI8bm9pbmNsdWRlPlxcblwiXG5cbiAgICAgICAgIyBESVNQTEFZVElUTEUgYW5kIFRlbXBsYXRlOkxvd2VyY2FzZV90aXRsZVxuICAgICAgICBkaXNwbGF5dGl0bGUgPSBAV00uUGFyc2VyLmZpbmRWYXJpYWJsZXMoY29udGVudCwgXCJESVNQTEFZVElUTEVcIilcbiAgICAgICAgbG93ZXJjYXNldGl0bGUgPSBAV00uUGFyc2VyLmZpbmRUZW1wbGF0ZXMoY29udGVudCwgXCJMb3dlcmNhc2UgdGl0bGVcIilcbiAgICAgICAgdGl0bGVtb2RzID0gZGlzcGxheXRpdGxlLmNvbmNhdChsb3dlcmNhc2V0aXRsZSlcbiAgICAgICAgdGl0bGVtb2RzLnNvcnQoIChhLCBiKSAtPlxuICAgICAgICAgICAgcmV0dXJuIGEuaW5kZXggLSBiLmluZGV4XG4gICAgICAgIClcbiAgICAgICAgdGVtcGNvbnRlbnQgPSBcIlwiXG4gICAgICAgIGNvbnRlbnRJZCA9IDBcbiAgICAgICAgZm9yIHRpdGxlbW9kIGluIHRpdGxlbW9kc1xuICAgICAgICAgICAgdGVtcGNvbnRlbnQgKz0gY29udGVudC5zdWJzdHJpbmcoY29udGVudElkLCB0aXRsZW1vZC5pbmRleClcbiAgICAgICAgICAgIGNvbnRlbnRJZCA9IHRpdGxlbW9kLmluZGV4ICsgdGl0bGVtb2QubGVuZ3RoXG5cbiAgICAgICAgdGVtcGNvbnRlbnQgKz0gY29udGVudC5zdWJzdHJpbmcoY29udGVudElkKVxuICAgICAgICBjb250ZW50ID0gdGVtcGNvbnRlbnRcbiAgICAgICAgZHQgPSBkaXNwbGF5dGl0bGUucG9wKClcbiAgICAgICAgbGN0ID0gbG93ZXJjYXNldGl0bGUucG9wKClcbiAgICAgICAgZGxjdCA9IFwiXCJcbiAgICAgICAgaWYgZHQgYW5kIG5vdCBsY3RcbiAgICAgICAgICAgIGRsY3QgPSBcInt7RElTUExBWVRJVExFOlwiICsgZHQudmFsdWUgKyBcIn19XCJcbiAgICAgICAgZWxzZSBpZiBub3QgZHQgYW5kIGxjdFxuICAgICAgICAgICAgZGxjdCA9IFwie3tMb3dlcmNhc2UgdGl0bGV9fVwiXG4gICAgICAgIGVsc2UgaWYgZHQgYW5kIGxjdFxuICAgICAgICAgICAgZGxjdCA9IGlmIGR0LmluZGV4IDwgbGN0LmluZGV4IHRoZW4gXCJ7e0xvd2VyY2FzZSB0aXRsZX19XCIgZWxzZSBcInt7RElTUExBWVRJVExFOiN7ZHQudmFsdWV9fX1cIlxuICAgICAgICBpZiBkaXNwbGF5dGl0bGUubGVuZ3RoIG9yIGxvd2VyY2FzZXRpdGxlLmxlbmd0aFxuICAgICAgICAgICAgQXBwLmxvZy5sb2dXYXJuaW5nKFwiRm91bmQgbXVsdGlwbGUgaW5zdGFuY2VzIG9mXG4gICAgICAgICAgICAgICAge3tESVNQTEFZVElUTEU6Li4ufX0gb3Ige3tMb3dlcmNhc2UgdGl0bGV9fTogb25seSB0aGUgbGFzdFxuICAgICAgICAgICAgICAgIG9uZSBoYXMgYmVlbiB1c2VkLCB0aGUgb3RoZXJzIGhhdmUgYmVlbiBkZWxldGVkXCIpXG5cbiAgICAgICAgIyBCZWhhdmlvciBzd2l0Y2hlc1xuICAgICAgICBiZWhhdmlvcnN3aXRjaGVzID0gQFdNLlBhcnNlci5maW5kQmVoYXZpb3JTd2l0Y2hlcyhjb250ZW50KVxuICAgICAgICBic2xpc3QgPSBbXVxuICAgICAgICB0ZW1wY29udGVudCA9IFwiXCJcbiAgICAgICAgY29udGVudElkID0gMFxuICAgICAgICBmb3IgYnN3aXRjaCwgYiBpbiBiZWhhdmlvcnN3aXRjaGVzXG4gICAgICAgICAgICBpZiBic3dpdGNoLm1hdGNoWzFdIGluIFtcIlRPQ1wiLCBcIlNUQVJUXCIsIFwiRU5EXCJdXG4gICAgICAgICAgICAgICAgYmVoYXZpb3Jzd2l0Y2hlcy5zcGxpY2UoYiwgMSlcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBpZiBic3dpdGNoLm1hdGNoWzBdIG5vdCBpbiBic2xpc3RcbiAgICAgICAgICAgICAgICAgICAgYnNsaXN0LnB1c2goYnN3aXRjaC5tYXRjaFswXSlcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIEFwcC5sb2cubG9nV2FybmluZyhcIlJlbW92ZWQgZHVwbGljYXRlIG9mXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI3tic3dpdGNoLm1hdGNoWzBdfVwiKVxuICAgICAgICAgICAgICAgIHRlbXBjb250ZW50ICs9IGNvbnRlbnQuc3Vic3RyaW5nKGNvbnRlbnRJZCwgYnN3aXRjaC5pbmRleClcbiAgICAgICAgICAgICAgICBjb250ZW50SWQgPSBic3dpdGNoLmluZGV4ICsgYnN3aXRjaC5sZW5ndGhcblxuICAgICAgICB0ZW1wY29udGVudCArPSBjb250ZW50LnN1YnN0cmluZyhjb250ZW50SWQpXG4gICAgICAgIGNvbnRlbnQgPSB0ZW1wY29udGVudFxuXG4gICAgICAgIGlmIG5vdCBkbGN0IGFuZCBic2xpc3QubGVuZ3RoXG4gICAgICAgICAgICBoZWFkZXIgKz0gYnNsaXN0LmpvaW4oXCIgXCIpICsgXCJcXG5cIlxuICAgICAgICBlbHNlIGlmIGRsY3QgYW5kIG5vdCBic2xpc3QubGVuZ3RoXG4gICAgICAgICAgICBoZWFkZXIgKz0gZGxjdCArIFwiXFxuXCJcbiAgICAgICAgZWxzZSBpZiBkbGN0IGFuZCBic2xpc3QubGVuZ3RoXG4gICAgICAgICAgICBoZWFkZXIgKz0gZGxjdCArIFwiIFwiICsgYnNsaXN0LmpvaW4oXCIgXCIpICsgXCJcXG5cIlxuXG4gICAgICAgICMgQ2F0ZWdvcmllc1xuICAgICAgICBjYXRlZ29yaWVzID0gQFdNLlBhcnNlci5maW5kQ2F0ZWdvcmllcyhjb250ZW50KVxuICAgICAgICBjYXRsaXN0ID0gW11cbiAgICAgICAgY2F0bGlua3MgPSBbXVxuICAgICAgICB0ZW1wY29udGVudCA9IFwiXCJcbiAgICAgICAgY29udGVudElkID0gMFxuICAgICAgICBmb3IgY2F0IGluIGNhdGVnb3JpZXNcbiAgICAgICAgICAgIGlmIGNhdC5mcmFnbWVudFxuICAgICAgICAgICAgICAgIEFwcC5sb2cubG9nV2FybmluZyhBcHAubG9nLmxpbmtUb1dpa2lQYWdlKGNhdC5saW5rLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0LnJhd0xpbmspICsgXCIgY29udGFpbnMgYSBmcmFnbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlLCBidXQgaXQgZG9lc24ndCBtYWtlIHNlbnNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbiBjYXRlZ29yaWVzIGFuZCB3aWxsIGJlIHJlbW92ZWRcIilcblxuICAgICAgICAgICAgY2xlYW50aXRsZSA9IEBXTS5QYXJzZXIuc3F1YXNoQ29udGlndW91c1doaXRlc3BhY2UoY2F0LnRpdGxlKVxuICAgICAgICAgICAgY2F0dGV4dCA9IFwiQ2F0ZWdvcnk6XCIgKyBjbGVhbnRpdGxlXG4gICAgICAgICAgICAjIERvbid0IGp1c3QgcGFzcyBjbGVhbnRpdGxlIGhlcmUsIG90aGVyd2lzZSB0aGUgbGFuZ3VhZ2Ugb2ZcbiAgICAgICAgICAgICMgICByb290IGxhbmd1YWdlIGNhdGVnb3JpZXMgd29uJ3QgYmUgcHJvcGVybHkgZGV0ZWN0ZWRcbiAgICAgICAgICAgIGNhdGxhbmcgPSBXTS5BcmNoV2lraS5kZXRlY3RMYW5ndWFnZShjYXR0ZXh0KVsxXVxuICAgICAgICAgICAgY2F0bGluayA9IFwiW1tcIiArIGNhdHRleHQgKyAoaWYgY2F0LmFuY2hvciB0aGVuIFwifFwiICsgY2F0LmFuY2hvciBlbHNlIFwiXCIpICsgXCJdXVwiXG4gICAgICAgICAgICBpZiBsYW5ndWFnZSAhPSBjYXRsYW5nXG4gICAgICAgICAgICAgICAgQXBwLmxvZy5sb2dXYXJuaW5nKEFwcC5sb2cubGlua1RvV2lraVBhZ2UoY2F0LmxpbmssIGNhdHRleHQpICtcbiAgICAgICAgICAgICAgICAgICAgXCIgYmVsb25ncyB0byBhIGRpZmZlcmVudFxuICAgICAgICAgICAgICAgICAgICBsYW5ndWFnZSB0aGFuIHRoZSBvbmUgb2YgdGhlIHRpdGxlIChcIiArIGxhbmd1YWdlICsgXCIpXCIpXG5cbiAgICAgICAgICAgIGlmIGNhdGxpc3QuaW5kZXhPZihjYXR0ZXh0KSA8IDBcbiAgICAgICAgICAgICAgICBjYXRsaXN0LnB1c2goY2F0dGV4dClcbiAgICAgICAgICAgICAgICBjYXRsaW5rcy5wdXNoKGNhdGxpbmspXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgQXBwLmxvZy5sb2dXYXJuaW5nKFwiUmVtb3ZlZCBkdXBsaWNhdGUgb2YgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQXBwLmxvZy5saW5rVG9XaWtpUGFnZShjYXQubGluaywgY2F0dGV4dCkpXG5cbiAgICAgICAgICAgIHRlbXBjb250ZW50ICs9IGNvbnRlbnQuc3Vic3RyaW5nKGNvbnRlbnRJZCwgY2F0LmluZGV4KVxuICAgICAgICAgICAgY29udGVudElkID0gY2F0LmluZGV4ICsgY2F0Lmxlbmd0aFxuXG4gICAgICAgIGlmIGNhdGxpc3QubGVuZ3RoXG4gICAgICAgICAgICBoZWFkZXIgKz0gY2F0bGlua3Muam9pbihcIlxcblwiKSArIFwiXFxuXCJcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgQXBwLmxvZy5sb2dXYXJuaW5nKFwiVGhlIGFydGljbGUgaXMgbm90IGNhdGVnb3JpemVkXCIpXG4gICAgICAgIHRlbXBjb250ZW50ICs9IGNvbnRlbnQuc3Vic3RyaW5nKGNvbnRlbnRJZClcbiAgICAgICAgY29udGVudCA9IHRlbXBjb250ZW50XG5cbiAgICAgICAgIyBJbnRlcmxhbmd1YWdlIGxpbmtzXG4gICAgICAgIGludGVybGFuZ3VhZ2UgPSBXTS5BcmNoV2lraS5maW5kQWxsSW50ZXJsYW5ndWFnZUxpbmtzKGNvbnRlbnQpXG4gICAgICAgIGl3bGlzdCA9IFtdXG4gICAgICAgIGl3bGlua3MgPSBbXVxuICAgICAgICB0ZW1wY29udGVudCA9IFwiXCJcbiAgICAgICAgY29udGVudElkID0gMFxuICAgICAgICBmb3IgbGluayBpbiBpbnRlcmxhbmd1YWdlXG4gICAgICAgICAgICBpZiBsaW5rLmFuY2hvclxuICAgICAgICAgICAgICAgICMgQ2Fubm90IHVzZSBBcHAubG9nLmxpbmtUb1dpa2lQYWdlIGJlY2F1c2UgbG9jYWwgaW50ZXJsYW5ndWFnZVxuICAgICAgICAgICAgICAgICMgICBsaW5rcyB3b3VsZCBub3QgcmVzb2x2ZWQgY29ycmVjdGx5OyBsaW5rVG9QYWdlIHdvdWxkIG5lZWRcbiAgICAgICAgICAgICAgICAjICAgdG8gZmluZCB0aGUgVVJMIGluc3RlYWQsIHdoaWNoIHNlZW1zIHRvbyBjb21wbGljYXRlZCBmb3JcbiAgICAgICAgICAgICAgICAjICAgdGhlIHB1cnBvc2Ugb2YgdGhpcyBwbHVnaW5cbiAgICAgICAgICAgICAgICBBcHAubG9nLmxvZ1dhcm5pbmcobGluay5yYXdMaW5rICsgXCIgY29udGFpbnMgYW4gYWx0ZXJuYXRpdmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQsIGJ1dCBpdCBkb2Vzbid0IG1ha2Ugc2Vuc2UgaW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVybGFuZ3VhZ2UgbGlua3MgYW5kIHdpbGwgYmUgcmVtb3ZlZFwiKVxuXG4gICAgICAgICAgICAjIEFwcGx5aW5nIEBXTS5QYXJzZXIuc3F1YXNoQ29udGlndW91c1doaXRlc3BhY2UgaXMgZGFuZ2Vyb3VzIGhlcmVcbiAgICAgICAgICAgICMgICBiZWNhdXNlIHdlIGRvbid0IGtub3cgaG93IHRoZSB0YXJnZXQgc2VydmVyIGhhbmRsZXMgd2hpdGVzcGFjZVxuICAgICAgICAgICAgbGlua3RpdGxlID0gbGluay50aXRsZVxuICAgICAgICAgICAgbGlua2xhbmcgPSBsaW5rLm5hbWVzcGFjZVxuICAgICAgICAgICAgbGlua3RleHQgPSBsaW5rbGFuZyArIFwiOlwiICsgbGlua3RpdGxlXG4gICAgICAgICAgICBmdWxsbGluayA9IFwiW1tcIiArIGxpbmt0ZXh0ICsgKGlmIGxpbmsuZnJhZ21lbnQgdGhlbiBcIiNcIiArIGxpbmsuZnJhZ21lbnQgZWxzZSBcIlwiKSArIFwiXV1cIlxuICAgICAgICAgICAgaWYgaXdsaXN0LmluZGV4T2YobGlua3RleHQpIDwgMFxuICAgICAgICAgICAgICAgIGl3bGlzdC5wdXNoKGxpbmt0ZXh0KVxuICAgICAgICAgICAgICAgIGl3bGlua3MucHVzaChmdWxsbGluaylcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAjIENhbm5vdCB1c2UgQXBwLmxvZy5saW5rVG9XaWtpUGFnZSBiZWNhdXNlIGxvY2FsIGludGVybGFuZ3VhZ2VcbiAgICAgICAgICAgICAgICAjICAgbGlua3Mgd291bGQgbm90IHJlc29sdmVkIGNvcnJlY3RseTsgbGlua1RvUGFnZSB3b3VsZCBuZWVkXG4gICAgICAgICAgICAgICAgIyAgIHRvIGZpbmQgdGhlIFVSTCBpbnN0ZWFkLCB3aGljaCBzZWVtcyB0b28gY29tcGxpY2F0ZWQgZm9yXG4gICAgICAgICAgICAgICAgIyAgIHRoZSBwdXJwb3NlIG9mIHRoaXMgcGx1Z2luXG4gICAgICAgICAgICAgICAgQXBwLmxvZy5sb2dXYXJuaW5nKFwiUmVtb3ZlZCBkdXBsaWNhdGUgb2YgXCIgKyBsaW5rdGV4dClcblxuICAgICAgICAgICAgdGVtcGNvbnRlbnQgKz0gY29udGVudC5zdWJzdHJpbmcoY29udGVudElkLCBsaW5rLmluZGV4KVxuICAgICAgICAgICAgY29udGVudElkID0gbGluay5pbmRleCArIGxpbmsubGVuZ3RoXG5cbiAgICAgICAgaWYgaXdsaXN0Lmxlbmd0aFxuICAgICAgICAgICAgaXdsaW5rcy5zb3J0KClcbiAgICAgICAgICAgIGhlYWRlciArPSBpd2xpbmtzLmpvaW4oXCJcXG5cIikgKyBcIlxcblwiXG5cbiAgICAgICAgdGVtcGNvbnRlbnQgKz0gY29udGVudC5zdWJzdHJpbmcoY29udGVudElkKVxuICAgICAgICBjb250ZW50ID0gdGVtcGNvbnRlbnRcblxuICAgICAgICBmaXJzdENoYXIgPSBjb250ZW50LnNlYXJjaCgvW15cXHNdLylcbiAgICAgICAgY29udGVudCA9IGNvbnRlbnQuc3Vic3RyKGZpcnN0Q2hhcilcblxuICAgICAgICBuZXdUZXh0ID0gaGVhZGVyICsgY29udGVudFxuXG4gICAgICAgIGlmIG5ld1RleHQgIT0gc291cmNlXG4gICAgICAgICAgICBAV00uRWRpdG9yLndyaXRlU291cmNlKG5ld1RleHQpXG4gICAgICAgICAgICBBcHAubG9nLmxvZ0luZm8oXCJGaXhlZCBoZWFkZXJcIilcblxuICAgICAgICBpZiBjYWxsTmV4dFxuICAgICAgICAgICAgY2FsbE5leHQoKVxuIiwiIyBXaWtpIE1vbmtleSAtIE1lZGlhV2lraSBib3QgYW5kIGVkaXRvci1hc3Npc3RhbnQgdXNlciBzY3JpcHRcbiMgQ29weXJpZ2h0IChDKSAyMDExIERhcmlvIEdpb3Zhbm5ldHRpIDxkZXZAZGFyaW9naW92YW5uZXR0aS5uZXQ+XG4jXG4jIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFdpa2kgTW9ua2V5LlxuI1xuIyBXaWtpIE1vbmtleSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4jIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4jIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4jIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4jXG4jIFdpa2kgTW9ua2V5IGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4jIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4jIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiMgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbiNcbiMgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiMgYWxvbmcgd2l0aCBXaWtpIE1vbmtleS4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cblxuQXBwID0gcmVxdWlyZSgnLi4vYXBwJylcbntQbHVnaW59ID0gcmVxdWlyZSgnLi9fUGx1Z2luJylcblxuXG5jbGFzcyBtb2R1bGUuZXhwb3J0cy5BcmNoV2lraUZpeEhlYWRpbmdzIGV4dGVuZHMgUGx1Z2luXG4gICAgQGNvbmZfZGVmYXVsdDpcbiAgICAgICAgZW5hYmxlZDogdHJ1ZVxuICAgICAgICBlZGl0b3JfbWVudTogW1wiVGV4dCBwbHVnaW5zXCIsIFwiRml4IGhlYWRpbmdzXCJdXG5cbiAgICBtYWluX2VkaXRvcjogKGNhbGxOZXh0KSAtPlxuICAgICAgICBzb3VyY2UgPSBAV00uRWRpdG9yLnJlYWRTb3VyY2UoKVxuXG4gICAgICAgIGluZm8gPSBAV00uUGFyc2VyLmZpbmRTZWN0aW9uSGVhZGluZ3Moc291cmNlKVxuXG4gICAgICAgIGlmIEBXTS5FZGl0b3IuaXNTZWN0aW9uKClcbiAgICAgICAgICAgIGluY3JlYXNlTGV2ZWwgPSBpbmZvLm1pbkxldmVsIC0gMVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICBpZiBpbmZvLm1heFRvY0xldmVsIDwgNlxuICAgICAgICAgICAgICAgIGluY3JlYXNlTGV2ZWwgPSAxXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgaW5jcmVhc2VMZXZlbCA9IDBcbiAgICAgICAgICAgICAgICBBcHAubG9nLmxvZ1dhcm5pbmcoXCJUaGVyZSBhcmUgNiBsZXZlbHMgb2YgaGVhZGluZ3MsIGl0IGhhc1xuICAgICAgICAgICAgICAgICAgICBiZWVuIG5lY2Vzc2FyeSB0byBzdGFydCBjcmVhdGluZyB0aGVtIGZyb20gbGV2ZWwgMVxuICAgICAgICAgICAgICAgICAgICBhbHRob3VnaCB1c3VhbGx5IGl0IGlzIHN1Z2dlc3RlZCB0byBzdGFydCBmcm9tIGxldmVsIDJcIilcblxuICAgICAgICBuZXd0ZXh0ID0gXCJcIlxuICAgICAgICBwcmV2SWQgPSAwXG5cbiAgICAgICAgZm9yIHNlY3Rpb24gaW4gaW5mby5zZWN0aW9uc1xuICAgICAgICAgICAgbmV3dGV4dCArPSBzb3VyY2Uuc3Vic3RyaW5nKHByZXZJZCwgc2VjdGlvbi5pbmRleClcbiAgICAgICAgICAgIG5ld3RleHQgKz0gbmV3IEFycmF5KHNlY3Rpb24udG9jTGV2ZWwgKyBpbmNyZWFzZUxldmVsICsgMSkuam9pbihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiPVwiKVxuICAgICAgICAgICAgbmV3dGV4dCArPSBzZWN0aW9uLnJhd2hlYWRpbmdcbiAgICAgICAgICAgIG5ld3RleHQgKz0gbmV3IEFycmF5KHNlY3Rpb24udG9jTGV2ZWwgKyBpbmNyZWFzZUxldmVsICsgMSkuam9pbihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiPVwiKVxuICAgICAgICAgICAgcHJldklkID0gc2VjdGlvbi5pbmRleCArIHNlY3Rpb24ubGVuZ3RoMFxuXG4gICAgICAgIG5ld3RleHQgKz0gc291cmNlLnN1YnN0cihwcmV2SWQpXG5cbiAgICAgICAgaWYgbmV3dGV4dCAhPSBzb3VyY2VcbiAgICAgICAgICAgIEBXTS5FZGl0b3Iud3JpdGVTb3VyY2UobmV3dGV4dClcbiAgICAgICAgICAgIEFwcC5sb2cubG9nSW5mbyhcIkZpeGVkIHNlY3Rpb24gaGVhZGluZ3NcIilcblxuICAgICAgICBpZiBjYWxsTmV4dFxuICAgICAgICAgICAgY2FsbE5leHQoKVxuIiwiIyBXaWtpIE1vbmtleSAtIE1lZGlhV2lraSBib3QgYW5kIGVkaXRvci1hc3Npc3RhbnQgdXNlciBzY3JpcHRcbiMgQ29weXJpZ2h0IChDKSAyMDExIERhcmlvIEdpb3Zhbm5ldHRpIDxkZXZAZGFyaW9naW92YW5uZXR0aS5uZXQ+XG4jXG4jIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFdpa2kgTW9ua2V5LlxuI1xuIyBXaWtpIE1vbmtleSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4jIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4jIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4jIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4jXG4jIFdpa2kgTW9ua2V5IGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4jIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4jIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiMgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbiNcbiMgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiMgYWxvbmcgd2l0aCBXaWtpIE1vbmtleS4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cblxuQXBwID0gcmVxdWlyZSgnLi4vYXBwJylcbntQbHVnaW59ID0gcmVxdWlyZSgnLi9fUGx1Z2luJylcblxuXG5jbGFzcyBtb2R1bGUuZXhwb3J0cy5BcmNoV2lraUZpeExpbmtzIGV4dGVuZHMgUGx1Z2luXG4gICAgQGNvbmZfZGVmYXVsdDpcbiAgICAgICAgZW5hYmxlZDogdHJ1ZVxuICAgICAgICBlZGl0b3JfbWVudTogW1wiVGV4dCBwbHVnaW5zXCIsIFwiRml4IGV4dGVybmFsIGxpbmtzXCJdXG5cbiAgICBkb1JlcGxhY2U6ICh0eHQpIC0+XG4gICAgICAgICMgYXJjaGxpbnV4Lm9yZyBIVFRQIC0+IEhUVFBTXG5cbiAgICAgICAgcmUgPSAvaHR0cDpcXC9cXC8oW2Etel0rXFwuKT9hcmNobGludXhcXC5vcmcoPyFcXC5bYS16XSkvaWdcbiAgICAgICAgdHh0ID0gdHh0LnJlcGxhY2UocmUsICdodHRwczovLyQxYXJjaGxpbnV4Lm9yZycpXG5cbiAgICAgICAgIyB3aWtpLmFyY2hsaW51eC5vcmcgLT4gSW50ZXJuYWwgbGlua1xuXG4gICAgICAgIHJlID0gL1xcW2h0dHBzPzpcXC9cXC93aWtpXFwuYXJjaGxpbnV4XFwub3JnXFwvaW5kZXhcXC5waHBcXC9DYXRlZ29yeTooW15cXF1dKz8pICguKz8pXFxdL2lnXG4gICAgICAgIHR4dCA9IHR4dC5yZXBsYWNlKHJlLCAnW1s6Q2F0ZWdvcnk6JDF8JDJdXScpXG5cbiAgICAgICAgcmUgPSAvXFxbaHR0cHM/OlxcL1xcL3dpa2lcXC5hcmNobGludXhcXC5vcmdcXC9pbmRleFxcLnBocFxcL0NhdGVnb3J5OiguKz8pXFxdL2lnXG4gICAgICAgIHR4dCA9IHR4dC5yZXBsYWNlKHJlLCAnW1s6Q2F0ZWdvcnk6JDFdXScpXG5cbiAgICAgICAgcmUgPSAvaHR0cHM/OlxcL1xcL3dpa2lcXC5hcmNobGludXhcXC5vcmdcXC9pbmRleFxcLnBocFxcL0NhdGVnb3J5OihbXlxcc10rKS9pZ1xuICAgICAgICB0eHQgPSB0eHQucmVwbGFjZShyZSwgJ1tbOkNhdGVnb3J5OiQxXV0nKVxuXG4gICAgICAgIHJlID0gL1xcW2h0dHBzPzpcXC9cXC93aWtpXFwuYXJjaGxpbnV4XFwub3JnXFwvaW5kZXhcXC5waHBcXC8oW15cXF1dKz8pICguKz8pXFxdL2lnXG4gICAgICAgIHR4dCA9IHR4dC5yZXBsYWNlKHJlLCAnW1skMXwkMl1dJylcblxuICAgICAgICByZSA9IC9cXFtodHRwcz86XFwvXFwvd2lraVxcLmFyY2hsaW51eFxcLm9yZ1xcL2luZGV4XFwucGhwXFwvKC4rPylcXF0vaWdcbiAgICAgICAgdHh0ID0gdHh0LnJlcGxhY2UocmUsICdbWyQxXV0nKVxuXG4gICAgICAgIHJlID0gL2h0dHBzPzpcXC9cXC93aWtpXFwuYXJjaGxpbnV4XFwub3JnXFwvaW5kZXhcXC5waHBcXC8oW15cXHNdKykvaWdcbiAgICAgICAgdHh0ID0gdHh0LnJlcGxhY2UocmUsICdbWyQxXV0nKVxuXG4gICAgICAgIHJlID0gL2h0dHBzPzpcXC9cXC93aWtpXFwuYXJjaGxpbnV4XFwub3JnKD8hXFwuKS9pZ1xuXG4gICAgICAgIGlmIHJlLnRlc3QodHh0KVxuICAgICAgICAgICAgQXBwLmxvZy5sb2dXYXJuaW5nKFwiSXQgaGFzbid0IGJlZW4gcG9zc2libGUgdG8gY29udmVydCBzb21lIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibGlua3MgdG8gd2lraS5hcmNobGludXgub3JnXCIpXG5cbiAgICAgICAgIyBXaWtpcGVkaWEgLT4gd2lraXBlZGlhOiBpbnRlcmxpbmtcblxuICAgICAgICByZSA9IC9cXFtodHRwcz86XFwvXFwvZW5cXC53aWtpcGVkaWFcXC5vcmdcXC93aWtpXFwvKFteXFxdXSs/KSAoLis/KVxcXS9pZ1xuICAgICAgICB0eHQgPSB0eHQucmVwbGFjZShyZSwgJ1tbd2lraXBlZGlhOiQxfCQyXV0nKVxuXG4gICAgICAgIHJlID0gL1xcW2h0dHBzPzpcXC9cXC9lblxcLndpa2lwZWRpYVxcLm9yZ1xcL3dpa2lcXC8oLis/KVxcXS9pZ1xuICAgICAgICB0eHQgPSB0eHQucmVwbGFjZShyZSwgJ1tbd2lraXBlZGlhOiQxXV0nKVxuXG4gICAgICAgIHJlID0gL2h0dHBzPzpcXC9cXC9lblxcLndpa2lwZWRpYVxcLm9yZ1xcL3dpa2lcXC8oW15cXHNdKykvaWdcbiAgICAgICAgdHh0ID0gdHh0LnJlcGxhY2UocmUsICdbW3dpa2lwZWRpYTokMV1dJylcblxuICAgICAgICByZSA9IC9odHRwcz86XFwvXFwvKFthLXpdKz8pXFwud2lraXBlZGlhXFwub3JnKD8hXFwuKS9pZ1xuXG4gICAgICAgIGlmIHJlLnRlc3QodHh0KVxuICAgICAgICAgICAgQXBwLmxvZy5sb2dXYXJuaW5nKFwiSXQgaGFzbid0IGJlZW4gcG9zc2libGUgdG8gY29udmVydCBzb21lIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJsaW5rcyB0byBXaWtpcGVkaWFcIilcblxuICAgICAgICAjIE9mZmljaWFsIHBhY2thZ2UgbGlua3MgLT4gUGtnIHRlbXBsYXRlXG5cbiAgICAgICAgcmUgPSAvXFxbaHR0cHM/OlxcL1xcLyg/Ond3d1xcLik/YXJjaGxpbnV4XFwub3JnXFwvcGFja2FnZXNcXC8oPzpjb21tdW5pdHl8Y29tbXVuaXR5LXRlc3Rpbmd8Y29yZXxleHRyYXxtdWx0aWxpYnxtdWx0aWxpYi10ZXN0aW5nfHRlc3RpbmcpXFwvKD86YW55fGk2ODZ8eDg2XzY0KVxcLyhbXlxcc10rPylcXC8/ICsoLis/KT9cXF0vaWdcbiAgICAgICAgbmV3VGV4dCA9ICcnXG4gICAgICAgIHByZXZJZCA9IDBcblxuICAgICAgICB3aGlsZSB0cnVlXG4gICAgICAgICAgICBtYXRjaCA9IHJlLmV4ZWModHh0KVxuXG4gICAgICAgICAgICBpZiBtYXRjaFxuICAgICAgICAgICAgICAgICMgRG9uJ3Qgam9pbiB0aGVzZSB0d28gY29uZGl0aW9uc1xuICAgICAgICAgICAgICAgIGlmIG1hdGNoWzFdID09IG1hdGNoWzJdXG4gICAgICAgICAgICAgICAgICAgIEwgPSBtYXRjaFswXS5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgbmV3VGV4dCArPSB0eHQuc3Vic3RyaW5nKHByZXZJZCwgcmUubGFzdEluZGV4IC0gTCkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICd7e1BrZ3wnICsgbWF0Y2hbMV0gKyAnfX0nXG5cbiAgICAgICAgICAgICAgICAgICAgcHJldklkID0gcmUubGFzdEluZGV4XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgYnJlYWtcblxuICAgICAgICBuZXdUZXh0ICs9IHR4dC5zdWJzdHIocHJldklkKVxuICAgICAgICB0eHQgPSBuZXdUZXh0XG5cbiAgICAgICAgcmUgPSAvXFxbaHR0cHM/OlxcL1xcLyg/Ond3d1xcLik/YXJjaGxpbnV4XFwub3JnXFwvcGFja2FnZXNcXC8oPzpjb21tdW5pdHl8Y29tbXVuaXR5LXRlc3Rpbmd8Y29yZXxleHRyYXxtdWx0aWxpYnxtdWx0aWxpYi10ZXN0aW5nfHRlc3RpbmcpXFwvKD86YW55fGk2ODZ8eDg2XzY0KVxcLyhbXlxcc10rPylcXC8/XFxdL2lnXG4gICAgICAgIHR4dCA9IHR4dC5yZXBsYWNlKHJlLCAne3tQa2d8JDF9fScpXG5cbiAgICAgICAgcmUgPSAvKFteXFxbXSlodHRwcz86XFwvXFwvKD86d3d3XFwuKT9hcmNobGludXhcXC5vcmdcXC9wYWNrYWdlc1xcLyg/OmNvbW11bml0eXxjb21tdW5pdHktdGVzdGluZ3xjb3JlfGV4dHJhfG11bHRpbGlifG11bHRpbGliLXRlc3Rpbmd8dGVzdGluZylcXC8oPzphbnl8aTY4Nnx4ODZfNjQpXFwvKFteXFxzXFwvXSspXFwvPy9pZ1xuICAgICAgICB0eHQgPSB0eHQucmVwbGFjZShyZSwgJyQxe3tQa2d8JDJ9fScpXG5cbiAgICAgICAgcmUgPSAvaHR0cHM/OlxcL1xcLyg/Ond3d1xcLik/YXJjaGxpbnV4XFwub3JnXFwvcGFja2FnZXMoPyFcXC8/XFxzKS9pZ1xuXG4gICAgICAgIGlmIHJlLnRlc3QodHh0KVxuICAgICAgICAgICAgQXBwLmxvZy5sb2dXYXJuaW5nKFwiSXQgaGFzbid0IGJlZW4gcG9zc2libGUgdG8gY29udmVydCBzb21lIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJsaW5rcyB0byBhcmNobGludXgub3JnL3BhY2thZ2VzXCIpXG5cbiAgICAgICAgIyBBVVIgcGFja2FnZSBsaW5rcyAtPiBBVVIgdGVtcGxhdGVcblxuICAgICAgICByZSA9IC9cXFtodHRwcz86XFwvXFwvYXVyXFwuYXJjaGxpbnV4XFwub3JnXFwvcGFja2FnZXNcXC8oW15cXHNdKz8pXFwvPyArKC4rPyk/XFxdL2lnXG4gICAgICAgIG5ld1RleHQgPSAnJ1xuICAgICAgICBwcmV2SWQgPSAwXG5cbiAgICAgICAgd2hpbGUgdHJ1ZVxuICAgICAgICAgICAgbWF0Y2ggPSByZS5leGVjKHR4dClcblxuICAgICAgICAgICAgaWYgbWF0Y2hcbiAgICAgICAgICAgICAgICAjIERvbid0IGpvaW4gdGhlc2UgdHdvIGNvbmRpdGlvbnNcbiAgICAgICAgICAgICAgICBpZiBtYXRjaFsxXSA9PSBtYXRjaFsyXVxuICAgICAgICAgICAgICAgICAgICBMID0gbWF0Y2hbMF0ubGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgIG5ld1RleHQgKz0gdHh0LnN1YnN0cmluZyhwcmV2SWQsIHJlLmxhc3RJbmRleCAtIEwpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAne3tBVVJ8JyArIG1hdGNoWzFdICsgJ319J1xuXG4gICAgICAgICAgICAgICAgICAgIHByZXZJZCA9IHJlLmxhc3RJbmRleFxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgbmV3VGV4dCArPSB0eHQuc3Vic3RyKHByZXZJZClcbiAgICAgICAgdHh0ID0gbmV3VGV4dFxuXG4gICAgICAgIHJlID0gL1xcW2h0dHBzPzpcXC9cXC9hdXJcXC5hcmNobGludXhcXC5vcmdcXC9wYWNrYWdlc1xcLyhbXlxcc10rPylcXC8/XFxdL2lnXG4gICAgICAgIHR4dCA9IHR4dC5yZXBsYWNlKHJlLCAne3tBVVJ8JDF9fScpXG5cbiAgICAgICAgcmUgPSAvKFteXFxbXSlodHRwcz86XFwvXFwvYXVyXFwuYXJjaGxpbnV4XFwub3JnXFwvcGFja2FnZXNcXC8oW15cXHNcXC9dKylcXC8/L2lnXG4gICAgICAgIHR4dCA9IHR4dC5yZXBsYWNlKHJlLCAnJDF7e0FVUnwkMn19JylcblxuICAgICAgICByZSA9IC9odHRwcz86XFwvXFwvYXVyXFwuYXJjaGxpbnV4XFwub3JnKD8hKD86XFwufCg/OlxcLz9wYWNrYWdlcyk/XFwvP1xccykpL2lnXG5cbiAgICAgICAgaWYgcmUudGVzdCh0eHQpXG4gICAgICAgICAgICBBcHAubG9nLmxvZ1dhcm5pbmcoXCJJdCBoYXNuJ3QgYmVlbiBwb3NzaWJsZSB0byBjb252ZXJ0IHNvbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rcyB0byBhdXIuYXJjaGxpbnV4Lm9yZyAodHJ5IHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcXCJGaXggb2xkIEFVUiBsaW5rc1xcXCIgZnVuY3Rpb24sIGlmIGluc3RhbGxlZClcIilcblxuICAgICAgICAjIEJ1ZyBsaW5rcyAtPiBCdWcgdGVtcGxhdGVcblxuICAgICAgICByZSA9IC9cXFtodHRwcz86XFwvXFwvYnVnc1xcLmFyY2hsaW51eFxcLm9yZ1xcL3Rhc2tcXC8oW15cXHNdKz8pXFwvPyArKC4rPyk/XFxdL2lnXG4gICAgICAgIG5ld1RleHQgPSAnJ1xuICAgICAgICBwcmV2SWQgPSAwXG5cbiAgICAgICAgd2hpbGUgdHJ1ZVxuICAgICAgICAgICAgbWF0Y2ggPSByZS5leGVjKHR4dClcblxuICAgICAgICAgICAgaWYgbWF0Y2hcbiAgICAgICAgICAgICAgICAjIERvbid0IGpvaW4gdGhlc2UgdHdvIGNvbmRpdGlvbnNcbiAgICAgICAgICAgICAgICBpZiBtYXRjaFsxXSA9PSBtYXRjaFsyXVxuICAgICAgICAgICAgICAgICAgICBMID0gbWF0Y2hbMF0ubGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgIG5ld1RleHQgKz0gdHh0LnN1YnN0cmluZyhwcmV2SWQsIHJlLmxhc3RJbmRleCAtIEwpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAne3tCdWd8JyArIG1hdGNoWzFdICsgJ319J1xuXG4gICAgICAgICAgICAgICAgICAgIHByZXZJZCA9IHJlLmxhc3RJbmRleFxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgbmV3VGV4dCArPSB0eHQuc3Vic3RyKHByZXZJZClcbiAgICAgICAgdHh0ID0gbmV3VGV4dFxuXG4gICAgICAgIHJlID0gL1xcW2h0dHBzPzpcXC9cXC9idWdzXFwuYXJjaGxpbnV4XFwub3JnXFwvdGFza1xcLyhbXlxcc10rPylcXC8/XFxdL2lnXG4gICAgICAgIHR4dCA9IHR4dC5yZXBsYWNlKHJlLCAne3tCdWd8JDF9fScpXG5cbiAgICAgICAgcmUgPSAvKFteXFxbXSlodHRwcz86XFwvXFwvYnVnc1xcLmFyY2hsaW51eFxcLm9yZ1xcL3Rhc2tcXC8oW15cXHNcXC9dKylcXC8/L2lnXG4gICAgICAgIHR4dCA9IHR4dC5yZXBsYWNlKHJlLCAnJDF7e0J1Z3wkMn19JylcblxuICAgICAgICByZSA9IC9odHRwcz86XFwvXFwvYnVnc1xcLmFyY2hsaW51eFxcLm9yZ1xcL3Rhc2svaWdcblxuICAgICAgICBpZiByZS50ZXN0KHR4dClcbiAgICAgICAgICAgIEFwcC5sb2cubG9nV2FybmluZyhcIkl0IGhhc24ndCBiZWVuIHBvc3NpYmxlIHRvIGNvbnZlcnQgc29tZSBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJsaW5rcyB0byBidWdzLmFyY2hsaW51eC5vcmcvdGFza1wiKVxuXG4gICAgICAgIHJldHVybiB0eHRcblxuICAgIG1haW5fZWRpdG9yOiAoY2FsbE5leHQpIC0+XG4gICAgICAgIHNvdXJjZSA9IEBXTS5FZGl0b3IucmVhZFNvdXJjZSgpXG4gICAgICAgIG5ld3RleHQgPSBAZG9SZXBsYWNlKHNvdXJjZSlcblxuICAgICAgICBpZiBuZXd0ZXh0ICE9IHNvdXJjZVxuICAgICAgICAgICAgQFdNLkVkaXRvci53cml0ZVNvdXJjZShuZXd0ZXh0KVxuICAgICAgICAgICAgQXBwLmxvZy5sb2dJbmZvKFwiRml4ZWQgbGlua3NcIilcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgQXBwLmxvZy5sb2dJbmZvKFwiTm8gZml4YWJsZSBsaW5rcyBmb3VuZFwiKVxuXG4gICAgICAgIGlmIGNhbGxOZXh0XG4gICAgICAgICAgICBjYWxsTmV4dCgpXG5cbiAgICAjIE5vdGUgdGhhdCBpdCdzIHRvbyBkYW5nZXJvdXMgdG8gdXNlIHRoaXMgcGx1Z2luIHdpdGggdGhlIGJvdCwgaW4gZmFjdFxuICAgICMgc29tZSBmdWxsIFVSTHMgYXJlIGNvcnJlY3RseSB1c2VkIGluIGNvZGUgYmxvY2tzIChlLmcuIHdnZXQgbGluZXMpXG4iLCIjIFdpa2kgTW9ua2V5IC0gTWVkaWFXaWtpIGJvdCBhbmQgZWRpdG9yLWFzc2lzdGFudCB1c2VyIHNjcmlwdFxuIyBDb3B5cmlnaHQgKEMpIDIwMTEgRGFyaW8gR2lvdmFubmV0dGkgPGRldkBkYXJpb2dpb3Zhbm5ldHRpLm5ldD5cbiNcbiMgVGhpcyBmaWxlIGlzIHBhcnQgb2YgV2lraSBNb25rZXkuXG4jXG4jIFdpa2kgTW9ua2V5IGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiMgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiMgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiMgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbiNcbiMgV2lraSBNb25rZXkgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiMgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiMgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuIyBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuI1xuIyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuIyBhbG9uZyB3aXRoIFdpa2kgTW9ua2V5LiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuXG57anNzY30gPSByZXF1aXJlKCcuLi9tb2R1bGVzL2xpYnMnKVxuV00gPSByZXF1aXJlKCcuLi9tb2R1bGVzJylcbkFwcCA9IHJlcXVpcmUoJy4uL2FwcCcpXG57UGx1Z2lufSA9IHJlcXVpcmUoJy4vX1BsdWdpbicpXG5cblxuY2xhc3MgbW9kdWxlLmV4cG9ydHMuQXJjaFdpa2lOUEZpbHRlciBleHRlbmRzIFBsdWdpblxuICAgIEBjb25mX2RlZmF1bHQ6XG4gICAgICAgIGVuYWJsZWQ6IHRydWVcbiAgICAgICAgZmlsdGVyX2xhYmVsOiBcIkRlZmF1bHQgZmlsdGVyXCJcbiAgICAgICAgZGVmYXVsdF9sYW5ndWFnZTogXCJFbmdsaXNoXCJcblxuICAgIG1haW5fbmV3cGFnZXM6IC0+XG4gICAgICAgIGpzc2MoXG4gICAgICAgICAgICAnQGdsb2JhbCAjbXctY29udGVudC10ZXh0ID4gaDUnOlxuICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJyNhZmEnXG4gICAgICAgIClcblxuICAgICAgICBjb250ZW50RGl2ID0gJCgnI213LWNvbnRlbnQtdGV4dCcpXG4gICAgICAgIHVsID0gY29udGVudERpdi5maW5kKCd1bCcpLmZpcnN0KClcbiAgICAgICAgbGlMaXN0ID0gdWwuY2hpbGRyZW4oJ2xpJylcblxuICAgICAgICBmb3IgbGkgaW4gbGlMaXN0XG4gICAgICAgICAgICBsaW5rID0gJChsaSkuZmluZCgnYS5tdy1uZXdwYWdlcy1wYWdlbmFtZScpLmZpcnN0KClcbiAgICAgICAgICAgIFtwdXJlVGl0bGUsIGxhbmd1YWdlXSA9IFdNLkFyY2hXaWtpLmRldGVjdExhbmd1YWdlKGxpbmtbMF0udGl0bGUpXG4gICAgICAgICAgICBpZiBsYW5ndWFnZSAhPSBAY29uZi5kZWZhdWx0X2xhbmd1YWdlXG4gICAgICAgICAgICAgICAgQG1vdmVBcnRpY2xlKGNvbnRlbnREaXYsIGxpLCBsYW5ndWFnZSlcblxuICAgICAgICBBcHAubG9nLmxvZ0luZm8oXCJHcm91cGVkIGFydGljbGVzIGJ5IGxhbmd1YWdlXCIpXG5cbiAgICBtb3ZlQXJ0aWNsZTogKGNvbnRlbnREaXYsIGxpLCBsYW5ndWFnZSkgLT5cbiAgICAgICAgbGFuZ0hzID0gY29udGVudERpdi5jaGlsZHJlbignaDUnKVxuICAgICAgICBsYW5nRm91bmQgPSBmYWxzZVxuICAgICAgICBmb3IgSExhbmcgaW4gbGFuZ0hzXG4gICAgICAgICAgICBpZiBITGFuZy5pbm5lckhUTUwgPT0gbGFuZ3VhZ2VcbiAgICAgICAgICAgICAgICB1bCA9ICQoSExhbmcpLm5leHQoKS5hcHBlbmQobGkpXG4gICAgICAgICAgICAgICAgbGFuZ0ZvdW5kID0gdHJ1ZVxuICAgICAgICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgaWYgbm90IGxhbmdGb3VuZFxuICAgICAgICAgICAgY29udGVudERpdi5hcHBlbmQoXG4gICAgICAgICAgICAgICAgJCgnPGg1PicpLnRleHQobGFuZ3VhZ2UpLFxuICAgICAgICAgICAgICAgICQoJzx1bD4nKS5hcHBlbmQobGkpLFxuICAgICAgICAgICAgKVxuIiwiIyBXaWtpIE1vbmtleSAtIE1lZGlhV2lraSBib3QgYW5kIGVkaXRvci1hc3Npc3RhbnQgdXNlciBzY3JpcHRcbiMgQ29weXJpZ2h0IChDKSAyMDExIERhcmlvIEdpb3Zhbm5ldHRpIDxkZXZAZGFyaW9naW92YW5uZXR0aS5uZXQ+XG4jXG4jIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFdpa2kgTW9ua2V5LlxuI1xuIyBXaWtpIE1vbmtleSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4jIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4jIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4jIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4jXG4jIFdpa2kgTW9ua2V5IGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4jIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4jIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiMgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbiNcbiMgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiMgYWxvbmcgd2l0aCBXaWtpIE1vbmtleS4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cblxuQXBwID0gcmVxdWlyZSgnLi4vYXBwJylcbntQbHVnaW59ID0gcmVxdWlyZSgnLi9fUGx1Z2luJylcblxuXG5jbGFzcyBtb2R1bGUuZXhwb3J0cy5BcmNoV2lraU5ld1RlbXBsYXRlcyBleHRlbmRzIFBsdWdpblxuICAgIEBjb25mX2RlZmF1bHQ6XG4gICAgICAgIGVuYWJsZWQ6IHRydWVcbiAgICAgICAgZWRpdG9yX21lbnU6IFtcIlRleHQgcGx1Z2luc1wiLCBcIlVzZSBjb2RlIHRlbXBsYXRlc1wiXVxuXG4gICAgbWFpbl9lZGl0b3I6IChjYWxsTmV4dCkgLT5cbiAgICAgICAgc291cmNlID0gQFdNLkVkaXRvci5yZWFkU291cmNlKClcbiAgICAgICAgbmV3dGV4dCA9IHNvdXJjZVxuXG4gICAgICAgIHJlOCA9IC88cHJlPigoKD8hPChwcmV8bm93aWtpKT4pW15cXD1cXHxdKSo/KCg/ITwocHJlfG5vd2lraSk+KVteXFw9XFx8XFx9XSkpPFxcL3ByZT4vaWdcbiAgICAgICAgcmU5ID0gLzxwcmU+KCgoPyE8KHByZXxub3dpa2kpPilbXlxcfF0pKj8oKD8hPChwcmV8bm93aWtpKT4pW15cXHxcXH1dKSk8XFwvcHJlPi9pZ1xuICAgICAgICByZTEwID0gLzxwcmU+KFxcbiooKD8hPChwcmV8bm93aWtpKT4pLlxcbiopKz8pPFxcL3ByZT4vaWdcblxuICAgICAgICByZTExID0gLzxjb2RlPigoKD8hPChjb2RlfG5vd2lraSk+KVteXFw9XFx8XFxuXSkqPygoPyE8KGNvZGV8bm93aWtpKT4pW15cXD1cXHxcXH1cXG5dKSk8XFwvY29kZT4vaWdcbiAgICAgICAgcmUxMiA9IC88Y29kZT4oKCg/ITwoY29kZXxub3dpa2kpPilbXlxcfFxcbl0pKj8oKD8hPChjb2RlfG5vd2lraSk+KVteXFx8XFx9XFxuXSkpPFxcL2NvZGU+L2lnXG4gICAgICAgIHJlMTMgPSAvPGNvZGU+KCgoPyE8KGNvZGV8bm93aWtpKT4pW15cXG5dKSs/KTxcXC9jb2RlPi9pZ1xuXG4gICAgICAgIHJlMTQgPSAvPHR0PigoKD8hPCh0dHxub3dpa2kpPilbXlxcPVxcfFxcbl0pKj8oKD8hPCh0dHxub3dpa2kpPilbXlxcPVxcfFxcfVxcbl0pKTxcXC90dD4vaWdcbiAgICAgICAgcmUxNSA9IC88dHQ+KCgoPyE8KHR0fG5vd2lraSk+KVteXFx8XFxuXSkqPygoPyE8KHR0fG5vd2lraSk+KVteXFx8XFx9XFxuXSkpPFxcL3R0Pi9pZ1xuICAgICAgICByZTE2ID0gLzx0dD4oKCg/ITwodHR8bm93aWtpKT4pW15cXG5dKSs/KTxcXC90dD4vaWdcblxuICAgICAgICBuZXd0ZXh0ID0gbmV3dGV4dC5yZXBsYWNlKHJlOCwgJ3t7YmN8JDF9fScpXG4gICAgICAgIG5ld3RleHQgPSBuZXd0ZXh0LnJlcGxhY2UocmU5LCAne3tiY3wxPSQxfX0nKSAgIyBNdXN0IGNvbWUgYWZ0ZXIgcmU4XG4gICAgICAgIG5ld3RleHQgPSBuZXd0ZXh0LnJlcGxhY2UocmUxMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICd7e2JjfDxub3dpa2k+JDE8L25vd2lraT59fScpICAjIE11c3QgY29tZSBhZnRlciByZTlcblxuICAgICAgICBuZXd0ZXh0ID0gbmV3dGV4dC5yZXBsYWNlKHJlMTEsICd7e2ljfCQxfX0nKVxuICAgICAgICBuZXd0ZXh0ID0gbmV3dGV4dC5yZXBsYWNlKHJlMTIsICd7e2ljfDE9JDF9fScpICAjIE11c3QgY29tZSBhZnRlciByZTExXG4gICAgICAgIG5ld3RleHQgPSBuZXd0ZXh0LnJlcGxhY2UocmUxMyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd7e2ljfDxub3dpa2k+JDE8L25vd2lraT59fScpICAjIE11c3QgY29tZSBhZnRlciByZTEyXG5cbiAgICAgICAgbmV3dGV4dCA9IG5ld3RleHQucmVwbGFjZShyZTE0LCAne3tpY3wkMX19JylcbiAgICAgICAgbmV3dGV4dCA9IG5ld3RleHQucmVwbGFjZShyZTE1LCAne3tpY3wxPSQxfX0nKSAgIyBNdXN0IGNvbWUgYWZ0ZXIgcmUxNFxuICAgICAgICBuZXd0ZXh0ID0gbmV3dGV4dC5yZXBsYWNlKHJlMTYsXG4gICAgICAgICAgICAgICAgICAgICAgICAne3tpY3w8bm93aWtpPiQxPC9ub3dpa2k+fX0nKSAgIyBNdXN0IGNvbWUgYWZ0ZXIgcmUxNVxuXG4gICAgICAgIGlmIG5ld3RleHQgIT0gc291cmNlXG4gICAgICAgICAgICBAV00uRWRpdG9yLndyaXRlU291cmNlKG5ld3RleHQpXG4gICAgICAgICAgICBBcHAubG9nLmxvZ0luZm8oXCJUdXJuZWQgSFRNTCB0YWdzIGludG8gcHJvcGVyIHRlbXBsYXRlc1wiKVxuXG4gICAgICAgIHRlc3RzID0gW1xuICAgICAgICAgICAgWycmbHQ7cHJlPicsIG5ld3RleHQubWF0Y2goLzxwcmUvaWcpXSxcbiAgICAgICAgICAgIFsnJmx0O2NvZGU+JywgbmV3dGV4dC5tYXRjaCgvPGNvZGUvaWcpXSxcbiAgICAgICAgICAgIFsnJmx0O3R0PicsIG5ld3RleHQubWF0Y2goLzx0dC9pZyldXG4gICAgICAgIF1cblxuICAgICAgICBmb3IgdGVzdCBpbiB0ZXN0c1xuICAgICAgICAgICAgaWYgdGVzdFsxXVxuICAgICAgICAgICAgICAgIEFwcC5sb2cubG9nV2FybmluZyh0ZXN0WzFdLmxlbmd0aCArICcgJyArXG4gICAgICAgICAgICAgICAgICAgIHRlc3RbMF0gKyAnIGluc3RhbmNlcyByZXF1aXJlIG1hbnVhbCBpbnRlcnZlbnRpb24nKVxuXG4gICAgICAgIGlmIGNhbGxOZXh0XG4gICAgICAgICAgICBjYWxsTmV4dCgpXG4iLCIjIFdpa2kgTW9ua2V5IC0gTWVkaWFXaWtpIGJvdCBhbmQgZWRpdG9yLWFzc2lzdGFudCB1c2VyIHNjcmlwdFxuIyBDb3B5cmlnaHQgKEMpIDIwMTEgRGFyaW8gR2lvdmFubmV0dGkgPGRldkBkYXJpb2dpb3Zhbm5ldHRpLm5ldD5cbiNcbiMgVGhpcyBmaWxlIGlzIHBhcnQgb2YgV2lraSBNb25rZXkuXG4jXG4jIFdpa2kgTW9ua2V5IGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiMgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiMgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiMgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbiNcbiMgV2lraSBNb25rZXkgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiMgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiMgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuIyBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuI1xuIyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuIyBhbG9uZyB3aXRoIFdpa2kgTW9ua2V5LiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuXG57anNzY30gPSByZXF1aXJlKCcuLi9tb2R1bGVzL2xpYnMnKVxuV00gPSByZXF1aXJlKCcuLi9tb2R1bGVzJylcbkFwcCA9IHJlcXVpcmUoJy4uL2FwcCcpXG57UGx1Z2lufSA9IHJlcXVpcmUoJy4vX1BsdWdpbicpXG5cblxuY2xhc3MgbW9kdWxlLmV4cG9ydHMuQXJjaFdpa2lSQ0ZpbHRlciBleHRlbmRzIFBsdWdpblxuICAgIEBjb25mX2RlZmF1bHQ6XG4gICAgICAgIGVuYWJsZWQ6IHRydWVcbiAgICAgICAgZmlsdGVyX2xhYmVsOiBcIkRlZmF1bHQgZmlsdGVyXCJcbiAgICAgICAgZGVmYXVsdF9sYW5ndWFnZTogXCJFbmdsaXNoXCJcblxuICAgIG1haW5fcmVjZW50Y2hhbmdlczogLT5cbiAgICAgICAgaDRzID0gJCgnI213LWNvbnRlbnQtdGV4dCAubXctY2hhbmdlc2xpc3QgPiBoNCcpXG5cbiAgICAgICAgaWYgaDRzLmVxKDApLm5leHQoKVswXS5sb2NhbE5hbWUudG9Mb3dlckNhc2UoKSAhPSAnZGl2J1xuICAgICAgICAgICAgQXBwLmxvZy5sb2dFcnJvcihcIlRoaXMgZmlsdGVyIGlzIGRlc2lnbmVkIHRvIHdvcmsgb24gdG9wIG9mXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNZWRpYVdpa2kncyBmaWx0ZXIsIHdoaWNoIHlvdSBjYW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuYWJsZSBpbiB5b3VyIHVzZXIgcHJlZmVyZW5jZXMuXCIpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGpzc2MoXG4gICAgICAgICAgICAgICAgJ0BnbG9iYWwnOlxuICAgICAgICAgICAgICAgICAgICAnI213LWNvbnRlbnQtdGV4dCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAnJiA+IGRpdiA+IGg0JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICcjYWFmJ1xuICAgICAgICAgICAgICAgICAgICAgICAgJyYgPiBkaXYgPiBkaXYgPiBoNSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAnI2FmYSdcbiAgICAgICAgICAgIClcblxuICAgICAgICAgICAgZm9yIGg0IGluIGg0c1xuICAgICAgICAgICAgICAgIGdyb3VwRGl2ID0gJChoNCkubmV4dCgpXG4gICAgICAgICAgICAgICAgZm9yIGFydGljbGVUYWJsZSBpbiBncm91cERpdi5jaGlsZHJlbigndGFibGUnKVxuICAgICAgICAgICAgICAgICAgICBsaW5rID0gJChhcnRpY2xlVGFibGUpLmZpbmQoJ2EubXctY2hhbmdlc2xpc3QtdGl0bGUnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZmlyc3QoKVxuICAgICAgICAgICAgICAgICAgICBpZiBsaW5rWzBdXG4gICAgICAgICAgICAgICAgICAgICAgICBbcHVyZVRpdGxlLCBsYW5ndWFnZV0gPSBXTS5BcmNoV2lraS5kZXRlY3RMYW5ndWFnZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rWzBdLnRpdGxlKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgbGFuZ3VhZ2UgIT0gQGNvbmYuZGVmYXVsdF9sYW5ndWFnZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEBtb3ZlQXJ0aWNsZShncm91cERpdiwgYXJ0aWNsZVRhYmxlLCBsYW5ndWFnZSlcblxuICAgICAgICAgICAgQXBwLmxvZy5sb2dJbmZvKFwiR3JvdXBlZCBhcnRpY2xlcyBieSBsYW5ndWFnZVwiKVxuXG4gICAgbW92ZUFydGljbGU6IChncm91cERpdiwgYXJ0aWNsZVRhYmxlLCBsYW5ndWFnZSkgLT5cbiAgICAgICAgbGFuZ0hzID0gZ3JvdXBEaXYuY2hpbGRyZW4oJ2g1JylcbiAgICAgICAgbGFuZ0ZvdW5kID0gZmFsc2VcbiAgICAgICAgZm9yIEhMYW5nLCBpIGluIGxhbmdIc1xuICAgICAgICAgICAgaWYgSExhbmcuaW5uZXJIVE1MID09IGxhbmd1YWdlXG4gICAgICAgICAgICAgICAgaWYgaSArIDEgPCBsYW5nSHMubGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgIGxhbmdIcy5lcShpICsgMSkuYmVmb3JlKGFydGljbGVUYWJsZSlcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGdyb3VwRGl2LmFwcGVuZChhcnRpY2xlVGFibGUpXG4gICAgICAgICAgICAgICAgbGFuZ0ZvdW5kID0gdHJ1ZVxuICAgICAgICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgaWYgbm90IGxhbmdGb3VuZFxuICAgICAgICAgICAgZ3JvdXBEaXYuYXBwZW5kKFxuICAgICAgICAgICAgICAgICQoJzxoNT4nKS50ZXh0KGxhbmd1YWdlKSxcbiAgICAgICAgICAgICAgICBhcnRpY2xlVGFibGUsXG4gICAgICAgICAgICApXG4iLCIjIFdpa2kgTW9ua2V5IC0gTWVkaWFXaWtpIGJvdCBhbmQgZWRpdG9yLWFzc2lzdGFudCB1c2VyIHNjcmlwdFxuIyBDb3B5cmlnaHQgKEMpIDIwMTEgRGFyaW8gR2lvdmFubmV0dGkgPGRldkBkYXJpb2dpb3Zhbm5ldHRpLm5ldD5cbiNcbiMgVGhpcyBmaWxlIGlzIHBhcnQgb2YgV2lraSBNb25rZXkuXG4jXG4jIFdpa2kgTW9ua2V5IGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiMgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiMgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiMgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbiNcbiMgV2lraSBNb25rZXkgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiMgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiMgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuIyBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuI1xuIyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuIyBhbG9uZyB3aXRoIFdpa2kgTW9ua2V5LiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuXG57anNzY30gPSByZXF1aXJlKCcuLi9tb2R1bGVzL2xpYnMnKVxuV00gPSByZXF1aXJlKCcuLi9tb2R1bGVzJylcbkFwcCA9IHJlcXVpcmUoJy4uL2FwcCcpXG57UGx1Z2lufSA9IHJlcXVpcmUoJy4vX1BsdWdpbicpXG5cblxuY2xhc3MgbW9kdWxlLmV4cG9ydHMuQXJjaFdpa2lTYXZlVGFsayBleHRlbmRzIFBsdWdpblxuICAgIEBjb25mX2RlZmF1bHQ6XG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlXG4gICAgICAgIGRpZmZfbWVudTogW1wiU2F2ZSBkaXNjdXNzaW9uXCJdXG4gICAgICAgIHBhZ2U6IG51bGxcbiAgICAgICAgZWRpdF9zdW1tYXJ5OiBcImFkZCBkaXNjdXNzaW9uXCJcblxuICAgIG1ha2VVSTogLT5cbiAgICAgICAge2NsYXNzZXN9ID0ganNzYyhcbiAgICAgICAgICAgIHNhdmVUYWxrOlxuICAgICAgICAgICAgICAgIG1hcmdpbkxlZnQ6ICcwLjMzZW0nXG4gICAgICAgIClcblxuICAgICAgICBhcnRpY2xlID0gQGNvbmYucGFnZVxuXG4gICAgICAgIGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJylcbiAgICAgICAgbGluay5pZCA9IFwiV2lraU1vbmtleS1BcmNoV2lraVNhdmVUYWxrXCJcbiAgICAgICAgbGluay5jbGFzc05hbWUgPSBjbGFzc2VzLnNhdmVUYWxrXG4gICAgICAgIGxpbmsuaHJlZiA9IFwiL2luZGV4LnBocC9cIiArIGFydGljbGVcbiAgICAgICAgbGluay5pbm5lckhUTUwgPSBhcnRpY2xlXG5cbiAgICAgICAgcmV0dXJuIGxpbmtcblxuICAgIG1haW5fZGlmZjogKGNhbGxOZXh0KSAtPlxuICAgICAgICBhcnRpY2xlID0gQGNvbmYucGFnZVxuICAgICAgICBzdW1tYXJ5ID0gQGNvbmYuZWRpdF9zdW1tYXJ5XG5cbiAgICAgICAgQXBwLmxvZy5sb2dJbmZvKCdBcHBlbmRpbmcgZGlmZiB0byAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBBcHAubG9nLmxpbmtUb1dpa2lQYWdlKGFydGljbGUsIGFydGljbGUpICsgXCIgLi4uXCIpXG5cbiAgICAgICAgV00uRGlmZi5nZXRFbmRUaW1lc3RhbXAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQG1haW5HZXRFbmRUaW1lc3RhbXAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW2FydGljbGUsIHN1bW1hcnksIGNhbGxOZXh0XSlcblxuICAgIG1haW5HZXRFbmRUaW1lc3RhbXA6IChlbmRkYXRlLCBhcmdzKSA9PlxuICAgICAgICBhcnRpY2xlID0gYXJnc1swXVxuICAgICAgICBzdW1tYXJ5ID0gYXJnc1sxXVxuICAgICAgICBjYWxsTmV4dCA9IGFyZ3NbMl1cblxuICAgICAgICBAV00uTVcuY2FsbFF1ZXJ5RWRpdChhcnRpY2xlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEBtYWluV3JpdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW3N1bW1hcnksIGVuZGRhdGUsIGNhbGxOZXh0XSlcblxuICAgIG1haW5Xcml0ZTogKGFydGljbGUsIHNvdXJjZSwgdGltZXN0YW1wLCBlZGl0dG9rZW4sIGFyZ3MpID0+XG4gICAgICAgIHN1bW1hcnkgPSBhcmdzWzBdXG4gICAgICAgIGVuZGRhdGUgPSBhcmdzWzFdXG4gICAgICAgIGNhbGxOZXh0ID0gYXJnc1syXVxuXG4gICAgICAgIHRpdGxlID0gbXcuY29uZmlnLmdldCgnd2dQYWdlTmFtZScpXG4gICAgICAgIHBFbmRkYXRlID0gZW5kZGF0ZS5zdWJzdHIoMCwgMTApICsgXCImbmJzcDtcIiArIGVuZGRhdGUuc3Vic3RyKDExLCA4KVxuXG4gICAgICAgIG5ld3RleHQgPSBAV00uVGFibGVzLmFwcGVuZFJvdyhzb3VyY2UsIFwiPCEtLSBSRVBMWSBUQUJMRSAtLT5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFtcIltcIiArIGxvY2F0aW9uLmhyZWYgKyBcIiBcIiArIHRpdGxlICsgXCJdXCIsIHBFbmRkYXRlXSlcblxuICAgICAgICBAV00uTVcuY2FsbEFQSVBvc3QoXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYWN0aW9uOiBcImVkaXRcIixcbiAgICAgICAgICAgICAgICBib3Q6IFwiMVwiLFxuICAgICAgICAgICAgICAgIHRpdGxlOiBhcnRpY2xlLFxuICAgICAgICAgICAgICAgIHN1bW1hcnk6IHN1bW1hcnksXG4gICAgICAgICAgICAgICAgdGV4dDogbmV3dGV4dCxcbiAgICAgICAgICAgICAgICBiYXNldGltZXN0YW1wOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAgICAgdG9rZW46IGVkaXR0b2tlblxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIEBtYWluRW5kLFxuICAgICAgICAgICAgW2FydGljbGUsIGNhbGxOZXh0XSxcbiAgICAgICAgICAgIG51bGxcbiAgICAgICAgKVxuXG4gICAgbWFpbkVuZDogKHJlcywgYXJncykgPT5cbiAgICAgICAgYXJ0aWNsZSA9IGFyZ3NbMF1cbiAgICAgICAgY2FsbE5leHQgPSBhcmdzWzFdXG5cbiAgICAgICAgaWYgcmVzLmVkaXQgYW5kIHJlcy5lZGl0LnJlc3VsdCA9PSAnU3VjY2VzcydcbiAgICAgICAgICAgIEFwcC5sb2cubG9nSW5mbygnRGlmZiBjb3JyZWN0bHkgYXBwZW5kZWQgdG8gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBcHAubG9nLmxpbmtUb1dpa2lQYWdlKGFydGljbGUsIGFydGljbGUpKVxuICAgICAgICAgICAgaWYgY2FsbE5leHRcbiAgICAgICAgICAgICAgICBjYWxsTmV4dCgpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIEFwcC5sb2cubG9nRXJyb3IoJ1RoZSBkaWZmIGhhcyBub3QgYmVlbiBhcHBlbmRlZCFcXG4nICtcbiAgICAgICAgICAgICAgICAgICAgcmVzWydlcnJvciddWydpbmZvJ10gKyBcIiAoXCIgKyByZXNbJ2Vycm9yJ11bJ2NvZGUnXSArIFwiKVwiKVxuIiwiIyBXaWtpIE1vbmtleSAtIE1lZGlhV2lraSBib3QgYW5kIGVkaXRvci1hc3Npc3RhbnQgdXNlciBzY3JpcHRcbiMgQ29weXJpZ2h0IChDKSAyMDExIERhcmlvIEdpb3Zhbm5ldHRpIDxkZXZAZGFyaW9naW92YW5uZXR0aS5uZXQ+XG4jXG4jIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFdpa2kgTW9ua2V5LlxuI1xuIyBXaWtpIE1vbmtleSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4jIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4jIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4jIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4jXG4jIFdpa2kgTW9ua2V5IGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4jIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4jIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiMgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbiNcbiMgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiMgYWxvbmcgd2l0aCBXaWtpIE1vbmtleS4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cblxuQXBwID0gcmVxdWlyZSgnLi4vYXBwJylcbntQbHVnaW59ID0gcmVxdWlyZSgnLi9fUGx1Z2luJylcblxuXG5jbGFzcyBtb2R1bGUuZXhwb3J0cy5BcmNoV2lraVNvcnRDb250YWN0cyBleHRlbmRzIFBsdWdpblxuICAgICMgVGhpcyBwbHVnaW4gd2FzIG9yaWdpbmFsbHkgYmFzZWQgb24gbGlzdD1hbGx1c2VycywgYnV0IGJlY2F1c2Ugb2YgYnVnXG4gICAgIyAgIzIwOCBpdCBjYW4ndCByZWx5IG9uIHRoYXQgYW55bW9yZSwgc28gaXQgd2FzIHJld3JpdHRlbiB3aXRoXG4gICAgIyAgNjBiYjJhYzJhMmRjZDBiMTViN2FhYzgwNzI1YzgzMTUxMTczZWViM1xuICAgICMgU2VlIGFsc28gaHR0cHM6Ly9iYnMuYXJjaGxpbnV4Lm9yZy92aWV3dG9waWMucGhwP2lkPTE5MjM4OSBhbmRcbiAgICAjICBodHRwczovL2xpc3RzLndpa2ltZWRpYS5vcmcvcGlwZXJtYWlsL21lZGlhd2lraS1sLzIwMTUtSmFudWFyeS8wNDM4NTAuaHRtbFxuXG4gICAgc3RhcnRNYXJrID0gXCJTVEFSVCBBVVRPIExJU1QgLSBETyBOT1QgUkVNT1ZFIE9SIE1PRElGWSBUSElTIE1BUkstLT5cIlxuICAgIGVuZE1hcmsgPSBcIjwhLS1FTkQgQVVUTyBMSVNUIC0gRE8gTk9UIFJFTU9WRSBPUiBNT0RJRlkgVEhJUyBNQVJLXCJcbiAgICAjIERvbid0IGRvIFwiKD86IFxcXFw8IS0tIGFzc29jaWF0ZWQgYm90OiAoLis/KSAtLT4pPy4qJFwiXG4gICAgcmVnRXhwID0gbmV3IFJlZ0V4cChcIl5cXFxcKi4qP1xcXFxbXFxcXFtVc2VyOiguKz8pXFxcXHwuKz9cIiArXG4gICAgICAgICAgICAgICAgICAgIFwiKD86IFxcXFw8IS0tIGFzc29jaWF0ZWQgYm90OiAoLis/KSAtLT4uKik/JFwiLCBcIlwiKVxuXG4gICAgQGNvbmZfZGVmYXVsdDpcbiAgICAgICAgZW5hYmxlZDogZmFsc2VcbiAgICAgICAgc3BlY2lhbF9tZW51OiBbXCJTb3J0IHN0YWZmIGNvbnRhY3RzXCJdXG4gICAgICAgIGVkaXRfc3VtbWFyeTogXCJhdXRvbWF0aWNhbGx5IHNvcnQgbGlzdCBhY2NvcmRpbmcgdG8gcmVjZW50IGFjdGl2aXR5XCJcbiAgICAgICAgcGFnZXM6IFt7XG4gICAgICAgICAgICB0aXRsZTogXCJBcmNoV2lraTpBZG1pbmlzdHJhdG9yc1wiXG4gICAgICAgICAgICByZWNlbnRfZGF5czogMzBcbiAgICAgICAgICAgIGluYWN0aXZlX2xpbWl0OiAzMFxuICAgICAgICAgICAgaW5hY3RpdmVfbWVzc2FnZTogXCJUaGUgZm9sbG93aW5nIEFkbWluaXN0cmF0b3JzIGFyZSBjdXJyZW50bHlcbiAgICAgICAgICAgICAgICBpbmFjdGl2ZSAobGVzcyB0aGFuIDMwIGVkaXRzIGluIHRoZSBsYXN0IDMwIGRheXMpOlwiXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRpdGxlOiBcIkFyY2hXaWtpOk1haW50YWluZXJzXCJcbiAgICAgICAgICAgIHJlY2VudF9kYXlzOiAzMFxuICAgICAgICAgICAgaW5hY3RpdmVfbGltaXQ6IDEwXG4gICAgICAgICAgICBpbmFjdGl2ZV9tZXNzYWdlOiBcIlRoZSBmb2xsb3dpbmcgTWFpbnRhaW5lcnMgYXJlIGN1cnJlbnRseVxuICAgICAgICAgICAgICAgIGluYWN0aXZlIChsZXNzIHRoYW4gMTAgZWRpdHMgaW4gdGhlIGxhc3QgMzAgZGF5cyk6XCJcbiAgICAgICAgfV1cblxuICAgIG1haW5fc3BlY2lhbDogKGNhbGxOZXh0KSAtPlxuICAgICAgICBAaXRlcmF0ZVBhZ2VzKC0xLCBjYWxsTmV4dClcblxuICAgIGl0ZXJhdGVQYWdlczogKHBhZ2VpZCwgY2FsbE5leHQpIC0+XG4gICAgICAgIHBhZ2VpZCsrXG4gICAgICAgIHBjb25mID0gQGNvbmYucGFnZXNbcGFnZWlkXVxuICAgICAgICBpZiBwY29uZlxuICAgICAgICAgICAgcGFnZSA9IHBjb25mLnRpdGxlXG4gICAgICAgICAgICByZWNlbnREYXlzID0gcGNvbmYucmVjZW50X2RheXNcbiAgICAgICAgICAgIGluYWN0aXZlTGltaXQgPSBwY29uZi5pbmFjdGl2ZV9saW1pdFxuICAgICAgICAgICAgaW5hY3RpdmVJbnRybyA9IHBjb25mLmluYWN0aXZlX21lc3NhZ2VcbiAgICAgICAgICAgIHN1bW1hcnkgPSBAY29uZi5lZGl0X3N1bW1hcnlcblxuICAgICAgICAgICAgQXBwLmxvZy5sb2dJbmZvKFwiU29ydGluZyBcIiArIEFwcC5sb2cubGlua1RvV2lraVBhZ2UocGFnZSwgcGFnZSkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgLi4uXCIpXG5cbiAgICAgICAgICAgIEBXTS5NVy5jYWxsUXVlcnlFZGl0KHBhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEBwYXJzZUxpc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtyZWNlbnREYXlzLCBpbmFjdGl2ZUxpbWl0LCBpbmFjdGl2ZUludHJvLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VtbWFyeSwgY2FsbE5leHQsIHBhZ2VpZF0pXG4gICAgICAgIGVsc2UgaWYgY2FsbE5leHRcbiAgICAgICAgICAgIGNhbGxOZXh0KClcblxuICAgIHBhcnNlTGlzdDogKHRpdGxlLCBzb3VyY2UsIHRpbWVzdGFtcCwgZWRpdHRva2VuLCBhcmdzKSA9PlxuICAgICAgICByZWNlbnREYXlzID0gYXJnc1swXVxuICAgICAgICBpbmFjdGl2ZUxpbWl0ID0gYXJnc1sxXVxuICAgICAgICBpbmFjdGl2ZUludHJvID0gYXJnc1syXVxuICAgICAgICBzdW1tYXJ5ID0gYXJnc1szXVxuICAgICAgICBjYWxsTmV4dCA9IGFyZ3NbNF1cbiAgICAgICAgcGFnZWlkID0gYXJnc1s1XVxuXG4gICAgICAgIHN0YXJ0TGlzdCA9IHNvdXJjZS5pbmRleE9mKHN0YXJ0TWFyaylcbiAgICAgICAgZW5kTGlzdCA9IHNvdXJjZS5pbmRleE9mKGVuZE1hcmspXG5cbiAgICAgICAgaWYgc3RhcnRMaXN0ID4gLTEgYW5kIGVuZExpc3QgPiAtMVxuICAgICAgICAgICAgc3RhcnRMaXN0ICs9IHN0YXJ0TWFyay5sZW5ndGhcbiAgICAgICAgICAgIGRhdGUgPSBuZXcgRGF0ZSgpXG4gICAgICAgICAgICB1Y3N0YXJ0ID0gTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMClcbiAgICAgICAgICAgIHVjZW5kID0gdWNzdGFydCAtIDg2NDAwICogcmVjZW50RGF5c1xuICAgICAgICAgICAgdXNlcnMgPVxuICAgICAgICAgICAgICAgIGFjdGl2ZTogW11cbiAgICAgICAgICAgICAgICBpbmFjdGl2ZTogW11cblxuICAgICAgICAgICAgdXNlcnNBcnJheSA9IHNvdXJjZS5zdWJzdHJpbmcoc3RhcnRMaXN0LCBlbmRMaXN0KS5zcGxpdChcIlxcblwiKVxuICAgICAgICAgICAgQGl0ZXJhdGVVc2Vycyh1c2Vyc0FycmF5LCAtMSwgdWNzdGFydCwgdWNlbmQsIHVzZXJzLCB0aXRsZSwgc291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0TGlzdCwgZW5kTGlzdCwgdGltZXN0YW1wLCBlZGl0dG9rZW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5hY3RpdmVMaW1pdCwgaW5hY3RpdmVJbnRybywgc3VtbWFyeSwgY2FsbE5leHQsIHBhZ2VpZClcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgQXBwLmxvZy5sb2dFcnJvcihcIkNhbm5vdCBmaW5kIHRoZSBuZWVkZWQgbWFya3NcIilcblxuICAgIGl0ZXJhdGVVc2VyczogKHVzZXJzQXJyYXksIGluZGV4LCB1Y3N0YXJ0LCB1Y2VuZCwgdXNlcnMsXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlLCBzb3VyY2UsIHN0YXJ0TGlzdCwgZW5kTGlzdCwgdGltZXN0YW1wLCBlZGl0dG9rZW4sXG4gICAgICAgICAgICAgICAgICAgIGluYWN0aXZlTGltaXQsIGluYWN0aXZlSW50cm8sIHN1bW1hcnksIGNhbGxOZXh0LCBwYWdlaWQpID0+XG4gICAgICAgIGluZGV4KytcblxuICAgICAgICBpZiBpbmRleCA8IHVzZXJzQXJyYXkubGVuZ3RoXG4gICAgICAgICAgICB1c2VyU3RyaW5nID0gdXNlcnNBcnJheVtpbmRleF1cbiAgICAgICAgICAgIG1hdGNoID0gcmVnRXhwLmV4ZWModXNlclN0cmluZylcblxuICAgICAgICAgICAgaWYgbWF0Y2hcbiAgICAgICAgICAgICAgICB1Y3VzZXIgPSBtYXRjaFsxXS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG1hdGNoWzFdLnN1YnN0cigxKVxuXG4gICAgICAgICAgICAgICAgaWYgbWF0Y2hbMl1cbiAgICAgICAgICAgICAgICAgICAgdWN1c2VyICs9IFwifFwiICsgbWF0Y2hbMl0uY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hbMl0uc3Vic3RyKDEpXG5cbiAgICAgICAgICAgICAgICBBcHAubG9nLmxvZ0luZm8oXCJRdWVyeWluZyBcIiArIHVjdXNlciArIFwiIC4uLlwiKVxuXG4gICAgICAgICAgICAgICAgQFdNLk1XLmdldFVzZXJDb250cmlicyh1Y3VzZXIsIHVjc3RhcnQsIHVjZW5kLFxuICAgICAgICAgICAgICAgICAgICBAc3RvcmVVc2VyQ29udHJpYnMsXG4gICAgICAgICAgICAgICAgICAgIFt1c2Vyc0FycmF5LCBpbmRleCwgdWNzdGFydCwgdWNlbmQsIHVzZXJzLCB0aXRsZSwgc291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgc3RhcnRMaXN0LCBlbmRMaXN0LCB0aW1lc3RhbXAsIGVkaXR0b2tlbiwgaW5hY3RpdmVMaW1pdCxcbiAgICAgICAgICAgICAgICAgICAgIGluYWN0aXZlSW50cm8sIHN1bW1hcnksIGNhbGxOZXh0LCBwYWdlaWRdKVxuXG4gICAgICAgICAgICBlbHNlIGlmIHVzZXJTdHJpbmcgIT0gXCJcIiBhbmRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJTdHJpbmcuaW5kZXhPZihpbmFjdGl2ZUludHJvKSAhPSAwXG4gICAgICAgICAgICAgICAgQXBwLmxvZy5sb2dFcnJvcihcIkFuIGVudHJ5IGluIHRoZSBsaXN0IG1heSBub3QgYmUgY29ycmVjdGx5IFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImZvcm1hdHRlZFwiKVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIEBpdGVyYXRlVXNlcnModXNlcnNBcnJheSwgaW5kZXgsIHVjc3RhcnQsIHVjZW5kLCB1c2VycywgdGl0bGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlLCBzdGFydExpc3QsIGVuZExpc3QsIHRpbWVzdGFtcCwgZWRpdHRva2VuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluYWN0aXZlTGltaXQsIGluYWN0aXZlSW50cm8sIHN1bW1hcnksIGNhbGxOZXh0LCBwYWdlaWQpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIEB1cGRhdGVMaXN0KHVzZXJzLCB0aXRsZSwgc291cmNlLCBzdGFydExpc3QsIGVuZExpc3QsIHRpbWVzdGFtcCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWRpdHRva2VuLCBpbmFjdGl2ZUludHJvLCBzdW1tYXJ5LCBjYWxsTmV4dCwgcGFnZWlkKVxuXG4gICAgc3RvcmVVc2VyQ29udHJpYnM6IChyZXN1bHRzLCBhcmdzKSA9PlxuICAgICAgICB1c2Vyc0FycmF5ID0gYXJnc1swXVxuICAgICAgICBpbmRleCA9IGFyZ3NbMV1cbiAgICAgICAgdWNzdGFydCA9IGFyZ3NbMl1cbiAgICAgICAgdWNlbmQgPSBhcmdzWzNdXG4gICAgICAgIHVzZXJzID0gYXJnc1s0XVxuICAgICAgICB0aXRsZSA9IGFyZ3NbNV1cbiAgICAgICAgc291cmNlID0gYXJnc1s2XVxuICAgICAgICBzdGFydExpc3QgPSBhcmdzWzddXG4gICAgICAgIGVuZExpc3QgPSBhcmdzWzhdXG4gICAgICAgIHRpbWVzdGFtcCA9IGFyZ3NbOV1cbiAgICAgICAgZWRpdHRva2VuID0gYXJnc1sxMF1cbiAgICAgICAgaW5hY3RpdmVMaW1pdCA9IGFyZ3NbMTFdXG4gICAgICAgIGluYWN0aXZlSW50cm8gPSBhcmdzWzEyXVxuICAgICAgICBzdW1tYXJ5ID0gYXJnc1sxM11cbiAgICAgICAgY2FsbE5leHQgPSBhcmdzWzE0XVxuICAgICAgICBwYWdlaWQgPSBhcmdzWzE1XVxuXG4gICAgICAgIGVkaXRzID0gcmVzdWx0cy5sZW5ndGhcblxuICAgICAgICBpZiBlZGl0cyA8IGluYWN0aXZlTGltaXRcbiAgICAgICAgICAgIHVzZXJzLmluYWN0aXZlLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ0ZXh0XCI6IHVzZXJzQXJyYXlbaW5kZXhdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImVkaXRzXCI6IGVkaXRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHVzZXJzLmFjdGl2ZS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwidGV4dFwiOiB1c2Vyc0FycmF5W2luZGV4XVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJlZGl0c1wiOiBlZGl0c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcblxuICAgICAgICBAaXRlcmF0ZVVzZXJzKHVzZXJzQXJyYXksIGluZGV4LCB1Y3N0YXJ0LCB1Y2VuZCwgdXNlcnMsIHRpdGxlLCBzb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRMaXN0LCBlbmRMaXN0LCB0aW1lc3RhbXAsIGVkaXR0b2tlbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmFjdGl2ZUxpbWl0LCBpbmFjdGl2ZUludHJvLCBzdW1tYXJ5LCBjYWxsTmV4dCwgcGFnZWlkKVxuXG4gICAgdXBkYXRlTGlzdDogKHVzZXJzLCB0aXRsZSwgc291cmNlLCBzdGFydExpc3QsIGVuZExpc3QsXG4gICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcCwgZWRpdHRva2VuLCBpbmFjdGl2ZUludHJvLCBzdW1tYXJ5LCBjYWxsTmV4dCwgcGFnZWlkKSA9PlxuICAgICAgICBzb3J0ZXIgPSAoYSwgYikgLT5cbiAgICAgICAgICAgICMgVXNlcnMgbXVzdCBiZSBzb3J0ZWQgaW4gZGVzY2VuZGluZyBvcmRlclxuICAgICAgICAgICAgaWYgYS5lZGl0cyA8IGIuZWRpdHNcbiAgICAgICAgICAgICAgICByZXR1cm4gMVxuICAgICAgICAgICAgZWxzZSBpZiBhLmVkaXRzID4gYi5lZGl0c1xuICAgICAgICAgICAgICAgIHJldHVybiAtMVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJldHVybiAwXG5cbiAgICAgICAgdXNlcnMuYWN0aXZlLnNvcnQoc29ydGVyKVxuICAgICAgICB1c2Vycy5pbmFjdGl2ZS5zb3J0KHNvcnRlcilcblxuICAgICAgICBuZXdMaXN0ID0gXCJcXG5cIlxuXG4gICAgICAgIGZvciB1c2VyIGluIHVzZXJzLmFjdGl2ZVxuICAgICAgICAgICAgbmV3TGlzdCArPSB1c2VyLnRleHQgKyBcIlxcblwiXG5cbiAgICAgICAgaWYgdXNlcnMuaW5hY3RpdmUubGVuZ3RoID4gMFxuICAgICAgICAgICAgbmV3TGlzdCArPSBcIlxcblwiICsgaW5hY3RpdmVJbnRybyArIFwiXFxuXFxuXCJcblxuICAgICAgICAgICAgZm9yIHVzZXIgaW4gdXNlcnMuaW5hY3RpdmVcbiAgICAgICAgICAgICAgICBuZXdMaXN0ICs9IHVzZXIudGV4dCArIFwiXFxuXCJcblxuICAgICAgICBuZXdUZXh0ID0gc291cmNlLnN1YnN0cmluZygwLCBzdGFydExpc3QpICsgbmV3TGlzdCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlLnN1YnN0cmluZyhlbmRMaXN0KVxuXG4gICAgICAgIGlmIG5ld1RleHQgIT0gc291cmNlXG4gICAgICAgICAgICBAV00uTVcuY2FsbEFQSVBvc3Qoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcImVkaXRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm90OiBcIjFcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWlub3I6IFwiMVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogdGl0bGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1bW1hcnk6IHN1bW1hcnlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IG5ld1RleHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIxYXNldGltZXN0YW1wOiB0aW1lc3RhbXBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuOiBlZGl0dG9rZW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEB3cml0ZVBhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW3RpdGxlLCBjYWxsTmV4dCwgcGFnZWlkXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBudWxsKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICBBcHAubG9nLmxvZ0luZm8oQXBwLmxvZy5saW5rVG9XaWtpUGFnZSh0aXRsZSwgdGl0bGUpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgd2FzIGFscmVhZHkgdXAgdG8gZGF0ZVwiKVxuICAgICAgICAgICAgQGl0ZXJhdGVQYWdlcyhwYWdlaWQsIGNhbGxOZXh0KVxuXG4gICAgd3JpdGVQYWdlOiAocmVzLCBhcmdzKSA9PlxuICAgICAgICB0aXRsZSA9IGFyZ3NbMF1cbiAgICAgICAgY2FsbE5leHQgPSBhcmdzWzFdXG4gICAgICAgIHBhZ2VpZCA9IGFyZ3NbMl1cblxuICAgICAgICBpZiByZXMuZWRpdCBhbmQgcmVzLmVkaXQucmVzdWx0ID09ICdTdWNjZXNzJ1xuICAgICAgICAgICAgQXBwLmxvZy5sb2dJbmZvKEFwcC5sb2cubGlua1RvV2lraVBhZ2UodGl0bGUsIHRpdGxlKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgd2FzIGNvcnJlY3RseSB1cGRhdGVkXCIpXG4gICAgICAgICAgICBAaXRlcmF0ZVBhZ2VzKHBhZ2VpZCwgY2FsbE5leHQpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIEFwcC5sb2cubG9nRXJyb3IocmVzWydlcnJvciddWydpbmZvJ10gK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIiAoXCIgKyByZXNbJ2Vycm9yJ11bJ2NvZGUnXSArIFwiKVwiKVxuIiwiIyBXaWtpIE1vbmtleSAtIE1lZGlhV2lraSBib3QgYW5kIGVkaXRvci1hc3Npc3RhbnQgdXNlciBzY3JpcHRcbiMgQ29weXJpZ2h0IChDKSAyMDExIERhcmlvIEdpb3Zhbm5ldHRpIDxkZXZAZGFyaW9naW92YW5uZXR0aS5uZXQ+XG4jXG4jIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFdpa2kgTW9ua2V5LlxuI1xuIyBXaWtpIE1vbmtleSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4jIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4jIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4jIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4jXG4jIFdpa2kgTW9ua2V5IGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4jIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4jIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiMgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbiNcbiMgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiMgYWxvbmcgd2l0aCBXaWtpIE1vbmtleS4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cblxuV00gPSByZXF1aXJlKCcuLi9tb2R1bGVzJylcbkFwcCA9IHJlcXVpcmUoJy4uL2FwcCcpXG57UGx1Z2lufSA9IHJlcXVpcmUoJy4vX1BsdWdpbicpXG5cblxuY2xhc3MgbW9kdWxlLmV4cG9ydHMuQXJjaFdpa2lXYW50ZWRDYXRlZ29yaWVzIGV4dGVuZHMgUGx1Z2luXG4gICAgQGNvbmZfZGVmYXVsdDpcbiAgICAgICAgZW5hYmxlZDogZmFsc2VcbiAgICAgICAgYm90X2xhYmVsOiBcIkNyZWF0ZSB3YW50ZWQgY2F0ZWdvcmllc1wiXG5cbiAgICBtYWluX2JvdDogKHRpdGxlLCBjYWxsQm90LCBjaGFpbkFyZ3MpIC0+XG4gICAgICAgIHRpdGxlID0gdGl0bGUucmVwbGFjZShcIiAocGFnZSBkb2VzIG5vdCBleGlzdClcIiwgXCJcIilcblxuICAgICAgICBAV00uTVcuY2FsbFF1ZXJ5KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wOiBcImluZm9cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRva2VuOiBcImVkaXRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZXM6IHRpdGxlXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgQG1haW5BdXRvV3JpdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBbdGl0bGUsIGNhbGxCb3RdLFxuICAgICAgICAgICAgICAgICAgICAgICAgbnVsbClcblxuICAgIG1haW5BdXRvV3JpdGU6IChwYWdlLCBhcmdzKSAtPlxuICAgICAgICB0aXRsZSA9IGFyZ3NbMF1cbiAgICAgICAgY2FsbEJvdCA9IGFyZ3NbMV1cblxuICAgICAgICBlZGl0dG9rZW4gPSBwYWdlLmVkaXR0b2tlblxuXG4gICAgICAgIGxhbmd1YWdlID0gV00uQXJjaFdpa2kuZGV0ZWN0TGFuZ3VhZ2UodGl0bGUpWzFdXG5cbiAgICAgICAgaWYgbGFuZ3VhZ2UgIT0gV00uQXJjaFdpa2kuZ2V0TG9jYWxMYW5ndWFnZSgpXG4gICAgICAgICAgICB0ZXh0ID0gXCJbW0NhdGVnb3J5OlwiICsgbGFuZ3VhZ2UgKyBcIl1dXCJcbiAgICAgICAgICAgIHN1bW1hcnkgPSBcIndhbnRlZCBjYXRlZ29yeVwiXG5cbiAgICAgICAgICAgIEBXTS5NVy5jYWxsQVBJUG9zdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXCJlZGl0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvdDogXCIxXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiB0aXRsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VtbWFyeTogc3VtbWFyeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogdGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlb25seTogXCIxXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuOiBlZGl0dG9rZW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEBtYWluQXV0b0VuZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsQm90LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bGwpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGNhbGxCb3QoMCwgbnVsbClcblxuICAgIG1haW5BdXRvRW5kOiAocmVzLCBjYWxsQm90KSAtPlxuICAgICAgICBpZiByZXMuZWRpdCBhbmQgcmVzLmVkaXQucmVzdWx0ID09ICdTdWNjZXNzJ1xuICAgICAgICAgICAgY2FsbEJvdCgxLCBudWxsKVxuICAgICAgICBlbHNlIGlmIHJlcy5lcnJvclxuICAgICAgICAgICAgQXBwLmxvZy5sb2dFcnJvcihyZXMuZXJyb3IuaW5mbyArIFwiIChcIiArIHJlcy5lcnJvci5jb2RlICsgXCIpXCIpXG4gICAgICAgICAgICBjYWxsQm90KHJlcy5lcnJvci5jb2RlLCBudWxsKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICBjYWxsQm90KGZhbHNlLCBudWxsKVxuIiwiIyBXaWtpIE1vbmtleSAtIE1lZGlhV2lraSBib3QgYW5kIGVkaXRvci1hc3Npc3RhbnQgdXNlciBzY3JpcHRcbiMgQ29weXJpZ2h0IChDKSAyMDExIERhcmlvIEdpb3Zhbm5ldHRpIDxkZXZAZGFyaW9naW92YW5uZXR0aS5uZXQ+XG4jXG4jIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFdpa2kgTW9ua2V5LlxuI1xuIyBXaWtpIE1vbmtleSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4jIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4jIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4jIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4jXG4jIFdpa2kgTW9ua2V5IGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4jIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4jIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiMgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbiNcbiMgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiMgYWxvbmcgd2l0aCBXaWtpIE1vbmtleS4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cblxuQXBwID0gcmVxdWlyZSgnLi4vYXBwJylcbntQbHVnaW59ID0gcmVxdWlyZSgnLi9fUGx1Z2luJylcblxuXG5jbGFzcyBtb2R1bGUuZXhwb3J0cy5EZWxldGVQYWdlcyBleHRlbmRzIFBsdWdpblxuICAgIEBjb25mX2RlZmF1bHQ6XG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlXG4gICAgICAgIGJvdF9sYWJlbDogXCJEZWxldGUgcGFnZXNcIlxuICAgICAgICBlZGl0X3N1bW1hcnk6IFwiZGVsZXRlIHBhZ2VcIlxuXG4gICAgbWFpbl9ib3Q6ICh0aXRsZSwgY2FsbEJvdCwgY2hhaW5BcmdzKSAtPlxuICAgICAgICBzdW1tYXJ5ID0gQGNvbmYuZWRpdF9zdW1tYXJ5XG5cbiAgICAgICAgQFdNLk1XLmNhbGxRdWVyeSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcDogJ2luZm8nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50b2tlbjogJ2RlbGV0ZSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZXM6IHRpdGxlXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgQG1haW5BdXRvV3JpdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBbdGl0bGUsIHN1bW1hcnksIGNhbGxCb3RdLFxuICAgICAgICAgICAgICAgICAgICAgICAgbnVsbClcblxuICAgIG1haW5BdXRvV3JpdGU6IChwYWdlLCBhcmdzKSAtPlxuICAgICAgICB0aXRsZSA9IGFyZ3NbMF1cbiAgICAgICAgc3VtbWFyeSA9IGFyZ3NbMV1cbiAgICAgICAgY2FsbEJvdCA9IGFyZ3NbMl1cblxuICAgICAgICBkZWxldGV0b2tlbiA9IHBhZ2UuZGVsZXRldG9rZW5cblxuICAgICAgICBAV00uTVcuY2FsbEFQSVBvc3Qoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogJ2RlbGV0ZSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3Q6ICcxJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiB0aXRsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuOiBkZWxldGV0b2tlblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYXNvbjogc3VtbWFyeVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIEBtYWluQXV0b0VuZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIFt0aXRsZSwgY2FsbEJvdF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBudWxsKVxuXG4gICAgbWFpbkF1dG9FbmQ6IChyZXMsIGFyZ3MpIC0+XG4gICAgICAgIHRpdGxlID0gYXJnc1swXVxuICAgICAgICBjYWxsQm90ID0gYXJnc1sxXVxuXG4gICAgICAgIGlmIG5vdCByZXMuZGVsZXRlXG4gICAgICAgICAgICBpZiByZXMuZXJyb3JcbiAgICAgICAgICAgICAgICBBcHAubG9nLmxvZ0Vycm9yKFwiI3tBcHAubG9nLmxpbmtUb1dpa2lQYWdlKHRpdGxlLCB0aXRsZSl9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhcyBub3QgYmVlbiBkZWxldGVkIVxcbiN7cmVzLmVycm9yLmluZm99XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgje3Jlcy5lcnJvci5jb2RlfSlcIilcbiAgICAgICAgICAgICAgICBjYWxsQm90KHJlcy5lcnJvci5jb2RlLCBudWxsKVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGNhbGxCb3QoZmFsc2UsIG51bGwpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGNhbGxCb3QoMSwgbnVsbClcbiIsIiMgV2lraSBNb25rZXkgLSBNZWRpYVdpa2kgYm90IGFuZCBlZGl0b3ItYXNzaXN0YW50IHVzZXIgc2NyaXB0XG4jIENvcHlyaWdodCAoQykgMjAxMSBEYXJpbyBHaW92YW5uZXR0aSA8ZGV2QGRhcmlvZ2lvdmFubmV0dGkubmV0PlxuI1xuIyBUaGlzIGZpbGUgaXMgcGFydCBvZiBXaWtpIE1vbmtleS5cbiNcbiMgV2lraSBNb25rZXkgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuIyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuIyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuIyAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuI1xuIyBXaWtpIE1vbmtleSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuIyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuIyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4jIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4jXG4jIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4jIGFsb25nIHdpdGggV2lraSBNb25rZXkuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG5cbkFwcCA9IHJlcXVpcmUoJy4uL2FwcCcpXG57UGx1Z2lufSA9IHJlcXVpcmUoJy4vX1BsdWdpbicpXG5cblxuY2xhc3MgbW9kdWxlLmV4cG9ydHMuRXhwYW5kQ29udHJhY3Rpb25zIGV4dGVuZHMgUGx1Z2luXG4gICAgQGNvbmZfZGVmYXVsdDpcbiAgICAgICAgZW5hYmxlZDogdHJ1ZVxuICAgICAgICBlZGl0b3JfbWVudTogW1wiVGV4dCBwbHVnaW5zXCIsIFwiRXhwYW5kIGNvbnRyYWN0aW9uc1wiXVxuXG4gICAgcmVwbGFjZTogKHNvdXJjZSwgcmVnRXhwLCBuZXdTdHJpbmcsIGNoZWNrU3RyaW5nLCBjaGVja1N0cmluZ3MpIC0+XG4gICAgICAgIG5ld3RleHQgPSBzb3VyY2UucmVwbGFjZShyZWdFeHAsIG5ld1N0cmluZylcbiAgICAgICAgaWYgY2hlY2tTdHJpbmdzLmxlbmd0aCA+IDEgYW5kIG5ld3RleHQgIT0gc291cmNlXG4gICAgICAgICAgICBBcHAubG9nLmxvZ1dhcm5pbmcoXCJSZXBsYWNlZCBzb21lIFxcXCIje2NoZWNrU3RyaW5nfVxcXCIgd2l0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcXCIje2NoZWNrU3RyaW5nc1swXX1cXFwiOiBjaGVjayB0aGF0IGl0IGRpZG4ndFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lYW4gXFxcIiN7Y2hlY2tTdHJpbmdzLnNsaWNlKDEpLmpvaW4oJ1xcXCIgb3IgXFxcIicpfVxcXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnN0ZWFkXCIpXG4gICAgICAgIHJldHVybiBuZXd0ZXh0XG5cbiAgICBtYWluX2VkaXRvcjogKGNhbGxOZXh0KSAtPlxuICAgICAgICBzb3VyY2UgPSBAV00uRWRpdG9yLnJlYWRTb3VyY2UoKVxuICAgICAgICBuZXd0ZXh0ID0gc291cmNlXG5cbiAgICAgICAgIyBJZ25vcmluZyBcIklcIiBzaW5jZSB3cml0aW5nIGluIDFzdCBwZXJzb24gaXNuJ3QgZm9ybWFsIGFueXdheVxuICAgICAgICAjIE5vdGUgdGhhdCBKYXZhU2NyaXB0IGRvZXNuJ3Qgc3VwcG9ydCBsb29rIGJlaGluZCA6KFxuICAgICAgICAjIFBheSBhdHRlbnRpb24gdG8gcHJlc2VydmUgdGhlIG9yaWdpbmFsIGNhcGl0YWxpemF0aW9uXG5cbiAgICAgICAgbmV3dGV4dCA9IEByZXBsYWNlKG5ld3RleHQsIC8oW2Etel0pJ3JlL2lnLCAnJDEgYXJlJywgXCIncmVcIiwgW1wiYXJlXCJdKVxuICAgICAgICBuZXd0ZXh0ID0gQHJlcGxhY2UobmV3dGV4dCwgLyhbYS16XSkndmUvaWcsICckMSBoYXZlJywgXCIndmVcIiwgW1wiaGF2ZVwiXSlcbiAgICAgICAgbmV3dGV4dCA9IEByZXBsYWNlKG5ld3RleHQsIC8oW2Etel0pJ2xsL2lnLCAnJDEgd2lsbCcsIFwiJ2xsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJ3aWxsXCIsIFwic2hhbGxcIl0pXG4gICAgICAgIG5ld3RleHQgPSBAcmVwbGFjZShuZXd0ZXh0LCAvKFthLXpdKSdkL2lnLCAnJDEgd291bGQnLCBcIidkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJ3b3VsZFwiLCBcImhhZFwiXSlcbiAgICAgICAgbmV3dGV4dCA9IEByZXBsYWNlKG5ld3RleHQsIC8oYylhbid0L2lnLCAnJDFhbm5vdCcsIFwiY2FuJ3RcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJjYW5ub3RcIl0pXG4gICAgICAgIG5ld3RleHQgPSBAcmVwbGFjZShuZXd0ZXh0LCAvKHcpb24ndC9pZywgJyQxaWxsIG5vdCcsIFwid29uJ3RcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJ3aWxsIG5vdFwiXSlcbiAgICAgICAgbmV3dGV4dCA9IEByZXBsYWNlKG5ld3RleHQsIC8oW2Etel0pbid0L2lnLCAnJDEgbm90JywgXCJuJ3RcIiwgW1wibm90XCJdKVxuICAgICAgICBuZXd0ZXh0ID0gQHJlcGxhY2UobmV3dGV4dCwgLyhoZXJlfHRoZXJlKSdzL2lnLCAnJDEgaXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiaGVyZS90aGVyZSdzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wiaGVyZS90aGVyZSBpc1wiLCBcImhlcmUvdGhlcmUgaGFzXCJdKVxuICAgICAgICBuZXd0ZXh0ID0gQHJlcGxhY2UobmV3dGV4dCwgLyhnKW9ubmEvaWcsICckMW9pbmcgdG8nLCBcImdvbm5hXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wiZ29pbmcgdG9cIl0pXG4gICAgICAgICMgUmVwbGFjaW5nIGhlJ3MsIHNoZSdzLCB0aGF0J3MsIHdoYXQncywgd2hlcmUncywgd2hvJ3MgLi4uIG1heSBiZSB0b29cbiAgICAgICAgIyAgIGRhbmdlcm91c1xuICAgICAgICBuZXd0ZXh0ID0gQHJlcGxhY2UobmV3dGV4dCwgLyhbYS16XSkncyAoYmVlbikvaWcsICckMSBoYXMgJDInLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiJ3MgYmVlblwiLCBbXCJoYXMgYmVlblwiXSlcbiAgICAgICAgbmV3dGV4dCA9IEByZXBsYWNlKG5ld3RleHQsIC8obGV0KSdzL2lnLCAnJDEgdXMnLCBcImxldCdzXCIsIFtcImxldCB1c1wiXSlcbiAgICAgICAgbmV3dGV4dCA9IEByZXBsYWNlKG5ld3RleHQsIC8oaXQpJyhzIG93bikvaWcsICckMSQyJywgXCJpdCdzIG93blwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcIml0cyBvd25cIl0pXG5cbiAgICAgICAgc3MgPSBuZXd0ZXh0Lm1hdGNoKC9bYS16XSdzL2dpKVxuICAgICAgICBpZiBzc1xuICAgICAgICAgICAgQXBwLmxvZy5sb2dXYXJuaW5nKFwiRm91bmQgXCIgKyBzcy5sZW5ndGggKyBcIiBpbnN0YW5jZXMgb2YgXFxcIidzXFxcIjogXCIgK1xuICAgICAgICAgICAgICAgICAgICBcImNoZWNrIGlmIHRoZXkgY2FuIGJlIHJlcGxhY2VkIHdpdGggXFxcImlzXFxcIiwgXFxcImhhc1xcXCIsIC4uLlwiKVxuXG4gICAgICAgIGlmIG5ld3RleHQgIT0gc291cmNlXG4gICAgICAgICAgICBAV00uRWRpdG9yLndyaXRlU291cmNlKG5ld3RleHQpXG4gICAgICAgICAgICBBcHAubG9nLmxvZ0luZm8oXCJFeHBhbmRlZCBjb250cmFjdGlvbnNcIilcblxuICAgICAgICBpZiBjYWxsTmV4dFxuICAgICAgICAgICAgY2FsbE5leHQoKVxuIiwiIyBXaWtpIE1vbmtleSAtIE1lZGlhV2lraSBib3QgYW5kIGVkaXRvci1hc3Npc3RhbnQgdXNlciBzY3JpcHRcbiMgQ29weXJpZ2h0IChDKSAyMDExIERhcmlvIEdpb3Zhbm5ldHRpIDxkZXZAZGFyaW9naW92YW5uZXR0aS5uZXQ+XG4jXG4jIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFdpa2kgTW9ua2V5LlxuI1xuIyBXaWtpIE1vbmtleSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4jIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4jIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4jIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4jXG4jIFdpa2kgTW9ua2V5IGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4jIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4jIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiMgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbiNcbiMgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiMgYWxvbmcgd2l0aCBXaWtpIE1vbmtleS4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cblxue2pzc2N9ID0gcmVxdWlyZSgnLi4vbW9kdWxlcy9saWJzJylcbkFwcCA9IHJlcXVpcmUoJy4uL2FwcCcpXG57UGx1Z2lufSA9IHJlcXVpcmUoJy4vX1BsdWdpbicpXG5cblxuY2xhc3MgbW9kdWxlLmV4cG9ydHMuRml4QmFja2xpbmtGcmFnbWVudHMgZXh0ZW5kcyBQbHVnaW5cbiAgICBAY29uZl9kZWZhdWx0OlxuICAgICAgICBlbmFibGVkOiB0cnVlXG4gICAgICAgIGJvdF9sYWJlbDogXCJGaXggbGlua3MgdG8gc3BlY2lmaWMgc2VjdGlvbnMgb2YgYSB0YXJnZXQgcGFnZVwiXG4gICAgICAgIGVkaXRfc3VtbWFyeTogXCJmaXggbGlua3MgdG8gc3BlY2lmaWMgc2VjdGlvbnNcIlxuXG4gICAgbWFrZUJvdFVJOiA9PlxuICAgICAgICB7Y2xhc3Nlc30gPSBqc3NjKFxuICAgICAgICAgICAgZml4QmFja2xpbmtGcmFnbWVudHM6XG4gICAgICAgICAgICAgICAgXCImIGlucHV0W3R5cGU9J3RleHQnXVwiOlxuICAgICAgICAgICAgICAgICAgICBtYXJnaW5MZWZ0OiAnMC4zM2VtJ1xuICAgICAgICApXG5cbiAgICAgICAgZGl2TWFpbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgICAgIGRpdk1haW4uaWQgPSBcIldpa2lNb25rZXktRml4QmFja2xpbmtGcmFnbWVudHNcIlxuICAgICAgICBkaXZNYWluLmNsYXNzTmFtZSA9IGNsYXNzZXMuZml4QmFja2xpbmtGcmFnbWVudHNcblxuICAgICAgICBsYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKVxuICAgICAgICBsYWJlbC5pbm5lckhUTUwgPSAnVGFyZ2V0IHBhZ2U6J1xuICAgICAgICBkaXZNYWluLmFwcGVuZENoaWxkKGxhYmVsKVxuXG4gICAgICAgIHRhcmdldCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0JylcbiAgICAgICAgdGFyZ2V0LnNldEF0dHJpYnV0ZSgndHlwZScsICd0ZXh0JylcbiAgICAgICAgdGFyZ2V0LmlkID0gXCJXaWtpTW9ua2V5LUZpeEJhY2tsaW5rRnJhZ21lbnRzLVRhcmdldFwiXG5cbiAgICAgICAgaWYgQFdNLldoYXRMaW5rc0hlcmUuaXNXaGF0TGlua3NIZXJlUGFnZSgpXG4gICAgICAgICAgICB0YXJnZXQudmFsdWUgPSBAV00uV2hhdExpbmtzSGVyZS5nZXRUaXRsZSgpXG5cbiAgICAgICAgZGl2TWFpbi5hcHBlbmRDaGlsZCh0YXJnZXQpXG5cbiAgICAgICAgcmV0dXJuIGRpdk1haW5cblxuICAgIHJlYWRUYXJnZXQgPSAtPlxuICAgICAgICByZXR1cm4gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJXaWtpTW9ua2V5LUZpeEJhY2tsaW5rRnJhZ21lbnRzLVRhcmdldFwiKS52YWx1ZVxuXG4gICAgZml4TGlua3M6IChzb3VyY2UsIHRhcmdldCwgc2VjdGlvbnMpID0+XG4gICAgICAgICMgTm90ZSB0aGF0IGl0J3MgaW1wb3NzaWJsZSB0byByZWNvZ25pemUgYW55IG5hbWVzcGFjZXMgaW4gdGhlIHRpdGxlXG4gICAgICAgICMgICB3aXRob3V0IHF1ZXJ5aW5nIHRoZSBzZXJ2ZXJcbiAgICAgICAgIyBBbHRlcm5hdGl2ZWx5LCBhIGxpc3Qgb2YgdGhlIGtub3duIG5hbWVzcGFjZXMgY291bGQgYmUgbWFpbnRhaW5lZFxuICAgICAgICAjICAgZm9yIGVhY2ggd2lraVxuICAgICAgICAjIFJlY29nbml6aW5nIG5hbWVzcGFjZXMgd291bGQgbGV0IHJlY29nbml6ZSBtb3JlIGxpYmVyYWwgbGlua1xuICAgICAgICAjICAgc3ludGF4ZXMgKGUuZy4gc3BhY2VzIGFyb3VuZCB0aGUgY29sb24pXG4gICAgICAgIGxpbmtzID0gQFdNLlBhcnNlci5maW5kSW50ZXJuYWxMaW5rcyhzb3VyY2UsIG51bGwsIHRhcmdldClcblxuICAgICAgICBuZXdUZXh0ID0gXCJcIlxuICAgICAgICBwcmV2SWQgPSAwXG5cbiAgICAgICAgZm9yIGxpbmsgaW4gbGlua3NcbiAgICAgICAgICAgIG5ld1RleHQgKz0gc291cmNlLnN1YnN0cmluZyhwcmV2SWQsIGxpbmsuaW5kZXgpXG4gICAgICAgICAgICBuZXdsaW5rID0gbGluay5yYXdMaW5rXG5cbiAgICAgICAgICAgIHJhd2ZyYWdtZW50ID0gbGluay5mcmFnbWVudFxuXG4gICAgICAgICAgICBpZiByYXdmcmFnbWVudFxuICAgICAgICAgICAgICAgIGZpeGVkRnJhZ21lbnQgPSBAZml4RnJhZ21lbnQocmF3ZnJhZ21lbnQsIHNlY3Rpb25zKVxuXG4gICAgICAgICAgICAgICAgaWYgZml4ZWRGcmFnbWVudCBpcyB0cnVlXG4gICAgICAgICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgICAgICBlbHNlIGlmIGZpeGVkRnJhZ21lbnRcbiAgICAgICAgICAgICAgICAgICAgb2xkbGluayA9IG5ld2xpbmtcbiAgICAgICAgICAgICAgICAgICAgbmV3bGluayA9IFwiW1tcIiArIHRhcmdldCArIFwiI1wiICsgZml4ZWRGcmFnbWVudCArXG4gICAgICAgICAgICAgICAgICAgICAgICAoaWYgbGluay5hbmNob3IgdGhlbiBcInxcIiArIGxpbmsuYW5jaG9yIGVsc2UgXCJcIikgKyBcIl1dXCJcbiAgICAgICAgICAgICAgICAgICAgQXBwLmxvZy5sb2dJbmZvKFwiRml4ZWQgYnJva2VuIGxpbmsgZnJhZ21lbnQ6IFwiICsgb2xkbGluayArXG4gICAgICAgICAgICAgICAgICAgICAgICBcIiAtPiBcIiArIEFwcC5sb2cubGlua1RvV2lraVBhZ2UobGluay5saW5rLCBuZXdsaW5rKSlcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIEFwcC5sb2cubG9nV2FybmluZyhcIkNhbm5vdCBmaXggYnJva2VuIGxpbmsgZnJhZ21lbnQ6IFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFwcC5sb2cubGlua1RvV2lraVBhZ2UobGluay5saW5rLCBuZXdsaW5rKSlcblxuICAgICAgICAgICAgbmV3VGV4dCArPSBuZXdsaW5rXG4gICAgICAgICAgICBwcmV2SWQgPSBsaW5rLmluZGV4ICsgbGluay5sZW5ndGhcblxuICAgICAgICBuZXdUZXh0ICs9IHNvdXJjZS5zdWJzdHIocHJldklkKVxuXG4gICAgICAgICMgV2l0aG91dCB0aGlzIGNoZWNrIHRoaXMgcGx1Z2luIHdvdWxkIGJlIHNwZWNpZmljIHRvIEFyY2hXaWtpXG4gICAgICAgIGlmIGxvY2F0aW9uLmhvc3RuYW1lID09ICd3aWtpLmFyY2hsaW51eC5vcmcnXG4gICAgICAgICAgICBuZXdUZXh0ID0gQGZpeEFyY2hXaWtpTGlua3MobmV3VGV4dCwgdGFyZ2V0LCBzZWN0aW9ucylcblxuICAgICAgICByZXR1cm4gbmV3VGV4dFxuXG4gICAgZml4QXJjaFdpa2lMaW5rczogKHNvdXJjZSwgdGFyZ2V0LCBzZWN0aW9ucykgPT5cbiAgICAgICAgbGlua3MgPSBAV00uUGFyc2VyLmZpbmRUZW1wbGF0ZXMoc291cmNlLCAnUmVsYXRlZCcpXG5cbiAgICAgICAgbmV3VGV4dDEgPSBcIlwiXG4gICAgICAgIHByZXZJZCA9IDBcblxuICAgICAgICBmb3IgbGluayBpbiBsaW5rc1xuICAgICAgICAgICAgbmV3VGV4dDEgKz0gc291cmNlLnN1YnN0cmluZyhwcmV2SWQsIGxpbmsuaW5kZXgpXG4gICAgICAgICAgICBuZXdUZXh0MSArPSBAZml4QXJjaFdpa2lMaW5rKHRhcmdldCwgc2VjdGlvbnMsIGxpbmssIDEpXG4gICAgICAgICAgICBwcmV2SWQgPSBsaW5rLmluZGV4ICsgbGluay5sZW5ndGhcblxuICAgICAgICBuZXdUZXh0MSArPSBzb3VyY2Uuc3Vic3RyKHByZXZJZClcblxuICAgICAgICBsaW5rczIgPSBAV00uUGFyc2VyLmZpbmRUZW1wbGF0ZXMobmV3VGV4dDEsICdSZWxhdGVkMicpXG5cbiAgICAgICAgbmV3VGV4dDIgPSBcIlwiXG4gICAgICAgIHByZXZJZCA9IDBcblxuICAgICAgICBmb3IgbGluazIgaW4gbGlua3MyXG4gICAgICAgICAgICBuZXdUZXh0MiArPSBuZXdUZXh0MS5zdWJzdHJpbmcocHJldklkLCBsaW5rMi5pbmRleClcbiAgICAgICAgICAgIG5ld1RleHQyICs9IEBmaXhBcmNoV2lraUxpbmsodGFyZ2V0LCBzZWN0aW9ucywgbGluazIsIDIpXG4gICAgICAgICAgICBwcmV2SWQgPSBsaW5rMi5pbmRleCArIGxpbmsyLmxlbmd0aFxuXG4gICAgICAgIG5ld1RleHQyICs9IG5ld1RleHQxLnN1YnN0cihwcmV2SWQpXG5cbiAgICAgICAgcmV0dXJuIG5ld1RleHQyXG5cbiAgICBmaXhBcmNoV2lraUxpbms6ICh0YXJnZXQsIHNlY3Rpb25zLCB0ZW1wbGF0ZSwgZXhwZWN0ZWRBcmdzKSA9PlxuICAgICAgICBhcmdzID0gdGVtcGxhdGUuYXJndW1lbnRzXG5cbiAgICAgICAgIyBEb24ndCBjcmFzaCBpbiBjYXNlIG9mIG1hbGZvcm1lZCB0ZW1wbGF0ZXNcbiAgICAgICAgaWYgYXJncy5sZW5ndGggPT0gZXhwZWN0ZWRBcmdzXG4gICAgICAgICAgICBsaW5rID0gYXJnc1swXS52YWx1ZVxuICAgICAgICAgICAgZnJhZ0lkID0gbGluay5pbmRleE9mKCcjJylcblxuICAgICAgICAgICAgaWYgZnJhZ0lkID4gLTFcbiAgICAgICAgICAgICAgICBsdGl0bGUgPSBsaW5rLnN1YnN0cmluZygwLCBmcmFnSWQpXG5cbiAgICAgICAgICAgICAgICAjIE5vdGUgdGhhdCBpdCdzIGltcG9zc2libGUgdG8gcmVjb2duaXplIGFueSBuYW1lc3BhY2VzIGluIHRoZVxuICAgICAgICAgICAgICAgICMgICB0aXRsZSB3aXRob3V0IHF1ZXJ5aW5nIHRoZSBzZXJ2ZXJcbiAgICAgICAgICAgICAgICAjIEFsdGVybmF0aXZlbHksIGEgbGlzdCBvZiB0aGUga25vd24gbmFtZXNwYWNlcyBjb3VsZCBiZVxuICAgICAgICAgICAgICAgICMgICBtYWludGFpbmVkIGZvciBlYWNoIHdpa2lcbiAgICAgICAgICAgICAgICAjIFJlY29nbml6aW5nIG5hbWVzcGFjZXMgd291bGQgbGV0IHJlY29nbml6ZSBtb3JlIGxpYmVyYWwgbGlua1xuICAgICAgICAgICAgICAgICMgICBzeW50YXhlcyAoZS5nLiBzcGFjZXMgYXJvdW5kIHRoZSBjb2xvbilcbiAgICAgICAgICAgICAgICBpZiBAV00uUGFyc2VyLmNvbXBhcmVBcnRpY2xlVGl0bGVzKGx0aXRsZSwgdGFyZ2V0KVxuICAgICAgICAgICAgICAgICAgICByYXdmcmFnbWVudCA9IGxpbmsuc3Vic3RyKGZyYWdJZCArIDEpXG4gICAgICAgICAgICAgICAgICAgIGZpeGVkRnJhZ21lbnQgPSBAZml4RnJhZ21lbnQocmF3ZnJhZ21lbnQsIHNlY3Rpb25zKVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIGZpeGVkRnJhZ21lbnQgaXMgdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIGZpeGVkRnJhZ21lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuY2hvciA9IGlmIGFyZ3NbMV0gdGhlbiAoXCJ8XCIgKyBhcmdzWzFdLnZhbHVlKSBlbHNlIFwiXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld2xpbmsgPSBcInt7XCIgKyB0ZW1wbGF0ZS50aXRsZSArIFwifFwiICsgdGFyZ2V0ICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIiNcIiArIGZpeGVkRnJhZ21lbnQgICsgYW5jaG9yICsgXCJ9fVwiXG4gICAgICAgICAgICAgICAgICAgICAgICBBcHAubG9nLmxvZ0luZm8oXCJGaXhlZCBicm9rZW4gbGluayBmcmFnbWVudDogXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlLnJhd1RyYW5zY2x1c2lvbiArIFwiIC0+IFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBcHAubG9nLmxpbmtUb1dpa2lQYWdlKGxpbmssIG5ld2xpbmspKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ld2xpbmtcblxuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBBcHAubG9nLmxvZ1dhcm5pbmcoXCJDYW5ub3QgZml4IGJyb2tlbiBsaW5rIGZyYWdtZW50OiBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQXBwLmxvZy5saW5rVG9XaWtpUGFnZShsaW5rLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlLnJhd1RyYW5zY2x1c2lvbikpXG5cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgQXBwLmxvZy5sb2dXYXJuaW5nKFwiVGVtcGxhdGU6XCIgKyB0ZW1wbGF0ZS50aXRsZSArIFwiIG11c3QgaGF2ZSBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZEFyZ3MgKyBcIiBhbmQgb25seSBcIiArIGV4cGVjdGVkQXJncyArXG4gICAgICAgICAgICAgICAgICAgICAgICAoaWYgZXhwZWN0ZWRBcmdzID4gMSB0aGVuIFwiIGFyZ3VtZW50czogXCIgZWxzZSBcIiBhcmd1bWVudDogXCIpICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlLnJhd1RyYW5zY2x1c2lvbilcblxuICAgICAgICByZXR1cm4gdGVtcGxhdGUucmF3VHJhbnNjbHVzaW9uXG5cbiAgICBmaXhGcmFnbWVudDogKHJhd2ZyYWdtZW50LCBzZWN0aW9ucykgPT5cbiAgICAgICAgaWYgcmF3ZnJhZ21lbnRcbiAgICAgICAgICAgIGZyYWdtZW50ID0gQFdNLlBhcnNlci5zcXVhc2hDb250aWd1b3VzV2hpdGVzcGFjZShyYXdmcmFnbWVudClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRyaW0oKVxuXG4gICAgICAgICAgICBpZiBzZWN0aW9ucy5pbmRleE9mKGZyYWdtZW50KSA8IDBcbiAgICAgICAgICAgICAgICBmb3Igc2VjdGlvbiBpbiBzZWN0aW9uc1xuICAgICAgICAgICAgICAgICAgICAjIFRoZSBGaXhGcmFnbWVudHMgYW5kIEZpeExpbmtGcmFnbWVudHMgcGx1Z2lucyBhbHNvIHRyeVxuICAgICAgICAgICAgICAgICAgICAjIHRvIGZpeCBkb3QtZW5jb2RlZCBmcmFnbWVudHMgaG93ZXZlciBpdCdzIHRvbyBkYW5nZXJvdXNcbiAgICAgICAgICAgICAgICAgICAgIyB0byBkbyBpdCB3aXRoIHRoaXMgYm90IHBsdWdpbiwgaGF2ZSB0aGUgdXNlciBmaXhcbiAgICAgICAgICAgICAgICAgICAgIyBmcmFnbWVudHMgbWFudWFsbHlcbiAgICAgICAgICAgICAgICAgICAgaWYgc2VjdGlvbi50b0xvd2VyQ2FzZSgpID09IGZyYWdtZW50LnRvTG93ZXJDYXNlKClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWN0aW9uXG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuXG4gICAgbWFpbl9ib3Q6ICh0aXRsZSwgY2FsbEJvdCwgY2hhaW5BcmdzKSAtPlxuICAgICAgICBzdW1tYXJ5ID0gQGNvbmYuZWRpdF9zdW1tYXJ5XG5cbiAgICAgICAgdGFyZ2V0ID0gcmVhZFRhcmdldCgpXG4gICAgICAgIEFwcC5sb2cubG9nSGlkZGVuKFwiVGFyZ2V0IHBhZ2U6IFwiICsgdGFyZ2V0KVxuXG4gICAgICAgIGlmIHRhcmdldFxuICAgICAgICAgICAgaWYgY2hhaW5BcmdzIGlzIG51bGxcbiAgICAgICAgICAgICAgICBwYXJhbXMgPVxuICAgICAgICAgICAgICAgICAgICAnYWN0aW9uJzogJ3BhcnNlJ1xuICAgICAgICAgICAgICAgICAgICAncHJvcCc6ICdzZWN0aW9ucydcbiAgICAgICAgICAgICAgICAgICAgJ3BhZ2UnOiB0YXJnZXRcbiAgICAgICAgICAgICAgICAgICAgJ3JlZGlyZWN0cyc6IDFcblxuICAgICAgICAgICAgICAgIEFwcC5sb2cubG9nV2FybmluZyhcIklmIHNvbWUgYXJ0aWNsZXMgaW4gdGhlIGxpc3QgYXJlXG4gICAgICAgICAgICAgICAgICAgIGxpbmtpbmcgdG8gdGhlIHRhcmdldCBhcnRpY2xlXG4gICAgICAgICAgICAgICAgICAgIHRocm91Z2ggYSByZWRpcmVjdCwgeW91IHNob3VsZCBwcm9jZXNzIHRoZSBiYWNrbGlua3NcbiAgICAgICAgICAgICAgICAgICAgb2YgdGhhdCByZWRpcmVjdCBwYWdlIHNlcGFyYXRlbHkgdGhyb3VnaCBpdHNcbiAgICAgICAgICAgICAgICAgICAgU3BlY2lhbDpXaGF0TGlua3NIZXJlIHBhZ2UsIGFzIHRoaXMgcGx1Z2luIGNhbiBvbmx5XG4gICAgICAgICAgICAgICAgICAgIGZpeCBsaW5rcyB0aGF0IGV4YWN0bHkgbWF0Y2ggdGhlIHRpdGxlIG9mIHRoZSB0YXJnZXRcbiAgICAgICAgICAgICAgICAgICAgYXJ0aWNsZS5cXG5JbiBvcmRlciB0byBzYXZlIHRpbWUgeW91IGFyZSBhZHZpc2VkIHRvXG4gICAgICAgICAgICAgICAgICAgIGhpZGUgdGhlIHJlZGlyZWN0cyBpbiB0aGUgcGFnZSBsaXN0cyB0aGF0IGFsbG93IHRvIGRvXG4gICAgICAgICAgICAgICAgICAgIHNvLlwiKVxuXG4gICAgICAgICAgICAgICAgQFdNLk1XLmNhbGxBUElHZXQocGFyYW1zLFxuICAgICAgICAgICAgICAgICAgICAgICAgIEBtYWluQXV0b0ZpbmRTZWN0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICBbdGl0bGUsIHRhcmdldCwgc3VtbWFyeSwgY2FsbEJvdF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgbnVsbClcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBAbWFpbkF1dG9SZWFkKHRhcmdldCwgY2hhaW5BcmdzLCB0aXRsZSwgc3VtbWFyeSwgY2FsbEJvdClcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgQXBwLmxvZy5sb2dFcnJvcignVGhlIHRhcmdldCBwYWdlIGNhbm5vdCBiZSBlbXB0eScpXG4gICAgICAgICAgICBjYWxsQm90KGZhbHNlLCBudWxsKVxuXG4gICAgbWFpbkF1dG9GaW5kU2VjdGlvbnM6IChyZXMsIGFyZ3MpID0+XG4gICAgICAgIHRpdGxlID0gYXJnc1swXVxuICAgICAgICB0YXJnZXQgPSBhcmdzWzFdXG4gICAgICAgIHN1bW1hcnkgPSBhcmdzWzJdXG4gICAgICAgIGNhbGxCb3QgPSBhcmdzWzNdXG4gICAgICAgIHNlY3Rpb25zID0gW11cblxuICAgICAgICBpZiByZXMucGFyc2VcbiAgICAgICAgICAgIGZvciBzZWN0aW9uIGluIHJlcy5wYXJzZS5zZWN0aW9uc1xuICAgICAgICAgICAgICAgIHNlY3Rpb25zLnB1c2goQFdNLlBhcnNlci5zcXVhc2hDb250aWd1b3VzV2hpdGVzcGFjZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWN0aW9uLmxpbmUpLnRyaW0oKSlcblxuICAgICAgICAgICAgQG1haW5BdXRvUmVhZCh0YXJnZXQsIHNlY3Rpb25zLCB0aXRsZSwgc3VtbWFyeSwgY2FsbEJvdClcblxuICAgICAgICBlbHNlXG4gICAgICAgICAgICBBcHAubG9nLmxvZ0Vycm9yKFwiVGhlIHNldCB0YXJnZXQgcGFnZSwgXCIgKyB0YXJnZXQgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLCBzZWVtcyBub3QgdG8gZXhpc3RcIilcblxuICAgICAgICAgICAgaWYgcmVzLmVycm9yXG4gICAgICAgICAgICAgICAgY2FsbEJvdChyZXMuZXJyb3IuY29kZSwgc2VjdGlvbnMpXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgY2FsbEJvdChmYWxzZSwgc2VjdGlvbnMpXG5cbiAgICBtYWluQXV0b1JlYWQ6ICh0YXJnZXQsIHNlY3Rpb25zLCB0aXRsZSwgc3VtbWFyeSwgY2FsbEJvdCkgPT5cbiAgICAgICAgQFdNLk1XLmNhbGxRdWVyeUVkaXQodGl0bGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQG1haW5BdXRvV3JpdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW3RhcmdldCwgc3VtbWFyeSwgY2FsbEJvdCwgc2VjdGlvbnNdKVxuXG4gICAgbWFpbkF1dG9Xcml0ZTogKHRpdGxlLCBzb3VyY2UsIHRpbWVzdGFtcCwgZWRpdHRva2VuLCBhcmdzKSA9PlxuICAgICAgICB0YXJnZXQgPSBhcmdzWzBdXG4gICAgICAgIHN1bW1hcnkgPSBhcmdzWzFdXG4gICAgICAgIGNhbGxCb3QgPSBhcmdzWzJdXG4gICAgICAgIHNlY3Rpb25zID0gYXJnc1szXVxuXG4gICAgICAgIG5ld3RleHQgPSBAZml4TGlua3Moc291cmNlLCB0YXJnZXQsIHNlY3Rpb25zKVxuXG4gICAgICAgIGlmIG5ld3RleHQgIT0gc291cmNlXG4gICAgICAgICAgICBAV00uTVcuY2FsbEFQSVBvc3Qoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcImVkaXRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvdDogXCIxXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogdGl0bGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdW1tYXJ5OiBzdW1tYXJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogbmV3dGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhc2V0aW1lc3RhbXA6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuOiBlZGl0dG9rZW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQG1haW5BdXRvRW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbY2FsbEJvdCwgc2VjdGlvbnNdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudWxsKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICBjYWxsQm90KDAsIHNlY3Rpb25zKVxuXG4gICAgbWFpbkF1dG9FbmQ6IChyZXMsIGFyZ3MpID0+XG4gICAgICAgIGNhbGxCb3QgPSBhcmdzWzBdXG4gICAgICAgIHNlY3Rpb25zID0gYXJnc1sxXVxuXG4gICAgICAgIGlmIHJlcy5lZGl0IGFuZCByZXMuZWRpdC5yZXN1bHQgPT0gJ1N1Y2Nlc3MnXG4gICAgICAgICAgICBjYWxsQm90KDEsIHNlY3Rpb25zKVxuICAgICAgICBlbHNlIGlmIHJlcy5lcnJvclxuICAgICAgICAgICAgQXBwLmxvZy5sb2dFcnJvcihyZXMuZXJyb3IuaW5mbyArIFwiIChcIiArIHJlcy5lcnJvci5jb2RlICsgXCIpXCIpXG4gICAgICAgICAgICBjYWxsQm90KHJlcy5lcnJvci5jb2RlLCBzZWN0aW9ucylcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgY2FsbEJvdChmYWxzZSwgc2VjdGlvbnMpXG4iLCIjIFdpa2kgTW9ua2V5IC0gTWVkaWFXaWtpIGJvdCBhbmQgZWRpdG9yLWFzc2lzdGFudCB1c2VyIHNjcmlwdFxuIyBDb3B5cmlnaHQgKEMpIDIwMTEgRGFyaW8gR2lvdmFubmV0dGkgPGRldkBkYXJpb2dpb3Zhbm5ldHRpLm5ldD5cbiNcbiMgVGhpcyBmaWxlIGlzIHBhcnQgb2YgV2lraSBNb25rZXkuXG4jXG4jIFdpa2kgTW9ua2V5IGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiMgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiMgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiMgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbiNcbiMgV2lraSBNb25rZXkgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiMgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiMgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuIyBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuI1xuIyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuIyBhbG9uZyB3aXRoIFdpa2kgTW9ua2V5LiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuXG5BcHAgPSByZXF1aXJlKCcuLi9hcHAnKVxue1BsdWdpbn0gPSByZXF1aXJlKCcuL19QbHVnaW4nKVxuU3RyID0gcmVxdWlyZSgnQGt5bmlrb3MvbWlzYy9kaXN0L1N0cicpXG5cblxuY2xhc3MgbW9kdWxlLmV4cG9ydHMuRml4RG91YmxlUmVkaXJlY3RzIGV4dGVuZHMgUGx1Z2luXG4gICAgQGNvbmZfZGVmYXVsdDpcbiAgICAgICAgZW5hYmxlZDogdHJ1ZVxuICAgICAgICBzcGVjaWFsX21lbnU6IFtcIkZpeCBkb3VibGUgcmVkaXJlY3RzXCJdXG4gICAgICAgIGVkaXRfc3VtbWFyeTogXCJmaXggZG91YmxlIHJlZGlyZWN0XCJcblxuICAgIG1haW5fc3BlY2lhbDogKGNhbGxOZXh0KSAtPlxuICAgICAgICBBcHAubG9nLmxvZ0luZm8oXCJGaXhpbmcgZG91YmxlIHJlZGlyZWN0cyAuLi5cIilcblxuICAgICAgICB7cmVzdWx0cywgc2l0ZWluZm99ID1cbiAgICAgICAgICAgIGF3YWl0IEBXTS5NVy5nZXRTcGVjaWFsTGlzdChcIkRvdWJsZVJlZGlyZWN0c1wiLCBcIm5hbWVzcGFjZXNcIilcblxuICAgICAgICB7bmFtZXNwYWNlc30gPSBzaXRlaW5mb1xuICAgICAgICByZXN1bHRzLnJldmVyc2UoKVxuXG4gICAgICAgIHRyeVxuICAgICAgICAgICAgZm9yIGRvdWJsZVJlZGlyZWN0IGluIHJlc3VsdHNcbiAgICAgICAgICAgICAgICBhd2FpdCBAcHJvY2Vzc19yZWRpcmVjdChkb3VibGVSZWRpcmVjdCwgbmFtZXNwYWNlcylcbiAgICAgICAgY2F0Y2ggZXJyb3JcbiAgICAgICAgICAgIEFwcC5sb2cubG9nRXJyb3IoZXJyb3IubWVzc2FnZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuXG4gICAgICAgIEFwcC5sb2cubG9nSW5mbyhcIkZpeGVkIGRvdWJsZSByZWRpcmVjdHNcIilcbiAgICAgICAgaWYgY2FsbE5leHRcbiAgICAgICAgICAgIGNhbGxOZXh0KClcblxuICAgIHByb2Nlc3NfcmVkaXJlY3Q6IChkb3VibGVSZWRpcmVjdCwgbmFtZXNwYWNlcykgPT5cbiAgICAgICAge3NvdXJjZSwgdGltZXN0YW1wLCBlZGl0dG9rZW59ID1cbiAgICAgICAgICAgIGF3YWl0IEBXTS5NVy5jYWxsUXVlcnlFZGl0KGRvdWJsZVJlZGlyZWN0LnRpdGxlKVxuICAgICAgICBkb3VibGVSZWRpcmVjdFNvdXJjZSA9IHNvdXJjZVxuXG4gICAgICAgIG1pZGRsZVJlZGlyZWN0VGl0bGUgPVxuICAgICAgICAgICAgW25hbWVzcGFjZXNbZG91YmxlUmVkaXJlY3QuZGF0YWJhc2VSZXN1bHQuYl9uYW1lc3BhY2VdWycqJ11cbiAgICAgICAgICAgICBkb3VibGVSZWRpcmVjdC5kYXRhYmFzZVJlc3VsdC5iX3RpdGxlXS5qb2luKCc6JylcblxuICAgICAgICBtaWRkbGVSZWRpcmVjdCA9IGF3YWl0IEBXTS5NVy5jYWxsUXVlcnkoXG4gICAgICAgICAgICBwcm9wOiBcInJldmlzaW9uc1wiXG4gICAgICAgICAgICBydnByb3A6IFwiY29udGVudFwiXG4gICAgICAgICAgICB0aXRsZXM6IG1pZGRsZVJlZGlyZWN0VGl0bGVcbiAgICAgICAgKVxuXG4gICAgICAgIG1pZGRsZVJlZGlyZWN0U291cmNlID0gbWlkZGxlUmVkaXJlY3QucmV2aXNpb25zWzBdW1wiKlwiXVxuXG4gICAgICAgIEFwcC5sb2cubG9nSW5mbyhcIlByb2Nlc3NpbmcgI3tBcHAubG9nLmxpbmtUb1dpa2lQYWdlKFxuICAgICAgICAgICAgZG91YmxlUmVkaXJlY3QudGl0bGUsIGRvdWJsZVJlZGlyZWN0LnRpdGxlKX0gLi4uXCIpXG5cbiAgICAgICAgcmF3T2xkVGFyZ2V0ID0gZG91YmxlUmVkaXJlY3RTb3VyY2UubWF0Y2goL1xccyojcmVkaXJlY3RcXHMqW15cXG5dKy9pKVxuICAgICAgICBvbGRUYXJnZXQgPSBAV00uUGFyc2VyLmZpbmRJbnRlcm5hbExpbmtzKHJhd09sZFRhcmdldFswXSwgbnVsbClbMF1cblxuICAgICAgICByYXdNaWRkbGVUYXJnZXQgPSBtaWRkbGVSZWRpcmVjdFNvdXJjZS5tYXRjaCgvXFxzKiNyZWRpcmVjdFxccypbXlxcbl0rL2kpXG4gICAgICAgIG1pZGRsZVRhcmdldCA9XG4gICAgICAgICAgICBAV00uUGFyc2VyLmZpbmRJbnRlcm5hbExpbmtzKHJhd01pZGRsZVRhcmdldFswXSwgbnVsbClbMF1cblxuICAgICAgICBuZXdUYXJnZXRGcmFnbWVudCA9IGRvIC0+XG4gICAgICAgICAgICBpZiBvbGRUYXJnZXQuZnJhZ21lbnRcbiAgICAgICAgICAgICAgICByZXR1cm4gXCIjXCIgKyBvbGRUYXJnZXQuZnJhZ21lbnRcbiAgICAgICAgICAgIGVsc2UgaWYgbWlkZGxlVGFyZ2V0LmZyYWdtZW50XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiI1wiICsgbWlkZGxlVGFyZ2V0LmZyYWdtZW50XG4gICAgICAgICAgICByZXR1cm4gXCJcIlxuXG4gICAgICAgIG5ld1RhcmdldEFsdEFuY2hvciA9IGRvIC0+XG4gICAgICAgICAgICBpZiBvbGRUYXJnZXQuYW5jaG9yXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwifFwiICsgb2xkVGFyZ2V0LmFuY2hvclxuICAgICAgICAgICAgZWxzZSBpZiBtaWRkbGVUYXJnZXQuYW5jaG9yXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwifFwiICsgbWlkZGxlVGFyZ2V0LmFuY2hvclxuICAgICAgICAgICAgcmV0dXJuIFwiXCJcblxuICAgICAgICBuZXdUYXJnZXRJbnRlcmxhbmd1YWdlID0gaWYgZG91YmxlUmVkaXJlY3QuZGF0YWJhc2VSZXN1bHQuY19pbnRlcndpa2kgXFxcbiAgICAgICAgICAgIHRoZW4gZG91YmxlUmVkaXJlY3QuZGF0YWJhc2VSZXN1bHQuY19pbnRlcndpa2kgKyBcIjpcIiBlbHNlIFwiXCJcblxuICAgICAgICBuZXdUYXJnZXROYW1lc3BhY2UgPSBkbyAtPlxuICAgICAgICAgICAgY25zID0gbmFtZXNwYWNlc1tkb3VibGVSZWRpcmVjdC5kYXRhYmFzZVJlc3VsdC5jX25hbWVzcGFjZV1bXCIqXCJdXG4gICAgICAgICAgICBpZiBjbnNcbiAgICAgICAgICAgICAgICByZXR1cm4gQFdNLlBhcnNlci5zcXVhc2hDb250aWd1b3VzV2hpdGVzcGFjZShjbnMpICsgXCI6XCJcbiAgICAgICAgICAgIHJldHVybiBcIlwiXG5cbiAgICAgICAgbmV3VGFyZ2V0VGl0bGUgPSBAV00uUGFyc2VyLnNxdWFzaENvbnRpZ3VvdXNXaGl0ZXNwYWNlKFxuICAgICAgICAgICAgZG91YmxlUmVkaXJlY3QuZGF0YWJhc2VSZXN1bHQuY190aXRsZSlcblxuICAgICAgICBuZXdUYXJnZXQgPSBcIltbI3tuZXdUYXJnZXRJbnRlcmxhbmd1YWdlfSN7bmV3VGFyZ2V0TmFtZXNwYWNlfVwiICtcbiAgICAgICAgICAgIFwiI3tuZXdUYXJnZXRUaXRsZX0je25ld1RhcmdldEZyYWdtZW50fSN7bmV3VGFyZ2V0QWx0QW5jaG9yfV1dXCJcbiAgICAgICAgbmV3VGV4dCA9IFN0ci5vdmVyd3JpdGVGb3IoZG91YmxlUmVkaXJlY3RTb3VyY2UsIG5ld1RhcmdldCxcbiAgICAgICAgICAgIG9sZFRhcmdldC5pbmRleCwgb2xkVGFyZ2V0Lmxlbmd0aClcblxuICAgICAgICBpZiBuZXdUZXh0IGlzbnQgZG91YmxlUmVkaXJlY3RTb3VyY2VcbiAgICAgICAgICAgIHJlcyA9IGF3YWl0IEBXTS5NVy5jYWxsQVBJUG9zdChcbiAgICAgICAgICAgICAgICBhY3Rpb246IFwiZWRpdFwiXG4gICAgICAgICAgICAgICAgYm90OiBcIjFcIlxuICAgICAgICAgICAgICAgIHRpdGxlOiBkb3VibGVSZWRpcmVjdC50aXRsZVxuICAgICAgICAgICAgICAgIHN1bW1hcnk6IEBjb25mLmVkaXRfc3VtbWFyeVxuICAgICAgICAgICAgICAgIHRleHQ6IG5ld1RleHRcbiAgICAgICAgICAgICAgICBiMWFzZXRpbWVzdGFtcDogdGltZXN0YW1wXG4gICAgICAgICAgICAgICAgdG9rZW46IGVkaXR0b2tlblxuICAgICAgICAgICAgKVxuXG4gICAgICAgICAgICBpZiBub3QgcmVzLmVkaXQgb3IgcmVzLmVkaXQucmVzdWx0IGlzbnQgJ1N1Y2Nlc3MnXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiI3tyZXMuZXJyb3IuaW5mb30gKCN7cmVzLmVycm9yLmNvZGV9KVwiKVxuXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIEFwcC5sb2cubG9nV2FybmluZyhcIkNvdWxkIG5vdCBmaXggI3tBcHAubG9nLmxpbmtUb1dpa2lQYWdlKFxuICAgICAgICAgICAgICAgIGRvdWJsZVJlZGlyZWN0LnRpdGxlLCBkb3VibGVSZWRpcmVjdC50aXRsZSl9XCIpXG4iLCIjIFdpa2kgTW9ua2V5IC0gTWVkaWFXaWtpIGJvdCBhbmQgZWRpdG9yLWFzc2lzdGFudCB1c2VyIHNjcmlwdFxuIyBDb3B5cmlnaHQgKEMpIDIwMTEgRGFyaW8gR2lvdmFubmV0dGkgPGRldkBkYXJpb2dpb3Zhbm5ldHRpLm5ldD5cbiNcbiMgVGhpcyBmaWxlIGlzIHBhcnQgb2YgV2lraSBNb25rZXkuXG4jXG4jIFdpa2kgTW9ua2V5IGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiMgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiMgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiMgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbiNcbiMgV2lraSBNb25rZXkgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiMgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiMgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuIyBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuI1xuIyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuIyBhbG9uZyB3aXRoIFdpa2kgTW9ua2V5LiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuXG5BcHAgPSByZXF1aXJlKCcuLi9hcHAnKVxue1BsdWdpbn0gPSByZXF1aXJlKCcuL19QbHVnaW4nKVxuXG5cbmNsYXNzIG1vZHVsZS5leHBvcnRzLkZpeEZyYWdtZW50cyBleHRlbmRzIFBsdWdpblxuICAgIEBjb25mX2RlZmF1bHQ6XG4gICAgICAgIGVuYWJsZWQ6IHRydWVcbiAgICAgICAgZWRpdG9yX21lbnU6IFtcIlRleHQgcGx1Z2luc1wiLCBcIkZpeCBzZWN0aW9uIGxpbmtzXCJdXG5cbiAgICBmaXhMaW5rczogKHNvdXJjZSkgLT5cbiAgICAgICAgdGl0bGUgPSBAV00uRWRpdG9yLmdldFRpdGxlKClcbiAgICAgICAgc2VjdGlvbnMgPSBAV00uUGFyc2VyLmZpbmRTZWN0aW9uSGVhZGluZ3Moc291cmNlKS5zZWN0aW9uc1xuXG4gICAgICAgIHNsaW5rcyA9IEBXTS5QYXJzZXIuZmluZFNlY3Rpb25MaW5rcyhzb3VyY2UpXG4gICAgICAgIG5ld3RleHQxID0gXCJcIlxuICAgICAgICBwcmV2SWQgPSAwXG5cbiAgICAgICAgZm9yIGxpbmsgaW4gc2xpbmtzXG4gICAgICAgICAgICBuZXd0ZXh0MSArPSBzb3VyY2Uuc3Vic3RyaW5nKHByZXZJZCwgbGluay5pbmRleClcbiAgICAgICAgICAgIG5ld3RleHQxICs9IEBmaXhMaW5rKHNvdXJjZSwgc2VjdGlvbnMsIGxpbmsucmF3TGluaywgbGluay5mcmFnbWVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rLmFuY2hvcilcbiAgICAgICAgICAgIHByZXZJZCA9IGxpbmsuaW5kZXggKyBsaW5rLmxlbmd0aFxuXG4gICAgICAgIG5ld3RleHQxICs9IHNvdXJjZS5zdWJzdHIocHJldklkKVxuXG4gICAgICAgICMgTm90ZSB0aGF0IGl0J3MgaW1wb3NzaWJsZSB0byByZWNvZ25pemUgYW55IG5hbWVzcGFjZXMgaW4gdGhlIHRpdGxlXG4gICAgICAgICMgICB3aXRob3V0IHF1ZXJ5aW5nIHRoZSBzZXJ2ZXJcbiAgICAgICAgIyBBbHRlcm5hdGl2ZWx5LCBhIGxpc3Qgb2YgdGhlIGtub3duIG5hbWVzcGFjZXMgY291bGQgYmUgbWFpbnRhaW5lZFxuICAgICAgICAjICAgZm9yIGVhY2ggd2lraVxuICAgICAgICAjIFJlY29nbml6aW5nIG5hbWVzcGFjZXMgd291bGQgbGV0IHJlY29nbml6ZSBtb3JlIGxpYmVyYWwgbGlua1xuICAgICAgICAjICAgc3ludGF4ZXMgKGUuZy4gc3BhY2VzIGFyb3VuZCB0aGUgY29sb24pXG4gICAgICAgIGlsaW5rcyA9IEBXTS5QYXJzZXIuZmluZEludGVybmFsTGlua3MobmV3dGV4dDEsIG51bGwsIHRpdGxlKVxuICAgICAgICBuZXd0ZXh0MiA9IFwiXCJcbiAgICAgICAgcHJldklkID0gMFxuXG4gICAgICAgIGZvciBsaW5rIGluIGlsaW5rc1xuICAgICAgICAgICAgbmV3dGV4dDIgKz0gbmV3dGV4dDEuc3Vic3RyaW5nKHByZXZJZCwgbGluay5pbmRleClcbiAgICAgICAgICAgIHJhd2ZyYWdtZW50ID0gbGluay5mcmFnbWVudFxuXG4gICAgICAgICAgICBpZiByYXdmcmFnbWVudFxuICAgICAgICAgICAgICAgIG5ld3RleHQyICs9IEBmaXhMaW5rKG5ld3RleHQxLCBzZWN0aW9ucywgbGluay5yYXdMaW5rLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhd2ZyYWdtZW50LCBsaW5rLmFuY2hvcilcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBuZXd0ZXh0MiArPSBsaW5rLnJhd0xpbmtcblxuICAgICAgICAgICAgcHJldklkID0gbGluay5pbmRleCArIGxpbmsubGVuZ3RoXG5cbiAgICAgICAgbmV3dGV4dDIgKz0gbmV3dGV4dDEuc3Vic3RyKHByZXZJZClcblxuICAgICAgICByZXR1cm4gbmV3dGV4dDJcblxuICAgIGZpeExpbms6IChzb3VyY2UsIHNlY3Rpb25zLCByYXdsaW5rLCByYXdmcmFnbWVudCwgbGFsdCkgLT5cbiAgICAgICAgZnJhZ21lbnQgPSBAV00uUGFyc2VyLnNxdWFzaENvbnRpZ3VvdXNXaGl0ZXNwYWNlKHJhd2ZyYWdtZW50KS50cmltKClcblxuICAgICAgICBmb3Igc2VjdGlvbiBpbiBzZWN0aW9uc1xuICAgICAgICAgICAgaGVhZGluZyA9IHNlY3Rpb24uY2xlYW5oZWFkaW5nXG4gICAgICAgICAgICBkb3RIZWFkaW5nID0gQFdNLlBhcnNlci5kb3RFbmNvZGUoaGVhZGluZylcbiAgICAgICAgICAgIGRvdEZyYWdtZW50ID0gQFdNLlBhcnNlci5kb3RFbmNvZGUoZnJhZ21lbnQpXG5cbiAgICAgICAgICAgIGlmIGRvdEhlYWRpbmcudG9Mb3dlckNhc2UoKSA9PSBkb3RGcmFnbWVudC50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgICAgICAgaWYgZnJhZ21lbnQgPT0gZG90RnJhZ21lbnRcbiAgICAgICAgICAgICAgICAgICAgIyBJZiB0aGUgZnJhZ21lbnQgd2FzIGVuY29kZWQsIHJlLWVuY29kZSBpdCBiZWNhdXNlIGl0XG4gICAgICAgICAgICAgICAgICAgICMgY291bGQgY29udGFpbiBsaW5rLWJyZWFraW5nIGNoYXJhY3RlcnMgKGUuZy4gW118e30pXG4gICAgICAgICAgICAgICAgICAgICMgVGhlIGNvbmRpdGlvbiB3b3VsZCBhbHNvIGJlIHRydWUgaWYgdGhlIGZyYWdtZW50IGRvZXNuJ3RcbiAgICAgICAgICAgICAgICAgICAgIyBjb250YWluIGFueSBlbmNvZGFibGUgY2hhcmFjdGVycywgYnV0IHNpbmNlIGhlYWRpbmcgYW5kXG4gICAgICAgICAgICAgICAgICAgICMgZnJhZ21lbnQgYXQgbW9zdCBkaWZmZXIgYnkgY2FwaXRhbGl6YXRpb24sIGVuY29kaW5nIHRoZVxuICAgICAgICAgICAgICAgICAgICAjIGhlYWRpbmcgd29uJ3QgaGF2ZSBhbnkgZWZmZWN0XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIltbI1wiICsgZG90SGVhZGluZyArIChpZiBsYWx0IHRoZW4gXCJ8XCIgKyBsYWx0IGVsc2UgXCJcIikgKyBcIl1dXCJcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICMgSWYgdGhlIGZyYWdtZW50IHdhcyBub3QgZW5jb2RlZCwgaWYgdGhlIGZyYWdtZW50XG4gICAgICAgICAgICAgICAgICAgICMgY29udGFpbmVkIGxpbmstYnJlYWtpbmcgY2hhcmFjdGVycyB0aGUgbGluayB3YXMgYWxyZWFkeVxuICAgICAgICAgICAgICAgICAgICAjIGJyb2tlbiwgYW5kIHJlcGxhY2luZyBpdCB3aXRoIGhlYWRpbmcgd291bGRuJ3QgbWFrZVxuICAgICAgICAgICAgICAgICAgICAjIHRoaW5ncyB3b3JzZTsgaWYgdGhlIGZyYWdtZW50IGRpZG4ndCBjb250YWluXG4gICAgICAgICAgICAgICAgICAgICMgbGluay1icmVha2luZyBjaGFyYWN0ZXJzLCB0aGUgaGVhZGluZyBkb2Vzbid0IGVpdGhlcixcbiAgICAgICAgICAgICAgICAgICAgIyBzaW5jZSBoZWFkaW5nIGFuZCBmcmFnbWVudCBhdCBtb3N0IGRpZmZlciBieVxuICAgICAgICAgICAgICAgICAgICAjIGNhcGl0YWxpemF0aW9uLCBzbyBpdCdzIHNhZmUgdG8gcmVwbGFjZSBpdFxuICAgICAgICAgICAgICAgICAgICAjIElmIHRoZSBmcmFnbWVudCB3YXMgKnBhcnRpYWxseSogZW5jb2RlZCBpbnN0ZWFkLCBhXG4gICAgICAgICAgICAgICAgICAgICMgbGluay1icmVha2luZyBjaGFyYWN0ZXIgbWF5IGhhdmUgYmVlbiBlbmNvZGVkLCBzbyBhbGxcbiAgICAgICAgICAgICAgICAgICAgIyBsaW5rLWJyZWFraW5nIGNoYXJhY3RlcnMgbXVzdCBiZSByZS1lbmNvZGVkIGhlcmUhXG4gICAgICAgICAgICAgICAgICAgIGVzY0hlYWRpbmcgPSBAV00uUGFyc2VyLmRvdEVuY29kZUxpbmtCcmVha2luZ0ZyYWdtZW50Q2hhcmFjdGVycyhoZWFkaW5nKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJbWyNcIiArIGVzY0hlYWRpbmcgKyAoaWYgbGFsdCB0aGVuIFwifFwiICsgbGFsdCBlbHNlIFwiXCIpICsgXCJdXVwiXG5cbiAgICAgICAgIyBJdCdzIG5vdCBlYXN5IHRvIHVzZSBBcHAubG9nLmxpbmtUb1dpa2lQYWdlIGJlY2F1c2UgcHVyZSBmcmFnbWVudHNcbiAgICAgICAgIyAgIGFyZSBub3Qgc3VwcG9ydGVkIHlldFxuICAgICAgICBBcHAubG9nLmxvZ1dhcm5pbmcoXCJDYW5ub3QgZml4IGJyb2tlbiBzZWN0aW9uIGxpbms6IFwiICsgcmF3bGluaylcbiAgICAgICAgcmV0dXJuIHJhd2xpbmtcblxuICAgIG1haW5fZWRpdG9yOiAoY2FsbE5leHQpIC0+XG4gICAgICAgIHNvdXJjZSA9IEBXTS5FZGl0b3IucmVhZFNvdXJjZSgpXG4gICAgICAgIG5ld3RleHQgPSBAZml4TGlua3Moc291cmNlKVxuXG4gICAgICAgIGlmIG5ld3RleHQgIT0gc291cmNlXG4gICAgICAgICAgICBAV00uRWRpdG9yLndyaXRlU291cmNlKG5ld3RleHQpXG4gICAgICAgICAgICBBcHAubG9nLmxvZ0luZm8oXCJGaXhlZCBzZWN0aW9uIGxpbmtzXCIpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIEFwcC5sb2cubG9nSW5mbyhcIk5vIGZpeGFibGUgc2VjdGlvbiBsaW5rcyBmb3VuZFwiKVxuXG4gICAgICAgIGlmIGNhbGxOZXh0XG4gICAgICAgICAgICBjYWxsTmV4dCgpXG4iLCIjIFdpa2kgTW9ua2V5IC0gTWVkaWFXaWtpIGJvdCBhbmQgZWRpdG9yLWFzc2lzdGFudCB1c2VyIHNjcmlwdFxuIyBDb3B5cmlnaHQgKEMpIDIwMTEgRGFyaW8gR2lvdmFubmV0dGkgPGRldkBkYXJpb2dpb3Zhbm5ldHRpLm5ldD5cbiNcbiMgVGhpcyBmaWxlIGlzIHBhcnQgb2YgV2lraSBNb25rZXkuXG4jXG4jIFdpa2kgTW9ua2V5IGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiMgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiMgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiMgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbiNcbiMgV2lraSBNb25rZXkgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiMgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiMgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuIyBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuI1xuIyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuIyBhbG9uZyB3aXRoIFdpa2kgTW9ua2V5LiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuXG5BcHAgPSByZXF1aXJlKCcuLi9hcHAnKVxue1BsdWdpbn0gPSByZXF1aXJlKCcuL19QbHVnaW4nKVxuXG5cbmNsYXNzIG1vZHVsZS5leHBvcnRzLkZpeExpbmtGcmFnbWVudHMgZXh0ZW5kcyBQbHVnaW5cbiAgICBAY29uZl9kZWZhdWx0OlxuICAgICAgICBlbmFibGVkOiB0cnVlXG4gICAgICAgIGVkaXRvcl9tZW51OiBbXCJRdWVyeSBwbHVnaW5zXCIsIFwiRml4IGV4dGVybmFsIHNlY3Rpb24gbGlua3NcIl1cblxuICAgIHByb2Nlc3NMaW5rOiAodGl0bGUsIGl3cHJlZml4ZXMsIGxpbmtzLCBpbmRleCwgc291cmNlLCBuZXdUZXh0LCBwcmV2SWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsLCBjYWxsQXJncykgPT5cbiAgICAgICAgaWYgbGlua3NbaW5kZXhdXG4gICAgICAgICAgICBsaW5rID0gbGlua3NbaW5kZXhdXG4gICAgICAgICAgICByYXdmcmFnbWVudCA9IGxpbmsuZnJhZ21lbnRcblxuICAgICAgICAgICAgaWYgbm90IChsaW5rLm5hbWVzcGFjZT8gYW5kIGxpbmsubmFtZXNwYWNlLnRvTG93ZXJDYXNlKCkgaW4gaXdwcmVmaXhlcykgYW5kIHJhd2ZyYWdtZW50XG4gICAgICAgICAgICAgICAgQXBwLmxvZy5sb2dJbmZvKFwiUHJvY2Vzc2luZyBcIiArXG4gICAgICAgICAgICAgICAgICAgIEFwcC5sb2cubGlua1RvV2lraVBhZ2UobGluay5saW5rLCBsaW5rLnJhd0xpbmspICsgXCIgLi4uXCIpXG5cbiAgICAgICAgICAgICAgICB0YXJnZXQgPSAoaWYgbGluay5uYW1lc3BhY2UgdGhlbiBsaW5rLm5hbWVzcGFjZSArIFwiOlwiIGVsc2UgXCJcIikgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rLnRpdGxlXG5cbiAgICAgICAgICAgICAgICAjIE5vdGUgdGhhdCBpdCdzIGltcG9zc2libGUgdG8gcmVjb2duaXplIGFueSBuYW1lc3BhY2VzIGluIHRoZVxuICAgICAgICAgICAgICAgICMgICB0aXRsZSB3aXRob3V0IHF1ZXJ5aW5nIHRoZSBzZXJ2ZXJcbiAgICAgICAgICAgICAgICAjIEFsdGVybmF0aXZlbHksIGEgbGlzdCBvZiB0aGUga25vd24gbmFtZXNwYWNlcyBjb3VsZCBiZVxuICAgICAgICAgICAgICAgICMgICBtYWludGFpbmVkIGZvciBlYWNoIHdpa2lcbiAgICAgICAgICAgICAgICAjIFJlY29nbml6aW5nIG5hbWVzcGFjZXMgd291bGQgbGV0IHJlY29nbml6ZSBtb3JlIGxpYmVyYWwgbGlua1xuICAgICAgICAgICAgICAgICMgICBzeW50YXhlcyAoZS5nLiBzcGFjZXMgYXJvdW5kIHRoZSBjb2xvbilcbiAgICAgICAgICAgICAgICBpZiBub3QgQFdNLlBhcnNlci5jb21wYXJlQXJ0aWNsZVRpdGxlcyh0YXJnZXQsIHRpdGxlKVxuICAgICAgICAgICAgICAgICAgICBwYXJhbXMgPVxuICAgICAgICAgICAgICAgICAgICAgICAgJ2FjdGlvbic6ICdwYXJzZSdcbiAgICAgICAgICAgICAgICAgICAgICAgICdwcm9wJzogJ3NlY3Rpb25zJ1xuICAgICAgICAgICAgICAgICAgICAgICAgJ3BhZ2UnOiB0YXJnZXRcbiAgICAgICAgICAgICAgICAgICAgICAgICdyZWRpcmVjdHMnOiAxXG5cbiAgICAgICAgICAgICAgICAgICAgQFdNLk1XLmNhbGxBUElHZXQocGFyYW1zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBAcHJvY2Vzc0xpbmtDb250aW51ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW2xpbmssIHRhcmdldCwgcmF3ZnJhZ21lbnQsIGl3cHJlZml4ZXMsIGxpbmtzLCBpbmRleCwgc291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3VGV4dCwgcHJldklkLCB0aXRsZSwgY2FsbCwgY2FsbEFyZ3NdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudWxsKVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgaW5kZXgrK1xuICAgICAgICAgICAgICAgICAgICBAcHJvY2Vzc0xpbmsodGl0bGUsIGl3cHJlZml4ZXMsIGxpbmtzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4LCBzb3VyY2UsIG5ld1RleHQsIHByZXZJZCwgY2FsbCwgY2FsbEFyZ3MpXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgaW5kZXgrK1xuICAgICAgICAgICAgICAgIEBwcm9jZXNzTGluayh0aXRsZSwgaXdwcmVmaXhlcywgbGlua3MsIGluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlLCBuZXdUZXh0LCBwcmV2SWQsIGNhbGwsIGNhbGxBcmdzKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICBuZXdUZXh0ICs9IHNvdXJjZS5zdWJzdHIocHJldklkKVxuICAgICAgICAgICAgY2FsbChuZXdUZXh0LCBpd3ByZWZpeGVzLCBjYWxsQXJncylcblxuICAgIHByb2Nlc3NMaW5rQ29udGludWU6IChyZXMsIGFyZ3MpID0+XG4gICAgICAgIGxpbmsgPSBhcmdzWzBdXG4gICAgICAgIHRhcmdldCA9IGFyZ3NbMV1cbiAgICAgICAgcmF3ZnJhZ21lbnQgPSBhcmdzWzJdXG4gICAgICAgIGl3cHJlZml4ZXMgPSBhcmdzWzNdXG4gICAgICAgIGxpbmtzID0gYXJnc1s0XVxuICAgICAgICBpbmRleCA9IGFyZ3NbNV1cbiAgICAgICAgc291cmNlID0gYXJnc1s2XVxuICAgICAgICBuZXdUZXh0ID0gYXJnc1s3XVxuICAgICAgICBwcmV2SWQgPSBhcmdzWzhdXG4gICAgICAgIHRpdGxlID0gYXJnc1s5XVxuICAgICAgICBjYWxsID0gYXJnc1sxMF1cbiAgICAgICAgY2FsbEFyZ3MgPSBhcmdzWzExXVxuXG4gICAgICAgICMgQ2hlY2sgdGhhdCB0aGUgcGFnZSBpcyBpbiB0aGUgd2lraSAoZS5nLiBpdCdzIG5vdCBhbiBpbnRlcndpa2kgbGluaylcbiAgICAgICAgaWYgcmVzLnBhcnNlXG4gICAgICAgICAgICBzZWN0aW9ucyA9IFtdXG5cbiAgICAgICAgICAgIGZvciBzZWN0aW9uIGluIHJlcy5wYXJzZS5zZWN0aW9uc1xuICAgICAgICAgICAgICAgIHNlY3Rpb25zLnB1c2goQFdNLlBhcnNlci5zcXVhc2hDb250aWd1b3VzV2hpdGVzcGFjZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWN0aW9uLmxpbmUpLnRyaW0oKSlcblxuICAgICAgICAgICAgZml4ZWRGcmFnbWVudCA9IEBmaXhGcmFnbWVudChyYXdmcmFnbWVudCwgc2VjdGlvbnMpXG5cbiAgICAgICAgICAgIG5ld1RleHQgKz0gc291cmNlLnN1YnN0cmluZyhwcmV2SWQsIGxpbmsuaW5kZXgpXG5cbiAgICAgICAgICAgIGlmIGZpeGVkRnJhZ21lbnQgaXMgdHJ1ZVxuICAgICAgICAgICAgICAgIG5ld1RleHQgKz0gbGluay5yYXdMaW5rXG4gICAgICAgICAgICBlbHNlIGlmIGZpeGVkRnJhZ21lbnRcbiAgICAgICAgICAgICAgICBuZXdUZXh0ICs9IFwiW1tcIiArIHRhcmdldCArIFwiI1wiICsgZml4ZWRGcmFnbWVudCAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChpZiBsaW5rLmFuY2hvciB0aGVuIFwifFwiICsgbGluay5hbmNob3IgZWxzZSBcIlwiKSArIFwiXV1cIlxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIEFwcC5sb2cubG9nV2FybmluZyhcIkNhbm5vdCBmaXggYnJva2VuIGxpbmsgZnJhZ21lbnQ6IFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBBcHAubG9nLmxpbmtUb1dpa2lQYWdlKGxpbmsubGluaywgbGluay5yYXdMaW5rKSlcbiAgICAgICAgICAgICAgICBuZXdUZXh0ICs9IGxpbmsucmF3TGlua1xuXG4gICAgICAgICAgICBwcmV2SWQgPSBsaW5rLmluZGV4ICsgbGluay5sZW5ndGhcblxuICAgICAgICBpbmRleCsrXG4gICAgICAgIEBwcm9jZXNzTGluayh0aXRsZSwgaXdwcmVmaXhlcywgbGlua3MsIGluZGV4LCBzb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1RleHQsIHByZXZJZCwgY2FsbCwgY2FsbEFyZ3MpXG5cbiAgICBmaXhGcmFnbWVudDogKHJhd2ZyYWdtZW50LCBzZWN0aW9ucykgPT5cbiAgICAgICAgZnJhZ21lbnQgPSBAV00uUGFyc2VyLnNxdWFzaENvbnRpZ3VvdXNXaGl0ZXNwYWNlKHJhd2ZyYWdtZW50KS50cmltKClcblxuICAgICAgICBpZiBzZWN0aW9ucy5pbmRleE9mKGZyYWdtZW50KSA8IDBcbiAgICAgICAgICAgIGZvciBzZWN0aW9uIGluIHNlY3Rpb25zXG4gICAgICAgICAgICAgICAgZG90U2VjdGlvbiA9IEBXTS5QYXJzZXIuZG90RW5jb2RlKHNlY3Rpb24pXG4gICAgICAgICAgICAgICAgZG90RnJhZ21lbnQgPSBAV00uUGFyc2VyLmRvdEVuY29kZShmcmFnbWVudClcblxuICAgICAgICAgICAgICAgIGlmIGRvdFNlY3Rpb24udG9Mb3dlckNhc2UoKSA9PSBkb3RGcmFnbWVudC50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgICAgICAgICAgIGlmIGZyYWdtZW50ID09IGRvdEZyYWdtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAjIElmIHRoZSBmcmFnbWVudCB3YXMgZW5jb2RlZCwgcmUtZW5jb2RlIGl0IGJlY2F1c2UgaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICMgY291bGQgY29udGFpbiBsaW5rLWJyZWFraW5nIGNoYXJhY3RlcnMgKGUuZy4gW118e30pXG4gICAgICAgICAgICAgICAgICAgICAgICAjIFRoZSBjb25kaXRpb24gd291bGQgYWxzbyBiZSB0cnVlIGlmIHRoZSBmcmFnbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgIyBkb2Vzbid0IGNvbnRhaW4gYW55IGVuY29kYWJsZSBjaGFyYWN0ZXJzLCBidXQgc2luY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICMgc2VjdGlvbiBhbmQgZnJhZ21lbnQgYXQgbW9zdCBkaWZmZXIgYnlcbiAgICAgICAgICAgICAgICAgICAgICAgICMgY2FwaXRhbGl6YXRpb24sIGVuY29kaW5nIHRoZSBzZWN0aW9uIHdvbid0IGhhdmUgYW55XG4gICAgICAgICAgICAgICAgICAgICAgICAjIGVmZmVjdFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRvdFNlY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgIyBJZiB0aGUgZnJhZ21lbnQgd2FzIG5vdCBlbmNvZGVkLCBpZiB0aGUgZnJhZ21lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICMgY29udGFpbmVkIGxpbmstYnJlYWtpbmcgY2hhcmFjdGVycyB0aGUgbGluayB3YXNcbiAgICAgICAgICAgICAgICAgICAgICAgICMgYWxyZWFkeSBicm9rZW4sIGFuZCByZXBsYWNpbmcgaXQgd2l0aCBzZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAjIHdvdWxkbid0IG1ha2UgdGhpbmdzIHdvcnNlOyBpZiB0aGUgZnJhZ21lbnQgZGlkbid0XG4gICAgICAgICAgICAgICAgICAgICAgICAjIGNvbnRhaW4gbGluay1icmVha2luZyBjaGFyYWN0ZXJzLCB0aGUgc2VjdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgIyBkb2Vzbid0IGVpdGhlciwgc2luY2Ugc2VjdGlvbiBhbmQgZnJhZ21lbnQgYXQgbW9zdFxuICAgICAgICAgICAgICAgICAgICAgICAgIyBkaWZmZXIgYnkgY2FwaXRhbGl6YXRpb24sIHNvIGl0J3Mgc2FmZSB0byByZXBsYWNlIGl0XG4gICAgICAgICAgICAgICAgICAgICAgICAjIElmIHRoZSBmcmFnbWVudCB3YXMgKnBhcnRpYWxseSogZW5jb2RlZCBpbnN0ZWFkLCBhXG4gICAgICAgICAgICAgICAgICAgICAgICAjIGxpbmstYnJlYWtpbmcgY2hhcmFjdGVyIG1heSBoYXZlIGJlZW4gZW5jb2RlZCwgc29cbiAgICAgICAgICAgICAgICAgICAgICAgICMgYWxsIGxpbmstYnJlYWtpbmcgY2hhcmFjdGVycyBtdXN0IGJlIHJlLWVuY29kZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICMgaGVyZSFcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBAV00uUGFyc2VyLmRvdEVuY29kZUxpbmtCcmVha2luZ0ZyYWdtZW50Q2hhcmFjdGVycyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VjdGlvbilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuXG4gICAgZmluZEFyY2hXaWtpTGlua3M6IChuZXdUZXh0LCBpd3ByZWZpeGVzLCBjYWxsQXJncykgPT5cbiAgICAgICAgdGVtcGxhdGVzID0gQFdNLlBhcnNlci5maW5kVGVtcGxhdGVzKG5ld1RleHQsICdSZWxhdGVkJylcbiAgICAgICAgdGl0bGUgPSBAV00uRWRpdG9yLmdldFRpdGxlKClcbiAgICAgICAgQHByb2Nlc3NBcmNoV2lraUxpbmsodGl0bGUsIGl3cHJlZml4ZXMsIHRlbXBsYXRlcywgMSwgMCxcbiAgICAgICAgICAgICAgICAgICAgbmV3VGV4dCwgXCJcIiwgMCxcbiAgICAgICAgICAgICAgICAgICAgQGZpbmRBcmNoV2lraUxpbmtzMiwgY2FsbEFyZ3MpXG5cbiAgICBmaW5kQXJjaFdpa2lMaW5rczI6IChuZXdUZXh0LCBpd3ByZWZpeGVzLCBjYWxsQXJncykgPT5cbiAgICAgICAgdGVtcGxhdGVzID0gQFdNLlBhcnNlci5maW5kVGVtcGxhdGVzKG5ld1RleHQsICdSZWxhdGVkMicpXG4gICAgICAgIHRpdGxlID0gQFdNLkVkaXRvci5nZXRUaXRsZSgpXG4gICAgICAgIEBwcm9jZXNzQXJjaFdpa2lMaW5rKHRpdGxlLCBpd3ByZWZpeGVzLCB0ZW1wbGF0ZXMsIDIsIDAsXG4gICAgICAgICAgICAgICAgbmV3VGV4dCwgXCJcIiwgMCwgQG1haW5FbmQsIGNhbGxBcmdzKVxuXG4gICAgcHJvY2Vzc0FyY2hXaWtpTGluazogKHRpdGxlLCBpd3ByZWZpeGVzLCB0ZW1wbGF0ZXMsIGV4cGVjdGVkQXJncywgaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2UsIG5ld1RleHQsIHByZXZJZCwgY2FsbCwgY2FsbEFyZ3MpID0+XG4gICAgICAgIGlmIHRlbXBsYXRlc1tpbmRleF1cbiAgICAgICAgICAgIHRlbXBsYXRlID0gdGVtcGxhdGVzW2luZGV4XVxuICAgICAgICAgICAgYXJncyA9IHRlbXBsYXRlLmFyZ3VtZW50c1xuXG4gICAgICAgICAgICAjIERvbid0IGNyYXNoIGluIGNhc2Ugb2YgbWFsZm9ybWVkIHRlbXBsYXRlc1xuICAgICAgICAgICAgaWYgYXJncy5sZW5ndGggPT0gZXhwZWN0ZWRBcmdzXG4gICAgICAgICAgICAgICAgbGluayA9IGFyZ3NbMF0udmFsdWVcbiAgICAgICAgICAgICAgICBmcmFnSWQgPSBsaW5rLmluZGV4T2YoJyMnKVxuXG4gICAgICAgICAgICAgICAgaWYgZnJhZ0lkID4gLTFcbiAgICAgICAgICAgICAgICAgICAgcmF3dGFyZ2V0ID0gbGluay5zdWJzdHJpbmcoMCwgZnJhZ0lkKVxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQgPSBAV00uUGFyc2VyLnNxdWFzaENvbnRpZ3VvdXNXaGl0ZXNwYWNlKHJhd3RhcmdldCkudHJpbSgpXG4gICAgICAgICAgICAgICAgICAgIHJhd2ZyYWdtZW50ID0gbGluay5zdWJzdHIoZnJhZ0lkICsgMSlcblxuICAgICAgICAgICAgICAgICAgICBpZiByYXdmcmFnbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgIyBOb3RlIHRoYXQgaXQncyBpbXBvc3NpYmxlIHRvIHJlY29nbml6ZSBhbnlcbiAgICAgICAgICAgICAgICAgICAgICAgICMgICBuYW1lc3BhY2VzIGluIHRoZSB0aXRsZSB3aXRob3V0IHF1ZXJ5aW5nIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgIyAgIHNlcnZlclxuICAgICAgICAgICAgICAgICAgICAgICAgIyBBbHRlcm5hdGl2ZWx5LCBhIGxpc3Qgb2YgdGhlIGtub3duIG5hbWVzcGFjZXMgY291bGRcbiAgICAgICAgICAgICAgICAgICAgICAgICMgICBiZSBtYWludGFpbmVkIGZvciBlYWNoIHdpa2lcbiAgICAgICAgICAgICAgICAgICAgICAgICMgUmVjb2duaXppbmcgbmFtZXNwYWNlcyB3b3VsZCBsZXQgcmVjb2duaXplIG1vcmVcbiAgICAgICAgICAgICAgICAgICAgICAgICMgICBsaWJlcmFsIGxpbmsgc3ludGF4ZXMgKGUuZy4gc3BhY2VzIGFyb3VuZCB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgICMgICBjb2xvbilcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIG5vdCBAV00uUGFyc2VyLmNvbXBhcmVBcnRpY2xlVGl0bGVzKHRhcmdldCwgdGl0bGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQXBwLmxvZy5sb2dJbmZvKFwiUHJvY2Vzc2luZyBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQXBwLmxvZy5saW5rVG9XaWtpUGFnZShsaW5rLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlLnJhd1RyYW5zY2x1c2lvbikgKyBcIiAuLi5cIilcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcyA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdhY3Rpb24nOiAncGFyc2UnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdwcm9wJzogJ3NlY3Rpb25zJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAncGFnZSc6IHRhcmdldFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAncmVkaXJlY3RzJzogMVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQFdNLk1XLmNhbGxBUElHZXQocGFyYW1zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQHByb2Nlc3NBcmNoV2lraUxpbmtDb250aW51ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFt0ZW1wbGF0ZSwgdGFyZ2V0LCByYXdmcmFnbWVudCwgaXdwcmVmaXhlcywgdGVtcGxhdGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWRBcmdzLCBpbmRleCwgc291cmNlLCBuZXdUZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldklkLCB0aXRsZSwgY2FsbCwgY2FsbEFyZ3NdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCsrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQHByb2Nlc3NBcmNoV2lraUxpbmsoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZSwgaXdwcmVmaXhlcywgdGVtcGxhdGVzLCBleHBlY3RlZEFyZ3MsIGluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlLCBuZXdUZXh0LCBwcmV2SWQsIGNhbGwsIGNhbGxBcmdzKVxuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleCsrXG4gICAgICAgICAgICAgICAgICAgICAgICBAcHJvY2Vzc0FyY2hXaWtpTGluayh0aXRsZSwgaXdwcmVmaXhlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZXMsIGV4cGVjdGVkQXJncywgaW5kZXgsIHNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdUZXh0LCBwcmV2SWQsIGNhbGwsIGNhbGxBcmdzKVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgaW5kZXgrK1xuICAgICAgICAgICAgICAgICAgICBAcHJvY2Vzc0FyY2hXaWtpTGluayh0aXRsZSwgaXdwcmVmaXhlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZXMsIGV4cGVjdGVkQXJncywgaW5kZXgsIHNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdUZXh0LCBwcmV2SWQsIGNhbGwsIGNhbGxBcmdzKVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIEFwcC5sb2cubG9nV2FybmluZyhcIlRlbXBsYXRlOlwiICsgdGVtcGxhdGUudGl0bGUgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCIgbXVzdCBoYXZlIFwiICsgZXhwZWN0ZWRBcmdzICsgXCIgYW5kIG9ubHkgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWRBcmdzICtcbiAgICAgICAgICAgICAgICAgICAgICAgIChpZiBleHBlY3RlZEFyZ3MgPiAxIHRoZW4gXCIgYXJndW1lbnRzOiBcIiBlbHNlIFwiIGFyZ3VtZW50OiBcIikgK1xuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGUucmF3VHJhbnNjbHVzaW9uKVxuICAgICAgICAgICAgICAgIGluZGV4KytcbiAgICAgICAgICAgICAgICBAcHJvY2Vzc0FyY2hXaWtpTGluayh0aXRsZSwgaXdwcmVmaXhlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZXMsIGV4cGVjdGVkQXJncywgaW5kZXgsIHNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdUZXh0LCBwcmV2SWQsIGNhbGwsIGNhbGxBcmdzKVxuXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIG5ld1RleHQgKz0gc291cmNlLnN1YnN0cihwcmV2SWQpXG4gICAgICAgICAgICBjYWxsKG5ld1RleHQsIGl3cHJlZml4ZXMsIGNhbGxBcmdzKVxuXG4gICAgcHJvY2Vzc0FyY2hXaWtpTGlua0NvbnRpbnVlOiAocmVzLCBhcmdzKSA9PlxuICAgICAgICB0ZW1wbGF0ZSA9IGFyZ3NbMF1cbiAgICAgICAgdGFyZ2V0ID0gYXJnc1sxXVxuICAgICAgICByYXdmcmFnbWVudCA9IGFyZ3NbMl1cbiAgICAgICAgaXdwcmVmaXhlcyA9IGFyZ3NbM11cbiAgICAgICAgdGVtcGxhdGVzID0gYXJnc1s0XVxuICAgICAgICBleHBlY3RlZEFyZ3MgPSBhcmdzWzVdXG4gICAgICAgIGluZGV4ID0gYXJnc1s2XVxuICAgICAgICBzb3VyY2UgPSBhcmdzWzddXG4gICAgICAgIG5ld1RleHQgPSBhcmdzWzhdXG4gICAgICAgIHByZXZJZCA9IGFyZ3NbOV1cbiAgICAgICAgdGl0bGUgPSBhcmdzWzEwXVxuICAgICAgICBjYWxsID0gYXJnc1sxMV1cbiAgICAgICAgY2FsbEFyZ3MgPSBhcmdzWzEyXVxuXG4gICAgICAgICMgQ2hlY2sgdGhhdCB0aGUgcGFnZSBpcyBpbiB0aGUgd2lraSAoZS5nLiBpdCdzIG5vdCBhbiBpbnRlcndpa2kgbGluaylcbiAgICAgICAgaWYgcmVzLnBhcnNlXG4gICAgICAgICAgICBzZWN0aW9ucyA9IFtdXG5cbiAgICAgICAgICAgIGZvciBzZWN0aW9uIGluIHJlcy5wYXJzZS5zZWN0aW9uc1xuICAgICAgICAgICAgICAgIHNlY3Rpb25zLnB1c2goQFdNLlBhcnNlci5zcXVhc2hDb250aWd1b3VzV2hpdGVzcGFjZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWN0aW9uLmxpbmUpLnRyaW0oKSlcblxuICAgICAgICAgICAgZml4ZWRGcmFnbWVudCA9IEBmaXhGcmFnbWVudChyYXdmcmFnbWVudCwgc2VjdGlvbnMpXG5cbiAgICAgICAgICAgIG5ld1RleHQgKz0gc291cmNlLnN1YnN0cmluZyhwcmV2SWQsIHRlbXBsYXRlLmluZGV4KVxuXG4gICAgICAgICAgICBpZiBmaXhlZEZyYWdtZW50IGlzIHRydWVcbiAgICAgICAgICAgICAgICBuZXdUZXh0ICs9IHRlbXBsYXRlLnJhd1RyYW5zY2x1c2lvblxuICAgICAgICAgICAgZWxzZSBpZiBmaXhlZEZyYWdtZW50XG4gICAgICAgICAgICAgICAgYW5jaG9yID0gaWYgdGVtcGxhdGUuYXJndW1lbnRzWzFdIHRoZW4gKFwifFwiICsgdGVtcGxhdGUuYXJndW1lbnRzWzFdLnZhbHVlKSBlbHNlIFwiXCJcbiAgICAgICAgICAgICAgICBuZXdUZXh0ICs9IFwie3tcIiArIHRlbXBsYXRlLnRpdGxlICsgXCJ8XCIgKyB0YXJnZXQgKyBcIiNcIiArIGZpeGVkRnJhZ21lbnQgICsgYW5jaG9yICsgXCJ9fVwiXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgQXBwLmxvZy5sb2dXYXJuaW5nKFwiQ2Fubm90IGZpeCBicm9rZW4gbGluayBmcmFnbWVudDogXCIgK1xuICAgICAgICAgICAgICAgICAgICBBcHAubG9nLmxpbmtUb1dpa2lQYWdlKHRhcmdldCwgdGVtcGxhdGUucmF3VHJhbnNjbHVzaW9uKSlcbiAgICAgICAgICAgICAgICBuZXdUZXh0ICs9IHRlbXBsYXRlLnJhd1RyYW5zY2x1c2lvblxuXG4gICAgICAgICAgICBwcmV2SWQgPSB0ZW1wbGF0ZS5pbmRleCArIHRlbXBsYXRlLmxlbmd0aFxuXG4gICAgICAgIGluZGV4KytcbiAgICAgICAgQHByb2Nlc3NBcmNoV2lraUxpbmsodGl0bGUsIGl3cHJlZml4ZXMsIHRlbXBsYXRlcyxcbiAgICAgICAgICAgICAgICBleHBlY3RlZEFyZ3MsIGluZGV4LCBzb3VyY2UsIG5ld1RleHQsIHByZXZJZCwgY2FsbCwgY2FsbEFyZ3MpXG5cbiAgICBtYWluX2VkaXRvcjogKGNhbGxOZXh0KSAtPlxuICAgICAgICBzb3VyY2UgPSBAV00uRWRpdG9yLnJlYWRTb3VyY2UoKVxuICAgICAgICBBcHAubG9nLmxvZ0luZm8oXCJGaXhpbmcgbGlua3MgdG8gc2VjdGlvbnMgb2Ygb3RoZXIgYXJ0aWNsZXMgLi4uXCIpXG4gICAgICAgIHRpdGxlID0gQFdNLkVkaXRvci5nZXRUaXRsZSgpXG4gICAgICAgIHJlcyA9IGF3YWl0IEBXTS5NVy5nZXRJbnRlcndpa2lNYXAodGl0bGUpXG4gICAgICAgIGl3cHJlZml4ZXMgPSAoaXcucHJlZml4IGZvciBpdyBpbiByZXMucXVlcnkuaW50ZXJ3aWtpbWFwKVxuICAgICAgICBsaW5rcyA9IEBXTS5QYXJzZXIuZmluZEludGVybmFsTGlua3Moc291cmNlLCBudWxsLCBudWxsKVxuICAgICAgICBAcHJvY2Vzc0xpbmsodGl0bGUsIGl3cHJlZml4ZXMsIGxpbmtzLCAwLCBzb3VyY2UsIFwiXCIsIDAsXG4gICAgICAgICAgICAgICAgICAgICBAbWFpbkNvbnRpbnVlLCBjYWxsTmV4dClcblxuICAgIG1haW5Db250aW51ZTogKG5ld1RleHQsIGl3cHJlZml4ZXMsIGNhbGxOZXh0KSA9PlxuICAgICAgICAjIFdpdGhvdXQgdGhpcyBjaGVjayB0aGlzIHBsdWdpbiB3b3VsZCBiZSBzcGVjaWZpYyB0byBBcmNoV2lraVxuICAgICAgICBpZiBsb2NhdGlvbi5ob3N0bmFtZSA9PSAnd2lraS5hcmNobGludXgub3JnJ1xuICAgICAgICAgICAgdGVtcGxhdGVzID0gQGZpbmRBcmNoV2lraUxpbmtzKG5ld1RleHQsIGl3cHJlZml4ZXMsIGNhbGxOZXh0KVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICBAbWFpbkVuZChuZXdUZXh0LCBpd3ByZWZpeGVzLCBjYWxsTmV4dClcblxuICAgIG1haW5FbmQ6IChuZXdUZXh0LCBpd3ByZWZpeGVzLCBjYWxsTmV4dCkgPT5cbiAgICAgICAgc291cmNlID0gQFdNLkVkaXRvci5yZWFkU291cmNlKClcblxuICAgICAgICBpZiBuZXdUZXh0ICE9IHNvdXJjZVxuICAgICAgICAgICAgQFdNLkVkaXRvci53cml0ZVNvdXJjZShuZXdUZXh0KVxuICAgICAgICAgICAgQXBwLmxvZy5sb2dJbmZvKFwiUmVwbGFjZWQgbGlua3MgdG8gc2VjdGlvbnMgb2Ygb3RoZXIgYXJ0aWNsZXNcIilcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgQXBwLmxvZy5sb2dJbmZvKFwiTm8gZml4YWJsZSBsaW5rcyB0byBzZWN0aW9ucyBvZiBvdGhlciBhcnRpY2xlcyBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZm91bmRcIilcblxuICAgICAgICBpZiBjYWxsTmV4dFxuICAgICAgICAgICAgY2FsbE5leHQoKVxuIiwiIyBXaWtpIE1vbmtleSAtIE1lZGlhV2lraSBib3QgYW5kIGVkaXRvci1hc3Npc3RhbnQgdXNlciBzY3JpcHRcbiMgQ29weXJpZ2h0IChDKSAyMDExIERhcmlvIEdpb3Zhbm5ldHRpIDxkZXZAZGFyaW9naW92YW5uZXR0aS5uZXQ+XG4jXG4jIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFdpa2kgTW9ua2V5LlxuI1xuIyBXaWtpIE1vbmtleSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4jIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4jIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4jIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4jXG4jIFdpa2kgTW9ua2V5IGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4jIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4jIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiMgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbiNcbiMgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiMgYWxvbmcgd2l0aCBXaWtpIE1vbmtleS4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cblxuQXBwID0gcmVxdWlyZSgnLi4vYXBwJylcbntQbHVnaW59ID0gcmVxdWlyZSgnLi9fUGx1Z2luJylcblxuXG5jbGFzcyBtb2R1bGUuZXhwb3J0cy5NdWx0aXBsZUxpbmVCcmVha3MgZXh0ZW5kcyBQbHVnaW5cbiAgICBAY29uZl9kZWZhdWx0OlxuICAgICAgICBlbmFibGVkOiB0cnVlXG4gICAgICAgIGVkaXRvcl9tZW51OiBbXCJUZXh0IHBsdWdpbnNcIiwgXCJTcXVhc2ggbXVsdGlwbGUgbGluZSBicmVha3NcIl1cblxuICAgIG1haW5fZWRpdG9yOiAoY2FsbE5leHQpIC0+XG4gICAgICAgIHNvdXJjZSA9IEBXTS5FZGl0b3IucmVhZFNvdXJjZSgpXG4gICAgICAgIG5ld3RleHQgPSBzb3VyY2VcblxuICAgICAgICBuZXd0ZXh0ID0gbmV3dGV4dC5yZXBsYWNlKC9bXFxuXXszLH0vZywgJ1xcblxcbicpXG5cbiAgICAgICAgaWYgbmV3dGV4dCAhPSBzb3VyY2VcbiAgICAgICAgICAgIEBXTS5FZGl0b3Iud3JpdGVTb3VyY2UobmV3dGV4dClcbiAgICAgICAgICAgIEFwcC5sb2cubG9nSW5mbyhcIlJlbW92ZWQgbXVsdGlwbGUgbGluZSBicmVha3NcIilcblxuICAgICAgICBpZiBjYWxsTmV4dFxuICAgICAgICAgICAgY2FsbE5leHQoKVxuIiwiIyBXaWtpIE1vbmtleSAtIE1lZGlhV2lraSBib3QgYW5kIGVkaXRvci1hc3Npc3RhbnQgdXNlciBzY3JpcHRcbiMgQ29weXJpZ2h0IChDKSAyMDExIERhcmlvIEdpb3Zhbm5ldHRpIDxkZXZAZGFyaW9naW92YW5uZXR0aS5uZXQ+XG4jXG4jIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFdpa2kgTW9ua2V5LlxuI1xuIyBXaWtpIE1vbmtleSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4jIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4jIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4jIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4jXG4jIFdpa2kgTW9ua2V5IGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4jIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4jIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiMgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbiNcbiMgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiMgYWxvbmcgd2l0aCBXaWtpIE1vbmtleS4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cblxue2pzc2N9ID0gcmVxdWlyZSgnLi4vbW9kdWxlcy9saWJzJylcbkFwcCA9IHJlcXVpcmUoJy4uL2FwcCcpXG57UGx1Z2lufSA9IHJlcXVpcmUoJy4vX1BsdWdpbicpXG5cblxuY2xhc3MgbW9kdWxlLmV4cG9ydHMuU2ltcGxlUmVwbGFjZSBleHRlbmRzIFBsdWdpblxuICAgIEBjb25mX2RlZmF1bHQ6XG4gICAgICAgIGVuYWJsZWQ6IHRydWVcbiAgICAgICAgZWRpdG9yX21lbnU6IFtcIlJlZ0V4cCBzdWJzdGl0dXRpb25cIl1cbiAgICAgICAgYm90X2xhYmVsOiBcIlJlZ0V4cCBzdWJzdGl0dXRpb25cIlxuXG4gICAgbWFrZVVJID0gLT5cbiAgICAgICAge2NsYXNzZXN9ID0ganNzYyhcbiAgICAgICAgICAgIHNpbXBsZVJlcGxhY2U6XG4gICAgICAgICAgICAgICAgJyYgZGl2JzpcbiAgICAgICAgICAgICAgICAgICAgbWFyZ2luQm90dG9tOiAnMC4zM2VtJ1xuXG4gICAgICAgICAgICAgICAgXCImIGlucHV0W3R5cGU9J3RleHQnXVwiOlxuICAgICAgICAgICAgICAgICAgICBtYXJnaW5MZWZ0OiAnMC4zM2VtJ1xuICAgICAgICAgICAgICAgICAgICB3aWR0aDogJzYwJSdcbiAgICAgICAgKVxuXG4gICAgICAgIGRpdk1haW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgICAgICBkaXZNYWluLmlkID0gXCJXaWtpTW9ua2V5LVNpbXBsZVJlcGxhY2VcIlxuICAgICAgICBkaXZNYWluLmNsYXNzTmFtZSA9IGNsYXNzZXMuc2ltcGxlUmVwbGFjZVxuXG4gICAgICAgIHBhcjEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuXG4gICAgICAgIHJlZ2V4cExhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpXG4gICAgICAgIHJlZ2V4cExhYmVsLmlubmVySFRNTCA9ICdSZWdFeHAgcGF0dGVybjonXG5cbiAgICAgICAgcmVnZXhwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKVxuICAgICAgICByZWdleHAuc2V0QXR0cmlidXRlKCd0eXBlJywgJ3RleHQnKVxuICAgICAgICByZWdleHAuaWQgPSBcIldpa2lNb25rZXktU2ltcGxlUmVwbGFjZS1SZWdFeHBcIlxuXG4gICAgICAgIGlnbm9yZUNhc2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpXG4gICAgICAgIGlnbm9yZUNhc2Uuc2V0QXR0cmlidXRlKCd0eXBlJywgJ2NoZWNrYm94JylcbiAgICAgICAgaWdub3JlQ2FzZS5pZCA9IFwiV2lraU1vbmtleS1TaW1wbGVSZXBsYWNlLUlnbm9yZUNhc2VcIlxuXG4gICAgICAgIGlnbm9yZUNhc2VMYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKVxuICAgICAgICBpZ25vcmVDYXNlTGFiZWwuaW5uZXJIVE1MID0gJ2knXG5cbiAgICAgICAgcGFyMS5hcHBlbmRDaGlsZChyZWdleHBMYWJlbClcbiAgICAgICAgcGFyMS5hcHBlbmRDaGlsZChyZWdleHApXG4gICAgICAgIHBhcjEuYXBwZW5kQ2hpbGQoaWdub3JlQ2FzZSlcbiAgICAgICAgcGFyMS5hcHBlbmRDaGlsZChpZ25vcmVDYXNlTGFiZWwpXG5cbiAgICAgICAgcGFyMiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG5cbiAgICAgICAgbmV3U3RyaW5nTGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJylcbiAgICAgICAgbmV3U3RyaW5nTGFiZWwuaW5uZXJIVE1MID0gJ05ldyBzdHJpbmc6J1xuXG4gICAgICAgIG5ld1N0cmluZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0JylcbiAgICAgICAgbmV3U3RyaW5nLnNldEF0dHJpYnV0ZSgndHlwZScsICd0ZXh0JylcbiAgICAgICAgbmV3U3RyaW5nLmlkID0gXCJXaWtpTW9ua2V5LVNpbXBsZVJlcGxhY2UtTmV3U3RyaW5nXCJcblxuICAgICAgICBwYXIyLmFwcGVuZENoaWxkKG5ld1N0cmluZ0xhYmVsKVxuICAgICAgICBwYXIyLmFwcGVuZENoaWxkKG5ld1N0cmluZylcblxuICAgICAgICBkaXZNYWluLmFwcGVuZENoaWxkKHBhcjEpXG4gICAgICAgIGRpdk1haW4uYXBwZW5kQ2hpbGQocGFyMilcblxuICAgICAgICByZXR1cm4gZGl2TWFpblxuXG4gICAgbWFrZVVJOiAtPlxuICAgICAgICByZXR1cm4gbWFrZVVJKClcblxuICAgIG1ha2VCb3RVSTogLT5cbiAgICAgICAgZGl2TWFpbiA9IG1ha2VVSSgpXG4gICAgICAgIHBhcjMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuXG4gICAgICAgIHN1bW1hcnlMYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKVxuICAgICAgICBzdW1tYXJ5TGFiZWwuaW5uZXJIVE1MID0gJ0VkaXQgc3VtbWFyeTonXG5cbiAgICAgICAgc3VtbWFyeSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0JylcbiAgICAgICAgc3VtbWFyeS5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAndGV4dCcpXG4gICAgICAgIHN1bW1hcnkuaWQgPSBcIldpa2lNb25rZXktU2ltcGxlUmVwbGFjZS1TdW1tYXJ5XCJcblxuICAgICAgICBwYXIzLmFwcGVuZENoaWxkKHN1bW1hcnlMYWJlbClcbiAgICAgICAgcGFyMy5hcHBlbmRDaGlsZChzdW1tYXJ5KVxuXG4gICAgICAgIGRpdk1haW4uYXBwZW5kQ2hpbGQocGFyMylcblxuICAgICAgICByZXR1cm4gZGl2TWFpblxuXG4gICAgY29uZmlndXJhdGlvbiA9IG51bGxcblxuICAgIHN0b3JlQ29uZmlndXJhdGlvbjogPT5cbiAgICAgICAgY29uZmlndXJhdGlvbiA9XG4gICAgICAgICAgICBwYXR0ZXJuOiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJXaWtpTW9ua2V5LVNpbXBsZVJlcGxhY2UtUmVnRXhwXCIpLnZhbHVlXG4gICAgICAgICAgICBpZ25vcmVDYXNlOiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJXaWtpTW9ua2V5LVNpbXBsZVJlcGxhY2UtSWdub3JlQ2FzZVwiKS5jaGVja2VkXG4gICAgICAgICAgICBuZXdTdHJpbmc6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIldpa2lNb25rZXktU2ltcGxlUmVwbGFjZS1OZXdTdHJpbmdcIikudmFsdWVcblxuICAgICAgICBBcHAubG9nLmxvZ0hpZGRlbihcIlBhdHRlcm46IFwiICsgY29uZmlndXJhdGlvbi5wYXR0ZXJuKVxuICAgICAgICBBcHAubG9nLmxvZ0hpZGRlbihcIklnbm9yZSBjYXNlOiBcIiArIGNvbmZpZ3VyYXRpb24uaWdub3JlQ2FzZSlcbiAgICAgICAgQXBwLmxvZy5sb2dIaWRkZW4oXCJOZXcgc3RyaW5nOiBcIiArIGNvbmZpZ3VyYXRpb24ubmV3U3RyaW5nKVxuXG4gICAgc3RvcmVSZWdFeHAgPSAtPlxuICAgICAgICBjb25maWd1cmF0aW9uLnJlZ0V4cCA9IG5ldyBSZWdFeHAoY29uZmlndXJhdGlvbi5wYXR0ZXJuLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJnXCIgKyAoaWYgY29uZmlndXJhdGlvbi5pZ25vcmVDYXNlIHRoZW4gXCJpXCIgZWxzZSBcIlwiKSlcblxuICAgIG1haW5fZWRpdG9yOiAoY2FsbE5leHQpIC0+XG4gICAgICAgIEBzdG9yZUNvbmZpZ3VyYXRpb24oKVxuXG4gICAgICAgIHRyeVxuICAgICAgICAgICAgc3RvcmVSZWdFeHAoKVxuICAgICAgICBjYXRjaCBleGNcbiAgICAgICAgICAgIEFwcC5sb2cubG9nRXJyb3IoXCJJbnZhbGlkIHBhdHRlcm46IFwiICsgZXhjKVxuICAgICAgICAgICAgIyBCbG9jayB0aGUgZXhlY3V0aW9uIG9mIHRoaXMgZnVuY3Rpb25cbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuXG4gICAgICAgIHNvdXJjZSA9IEBXTS5FZGl0b3IucmVhZFNvdXJjZSgpXG4gICAgICAgIG5ld3RleHQgPSBzb3VyY2UucmVwbGFjZShjb25maWd1cmF0aW9uLnJlZ0V4cCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWd1cmF0aW9uLm5ld1N0cmluZylcblxuICAgICAgICBpZiBuZXd0ZXh0ICE9IHNvdXJjZVxuICAgICAgICAgICAgQFdNLkVkaXRvci53cml0ZVNvdXJjZShuZXd0ZXh0KVxuICAgICAgICAgICAgQXBwLmxvZy5sb2dJbmZvKFwiVGV4dCBzdWJzdGl0dXRlZFwiKVxuXG4gICAgICAgIGlmIGNhbGxOZXh0XG4gICAgICAgICAgICBjYWxsTmV4dCgpXG5cbiAgICBtYWluX2JvdDogKHRpdGxlLCBjYWxsQm90LCBjaGFpbkFyZ3MpIC0+XG4gICAgICAgIEBzdG9yZUNvbmZpZ3VyYXRpb24oKVxuXG4gICAgICAgIHRyeVxuICAgICAgICAgICAgc3RvcmVSZWdFeHAoKVxuICAgICAgICBjYXRjaCBleGNcbiAgICAgICAgICAgIEFwcC5sb2cubG9nRXJyb3IoXCJJbnZhbGlkIHBhdHRlcm46IFwiICsgZXhjKVxuICAgICAgICAgICAgY2FsbEJvdChmYWxzZSwgbnVsbClcbiAgICAgICAgICAgICMgQmxvY2sgdGhlIGV4ZWN1dGlvbiBvZiB0aGlzIGZ1bmN0aW9uXG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcblxuICAgICAgICBzdW1tYXJ5ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIldpa2lNb25rZXktU2ltcGxlUmVwbGFjZS1TdW1tYXJ5XCIpLnZhbHVlXG5cbiAgICAgICAgaWYgc3VtbWFyeSAhPSBcIlwiXG4gICAgICAgICAgICBAV00uTVcuY2FsbFF1ZXJ5RWRpdCh0aXRsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQG1haW5BdXRvV3JpdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtzdW1tYXJ5LCBjYWxsQm90XSlcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgQXBwLmxvZy5sb2dFcnJvcihcIlRoZSBlZGl0IHN1bW1hcnkgY2Fubm90IGJlIGVtcHR5XCIpXG4gICAgICAgICAgICBjYWxsQm90KGZhbHNlLCBudWxsKVxuXG4gICAgbWFpbkF1dG9Xcml0ZTogKHRpdGxlLCBzb3VyY2UsIHRpbWVzdGFtcCwgZWRpdHRva2VuLCBhcmdzKSA9PlxuICAgICAgICBzdW1tYXJ5ID0gYXJnc1swXVxuICAgICAgICBjYWxsQm90ID0gYXJnc1sxXVxuXG4gICAgICAgIG5ld3RleHQgPSBzb3VyY2UucmVwbGFjZShjb25maWd1cmF0aW9uLnJlZ0V4cCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWd1cmF0aW9uLm5ld1N0cmluZylcblxuICAgICAgICBpZiBuZXd0ZXh0ICE9IHNvdXJjZVxuICAgICAgICAgICAgQFdNLk1XLmNhbGxBUElQb3N0KHthY3Rpb246IFwiZWRpdFwiLCBib3Q6IFwiMVwiLCB0aXRsZTogdGl0bGUsIHN1bW1hcnk6IHN1bW1hcnksIHRleHQ6IG5ld3RleHQsIGJhc2V0aW1lc3RhbXA6IHRpbWVzdGFtcCwgdG9rZW46IGVkaXR0b2tlbn0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQG1haW5BdXRvRW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxCb3QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVsbClcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgY2FsbEJvdCgwLCBudWxsKVxuXG4gICAgbWFpbkF1dG9FbmQ6IChyZXMsIGNhbGxCb3QpID0+XG4gICAgICAgIGlmIHJlcy5lZGl0IGFuZCByZXMuZWRpdC5yZXN1bHQgPT0gJ1N1Y2Nlc3MnXG4gICAgICAgICAgICBjYWxsQm90KDEsIG51bGwpXG4gICAgICAgIGVsc2UgaWYgcmVzLmVycm9yXG4gICAgICAgICAgICBBcHAubG9nLmxvZ0Vycm9yKHJlcy5lcnJvci5pbmZvICsgXCIgKFwiICsgcmVzLmVycm9yLmNvZGUgKyBcIilcIilcbiAgICAgICAgICAgIGNhbGxCb3QocmVzLmVycm9yLmNvZGUsIG51bGwpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGNhbGxCb3QoZmFsc2UsIG51bGwpXG4iLCIjIFdpa2kgTW9ua2V5IC0gTWVkaWFXaWtpIGJvdCBhbmQgZWRpdG9yLWFzc2lzdGFudCB1c2VyIHNjcmlwdFxuIyBDb3B5cmlnaHQgKEMpIDIwMTEgRGFyaW8gR2lvdmFubmV0dGkgPGRldkBkYXJpb2dpb3Zhbm5ldHRpLm5ldD5cbiNcbiMgVGhpcyBmaWxlIGlzIHBhcnQgb2YgV2lraSBNb25rZXkuXG4jXG4jIFdpa2kgTW9ua2V5IGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiMgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiMgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiMgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbiNcbiMgV2lraSBNb25rZXkgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiMgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiMgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuIyBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuI1xuIyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuIyBhbG9uZyB3aXRoIFdpa2kgTW9ua2V5LiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuXG5XTSA9IHJlcXVpcmUoJy4uL21vZHVsZXMnKVxuQXBwID0gcmVxdWlyZSgnLi4vYXBwJylcbntQbHVnaW59ID0gcmVxdWlyZSgnLi9fUGx1Z2luJylcblxuXG5jbGFzcyBtb2R1bGUuZXhwb3J0cy5TeW5jaHJvbml6ZUludGVybGFuZ3VhZ2VMaW5rcyBleHRlbmRzIFBsdWdpblxuICAgIEBjb25mX2RlZmF1bHQ6XG4gICAgICAgIGVuYWJsZWQ6IHRydWVcbiAgICAgICAgZWRpdG9yX21lbnU6IFtcIlF1ZXJ5IHBsdWdpbnNcIiwgXCJTeW5jIGludGVybGFuZ3VhZ2UgbGlua3NcIl1cbiAgICAgICAgYm90X2xhYmVsOiBcIlN5bmNocm9uaXplIGludGVybGFuZ3VhZ2UgbGlua3NcIlxuICAgICAgICBsYW5ndWFnZV90YWc6IFwiZW5cIlxuICAgICAgICB0YWdfd2hpdGVsaXN0OiBbXCJlblwiXVxuICAgICAgICBzdXBwb3J0ZWRfdGFnczogW1wiZW5cIl1cbiAgICAgICAgZWRpdF9zdW1tYXJ5OiBcInN5bmNocm9uaXplZCBpbnRlcmxhbmd1YWdlIGxpbmtzIHdpdGggdGhlIG90aGVyIHdpa2lzXCJcbiAgICBAd2lraV90b19jb25mX2RlZmF1bHQ6XG4gICAgICAgIEFyY2hXaWtpOlxuICAgICAgICAgICAgbGFuZ3VhZ2VfdGFnOiBcIkFyY2hXaWtpXCJcbiAgICAgICAgICAgIHRhZ193aGl0ZWxpc3Q6IFwiQXJjaFdpa2lcIlxuICAgICAgICAgICAgc3VwcG9ydGVkX3RhZ3M6IFwiQXJjaFdpa2lcIlxuICAgICAgICBXaWtpcGVkaWE6XG4gICAgICAgICAgICBlbmFibGVkOiBmYWxzZVxuXG4gICAgZGV0ZWN0TGFuZzogKHRpdGxlLCB0YWcpID0+XG4gICAgICAgICMgV2l0aG91dCB0aGlzIGNoZWNrIHRoaXMgcGx1Z2luIHdvdWxkIGJlIHNwZWNpZmljIHRvIEFyY2hXaWtpXG4gICAgICAgIGlmIHRhZyA9PSBcIkFyY2hXaWtpXCJcbiAgICAgICAgICAgIGRldGVjdCA9IFdNLkFyY2hXaWtpLmRldGVjdExhbmd1YWdlKHRpdGxlKVxuICAgICAgICAgICAgcHVyZVRpdGxlID0gZGV0ZWN0WzBdXG4gICAgICAgICAgICB0YWcgPSBXTS5BcmNoV2lraS5nZXRJbnRlcmxhbmd1YWdlVGFnKGRldGVjdFsxXSlcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcHVyZVRpdGxlID0gdGl0bGVcblxuICAgICAgICByZXR1cm4gW3B1cmVUaXRsZSwgdGFnXVxuXG4gICAgY29tcHV0ZVdoaXRlTGlzdDogKHdoaXRlbGlzdCkgPT5cbiAgICAgICAgIyBXaXRob3V0IHRoaXMgY2hlY2sgdGhpcyBwbHVnaW4gd291bGQgYmUgc3BlY2lmaWMgdG8gQXJjaFdpa2lcbiAgICAgICAgaWYgd2hpdGVsaXN0ID09IFwiQXJjaFdpa2lcIlxuICAgICAgICAgICAgcmV0dXJuIFdNLkFyY2hXaWtpLmdldEludGVybmFsSW50ZXJ3aWtpTGFuZ3VhZ2VzKClcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIHdoaXRlbGlzdFxuXG4gICAgY29tcHV0ZVN1cHBvcnRlZExhbmdzOiAoc3VwcG9ydGVkTGFuZ3MpID0+XG4gICAgICAgICMgV2l0aG91dCB0aGlzIGNoZWNrIHRoaXMgcGx1Z2luIHdvdWxkIGJlIHNwZWNpZmljIHRvIEFyY2hXaWtpXG4gICAgICAgIGlmIHN1cHBvcnRlZExhbmdzID09IFwiQXJjaFdpa2lcIlxuICAgICAgICAgICAgcmV0dXJuIFdNLkFyY2hXaWtpLmdldEludGVyd2lraUxhbmd1YWdlcygpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBzdXBwb3J0ZWRMYW5nc1xuXG4gICAgbWFpbl9lZGl0b3I6IChjYWxsTmV4dCkgLT5cbiAgICAgICAgdGl0bGUgPSBAV00uRWRpdG9yLmdldFRpdGxlKClcblxuICAgICAgICBkZXRlY3QgPSBAZGV0ZWN0TGFuZyh0aXRsZSwgQGNvbmYubGFuZ3VhZ2VfdGFnKVxuICAgICAgICBwdXJlVGl0bGUgPSBkZXRlY3RbMF1cbiAgICAgICAgdGFnID0gZGV0ZWN0WzFdXG5cbiAgICAgICAgd2hpdGVsaXN0ID0gQGNvbXB1dGVXaGl0ZUxpc3QoQGNvbmYudGFnX3doaXRlbGlzdClcbiAgICAgICAgc3VwcG9ydGVkTGFuZ3MgPSBAY29tcHV0ZVN1cHBvcnRlZExhbmdzKEBjb25mLnN1cHBvcnRlZF90YWdzKVxuXG4gICAgICAgIEFwcC5sb2cubG9nSW5mbyhcIlN5bmNocm9uaXppbmcgaW50ZXJsYW5ndWFnZSBsaW5rcyAuLi5cIilcblxuICAgICAgICBAV00uTVcuZ2V0TG9jYWxJbnRlcndpa2lNYXAoXG4gICAgICAgICAgICB0aXRsZSxcbiAgICAgICAgICAgIEBtYWluQ29udGludWUsXG4gICAgICAgICAgICBbdGFnLCBwdXJlVGl0bGUsIHN1cHBvcnRlZExhbmdzLCB3aGl0ZWxpc3QsIHRpdGxlLCBjYWxsTmV4dF1cbiAgICAgICAgKVxuXG4gICAgbWFpbkNvbnRpbnVlOiAoaXdtYXAsIGFyZ3MpID0+XG4gICAgICAgIHRhZyA9IGFyZ3NbMF1cbiAgICAgICAgcHVyZVRpdGxlID0gYXJnc1sxXVxuICAgICAgICBzdXBwb3J0ZWRMYW5ncyA9IGFyZ3NbMl1cbiAgICAgICAgd2hpdGVsaXN0ID0gYXJnc1szXVxuICAgICAgICB0aXRsZSA9IGFyZ3NbNF1cbiAgICAgICAgY2FsbE5leHQgPSBhcmdzWzVdXG5cbiAgICAgICAgc291cmNlID0gQFdNLkVkaXRvci5yZWFkU291cmNlKClcblxuICAgICAgICBsYW5nbGlua3MgPSBAV00uSW50ZXJsYW5ndWFnZS5wYXJzZUxpbmtzKHN1cHBvcnRlZExhbmdzLCBzb3VyY2UsIGl3bWFwKVxuXG4gICAgICAgIHdpa2lVcmxzID0gQFdNLk1XLmdldFdpa2lVcmxzKClcbiAgICAgICAgdXJsID0gd2lraVVybHMuc2hvcnQgKyBlbmNvZGVVUklDb21wb25lbnQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEBXTS5QYXJzZXIuc3F1YXNoQ29udGlndW91c1doaXRlc3BhY2UodGl0bGUpKVxuXG4gICAgICAgIHZpc2l0ZWRsaW5rcyA9IHt9XG4gICAgICAgIHZpc2l0ZWRsaW5rc1t0YWcudG9Mb3dlckNhc2UoKV0gPSBAV00uSW50ZXJsYW5ndWFnZS5jcmVhdGVWaXNpdGVkTGluayhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFnLCBwdXJlVGl0bGUsIHVybCwgaXdtYXAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZSwgbnVsbCwgbnVsbCwgbGFuZ2xpbmtzKVxuXG4gICAgICAgIG5ld2xpbmtzID0ge31cblxuICAgICAgICBBcHAubG9nLmxvZ0luZm8oXCJSZWFkaW5nIFwiICsgQXBwLmxvZy5saW5rVG9QYWdlKHVybCwgXCJlZGl0ZWQgYXJ0aWNsZVwiKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiIC4uLlwiKVxuXG4gICAgICAgIGlmIGxhbmdsaW5rc1xuICAgICAgICAgICAgZm9yIGxpbmsgaW4gbGFuZ2xpbmtzXG4gICAgICAgICAgICAgICAgbmxpbmsgPSBuZXdsaW5rc1tsaW5rLmxhbmcudG9Mb3dlckNhc2UoKV1cbiAgICAgICAgICAgICAgICB2bGluayA9IHZpc2l0ZWRsaW5rc1tsaW5rLmxhbmcudG9Mb3dlckNhc2UoKV1cblxuICAgICAgICAgICAgICAgIGlmIG5vdCB2bGluayBhbmQgbm90IG5saW5rXG4gICAgICAgICAgICAgICAgICAgIG5ld2xpbmtzW2xpbmsubGFuZy50b0xvd2VyQ2FzZSgpXSA9IEBXTS5JbnRlcmxhbmd1YWdlLmNyZWF0ZU5ld0xpbmsoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmsubGFuZywgbGluay50aXRsZSwgbGluay51cmwpXG4gICAgICAgICAgICAgICAgZWxzZSBpZiB2bGluayBhbmQgdmxpbmsudXJsICE9IGxpbmsudXJsXG4gICAgICAgICAgICAgICAgICAgICMgSnVzdCBpZ25vcmUgYW55IGNvbmZsaWN0aW5nIGxpbmtzIGFuZCB3YXJuIHRoZSB1c2VyOlxuICAgICAgICAgICAgICAgICAgICAjIGlmIGl0J3MgYSByZWFsIGNvbmZsaWN0LCB0aGUgdXNlciB3aWxsIGludmVzdGlnYXRlIGl0LFxuICAgICAgICAgICAgICAgICAgICAjIG90aGVyd2lzZSB0aGUgdXNlciB3aWxsIGlnbm9yZSBpdFxuICAgICAgICAgICAgICAgICAgICBBcHAubG9nLmxvZ1dhcm5pbmcoXCJQb3NzaWJseSBjb25mbGljdGluZyBpbnRlcmxhbmd1YWdlIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwibGlua3M6IFwiICsgQXBwLmxvZy5saW5rVG9QYWdlKGxpbmsudXJsLCBcIltbXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgbGluay5sYW5nICsgXCI6XCIgKyBsaW5rLnRpdGxlICsgXCJdXVwiKSArIFwiIGFuZCBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICBBcHAubG9nLmxpbmtUb1BhZ2UodmxpbmsudXJsLCBcIltbXCIgKyBsaW5rLmxhbmcgKyBcIjpcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICB2aXNpdGVkbGlua3NbbGluay5sYW5nLnRvTG93ZXJDYXNlKCldLnRpdGxlICsgXCJdXVwiKSlcbiAgICAgICAgICAgICAgICBlbHNlIGlmIG5saW5rIGFuZCBubGluay51cmwgIT0gbGluay51cmxcbiAgICAgICAgICAgICAgICAgICAgIyBKdXN0IGlnbm9yZSBhbnkgY29uZmxpY3RpbmcgbGlua3MgYW5kIHdhcm4gdGhlIHVzZXI6XG4gICAgICAgICAgICAgICAgICAgICMgaWYgaXQncyBhIHJlYWwgY29uZmxpY3QsIHRoZSB1c2VyIHdpbGwgaW52ZXN0aWdhdGUgaXQsXG4gICAgICAgICAgICAgICAgICAgICMgb3RoZXJ3aXNlIHRoZSB1c2VyIHdpbGwgaWdub3JlIGl0XG4gICAgICAgICAgICAgICAgICAgIEFwcC5sb2cubG9nV2FybmluZyhcIlBvc3NpYmx5IGNvbmZsaWN0aW5nIGludGVybGFuZ3VhZ2UgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJsaW5rczogXCIgKyBBcHAubG9nLmxpbmtUb1BhZ2UobGluay51cmwsIFwiW1tcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rLmxhbmcgKyBcIjpcIiArIGxpbmsudGl0bGUgKyBcIl1dXCIpICsgXCIgYW5kIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIEFwcC5sb2cubGlua1RvUGFnZShubGluay51cmwsIFwiW1tcIiArIGxpbmsubGFuZyArIFwiOlwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld2xpbmtzW2xpbmsubGFuZy50b0xvd2VyQ2FzZSgpXS50aXRsZSArIFwiXV1cIikpXG5cbiAgICAgICAgICAgIEBXTS5JbnRlcmxhbmd1YWdlLmNvbGxlY3RMaW5rcyhcbiAgICAgICAgICAgICAgICB2aXNpdGVkbGlua3MsXG4gICAgICAgICAgICAgICAgbmV3bGlua3MsXG4gICAgICAgICAgICAgICAgc3VwcG9ydGVkTGFuZ3MsXG4gICAgICAgICAgICAgICAgd2hpdGVsaXN0LFxuICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgIEBtYWluRW5kLFxuICAgICAgICAgICAgICAgIFt0YWcsIHVybCwgc291cmNlLCBsYW5nbGlua3MsIGl3bWFwLCBjYWxsTmV4dF1cbiAgICAgICAgICAgIClcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgQXBwLmxvZy5sb2dJbmZvKFwiTm8gaW50ZXJsYW5ndWFnZSBsaW5rcyBmb3VuZFwiKVxuXG4gICAgICAgICAgICBpZiBjYWxsTmV4dFxuICAgICAgICAgICAgICAgIGNhbGxOZXh0KClcblxuICAgIG1haW5FbmQ6IChsaW5rcywgYXJncykgPT5cbiAgICAgICAgdGFnID0gYXJnc1swXVxuICAgICAgICB1cmwgPSBhcmdzWzFdXG4gICAgICAgIHNvdXJjZSA9IGFyZ3NbMl1cbiAgICAgICAgbGFuZ2xpbmtzID0gYXJnc1szXVxuICAgICAgICBpd21hcCA9IGFyZ3NbNF1cbiAgICAgICAgY2FsbE5leHQgPSBhcmdzWzVdXG5cbiAgICAgICAgbmV3VGV4dCA9IEBXTS5JbnRlcmxhbmd1YWdlLnVwZGF0ZUxpbmtzKHRhZywgdXJsLCBpd21hcCwgc291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFuZ2xpbmtzLCBsaW5rcylcblxuICAgICAgICBpZiBuZXdUZXh0ICE9IHNvdXJjZVxuICAgICAgICAgICAgQFdNLkVkaXRvci53cml0ZVNvdXJjZShuZXdUZXh0KVxuICAgICAgICAgICAgQXBwLmxvZy5sb2dJbmZvKFwiU3luY2hyb25pemVkIGludGVybGFuZ3VhZ2UgbGlua3NcIilcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgQXBwLmxvZy5sb2dJbmZvKFwiSW50ZXJsYW5ndWFnZSBsaW5rcyB3ZXJlIGFscmVhZHkgc3luY2hyb25pemVkXCIpXG5cbiAgICAgICAgaWYgY2FsbE5leHRcbiAgICAgICAgICAgIGNhbGxOZXh0KClcblxuICAgIG1haW5fYm90OiAodGl0bGUsIGNhbGxCb3QsIGNoYWluQXJncykgLT5cbiAgICAgICAgZGV0ZWN0ID0gQGRldGVjdExhbmcodGl0bGUsIEBjb25mLmxhbmd1YWdlX3RhZylcbiAgICAgICAgcHVyZVRpdGxlID0gZGV0ZWN0WzBdXG4gICAgICAgIHRhZyA9IGRldGVjdFsxXVxuXG4gICAgICAgIHdoaXRlbGlzdCA9IEBjb21wdXRlV2hpdGVMaXN0KEBjb25mLnRhZ193aGl0ZWxpc3QpXG4gICAgICAgIHN1cHBvcnRlZExhbmdzID0gQGNvbXB1dGVTdXBwb3J0ZWRMYW5ncyhAY29uZi5zdXBwb3J0ZWRfdGFncylcblxuICAgICAgICBzdW1tYXJ5ID0gQGNvbmYuZWRpdF9zdW1tYXJ5XG5cbiAgICAgICAgd2lraVVybHMgPSBAV00uTVcuZ2V0V2lraVVybHMoKVxuICAgICAgICB1cmwgPSB3aWtpVXJscy5zaG9ydCArIGVuY29kZVVSSUNvbXBvbmVudChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQFdNLlBhcnNlci5zcXVhc2hDb250aWd1b3VzV2hpdGVzcGFjZSh0aXRsZSkpXG5cbiAgICAgICAgdmlzaXRlZGxpbmtzID0ge31cblxuICAgICAgICBuZXdsaW5rcyA9IHt9XG4gICAgICAgIG5ld2xpbmtzW3RhZy50b0xvd2VyQ2FzZSgpXSA9IEBXTS5JbnRlcmxhbmd1YWdlLmNyZWF0ZU5ld0xpbmsodGFnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHVyZVRpdGxlLCB1cmwpXG5cbiAgICAgICAgQFdNLkludGVybGFuZ3VhZ2UuY29sbGVjdExpbmtzKFxuICAgICAgICAgICAgdmlzaXRlZGxpbmtzLFxuICAgICAgICAgICAgbmV3bGlua3MsXG4gICAgICAgICAgICBzdXBwb3J0ZWRMYW5ncyxcbiAgICAgICAgICAgIHdoaXRlbGlzdCxcbiAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICBAbWFpbkF1dG9Xcml0ZSxcbiAgICAgICAgICAgIFt0aXRsZSwgdXJsLCB0YWcsIHN1bW1hcnksIGNhbGxCb3RdXG4gICAgICAgIClcblxuICAgIG1haW5BdXRvV3JpdGU6IChsaW5rcywgYXJncykgPT5cbiAgICAgICAgdGl0bGUgPSBhcmdzWzBdXG4gICAgICAgIHVybCA9IGFyZ3NbMV1cbiAgICAgICAgdGFnID0gYXJnc1syXVxuICAgICAgICBzdW1tYXJ5ID0gYXJnc1szXVxuICAgICAgICBjYWxsQm90ID0gYXJnc1s0XVxuXG4gICAgICAgIGxjVGFnID0gdGFnLnRvTG93ZXJDYXNlKClcbiAgICAgICAgIyBOZXcgbGlua3MgdGhhdCB3ZXJlIG5vdCBpbiB0aGUgd2hpdGUgbGlzdCB3aWxsIGhhdmUgdGhlIFwiaXdtYXBcIlxuICAgICAgICAjIGF0dHJpYnV0ZSBmYWxzZSwgXCJ0aW1lc3RhbXBcIiBhbmQgXCJlZGl0dG9rZW5cIiBudWxsIGFuZCBcImxpbmtzXCIgYXMgYW5cbiAgICAgICAgIyBlbXB0eSBhcnJheSwgaG93ZXZlciBsaW5rc1tsY1RhZ10gc2hvdWxkIGFsd2F5cyBiZSBzYWZlXG4gICAgICAgIGl3bWFwID0gbGlua3NbbGNUYWddLml3bWFwXG4gICAgICAgIHNvdXJjZSA9IGxpbmtzW2xjVGFnXS5zb3VyY2VcbiAgICAgICAgbGFuZ2xpbmtzID0gbGlua3NbbGNUYWddLmxpbmtzXG4gICAgICAgIHRpbWVzdGFtcCA9IGxpbmtzW2xjVGFnXS50aW1lc3RhbXBcbiAgICAgICAgZWRpdHRva2VuID0gbGlua3NbbGNUYWddLmVkaXR0b2tlblxuXG4gICAgICAgIG5ld1RleHQgPSBAV00uSW50ZXJsYW5ndWFnZS51cGRhdGVMaW5rcyh0YWcsIHVybCwgaXdtYXAsIHNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhbmdsaW5rcywgbGlua3MpXG5cbiAgICAgICAgaWYgbmV3VGV4dCAhPSBzb3VyY2VcbiAgICAgICAgICAgIEBXTS5NVy5jYWxsQVBJUG9zdCh7XG4gICAgICAgICAgICAgICAgIGFjdGlvbjogXCJlZGl0XCJcbiAgICAgICAgICAgICAgICAgYm90OiBcIjFcIlxuICAgICAgICAgICAgICAgICB0aXRsZTogdGl0bGVcbiAgICAgICAgICAgICAgICAgc3VtbWFyeTogc3VtbWFyeVxuICAgICAgICAgICAgICAgICB0ZXh0OiBuZXdUZXh0XG4gICAgICAgICAgICAgICAgIGJhc2V0aW1lc3RhbXA6IHRpbWVzdGFtcFxuICAgICAgICAgICAgICAgICB0b2tlbjogZWRpdHRva2VuXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBAbWFpbkF1dG9FbmQsXG4gICAgICAgICAgICAgICAgY2FsbEJvdCxcbiAgICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICApXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGNhbGxCb3QoMCwgbnVsbClcblxuICAgIG1haW5BdXRvRW5kOiAocmVzLCBjYWxsQm90KSA9PlxuICAgICAgICBpZiByZXMuZWRpdCBhbmQgcmVzLmVkaXQucmVzdWx0ID09ICdTdWNjZXNzJ1xuICAgICAgICAgICAgY2FsbEJvdCgxLCBudWxsKVxuICAgICAgICBlbHNlIGlmIHJlcy5lcnJvclxuICAgICAgICAgICAgQXBwLmxvZy5sb2dFcnJvcihyZXMuZXJyb3IuaW5mbyArIFwiIChcIiArIHJlcy5lcnJvci5jb2RlICsgXCIpXCIpXG4gICAgICAgICAgICBjYWxsQm90KHJlcy5lcnJvci5jb2RlLCBudWxsKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICBjYWxsQm90KGZhbHNlLCBudWxsKVxuIiwiIyBXaWtpIE1vbmtleSAtIE1lZGlhV2lraSBib3QgYW5kIGVkaXRvci1hc3Npc3RhbnQgdXNlciBzY3JpcHRcbiMgQ29weXJpZ2h0IChDKSAyMDExIERhcmlvIEdpb3Zhbm5ldHRpIDxkZXZAZGFyaW9naW92YW5uZXR0aS5uZXQ+XG4jXG4jIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFdpa2kgTW9ua2V5LlxuI1xuIyBXaWtpIE1vbmtleSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4jIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4jIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4jIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4jXG4jIFdpa2kgTW9ua2V5IGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4jIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4jIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiMgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbiNcbiMgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiMgYWxvbmcgd2l0aCBXaWtpIE1vbmtleS4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cblxuV00gPSByZXF1aXJlKCcuLi9tb2R1bGVzJylcbkFwcCA9IHJlcXVpcmUoJy4uL2FwcCcpXG57UGx1Z2lufSA9IHJlcXVpcmUoJy4vX1BsdWdpbicpXG5TdHIgPSByZXF1aXJlKCdAa3luaWtvcy9taXNjL2Rpc3QvU3RyJylcblxuXG5jbGFzcyBtb2R1bGUuZXhwb3J0cy5VcGRhdGVDYXRlZ29yeVRyZWUgZXh0ZW5kcyBQbHVnaW5cbiAgICBAY29uZl9kZWZhdWx0OlxuICAgICAgICBlbmFibGVkOiBmYWxzZVxuICAgICAgICBzcGVjaWFsX21lbnU6IFtcIlVwZGF0ZSBjYXRlZ29yeSB0cmVlc1wiXVxuICAgICAgICBlZGl0X3N1bW1hcnk6IFwiYXV0b21hdGljIHVwZGF0ZVwiXG4gICAgICAgIHNob3dfcm9vdF9hbHNvX2luOiBmYWxzZVxuICAgICAgICBwYWdlczogW11cbiAgICBAd2lraV90b19jb25mX2RlZmF1bHQ6XG4gICAgICAgIEFyY2hXaWtpOlxuICAgICAgICAgICAgcGFnZXM6IFtcImFyXCIsIFwiY3NcIiwgXCJjc1wiLCBcImRhXCIsIFwiZWxcIiwgXCJlblwiLCBcImVzXCIsIFwiaGVcIiwgXCJoclwiLCBcImh1XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiaWRcIiwgXCJpdFwiLCBcImtvXCIsIFwibHRcIiwgXCJubFwiLCBcInBsXCIsIFwicHRcIiwgXCJydVwiLCBcInNrXCIsIFwic3JcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ0aFwiLCBcInRyXCIsIFwidWtcIiwgXCJ6aC1oYW5zXCIsIFwiemgtaGFudFwiXVxuICAgICAgICBXaWtpcGVkaWE6IHt9XG5cbiAgICBtYWluX3NwZWNpYWw6IChjYWxsTmV4dCkgLT5cbiAgICAgICAgQGl0ZXJhdGVQYWdlcygtMSwgY2FsbE5leHQpXG5cbiAgICBpdGVyYXRlUGFnZXM6IChwYWdlaWQsIGNhbGxOZXh0KSAtPlxuICAgICAgICBwYWdlaWQrK1xuICAgICAgICBzdW1tYXJ5ID0gQGNvbmYuZWRpdF9zdW1tYXJ5XG4gICAgICAgIHNob3dSb290QWxzb0luID0gQGNvbmYuc2hvd19yb290X2Fsc29faW5cbiAgICAgICAgcGNvbmYgPSBAY29uZi5wYWdlc1twYWdlaWRdXG4gICAgICAgIGlmIHBjb25mXG4gICAgICAgICAgICBpZiAkLnR5cGUocGNvbmYpIGlzIFwic3RyaW5nXCJcbiAgICAgICAgICAgICAgICBwYXJhbXMgPSBXTS5BcmNoV2lraS5nZXRUYWJsZU9mQ29udGVudHMocGNvbmYpXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgIyBUaGlzIHNob3VsZCBiZSBhIGN1c3RvbSBjb25maWd1cmF0aW9uIG9iamVjdFxuICAgICAgICAgICAgICAgIHBhcmFtcyA9IHBjb25mXG5cbiAgICAgICAgICAgIEBXTS5NVy5pc1VzZXJCb3QodGhpcy5tYWluQ29udGludWUsIFtwYXJhbXMsIHNob3dSb290QWxzb0luLCBzdW1tYXJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxOZXh0LCBwYWdlaWRdKVxuXG4gICAgICAgIGVsc2UgaWYgY2FsbE5leHRcbiAgICAgICAgICAgIGNhbGxOZXh0KClcblxuICAgIG1haW5Db250aW51ZTogKGJvdFRlc3QsIGFyZ3MpID0+XG4gICAgICAgIEByZWFkVG9DKHtcbiAgICAgICAgICAgIHBhcmFtczogYXJnc1swXVxuICAgICAgICAgICAgbWluSW50ZXJ2YWw6IGlmIGJvdFRlc3QgdGhlbiA2MDAwMCBlbHNlIDIxNjAwMDAwXG4gICAgICAgICAgICBlZGl0dG9rZW46IFwiXCJcbiAgICAgICAgICAgIHRpbWVzdGFtcDogXCJcIlxuICAgICAgICAgICAgc291cmNlOiBcIlwiXG4gICAgICAgICAgICBzdGFydElkOiAwXG4gICAgICAgICAgICBlbmRJZDogMFxuICAgICAgICAgICAgdHJlZVRleHQ6IFwiXCJcbiAgICAgICAgICAgIHN0YXJ0TWFyazogXCJTVEFSVCBBVVRPIFRPQyAtIERPIE5PVCBSRU1PVkUgT1IgTU9ESUZZIFRISVMgTUFSSy0tPlwiXG4gICAgICAgICAgICBlbmRNYXJrOiBcIjwhLS1FTkQgQVVUTyBUT0MgLSBETyBOT1QgUkVNT1ZFIE9SIE1PRElGWSBUSElTIE1BUktcIlxuICAgICAgICAgICAgYWx0TmFtZXM6IHt9XG4gICAgICAgICAgICBzaG93Um9vdEFsc29JbjogYXJnc1sxXVxuICAgICAgICAgICAgc3VtbWFyeTogYXJnc1syXVxuICAgICAgICAgICAgY2FsbE5leHQ6IGFyZ3NbM11cbiAgICAgICAgICAgIHBhZ2VpZDogYXJnc1s0XVxuICAgICAgICB9KVxuXG4gICAgcmVhZFRvQzogKGFyZ3MpID0+XG4gICAgICAgIEFwcC5sb2cubG9nSW5mbygnVXBkYXRpbmcgJyArIEFwcC5sb2cubGlua1RvV2lraVBhZ2UoYXJncy5wYXJhbXMucGFnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MucGFyYW1zLnBhZ2UpICsgXCIgLi4uXCIpXG4gICAgICAgIEBXTS5NVy5jYWxsUXVlcnlFZGl0KGFyZ3MucGFyYW1zLnBhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQHByb2Nlc3NUb0MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJncylcblxuICAgIHByb2Nlc3NUb0M6ICh0aXRsZSwgc291cmNlLCB0aW1lc3RhbXAsIGVkaXR0b2tlbiwgYXJncykgPT5cbiAgICAgICAgYXJncy5zb3VyY2UgPSBzb3VyY2VcbiAgICAgICAgYXJncy50aW1lc3RhbXAgPSB0aW1lc3RhbXBcbiAgICAgICAgYXJncy5lZGl0dG9rZW4gPSBlZGl0dG9rZW5cblxuICAgICAgICBub3cgPSBuZXcgRGF0ZSgpXG4gICAgICAgIG1zVGltZXN0YW1wID0gRGF0ZS5wYXJzZShhcmdzLnRpbWVzdGFtcClcbiAgICAgICAgaWYgbm93LmdldFRpbWUoKSAtIG1zVGltZXN0YW1wID49IGFyZ3MubWluSW50ZXJ2YWxcbiAgICAgICAgICAgIHN0YXJ0ID0gYXJncy5zb3VyY2UuaW5kZXhPZihhcmdzLnN0YXJ0TWFyaylcbiAgICAgICAgICAgIGVuZCA9IGFyZ3Muc291cmNlLmxhc3RJbmRleE9mKGFyZ3MuZW5kTWFyaylcblxuICAgICAgICAgICAgaWYgc3RhcnQgPiAtMSBhbmQgZW5kID4gLTFcbiAgICAgICAgICAgICAgICBhcmdzLnN0YXJ0SWQgPSBzdGFydCArIGFyZ3Muc3RhcnRNYXJrLmxlbmd0aFxuICAgICAgICAgICAgICAgIGFyZ3MuZW5kSWQgPSBlbmRcbiAgICAgICAgICAgICAgICBhcmdzLnRyZWVUZXh0ID0gXCJcIlxuICAgICAgICAgICAgICAgIGFyZ3MuYWx0TmFtZXMgPSBpZiBhcmdzLnBhcmFtcy5rZWVwQWx0TmFtZSB0aGVuIEBzdG9yZUFsdGVybmF0aXZlTmFtZXMoYXJncy5zb3VyY2UpIGVsc2Uge31cbiAgICAgICAgICAgICAgICBXTS5DYXQucmVjdXJzZVRyZWUoe1xuICAgICAgICAgICAgICAgICAgICBub2RlOiBhcmdzLnBhcmFtcy5yb290LFxuICAgICAgICAgICAgICAgICAgICBjYWxsTm9kZTogQHByb2Nlc3NDYXRlZ29yeSxcbiAgICAgICAgICAgICAgICAgICAgY2FsbEVuZDogQHdyaXRlVG9DLFxuICAgICAgICAgICAgICAgICAgICBjYWxsQXJnczogYXJnc1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgQXBwLmxvZy5sb2dFcnJvcihcIkNhbm5vdCBmaW5kIGluc2VydGlvbiBtYXJrcyBpbiBcIiArXG4gICAgICAgICAgICAgICAgICAgIEFwcC5sb2cubGlua1RvV2lraVBhZ2UoYXJncy5wYXJhbXMucGFnZSwgYXJncy5wYXJhbXMucGFnZSkpXG4gICAgICAgICAgICAgICAgQGl0ZXJhdGVQYWdlcyhhcmdzLnBhZ2VpZCwgYXJncy5jYWxsTmV4dClcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgQXBwLmxvZy5sb2dXYXJuaW5nKEFwcC5sb2cubGlua1RvV2lraVBhZ2UoYXJncy5wYXJhbXMucGFnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MucGFyYW1zLnBhZ2UpICsgJyBoYXMgYmVlbiB1cGRhdGVkIHRvbyByZWNlbnRseScpXG4gICAgICAgICAgICBAaXRlcmF0ZVBhZ2VzKGFyZ3MucGFnZWlkLCBhcmdzLmNhbGxOZXh0KVxuXG4gICAgc3RvcmVBbHRlcm5hdGl2ZU5hbWVzOiAoc291cmNlKSA9PlxuICAgICAgICBkaWN0ID0ge31cbiAgICAgICAgcmVnRXhwID0gL1xcW1xcW1xcOihbQ2NdYXRlZ29yeVxcOi4rPylcXHwoLis/KVxcXVxcXS9nbVxuICAgICAgICB3aGlsZSB0cnVlXG4gICAgICAgICAgICBtYXRjaCA9IHJlZ0V4cC5leGVjKHNvdXJjZSlcbiAgICAgICAgICAgIGlmIG1hdGNoXG4gICAgICAgICAgICAgICAgZGljdFttYXRjaFsxXS50b0xvd2VyQ2FzZSgpXSA9IG1hdGNoWzJdXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgcmV0dXJuIGRpY3RcblxuICAgIHByb2Nlc3NDYXRlZ29yeTogKHBhcmFtcykgPT5cbiAgICAgICAgYXJncyA9IHBhcmFtcy5jYWxsQXJnc1xuXG4gICAgICAgIEFwcC5sb2cubG9nSW5mbyhcIlByb2Nlc3NpbmcgXCIgKyBBcHAubG9nLmxpbmtUb1dpa2lQYWdlKHBhcmFtcy5ub2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMubm9kZSkgKyBcIiAuLi5cIilcblxuICAgICAgICB0ZXh0ID0gXCJcIlxuXG4gICAgICAgIGZvciBbMC4uLnBhcmFtcy5hbmNlc3RvcnMubGVuZ3RoXVxuICAgICAgICAgICAgdGV4dCArPSBhcmdzLnBhcmFtcy5pbmRlbnRUeXBlXG5cbiAgICAgICAgaWYgYXJncy5wYXJhbXMuc2hvd0luZGljZXNcbiAgICAgICAgICAgIGluZGljZXMgPSBbXVxuICAgICAgICAgICAgbm9kZSA9IHBhcmFtc1xuICAgICAgICAgICAgd2hpbGUgbm9kZS5wYXJlbnRJbmRleCAhPSBudWxsXG4gICAgICAgICAgICAgICAgaW5kaWNlcy5wdXNoKG5vZGUuc2libGluZ0luZGV4ICsgMSlcbiAgICAgICAgICAgICAgICBub2RlID0gcGFyYW1zLm5vZGVzTGlzdFtub2RlLnBhcmVudEluZGV4XVxuICAgICAgICAgICAgaWYgaW5kaWNlcy5sZW5ndGhcbiAgICAgICAgICAgICAgICB0ZXh0ICs9IFwiPHNtYWxsPlwiICsgaW5kaWNlcy5yZXZlcnNlKCkuam9pbihcIi5cIikgKyBcIi48L3NtYWxsPiBcIlxuXG4gICAgICAgIGFsdE5hbWUgPSBpZiBhcmdzLmFsdE5hbWVzW3BhcmFtcy5ub2RlLnRvTG93ZXJDYXNlKCldIHRoZW4gYXJncy5hbHROYW1lc1twYXJhbXMubm9kZS50b0xvd2VyQ2FzZSgpXSBlbHNlIG51bGxcbiAgICAgICAgdGV4dCArPSBAY3JlYXRlQ2F0TGluayhwYXJhbXMubm9kZSwgYXJncy5wYXJhbXMucmVwbGFjZSwgYWx0TmFtZSlcblxuICAgICAgICB0ZXh0ICs9IGlmIGFyZ3MucGFyYW1zLnJpZ2h0VG9MZWZ0IHRoZW4gXCImbHJtOyBcIiBlbHNlIFwiIFwiXG5cbiAgICAgICAgaWYgcGFyYW1zLmNoaWxkcmVuID09IFwibG9vcFwiXG4gICAgICAgICAgICB0ZXh0ICs9IFwiJycnW0xPT1BdJycnXFxuXCJcbiAgICAgICAgICAgIEFwcC5sb2cubG9nV2FybmluZyhcIkxvb3AgaW4gXCIgKyBBcHAubG9nLmxpbmtUb1dpa2lQYWdlKHBhcmFtcy5ub2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy5ub2RlKSlcbiAgICAgICAgICAgIEBwcm9jZXNzQ2F0ZWdvcnlFbmQocGFyYW1zLCBhcmdzLCB0ZXh0KVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICBXTS5DYXQuZ2V0UGFyZW50c0FuZEluZm8oXG4gICAgICAgICAgICAgICAgcGFyYW1zLm5vZGUsXG4gICAgICAgICAgICAgICAgQHByb2Nlc3NDYXRlZ29yeUFkZFN1ZmZpeCxcbiAgICAgICAgICAgICAgICBbcGFyYW1zLCBhcmdzLCB0ZXh0LCBhbHROYW1lXVxuICAgICAgICAgICAgKVxuXG4gICAgcHJvY2Vzc0NhdGVnb3J5QWRkU3VmZml4OiAocGFyZW50cywgaW5mbywgYXJnc18pID0+XG4gICAgICAgIHBhcmFtcyA9IGFyZ3NfWzBdXG4gICAgICAgIGFyZ3MgPSBhcmdzX1sxXVxuICAgICAgICB0ZXh0ID0gYXJnc19bMl1cbiAgICAgICAgYWx0TmFtZSA9IGFyZ3NfWzNdXG5cbiAgICAgICAgY3VyclBhcmVudCA9IHBhcmFtcy5hbmNlc3RvcnNbcGFyYW1zLmFuY2VzdG9ycy5sZW5ndGggLSAxXVxuICAgICAgICBhbHNvUGFyZW50cyA9IFtdXG4gICAgICAgIHRleHQgKz0gXCI8c21hbGw+KFwiICsgKGlmIGluZm8gdGhlbiBpbmZvLnBhZ2VzIGVsc2UgMCkgKyBcIilcIlxuXG4gICAgICAgICMgQWxsb3cgaGlkaW5nIHRoZSBcImFsc28gaW5cIiAod2hvc2UgY3VyclBhcmVudCBpcyB1bmRlZmluZWQpIGxpbmtzIGZvclxuICAgICAgICAjIHRoZSByb290IGl0ZW0sIHNpbmNlIHRoZSByb290J3MgcGFyZW50IGNhdGVnb3J5IHdvdWxkIGJlIGRpc3BsYXllZFxuICAgICAgICAjIHRoZXJlXG4gICAgICAgIGlmIGN1cnJQYXJlbnQgb3IgYXJncy5zaG93Um9vdEFsc29JblxuICAgICAgICAgICAgZm9yIHBhciBpbiBwYXJlbnRzXG4gICAgICAgICAgICAgICAgaWYgY3VyclBhcmVudCAhPSBwYXIudGl0bGUgYW5kIG5vdCAoXCJoaWRkZW5cIiBpbiBwYXIpXG4gICAgICAgICAgICAgICAgICAgIGFsc29QYXJlbnRzLnB1c2gocGFyKVxuXG4gICAgICAgICAgICBpZiBhbHNvUGFyZW50cy5sZW5ndGhcbiAgICAgICAgICAgICAgICBwYXJlbnRUaXRsZXMgPSBbXVxuICAgICAgICAgICAgICAgIGZvciBpIGluIGFsc29QYXJlbnRzXG4gICAgICAgICAgICAgICAgICAgIGFsdE5hbWUgPSBpZiBhcmdzLmFsdE5hbWVzW2Fsc29QYXJlbnRzW2ldLnRpdGxlLnRvTG93ZXJDYXNlKCldIHRoZW4gYXJncy5hbHROYW1lc1thbHNvUGFyZW50c1tpXS50aXRsZS50b0xvd2VyQ2FzZSgpXSBlbHNlIG51bGxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50VGl0bGVzLnB1c2goQGNyZWF0ZUNhdExpbmsoYWxzb1BhcmVudHNbaV0udGl0bGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzLnBhcmFtcy5yZXBsYWNlLCBhbHROYW1lKSlcblxuICAgICAgICAgICAgICAgIHRleHQgKz0gXCIgKFwiICsgYXJncy5wYXJhbXMuYWxzb0luICsgXCIgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50VGl0bGVzLmpvaW4oXCIsIFwiKSArIFwiKVwiXG5cbiAgICAgICAgdGV4dCArPSBcIjwvc21hbGw+XFxuXCJcblxuICAgICAgICBAcHJvY2Vzc0NhdGVnb3J5RW5kKHBhcmFtcywgYXJncywgdGV4dClcblxuICAgIHByb2Nlc3NDYXRlZ29yeUVuZDogKHBhcmFtcywgYXJncywgdGV4dCkgPT5cbiAgICAgICAgYXJncy50cmVlVGV4dCArPSB0ZXh0XG5cbiAgICAgICAgcGFyYW1zLmNhbGxBcmdzID0gYXJnc1xuXG4gICAgICAgIFdNLkNhdC5yZWN1cnNlVHJlZUNvbnRpbnVlKHBhcmFtcylcblxuICAgIGNyZWF0ZUNhdExpbms6IChjYXQsIHJlcGxhY2UsIGFsdE5hbWUpID0+XG4gICAgICAgIGlmIGFsdE5hbWVcbiAgICAgICAgICAgIGNhdE5hbWUgPSBhbHROYW1lXG4gICAgICAgIGVsc2UgaWYgcmVwbGFjZVxuICAgICAgICAgICAgcmVnRXhwID0gbmV3IFJlZ0V4cChyZXBsYWNlWzBdLCByZXBsYWNlWzFdKVxuICAgICAgICAgICAgY2F0TmFtZSA9IGNhdC5zdWJzdHIoOSkucmVwbGFjZShyZWdFeHAsIHJlcGxhY2VbMl0pXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGNhdE5hbWUgPSBjYXQuc3Vic3RyKDkpXG4gICAgICAgIHJldHVybiBcIltbOlwiICsgY2F0ICsgXCJ8XCIgKyBjYXROYW1lICsgXCJdXVwiXG5cbiAgICB3cml0ZVRvQzogKHBhcmFtcykgPT5cbiAgICAgICAgYXJncyA9IHBhcmFtcy5jYWxsQXJnc1xuXG4gICAgICAgIGFyZ3MudHJlZVRleHQgPSBcIlxcblwiICsgYXJncy50cmVlVGV4dFxuICAgICAgICBuZXd0ZXh0ID0gU3RyLm92ZXJ3cml0ZUJldHdlZW4oYXJncy5zb3VyY2UsIGFyZ3MudHJlZVRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJncy5zdGFydElkLCBhcmdzLmVuZElkKVxuXG4gICAgICAgIGlmIG5ld3RleHQgIT0gYXJncy5zb3VyY2VcbiAgICAgICAgICAgIEBXTS5NVy5jYWxsQVBJUG9zdCh7XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXCJlZGl0XCJcbiAgICAgICAgICAgICAgICAgICAgYm90OiBcIjFcIlxuICAgICAgICAgICAgICAgICAgICBtaW5vcjogXCIxXCJcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IGFyZ3MucGFyYW1zLnBhZ2VcbiAgICAgICAgICAgICAgICAgICAgc3VtbWFyeTogYXJncy5zdW1tYXJ5XG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IG5ld3RleHRcbiAgICAgICAgICAgICAgICAgICAgYmFzZXRpbWVzdGFtcDogYXJncy50aW1lc3RhbXBcbiAgICAgICAgICAgICAgICAgICAgdG9rZW46IGFyZ3MuZWRpdHRva2VuXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBAY2hlY2tXcml0ZSxcbiAgICAgICAgICAgICAgICBhcmdzLFxuICAgICAgICAgICAgICAgIG51bGwpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIEFwcC5sb2cubG9nSW5mbyhBcHAubG9nLmxpbmtUb1dpa2lQYWdlKGFyZ3MucGFyYW1zLnBhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MucGFyYW1zLnBhZ2UpICsgJyBpcyBhbHJlYWR5IHVwIHRvIGRhdGUnKVxuXG4gICAgICAgICAgICBAaXRlcmF0ZVBhZ2VzKGFyZ3MucGFnZWlkLCBhcmdzLmNhbGxOZXh0KVxuXG4gICAgY2hlY2tXcml0ZTogKHJlcywgYXJncykgPT5cbiAgICAgICAgaWYgcmVzLmVkaXQgYW5kIHJlcy5lZGl0LnJlc3VsdCA9PSAnU3VjY2VzcydcbiAgICAgICAgICAgIEFwcC5sb2cubG9nSW5mbyhBcHAubG9nLmxpbmtUb1dpa2lQYWdlKGFyZ3MucGFyYW1zLnBhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzLnBhcmFtcy5wYWdlKSArICcgY29ycmVjdGx5IHVwZGF0ZWQnKVxuXG4gICAgICAgICAgICBAaXRlcmF0ZVBhZ2VzKGFyZ3MucGFnZWlkLCBhcmdzLmNhbGxOZXh0KVxuXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIEFwcC5sb2cubG9nRXJyb3IoQXBwLmxvZy5saW5rVG9XaWtpUGFnZShhcmdzLnBhcmFtcy5wYWdlLFxuICAgICAgICAgICAgICAgICAgICBhcmdzLnBhcmFtcy5wYWdlKSArICcgaGFzIG5vdCBiZWVuIHVwZGF0ZWQhXFxuJyArXG4gICAgICAgICAgICAgICAgICAgIHJlc1snZXJyb3InXVsnaW5mbyddICsgXCIgKFwiICsgcmVzWydlcnJvciddWydjb2RlJ10gKyBcIilcIilcbiIsIiMgV2lraSBNb25rZXkgLSBNZWRpYVdpa2kgYm90IGFuZCBlZGl0b3ItYXNzaXN0YW50IHVzZXIgc2NyaXB0XG4jIENvcHlyaWdodCAoQykgMjAxMSBEYXJpbyBHaW92YW5uZXR0aSA8ZGV2QGRhcmlvZ2lvdmFubmV0dGkubmV0PlxuI1xuIyBUaGlzIGZpbGUgaXMgcGFydCBvZiBXaWtpIE1vbmtleS5cbiNcbiMgV2lraSBNb25rZXkgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuIyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuIyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuIyAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuI1xuIyBXaWtpIE1vbmtleSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuIyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuIyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4jIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4jXG4jIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4jIGFsb25nIHdpdGggV2lraSBNb25rZXkuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG5cblxuY2xhc3MgbW9kdWxlLmV4cG9ydHMuUGx1Z2luXG4gICAgIyBEb24ndCBjcmVhdGUgZGVmYXVsdCBvYmplY3RzIGhlcmUsIG9yIHRoZXknbGwgYmUgc2hhcmVkIGFtb25nIHRoZVxuICAgICMgc3ViY2xhc3NlcyB1bmxlc3Mgb3ZlcnJpZGRlblxuICAgICMgQGNvbmZfZGVmYXVsdDoge31cbiAgICAjIEB3aWtpX3RvX2NvbmZfZGVmYXVsdDoge31cbiAgICAjIGNvbmY6IHt9XG5cbiAgICBAX19jb25maWd1cmU6ICh3aWtpX25hbWUsIHVzZXJfY29uZmlnKSAtPlxuICAgICAgICAjIERvIGdlbmVyYXRlIGEgbmV3IG9iamVjdCBmb3IgZWFjaCBwbHVnaW5cbiAgICAgICAgQDo6Y29uZiA9IHt9XG5cbiAgICAgICAgaWYgQGNvbmZfZGVmYXVsdD9cbiAgICAgICAgICAgICQuZXh0ZW5kKEA6OmNvbmYsIEBjb25mX2RlZmF1bHQpXG5cbiAgICAgICAgaWYgQHdpa2lfdG9fY29uZl9kZWZhdWx0PyBhbmQgd2lraV9uYW1lIG9mIEB3aWtpX3RvX2NvbmZfZGVmYXVsdFxuICAgICAgICAgICAgJC5leHRlbmQoQDo6Y29uZiwgQHdpa2lfdG9fY29uZl9kZWZhdWx0W3dpa2lfbmFtZV0pXG5cbiAgICAgICAgaWYgQG5hbWUgb2YgdXNlcl9jb25maWdcbiAgICAgICAgICAgICMgRG9uJ3QganVzdCB1c2UgJC5leHRlbmQoKSBzbyBpdCdzIHBvc3NpYmxlIHRvIHNlZSBpZiB0aGVyZSBhcmVcbiAgICAgICAgICAgICMgdW5rbm93biBvcHRpb25zIGFuZCBwb3NzaWJseSB3YXJuIHRoZSB1c2VyXG4gICAgICAgICAgICBmb3Igb3B0aW9uLCB2YWx1ZSBvZiB1c2VyX2NvbmZpZ1tAbmFtZV0gd2hlbiBvcHRpb24gb2YgQDo6Y29uZlxuICAgICAgICAgICAgICAgIEA6OmNvbmZbb3B0aW9uXSA9IHZhbHVlXG4gICAgICAgICAgICAgICAgZGVsZXRlIHVzZXJfY29uZmlnW0BuYW1lXVtvcHRpb25dXG5cbiAgICAgICAgaWYgbm90IEA6OmNvbmYuZW5hYmxlZFxuICAgICAgICAgICAgZGVsZXRlIHVzZXJfY29uZmlnW0BuYW1lXVxuICAgICAgICAgICAgIyBUT0RPOiBQcm9wZXJseSBleHRlbmQgRXJyb3IsIGJ1dCBiZXdhcmUgdGhhdCBCYWJlbCBkb2Vzbid0IGxpa2VcbiAgICAgICAgICAgICMgICAgICAgaXQgd2l0aG91dCBzcGVjaWZpYyBwbHVnaW5zXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQbHVnaW4gZGlzYWJsZWRcIilcblxuICAgICAgICBpZiAkLmlzRW1wdHlPYmplY3QodXNlcl9jb25maWdbQG5hbWVdKVxuICAgICAgICAgICAgZGVsZXRlIHVzZXJfY29uZmlnW0BuYW1lXVxuXG4gICAgY29uc3RydWN0b3I6IChAV00pIC0+XG5cbiAgICBtYWluX2JvdDogbnVsbFxuICAgIG1haW5fZGlmZjogbnVsbFxuICAgIG1haW5fZWRpdG9yOiBudWxsXG4gICAgbWFpbl9uZXdwYWdlczogbnVsbFxuICAgIG1haW5fcmVjZW50Y2hhbmdlczogbnVsbFxuICAgIG1haW5fc3BlY2lhbDogbnVsbFxuIl19
