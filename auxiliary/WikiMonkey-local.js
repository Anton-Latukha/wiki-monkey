/**
 * Modules in this bundle
 * @license
 *
 * @kynikos/wiki-monkey:
 *   license: GPL-3.0 (http://opensource.org/licenses/GPL-3.0)
 *   author: Dario Giovannetti
 *   version: 4.1.0
 *
 * @kynikos/misc:
 *   license: MIT (http://opensource.org/licenses/MIT)
 *   author: Dario Giovannetti
 *   homepage: https://github.com/kynikos/lib.js.misc#readme
 *   version: 0.1.3
 *
 * babel-polyfill:
 *   license: MIT (http://opensource.org/licenses/MIT)
 *   author: Sebastian McKenzie <sebmck@gmail.com>
 *   homepage: https://babeljs.io/
 *   version: 6.26.0
 *
 * browser-split:
 *   license: MIT (http://opensource.org/licenses/MIT)
 *   author: Julian Gruber <mail@juliangruber.com>
 *   homepage: https://github.com/juliangruber/browser-split
 *   version: 0.0.0
 *
 * class-list:
 *   licenses: MIT (http://opensource.org/licenses/MIT)
 *   author: Raynos <raynos2@gmail.com>
 *   contributors: Jake Verbaten
 *   homepage: https://github.com/Raynos/class-list
 *   version: 0.1.1
 *
 * core-js:
 *   license: MIT (http://opensource.org/licenses/MIT)
 *   homepage: https://github.com/zloirock/core-js#readme
 *   version: 2.5.1
 *
 * css-vendor:
 *   license: MIT (http://opensource.org/licenses/MIT)
 *   author: Oleg Slobodskoi <oleg008@gmail.com>
 *   homepage: https://github.com/cssinjs/css-vendor#readme
 *   version: 0.3.8
 *
 * hyperscript:
 *   license: MIT (http://opensource.org/licenses/MIT)
 *   author: 'Dominic Tarr' <dominic.tarr@gmail.com>
 *   homepage: https://github.com/dominictarr/hyperscript
 *   version: 2.0.2
 *
 * hyperscript-helpers:
 *   license: MIT (http://opensource.org/licenses/MIT)
 *   author: ohanhi
 *   homepage: https://github.com/ohanhi/hyperscript-helpers#readme
 *   version: 3.0.3
 *
 * indexof:
 *   version: 0.0.1
 *
 * is-in-browser:
 *   license: MIT (http://opensource.org/licenses/MIT)
 *   author: Jared Anderson
 *   homepage: https://github.com/tuxsudo/is-in-browser#readme
 *   version: 1.1.3
 *
 * jss:
 *   license: MIT (http://opensource.org/licenses/MIT)
 *   author: Oleg Slobodskoi <oleg008@gmail.com>
 *   homepage: https://github.com/cssinjs/jss#readme
 *   version: 9.5.1
 *
 * jss-camel-case:
 *   license: MIT (http://opensource.org/licenses/MIT)
 *   author: Oleg Slobodskoi <oleg008@gmail.com>
 *   homepage: https://github.com/cssinjs/jss-camel-case#readme
 *   version: 6.0.0
 *
 * jss-compose:
 *   license: MIT (http://opensource.org/licenses/MIT)
 *   author: Pavel Davydov <typical000@gmail.com>
 *   homepage: https://github.com/cssinjs/jss-compose#readme
 *   version: 5.0.0
 *
 * jss-default-unit:
 *   license: MIT (http://opensource.org/licenses/MIT)
 *   author: Oleg Slobodskoi <oleg008@gmail.com>
 *   homepage: https://github.com/cssinjs/jss-default-unit#readme
 *   version: 8.0.2
 *
 * jss-expand:
 *   license: MIT (http://opensource.org/licenses/MIT)
 *   author: Pavel Davydov <typical000@gmail.com>
 *   homepage: https://github.com/cssinjs/jss-expand#readme
 *   version: 5.1.0
 *
 * jss-extend:
 *   license: MIT (http://opensource.org/licenses/MIT)
 *   author: Oleg Slobodskoi <oleg008@gmail.com>
 *   homepage: https://github.com/cssinjs/jss-extend#readme
 *   version: 6.1.0
 *
 * jss-global:
 *   license: MIT (http://opensource.org/licenses/MIT)
 *   author: Oleg Slobodskoi <oleg008@gmail.com>
 *   homepage: https://github.com/cssinjs/jss-global
 *   version: 3.0.0
 *
 * jss-nested:
 *   license: MIT (http://opensource.org/licenses/MIT)
 *   author: Oleg Slobodskoi <oleg008@gmail.com>
 *   homepage: https://github.com/cssinjs/jss-nested#readme
 *   version: 6.0.1
 *
 * jss-preset-default:
 *   license: MIT (http://opensource.org/licenses/MIT)
 *   author: Oleg Slobodskoi <oleg008@gmail.com>
 *   homepage: https://github.com/cssinjs/jss-preset-default#readme
 *   version: 4.1.0
 *
 * jss-props-sort:
 *   license: MIT (http://opensource.org/licenses/MIT)
 *   author: Oleg Slobodskoi <oleg008@gmail.com>
 *   homepage: https://github.com/cssinjs/jss-props-sort#readme
 *   version: 6.0.0
 *
 * jss-template:
 *   license: MIT (http://opensource.org/licenses/MIT)
 *   author: Oleg Slobodskoi <oleg008@gmail.com>
 *   homepage: https://github.com/cssinjs/jss-template#readme
 *   version: 1.0.1
 *
 * jss-vendor-prefixer:
 *   license: MIT (http://opensource.org/licenses/MIT)
 *   author: Oleg Slobodskoi <oleg008@gmail.com>
 *   homepage: https://github.com/cssinjs/jss-vendor-prefixer#readme
 *   version: 7.0.0
 *
 * moment:
 *   license: MIT (http://opensource.org/licenses/MIT)
 *   author: Iskren Ivov Chernev <iskren.chernev@gmail.com>
 *   contributors: Tim Wood <washwithcare@gmail.com>, Rocky Meza, Matt Johnson <mj1856@hotmail.com>, Isaac Cambron <isaac@isaaccambron.com>, Andre Polykanine <andre@oire.org>
 *   homepage: http://momentjs.com
 *   version: 2.20.1
 *
 * process:
 *   license: MIT (http://opensource.org/licenses/MIT)
 *   author: Roman Shtylman <shtylman@gmail.com>
 *   homepage: https://github.com/shtylman/node-process#readme
 *   version: 0.11.10
 *
 * regenerator-runtime:
 *   license: MIT (http://opensource.org/licenses/MIT)
 *   author: Ben Newman <bn@cs.stanford.edu>
 *   version: 0.10.5
 *
 * symbol-observable:
 *   license: MIT (http://opensource.org/licenses/MIT)
 *   author: Ben Lesh <ben@benlesh.com>
 *   homepage: https://github.com/blesh/symbol-observable#readme
 *   version: 1.1.0
 *
 * warning:
 *   license: BSD-3-Clause (http://opensource.org/licenses/BSD-3-Clause)
 *   author: Berkeley Martinez <berkeley@r3dm.com>
 *   homepage: https://github.com/BerkeleyTrue/warning
 *   version: 3.0.0
 *
 * This header is generated by licensify (https://github.com/twada/licensify)
 */
(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
"use strict";

// Generated by CoffeeScript 2.1.1
// JavaScript auxiliary library
// Copyright (C) 2012 Dario Giovannetti <dev@dariogiovannetti.net>

// This file is part of JavaScript auxiliary library.

// JavaScript auxiliary library is free software: you can redistribute it
// and/or modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation, either version 3
// of the License, or (at your option) any later version.

// JavaScript auxiliary library is distributed in the hope that it will be
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with JavaScript auxiliary library.
// If not, see <http://www.gnu.org/licenses/>.
module.exports.executeAsync = function (functions, id) {
  var _this = this;

  var callContinue, fid;
  id++;
  if (functions[id]) {
    fid = functions[id];
    callContinue = function callContinue() {
      return _this.executeAsync(functions, id);
    };
    return fid[0](fid[1], callContinue);
  }
};

module.exports.recurseTreeAsync = function (params) {
  var parent;
  // params = {
  //   node: ,
  //   parentIndex: ,
  //   siblingIndex: ,
  //   ancestors: ,
  //   children: ,
  //   callChildren: ,
  //   callNode: ,
  //   callEnd: ,
  //   callArgs: ,
  //   stage: ,
  //   nodesList:
  // }

  // nodesList: [
  //   {
  //     node: ,
  //     parentIndex: ,
  //     siblingIndex: ,
  //     ancestors: [...],
  //     children: [...]
  //   },
  //   {...}
  // ]

  // Example:

  // recurseTreeAsync({
  //   node: ,
  //   callChildren: ,
  //   callNode: ,
  //   callEnd: ,
  //   callArgs:
  // });

  // callChildren(params) {
  //   params.children = ;
  //   recurseTreeAsync(params);
  // }

  // callNode(params) {
  //   recurseTreeAsync(params);
  // }

  // callEnd(params) {}
  switch (params.stage) {
    case void 0:
      params.parentIndex = null;
      params.siblingIndex = 0;
      params.ancestors = [];
      params.children = [];
      params.nodesList = [];
      params.stage = 1;
      return this.recurseTreeAsync(params);
    case 1:
      params.stage = 2;
      // Prevent infinite loops
      if (params.ancestors.indexOf(params.node) === -1) {
        return params.callChildren(params);
      } else {
        params.children = "loop";
        return this.recurseTreeAsync(params);
      }
      break;
    case 2:
      params.nodesList.push({
        node: params.node,
        parentIndex: params.parentIndex,
        siblingIndex: params.siblingIndex,
        ancestors: params.ancestors.slice(0),
        children: params.children.slice(0)
      });
      params.stage = 3;
      return params.callNode(params);
    case 3:
      if (params.children.length && params.children !== "loop") {
        // Go to the first child
        params.ancestors.push(params.node);
        params.node = params.children[0];
        params.parentIndex = params.nodesList.length - 1;
        params.siblingIndex = 0;
        params.children = [];
        params.stage = 1;
        return this.recurseTreeAsync(params);
      } else if (params.parentIndex !== null) {
        // Go to the next sibling
        parent = params.nodesList[params.parentIndex];
        params.siblingIndex++;
        params.node = parent.children[params.siblingIndex];
        params.children = [];
        if (params.node) {
          params.stage = 1;
        } else {
          // There are no more siblings
          params.node = parent.node;
          params.parentIndex = parent.parentIndex;
          params.siblingIndex = parent.siblingIndex;
          params.ancestors = parent.ancestors.slice(0);
          params.stage = 3;
        }
        return this.recurseTreeAsync(params);
      } else {
        // End of recursion
        return params.callEnd(params);
      }
  }
};
},{}],2:[function(require,module,exports){
'use strict';

// Generated by CoffeeScript 2.1.1
// JavaScript auxiliary library
// Copyright (C) 2012 Dario Giovannetti <dev@dariogiovannetti.net>

// This file is part of JavaScript auxiliary library.

// JavaScript auxiliary library is free software: you can redistribute it
// and/or modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation, either version 3
// of the License, or (at your option) any later version.

// JavaScript auxiliary library is distributed in the hope that it will be
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with JavaScript auxiliary library.
// If not, see <http://www.gnu.org/licenses/>.
module.exports.addStyleElement = function (css) {
  var style;
  style = document.createElement('style');
  style.setAttribute('type', 'text/css');
  style.innerHTML = css;
  return document.head.appendChild(style);
};
},{}],3:[function(require,module,exports){
'use strict';

// Generated by CoffeeScript 2.1.1
// JavaScript auxiliary library
// Copyright (C) 2012 Dario Giovannetti <dev@dariogiovannetti.net>

// This file is part of JavaScript auxiliary library.

// JavaScript auxiliary library is free software: you can redistribute it
// and/or modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation, either version 3
// of the License, or (at your option) any later version.

// JavaScript auxiliary library is distributed in the hope that it will be
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with JavaScript auxiliary library.
// If not, see <http://www.gnu.org/licenses/>.
module.exports.normalizeCarriageReturns = function (source) {
  // Opera and IE use \r\n instead of \n
  return source.replace(/\r\n/g, '\n');
};
},{}],4:[function(require,module,exports){
'use strict';

// Generated by CoffeeScript 2.1.1
// JavaScript auxiliary library
// Copyright (C) 2012 Dario Giovannetti <dev@dariogiovannetti.net>

// This file is part of JavaScript auxiliary library.

// JavaScript auxiliary library is free software: you can redistribute it
// and/or modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation, either version 3
// of the License, or (at your option) any later version.

// JavaScript auxiliary library is distributed in the hope that it will be
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with JavaScript auxiliary library.
// If not, see <http://www.gnu.org/licenses/>.
module.exports.getUrlLocation = function (url) {
  var link;
  link = document.createElement('a');
  link.href = url;
  return link;
};

module.exports.getURIParameters = function (uri) {
  var i, len, par, qarray, qdict, qstring, s;
  if (uri) {
    qstring = module.exports.getUrlLocation(uri).search;
  } else {
    qstring = location.search;
  }
  qarray = qstring.substr(1).split('&');
  qdict = new Object();
  s = new Array();
  for (i = 0, len = qarray.length; i < len; i++) {
    par = qarray[i];
    s = par.split('=');
    qdict[s[0]] = s[1];
  }
  return qdict;
};

module.exports.getURIParameter = function (uri, name) {
  return module.exports.getURIParameters(uri)[name];
};

module.exports.sendGetAsyncRequest = function (url, call) {
  var req;
  req = new XMLHttpRequest();
  req.onreadystatechange = function () {
    if (req.readyState === 4 && req.status === 200) {
      return call(req);
    }
  };
  req.open("GET", url, true);
  return req.send();
};

module.exports.sendGetSyncRequest = function (url) {
  var req;
  req = new XMLHttpRequest();
  req.open("GET", url, false);
  req.send();
  return req;
};

module.exports.sendPostAsyncRequest = function (url, call, query, header, headervalue) {
  var req;
  req = new XMLHttpRequest();
  req.onreadystatechange = function () {
    if (req.readyState === 4 && req.status === 200) {
      return call(req);
    }
  };
  req.open("POST", url, true);
  if (header && headervalue) {
    req.setRequestHeader(header, headervalue);
  }
  return req.send(query);
};

module.exports.sendPostSyncRequest = function (url, query, header, headervalue) {
  var req;
  req = new XMLHttpRequest();
  req.open("POST", url, false);
  if (header && headervalue) {
    req.setRequestHeader(header, headervalue);
  }
  req.send(query);
  return req;
};
},{}],5:[function(require,module,exports){
"use strict";

// Generated by CoffeeScript 2.1.1
// JavaScript auxiliary library
// Copyright (C) 2012 Dario Giovannetti <dev@dariogiovannetti.net>

// This file is part of JavaScript auxiliary library.

// JavaScript auxiliary library is free software: you can redistribute it
// and/or modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation, either version 3
// of the License, or (at your option) any later version.

// JavaScript auxiliary library is distributed in the hope that it will be
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with JavaScript auxiliary library.
// If not, see <http://www.gnu.org/licenses/>.
module.exports.getKeys = function (object) {
  var i, keys;
  keys = [];
  for (i in object) {
    keys.push(i);
  }
  return keys;
};

module.exports.getValues = function (object) {
  var i, values;
  values = [];
  for (i in object) {
    values.push(object[i]);
  }
  return values;
};

module.exports.getFirstItem = function (object) {
  var i;
  for (i in object) {
    return object[i];
  }
};
},{}],6:[function(require,module,exports){
"use strict";

// Generated by CoffeeScript 2.1.1
// JavaScript auxiliary library
// Copyright (C) 2012 Dario Giovannetti <dev@dariogiovannetti.net>

// This file is part of JavaScript auxiliary library.

// JavaScript auxiliary library is free software: you can redistribute it
// and/or modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation, either version 3
// of the License, or (at your option) any later version.

// JavaScript auxiliary library is distributed in the hope that it will be
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with JavaScript auxiliary library.
// If not, see <http://www.gnu.org/licenses/>.
module.exports.escapePattern = function (string) {
  // Escaping any other characters is not necessary, references:
  // - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions
  // - http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
  // - http://stackoverflow.com/questions/2593637/how-to-escape-regular-expression-in-javascript
  // - http://stackoverflow.com/questions/494035/how-do-you-pass-a-variable-to-a-regular-expression-javascript
  // - http://stackoverflow.com/questions/3446170/escape-string-for-use-in-javascript-regex
  // - http://stackoverflow.com/questions/399078/what-special-characters-must-be-escaped-in-regular-expressions

  // Note for Wiki Monkey: do *not* escape '\s' here so that it will be
  // safe to use prepareRegexpWhitespace in WM.Parser
  return string.replace(/[-[\]{}()^$*+?.|\\]/g, "\\$&");
};

module.exports.matchAll = function (source, regExp) {
  var L, match, result;
  result = [];
  while (true) {
    match = regExp.exec(source);
    if (match) {
      L = match[0].length;
      result.push({
        "match": match,
        "index": regExp.lastIndex - L,
        "length": L
      });
    } else {
      break;
    }
  }
  return result;
};

module.exports.matchAllConditional = function (source, regExp, test) {
  var L, match, result;
  result = [];
  while (true) {
    match = regExp.exec(source);
    if (match && test(match)) {
      L = match[0].length;
      result.push({
        "match": match,
        "index": regExp.lastIndex - L,
        "length": L
      });
    } else {
      break;
    }
  }
  return result;
};
},{}],7:[function(require,module,exports){
"use strict";

// Generated by CoffeeScript 2.1.1
// JavaScript auxiliary library
// Copyright (C) 2012 Dario Giovannetti <dev@dariogiovannetti.net>

// This file is part of JavaScript auxiliary library.

// JavaScript auxiliary library is free software: you can redistribute it
// and/or modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation, either version 3
// of the License, or (at your option) any later version.

// JavaScript auxiliary library is distributed in the hope that it will be
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with JavaScript auxiliary library.
// If not, see <http://www.gnu.org/licenses/>.
module.exports.insert = function (string, newString, id) {
  if (id == null) {
    id = 0;
  }
  return string.substring(0, id) + newString + string.substr(id);
};

module.exports.overwriteFor = function (string, newString, id, length) {
  if (id == null) {
    id = 0;
  }
  if (!length || length < 0) {
    length = 0;
  }
  return string.substring(0, id) + newString + string.substr(id + length);
};

module.exports.overwriteAt = function (string, newString, id) {
  return module.exports.overwriteFor(string, newString, id, newString.length);
};

module.exports.overwriteBetween = function (string, newString, id1, id2) {
  var tempid;
  if (id1 == null) {
    id1 = 0;
  }
  if (id2 == null) {
    id2 = id1;
  }
  if (id1 > id2) {
    tempid = id2;
    id2 = id1;
    id1 = tempid;
  }
  return string.substring(0, id1) + newString + string.substr(id2);
};

module.exports.removeFor = function (string, id, length) {
  return module.exports.overwriteFor(string, "", id, length);
};

module.exports.removeBetween = function (string, id1, id2) {
  return module.exports.overwriteBetween(string, "", id1, id2);
};

module.exports.padLeft = function (string, filler, length) {
  while (string.length < length) {
    string = filler + string;
  }
  return string;
};

module.exports.padRight = function (string, filler, length) {
  while (string.length < length) {
    string += filler;
  }
  return string;
};

module.exports.findSimpleEnclosures = function (string, openTag, openLength, closeTag, closeLength) {
  var cIndex, cIndexRel, oIndex, oIndexRel, results, searchIndex;
  // openTag and closeTag can be strings or regular expressions
  // If the string is "<<>>" and the tags are "<" and ">", the result is
  //   [[0, 2], ]
  // Results are guaranteed to be in order of appearance in the original
  //   text
  results = [];
  searchIndex = 0;
  oIndexRel = string.search(openTag);
  while (true) {
    if (oIndexRel > -1) {
      oIndex = searchIndex + oIndexRel;
      cIndexRel = string.substr(oIndex + openLength).search(closeTag);
      if (cIndexRel > -1) {
        cIndex = oIndex + openLength + cIndexRel;
        results.push([oIndex, cIndex]);
        searchIndex = cIndex + closeLength;
        if (searchIndex < string.length) {
          oIndexRel = string.substr(searchIndex).search(openTag);
          continue;
        } else {
          break;
        }
      } else {
        // A tag is left open (no closing tag is found)
        // Let each implementation decide what to do in this case
        //   (either consider the tag working until the end of text
        //   or not)
        results.push([oIndex, false]);
        break;
      }
    } else {
      break;
    }
  }
  return results;
};

module.exports.findNestedEnclosures = function (string, openTag, closeTag, maskChar) {
  var cIndex, cIndexRel, closeLength, maskLength, maskedString, maskedString1, maskedString2, maskedString3, oIndex, oIndexRel, openLength, results, searchIndex;
  // openTag and closeTag must be strings, *not* regular expressions,
  //   unlike this.findSimpleEnclosures
  // maskChar must be a *1*-character string and must *not* be part of
  //   neither openTag nor closeTag
  // If the string is "<<>>" and the tags are "<" and ">", the result is
  //   [[1, 2], [0, 3]]
  openLength = openTag.length;
  closeLength = closeTag.length;
  results = [];
  searchIndex = 0;
  cIndexRel = string.indexOf(closeTag);
  maskedString = string;
  while (true) {
    if (cIndexRel > -1) {
      cIndex = searchIndex + cIndexRel;
      oIndexRel = maskedString.substring(searchIndex, cIndex).lastIndexOf(openTag);
      if (oIndexRel > -1) {
        oIndex = searchIndex + oIndexRel;
        results.push([oIndex, cIndex]);
        maskedString1 = maskedString.substring(0, oIndex);
        maskLength = cIndex - oIndex + closeLength;
        maskedString2 = module.exports.padRight("", maskChar, maskLength);
        maskedString3 = maskedString.substring(cIndex + closeLength);
        maskedString = maskedString1 + maskedString2 + maskedString3;
      } else {
        // Do *not* increment searchIndex in this case, in fact in
        //   we don't know yet whether there are more openTags
        //   before the one found
        searchIndex = cIndex + closeLength;
      }
      cIndexRel = maskedString.substring(searchIndex).indexOf(closeTag);
      continue;
    } else {
      break;
    }
  }
  return [results, maskedString];
};

module.exports.findInnermostEnclosures = function (string, openTag, closeTag) {
  var cIndex, cIndexRel, closeLength, oIndex, oIndexRel, openLength, results, searchIndex;
  // openTag and closeTag must be strings, *not* regular expressions,
  //   unlike this.findSimpleEnclosures
  // If the string is "<<>>" and the tags are "<" and ">", the result is
  //   [[1, 2], ]
  openLength = openTag.length;
  closeLength = closeTag.length;
  results = [];
  searchIndex = 0;
  while (true) {
    cIndexRel = string.substring(searchIndex).indexOf(closeTag);
    if (cIndexRel > -1) {
      cIndex = searchIndex + cIndexRel;
      oIndexRel = string.substring(searchIndex, cIndex).lastIndexOf(openTag);
      if (oIndexRel > -1) {
        oIndex = searchIndex + oIndexRel;
        results.push([oIndex, cIndex]);
      }
      searchIndex = cIndex + closeLength;
      continue;
    } else {
      break;
    }
  }
  return results;
};
},{}],8:[function(require,module,exports){
(function (global){
"use strict";

require("core-js/shim");

require("regenerator-runtime/runtime");

require("core-js/fn/regexp/escape");

if (global._babelPolyfill) {
  throw new Error("only one instance of babel-polyfill is allowed");
}
global._babelPolyfill = true;

var DEFINE_PROPERTY = "defineProperty";
function define(O, key, value) {
  O[key] || Object[DEFINE_PROPERTY](O, key, {
    writable: true,
    configurable: true,
    value: value
  });
}

define(String.prototype, "padLeft", "".padStart);
define(String.prototype, "padRight", "".padEnd);

"pop,reverse,shift,keys,values,entries,indexOf,every,some,forEach,map,filter,find,findIndex,includes,join,slice,concat,push,splice,unshift,sort,lastIndexOf,reduce,reduceRight,copyWithin,fill".split(",").forEach(function (key) {
  [][key] && define(Array, key, Function.call.bind([][key]));
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"core-js/fn/regexp/escape":13,"core-js/shim":335,"regenerator-runtime/runtime":9}],9:[function(require,module,exports){
(function (global){
/**
 * Copyright (c) 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
 * additional grant of patent rights can be found in the PATENTS file in
 * the same directory.
 */

!(function(global) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  var inModule = typeof module === "object";
  var runtime = global.regeneratorRuntime;
  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    }
    // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.
    return;
  }

  // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.
  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  runtime.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  runtime.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  runtime.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  runtime.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration. If the Promise is rejected, however, the
          // result for this iteration will be rejected with the same
          // reason. Note that rejections of yielded Promises are not
          // thrown back into the generator function, as is the case
          // when an awaited Promise is rejected. This difference in
          // behavior between yield and await is important, because it
          // allows the consumer to decide what to do with the yielded
          // rejection (swallow it and continue, manually .throw it back
          // into the generator, abandon iteration, whatever). With
          // await, by contrast, there is no opportunity to examine the
          // rejection reason outside the generator function, so the
          // only option is to throw it from the await expression, and
          // let the generator function handle the exception.
          result.value = unwrapped;
          resolve(result);
        }, reject);
      }
    }

    if (typeof global.process === "object" && global.process.domain) {
      invoke = global.process.domain.bind(invoke);
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  runtime.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList)
    );

    return runtime.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        if (delegate.iterator.return) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  runtime.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  runtime.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };
})(
  // Among the various tricks for obtaining a reference to the global
  // object, this seems to be the most reliable technique that does not
  // use indirect eval (which violates Content Security Policy).
  typeof global === "object" ? global :
  typeof window === "object" ? window :
  typeof self === "object" ? self : this
);

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],10:[function(require,module,exports){

},{}],11:[function(require,module,exports){
/*!
 * Cross-Browser Split 1.1.1
 * Copyright 2007-2012 Steven Levithan <stevenlevithan.com>
 * Available under the MIT License
 * ECMAScript compliant, uniform cross-browser split method
 */

/**
 * Splits a string into an array of strings using a regex or string separator. Matches of the
 * separator are not included in the result array. However, if `separator` is a regex that contains
 * capturing groups, backreferences are spliced into the result each time `separator` is matched.
 * Fixes browser bugs compared to the native `String.prototype.split` and can be used reliably
 * cross-browser.
 * @param {String} str String to split.
 * @param {RegExp|String} separator Regex or string to use for separating the string.
 * @param {Number} [limit] Maximum number of items to include in the result array.
 * @returns {Array} Array of substrings.
 * @example
 *
 * // Basic use
 * split('a b c d', ' ');
 * // -> ['a', 'b', 'c', 'd']
 *
 * // With limit
 * split('a b c d', ' ', 2);
 * // -> ['a', 'b']
 *
 * // Backreferences in result array
 * split('..word1 word2..', /([a-z]+)(\d+)/i);
 * // -> ['..', 'word', '1', ' ', 'word', '2', '..']
 */
module.exports = (function split(undef) {

  var nativeSplit = String.prototype.split,
    compliantExecNpcg = /()??/.exec("")[1] === undef,
    // NPCG: nonparticipating capturing group
    self;

  self = function(str, separator, limit) {
    // If `separator` is not a regex, use `nativeSplit`
    if (Object.prototype.toString.call(separator) !== "[object RegExp]") {
      return nativeSplit.call(str, separator, limit);
    }
    var output = [],
      flags = (separator.ignoreCase ? "i" : "") + (separator.multiline ? "m" : "") + (separator.extended ? "x" : "") + // Proposed for ES6
      (separator.sticky ? "y" : ""),
      // Firefox 3+
      lastLastIndex = 0,
      // Make `global` and avoid `lastIndex` issues by working with a copy
      separator = new RegExp(separator.source, flags + "g"),
      separator2, match, lastIndex, lastLength;
    str += ""; // Type-convert
    if (!compliantExecNpcg) {
      // Doesn't need flags gy, but they don't hurt
      separator2 = new RegExp("^" + separator.source + "$(?!\\s)", flags);
    }
    /* Values for `limit`, per the spec:
     * If undefined: 4294967295 // Math.pow(2, 32) - 1
     * If 0, Infinity, or NaN: 0
     * If positive number: limit = Math.floor(limit); if (limit > 4294967295) limit -= 4294967296;
     * If negative number: 4294967296 - Math.floor(Math.abs(limit))
     * If other: Type-convert, then use the above rules
     */
    limit = limit === undef ? -1 >>> 0 : // Math.pow(2, 32) - 1
    limit >>> 0; // ToUint32(limit)
    while (match = separator.exec(str)) {
      // `separator.lastIndex` is not reliable cross-browser
      lastIndex = match.index + match[0].length;
      if (lastIndex > lastLastIndex) {
        output.push(str.slice(lastLastIndex, match.index));
        // Fix browsers whose `exec` methods don't consistently return `undefined` for
        // nonparticipating capturing groups
        if (!compliantExecNpcg && match.length > 1) {
          match[0].replace(separator2, function() {
            for (var i = 1; i < arguments.length - 2; i++) {
              if (arguments[i] === undef) {
                match[i] = undef;
              }
            }
          });
        }
        if (match.length > 1 && match.index < str.length) {
          Array.prototype.push.apply(output, match.slice(1));
        }
        lastLength = match[0].length;
        lastLastIndex = lastIndex;
        if (output.length >= limit) {
          break;
        }
      }
      if (separator.lastIndex === match.index) {
        separator.lastIndex++; // Avoid an infinite loop
      }
    }
    if (lastLastIndex === str.length) {
      if (lastLength || !separator.test("")) {
        output.push("");
      }
    } else {
      output.push(str.slice(lastLastIndex));
    }
    return output.length > limit ? output.slice(0, limit) : output;
  };

  return self;
})();

},{}],12:[function(require,module,exports){
// contains, add, remove, toggle
var indexof = require('indexof')

module.exports = ClassList

function ClassList(elem) {
    var cl = elem.classList

    if (cl) {
        return cl
    }

    var classList = {
        add: add
        , remove: remove
        , contains: contains
        , toggle: toggle
        , toString: $toString
        , length: 0
        , item: item
    }

    return classList

    function add(token) {
        var list = getTokens()
        if (indexof(list, token) > -1) {
            return
        }
        list.push(token)
        setTokens(list)
    }

    function remove(token) {
        var list = getTokens()
            , index = indexof(list, token)

        if (index === -1) {
            return
        }

        list.splice(index, 1)
        setTokens(list)
    }

    function contains(token) {
        return indexof(getTokens(), token) > -1
    }

    function toggle(token) {
        if (contains(token)) {
            remove(token)
            return false
        } else {
            add(token)
            return true
        }
    }

    function $toString() {
        return elem.className
    }

    function item(index) {
        var tokens = getTokens()
        return tokens[index] || null
    }

    function getTokens() {
        var className = elem.className

        return filter(className.split(" "), isTruthy)
    }

    function setTokens(list) {
        var length = list.length

        elem.className = list.join(" ")
        classList.length = length

        for (var i = 0; i < list.length; i++) {
            classList[i] = list[i]
        }

        delete list[length]
    }
}

function filter (arr, fn) {
    var ret = []
    for (var i = 0; i < arr.length; i++) {
        if (fn(arr[i])) ret.push(arr[i])
    }
    return ret
}

function isTruthy(value) {
    return !!value
}

},{"indexof":343}],13:[function(require,module,exports){
require('../../modules/core.regexp.escape');
module.exports = require('../../modules/_core').RegExp.escape;

},{"../../modules/_core":34,"../../modules/core.regexp.escape":138}],14:[function(require,module,exports){
module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};

},{}],15:[function(require,module,exports){
var cof = require('./_cof');
module.exports = function (it, msg) {
  if (typeof it != 'number' && cof(it) != 'Number') throw TypeError(msg);
  return +it;
};

},{"./_cof":29}],16:[function(require,module,exports){
// 22.1.3.31 Array.prototype[@@unscopables]
var UNSCOPABLES = require('./_wks')('unscopables');
var ArrayProto = Array.prototype;
if (ArrayProto[UNSCOPABLES] == undefined) require('./_hide')(ArrayProto, UNSCOPABLES, {});
module.exports = function (key) {
  ArrayProto[UNSCOPABLES][key] = true;
};

},{"./_hide":53,"./_wks":136}],17:[function(require,module,exports){
module.exports = function (it, Constructor, name, forbiddenField) {
  if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {
    throw TypeError(name + ': incorrect invocation!');
  } return it;
};

},{}],18:[function(require,module,exports){
var isObject = require('./_is-object');
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};

},{"./_is-object":62}],19:[function(require,module,exports){
// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
'use strict';
var toObject = require('./_to-object');
var toAbsoluteIndex = require('./_to-absolute-index');
var toLength = require('./_to-length');

module.exports = [].copyWithin || function copyWithin(target /* = 0 */, start /* = 0, end = @length */) {
  var O = toObject(this);
  var len = toLength(O.length);
  var to = toAbsoluteIndex(target, len);
  var from = toAbsoluteIndex(start, len);
  var end = arguments.length > 2 ? arguments[2] : undefined;
  var count = Math.min((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to);
  var inc = 1;
  if (from < to && to < from + count) {
    inc = -1;
    from += count - 1;
    to += count - 1;
  }
  while (count-- > 0) {
    if (from in O) O[to] = O[from];
    else delete O[to];
    to += inc;
    from += inc;
  } return O;
};

},{"./_to-absolute-index":122,"./_to-length":126,"./_to-object":127}],20:[function(require,module,exports){
// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
'use strict';
var toObject = require('./_to-object');
var toAbsoluteIndex = require('./_to-absolute-index');
var toLength = require('./_to-length');
module.exports = function fill(value /* , start = 0, end = @length */) {
  var O = toObject(this);
  var length = toLength(O.length);
  var aLen = arguments.length;
  var index = toAbsoluteIndex(aLen > 1 ? arguments[1] : undefined, length);
  var end = aLen > 2 ? arguments[2] : undefined;
  var endPos = end === undefined ? length : toAbsoluteIndex(end, length);
  while (endPos > index) O[index++] = value;
  return O;
};

},{"./_to-absolute-index":122,"./_to-length":126,"./_to-object":127}],21:[function(require,module,exports){
var forOf = require('./_for-of');

module.exports = function (iter, ITERATOR) {
  var result = [];
  forOf(iter, false, result.push, result, ITERATOR);
  return result;
};

},{"./_for-of":50}],22:[function(require,module,exports){
// false -> Array#indexOf
// true  -> Array#includes
var toIObject = require('./_to-iobject');
var toLength = require('./_to-length');
var toAbsoluteIndex = require('./_to-absolute-index');
module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

},{"./_to-absolute-index":122,"./_to-iobject":125,"./_to-length":126}],23:[function(require,module,exports){
// 0 -> Array#forEach
// 1 -> Array#map
// 2 -> Array#filter
// 3 -> Array#some
// 4 -> Array#every
// 5 -> Array#find
// 6 -> Array#findIndex
var ctx = require('./_ctx');
var IObject = require('./_iobject');
var toObject = require('./_to-object');
var toLength = require('./_to-length');
var asc = require('./_array-species-create');
module.exports = function (TYPE, $create) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  var create = $create || asc;
  return function ($this, callbackfn, that) {
    var O = toObject($this);
    var self = IObject(O);
    var f = ctx(callbackfn, that, 3);
    var length = toLength(self.length);
    var index = 0;
    var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
    var val, res;
    for (;length > index; index++) if (NO_HOLES || index in self) {
      val = self[index];
      res = f(val, index, O);
      if (TYPE) {
        if (IS_MAP) result[index] = res;   // map
        else if (res) switch (TYPE) {
          case 3: return true;             // some
          case 5: return val;              // find
          case 6: return index;            // findIndex
          case 2: result.push(val);        // filter
        } else if (IS_EVERY) return false; // every
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
  };
};

},{"./_array-species-create":26,"./_ctx":36,"./_iobject":58,"./_to-length":126,"./_to-object":127}],24:[function(require,module,exports){
var aFunction = require('./_a-function');
var toObject = require('./_to-object');
var IObject = require('./_iobject');
var toLength = require('./_to-length');

module.exports = function (that, callbackfn, aLen, memo, isRight) {
  aFunction(callbackfn);
  var O = toObject(that);
  var self = IObject(O);
  var length = toLength(O.length);
  var index = isRight ? length - 1 : 0;
  var i = isRight ? -1 : 1;
  if (aLen < 2) for (;;) {
    if (index in self) {
      memo = self[index];
      index += i;
      break;
    }
    index += i;
    if (isRight ? index < 0 : length <= index) {
      throw TypeError('Reduce of empty array with no initial value');
    }
  }
  for (;isRight ? index >= 0 : length > index; index += i) if (index in self) {
    memo = callbackfn(memo, self[index], index, O);
  }
  return memo;
};

},{"./_a-function":14,"./_iobject":58,"./_to-length":126,"./_to-object":127}],25:[function(require,module,exports){
var isObject = require('./_is-object');
var isArray = require('./_is-array');
var SPECIES = require('./_wks')('species');

module.exports = function (original) {
  var C;
  if (isArray(original)) {
    C = original.constructor;
    // cross-realm fallback
    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
    if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  } return C === undefined ? Array : C;
};

},{"./_is-array":60,"./_is-object":62,"./_wks":136}],26:[function(require,module,exports){
// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
var speciesConstructor = require('./_array-species-constructor');

module.exports = function (original, length) {
  return new (speciesConstructor(original))(length);
};

},{"./_array-species-constructor":25}],27:[function(require,module,exports){
'use strict';
var aFunction = require('./_a-function');
var isObject = require('./_is-object');
var invoke = require('./_invoke');
var arraySlice = [].slice;
var factories = {};

var construct = function (F, len, args) {
  if (!(len in factories)) {
    for (var n = [], i = 0; i < len; i++) n[i] = 'a[' + i + ']';
    // eslint-disable-next-line no-new-func
    factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');
  } return factories[len](F, args);
};

module.exports = Function.bind || function bind(that /* , ...args */) {
  var fn = aFunction(this);
  var partArgs = arraySlice.call(arguments, 1);
  var bound = function (/* args... */) {
    var args = partArgs.concat(arraySlice.call(arguments));
    return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that);
  };
  if (isObject(fn.prototype)) bound.prototype = fn.prototype;
  return bound;
};

},{"./_a-function":14,"./_invoke":57,"./_is-object":62}],28:[function(require,module,exports){
// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = require('./_cof');
var TAG = require('./_wks')('toStringTag');
// ES3 wrong here
var ARG = cof(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (e) { /* empty */ }
};

module.exports = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};

},{"./_cof":29,"./_wks":136}],29:[function(require,module,exports){
var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};

},{}],30:[function(require,module,exports){
'use strict';
var dP = require('./_object-dp').f;
var create = require('./_object-create');
var redefineAll = require('./_redefine-all');
var ctx = require('./_ctx');
var anInstance = require('./_an-instance');
var forOf = require('./_for-of');
var $iterDefine = require('./_iter-define');
var step = require('./_iter-step');
var setSpecies = require('./_set-species');
var DESCRIPTORS = require('./_descriptors');
var fastKey = require('./_meta').fastKey;
var validate = require('./_validate-collection');
var SIZE = DESCRIPTORS ? '_s' : 'size';

var getEntry = function (that, key) {
  // fast case
  var index = fastKey(key);
  var entry;
  if (index !== 'F') return that._i[index];
  // frozen object case
  for (entry = that._f; entry; entry = entry.n) {
    if (entry.k == key) return entry;
  }
};

module.exports = {
  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME;         // collection type
      that._i = create(null); // index
      that._f = undefined;    // first entry
      that._l = undefined;    // last entry
      that[SIZE] = 0;         // size
      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear() {
        for (var that = validate(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {
          entry.r = true;
          if (entry.p) entry.p = entry.p.n = undefined;
          delete data[entry.i];
        }
        that._f = that._l = undefined;
        that[SIZE] = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function (key) {
        var that = validate(this, NAME);
        var entry = getEntry(that, key);
        if (entry) {
          var next = entry.n;
          var prev = entry.p;
          delete that._i[entry.i];
          entry.r = true;
          if (prev) prev.n = next;
          if (next) next.p = prev;
          if (that._f == entry) that._f = next;
          if (that._l == entry) that._l = prev;
          that[SIZE]--;
        } return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn /* , that = undefined */) {
        validate(this, NAME);
        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
        var entry;
        while (entry = entry ? entry.n : this._f) {
          f(entry.v, entry.k, this);
          // revert to the last existing entry
          while (entry && entry.r) entry = entry.p;
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key) {
        return !!getEntry(validate(this, NAME), key);
      }
    });
    if (DESCRIPTORS) dP(C.prototype, 'size', {
      get: function () {
        return validate(this, NAME)[SIZE];
      }
    });
    return C;
  },
  def: function (that, key, value) {
    var entry = getEntry(that, key);
    var prev, index;
    // change existing entry
    if (entry) {
      entry.v = value;
    // create new entry
    } else {
      that._l = entry = {
        i: index = fastKey(key, true), // <- index
        k: key,                        // <- key
        v: value,                      // <- value
        p: prev = that._l,             // <- previous entry
        n: undefined,                  // <- next entry
        r: false                       // <- removed
      };
      if (!that._f) that._f = entry;
      if (prev) prev.n = entry;
      that[SIZE]++;
      // add to index
      if (index !== 'F') that._i[index] = entry;
    } return that;
  },
  getEntry: getEntry,
  setStrong: function (C, NAME, IS_MAP) {
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    $iterDefine(C, NAME, function (iterated, kind) {
      this._t = validate(iterated, NAME); // target
      this._k = kind;                     // kind
      this._l = undefined;                // previous
    }, function () {
      var that = this;
      var kind = that._k;
      var entry = that._l;
      // revert to the last existing entry
      while (entry && entry.r) entry = entry.p;
      // get next entry
      if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
        // or finish the iteration
        that._t = undefined;
        return step(1);
      }
      // return step by kind
      if (kind == 'keys') return step(0, entry.k);
      if (kind == 'values') return step(0, entry.v);
      return step(0, [entry.k, entry.v]);
    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);

    // add [@@species], 23.1.2.2, 23.2.2.2
    setSpecies(NAME);
  }
};

},{"./_an-instance":17,"./_ctx":36,"./_descriptors":40,"./_for-of":50,"./_iter-define":66,"./_iter-step":68,"./_meta":76,"./_object-create":81,"./_object-dp":82,"./_redefine-all":101,"./_set-species":108,"./_validate-collection":133}],31:[function(require,module,exports){
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var classof = require('./_classof');
var from = require('./_array-from-iterable');
module.exports = function (NAME) {
  return function toJSON() {
    if (classof(this) != NAME) throw TypeError(NAME + "#toJSON isn't generic");
    return from(this);
  };
};

},{"./_array-from-iterable":21,"./_classof":28}],32:[function(require,module,exports){
'use strict';
var redefineAll = require('./_redefine-all');
var getWeak = require('./_meta').getWeak;
var anObject = require('./_an-object');
var isObject = require('./_is-object');
var anInstance = require('./_an-instance');
var forOf = require('./_for-of');
var createArrayMethod = require('./_array-methods');
var $has = require('./_has');
var validate = require('./_validate-collection');
var arrayFind = createArrayMethod(5);
var arrayFindIndex = createArrayMethod(6);
var id = 0;

// fallback for uncaught frozen keys
var uncaughtFrozenStore = function (that) {
  return that._l || (that._l = new UncaughtFrozenStore());
};
var UncaughtFrozenStore = function () {
  this.a = [];
};
var findUncaughtFrozen = function (store, key) {
  return arrayFind(store.a, function (it) {
    return it[0] === key;
  });
};
UncaughtFrozenStore.prototype = {
  get: function (key) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) return entry[1];
  },
  has: function (key) {
    return !!findUncaughtFrozen(this, key);
  },
  set: function (key, value) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) entry[1] = value;
    else this.a.push([key, value]);
  },
  'delete': function (key) {
    var index = arrayFindIndex(this.a, function (it) {
      return it[0] === key;
    });
    if (~index) this.a.splice(index, 1);
    return !!~index;
  }
};

module.exports = {
  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME;      // collection type
      that._i = id++;      // collection id
      that._l = undefined; // leak store for uncaught frozen objects
      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.3.3.2 WeakMap.prototype.delete(key)
      // 23.4.3.3 WeakSet.prototype.delete(value)
      'delete': function (key) {
        if (!isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(validate(this, NAME))['delete'](key);
        return data && $has(data, this._i) && delete data[this._i];
      },
      // 23.3.3.4 WeakMap.prototype.has(key)
      // 23.4.3.4 WeakSet.prototype.has(value)
      has: function has(key) {
        if (!isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(validate(this, NAME)).has(key);
        return data && $has(data, this._i);
      }
    });
    return C;
  },
  def: function (that, key, value) {
    var data = getWeak(anObject(key), true);
    if (data === true) uncaughtFrozenStore(that).set(key, value);
    else data[that._i] = value;
    return that;
  },
  ufstore: uncaughtFrozenStore
};

},{"./_an-instance":17,"./_an-object":18,"./_array-methods":23,"./_for-of":50,"./_has":52,"./_is-object":62,"./_meta":76,"./_redefine-all":101,"./_validate-collection":133}],33:[function(require,module,exports){
'use strict';
var global = require('./_global');
var $export = require('./_export');
var redefine = require('./_redefine');
var redefineAll = require('./_redefine-all');
var meta = require('./_meta');
var forOf = require('./_for-of');
var anInstance = require('./_an-instance');
var isObject = require('./_is-object');
var fails = require('./_fails');
var $iterDetect = require('./_iter-detect');
var setToStringTag = require('./_set-to-string-tag');
var inheritIfRequired = require('./_inherit-if-required');

module.exports = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
  var Base = global[NAME];
  var C = Base;
  var ADDER = IS_MAP ? 'set' : 'add';
  var proto = C && C.prototype;
  var O = {};
  var fixMethod = function (KEY) {
    var fn = proto[KEY];
    redefine(proto, KEY,
      KEY == 'delete' ? function (a) {
        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'has' ? function has(a) {
        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'get' ? function get(a) {
        return IS_WEAK && !isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'add' ? function add(a) { fn.call(this, a === 0 ? 0 : a); return this; }
        : function set(a, b) { fn.call(this, a === 0 ? 0 : a, b); return this; }
    );
  };
  if (typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function () {
    new C().entries().next();
  }))) {
    // create collection constructor
    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
    redefineAll(C.prototype, methods);
    meta.NEED = true;
  } else {
    var instance = new C();
    // early implementations not supports chaining
    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;
    // V8 ~  Chromium 40- weak-collections throws on primitives, but should return false
    var THROWS_ON_PRIMITIVES = fails(function () { instance.has(1); });
    // most early implementations doesn't supports iterables, most modern - not close it correctly
    var ACCEPT_ITERABLES = $iterDetect(function (iter) { new C(iter); }); // eslint-disable-line no-new
    // for early implementations -0 and +0 not the same
    var BUGGY_ZERO = !IS_WEAK && fails(function () {
      // V8 ~ Chromium 42- fails only with 5+ elements
      var $instance = new C();
      var index = 5;
      while (index--) $instance[ADDER](index, index);
      return !$instance.has(-0);
    });
    if (!ACCEPT_ITERABLES) {
      C = wrapper(function (target, iterable) {
        anInstance(target, C, NAME);
        var that = inheritIfRequired(new Base(), target, C);
        if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
        return that;
      });
      C.prototype = proto;
      proto.constructor = C;
    }
    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
      fixMethod('delete');
      fixMethod('has');
      IS_MAP && fixMethod('get');
    }
    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);
    // weak collections should not contains .clear method
    if (IS_WEAK && proto.clear) delete proto.clear;
  }

  setToStringTag(C, NAME);

  O[NAME] = C;
  $export($export.G + $export.W + $export.F * (C != Base), O);

  if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);

  return C;
};

},{"./_an-instance":17,"./_export":44,"./_fails":46,"./_for-of":50,"./_global":51,"./_inherit-if-required":56,"./_is-object":62,"./_iter-detect":67,"./_meta":76,"./_redefine":102,"./_redefine-all":101,"./_set-to-string-tag":109}],34:[function(require,module,exports){
var core = module.exports = { version: '2.5.1' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef

},{}],35:[function(require,module,exports){
'use strict';
var $defineProperty = require('./_object-dp');
var createDesc = require('./_property-desc');

module.exports = function (object, index, value) {
  if (index in object) $defineProperty.f(object, index, createDesc(0, value));
  else object[index] = value;
};

},{"./_object-dp":82,"./_property-desc":100}],36:[function(require,module,exports){
// optional / simple context binding
var aFunction = require('./_a-function');
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};

},{"./_a-function":14}],37:[function(require,module,exports){
'use strict';
// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()
var fails = require('./_fails');
var getTime = Date.prototype.getTime;
var $toISOString = Date.prototype.toISOString;

var lz = function (num) {
  return num > 9 ? num : '0' + num;
};

// PhantomJS / old WebKit has a broken implementations
module.exports = (fails(function () {
  return $toISOString.call(new Date(-5e13 - 1)) != '0385-07-25T07:06:39.999Z';
}) || !fails(function () {
  $toISOString.call(new Date(NaN));
})) ? function toISOString() {
  if (!isFinite(getTime.call(this))) throw RangeError('Invalid time value');
  var d = this;
  var y = d.getUTCFullYear();
  var m = d.getUTCMilliseconds();
  var s = y < 0 ? '-' : y > 9999 ? '+' : '';
  return s + ('00000' + Math.abs(y)).slice(s ? -6 : -4) +
    '-' + lz(d.getUTCMonth() + 1) + '-' + lz(d.getUTCDate()) +
    'T' + lz(d.getUTCHours()) + ':' + lz(d.getUTCMinutes()) +
    ':' + lz(d.getUTCSeconds()) + '.' + (m > 99 ? m : '0' + lz(m)) + 'Z';
} : $toISOString;

},{"./_fails":46}],38:[function(require,module,exports){
'use strict';
var anObject = require('./_an-object');
var toPrimitive = require('./_to-primitive');
var NUMBER = 'number';

module.exports = function (hint) {
  if (hint !== 'string' && hint !== NUMBER && hint !== 'default') throw TypeError('Incorrect hint');
  return toPrimitive(anObject(this), hint != NUMBER);
};

},{"./_an-object":18,"./_to-primitive":128}],39:[function(require,module,exports){
// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};

},{}],40:[function(require,module,exports){
// Thank's IE8 for his funny defineProperty
module.exports = !require('./_fails')(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});

},{"./_fails":46}],41:[function(require,module,exports){
var isObject = require('./_is-object');
var document = require('./_global').document;
// typeof document.createElement is 'object' in old IE
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};

},{"./_global":51,"./_is-object":62}],42:[function(require,module,exports){
// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');

},{}],43:[function(require,module,exports){
// all enumerable object keys, includes symbols
var getKeys = require('./_object-keys');
var gOPS = require('./_object-gops');
var pIE = require('./_object-pie');
module.exports = function (it) {
  var result = getKeys(it);
  var getSymbols = gOPS.f;
  if (getSymbols) {
    var symbols = getSymbols(it);
    var isEnum = pIE.f;
    var i = 0;
    var key;
    while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);
  } return result;
};

},{"./_object-gops":88,"./_object-keys":91,"./_object-pie":92}],44:[function(require,module,exports){
var global = require('./_global');
var core = require('./_core');
var hide = require('./_hide');
var redefine = require('./_redefine');
var ctx = require('./_ctx');
var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE];
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});
  var key, own, out, exp;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    // export native or passed
    out = (own ? target : source)[key];
    // bind timers to global for call from export context
    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // extend global
    if (target) redefine(target, key, out, type & $export.U);
    // export
    if (exports[key] != out) hide(exports, key, exp);
    if (IS_PROTO && expProto[key] != out) expProto[key] = out;
  }
};
global.core = core;
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;

},{"./_core":34,"./_ctx":36,"./_global":51,"./_hide":53,"./_redefine":102}],45:[function(require,module,exports){
var MATCH = require('./_wks')('match');
module.exports = function (KEY) {
  var re = /./;
  try {
    '/./'[KEY](re);
  } catch (e) {
    try {
      re[MATCH] = false;
      return !'/./'[KEY](re);
    } catch (f) { /* empty */ }
  } return true;
};

},{"./_wks":136}],46:[function(require,module,exports){
module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};

},{}],47:[function(require,module,exports){
'use strict';
var hide = require('./_hide');
var redefine = require('./_redefine');
var fails = require('./_fails');
var defined = require('./_defined');
var wks = require('./_wks');

module.exports = function (KEY, length, exec) {
  var SYMBOL = wks(KEY);
  var fns = exec(defined, SYMBOL, ''[KEY]);
  var strfn = fns[0];
  var rxfn = fns[1];
  if (fails(function () {
    var O = {};
    O[SYMBOL] = function () { return 7; };
    return ''[KEY](O) != 7;
  })) {
    redefine(String.prototype, KEY, strfn);
    hide(RegExp.prototype, SYMBOL, length == 2
      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
      // 21.2.5.11 RegExp.prototype[@@split](string, limit)
      ? function (string, arg) { return rxfn.call(string, this, arg); }
      // 21.2.5.6 RegExp.prototype[@@match](string)
      // 21.2.5.9 RegExp.prototype[@@search](string)
      : function (string) { return rxfn.call(string, this); }
    );
  }
};

},{"./_defined":39,"./_fails":46,"./_hide":53,"./_redefine":102,"./_wks":136}],48:[function(require,module,exports){
'use strict';
// 21.2.5.3 get RegExp.prototype.flags
var anObject = require('./_an-object');
module.exports = function () {
  var that = anObject(this);
  var result = '';
  if (that.global) result += 'g';
  if (that.ignoreCase) result += 'i';
  if (that.multiline) result += 'm';
  if (that.unicode) result += 'u';
  if (that.sticky) result += 'y';
  return result;
};

},{"./_an-object":18}],49:[function(require,module,exports){
'use strict';
// https://tc39.github.io/proposal-flatMap/#sec-FlattenIntoArray
var isArray = require('./_is-array');
var isObject = require('./_is-object');
var toLength = require('./_to-length');
var ctx = require('./_ctx');
var IS_CONCAT_SPREADABLE = require('./_wks')('isConcatSpreadable');

function flattenIntoArray(target, original, source, sourceLen, start, depth, mapper, thisArg) {
  var targetIndex = start;
  var sourceIndex = 0;
  var mapFn = mapper ? ctx(mapper, thisArg, 3) : false;
  var element, spreadable;

  while (sourceIndex < sourceLen) {
    if (sourceIndex in source) {
      element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];

      spreadable = false;
      if (isObject(element)) {
        spreadable = element[IS_CONCAT_SPREADABLE];
        spreadable = spreadable !== undefined ? !!spreadable : isArray(element);
      }

      if (spreadable && depth > 0) {
        targetIndex = flattenIntoArray(target, original, element, toLength(element.length), targetIndex, depth - 1) - 1;
      } else {
        if (targetIndex >= 0x1fffffffffffff) throw TypeError();
        target[targetIndex] = element;
      }

      targetIndex++;
    }
    sourceIndex++;
  }
  return targetIndex;
}

module.exports = flattenIntoArray;

},{"./_ctx":36,"./_is-array":60,"./_is-object":62,"./_to-length":126,"./_wks":136}],50:[function(require,module,exports){
var ctx = require('./_ctx');
var call = require('./_iter-call');
var isArrayIter = require('./_is-array-iter');
var anObject = require('./_an-object');
var toLength = require('./_to-length');
var getIterFn = require('./core.get-iterator-method');
var BREAK = {};
var RETURN = {};
var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
  var iterFn = ITERATOR ? function () { return iterable; } : getIterFn(iterable);
  var f = ctx(fn, that, entries ? 2 : 1);
  var index = 0;
  var length, step, iterator, result;
  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
  // fast case for arrays with default iterator
  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
    if (result === BREAK || result === RETURN) return result;
  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
    result = call(iterator, f, step.value, entries);
    if (result === BREAK || result === RETURN) return result;
  }
};
exports.BREAK = BREAK;
exports.RETURN = RETURN;

},{"./_an-object":18,"./_ctx":36,"./_is-array-iter":59,"./_iter-call":64,"./_to-length":126,"./core.get-iterator-method":137}],51:[function(require,module,exports){
// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef

},{}],52:[function(require,module,exports){
var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};

},{}],53:[function(require,module,exports){
var dP = require('./_object-dp');
var createDesc = require('./_property-desc');
module.exports = require('./_descriptors') ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};

},{"./_descriptors":40,"./_object-dp":82,"./_property-desc":100}],54:[function(require,module,exports){
var document = require('./_global').document;
module.exports = document && document.documentElement;

},{"./_global":51}],55:[function(require,module,exports){
module.exports = !require('./_descriptors') && !require('./_fails')(function () {
  return Object.defineProperty(require('./_dom-create')('div'), 'a', { get: function () { return 7; } }).a != 7;
});

},{"./_descriptors":40,"./_dom-create":41,"./_fails":46}],56:[function(require,module,exports){
var isObject = require('./_is-object');
var setPrototypeOf = require('./_set-proto').set;
module.exports = function (that, target, C) {
  var S = target.constructor;
  var P;
  if (S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf) {
    setPrototypeOf(that, P);
  } return that;
};

},{"./_is-object":62,"./_set-proto":107}],57:[function(require,module,exports){
// fast apply, http://jsperf.lnkit.com/fast-apply/5
module.exports = function (fn, args, that) {
  var un = that === undefined;
  switch (args.length) {
    case 0: return un ? fn()
                      : fn.call(that);
    case 1: return un ? fn(args[0])
                      : fn.call(that, args[0]);
    case 2: return un ? fn(args[0], args[1])
                      : fn.call(that, args[0], args[1]);
    case 3: return un ? fn(args[0], args[1], args[2])
                      : fn.call(that, args[0], args[1], args[2]);
    case 4: return un ? fn(args[0], args[1], args[2], args[3])
                      : fn.call(that, args[0], args[1], args[2], args[3]);
  } return fn.apply(that, args);
};

},{}],58:[function(require,module,exports){
// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = require('./_cof');
// eslint-disable-next-line no-prototype-builtins
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};

},{"./_cof":29}],59:[function(require,module,exports){
// check on default Array iterator
var Iterators = require('./_iterators');
var ITERATOR = require('./_wks')('iterator');
var ArrayProto = Array.prototype;

module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};

},{"./_iterators":69,"./_wks":136}],60:[function(require,module,exports){
// 7.2.2 IsArray(argument)
var cof = require('./_cof');
module.exports = Array.isArray || function isArray(arg) {
  return cof(arg) == 'Array';
};

},{"./_cof":29}],61:[function(require,module,exports){
// 20.1.2.3 Number.isInteger(number)
var isObject = require('./_is-object');
var floor = Math.floor;
module.exports = function isInteger(it) {
  return !isObject(it) && isFinite(it) && floor(it) === it;
};

},{"./_is-object":62}],62:[function(require,module,exports){
module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};

},{}],63:[function(require,module,exports){
// 7.2.8 IsRegExp(argument)
var isObject = require('./_is-object');
var cof = require('./_cof');
var MATCH = require('./_wks')('match');
module.exports = function (it) {
  var isRegExp;
  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');
};

},{"./_cof":29,"./_is-object":62,"./_wks":136}],64:[function(require,module,exports){
// call something on iterator step with safe closing on error
var anObject = require('./_an-object');
module.exports = function (iterator, fn, value, entries) {
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch (e) {
    var ret = iterator['return'];
    if (ret !== undefined) anObject(ret.call(iterator));
    throw e;
  }
};

},{"./_an-object":18}],65:[function(require,module,exports){
'use strict';
var create = require('./_object-create');
var descriptor = require('./_property-desc');
var setToStringTag = require('./_set-to-string-tag');
var IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
require('./_hide')(IteratorPrototype, require('./_wks')('iterator'), function () { return this; });

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
  setToStringTag(Constructor, NAME + ' Iterator');
};

},{"./_hide":53,"./_object-create":81,"./_property-desc":100,"./_set-to-string-tag":109,"./_wks":136}],66:[function(require,module,exports){
'use strict';
var LIBRARY = require('./_library');
var $export = require('./_export');
var redefine = require('./_redefine');
var hide = require('./_hide');
var has = require('./_has');
var Iterators = require('./_iterators');
var $iterCreate = require('./_iter-create');
var setToStringTag = require('./_set-to-string-tag');
var getPrototypeOf = require('./_object-gpo');
var ITERATOR = require('./_wks')('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function () { return this; };

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);
  var getMethod = function (kind) {
    if (!BUGGY && kind in proto) return proto[kind];
    switch (kind) {
      case KEYS: return function keys() { return new Constructor(this, kind); };
      case VALUES: return function values() { return new Constructor(this, kind); };
    } return function entries() { return new Constructor(this, kind); };
  };
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  // Fix native
  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if (!LIBRARY && !has(IteratorPrototype, ITERATOR)) hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;
    $default = function values() { return $native.call(this); };
  }
  // Define iterator
  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;
  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};

},{"./_export":44,"./_has":52,"./_hide":53,"./_iter-create":65,"./_iterators":69,"./_library":70,"./_object-gpo":89,"./_redefine":102,"./_set-to-string-tag":109,"./_wks":136}],67:[function(require,module,exports){
var ITERATOR = require('./_wks')('iterator');
var SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();
  riter['return'] = function () { SAFE_CLOSING = true; };
  // eslint-disable-next-line no-throw-literal
  Array.from(riter, function () { throw 2; });
} catch (e) { /* empty */ }

module.exports = function (exec, skipClosing) {
  if (!skipClosing && !SAFE_CLOSING) return false;
  var safe = false;
  try {
    var arr = [7];
    var iter = arr[ITERATOR]();
    iter.next = function () { return { done: safe = true }; };
    arr[ITERATOR] = function () { return iter; };
    exec(arr);
  } catch (e) { /* empty */ }
  return safe;
};

},{"./_wks":136}],68:[function(require,module,exports){
module.exports = function (done, value) {
  return { value: value, done: !!done };
};

},{}],69:[function(require,module,exports){
module.exports = {};

},{}],70:[function(require,module,exports){
module.exports = false;

},{}],71:[function(require,module,exports){
// 20.2.2.14 Math.expm1(x)
var $expm1 = Math.expm1;
module.exports = (!$expm1
  // Old FF bug
  || $expm1(10) > 22025.465794806719 || $expm1(10) < 22025.4657948067165168
  // Tor Browser bug
  || $expm1(-2e-17) != -2e-17
) ? function expm1(x) {
  return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : Math.exp(x) - 1;
} : $expm1;

},{}],72:[function(require,module,exports){
// 20.2.2.16 Math.fround(x)
var sign = require('./_math-sign');
var pow = Math.pow;
var EPSILON = pow(2, -52);
var EPSILON32 = pow(2, -23);
var MAX32 = pow(2, 127) * (2 - EPSILON32);
var MIN32 = pow(2, -126);

var roundTiesToEven = function (n) {
  return n + 1 / EPSILON - 1 / EPSILON;
};

module.exports = Math.fround || function fround(x) {
  var $abs = Math.abs(x);
  var $sign = sign(x);
  var a, result;
  if ($abs < MIN32) return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
  a = (1 + EPSILON32 / EPSILON) * $abs;
  result = a - (a - $abs);
  // eslint-disable-next-line no-self-compare
  if (result > MAX32 || result != result) return $sign * Infinity;
  return $sign * result;
};

},{"./_math-sign":75}],73:[function(require,module,exports){
// 20.2.2.20 Math.log1p(x)
module.exports = Math.log1p || function log1p(x) {
  return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : Math.log(1 + x);
};

},{}],74:[function(require,module,exports){
// https://rwaldron.github.io/proposal-math-extensions/
module.exports = Math.scale || function scale(x, inLow, inHigh, outLow, outHigh) {
  if (
    arguments.length === 0
      // eslint-disable-next-line no-self-compare
      || x != x
      // eslint-disable-next-line no-self-compare
      || inLow != inLow
      // eslint-disable-next-line no-self-compare
      || inHigh != inHigh
      // eslint-disable-next-line no-self-compare
      || outLow != outLow
      // eslint-disable-next-line no-self-compare
      || outHigh != outHigh
  ) return NaN;
  if (x === Infinity || x === -Infinity) return x;
  return (x - inLow) * (outHigh - outLow) / (inHigh - inLow) + outLow;
};

},{}],75:[function(require,module,exports){
// 20.2.2.28 Math.sign(x)
module.exports = Math.sign || function sign(x) {
  // eslint-disable-next-line no-self-compare
  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
};

},{}],76:[function(require,module,exports){
var META = require('./_uid')('meta');
var isObject = require('./_is-object');
var has = require('./_has');
var setDesc = require('./_object-dp').f;
var id = 0;
var isExtensible = Object.isExtensible || function () {
  return true;
};
var FREEZE = !require('./_fails')(function () {
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function (it) {
  setDesc(it, META, { value: {
    i: 'O' + ++id, // object ID
    w: {}          // weak collections IDs
  } });
};
var fastKey = function (it, create) {
  // return primitive with prefix
  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F';
    // not necessary to add metadata
    if (!create) return 'E';
    // add missing metadata
    setMeta(it);
  // return object ID
  } return it[META].i;
};
var getWeak = function (it, create) {
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true;
    // not necessary to add metadata
    if (!create) return false;
    // add missing metadata
    setMeta(it);
  // return hash weak collections IDs
  } return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function (it) {
  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY: META,
  NEED: false,
  fastKey: fastKey,
  getWeak: getWeak,
  onFreeze: onFreeze
};

},{"./_fails":46,"./_has":52,"./_is-object":62,"./_object-dp":82,"./_uid":132}],77:[function(require,module,exports){
var Map = require('./es6.map');
var $export = require('./_export');
var shared = require('./_shared')('metadata');
var store = shared.store || (shared.store = new (require('./es6.weak-map'))());

var getOrCreateMetadataMap = function (target, targetKey, create) {
  var targetMetadata = store.get(target);
  if (!targetMetadata) {
    if (!create) return undefined;
    store.set(target, targetMetadata = new Map());
  }
  var keyMetadata = targetMetadata.get(targetKey);
  if (!keyMetadata) {
    if (!create) return undefined;
    targetMetadata.set(targetKey, keyMetadata = new Map());
  } return keyMetadata;
};
var ordinaryHasOwnMetadata = function (MetadataKey, O, P) {
  var metadataMap = getOrCreateMetadataMap(O, P, false);
  return metadataMap === undefined ? false : metadataMap.has(MetadataKey);
};
var ordinaryGetOwnMetadata = function (MetadataKey, O, P) {
  var metadataMap = getOrCreateMetadataMap(O, P, false);
  return metadataMap === undefined ? undefined : metadataMap.get(MetadataKey);
};
var ordinaryDefineOwnMetadata = function (MetadataKey, MetadataValue, O, P) {
  getOrCreateMetadataMap(O, P, true).set(MetadataKey, MetadataValue);
};
var ordinaryOwnMetadataKeys = function (target, targetKey) {
  var metadataMap = getOrCreateMetadataMap(target, targetKey, false);
  var keys = [];
  if (metadataMap) metadataMap.forEach(function (_, key) { keys.push(key); });
  return keys;
};
var toMetaKey = function (it) {
  return it === undefined || typeof it == 'symbol' ? it : String(it);
};
var exp = function (O) {
  $export($export.S, 'Reflect', O);
};

module.exports = {
  store: store,
  map: getOrCreateMetadataMap,
  has: ordinaryHasOwnMetadata,
  get: ordinaryGetOwnMetadata,
  set: ordinaryDefineOwnMetadata,
  keys: ordinaryOwnMetadataKeys,
  key: toMetaKey,
  exp: exp
};

},{"./_export":44,"./_shared":111,"./es6.map":168,"./es6.weak-map":274}],78:[function(require,module,exports){
var global = require('./_global');
var macrotask = require('./_task').set;
var Observer = global.MutationObserver || global.WebKitMutationObserver;
var process = global.process;
var Promise = global.Promise;
var isNode = require('./_cof')(process) == 'process';

module.exports = function () {
  var head, last, notify;

  var flush = function () {
    var parent, fn;
    if (isNode && (parent = process.domain)) parent.exit();
    while (head) {
      fn = head.fn;
      head = head.next;
      try {
        fn();
      } catch (e) {
        if (head) notify();
        else last = undefined;
        throw e;
      }
    } last = undefined;
    if (parent) parent.enter();
  };

  // Node.js
  if (isNode) {
    notify = function () {
      process.nextTick(flush);
    };
  // browsers with MutationObserver
  } else if (Observer) {
    var toggle = true;
    var node = document.createTextNode('');
    new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new
    notify = function () {
      node.data = toggle = !toggle;
    };
  // environments with maybe non-completely correct, but existent Promise
  } else if (Promise && Promise.resolve) {
    var promise = Promise.resolve();
    notify = function () {
      promise.then(flush);
    };
  // for other environments - macrotask based on:
  // - setImmediate
  // - MessageChannel
  // - window.postMessag
  // - onreadystatechange
  // - setTimeout
  } else {
    notify = function () {
      // strange IE + webpack dev server bug - use .call(global)
      macrotask.call(global, flush);
    };
  }

  return function (fn) {
    var task = { fn: fn, next: undefined };
    if (last) last.next = task;
    if (!head) {
      head = task;
      notify();
    } last = task;
  };
};

},{"./_cof":29,"./_global":51,"./_task":121}],79:[function(require,module,exports){
'use strict';
// 25.4.1.5 NewPromiseCapability(C)
var aFunction = require('./_a-function');

function PromiseCapability(C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject = $$reject;
  });
  this.resolve = aFunction(resolve);
  this.reject = aFunction(reject);
}

module.exports.f = function (C) {
  return new PromiseCapability(C);
};

},{"./_a-function":14}],80:[function(require,module,exports){
'use strict';
// 19.1.2.1 Object.assign(target, source, ...)
var getKeys = require('./_object-keys');
var gOPS = require('./_object-gops');
var pIE = require('./_object-pie');
var toObject = require('./_to-object');
var IObject = require('./_iobject');
var $assign = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = !$assign || require('./_fails')(function () {
  var A = {};
  var B = {};
  // eslint-disable-next-line no-undef
  var S = Symbol();
  var K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function (k) { B[k] = k; });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source) { // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var aLen = arguments.length;
  var index = 1;
  var getSymbols = gOPS.f;
  var isEnum = pIE.f;
  while (aLen > index) {
    var S = IObject(arguments[index++]);
    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) if (isEnum.call(S, key = keys[j++])) T[key] = S[key];
  } return T;
} : $assign;

},{"./_fails":46,"./_iobject":58,"./_object-gops":88,"./_object-keys":91,"./_object-pie":92,"./_to-object":127}],81:[function(require,module,exports){
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = require('./_an-object');
var dPs = require('./_object-dps');
var enumBugKeys = require('./_enum-bug-keys');
var IE_PROTO = require('./_shared-key')('IE_PROTO');
var Empty = function () { /* empty */ };
var PROTOTYPE = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = require('./_dom-create')('iframe');
  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';
  require('./_html').appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};

},{"./_an-object":18,"./_dom-create":41,"./_enum-bug-keys":42,"./_html":54,"./_object-dps":83,"./_shared-key":110}],82:[function(require,module,exports){
var anObject = require('./_an-object');
var IE8_DOM_DEFINE = require('./_ie8-dom-define');
var toPrimitive = require('./_to-primitive');
var dP = Object.defineProperty;

exports.f = require('./_descriptors') ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};

},{"./_an-object":18,"./_descriptors":40,"./_ie8-dom-define":55,"./_to-primitive":128}],83:[function(require,module,exports){
var dP = require('./_object-dp');
var anObject = require('./_an-object');
var getKeys = require('./_object-keys');

module.exports = require('./_descriptors') ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;
  while (length > i) dP.f(O, P = keys[i++], Properties[P]);
  return O;
};

},{"./_an-object":18,"./_descriptors":40,"./_object-dp":82,"./_object-keys":91}],84:[function(require,module,exports){
'use strict';
// Forced replacement prototype accessors methods
module.exports = require('./_library') || !require('./_fails')(function () {
  var K = Math.random();
  // In FF throws only define methods
  // eslint-disable-next-line no-undef, no-useless-call
  __defineSetter__.call(null, K, function () { /* empty */ });
  delete require('./_global')[K];
});

},{"./_fails":46,"./_global":51,"./_library":70}],85:[function(require,module,exports){
var pIE = require('./_object-pie');
var createDesc = require('./_property-desc');
var toIObject = require('./_to-iobject');
var toPrimitive = require('./_to-primitive');
var has = require('./_has');
var IE8_DOM_DEFINE = require('./_ie8-dom-define');
var gOPD = Object.getOwnPropertyDescriptor;

exports.f = require('./_descriptors') ? gOPD : function getOwnPropertyDescriptor(O, P) {
  O = toIObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return gOPD(O, P);
  } catch (e) { /* empty */ }
  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
};

},{"./_descriptors":40,"./_has":52,"./_ie8-dom-define":55,"./_object-pie":92,"./_property-desc":100,"./_to-iobject":125,"./_to-primitive":128}],86:[function(require,module,exports){
// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = require('./_to-iobject');
var gOPN = require('./_object-gopn').f;
var toString = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return gOPN(it);
  } catch (e) {
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};

},{"./_object-gopn":87,"./_to-iobject":125}],87:[function(require,module,exports){
// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys = require('./_object-keys-internal');
var hiddenKeys = require('./_enum-bug-keys').concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return $keys(O, hiddenKeys);
};

},{"./_enum-bug-keys":42,"./_object-keys-internal":90}],88:[function(require,module,exports){
exports.f = Object.getOwnPropertySymbols;

},{}],89:[function(require,module,exports){
// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = require('./_has');
var toObject = require('./_to-object');
var IE_PROTO = require('./_shared-key')('IE_PROTO');
var ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};

},{"./_has":52,"./_shared-key":110,"./_to-object":127}],90:[function(require,module,exports){
var has = require('./_has');
var toIObject = require('./_to-iobject');
var arrayIndexOf = require('./_array-includes')(false);
var IE_PROTO = require('./_shared-key')('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};

},{"./_array-includes":22,"./_has":52,"./_shared-key":110,"./_to-iobject":125}],91:[function(require,module,exports){
// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = require('./_object-keys-internal');
var enumBugKeys = require('./_enum-bug-keys');

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};

},{"./_enum-bug-keys":42,"./_object-keys-internal":90}],92:[function(require,module,exports){
exports.f = {}.propertyIsEnumerable;

},{}],93:[function(require,module,exports){
// most Object methods by ES6 should accept primitives
var $export = require('./_export');
var core = require('./_core');
var fails = require('./_fails');
module.exports = function (KEY, exec) {
  var fn = (core.Object || {})[KEY] || Object[KEY];
  var exp = {};
  exp[KEY] = exec(fn);
  $export($export.S + $export.F * fails(function () { fn(1); }), 'Object', exp);
};

},{"./_core":34,"./_export":44,"./_fails":46}],94:[function(require,module,exports){
var getKeys = require('./_object-keys');
var toIObject = require('./_to-iobject');
var isEnum = require('./_object-pie').f;
module.exports = function (isEntries) {
  return function (it) {
    var O = toIObject(it);
    var keys = getKeys(O);
    var length = keys.length;
    var i = 0;
    var result = [];
    var key;
    while (length > i) if (isEnum.call(O, key = keys[i++])) {
      result.push(isEntries ? [key, O[key]] : O[key]);
    } return result;
  };
};

},{"./_object-keys":91,"./_object-pie":92,"./_to-iobject":125}],95:[function(require,module,exports){
// all object keys, includes non-enumerable and symbols
var gOPN = require('./_object-gopn');
var gOPS = require('./_object-gops');
var anObject = require('./_an-object');
var Reflect = require('./_global').Reflect;
module.exports = Reflect && Reflect.ownKeys || function ownKeys(it) {
  var keys = gOPN.f(anObject(it));
  var getSymbols = gOPS.f;
  return getSymbols ? keys.concat(getSymbols(it)) : keys;
};

},{"./_an-object":18,"./_global":51,"./_object-gopn":87,"./_object-gops":88}],96:[function(require,module,exports){
var $parseFloat = require('./_global').parseFloat;
var $trim = require('./_string-trim').trim;

module.exports = 1 / $parseFloat(require('./_string-ws') + '-0') !== -Infinity ? function parseFloat(str) {
  var string = $trim(String(str), 3);
  var result = $parseFloat(string);
  return result === 0 && string.charAt(0) == '-' ? -0 : result;
} : $parseFloat;

},{"./_global":51,"./_string-trim":119,"./_string-ws":120}],97:[function(require,module,exports){
var $parseInt = require('./_global').parseInt;
var $trim = require('./_string-trim').trim;
var ws = require('./_string-ws');
var hex = /^[-+]?0[xX]/;

module.exports = $parseInt(ws + '08') !== 8 || $parseInt(ws + '0x16') !== 22 ? function parseInt(str, radix) {
  var string = $trim(String(str), 3);
  return $parseInt(string, (radix >>> 0) || (hex.test(string) ? 16 : 10));
} : $parseInt;

},{"./_global":51,"./_string-trim":119,"./_string-ws":120}],98:[function(require,module,exports){
module.exports = function (exec) {
  try {
    return { e: false, v: exec() };
  } catch (e) {
    return { e: true, v: e };
  }
};

},{}],99:[function(require,module,exports){
var anObject = require('./_an-object');
var isObject = require('./_is-object');
var newPromiseCapability = require('./_new-promise-capability');

module.exports = function (C, x) {
  anObject(C);
  if (isObject(x) && x.constructor === C) return x;
  var promiseCapability = newPromiseCapability.f(C);
  var resolve = promiseCapability.resolve;
  resolve(x);
  return promiseCapability.promise;
};

},{"./_an-object":18,"./_is-object":62,"./_new-promise-capability":79}],100:[function(require,module,exports){
module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};

},{}],101:[function(require,module,exports){
var redefine = require('./_redefine');
module.exports = function (target, src, safe) {
  for (var key in src) redefine(target, key, src[key], safe);
  return target;
};

},{"./_redefine":102}],102:[function(require,module,exports){
var global = require('./_global');
var hide = require('./_hide');
var has = require('./_has');
var SRC = require('./_uid')('src');
var TO_STRING = 'toString';
var $toString = Function[TO_STRING];
var TPL = ('' + $toString).split(TO_STRING);

require('./_core').inspectSource = function (it) {
  return $toString.call(it);
};

(module.exports = function (O, key, val, safe) {
  var isFunction = typeof val == 'function';
  if (isFunction) has(val, 'name') || hide(val, 'name', key);
  if (O[key] === val) return;
  if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
  if (O === global) {
    O[key] = val;
  } else if (!safe) {
    delete O[key];
    hide(O, key, val);
  } else if (O[key]) {
    O[key] = val;
  } else {
    hide(O, key, val);
  }
// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, TO_STRING, function toString() {
  return typeof this == 'function' && this[SRC] || $toString.call(this);
});

},{"./_core":34,"./_global":51,"./_has":52,"./_hide":53,"./_uid":132}],103:[function(require,module,exports){
module.exports = function (regExp, replace) {
  var replacer = replace === Object(replace) ? function (part) {
    return replace[part];
  } : replace;
  return function (it) {
    return String(it).replace(regExp, replacer);
  };
};

},{}],104:[function(require,module,exports){
// 7.2.9 SameValue(x, y)
module.exports = Object.is || function is(x, y) {
  // eslint-disable-next-line no-self-compare
  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
};

},{}],105:[function(require,module,exports){
'use strict';
// https://tc39.github.io/proposal-setmap-offrom/
var $export = require('./_export');
var aFunction = require('./_a-function');
var ctx = require('./_ctx');
var forOf = require('./_for-of');

module.exports = function (COLLECTION) {
  $export($export.S, COLLECTION, { from: function from(source /* , mapFn, thisArg */) {
    var mapFn = arguments[1];
    var mapping, A, n, cb;
    aFunction(this);
    mapping = mapFn !== undefined;
    if (mapping) aFunction(mapFn);
    if (source == undefined) return new this();
    A = [];
    if (mapping) {
      n = 0;
      cb = ctx(mapFn, arguments[2], 2);
      forOf(source, false, function (nextItem) {
        A.push(cb(nextItem, n++));
      });
    } else {
      forOf(source, false, A.push, A);
    }
    return new this(A);
  } });
};

},{"./_a-function":14,"./_ctx":36,"./_export":44,"./_for-of":50}],106:[function(require,module,exports){
'use strict';
// https://tc39.github.io/proposal-setmap-offrom/
var $export = require('./_export');

module.exports = function (COLLECTION) {
  $export($export.S, COLLECTION, { of: function of() {
    var length = arguments.length;
    var A = Array(length);
    while (length--) A[length] = arguments[length];
    return new this(A);
  } });
};

},{"./_export":44}],107:[function(require,module,exports){
// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var isObject = require('./_is-object');
var anObject = require('./_an-object');
var check = function (O, proto) {
  anObject(O);
  if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
};
module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
    function (test, buggy, set) {
      try {
        set = require('./_ctx')(Function.call, require('./_object-gopd').f(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch (e) { buggy = true; }
      return function setPrototypeOf(O, proto) {
        check(O, proto);
        if (buggy) O.__proto__ = proto;
        else set(O, proto);
        return O;
      };
    }({}, false) : undefined),
  check: check
};

},{"./_an-object":18,"./_ctx":36,"./_is-object":62,"./_object-gopd":85}],108:[function(require,module,exports){
'use strict';
var global = require('./_global');
var dP = require('./_object-dp');
var DESCRIPTORS = require('./_descriptors');
var SPECIES = require('./_wks')('species');

module.exports = function (KEY) {
  var C = global[KEY];
  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
    configurable: true,
    get: function () { return this; }
  });
};

},{"./_descriptors":40,"./_global":51,"./_object-dp":82,"./_wks":136}],109:[function(require,module,exports){
var def = require('./_object-dp').f;
var has = require('./_has');
var TAG = require('./_wks')('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
};

},{"./_has":52,"./_object-dp":82,"./_wks":136}],110:[function(require,module,exports){
var shared = require('./_shared')('keys');
var uid = require('./_uid');
module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};

},{"./_shared":111,"./_uid":132}],111:[function(require,module,exports){
var global = require('./_global');
var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});
module.exports = function (key) {
  return store[key] || (store[key] = {});
};

},{"./_global":51}],112:[function(require,module,exports){
// 7.3.20 SpeciesConstructor(O, defaultConstructor)
var anObject = require('./_an-object');
var aFunction = require('./_a-function');
var SPECIES = require('./_wks')('species');
module.exports = function (O, D) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
};

},{"./_a-function":14,"./_an-object":18,"./_wks":136}],113:[function(require,module,exports){
'use strict';
var fails = require('./_fails');

module.exports = function (method, arg) {
  return !!method && fails(function () {
    // eslint-disable-next-line no-useless-call
    arg ? method.call(null, function () { /* empty */ }, 1) : method.call(null);
  });
};

},{"./_fails":46}],114:[function(require,module,exports){
var toInteger = require('./_to-integer');
var defined = require('./_defined');
// true  -> String#at
// false -> String#codePointAt
module.exports = function (TO_STRING) {
  return function (that, pos) {
    var s = String(defined(that));
    var i = toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};

},{"./_defined":39,"./_to-integer":124}],115:[function(require,module,exports){
// helper for String#{startsWith, endsWith, includes}
var isRegExp = require('./_is-regexp');
var defined = require('./_defined');

module.exports = function (that, searchString, NAME) {
  if (isRegExp(searchString)) throw TypeError('String#' + NAME + " doesn't accept regex!");
  return String(defined(that));
};

},{"./_defined":39,"./_is-regexp":63}],116:[function(require,module,exports){
var $export = require('./_export');
var fails = require('./_fails');
var defined = require('./_defined');
var quot = /"/g;
// B.2.3.2.1 CreateHTML(string, tag, attribute, value)
var createHTML = function (string, tag, attribute, value) {
  var S = String(defined(string));
  var p1 = '<' + tag;
  if (attribute !== '') p1 += ' ' + attribute + '="' + String(value).replace(quot, '&quot;') + '"';
  return p1 + '>' + S + '</' + tag + '>';
};
module.exports = function (NAME, exec) {
  var O = {};
  O[NAME] = exec(createHTML);
  $export($export.P + $export.F * fails(function () {
    var test = ''[NAME]('"');
    return test !== test.toLowerCase() || test.split('"').length > 3;
  }), 'String', O);
};

},{"./_defined":39,"./_export":44,"./_fails":46}],117:[function(require,module,exports){
// https://github.com/tc39/proposal-string-pad-start-end
var toLength = require('./_to-length');
var repeat = require('./_string-repeat');
var defined = require('./_defined');

module.exports = function (that, maxLength, fillString, left) {
  var S = String(defined(that));
  var stringLength = S.length;
  var fillStr = fillString === undefined ? ' ' : String(fillString);
  var intMaxLength = toLength(maxLength);
  if (intMaxLength <= stringLength || fillStr == '') return S;
  var fillLen = intMaxLength - stringLength;
  var stringFiller = repeat.call(fillStr, Math.ceil(fillLen / fillStr.length));
  if (stringFiller.length > fillLen) stringFiller = stringFiller.slice(0, fillLen);
  return left ? stringFiller + S : S + stringFiller;
};

},{"./_defined":39,"./_string-repeat":118,"./_to-length":126}],118:[function(require,module,exports){
'use strict';
var toInteger = require('./_to-integer');
var defined = require('./_defined');

module.exports = function repeat(count) {
  var str = String(defined(this));
  var res = '';
  var n = toInteger(count);
  if (n < 0 || n == Infinity) throw RangeError("Count can't be negative");
  for (;n > 0; (n >>>= 1) && (str += str)) if (n & 1) res += str;
  return res;
};

},{"./_defined":39,"./_to-integer":124}],119:[function(require,module,exports){
var $export = require('./_export');
var defined = require('./_defined');
var fails = require('./_fails');
var spaces = require('./_string-ws');
var space = '[' + spaces + ']';
var non = '\u200b\u0085';
var ltrim = RegExp('^' + space + space + '*');
var rtrim = RegExp(space + space + '*$');

var exporter = function (KEY, exec, ALIAS) {
  var exp = {};
  var FORCE = fails(function () {
    return !!spaces[KEY]() || non[KEY]() != non;
  });
  var fn = exp[KEY] = FORCE ? exec(trim) : spaces[KEY];
  if (ALIAS) exp[ALIAS] = fn;
  $export($export.P + $export.F * FORCE, 'String', exp);
};

// 1 -> String#trimLeft
// 2 -> String#trimRight
// 3 -> String#trim
var trim = exporter.trim = function (string, TYPE) {
  string = String(defined(string));
  if (TYPE & 1) string = string.replace(ltrim, '');
  if (TYPE & 2) string = string.replace(rtrim, '');
  return string;
};

module.exports = exporter;

},{"./_defined":39,"./_export":44,"./_fails":46,"./_string-ws":120}],120:[function(require,module,exports){
module.exports = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' +
  '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';

},{}],121:[function(require,module,exports){
var ctx = require('./_ctx');
var invoke = require('./_invoke');
var html = require('./_html');
var cel = require('./_dom-create');
var global = require('./_global');
var process = global.process;
var setTask = global.setImmediate;
var clearTask = global.clearImmediate;
var MessageChannel = global.MessageChannel;
var Dispatch = global.Dispatch;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var defer, channel, port;
var run = function () {
  var id = +this;
  // eslint-disable-next-line no-prototype-builtins
  if (queue.hasOwnProperty(id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};
var listener = function (event) {
  run.call(event.data);
};
// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if (!setTask || !clearTask) {
  setTask = function setImmediate(fn) {
    var args = [];
    var i = 1;
    while (arguments.length > i) args.push(arguments[i++]);
    queue[++counter] = function () {
      // eslint-disable-next-line no-new-func
      invoke(typeof fn == 'function' ? fn : Function(fn), args);
    };
    defer(counter);
    return counter;
  };
  clearTask = function clearImmediate(id) {
    delete queue[id];
  };
  // Node.js 0.8-
  if (require('./_cof')(process) == 'process') {
    defer = function (id) {
      process.nextTick(ctx(run, id, 1));
    };
  // Sphere (JS game engine) Dispatch API
  } else if (Dispatch && Dispatch.now) {
    defer = function (id) {
      Dispatch.now(ctx(run, id, 1));
    };
  // Browsers with MessageChannel, includes WebWorkers
  } else if (MessageChannel) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = ctx(port.postMessage, port, 1);
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
    defer = function (id) {
      global.postMessage(id + '', '*');
    };
    global.addEventListener('message', listener, false);
  // IE8-
  } else if (ONREADYSTATECHANGE in cel('script')) {
    defer = function (id) {
      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {
        html.removeChild(this);
        run.call(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function (id) {
      setTimeout(ctx(run, id, 1), 0);
    };
  }
}
module.exports = {
  set: setTask,
  clear: clearTask
};

},{"./_cof":29,"./_ctx":36,"./_dom-create":41,"./_global":51,"./_html":54,"./_invoke":57}],122:[function(require,module,exports){
var toInteger = require('./_to-integer');
var max = Math.max;
var min = Math.min;
module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};

},{"./_to-integer":124}],123:[function(require,module,exports){
// https://tc39.github.io/ecma262/#sec-toindex
var toInteger = require('./_to-integer');
var toLength = require('./_to-length');
module.exports = function (it) {
  if (it === undefined) return 0;
  var number = toInteger(it);
  var length = toLength(number);
  if (number !== length) throw RangeError('Wrong length!');
  return length;
};

},{"./_to-integer":124,"./_to-length":126}],124:[function(require,module,exports){
// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};

},{}],125:[function(require,module,exports){
// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = require('./_iobject');
var defined = require('./_defined');
module.exports = function (it) {
  return IObject(defined(it));
};

},{"./_defined":39,"./_iobject":58}],126:[function(require,module,exports){
// 7.1.15 ToLength
var toInteger = require('./_to-integer');
var min = Math.min;
module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};

},{"./_to-integer":124}],127:[function(require,module,exports){
// 7.1.13 ToObject(argument)
var defined = require('./_defined');
module.exports = function (it) {
  return Object(defined(it));
};

},{"./_defined":39}],128:[function(require,module,exports){
// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = require('./_is-object');
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};

},{"./_is-object":62}],129:[function(require,module,exports){
'use strict';
if (require('./_descriptors')) {
  var LIBRARY = require('./_library');
  var global = require('./_global');
  var fails = require('./_fails');
  var $export = require('./_export');
  var $typed = require('./_typed');
  var $buffer = require('./_typed-buffer');
  var ctx = require('./_ctx');
  var anInstance = require('./_an-instance');
  var propertyDesc = require('./_property-desc');
  var hide = require('./_hide');
  var redefineAll = require('./_redefine-all');
  var toInteger = require('./_to-integer');
  var toLength = require('./_to-length');
  var toIndex = require('./_to-index');
  var toAbsoluteIndex = require('./_to-absolute-index');
  var toPrimitive = require('./_to-primitive');
  var has = require('./_has');
  var classof = require('./_classof');
  var isObject = require('./_is-object');
  var toObject = require('./_to-object');
  var isArrayIter = require('./_is-array-iter');
  var create = require('./_object-create');
  var getPrototypeOf = require('./_object-gpo');
  var gOPN = require('./_object-gopn').f;
  var getIterFn = require('./core.get-iterator-method');
  var uid = require('./_uid');
  var wks = require('./_wks');
  var createArrayMethod = require('./_array-methods');
  var createArrayIncludes = require('./_array-includes');
  var speciesConstructor = require('./_species-constructor');
  var ArrayIterators = require('./es6.array.iterator');
  var Iterators = require('./_iterators');
  var $iterDetect = require('./_iter-detect');
  var setSpecies = require('./_set-species');
  var arrayFill = require('./_array-fill');
  var arrayCopyWithin = require('./_array-copy-within');
  var $DP = require('./_object-dp');
  var $GOPD = require('./_object-gopd');
  var dP = $DP.f;
  var gOPD = $GOPD.f;
  var RangeError = global.RangeError;
  var TypeError = global.TypeError;
  var Uint8Array = global.Uint8Array;
  var ARRAY_BUFFER = 'ArrayBuffer';
  var SHARED_BUFFER = 'Shared' + ARRAY_BUFFER;
  var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
  var PROTOTYPE = 'prototype';
  var ArrayProto = Array[PROTOTYPE];
  var $ArrayBuffer = $buffer.ArrayBuffer;
  var $DataView = $buffer.DataView;
  var arrayForEach = createArrayMethod(0);
  var arrayFilter = createArrayMethod(2);
  var arraySome = createArrayMethod(3);
  var arrayEvery = createArrayMethod(4);
  var arrayFind = createArrayMethod(5);
  var arrayFindIndex = createArrayMethod(6);
  var arrayIncludes = createArrayIncludes(true);
  var arrayIndexOf = createArrayIncludes(false);
  var arrayValues = ArrayIterators.values;
  var arrayKeys = ArrayIterators.keys;
  var arrayEntries = ArrayIterators.entries;
  var arrayLastIndexOf = ArrayProto.lastIndexOf;
  var arrayReduce = ArrayProto.reduce;
  var arrayReduceRight = ArrayProto.reduceRight;
  var arrayJoin = ArrayProto.join;
  var arraySort = ArrayProto.sort;
  var arraySlice = ArrayProto.slice;
  var arrayToString = ArrayProto.toString;
  var arrayToLocaleString = ArrayProto.toLocaleString;
  var ITERATOR = wks('iterator');
  var TAG = wks('toStringTag');
  var TYPED_CONSTRUCTOR = uid('typed_constructor');
  var DEF_CONSTRUCTOR = uid('def_constructor');
  var ALL_CONSTRUCTORS = $typed.CONSTR;
  var TYPED_ARRAY = $typed.TYPED;
  var VIEW = $typed.VIEW;
  var WRONG_LENGTH = 'Wrong length!';

  var $map = createArrayMethod(1, function (O, length) {
    return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length);
  });

  var LITTLE_ENDIAN = fails(function () {
    // eslint-disable-next-line no-undef
    return new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;
  });

  var FORCED_SET = !!Uint8Array && !!Uint8Array[PROTOTYPE].set && fails(function () {
    new Uint8Array(1).set({});
  });

  var toOffset = function (it, BYTES) {
    var offset = toInteger(it);
    if (offset < 0 || offset % BYTES) throw RangeError('Wrong offset!');
    return offset;
  };

  var validate = function (it) {
    if (isObject(it) && TYPED_ARRAY in it) return it;
    throw TypeError(it + ' is not a typed array!');
  };

  var allocate = function (C, length) {
    if (!(isObject(C) && TYPED_CONSTRUCTOR in C)) {
      throw TypeError('It is not a typed array constructor!');
    } return new C(length);
  };

  var speciesFromList = function (O, list) {
    return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list);
  };

  var fromList = function (C, list) {
    var index = 0;
    var length = list.length;
    var result = allocate(C, length);
    while (length > index) result[index] = list[index++];
    return result;
  };

  var addGetter = function (it, key, internal) {
    dP(it, key, { get: function () { return this._d[internal]; } });
  };

  var $from = function from(source /* , mapfn, thisArg */) {
    var O = toObject(source);
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var iterFn = getIterFn(O);
    var i, length, values, result, step, iterator;
    if (iterFn != undefined && !isArrayIter(iterFn)) {
      for (iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++) {
        values.push(step.value);
      } O = values;
    }
    if (mapping && aLen > 2) mapfn = ctx(mapfn, arguments[2], 2);
    for (i = 0, length = toLength(O.length), result = allocate(this, length); length > i; i++) {
      result[i] = mapping ? mapfn(O[i], i) : O[i];
    }
    return result;
  };

  var $of = function of(/* ...items */) {
    var index = 0;
    var length = arguments.length;
    var result = allocate(this, length);
    while (length > index) result[index] = arguments[index++];
    return result;
  };

  // iOS Safari 6.x fails here
  var TO_LOCALE_BUG = !!Uint8Array && fails(function () { arrayToLocaleString.call(new Uint8Array(1)); });

  var $toLocaleString = function toLocaleString() {
    return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments);
  };

  var proto = {
    copyWithin: function copyWithin(target, start /* , end */) {
      return arrayCopyWithin.call(validate(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
    },
    every: function every(callbackfn /* , thisArg */) {
      return arrayEvery(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    fill: function fill(value /* , start, end */) { // eslint-disable-line no-unused-vars
      return arrayFill.apply(validate(this), arguments);
    },
    filter: function filter(callbackfn /* , thisArg */) {
      return speciesFromList(this, arrayFilter(validate(this), callbackfn,
        arguments.length > 1 ? arguments[1] : undefined));
    },
    find: function find(predicate /* , thisArg */) {
      return arrayFind(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    findIndex: function findIndex(predicate /* , thisArg */) {
      return arrayFindIndex(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    forEach: function forEach(callbackfn /* , thisArg */) {
      arrayForEach(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    indexOf: function indexOf(searchElement /* , fromIndex */) {
      return arrayIndexOf(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    includes: function includes(searchElement /* , fromIndex */) {
      return arrayIncludes(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    join: function join(separator) { // eslint-disable-line no-unused-vars
      return arrayJoin.apply(validate(this), arguments);
    },
    lastIndexOf: function lastIndexOf(searchElement /* , fromIndex */) { // eslint-disable-line no-unused-vars
      return arrayLastIndexOf.apply(validate(this), arguments);
    },
    map: function map(mapfn /* , thisArg */) {
      return $map(validate(this), mapfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    reduce: function reduce(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars
      return arrayReduce.apply(validate(this), arguments);
    },
    reduceRight: function reduceRight(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars
      return arrayReduceRight.apply(validate(this), arguments);
    },
    reverse: function reverse() {
      var that = this;
      var length = validate(that).length;
      var middle = Math.floor(length / 2);
      var index = 0;
      var value;
      while (index < middle) {
        value = that[index];
        that[index++] = that[--length];
        that[length] = value;
      } return that;
    },
    some: function some(callbackfn /* , thisArg */) {
      return arraySome(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    sort: function sort(comparefn) {
      return arraySort.call(validate(this), comparefn);
    },
    subarray: function subarray(begin, end) {
      var O = validate(this);
      var length = O.length;
      var $begin = toAbsoluteIndex(begin, length);
      return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))(
        O.buffer,
        O.byteOffset + $begin * O.BYTES_PER_ELEMENT,
        toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - $begin)
      );
    }
  };

  var $slice = function slice(start, end) {
    return speciesFromList(this, arraySlice.call(validate(this), start, end));
  };

  var $set = function set(arrayLike /* , offset */) {
    validate(this);
    var offset = toOffset(arguments[1], 1);
    var length = this.length;
    var src = toObject(arrayLike);
    var len = toLength(src.length);
    var index = 0;
    if (len + offset > length) throw RangeError(WRONG_LENGTH);
    while (index < len) this[offset + index] = src[index++];
  };

  var $iterators = {
    entries: function entries() {
      return arrayEntries.call(validate(this));
    },
    keys: function keys() {
      return arrayKeys.call(validate(this));
    },
    values: function values() {
      return arrayValues.call(validate(this));
    }
  };

  var isTAIndex = function (target, key) {
    return isObject(target)
      && target[TYPED_ARRAY]
      && typeof key != 'symbol'
      && key in target
      && String(+key) == String(key);
  };
  var $getDesc = function getOwnPropertyDescriptor(target, key) {
    return isTAIndex(target, key = toPrimitive(key, true))
      ? propertyDesc(2, target[key])
      : gOPD(target, key);
  };
  var $setDesc = function defineProperty(target, key, desc) {
    if (isTAIndex(target, key = toPrimitive(key, true))
      && isObject(desc)
      && has(desc, 'value')
      && !has(desc, 'get')
      && !has(desc, 'set')
      // TODO: add validation descriptor w/o calling accessors
      && !desc.configurable
      && (!has(desc, 'writable') || desc.writable)
      && (!has(desc, 'enumerable') || desc.enumerable)
    ) {
      target[key] = desc.value;
      return target;
    } return dP(target, key, desc);
  };

  if (!ALL_CONSTRUCTORS) {
    $GOPD.f = $getDesc;
    $DP.f = $setDesc;
  }

  $export($export.S + $export.F * !ALL_CONSTRUCTORS, 'Object', {
    getOwnPropertyDescriptor: $getDesc,
    defineProperty: $setDesc
  });

  if (fails(function () { arrayToString.call({}); })) {
    arrayToString = arrayToLocaleString = function toString() {
      return arrayJoin.call(this);
    };
  }

  var $TypedArrayPrototype$ = redefineAll({}, proto);
  redefineAll($TypedArrayPrototype$, $iterators);
  hide($TypedArrayPrototype$, ITERATOR, $iterators.values);
  redefineAll($TypedArrayPrototype$, {
    slice: $slice,
    set: $set,
    constructor: function () { /* noop */ },
    toString: arrayToString,
    toLocaleString: $toLocaleString
  });
  addGetter($TypedArrayPrototype$, 'buffer', 'b');
  addGetter($TypedArrayPrototype$, 'byteOffset', 'o');
  addGetter($TypedArrayPrototype$, 'byteLength', 'l');
  addGetter($TypedArrayPrototype$, 'length', 'e');
  dP($TypedArrayPrototype$, TAG, {
    get: function () { return this[TYPED_ARRAY]; }
  });

  // eslint-disable-next-line max-statements
  module.exports = function (KEY, BYTES, wrapper, CLAMPED) {
    CLAMPED = !!CLAMPED;
    var NAME = KEY + (CLAMPED ? 'Clamped' : '') + 'Array';
    var GETTER = 'get' + KEY;
    var SETTER = 'set' + KEY;
    var TypedArray = global[NAME];
    var Base = TypedArray || {};
    var TAC = TypedArray && getPrototypeOf(TypedArray);
    var FORCED = !TypedArray || !$typed.ABV;
    var O = {};
    var TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE];
    var getter = function (that, index) {
      var data = that._d;
      return data.v[GETTER](index * BYTES + data.o, LITTLE_ENDIAN);
    };
    var setter = function (that, index, value) {
      var data = that._d;
      if (CLAMPED) value = (value = Math.round(value)) < 0 ? 0 : value > 0xff ? 0xff : value & 0xff;
      data.v[SETTER](index * BYTES + data.o, value, LITTLE_ENDIAN);
    };
    var addElement = function (that, index) {
      dP(that, index, {
        get: function () {
          return getter(this, index);
        },
        set: function (value) {
          return setter(this, index, value);
        },
        enumerable: true
      });
    };
    if (FORCED) {
      TypedArray = wrapper(function (that, data, $offset, $length) {
        anInstance(that, TypedArray, NAME, '_d');
        var index = 0;
        var offset = 0;
        var buffer, byteLength, length, klass;
        if (!isObject(data)) {
          length = toIndex(data);
          byteLength = length * BYTES;
          buffer = new $ArrayBuffer(byteLength);
        } else if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
          buffer = data;
          offset = toOffset($offset, BYTES);
          var $len = data.byteLength;
          if ($length === undefined) {
            if ($len % BYTES) throw RangeError(WRONG_LENGTH);
            byteLength = $len - offset;
            if (byteLength < 0) throw RangeError(WRONG_LENGTH);
          } else {
            byteLength = toLength($length) * BYTES;
            if (byteLength + offset > $len) throw RangeError(WRONG_LENGTH);
          }
          length = byteLength / BYTES;
        } else if (TYPED_ARRAY in data) {
          return fromList(TypedArray, data);
        } else {
          return $from.call(TypedArray, data);
        }
        hide(that, '_d', {
          b: buffer,
          o: offset,
          l: byteLength,
          e: length,
          v: new $DataView(buffer)
        });
        while (index < length) addElement(that, index++);
      });
      TypedArrayPrototype = TypedArray[PROTOTYPE] = create($TypedArrayPrototype$);
      hide(TypedArrayPrototype, 'constructor', TypedArray);
    } else if (!fails(function () {
      TypedArray(1);
    }) || !fails(function () {
      new TypedArray(-1); // eslint-disable-line no-new
    }) || !$iterDetect(function (iter) {
      new TypedArray(); // eslint-disable-line no-new
      new TypedArray(null); // eslint-disable-line no-new
      new TypedArray(1.5); // eslint-disable-line no-new
      new TypedArray(iter); // eslint-disable-line no-new
    }, true)) {
      TypedArray = wrapper(function (that, data, $offset, $length) {
        anInstance(that, TypedArray, NAME);
        var klass;
        // `ws` module bug, temporarily remove validation length for Uint8Array
        // https://github.com/websockets/ws/pull/645
        if (!isObject(data)) return new Base(toIndex(data));
        if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
          return $length !== undefined
            ? new Base(data, toOffset($offset, BYTES), $length)
            : $offset !== undefined
              ? new Base(data, toOffset($offset, BYTES))
              : new Base(data);
        }
        if (TYPED_ARRAY in data) return fromList(TypedArray, data);
        return $from.call(TypedArray, data);
      });
      arrayForEach(TAC !== Function.prototype ? gOPN(Base).concat(gOPN(TAC)) : gOPN(Base), function (key) {
        if (!(key in TypedArray)) hide(TypedArray, key, Base[key]);
      });
      TypedArray[PROTOTYPE] = TypedArrayPrototype;
      if (!LIBRARY) TypedArrayPrototype.constructor = TypedArray;
    }
    var $nativeIterator = TypedArrayPrototype[ITERATOR];
    var CORRECT_ITER_NAME = !!$nativeIterator
      && ($nativeIterator.name == 'values' || $nativeIterator.name == undefined);
    var $iterator = $iterators.values;
    hide(TypedArray, TYPED_CONSTRUCTOR, true);
    hide(TypedArrayPrototype, TYPED_ARRAY, NAME);
    hide(TypedArrayPrototype, VIEW, true);
    hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray);

    if (CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)) {
      dP(TypedArrayPrototype, TAG, {
        get: function () { return NAME; }
      });
    }

    O[NAME] = TypedArray;

    $export($export.G + $export.W + $export.F * (TypedArray != Base), O);

    $export($export.S, NAME, {
      BYTES_PER_ELEMENT: BYTES
    });

    $export($export.S + $export.F * fails(function () { Base.of.call(TypedArray, 1); }), NAME, {
      from: $from,
      of: $of
    });

    if (!(BYTES_PER_ELEMENT in TypedArrayPrototype)) hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES);

    $export($export.P, NAME, proto);

    setSpecies(NAME);

    $export($export.P + $export.F * FORCED_SET, NAME, { set: $set });

    $export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators);

    if (!LIBRARY && TypedArrayPrototype.toString != arrayToString) TypedArrayPrototype.toString = arrayToString;

    $export($export.P + $export.F * fails(function () {
      new TypedArray(1).slice();
    }), NAME, { slice: $slice });

    $export($export.P + $export.F * (fails(function () {
      return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString();
    }) || !fails(function () {
      TypedArrayPrototype.toLocaleString.call([1, 2]);
    })), NAME, { toLocaleString: $toLocaleString });

    Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator;
    if (!LIBRARY && !CORRECT_ITER_NAME) hide(TypedArrayPrototype, ITERATOR, $iterator);
  };
} else module.exports = function () { /* empty */ };

},{"./_an-instance":17,"./_array-copy-within":19,"./_array-fill":20,"./_array-includes":22,"./_array-methods":23,"./_classof":28,"./_ctx":36,"./_descriptors":40,"./_export":44,"./_fails":46,"./_global":51,"./_has":52,"./_hide":53,"./_is-array-iter":59,"./_is-object":62,"./_iter-detect":67,"./_iterators":69,"./_library":70,"./_object-create":81,"./_object-dp":82,"./_object-gopd":85,"./_object-gopn":87,"./_object-gpo":89,"./_property-desc":100,"./_redefine-all":101,"./_set-species":108,"./_species-constructor":112,"./_to-absolute-index":122,"./_to-index":123,"./_to-integer":124,"./_to-length":126,"./_to-object":127,"./_to-primitive":128,"./_typed":131,"./_typed-buffer":130,"./_uid":132,"./_wks":136,"./core.get-iterator-method":137,"./es6.array.iterator":149}],130:[function(require,module,exports){
'use strict';
var global = require('./_global');
var DESCRIPTORS = require('./_descriptors');
var LIBRARY = require('./_library');
var $typed = require('./_typed');
var hide = require('./_hide');
var redefineAll = require('./_redefine-all');
var fails = require('./_fails');
var anInstance = require('./_an-instance');
var toInteger = require('./_to-integer');
var toLength = require('./_to-length');
var toIndex = require('./_to-index');
var gOPN = require('./_object-gopn').f;
var dP = require('./_object-dp').f;
var arrayFill = require('./_array-fill');
var setToStringTag = require('./_set-to-string-tag');
var ARRAY_BUFFER = 'ArrayBuffer';
var DATA_VIEW = 'DataView';
var PROTOTYPE = 'prototype';
var WRONG_LENGTH = 'Wrong length!';
var WRONG_INDEX = 'Wrong index!';
var $ArrayBuffer = global[ARRAY_BUFFER];
var $DataView = global[DATA_VIEW];
var Math = global.Math;
var RangeError = global.RangeError;
// eslint-disable-next-line no-shadow-restricted-names
var Infinity = global.Infinity;
var BaseBuffer = $ArrayBuffer;
var abs = Math.abs;
var pow = Math.pow;
var floor = Math.floor;
var log = Math.log;
var LN2 = Math.LN2;
var BUFFER = 'buffer';
var BYTE_LENGTH = 'byteLength';
var BYTE_OFFSET = 'byteOffset';
var $BUFFER = DESCRIPTORS ? '_b' : BUFFER;
var $LENGTH = DESCRIPTORS ? '_l' : BYTE_LENGTH;
var $OFFSET = DESCRIPTORS ? '_o' : BYTE_OFFSET;

// IEEE754 conversions based on https://github.com/feross/ieee754
function packIEEE754(value, mLen, nBytes) {
  var buffer = Array(nBytes);
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0;
  var i = 0;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  var e, m, c;
  value = abs(value);
  // eslint-disable-next-line no-self-compare
  if (value != value || value === Infinity) {
    // eslint-disable-next-line no-self-compare
    m = value != value ? 1 : 0;
    e = eMax;
  } else {
    e = floor(log(value) / LN2);
    if (value * (c = pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }
    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * pow(2, eBias - 1) * pow(2, mLen);
      e = 0;
    }
  }
  for (; mLen >= 8; buffer[i++] = m & 255, m /= 256, mLen -= 8);
  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer[i++] = e & 255, e /= 256, eLen -= 8);
  buffer[--i] |= s * 128;
  return buffer;
}
function unpackIEEE754(buffer, mLen, nBytes) {
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = eLen - 7;
  var i = nBytes - 1;
  var s = buffer[i--];
  var e = s & 127;
  var m;
  s >>= 7;
  for (; nBits > 0; e = e * 256 + buffer[i], i--, nBits -= 8);
  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[i], i--, nBits -= 8);
  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : s ? -Infinity : Infinity;
  } else {
    m = m + pow(2, mLen);
    e = e - eBias;
  } return (s ? -1 : 1) * m * pow(2, e - mLen);
}

function unpackI32(bytes) {
  return bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0];
}
function packI8(it) {
  return [it & 0xff];
}
function packI16(it) {
  return [it & 0xff, it >> 8 & 0xff];
}
function packI32(it) {
  return [it & 0xff, it >> 8 & 0xff, it >> 16 & 0xff, it >> 24 & 0xff];
}
function packF64(it) {
  return packIEEE754(it, 52, 8);
}
function packF32(it) {
  return packIEEE754(it, 23, 4);
}

function addGetter(C, key, internal) {
  dP(C[PROTOTYPE], key, { get: function () { return this[internal]; } });
}

function get(view, bytes, index, isLittleEndian) {
  var numIndex = +index;
  var intIndex = toIndex(numIndex);
  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b;
  var start = intIndex + view[$OFFSET];
  var pack = store.slice(start, start + bytes);
  return isLittleEndian ? pack : pack.reverse();
}
function set(view, bytes, index, conversion, value, isLittleEndian) {
  var numIndex = +index;
  var intIndex = toIndex(numIndex);
  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b;
  var start = intIndex + view[$OFFSET];
  var pack = conversion(+value);
  for (var i = 0; i < bytes; i++) store[start + i] = pack[isLittleEndian ? i : bytes - i - 1];
}

if (!$typed.ABV) {
  $ArrayBuffer = function ArrayBuffer(length) {
    anInstance(this, $ArrayBuffer, ARRAY_BUFFER);
    var byteLength = toIndex(length);
    this._b = arrayFill.call(Array(byteLength), 0);
    this[$LENGTH] = byteLength;
  };

  $DataView = function DataView(buffer, byteOffset, byteLength) {
    anInstance(this, $DataView, DATA_VIEW);
    anInstance(buffer, $ArrayBuffer, DATA_VIEW);
    var bufferLength = buffer[$LENGTH];
    var offset = toInteger(byteOffset);
    if (offset < 0 || offset > bufferLength) throw RangeError('Wrong offset!');
    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
    if (offset + byteLength > bufferLength) throw RangeError(WRONG_LENGTH);
    this[$BUFFER] = buffer;
    this[$OFFSET] = offset;
    this[$LENGTH] = byteLength;
  };

  if (DESCRIPTORS) {
    addGetter($ArrayBuffer, BYTE_LENGTH, '_l');
    addGetter($DataView, BUFFER, '_b');
    addGetter($DataView, BYTE_LENGTH, '_l');
    addGetter($DataView, BYTE_OFFSET, '_o');
  }

  redefineAll($DataView[PROTOTYPE], {
    getInt8: function getInt8(byteOffset) {
      return get(this, 1, byteOffset)[0] << 24 >> 24;
    },
    getUint8: function getUint8(byteOffset) {
      return get(this, 1, byteOffset)[0];
    },
    getInt16: function getInt16(byteOffset /* , littleEndian */) {
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
    },
    getUint16: function getUint16(byteOffset /* , littleEndian */) {
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return bytes[1] << 8 | bytes[0];
    },
    getInt32: function getInt32(byteOffset /* , littleEndian */) {
      return unpackI32(get(this, 4, byteOffset, arguments[1]));
    },
    getUint32: function getUint32(byteOffset /* , littleEndian */) {
      return unpackI32(get(this, 4, byteOffset, arguments[1])) >>> 0;
    },
    getFloat32: function getFloat32(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4);
    },
    getFloat64: function getFloat64(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8);
    },
    setInt8: function setInt8(byteOffset, value) {
      set(this, 1, byteOffset, packI8, value);
    },
    setUint8: function setUint8(byteOffset, value) {
      set(this, 1, byteOffset, packI8, value);
    },
    setInt16: function setInt16(byteOffset, value /* , littleEndian */) {
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setUint16: function setUint16(byteOffset, value /* , littleEndian */) {
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setInt32: function setInt32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setUint32: function setUint32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setFloat32: function setFloat32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packF32, value, arguments[2]);
    },
    setFloat64: function setFloat64(byteOffset, value /* , littleEndian */) {
      set(this, 8, byteOffset, packF64, value, arguments[2]);
    }
  });
} else {
  if (!fails(function () {
    $ArrayBuffer(1);
  }) || !fails(function () {
    new $ArrayBuffer(-1); // eslint-disable-line no-new
  }) || fails(function () {
    new $ArrayBuffer(); // eslint-disable-line no-new
    new $ArrayBuffer(1.5); // eslint-disable-line no-new
    new $ArrayBuffer(NaN); // eslint-disable-line no-new
    return $ArrayBuffer.name != ARRAY_BUFFER;
  })) {
    $ArrayBuffer = function ArrayBuffer(length) {
      anInstance(this, $ArrayBuffer);
      return new BaseBuffer(toIndex(length));
    };
    var ArrayBufferProto = $ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE];
    for (var keys = gOPN(BaseBuffer), j = 0, key; keys.length > j;) {
      if (!((key = keys[j++]) in $ArrayBuffer)) hide($ArrayBuffer, key, BaseBuffer[key]);
    }
    if (!LIBRARY) ArrayBufferProto.constructor = $ArrayBuffer;
  }
  // iOS Safari 7.x bug
  var view = new $DataView(new $ArrayBuffer(2));
  var $setInt8 = $DataView[PROTOTYPE].setInt8;
  view.setInt8(0, 2147483648);
  view.setInt8(1, 2147483649);
  if (view.getInt8(0) || !view.getInt8(1)) redefineAll($DataView[PROTOTYPE], {
    setInt8: function setInt8(byteOffset, value) {
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    },
    setUint8: function setUint8(byteOffset, value) {
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    }
  }, true);
}
setToStringTag($ArrayBuffer, ARRAY_BUFFER);
setToStringTag($DataView, DATA_VIEW);
hide($DataView[PROTOTYPE], $typed.VIEW, true);
exports[ARRAY_BUFFER] = $ArrayBuffer;
exports[DATA_VIEW] = $DataView;

},{"./_an-instance":17,"./_array-fill":20,"./_descriptors":40,"./_fails":46,"./_global":51,"./_hide":53,"./_library":70,"./_object-dp":82,"./_object-gopn":87,"./_redefine-all":101,"./_set-to-string-tag":109,"./_to-index":123,"./_to-integer":124,"./_to-length":126,"./_typed":131}],131:[function(require,module,exports){
var global = require('./_global');
var hide = require('./_hide');
var uid = require('./_uid');
var TYPED = uid('typed_array');
var VIEW = uid('view');
var ABV = !!(global.ArrayBuffer && global.DataView);
var CONSTR = ABV;
var i = 0;
var l = 9;
var Typed;

var TypedArrayConstructors = (
  'Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array'
).split(',');

while (i < l) {
  if (Typed = global[TypedArrayConstructors[i++]]) {
    hide(Typed.prototype, TYPED, true);
    hide(Typed.prototype, VIEW, true);
  } else CONSTR = false;
}

module.exports = {
  ABV: ABV,
  CONSTR: CONSTR,
  TYPED: TYPED,
  VIEW: VIEW
};

},{"./_global":51,"./_hide":53,"./_uid":132}],132:[function(require,module,exports){
var id = 0;
var px = Math.random();
module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};

},{}],133:[function(require,module,exports){
var isObject = require('./_is-object');
module.exports = function (it, TYPE) {
  if (!isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');
  return it;
};

},{"./_is-object":62}],134:[function(require,module,exports){
var global = require('./_global');
var core = require('./_core');
var LIBRARY = require('./_library');
var wksExt = require('./_wks-ext');
var defineProperty = require('./_object-dp').f;
module.exports = function (name) {
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });
};

},{"./_core":34,"./_global":51,"./_library":70,"./_object-dp":82,"./_wks-ext":135}],135:[function(require,module,exports){
exports.f = require('./_wks');

},{"./_wks":136}],136:[function(require,module,exports){
var store = require('./_shared')('wks');
var uid = require('./_uid');
var Symbol = require('./_global').Symbol;
var USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;

},{"./_global":51,"./_shared":111,"./_uid":132}],137:[function(require,module,exports){
var classof = require('./_classof');
var ITERATOR = require('./_wks')('iterator');
var Iterators = require('./_iterators');
module.exports = require('./_core').getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};

},{"./_classof":28,"./_core":34,"./_iterators":69,"./_wks":136}],138:[function(require,module,exports){
// https://github.com/benjamingr/RexExp.escape
var $export = require('./_export');
var $re = require('./_replacer')(/[\\^$*+?.()|[\]{}]/g, '\\$&');

$export($export.S, 'RegExp', { escape: function escape(it) { return $re(it); } });

},{"./_export":44,"./_replacer":103}],139:[function(require,module,exports){
// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
var $export = require('./_export');

$export($export.P, 'Array', { copyWithin: require('./_array-copy-within') });

require('./_add-to-unscopables')('copyWithin');

},{"./_add-to-unscopables":16,"./_array-copy-within":19,"./_export":44}],140:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var $every = require('./_array-methods')(4);

$export($export.P + $export.F * !require('./_strict-method')([].every, true), 'Array', {
  // 22.1.3.5 / 15.4.4.16 Array.prototype.every(callbackfn [, thisArg])
  every: function every(callbackfn /* , thisArg */) {
    return $every(this, callbackfn, arguments[1]);
  }
});

},{"./_array-methods":23,"./_export":44,"./_strict-method":113}],141:[function(require,module,exports){
// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
var $export = require('./_export');

$export($export.P, 'Array', { fill: require('./_array-fill') });

require('./_add-to-unscopables')('fill');

},{"./_add-to-unscopables":16,"./_array-fill":20,"./_export":44}],142:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var $filter = require('./_array-methods')(2);

$export($export.P + $export.F * !require('./_strict-method')([].filter, true), 'Array', {
  // 22.1.3.7 / 15.4.4.20 Array.prototype.filter(callbackfn [, thisArg])
  filter: function filter(callbackfn /* , thisArg */) {
    return $filter(this, callbackfn, arguments[1]);
  }
});

},{"./_array-methods":23,"./_export":44,"./_strict-method":113}],143:[function(require,module,exports){
'use strict';
// 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)
var $export = require('./_export');
var $find = require('./_array-methods')(6);
var KEY = 'findIndex';
var forced = true;
// Shouldn't skip holes
if (KEY in []) Array(1)[KEY](function () { forced = false; });
$export($export.P + $export.F * forced, 'Array', {
  findIndex: function findIndex(callbackfn /* , that = undefined */) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});
require('./_add-to-unscopables')(KEY);

},{"./_add-to-unscopables":16,"./_array-methods":23,"./_export":44}],144:[function(require,module,exports){
'use strict';
// 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)
var $export = require('./_export');
var $find = require('./_array-methods')(5);
var KEY = 'find';
var forced = true;
// Shouldn't skip holes
if (KEY in []) Array(1)[KEY](function () { forced = false; });
$export($export.P + $export.F * forced, 'Array', {
  find: function find(callbackfn /* , that = undefined */) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});
require('./_add-to-unscopables')(KEY);

},{"./_add-to-unscopables":16,"./_array-methods":23,"./_export":44}],145:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var $forEach = require('./_array-methods')(0);
var STRICT = require('./_strict-method')([].forEach, true);

$export($export.P + $export.F * !STRICT, 'Array', {
  // 22.1.3.10 / 15.4.4.18 Array.prototype.forEach(callbackfn [, thisArg])
  forEach: function forEach(callbackfn /* , thisArg */) {
    return $forEach(this, callbackfn, arguments[1]);
  }
});

},{"./_array-methods":23,"./_export":44,"./_strict-method":113}],146:[function(require,module,exports){
'use strict';
var ctx = require('./_ctx');
var $export = require('./_export');
var toObject = require('./_to-object');
var call = require('./_iter-call');
var isArrayIter = require('./_is-array-iter');
var toLength = require('./_to-length');
var createProperty = require('./_create-property');
var getIterFn = require('./core.get-iterator-method');

$export($export.S + $export.F * !require('./_iter-detect')(function (iter) { Array.from(iter); }), 'Array', {
  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
  from: function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
    var O = toObject(arrayLike);
    var C = typeof this == 'function' ? this : Array;
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var index = 0;
    var iterFn = getIterFn(O);
    var length, result, step, iterator;
    if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
    // if object isn't iterable or it's array with default iterator - use simple case
    if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {
      for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
      }
    } else {
      length = toLength(O.length);
      for (result = new C(length); length > index; index++) {
        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
      }
    }
    result.length = index;
    return result;
  }
});

},{"./_create-property":35,"./_ctx":36,"./_export":44,"./_is-array-iter":59,"./_iter-call":64,"./_iter-detect":67,"./_to-length":126,"./_to-object":127,"./core.get-iterator-method":137}],147:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var $indexOf = require('./_array-includes')(false);
var $native = [].indexOf;
var NEGATIVE_ZERO = !!$native && 1 / [1].indexOf(1, -0) < 0;

$export($export.P + $export.F * (NEGATIVE_ZERO || !require('./_strict-method')($native)), 'Array', {
  // 22.1.3.11 / 15.4.4.14 Array.prototype.indexOf(searchElement [, fromIndex])
  indexOf: function indexOf(searchElement /* , fromIndex = 0 */) {
    return NEGATIVE_ZERO
      // convert -0 to +0
      ? $native.apply(this, arguments) || 0
      : $indexOf(this, searchElement, arguments[1]);
  }
});

},{"./_array-includes":22,"./_export":44,"./_strict-method":113}],148:[function(require,module,exports){
// 22.1.2.2 / 15.4.3.2 Array.isArray(arg)
var $export = require('./_export');

$export($export.S, 'Array', { isArray: require('./_is-array') });

},{"./_export":44,"./_is-array":60}],149:[function(require,module,exports){
'use strict';
var addToUnscopables = require('./_add-to-unscopables');
var step = require('./_iter-step');
var Iterators = require('./_iterators');
var toIObject = require('./_to-iobject');

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = require('./_iter-define')(Array, 'Array', function (iterated, kind) {
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;
  if (!O || index >= O.length) {
    this._t = undefined;
    return step(1);
  }
  if (kind == 'keys') return step(0, index);
  if (kind == 'values') return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');

},{"./_add-to-unscopables":16,"./_iter-define":66,"./_iter-step":68,"./_iterators":69,"./_to-iobject":125}],150:[function(require,module,exports){
'use strict';
// 22.1.3.13 Array.prototype.join(separator)
var $export = require('./_export');
var toIObject = require('./_to-iobject');
var arrayJoin = [].join;

// fallback for not array-like strings
$export($export.P + $export.F * (require('./_iobject') != Object || !require('./_strict-method')(arrayJoin)), 'Array', {
  join: function join(separator) {
    return arrayJoin.call(toIObject(this), separator === undefined ? ',' : separator);
  }
});

},{"./_export":44,"./_iobject":58,"./_strict-method":113,"./_to-iobject":125}],151:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var toIObject = require('./_to-iobject');
var toInteger = require('./_to-integer');
var toLength = require('./_to-length');
var $native = [].lastIndexOf;
var NEGATIVE_ZERO = !!$native && 1 / [1].lastIndexOf(1, -0) < 0;

$export($export.P + $export.F * (NEGATIVE_ZERO || !require('./_strict-method')($native)), 'Array', {
  // 22.1.3.14 / 15.4.4.15 Array.prototype.lastIndexOf(searchElement [, fromIndex])
  lastIndexOf: function lastIndexOf(searchElement /* , fromIndex = @[*-1] */) {
    // convert -0 to +0
    if (NEGATIVE_ZERO) return $native.apply(this, arguments) || 0;
    var O = toIObject(this);
    var length = toLength(O.length);
    var index = length - 1;
    if (arguments.length > 1) index = Math.min(index, toInteger(arguments[1]));
    if (index < 0) index = length + index;
    for (;index >= 0; index--) if (index in O) if (O[index] === searchElement) return index || 0;
    return -1;
  }
});

},{"./_export":44,"./_strict-method":113,"./_to-integer":124,"./_to-iobject":125,"./_to-length":126}],152:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var $map = require('./_array-methods')(1);

$export($export.P + $export.F * !require('./_strict-method')([].map, true), 'Array', {
  // 22.1.3.15 / 15.4.4.19 Array.prototype.map(callbackfn [, thisArg])
  map: function map(callbackfn /* , thisArg */) {
    return $map(this, callbackfn, arguments[1]);
  }
});

},{"./_array-methods":23,"./_export":44,"./_strict-method":113}],153:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var createProperty = require('./_create-property');

// WebKit Array.of isn't generic
$export($export.S + $export.F * require('./_fails')(function () {
  function F() { /* empty */ }
  return !(Array.of.call(F) instanceof F);
}), 'Array', {
  // 22.1.2.3 Array.of( ...items)
  of: function of(/* ...args */) {
    var index = 0;
    var aLen = arguments.length;
    var result = new (typeof this == 'function' ? this : Array)(aLen);
    while (aLen > index) createProperty(result, index, arguments[index++]);
    result.length = aLen;
    return result;
  }
});

},{"./_create-property":35,"./_export":44,"./_fails":46}],154:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var $reduce = require('./_array-reduce');

$export($export.P + $export.F * !require('./_strict-method')([].reduceRight, true), 'Array', {
  // 22.1.3.19 / 15.4.4.22 Array.prototype.reduceRight(callbackfn [, initialValue])
  reduceRight: function reduceRight(callbackfn /* , initialValue */) {
    return $reduce(this, callbackfn, arguments.length, arguments[1], true);
  }
});

},{"./_array-reduce":24,"./_export":44,"./_strict-method":113}],155:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var $reduce = require('./_array-reduce');

$export($export.P + $export.F * !require('./_strict-method')([].reduce, true), 'Array', {
  // 22.1.3.18 / 15.4.4.21 Array.prototype.reduce(callbackfn [, initialValue])
  reduce: function reduce(callbackfn /* , initialValue */) {
    return $reduce(this, callbackfn, arguments.length, arguments[1], false);
  }
});

},{"./_array-reduce":24,"./_export":44,"./_strict-method":113}],156:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var html = require('./_html');
var cof = require('./_cof');
var toAbsoluteIndex = require('./_to-absolute-index');
var toLength = require('./_to-length');
var arraySlice = [].slice;

// fallback for not array-like ES3 strings and DOM objects
$export($export.P + $export.F * require('./_fails')(function () {
  if (html) arraySlice.call(html);
}), 'Array', {
  slice: function slice(begin, end) {
    var len = toLength(this.length);
    var klass = cof(this);
    end = end === undefined ? len : end;
    if (klass == 'Array') return arraySlice.call(this, begin, end);
    var start = toAbsoluteIndex(begin, len);
    var upTo = toAbsoluteIndex(end, len);
    var size = toLength(upTo - start);
    var cloned = Array(size);
    var i = 0;
    for (; i < size; i++) cloned[i] = klass == 'String'
      ? this.charAt(start + i)
      : this[start + i];
    return cloned;
  }
});

},{"./_cof":29,"./_export":44,"./_fails":46,"./_html":54,"./_to-absolute-index":122,"./_to-length":126}],157:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var $some = require('./_array-methods')(3);

$export($export.P + $export.F * !require('./_strict-method')([].some, true), 'Array', {
  // 22.1.3.23 / 15.4.4.17 Array.prototype.some(callbackfn [, thisArg])
  some: function some(callbackfn /* , thisArg */) {
    return $some(this, callbackfn, arguments[1]);
  }
});

},{"./_array-methods":23,"./_export":44,"./_strict-method":113}],158:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var aFunction = require('./_a-function');
var toObject = require('./_to-object');
var fails = require('./_fails');
var $sort = [].sort;
var test = [1, 2, 3];

$export($export.P + $export.F * (fails(function () {
  // IE8-
  test.sort(undefined);
}) || !fails(function () {
  // V8 bug
  test.sort(null);
  // Old WebKit
}) || !require('./_strict-method')($sort)), 'Array', {
  // 22.1.3.25 Array.prototype.sort(comparefn)
  sort: function sort(comparefn) {
    return comparefn === undefined
      ? $sort.call(toObject(this))
      : $sort.call(toObject(this), aFunction(comparefn));
  }
});

},{"./_a-function":14,"./_export":44,"./_fails":46,"./_strict-method":113,"./_to-object":127}],159:[function(require,module,exports){
require('./_set-species')('Array');

},{"./_set-species":108}],160:[function(require,module,exports){
// 20.3.3.1 / 15.9.4.4 Date.now()
var $export = require('./_export');

$export($export.S, 'Date', { now: function () { return new Date().getTime(); } });

},{"./_export":44}],161:[function(require,module,exports){
// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()
var $export = require('./_export');
var toISOString = require('./_date-to-iso-string');

// PhantomJS / old WebKit has a broken implementations
$export($export.P + $export.F * (Date.prototype.toISOString !== toISOString), 'Date', {
  toISOString: toISOString
});

},{"./_date-to-iso-string":37,"./_export":44}],162:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var toObject = require('./_to-object');
var toPrimitive = require('./_to-primitive');

$export($export.P + $export.F * require('./_fails')(function () {
  return new Date(NaN).toJSON() !== null
    || Date.prototype.toJSON.call({ toISOString: function () { return 1; } }) !== 1;
}), 'Date', {
  // eslint-disable-next-line no-unused-vars
  toJSON: function toJSON(key) {
    var O = toObject(this);
    var pv = toPrimitive(O);
    return typeof pv == 'number' && !isFinite(pv) ? null : O.toISOString();
  }
});

},{"./_export":44,"./_fails":46,"./_to-object":127,"./_to-primitive":128}],163:[function(require,module,exports){
var TO_PRIMITIVE = require('./_wks')('toPrimitive');
var proto = Date.prototype;

if (!(TO_PRIMITIVE in proto)) require('./_hide')(proto, TO_PRIMITIVE, require('./_date-to-primitive'));

},{"./_date-to-primitive":38,"./_hide":53,"./_wks":136}],164:[function(require,module,exports){
var DateProto = Date.prototype;
var INVALID_DATE = 'Invalid Date';
var TO_STRING = 'toString';
var $toString = DateProto[TO_STRING];
var getTime = DateProto.getTime;
if (new Date(NaN) + '' != INVALID_DATE) {
  require('./_redefine')(DateProto, TO_STRING, function toString() {
    var value = getTime.call(this);
    // eslint-disable-next-line no-self-compare
    return value === value ? $toString.call(this) : INVALID_DATE;
  });
}

},{"./_redefine":102}],165:[function(require,module,exports){
// 19.2.3.2 / 15.3.4.5 Function.prototype.bind(thisArg, args...)
var $export = require('./_export');

$export($export.P, 'Function', { bind: require('./_bind') });

},{"./_bind":27,"./_export":44}],166:[function(require,module,exports){
'use strict';
var isObject = require('./_is-object');
var getPrototypeOf = require('./_object-gpo');
var HAS_INSTANCE = require('./_wks')('hasInstance');
var FunctionProto = Function.prototype;
// 19.2.3.6 Function.prototype[@@hasInstance](V)
if (!(HAS_INSTANCE in FunctionProto)) require('./_object-dp').f(FunctionProto, HAS_INSTANCE, { value: function (O) {
  if (typeof this != 'function' || !isObject(O)) return false;
  if (!isObject(this.prototype)) return O instanceof this;
  // for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this:
  while (O = getPrototypeOf(O)) if (this.prototype === O) return true;
  return false;
} });

},{"./_is-object":62,"./_object-dp":82,"./_object-gpo":89,"./_wks":136}],167:[function(require,module,exports){
var dP = require('./_object-dp').f;
var FProto = Function.prototype;
var nameRE = /^\s*function ([^ (]*)/;
var NAME = 'name';

// 19.2.4.2 name
NAME in FProto || require('./_descriptors') && dP(FProto, NAME, {
  configurable: true,
  get: function () {
    try {
      return ('' + this).match(nameRE)[1];
    } catch (e) {
      return '';
    }
  }
});

},{"./_descriptors":40,"./_object-dp":82}],168:[function(require,module,exports){
'use strict';
var strong = require('./_collection-strong');
var validate = require('./_validate-collection');
var MAP = 'Map';

// 23.1 Map Objects
module.exports = require('./_collection')(MAP, function (get) {
  return function Map() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.1.3.6 Map.prototype.get(key)
  get: function get(key) {
    var entry = strong.getEntry(validate(this, MAP), key);
    return entry && entry.v;
  },
  // 23.1.3.9 Map.prototype.set(key, value)
  set: function set(key, value) {
    return strong.def(validate(this, MAP), key === 0 ? 0 : key, value);
  }
}, strong, true);

},{"./_collection":33,"./_collection-strong":30,"./_validate-collection":133}],169:[function(require,module,exports){
// 20.2.2.3 Math.acosh(x)
var $export = require('./_export');
var log1p = require('./_math-log1p');
var sqrt = Math.sqrt;
var $acosh = Math.acosh;

$export($export.S + $export.F * !($acosh
  // V8 bug: https://code.google.com/p/v8/issues/detail?id=3509
  && Math.floor($acosh(Number.MAX_VALUE)) == 710
  // Tor Browser bug: Math.acosh(Infinity) -> NaN
  && $acosh(Infinity) == Infinity
), 'Math', {
  acosh: function acosh(x) {
    return (x = +x) < 1 ? NaN : x > 94906265.62425156
      ? Math.log(x) + Math.LN2
      : log1p(x - 1 + sqrt(x - 1) * sqrt(x + 1));
  }
});

},{"./_export":44,"./_math-log1p":73}],170:[function(require,module,exports){
// 20.2.2.5 Math.asinh(x)
var $export = require('./_export');
var $asinh = Math.asinh;

function asinh(x) {
  return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : Math.log(x + Math.sqrt(x * x + 1));
}

// Tor Browser bug: Math.asinh(0) -> -0
$export($export.S + $export.F * !($asinh && 1 / $asinh(0) > 0), 'Math', { asinh: asinh });

},{"./_export":44}],171:[function(require,module,exports){
// 20.2.2.7 Math.atanh(x)
var $export = require('./_export');
var $atanh = Math.atanh;

// Tor Browser bug: Math.atanh(-0) -> 0
$export($export.S + $export.F * !($atanh && 1 / $atanh(-0) < 0), 'Math', {
  atanh: function atanh(x) {
    return (x = +x) == 0 ? x : Math.log((1 + x) / (1 - x)) / 2;
  }
});

},{"./_export":44}],172:[function(require,module,exports){
// 20.2.2.9 Math.cbrt(x)
var $export = require('./_export');
var sign = require('./_math-sign');

$export($export.S, 'Math', {
  cbrt: function cbrt(x) {
    return sign(x = +x) * Math.pow(Math.abs(x), 1 / 3);
  }
});

},{"./_export":44,"./_math-sign":75}],173:[function(require,module,exports){
// 20.2.2.11 Math.clz32(x)
var $export = require('./_export');

$export($export.S, 'Math', {
  clz32: function clz32(x) {
    return (x >>>= 0) ? 31 - Math.floor(Math.log(x + 0.5) * Math.LOG2E) : 32;
  }
});

},{"./_export":44}],174:[function(require,module,exports){
// 20.2.2.12 Math.cosh(x)
var $export = require('./_export');
var exp = Math.exp;

$export($export.S, 'Math', {
  cosh: function cosh(x) {
    return (exp(x = +x) + exp(-x)) / 2;
  }
});

},{"./_export":44}],175:[function(require,module,exports){
// 20.2.2.14 Math.expm1(x)
var $export = require('./_export');
var $expm1 = require('./_math-expm1');

$export($export.S + $export.F * ($expm1 != Math.expm1), 'Math', { expm1: $expm1 });

},{"./_export":44,"./_math-expm1":71}],176:[function(require,module,exports){
// 20.2.2.16 Math.fround(x)
var $export = require('./_export');

$export($export.S, 'Math', { fround: require('./_math-fround') });

},{"./_export":44,"./_math-fround":72}],177:[function(require,module,exports){
// 20.2.2.17 Math.hypot([value1[, value2[, … ]]])
var $export = require('./_export');
var abs = Math.abs;

$export($export.S, 'Math', {
  hypot: function hypot(value1, value2) { // eslint-disable-line no-unused-vars
    var sum = 0;
    var i = 0;
    var aLen = arguments.length;
    var larg = 0;
    var arg, div;
    while (i < aLen) {
      arg = abs(arguments[i++]);
      if (larg < arg) {
        div = larg / arg;
        sum = sum * div * div + 1;
        larg = arg;
      } else if (arg > 0) {
        div = arg / larg;
        sum += div * div;
      } else sum += arg;
    }
    return larg === Infinity ? Infinity : larg * Math.sqrt(sum);
  }
});

},{"./_export":44}],178:[function(require,module,exports){
// 20.2.2.18 Math.imul(x, y)
var $export = require('./_export');
var $imul = Math.imul;

// some WebKit versions fails with big numbers, some has wrong arity
$export($export.S + $export.F * require('./_fails')(function () {
  return $imul(0xffffffff, 5) != -5 || $imul.length != 2;
}), 'Math', {
  imul: function imul(x, y) {
    var UINT16 = 0xffff;
    var xn = +x;
    var yn = +y;
    var xl = UINT16 & xn;
    var yl = UINT16 & yn;
    return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);
  }
});

},{"./_export":44,"./_fails":46}],179:[function(require,module,exports){
// 20.2.2.21 Math.log10(x)
var $export = require('./_export');

$export($export.S, 'Math', {
  log10: function log10(x) {
    return Math.log(x) * Math.LOG10E;
  }
});

},{"./_export":44}],180:[function(require,module,exports){
// 20.2.2.20 Math.log1p(x)
var $export = require('./_export');

$export($export.S, 'Math', { log1p: require('./_math-log1p') });

},{"./_export":44,"./_math-log1p":73}],181:[function(require,module,exports){
// 20.2.2.22 Math.log2(x)
var $export = require('./_export');

$export($export.S, 'Math', {
  log2: function log2(x) {
    return Math.log(x) / Math.LN2;
  }
});

},{"./_export":44}],182:[function(require,module,exports){
// 20.2.2.28 Math.sign(x)
var $export = require('./_export');

$export($export.S, 'Math', { sign: require('./_math-sign') });

},{"./_export":44,"./_math-sign":75}],183:[function(require,module,exports){
// 20.2.2.30 Math.sinh(x)
var $export = require('./_export');
var expm1 = require('./_math-expm1');
var exp = Math.exp;

// V8 near Chromium 38 has a problem with very small numbers
$export($export.S + $export.F * require('./_fails')(function () {
  return !Math.sinh(-2e-17) != -2e-17;
}), 'Math', {
  sinh: function sinh(x) {
    return Math.abs(x = +x) < 1
      ? (expm1(x) - expm1(-x)) / 2
      : (exp(x - 1) - exp(-x - 1)) * (Math.E / 2);
  }
});

},{"./_export":44,"./_fails":46,"./_math-expm1":71}],184:[function(require,module,exports){
// 20.2.2.33 Math.tanh(x)
var $export = require('./_export');
var expm1 = require('./_math-expm1');
var exp = Math.exp;

$export($export.S, 'Math', {
  tanh: function tanh(x) {
    var a = expm1(x = +x);
    var b = expm1(-x);
    return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));
  }
});

},{"./_export":44,"./_math-expm1":71}],185:[function(require,module,exports){
// 20.2.2.34 Math.trunc(x)
var $export = require('./_export');

$export($export.S, 'Math', {
  trunc: function trunc(it) {
    return (it > 0 ? Math.floor : Math.ceil)(it);
  }
});

},{"./_export":44}],186:[function(require,module,exports){
'use strict';
var global = require('./_global');
var has = require('./_has');
var cof = require('./_cof');
var inheritIfRequired = require('./_inherit-if-required');
var toPrimitive = require('./_to-primitive');
var fails = require('./_fails');
var gOPN = require('./_object-gopn').f;
var gOPD = require('./_object-gopd').f;
var dP = require('./_object-dp').f;
var $trim = require('./_string-trim').trim;
var NUMBER = 'Number';
var $Number = global[NUMBER];
var Base = $Number;
var proto = $Number.prototype;
// Opera ~12 has broken Object#toString
var BROKEN_COF = cof(require('./_object-create')(proto)) == NUMBER;
var TRIM = 'trim' in String.prototype;

// 7.1.3 ToNumber(argument)
var toNumber = function (argument) {
  var it = toPrimitive(argument, false);
  if (typeof it == 'string' && it.length > 2) {
    it = TRIM ? it.trim() : $trim(it, 3);
    var first = it.charCodeAt(0);
    var third, radix, maxCode;
    if (first === 43 || first === 45) {
      third = it.charCodeAt(2);
      if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
    } else if (first === 48) {
      switch (it.charCodeAt(1)) {
        case 66: case 98: radix = 2; maxCode = 49; break; // fast equal /^0b[01]+$/i
        case 79: case 111: radix = 8; maxCode = 55; break; // fast equal /^0o[0-7]+$/i
        default: return +it;
      }
      for (var digits = it.slice(2), i = 0, l = digits.length, code; i < l; i++) {
        code = digits.charCodeAt(i);
        // parseInt parses a string to a first unavailable symbol
        // but ToNumber should return NaN if a string contains unavailable symbols
        if (code < 48 || code > maxCode) return NaN;
      } return parseInt(digits, radix);
    }
  } return +it;
};

if (!$Number(' 0o1') || !$Number('0b1') || $Number('+0x1')) {
  $Number = function Number(value) {
    var it = arguments.length < 1 ? 0 : value;
    var that = this;
    return that instanceof $Number
      // check on 1..constructor(foo) case
      && (BROKEN_COF ? fails(function () { proto.valueOf.call(that); }) : cof(that) != NUMBER)
        ? inheritIfRequired(new Base(toNumber(it)), that, $Number) : toNumber(it);
  };
  for (var keys = require('./_descriptors') ? gOPN(Base) : (
    // ES3:
    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
    // ES6 (in case, if modules with ES6 Number statics required before):
    'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' +
    'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger'
  ).split(','), j = 0, key; keys.length > j; j++) {
    if (has(Base, key = keys[j]) && !has($Number, key)) {
      dP($Number, key, gOPD(Base, key));
    }
  }
  $Number.prototype = proto;
  proto.constructor = $Number;
  require('./_redefine')(global, NUMBER, $Number);
}

},{"./_cof":29,"./_descriptors":40,"./_fails":46,"./_global":51,"./_has":52,"./_inherit-if-required":56,"./_object-create":81,"./_object-dp":82,"./_object-gopd":85,"./_object-gopn":87,"./_redefine":102,"./_string-trim":119,"./_to-primitive":128}],187:[function(require,module,exports){
// 20.1.2.1 Number.EPSILON
var $export = require('./_export');

$export($export.S, 'Number', { EPSILON: Math.pow(2, -52) });

},{"./_export":44}],188:[function(require,module,exports){
// 20.1.2.2 Number.isFinite(number)
var $export = require('./_export');
var _isFinite = require('./_global').isFinite;

$export($export.S, 'Number', {
  isFinite: function isFinite(it) {
    return typeof it == 'number' && _isFinite(it);
  }
});

},{"./_export":44,"./_global":51}],189:[function(require,module,exports){
// 20.1.2.3 Number.isInteger(number)
var $export = require('./_export');

$export($export.S, 'Number', { isInteger: require('./_is-integer') });

},{"./_export":44,"./_is-integer":61}],190:[function(require,module,exports){
// 20.1.2.4 Number.isNaN(number)
var $export = require('./_export');

$export($export.S, 'Number', {
  isNaN: function isNaN(number) {
    // eslint-disable-next-line no-self-compare
    return number != number;
  }
});

},{"./_export":44}],191:[function(require,module,exports){
// 20.1.2.5 Number.isSafeInteger(number)
var $export = require('./_export');
var isInteger = require('./_is-integer');
var abs = Math.abs;

$export($export.S, 'Number', {
  isSafeInteger: function isSafeInteger(number) {
    return isInteger(number) && abs(number) <= 0x1fffffffffffff;
  }
});

},{"./_export":44,"./_is-integer":61}],192:[function(require,module,exports){
// 20.1.2.6 Number.MAX_SAFE_INTEGER
var $export = require('./_export');

$export($export.S, 'Number', { MAX_SAFE_INTEGER: 0x1fffffffffffff });

},{"./_export":44}],193:[function(require,module,exports){
// 20.1.2.10 Number.MIN_SAFE_INTEGER
var $export = require('./_export');

$export($export.S, 'Number', { MIN_SAFE_INTEGER: -0x1fffffffffffff });

},{"./_export":44}],194:[function(require,module,exports){
var $export = require('./_export');
var $parseFloat = require('./_parse-float');
// 20.1.2.12 Number.parseFloat(string)
$export($export.S + $export.F * (Number.parseFloat != $parseFloat), 'Number', { parseFloat: $parseFloat });

},{"./_export":44,"./_parse-float":96}],195:[function(require,module,exports){
var $export = require('./_export');
var $parseInt = require('./_parse-int');
// 20.1.2.13 Number.parseInt(string, radix)
$export($export.S + $export.F * (Number.parseInt != $parseInt), 'Number', { parseInt: $parseInt });

},{"./_export":44,"./_parse-int":97}],196:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var toInteger = require('./_to-integer');
var aNumberValue = require('./_a-number-value');
var repeat = require('./_string-repeat');
var $toFixed = 1.0.toFixed;
var floor = Math.floor;
var data = [0, 0, 0, 0, 0, 0];
var ERROR = 'Number.toFixed: incorrect invocation!';
var ZERO = '0';

var multiply = function (n, c) {
  var i = -1;
  var c2 = c;
  while (++i < 6) {
    c2 += n * data[i];
    data[i] = c2 % 1e7;
    c2 = floor(c2 / 1e7);
  }
};
var divide = function (n) {
  var i = 6;
  var c = 0;
  while (--i >= 0) {
    c += data[i];
    data[i] = floor(c / n);
    c = (c % n) * 1e7;
  }
};
var numToString = function () {
  var i = 6;
  var s = '';
  while (--i >= 0) {
    if (s !== '' || i === 0 || data[i] !== 0) {
      var t = String(data[i]);
      s = s === '' ? t : s + repeat.call(ZERO, 7 - t.length) + t;
    }
  } return s;
};
var pow = function (x, n, acc) {
  return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);
};
var log = function (x) {
  var n = 0;
  var x2 = x;
  while (x2 >= 4096) {
    n += 12;
    x2 /= 4096;
  }
  while (x2 >= 2) {
    n += 1;
    x2 /= 2;
  } return n;
};

$export($export.P + $export.F * (!!$toFixed && (
  0.00008.toFixed(3) !== '0.000' ||
  0.9.toFixed(0) !== '1' ||
  1.255.toFixed(2) !== '1.25' ||
  1000000000000000128.0.toFixed(0) !== '1000000000000000128'
) || !require('./_fails')(function () {
  // V8 ~ Android 4.3-
  $toFixed.call({});
})), 'Number', {
  toFixed: function toFixed(fractionDigits) {
    var x = aNumberValue(this, ERROR);
    var f = toInteger(fractionDigits);
    var s = '';
    var m = ZERO;
    var e, z, j, k;
    if (f < 0 || f > 20) throw RangeError(ERROR);
    // eslint-disable-next-line no-self-compare
    if (x != x) return 'NaN';
    if (x <= -1e21 || x >= 1e21) return String(x);
    if (x < 0) {
      s = '-';
      x = -x;
    }
    if (x > 1e-21) {
      e = log(x * pow(2, 69, 1)) - 69;
      z = e < 0 ? x * pow(2, -e, 1) : x / pow(2, e, 1);
      z *= 0x10000000000000;
      e = 52 - e;
      if (e > 0) {
        multiply(0, z);
        j = f;
        while (j >= 7) {
          multiply(1e7, 0);
          j -= 7;
        }
        multiply(pow(10, j, 1), 0);
        j = e - 1;
        while (j >= 23) {
          divide(1 << 23);
          j -= 23;
        }
        divide(1 << j);
        multiply(1, 1);
        divide(2);
        m = numToString();
      } else {
        multiply(0, z);
        multiply(1 << -e, 0);
        m = numToString() + repeat.call(ZERO, f);
      }
    }
    if (f > 0) {
      k = m.length;
      m = s + (k <= f ? '0.' + repeat.call(ZERO, f - k) + m : m.slice(0, k - f) + '.' + m.slice(k - f));
    } else {
      m = s + m;
    } return m;
  }
});

},{"./_a-number-value":15,"./_export":44,"./_fails":46,"./_string-repeat":118,"./_to-integer":124}],197:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var $fails = require('./_fails');
var aNumberValue = require('./_a-number-value');
var $toPrecision = 1.0.toPrecision;

$export($export.P + $export.F * ($fails(function () {
  // IE7-
  return $toPrecision.call(1, undefined) !== '1';
}) || !$fails(function () {
  // V8 ~ Android 4.3-
  $toPrecision.call({});
})), 'Number', {
  toPrecision: function toPrecision(precision) {
    var that = aNumberValue(this, 'Number#toPrecision: incorrect invocation!');
    return precision === undefined ? $toPrecision.call(that) : $toPrecision.call(that, precision);
  }
});

},{"./_a-number-value":15,"./_export":44,"./_fails":46}],198:[function(require,module,exports){
// 19.1.3.1 Object.assign(target, source)
var $export = require('./_export');

$export($export.S + $export.F, 'Object', { assign: require('./_object-assign') });

},{"./_export":44,"./_object-assign":80}],199:[function(require,module,exports){
var $export = require('./_export');
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
$export($export.S, 'Object', { create: require('./_object-create') });

},{"./_export":44,"./_object-create":81}],200:[function(require,module,exports){
var $export = require('./_export');
// 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)
$export($export.S + $export.F * !require('./_descriptors'), 'Object', { defineProperties: require('./_object-dps') });

},{"./_descriptors":40,"./_export":44,"./_object-dps":83}],201:[function(require,module,exports){
var $export = require('./_export');
// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
$export($export.S + $export.F * !require('./_descriptors'), 'Object', { defineProperty: require('./_object-dp').f });

},{"./_descriptors":40,"./_export":44,"./_object-dp":82}],202:[function(require,module,exports){
// 19.1.2.5 Object.freeze(O)
var isObject = require('./_is-object');
var meta = require('./_meta').onFreeze;

require('./_object-sap')('freeze', function ($freeze) {
  return function freeze(it) {
    return $freeze && isObject(it) ? $freeze(meta(it)) : it;
  };
});

},{"./_is-object":62,"./_meta":76,"./_object-sap":93}],203:[function(require,module,exports){
// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
var toIObject = require('./_to-iobject');
var $getOwnPropertyDescriptor = require('./_object-gopd').f;

require('./_object-sap')('getOwnPropertyDescriptor', function () {
  return function getOwnPropertyDescriptor(it, key) {
    return $getOwnPropertyDescriptor(toIObject(it), key);
  };
});

},{"./_object-gopd":85,"./_object-sap":93,"./_to-iobject":125}],204:[function(require,module,exports){
// 19.1.2.7 Object.getOwnPropertyNames(O)
require('./_object-sap')('getOwnPropertyNames', function () {
  return require('./_object-gopn-ext').f;
});

},{"./_object-gopn-ext":86,"./_object-sap":93}],205:[function(require,module,exports){
// 19.1.2.9 Object.getPrototypeOf(O)
var toObject = require('./_to-object');
var $getPrototypeOf = require('./_object-gpo');

require('./_object-sap')('getPrototypeOf', function () {
  return function getPrototypeOf(it) {
    return $getPrototypeOf(toObject(it));
  };
});

},{"./_object-gpo":89,"./_object-sap":93,"./_to-object":127}],206:[function(require,module,exports){
// 19.1.2.11 Object.isExtensible(O)
var isObject = require('./_is-object');

require('./_object-sap')('isExtensible', function ($isExtensible) {
  return function isExtensible(it) {
    return isObject(it) ? $isExtensible ? $isExtensible(it) : true : false;
  };
});

},{"./_is-object":62,"./_object-sap":93}],207:[function(require,module,exports){
// 19.1.2.12 Object.isFrozen(O)
var isObject = require('./_is-object');

require('./_object-sap')('isFrozen', function ($isFrozen) {
  return function isFrozen(it) {
    return isObject(it) ? $isFrozen ? $isFrozen(it) : false : true;
  };
});

},{"./_is-object":62,"./_object-sap":93}],208:[function(require,module,exports){
// 19.1.2.13 Object.isSealed(O)
var isObject = require('./_is-object');

require('./_object-sap')('isSealed', function ($isSealed) {
  return function isSealed(it) {
    return isObject(it) ? $isSealed ? $isSealed(it) : false : true;
  };
});

},{"./_is-object":62,"./_object-sap":93}],209:[function(require,module,exports){
// 19.1.3.10 Object.is(value1, value2)
var $export = require('./_export');
$export($export.S, 'Object', { is: require('./_same-value') });

},{"./_export":44,"./_same-value":104}],210:[function(require,module,exports){
// 19.1.2.14 Object.keys(O)
var toObject = require('./_to-object');
var $keys = require('./_object-keys');

require('./_object-sap')('keys', function () {
  return function keys(it) {
    return $keys(toObject(it));
  };
});

},{"./_object-keys":91,"./_object-sap":93,"./_to-object":127}],211:[function(require,module,exports){
// 19.1.2.15 Object.preventExtensions(O)
var isObject = require('./_is-object');
var meta = require('./_meta').onFreeze;

require('./_object-sap')('preventExtensions', function ($preventExtensions) {
  return function preventExtensions(it) {
    return $preventExtensions && isObject(it) ? $preventExtensions(meta(it)) : it;
  };
});

},{"./_is-object":62,"./_meta":76,"./_object-sap":93}],212:[function(require,module,exports){
// 19.1.2.17 Object.seal(O)
var isObject = require('./_is-object');
var meta = require('./_meta').onFreeze;

require('./_object-sap')('seal', function ($seal) {
  return function seal(it) {
    return $seal && isObject(it) ? $seal(meta(it)) : it;
  };
});

},{"./_is-object":62,"./_meta":76,"./_object-sap":93}],213:[function(require,module,exports){
// 19.1.3.19 Object.setPrototypeOf(O, proto)
var $export = require('./_export');
$export($export.S, 'Object', { setPrototypeOf: require('./_set-proto').set });

},{"./_export":44,"./_set-proto":107}],214:[function(require,module,exports){
'use strict';
// 19.1.3.6 Object.prototype.toString()
var classof = require('./_classof');
var test = {};
test[require('./_wks')('toStringTag')] = 'z';
if (test + '' != '[object z]') {
  require('./_redefine')(Object.prototype, 'toString', function toString() {
    return '[object ' + classof(this) + ']';
  }, true);
}

},{"./_classof":28,"./_redefine":102,"./_wks":136}],215:[function(require,module,exports){
var $export = require('./_export');
var $parseFloat = require('./_parse-float');
// 18.2.4 parseFloat(string)
$export($export.G + $export.F * (parseFloat != $parseFloat), { parseFloat: $parseFloat });

},{"./_export":44,"./_parse-float":96}],216:[function(require,module,exports){
var $export = require('./_export');
var $parseInt = require('./_parse-int');
// 18.2.5 parseInt(string, radix)
$export($export.G + $export.F * (parseInt != $parseInt), { parseInt: $parseInt });

},{"./_export":44,"./_parse-int":97}],217:[function(require,module,exports){
'use strict';
var LIBRARY = require('./_library');
var global = require('./_global');
var ctx = require('./_ctx');
var classof = require('./_classof');
var $export = require('./_export');
var isObject = require('./_is-object');
var aFunction = require('./_a-function');
var anInstance = require('./_an-instance');
var forOf = require('./_for-of');
var speciesConstructor = require('./_species-constructor');
var task = require('./_task').set;
var microtask = require('./_microtask')();
var newPromiseCapabilityModule = require('./_new-promise-capability');
var perform = require('./_perform');
var promiseResolve = require('./_promise-resolve');
var PROMISE = 'Promise';
var TypeError = global.TypeError;
var process = global.process;
var $Promise = global[PROMISE];
var isNode = classof(process) == 'process';
var empty = function () { /* empty */ };
var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
var newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;

var USE_NATIVE = !!function () {
  try {
    // correct subclassing with @@species support
    var promise = $Promise.resolve(1);
    var FakePromise = (promise.constructor = {})[require('./_wks')('species')] = function (exec) {
      exec(empty, empty);
    };
    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
    return (isNode || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise;
  } catch (e) { /* empty */ }
}();

// helpers
var isThenable = function (it) {
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};
var notify = function (promise, isReject) {
  if (promise._n) return;
  promise._n = true;
  var chain = promise._c;
  microtask(function () {
    var value = promise._v;
    var ok = promise._s == 1;
    var i = 0;
    var run = function (reaction) {
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve = reaction.resolve;
      var reject = reaction.reject;
      var domain = reaction.domain;
      var result, then;
      try {
        if (handler) {
          if (!ok) {
            if (promise._h == 2) onHandleUnhandled(promise);
            promise._h = 1;
          }
          if (handler === true) result = value;
          else {
            if (domain) domain.enter();
            result = handler(value);
            if (domain) domain.exit();
          }
          if (result === reaction.promise) {
            reject(TypeError('Promise-chain cycle'));
          } else if (then = isThenable(result)) {
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch (e) {
        reject(e);
      }
    };
    while (chain.length > i) run(chain[i++]); // variable length - can't use forEach
    promise._c = [];
    promise._n = false;
    if (isReject && !promise._h) onUnhandled(promise);
  });
};
var onUnhandled = function (promise) {
  task.call(global, function () {
    var value = promise._v;
    var unhandled = isUnhandled(promise);
    var result, handler, console;
    if (unhandled) {
      result = perform(function () {
        if (isNode) {
          process.emit('unhandledRejection', value, promise);
        } else if (handler = global.onunhandledrejection) {
          handler({ promise: promise, reason: value });
        } else if ((console = global.console) && console.error) {
          console.error('Unhandled promise rejection', value);
        }
      });
      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
    } promise._a = undefined;
    if (unhandled && result.e) throw result.v;
  });
};
var isUnhandled = function (promise) {
  if (promise._h == 1) return false;
  var chain = promise._a || promise._c;
  var i = 0;
  var reaction;
  while (chain.length > i) {
    reaction = chain[i++];
    if (reaction.fail || !isUnhandled(reaction.promise)) return false;
  } return true;
};
var onHandleUnhandled = function (promise) {
  task.call(global, function () {
    var handler;
    if (isNode) {
      process.emit('rejectionHandled', promise);
    } else if (handler = global.onrejectionhandled) {
      handler({ promise: promise, reason: promise._v });
    }
  });
};
var $reject = function (value) {
  var promise = this;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  promise._v = value;
  promise._s = 2;
  if (!promise._a) promise._a = promise._c.slice();
  notify(promise, true);
};
var $resolve = function (value) {
  var promise = this;
  var then;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  try {
    if (promise === value) throw TypeError("Promise can't be resolved itself");
    if (then = isThenable(value)) {
      microtask(function () {
        var wrapper = { _w: promise, _d: false }; // wrap
        try {
          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
        } catch (e) {
          $reject.call(wrapper, e);
        }
      });
    } else {
      promise._v = value;
      promise._s = 1;
      notify(promise, false);
    }
  } catch (e) {
    $reject.call({ _w: promise, _d: false }, e); // wrap
  }
};

// constructor polyfill
if (!USE_NATIVE) {
  // 25.4.3.1 Promise(executor)
  $Promise = function Promise(executor) {
    anInstance(this, $Promise, PROMISE, '_h');
    aFunction(executor);
    Internal.call(this);
    try {
      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
    } catch (err) {
      $reject.call(this, err);
    }
  };
  // eslint-disable-next-line no-unused-vars
  Internal = function Promise(executor) {
    this._c = [];             // <- awaiting reactions
    this._a = undefined;      // <- checked in isUnhandled reactions
    this._s = 0;              // <- state
    this._d = false;          // <- done
    this._v = undefined;      // <- value
    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
    this._n = false;          // <- notify
  };
  Internal.prototype = require('./_redefine-all')($Promise.prototype, {
    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
    then: function then(onFulfilled, onRejected) {
      var reaction = newPromiseCapability(speciesConstructor(this, $Promise));
      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail = typeof onRejected == 'function' && onRejected;
      reaction.domain = isNode ? process.domain : undefined;
      this._c.push(reaction);
      if (this._a) this._a.push(reaction);
      if (this._s) notify(this, false);
      return reaction.promise;
    },
    // 25.4.5.1 Promise.prototype.catch(onRejected)
    'catch': function (onRejected) {
      return this.then(undefined, onRejected);
    }
  });
  OwnPromiseCapability = function () {
    var promise = new Internal();
    this.promise = promise;
    this.resolve = ctx($resolve, promise, 1);
    this.reject = ctx($reject, promise, 1);
  };
  newPromiseCapabilityModule.f = newPromiseCapability = function (C) {
    return C === $Promise || C === Wrapper
      ? new OwnPromiseCapability(C)
      : newGenericPromiseCapability(C);
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Promise: $Promise });
require('./_set-to-string-tag')($Promise, PROMISE);
require('./_set-species')(PROMISE);
Wrapper = require('./_core')[PROMISE];

// statics
$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
  // 25.4.4.5 Promise.reject(r)
  reject: function reject(r) {
    var capability = newPromiseCapability(this);
    var $$reject = capability.reject;
    $$reject(r);
    return capability.promise;
  }
});
$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
  // 25.4.4.6 Promise.resolve(x)
  resolve: function resolve(x) {
    return promiseResolve(LIBRARY && this === Wrapper ? $Promise : this, x);
  }
});
$export($export.S + $export.F * !(USE_NATIVE && require('./_iter-detect')(function (iter) {
  $Promise.all(iter)['catch'](empty);
})), PROMISE, {
  // 25.4.4.1 Promise.all(iterable)
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var values = [];
      var index = 0;
      var remaining = 1;
      forOf(iterable, false, function (promise) {
        var $index = index++;
        var alreadyCalled = false;
        values.push(undefined);
        remaining++;
        C.resolve(promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[$index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if (result.e) reject(result.v);
    return capability.promise;
  },
  // 25.4.4.4 Promise.race(iterable)
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var reject = capability.reject;
    var result = perform(function () {
      forOf(iterable, false, function (promise) {
        C.resolve(promise).then(capability.resolve, reject);
      });
    });
    if (result.e) reject(result.v);
    return capability.promise;
  }
});

},{"./_a-function":14,"./_an-instance":17,"./_classof":28,"./_core":34,"./_ctx":36,"./_export":44,"./_for-of":50,"./_global":51,"./_is-object":62,"./_iter-detect":67,"./_library":70,"./_microtask":78,"./_new-promise-capability":79,"./_perform":98,"./_promise-resolve":99,"./_redefine-all":101,"./_set-species":108,"./_set-to-string-tag":109,"./_species-constructor":112,"./_task":121,"./_wks":136}],218:[function(require,module,exports){
// 26.1.1 Reflect.apply(target, thisArgument, argumentsList)
var $export = require('./_export');
var aFunction = require('./_a-function');
var anObject = require('./_an-object');
var rApply = (require('./_global').Reflect || {}).apply;
var fApply = Function.apply;
// MS Edge argumentsList argument is optional
$export($export.S + $export.F * !require('./_fails')(function () {
  rApply(function () { /* empty */ });
}), 'Reflect', {
  apply: function apply(target, thisArgument, argumentsList) {
    var T = aFunction(target);
    var L = anObject(argumentsList);
    return rApply ? rApply(T, thisArgument, L) : fApply.call(T, thisArgument, L);
  }
});

},{"./_a-function":14,"./_an-object":18,"./_export":44,"./_fails":46,"./_global":51}],219:[function(require,module,exports){
// 26.1.2 Reflect.construct(target, argumentsList [, newTarget])
var $export = require('./_export');
var create = require('./_object-create');
var aFunction = require('./_a-function');
var anObject = require('./_an-object');
var isObject = require('./_is-object');
var fails = require('./_fails');
var bind = require('./_bind');
var rConstruct = (require('./_global').Reflect || {}).construct;

// MS Edge supports only 2 arguments and argumentsList argument is optional
// FF Nightly sets third argument as `new.target`, but does not create `this` from it
var NEW_TARGET_BUG = fails(function () {
  function F() { /* empty */ }
  return !(rConstruct(function () { /* empty */ }, [], F) instanceof F);
});
var ARGS_BUG = !fails(function () {
  rConstruct(function () { /* empty */ });
});

$export($export.S + $export.F * (NEW_TARGET_BUG || ARGS_BUG), 'Reflect', {
  construct: function construct(Target, args /* , newTarget */) {
    aFunction(Target);
    anObject(args);
    var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);
    if (ARGS_BUG && !NEW_TARGET_BUG) return rConstruct(Target, args, newTarget);
    if (Target == newTarget) {
      // w/o altered newTarget, optimization for 0-4 arguments
      switch (args.length) {
        case 0: return new Target();
        case 1: return new Target(args[0]);
        case 2: return new Target(args[0], args[1]);
        case 3: return new Target(args[0], args[1], args[2]);
        case 4: return new Target(args[0], args[1], args[2], args[3]);
      }
      // w/o altered newTarget, lot of arguments case
      var $args = [null];
      $args.push.apply($args, args);
      return new (bind.apply(Target, $args))();
    }
    // with altered newTarget, not support built-in constructors
    var proto = newTarget.prototype;
    var instance = create(isObject(proto) ? proto : Object.prototype);
    var result = Function.apply.call(Target, instance, args);
    return isObject(result) ? result : instance;
  }
});

},{"./_a-function":14,"./_an-object":18,"./_bind":27,"./_export":44,"./_fails":46,"./_global":51,"./_is-object":62,"./_object-create":81}],220:[function(require,module,exports){
// 26.1.3 Reflect.defineProperty(target, propertyKey, attributes)
var dP = require('./_object-dp');
var $export = require('./_export');
var anObject = require('./_an-object');
var toPrimitive = require('./_to-primitive');

// MS Edge has broken Reflect.defineProperty - throwing instead of returning false
$export($export.S + $export.F * require('./_fails')(function () {
  // eslint-disable-next-line no-undef
  Reflect.defineProperty(dP.f({}, 1, { value: 1 }), 1, { value: 2 });
}), 'Reflect', {
  defineProperty: function defineProperty(target, propertyKey, attributes) {
    anObject(target);
    propertyKey = toPrimitive(propertyKey, true);
    anObject(attributes);
    try {
      dP.f(target, propertyKey, attributes);
      return true;
    } catch (e) {
      return false;
    }
  }
});

},{"./_an-object":18,"./_export":44,"./_fails":46,"./_object-dp":82,"./_to-primitive":128}],221:[function(require,module,exports){
// 26.1.4 Reflect.deleteProperty(target, propertyKey)
var $export = require('./_export');
var gOPD = require('./_object-gopd').f;
var anObject = require('./_an-object');

$export($export.S, 'Reflect', {
  deleteProperty: function deleteProperty(target, propertyKey) {
    var desc = gOPD(anObject(target), propertyKey);
    return desc && !desc.configurable ? false : delete target[propertyKey];
  }
});

},{"./_an-object":18,"./_export":44,"./_object-gopd":85}],222:[function(require,module,exports){
'use strict';
// 26.1.5 Reflect.enumerate(target)
var $export = require('./_export');
var anObject = require('./_an-object');
var Enumerate = function (iterated) {
  this._t = anObject(iterated); // target
  this._i = 0;                  // next index
  var keys = this._k = [];      // keys
  var key;
  for (key in iterated) keys.push(key);
};
require('./_iter-create')(Enumerate, 'Object', function () {
  var that = this;
  var keys = that._k;
  var key;
  do {
    if (that._i >= keys.length) return { value: undefined, done: true };
  } while (!((key = keys[that._i++]) in that._t));
  return { value: key, done: false };
});

$export($export.S, 'Reflect', {
  enumerate: function enumerate(target) {
    return new Enumerate(target);
  }
});

},{"./_an-object":18,"./_export":44,"./_iter-create":65}],223:[function(require,module,exports){
// 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey)
var gOPD = require('./_object-gopd');
var $export = require('./_export');
var anObject = require('./_an-object');

$export($export.S, 'Reflect', {
  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) {
    return gOPD.f(anObject(target), propertyKey);
  }
});

},{"./_an-object":18,"./_export":44,"./_object-gopd":85}],224:[function(require,module,exports){
// 26.1.8 Reflect.getPrototypeOf(target)
var $export = require('./_export');
var getProto = require('./_object-gpo');
var anObject = require('./_an-object');

$export($export.S, 'Reflect', {
  getPrototypeOf: function getPrototypeOf(target) {
    return getProto(anObject(target));
  }
});

},{"./_an-object":18,"./_export":44,"./_object-gpo":89}],225:[function(require,module,exports){
// 26.1.6 Reflect.get(target, propertyKey [, receiver])
var gOPD = require('./_object-gopd');
var getPrototypeOf = require('./_object-gpo');
var has = require('./_has');
var $export = require('./_export');
var isObject = require('./_is-object');
var anObject = require('./_an-object');

function get(target, propertyKey /* , receiver */) {
  var receiver = arguments.length < 3 ? target : arguments[2];
  var desc, proto;
  if (anObject(target) === receiver) return target[propertyKey];
  if (desc = gOPD.f(target, propertyKey)) return has(desc, 'value')
    ? desc.value
    : desc.get !== undefined
      ? desc.get.call(receiver)
      : undefined;
  if (isObject(proto = getPrototypeOf(target))) return get(proto, propertyKey, receiver);
}

$export($export.S, 'Reflect', { get: get });

},{"./_an-object":18,"./_export":44,"./_has":52,"./_is-object":62,"./_object-gopd":85,"./_object-gpo":89}],226:[function(require,module,exports){
// 26.1.9 Reflect.has(target, propertyKey)
var $export = require('./_export');

$export($export.S, 'Reflect', {
  has: function has(target, propertyKey) {
    return propertyKey in target;
  }
});

},{"./_export":44}],227:[function(require,module,exports){
// 26.1.10 Reflect.isExtensible(target)
var $export = require('./_export');
var anObject = require('./_an-object');
var $isExtensible = Object.isExtensible;

$export($export.S, 'Reflect', {
  isExtensible: function isExtensible(target) {
    anObject(target);
    return $isExtensible ? $isExtensible(target) : true;
  }
});

},{"./_an-object":18,"./_export":44}],228:[function(require,module,exports){
// 26.1.11 Reflect.ownKeys(target)
var $export = require('./_export');

$export($export.S, 'Reflect', { ownKeys: require('./_own-keys') });

},{"./_export":44,"./_own-keys":95}],229:[function(require,module,exports){
// 26.1.12 Reflect.preventExtensions(target)
var $export = require('./_export');
var anObject = require('./_an-object');
var $preventExtensions = Object.preventExtensions;

$export($export.S, 'Reflect', {
  preventExtensions: function preventExtensions(target) {
    anObject(target);
    try {
      if ($preventExtensions) $preventExtensions(target);
      return true;
    } catch (e) {
      return false;
    }
  }
});

},{"./_an-object":18,"./_export":44}],230:[function(require,module,exports){
// 26.1.14 Reflect.setPrototypeOf(target, proto)
var $export = require('./_export');
var setProto = require('./_set-proto');

if (setProto) $export($export.S, 'Reflect', {
  setPrototypeOf: function setPrototypeOf(target, proto) {
    setProto.check(target, proto);
    try {
      setProto.set(target, proto);
      return true;
    } catch (e) {
      return false;
    }
  }
});

},{"./_export":44,"./_set-proto":107}],231:[function(require,module,exports){
// 26.1.13 Reflect.set(target, propertyKey, V [, receiver])
var dP = require('./_object-dp');
var gOPD = require('./_object-gopd');
var getPrototypeOf = require('./_object-gpo');
var has = require('./_has');
var $export = require('./_export');
var createDesc = require('./_property-desc');
var anObject = require('./_an-object');
var isObject = require('./_is-object');

function set(target, propertyKey, V /* , receiver */) {
  var receiver = arguments.length < 4 ? target : arguments[3];
  var ownDesc = gOPD.f(anObject(target), propertyKey);
  var existingDescriptor, proto;
  if (!ownDesc) {
    if (isObject(proto = getPrototypeOf(target))) {
      return set(proto, propertyKey, V, receiver);
    }
    ownDesc = createDesc(0);
  }
  if (has(ownDesc, 'value')) {
    if (ownDesc.writable === false || !isObject(receiver)) return false;
    existingDescriptor = gOPD.f(receiver, propertyKey) || createDesc(0);
    existingDescriptor.value = V;
    dP.f(receiver, propertyKey, existingDescriptor);
    return true;
  }
  return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true);
}

$export($export.S, 'Reflect', { set: set });

},{"./_an-object":18,"./_export":44,"./_has":52,"./_is-object":62,"./_object-dp":82,"./_object-gopd":85,"./_object-gpo":89,"./_property-desc":100}],232:[function(require,module,exports){
var global = require('./_global');
var inheritIfRequired = require('./_inherit-if-required');
var dP = require('./_object-dp').f;
var gOPN = require('./_object-gopn').f;
var isRegExp = require('./_is-regexp');
var $flags = require('./_flags');
var $RegExp = global.RegExp;
var Base = $RegExp;
var proto = $RegExp.prototype;
var re1 = /a/g;
var re2 = /a/g;
// "new" creates a new object, old webkit buggy here
var CORRECT_NEW = new $RegExp(re1) !== re1;

if (require('./_descriptors') && (!CORRECT_NEW || require('./_fails')(function () {
  re2[require('./_wks')('match')] = false;
  // RegExp constructor can alter flags and IsRegExp works correct with @@match
  return $RegExp(re1) != re1 || $RegExp(re2) == re2 || $RegExp(re1, 'i') != '/a/i';
}))) {
  $RegExp = function RegExp(p, f) {
    var tiRE = this instanceof $RegExp;
    var piRE = isRegExp(p);
    var fiU = f === undefined;
    return !tiRE && piRE && p.constructor === $RegExp && fiU ? p
      : inheritIfRequired(CORRECT_NEW
        ? new Base(piRE && !fiU ? p.source : p, f)
        : Base((piRE = p instanceof $RegExp) ? p.source : p, piRE && fiU ? $flags.call(p) : f)
      , tiRE ? this : proto, $RegExp);
  };
  var proxy = function (key) {
    key in $RegExp || dP($RegExp, key, {
      configurable: true,
      get: function () { return Base[key]; },
      set: function (it) { Base[key] = it; }
    });
  };
  for (var keys = gOPN(Base), i = 0; keys.length > i;) proxy(keys[i++]);
  proto.constructor = $RegExp;
  $RegExp.prototype = proto;
  require('./_redefine')(global, 'RegExp', $RegExp);
}

require('./_set-species')('RegExp');

},{"./_descriptors":40,"./_fails":46,"./_flags":48,"./_global":51,"./_inherit-if-required":56,"./_is-regexp":63,"./_object-dp":82,"./_object-gopn":87,"./_redefine":102,"./_set-species":108,"./_wks":136}],233:[function(require,module,exports){
// 21.2.5.3 get RegExp.prototype.flags()
if (require('./_descriptors') && /./g.flags != 'g') require('./_object-dp').f(RegExp.prototype, 'flags', {
  configurable: true,
  get: require('./_flags')
});

},{"./_descriptors":40,"./_flags":48,"./_object-dp":82}],234:[function(require,module,exports){
// @@match logic
require('./_fix-re-wks')('match', 1, function (defined, MATCH, $match) {
  // 21.1.3.11 String.prototype.match(regexp)
  return [function match(regexp) {
    'use strict';
    var O = defined(this);
    var fn = regexp == undefined ? undefined : regexp[MATCH];
    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
  }, $match];
});

},{"./_fix-re-wks":47}],235:[function(require,module,exports){
// @@replace logic
require('./_fix-re-wks')('replace', 2, function (defined, REPLACE, $replace) {
  // 21.1.3.14 String.prototype.replace(searchValue, replaceValue)
  return [function replace(searchValue, replaceValue) {
    'use strict';
    var O = defined(this);
    var fn = searchValue == undefined ? undefined : searchValue[REPLACE];
    return fn !== undefined
      ? fn.call(searchValue, O, replaceValue)
      : $replace.call(String(O), searchValue, replaceValue);
  }, $replace];
});

},{"./_fix-re-wks":47}],236:[function(require,module,exports){
// @@search logic
require('./_fix-re-wks')('search', 1, function (defined, SEARCH, $search) {
  // 21.1.3.15 String.prototype.search(regexp)
  return [function search(regexp) {
    'use strict';
    var O = defined(this);
    var fn = regexp == undefined ? undefined : regexp[SEARCH];
    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
  }, $search];
});

},{"./_fix-re-wks":47}],237:[function(require,module,exports){
// @@split logic
require('./_fix-re-wks')('split', 2, function (defined, SPLIT, $split) {
  'use strict';
  var isRegExp = require('./_is-regexp');
  var _split = $split;
  var $push = [].push;
  var $SPLIT = 'split';
  var LENGTH = 'length';
  var LAST_INDEX = 'lastIndex';
  if (
    'abbc'[$SPLIT](/(b)*/)[1] == 'c' ||
    'test'[$SPLIT](/(?:)/, -1)[LENGTH] != 4 ||
    'ab'[$SPLIT](/(?:ab)*/)[LENGTH] != 2 ||
    '.'[$SPLIT](/(.?)(.?)/)[LENGTH] != 4 ||
    '.'[$SPLIT](/()()/)[LENGTH] > 1 ||
    ''[$SPLIT](/.?/)[LENGTH]
  ) {
    var NPCG = /()??/.exec('')[1] === undefined; // nonparticipating capturing group
    // based on es5-shim implementation, need to rework it
    $split = function (separator, limit) {
      var string = String(this);
      if (separator === undefined && limit === 0) return [];
      // If `separator` is not a regex, use native split
      if (!isRegExp(separator)) return _split.call(string, separator, limit);
      var output = [];
      var flags = (separator.ignoreCase ? 'i' : '') +
                  (separator.multiline ? 'm' : '') +
                  (separator.unicode ? 'u' : '') +
                  (separator.sticky ? 'y' : '');
      var lastLastIndex = 0;
      var splitLimit = limit === undefined ? 4294967295 : limit >>> 0;
      // Make `global` and avoid `lastIndex` issues by working with a copy
      var separatorCopy = new RegExp(separator.source, flags + 'g');
      var separator2, match, lastIndex, lastLength, i;
      // Doesn't need flags gy, but they don't hurt
      if (!NPCG) separator2 = new RegExp('^' + separatorCopy.source + '$(?!\\s)', flags);
      while (match = separatorCopy.exec(string)) {
        // `separatorCopy.lastIndex` is not reliable cross-browser
        lastIndex = match.index + match[0][LENGTH];
        if (lastIndex > lastLastIndex) {
          output.push(string.slice(lastLastIndex, match.index));
          // Fix browsers whose `exec` methods don't consistently return `undefined` for NPCG
          // eslint-disable-next-line no-loop-func
          if (!NPCG && match[LENGTH] > 1) match[0].replace(separator2, function () {
            for (i = 1; i < arguments[LENGTH] - 2; i++) if (arguments[i] === undefined) match[i] = undefined;
          });
          if (match[LENGTH] > 1 && match.index < string[LENGTH]) $push.apply(output, match.slice(1));
          lastLength = match[0][LENGTH];
          lastLastIndex = lastIndex;
          if (output[LENGTH] >= splitLimit) break;
        }
        if (separatorCopy[LAST_INDEX] === match.index) separatorCopy[LAST_INDEX]++; // Avoid an infinite loop
      }
      if (lastLastIndex === string[LENGTH]) {
        if (lastLength || !separatorCopy.test('')) output.push('');
      } else output.push(string.slice(lastLastIndex));
      return output[LENGTH] > splitLimit ? output.slice(0, splitLimit) : output;
    };
  // Chakra, V8
  } else if ('0'[$SPLIT](undefined, 0)[LENGTH]) {
    $split = function (separator, limit) {
      return separator === undefined && limit === 0 ? [] : _split.call(this, separator, limit);
    };
  }
  // 21.1.3.17 String.prototype.split(separator, limit)
  return [function split(separator, limit) {
    var O = defined(this);
    var fn = separator == undefined ? undefined : separator[SPLIT];
    return fn !== undefined ? fn.call(separator, O, limit) : $split.call(String(O), separator, limit);
  }, $split];
});

},{"./_fix-re-wks":47,"./_is-regexp":63}],238:[function(require,module,exports){
'use strict';
require('./es6.regexp.flags');
var anObject = require('./_an-object');
var $flags = require('./_flags');
var DESCRIPTORS = require('./_descriptors');
var TO_STRING = 'toString';
var $toString = /./[TO_STRING];

var define = function (fn) {
  require('./_redefine')(RegExp.prototype, TO_STRING, fn, true);
};

// 21.2.5.14 RegExp.prototype.toString()
if (require('./_fails')(function () { return $toString.call({ source: 'a', flags: 'b' }) != '/a/b'; })) {
  define(function toString() {
    var R = anObject(this);
    return '/'.concat(R.source, '/',
      'flags' in R ? R.flags : !DESCRIPTORS && R instanceof RegExp ? $flags.call(R) : undefined);
  });
// FF44- RegExp#toString has a wrong name
} else if ($toString.name != TO_STRING) {
  define(function toString() {
    return $toString.call(this);
  });
}

},{"./_an-object":18,"./_descriptors":40,"./_fails":46,"./_flags":48,"./_redefine":102,"./es6.regexp.flags":233}],239:[function(require,module,exports){
'use strict';
var strong = require('./_collection-strong');
var validate = require('./_validate-collection');
var SET = 'Set';

// 23.2 Set Objects
module.exports = require('./_collection')(SET, function (get) {
  return function Set() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.2.3.1 Set.prototype.add(value)
  add: function add(value) {
    return strong.def(validate(this, SET), value = value === 0 ? 0 : value, value);
  }
}, strong);

},{"./_collection":33,"./_collection-strong":30,"./_validate-collection":133}],240:[function(require,module,exports){
'use strict';
// B.2.3.2 String.prototype.anchor(name)
require('./_string-html')('anchor', function (createHTML) {
  return function anchor(name) {
    return createHTML(this, 'a', 'name', name);
  };
});

},{"./_string-html":116}],241:[function(require,module,exports){
'use strict';
// B.2.3.3 String.prototype.big()
require('./_string-html')('big', function (createHTML) {
  return function big() {
    return createHTML(this, 'big', '', '');
  };
});

},{"./_string-html":116}],242:[function(require,module,exports){
'use strict';
// B.2.3.4 String.prototype.blink()
require('./_string-html')('blink', function (createHTML) {
  return function blink() {
    return createHTML(this, 'blink', '', '');
  };
});

},{"./_string-html":116}],243:[function(require,module,exports){
'use strict';
// B.2.3.5 String.prototype.bold()
require('./_string-html')('bold', function (createHTML) {
  return function bold() {
    return createHTML(this, 'b', '', '');
  };
});

},{"./_string-html":116}],244:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var $at = require('./_string-at')(false);
$export($export.P, 'String', {
  // 21.1.3.3 String.prototype.codePointAt(pos)
  codePointAt: function codePointAt(pos) {
    return $at(this, pos);
  }
});

},{"./_export":44,"./_string-at":114}],245:[function(require,module,exports){
// 21.1.3.6 String.prototype.endsWith(searchString [, endPosition])
'use strict';
var $export = require('./_export');
var toLength = require('./_to-length');
var context = require('./_string-context');
var ENDS_WITH = 'endsWith';
var $endsWith = ''[ENDS_WITH];

$export($export.P + $export.F * require('./_fails-is-regexp')(ENDS_WITH), 'String', {
  endsWith: function endsWith(searchString /* , endPosition = @length */) {
    var that = context(this, searchString, ENDS_WITH);
    var endPosition = arguments.length > 1 ? arguments[1] : undefined;
    var len = toLength(that.length);
    var end = endPosition === undefined ? len : Math.min(toLength(endPosition), len);
    var search = String(searchString);
    return $endsWith
      ? $endsWith.call(that, search, end)
      : that.slice(end - search.length, end) === search;
  }
});

},{"./_export":44,"./_fails-is-regexp":45,"./_string-context":115,"./_to-length":126}],246:[function(require,module,exports){
'use strict';
// B.2.3.6 String.prototype.fixed()
require('./_string-html')('fixed', function (createHTML) {
  return function fixed() {
    return createHTML(this, 'tt', '', '');
  };
});

},{"./_string-html":116}],247:[function(require,module,exports){
'use strict';
// B.2.3.7 String.prototype.fontcolor(color)
require('./_string-html')('fontcolor', function (createHTML) {
  return function fontcolor(color) {
    return createHTML(this, 'font', 'color', color);
  };
});

},{"./_string-html":116}],248:[function(require,module,exports){
'use strict';
// B.2.3.8 String.prototype.fontsize(size)
require('./_string-html')('fontsize', function (createHTML) {
  return function fontsize(size) {
    return createHTML(this, 'font', 'size', size);
  };
});

},{"./_string-html":116}],249:[function(require,module,exports){
var $export = require('./_export');
var toAbsoluteIndex = require('./_to-absolute-index');
var fromCharCode = String.fromCharCode;
var $fromCodePoint = String.fromCodePoint;

// length should be 1, old FF problem
$export($export.S + $export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {
  // 21.1.2.2 String.fromCodePoint(...codePoints)
  fromCodePoint: function fromCodePoint(x) { // eslint-disable-line no-unused-vars
    var res = [];
    var aLen = arguments.length;
    var i = 0;
    var code;
    while (aLen > i) {
      code = +arguments[i++];
      if (toAbsoluteIndex(code, 0x10ffff) !== code) throw RangeError(code + ' is not a valid code point');
      res.push(code < 0x10000
        ? fromCharCode(code)
        : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00)
      );
    } return res.join('');
  }
});

},{"./_export":44,"./_to-absolute-index":122}],250:[function(require,module,exports){
// 21.1.3.7 String.prototype.includes(searchString, position = 0)
'use strict';
var $export = require('./_export');
var context = require('./_string-context');
var INCLUDES = 'includes';

$export($export.P + $export.F * require('./_fails-is-regexp')(INCLUDES), 'String', {
  includes: function includes(searchString /* , position = 0 */) {
    return !!~context(this, searchString, INCLUDES)
      .indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);
  }
});

},{"./_export":44,"./_fails-is-regexp":45,"./_string-context":115}],251:[function(require,module,exports){
'use strict';
// B.2.3.9 String.prototype.italics()
require('./_string-html')('italics', function (createHTML) {
  return function italics() {
    return createHTML(this, 'i', '', '');
  };
});

},{"./_string-html":116}],252:[function(require,module,exports){
'use strict';
var $at = require('./_string-at')(true);

// 21.1.3.27 String.prototype[@@iterator]()
require('./_iter-define')(String, 'String', function (iterated) {
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var index = this._i;
  var point;
  if (index >= O.length) return { value: undefined, done: true };
  point = $at(O, index);
  this._i += point.length;
  return { value: point, done: false };
});

},{"./_iter-define":66,"./_string-at":114}],253:[function(require,module,exports){
'use strict';
// B.2.3.10 String.prototype.link(url)
require('./_string-html')('link', function (createHTML) {
  return function link(url) {
    return createHTML(this, 'a', 'href', url);
  };
});

},{"./_string-html":116}],254:[function(require,module,exports){
var $export = require('./_export');
var toIObject = require('./_to-iobject');
var toLength = require('./_to-length');

$export($export.S, 'String', {
  // 21.1.2.4 String.raw(callSite, ...substitutions)
  raw: function raw(callSite) {
    var tpl = toIObject(callSite.raw);
    var len = toLength(tpl.length);
    var aLen = arguments.length;
    var res = [];
    var i = 0;
    while (len > i) {
      res.push(String(tpl[i++]));
      if (i < aLen) res.push(String(arguments[i]));
    } return res.join('');
  }
});

},{"./_export":44,"./_to-iobject":125,"./_to-length":126}],255:[function(require,module,exports){
var $export = require('./_export');

$export($export.P, 'String', {
  // 21.1.3.13 String.prototype.repeat(count)
  repeat: require('./_string-repeat')
});

},{"./_export":44,"./_string-repeat":118}],256:[function(require,module,exports){
'use strict';
// B.2.3.11 String.prototype.small()
require('./_string-html')('small', function (createHTML) {
  return function small() {
    return createHTML(this, 'small', '', '');
  };
});

},{"./_string-html":116}],257:[function(require,module,exports){
// 21.1.3.18 String.prototype.startsWith(searchString [, position ])
'use strict';
var $export = require('./_export');
var toLength = require('./_to-length');
var context = require('./_string-context');
var STARTS_WITH = 'startsWith';
var $startsWith = ''[STARTS_WITH];

$export($export.P + $export.F * require('./_fails-is-regexp')(STARTS_WITH), 'String', {
  startsWith: function startsWith(searchString /* , position = 0 */) {
    var that = context(this, searchString, STARTS_WITH);
    var index = toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length));
    var search = String(searchString);
    return $startsWith
      ? $startsWith.call(that, search, index)
      : that.slice(index, index + search.length) === search;
  }
});

},{"./_export":44,"./_fails-is-regexp":45,"./_string-context":115,"./_to-length":126}],258:[function(require,module,exports){
'use strict';
// B.2.3.12 String.prototype.strike()
require('./_string-html')('strike', function (createHTML) {
  return function strike() {
    return createHTML(this, 'strike', '', '');
  };
});

},{"./_string-html":116}],259:[function(require,module,exports){
'use strict';
// B.2.3.13 String.prototype.sub()
require('./_string-html')('sub', function (createHTML) {
  return function sub() {
    return createHTML(this, 'sub', '', '');
  };
});

},{"./_string-html":116}],260:[function(require,module,exports){
'use strict';
// B.2.3.14 String.prototype.sup()
require('./_string-html')('sup', function (createHTML) {
  return function sup() {
    return createHTML(this, 'sup', '', '');
  };
});

},{"./_string-html":116}],261:[function(require,module,exports){
'use strict';
// 21.1.3.25 String.prototype.trim()
require('./_string-trim')('trim', function ($trim) {
  return function trim() {
    return $trim(this, 3);
  };
});

},{"./_string-trim":119}],262:[function(require,module,exports){
'use strict';
// ECMAScript 6 symbols shim
var global = require('./_global');
var has = require('./_has');
var DESCRIPTORS = require('./_descriptors');
var $export = require('./_export');
var redefine = require('./_redefine');
var META = require('./_meta').KEY;
var $fails = require('./_fails');
var shared = require('./_shared');
var setToStringTag = require('./_set-to-string-tag');
var uid = require('./_uid');
var wks = require('./_wks');
var wksExt = require('./_wks-ext');
var wksDefine = require('./_wks-define');
var enumKeys = require('./_enum-keys');
var isArray = require('./_is-array');
var anObject = require('./_an-object');
var toIObject = require('./_to-iobject');
var toPrimitive = require('./_to-primitive');
var createDesc = require('./_property-desc');
var _create = require('./_object-create');
var gOPNExt = require('./_object-gopn-ext');
var $GOPD = require('./_object-gopd');
var $DP = require('./_object-dp');
var $keys = require('./_object-keys');
var gOPD = $GOPD.f;
var dP = $DP.f;
var gOPN = gOPNExt.f;
var $Symbol = global.Symbol;
var $JSON = global.JSON;
var _stringify = $JSON && $JSON.stringify;
var PROTOTYPE = 'prototype';
var HIDDEN = wks('_hidden');
var TO_PRIMITIVE = wks('toPrimitive');
var isEnum = {}.propertyIsEnumerable;
var SymbolRegistry = shared('symbol-registry');
var AllSymbols = shared('symbols');
var OPSymbols = shared('op-symbols');
var ObjectProto = Object[PROTOTYPE];
var USE_NATIVE = typeof $Symbol == 'function';
var QObject = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = DESCRIPTORS && $fails(function () {
  return _create(dP({}, 'a', {
    get: function () { return dP(this, 'a', { value: 7 }).a; }
  })).a != 7;
}) ? function (it, key, D) {
  var protoDesc = gOPD(ObjectProto, key);
  if (protoDesc) delete ObjectProto[key];
  dP(it, key, D);
  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function (tag) {
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D) {
  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);
  if (has(AllSymbols, key)) {
    if (!D.enumerable) {
      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
      D = _create(D, { enumerable: createDesc(0, false) });
    } return setSymbolDesc(it, key, D);
  } return dP(it, key, D);
};
var $defineProperties = function defineProperties(it, P) {
  anObject(it);
  var keys = enumKeys(P = toIObject(P));
  var i = 0;
  var l = keys.length;
  var key;
  while (l > i) $defineProperty(it, key = keys[i++], P[key]);
  return it;
};
var $create = function create(it, P) {
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key) {
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
  it = toIObject(it);
  key = toPrimitive(key, true);
  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
  var D = gOPD(it, key);
  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it) {
  var names = gOPN(toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
  } return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
  var IS_OP = it === ObjectProto;
  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
  } return result;
};

// 19.4.1.1 Symbol([description])
if (!USE_NATIVE) {
  $Symbol = function Symbol() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
    var $set = function (value) {
      if (this === ObjectProto) $set.call(OPSymbols, value);
      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };
    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
    return wrap(tag);
  };
  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
    return this._k;
  });

  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f = $defineProperty;
  require('./_object-gopn').f = gOPNExt.f = $getOwnPropertyNames;
  require('./_object-pie').f = $propertyIsEnumerable;
  require('./_object-gops').f = $getOwnPropertySymbols;

  if (DESCRIPTORS && !require('./_library')) {
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function (name) {
    return wrap(wks(name));
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });

for (var es6Symbols = (
  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
).split(','), j = 0; es6Symbols.length > j;)wks(es6Symbols[j++]);

for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);

$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function (key) {
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');
    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
  },
  useSetter: function () { setter = true; },
  useSimple: function () { setter = false; }
});

$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it) {
    if (it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
    var args = [it];
    var i = 1;
    var replacer, $replacer;
    while (arguments.length > i) args.push(arguments[i++]);
    replacer = args[1];
    if (typeof replacer == 'function') $replacer = replacer;
    if ($replacer || !isArray(replacer)) replacer = function (key, value) {
      if ($replacer) value = $replacer.call(this, key, value);
      if (!isSymbol(value)) return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
});

// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
$Symbol[PROTOTYPE][TO_PRIMITIVE] || require('./_hide')($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setToStringTag(global.JSON, 'JSON', true);

},{"./_an-object":18,"./_descriptors":40,"./_enum-keys":43,"./_export":44,"./_fails":46,"./_global":51,"./_has":52,"./_hide":53,"./_is-array":60,"./_library":70,"./_meta":76,"./_object-create":81,"./_object-dp":82,"./_object-gopd":85,"./_object-gopn":87,"./_object-gopn-ext":86,"./_object-gops":88,"./_object-keys":91,"./_object-pie":92,"./_property-desc":100,"./_redefine":102,"./_set-to-string-tag":109,"./_shared":111,"./_to-iobject":125,"./_to-primitive":128,"./_uid":132,"./_wks":136,"./_wks-define":134,"./_wks-ext":135}],263:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var $typed = require('./_typed');
var buffer = require('./_typed-buffer');
var anObject = require('./_an-object');
var toAbsoluteIndex = require('./_to-absolute-index');
var toLength = require('./_to-length');
var isObject = require('./_is-object');
var ArrayBuffer = require('./_global').ArrayBuffer;
var speciesConstructor = require('./_species-constructor');
var $ArrayBuffer = buffer.ArrayBuffer;
var $DataView = buffer.DataView;
var $isView = $typed.ABV && ArrayBuffer.isView;
var $slice = $ArrayBuffer.prototype.slice;
var VIEW = $typed.VIEW;
var ARRAY_BUFFER = 'ArrayBuffer';

$export($export.G + $export.W + $export.F * (ArrayBuffer !== $ArrayBuffer), { ArrayBuffer: $ArrayBuffer });

$export($export.S + $export.F * !$typed.CONSTR, ARRAY_BUFFER, {
  // 24.1.3.1 ArrayBuffer.isView(arg)
  isView: function isView(it) {
    return $isView && $isView(it) || isObject(it) && VIEW in it;
  }
});

$export($export.P + $export.U + $export.F * require('./_fails')(function () {
  return !new $ArrayBuffer(2).slice(1, undefined).byteLength;
}), ARRAY_BUFFER, {
  // 24.1.4.3 ArrayBuffer.prototype.slice(start, end)
  slice: function slice(start, end) {
    if ($slice !== undefined && end === undefined) return $slice.call(anObject(this), start); // FF fix
    var len = anObject(this).byteLength;
    var first = toAbsoluteIndex(start, len);
    var final = toAbsoluteIndex(end === undefined ? len : end, len);
    var result = new (speciesConstructor(this, $ArrayBuffer))(toLength(final - first));
    var viewS = new $DataView(this);
    var viewT = new $DataView(result);
    var index = 0;
    while (first < final) {
      viewT.setUint8(index++, viewS.getUint8(first++));
    } return result;
  }
});

require('./_set-species')(ARRAY_BUFFER);

},{"./_an-object":18,"./_export":44,"./_fails":46,"./_global":51,"./_is-object":62,"./_set-species":108,"./_species-constructor":112,"./_to-absolute-index":122,"./_to-length":126,"./_typed":131,"./_typed-buffer":130}],264:[function(require,module,exports){
var $export = require('./_export');
$export($export.G + $export.W + $export.F * !require('./_typed').ABV, {
  DataView: require('./_typed-buffer').DataView
});

},{"./_export":44,"./_typed":131,"./_typed-buffer":130}],265:[function(require,module,exports){
require('./_typed-array')('Float32', 4, function (init) {
  return function Float32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":129}],266:[function(require,module,exports){
require('./_typed-array')('Float64', 8, function (init) {
  return function Float64Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":129}],267:[function(require,module,exports){
require('./_typed-array')('Int16', 2, function (init) {
  return function Int16Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":129}],268:[function(require,module,exports){
require('./_typed-array')('Int32', 4, function (init) {
  return function Int32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":129}],269:[function(require,module,exports){
require('./_typed-array')('Int8', 1, function (init) {
  return function Int8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":129}],270:[function(require,module,exports){
require('./_typed-array')('Uint16', 2, function (init) {
  return function Uint16Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":129}],271:[function(require,module,exports){
require('./_typed-array')('Uint32', 4, function (init) {
  return function Uint32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":129}],272:[function(require,module,exports){
require('./_typed-array')('Uint8', 1, function (init) {
  return function Uint8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":129}],273:[function(require,module,exports){
require('./_typed-array')('Uint8', 1, function (init) {
  return function Uint8ClampedArray(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
}, true);

},{"./_typed-array":129}],274:[function(require,module,exports){
'use strict';
var each = require('./_array-methods')(0);
var redefine = require('./_redefine');
var meta = require('./_meta');
var assign = require('./_object-assign');
var weak = require('./_collection-weak');
var isObject = require('./_is-object');
var fails = require('./_fails');
var validate = require('./_validate-collection');
var WEAK_MAP = 'WeakMap';
var getWeak = meta.getWeak;
var isExtensible = Object.isExtensible;
var uncaughtFrozenStore = weak.ufstore;
var tmp = {};
var InternalMap;

var wrapper = function (get) {
  return function WeakMap() {
    return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
};

var methods = {
  // 23.3.3.3 WeakMap.prototype.get(key)
  get: function get(key) {
    if (isObject(key)) {
      var data = getWeak(key);
      if (data === true) return uncaughtFrozenStore(validate(this, WEAK_MAP)).get(key);
      return data ? data[this._i] : undefined;
    }
  },
  // 23.3.3.5 WeakMap.prototype.set(key, value)
  set: function set(key, value) {
    return weak.def(validate(this, WEAK_MAP), key, value);
  }
};

// 23.3 WeakMap Objects
var $WeakMap = module.exports = require('./_collection')(WEAK_MAP, wrapper, methods, weak, true, true);

// IE11 WeakMap frozen keys fix
if (fails(function () { return new $WeakMap().set((Object.freeze || Object)(tmp), 7).get(tmp) != 7; })) {
  InternalMap = weak.getConstructor(wrapper, WEAK_MAP);
  assign(InternalMap.prototype, methods);
  meta.NEED = true;
  each(['delete', 'has', 'get', 'set'], function (key) {
    var proto = $WeakMap.prototype;
    var method = proto[key];
    redefine(proto, key, function (a, b) {
      // store frozen objects on internal weakmap shim
      if (isObject(a) && !isExtensible(a)) {
        if (!this._f) this._f = new InternalMap();
        var result = this._f[key](a, b);
        return key == 'set' ? this : result;
      // store all the rest on native weakmap
      } return method.call(this, a, b);
    });
  });
}

},{"./_array-methods":23,"./_collection":33,"./_collection-weak":32,"./_fails":46,"./_is-object":62,"./_meta":76,"./_object-assign":80,"./_redefine":102,"./_validate-collection":133}],275:[function(require,module,exports){
'use strict';
var weak = require('./_collection-weak');
var validate = require('./_validate-collection');
var WEAK_SET = 'WeakSet';

// 23.4 WeakSet Objects
require('./_collection')(WEAK_SET, function (get) {
  return function WeakSet() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.4.3.1 WeakSet.prototype.add(value)
  add: function add(value) {
    return weak.def(validate(this, WEAK_SET), value, true);
  }
}, weak, false, true);

},{"./_collection":33,"./_collection-weak":32,"./_validate-collection":133}],276:[function(require,module,exports){
'use strict';
// https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatMap
var $export = require('./_export');
var flattenIntoArray = require('./_flatten-into-array');
var toObject = require('./_to-object');
var toLength = require('./_to-length');
var aFunction = require('./_a-function');
var arraySpeciesCreate = require('./_array-species-create');

$export($export.P, 'Array', {
  flatMap: function flatMap(callbackfn /* , thisArg */) {
    var O = toObject(this);
    var sourceLen, A;
    aFunction(callbackfn);
    sourceLen = toLength(O.length);
    A = arraySpeciesCreate(O, 0);
    flattenIntoArray(A, O, O, sourceLen, 0, 1, callbackfn, arguments[1]);
    return A;
  }
});

require('./_add-to-unscopables')('flatMap');

},{"./_a-function":14,"./_add-to-unscopables":16,"./_array-species-create":26,"./_export":44,"./_flatten-into-array":49,"./_to-length":126,"./_to-object":127}],277:[function(require,module,exports){
'use strict';
// https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatten
var $export = require('./_export');
var flattenIntoArray = require('./_flatten-into-array');
var toObject = require('./_to-object');
var toLength = require('./_to-length');
var toInteger = require('./_to-integer');
var arraySpeciesCreate = require('./_array-species-create');

$export($export.P, 'Array', {
  flatten: function flatten(/* depthArg = 1 */) {
    var depthArg = arguments[0];
    var O = toObject(this);
    var sourceLen = toLength(O.length);
    var A = arraySpeciesCreate(O, 0);
    flattenIntoArray(A, O, O, sourceLen, 0, depthArg === undefined ? 1 : toInteger(depthArg));
    return A;
  }
});

require('./_add-to-unscopables')('flatten');

},{"./_add-to-unscopables":16,"./_array-species-create":26,"./_export":44,"./_flatten-into-array":49,"./_to-integer":124,"./_to-length":126,"./_to-object":127}],278:[function(require,module,exports){
'use strict';
// https://github.com/tc39/Array.prototype.includes
var $export = require('./_export');
var $includes = require('./_array-includes')(true);

$export($export.P, 'Array', {
  includes: function includes(el /* , fromIndex = 0 */) {
    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
  }
});

require('./_add-to-unscopables')('includes');

},{"./_add-to-unscopables":16,"./_array-includes":22,"./_export":44}],279:[function(require,module,exports){
// https://github.com/rwaldron/tc39-notes/blob/master/es6/2014-09/sept-25.md#510-globalasap-for-enqueuing-a-microtask
var $export = require('./_export');
var microtask = require('./_microtask')();
var process = require('./_global').process;
var isNode = require('./_cof')(process) == 'process';

$export($export.G, {
  asap: function asap(fn) {
    var domain = isNode && process.domain;
    microtask(domain ? domain.bind(fn) : fn);
  }
});

},{"./_cof":29,"./_export":44,"./_global":51,"./_microtask":78}],280:[function(require,module,exports){
// https://github.com/ljharb/proposal-is-error
var $export = require('./_export');
var cof = require('./_cof');

$export($export.S, 'Error', {
  isError: function isError(it) {
    return cof(it) === 'Error';
  }
});

},{"./_cof":29,"./_export":44}],281:[function(require,module,exports){
// https://github.com/tc39/proposal-global
var $export = require('./_export');

$export($export.G, { global: require('./_global') });

},{"./_export":44,"./_global":51}],282:[function(require,module,exports){
// https://tc39.github.io/proposal-setmap-offrom/#sec-map.from
require('./_set-collection-from')('Map');

},{"./_set-collection-from":105}],283:[function(require,module,exports){
// https://tc39.github.io/proposal-setmap-offrom/#sec-map.of
require('./_set-collection-of')('Map');

},{"./_set-collection-of":106}],284:[function(require,module,exports){
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export = require('./_export');

$export($export.P + $export.R, 'Map', { toJSON: require('./_collection-to-json')('Map') });

},{"./_collection-to-json":31,"./_export":44}],285:[function(require,module,exports){
// https://rwaldron.github.io/proposal-math-extensions/
var $export = require('./_export');

$export($export.S, 'Math', {
  clamp: function clamp(x, lower, upper) {
    return Math.min(upper, Math.max(lower, x));
  }
});

},{"./_export":44}],286:[function(require,module,exports){
// https://rwaldron.github.io/proposal-math-extensions/
var $export = require('./_export');

$export($export.S, 'Math', { DEG_PER_RAD: Math.PI / 180 });

},{"./_export":44}],287:[function(require,module,exports){
// https://rwaldron.github.io/proposal-math-extensions/
var $export = require('./_export');
var RAD_PER_DEG = 180 / Math.PI;

$export($export.S, 'Math', {
  degrees: function degrees(radians) {
    return radians * RAD_PER_DEG;
  }
});

},{"./_export":44}],288:[function(require,module,exports){
// https://rwaldron.github.io/proposal-math-extensions/
var $export = require('./_export');
var scale = require('./_math-scale');
var fround = require('./_math-fround');

$export($export.S, 'Math', {
  fscale: function fscale(x, inLow, inHigh, outLow, outHigh) {
    return fround(scale(x, inLow, inHigh, outLow, outHigh));
  }
});

},{"./_export":44,"./_math-fround":72,"./_math-scale":74}],289:[function(require,module,exports){
// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = require('./_export');

$export($export.S, 'Math', {
  iaddh: function iaddh(x0, x1, y0, y1) {
    var $x0 = x0 >>> 0;
    var $x1 = x1 >>> 0;
    var $y0 = y0 >>> 0;
    return $x1 + (y1 >>> 0) + (($x0 & $y0 | ($x0 | $y0) & ~($x0 + $y0 >>> 0)) >>> 31) | 0;
  }
});

},{"./_export":44}],290:[function(require,module,exports){
// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = require('./_export');

$export($export.S, 'Math', {
  imulh: function imulh(u, v) {
    var UINT16 = 0xffff;
    var $u = +u;
    var $v = +v;
    var u0 = $u & UINT16;
    var v0 = $v & UINT16;
    var u1 = $u >> 16;
    var v1 = $v >> 16;
    var t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
    return u1 * v1 + (t >> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >> 16);
  }
});

},{"./_export":44}],291:[function(require,module,exports){
// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = require('./_export');

$export($export.S, 'Math', {
  isubh: function isubh(x0, x1, y0, y1) {
    var $x0 = x0 >>> 0;
    var $x1 = x1 >>> 0;
    var $y0 = y0 >>> 0;
    return $x1 - (y1 >>> 0) - ((~$x0 & $y0 | ~($x0 ^ $y0) & $x0 - $y0 >>> 0) >>> 31) | 0;
  }
});

},{"./_export":44}],292:[function(require,module,exports){
// https://rwaldron.github.io/proposal-math-extensions/
var $export = require('./_export');

$export($export.S, 'Math', { RAD_PER_DEG: 180 / Math.PI });

},{"./_export":44}],293:[function(require,module,exports){
// https://rwaldron.github.io/proposal-math-extensions/
var $export = require('./_export');
var DEG_PER_RAD = Math.PI / 180;

$export($export.S, 'Math', {
  radians: function radians(degrees) {
    return degrees * DEG_PER_RAD;
  }
});

},{"./_export":44}],294:[function(require,module,exports){
// https://rwaldron.github.io/proposal-math-extensions/
var $export = require('./_export');

$export($export.S, 'Math', { scale: require('./_math-scale') });

},{"./_export":44,"./_math-scale":74}],295:[function(require,module,exports){
// http://jfbastien.github.io/papers/Math.signbit.html
var $export = require('./_export');

$export($export.S, 'Math', { signbit: function signbit(x) {
  // eslint-disable-next-line no-self-compare
  return (x = +x) != x ? x : x == 0 ? 1 / x == Infinity : x > 0;
} });

},{"./_export":44}],296:[function(require,module,exports){
// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = require('./_export');

$export($export.S, 'Math', {
  umulh: function umulh(u, v) {
    var UINT16 = 0xffff;
    var $u = +u;
    var $v = +v;
    var u0 = $u & UINT16;
    var v0 = $v & UINT16;
    var u1 = $u >>> 16;
    var v1 = $v >>> 16;
    var t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
    return u1 * v1 + (t >>> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >>> 16);
  }
});

},{"./_export":44}],297:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var toObject = require('./_to-object');
var aFunction = require('./_a-function');
var $defineProperty = require('./_object-dp');

// B.2.2.2 Object.prototype.__defineGetter__(P, getter)
require('./_descriptors') && $export($export.P + require('./_object-forced-pam'), 'Object', {
  __defineGetter__: function __defineGetter__(P, getter) {
    $defineProperty.f(toObject(this), P, { get: aFunction(getter), enumerable: true, configurable: true });
  }
});

},{"./_a-function":14,"./_descriptors":40,"./_export":44,"./_object-dp":82,"./_object-forced-pam":84,"./_to-object":127}],298:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var toObject = require('./_to-object');
var aFunction = require('./_a-function');
var $defineProperty = require('./_object-dp');

// B.2.2.3 Object.prototype.__defineSetter__(P, setter)
require('./_descriptors') && $export($export.P + require('./_object-forced-pam'), 'Object', {
  __defineSetter__: function __defineSetter__(P, setter) {
    $defineProperty.f(toObject(this), P, { set: aFunction(setter), enumerable: true, configurable: true });
  }
});

},{"./_a-function":14,"./_descriptors":40,"./_export":44,"./_object-dp":82,"./_object-forced-pam":84,"./_to-object":127}],299:[function(require,module,exports){
// https://github.com/tc39/proposal-object-values-entries
var $export = require('./_export');
var $entries = require('./_object-to-array')(true);

$export($export.S, 'Object', {
  entries: function entries(it) {
    return $entries(it);
  }
});

},{"./_export":44,"./_object-to-array":94}],300:[function(require,module,exports){
// https://github.com/tc39/proposal-object-getownpropertydescriptors
var $export = require('./_export');
var ownKeys = require('./_own-keys');
var toIObject = require('./_to-iobject');
var gOPD = require('./_object-gopd');
var createProperty = require('./_create-property');

$export($export.S, 'Object', {
  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
    var O = toIObject(object);
    var getDesc = gOPD.f;
    var keys = ownKeys(O);
    var result = {};
    var i = 0;
    var key, desc;
    while (keys.length > i) {
      desc = getDesc(O, key = keys[i++]);
      if (desc !== undefined) createProperty(result, key, desc);
    }
    return result;
  }
});

},{"./_create-property":35,"./_export":44,"./_object-gopd":85,"./_own-keys":95,"./_to-iobject":125}],301:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var toObject = require('./_to-object');
var toPrimitive = require('./_to-primitive');
var getPrototypeOf = require('./_object-gpo');
var getOwnPropertyDescriptor = require('./_object-gopd').f;

// B.2.2.4 Object.prototype.__lookupGetter__(P)
require('./_descriptors') && $export($export.P + require('./_object-forced-pam'), 'Object', {
  __lookupGetter__: function __lookupGetter__(P) {
    var O = toObject(this);
    var K = toPrimitive(P, true);
    var D;
    do {
      if (D = getOwnPropertyDescriptor(O, K)) return D.get;
    } while (O = getPrototypeOf(O));
  }
});

},{"./_descriptors":40,"./_export":44,"./_object-forced-pam":84,"./_object-gopd":85,"./_object-gpo":89,"./_to-object":127,"./_to-primitive":128}],302:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var toObject = require('./_to-object');
var toPrimitive = require('./_to-primitive');
var getPrototypeOf = require('./_object-gpo');
var getOwnPropertyDescriptor = require('./_object-gopd').f;

// B.2.2.5 Object.prototype.__lookupSetter__(P)
require('./_descriptors') && $export($export.P + require('./_object-forced-pam'), 'Object', {
  __lookupSetter__: function __lookupSetter__(P) {
    var O = toObject(this);
    var K = toPrimitive(P, true);
    var D;
    do {
      if (D = getOwnPropertyDescriptor(O, K)) return D.set;
    } while (O = getPrototypeOf(O));
  }
});

},{"./_descriptors":40,"./_export":44,"./_object-forced-pam":84,"./_object-gopd":85,"./_object-gpo":89,"./_to-object":127,"./_to-primitive":128}],303:[function(require,module,exports){
// https://github.com/tc39/proposal-object-values-entries
var $export = require('./_export');
var $values = require('./_object-to-array')(false);

$export($export.S, 'Object', {
  values: function values(it) {
    return $values(it);
  }
});

},{"./_export":44,"./_object-to-array":94}],304:[function(require,module,exports){
'use strict';
// https://github.com/zenparsing/es-observable
var $export = require('./_export');
var global = require('./_global');
var core = require('./_core');
var microtask = require('./_microtask')();
var OBSERVABLE = require('./_wks')('observable');
var aFunction = require('./_a-function');
var anObject = require('./_an-object');
var anInstance = require('./_an-instance');
var redefineAll = require('./_redefine-all');
var hide = require('./_hide');
var forOf = require('./_for-of');
var RETURN = forOf.RETURN;

var getMethod = function (fn) {
  return fn == null ? undefined : aFunction(fn);
};

var cleanupSubscription = function (subscription) {
  var cleanup = subscription._c;
  if (cleanup) {
    subscription._c = undefined;
    cleanup();
  }
};

var subscriptionClosed = function (subscription) {
  return subscription._o === undefined;
};

var closeSubscription = function (subscription) {
  if (!subscriptionClosed(subscription)) {
    subscription._o = undefined;
    cleanupSubscription(subscription);
  }
};

var Subscription = function (observer, subscriber) {
  anObject(observer);
  this._c = undefined;
  this._o = observer;
  observer = new SubscriptionObserver(this);
  try {
    var cleanup = subscriber(observer);
    var subscription = cleanup;
    if (cleanup != null) {
      if (typeof cleanup.unsubscribe === 'function') cleanup = function () { subscription.unsubscribe(); };
      else aFunction(cleanup);
      this._c = cleanup;
    }
  } catch (e) {
    observer.error(e);
    return;
  } if (subscriptionClosed(this)) cleanupSubscription(this);
};

Subscription.prototype = redefineAll({}, {
  unsubscribe: function unsubscribe() { closeSubscription(this); }
});

var SubscriptionObserver = function (subscription) {
  this._s = subscription;
};

SubscriptionObserver.prototype = redefineAll({}, {
  next: function next(value) {
    var subscription = this._s;
    if (!subscriptionClosed(subscription)) {
      var observer = subscription._o;
      try {
        var m = getMethod(observer.next);
        if (m) return m.call(observer, value);
      } catch (e) {
        try {
          closeSubscription(subscription);
        } finally {
          throw e;
        }
      }
    }
  },
  error: function error(value) {
    var subscription = this._s;
    if (subscriptionClosed(subscription)) throw value;
    var observer = subscription._o;
    subscription._o = undefined;
    try {
      var m = getMethod(observer.error);
      if (!m) throw value;
      value = m.call(observer, value);
    } catch (e) {
      try {
        cleanupSubscription(subscription);
      } finally {
        throw e;
      }
    } cleanupSubscription(subscription);
    return value;
  },
  complete: function complete(value) {
    var subscription = this._s;
    if (!subscriptionClosed(subscription)) {
      var observer = subscription._o;
      subscription._o = undefined;
      try {
        var m = getMethod(observer.complete);
        value = m ? m.call(observer, value) : undefined;
      } catch (e) {
        try {
          cleanupSubscription(subscription);
        } finally {
          throw e;
        }
      } cleanupSubscription(subscription);
      return value;
    }
  }
});

var $Observable = function Observable(subscriber) {
  anInstance(this, $Observable, 'Observable', '_f')._f = aFunction(subscriber);
};

redefineAll($Observable.prototype, {
  subscribe: function subscribe(observer) {
    return new Subscription(observer, this._f);
  },
  forEach: function forEach(fn) {
    var that = this;
    return new (core.Promise || global.Promise)(function (resolve, reject) {
      aFunction(fn);
      var subscription = that.subscribe({
        next: function (value) {
          try {
            return fn(value);
          } catch (e) {
            reject(e);
            subscription.unsubscribe();
          }
        },
        error: reject,
        complete: resolve
      });
    });
  }
});

redefineAll($Observable, {
  from: function from(x) {
    var C = typeof this === 'function' ? this : $Observable;
    var method = getMethod(anObject(x)[OBSERVABLE]);
    if (method) {
      var observable = anObject(method.call(x));
      return observable.constructor === C ? observable : new C(function (observer) {
        return observable.subscribe(observer);
      });
    }
    return new C(function (observer) {
      var done = false;
      microtask(function () {
        if (!done) {
          try {
            if (forOf(x, false, function (it) {
              observer.next(it);
              if (done) return RETURN;
            }) === RETURN) return;
          } catch (e) {
            if (done) throw e;
            observer.error(e);
            return;
          } observer.complete();
        }
      });
      return function () { done = true; };
    });
  },
  of: function of() {
    for (var i = 0, l = arguments.length, items = Array(l); i < l;) items[i] = arguments[i++];
    return new (typeof this === 'function' ? this : $Observable)(function (observer) {
      var done = false;
      microtask(function () {
        if (!done) {
          for (var j = 0; j < items.length; ++j) {
            observer.next(items[j]);
            if (done) return;
          } observer.complete();
        }
      });
      return function () { done = true; };
    });
  }
});

hide($Observable.prototype, OBSERVABLE, function () { return this; });

$export($export.G, { Observable: $Observable });

require('./_set-species')('Observable');

},{"./_a-function":14,"./_an-instance":17,"./_an-object":18,"./_core":34,"./_export":44,"./_for-of":50,"./_global":51,"./_hide":53,"./_microtask":78,"./_redefine-all":101,"./_set-species":108,"./_wks":136}],305:[function(require,module,exports){
// https://github.com/tc39/proposal-promise-finally
'use strict';
var $export = require('./_export');
var core = require('./_core');
var global = require('./_global');
var speciesConstructor = require('./_species-constructor');
var promiseResolve = require('./_promise-resolve');

$export($export.P + $export.R, 'Promise', { 'finally': function (onFinally) {
  var C = speciesConstructor(this, core.Promise || global.Promise);
  var isFunction = typeof onFinally == 'function';
  return this.then(
    isFunction ? function (x) {
      return promiseResolve(C, onFinally()).then(function () { return x; });
    } : onFinally,
    isFunction ? function (e) {
      return promiseResolve(C, onFinally()).then(function () { throw e; });
    } : onFinally
  );
} });

},{"./_core":34,"./_export":44,"./_global":51,"./_promise-resolve":99,"./_species-constructor":112}],306:[function(require,module,exports){
'use strict';
// https://github.com/tc39/proposal-promise-try
var $export = require('./_export');
var newPromiseCapability = require('./_new-promise-capability');
var perform = require('./_perform');

$export($export.S, 'Promise', { 'try': function (callbackfn) {
  var promiseCapability = newPromiseCapability.f(this);
  var result = perform(callbackfn);
  (result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v);
  return promiseCapability.promise;
} });

},{"./_export":44,"./_new-promise-capability":79,"./_perform":98}],307:[function(require,module,exports){
var metadata = require('./_metadata');
var anObject = require('./_an-object');
var toMetaKey = metadata.key;
var ordinaryDefineOwnMetadata = metadata.set;

metadata.exp({ defineMetadata: function defineMetadata(metadataKey, metadataValue, target, targetKey) {
  ordinaryDefineOwnMetadata(metadataKey, metadataValue, anObject(target), toMetaKey(targetKey));
} });

},{"./_an-object":18,"./_metadata":77}],308:[function(require,module,exports){
var metadata = require('./_metadata');
var anObject = require('./_an-object');
var toMetaKey = metadata.key;
var getOrCreateMetadataMap = metadata.map;
var store = metadata.store;

metadata.exp({ deleteMetadata: function deleteMetadata(metadataKey, target /* , targetKey */) {
  var targetKey = arguments.length < 3 ? undefined : toMetaKey(arguments[2]);
  var metadataMap = getOrCreateMetadataMap(anObject(target), targetKey, false);
  if (metadataMap === undefined || !metadataMap['delete'](metadataKey)) return false;
  if (metadataMap.size) return true;
  var targetMetadata = store.get(target);
  targetMetadata['delete'](targetKey);
  return !!targetMetadata.size || store['delete'](target);
} });

},{"./_an-object":18,"./_metadata":77}],309:[function(require,module,exports){
var Set = require('./es6.set');
var from = require('./_array-from-iterable');
var metadata = require('./_metadata');
var anObject = require('./_an-object');
var getPrototypeOf = require('./_object-gpo');
var ordinaryOwnMetadataKeys = metadata.keys;
var toMetaKey = metadata.key;

var ordinaryMetadataKeys = function (O, P) {
  var oKeys = ordinaryOwnMetadataKeys(O, P);
  var parent = getPrototypeOf(O);
  if (parent === null) return oKeys;
  var pKeys = ordinaryMetadataKeys(parent, P);
  return pKeys.length ? oKeys.length ? from(new Set(oKeys.concat(pKeys))) : pKeys : oKeys;
};

metadata.exp({ getMetadataKeys: function getMetadataKeys(target /* , targetKey */) {
  return ordinaryMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));
} });

},{"./_an-object":18,"./_array-from-iterable":21,"./_metadata":77,"./_object-gpo":89,"./es6.set":239}],310:[function(require,module,exports){
var metadata = require('./_metadata');
var anObject = require('./_an-object');
var getPrototypeOf = require('./_object-gpo');
var ordinaryHasOwnMetadata = metadata.has;
var ordinaryGetOwnMetadata = metadata.get;
var toMetaKey = metadata.key;

var ordinaryGetMetadata = function (MetadataKey, O, P) {
  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
  if (hasOwn) return ordinaryGetOwnMetadata(MetadataKey, O, P);
  var parent = getPrototypeOf(O);
  return parent !== null ? ordinaryGetMetadata(MetadataKey, parent, P) : undefined;
};

metadata.exp({ getMetadata: function getMetadata(metadataKey, target /* , targetKey */) {
  return ordinaryGetMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
} });

},{"./_an-object":18,"./_metadata":77,"./_object-gpo":89}],311:[function(require,module,exports){
var metadata = require('./_metadata');
var anObject = require('./_an-object');
var ordinaryOwnMetadataKeys = metadata.keys;
var toMetaKey = metadata.key;

metadata.exp({ getOwnMetadataKeys: function getOwnMetadataKeys(target /* , targetKey */) {
  return ordinaryOwnMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));
} });

},{"./_an-object":18,"./_metadata":77}],312:[function(require,module,exports){
var metadata = require('./_metadata');
var anObject = require('./_an-object');
var ordinaryGetOwnMetadata = metadata.get;
var toMetaKey = metadata.key;

metadata.exp({ getOwnMetadata: function getOwnMetadata(metadataKey, target /* , targetKey */) {
  return ordinaryGetOwnMetadata(metadataKey, anObject(target)
    , arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
} });

},{"./_an-object":18,"./_metadata":77}],313:[function(require,module,exports){
var metadata = require('./_metadata');
var anObject = require('./_an-object');
var getPrototypeOf = require('./_object-gpo');
var ordinaryHasOwnMetadata = metadata.has;
var toMetaKey = metadata.key;

var ordinaryHasMetadata = function (MetadataKey, O, P) {
  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
  if (hasOwn) return true;
  var parent = getPrototypeOf(O);
  return parent !== null ? ordinaryHasMetadata(MetadataKey, parent, P) : false;
};

metadata.exp({ hasMetadata: function hasMetadata(metadataKey, target /* , targetKey */) {
  return ordinaryHasMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
} });

},{"./_an-object":18,"./_metadata":77,"./_object-gpo":89}],314:[function(require,module,exports){
var metadata = require('./_metadata');
var anObject = require('./_an-object');
var ordinaryHasOwnMetadata = metadata.has;
var toMetaKey = metadata.key;

metadata.exp({ hasOwnMetadata: function hasOwnMetadata(metadataKey, target /* , targetKey */) {
  return ordinaryHasOwnMetadata(metadataKey, anObject(target)
    , arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
} });

},{"./_an-object":18,"./_metadata":77}],315:[function(require,module,exports){
var $metadata = require('./_metadata');
var anObject = require('./_an-object');
var aFunction = require('./_a-function');
var toMetaKey = $metadata.key;
var ordinaryDefineOwnMetadata = $metadata.set;

$metadata.exp({ metadata: function metadata(metadataKey, metadataValue) {
  return function decorator(target, targetKey) {
    ordinaryDefineOwnMetadata(
      metadataKey, metadataValue,
      (targetKey !== undefined ? anObject : aFunction)(target),
      toMetaKey(targetKey)
    );
  };
} });

},{"./_a-function":14,"./_an-object":18,"./_metadata":77}],316:[function(require,module,exports){
// https://tc39.github.io/proposal-setmap-offrom/#sec-set.from
require('./_set-collection-from')('Set');

},{"./_set-collection-from":105}],317:[function(require,module,exports){
// https://tc39.github.io/proposal-setmap-offrom/#sec-set.of
require('./_set-collection-of')('Set');

},{"./_set-collection-of":106}],318:[function(require,module,exports){
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export = require('./_export');

$export($export.P + $export.R, 'Set', { toJSON: require('./_collection-to-json')('Set') });

},{"./_collection-to-json":31,"./_export":44}],319:[function(require,module,exports){
'use strict';
// https://github.com/mathiasbynens/String.prototype.at
var $export = require('./_export');
var $at = require('./_string-at')(true);

$export($export.P, 'String', {
  at: function at(pos) {
    return $at(this, pos);
  }
});

},{"./_export":44,"./_string-at":114}],320:[function(require,module,exports){
'use strict';
// https://tc39.github.io/String.prototype.matchAll/
var $export = require('./_export');
var defined = require('./_defined');
var toLength = require('./_to-length');
var isRegExp = require('./_is-regexp');
var getFlags = require('./_flags');
var RegExpProto = RegExp.prototype;

var $RegExpStringIterator = function (regexp, string) {
  this._r = regexp;
  this._s = string;
};

require('./_iter-create')($RegExpStringIterator, 'RegExp String', function next() {
  var match = this._r.exec(this._s);
  return { value: match, done: match === null };
});

$export($export.P, 'String', {
  matchAll: function matchAll(regexp) {
    defined(this);
    if (!isRegExp(regexp)) throw TypeError(regexp + ' is not a regexp!');
    var S = String(this);
    var flags = 'flags' in RegExpProto ? String(regexp.flags) : getFlags.call(regexp);
    var rx = new RegExp(regexp.source, ~flags.indexOf('g') ? flags : 'g' + flags);
    rx.lastIndex = toLength(regexp.lastIndex);
    return new $RegExpStringIterator(rx, S);
  }
});

},{"./_defined":39,"./_export":44,"./_flags":48,"./_is-regexp":63,"./_iter-create":65,"./_to-length":126}],321:[function(require,module,exports){
'use strict';
// https://github.com/tc39/proposal-string-pad-start-end
var $export = require('./_export');
var $pad = require('./_string-pad');

$export($export.P, 'String', {
  padEnd: function padEnd(maxLength /* , fillString = ' ' */) {
    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, false);
  }
});

},{"./_export":44,"./_string-pad":117}],322:[function(require,module,exports){
'use strict';
// https://github.com/tc39/proposal-string-pad-start-end
var $export = require('./_export');
var $pad = require('./_string-pad');

$export($export.P, 'String', {
  padStart: function padStart(maxLength /* , fillString = ' ' */) {
    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, true);
  }
});

},{"./_export":44,"./_string-pad":117}],323:[function(require,module,exports){
'use strict';
// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
require('./_string-trim')('trimLeft', function ($trim) {
  return function trimLeft() {
    return $trim(this, 1);
  };
}, 'trimStart');

},{"./_string-trim":119}],324:[function(require,module,exports){
'use strict';
// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
require('./_string-trim')('trimRight', function ($trim) {
  return function trimRight() {
    return $trim(this, 2);
  };
}, 'trimEnd');

},{"./_string-trim":119}],325:[function(require,module,exports){
require('./_wks-define')('asyncIterator');

},{"./_wks-define":134}],326:[function(require,module,exports){
require('./_wks-define')('observable');

},{"./_wks-define":134}],327:[function(require,module,exports){
// https://github.com/tc39/proposal-global
var $export = require('./_export');

$export($export.S, 'System', { global: require('./_global') });

},{"./_export":44,"./_global":51}],328:[function(require,module,exports){
// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.from
require('./_set-collection-from')('WeakMap');

},{"./_set-collection-from":105}],329:[function(require,module,exports){
// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.of
require('./_set-collection-of')('WeakMap');

},{"./_set-collection-of":106}],330:[function(require,module,exports){
// https://tc39.github.io/proposal-setmap-offrom/#sec-weakset.from
require('./_set-collection-from')('WeakSet');

},{"./_set-collection-from":105}],331:[function(require,module,exports){
// https://tc39.github.io/proposal-setmap-offrom/#sec-weakset.of
require('./_set-collection-of')('WeakSet');

},{"./_set-collection-of":106}],332:[function(require,module,exports){
var $iterators = require('./es6.array.iterator');
var getKeys = require('./_object-keys');
var redefine = require('./_redefine');
var global = require('./_global');
var hide = require('./_hide');
var Iterators = require('./_iterators');
var wks = require('./_wks');
var ITERATOR = wks('iterator');
var TO_STRING_TAG = wks('toStringTag');
var ArrayValues = Iterators.Array;

var DOMIterables = {
  CSSRuleList: true, // TODO: Not spec compliant, should be false.
  CSSStyleDeclaration: false,
  CSSValueList: false,
  ClientRectList: false,
  DOMRectList: false,
  DOMStringList: false,
  DOMTokenList: true,
  DataTransferItemList: false,
  FileList: false,
  HTMLAllCollection: false,
  HTMLCollection: false,
  HTMLFormElement: false,
  HTMLSelectElement: false,
  MediaList: true, // TODO: Not spec compliant, should be false.
  MimeTypeArray: false,
  NamedNodeMap: false,
  NodeList: true,
  PaintRequestList: false,
  Plugin: false,
  PluginArray: false,
  SVGLengthList: false,
  SVGNumberList: false,
  SVGPathSegList: false,
  SVGPointList: false,
  SVGStringList: false,
  SVGTransformList: false,
  SourceBufferList: false,
  StyleSheetList: true, // TODO: Not spec compliant, should be false.
  TextTrackCueList: false,
  TextTrackList: false,
  TouchList: false
};

for (var collections = getKeys(DOMIterables), i = 0; i < collections.length; i++) {
  var NAME = collections[i];
  var explicit = DOMIterables[NAME];
  var Collection = global[NAME];
  var proto = Collection && Collection.prototype;
  var key;
  if (proto) {
    if (!proto[ITERATOR]) hide(proto, ITERATOR, ArrayValues);
    if (!proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
    Iterators[NAME] = ArrayValues;
    if (explicit) for (key in $iterators) if (!proto[key]) redefine(proto, key, $iterators[key], true);
  }
}

},{"./_global":51,"./_hide":53,"./_iterators":69,"./_object-keys":91,"./_redefine":102,"./_wks":136,"./es6.array.iterator":149}],333:[function(require,module,exports){
var $export = require('./_export');
var $task = require('./_task');
$export($export.G + $export.B, {
  setImmediate: $task.set,
  clearImmediate: $task.clear
});

},{"./_export":44,"./_task":121}],334:[function(require,module,exports){
// ie9- setTimeout & setInterval additional parameters fix
var global = require('./_global');
var $export = require('./_export');
var navigator = global.navigator;
var slice = [].slice;
var MSIE = !!navigator && /MSIE .\./.test(navigator.userAgent); // <- dirty ie9- check
var wrap = function (set) {
  return function (fn, time /* , ...args */) {
    var boundArgs = arguments.length > 2;
    var args = boundArgs ? slice.call(arguments, 2) : false;
    return set(boundArgs ? function () {
      // eslint-disable-next-line no-new-func
      (typeof fn == 'function' ? fn : Function(fn)).apply(this, args);
    } : fn, time);
  };
};
$export($export.G + $export.B + $export.F * MSIE, {
  setTimeout: wrap(global.setTimeout),
  setInterval: wrap(global.setInterval)
});

},{"./_export":44,"./_global":51}],335:[function(require,module,exports){
require('./modules/es6.symbol');
require('./modules/es6.object.create');
require('./modules/es6.object.define-property');
require('./modules/es6.object.define-properties');
require('./modules/es6.object.get-own-property-descriptor');
require('./modules/es6.object.get-prototype-of');
require('./modules/es6.object.keys');
require('./modules/es6.object.get-own-property-names');
require('./modules/es6.object.freeze');
require('./modules/es6.object.seal');
require('./modules/es6.object.prevent-extensions');
require('./modules/es6.object.is-frozen');
require('./modules/es6.object.is-sealed');
require('./modules/es6.object.is-extensible');
require('./modules/es6.object.assign');
require('./modules/es6.object.is');
require('./modules/es6.object.set-prototype-of');
require('./modules/es6.object.to-string');
require('./modules/es6.function.bind');
require('./modules/es6.function.name');
require('./modules/es6.function.has-instance');
require('./modules/es6.parse-int');
require('./modules/es6.parse-float');
require('./modules/es6.number.constructor');
require('./modules/es6.number.to-fixed');
require('./modules/es6.number.to-precision');
require('./modules/es6.number.epsilon');
require('./modules/es6.number.is-finite');
require('./modules/es6.number.is-integer');
require('./modules/es6.number.is-nan');
require('./modules/es6.number.is-safe-integer');
require('./modules/es6.number.max-safe-integer');
require('./modules/es6.number.min-safe-integer');
require('./modules/es6.number.parse-float');
require('./modules/es6.number.parse-int');
require('./modules/es6.math.acosh');
require('./modules/es6.math.asinh');
require('./modules/es6.math.atanh');
require('./modules/es6.math.cbrt');
require('./modules/es6.math.clz32');
require('./modules/es6.math.cosh');
require('./modules/es6.math.expm1');
require('./modules/es6.math.fround');
require('./modules/es6.math.hypot');
require('./modules/es6.math.imul');
require('./modules/es6.math.log10');
require('./modules/es6.math.log1p');
require('./modules/es6.math.log2');
require('./modules/es6.math.sign');
require('./modules/es6.math.sinh');
require('./modules/es6.math.tanh');
require('./modules/es6.math.trunc');
require('./modules/es6.string.from-code-point');
require('./modules/es6.string.raw');
require('./modules/es6.string.trim');
require('./modules/es6.string.iterator');
require('./modules/es6.string.code-point-at');
require('./modules/es6.string.ends-with');
require('./modules/es6.string.includes');
require('./modules/es6.string.repeat');
require('./modules/es6.string.starts-with');
require('./modules/es6.string.anchor');
require('./modules/es6.string.big');
require('./modules/es6.string.blink');
require('./modules/es6.string.bold');
require('./modules/es6.string.fixed');
require('./modules/es6.string.fontcolor');
require('./modules/es6.string.fontsize');
require('./modules/es6.string.italics');
require('./modules/es6.string.link');
require('./modules/es6.string.small');
require('./modules/es6.string.strike');
require('./modules/es6.string.sub');
require('./modules/es6.string.sup');
require('./modules/es6.date.now');
require('./modules/es6.date.to-json');
require('./modules/es6.date.to-iso-string');
require('./modules/es6.date.to-string');
require('./modules/es6.date.to-primitive');
require('./modules/es6.array.is-array');
require('./modules/es6.array.from');
require('./modules/es6.array.of');
require('./modules/es6.array.join');
require('./modules/es6.array.slice');
require('./modules/es6.array.sort');
require('./modules/es6.array.for-each');
require('./modules/es6.array.map');
require('./modules/es6.array.filter');
require('./modules/es6.array.some');
require('./modules/es6.array.every');
require('./modules/es6.array.reduce');
require('./modules/es6.array.reduce-right');
require('./modules/es6.array.index-of');
require('./modules/es6.array.last-index-of');
require('./modules/es6.array.copy-within');
require('./modules/es6.array.fill');
require('./modules/es6.array.find');
require('./modules/es6.array.find-index');
require('./modules/es6.array.species');
require('./modules/es6.array.iterator');
require('./modules/es6.regexp.constructor');
require('./modules/es6.regexp.to-string');
require('./modules/es6.regexp.flags');
require('./modules/es6.regexp.match');
require('./modules/es6.regexp.replace');
require('./modules/es6.regexp.search');
require('./modules/es6.regexp.split');
require('./modules/es6.promise');
require('./modules/es6.map');
require('./modules/es6.set');
require('./modules/es6.weak-map');
require('./modules/es6.weak-set');
require('./modules/es6.typed.array-buffer');
require('./modules/es6.typed.data-view');
require('./modules/es6.typed.int8-array');
require('./modules/es6.typed.uint8-array');
require('./modules/es6.typed.uint8-clamped-array');
require('./modules/es6.typed.int16-array');
require('./modules/es6.typed.uint16-array');
require('./modules/es6.typed.int32-array');
require('./modules/es6.typed.uint32-array');
require('./modules/es6.typed.float32-array');
require('./modules/es6.typed.float64-array');
require('./modules/es6.reflect.apply');
require('./modules/es6.reflect.construct');
require('./modules/es6.reflect.define-property');
require('./modules/es6.reflect.delete-property');
require('./modules/es6.reflect.enumerate');
require('./modules/es6.reflect.get');
require('./modules/es6.reflect.get-own-property-descriptor');
require('./modules/es6.reflect.get-prototype-of');
require('./modules/es6.reflect.has');
require('./modules/es6.reflect.is-extensible');
require('./modules/es6.reflect.own-keys');
require('./modules/es6.reflect.prevent-extensions');
require('./modules/es6.reflect.set');
require('./modules/es6.reflect.set-prototype-of');
require('./modules/es7.array.includes');
require('./modules/es7.array.flat-map');
require('./modules/es7.array.flatten');
require('./modules/es7.string.at');
require('./modules/es7.string.pad-start');
require('./modules/es7.string.pad-end');
require('./modules/es7.string.trim-left');
require('./modules/es7.string.trim-right');
require('./modules/es7.string.match-all');
require('./modules/es7.symbol.async-iterator');
require('./modules/es7.symbol.observable');
require('./modules/es7.object.get-own-property-descriptors');
require('./modules/es7.object.values');
require('./modules/es7.object.entries');
require('./modules/es7.object.define-getter');
require('./modules/es7.object.define-setter');
require('./modules/es7.object.lookup-getter');
require('./modules/es7.object.lookup-setter');
require('./modules/es7.map.to-json');
require('./modules/es7.set.to-json');
require('./modules/es7.map.of');
require('./modules/es7.set.of');
require('./modules/es7.weak-map.of');
require('./modules/es7.weak-set.of');
require('./modules/es7.map.from');
require('./modules/es7.set.from');
require('./modules/es7.weak-map.from');
require('./modules/es7.weak-set.from');
require('./modules/es7.global');
require('./modules/es7.system.global');
require('./modules/es7.error.is-error');
require('./modules/es7.math.clamp');
require('./modules/es7.math.deg-per-rad');
require('./modules/es7.math.degrees');
require('./modules/es7.math.fscale');
require('./modules/es7.math.iaddh');
require('./modules/es7.math.isubh');
require('./modules/es7.math.imulh');
require('./modules/es7.math.rad-per-deg');
require('./modules/es7.math.radians');
require('./modules/es7.math.scale');
require('./modules/es7.math.umulh');
require('./modules/es7.math.signbit');
require('./modules/es7.promise.finally');
require('./modules/es7.promise.try');
require('./modules/es7.reflect.define-metadata');
require('./modules/es7.reflect.delete-metadata');
require('./modules/es7.reflect.get-metadata');
require('./modules/es7.reflect.get-metadata-keys');
require('./modules/es7.reflect.get-own-metadata');
require('./modules/es7.reflect.get-own-metadata-keys');
require('./modules/es7.reflect.has-metadata');
require('./modules/es7.reflect.has-own-metadata');
require('./modules/es7.reflect.metadata');
require('./modules/es7.asap');
require('./modules/es7.observable');
require('./modules/web.timers');
require('./modules/web.immediate');
require('./modules/web.dom.iterable');
module.exports = require('./modules/_core');

},{"./modules/_core":34,"./modules/es6.array.copy-within":139,"./modules/es6.array.every":140,"./modules/es6.array.fill":141,"./modules/es6.array.filter":142,"./modules/es6.array.find":144,"./modules/es6.array.find-index":143,"./modules/es6.array.for-each":145,"./modules/es6.array.from":146,"./modules/es6.array.index-of":147,"./modules/es6.array.is-array":148,"./modules/es6.array.iterator":149,"./modules/es6.array.join":150,"./modules/es6.array.last-index-of":151,"./modules/es6.array.map":152,"./modules/es6.array.of":153,"./modules/es6.array.reduce":155,"./modules/es6.array.reduce-right":154,"./modules/es6.array.slice":156,"./modules/es6.array.some":157,"./modules/es6.array.sort":158,"./modules/es6.array.species":159,"./modules/es6.date.now":160,"./modules/es6.date.to-iso-string":161,"./modules/es6.date.to-json":162,"./modules/es6.date.to-primitive":163,"./modules/es6.date.to-string":164,"./modules/es6.function.bind":165,"./modules/es6.function.has-instance":166,"./modules/es6.function.name":167,"./modules/es6.map":168,"./modules/es6.math.acosh":169,"./modules/es6.math.asinh":170,"./modules/es6.math.atanh":171,"./modules/es6.math.cbrt":172,"./modules/es6.math.clz32":173,"./modules/es6.math.cosh":174,"./modules/es6.math.expm1":175,"./modules/es6.math.fround":176,"./modules/es6.math.hypot":177,"./modules/es6.math.imul":178,"./modules/es6.math.log10":179,"./modules/es6.math.log1p":180,"./modules/es6.math.log2":181,"./modules/es6.math.sign":182,"./modules/es6.math.sinh":183,"./modules/es6.math.tanh":184,"./modules/es6.math.trunc":185,"./modules/es6.number.constructor":186,"./modules/es6.number.epsilon":187,"./modules/es6.number.is-finite":188,"./modules/es6.number.is-integer":189,"./modules/es6.number.is-nan":190,"./modules/es6.number.is-safe-integer":191,"./modules/es6.number.max-safe-integer":192,"./modules/es6.number.min-safe-integer":193,"./modules/es6.number.parse-float":194,"./modules/es6.number.parse-int":195,"./modules/es6.number.to-fixed":196,"./modules/es6.number.to-precision":197,"./modules/es6.object.assign":198,"./modules/es6.object.create":199,"./modules/es6.object.define-properties":200,"./modules/es6.object.define-property":201,"./modules/es6.object.freeze":202,"./modules/es6.object.get-own-property-descriptor":203,"./modules/es6.object.get-own-property-names":204,"./modules/es6.object.get-prototype-of":205,"./modules/es6.object.is":209,"./modules/es6.object.is-extensible":206,"./modules/es6.object.is-frozen":207,"./modules/es6.object.is-sealed":208,"./modules/es6.object.keys":210,"./modules/es6.object.prevent-extensions":211,"./modules/es6.object.seal":212,"./modules/es6.object.set-prototype-of":213,"./modules/es6.object.to-string":214,"./modules/es6.parse-float":215,"./modules/es6.parse-int":216,"./modules/es6.promise":217,"./modules/es6.reflect.apply":218,"./modules/es6.reflect.construct":219,"./modules/es6.reflect.define-property":220,"./modules/es6.reflect.delete-property":221,"./modules/es6.reflect.enumerate":222,"./modules/es6.reflect.get":225,"./modules/es6.reflect.get-own-property-descriptor":223,"./modules/es6.reflect.get-prototype-of":224,"./modules/es6.reflect.has":226,"./modules/es6.reflect.is-extensible":227,"./modules/es6.reflect.own-keys":228,"./modules/es6.reflect.prevent-extensions":229,"./modules/es6.reflect.set":231,"./modules/es6.reflect.set-prototype-of":230,"./modules/es6.regexp.constructor":232,"./modules/es6.regexp.flags":233,"./modules/es6.regexp.match":234,"./modules/es6.regexp.replace":235,"./modules/es6.regexp.search":236,"./modules/es6.regexp.split":237,"./modules/es6.regexp.to-string":238,"./modules/es6.set":239,"./modules/es6.string.anchor":240,"./modules/es6.string.big":241,"./modules/es6.string.blink":242,"./modules/es6.string.bold":243,"./modules/es6.string.code-point-at":244,"./modules/es6.string.ends-with":245,"./modules/es6.string.fixed":246,"./modules/es6.string.fontcolor":247,"./modules/es6.string.fontsize":248,"./modules/es6.string.from-code-point":249,"./modules/es6.string.includes":250,"./modules/es6.string.italics":251,"./modules/es6.string.iterator":252,"./modules/es6.string.link":253,"./modules/es6.string.raw":254,"./modules/es6.string.repeat":255,"./modules/es6.string.small":256,"./modules/es6.string.starts-with":257,"./modules/es6.string.strike":258,"./modules/es6.string.sub":259,"./modules/es6.string.sup":260,"./modules/es6.string.trim":261,"./modules/es6.symbol":262,"./modules/es6.typed.array-buffer":263,"./modules/es6.typed.data-view":264,"./modules/es6.typed.float32-array":265,"./modules/es6.typed.float64-array":266,"./modules/es6.typed.int16-array":267,"./modules/es6.typed.int32-array":268,"./modules/es6.typed.int8-array":269,"./modules/es6.typed.uint16-array":270,"./modules/es6.typed.uint32-array":271,"./modules/es6.typed.uint8-array":272,"./modules/es6.typed.uint8-clamped-array":273,"./modules/es6.weak-map":274,"./modules/es6.weak-set":275,"./modules/es7.array.flat-map":276,"./modules/es7.array.flatten":277,"./modules/es7.array.includes":278,"./modules/es7.asap":279,"./modules/es7.error.is-error":280,"./modules/es7.global":281,"./modules/es7.map.from":282,"./modules/es7.map.of":283,"./modules/es7.map.to-json":284,"./modules/es7.math.clamp":285,"./modules/es7.math.deg-per-rad":286,"./modules/es7.math.degrees":287,"./modules/es7.math.fscale":288,"./modules/es7.math.iaddh":289,"./modules/es7.math.imulh":290,"./modules/es7.math.isubh":291,"./modules/es7.math.rad-per-deg":292,"./modules/es7.math.radians":293,"./modules/es7.math.scale":294,"./modules/es7.math.signbit":295,"./modules/es7.math.umulh":296,"./modules/es7.object.define-getter":297,"./modules/es7.object.define-setter":298,"./modules/es7.object.entries":299,"./modules/es7.object.get-own-property-descriptors":300,"./modules/es7.object.lookup-getter":301,"./modules/es7.object.lookup-setter":302,"./modules/es7.object.values":303,"./modules/es7.observable":304,"./modules/es7.promise.finally":305,"./modules/es7.promise.try":306,"./modules/es7.reflect.define-metadata":307,"./modules/es7.reflect.delete-metadata":308,"./modules/es7.reflect.get-metadata":310,"./modules/es7.reflect.get-metadata-keys":309,"./modules/es7.reflect.get-own-metadata":312,"./modules/es7.reflect.get-own-metadata-keys":311,"./modules/es7.reflect.has-metadata":313,"./modules/es7.reflect.has-own-metadata":314,"./modules/es7.reflect.metadata":315,"./modules/es7.set.from":316,"./modules/es7.set.of":317,"./modules/es7.set.to-json":318,"./modules/es7.string.at":319,"./modules/es7.string.match-all":320,"./modules/es7.string.pad-end":321,"./modules/es7.string.pad-start":322,"./modules/es7.string.trim-left":323,"./modules/es7.string.trim-right":324,"./modules/es7.symbol.async-iterator":325,"./modules/es7.symbol.observable":326,"./modules/es7.system.global":327,"./modules/es7.weak-map.from":328,"./modules/es7.weak-map.of":329,"./modules/es7.weak-set.from":330,"./modules/es7.weak-set.of":331,"./modules/web.dom.iterable":332,"./modules/web.immediate":333,"./modules/web.timers":334}],336:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports['default'] = camelize;
var regExp = /[-\s]+(.)?/g;

/**
 * Convert dash separated strings to camel cased.
 *
 * @param {String} str
 * @return {String}
 */
function camelize(str) {
  return str.replace(regExp, toUpper);
}

function toUpper(match, c) {
  return c ? c.toUpperCase() : '';
}
},{}],337:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.supportedValue = exports.supportedProperty = exports.prefix = undefined;

var _prefix = require('./prefix');

var _prefix2 = _interopRequireDefault(_prefix);

var _supportedProperty = require('./supported-property');

var _supportedProperty2 = _interopRequireDefault(_supportedProperty);

var _supportedValue = require('./supported-value');

var _supportedValue2 = _interopRequireDefault(_supportedValue);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

exports['default'] = {
  prefix: _prefix2['default'],
  supportedProperty: _supportedProperty2['default'],
  supportedValue: _supportedValue2['default']
}; /**
    * CSS Vendor prefix detection and property feature testing.
    *
    * @copyright Oleg Slobodskoi 2015
    * @website https://github.com/jsstyles/css-vendor
    * @license MIT
    */

exports.prefix = _prefix2['default'];
exports.supportedProperty = _supportedProperty2['default'];
exports.supportedValue = _supportedValue2['default'];
},{"./prefix":338,"./supported-property":339,"./supported-value":340}],338:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _isInBrowser = require('is-in-browser');

var _isInBrowser2 = _interopRequireDefault(_isInBrowser);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var js = ''; /**
              * Export javascript style and css style vendor prefixes.
              * Based on "transform" support test.
              */

var css = '';

// We should not do anything if required serverside.
if (_isInBrowser2['default']) {
  // Order matters. We need to check Webkit the last one because
  // other vendors use to add Webkit prefixes to some properties
  var jsCssMap = {
    Moz: '-moz-',
    // IE did it wrong again ...
    ms: '-ms-',
    O: '-o-',
    Webkit: '-webkit-'
  };
  var style = document.createElement('p').style;
  var testProp = 'Transform';

  for (var key in jsCssMap) {
    if (key + testProp in style) {
      js = key;
      css = jsCssMap[key];
      break;
    }
  }
}

/**
 * Vendor prefix string for the current browser.
 *
 * @type {{js: String, css: String}}
 * @api public
 */
exports['default'] = { js: js, css: css };
},{"is-in-browser":344}],339:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports['default'] = supportedProperty;

var _isInBrowser = require('is-in-browser');

var _isInBrowser2 = _interopRequireDefault(_isInBrowser);

var _prefix = require('./prefix');

var _prefix2 = _interopRequireDefault(_prefix);

var _camelize = require('./camelize');

var _camelize2 = _interopRequireDefault(_camelize);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var el = void 0;
var cache = {};

if (_isInBrowser2['default']) {
  el = document.createElement('p');

  /**
   * We test every property on vendor prefix requirement.
   * Once tested, result is cached. It gives us up to 70% perf boost.
   * http://jsperf.com/element-style-object-access-vs-plain-object
   *
   * Prefill cache with known css properties to reduce amount of
   * properties we need to feature test at runtime.
   * http://davidwalsh.name/vendor-prefix
   */
  var computed = window.getComputedStyle(document.documentElement, '');
  for (var key in computed) {
    if (!isNaN(key)) cache[computed[key]] = computed[key];
  }
}

/**
 * Test if a property is supported, returns supported property with vendor
 * prefix if required. Returns `false` if not supported.
 *
 * @param {String} prop dash separated
 * @return {String|Boolean}
 * @api public
 */
function supportedProperty(prop) {
  // For server-side rendering.
  if (!el) return prop;

  // We have not tested this prop yet, lets do the test.
  if (cache[prop] != null) return cache[prop];

  // Camelization is required because we can't test using
  // css syntax for e.g. in FF.
  // Test if property is supported as it is.
  if ((0, _camelize2['default'])(prop) in el.style) {
    cache[prop] = prop;
  }
  // Test if property is supported with vendor prefix.
  else if (_prefix2['default'].js + (0, _camelize2['default'])('-' + prop) in el.style) {
      cache[prop] = _prefix2['default'].css + prop;
    } else {
      cache[prop] = false;
    }

  return cache[prop];
}
},{"./camelize":336,"./prefix":338,"is-in-browser":344}],340:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports['default'] = supportedValue;

var _isInBrowser = require('is-in-browser');

var _isInBrowser2 = _interopRequireDefault(_isInBrowser);

var _prefix = require('./prefix');

var _prefix2 = _interopRequireDefault(_prefix);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var cache = {};
var el = void 0;

if (_isInBrowser2['default']) el = document.createElement('p');

/**
 * Returns prefixed value if needed. Returns `false` if value is not supported.
 *
 * @param {String} property
 * @param {String} value
 * @return {String|Boolean}
 * @api public
 */
function supportedValue(property, value) {
  // For server-side rendering.
  if (!el) return value;

  // It is a string or a number as a string like '1'.
  // We want only prefixable values here.
  if (typeof value !== 'string' || !isNaN(parseInt(value, 10))) return value;

  var cacheKey = property + value;

  if (cache[cacheKey] != null) return cache[cacheKey];

  // IE can even throw an error in some cases, for e.g. style.content = 'bar'
  try {
    // Test value as it is.
    el.style[property] = value;
  } catch (err) {
    cache[cacheKey] = false;
    return false;
  }

  // Value is supported as it is.
  if (el.style[property] !== '') {
    cache[cacheKey] = value;
  } else {
    // Test value with vendor prefix.
    value = _prefix2['default'].css + value;

    // Hardcode test to convert "flex" to "-ms-flexbox" for IE10.
    if (value === '-ms-flex') value = '-ms-flexbox';

    el.style[property] = value;

    // Value is supported with vendor prefix.
    if (el.style[property] !== '') cache[cacheKey] = value;
  }

  if (!cache[cacheKey]) cache[cacheKey] = false;

  // Reset style value.
  el.style[property] = '';

  return cache[cacheKey];
}
},{"./prefix":338,"is-in-browser":344}],341:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
var isValidString = function isValidString(param) {
  return typeof param === 'string' && param.length > 0;
};

var startsWith = function startsWith(string, start) {
  return string[0] === start;
};

var isSelector = function isSelector(param) {
  return isValidString(param) && (startsWith(param, '.') || startsWith(param, '#'));
};

var node = function node(h) {
  return function (tagName) {
    return function (first) {
      for (var _len = arguments.length, rest = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        rest[_key - 1] = arguments[_key];
      }

      if (isSelector(first)) {
        return h.apply(undefined, [tagName + first].concat(rest));
      } else if (typeof first === 'undefined') {
        return h(tagName);
      } else {
        return h.apply(undefined, [tagName, first].concat(rest));
      }
    };
  };
};

var TAG_NAMES = ['a', 'abbr', 'acronym', 'address', 'applet', 'area', 'article', 'aside', 'audio', 'b', 'base', 'basefont', 'bdi', 'bdo', 'bgsound', 'big', 'blink', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'center', 'cite', 'code', 'col', 'colgroup', 'command', 'content', 'data', 'datalist', 'dd', 'del', 'details', 'dfn', 'dialog', 'dir', 'div', 'dl', 'dt', 'element', 'em', 'embed', 'fieldset', 'figcaption', 'figure', 'font', 'footer', 'form', 'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'iframe', 'image', 'img', 'input', 'ins', 'isindex', 'kbd', 'keygen', 'label', 'legend', 'li', 'link', 'listing', 'main', 'map', 'mark', 'marquee', 'math', 'menu', 'menuitem', 'meta', 'meter', 'multicol', 'nav', 'nextid', 'nobr', 'noembed', 'noframes', 'noscript', 'object', 'ol', 'optgroup', 'option', 'output', 'p', 'param', 'picture', 'plaintext', 'pre', 'progress', 'q', 'rb', 'rbc', 'rp', 'rt', 'rtc', 'ruby', 's', 'samp', 'script', 'section', 'select', 'shadow', 'slot', 'small', 'source', 'spacer', 'span', 'strike', 'strong', 'style', 'sub', 'summary', 'sup', 'svg', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'time', 'title', 'tr', 'track', 'tt', 'u', 'ul', 'var', 'video', 'wbr', 'xmp'];

exports['default'] = function (h) {
  var createTag = node(h);
  var exported = { TAG_NAMES: TAG_NAMES, isSelector: isSelector, createTag: createTag };
  TAG_NAMES.forEach(function (n) {
    exported[n] = createTag(n);
  });
  return exported;
};

module.exports = exports['default'];
},{}],342:[function(require,module,exports){
var split = require('browser-split')
var ClassList = require('class-list')

var w = typeof window === 'undefined' ? require('html-element') : window
var document = w.document
var Text = w.Text

function context () {

  var cleanupFuncs = []

  function h() {
    var args = [].slice.call(arguments), e = null
    function item (l) {
      var r
      function parseClass (string) {
        // Our minimal parser doesn’t understand escaping CSS special
        // characters like `#`. Don’t use them. More reading:
        // https://mathiasbynens.be/notes/css-escapes .

        var m = split(string, /([\.#]?[^\s#.]+)/)
        if(/^\.|#/.test(m[1]))
          e = document.createElement('div')
        forEach(m, function (v) {
          var s = v.substring(1,v.length)
          if(!v) return
          if(!e)
            e = document.createElement(v)
          else if (v[0] === '.')
            ClassList(e).add(s)
          else if (v[0] === '#')
            e.setAttribute('id', s)
        })
      }

      if(l == null)
        ;
      else if('string' === typeof l) {
        if(!e)
          parseClass(l)
        else
          e.appendChild(r = document.createTextNode(l))
      }
      else if('number' === typeof l
        || 'boolean' === typeof l
        || l instanceof Date
        || l instanceof RegExp ) {
          e.appendChild(r = document.createTextNode(l.toString()))
      }
      //there might be a better way to handle this...
      else if (isArray(l))
        forEach(l, item)
      else if(isNode(l))
        e.appendChild(r = l)
      else if(l instanceof Text)
        e.appendChild(r = l)
      else if ('object' === typeof l) {
        for (var k in l) {
          if('function' === typeof l[k]) {
            if(/^on\w+/.test(k)) {
              (function (k, l) { // capture k, l in the closure
                if (e.addEventListener){
                  e.addEventListener(k.substring(2), l[k], false)
                  cleanupFuncs.push(function(){
                    e.removeEventListener(k.substring(2), l[k], false)
                  })
                }else{
                  e.attachEvent(k, l[k])
                  cleanupFuncs.push(function(){
                    e.detachEvent(k, l[k])
                  })
                }
              })(k, l)
            } else {
              // observable
              e[k] = l[k]()
              cleanupFuncs.push(l[k](function (v) {
                e[k] = v
              }))
            }
          }
          else if(k === 'style') {
            if('string' === typeof l[k]) {
              e.style.cssText = l[k]
            }else{
              for (var s in l[k]) (function(s, v) {
                if('function' === typeof v) {
                  // observable
                  e.style.setProperty(s, v())
                  cleanupFuncs.push(v(function (val) {
                    e.style.setProperty(s, val)
                  }))
                } else
                  var match = l[k][s].match(/(.*)\W+!important\W*$/);
                  if (match) {
                    e.style.setProperty(s, match[1], 'important')
                  } else {
                    e.style.setProperty(s, l[k][s])
                  }
              })(s, l[k][s])
            }
          } else if(k === 'attrs') {
            for (var v in l[k]) {
              e.setAttribute(v, l[k][v])
            }
          }
          else if (k.substr(0, 5) === "data-") {
            e.setAttribute(k, l[k])
          } else {
            e[k] = l[k]
          }
        }
      } else if ('function' === typeof l) {
        //assume it's an observable!
        var v = l()
        e.appendChild(r = isNode(v) ? v : document.createTextNode(v))

        cleanupFuncs.push(l(function (v) {
          if(isNode(v) && r.parentElement)
            r.parentElement.replaceChild(v, r), r = v
          else
            r.textContent = v
        }))
      }

      return r
    }
    while(args.length)
      item(args.shift())

    return e
  }

  h.cleanup = function () {
    for (var i = 0; i < cleanupFuncs.length; i++){
      cleanupFuncs[i]()
    }
    cleanupFuncs.length = 0
  }

  return h
}

var h = module.exports = context()
h.context = context

function isNode (el) {
  return el && el.nodeName && el.nodeType
}

function forEach (arr, fn) {
  if (arr.forEach) return arr.forEach(fn)
  for (var i = 0; i < arr.length; i++) fn(arr[i], i)
}

function isArray (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]'
}



},{"browser-split":11,"class-list":12,"html-element":10}],343:[function(require,module,exports){

var indexOf = [].indexOf;

module.exports = function(arr, obj){
  if (indexOf) return arr.indexOf(obj);
  for (var i = 0; i < arr.length; ++i) {
    if (arr[i] === obj) return i;
  }
  return -1;
};
},{}],344:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var isBrowser = exports.isBrowser = (typeof window === "undefined" ? "undefined" : _typeof(window)) === "object" && (typeof document === "undefined" ? "undefined" : _typeof(document)) === 'object' && document.nodeType === 9;

exports.default = isBrowser;
},{}],345:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = camelCase;
var regExp = /([A-Z])/g;

/**
 * Replace a string passed from String#replace.
 * @param {String} str
 * @return {String}
 */
function replace(str) {
  return "-" + str.toLowerCase();
}

/**
 * Convert camel cased property names to dash separated.
 *
 * @param {Object} style
 * @return {Object}
 */
function convertCase(style) {
  var converted = {};

  for (var prop in style) {
    converted[prop.replace(regExp, replace)] = style[prop];
  }

  if (style.fallbacks) {
    if (Array.isArray(style.fallbacks)) converted.fallbacks = style.fallbacks.map(convertCase);else converted.fallbacks = convertCase(style.fallbacks);
  }

  return converted;
}

/**
 * Allow camel cased property names by converting them back to dasherized.
 *
 * @param {Rule} rule
 */
function camelCase() {
  function onProcessStyle(style) {
    if (Array.isArray(style)) {
      // Handle rules like @font-face, which can have multiple styles in an array
      for (var index = 0; index < style.length; index++) {
        style[index] = convertCase(style[index]);
      }
      return style;
    }

    return convertCase(style);
  }

  return { onProcessStyle: onProcessStyle };
}
},{}],346:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = jssCompose;

var _warning = require('warning');

var _warning2 = _interopRequireDefault(_warning);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Set selector.
 *
 * @param {Object} original rule
 * @param {String} className class string
 * @return {Boolean} flag, indicating function was successfull or not
 */
function registerClass(rule, className) {
  // Skip falsy values
  if (!className) return true;

  // Support array of class names `{composes: ['foo', 'bar']}`
  if (Array.isArray(className)) {
    for (var index = 0; index < className.length; index++) {
      var isSetted = registerClass(rule, className[index]);
      if (!isSetted) return false;
    }

    return true;
  }

  // Support space separated class names `{composes: 'foo bar'}`
  if (className.indexOf(' ') > -1) {
    return registerClass(rule, className.split(' '));
  }

  var parent = rule.options.parent;

  // It is a ref to a local rule.

  if (className[0] === '$') {
    var refRule = parent.getRule(className.substr(1));

    if (!refRule) {
      (0, _warning2.default)(false, '[JSS] Referenced rule is not defined. \r\n%s', rule);
      return false;
    }

    if (refRule === rule) {
      (0, _warning2.default)(false, '[JSS] Cyclic composition detected. \r\n%s', rule);
      return false;
    }

    parent.classes[rule.key] += ' ' + parent.classes[refRule.key];

    return true;
  }

  rule.options.parent.classes[rule.key] += ' ' + className;

  return true;
}

/**
 * Convert compose property to additional class, remove property from original styles.
 *
 * @param {Rule} rule
 * @api public
 */
function jssCompose() {
  function onProcessStyle(style, rule) {
    if (!style.composes) return style;
    registerClass(rule, style.composes);
    // Remove composes property to prevent infinite loop.
    delete style.composes;
    return style;
  }
  return { onProcessStyle: onProcessStyle };
}
},{"warning":394}],347:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Generated jss-default-unit CSS property units
 *
 * @type object
 */
exports['default'] = {
  'animation-delay': 'ms',
  'animation-duration': 'ms',
  'background-position': 'px',
  'background-position-x': 'px',
  'background-position-y': 'px',
  'background-size': 'px',
  border: 'px',
  'border-bottom': 'px',
  'border-bottom-left-radius': 'px',
  'border-bottom-right-radius': 'px',
  'border-bottom-width': 'px',
  'border-left': 'px',
  'border-left-width': 'px',
  'border-radius': 'px',
  'border-right': 'px',
  'border-right-width': 'px',
  'border-spacing': 'px',
  'border-top': 'px',
  'border-top-left-radius': 'px',
  'border-top-right-radius': 'px',
  'border-top-width': 'px',
  'border-width': 'px',
  'border-after-width': 'px',
  'border-before-width': 'px',
  'border-end-width': 'px',
  'border-horizontal-spacing': 'px',
  'border-start-width': 'px',
  'border-vertical-spacing': 'px',
  bottom: 'px',
  'box-shadow': 'px',
  'column-gap': 'px',
  'column-rule': 'px',
  'column-rule-width': 'px',
  'column-width': 'px',
  'flex-basis': 'px',
  'font-size': 'px',
  'font-size-delta': 'px',
  height: 'px',
  left: 'px',
  'letter-spacing': 'px',
  'logical-height': 'px',
  'logical-width': 'px',
  margin: 'px',
  'margin-after': 'px',
  'margin-before': 'px',
  'margin-bottom': 'px',
  'margin-left': 'px',
  'margin-right': 'px',
  'margin-top': 'px',
  'max-height': 'px',
  'max-width': 'px',
  'margin-end': 'px',
  'margin-start': 'px',
  'mask-position-x': 'px',
  'mask-position-y': 'px',
  'mask-size': 'px',
  'max-logical-height': 'px',
  'max-logical-width': 'px',
  'min-height': 'px',
  'min-width': 'px',
  'min-logical-height': 'px',
  'min-logical-width': 'px',
  motion: 'px',
  'motion-offset': 'px',
  outline: 'px',
  'outline-offset': 'px',
  'outline-width': 'px',
  padding: 'px',
  'padding-bottom': 'px',
  'padding-left': 'px',
  'padding-right': 'px',
  'padding-top': 'px',
  'padding-after': 'px',
  'padding-before': 'px',
  'padding-end': 'px',
  'padding-start': 'px',
  'perspective-origin-x': '%',
  'perspective-origin-y': '%',
  perspective: 'px',
  right: 'px',
  'shape-margin': 'px',
  size: 'px',
  'text-indent': 'px',
  'text-stroke': 'px',
  'text-stroke-width': 'px',
  top: 'px',
  'transform-origin': '%',
  'transform-origin-x': '%',
  'transform-origin-y': '%',
  'transform-origin-z': '%',
  'transition-delay': 'ms',
  'transition-duration': 'ms',
  'vertical-align': 'px',
  width: 'px',
  'word-spacing': 'px',
  // Not existing properties.
  // Used to avoid issues with jss-expand intergration.
  'box-shadow-x': 'px',
  'box-shadow-y': 'px',
  'box-shadow-blur': 'px',
  'box-shadow-spread': 'px',
  'font-line-height': 'px',
  'text-shadow-x': 'px',
  'text-shadow-y': 'px',
  'text-shadow-blur': 'px'
};
},{}],348:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports['default'] = defaultUnit;

var _defaultUnits = require('./defaultUnits');

var _defaultUnits2 = _interopRequireDefault(_defaultUnits);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/**
 * Clones the object and adds a camel cased property version.
 */
function addCamelCasedVersion(obj) {
  var regExp = /(-[a-z])/g;
  var replace = function replace(str) {
    return str[1].toUpperCase();
  };
  var newObj = {};
  for (var key in obj) {
    newObj[key] = obj[key];
    newObj[key.replace(regExp, replace)] = obj[key];
  }
  return newObj;
}

var units = addCamelCasedVersion(_defaultUnits2['default']);

/**
 * Recursive deep style passing function
 *
 * @param {String} current property
 * @param {(Object|Array|Number|String)} property value
 * @param {Object} options
 * @return {(Object|Array|Number|String)} resulting value
 */
function iterate(prop, value, options) {
  if (!value) return value;

  var convertedValue = value;

  var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);
  if (type === 'object' && Array.isArray(value)) type = 'array';

  switch (type) {
    case 'object':
      if (prop === 'fallbacks') {
        for (var innerProp in value) {
          value[innerProp] = iterate(innerProp, value[innerProp], options);
        }
        break;
      }
      for (var _innerProp in value) {
        value[_innerProp] = iterate(prop + '-' + _innerProp, value[_innerProp], options);
      }
      break;
    case 'array':
      for (var i = 0; i < value.length; i++) {
        value[i] = iterate(prop, value[i], options);
      }
      break;
    case 'number':
      if (value !== 0) {
        convertedValue = value + (options[prop] || units[prop] || '');
      }
      break;
    default:
      break;
  }

  return convertedValue;
}

/**
 * Add unit to numeric values.
 */
function defaultUnit() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var camelCasedOptions = addCamelCasedVersion(options);

  function onProcessStyle(style, rule) {
    if (rule.type !== 'style') return style;

    for (var prop in style) {
      style[prop] = iterate(prop, style[prop], camelCasedOptions);
    }

    return style;
  }

  function onChangeValue(value, prop) {
    return iterate(prop, value, camelCasedOptions);
  }

  return { onProcessStyle: onProcessStyle, onChangeValue: onChangeValue };
}
},{"./defaultUnits":347}],349:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.default = jssExpand;

var _props = require('./props');

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Map values by given prop.
 *
 * @param {Array} array of values
 * @param {String} original property
 * @param {String} original rule
 * @return {String} mapped values
 */
function mapValuesByProp(value, prop, rule) {
  return value.map(function (item) {
    return objectToString(item, prop, rule);
  });
}

/**
 * Convert array to string.
 *
 * @param {Array} array of values
 * @param {String} original property
 * @param {Object} sheme, for converting arrays in strings
 * @param {Object} original rule
 * @return {String} converted string
 */
function arrayToString(value, prop, scheme, rule) {
  if (scheme[prop] == null) return value.join(',');
  if (value.length === 0) return '';
  if (Array.isArray(value[0])) return arrayToString(value[0], prop, scheme);
  if (_typeof(value[0]) === 'object') {
    return mapValuesByProp(value, prop, rule);
  }
  return value.join(' ');
}

/**
 * Convert object to string.
 *
 * @param {Object} object of values
 * @param {String} original property
 * @param {Object} original rule
 * @param {Boolean} is fallback prop
 * @return {String} converted string
 */
function objectToString(value, prop, rule, isFallback) {
  if (!(_props.propObj[prop] || _props.customPropObj[prop])) return '';

  var result = [];

  // Check if exists any non-standart property
  if (_props.customPropObj[prop]) {
    value = customPropsToStyle(value, rule, _props.customPropObj[prop], isFallback);
  }

  // Pass throught all standart props
  if (Object.keys(value).length) {
    for (var baseProp in _props.propObj[prop]) {
      if (value[baseProp]) {
        if (Array.isArray(value[baseProp])) {
          result.push(arrayToString(value[baseProp], baseProp, _props.propArrayInObj));
        } else result.push(value[baseProp]);
        continue;
      }

      // Add default value from props config.
      if (_props.propObj[prop][baseProp] != null) {
        result.push(_props.propObj[prop][baseProp]);
      }
    }
  }

  return result.join(' ');
}

/**
 * Convert custom properties values to styles adding them to rule directly
 *
 * @param {Object} object of values
 * @param {Object} original rule
 * @param {String} property, that contain partial custom properties
 * @param {Boolean} is fallback prop
 * @return {Object} value without custom properties, that was already added to rule
 */
function customPropsToStyle(value, rule, customProps, isFallback) {
  for (var prop in customProps) {
    var propName = customProps[prop];

    // If current property doesn't exist already in rule - add new one
    if (typeof value[prop] !== 'undefined' && (isFallback || !rule.prop(propName))) {
      var appendedValue = styleDetector(_defineProperty({}, propName, value[prop]), rule)[propName];

      // Add style directly in rule
      if (isFallback) rule.style.fallbacks[propName] = appendedValue;else rule.style[propName] = appendedValue;
    }
    // Delete converted property to avoid double converting
    delete value[prop];
  }

  return value;
}

/**
 * Detect if a style needs to be converted.
 *
 * @param {Object} style
 * @param {Object} rule
 * @param {Boolean} is fallback prop
 * @return {Object} convertedStyle
 */
function styleDetector(style, rule, isFallback) {
  for (var prop in style) {
    var value = style[prop];

    if (Array.isArray(value)) {
      // Check double arrays to avoid recursion.
      if (!Array.isArray(value[0])) {
        if (prop === 'fallbacks') {
          for (var index = 0; index < style.fallbacks.length; index++) {
            style.fallbacks[index] = styleDetector(style.fallbacks[index], rule, true);
          }
          continue;
        }

        style[prop] = arrayToString(value, prop, _props.propArray);
        // Avoid creating properties with empty values
        if (!style[prop]) delete style[prop];
      }
    } else if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {
      if (prop === 'fallbacks') {
        style.fallbacks = styleDetector(style.fallbacks, rule, true);
        continue;
      }

      style[prop] = objectToString(value, prop, rule, isFallback);
      // Avoid creating properties with empty values
      if (!style[prop]) delete style[prop];
    }

    // Maybe a computed value resulting in an empty string
    else if (style[prop] === '') delete style[prop];
  }

  return style;
}

/**
 * Adds possibility to write expanded styles.
 *
 * @param {Rule} rule
 * @api public
 */
function jssExpand() {
  function onProcessStyle(style, rule) {
    if (!style || rule.type !== 'style') return style;

    if (Array.isArray(style)) {
      // Pass rules one by one and reformat them
      for (var index = 0; index < style.length; index++) {
        style[index] = styleDetector(style[index], rule);
      }
      return style;
    }

    return styleDetector(style, rule);
  }

  return { onProcessStyle: onProcessStyle };
}
},{"./props":350}],350:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * A scheme for converting properties from array to regular style.
 * All properties listed below will be transformed to a string separated by space.
 */
var propArray = exports.propArray = {
  'background-size': true,
  'background-position': true,
  border: true,
  'border-bottom': true,
  'border-left': true,
  'border-top': true,
  'border-right': true,
  'border-radius': true,
  'border-image': true,
  'box-shadow': true,
  flex: true,
  margin: true,
  padding: true,
  outline: true,
  'transform-origin': true,
  transform: true,
  transition: true

  /**
   * A scheme for converting arrays to regular styles inside of objects.
   * For e.g.: "{position: [0, 0]}" => "background-position: 0 0;".
   */
};var propArrayInObj = exports.propArrayInObj = {
  position: true, // background-position
  size: true // background-size


  /**
   * A scheme for parsing and building correct styles from passed objects.
   */
};var propObj = exports.propObj = {
  padding: {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  },
  margin: {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  },
  background: {
    attachment: null,
    color: null,
    image: null,
    position: null,
    repeat: null
  },
  border: {
    width: null,
    style: null,
    color: null
  },
  'border-top': {
    width: null,
    style: null,
    color: null
  },
  'border-right': {
    width: null,
    style: null,
    color: null
  },
  'border-bottom': {
    width: null,
    style: null,
    color: null
  },
  'border-left': {
    width: null,
    style: null,
    color: null
  },
  outline: {
    width: null,
    style: null,
    color: null
  },
  'list-style': {
    type: null,
    position: null,
    image: null
  },
  transition: {
    property: null,
    duration: null,
    'timing-function': null,
    timingFunction: null, // Needed for avoiding comilation issues with jss-camel-case
    delay: null
  },
  animation: {
    name: null,
    duration: null,
    'timing-function': null,
    timingFunction: null, // Needed to avoid compilation issues with jss-camel-case
    delay: null,
    'iteration-count': null,
    iterationCount: null, // Needed to avoid compilation issues with jss-camel-case
    direction: null,
    'fill-mode': null,
    fillMode: null, // Needed to avoid compilation issues with jss-camel-case
    'play-state': null,
    playState: null // Needed to avoid compilation issues with jss-camel-case
  },
  'box-shadow': {
    x: 0,
    y: 0,
    blur: 0,
    spread: 0,
    color: null,
    inset: null
  },
  'text-shadow': {
    x: 0,
    y: 0,
    blur: null,
    color: null
  }

  /**
   * A scheme for converting non-standart properties inside object.
   * For e.g.: include 'border-radius' property inside 'border' object.
   */
};var customPropObj = exports.customPropObj = {
  border: {
    radius: 'border-radius',
    image: 'border-image'
  },
  background: {
    size: 'background-size',
    image: 'background-image'
  },
  font: {
    style: 'font-style',
    variant: 'font-variant',
    weight: 'font-weight',
    stretch: 'font-stretch',
    size: 'font-size',
    family: 'font-family',
    lineHeight: 'line-height', // Needed to avoid compilation issues with jss-camel-case
    'line-height': 'line-height'
  },
  flex: {
    grow: 'flex-grow',
    basis: 'flex-basis',
    direction: 'flex-direction',
    wrap: 'flex-wrap',
    flow: 'flex-flow',
    shrink: 'flex-shrink'
  },
  align: {
    self: 'align-self',
    items: 'align-items',
    content: 'align-content'
  }
};
},{}],351:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports['default'] = jssExtend;

var _warning = require('warning');

var _warning2 = _interopRequireDefault(_warning);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var isObject = function isObject(obj) {
  return obj && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' && !Array.isArray(obj);
};

/**
 * Recursively extend styles.
 */
function extend(style, rule, sheet) {
  var newStyle = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

  if (typeof style.extend === 'string') {
    if (sheet) {
      var refRule = sheet.getRule(style.extend);
      if (refRule) {
        if (refRule === rule) (0, _warning2['default'])(false, '[JSS] A rule tries to extend itself \r\n%s', rule);else if (refRule.options.parent) {
          var originalStyle = refRule.options.parent.rules.raw[style.extend];
          extend(originalStyle, rule, sheet, newStyle);
        }
      }
    }
  } else if (Array.isArray(style.extend)) {
    for (var index = 0; index < style.extend.length; index++) {
      extend(style.extend[index], rule, sheet, newStyle);
    }
  } else {
    for (var prop in style.extend) {
      if (prop === 'extend') {
        extend(style.extend.extend, rule, sheet, newStyle);
      } else if (isObject(style.extend[prop])) {
        if (!newStyle[prop]) newStyle[prop] = {};
        extend(style.extend[prop], rule, sheet, newStyle[prop]);
      } else {
        newStyle[prop] = style.extend[prop];
      }
    }
  }
  // Copy base style.
  for (var _prop in style) {
    if (_prop === 'extend') continue;
    if (isObject(newStyle[_prop]) && isObject(style[_prop])) {
      extend(style[_prop], rule, sheet, newStyle[_prop]);
    } else if (isObject(style[_prop])) {
      newStyle[_prop] = extend(style[_prop], rule, sheet);
    } else {
      newStyle[_prop] = style[_prop];
    }
  }

  return newStyle;
}

/**
 * Handle `extend` property.
 *
 * @param {Rule} rule
 * @api public
 */
function jssExtend() {
  function onProcessStyle(style, rule, sheet) {
    return style.extend ? extend(style, rule, sheet) : style;
  }

  return { onProcessStyle: onProcessStyle };
}
},{"warning":394}],352:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports['default'] = jssGlobal;

var _jss = require('jss');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var propKey = '@global';
var prefixKey = '@global ';

var GlobalContainerRule = function () {
  function GlobalContainerRule(key, styles, options) {
    _classCallCheck(this, GlobalContainerRule);

    this.type = 'global';

    this.key = key;
    this.options = options;
    this.rules = new _jss.RuleList(_extends({}, options, {
      parent: this
    }));

    for (var selector in styles) {
      this.rules.add(selector, styles[selector], { selector: selector });
    }

    this.rules.process();
  }

  /**
   * Get a rule.
   */


  _createClass(GlobalContainerRule, [{
    key: 'getRule',
    value: function getRule(name) {
      return this.rules.get(name);
    }

    /**
     * Create and register rule, run plugins.
     */

  }, {
    key: 'addRule',
    value: function addRule(name, style, options) {
      var rule = this.rules.add(name, style, options);
      this.options.jss.plugins.onProcessRule(rule);
      return rule;
    }

    /**
     * Get index of a rule.
     */

  }, {
    key: 'indexOf',
    value: function indexOf(rule) {
      return this.rules.indexOf(rule);
    }

    /**
     * Generates a CSS string.
     */

  }, {
    key: 'toString',
    value: function toString() {
      return this.rules.toString();
    }
  }]);

  return GlobalContainerRule;
}();

var GlobalPrefixedRule = function () {
  function GlobalPrefixedRule(name, style, options) {
    _classCallCheck(this, GlobalPrefixedRule);

    this.name = name;
    this.options = options;
    var selector = name.substr(prefixKey.length);
    this.rule = options.jss.createRule(selector, style, _extends({}, options, {
      parent: this,
      selector: selector
    }));
  }

  _createClass(GlobalPrefixedRule, [{
    key: 'toString',
    value: function toString(options) {
      return this.rule.toString(options);
    }
  }]);

  return GlobalPrefixedRule;
}();

var separatorRegExp = /\s*,\s*/g;

function addScope(selector, scope) {
  var parts = selector.split(separatorRegExp);
  var scoped = '';
  for (var i = 0; i < parts.length; i++) {
    scoped += scope + ' ' + parts[i].trim();
    if (parts[i + 1]) scoped += ', ';
  }
  return scoped;
}

function handleNestedGlobalContainerRule(rule) {
  var options = rule.options,
      style = rule.style;

  var rules = style[propKey];

  if (!rules) return;

  for (var name in rules) {
    options.sheet.addRule(name, rules[name], _extends({}, options, {
      selector: addScope(name, rule.selector)
    }));
  }

  delete style[propKey];
}

function handlePrefixedGlobalRule(rule) {
  var options = rule.options,
      style = rule.style;

  for (var prop in style) {
    if (prop.substr(0, propKey.length) !== propKey) continue;

    var selector = addScope(prop.substr(propKey.length), rule.selector);
    options.sheet.addRule(selector, style[prop], _extends({}, options, {
      selector: selector
    }));
    delete style[prop];
  }
}

/**
 * Convert nested rules to separate, remove them from original styles.
 *
 * @param {Rule} rule
 * @api public
 */
function jssGlobal() {
  function onCreateRule(name, styles, options) {
    if (name === propKey) {
      return new GlobalContainerRule(name, styles, options);
    }

    if (name[0] === '@' && name.substr(0, prefixKey.length) === prefixKey) {
      return new GlobalPrefixedRule(name, styles, options);
    }

    var parent = options.parent;


    if (parent) {
      if (parent.type === 'global' || parent.options.parent.type === 'global') {
        options.global = true;
      }
    }

    if (options.global) options.selector = name;

    return null;
  }

  function onProcessRule(rule) {
    if (rule.type !== 'style') return;

    handleNestedGlobalContainerRule(rule);
    handlePrefixedGlobalRule(rule);
  }

  return { onCreateRule: onCreateRule, onProcessRule: onProcessRule };
}
},{"jss":365}],353:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = jssNested;

var _warning = require('warning');

var _warning2 = _interopRequireDefault(_warning);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var separatorRegExp = /\s*,\s*/g;
var parentRegExp = /&/g;
var refRegExp = /\$([\w-]+)/g;

/**
 * Convert nested rules to separate, remove them from original styles.
 *
 * @param {Rule} rule
 * @api public
 */
function jssNested() {
  // Get a function to be used for $ref replacement.
  function getReplaceRef(container) {
    return function (match, key) {
      var rule = container.getRule(key);
      if (rule) return rule.selector;
      (0, _warning2.default)(false, '[JSS] Could not find the referenced rule %s in %s.', key, container.options.meta || container);
      return key;
    };
  }

  var hasAnd = function hasAnd(str) {
    return str.indexOf('&') !== -1;
  };

  function replaceParentRefs(nestedProp, parentProp) {
    var parentSelectors = parentProp.split(separatorRegExp);
    var nestedSelectors = nestedProp.split(separatorRegExp);

    var result = '';

    for (var i = 0; i < parentSelectors.length; i++) {
      var parent = parentSelectors[i];

      for (var j = 0; j < nestedSelectors.length; j++) {
        var nested = nestedSelectors[j];
        if (result) result += ', ';
        // Replace all & by the parent or prefix & with the parent.
        result += hasAnd(nested) ? nested.replace(parentRegExp, parent) : parent + ' ' + nested;
      }
    }

    return result;
  }

  function getOptions(rule, container, options) {
    // Options has been already created, now we only increase index.
    if (options) return _extends({}, options, { index: options.index + 1 });

    var nestingLevel = rule.options.nestingLevel;

    nestingLevel = nestingLevel === undefined ? 1 : nestingLevel + 1;

    return _extends({}, rule.options, {
      nestingLevel: nestingLevel,
      index: container.indexOf(rule) + 1
    });
  }

  function onProcessStyle(style, rule) {
    if (rule.type !== 'style') return style;
    var container = rule.options.parent;
    var options = void 0;
    var replaceRef = void 0;
    for (var prop in style) {
      var isNested = hasAnd(prop);
      var isNestedConditional = prop[0] === '@';

      if (!isNested && !isNestedConditional) continue;

      options = getOptions(rule, container, options);

      if (isNested) {
        var selector = replaceParentRefs(prop, rule.selector
        // Lazily create the ref replacer function just once for
        // all nested rules within the sheet.
        );if (!replaceRef) replaceRef = getReplaceRef(container
        // Replace all $refs.
        );selector = selector.replace(refRegExp, replaceRef);

        container.addRule(selector, style[prop], _extends({}, options, { selector: selector }));
      } else if (isNestedConditional) {
        container
        // Place conditional right after the parent rule to ensure right ordering.
        .addRule(prop, null, options).addRule(rule.key, style[prop], { selector: rule.selector });
      }

      delete style[prop];
    }

    return style;
  }

  return { onProcessStyle: onProcessStyle };
}
},{"warning":394}],354:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _jssTemplate = require('jss-template');

var _jssTemplate2 = _interopRequireDefault(_jssTemplate);

var _jssGlobal = require('jss-global');

var _jssGlobal2 = _interopRequireDefault(_jssGlobal);

var _jssExtend = require('jss-extend');

var _jssExtend2 = _interopRequireDefault(_jssExtend);

var _jssNested = require('jss-nested');

var _jssNested2 = _interopRequireDefault(_jssNested);

var _jssCompose = require('jss-compose');

var _jssCompose2 = _interopRequireDefault(_jssCompose);

var _jssCamelCase = require('jss-camel-case');

var _jssCamelCase2 = _interopRequireDefault(_jssCamelCase);

var _jssDefaultUnit = require('jss-default-unit');

var _jssDefaultUnit2 = _interopRequireDefault(_jssDefaultUnit);

var _jssExpand = require('jss-expand');

var _jssExpand2 = _interopRequireDefault(_jssExpand);

var _jssVendorPrefixer = require('jss-vendor-prefixer');

var _jssVendorPrefixer2 = _interopRequireDefault(_jssVendorPrefixer);

var _jssPropsSort = require('jss-props-sort');

var _jssPropsSort2 = _interopRequireDefault(_jssPropsSort);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function () {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return {
    plugins: [(0, _jssTemplate2.default)(options.template), (0, _jssGlobal2.default)(options.global), (0, _jssExtend2.default)(options.extend), (0, _jssNested2.default)(options.nested), (0, _jssCompose2.default)(options.compose), (0, _jssCamelCase2.default)(options.camelCase), (0, _jssDefaultUnit2.default)(options.defaultUnit), (0, _jssExpand2.default)(options.expand), (0, _jssVendorPrefixer2.default)(options.vendorPrefixer), (0, _jssPropsSort2.default)(options.propsSort)]
  };
};
},{"jss-camel-case":345,"jss-compose":346,"jss-default-unit":348,"jss-expand":349,"jss-extend":351,"jss-global":352,"jss-nested":353,"jss-props-sort":355,"jss-template":356,"jss-vendor-prefixer":358}],355:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports['default'] = jssPropsSort;
/**
 * Sort props by length.
 */
function jssPropsSort() {
  function sort(prop0, prop1) {
    return prop0.length - prop1.length;
  }

  function onProcessStyle(style, rule) {
    if (rule.type !== 'style') return style;

    var newStyle = {};
    var props = Object.keys(style).sort(sort);
    for (var prop in props) {
      newStyle[props[prop]] = style[props[prop]];
    }
    return newStyle;
  }

  return { onProcessStyle: onProcessStyle };
}
},{}],356:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _parse = require('./parse');

var _parse2 = _interopRequireDefault(_parse);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var onProcessRule = function onProcessRule(rule) {
  if (typeof rule.style === 'string') {
    rule.style = (0, _parse2['default'])(rule.style);
  }
};

exports['default'] = function () {
  return { onProcessRule: onProcessRule };
};
},{"./parse":357}],357:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _warning = require('warning');

var _warning2 = _interopRequireDefault(_warning);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var semiWithNl = /;\n/;

/**
 * Naive CSS parser.
 * - Supports only rule body (no selectors)
 * - Requires semicolon and new line after the value (except of last line)
 * - No nested rules support
 */

exports['default'] = function (cssText) {
  var style = {};
  var split = cssText.split(semiWithNl);
  for (var i = 0; i < split.length; i++) {
    var decl = (split[i] || '').trim();

    if (!decl) continue;
    var colonIndex = decl.indexOf(':');
    if (colonIndex === -1) {
      (0, _warning2['default'])(false, 'Malformed CSS string "%s"', decl);
      continue;
    }
    var prop = decl.substr(0, colonIndex).trim();
    var value = decl.substr(colonIndex + 1).trim();
    style[prop] = value;
  }
  return style;
};
},{"warning":394}],358:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports['default'] = jssVendorPrefixer;

var _cssVendor = require('css-vendor');

var vendor = _interopRequireWildcard(_cssVendor);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

/**
 * Add vendor prefix to a property name when needed.
 *
 * @param {Rule} rule
 * @api public
 */
function jssVendorPrefixer() {
  function onProcessRule(rule) {
    if (rule.type === 'keyframes') {
      rule.key = '@' + vendor.prefix.css + rule.key.substr(1);
    }
  }

  function onProcessStyle(style, rule) {
    if (rule.type !== 'style') return style;

    for (var prop in style) {
      var value = style[prop];

      var changeProp = false;
      var supportedProp = vendor.supportedProperty(prop);
      if (supportedProp && supportedProp !== prop) changeProp = true;

      var changeValue = false;
      var supportedValue = vendor.supportedValue(supportedProp, value);
      if (supportedValue && supportedValue !== value) changeValue = true;

      if (changeProp || changeValue) {
        if (changeProp) delete style[prop];
        style[supportedProp || prop] = supportedValue || value;
      }
    }

    return style;
  }

  function onChangeValue(value, prop) {
    return vendor.supportedValue(prop, value);
  }

  return { onProcessRule: onProcessRule, onProcessStyle: onProcessStyle, onChangeValue: onChangeValue };
}
},{"css-vendor":337}],359:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _isInBrowser = require('is-in-browser');

var _isInBrowser2 = _interopRequireDefault(_isInBrowser);

var _StyleSheet = require('./StyleSheet');

var _StyleSheet2 = _interopRequireDefault(_StyleSheet);

var _PluginsRegistry = require('./PluginsRegistry');

var _PluginsRegistry2 = _interopRequireDefault(_PluginsRegistry);

var _rules = require('./plugins/rules');

var _rules2 = _interopRequireDefault(_rules);

var _observables = require('./plugins/observables');

var _observables2 = _interopRequireDefault(_observables);

var _functions = require('./plugins/functions');

var _functions2 = _interopRequireDefault(_functions);

var _sheets = require('./sheets');

var _sheets2 = _interopRequireDefault(_sheets);

var _StyleRule = require('./rules/StyleRule');

var _StyleRule2 = _interopRequireDefault(_StyleRule);

var _createGenerateClassName = require('./utils/createGenerateClassName');

var _createGenerateClassName2 = _interopRequireDefault(_createGenerateClassName);

var _createRule2 = require('./utils/createRule');

var _createRule3 = _interopRequireDefault(_createRule2);

var _DomRenderer = require('./renderers/DomRenderer');

var _DomRenderer2 = _interopRequireDefault(_DomRenderer);

var _VirtualRenderer = require('./renderers/VirtualRenderer');

var _VirtualRenderer2 = _interopRequireDefault(_VirtualRenderer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var defaultPlugins = _rules2['default'].concat([_observables2['default'], _functions2['default']]);

var instanceCounter = 0;

var Jss = function () {
  function Jss(options) {
    _classCallCheck(this, Jss);

    this.id = instanceCounter++;
    this.version = "9.5.1";
    this.plugins = new _PluginsRegistry2['default']();
    this.options = {
      createGenerateClassName: _createGenerateClassName2['default'],
      Renderer: _isInBrowser2['default'] ? _DomRenderer2['default'] : _VirtualRenderer2['default'],
      plugins: []
    };
    this.generateClassName = (0, _createGenerateClassName2['default'])();

    // eslint-disable-next-line prefer-spread
    this.use.apply(this, defaultPlugins);
    this.setup(options);
  }

  _createClass(Jss, [{
    key: 'setup',
    value: function setup() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (options.createGenerateClassName) {
        this.options.createGenerateClassName = options.createGenerateClassName;
        // $FlowFixMe
        this.generateClassName = options.createGenerateClassName();
      }

      if (options.insertionPoint != null) this.options.insertionPoint = options.insertionPoint;
      if (options.virtual || options.Renderer) {
        this.options.Renderer = options.Renderer || (options.virtual ? _VirtualRenderer2['default'] : _DomRenderer2['default']);
      }

      // eslint-disable-next-line prefer-spread
      if (options.plugins) this.use.apply(this, options.plugins);

      return this;
    }

    /**
     * Create a Style Sheet.
     */

  }, {
    key: 'createStyleSheet',
    value: function createStyleSheet(styles) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var index = options.index;
      if (typeof index !== 'number') {
        index = _sheets2['default'].index === 0 ? 0 : _sheets2['default'].index + 1;
      }
      var sheet = new _StyleSheet2['default'](styles, _extends({}, options, {
        jss: this,
        generateClassName: options.generateClassName || this.generateClassName,
        insertionPoint: this.options.insertionPoint,
        Renderer: this.options.Renderer,
        index: index
      }));
      this.plugins.onProcessSheet(sheet);

      return sheet;
    }

    /**
     * Detach the Style Sheet and remove it from the registry.
     */

  }, {
    key: 'removeStyleSheet',
    value: function removeStyleSheet(sheet) {
      sheet.detach();
      _sheets2['default'].remove(sheet);
      return this;
    }

    /**
     * Create a rule without a Style Sheet.
     */

  }, {
    key: 'createRule',
    value: function createRule(name) {
      var style = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      // Enable rule without name for inline styles.
      if ((typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {
        options = style;
        style = name;
        name = undefined;
      }

      // Cast from RuleFactoryOptions to RuleOptions
      // https://stackoverflow.com/questions/41328728/force-casting-in-flow
      var ruleOptions = options;

      ruleOptions.jss = this;
      ruleOptions.Renderer = this.options.Renderer;
      if (!ruleOptions.generateClassName) ruleOptions.generateClassName = this.generateClassName;
      if (!ruleOptions.classes) ruleOptions.classes = {};
      var rule = (0, _createRule3['default'])(name, style, ruleOptions);

      if (!ruleOptions.selector && rule instanceof _StyleRule2['default']) {
        rule.selector = '.' + ruleOptions.generateClassName(rule);
      }

      this.plugins.onProcessRule(rule);

      return rule;
    }

    /**
     * Register plugin. Passed function will be invoked with a rule instance.
     */

  }, {
    key: 'use',
    value: function use() {
      var _this = this;

      for (var _len = arguments.length, plugins = Array(_len), _key = 0; _key < _len; _key++) {
        plugins[_key] = arguments[_key];
      }

      plugins.forEach(function (plugin) {
        // Avoids applying same plugin twice, at least based on ref.
        if (_this.options.plugins.indexOf(plugin) === -1) {
          _this.options.plugins.push(plugin);
          _this.plugins.use(plugin);
        }
      });

      return this;
    }
  }]);

  return Jss;
}();

exports['default'] = Jss;
},{"./PluginsRegistry":360,"./StyleSheet":364,"./plugins/functions":366,"./plugins/observables":367,"./plugins/rules":368,"./renderers/DomRenderer":369,"./renderers/VirtualRenderer":370,"./rules/StyleRule":375,"./sheets":377,"./utils/createGenerateClassName":379,"./utils/createRule":380,"is-in-browser":344}],360:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _warning = require('warning');

var _warning2 = _interopRequireDefault(_warning);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var PluginsRegistry = function () {
  function PluginsRegistry() {
    _classCallCheck(this, PluginsRegistry);

    this.hooks = {
      onCreateRule: [],
      onProcessRule: [],
      onProcessStyle: [],
      onProcessSheet: [],
      onChangeValue: [],
      onUpdate: []

      /**
       * Call `onCreateRule` hooks and return an object if returned by a hook.
       */
    };
  }

  _createClass(PluginsRegistry, [{
    key: 'onCreateRule',
    value: function onCreateRule(name, decl, options) {
      for (var i = 0; i < this.hooks.onCreateRule.length; i++) {
        var rule = this.hooks.onCreateRule[i](name, decl, options);
        if (rule) return rule;
      }
      return null;
    }

    /**
     * Call `onProcessRule` hooks.
     */

  }, {
    key: 'onProcessRule',
    value: function onProcessRule(rule) {
      if (rule.isProcessed) return;
      var sheet = rule.options.sheet;

      for (var i = 0; i < this.hooks.onProcessRule.length; i++) {
        this.hooks.onProcessRule[i](rule, sheet);
      }

      // $FlowFixMe
      if (rule.style) this.onProcessStyle(rule.style, rule, sheet);

      rule.isProcessed = true;
    }

    /**
     * Call `onProcessStyle` hooks.
     */

  }, {
    key: 'onProcessStyle',
    value: function onProcessStyle(style, rule, sheet) {
      var nextStyle = style;

      for (var i = 0; i < this.hooks.onProcessStyle.length; i++) {
        nextStyle = this.hooks.onProcessStyle[i](nextStyle, rule, sheet);
        // $FlowFixMe
        rule.style = nextStyle;
      }
    }

    /**
     * Call `onProcessSheet` hooks.
     */

  }, {
    key: 'onProcessSheet',
    value: function onProcessSheet(sheet) {
      for (var i = 0; i < this.hooks.onProcessSheet.length; i++) {
        this.hooks.onProcessSheet[i](sheet);
      }
    }

    /**
     * Call `onUpdate` hooks.
     */

  }, {
    key: 'onUpdate',
    value: function onUpdate(data, rule, sheet) {
      for (var i = 0; i < this.hooks.onUpdate.length; i++) {
        this.hooks.onUpdate[i](data, rule, sheet);
      }
    }

    /**
     * Call `onChangeValue` hooks.
     */

  }, {
    key: 'onChangeValue',
    value: function onChangeValue(value, prop, rule) {
      var processedValue = value;
      for (var i = 0; i < this.hooks.onChangeValue.length; i++) {
        processedValue = this.hooks.onChangeValue[i](processedValue, prop, rule);
      }
      return processedValue;
    }

    /**
     * Register a plugin.
     * If function is passed, it is a shortcut for `{onProcessRule}`.
     */

  }, {
    key: 'use',
    value: function use(plugin) {
      for (var name in plugin) {
        if (this.hooks[name]) this.hooks[name].push(plugin[name]);else (0, _warning2['default'])(false, '[JSS] Unknown hook "%s".', name);
      }
    }
  }]);

  return PluginsRegistry;
}();

exports['default'] = PluginsRegistry;
},{"warning":394}],361:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _createRule = require('./utils/createRule');

var _createRule2 = _interopRequireDefault(_createRule);

var _linkRule = require('./utils/linkRule');

var _linkRule2 = _interopRequireDefault(_linkRule);

var _StyleRule = require('./rules/StyleRule');

var _StyleRule2 = _interopRequireDefault(_StyleRule);

var _escape = require('./utils/escape');

var _escape2 = _interopRequireDefault(_escape);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Contains rules objects and allows adding/removing etc.
 * Is used for e.g. by `StyleSheet` or `ConditionalRule`.
 */
var RuleList = function () {

  // Original styles object.
  function RuleList(options) {
    _classCallCheck(this, RuleList);

    this.map = {};
    this.raw = {};
    this.index = [];

    this.options = options;
    this.classes = options.classes;
  }

  /**
   * Create and register rule.
   *
   * Will not render after Style Sheet was rendered the first time.
   */


  // Used to ensure correct rules order.

  // Rules registry for access by .get() method.
  // It contains the same rule registered by name and by selector.


  _createClass(RuleList, [{
    key: 'add',
    value: function add(name, decl, options) {
      var _options = this.options,
          parent = _options.parent,
          sheet = _options.sheet,
          jss = _options.jss,
          Renderer = _options.Renderer,
          generateClassName = _options.generateClassName;


      options = _extends({
        classes: this.classes,
        parent: parent,
        sheet: sheet,
        jss: jss,
        Renderer: Renderer,
        generateClassName: generateClassName
      }, options);

      if (!options.selector && this.classes[name]) {
        options.selector = '.' + (0, _escape2['default'])(this.classes[name]);
      }

      this.raw[name] = decl;

      var rule = (0, _createRule2['default'])(name, decl, options);

      var className = void 0;

      if (!options.selector && rule instanceof _StyleRule2['default']) {
        className = generateClassName(rule, sheet);
        rule.selector = '.' + (0, _escape2['default'])(className);
      }

      this.register(rule, className);

      var index = options.index === undefined ? this.index.length : options.index;
      this.index.splice(index, 0, rule);

      return rule;
    }

    /**
     * Get a rule.
     */

  }, {
    key: 'get',
    value: function get(name) {
      return this.map[name];
    }

    /**
     * Delete a rule.
     */

  }, {
    key: 'remove',
    value: function remove(rule) {
      this.unregister(rule);
      this.index.splice(this.indexOf(rule), 1);
    }

    /**
     * Get index of a rule.
     */

  }, {
    key: 'indexOf',
    value: function indexOf(rule) {
      return this.index.indexOf(rule);
    }

    /**
     * Run `onProcessRule()` plugins on every rule.
     */

  }, {
    key: 'process',
    value: function process() {
      var plugins = this.options.jss.plugins;
      // We need to clone array because if we modify the index somewhere else during a loop
      // we end up with very hard-to-track-down side effects.

      this.index.slice(0).forEach(plugins.onProcessRule, plugins);
    }

    /**
     * Register a rule in `.map` and `.classes` maps.
     */

  }, {
    key: 'register',
    value: function register(rule, className) {
      this.map[rule.key] = rule;
      if (rule instanceof _StyleRule2['default']) {
        this.map[rule.selector] = rule;
        if (className) this.classes[rule.key] = className;
      }
    }

    /**
     * Unregister a rule.
     */

  }, {
    key: 'unregister',
    value: function unregister(rule) {
      delete this.map[rule.key];
      if (rule instanceof _StyleRule2['default']) {
        delete this.map[rule.selector];
        delete this.classes[rule.key];
      }
    }

    /**
     * Update the function values with a new data.
     */

  }, {
    key: 'update',
    value: function update(name, data) {
      var _options2 = this.options,
          plugins = _options2.jss.plugins,
          sheet = _options2.sheet;

      if (typeof name === 'string') {
        plugins.onUpdate(data, this.get(name), sheet);
        return;
      }

      for (var index = 0; index < this.index.length; index++) {
        plugins.onUpdate(name, this.index[index], sheet);
      }
    }

    /**
     * Link renderable rules with CSSRuleList.
     */

  }, {
    key: 'link',
    value: function link(cssRules) {
      var map = this.options.sheet.renderer.getUnescapedKeysMap(this.index);

      for (var i = 0; i < cssRules.length; i++) {
        var cssRule = cssRules[i];
        var _key = this.options.sheet.renderer.getKey(cssRule);
        if (map[_key]) _key = map[_key];
        var rule = this.map[_key];
        if (rule) (0, _linkRule2['default'])(rule, cssRule);
      }
    }

    /**
     * Convert rules to a CSS string.
     */

  }, {
    key: 'toString',
    value: function toString(options) {
      var str = '';
      var sheet = this.options.sheet;

      var link = sheet ? sheet.options.link : false;

      for (var index = 0; index < this.index.length; index++) {
        var rule = this.index[index];
        var css = rule.toString(options);

        // No need to render an empty rule.
        if (!css && !link) continue;

        if (str) str += '\n';
        str += css;
      }

      return str;
    }
  }]);

  return RuleList;
}();

exports['default'] = RuleList;
},{"./rules/StyleRule":375,"./utils/createRule":380,"./utils/escape":381,"./utils/linkRule":385}],362:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _warning = require('warning');

var _warning2 = _interopRequireDefault(_warning);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * SheetsManager is like a WeakMap which is designed to count StyleSheet
 * instances and attach/detach automatically.
 */
var SheetsManager = function () {
  function SheetsManager() {
    _classCallCheck(this, SheetsManager);

    this.sheets = [];
    this.refs = [];
    this.keys = [];
  }

  _createClass(SheetsManager, [{
    key: 'get',
    value: function get(key) {
      var index = this.keys.indexOf(key);
      return this.sheets[index];
    }
  }, {
    key: 'add',
    value: function add(key, sheet) {
      var sheets = this.sheets,
          refs = this.refs,
          keys = this.keys;

      var index = sheets.indexOf(sheet);

      if (index !== -1) return index;

      sheets.push(sheet);
      refs.push(0);
      keys.push(key);

      return sheets.length - 1;
    }
  }, {
    key: 'manage',
    value: function manage(key) {
      var index = this.keys.indexOf(key);
      var sheet = this.sheets[index];
      if (this.refs[index] === 0) sheet.attach();
      this.refs[index]++;
      if (!this.keys[index]) this.keys.splice(index, 0, key);
      return sheet;
    }
  }, {
    key: 'unmanage',
    value: function unmanage(key) {
      var index = this.keys.indexOf(key);
      if (index === -1) {
        // eslint-ignore-next-line no-console
        (0, _warning2['default'])(false, 'SheetsManager: can\'t find sheet to unmanage');
        return;
      }
      if (this.refs[index] > 0) {
        this.refs[index]--;
        if (this.refs[index] === 0) this.sheets[index].detach();
      }
    }
  }, {
    key: 'size',
    get: function get() {
      return this.keys.length;
    }
  }]);

  return SheetsManager;
}();

exports['default'] = SheetsManager;
},{"warning":394}],363:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Sheets registry to access them all at one place.
 */
var SheetsRegistry = function () {
  function SheetsRegistry() {
    _classCallCheck(this, SheetsRegistry);

    this.registry = [];
  }

  _createClass(SheetsRegistry, [{
    key: 'add',


    /**
     * Register a Style Sheet.
     */
    value: function add(sheet) {
      var registry = this.registry;
      var index = sheet.options.index;


      if (registry.indexOf(sheet) !== -1) return;

      if (registry.length === 0 || index >= this.index) {
        registry.push(sheet);
        return;
      }

      // Find a position.
      for (var i = 0; i < registry.length; i++) {
        if (registry[i].options.index > index) {
          registry.splice(i, 0, sheet);
          return;
        }
      }
    }

    /**
     * Reset the registry.
     */

  }, {
    key: 'reset',
    value: function reset() {
      this.registry = [];
    }

    /**
     * Remove a Style Sheet.
     */

  }, {
    key: 'remove',
    value: function remove(sheet) {
      var index = this.registry.indexOf(sheet);
      this.registry.splice(index, 1);
    }

    /**
     * Convert all attached sheets to a CSS string.
     */

  }, {
    key: 'toString',
    value: function toString(options) {
      return this.registry.filter(function (sheet) {
        return sheet.attached;
      }).map(function (sheet) {
        return sheet.toString(options);
      }).join('\n');
    }
  }, {
    key: 'index',


    /**
     * Current highest index number.
     */
    get: function get() {
      return this.registry.length === 0 ? 0 : this.registry[this.registry.length - 1].options.index;
    }
  }]);

  return SheetsRegistry;
}();

exports['default'] = SheetsRegistry;
},{}],364:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _linkRule = require('./utils/linkRule');

var _linkRule2 = _interopRequireDefault(_linkRule);

var _RuleList = require('./RuleList');

var _RuleList2 = _interopRequireDefault(_RuleList);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var StyleSheet = function () {
  function StyleSheet(styles, options) {
    _classCallCheck(this, StyleSheet);

    this.attached = false;
    this.deployed = false;
    this.linked = false;
    this.classes = {};
    this.options = _extends({}, options, {
      sheet: this,
      parent: this,
      classes: this.classes
    });
    this.renderer = new options.Renderer(this);
    this.rules = new _RuleList2['default'](this.options);

    for (var name in styles) {
      this.rules.add(name, styles[name]);
    }

    this.rules.process();
  }

  /**
   * Attach renderable to the render tree.
   */


  _createClass(StyleSheet, [{
    key: 'attach',
    value: function attach() {
      if (this.attached) return this;
      if (!this.deployed) this.deploy();
      this.renderer.attach();
      if (!this.linked && this.options.link) this.link();
      this.attached = true;
      return this;
    }

    /**
     * Remove renderable from render tree.
     */

  }, {
    key: 'detach',
    value: function detach() {
      if (!this.attached) return this;
      this.renderer.detach();
      this.attached = false;
      return this;
    }

    /**
     * Add a rule to the current stylesheet.
     * Will insert a rule also after the stylesheet has been rendered first time.
     */

  }, {
    key: 'addRule',
    value: function addRule(name, decl, options) {
      var queue = this.queue;

      // Plugins can create rules.
      // In order to preserve the right order, we need to queue all `.addRule` calls,
      // which happen after the first `rules.add()` call.

      if (this.attached && !queue) this.queue = [];

      var rule = this.rules.add(name, decl, options);
      this.options.jss.plugins.onProcessRule(rule);

      if (this.attached) {
        if (!this.deployed) return rule;
        // Don't insert rule directly if there is no stringified version yet.
        // It will be inserted all together when .attach is called.
        if (queue) queue.push(rule);else {
          this.insertRule(rule);
          if (this.queue) {
            this.queue.forEach(this.insertRule, this);
            this.queue = undefined;
          }
        }
        return rule;
      }

      // We can't add rules to a detached style node.
      // We will redeploy the sheet once user will attach it.
      this.deployed = false;

      return rule;
    }

    /**
     * Insert rule into the StyleSheet
     */

  }, {
    key: 'insertRule',
    value: function insertRule(rule) {
      var renderable = this.renderer.insertRule(rule);
      if (renderable && this.options.link) (0, _linkRule2['default'])(rule, renderable);
    }

    /**
     * Create and add rules.
     * Will render also after Style Sheet was rendered the first time.
     */

  }, {
    key: 'addRules',
    value: function addRules(styles, options) {
      var added = [];
      for (var name in styles) {
        added.push(this.addRule(name, styles[name], options));
      }
      return added;
    }

    /**
     * Get a rule by name.
     */

  }, {
    key: 'getRule',
    value: function getRule(name) {
      return this.rules.get(name);
    }

    /**
     * Delete a rule by name.
     * Returns `true`: if rule has been deleted from the DOM.
     */

  }, {
    key: 'deleteRule',
    value: function deleteRule(name) {
      var rule = this.rules.get(name);

      if (!rule) return false;

      this.rules.remove(rule);

      if (this.attached && rule.renderable) {
        return this.renderer.deleteRule(rule.renderable);
      }

      return true;
    }

    /**
     * Get index of a rule.
     */

  }, {
    key: 'indexOf',
    value: function indexOf(rule) {
      return this.rules.indexOf(rule);
    }

    /**
     * Deploy pure CSS string to a renderable.
     */

  }, {
    key: 'deploy',
    value: function deploy() {
      this.renderer.deploy();
      this.deployed = true;
      return this;
    }

    /**
     * Link renderable CSS rules from sheet with their corresponding models.
     */

  }, {
    key: 'link',
    value: function link() {
      var cssRules = this.renderer.getRules();

      // Is undefined when VirtualRenderer is used.
      if (cssRules) this.rules.link(cssRules);
      this.linked = true;
      return this;
    }

    /**
     * Update the function values with a new data.
     */

  }, {
    key: 'update',
    value: function update(name, data) {
      this.rules.update(name, data);
      return this;
    }

    /**
     * Convert rules to a CSS string.
     */

  }, {
    key: 'toString',
    value: function toString(options) {
      return this.rules.toString(options);
    }
  }]);

  return StyleSheet;
}();

exports['default'] = StyleSheet;
},{"./RuleList":361,"./utils/linkRule":385}],365:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.create = exports.createGenerateClassName = exports.sheets = exports.RuleList = exports.SheetsManager = exports.SheetsRegistry = exports.toCssValue = exports.getDynamicStyles = undefined;

var _getDynamicStyles = require('./utils/getDynamicStyles');

Object.defineProperty(exports, 'getDynamicStyles', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_getDynamicStyles)['default'];
  }
});

var _toCssValue = require('./utils/toCssValue');

Object.defineProperty(exports, 'toCssValue', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_toCssValue)['default'];
  }
});

var _SheetsRegistry = require('./SheetsRegistry');

Object.defineProperty(exports, 'SheetsRegistry', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_SheetsRegistry)['default'];
  }
});

var _SheetsManager = require('./SheetsManager');

Object.defineProperty(exports, 'SheetsManager', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_SheetsManager)['default'];
  }
});

var _RuleList = require('./RuleList');

Object.defineProperty(exports, 'RuleList', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_RuleList)['default'];
  }
});

var _sheets = require('./sheets');

Object.defineProperty(exports, 'sheets', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_sheets)['default'];
  }
});

var _createGenerateClassName = require('./utils/createGenerateClassName');

Object.defineProperty(exports, 'createGenerateClassName', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_createGenerateClassName)['default'];
  }
});

var _Jss = require('./Jss');

var _Jss2 = _interopRequireDefault(_Jss);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/**
 * Creates a new instance of Jss.
 */
var create = exports.create = function create(options) {
  return new _Jss2['default'](options);
};

/**
 * A global Jss instance.
 */
exports['default'] = create();
},{"./Jss":359,"./RuleList":361,"./SheetsManager":362,"./SheetsRegistry":363,"./sheets":377,"./utils/createGenerateClassName":379,"./utils/getDynamicStyles":382,"./utils/toCssValue":388}],366:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _RuleList = require('../RuleList');

var _RuleList2 = _interopRequireDefault(_RuleList);

var _StyleRule = require('../rules/StyleRule');

var _StyleRule2 = _interopRequireDefault(_StyleRule);

var _kebabCase = require('../utils/kebabCase');

var _kebabCase2 = _interopRequireDefault(_kebabCase);

var _createRule = require('../utils/createRule');

var _createRule2 = _interopRequireDefault(_createRule);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

// A symbol replacement.
var now = Date.now();
var fnValuesNs = 'fnValues' + now;
var fnStyleNs = 'fnStyle' + ++now;

exports['default'] = {
  onCreateRule: function onCreateRule(name, decl, options) {
    if (typeof decl !== 'function') return null;
    var rule = (0, _createRule2['default'])(name, {}, options);
    rule[fnStyleNs] = decl;
    return rule;
  },
  onProcessStyle: function onProcessStyle(style, rule) {
    var fn = {};
    for (var prop in style) {
      var value = style[prop];
      if (typeof value !== 'function') continue;
      delete style[prop];
      fn[(0, _kebabCase2['default'])(prop)] = value;
    }
    rule = rule;
    rule[fnValuesNs] = fn;
    return style;
  },
  onUpdate: function onUpdate(data, rule) {
    // It is a rules container like for e.g. ConditionalRule.
    if (rule.rules instanceof _RuleList2['default']) {
      rule.rules.update(data);
      return;
    }
    if (!(rule instanceof _StyleRule2['default'])) return;

    rule = rule;

    // If we have a fn values map, it is a rule with function values.
    if (rule[fnValuesNs]) {
      for (var prop in rule[fnValuesNs]) {
        rule.prop(prop, rule[fnValuesNs][prop](data));
      }
    }

    rule = rule;

    var fnStyle = rule[fnStyleNs];

    // If we have a style function, the entire rule is dynamic and style object
    // will be returned from that function.
    if (fnStyle) {
      var style = fnStyle(data);
      for (var _prop in style) {
        rule.prop(_prop, style[_prop]);
      }
    }
  }
};
},{"../RuleList":361,"../rules/StyleRule":375,"../utils/createRule":380,"../utils/kebabCase":384}],367:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _StyleRule = require('../rules/StyleRule');

var _StyleRule2 = _interopRequireDefault(_StyleRule);

var _createRule = require('../utils/createRule');

var _createRule2 = _interopRequireDefault(_createRule);

var _isObservable = require('../utils/isObservable');

var _isObservable2 = _interopRequireDefault(_isObservable);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

exports['default'] = {
  onCreateRule: function onCreateRule(name, decl, options) {
    if (!(0, _isObservable2['default'])(decl)) return null;

    // Cast `decl` to `Observable`, since it passed the type guard.
    var style$ = decl;

    var rule = (0, _createRule2['default'])(name, {}, options);

    // TODO
    // Call `stream.subscribe()` returns a subscription, which should be explicitly
    // unsubscribed from when we know this sheet is no longer needed.
    style$.subscribe(function (style) {
      for (var prop in style) {
        rule.prop(prop, style[prop]);
      }
    });

    return rule;
  },
  onProcessRule: function onProcessRule(rule) {
    if (!(rule instanceof _StyleRule2['default'])) return;
    var styleRule = rule;
    var style = styleRule.style;

    var _loop = function _loop(prop) {
      var value = style[prop];
      if (!(0, _isObservable2['default'])(value)) return 'continue';
      delete style[prop];
      value.subscribe({
        next: function next(nextValue) {
          styleRule.prop(prop, nextValue);
        }
      });
    };

    for (var prop in style) {
      var _ret = _loop(prop);

      if (_ret === 'continue') continue;
    }
  }
};
},{"../rules/StyleRule":375,"../utils/createRule":380,"../utils/isObservable":383}],368:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _SimpleRule = require('../rules/SimpleRule');

var _SimpleRule2 = _interopRequireDefault(_SimpleRule);

var _KeyframesRule = require('../rules/KeyframesRule');

var _KeyframesRule2 = _interopRequireDefault(_KeyframesRule);

var _ConditionalRule = require('../rules/ConditionalRule');

var _ConditionalRule2 = _interopRequireDefault(_ConditionalRule);

var _FontFaceRule = require('../rules/FontFaceRule');

var _FontFaceRule2 = _interopRequireDefault(_FontFaceRule);

var _ViewportRule = require('../rules/ViewportRule');

var _ViewportRule2 = _interopRequireDefault(_ViewportRule);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var classes = {
  '@charset': _SimpleRule2['default'],
  '@import': _SimpleRule2['default'],
  '@namespace': _SimpleRule2['default'],
  '@keyframes': _KeyframesRule2['default'],
  '@media': _ConditionalRule2['default'],
  '@supports': _ConditionalRule2['default'],
  '@font-face': _FontFaceRule2['default'],
  '@viewport': _ViewportRule2['default'],
  '@-ms-viewport': _ViewportRule2['default']

  /**
   * Generate plugins which will register all rules.
   */
};
exports['default'] = Object.keys(classes).map(function (key) {
  // https://jsperf.com/indexof-vs-substr-vs-regex-at-the-beginning-3
  var re = new RegExp('^' + key);
  var onCreateRule = function onCreateRule(name, decl, options) {
    return re.test(name) ? new classes[key](name, decl, options) : null;
  };
  return { onCreateRule: onCreateRule };
});
},{"../rules/ConditionalRule":371,"../rules/FontFaceRule":372,"../rules/KeyframesRule":373,"../rules/SimpleRule":374,"../rules/ViewportRule":376}],369:[function(require,module,exports){
(function (global){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _warning = require('warning');

var _warning2 = _interopRequireDefault(_warning);

var _sheets = require('../sheets');

var _sheets2 = _interopRequireDefault(_sheets);

var _StyleRule = require('../rules/StyleRule');

var _StyleRule2 = _interopRequireDefault(_StyleRule);

var _toCssValue = require('../utils/toCssValue');

var _toCssValue2 = _interopRequireDefault(_toCssValue);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Get a style property.
 */
function getStyle(cssRule, prop) {
  try {
    return cssRule.style.getPropertyValue(prop);
  } catch (err) {
    // IE may throw if property is unknown.
    return '';
  }
}

/**
 * Set a style property.
 */
function setStyle(cssRule, prop, value) {
  try {
    var cssValue = value;

    if (Array.isArray(value)) {
      cssValue = (0, _toCssValue2['default'])(value, true);

      if (value[value.length - 1] === '!important') {
        cssRule.style.setProperty(prop, cssValue, 'important');
        return true;
      }
    }

    cssRule.style.setProperty(prop, cssValue);
  } catch (err) {
    // IE may throw if property is unknown.
    return false;
  }
  return true;
}

var CSSRuleTypes = {
  STYLE_RULE: 1,
  KEYFRAMES_RULE: 7

  /**
   * Get the CSS Rule key.
   */

};var getKey = function () {
  var extractKey = function extractKey(cssText) {
    var from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    return cssText.substr(from, cssText.indexOf('{') - 1);
  };

  return function (cssRule) {
    if (cssRule.type === CSSRuleTypes.STYLE_RULE) return cssRule.selectorText;
    if (cssRule.type === CSSRuleTypes.KEYFRAMES_RULE) {
      var name = cssRule.name;

      if (name) return '@keyframes ' + name;

      // There is no rule.name in the following browsers:
      // - IE 9
      // - Safari 7.1.8
      // - Mobile Safari 9.0.0
      var cssText = cssRule.cssText;

      return '@' + extractKey(cssText, cssText.indexOf('keyframes'));
    }

    // Conditionals.
    return extractKey(cssRule.cssText);
  };
}();

/**
 * Set the selector.
 */
function setSelector(cssRule, selectorText) {
  cssRule.selectorText = selectorText;

  // Return false if setter was not successful.
  // Currently works in chrome only.
  return cssRule.selectorText === selectorText;
}

/**
 * Gets the `head` element upon the first call and caches it.
 */
var getHead = function () {
  var head = void 0;
  return function () {
    if (!head) head = document.head || document.getElementsByTagName('head')[0];
    return head;
  };
}();

/**
 * Gets a map of rule keys, where the property is an unescaped key and value
 * is a potentially escaped one.
 * It is used to identify CSS rules and the corresponding JSS rules. As an identifier
 * for CSSStyleRule we normally use `selectorText`. Though if original selector text
 * contains escaped code points e.g. `:not(#\\20)`, CSSOM will compile it to `:not(# )`
 * and so CSS rule's `selectorText` won't match JSS rule selector.
 *
 * https://www.w3.org/International/questions/qa-escapes#cssescapes
 */
var getUnescapedKeysMap = function () {
  var style = void 0;
  var isAttached = false;

  return function (rules) {
    var map = {};
    // https://github.com/facebook/flow/issues/2696
    if (!style) style = document.createElement('style');
    for (var i = 0; i < rules.length; i++) {
      var rule = rules[i];
      if (!(rule instanceof _StyleRule2['default'])) continue;
      var selector = rule.selector;
      // Only unescape selector over CSSOM if it contains a back slash.

      if (selector && selector.indexOf('\\') !== -1) {
        // Lazilly attach when needed.
        if (!isAttached) {
          getHead().appendChild(style);
          isAttached = true;
        }
        style.textContent = selector + ' {}';
        var _style = style,
            sheet = _style.sheet;

        if (sheet) {
          var cssRules = sheet.cssRules;

          if (cssRules) map[cssRules[0].selectorText] = rule.key;
        }
      }
    }
    if (isAttached) {
      getHead().removeChild(style);
      isAttached = false;
    }
    return map;
  };
}();

/**
 * Find attached sheet with an index higher than the passed one.
 */
function findHigherSheet(registry, options) {
  for (var i = 0; i < registry.length; i++) {
    var sheet = registry[i];
    if (sheet.attached && sheet.options.index > options.index && sheet.options.insertionPoint === options.insertionPoint) {
      return sheet;
    }
  }
  return null;
}

/**
 * Find attached sheet with the highest index.
 */
function findHighestSheet(registry, options) {
  for (var i = registry.length - 1; i >= 0; i--) {
    var sheet = registry[i];
    if (sheet.attached && sheet.options.insertionPoint === options.insertionPoint) {
      return sheet;
    }
  }
  return null;
}

/**
 * Find a comment with "jss" inside.
 */
function findCommentNode(text) {
  var head = getHead();
  for (var i = 0; i < head.childNodes.length; i++) {
    var node = head.childNodes[i];
    if (node.nodeType === 8 && node.nodeValue.trim() === text) {
      return node;
    }
  }
  return null;
}

/**
 * Find a node before which we can insert the sheet.
 */
function findPrevNode(options) {
  var registry = _sheets2['default'].registry;


  if (registry.length > 0) {
    // Try to insert before the next higher sheet.
    var sheet = findHigherSheet(registry, options);
    if (sheet) return sheet.renderer.element;

    // Otherwise insert after the last attached.
    sheet = findHighestSheet(registry, options);
    if (sheet) return sheet.renderer.element.nextElementSibling;
  }

  // Try to find a comment placeholder if registry is empty.
  var insertionPoint = options.insertionPoint;

  if (insertionPoint && typeof insertionPoint === 'string') {
    var comment = findCommentNode(insertionPoint);
    if (comment) return comment.nextSibling;
    // If user specifies an insertion point and it can't be found in the document -
    // bad specificity issues may appear.
    (0, _warning2['default'])(insertionPoint === 'jss', '[JSS] Insertion point "%s" not found.', insertionPoint);
  }

  return null;
}

/**
 * Insert style element into the DOM.
 */
function insertStyle(style, options) {
  var insertionPoint = options.insertionPoint;

  var prevNode = findPrevNode(options);

  if (prevNode) {
    var parentNode = prevNode.parentNode;

    if (parentNode) parentNode.insertBefore(style, prevNode);
    return;
  }

  // Works with iframes and any node types.
  if (insertionPoint && typeof insertionPoint.nodeType === 'number') {
    // https://stackoverflow.com/questions/41328728/force-casting-in-flow
    var insertionPointElement = insertionPoint;
    var _parentNode = insertionPointElement.parentNode;

    if (_parentNode) _parentNode.insertBefore(style, insertionPointElement.nextSibling);else (0, _warning2['default'])(false, '[JSS] Insertion point is not in the DOM.');
    return;
  }

  getHead().insertBefore(style, prevNode);
}

var DomRenderer = function () {
  function DomRenderer(sheet) {
    _classCallCheck(this, DomRenderer);

    this.getStyle = getStyle;
    this.setStyle = setStyle;
    this.setSelector = setSelector;
    this.getKey = getKey;
    this.getUnescapedKeysMap = getUnescapedKeysMap;
    this.hasInsertedRules = false;

    // There is no sheet when the renderer is used from a standalone StyleRule.
    if (sheet) _sheets2['default'].add(sheet);

    this.sheet = sheet;

    var _ref = this.sheet ? this.sheet.options : {},
        media = _ref.media,
        meta = _ref.meta,
        element = _ref.element;

    this.element = element || document.createElement('style');
    this.element.type = 'text/css';
    this.element.setAttribute('data-jss', '');
    if (media) this.element.setAttribute('media', media);
    if (meta) this.element.setAttribute('data-meta', meta);
    // eslint-disable-next-line no-underscore-dangle
    var nonce = global.__webpack_nonce__;
    if (nonce) this.element.setAttribute('nonce', nonce);
  }

  /**
   * Insert style element into render tree.
   */


  // HTMLStyleElement needs fixing https://github.com/facebook/flow/issues/2696


  _createClass(DomRenderer, [{
    key: 'attach',
    value: function attach() {
      // In the case the element node is external and it is already in the DOM.
      if (this.element.parentNode || !this.sheet) return;

      // When rules are inserted using `insertRule` API, after `sheet.detach().attach()`
      // browsers remove those rules.
      // TODO figure out if its a bug and if it is known.
      // Workaround is to redeploy the sheet before attaching as a string.
      if (this.hasInsertedRules) {
        this.deploy();
        this.hasInsertedRules = false;
      }

      insertStyle(this.element, this.sheet.options);
    }

    /**
     * Remove style element from render tree.
     */

  }, {
    key: 'detach',
    value: function detach() {
      this.element.parentNode.removeChild(this.element);
    }

    /**
     * Inject CSS string into element.
     */

  }, {
    key: 'deploy',
    value: function deploy() {
      if (!this.sheet) return;
      this.element.textContent = '\n' + this.sheet.toString() + '\n';
    }

    /**
     * Insert a rule into element.
     */

  }, {
    key: 'insertRule',
    value: function insertRule(rule, index) {
      var sheet = this.element.sheet;
      var cssRules = sheet.cssRules;

      var str = rule.toString();
      if (!index) index = cssRules.length;

      if (!str) return false;

      try {
        sheet.insertRule(str, index);
      } catch (err) {
        (0, _warning2['default'])(false, '[JSS] Can not insert an unsupported rule \n\r%s', rule);
        return false;
      }
      this.hasInsertedRules = true;

      return cssRules[index];
    }

    /**
     * Delete a rule.
     */

  }, {
    key: 'deleteRule',
    value: function deleteRule(cssRule) {
      var sheet = this.element.sheet;

      var index = this.indexOf(cssRule);
      if (index === -1) return false;
      sheet.deleteRule(index);
      return true;
    }

    /**
     * Get index of a CSS Rule.
     */

  }, {
    key: 'indexOf',
    value: function indexOf(cssRule) {
      var cssRules = this.element.sheet.cssRules;

      for (var _index = 0; _index < cssRules.length; _index++) {
        if (cssRule === cssRules[_index]) return _index;
      }
      return -1;
    }

    /**
     * Generate a new CSS rule and replace the existing one.
     */

  }, {
    key: 'replaceRule',
    value: function replaceRule(cssRule, rule) {
      var index = this.indexOf(cssRule);
      var newCssRule = this.insertRule(rule, index);
      this.element.sheet.deleteRule(index);
      return newCssRule;
    }

    /**
     * Get all rules elements.
     */

  }, {
    key: 'getRules',
    value: function getRules() {
      return this.element.sheet.cssRules;
    }
  }]);

  return DomRenderer;
}();

exports['default'] = DomRenderer;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../rules/StyleRule":375,"../sheets":377,"../utils/toCssValue":388,"warning":394}],370:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/* eslint-disable class-methods-use-this */

/**
 * Rendering backend to do nothing in nodejs.
 */
var VirtualRenderer = function () {
  function VirtualRenderer() {
    _classCallCheck(this, VirtualRenderer);
  }

  _createClass(VirtualRenderer, [{
    key: 'setStyle',
    value: function setStyle() {
      return true;
    }
  }, {
    key: 'getStyle',
    value: function getStyle() {
      return '';
    }
  }, {
    key: 'setSelector',
    value: function setSelector() {
      return true;
    }
  }, {
    key: 'getKey',
    value: function getKey() {
      return '';
    }
  }, {
    key: 'attach',
    value: function attach() {}
  }, {
    key: 'detach',
    value: function detach() {}
  }, {
    key: 'deploy',
    value: function deploy() {}
  }, {
    key: 'insertRule',
    value: function insertRule() {
      return false;
    }
  }, {
    key: 'deleteRule',
    value: function deleteRule() {
      return true;
    }
  }, {
    key: 'replaceRule',
    value: function replaceRule() {
      return false;
    }
  }, {
    key: 'getRules',
    value: function getRules() {}
  }, {
    key: 'indexOf',
    value: function indexOf() {
      return -1;
    }
  }]);

  return VirtualRenderer;
}();

exports['default'] = VirtualRenderer;
},{}],371:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _RuleList = require('../RuleList');

var _RuleList2 = _interopRequireDefault(_RuleList);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Conditional rule for @media, @supports
 */
var ConditionalRule = function () {
  function ConditionalRule(key, styles, options) {
    _classCallCheck(this, ConditionalRule);

    this.type = 'conditional';
    this.isProcessed = false;

    this.key = key;
    this.options = options;
    this.rules = new _RuleList2['default'](_extends({}, options, { parent: this }));

    for (var name in styles) {
      this.rules.add(name, styles[name]);
    }

    this.rules.process();
  }

  /**
   * Get a rule.
   */


  _createClass(ConditionalRule, [{
    key: 'getRule',
    value: function getRule(name) {
      return this.rules.get(name);
    }

    /**
     * Get index of a rule.
     */

  }, {
    key: 'indexOf',
    value: function indexOf(rule) {
      return this.rules.indexOf(rule);
    }

    /**
     * Create and register rule, run plugins.
     */

  }, {
    key: 'addRule',
    value: function addRule(name, style, options) {
      var rule = this.rules.add(name, style, options);
      this.options.jss.plugins.onProcessRule(rule);
      return rule;
    }

    /**
     * Generates a CSS string.
     */

  }, {
    key: 'toString',
    value: function toString() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { indent: 1 };

      var inner = this.rules.toString(options);
      return inner ? this.key + ' {\n' + inner + '\n}' : '';
    }
  }]);

  return ConditionalRule;
}();

exports['default'] = ConditionalRule;
},{"../RuleList":361}],372:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _toCss = require('../utils/toCss');

var _toCss2 = _interopRequireDefault(_toCss);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var FontFaceRule = function () {
  function FontFaceRule(key, style, options) {
    _classCallCheck(this, FontFaceRule);

    this.type = 'font-face';
    this.isProcessed = false;

    this.key = key;
    this.style = style;
    this.options = options;
  }

  /**
   * Generates a CSS string.
   */


  _createClass(FontFaceRule, [{
    key: 'toString',
    value: function toString(options) {
      if (Array.isArray(this.style)) {
        var str = '';
        for (var index = 0; index < this.style.length; index++) {
          str += (0, _toCss2['default'])(this.key, this.style[index]);
          if (this.style[index + 1]) str += '\n';
        }
        return str;
      }

      return (0, _toCss2['default'])(this.key, this.style, options);
    }
  }]);

  return FontFaceRule;
}();

exports['default'] = FontFaceRule;
},{"../utils/toCss":387}],373:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _RuleList = require('../RuleList');

var _RuleList2 = _interopRequireDefault(_RuleList);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Rule for @keyframes
 */
var KeyframesRule = function () {
  function KeyframesRule(key, frames, options) {
    _classCallCheck(this, KeyframesRule);

    this.type = 'keyframes';
    this.isProcessed = false;

    this.key = key;
    this.options = options;
    this.rules = new _RuleList2['default'](_extends({}, options, { parent: this }));

    for (var name in frames) {
      this.rules.add(name, frames[name], _extends({}, this.options, {
        parent: this,
        selector: name
      }));
    }

    this.rules.process();
  }

  /**
   * Generates a CSS string.
   */


  _createClass(KeyframesRule, [{
    key: 'toString',
    value: function toString() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { indent: 1 };

      var inner = this.rules.toString(options);
      if (inner) inner += '\n';
      return this.key + ' {\n' + inner + '}';
    }
  }]);

  return KeyframesRule;
}();

exports['default'] = KeyframesRule;
},{"../RuleList":361}],374:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var SimpleRule = function () {
  function SimpleRule(key, value, options) {
    _classCallCheck(this, SimpleRule);

    this.type = 'simple';
    this.isProcessed = false;

    this.key = key;
    this.value = value;
    this.options = options;
  }

  /**
   * Generates a CSS string.
   */
  // eslint-disable-next-line no-unused-vars


  _createClass(SimpleRule, [{
    key: 'toString',
    value: function toString(options) {
      if (Array.isArray(this.value)) {
        var str = '';
        for (var index = 0; index < this.value.length; index++) {
          str += this.key + ' ' + this.value[index] + ';';
          if (this.value[index + 1]) str += '\n';
        }
        return str;
      }

      return this.key + ' ' + this.value + ';';
    }
  }]);

  return SimpleRule;
}();

exports['default'] = SimpleRule;
},{}],375:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _warning = require('warning');

var _warning2 = _interopRequireDefault(_warning);

var _toCss = require('../utils/toCss');

var _toCss2 = _interopRequireDefault(_toCss);

var _toCssValue = require('../utils/toCssValue');

var _toCssValue2 = _interopRequireDefault(_toCssValue);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var StyleRule = function () {
  function StyleRule(key, style, options) {
    _classCallCheck(this, StyleRule);

    this.type = 'style';
    this.isProcessed = false;
    var sheet = options.sheet,
        Renderer = options.Renderer,
        selector = options.selector;

    this.key = key;
    this.options = options;
    this.style = style;
    if (selector) this.selectorText = selector;
    this.renderer = sheet ? sheet.renderer : new Renderer();
  }

  /**
   * Set selector string.
   * Attention: use this with caution. Most browsers didn't implement
   * selectorText setter, so this may result in rerendering of entire Style Sheet.
   */


  _createClass(StyleRule, [{
    key: 'prop',


    /**
     * Get or set a style property.
     */
    value: function prop(name, nextValue) {
      // It's a setter.
      if (nextValue != null) {
        // Don't do anything if the value has not changed.
        if (this.style[name] !== nextValue) {
          nextValue = this.options.jss.plugins.onChangeValue(nextValue, name, this);
          this.style[name] = nextValue;

          // Renderable is defined if StyleSheet option `link` is true.
          if (this.renderable) this.renderer.setStyle(this.renderable, name, nextValue);else {
            var sheet = this.options.sheet;

            if (sheet && sheet.attached) {
              (0, _warning2['default'])(false, 'Rule is not linked. Missing sheet option "link: true".');
            }
          }
        }
        return this;
      }

      return this.style[name];
    }

    /**
     * Apply rule to an element inline.
     */

  }, {
    key: 'applyTo',
    value: function applyTo(renderable) {
      var json = this.toJSON();
      for (var prop in json) {
        this.renderer.setStyle(renderable, prop, json[prop]);
      }return this;
    }

    /**
     * Returns JSON representation of the rule.
     * Fallbacks are not supported.
     * Useful for inline styles.
     */

  }, {
    key: 'toJSON',
    value: function toJSON() {
      var json = {};
      for (var prop in this.style) {
        var value = this.style[prop];
        if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) !== 'object') json[prop] = value;else if (Array.isArray(value)) json[prop] = (0, _toCssValue2['default'])(value);
      }
      return json;
    }

    /**
     * Generates a CSS string.
     */

  }, {
    key: 'toString',
    value: function toString(options) {
      var sheet = this.options.sheet;

      var link = sheet ? sheet.options.link : false;
      var opts = link ? _extends({}, options, { allowEmpty: true }) : options;
      return (0, _toCss2['default'])(this.selector, this.style, opts);
    }
  }, {
    key: 'selector',
    set: function set(selector) {
      if (selector === this.selectorText) return;

      this.selectorText = selector;

      if (this.renderable) {
        var hasChanged = this.renderer.setSelector(this.renderable, selector);

        // If selector setter is not implemented, rerender the rule.
        if (!hasChanged && this.renderable) {
          var renderable = this.renderer.replaceRule(this.renderable, this);
          if (renderable) this.renderable = renderable;
        }
      }
    }

    /**
     * Get selector string.
     */
    ,
    get: function get() {
      return this.selectorText;
    }
  }]);

  return StyleRule;
}();

exports['default'] = StyleRule;
},{"../utils/toCss":387,"../utils/toCssValue":388,"warning":394}],376:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _toCss = require('../utils/toCss');

var _toCss2 = _interopRequireDefault(_toCss);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ViewportRule = function () {
  function ViewportRule(key, style, options) {
    _classCallCheck(this, ViewportRule);

    this.type = 'viewport';
    this.isProcessed = false;

    this.key = key;
    this.style = style;
    this.options = options;
  }

  /**
   * Generates a CSS string.
   */


  _createClass(ViewportRule, [{
    key: 'toString',
    value: function toString(options) {
      return (0, _toCss2['default'])(this.key, this.style, options);
    }
  }]);

  return ViewportRule;
}();

exports['default'] = ViewportRule;
},{"../utils/toCss":387}],377:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _SheetsRegistry = require('./SheetsRegistry');

var _SheetsRegistry2 = _interopRequireDefault(_SheetsRegistry);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/**
 * This is a global sheets registry. Only DomRenderer will add sheets to it.
 * On the server one should use an own SheetsRegistry instance and add the
 * sheets to it, because you need to make sure to create a new registry for
 * each request in order to not leak sheets across requests.
 */
exports['default'] = new _SheetsRegistry2['default']();
},{"./SheetsRegistry":363}],378:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports['default'] = cloneStyle;

var _isObservable = require('./isObservable');

var _isObservable2 = _interopRequireDefault(_isObservable);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var isArray = Array.isArray;
function cloneStyle(style) {
  // Support empty values in case user ends up with them by accident.
  if (style == null) return style;

  // Support string value for SimpleRule.
  var typeOfStyle = typeof style === 'undefined' ? 'undefined' : _typeof(style);

  if (typeOfStyle === 'string' || typeOfStyle === 'number' || typeOfStyle === 'function') {
    return style;
  }

  // Support array for FontFaceRule.
  if (isArray(style)) return style.map(cloneStyle);

  // Support Observable styles.  Observables are immutable, so we don't need to
  // copy them.
  if ((0, _isObservable2['default'])(style)) return style;

  var newStyle = {};
  for (var name in style) {
    var value = style[name];
    if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {
      newStyle[name] = cloneStyle(value);
      continue;
    }
    newStyle[name] = value;
  }

  return newStyle;
}
},{"./isObservable":383}],379:[function(require,module,exports){
(function (process){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _warning = require('warning');

var _warning2 = _interopRequireDefault(_warning);

var _StyleSheet = require('../StyleSheet');

var _StyleSheet2 = _interopRequireDefault(_StyleSheet);

var _moduleId = require('./moduleId');

var _moduleId2 = _interopRequireDefault(_moduleId);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var maxRules = 1e10;


var env = process.env.NODE_ENV;

/**
 * Returns a function which generates unique class names based on counters.
 * When new generator function is created, rule counter is reseted.
 * We need to reset the rule counter for SSR for each request.
 */

exports['default'] = function () {
  var ruleCounter = 0;
  var defaultPrefix = env === 'production' ? 'c' : '';

  return function (rule, sheet) {
    ruleCounter += 1;

    if (ruleCounter > maxRules) {
      (0, _warning2['default'])(false, '[JSS] You might have a memory leak. Rule counter is at %s.', ruleCounter);
    }

    var prefix = defaultPrefix;
    var jssId = '';

    if (sheet) {
      prefix = sheet.options.classNamePrefix || defaultPrefix;
      if (sheet.options.jss.id != null) jssId += sheet.options.jss.id;
    }

    if (env === 'production') {
      return '' + prefix + _moduleId2['default'] + jssId + ruleCounter;
    }

    return prefix + rule.key + '-' + _moduleId2['default'] + (jssId && '-' + jssId) + '-' + ruleCounter;
  };
};
}).call(this,require('_process'))

},{"../StyleSheet":364,"./moduleId":386,"_process":390,"warning":394}],380:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports['default'] = createRule;

var _warning = require('warning');

var _warning2 = _interopRequireDefault(_warning);

var _StyleRule = require('../rules/StyleRule');

var _StyleRule2 = _interopRequireDefault(_StyleRule);

var _cloneStyle = require('../utils/cloneStyle');

var _cloneStyle2 = _interopRequireDefault(_cloneStyle);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/**
 * Create a rule instance.
 */
function createRule() {
  var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'unnamed';
  var decl = arguments[1];
  var options = arguments[2];
  var jss = options.jss;

  var declCopy = (0, _cloneStyle2['default'])(decl);

  var rule = jss.plugins.onCreateRule(name, declCopy, options);
  if (rule) return rule;

  // It is an at-rule and it has no instance.
  if (name[0] === '@') {
    (0, _warning2['default'])(false, '[JSS] Unknown at-rule %s', name);
  }

  return new _StyleRule2['default'](name, declCopy, options);
}
},{"../rules/StyleRule":375,"../utils/cloneStyle":378,"warning":394}],381:[function(require,module,exports){
(function (process,global){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var CSS = global.CSS;

var env = process.env.NODE_ENV;

var escapeRegex = /([[\].#*$><+~=|^:(),"'`])/g;

exports['default'] = function (str) {
  // We don't need to escape it in production, because we are not using user's
  // input for selectors, we are generating a valid selector.
  if (env === 'production') return str;

  if (!CSS || !CSS.escape) {
    return str.replace(escapeRegex, '\\$1');
  }

  return CSS.escape(str);
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"_process":390}],382:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
 * Extracts a styles object with only props that contain function values.
 */
exports['default'] = function (styles) {
  // eslint-disable-next-line no-shadow
  function extract(styles) {
    var to = null;

    for (var key in styles) {
      var value = styles[key];
      var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);

      if (type === 'function') {
        if (!to) to = {};
        to[key] = value;
      } else if (type === 'object' && value !== null && !Array.isArray(value)) {
        var extracted = extract(value);
        if (extracted) {
          if (!to) to = {};
          to[key] = extracted;
        }
      }
    }

    return to;
  }

  return extract(styles);
};
},{}],383:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _symbolObservable = require('symbol-observable');

var _symbolObservable2 = _interopRequireDefault(_symbolObservable);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

exports['default'] = function (value) {
  return value && value[_symbolObservable2['default']] && value === value[_symbolObservable2['default']]();
};
},{"symbol-observable":391}],384:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var regExp = /([A-Z])/g;
var replace = function replace(str) {
  return "-" + str.toLowerCase();
};

exports["default"] = function (str) {
  return str.replace(regExp, replace);
};
},{}],385:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = linkRule;
/**
 * Link rule with CSSStyleRule and nested rules with corresponding nested cssRules if both exists.
 */
function linkRule(rule, cssRule) {
  rule.renderable = cssRule;
  if (rule.rules && cssRule.cssRules) rule.rules.link(cssRule.cssRules);
}
},{}],386:[function(require,module,exports){
(function (global){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var ns = '2f1acc6c3a606b082e5eef5e54414ffb';
if (global[ns] == null) global[ns] = 0;

// Bundle may contain multiple JSS versions at the same time. In order to identify
// the current version with just one short number and use it for classes generation
// we use a counter. Also it is more accurate, because user can manually reevaluate
// the module.
exports['default'] = global[ns]++;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],387:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports['default'] = toCss;

var _toCssValue = require('./toCssValue');

var _toCssValue2 = _interopRequireDefault(_toCssValue);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/**
 * Indent a string.
 * http://jsperf.com/array-join-vs-for
 */
function indentStr(str, indent) {
  var result = '';
  for (var index = 0; index < indent; index++) {
    result += '  ';
  }return result + str;
}

/**
 * Converts a Rule to CSS string.
 */

function toCss(selector, style) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  var result = '';

  if (!style) return result;

  var _options$indent = options.indent,
      indent = _options$indent === undefined ? 0 : _options$indent;
  var fallbacks = style.fallbacks;


  indent++;

  // Apply fallbacks first.
  if (fallbacks) {
    // Array syntax {fallbacks: [{prop: value}]}
    if (Array.isArray(fallbacks)) {
      for (var index = 0; index < fallbacks.length; index++) {
        var fallback = fallbacks[index];
        for (var prop in fallback) {
          var value = fallback[prop];
          if (value != null) {
            result += '\n' + indentStr(prop + ': ' + (0, _toCssValue2['default'])(value) + ';', indent);
          }
        }
      }
    }
    // Object syntax {fallbacks: {prop: value}}
    else {
        for (var _prop in fallbacks) {
          var _value = fallbacks[_prop];
          if (_value != null) {
            result += '\n' + indentStr(_prop + ': ' + (0, _toCssValue2['default'])(_value) + ';', indent);
          }
        }
      }
  }

  for (var _prop2 in style) {
    var _value2 = style[_prop2];
    if (_value2 != null && _prop2 !== 'fallbacks') {
      result += '\n' + indentStr(_prop2 + ': ' + (0, _toCssValue2['default'])(_value2) + ';', indent);
    }
  }

  // Allow empty style in this case, because properties will be added dynamically.
  if (!result && !options.allowEmpty) return result;

  indent--;
  result = indentStr(selector + ' {' + result + '\n', indent) + indentStr('}', indent);

  return result;
}
},{"./toCssValue":388}],388:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports['default'] = toCssValue;
var join = function join(value, by) {
  var result = '';
  for (var i = 0; i < value.length; i++) {
    // Remove !important from the value, it will be readded later.
    if (value[i] === '!important') break;
    if (result) result += by;
    result += value[i];
  }
  return result;
};

/**
 * Converts array values to string.
 *
 * `margin: [['5px', '10px']]` > `margin: 5px 10px;`
 * `border: ['1px', '2px']` > `border: 1px, 2px;`
 * `margin: [['5px', '10px'], '!important']` > `margin: 5px 10px !important;`
 * `color: ['red', !important]` > `color: red !important;`
 */
function toCssValue(value) {
  var ignoreImportant = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  if (!Array.isArray(value)) return value;

  var cssValue = '';

  // Support space separated values via `[['5px', '10px']]`.
  if (Array.isArray(value[0])) {
    for (var i = 0; i < value.length; i++) {
      if (value[i] === '!important') break;
      if (cssValue) cssValue += ', ';
      cssValue += join(value[i], ' ');
    }
  } else cssValue = join(value, ', ');

  // Add !important, because it was ignored.
  if (!ignoreImportant && value[value.length - 1] === '!important') {
    cssValue += ' !important';
  }

  return cssValue;
}
},{}],389:[function(require,module,exports){
//! moment.js
//! version : 2.20.1
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com

;(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    global.moment = factory()
}(this, (function () { 'use strict';

var hookCallback;

function hooks () {
    return hookCallback.apply(null, arguments);
}

// This is done to register the method called with moment()
// without creating circular dependencies.
function setHookCallback (callback) {
    hookCallback = callback;
}

function isArray(input) {
    return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
}

function isObject(input) {
    // IE8 will treat undefined and null as object if it wasn't for
    // input != null
    return input != null && Object.prototype.toString.call(input) === '[object Object]';
}

function isObjectEmpty(obj) {
    if (Object.getOwnPropertyNames) {
        return (Object.getOwnPropertyNames(obj).length === 0);
    } else {
        var k;
        for (k in obj) {
            if (obj.hasOwnProperty(k)) {
                return false;
            }
        }
        return true;
    }
}

function isUndefined(input) {
    return input === void 0;
}

function isNumber(input) {
    return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';
}

function isDate(input) {
    return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
}

function map(arr, fn) {
    var res = [], i;
    for (i = 0; i < arr.length; ++i) {
        res.push(fn(arr[i], i));
    }
    return res;
}

function hasOwnProp(a, b) {
    return Object.prototype.hasOwnProperty.call(a, b);
}

function extend(a, b) {
    for (var i in b) {
        if (hasOwnProp(b, i)) {
            a[i] = b[i];
        }
    }

    if (hasOwnProp(b, 'toString')) {
        a.toString = b.toString;
    }

    if (hasOwnProp(b, 'valueOf')) {
        a.valueOf = b.valueOf;
    }

    return a;
}

function createUTC (input, format, locale, strict) {
    return createLocalOrUTC(input, format, locale, strict, true).utc();
}

function defaultParsingFlags() {
    // We need to deep clone this object.
    return {
        empty           : false,
        unusedTokens    : [],
        unusedInput     : [],
        overflow        : -2,
        charsLeftOver   : 0,
        nullInput       : false,
        invalidMonth    : null,
        invalidFormat   : false,
        userInvalidated : false,
        iso             : false,
        parsedDateParts : [],
        meridiem        : null,
        rfc2822         : false,
        weekdayMismatch : false
    };
}

function getParsingFlags(m) {
    if (m._pf == null) {
        m._pf = defaultParsingFlags();
    }
    return m._pf;
}

var some;
if (Array.prototype.some) {
    some = Array.prototype.some;
} else {
    some = function (fun) {
        var t = Object(this);
        var len = t.length >>> 0;

        for (var i = 0; i < len; i++) {
            if (i in t && fun.call(this, t[i], i, t)) {
                return true;
            }
        }

        return false;
    };
}

function isValid(m) {
    if (m._isValid == null) {
        var flags = getParsingFlags(m);
        var parsedParts = some.call(flags.parsedDateParts, function (i) {
            return i != null;
        });
        var isNowValid = !isNaN(m._d.getTime()) &&
            flags.overflow < 0 &&
            !flags.empty &&
            !flags.invalidMonth &&
            !flags.invalidWeekday &&
            !flags.weekdayMismatch &&
            !flags.nullInput &&
            !flags.invalidFormat &&
            !flags.userInvalidated &&
            (!flags.meridiem || (flags.meridiem && parsedParts));

        if (m._strict) {
            isNowValid = isNowValid &&
                flags.charsLeftOver === 0 &&
                flags.unusedTokens.length === 0 &&
                flags.bigHour === undefined;
        }

        if (Object.isFrozen == null || !Object.isFrozen(m)) {
            m._isValid = isNowValid;
        }
        else {
            return isNowValid;
        }
    }
    return m._isValid;
}

function createInvalid (flags) {
    var m = createUTC(NaN);
    if (flags != null) {
        extend(getParsingFlags(m), flags);
    }
    else {
        getParsingFlags(m).userInvalidated = true;
    }

    return m;
}

// Plugins that add properties should also add the key here (null value),
// so we can properly clone ourselves.
var momentProperties = hooks.momentProperties = [];

function copyConfig(to, from) {
    var i, prop, val;

    if (!isUndefined(from._isAMomentObject)) {
        to._isAMomentObject = from._isAMomentObject;
    }
    if (!isUndefined(from._i)) {
        to._i = from._i;
    }
    if (!isUndefined(from._f)) {
        to._f = from._f;
    }
    if (!isUndefined(from._l)) {
        to._l = from._l;
    }
    if (!isUndefined(from._strict)) {
        to._strict = from._strict;
    }
    if (!isUndefined(from._tzm)) {
        to._tzm = from._tzm;
    }
    if (!isUndefined(from._isUTC)) {
        to._isUTC = from._isUTC;
    }
    if (!isUndefined(from._offset)) {
        to._offset = from._offset;
    }
    if (!isUndefined(from._pf)) {
        to._pf = getParsingFlags(from);
    }
    if (!isUndefined(from._locale)) {
        to._locale = from._locale;
    }

    if (momentProperties.length > 0) {
        for (i = 0; i < momentProperties.length; i++) {
            prop = momentProperties[i];
            val = from[prop];
            if (!isUndefined(val)) {
                to[prop] = val;
            }
        }
    }

    return to;
}

var updateInProgress = false;

// Moment prototype object
function Moment(config) {
    copyConfig(this, config);
    this._d = new Date(config._d != null ? config._d.getTime() : NaN);
    if (!this.isValid()) {
        this._d = new Date(NaN);
    }
    // Prevent infinite loop in case updateOffset creates new moment
    // objects.
    if (updateInProgress === false) {
        updateInProgress = true;
        hooks.updateOffset(this);
        updateInProgress = false;
    }
}

function isMoment (obj) {
    return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
}

function absFloor (number) {
    if (number < 0) {
        // -0 -> 0
        return Math.ceil(number) || 0;
    } else {
        return Math.floor(number);
    }
}

function toInt(argumentForCoercion) {
    var coercedNumber = +argumentForCoercion,
        value = 0;

    if (coercedNumber !== 0 && isFinite(coercedNumber)) {
        value = absFloor(coercedNumber);
    }

    return value;
}

// compare two arrays, return the number of differences
function compareArrays(array1, array2, dontConvert) {
    var len = Math.min(array1.length, array2.length),
        lengthDiff = Math.abs(array1.length - array2.length),
        diffs = 0,
        i;
    for (i = 0; i < len; i++) {
        if ((dontConvert && array1[i] !== array2[i]) ||
            (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
            diffs++;
        }
    }
    return diffs + lengthDiff;
}

function warn(msg) {
    if (hooks.suppressDeprecationWarnings === false &&
            (typeof console !==  'undefined') && console.warn) {
        console.warn('Deprecation warning: ' + msg);
    }
}

function deprecate(msg, fn) {
    var firstTime = true;

    return extend(function () {
        if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(null, msg);
        }
        if (firstTime) {
            var args = [];
            var arg;
            for (var i = 0; i < arguments.length; i++) {
                arg = '';
                if (typeof arguments[i] === 'object') {
                    arg += '\n[' + i + '] ';
                    for (var key in arguments[0]) {
                        arg += key + ': ' + arguments[0][key] + ', ';
                    }
                    arg = arg.slice(0, -2); // Remove trailing comma and space
                } else {
                    arg = arguments[i];
                }
                args.push(arg);
            }
            warn(msg + '\nArguments: ' + Array.prototype.slice.call(args).join('') + '\n' + (new Error()).stack);
            firstTime = false;
        }
        return fn.apply(this, arguments);
    }, fn);
}

var deprecations = {};

function deprecateSimple(name, msg) {
    if (hooks.deprecationHandler != null) {
        hooks.deprecationHandler(name, msg);
    }
    if (!deprecations[name]) {
        warn(msg);
        deprecations[name] = true;
    }
}

hooks.suppressDeprecationWarnings = false;
hooks.deprecationHandler = null;

function isFunction(input) {
    return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
}

function set (config) {
    var prop, i;
    for (i in config) {
        prop = config[i];
        if (isFunction(prop)) {
            this[i] = prop;
        } else {
            this['_' + i] = prop;
        }
    }
    this._config = config;
    // Lenient ordinal parsing accepts just a number in addition to
    // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
    // TODO: Remove "ordinalParse" fallback in next major release.
    this._dayOfMonthOrdinalParseLenient = new RegExp(
        (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +
            '|' + (/\d{1,2}/).source);
}

function mergeConfigs(parentConfig, childConfig) {
    var res = extend({}, parentConfig), prop;
    for (prop in childConfig) {
        if (hasOwnProp(childConfig, prop)) {
            if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
                res[prop] = {};
                extend(res[prop], parentConfig[prop]);
                extend(res[prop], childConfig[prop]);
            } else if (childConfig[prop] != null) {
                res[prop] = childConfig[prop];
            } else {
                delete res[prop];
            }
        }
    }
    for (prop in parentConfig) {
        if (hasOwnProp(parentConfig, prop) &&
                !hasOwnProp(childConfig, prop) &&
                isObject(parentConfig[prop])) {
            // make sure changes to properties don't modify parent config
            res[prop] = extend({}, res[prop]);
        }
    }
    return res;
}

function Locale(config) {
    if (config != null) {
        this.set(config);
    }
}

var keys;

if (Object.keys) {
    keys = Object.keys;
} else {
    keys = function (obj) {
        var i, res = [];
        for (i in obj) {
            if (hasOwnProp(obj, i)) {
                res.push(i);
            }
        }
        return res;
    };
}

var defaultCalendar = {
    sameDay : '[Today at] LT',
    nextDay : '[Tomorrow at] LT',
    nextWeek : 'dddd [at] LT',
    lastDay : '[Yesterday at] LT',
    lastWeek : '[Last] dddd [at] LT',
    sameElse : 'L'
};

function calendar (key, mom, now) {
    var output = this._calendar[key] || this._calendar['sameElse'];
    return isFunction(output) ? output.call(mom, now) : output;
}

var defaultLongDateFormat = {
    LTS  : 'h:mm:ss A',
    LT   : 'h:mm A',
    L    : 'MM/DD/YYYY',
    LL   : 'MMMM D, YYYY',
    LLL  : 'MMMM D, YYYY h:mm A',
    LLLL : 'dddd, MMMM D, YYYY h:mm A'
};

function longDateFormat (key) {
    var format = this._longDateFormat[key],
        formatUpper = this._longDateFormat[key.toUpperCase()];

    if (format || !formatUpper) {
        return format;
    }

    this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
        return val.slice(1);
    });

    return this._longDateFormat[key];
}

var defaultInvalidDate = 'Invalid date';

function invalidDate () {
    return this._invalidDate;
}

var defaultOrdinal = '%d';
var defaultDayOfMonthOrdinalParse = /\d{1,2}/;

function ordinal (number) {
    return this._ordinal.replace('%d', number);
}

var defaultRelativeTime = {
    future : 'in %s',
    past   : '%s ago',
    s  : 'a few seconds',
    ss : '%d seconds',
    m  : 'a minute',
    mm : '%d minutes',
    h  : 'an hour',
    hh : '%d hours',
    d  : 'a day',
    dd : '%d days',
    M  : 'a month',
    MM : '%d months',
    y  : 'a year',
    yy : '%d years'
};

function relativeTime (number, withoutSuffix, string, isFuture) {
    var output = this._relativeTime[string];
    return (isFunction(output)) ?
        output(number, withoutSuffix, string, isFuture) :
        output.replace(/%d/i, number);
}

function pastFuture (diff, output) {
    var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
    return isFunction(format) ? format(output) : format.replace(/%s/i, output);
}

var aliases = {};

function addUnitAlias (unit, shorthand) {
    var lowerCase = unit.toLowerCase();
    aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
}

function normalizeUnits(units) {
    return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
}

function normalizeObjectUnits(inputObject) {
    var normalizedInput = {},
        normalizedProp,
        prop;

    for (prop in inputObject) {
        if (hasOwnProp(inputObject, prop)) {
            normalizedProp = normalizeUnits(prop);
            if (normalizedProp) {
                normalizedInput[normalizedProp] = inputObject[prop];
            }
        }
    }

    return normalizedInput;
}

var priorities = {};

function addUnitPriority(unit, priority) {
    priorities[unit] = priority;
}

function getPrioritizedUnits(unitsObj) {
    var units = [];
    for (var u in unitsObj) {
        units.push({unit: u, priority: priorities[u]});
    }
    units.sort(function (a, b) {
        return a.priority - b.priority;
    });
    return units;
}

function zeroFill(number, targetLength, forceSign) {
    var absNumber = '' + Math.abs(number),
        zerosToFill = targetLength - absNumber.length,
        sign = number >= 0;
    return (sign ? (forceSign ? '+' : '') : '-') +
        Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
}

var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;

var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;

var formatFunctions = {};

var formatTokenFunctions = {};

// token:    'M'
// padded:   ['MM', 2]
// ordinal:  'Mo'
// callback: function () { this.month() + 1 }
function addFormatToken (token, padded, ordinal, callback) {
    var func = callback;
    if (typeof callback === 'string') {
        func = function () {
            return this[callback]();
        };
    }
    if (token) {
        formatTokenFunctions[token] = func;
    }
    if (padded) {
        formatTokenFunctions[padded[0]] = function () {
            return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
        };
    }
    if (ordinal) {
        formatTokenFunctions[ordinal] = function () {
            return this.localeData().ordinal(func.apply(this, arguments), token);
        };
    }
}

function removeFormattingTokens(input) {
    if (input.match(/\[[\s\S]/)) {
        return input.replace(/^\[|\]$/g, '');
    }
    return input.replace(/\\/g, '');
}

function makeFormatFunction(format) {
    var array = format.match(formattingTokens), i, length;

    for (i = 0, length = array.length; i < length; i++) {
        if (formatTokenFunctions[array[i]]) {
            array[i] = formatTokenFunctions[array[i]];
        } else {
            array[i] = removeFormattingTokens(array[i]);
        }
    }

    return function (mom) {
        var output = '', i;
        for (i = 0; i < length; i++) {
            output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];
        }
        return output;
    };
}

// format date using native date object
function formatMoment(m, format) {
    if (!m.isValid()) {
        return m.localeData().invalidDate();
    }

    format = expandFormat(format, m.localeData());
    formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);

    return formatFunctions[format](m);
}

function expandFormat(format, locale) {
    var i = 5;

    function replaceLongDateFormatTokens(input) {
        return locale.longDateFormat(input) || input;
    }

    localFormattingTokens.lastIndex = 0;
    while (i >= 0 && localFormattingTokens.test(format)) {
        format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
        localFormattingTokens.lastIndex = 0;
        i -= 1;
    }

    return format;
}

var match1         = /\d/;            //       0 - 9
var match2         = /\d\d/;          //      00 - 99
var match3         = /\d{3}/;         //     000 - 999
var match4         = /\d{4}/;         //    0000 - 9999
var match6         = /[+-]?\d{6}/;    // -999999 - 999999
var match1to2      = /\d\d?/;         //       0 - 99
var match3to4      = /\d\d\d\d?/;     //     999 - 9999
var match5to6      = /\d\d\d\d\d\d?/; //   99999 - 999999
var match1to3      = /\d{1,3}/;       //       0 - 999
var match1to4      = /\d{1,4}/;       //       0 - 9999
var match1to6      = /[+-]?\d{1,6}/;  // -999999 - 999999

var matchUnsigned  = /\d+/;           //       0 - inf
var matchSigned    = /[+-]?\d+/;      //    -inf - inf

var matchOffset    = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z
var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z

var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123

// any word (or two) characters or numbers including two/three word month in arabic.
// includes scottish gaelic two word and hyphenated months
var matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i;


var regexes = {};

function addRegexToken (token, regex, strictRegex) {
    regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
        return (isStrict && strictRegex) ? strictRegex : regex;
    };
}

function getParseRegexForToken (token, config) {
    if (!hasOwnProp(regexes, token)) {
        return new RegExp(unescapeFormat(token));
    }

    return regexes[token](config._strict, config._locale);
}

// Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
function unescapeFormat(s) {
    return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
        return p1 || p2 || p3 || p4;
    }));
}

function regexEscape(s) {
    return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
}

var tokens = {};

function addParseToken (token, callback) {
    var i, func = callback;
    if (typeof token === 'string') {
        token = [token];
    }
    if (isNumber(callback)) {
        func = function (input, array) {
            array[callback] = toInt(input);
        };
    }
    for (i = 0; i < token.length; i++) {
        tokens[token[i]] = func;
    }
}

function addWeekParseToken (token, callback) {
    addParseToken(token, function (input, array, config, token) {
        config._w = config._w || {};
        callback(input, config._w, config, token);
    });
}

function addTimeToArrayFromToken(token, input, config) {
    if (input != null && hasOwnProp(tokens, token)) {
        tokens[token](input, config._a, config, token);
    }
}

var YEAR = 0;
var MONTH = 1;
var DATE = 2;
var HOUR = 3;
var MINUTE = 4;
var SECOND = 5;
var MILLISECOND = 6;
var WEEK = 7;
var WEEKDAY = 8;

// FORMATTING

addFormatToken('Y', 0, 0, function () {
    var y = this.year();
    return y <= 9999 ? '' + y : '+' + y;
});

addFormatToken(0, ['YY', 2], 0, function () {
    return this.year() % 100;
});

addFormatToken(0, ['YYYY',   4],       0, 'year');
addFormatToken(0, ['YYYYY',  5],       0, 'year');
addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

// ALIASES

addUnitAlias('year', 'y');

// PRIORITIES

addUnitPriority('year', 1);

// PARSING

addRegexToken('Y',      matchSigned);
addRegexToken('YY',     match1to2, match2);
addRegexToken('YYYY',   match1to4, match4);
addRegexToken('YYYYY',  match1to6, match6);
addRegexToken('YYYYYY', match1to6, match6);

addParseToken(['YYYYY', 'YYYYYY'], YEAR);
addParseToken('YYYY', function (input, array) {
    array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
});
addParseToken('YY', function (input, array) {
    array[YEAR] = hooks.parseTwoDigitYear(input);
});
addParseToken('Y', function (input, array) {
    array[YEAR] = parseInt(input, 10);
});

// HELPERS

function daysInYear(year) {
    return isLeapYear(year) ? 366 : 365;
}

function isLeapYear(year) {
    return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
}

// HOOKS

hooks.parseTwoDigitYear = function (input) {
    return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
};

// MOMENTS

var getSetYear = makeGetSet('FullYear', true);

function getIsLeapYear () {
    return isLeapYear(this.year());
}

function makeGetSet (unit, keepTime) {
    return function (value) {
        if (value != null) {
            set$1(this, unit, value);
            hooks.updateOffset(this, keepTime);
            return this;
        } else {
            return get(this, unit);
        }
    };
}

function get (mom, unit) {
    return mom.isValid() ?
        mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
}

function set$1 (mom, unit, value) {
    if (mom.isValid() && !isNaN(value)) {
        if (unit === 'FullYear' && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
            mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value, mom.month(), daysInMonth(value, mom.month()));
        }
        else {
            mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
        }
    }
}

// MOMENTS

function stringGet (units) {
    units = normalizeUnits(units);
    if (isFunction(this[units])) {
        return this[units]();
    }
    return this;
}


function stringSet (units, value) {
    if (typeof units === 'object') {
        units = normalizeObjectUnits(units);
        var prioritized = getPrioritizedUnits(units);
        for (var i = 0; i < prioritized.length; i++) {
            this[prioritized[i].unit](units[prioritized[i].unit]);
        }
    } else {
        units = normalizeUnits(units);
        if (isFunction(this[units])) {
            return this[units](value);
        }
    }
    return this;
}

function mod(n, x) {
    return ((n % x) + x) % x;
}

var indexOf;

if (Array.prototype.indexOf) {
    indexOf = Array.prototype.indexOf;
} else {
    indexOf = function (o) {
        // I know
        var i;
        for (i = 0; i < this.length; ++i) {
            if (this[i] === o) {
                return i;
            }
        }
        return -1;
    };
}

function daysInMonth(year, month) {
    if (isNaN(year) || isNaN(month)) {
        return NaN;
    }
    var modMonth = mod(month, 12);
    year += (month - modMonth) / 12;
    return modMonth === 1 ? (isLeapYear(year) ? 29 : 28) : (31 - modMonth % 7 % 2);
}

// FORMATTING

addFormatToken('M', ['MM', 2], 'Mo', function () {
    return this.month() + 1;
});

addFormatToken('MMM', 0, 0, function (format) {
    return this.localeData().monthsShort(this, format);
});

addFormatToken('MMMM', 0, 0, function (format) {
    return this.localeData().months(this, format);
});

// ALIASES

addUnitAlias('month', 'M');

// PRIORITY

addUnitPriority('month', 8);

// PARSING

addRegexToken('M',    match1to2);
addRegexToken('MM',   match1to2, match2);
addRegexToken('MMM',  function (isStrict, locale) {
    return locale.monthsShortRegex(isStrict);
});
addRegexToken('MMMM', function (isStrict, locale) {
    return locale.monthsRegex(isStrict);
});

addParseToken(['M', 'MM'], function (input, array) {
    array[MONTH] = toInt(input) - 1;
});

addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
    var month = config._locale.monthsParse(input, token, config._strict);
    // if we didn't find a month name, mark the date as invalid.
    if (month != null) {
        array[MONTH] = month;
    } else {
        getParsingFlags(config).invalidMonth = input;
    }
});

// LOCALES

var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
function localeMonths (m, format) {
    if (!m) {
        return isArray(this._months) ? this._months :
            this._months['standalone'];
    }
    return isArray(this._months) ? this._months[m.month()] :
        this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
}

var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
function localeMonthsShort (m, format) {
    if (!m) {
        return isArray(this._monthsShort) ? this._monthsShort :
            this._monthsShort['standalone'];
    }
    return isArray(this._monthsShort) ? this._monthsShort[m.month()] :
        this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
}

function handleStrictParse(monthName, format, strict) {
    var i, ii, mom, llc = monthName.toLocaleLowerCase();
    if (!this._monthsParse) {
        // this is not used
        this._monthsParse = [];
        this._longMonthsParse = [];
        this._shortMonthsParse = [];
        for (i = 0; i < 12; ++i) {
            mom = createUTC([2000, i]);
            this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
            this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
        }
    }

    if (strict) {
        if (format === 'MMM') {
            ii = indexOf.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
        } else {
            ii = indexOf.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
        }
    } else {
        if (format === 'MMM') {
            ii = indexOf.call(this._shortMonthsParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
        } else {
            ii = indexOf.call(this._longMonthsParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
        }
    }
}

function localeMonthsParse (monthName, format, strict) {
    var i, mom, regex;

    if (this._monthsParseExact) {
        return handleStrictParse.call(this, monthName, format, strict);
    }

    if (!this._monthsParse) {
        this._monthsParse = [];
        this._longMonthsParse = [];
        this._shortMonthsParse = [];
    }

    // TODO: add sorting
    // Sorting makes sure if one month (or abbr) is a prefix of another
    // see sorting in computeMonthsParse
    for (i = 0; i < 12; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, i]);
        if (strict && !this._longMonthsParse[i]) {
            this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
            this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
        }
        if (!strict && !this._monthsParse[i]) {
            regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
            this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
        }
        // test the regex
        if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
            return i;
        } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
            return i;
        } else if (!strict && this._monthsParse[i].test(monthName)) {
            return i;
        }
    }
}

// MOMENTS

function setMonth (mom, value) {
    var dayOfMonth;

    if (!mom.isValid()) {
        // No op
        return mom;
    }

    if (typeof value === 'string') {
        if (/^\d+$/.test(value)) {
            value = toInt(value);
        } else {
            value = mom.localeData().monthsParse(value);
            // TODO: Another silent failure?
            if (!isNumber(value)) {
                return mom;
            }
        }
    }

    dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
    mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
    return mom;
}

function getSetMonth (value) {
    if (value != null) {
        setMonth(this, value);
        hooks.updateOffset(this, true);
        return this;
    } else {
        return get(this, 'Month');
    }
}

function getDaysInMonth () {
    return daysInMonth(this.year(), this.month());
}

var defaultMonthsShortRegex = matchWord;
function monthsShortRegex (isStrict) {
    if (this._monthsParseExact) {
        if (!hasOwnProp(this, '_monthsRegex')) {
            computeMonthsParse.call(this);
        }
        if (isStrict) {
            return this._monthsShortStrictRegex;
        } else {
            return this._monthsShortRegex;
        }
    } else {
        if (!hasOwnProp(this, '_monthsShortRegex')) {
            this._monthsShortRegex = defaultMonthsShortRegex;
        }
        return this._monthsShortStrictRegex && isStrict ?
            this._monthsShortStrictRegex : this._monthsShortRegex;
    }
}

var defaultMonthsRegex = matchWord;
function monthsRegex (isStrict) {
    if (this._monthsParseExact) {
        if (!hasOwnProp(this, '_monthsRegex')) {
            computeMonthsParse.call(this);
        }
        if (isStrict) {
            return this._monthsStrictRegex;
        } else {
            return this._monthsRegex;
        }
    } else {
        if (!hasOwnProp(this, '_monthsRegex')) {
            this._monthsRegex = defaultMonthsRegex;
        }
        return this._monthsStrictRegex && isStrict ?
            this._monthsStrictRegex : this._monthsRegex;
    }
}

function computeMonthsParse () {
    function cmpLenRev(a, b) {
        return b.length - a.length;
    }

    var shortPieces = [], longPieces = [], mixedPieces = [],
        i, mom;
    for (i = 0; i < 12; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, i]);
        shortPieces.push(this.monthsShort(mom, ''));
        longPieces.push(this.months(mom, ''));
        mixedPieces.push(this.months(mom, ''));
        mixedPieces.push(this.monthsShort(mom, ''));
    }
    // Sorting makes sure if one month (or abbr) is a prefix of another it
    // will match the longer piece.
    shortPieces.sort(cmpLenRev);
    longPieces.sort(cmpLenRev);
    mixedPieces.sort(cmpLenRev);
    for (i = 0; i < 12; i++) {
        shortPieces[i] = regexEscape(shortPieces[i]);
        longPieces[i] = regexEscape(longPieces[i]);
    }
    for (i = 0; i < 24; i++) {
        mixedPieces[i] = regexEscape(mixedPieces[i]);
    }

    this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
    this._monthsShortRegex = this._monthsRegex;
    this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
    this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
}

function createDate (y, m, d, h, M, s, ms) {
    // can't just apply() to create a date:
    // https://stackoverflow.com/q/181348
    var date = new Date(y, m, d, h, M, s, ms);

    // the date constructor remaps years 0-99 to 1900-1999
    if (y < 100 && y >= 0 && isFinite(date.getFullYear())) {
        date.setFullYear(y);
    }
    return date;
}

function createUTCDate (y) {
    var date = new Date(Date.UTC.apply(null, arguments));

    // the Date.UTC function remaps years 0-99 to 1900-1999
    if (y < 100 && y >= 0 && isFinite(date.getUTCFullYear())) {
        date.setUTCFullYear(y);
    }
    return date;
}

// start-of-first-week - start-of-year
function firstWeekOffset(year, dow, doy) {
    var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
        fwd = 7 + dow - doy,
        // first-week day local weekday -- which local weekday is fwd
        fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

    return -fwdlw + fwd - 1;
}

// https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
    var localWeekday = (7 + weekday - dow) % 7,
        weekOffset = firstWeekOffset(year, dow, doy),
        dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
        resYear, resDayOfYear;

    if (dayOfYear <= 0) {
        resYear = year - 1;
        resDayOfYear = daysInYear(resYear) + dayOfYear;
    } else if (dayOfYear > daysInYear(year)) {
        resYear = year + 1;
        resDayOfYear = dayOfYear - daysInYear(year);
    } else {
        resYear = year;
        resDayOfYear = dayOfYear;
    }

    return {
        year: resYear,
        dayOfYear: resDayOfYear
    };
}

function weekOfYear(mom, dow, doy) {
    var weekOffset = firstWeekOffset(mom.year(), dow, doy),
        week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
        resWeek, resYear;

    if (week < 1) {
        resYear = mom.year() - 1;
        resWeek = week + weeksInYear(resYear, dow, doy);
    } else if (week > weeksInYear(mom.year(), dow, doy)) {
        resWeek = week - weeksInYear(mom.year(), dow, doy);
        resYear = mom.year() + 1;
    } else {
        resYear = mom.year();
        resWeek = week;
    }

    return {
        week: resWeek,
        year: resYear
    };
}

function weeksInYear(year, dow, doy) {
    var weekOffset = firstWeekOffset(year, dow, doy),
        weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
    return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
}

// FORMATTING

addFormatToken('w', ['ww', 2], 'wo', 'week');
addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

// ALIASES

addUnitAlias('week', 'w');
addUnitAlias('isoWeek', 'W');

// PRIORITIES

addUnitPriority('week', 5);
addUnitPriority('isoWeek', 5);

// PARSING

addRegexToken('w',  match1to2);
addRegexToken('ww', match1to2, match2);
addRegexToken('W',  match1to2);
addRegexToken('WW', match1to2, match2);

addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
    week[token.substr(0, 1)] = toInt(input);
});

// HELPERS

// LOCALES

function localeWeek (mom) {
    return weekOfYear(mom, this._week.dow, this._week.doy).week;
}

var defaultLocaleWeek = {
    dow : 0, // Sunday is the first day of the week.
    doy : 6  // The week that contains Jan 1st is the first week of the year.
};

function localeFirstDayOfWeek () {
    return this._week.dow;
}

function localeFirstDayOfYear () {
    return this._week.doy;
}

// MOMENTS

function getSetWeek (input) {
    var week = this.localeData().week(this);
    return input == null ? week : this.add((input - week) * 7, 'd');
}

function getSetISOWeek (input) {
    var week = weekOfYear(this, 1, 4).week;
    return input == null ? week : this.add((input - week) * 7, 'd');
}

// FORMATTING

addFormatToken('d', 0, 'do', 'day');

addFormatToken('dd', 0, 0, function (format) {
    return this.localeData().weekdaysMin(this, format);
});

addFormatToken('ddd', 0, 0, function (format) {
    return this.localeData().weekdaysShort(this, format);
});

addFormatToken('dddd', 0, 0, function (format) {
    return this.localeData().weekdays(this, format);
});

addFormatToken('e', 0, 0, 'weekday');
addFormatToken('E', 0, 0, 'isoWeekday');

// ALIASES

addUnitAlias('day', 'd');
addUnitAlias('weekday', 'e');
addUnitAlias('isoWeekday', 'E');

// PRIORITY
addUnitPriority('day', 11);
addUnitPriority('weekday', 11);
addUnitPriority('isoWeekday', 11);

// PARSING

addRegexToken('d',    match1to2);
addRegexToken('e',    match1to2);
addRegexToken('E',    match1to2);
addRegexToken('dd',   function (isStrict, locale) {
    return locale.weekdaysMinRegex(isStrict);
});
addRegexToken('ddd',   function (isStrict, locale) {
    return locale.weekdaysShortRegex(isStrict);
});
addRegexToken('dddd',   function (isStrict, locale) {
    return locale.weekdaysRegex(isStrict);
});

addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
    var weekday = config._locale.weekdaysParse(input, token, config._strict);
    // if we didn't get a weekday name, mark the date as invalid
    if (weekday != null) {
        week.d = weekday;
    } else {
        getParsingFlags(config).invalidWeekday = input;
    }
});

addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
    week[token] = toInt(input);
});

// HELPERS

function parseWeekday(input, locale) {
    if (typeof input !== 'string') {
        return input;
    }

    if (!isNaN(input)) {
        return parseInt(input, 10);
    }

    input = locale.weekdaysParse(input);
    if (typeof input === 'number') {
        return input;
    }

    return null;
}

function parseIsoWeekday(input, locale) {
    if (typeof input === 'string') {
        return locale.weekdaysParse(input) % 7 || 7;
    }
    return isNaN(input) ? null : input;
}

// LOCALES

var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
function localeWeekdays (m, format) {
    if (!m) {
        return isArray(this._weekdays) ? this._weekdays :
            this._weekdays['standalone'];
    }
    return isArray(this._weekdays) ? this._weekdays[m.day()] :
        this._weekdays[this._weekdays.isFormat.test(format) ? 'format' : 'standalone'][m.day()];
}

var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
function localeWeekdaysShort (m) {
    return (m) ? this._weekdaysShort[m.day()] : this._weekdaysShort;
}

var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
function localeWeekdaysMin (m) {
    return (m) ? this._weekdaysMin[m.day()] : this._weekdaysMin;
}

function handleStrictParse$1(weekdayName, format, strict) {
    var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
    if (!this._weekdaysParse) {
        this._weekdaysParse = [];
        this._shortWeekdaysParse = [];
        this._minWeekdaysParse = [];

        for (i = 0; i < 7; ++i) {
            mom = createUTC([2000, 1]).day(i);
            this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
            this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
            this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
        }
    }

    if (strict) {
        if (format === 'dddd') {
            ii = indexOf.call(this._weekdaysParse, llc);
            return ii !== -1 ? ii : null;
        } else if (format === 'ddd') {
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        } else {
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        }
    } else {
        if (format === 'dddd') {
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        } else if (format === 'ddd') {
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        } else {
            ii = indexOf.call(this._minWeekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        }
    }
}

function localeWeekdaysParse (weekdayName, format, strict) {
    var i, mom, regex;

    if (this._weekdaysParseExact) {
        return handleStrictParse$1.call(this, weekdayName, format, strict);
    }

    if (!this._weekdaysParse) {
        this._weekdaysParse = [];
        this._minWeekdaysParse = [];
        this._shortWeekdaysParse = [];
        this._fullWeekdaysParse = [];
    }

    for (i = 0; i < 7; i++) {
        // make the regex if we don't have it already

        mom = createUTC([2000, 1]).day(i);
        if (strict && !this._fullWeekdaysParse[i]) {
            this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\.?') + '$', 'i');
            this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\.?') + '$', 'i');
            this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\.?') + '$', 'i');
        }
        if (!this._weekdaysParse[i]) {
            regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
            this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
        }
        // test the regex
        if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
            return i;
        } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
            return i;
        } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
            return i;
        } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
            return i;
        }
    }
}

// MOMENTS

function getSetDayOfWeek (input) {
    if (!this.isValid()) {
        return input != null ? this : NaN;
    }
    var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
    if (input != null) {
        input = parseWeekday(input, this.localeData());
        return this.add(input - day, 'd');
    } else {
        return day;
    }
}

function getSetLocaleDayOfWeek (input) {
    if (!this.isValid()) {
        return input != null ? this : NaN;
    }
    var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
    return input == null ? weekday : this.add(input - weekday, 'd');
}

function getSetISODayOfWeek (input) {
    if (!this.isValid()) {
        return input != null ? this : NaN;
    }

    // behaves the same as moment#day except
    // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
    // as a setter, sunday should belong to the previous week.

    if (input != null) {
        var weekday = parseIsoWeekday(input, this.localeData());
        return this.day(this.day() % 7 ? weekday : weekday - 7);
    } else {
        return this.day() || 7;
    }
}

var defaultWeekdaysRegex = matchWord;
function weekdaysRegex (isStrict) {
    if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
            computeWeekdaysParse.call(this);
        }
        if (isStrict) {
            return this._weekdaysStrictRegex;
        } else {
            return this._weekdaysRegex;
        }
    } else {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
            this._weekdaysRegex = defaultWeekdaysRegex;
        }
        return this._weekdaysStrictRegex && isStrict ?
            this._weekdaysStrictRegex : this._weekdaysRegex;
    }
}

var defaultWeekdaysShortRegex = matchWord;
function weekdaysShortRegex (isStrict) {
    if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
            computeWeekdaysParse.call(this);
        }
        if (isStrict) {
            return this._weekdaysShortStrictRegex;
        } else {
            return this._weekdaysShortRegex;
        }
    } else {
        if (!hasOwnProp(this, '_weekdaysShortRegex')) {
            this._weekdaysShortRegex = defaultWeekdaysShortRegex;
        }
        return this._weekdaysShortStrictRegex && isStrict ?
            this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
    }
}

var defaultWeekdaysMinRegex = matchWord;
function weekdaysMinRegex (isStrict) {
    if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
            computeWeekdaysParse.call(this);
        }
        if (isStrict) {
            return this._weekdaysMinStrictRegex;
        } else {
            return this._weekdaysMinRegex;
        }
    } else {
        if (!hasOwnProp(this, '_weekdaysMinRegex')) {
            this._weekdaysMinRegex = defaultWeekdaysMinRegex;
        }
        return this._weekdaysMinStrictRegex && isStrict ?
            this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
    }
}


function computeWeekdaysParse () {
    function cmpLenRev(a, b) {
        return b.length - a.length;
    }

    var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [],
        i, mom, minp, shortp, longp;
    for (i = 0; i < 7; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, 1]).day(i);
        minp = this.weekdaysMin(mom, '');
        shortp = this.weekdaysShort(mom, '');
        longp = this.weekdays(mom, '');
        minPieces.push(minp);
        shortPieces.push(shortp);
        longPieces.push(longp);
        mixedPieces.push(minp);
        mixedPieces.push(shortp);
        mixedPieces.push(longp);
    }
    // Sorting makes sure if one weekday (or abbr) is a prefix of another it
    // will match the longer piece.
    minPieces.sort(cmpLenRev);
    shortPieces.sort(cmpLenRev);
    longPieces.sort(cmpLenRev);
    mixedPieces.sort(cmpLenRev);
    for (i = 0; i < 7; i++) {
        shortPieces[i] = regexEscape(shortPieces[i]);
        longPieces[i] = regexEscape(longPieces[i]);
        mixedPieces[i] = regexEscape(mixedPieces[i]);
    }

    this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
    this._weekdaysShortRegex = this._weekdaysRegex;
    this._weekdaysMinRegex = this._weekdaysRegex;

    this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
    this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
    this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
}

// FORMATTING

function hFormat() {
    return this.hours() % 12 || 12;
}

function kFormat() {
    return this.hours() || 24;
}

addFormatToken('H', ['HH', 2], 0, 'hour');
addFormatToken('h', ['hh', 2], 0, hFormat);
addFormatToken('k', ['kk', 2], 0, kFormat);

addFormatToken('hmm', 0, 0, function () {
    return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
});

addFormatToken('hmmss', 0, 0, function () {
    return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) +
        zeroFill(this.seconds(), 2);
});

addFormatToken('Hmm', 0, 0, function () {
    return '' + this.hours() + zeroFill(this.minutes(), 2);
});

addFormatToken('Hmmss', 0, 0, function () {
    return '' + this.hours() + zeroFill(this.minutes(), 2) +
        zeroFill(this.seconds(), 2);
});

function meridiem (token, lowercase) {
    addFormatToken(token, 0, 0, function () {
        return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
    });
}

meridiem('a', true);
meridiem('A', false);

// ALIASES

addUnitAlias('hour', 'h');

// PRIORITY
addUnitPriority('hour', 13);

// PARSING

function matchMeridiem (isStrict, locale) {
    return locale._meridiemParse;
}

addRegexToken('a',  matchMeridiem);
addRegexToken('A',  matchMeridiem);
addRegexToken('H',  match1to2);
addRegexToken('h',  match1to2);
addRegexToken('k',  match1to2);
addRegexToken('HH', match1to2, match2);
addRegexToken('hh', match1to2, match2);
addRegexToken('kk', match1to2, match2);

addRegexToken('hmm', match3to4);
addRegexToken('hmmss', match5to6);
addRegexToken('Hmm', match3to4);
addRegexToken('Hmmss', match5to6);

addParseToken(['H', 'HH'], HOUR);
addParseToken(['k', 'kk'], function (input, array, config) {
    var kInput = toInt(input);
    array[HOUR] = kInput === 24 ? 0 : kInput;
});
addParseToken(['a', 'A'], function (input, array, config) {
    config._isPm = config._locale.isPM(input);
    config._meridiem = input;
});
addParseToken(['h', 'hh'], function (input, array, config) {
    array[HOUR] = toInt(input);
    getParsingFlags(config).bigHour = true;
});
addParseToken('hmm', function (input, array, config) {
    var pos = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos));
    array[MINUTE] = toInt(input.substr(pos));
    getParsingFlags(config).bigHour = true;
});
addParseToken('hmmss', function (input, array, config) {
    var pos1 = input.length - 4;
    var pos2 = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos1));
    array[MINUTE] = toInt(input.substr(pos1, 2));
    array[SECOND] = toInt(input.substr(pos2));
    getParsingFlags(config).bigHour = true;
});
addParseToken('Hmm', function (input, array, config) {
    var pos = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos));
    array[MINUTE] = toInt(input.substr(pos));
});
addParseToken('Hmmss', function (input, array, config) {
    var pos1 = input.length - 4;
    var pos2 = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos1));
    array[MINUTE] = toInt(input.substr(pos1, 2));
    array[SECOND] = toInt(input.substr(pos2));
});

// LOCALES

function localeIsPM (input) {
    // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
    // Using charAt should be more compatible.
    return ((input + '').toLowerCase().charAt(0) === 'p');
}

var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
function localeMeridiem (hours, minutes, isLower) {
    if (hours > 11) {
        return isLower ? 'pm' : 'PM';
    } else {
        return isLower ? 'am' : 'AM';
    }
}


// MOMENTS

// Setting the hour should keep the time, because the user explicitly
// specified which hour he wants. So trying to maintain the same hour (in
// a new timezone) makes sense. Adding/subtracting hours does not follow
// this rule.
var getSetHour = makeGetSet('Hours', true);

// months
// week
// weekdays
// meridiem
var baseConfig = {
    calendar: defaultCalendar,
    longDateFormat: defaultLongDateFormat,
    invalidDate: defaultInvalidDate,
    ordinal: defaultOrdinal,
    dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
    relativeTime: defaultRelativeTime,

    months: defaultLocaleMonths,
    monthsShort: defaultLocaleMonthsShort,

    week: defaultLocaleWeek,

    weekdays: defaultLocaleWeekdays,
    weekdaysMin: defaultLocaleWeekdaysMin,
    weekdaysShort: defaultLocaleWeekdaysShort,

    meridiemParse: defaultLocaleMeridiemParse
};

// internal storage for locale config files
var locales = {};
var localeFamilies = {};
var globalLocale;

function normalizeLocale(key) {
    return key ? key.toLowerCase().replace('_', '-') : key;
}

// pick the locale from the array
// try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
// substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
function chooseLocale(names) {
    var i = 0, j, next, locale, split;

    while (i < names.length) {
        split = normalizeLocale(names[i]).split('-');
        j = split.length;
        next = normalizeLocale(names[i + 1]);
        next = next ? next.split('-') : null;
        while (j > 0) {
            locale = loadLocale(split.slice(0, j).join('-'));
            if (locale) {
                return locale;
            }
            if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                //the next array item is better than a shallower substring of this one
                break;
            }
            j--;
        }
        i++;
    }
    return null;
}

function loadLocale(name) {
    var oldLocale = null;
    // TODO: Find a better way to register and load all the locales in Node
    if (!locales[name] && (typeof module !== 'undefined') &&
            module && module.exports) {
        try {
            oldLocale = globalLocale._abbr;
            var aliasedRequire = require;
            aliasedRequire('./locale/' + name);
            getSetGlobalLocale(oldLocale);
        } catch (e) {}
    }
    return locales[name];
}

// This function will load locale and then set the global locale.  If
// no arguments are passed in, it will simply return the current global
// locale key.
function getSetGlobalLocale (key, values) {
    var data;
    if (key) {
        if (isUndefined(values)) {
            data = getLocale(key);
        }
        else {
            data = defineLocale(key, values);
        }

        if (data) {
            // moment.duration._locale = moment._locale = data;
            globalLocale = data;
        }
    }

    return globalLocale._abbr;
}

function defineLocale (name, config) {
    if (config !== null) {
        var parentConfig = baseConfig;
        config.abbr = name;
        if (locales[name] != null) {
            deprecateSimple('defineLocaleOverride',
                    'use moment.updateLocale(localeName, config) to change ' +
                    'an existing locale. moment.defineLocale(localeName, ' +
                    'config) should only be used for creating a new locale ' +
                    'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');
            parentConfig = locales[name]._config;
        } else if (config.parentLocale != null) {
            if (locales[config.parentLocale] != null) {
                parentConfig = locales[config.parentLocale]._config;
            } else {
                if (!localeFamilies[config.parentLocale]) {
                    localeFamilies[config.parentLocale] = [];
                }
                localeFamilies[config.parentLocale].push({
                    name: name,
                    config: config
                });
                return null;
            }
        }
        locales[name] = new Locale(mergeConfigs(parentConfig, config));

        if (localeFamilies[name]) {
            localeFamilies[name].forEach(function (x) {
                defineLocale(x.name, x.config);
            });
        }

        // backwards compat for now: also set the locale
        // make sure we set the locale AFTER all child locales have been
        // created, so we won't end up with the child locale set.
        getSetGlobalLocale(name);


        return locales[name];
    } else {
        // useful for testing
        delete locales[name];
        return null;
    }
}

function updateLocale(name, config) {
    if (config != null) {
        var locale, tmpLocale, parentConfig = baseConfig;
        // MERGE
        tmpLocale = loadLocale(name);
        if (tmpLocale != null) {
            parentConfig = tmpLocale._config;
        }
        config = mergeConfigs(parentConfig, config);
        locale = new Locale(config);
        locale.parentLocale = locales[name];
        locales[name] = locale;

        // backwards compat for now: also set the locale
        getSetGlobalLocale(name);
    } else {
        // pass null for config to unupdate, useful for tests
        if (locales[name] != null) {
            if (locales[name].parentLocale != null) {
                locales[name] = locales[name].parentLocale;
            } else if (locales[name] != null) {
                delete locales[name];
            }
        }
    }
    return locales[name];
}

// returns locale data
function getLocale (key) {
    var locale;

    if (key && key._locale && key._locale._abbr) {
        key = key._locale._abbr;
    }

    if (!key) {
        return globalLocale;
    }

    if (!isArray(key)) {
        //short-circuit everything else
        locale = loadLocale(key);
        if (locale) {
            return locale;
        }
        key = [key];
    }

    return chooseLocale(key);
}

function listLocales() {
    return keys(locales);
}

function checkOverflow (m) {
    var overflow;
    var a = m._a;

    if (a && getParsingFlags(m).overflow === -2) {
        overflow =
            a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :
            a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :
            a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :
            a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :
            a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :
            a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :
            -1;

        if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
            overflow = DATE;
        }
        if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
            overflow = WEEK;
        }
        if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
            overflow = WEEKDAY;
        }

        getParsingFlags(m).overflow = overflow;
    }

    return m;
}

// Pick the first defined of two or three arguments.
function defaults(a, b, c) {
    if (a != null) {
        return a;
    }
    if (b != null) {
        return b;
    }
    return c;
}

function currentDateArray(config) {
    // hooks is actually the exported moment object
    var nowValue = new Date(hooks.now());
    if (config._useUTC) {
        return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
    }
    return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
}

// convert an array to a date.
// the array should mirror the parameters below
// note: all values past the year are optional and will default to the lowest possible value.
// [year, month, day , hour, minute, second, millisecond]
function configFromArray (config) {
    var i, date, input = [], currentDate, expectedWeekday, yearToUse;

    if (config._d) {
        return;
    }

    currentDate = currentDateArray(config);

    //compute day of the year from weeks and weekdays
    if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
        dayOfYearFromWeekInfo(config);
    }

    //if the day of the year is set, figure out what it is
    if (config._dayOfYear != null) {
        yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

        if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
            getParsingFlags(config)._overflowDayOfYear = true;
        }

        date = createUTCDate(yearToUse, 0, config._dayOfYear);
        config._a[MONTH] = date.getUTCMonth();
        config._a[DATE] = date.getUTCDate();
    }

    // Default to current date.
    // * if no year, month, day of month are given, default to today
    // * if day of month is given, default month and year
    // * if month is given, default only year
    // * if year is given, don't default anything
    for (i = 0; i < 3 && config._a[i] == null; ++i) {
        config._a[i] = input[i] = currentDate[i];
    }

    // Zero out whatever was not defaulted, including time
    for (; i < 7; i++) {
        config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
    }

    // Check for 24:00:00.000
    if (config._a[HOUR] === 24 &&
            config._a[MINUTE] === 0 &&
            config._a[SECOND] === 0 &&
            config._a[MILLISECOND] === 0) {
        config._nextDay = true;
        config._a[HOUR] = 0;
    }

    config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
    expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();

    // Apply timezone offset from input. The actual utcOffset can be changed
    // with parseZone.
    if (config._tzm != null) {
        config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
    }

    if (config._nextDay) {
        config._a[HOUR] = 24;
    }

    // check for mismatching day of week
    if (config._w && typeof config._w.d !== 'undefined' && config._w.d !== expectedWeekday) {
        getParsingFlags(config).weekdayMismatch = true;
    }
}

function dayOfYearFromWeekInfo(config) {
    var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;

    w = config._w;
    if (w.GG != null || w.W != null || w.E != null) {
        dow = 1;
        doy = 4;

        // TODO: We need to take the current isoWeekYear, but that depends on
        // how we interpret now (local, utc, fixed offset). So create
        // a now version of current config (take local/utc/offset flags, and
        // create now).
        weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
        week = defaults(w.W, 1);
        weekday = defaults(w.E, 1);
        if (weekday < 1 || weekday > 7) {
            weekdayOverflow = true;
        }
    } else {
        dow = config._locale._week.dow;
        doy = config._locale._week.doy;

        var curWeek = weekOfYear(createLocal(), dow, doy);

        weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);

        // Default to current week.
        week = defaults(w.w, curWeek.week);

        if (w.d != null) {
            // weekday -- low day numbers are considered next week
            weekday = w.d;
            if (weekday < 0 || weekday > 6) {
                weekdayOverflow = true;
            }
        } else if (w.e != null) {
            // local weekday -- counting starts from begining of week
            weekday = w.e + dow;
            if (w.e < 0 || w.e > 6) {
                weekdayOverflow = true;
            }
        } else {
            // default to begining of week
            weekday = dow;
        }
    }
    if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
        getParsingFlags(config)._overflowWeeks = true;
    } else if (weekdayOverflow != null) {
        getParsingFlags(config)._overflowWeekday = true;
    } else {
        temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
        config._a[YEAR] = temp.year;
        config._dayOfYear = temp.dayOfYear;
    }
}

// iso 8601 regex
// 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;

var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;

var isoDates = [
    ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
    ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
    ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
    ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
    ['YYYY-DDD', /\d{4}-\d{3}/],
    ['YYYY-MM', /\d{4}-\d\d/, false],
    ['YYYYYYMMDD', /[+-]\d{10}/],
    ['YYYYMMDD', /\d{8}/],
    // YYYYMM is NOT allowed by the standard
    ['GGGG[W]WWE', /\d{4}W\d{3}/],
    ['GGGG[W]WW', /\d{4}W\d{2}/, false],
    ['YYYYDDD', /\d{7}/]
];

// iso time formats and regexes
var isoTimes = [
    ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
    ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
    ['HH:mm:ss', /\d\d:\d\d:\d\d/],
    ['HH:mm', /\d\d:\d\d/],
    ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
    ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
    ['HHmmss', /\d\d\d\d\d\d/],
    ['HHmm', /\d\d\d\d/],
    ['HH', /\d\d/]
];

var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;

// date from iso format
function configFromISO(config) {
    var i, l,
        string = config._i,
        match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
        allowTime, dateFormat, timeFormat, tzFormat;

    if (match) {
        getParsingFlags(config).iso = true;

        for (i = 0, l = isoDates.length; i < l; i++) {
            if (isoDates[i][1].exec(match[1])) {
                dateFormat = isoDates[i][0];
                allowTime = isoDates[i][2] !== false;
                break;
            }
        }
        if (dateFormat == null) {
            config._isValid = false;
            return;
        }
        if (match[3]) {
            for (i = 0, l = isoTimes.length; i < l; i++) {
                if (isoTimes[i][1].exec(match[3])) {
                    // match[2] should be 'T' or space
                    timeFormat = (match[2] || ' ') + isoTimes[i][0];
                    break;
                }
            }
            if (timeFormat == null) {
                config._isValid = false;
                return;
            }
        }
        if (!allowTime && timeFormat != null) {
            config._isValid = false;
            return;
        }
        if (match[4]) {
            if (tzRegex.exec(match[4])) {
                tzFormat = 'Z';
            } else {
                config._isValid = false;
                return;
            }
        }
        config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
        configFromStringAndFormat(config);
    } else {
        config._isValid = false;
    }
}

// RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3
var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/;

function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
    var result = [
        untruncateYear(yearStr),
        defaultLocaleMonthsShort.indexOf(monthStr),
        parseInt(dayStr, 10),
        parseInt(hourStr, 10),
        parseInt(minuteStr, 10)
    ];

    if (secondStr) {
        result.push(parseInt(secondStr, 10));
    }

    return result;
}

function untruncateYear(yearStr) {
    var year = parseInt(yearStr, 10);
    if (year <= 49) {
        return 2000 + year;
    } else if (year <= 999) {
        return 1900 + year;
    }
    return year;
}

function preprocessRFC2822(s) {
    // Remove comments and folding whitespace and replace multiple-spaces with a single space
    return s.replace(/\([^)]*\)|[\n\t]/g, ' ').replace(/(\s\s+)/g, ' ').trim();
}

function checkWeekday(weekdayStr, parsedInput, config) {
    if (weekdayStr) {
        // TODO: Replace the vanilla JS Date object with an indepentent day-of-week check.
        var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),
            weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();
        if (weekdayProvided !== weekdayActual) {
            getParsingFlags(config).weekdayMismatch = true;
            config._isValid = false;
            return false;
        }
    }
    return true;
}

var obsOffsets = {
    UT: 0,
    GMT: 0,
    EDT: -4 * 60,
    EST: -5 * 60,
    CDT: -5 * 60,
    CST: -6 * 60,
    MDT: -6 * 60,
    MST: -7 * 60,
    PDT: -7 * 60,
    PST: -8 * 60
};

function calculateOffset(obsOffset, militaryOffset, numOffset) {
    if (obsOffset) {
        return obsOffsets[obsOffset];
    } else if (militaryOffset) {
        // the only allowed military tz is Z
        return 0;
    } else {
        var hm = parseInt(numOffset, 10);
        var m = hm % 100, h = (hm - m) / 100;
        return h * 60 + m;
    }
}

// date and time from ref 2822 format
function configFromRFC2822(config) {
    var match = rfc2822.exec(preprocessRFC2822(config._i));
    if (match) {
        var parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);
        if (!checkWeekday(match[1], parsedArray, config)) {
            return;
        }

        config._a = parsedArray;
        config._tzm = calculateOffset(match[8], match[9], match[10]);

        config._d = createUTCDate.apply(null, config._a);
        config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);

        getParsingFlags(config).rfc2822 = true;
    } else {
        config._isValid = false;
    }
}

// date from iso format or fallback
function configFromString(config) {
    var matched = aspNetJsonRegex.exec(config._i);

    if (matched !== null) {
        config._d = new Date(+matched[1]);
        return;
    }

    configFromISO(config);
    if (config._isValid === false) {
        delete config._isValid;
    } else {
        return;
    }

    configFromRFC2822(config);
    if (config._isValid === false) {
        delete config._isValid;
    } else {
        return;
    }

    // Final attempt, use Input Fallback
    hooks.createFromInputFallback(config);
}

hooks.createFromInputFallback = deprecate(
    'value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' +
    'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' +
    'discouraged and will be removed in an upcoming major release. Please refer to ' +
    'http://momentjs.com/guides/#/warnings/js-date/ for more info.',
    function (config) {
        config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
    }
);

// constant that refers to the ISO standard
hooks.ISO_8601 = function () {};

// constant that refers to the RFC 2822 form
hooks.RFC_2822 = function () {};

// date from string and format string
function configFromStringAndFormat(config) {
    // TODO: Move this to another part of the creation flow to prevent circular deps
    if (config._f === hooks.ISO_8601) {
        configFromISO(config);
        return;
    }
    if (config._f === hooks.RFC_2822) {
        configFromRFC2822(config);
        return;
    }
    config._a = [];
    getParsingFlags(config).empty = true;

    // This array is used to make a Date, either with `new Date` or `Date.UTC`
    var string = '' + config._i,
        i, parsedInput, tokens, token, skipped,
        stringLength = string.length,
        totalParsedInputLength = 0;

    tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

    for (i = 0; i < tokens.length; i++) {
        token = tokens[i];
        parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
        // console.log('token', token, 'parsedInput', parsedInput,
        //         'regex', getParseRegexForToken(token, config));
        if (parsedInput) {
            skipped = string.substr(0, string.indexOf(parsedInput));
            if (skipped.length > 0) {
                getParsingFlags(config).unusedInput.push(skipped);
            }
            string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
            totalParsedInputLength += parsedInput.length;
        }
        // don't parse if it's not a known token
        if (formatTokenFunctions[token]) {
            if (parsedInput) {
                getParsingFlags(config).empty = false;
            }
            else {
                getParsingFlags(config).unusedTokens.push(token);
            }
            addTimeToArrayFromToken(token, parsedInput, config);
        }
        else if (config._strict && !parsedInput) {
            getParsingFlags(config).unusedTokens.push(token);
        }
    }

    // add remaining unparsed input length to the string
    getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
    if (string.length > 0) {
        getParsingFlags(config).unusedInput.push(string);
    }

    // clear _12h flag if hour is <= 12
    if (config._a[HOUR] <= 12 &&
        getParsingFlags(config).bigHour === true &&
        config._a[HOUR] > 0) {
        getParsingFlags(config).bigHour = undefined;
    }

    getParsingFlags(config).parsedDateParts = config._a.slice(0);
    getParsingFlags(config).meridiem = config._meridiem;
    // handle meridiem
    config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);

    configFromArray(config);
    checkOverflow(config);
}


function meridiemFixWrap (locale, hour, meridiem) {
    var isPm;

    if (meridiem == null) {
        // nothing to do
        return hour;
    }
    if (locale.meridiemHour != null) {
        return locale.meridiemHour(hour, meridiem);
    } else if (locale.isPM != null) {
        // Fallback
        isPm = locale.isPM(meridiem);
        if (isPm && hour < 12) {
            hour += 12;
        }
        if (!isPm && hour === 12) {
            hour = 0;
        }
        return hour;
    } else {
        // this is not supposed to happen
        return hour;
    }
}

// date from string and array of format strings
function configFromStringAndArray(config) {
    var tempConfig,
        bestMoment,

        scoreToBeat,
        i,
        currentScore;

    if (config._f.length === 0) {
        getParsingFlags(config).invalidFormat = true;
        config._d = new Date(NaN);
        return;
    }

    for (i = 0; i < config._f.length; i++) {
        currentScore = 0;
        tempConfig = copyConfig({}, config);
        if (config._useUTC != null) {
            tempConfig._useUTC = config._useUTC;
        }
        tempConfig._f = config._f[i];
        configFromStringAndFormat(tempConfig);

        if (!isValid(tempConfig)) {
            continue;
        }

        // if there is any input that was not parsed add a penalty for that format
        currentScore += getParsingFlags(tempConfig).charsLeftOver;

        //or tokens
        currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

        getParsingFlags(tempConfig).score = currentScore;

        if (scoreToBeat == null || currentScore < scoreToBeat) {
            scoreToBeat = currentScore;
            bestMoment = tempConfig;
        }
    }

    extend(config, bestMoment || tempConfig);
}

function configFromObject(config) {
    if (config._d) {
        return;
    }

    var i = normalizeObjectUnits(config._i);
    config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {
        return obj && parseInt(obj, 10);
    });

    configFromArray(config);
}

function createFromConfig (config) {
    var res = new Moment(checkOverflow(prepareConfig(config)));
    if (res._nextDay) {
        // Adding is smart enough around DST
        res.add(1, 'd');
        res._nextDay = undefined;
    }

    return res;
}

function prepareConfig (config) {
    var input = config._i,
        format = config._f;

    config._locale = config._locale || getLocale(config._l);

    if (input === null || (format === undefined && input === '')) {
        return createInvalid({nullInput: true});
    }

    if (typeof input === 'string') {
        config._i = input = config._locale.preparse(input);
    }

    if (isMoment(input)) {
        return new Moment(checkOverflow(input));
    } else if (isDate(input)) {
        config._d = input;
    } else if (isArray(format)) {
        configFromStringAndArray(config);
    } else if (format) {
        configFromStringAndFormat(config);
    }  else {
        configFromInput(config);
    }

    if (!isValid(config)) {
        config._d = null;
    }

    return config;
}

function configFromInput(config) {
    var input = config._i;
    if (isUndefined(input)) {
        config._d = new Date(hooks.now());
    } else if (isDate(input)) {
        config._d = new Date(input.valueOf());
    } else if (typeof input === 'string') {
        configFromString(config);
    } else if (isArray(input)) {
        config._a = map(input.slice(0), function (obj) {
            return parseInt(obj, 10);
        });
        configFromArray(config);
    } else if (isObject(input)) {
        configFromObject(config);
    } else if (isNumber(input)) {
        // from milliseconds
        config._d = new Date(input);
    } else {
        hooks.createFromInputFallback(config);
    }
}

function createLocalOrUTC (input, format, locale, strict, isUTC) {
    var c = {};

    if (locale === true || locale === false) {
        strict = locale;
        locale = undefined;
    }

    if ((isObject(input) && isObjectEmpty(input)) ||
            (isArray(input) && input.length === 0)) {
        input = undefined;
    }
    // object construction must be done this way.
    // https://github.com/moment/moment/issues/1423
    c._isAMomentObject = true;
    c._useUTC = c._isUTC = isUTC;
    c._l = locale;
    c._i = input;
    c._f = format;
    c._strict = strict;

    return createFromConfig(c);
}

function createLocal (input, format, locale, strict) {
    return createLocalOrUTC(input, format, locale, strict, false);
}

var prototypeMin = deprecate(
    'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',
    function () {
        var other = createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
            return other < this ? this : other;
        } else {
            return createInvalid();
        }
    }
);

var prototypeMax = deprecate(
    'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',
    function () {
        var other = createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
            return other > this ? this : other;
        } else {
            return createInvalid();
        }
    }
);

// Pick a moment m from moments so that m[fn](other) is true for all
// other. This relies on the function fn to be transitive.
//
// moments should either be an array of moment objects or an array, whose
// first element is an array of moment objects.
function pickBy(fn, moments) {
    var res, i;
    if (moments.length === 1 && isArray(moments[0])) {
        moments = moments[0];
    }
    if (!moments.length) {
        return createLocal();
    }
    res = moments[0];
    for (i = 1; i < moments.length; ++i) {
        if (!moments[i].isValid() || moments[i][fn](res)) {
            res = moments[i];
        }
    }
    return res;
}

// TODO: Use [].sort instead?
function min () {
    var args = [].slice.call(arguments, 0);

    return pickBy('isBefore', args);
}

function max () {
    var args = [].slice.call(arguments, 0);

    return pickBy('isAfter', args);
}

var now = function () {
    return Date.now ? Date.now() : +(new Date());
};

var ordering = ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'];

function isDurationValid(m) {
    for (var key in m) {
        if (!(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
            return false;
        }
    }

    var unitHasDecimal = false;
    for (var i = 0; i < ordering.length; ++i) {
        if (m[ordering[i]]) {
            if (unitHasDecimal) {
                return false; // only allow non-integers for smallest unit
            }
            if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
                unitHasDecimal = true;
            }
        }
    }

    return true;
}

function isValid$1() {
    return this._isValid;
}

function createInvalid$1() {
    return createDuration(NaN);
}

function Duration (duration) {
    var normalizedInput = normalizeObjectUnits(duration),
        years = normalizedInput.year || 0,
        quarters = normalizedInput.quarter || 0,
        months = normalizedInput.month || 0,
        weeks = normalizedInput.week || 0,
        days = normalizedInput.day || 0,
        hours = normalizedInput.hour || 0,
        minutes = normalizedInput.minute || 0,
        seconds = normalizedInput.second || 0,
        milliseconds = normalizedInput.millisecond || 0;

    this._isValid = isDurationValid(normalizedInput);

    // representation for dateAddRemove
    this._milliseconds = +milliseconds +
        seconds * 1e3 + // 1000
        minutes * 6e4 + // 1000 * 60
        hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
    // Because of dateAddRemove treats 24 hours as different from a
    // day when working around DST, we need to store them separately
    this._days = +days +
        weeks * 7;
    // It is impossible to translate months into days without knowing
    // which months you are are talking about, so we have to store
    // it separately.
    this._months = +months +
        quarters * 3 +
        years * 12;

    this._data = {};

    this._locale = getLocale();

    this._bubble();
}

function isDuration (obj) {
    return obj instanceof Duration;
}

function absRound (number) {
    if (number < 0) {
        return Math.round(-1 * number) * -1;
    } else {
        return Math.round(number);
    }
}

// FORMATTING

function offset (token, separator) {
    addFormatToken(token, 0, 0, function () {
        var offset = this.utcOffset();
        var sign = '+';
        if (offset < 0) {
            offset = -offset;
            sign = '-';
        }
        return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
    });
}

offset('Z', ':');
offset('ZZ', '');

// PARSING

addRegexToken('Z',  matchShortOffset);
addRegexToken('ZZ', matchShortOffset);
addParseToken(['Z', 'ZZ'], function (input, array, config) {
    config._useUTC = true;
    config._tzm = offsetFromString(matchShortOffset, input);
});

// HELPERS

// timezone chunker
// '+10:00' > ['10',  '00']
// '-1530'  > ['-15', '30']
var chunkOffset = /([\+\-]|\d\d)/gi;

function offsetFromString(matcher, string) {
    var matches = (string || '').match(matcher);

    if (matches === null) {
        return null;
    }

    var chunk   = matches[matches.length - 1] || [];
    var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];
    var minutes = +(parts[1] * 60) + toInt(parts[2]);

    return minutes === 0 ?
      0 :
      parts[0] === '+' ? minutes : -minutes;
}

// Return a moment from input, that is local/utc/zone equivalent to model.
function cloneWithOffset(input, model) {
    var res, diff;
    if (model._isUTC) {
        res = model.clone();
        diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
        // Use low-level api, because this fn is low-level api.
        res._d.setTime(res._d.valueOf() + diff);
        hooks.updateOffset(res, false);
        return res;
    } else {
        return createLocal(input).local();
    }
}

function getDateOffset (m) {
    // On Firefox.24 Date#getTimezoneOffset returns a floating point.
    // https://github.com/moment/moment/pull/1871
    return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
}

// HOOKS

// This function will be called whenever a moment is mutated.
// It is intended to keep the offset in sync with the timezone.
hooks.updateOffset = function () {};

// MOMENTS

// keepLocalTime = true means only change the timezone, without
// affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
// 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
// +0200, so we adjust the time as needed, to be valid.
//
// Keeping the time actually adds/subtracts (one hour)
// from the actual represented time. That is why we call updateOffset
// a second time. In case it wants us to change the offset again
// _changeInProgress == true case, then we have to adjust, because
// there is no such time in the given timezone.
function getSetOffset (input, keepLocalTime, keepMinutes) {
    var offset = this._offset || 0,
        localAdjust;
    if (!this.isValid()) {
        return input != null ? this : NaN;
    }
    if (input != null) {
        if (typeof input === 'string') {
            input = offsetFromString(matchShortOffset, input);
            if (input === null) {
                return this;
            }
        } else if (Math.abs(input) < 16 && !keepMinutes) {
            input = input * 60;
        }
        if (!this._isUTC && keepLocalTime) {
            localAdjust = getDateOffset(this);
        }
        this._offset = input;
        this._isUTC = true;
        if (localAdjust != null) {
            this.add(localAdjust, 'm');
        }
        if (offset !== input) {
            if (!keepLocalTime || this._changeInProgress) {
                addSubtract(this, createDuration(input - offset, 'm'), 1, false);
            } else if (!this._changeInProgress) {
                this._changeInProgress = true;
                hooks.updateOffset(this, true);
                this._changeInProgress = null;
            }
        }
        return this;
    } else {
        return this._isUTC ? offset : getDateOffset(this);
    }
}

function getSetZone (input, keepLocalTime) {
    if (input != null) {
        if (typeof input !== 'string') {
            input = -input;
        }

        this.utcOffset(input, keepLocalTime);

        return this;
    } else {
        return -this.utcOffset();
    }
}

function setOffsetToUTC (keepLocalTime) {
    return this.utcOffset(0, keepLocalTime);
}

function setOffsetToLocal (keepLocalTime) {
    if (this._isUTC) {
        this.utcOffset(0, keepLocalTime);
        this._isUTC = false;

        if (keepLocalTime) {
            this.subtract(getDateOffset(this), 'm');
        }
    }
    return this;
}

function setOffsetToParsedOffset () {
    if (this._tzm != null) {
        this.utcOffset(this._tzm, false, true);
    } else if (typeof this._i === 'string') {
        var tZone = offsetFromString(matchOffset, this._i);
        if (tZone != null) {
            this.utcOffset(tZone);
        }
        else {
            this.utcOffset(0, true);
        }
    }
    return this;
}

function hasAlignedHourOffset (input) {
    if (!this.isValid()) {
        return false;
    }
    input = input ? createLocal(input).utcOffset() : 0;

    return (this.utcOffset() - input) % 60 === 0;
}

function isDaylightSavingTime () {
    return (
        this.utcOffset() > this.clone().month(0).utcOffset() ||
        this.utcOffset() > this.clone().month(5).utcOffset()
    );
}

function isDaylightSavingTimeShifted () {
    if (!isUndefined(this._isDSTShifted)) {
        return this._isDSTShifted;
    }

    var c = {};

    copyConfig(c, this);
    c = prepareConfig(c);

    if (c._a) {
        var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
        this._isDSTShifted = this.isValid() &&
            compareArrays(c._a, other.toArray()) > 0;
    } else {
        this._isDSTShifted = false;
    }

    return this._isDSTShifted;
}

function isLocal () {
    return this.isValid() ? !this._isUTC : false;
}

function isUtcOffset () {
    return this.isValid() ? this._isUTC : false;
}

function isUtc () {
    return this.isValid() ? this._isUTC && this._offset === 0 : false;
}

// ASP.NET json date format regex
var aspNetRegex = /^(\-|\+)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/;

// from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
// somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
// and further modified to allow for strings containing both week and day
var isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;

function createDuration (input, key) {
    var duration = input,
        // matching against regexp is expensive, do it on demand
        match = null,
        sign,
        ret,
        diffRes;

    if (isDuration(input)) {
        duration = {
            ms : input._milliseconds,
            d  : input._days,
            M  : input._months
        };
    } else if (isNumber(input)) {
        duration = {};
        if (key) {
            duration[key] = input;
        } else {
            duration.milliseconds = input;
        }
    } else if (!!(match = aspNetRegex.exec(input))) {
        sign = (match[1] === '-') ? -1 : 1;
        duration = {
            y  : 0,
            d  : toInt(match[DATE])                         * sign,
            h  : toInt(match[HOUR])                         * sign,
            m  : toInt(match[MINUTE])                       * sign,
            s  : toInt(match[SECOND])                       * sign,
            ms : toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match
        };
    } else if (!!(match = isoRegex.exec(input))) {
        sign = (match[1] === '-') ? -1 : (match[1] === '+') ? 1 : 1;
        duration = {
            y : parseIso(match[2], sign),
            M : parseIso(match[3], sign),
            w : parseIso(match[4], sign),
            d : parseIso(match[5], sign),
            h : parseIso(match[6], sign),
            m : parseIso(match[7], sign),
            s : parseIso(match[8], sign)
        };
    } else if (duration == null) {// checks for null or undefined
        duration = {};
    } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
        diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));

        duration = {};
        duration.ms = diffRes.milliseconds;
        duration.M = diffRes.months;
    }

    ret = new Duration(duration);

    if (isDuration(input) && hasOwnProp(input, '_locale')) {
        ret._locale = input._locale;
    }

    return ret;
}

createDuration.fn = Duration.prototype;
createDuration.invalid = createInvalid$1;

function parseIso (inp, sign) {
    // We'd normally use ~~inp for this, but unfortunately it also
    // converts floats to ints.
    // inp may be undefined, so careful calling replace on it.
    var res = inp && parseFloat(inp.replace(',', '.'));
    // apply sign while we're at it
    return (isNaN(res) ? 0 : res) * sign;
}

function positiveMomentsDifference(base, other) {
    var res = {milliseconds: 0, months: 0};

    res.months = other.month() - base.month() +
        (other.year() - base.year()) * 12;
    if (base.clone().add(res.months, 'M').isAfter(other)) {
        --res.months;
    }

    res.milliseconds = +other - +(base.clone().add(res.months, 'M'));

    return res;
}

function momentsDifference(base, other) {
    var res;
    if (!(base.isValid() && other.isValid())) {
        return {milliseconds: 0, months: 0};
    }

    other = cloneWithOffset(other, base);
    if (base.isBefore(other)) {
        res = positiveMomentsDifference(base, other);
    } else {
        res = positiveMomentsDifference(other, base);
        res.milliseconds = -res.milliseconds;
        res.months = -res.months;
    }

    return res;
}

// TODO: remove 'name' arg after deprecation is removed
function createAdder(direction, name) {
    return function (val, period) {
        var dur, tmp;
        //invert the arguments, but complain about it
        if (period !== null && !isNaN(+period)) {
            deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' +
            'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');
            tmp = val; val = period; period = tmp;
        }

        val = typeof val === 'string' ? +val : val;
        dur = createDuration(val, period);
        addSubtract(this, dur, direction);
        return this;
    };
}

function addSubtract (mom, duration, isAdding, updateOffset) {
    var milliseconds = duration._milliseconds,
        days = absRound(duration._days),
        months = absRound(duration._months);

    if (!mom.isValid()) {
        // No op
        return;
    }

    updateOffset = updateOffset == null ? true : updateOffset;

    if (months) {
        setMonth(mom, get(mom, 'Month') + months * isAdding);
    }
    if (days) {
        set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
    }
    if (milliseconds) {
        mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
    }
    if (updateOffset) {
        hooks.updateOffset(mom, days || months);
    }
}

var add      = createAdder(1, 'add');
var subtract = createAdder(-1, 'subtract');

function getCalendarFormat(myMoment, now) {
    var diff = myMoment.diff(now, 'days', true);
    return diff < -6 ? 'sameElse' :
            diff < -1 ? 'lastWeek' :
            diff < 0 ? 'lastDay' :
            diff < 1 ? 'sameDay' :
            diff < 2 ? 'nextDay' :
            diff < 7 ? 'nextWeek' : 'sameElse';
}

function calendar$1 (time, formats) {
    // We want to compare the start of today, vs this.
    // Getting start-of-today depends on whether we're local/utc/offset or not.
    var now = time || createLocal(),
        sod = cloneWithOffset(now, this).startOf('day'),
        format = hooks.calendarFormat(this, sod) || 'sameElse';

    var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);

    return this.format(output || this.localeData().calendar(format, this, createLocal(now)));
}

function clone () {
    return new Moment(this);
}

function isAfter (input, units) {
    var localInput = isMoment(input) ? input : createLocal(input);
    if (!(this.isValid() && localInput.isValid())) {
        return false;
    }
    units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
    if (units === 'millisecond') {
        return this.valueOf() > localInput.valueOf();
    } else {
        return localInput.valueOf() < this.clone().startOf(units).valueOf();
    }
}

function isBefore (input, units) {
    var localInput = isMoment(input) ? input : createLocal(input);
    if (!(this.isValid() && localInput.isValid())) {
        return false;
    }
    units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
    if (units === 'millisecond') {
        return this.valueOf() < localInput.valueOf();
    } else {
        return this.clone().endOf(units).valueOf() < localInput.valueOf();
    }
}

function isBetween (from, to, units, inclusivity) {
    inclusivity = inclusivity || '()';
    return (inclusivity[0] === '(' ? this.isAfter(from, units) : !this.isBefore(from, units)) &&
        (inclusivity[1] === ')' ? this.isBefore(to, units) : !this.isAfter(to, units));
}

function isSame (input, units) {
    var localInput = isMoment(input) ? input : createLocal(input),
        inputMs;
    if (!(this.isValid() && localInput.isValid())) {
        return false;
    }
    units = normalizeUnits(units || 'millisecond');
    if (units === 'millisecond') {
        return this.valueOf() === localInput.valueOf();
    } else {
        inputMs = localInput.valueOf();
        return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
    }
}

function isSameOrAfter (input, units) {
    return this.isSame(input, units) || this.isAfter(input,units);
}

function isSameOrBefore (input, units) {
    return this.isSame(input, units) || this.isBefore(input,units);
}

function diff (input, units, asFloat) {
    var that,
        zoneDelta,
        delta, output;

    if (!this.isValid()) {
        return NaN;
    }

    that = cloneWithOffset(input, this);

    if (!that.isValid()) {
        return NaN;
    }

    zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

    units = normalizeUnits(units);

    switch (units) {
        case 'year': output = monthDiff(this, that) / 12; break;
        case 'month': output = monthDiff(this, that); break;
        case 'quarter': output = monthDiff(this, that) / 3; break;
        case 'second': output = (this - that) / 1e3; break; // 1000
        case 'minute': output = (this - that) / 6e4; break; // 1000 * 60
        case 'hour': output = (this - that) / 36e5; break; // 1000 * 60 * 60
        case 'day': output = (this - that - zoneDelta) / 864e5; break; // 1000 * 60 * 60 * 24, negate dst
        case 'week': output = (this - that - zoneDelta) / 6048e5; break; // 1000 * 60 * 60 * 24 * 7, negate dst
        default: output = this - that;
    }

    return asFloat ? output : absFloor(output);
}

function monthDiff (a, b) {
    // difference in months
    var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
        // b is in (anchor - 1 month, anchor + 1 month)
        anchor = a.clone().add(wholeMonthDiff, 'months'),
        anchor2, adjust;

    if (b - anchor < 0) {
        anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
        // linear across the month
        adjust = (b - anchor) / (anchor - anchor2);
    } else {
        anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
        // linear across the month
        adjust = (b - anchor) / (anchor2 - anchor);
    }

    //check for negative zero, return zero if negative zero
    return -(wholeMonthDiff + adjust) || 0;
}

hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

function toString () {
    return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
}

function toISOString(keepOffset) {
    if (!this.isValid()) {
        return null;
    }
    var utc = keepOffset !== true;
    var m = utc ? this.clone().utc() : this;
    if (m.year() < 0 || m.year() > 9999) {
        return formatMoment(m, utc ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ');
    }
    if (isFunction(Date.prototype.toISOString)) {
        // native implementation is ~50x faster, use it when we can
        if (utc) {
            return this.toDate().toISOString();
        } else {
            return new Date(this._d.valueOf()).toISOString().replace('Z', formatMoment(m, 'Z'));
        }
    }
    return formatMoment(m, utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ');
}

/**
 * Return a human readable representation of a moment that can
 * also be evaluated to get a new moment which is the same
 *
 * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
 */
function inspect () {
    if (!this.isValid()) {
        return 'moment.invalid(/* ' + this._i + ' */)';
    }
    var func = 'moment';
    var zone = '';
    if (!this.isLocal()) {
        func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
        zone = 'Z';
    }
    var prefix = '[' + func + '("]';
    var year = (0 <= this.year() && this.year() <= 9999) ? 'YYYY' : 'YYYYYY';
    var datetime = '-MM-DD[T]HH:mm:ss.SSS';
    var suffix = zone + '[")]';

    return this.format(prefix + year + datetime + suffix);
}

function format (inputString) {
    if (!inputString) {
        inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
    }
    var output = formatMoment(this, inputString);
    return this.localeData().postformat(output);
}

function from (time, withoutSuffix) {
    if (this.isValid() &&
            ((isMoment(time) && time.isValid()) ||
             createLocal(time).isValid())) {
        return createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
    } else {
        return this.localeData().invalidDate();
    }
}

function fromNow (withoutSuffix) {
    return this.from(createLocal(), withoutSuffix);
}

function to (time, withoutSuffix) {
    if (this.isValid() &&
            ((isMoment(time) && time.isValid()) ||
             createLocal(time).isValid())) {
        return createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);
    } else {
        return this.localeData().invalidDate();
    }
}

function toNow (withoutSuffix) {
    return this.to(createLocal(), withoutSuffix);
}

// If passed a locale key, it will set the locale for this
// instance.  Otherwise, it will return the locale configuration
// variables for this instance.
function locale (key) {
    var newLocaleData;

    if (key === undefined) {
        return this._locale._abbr;
    } else {
        newLocaleData = getLocale(key);
        if (newLocaleData != null) {
            this._locale = newLocaleData;
        }
        return this;
    }
}

var lang = deprecate(
    'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
    function (key) {
        if (key === undefined) {
            return this.localeData();
        } else {
            return this.locale(key);
        }
    }
);

function localeData () {
    return this._locale;
}

function startOf (units) {
    units = normalizeUnits(units);
    // the following switch intentionally omits break keywords
    // to utilize falling through the cases.
    switch (units) {
        case 'year':
            this.month(0);
            /* falls through */
        case 'quarter':
        case 'month':
            this.date(1);
            /* falls through */
        case 'week':
        case 'isoWeek':
        case 'day':
        case 'date':
            this.hours(0);
            /* falls through */
        case 'hour':
            this.minutes(0);
            /* falls through */
        case 'minute':
            this.seconds(0);
            /* falls through */
        case 'second':
            this.milliseconds(0);
    }

    // weeks are a special case
    if (units === 'week') {
        this.weekday(0);
    }
    if (units === 'isoWeek') {
        this.isoWeekday(1);
    }

    // quarters are also special
    if (units === 'quarter') {
        this.month(Math.floor(this.month() / 3) * 3);
    }

    return this;
}

function endOf (units) {
    units = normalizeUnits(units);
    if (units === undefined || units === 'millisecond') {
        return this;
    }

    // 'date' is an alias for 'day', so it should be considered as such.
    if (units === 'date') {
        units = 'day';
    }

    return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
}

function valueOf () {
    return this._d.valueOf() - ((this._offset || 0) * 60000);
}

function unix () {
    return Math.floor(this.valueOf() / 1000);
}

function toDate () {
    return new Date(this.valueOf());
}

function toArray () {
    var m = this;
    return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
}

function toObject () {
    var m = this;
    return {
        years: m.year(),
        months: m.month(),
        date: m.date(),
        hours: m.hours(),
        minutes: m.minutes(),
        seconds: m.seconds(),
        milliseconds: m.milliseconds()
    };
}

function toJSON () {
    // new Date(NaN).toJSON() === null
    return this.isValid() ? this.toISOString() : null;
}

function isValid$2 () {
    return isValid(this);
}

function parsingFlags () {
    return extend({}, getParsingFlags(this));
}

function invalidAt () {
    return getParsingFlags(this).overflow;
}

function creationData() {
    return {
        input: this._i,
        format: this._f,
        locale: this._locale,
        isUTC: this._isUTC,
        strict: this._strict
    };
}

// FORMATTING

addFormatToken(0, ['gg', 2], 0, function () {
    return this.weekYear() % 100;
});

addFormatToken(0, ['GG', 2], 0, function () {
    return this.isoWeekYear() % 100;
});

function addWeekYearFormatToken (token, getter) {
    addFormatToken(0, [token, token.length], 0, getter);
}

addWeekYearFormatToken('gggg',     'weekYear');
addWeekYearFormatToken('ggggg',    'weekYear');
addWeekYearFormatToken('GGGG',  'isoWeekYear');
addWeekYearFormatToken('GGGGG', 'isoWeekYear');

// ALIASES

addUnitAlias('weekYear', 'gg');
addUnitAlias('isoWeekYear', 'GG');

// PRIORITY

addUnitPriority('weekYear', 1);
addUnitPriority('isoWeekYear', 1);


// PARSING

addRegexToken('G',      matchSigned);
addRegexToken('g',      matchSigned);
addRegexToken('GG',     match1to2, match2);
addRegexToken('gg',     match1to2, match2);
addRegexToken('GGGG',   match1to4, match4);
addRegexToken('gggg',   match1to4, match4);
addRegexToken('GGGGG',  match1to6, match6);
addRegexToken('ggggg',  match1to6, match6);

addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
    week[token.substr(0, 2)] = toInt(input);
});

addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
    week[token] = hooks.parseTwoDigitYear(input);
});

// MOMENTS

function getSetWeekYear (input) {
    return getSetWeekYearHelper.call(this,
            input,
            this.week(),
            this.weekday(),
            this.localeData()._week.dow,
            this.localeData()._week.doy);
}

function getSetISOWeekYear (input) {
    return getSetWeekYearHelper.call(this,
            input, this.isoWeek(), this.isoWeekday(), 1, 4);
}

function getISOWeeksInYear () {
    return weeksInYear(this.year(), 1, 4);
}

function getWeeksInYear () {
    var weekInfo = this.localeData()._week;
    return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
}

function getSetWeekYearHelper(input, week, weekday, dow, doy) {
    var weeksTarget;
    if (input == null) {
        return weekOfYear(this, dow, doy).year;
    } else {
        weeksTarget = weeksInYear(input, dow, doy);
        if (week > weeksTarget) {
            week = weeksTarget;
        }
        return setWeekAll.call(this, input, week, weekday, dow, doy);
    }
}

function setWeekAll(weekYear, week, weekday, dow, doy) {
    var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
        date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

    this.year(date.getUTCFullYear());
    this.month(date.getUTCMonth());
    this.date(date.getUTCDate());
    return this;
}

// FORMATTING

addFormatToken('Q', 0, 'Qo', 'quarter');

// ALIASES

addUnitAlias('quarter', 'Q');

// PRIORITY

addUnitPriority('quarter', 7);

// PARSING

addRegexToken('Q', match1);
addParseToken('Q', function (input, array) {
    array[MONTH] = (toInt(input) - 1) * 3;
});

// MOMENTS

function getSetQuarter (input) {
    return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
}

// FORMATTING

addFormatToken('D', ['DD', 2], 'Do', 'date');

// ALIASES

addUnitAlias('date', 'D');

// PRIOROITY
addUnitPriority('date', 9);

// PARSING

addRegexToken('D',  match1to2);
addRegexToken('DD', match1to2, match2);
addRegexToken('Do', function (isStrict, locale) {
    // TODO: Remove "ordinalParse" fallback in next major release.
    return isStrict ?
      (locale._dayOfMonthOrdinalParse || locale._ordinalParse) :
      locale._dayOfMonthOrdinalParseLenient;
});

addParseToken(['D', 'DD'], DATE);
addParseToken('Do', function (input, array) {
    array[DATE] = toInt(input.match(match1to2)[0]);
});

// MOMENTS

var getSetDayOfMonth = makeGetSet('Date', true);

// FORMATTING

addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

// ALIASES

addUnitAlias('dayOfYear', 'DDD');

// PRIORITY
addUnitPriority('dayOfYear', 4);

// PARSING

addRegexToken('DDD',  match1to3);
addRegexToken('DDDD', match3);
addParseToken(['DDD', 'DDDD'], function (input, array, config) {
    config._dayOfYear = toInt(input);
});

// HELPERS

// MOMENTS

function getSetDayOfYear (input) {
    var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
    return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
}

// FORMATTING

addFormatToken('m', ['mm', 2], 0, 'minute');

// ALIASES

addUnitAlias('minute', 'm');

// PRIORITY

addUnitPriority('minute', 14);

// PARSING

addRegexToken('m',  match1to2);
addRegexToken('mm', match1to2, match2);
addParseToken(['m', 'mm'], MINUTE);

// MOMENTS

var getSetMinute = makeGetSet('Minutes', false);

// FORMATTING

addFormatToken('s', ['ss', 2], 0, 'second');

// ALIASES

addUnitAlias('second', 's');

// PRIORITY

addUnitPriority('second', 15);

// PARSING

addRegexToken('s',  match1to2);
addRegexToken('ss', match1to2, match2);
addParseToken(['s', 'ss'], SECOND);

// MOMENTS

var getSetSecond = makeGetSet('Seconds', false);

// FORMATTING

addFormatToken('S', 0, 0, function () {
    return ~~(this.millisecond() / 100);
});

addFormatToken(0, ['SS', 2], 0, function () {
    return ~~(this.millisecond() / 10);
});

addFormatToken(0, ['SSS', 3], 0, 'millisecond');
addFormatToken(0, ['SSSS', 4], 0, function () {
    return this.millisecond() * 10;
});
addFormatToken(0, ['SSSSS', 5], 0, function () {
    return this.millisecond() * 100;
});
addFormatToken(0, ['SSSSSS', 6], 0, function () {
    return this.millisecond() * 1000;
});
addFormatToken(0, ['SSSSSSS', 7], 0, function () {
    return this.millisecond() * 10000;
});
addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
    return this.millisecond() * 100000;
});
addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
    return this.millisecond() * 1000000;
});


// ALIASES

addUnitAlias('millisecond', 'ms');

// PRIORITY

addUnitPriority('millisecond', 16);

// PARSING

addRegexToken('S',    match1to3, match1);
addRegexToken('SS',   match1to3, match2);
addRegexToken('SSS',  match1to3, match3);

var token;
for (token = 'SSSS'; token.length <= 9; token += 'S') {
    addRegexToken(token, matchUnsigned);
}

function parseMs(input, array) {
    array[MILLISECOND] = toInt(('0.' + input) * 1000);
}

for (token = 'S'; token.length <= 9; token += 'S') {
    addParseToken(token, parseMs);
}
// MOMENTS

var getSetMillisecond = makeGetSet('Milliseconds', false);

// FORMATTING

addFormatToken('z',  0, 0, 'zoneAbbr');
addFormatToken('zz', 0, 0, 'zoneName');

// MOMENTS

function getZoneAbbr () {
    return this._isUTC ? 'UTC' : '';
}

function getZoneName () {
    return this._isUTC ? 'Coordinated Universal Time' : '';
}

var proto = Moment.prototype;

proto.add               = add;
proto.calendar          = calendar$1;
proto.clone             = clone;
proto.diff              = diff;
proto.endOf             = endOf;
proto.format            = format;
proto.from              = from;
proto.fromNow           = fromNow;
proto.to                = to;
proto.toNow             = toNow;
proto.get               = stringGet;
proto.invalidAt         = invalidAt;
proto.isAfter           = isAfter;
proto.isBefore          = isBefore;
proto.isBetween         = isBetween;
proto.isSame            = isSame;
proto.isSameOrAfter     = isSameOrAfter;
proto.isSameOrBefore    = isSameOrBefore;
proto.isValid           = isValid$2;
proto.lang              = lang;
proto.locale            = locale;
proto.localeData        = localeData;
proto.max               = prototypeMax;
proto.min               = prototypeMin;
proto.parsingFlags      = parsingFlags;
proto.set               = stringSet;
proto.startOf           = startOf;
proto.subtract          = subtract;
proto.toArray           = toArray;
proto.toObject          = toObject;
proto.toDate            = toDate;
proto.toISOString       = toISOString;
proto.inspect           = inspect;
proto.toJSON            = toJSON;
proto.toString          = toString;
proto.unix              = unix;
proto.valueOf           = valueOf;
proto.creationData      = creationData;

// Year
proto.year       = getSetYear;
proto.isLeapYear = getIsLeapYear;

// Week Year
proto.weekYear    = getSetWeekYear;
proto.isoWeekYear = getSetISOWeekYear;

// Quarter
proto.quarter = proto.quarters = getSetQuarter;

// Month
proto.month       = getSetMonth;
proto.daysInMonth = getDaysInMonth;

// Week
proto.week           = proto.weeks        = getSetWeek;
proto.isoWeek        = proto.isoWeeks     = getSetISOWeek;
proto.weeksInYear    = getWeeksInYear;
proto.isoWeeksInYear = getISOWeeksInYear;

// Day
proto.date       = getSetDayOfMonth;
proto.day        = proto.days             = getSetDayOfWeek;
proto.weekday    = getSetLocaleDayOfWeek;
proto.isoWeekday = getSetISODayOfWeek;
proto.dayOfYear  = getSetDayOfYear;

// Hour
proto.hour = proto.hours = getSetHour;

// Minute
proto.minute = proto.minutes = getSetMinute;

// Second
proto.second = proto.seconds = getSetSecond;

// Millisecond
proto.millisecond = proto.milliseconds = getSetMillisecond;

// Offset
proto.utcOffset            = getSetOffset;
proto.utc                  = setOffsetToUTC;
proto.local                = setOffsetToLocal;
proto.parseZone            = setOffsetToParsedOffset;
proto.hasAlignedHourOffset = hasAlignedHourOffset;
proto.isDST                = isDaylightSavingTime;
proto.isLocal              = isLocal;
proto.isUtcOffset          = isUtcOffset;
proto.isUtc                = isUtc;
proto.isUTC                = isUtc;

// Timezone
proto.zoneAbbr = getZoneAbbr;
proto.zoneName = getZoneName;

// Deprecations
proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);
proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);

function createUnix (input) {
    return createLocal(input * 1000);
}

function createInZone () {
    return createLocal.apply(null, arguments).parseZone();
}

function preParsePostFormat (string) {
    return string;
}

var proto$1 = Locale.prototype;

proto$1.calendar        = calendar;
proto$1.longDateFormat  = longDateFormat;
proto$1.invalidDate     = invalidDate;
proto$1.ordinal         = ordinal;
proto$1.preparse        = preParsePostFormat;
proto$1.postformat      = preParsePostFormat;
proto$1.relativeTime    = relativeTime;
proto$1.pastFuture      = pastFuture;
proto$1.set             = set;

// Month
proto$1.months            =        localeMonths;
proto$1.monthsShort       =        localeMonthsShort;
proto$1.monthsParse       =        localeMonthsParse;
proto$1.monthsRegex       = monthsRegex;
proto$1.monthsShortRegex  = monthsShortRegex;

// Week
proto$1.week = localeWeek;
proto$1.firstDayOfYear = localeFirstDayOfYear;
proto$1.firstDayOfWeek = localeFirstDayOfWeek;

// Day of Week
proto$1.weekdays       =        localeWeekdays;
proto$1.weekdaysMin    =        localeWeekdaysMin;
proto$1.weekdaysShort  =        localeWeekdaysShort;
proto$1.weekdaysParse  =        localeWeekdaysParse;

proto$1.weekdaysRegex       =        weekdaysRegex;
proto$1.weekdaysShortRegex  =        weekdaysShortRegex;
proto$1.weekdaysMinRegex    =        weekdaysMinRegex;

// Hours
proto$1.isPM = localeIsPM;
proto$1.meridiem = localeMeridiem;

function get$1 (format, index, field, setter) {
    var locale = getLocale();
    var utc = createUTC().set(setter, index);
    return locale[field](utc, format);
}

function listMonthsImpl (format, index, field) {
    if (isNumber(format)) {
        index = format;
        format = undefined;
    }

    format = format || '';

    if (index != null) {
        return get$1(format, index, field, 'month');
    }

    var i;
    var out = [];
    for (i = 0; i < 12; i++) {
        out[i] = get$1(format, i, field, 'month');
    }
    return out;
}

// ()
// (5)
// (fmt, 5)
// (fmt)
// (true)
// (true, 5)
// (true, fmt, 5)
// (true, fmt)
function listWeekdaysImpl (localeSorted, format, index, field) {
    if (typeof localeSorted === 'boolean') {
        if (isNumber(format)) {
            index = format;
            format = undefined;
        }

        format = format || '';
    } else {
        format = localeSorted;
        index = format;
        localeSorted = false;

        if (isNumber(format)) {
            index = format;
            format = undefined;
        }

        format = format || '';
    }

    var locale = getLocale(),
        shift = localeSorted ? locale._week.dow : 0;

    if (index != null) {
        return get$1(format, (index + shift) % 7, field, 'day');
    }

    var i;
    var out = [];
    for (i = 0; i < 7; i++) {
        out[i] = get$1(format, (i + shift) % 7, field, 'day');
    }
    return out;
}

function listMonths (format, index) {
    return listMonthsImpl(format, index, 'months');
}

function listMonthsShort (format, index) {
    return listMonthsImpl(format, index, 'monthsShort');
}

function listWeekdays (localeSorted, format, index) {
    return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
}

function listWeekdaysShort (localeSorted, format, index) {
    return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
}

function listWeekdaysMin (localeSorted, format, index) {
    return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
}

getSetGlobalLocale('en', {
    dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
    ordinal : function (number) {
        var b = number % 10,
            output = (toInt(number % 100 / 10) === 1) ? 'th' :
            (b === 1) ? 'st' :
            (b === 2) ? 'nd' :
            (b === 3) ? 'rd' : 'th';
        return number + output;
    }
});

// Side effect imports
hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);
hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);

var mathAbs = Math.abs;

function abs () {
    var data           = this._data;

    this._milliseconds = mathAbs(this._milliseconds);
    this._days         = mathAbs(this._days);
    this._months       = mathAbs(this._months);

    data.milliseconds  = mathAbs(data.milliseconds);
    data.seconds       = mathAbs(data.seconds);
    data.minutes       = mathAbs(data.minutes);
    data.hours         = mathAbs(data.hours);
    data.months        = mathAbs(data.months);
    data.years         = mathAbs(data.years);

    return this;
}

function addSubtract$1 (duration, input, value, direction) {
    var other = createDuration(input, value);

    duration._milliseconds += direction * other._milliseconds;
    duration._days         += direction * other._days;
    duration._months       += direction * other._months;

    return duration._bubble();
}

// supports only 2.0-style add(1, 's') or add(duration)
function add$1 (input, value) {
    return addSubtract$1(this, input, value, 1);
}

// supports only 2.0-style subtract(1, 's') or subtract(duration)
function subtract$1 (input, value) {
    return addSubtract$1(this, input, value, -1);
}

function absCeil (number) {
    if (number < 0) {
        return Math.floor(number);
    } else {
        return Math.ceil(number);
    }
}

function bubble () {
    var milliseconds = this._milliseconds;
    var days         = this._days;
    var months       = this._months;
    var data         = this._data;
    var seconds, minutes, hours, years, monthsFromDays;

    // if we have a mix of positive and negative values, bubble down first
    // check: https://github.com/moment/moment/issues/2166
    if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||
            (milliseconds <= 0 && days <= 0 && months <= 0))) {
        milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
        days = 0;
        months = 0;
    }

    // The following code bubbles up values, see the tests for
    // examples of what that means.
    data.milliseconds = milliseconds % 1000;

    seconds           = absFloor(milliseconds / 1000);
    data.seconds      = seconds % 60;

    minutes           = absFloor(seconds / 60);
    data.minutes      = minutes % 60;

    hours             = absFloor(minutes / 60);
    data.hours        = hours % 24;

    days += absFloor(hours / 24);

    // convert days to months
    monthsFromDays = absFloor(daysToMonths(days));
    months += monthsFromDays;
    days -= absCeil(monthsToDays(monthsFromDays));

    // 12 months -> 1 year
    years = absFloor(months / 12);
    months %= 12;

    data.days   = days;
    data.months = months;
    data.years  = years;

    return this;
}

function daysToMonths (days) {
    // 400 years have 146097 days (taking into account leap year rules)
    // 400 years have 12 months === 4800
    return days * 4800 / 146097;
}

function monthsToDays (months) {
    // the reverse of daysToMonths
    return months * 146097 / 4800;
}

function as (units) {
    if (!this.isValid()) {
        return NaN;
    }
    var days;
    var months;
    var milliseconds = this._milliseconds;

    units = normalizeUnits(units);

    if (units === 'month' || units === 'year') {
        days   = this._days   + milliseconds / 864e5;
        months = this._months + daysToMonths(days);
        return units === 'month' ? months : months / 12;
    } else {
        // handle milliseconds separately because of floating point math errors (issue #1867)
        days = this._days + Math.round(monthsToDays(this._months));
        switch (units) {
            case 'week'   : return days / 7     + milliseconds / 6048e5;
            case 'day'    : return days         + milliseconds / 864e5;
            case 'hour'   : return days * 24    + milliseconds / 36e5;
            case 'minute' : return days * 1440  + milliseconds / 6e4;
            case 'second' : return days * 86400 + milliseconds / 1000;
            // Math.floor prevents floating point math errors here
            case 'millisecond': return Math.floor(days * 864e5) + milliseconds;
            default: throw new Error('Unknown unit ' + units);
        }
    }
}

// TODO: Use this.as('ms')?
function valueOf$1 () {
    if (!this.isValid()) {
        return NaN;
    }
    return (
        this._milliseconds +
        this._days * 864e5 +
        (this._months % 12) * 2592e6 +
        toInt(this._months / 12) * 31536e6
    );
}

function makeAs (alias) {
    return function () {
        return this.as(alias);
    };
}

var asMilliseconds = makeAs('ms');
var asSeconds      = makeAs('s');
var asMinutes      = makeAs('m');
var asHours        = makeAs('h');
var asDays         = makeAs('d');
var asWeeks        = makeAs('w');
var asMonths       = makeAs('M');
var asYears        = makeAs('y');

function clone$1 () {
    return createDuration(this);
}

function get$2 (units) {
    units = normalizeUnits(units);
    return this.isValid() ? this[units + 's']() : NaN;
}

function makeGetter(name) {
    return function () {
        return this.isValid() ? this._data[name] : NaN;
    };
}

var milliseconds = makeGetter('milliseconds');
var seconds      = makeGetter('seconds');
var minutes      = makeGetter('minutes');
var hours        = makeGetter('hours');
var days         = makeGetter('days');
var months       = makeGetter('months');
var years        = makeGetter('years');

function weeks () {
    return absFloor(this.days() / 7);
}

var round = Math.round;
var thresholds = {
    ss: 44,         // a few seconds to seconds
    s : 45,         // seconds to minute
    m : 45,         // minutes to hour
    h : 22,         // hours to day
    d : 26,         // days to month
    M : 11          // months to year
};

// helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
    return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
}

function relativeTime$1 (posNegDuration, withoutSuffix, locale) {
    var duration = createDuration(posNegDuration).abs();
    var seconds  = round(duration.as('s'));
    var minutes  = round(duration.as('m'));
    var hours    = round(duration.as('h'));
    var days     = round(duration.as('d'));
    var months   = round(duration.as('M'));
    var years    = round(duration.as('y'));

    var a = seconds <= thresholds.ss && ['s', seconds]  ||
            seconds < thresholds.s   && ['ss', seconds] ||
            minutes <= 1             && ['m']           ||
            minutes < thresholds.m   && ['mm', minutes] ||
            hours   <= 1             && ['h']           ||
            hours   < thresholds.h   && ['hh', hours]   ||
            days    <= 1             && ['d']           ||
            days    < thresholds.d   && ['dd', days]    ||
            months  <= 1             && ['M']           ||
            months  < thresholds.M   && ['MM', months]  ||
            years   <= 1             && ['y']           || ['yy', years];

    a[2] = withoutSuffix;
    a[3] = +posNegDuration > 0;
    a[4] = locale;
    return substituteTimeAgo.apply(null, a);
}

// This function allows you to set the rounding function for relative time strings
function getSetRelativeTimeRounding (roundingFunction) {
    if (roundingFunction === undefined) {
        return round;
    }
    if (typeof(roundingFunction) === 'function') {
        round = roundingFunction;
        return true;
    }
    return false;
}

// This function allows you to set a threshold for relative time strings
function getSetRelativeTimeThreshold (threshold, limit) {
    if (thresholds[threshold] === undefined) {
        return false;
    }
    if (limit === undefined) {
        return thresholds[threshold];
    }
    thresholds[threshold] = limit;
    if (threshold === 's') {
        thresholds.ss = limit - 1;
    }
    return true;
}

function humanize (withSuffix) {
    if (!this.isValid()) {
        return this.localeData().invalidDate();
    }

    var locale = this.localeData();
    var output = relativeTime$1(this, !withSuffix, locale);

    if (withSuffix) {
        output = locale.pastFuture(+this, output);
    }

    return locale.postformat(output);
}

var abs$1 = Math.abs;

function sign(x) {
    return ((x > 0) - (x < 0)) || +x;
}

function toISOString$1() {
    // for ISO strings we do not use the normal bubbling rules:
    //  * milliseconds bubble up until they become hours
    //  * days do not bubble at all
    //  * months bubble up until they become years
    // This is because there is no context-free conversion between hours and days
    // (think of clock changes)
    // and also not between days and months (28-31 days per month)
    if (!this.isValid()) {
        return this.localeData().invalidDate();
    }

    var seconds = abs$1(this._milliseconds) / 1000;
    var days         = abs$1(this._days);
    var months       = abs$1(this._months);
    var minutes, hours, years;

    // 3600 seconds -> 60 minutes -> 1 hour
    minutes           = absFloor(seconds / 60);
    hours             = absFloor(minutes / 60);
    seconds %= 60;
    minutes %= 60;

    // 12 months -> 1 year
    years  = absFloor(months / 12);
    months %= 12;


    // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
    var Y = years;
    var M = months;
    var D = days;
    var h = hours;
    var m = minutes;
    var s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, '') : '';
    var total = this.asSeconds();

    if (!total) {
        // this is the same as C#'s (Noda) and python (isodate)...
        // but not other JS (goog.date)
        return 'P0D';
    }

    var totalSign = total < 0 ? '-' : '';
    var ymSign = sign(this._months) !== sign(total) ? '-' : '';
    var daysSign = sign(this._days) !== sign(total) ? '-' : '';
    var hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';

    return totalSign + 'P' +
        (Y ? ymSign + Y + 'Y' : '') +
        (M ? ymSign + M + 'M' : '') +
        (D ? daysSign + D + 'D' : '') +
        ((h || m || s) ? 'T' : '') +
        (h ? hmsSign + h + 'H' : '') +
        (m ? hmsSign + m + 'M' : '') +
        (s ? hmsSign + s + 'S' : '');
}

var proto$2 = Duration.prototype;

proto$2.isValid        = isValid$1;
proto$2.abs            = abs;
proto$2.add            = add$1;
proto$2.subtract       = subtract$1;
proto$2.as             = as;
proto$2.asMilliseconds = asMilliseconds;
proto$2.asSeconds      = asSeconds;
proto$2.asMinutes      = asMinutes;
proto$2.asHours        = asHours;
proto$2.asDays         = asDays;
proto$2.asWeeks        = asWeeks;
proto$2.asMonths       = asMonths;
proto$2.asYears        = asYears;
proto$2.valueOf        = valueOf$1;
proto$2._bubble        = bubble;
proto$2.clone          = clone$1;
proto$2.get            = get$2;
proto$2.milliseconds   = milliseconds;
proto$2.seconds        = seconds;
proto$2.minutes        = minutes;
proto$2.hours          = hours;
proto$2.days           = days;
proto$2.weeks          = weeks;
proto$2.months         = months;
proto$2.years          = years;
proto$2.humanize       = humanize;
proto$2.toISOString    = toISOString$1;
proto$2.toString       = toISOString$1;
proto$2.toJSON         = toISOString$1;
proto$2.locale         = locale;
proto$2.localeData     = localeData;

// Deprecations
proto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);
proto$2.lang = lang;

// Side effect imports

// FORMATTING

addFormatToken('X', 0, 0, 'unix');
addFormatToken('x', 0, 0, 'valueOf');

// PARSING

addRegexToken('x', matchSigned);
addRegexToken('X', matchTimestamp);
addParseToken('X', function (input, array, config) {
    config._d = new Date(parseFloat(input, 10) * 1000);
});
addParseToken('x', function (input, array, config) {
    config._d = new Date(toInt(input));
});

// Side effect imports


hooks.version = '2.20.1';

setHookCallback(createLocal);

hooks.fn                    = proto;
hooks.min                   = min;
hooks.max                   = max;
hooks.now                   = now;
hooks.utc                   = createUTC;
hooks.unix                  = createUnix;
hooks.months                = listMonths;
hooks.isDate                = isDate;
hooks.locale                = getSetGlobalLocale;
hooks.invalid               = createInvalid;
hooks.duration              = createDuration;
hooks.isMoment              = isMoment;
hooks.weekdays              = listWeekdays;
hooks.parseZone             = createInZone;
hooks.localeData            = getLocale;
hooks.isDuration            = isDuration;
hooks.monthsShort           = listMonthsShort;
hooks.weekdaysMin           = listWeekdaysMin;
hooks.defineLocale          = defineLocale;
hooks.updateLocale          = updateLocale;
hooks.locales               = listLocales;
hooks.weekdaysShort         = listWeekdaysShort;
hooks.normalizeUnits        = normalizeUnits;
hooks.relativeTimeRounding  = getSetRelativeTimeRounding;
hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
hooks.calendarFormat        = getCalendarFormat;
hooks.prototype             = proto;

// currently HTML5 input type only supports 24-hour formats
hooks.HTML5_FMT = {
    DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm',             // <input type="datetime-local" />
    DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss',  // <input type="datetime-local" step="1" />
    DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS',   // <input type="datetime-local" step="0.001" />
    DATE: 'YYYY-MM-DD',                             // <input type="date" />
    TIME: 'HH:mm',                                  // <input type="time" />
    TIME_SECONDS: 'HH:mm:ss',                       // <input type="time" step="1" />
    TIME_MS: 'HH:mm:ss.SSS',                        // <input type="time" step="0.001" />
    WEEK: 'YYYY-[W]WW',                             // <input type="week" />
    MONTH: 'YYYY-MM'                                // <input type="month" />
};

return hooks;

})));

},{}],390:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],391:[function(require,module,exports){
module.exports = require('./lib/index');

},{"./lib/index":392}],392:[function(require,module,exports){
(function (global){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _ponyfill = require('./ponyfill.js');

var _ponyfill2 = _interopRequireDefault(_ponyfill);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var root; /* global window */


if (typeof self !== 'undefined') {
  root = self;
} else if (typeof window !== 'undefined') {
  root = window;
} else if (typeof global !== 'undefined') {
  root = global;
} else if (typeof module !== 'undefined') {
  root = module;
} else {
  root = Function('return this')();
}

var result = (0, _ponyfill2['default'])(root);
exports['default'] = result;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./ponyfill.js":393}],393:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports['default'] = symbolObservablePonyfill;
function symbolObservablePonyfill(root) {
	var result;
	var _Symbol = root.Symbol;

	if (typeof _Symbol === 'function') {
		if (_Symbol.observable) {
			result = _Symbol.observable;
		} else {
			result = _Symbol('observable');
			_Symbol.observable = result;
		}
	} else {
		result = '@@observable';
	}

	return result;
};
},{}],394:[function(require,module,exports){
(function (process){
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

'use strict';

/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var warning = function() {};

if (process.env.NODE_ENV !== 'production') {
  warning = function(condition, format, args) {
    var len = arguments.length;
    args = new Array(len > 2 ? len - 2 : 0);
    for (var key = 2; key < len; key++) {
      args[key - 2] = arguments[key];
    }
    if (format === undefined) {
      throw new Error(
        '`warning(condition, format, ...args)` requires a warning ' +
        'message argument'
      );
    }

    if (format.length < 10 || (/^[s\W]*$/).test(format)) {
      throw new Error(
        'The warning format should be able to uniquely identify this ' +
        'warning. Please, use a more descriptive format than: ' + format
      );
    }

    if (!condition) {
      var argIndex = 0;
      var message = 'Warning: ' +
        format.replace(/%s/g, function() {
          return args[argIndex++];
        });
      if (typeof console !== 'undefined') {
        console.error(message);
      }
      try {
        // This error was thrown as a convenience so that you can use this stack
        // to find the callsite that caused this warning to fire.
        throw new Error(message);
      } catch(x) {}
    }
  };
}

module.exports = warning;

}).call(this,require('_process'))

},{"_process":390}],395:[function(require,module,exports){
module.exports={
  "name": "@kynikos/wiki-monkey",
  "version": "4.1.0",
  "author": "Dario Giovannetti",
  "description": "MediaWiki bot and editor-assistant user script.",
  "license": "GPL-3.0",
  "repository": {
    "type": "git",
    "url": "https://github.com/kynikos/wiki-monkey.git"
  },
  "keywords": [
    "wiki mediawiki bot"
  ],
  "dependencies": {
    "@kynikos/misc": "^0.1.3",
    "babel-polyfill": "^6.26.0",
    "hyperscript": "^2.0.2",
    "hyperscript-helpers": "^3.0.3",
    "jss": "^9.5.1",
    "jss-preset-default": "^4.1.0",
    "moment": "^2.20.1"
  },
  "devDependencies": {
    "@kynikos/browserify-helpers": "^1.0.8",
    "babel-core": "^6.26.0",
    "babel-preset-env": "^1.6.1",
    "coffeelint": "^2.0.7",
    "coffeescript": "^2.1.1",
    "http-server": "^0.11.1"
  }
}

},{}],396:[function(require,module,exports){
"use strict";

var WM;

var _require = require('./modules/_Init');

WM = _require.WM;

new WM("ArchWiki", require("./plugins/ArchWikiFixHeader"), require("./plugins/ArchWikiFixHeadings"), require("./plugins/ArchWikiFixLinks"), require("./plugins/ArchWikiNewTemplates"), require("./plugins/ArchWikiNPFilter"), require("./plugins/ArchWikiRCFilter"), require("./plugins/ArchWikiSaveTalk"), require("./plugins/ArchWikiSortContacts"), require("./plugins/ArchWikiWantedCategories"), require("./plugins/DeletePages"), require("./plugins/ExpandContractions"), require("./plugins/FixBacklinkFragments"), require("./plugins/FixDoubleRedirects"), require("./plugins/FixFragments"), require("./plugins/FixLinkFragments"), require("./plugins/MultipleLineBreaks"), require("./plugins/SimpleReplace"), require("./plugins/SynchronizeInterlanguageLinks"), require("./plugins/UpdateCategoryTree"));

},{"./modules/_Init":414,"./plugins/ArchWikiFixHeader":416,"./plugins/ArchWikiFixHeadings":417,"./plugins/ArchWikiFixLinks":418,"./plugins/ArchWikiNPFilter":419,"./plugins/ArchWikiNewTemplates":420,"./plugins/ArchWikiRCFilter":421,"./plugins/ArchWikiSaveTalk":422,"./plugins/ArchWikiSortContacts":423,"./plugins/ArchWikiWantedCategories":424,"./plugins/DeletePages":425,"./plugins/ExpandContractions":426,"./plugins/FixBacklinkFragments":427,"./plugins/FixDoubleRedirects":428,"./plugins/FixFragments":429,"./plugins/FixLinkFragments":430,"./plugins/MultipleLineBreaks":431,"./plugins/SimpleReplace":432,"./plugins/SynchronizeInterlanguageLinks":433,"./plugins/UpdateCategoryTree":434}],397:[function(require,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

module.exports = function () {
  var languages, tablesOfContents;

  var exports = function () {
    function exports(WM) {
      _classCallCheck(this, exports);

      this.WM = WM;
    }

    _createClass(exports, [{
      key: "getLocalLanguage",
      value: function getLocalLanguage() {
        return languages.local;
      }
    }, {
      key: "getCategoryLanguages",
      value: function getCategoryLanguages() {
        return languages.categories;
      }
    }, {
      key: "isCategoryLanguage",
      value: function isCategoryLanguage(lang) {
        return languages.categories.indexOf(lang) > -1;
      }
    }, {
      key: "getInterwikiLanguages",
      value: function getInterwikiLanguages() {
        return languages.interlanguage.external.concat(languages.interlanguage.internal);
      }
    }, {
      key: "isInterwikiLanguage",
      value: function isInterwikiLanguage(lang) {
        return this.getInterwikiLanguages().indexOf(lang) > -1;
      }
    }, {
      key: "getInternalInterwikiLanguages",
      value: function getInternalInterwikiLanguages() {
        return languages.interlanguage.internal;
      }
    }, {
      key: "isInternalInterwikiLanguage",
      value: function isInternalInterwikiLanguage(lang) {
        return languages.interlanguage.internal.indexOf(lang) > -1;
      }
    }, {
      key: "getInterlanguageTag",
      value: function getInterlanguageTag(language) {
        return languages.names[language].subtag;
      }
    }, {
      key: "detectLanguage",
      value: function detectLanguage(title) {
        var detectedLanguage, matches, pureTitle, testLangCat;
        matches = title.match(/^(.+?)(?:[ _]\(([^\(]+)\))?$/);
        pureTitle = matches[1];
        detectedLanguage = matches[2];
        if (!detectedLanguage || !this.isCategoryLanguage(detectedLanguage)) {
          testLangCat = matches[1].match(/^[ _]*[Cc]ategory[ _]*:[ _]*(.+?)[ _]*$/);
          if (testLangCat && this.isCategoryLanguage(testLangCat[1])) {
            detectedLanguage = testLangCat[1];
            pureTitle = matches[1];
          } else {
            detectedLanguage = this.getLocalLanguage();
            pureTitle = matches[0];
          }
        }
        return [pureTitle, detectedLanguage];
      }
    }, {
      key: "findAllInterlanguageLinks",
      value: function findAllInterlanguageLinks(source) {
        return this.WM.Parser.findSpecialLinks(source, this.getInterwikiLanguages().join("|"));
      }
    }, {
      key: "findInternalInterlanguageLinks",
      value: function findInternalInterlanguageLinks(source) {
        return this.WM.Parser.findSpecialLinks(source, this.getInternalInterwikiLanguages().join("|"));
      }
    }, {
      key: "getTableOfContents",
      value: function getTableOfContents(tag) {
        return tablesOfContents[tag];
      }
    }]);

    return exports;
  }();

  ;

  languages = {
    local: "English",
    names: {
      "العربية": {
        subtag: "ar",
        english: "Arabic"
      },
      "Български": {
        subtag: "bg",
        english: "Bulgarian"
      },
      "Català": {
        subtag: "ca",
        english: "Catalan"
      },
      "Česky": {
        subtag: "cs",
        english: "Czech"
      },
      "Dansk": {
        subtag: "da",
        english: "Danish"
      },
      "Deutsch": {
        subtag: "de",
        english: "German"
      },
      "Ελληνικά": {
        subtag: "el",
        english: "Greek"
      },
      "English": {
        subtag: "en",
        english: "English"
      },
      "Esperanto": {
        subtag: "eo",
        english: "Esperanto"
      },
      "Español": {
        subtag: "es",
        english: "Spanish"
      },
      "فارسی": {
        subtag: "fa",
        english: "Persian"
      },
      "Suomi": {
        subtag: "fi",
        english: "Finnish"
      },
      "Français": {
        subtag: "fr",
        english: "French"
      },
      "עברית": {
        subtag: "he",
        english: "Hebrew"
      },
      "Hrvatski": {
        subtag: "hr",
        english: "Croatian"
      },
      "Magyar": {
        subtag: "hu",
        english: "Hungarian"
      },
      "Indonesia": {
        subtag: "id",
        english: "Indonesian"
      },
      "Italiano": {
        subtag: "it",
        english: "Italian"
      },
      "日本語": {
        subtag: "ja",
        english: "Japanese"
      },
      "한국어": {
        subtag: "ko",
        english: "Korean"
      },
      "Lietuviškai": {
        subtag: "lt",
        english: "Lithuanian"
      },
      "Norsk Bokmål": {
        subtag: "nb",
        english: "Norwegian (Bokmål)"
      },
      "Nederlands": {
        subtag: "nl",
        english: "Dutch"
      },
      "Polski": {
        subtag: "pl",
        english: "Polish"
      },
      "Português": {
        subtag: "pt",
        english: "Portuguese"
      },
      "Română": {
        subtag: "ro",
        english: "Romanian"
      },
      "Русский": {
        subtag: "ru",
        english: "Russian"
      },
      "Slovenský": {
        subtag: "sk",
        english: "Slovak"
      },
      "Српски": {
        subtag: "sr",
        english: "Serbian"
      },
      "Svenska": {
        subtag: "sv",
        english: "Swedish"
      },
      "ไทย": {
        subtag: "th",
        english: "Thai"
      },
      "Türkçe": {
        subtag: "tr",
        english: "Turkish"
      },
      "Українська": {
        subtag: "uk",
        english: "Ukrainian"
      },
      "Tiếng Việt": {
        subtag: "vi",
        english: "Vietnamese"
      },
      "简体中文": {
        subtag: "zh-hans",
        english: "Chinese (Simplified)"
      },
      "正體中文": {
        subtag: "zh-hant",
        english: "Chinese (Traditional)"
      }
    },
    categories: ["العربية", "Български", "Català", "Česky", "Dansk", "Ελληνικά", "English", "Esperanto", "Español", "Suomi", "עברית", "Hrvatski", "Magyar", "Indonesia", "Italiano", "日本語", "한국어", "Lietuviškai", "Norsk Bokmål", "Nederlands", "Polski", "Português", "Русский", "Slovenský", "Српски", "ไทย", "Türkçe", "Українська", "简体中文", "正體中文"],
    interlanguage: {
      external: ["de", "fa", "fr", "ja", "ro"],
      internal: ["ar", "bg", "cs", "da", "el", "en", "es", "fi", "he", "hr", "hu", "id", "it", "ko", "lt", "nl", "pl", "pt", "ru", "sk", "sr", "sv", "th", "tr", "uk", "zh-hans", "zh-hant"]
    }
  };

  tablesOfContents = {
    "ar": {
      "page": "Table of contents (العربية)",
      "root": "Category:العربية",
      "alsoIn": "also in",
      "indentType": ":",
      "replace": ["[ _]\\(العربية\\)", "", ""],
      "keepAltName": true,
      "showIndices": true,
      "rightToLeft": true
    },
    "bg": {
      "page": "Table of contents (Български)",
      "root": "Category:Български",
      "alsoIn": "също в",
      "indentType": ":",
      "replace": ["[ _]\\(Български\\)", "", ""],
      "keepAltName": true,
      "showIndices": true,
      "rightToLeft": false
    },
    "cs": {
      "page": "Table of contents (Česky)",
      "root": "Category:Česky",
      "alsoIn": "také v",
      "indentType": ":",
      "replace": ["[ _]\\(Česky\\)", "", ""],
      "keepAltName": true,
      "showIndices": true,
      "rightToLeft": false
    },
    "da": {
      "page": "Table of contents (Dansk)",
      "root": "Category:Dansk",
      "alsoIn": "også i",
      "indentType": ":",
      "replace": ["[ _]\\(Dansk\\)", "", ""],
      "keepAltName": true,
      "showIndices": true,
      "rightToLeft": false
    },
    "el": {
      "page": "Table of contents (Ελληνικά)",
      "root": "Category:Ελληνικά",
      "alsoIn": "επίσης σε",
      "indentType": ":",
      "replace": ["[ _]\\(Ελληνικά\\)", "", ""],
      "keepAltName": true,
      "showIndices": true,
      "rightToLeft": false
    },
    "en": {
      "page": "Table of contents",
      "root": "Category:English",
      "alsoIn": "also in",
      "indentType": ":",
      "replace": null,
      "keepAltName": false,
      "showIndices": true,
      "rightToLeft": false
    },
    "es": {
      "page": "Table of contents (Español)",
      "root": "Category:Español",
      "alsoIn": "también en",
      "indentType": ":",
      "replace": ["[ _]\\(Español\\)", "", ""],
      "keepAltName": true,
      "showIndices": true,
      "rightToLeft": false
    },
    "he": {
      "page": "Table of contents (עברית)",
      "root": "Category:עברית",
      "alsoIn": "also in",
      "indentType": ":",
      "replace": ["[ _]\\(עברית\\)", "", ""],
      "keepAltName": true,
      "showIndices": true,
      "rightToLeft": true
    },
    "hr": {
      "page": "Table of contents (Hrvatski)",
      "root": "Category:Hrvatski",
      "alsoIn": "također u",
      "indentType": ":",
      "replace": ["[ _]\\(Hrvatski\\)", "", ""],
      "keepAltName": true,
      "showIndices": true,
      "rightToLeft": false
    },
    "hu": {
      "page": "Table of contents (Magyar)",
      "root": "Category:Magyar",
      "alsoIn": "is",
      "indentType": ":",
      "replace": ["[ _]\\(Magyar\\)", "", ""],
      "keepAltName": true,
      "showIndices": true,
      "rightToLeft": false
    },
    "id": {
      "page": "Table of contents (Indonesia)",
      "root": "Category:Indonesia",
      "alsoIn": "juga di",
      "indentType": ":",
      "replace": ["[ _]\\(Indonesia\\)", "", ""],
      "keepAltName": true,
      "showIndices": true,
      "rightToLeft": false
    },
    "it": {
      "page": "Table of contents (Italiano)",
      "root": "Category:Italiano",
      "alsoIn": "anche in",
      "indentType": ":",
      "replace": ["[ _]\\(Italiano\\)", "", ""],
      "keepAltName": true,
      "showIndices": true,
      "rightToLeft": false
    },
    "ko": {
      "page": "Table of contents (한국어)",
      "root": "Category:한국어",
      "alsoIn": "또한 에",
      "indentType": ":",
      "replace": ["[ _]\\(한국어\\)", "", ""],
      "keepAltName": true,
      "showIndices": true,
      "rightToLeft": false
    },
    "lt": {
      "page": "Table of contents (Lietuviškai)",
      "root": "Category:Lietuviškai",
      "alsoIn": "taip pat ir",
      "indentType": ":",
      "replace": ["[ _]\\(Lietuviškai\\)", "", ""],
      "keepAltName": true,
      "showIndices": true,
      "rightToLeft": false
    },
    "nl": {
      "page": "Table of contents (Nederlands)",
      "root": "Category:Nederlands",
      "alsoIn": "ook in",
      "indentType": ":",
      "replace": ["[ _]\\(Nederlands\\)", "", ""],
      "keepAltName": true,
      "showIndices": true,
      "rightToLeft": false
    },
    "pl": {
      "page": "Table of contents (Polski)",
      "root": "Category:Polski",
      "alsoIn": "również w",
      "indentType": ":",
      "replace": ["[ _]\\(Polski\\)", "", ""],
      "keepAltName": true,
      "showIndices": true,
      "rightToLeft": false
    },
    "pt": {
      "page": "Table of contents (Português)",
      "root": "Category:Português",
      "alsoIn": "também em",
      "indentType": ":",
      "replace": ["[ _]\\(Português\\)", "", ""],
      "keepAltName": true,
      "showIndices": true,
      "rightToLeft": false
    },
    "ru": {
      "page": "Table of contents (Русский)",
      "root": "Category:Русский",
      "alsoIn": "Также в",
      "indentType": ":",
      "replace": ["[ _]\\(Русский\\)", "", ""],
      "keepAltName": true,
      "showIndices": true,
      "rightToLeft": false
    },
    "sk": {
      "page": "Table of contents (Slovenský)",
      "root": "Category:Slovenský",
      "alsoIn": "tiež v",
      "indentType": ":",
      "replace": ["[ _]\\(Slovenský\\)", "", ""],
      "keepAltName": true,
      "showIndices": true,
      "rightToLeft": false
    },
    "sr": {
      "page": "Table of contents (Српски)",
      "root": "Category:Српски",
      "alsoIn": "такође у",
      "indentType": ":",
      "replace": ["[ _]\\(Српски\\)", "", ""],
      "keepAltName": true,
      "showIndices": true,
      "rightToLeft": false
    },
    "th": {
      "page": "Table of contents (ไทย)",
      "root": "Category:ไทย",
      "alsoIn": "ยังอยู่ใน",
      "indentType": ":",
      "replace": ["[ _]\\(ไทย\\)", "", ""],
      "keepAltName": true,
      "showIndices": true,
      "rightToLeft": false
    },
    "tr": {
      "page": "Table of contents (Türkçe)",
      "root": "Category:Türkçe",
      "alsoIn": "ayrıca",
      "indentType": ":",
      "replace": ["[ _]\\(Türkçe\\)", "", ""],
      "keepAltName": true,
      "showIndices": true,
      "rightToLeft": false
    },
    "uk": {
      "page": "Table of contents (Українська)",
      "root": "Category:Українська",
      "alsoIn": "також в",
      "indentType": ":",
      "replace": ["[ _]\\(Українська\\)", "", ""],
      "keepAltName": true,
      "showIndices": true,
      "rightToLeft": false
    },
    "zh-hans": {
      "page": "Table of contents (简体中文)",
      "root": "Category:简体中文",
      "alsoIn": "同时还属于",
      "indentType": ":",
      "replace": ["[ _]\\(简体中文\\)", "", ""],
      "keepAltName": true,
      "showIndices": true,
      "rightToLeft": false
    },
    "zh-hant": {
      "page": "Table of contents (正體中文)",
      "root": "Category:正體中文",
      "alsoIn": "還在",
      "indentType": ":",
      "replace": ["[ _]\\(正體中文\\)", "", ""],
      "keepAltName": true,
      "showIndices": true,
      "rightToLeft": false
    }
  };

  return exports;
}.call(undefined);

},{}],398:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var CSS;

CSS = require('@kynikos/misc/dist/CSS');

module.exports = function () {
  function exports(WM) {
    _classCallCheck(this, exports);

    this._previewFilter = this._previewFilter.bind(this);
    this._startAutomatic = this._startAutomatic.bind(this);
    this._startAutomaticContinue = this._startAutomaticContinue.bind(this);
    this.WM = WM;
    this.configuration = {
      plugin_name: null,
      function_: function function_() {},
      filters: [],
      list: {
        current: null,
        previous: null
      },
      visited: []
    };

    this.botToken = "0";
  }

  _createClass(exports, [{
    key: '_makeUI',
    value: function _makeUI(functions, lists) {
      var divContainer, fdiv;
      divContainer = document.createElement('div');
      divContainer.id = 'WikiMonkeyBot';
      CSS.addStyleElement("#WikiMonkeyBot-PluginSelect {width:100%; margin-bottom:1em;} #WikiMonkeyBot-ListSelect {margin-bottom:1em;} #WikiMonkeyBotFilter {height:6em; margin-bottom:1em; resize:vertical;} #WikiMonkeyBotStart, #WikiMonkeyBotStop {margin-right:0.33em; margin-bottom:1em; font-weight:bold;} a.WikiMonkeyBotSelected {background-color:#faa; padding:0.2em 0.4em;} a.WikiMonkeyBotProcessing {background-color:#ff8; padding:0.2em 0.4em;} a.WikiMonkeyBotChanged {background-color:#afa; padding:0.2em 0.4em;} a.WikiMonkeyBotUnchanged {background-color:#aaf; padding:0.2em 0.4em;} a.WikiMonkeyBotBypassed {background-color:orangered; padding:0.2em 0.4em;} a.WikiMonkeyBotFailed {background-color:red; padding:0.2em 0.4em;}");
      fdiv = this.makeFunctionUI(functions);
      if (fdiv) {
        divContainer.appendChild(fdiv);
        divContainer.appendChild(this.makeConfUI(lists));
        return divContainer;
      } else {
        return false;
      }
    }
  }, {
    key: 'makeFunctionUI',
    value: function makeFunctionUI(functions) {
      var Plugin, divFunction, ffunctions, fieldset, i, legend, len, makeUI, option, plugin, pluginInst, selectFunctions, self;
      self = this;
      fieldset = document.createElement('fieldset');
      legend = document.createElement('legend');
      legend.innerHTML = 'Plugin';
      selectFunctions = document.createElement('select');
      selectFunctions.id = 'WikiMonkeyBot-PluginSelect';
      ffunctions = [];
      for (i = 0, len = functions.length; i < len; i++) {
        Plugin = functions[i];
        plugin = new Plugin(this.WM);
        pluginInst = plugin.conf.bot_label;

        if (!pluginInst || !pluginInst.length) {
          continue;
        }
        ffunctions.push(plugin);
        option = document.createElement('option');
        option.innerHTML = pluginInst;
        if (plugin.constructor.name === this.WM.conf.default_bot_plugin) {
          option.selected = true;
        }
        selectFunctions.appendChild(option);
      }
      if (ffunctions.length) {
        selectFunctions.addEventListener("change", function (ffunctions) {
          return function () {
            var UI, id, makeUI, select;
            select = document.getElementById('WikiMonkeyBot-PluginSelect');
            id = select.selectedIndex;
            UI = document.getElementById('WikiMonkeyBotFunction');
            plugin = ffunctions[id];

            makeUI = plugin.makeBotUI;
            if (makeUI instanceof Function) {
              UI.replaceChild(makeUI(), UI.firstChild);
            } else {
              UI.replaceChild(document.createElement('div'), UI.firstChild);
            }
            self.configuration.plugin_name = plugin.constructor.name;
            return self.configuration.function_ = function (title, callContinue, chainArgs) {
              return plugin.main_bot(title, callContinue, chainArgs);
            };
          };
        }(ffunctions), false);
        divFunction = document.createElement('div');
        divFunction.id = "WikiMonkeyBotFunction";
        plugin = ffunctions[selectFunctions.selectedIndex];

        makeUI = plugin.makeBotUI;
        if (makeUI instanceof Function) {
          divFunction.appendChild(makeUI());
        } else {
          divFunction.appendChild(document.createElement('div'));
        }
        this.configuration.plugin_name = plugin.constructor.name;
        this.configuration.function_ = function (title, callContinue, chainArgs) {
          return plugin.main_bot(title, callContinue, chainArgs);
        };
        fieldset.appendChild(legend);
        fieldset.appendChild(selectFunctions);
        fieldset.appendChild(divFunction);
        return fieldset;
      } else {
        return false;
      }
    }
  }, {
    key: 'makeListSelector',
    value: function makeListSelector(lists) {
      var i, len, list, option, selectLists, self;
      self = this;
      selectLists = document.createElement('select');
      selectLists.id = 'WikiMonkeyBot-ListSelect';
      for (i = 0, len = lists.length; i < len; i++) {
        list = lists[i];
        if (list[0]) {
          option = document.createElement('option');
          option.innerHTML = list[2];
          selectLists.appendChild(option);
          if (!this.configuration.list.current) {
            this.configuration.list.current = list;
          }
        }
      }
      selectLists.addEventListener("change", function (lss) {
        return function () {
          var id, select;
          select = document.getElementById('WikiMonkeyBot-ListSelect');
          id = select.selectedIndex;
          self.configuration.list.previous = self.configuration.list.current;

          return self.configuration.list.current = lss[id];
        };
      }(lists), false);
      return selectLists;
    }
  }, {
    key: 'makeConfUI',
    value: function makeConfUI(lists) {
      var bot, duplicates, duplicatestag, elem, elems, fieldset, filter, forceStart, forceStartCB, forceStartLabel, i, inverse, inversetag, legend, len, listSelect, preview, self, start, startMsg;
      self = this;
      bot = document.createElement('div');
      fieldset = document.createElement('fieldset');
      legend = document.createElement('legend');
      legend.innerHTML = 'Filter';
      listSelect = this.makeListSelector(lists);
      filter = document.createElement('textarea');
      filter.id = 'WikiMonkeyBotFilter';
      preview = document.createElement('input');
      preview.id = 'WikiMonkeyBotPreview';
      preview.type = 'button';
      preview.value = 'Preview';
      duplicates = document.createElement('input');
      duplicates.type = 'checkbox';
      duplicates.id = 'WikiMonkeyBotDuplicates';
      inverse = document.createElement('input');
      inverse.type = 'checkbox';
      inverse.id = 'WikiMonkeyBotInverse';
      elems = [filter, duplicates, inverse];
      for (i = 0, len = elems.length; i < len; i++) {
        elem = elems[i];
        elem.addEventListener("change", function () {
          return self._disableStartBot('Filters have changed, preview the selection');
        }, false);
      }
      duplicatestag = document.createElement('span');
      duplicatestag.innerHTML = 'Duplicates';
      inversetag = document.createElement('span');
      inversetag.innerHTML = 'Inverse';
      preview.addEventListener("click", this._previewFilter, false);
      fieldset.appendChild(legend);
      if (listSelect.length > 1) {
        fieldset.appendChild(listSelect);
      }
      fieldset.appendChild(filter);
      fieldset.appendChild(preview);
      fieldset.appendChild(duplicates);
      fieldset.appendChild(duplicatestag);
      fieldset.appendChild(inverse);
      fieldset.appendChild(inversetag);
      start = document.createElement('input');
      start.type = 'button';
      start.value = 'Start bot';
      start.id = 'WikiMonkeyBotStart';
      start.addEventListener("click", this._startAutomatic, false);
      start.disabled = true;
      startMsg = document.createElement('span');
      startMsg.innerHTML = 'Set and preview the filter first';
      startMsg.id = 'WikiMonkeyBotStartMsg';
      forceStart = document.createElement('span');
      forceStart.id = 'WikiMonkeyBotForceStart';
      forceStartCB = document.createElement('input');
      forceStartCB.type = 'checkbox';
      forceStartCB.disabled = true;
      forceStartLabel = document.createElement('span');
      forceStartLabel.innerHTML = 'Force start, stopping any other currently running bots';
      forceStart.style.display = "none";
      forceStart.appendChild(forceStartCB);
      forceStart.appendChild(forceStartLabel);
      bot.appendChild(fieldset);
      bot.appendChild(start);
      bot.appendChild(startMsg);
      bot.appendChild(forceStart);
      return bot;
    }
  }, {
    key: '_enableStartBot',
    value: function _enableStartBot() {
      document.getElementById('WikiMonkeyBotStartMsg').innerHTML = '';
      return document.getElementById('WikiMonkeyBotStart').disabled = false;
    }
  }, {
    key: '_disableStartBot',
    value: function _disableStartBot(message) {
      document.getElementById('WikiMonkeyBotStartMsg').innerHTML = message;
      return document.getElementById('WikiMonkeyBotStart').disabled = true;
    }
  }, {
    key: '_enableStopBot',
    value: function _enableStopBot(stopId) {
      var self, start, stop;
      self = this;
      stop = document.createElement('input');
      stop.type = 'button';
      stop.value = 'Stop bot';
      stop.id = 'WikiMonkeyBotStop';
      stop.addEventListener("click", function (id) {
        return function () {
          clearTimeout(id);

          self._disableStopBot();
          self._endAutomatic(true);
          return self.WM.Log.logInfo('Bot stopped manually');
        };
      }(stopId), false);
      start = document.getElementById('WikiMonkeyBotStart');
      start.parentNode.insertBefore(stop, start);
      return start.style.display = 'none';
    }
  }, {
    key: '_disableStopBot',
    value: function _disableStopBot() {
      var stop;
      stop = document.getElementById('WikiMonkeyBotStop');
      stop.parentNode.removeChild(stop);
      return document.getElementById('WikiMonkeyBotStart').style.display = 'inline';
    }
  }, {
    key: '_disableControls',
    value: function _disableControls() {
      return this._setEnableControls(true);
    }
  }, {
    key: '_reEnableControls',
    value: function _reEnableControls() {
      return this._setEnableControls(false);
    }
  }, {
    key: '_setEnableControls',
    value: function _setEnableControls(flag) {
      var fset, fsets, i, len, results;
      fsets = document.getElementById('WikiMonkeyBot').getElementsByTagName('fieldset');
      results = [];
      for (i = 0, len = fsets.length; i < len; i++) {
        fset = fsets[i];

        results.push(fset.disabled = flag);
      }
      return results;
    }
  }, {
    key: '_enableForceStart',
    value: function _enableForceStart() {
      var force;
      force = document.getElementById('WikiMonkeyBotForceStart');
      force.getElementsByTagName('input')[0].disabled = false;
      return force.style.display = 'inline';
    }
  }, {
    key: '_disableForceStart',
    value: function _disableForceStart() {
      var force;
      force = document.getElementById('WikiMonkeyBotForceStart');
      force.getElementsByTagName('input')[0].checked = false;
      force.getElementsByTagName('input')[0].disabled = true;
      return force.style.display = 'none';
    }
  }, {
    key: '_canForceStart',
    value: function _canForceStart() {
      return document.getElementById('WikiMonkeyBotForceStart').getElementsByTagName('input')[0].checked;
    }
  }, {
    key: 'makeFilters',
    value: function makeFilters() {
      var exc, filter, filters, firstSlash, i, lastSlash, len, modifiers, negative, pattern, regexp;
      this.configuration.filters = [];
      filters = document.getElementById('WikiMonkeyBotFilter').value.split('\n');
      for (i = 0, len = filters.length; i < len; i++) {
        filter = filters[i];

        if (filter) {
          firstSlash = filter.indexOf('/');
          lastSlash = filter.lastIndexOf('/');
          pattern = filter.substring(firstSlash + 1, lastSlash);
          modifiers = filter.substring(lastSlash + 1);
          negative = filter.charAt(0) === '!';
          try {
            regexp = new RegExp(pattern, modifiers);
          } catch (error) {
            exc = error;
            this.WM.Log.logError('Invalid regexp: ' + exc);
            return false;
          }
          this.configuration.filters.push([regexp, negative]);
        }
      }

      return true;
    }
  }, {
    key: 'canProcessPage',
    value: function canProcessPage(link) {
      var duplicates, filter, filters, i, inverse, len, negative, regexp, test, title;

      if (link.className.split(" ").indexOf("new") < 0) {
        title = link.innerHTML;
        duplicates = document.getElementById('WikiMonkeyBotDuplicates').checked;
        if (duplicates || this.configuration.visited.indexOf(title) < 0) {
          this.configuration.visited.push(title);
          filters = this.configuration.filters;
          inverse = document.getElementById('WikiMonkeyBotInverse').checked;
          if (filters.length > 0) {
            for (i = 0, len = filters.length; i < len; i++) {
              filter = filters[i];
              regexp = filter[0];
              negative = filter[1];
              test = regexp.test(title);
              if (test !== negative) {
                if (inverse) {
                  return false;
                } else {
                  return true;
                }
              }
            }

            if (inverse) {
              return true;
            } else {
              return false;
            }
          } else {
            if (inverse) {
              return false;
            } else {
              return true;
            }
          }
        } else {
          return false;
        }
      } else {
        return false;
      }
    }
  }, {
    key: 'changeWikiMonkeyLinkClassName',
    value: function changeWikiMonkeyLinkClassName(className, newClass) {
      var classes, cls, i, len, newClasses;
      classes = className.split(" ");
      newClasses = [];
      for (i = 0, len = classes.length; i < len; i++) {
        cls = classes[i];
        if (cls.indexOf("WikiMonkey") < 0) {
          newClasses.push(cls);
        }
      }

      newClasses.push(newClass);
      return newClasses.join(" ");
    }
  }, {
    key: 'restoreOriginalLinkClassName',
    value: function restoreOriginalLinkClassName(className) {
      var classes, cls, i, len, origClasses;
      classes = className.split(" ");
      origClasses = [];
      for (i = 0, len = classes.length; i < len; i++) {
        cls = classes[i];
        if (cls.indexOf("WikiMonkey") < 0) {
          origClasses.push(cls);
        }
      }
      return origClasses.join(" ");
    }
  }, {
    key: '_previewFilter',
    value: function _previewFilter() {
      var N, enable, i, item, items, j, len, len1, link, linkId;
      this.WM.Log.logInfo('Updating filter preview, please wait ...');
      this._disableStartBot('Updating filter preview ...');
      if (this.configuration.list.previous) {
        if (this.configuration.list.current[0].nodeName === 'TBODY') {
          items = this.configuration.list.previous[0].getElementsByTagName('td');
        } else {
          items = this.configuration.list.previous[0].getElementsByTagName('li');
        }
        linkId = this.configuration.list.previous[1];
        for (i = 0, len = items.length; i < len; i++) {
          item = items[i];
          link = item.getElementsByTagName('a')[linkId];

          if (link) {
            link.className = this.restoreOriginalLinkClassName(link.className);
          }
        }
      }
      this.configuration.visited = [];
      linkId = this.configuration.list.current[1];
      enable = false;
      N = 0;
      if (this.makeFilters()) {
        if (this.configuration.list.current[0].nodeName === 'TBODY') {
          items = this.configuration.list.current[0].getElementsByTagName('td');
        } else {
          items = this.configuration.list.current[0].getElementsByTagName('li');
        }
        for (j = 0, len1 = items.length; j < len1; j++) {
          item = items[j];
          link = item.getElementsByTagName('a')[linkId];

          if (link) {
            if (this.canProcessPage(link)) {
              link.className = this.changeWikiMonkeyLinkClassName(link.className, 'WikiMonkeyBotSelected');
              enable = true;
              N++;
            } else {
              link.className = this.restoreOriginalLinkClassName(link.className);
            }
          }
        }
      }
      this.WM.Log.logInfo('Preview updated (' + N + ' pages selected)');
      if (enable) {
        return this._enableStartBot();
      } else {
        return this._disableStartBot('No pages selected, reset and preview the filter');
      }
    }
  }, {
    key: '_setBotToken',
    value: function _setBotToken() {
      var date, token;
      date = new Date();
      token = date.getTime() + "";
      this.botToken = token;
      return localStorage.setItem('WikiMonkeyBotToken', token);
    }
  }, {
    key: '_resetBotToken',
    value: function _resetBotToken(reset) {
      this.botToken = "0";
      if (reset) {
        return localStorage.setItem('WikiMonkeyBotToken', "0");
      }
    }
  }, {
    key: '_getBotToken',
    value: function _getBotToken() {
      return this.botToken;
    }
  }, {
    key: '_checkOtherBotsRunning',
    value: function _checkOtherBotsRunning() {
      var value;
      value = localStorage.getItem('WikiMonkeyBotToken');

      return value && value !== "0" && value !== this._getBotToken();
    }
  }, {
    key: '_startAutomatic',
    value: function _startAutomatic() {
      var i, item, items, itemsDOM, len, linkId;
      if (this._checkOtherBotsRunning() && !this._canForceStart()) {
        this.WM.Log.logError("It's not possible to start the bot (without forcing it) for one of the following reasons:<br> * another bot instance is currently running<br> * a previously running bot has stopped due to a page processing error<br> * a previously running bot has stopped due to a Javascript error<br> * a previously running bot has been interrupted by a browser page refresh");
        return this._enableForceStart();
      } else if (this.makeFilters()) {
        if (this.configuration.list.current[0].nodeName === 'TBODY') {
          itemsDOM = this.configuration.list.current[0].getElementsByTagName('td');
        } else {
          itemsDOM = this.configuration.list.current[0].getElementsByTagName('li');
        }

        items = [];
        for (i = 0, len = itemsDOM.length; i < len; i++) {
          item = itemsDOM[i];
          items.push(item);
        }
        linkId = this.configuration.list.current[1];
        this._disableForceStart();
        this._setBotToken();
        this.WM.Log.logInfo('Starting bot ...');
        this.WM.Log.logHidden("Plugin: " + this.configuration.plugin_name);
        this.WM.Log.logHidden("Filter: " + document.getElementById('WikiMonkeyBotFilter').value);
        this._disableStartBot('Bot is running ...');
        this._disableControls();
        this.configuration.visited = [];
        return this.WM.MW.isUserBot(this._startAutomaticContinue, [items, linkId]);
      }
    }
  }, {
    key: '_startAutomaticContinue',
    value: function _startAutomaticContinue(botTest, args) {
      var items, linkId;
      items = args[0];
      linkId = args[1];
      this.configuration.interval = botTest ? 3000 : 30000;
      return this._processItem(0, items, 0, linkId, null);
    }
  }, {
    key: 'makeCallContinue',
    value: function makeCallContinue(lis, id, linkId, ln, article) {
      var self;
      self = this;
      return function (status, resArgs) {
        switch (status) {
          case 0:
            ln.className = self.changeWikiMonkeyLinkClassName(ln.className, 'WikiMonkeyBotUnchanged');
            self.WM.Log.logInfo(self.WM.Log.linkToWikiPage(article, article) + " processed (unchanged)");
            id++;
            self._processItem(status, lis, id, linkId, resArgs);
            break;

          case 1:
            ln.className = self.changeWikiMonkeyLinkClassName(ln.className, 'WikiMonkeyBotChanged');
            self.WM.Log.logInfo(self.WM.Log.linkToWikiPage(article, article) + " processed (changed)");
            id++;
            self._processItem(status, lis, id, linkId, resArgs);
            break;

          case 'protectedpage':
            ln.className = self.changeWikiMonkeyLinkClassName(ln.className, 'WikiMonkeyBotBypassed');
            self.WM.Log.logWarning("This user doesn't have the rights to " + "edit " + self.WM.Log.linkToWikiPage(article, article) + ", bypassing it ...");
            id++;

            self._processItem(0, lis, id, linkId, resArgs);
            break;
          default:
            ln.className = self.changeWikiMonkeyLinkClassName(ln.className, 'WikiMonkeyBotFailed');
            self.WM.Log.logError("Error processing " + self.WM.Log.linkToWikiPage(article, article) + ", stopping the bot");
            return self._endAutomatic(true);
        }
      };
    }
  }, {
    key: '_processItem',
    value: function _processItem(status, items, index, linkId, chainArgs) {
      var interval, link, self, stopId, title;
      self = this;
      if (items[index]) {
        link = items[index].getElementsByTagName('a')[linkId];

        if (link && this.canProcessPage(link)) {
          title = link.title;
          if (status === 0) {
            interval = 1000;
          } else {
            interval = this.configuration.interval;
          }
          this.WM.Log.logInfo('Waiting ' + interval / 1000 + ' seconds ...');
          stopId = setTimeout(function (lis, id, ln, article, chainArgs) {
            return function () {
              self._disableStopBot();

              if (!self._checkOtherBotsRunning()) {
                ln.className = self.changeWikiMonkeyLinkClassName(ln.className, 'WikiMonkeyBotProcessing');
                self.WM.Log.logInfo("Processing " + self.WM.Log.linkToWikiPage(article, article) + " ...");
                return self.configuration.function_(article, self.makeCallContinue(lis, id, linkId, ln, article), chainArgs);
              } else {
                self.WM.Log.logError('Another bot has been ' + 'force-started, stopping ...');
                return self._endAutomatic(false);
              }
            };
          }(items, index, link, title, chainArgs), interval);
          return this._enableStopBot(stopId);
        } else {
          index++;
          return this._processItem(status, items, index, linkId, chainArgs);
        }
      } else {
        return this._endAutomatic(true);
      }
    }
  }, {
    key: '_endAutomatic',
    value: function _endAutomatic(reset) {
      this._resetBotToken(reset);
      this.WM.Log.logInfo('Bot operations completed (check the log for ' + 'warnings or errors)');
      this._disableStartBot('Bot operations completed, reset and preview ' + 'the filter');
      return this._reEnableControls();
    }
  }]);

  return exports;
}();

},{"@kynikos/misc/dist/CSS":2}],399:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Async, Obj;

Async = require('@kynikos/misc/dist/Async');

Obj = require('@kynikos/misc/dist/Obj');

module.exports = function () {
  function exports(WM) {
    _classCallCheck(this, exports);

    this.WM = WM;
  }

  _createClass(exports, [{
    key: 'recurseTree',
    value: function recurseTree(params) {
      params.callChildren = this.WM.Cat._recurseTreeCallChildren;
      return Async.recurseTreeAsync(params);
    }
  }, {
    key: 'recurseTreeContinue',
    value: function recurseTreeContinue(params) {
      return Async.recurseTreeAsync(params);
    }
  }, {
    key: '_recurseTreeCallChildren',
    value: function _recurseTreeCallChildren(params) {
      return this.WM.Cat.getSubCategories(params.node, this.WM.Cat._recurseTreeCallChildrenContinue, params);
    }
  }, {
    key: '_recurseTreeCallChildrenContinue',
    value: function _recurseTreeCallChildrenContinue(subCats, params) {
      var i, len, subCat;
      for (i = 0, len = subCats.length; i < len; i++) {
        subCat = subCats[i];
        params.children.push(subCat.title);
      }
      return Async.recurseTreeAsync(params);
    }
  }, {
    key: 'getSubCategories',
    value: function getSubCategories(parent, call, callArgs) {
      return this.WM.Cat._getMembers(parent, "subcat", call, callArgs);
    }
  }, {
    key: 'getAllMembers',
    value: function getAllMembers(parent, call, callArgs) {
      return this.WM.Cat._getMembers(parent, null, call, callArgs);
    }
  }, {
    key: '_getMembers',
    value: function _getMembers(name, cmtype, call, callArgs) {
      var query;
      query = {
        action: "query",
        list: "categorymembers",
        cmtitle: name,
        cmlimit: 500
      };
      if (cmtype) {
        query.cmtype = cmtype;
      }
      return this._getMembersContinue(query, call, callArgs, []);
    }
  }, {
    key: '_getMembersContinue',
    value: function _getMembersContinue(query, call, callArgs, members) {
      return this.WM.MW.callAPIGet(query, function (res, args) {
        members = members.concat(res.query.categorymembers);
        if (res["query-continue"]) {
          query.cmcontinue = res["query-continue"].categorymembers.cmcontinue;
          return this._getMembersContinue(query, call, args, members);
        } else {
          return call(members, args);
        }
      }, callArgs, null);
    }
  }, {
    key: 'getParentsAndInfo',
    value: function getParentsAndInfo(name, call, callArgs) {
      var query;
      query = {
        action: "query",
        prop: "categories|categoryinfo",
        titles: name,
        clprop: "hidden",
        cllimit: 500
      };
      return this._getParentsAndInfoContinue(query, call, callArgs, [], null);
    }
  }, {
    key: '_getParentsAndInfoContinue',
    value: function _getParentsAndInfoContinue(query, call, callArgs, parents, info) {
      return this.WM.MW.callAPIGet(query, function (res, args) {
        var page;
        page = Obj.getFirstItem(res.query.pages);
        if (page.categories) {
          parents = parents.concat(page.categories);
        }
        if (page.categoryinfo) {
          info = page.categoryinfo;
        }
        if (res["query-continue"]) {
          query.prop = "categories";
          query.clcontinue = res["query-continue"].categories.clcontinue;
          return this._getParentsAndInfoContinue(query, call, args, parents, info);
        } else {
          return call(parents, info, args);
        }
      }, callArgs, null);
    }
  }]);

  return exports;
}();

},{"@kynikos/misc/dist/Async":1,"@kynikos/misc/dist/Obj":5}],400:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var HTTP;

HTTP = require('@kynikos/misc/dist/HTTP');

module.exports = function () {
  function exports(WM) {
    _classCallCheck(this, exports);

    this.WM = WM;
  }

  _createClass(exports, [{
    key: 'getEndTimestamp',
    value: function getEndTimestamp(call, callArgs) {
      var diff, giveEndTimestamp, oldid, pars, title;
      title = decodeURIComponent(HTTP.getURIParameter(null, 'title'));
      diff = HTTP.getURIParameter(null, 'diff');
      oldid = HTTP.getURIParameter(null, 'oldid');
      giveEndTimestamp = function giveEndTimestamp(page, id) {
        return call(page.revisions[id].timestamp, callArgs);
      };
      switch (diff) {
        case 'next':
          pars = {
            prop: "revisions",
            titles: title,
            rvlimit: "2",
            rvprop: "timestamp",
            rvdir: "newer",
            rvstartid: oldid
          };
          return this.WM.MW.callQuery(pars, giveEndTimestamp, 1, null);
        case 'prev':
          pars = {
            prop: "revisions",
            revids: oldid,
            rvprop: "timestamp"
          };
          return this.WM.MW.callQuery(pars, giveEndTimestamp, 0, null);
        default:
          pars = {
            prop: "revisions",
            revids: diff,
            rvprop: "timestamp"
          };
          return this.WM.MW.callQuery(pars, giveEndTimestamp, 0, null);
      }
    }
  }]);

  return exports;
}();

},{"@kynikos/misc/dist/HTTP":4}],401:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Compatibility, HTTP;

Compatibility = require('@kynikos/misc/dist/Compatibility');

HTTP = require('@kynikos/misc/dist/HTTP');

module.exports = function () {
  function exports(WM) {
    _classCallCheck(this, exports);

    this.WM = WM;
  }

  _createClass(exports, [{
    key: 'getTitle',
    value: function getTitle() {
      return this.WM.Parser.squashContiguousWhitespace(decodeURIComponent(HTTP.getURIParameter(null, 'title')));
    }
  }, {
    key: 'isSection',
    value: function isSection() {
      if (document.getElementsByName('wpSection')[0].value) {
        return true;
      } else {
        return false;
      }
    }
  }, {
    key: 'readSource',
    value: function readSource() {
      var value;
      value = document.getElementById('wpTextbox1').value;

      return Compatibility.normalizeCarriageReturns(value);
    }
  }, {
    key: 'writeSource',
    value: function writeSource(text) {
      return document.getElementById('wpTextbox1').value = text;
    }
  }, {
    key: 'readSummary',
    value: function readSummary() {
      return document.getElementById('wpSummary').getAttribute("value");
    }
  }, {
    key: 'writeSummary',
    value: function writeSummary(text) {
      return document.getElementById('wpSummary').setAttribute("value", text);
    }
  }, {
    key: 'appendToSummary',
    value: function appendToSummary(text) {
      return document.getElementById('wpSummary').setAttribute("value", this.readSummary() + text);
    }
  }]);

  return exports;
}();

},{"@kynikos/misc/dist/Compatibility":3,"@kynikos/misc/dist/HTTP":4}],402:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var CSS;

CSS = require('@kynikos/misc/dist/CSS');

module.exports = function () {
  function exports(WM) {
    _classCallCheck(this, exports);

    this.updateFilterUI = this.updateFilterUI.bind(this);
    this.executePlugin = this.executePlugin.bind(this);
    this.WM = WM;
  }

  _createClass(exports, [{
    key: '_makeUI',
    value: function _makeUI(page_type, plugins) {
      var Plugin, commandsFilterDiv, div, divFilter, filters, i, len, option, plugin, pluginInst, selectFilter;
      this.page_type = page_type;
      CSS.addStyleElement("#WikiMonkeyFilters-Commands {display:flex; align-items:center; justify-content:space-between;} #WikiMonkeyFilters-Commands > select {flex:auto;} #WikiMonkeyFilters-Commands > select, #WikiMonkeyFilters-Commands > input[type='button'] {margin-right:1em;} #WikiMonkeyFilters-Commands > input[type='checkbox'] {margin-right:0.4em;}");
      filters = [];
      selectFilter = $('<select/>').change(this.updateFilterUI(filters));
      for (i = 0, len = plugins.length; i < len; i++) {
        Plugin = plugins[i];
        plugin = new Plugin(this.WM);
        pluginInst = plugin.conf.filter_label;

        if (!pluginInst) {
          continue;
        }
        filters.push(plugin);
        option = $('<option/>').text(pluginInst);
        if (plugin.constructor.name === this.WM.conf['default_' + this.page_type + '_plugin']) {
          option[0].selected = true;
        }
        option.appendTo(selectFilter);
      }
      if (filters.length) {
        commandsFilterDiv = $('<div/>').attr('id', 'WikiMonkeyFilters-Commands');
        commandsFilterDiv.append(selectFilter);
        $('<input/>').attr('type', 'button').val('Apply filter').click(this.executePlugin(filters)).appendTo(commandsFilterDiv);
        $('<input/>').attr('type', 'checkbox').change(this.toggleLog).appendTo(commandsFilterDiv);
        $('<span/>').text('Show Log').appendTo(commandsFilterDiv);
        divFilter = $('<div/>').attr('id', "WikiMonkeyFilters-Options");

        $('<div/>').appendTo(divFilter);
        this.doUpdateFilterUI(divFilter, filters, selectFilter[0].selectedIndex);
        div = $('<div/>').attr('id', 'WikiMonkeyFilters').append(commandsFilterDiv).append(divFilter);
        return div[0];
      } else {
        return false;
      }
    }
  }, {
    key: 'updateFilterUI',
    value: function updateFilterUI(filters) {
      var _this = this;

      return function (event) {
        var UI, id, select;
        UI = $('#WikiMonkeyFilters-Options');
        select = $('#WikiMonkeyFilters-Commands').find('select').first();
        id = select[0].selectedIndex;
        return _this.doUpdateFilterUI(UI, filters, id);
      };
    }
  }, {
    key: 'doUpdateFilterUI',
    value: function doUpdateFilterUI(UI, filters, id) {
      var makeUI;
      makeUI = filters[id].makeUI;
      if (makeUI instanceof Function) {
        return UI.children().first().replaceWith(makeUI());
      } else {
        return UI.children().first().replaceWith($('<div/>'));
      }
    }
  }, {
    key: 'executePlugin',
    value: function executePlugin(filters) {
      var _this2 = this;

      return function (event) {
        var id, select;
        select = $('#WikiMonkeyFilters-Commands').find('select').first();
        id = select[0].selectedIndex;
        filters[id]['main_' + _this2.page_type]();
        return event.target.disabled = true;
      };
    }
  }, {
    key: 'toggleLog',
    value: function toggleLog(event) {
      if (this.checked) {
        return $('#WikiMonkeyLog').show();
      } else {
        return $('#WikiMonkeyLog').hide();
      }
    }
  }]);

  return exports;
}();

},{"@kynikos/misc/dist/CSS":2}],403:[function(require,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Obj;

Obj = require('@kynikos/misc/dist/Obj');

module.exports = function () {
  function exports(WM) {
    _classCallCheck(this, exports);

    this.parseLinks = this.parseLinks.bind(this);
    this.queryLinks = this.queryLinks.bind(this);
    this.createNewLink = this.createNewLink.bind(this);
    this.createVisitedLink = this.createVisitedLink.bind(this);
    this.collectLinks = this.collectLinks.bind(this);
    this._collectLinksContinue = this._collectLinksContinue.bind(this);
    this.updateLinks = this.updateLinks.bind(this);
    this.WM = WM;
  }

  _createClass(exports, [{
    key: "parseLinks",
    value: function parseLinks(supportedLangs, source, iwmap) {
      var i, iw, j, langlinks, len, len1, link, ltag, ltitle, lurl, parsedLinks;
      parsedLinks = this.WM.Parser.findSpecialLinks(source, supportedLangs.join("|"));
      langlinks = [];
      for (i = 0, len = parsedLinks.length; i < len; i++) {
        link = parsedLinks[i];

        ltag = link.namespace;
        ltitle = link.title + (link.fragment ? "#" + link.fragment : "");
        for (j = 0, len1 = iwmap.length; j < len1; j++) {
          iw = iwmap[j];
          if (iw.prefix.toLowerCase() === ltag.toLowerCase()) {
            lurl = this.WM.MW.fixInterwikiUrl(iw.url);
            lurl = lurl.replace("$1", encodeURIComponent(this.WM.Parser.squashContiguousWhitespace(ltitle)));
            break;
          }
        }
        langlinks.push({
          lang: ltag,
          title: ltitle,
          url: lurl,
          index: link.index,
          length: link.length
        });
      }
      return langlinks;
    }
  }, {
    key: "queryLinks",
    value: function queryLinks(queryTitle, title, supportedLangs, whitelist, firstPage, callEnd, callArgs) {
      var _this = this;

      var query;
      query = {
        action: "query",
        prop: "info|revisions",
        rvprop: "content|timestamp",
        intoken: "edit",
        titles: queryTitle,
        meta: "siteinfo",
        siprop: "interwikimap",
        sifilteriw: "local"
      };

      if (!firstPage) {
        query.redirects = "1";
      }
      return this.WM.MW.callAPIGet(query, function (res, args) {
        var edittoken, error, iwmap, langlinks, page, source, timestamp;
        if (res.query.pages) {
          page = Obj.getFirstItem(res.query.pages);
          if (page.revisions) {
            error = null;
            source = page.revisions[0]["*"];
            timestamp = page.revisions[0].timestamp;
            edittoken = page.edittoken;
            iwmap = res.query.interwikimap;
            langlinks = _this.WM.Interlanguage.parseLinks(supportedLangs, source, iwmap);
          } else {
            error = 'nonexisting';
            source = false;
            timestamp = false;
            edittoken = false;
            iwmap = res.query.interwikimap;
            langlinks = false;
          }
        } else if (res.query.redirects) {
          error = 'unsolvedredirect';
          source = false;
          timestamp = false;
          edittoken = false;
          iwmap = res.query.interwikimap;
          langlinks = false;
        } else {
          error = 'unknown';
          source = false;
          timestamp = false;
          edittoken = false;
          iwmap = res.query.interwikimap;
          langlinks = false;
        }
        return callEnd(title, supportedLangs, whitelist, false, error, langlinks, iwmap, source, timestamp, edittoken, args);
      }, callArgs, function (args) {
        return callEnd(title, supportedLangs, whitelist, false, 'unknown', false, false, false, false, false, args);
      });
    }
  }, {
    key: "createNewLink",
    value: function createNewLink(origTag, title, url) {
      return {
        origTag: origTag,
        title: title,
        url: url
      };
    }
  }, {
    key: "createVisitedLink",
    value: function createVisitedLink(origTag, title, url, iwmap, source, timestamp, edittoken, links) {
      var entry, i, len, link;
      entry = {
        origTag: origTag,
        title: title,
        url: url,
        iwmap: iwmap,
        source: source,
        timestamp: timestamp,
        edittoken: edittoken,
        links: []
      };
      for (i = 0, len = links.length; i < len; i++) {
        link = links[i];
        entry.links.push(link);
      }
      return entry;
    }
  }, {
    key: "collectLinks",
    value: function collectLinks(visitedlinks, newlinks, supportedLangs, whitelist, firstPage, callEnd, callArgs) {
      var link, origTag, queryTitle, tag, title, url;
      for (tag in newlinks) {
        link = newlinks[tag];
        break;
      }
      if (link) {
        delete newlinks[tag];
        url = link.url;

        queryTitle = decodeURIComponent(this.WM.MW.getTitleFromWikiUrl(url));
        if (queryTitle) {
          origTag = link.origTag;
          title = link.title;

          if (firstPage || whitelist.indexOf(tag) > -1) {
            this.WM.Log.logInfo("Reading " + this.WM.Log.linkToPage(url, "[[" + origTag + ":" + title + "]]") + " ...");
            return this.queryLinks(queryTitle, title, supportedLangs, whitelist, firstPage, this.WM.Interlanguage._collectLinksContinue, [url, tag, origTag, visitedlinks, newlinks, callEnd, callArgs]);
          } else {
            return this.WM.Interlanguage._collectLinksContinue(title, supportedLangs, whitelist, firstPage, 'notinwhitelist', [], false, null, null, null, [url, tag, origTag, visitedlinks, newlinks, callEnd, callArgs]);
          }
        } else {
          this.WM.Log.logWarning("Cannot extract the page title from " + this.WM.Log.linkToPage(url, decodeURI(url)) + ", removing it if it was linked from the processed article");
          return this.WM.Interlanguage.collectLinks(visitedlinks, newlinks, supportedLangs, whitelist, firstPage, callEnd, callArgs);
        }
      } else {
        return callEnd(visitedlinks, callArgs);
      }
    }
  }, {
    key: "_collectLinksContinue",
    value: function _collectLinksContinue(title, supportedLangs, whitelist, firstPage, error, langlinks, iwmap, source, timestamp, edittoken, args) {
      var callArgs, callEnd, i, len, link, newlinks, nlink, origTag, tag, url, visitedlinks, vlink;
      url = args[0];
      tag = args[1];
      origTag = args[2];
      visitedlinks = args[3];
      newlinks = args[4];
      callEnd = args[5];
      callArgs = args[6];
      if (error === 'nonexisting') {
        this.WM.Log.logWarning(this.WM.Log.linkToPage(url, "[[" + origTag + ":" + title + "]]") + " seems to point to a non-existing article: removing it if it was linked from the processed article");
      } else {
        if (error === 'unsolvedredirect') {
          this.WM.Log.logWarning(this.WM.Log.linkToPage(url, "[[" + origTag + ":" + title + "]]") + " will not be checked because it points to an external redirect");
        } else if (error === 'unknown') {
          this.WM.Log.logWarning(this.WM.Log.linkToPage(url, "[[" + origTag + ":" + title + "]]") + " will not be checked because of an unspecified problem");
        } else if (error === 'notinwhitelist') {
          this.WM.Log.logWarning(this.WM.Log.linkToPage(url, "[[" + origTag + ":" + title + "]]") + " will not be checked because " + tag + " is not included in the whitelist defined in the configuration");
        }
        visitedlinks[tag] = this.WM.Interlanguage.createVisitedLink(origTag, title, url, iwmap, source, timestamp, edittoken, langlinks);
        for (i = 0, len = langlinks.length; i < len; i++) {
          link = langlinks[i];
          nlink = newlinks[link.lang.toLowerCase()];
          vlink = visitedlinks[link.lang.toLowerCase()];
          if (!vlink && !nlink) {
            newlinks[link.lang.toLowerCase()] = this.WM.Interlanguage.createNewLink(link.lang, link.title, link.url);
          } else if (vlink && vlink.url !== link.url) {
            this.WM.Log.logWarning("Possibly conflicting interlanguage links: " + this.WM.Log.linkToPage(link.url, "[[" + link.lang + ":" + link.title + "]]") + " and " + this.WM.Log.linkToPage(vlink.url, "[[" + link.lang + ":" + visitedlinks[link.lang.toLowerCase()].title + "]]"));
          } else if (nlink && nlink.url !== link.url) {
            this.WM.Log.logWarning("Possibly conflicting interlanguage links: " + this.WM.Log.linkToPage(link.url, "[[" + link.lang + ":" + link.title + "]]") + " and " + this.WM.Log.linkToPage(nlink.url, "[[" + link.lang + ":" + newlinks[link.lang.toLowerCase()].title + "]]"));
          }
        }
      }
      return this.WM.Interlanguage.collectLinks(visitedlinks, newlinks, supportedLangs, whitelist, firstPage, callEnd, callArgs);
    }
  }, {
    key: "updateLinks",
    value: function updateLinks(lang, url, iwmap, source, oldlinks, newlinks) {
      var body, cleanText, firstLink, head, i, iw, j, len, len1, link, linkList, links, parts, tag, tagFound, textId, trailws;
      lang = lang.toLowerCase();
      linkList = [];
      for (tag in newlinks) {
        if (tag !== lang) {
          link = newlinks[tag];
          tagFound = false;

          for (i = 0, len = iwmap.length; i < len; i++) {
            iw = iwmap[i];
            if (iw.prefix.toLowerCase() === tag.toLowerCase()) {
              linkList.push("[[" + link.origTag + ":" + link.title + "]]");
              tagFound = true;
              break;
            }
          }
          if (!tagFound) {
            this.WM.Log.logWarning(tag + " interlanguage links are not supported in " + this.WM.Log.linkToPage(url, "[[" + link.origTag + ":" + link.title + "]]") + " , ignoring them");
          }
        }
      }
      linkList.sort(function (a, b) {
        if (a.toLowerCase() > b.toLowerCase()) {
          return 1;
        }
        if (b.toLowerCase() > a.toLowerCase()) {
          return -1;
        } else {
          return 0;
        }
      });
      cleanText = "";
      textId = 0;
      for (j = 0, len1 = oldlinks.length; j < len1; j++) {
        link = oldlinks[j];
        cleanText += source.substring(textId, link.index);
        textId = link.index + link.length;
      }
      cleanText += source.substring(textId);
      if (oldlinks.length) {
        firstLink = oldlinks[0].index;
      } else {
        firstLink = 0;
      }
      parts = [];

      head = cleanText.substring(0, firstLink).trim();
      if (head) {
        parts.push(head);
      }
      links = linkList.join("\n");
      if (links) {
        parts.push(links);
      }
      body = cleanText.substr(firstLink).trim();
      if (body) {
        parts.push(body);
      }

      trailws = /\s*$/;
      return parts.join("\n") + trailws.exec(source);
    }
  }]);

  return exports;
}();

},{"@kynikos/misc/dist/Obj":5}],404:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Str, jss;

var _require = require('./libs');

jss = _require.jss;


Str = require('@kynikos/misc/dist/Str');

module.exports = function () {
  var classesToLevels;

  var exports = function () {
    function exports(WM) {
      _classCallCheck(this, exports);

      var classes, styles;
      this.WM = WM;
      this._currentInfoDisplayState = true;

      styles = {
        log: {
          height: '10em',
          border: '2px solid #07b',
          padding: '0.5em',
          overflow: 'auto',
          resize: 'vertical',
          'background-color': '#111',
          '& p.timestamp, & p.message': {
            border: 'none',
            padding: 0,
            'font-family': 'monospace',
            color: '#eee'
          },
          '& p.timestamp': {
            margin: '0 1em 0 0',
            'white-space': 'nowrap'
          },
          '& p.message': {
            margin: 0
          },
          '& div.mdebug, & div.minfo, & div.mwarning, & div.merror': {
            display: 'flex'
          },
          '& div.mhidden': {
            display: 'none'
          },
          '& div.mjson': {
            display: 'none'
          },
          '& div.mdebug p.message': {
            color: 'cyan'
          },
          '& div.mwarning p.message': {
            color: 'gold'
          },
          '& div.merror p.message': {
            color: 'red'
          },
          '& a': {
            color: 'inherit',
            'text-decoration': 'underline'
          }
        }
      };

      var _jss$createStyleSheet = jss.createStyleSheet(styles, {
        classNamePrefix: "WikiMonkey-"
      }).attach();

      classes = _jss$createStyleSheet.classes;

      this.classes = classes;
    }

    _createClass(exports, [{
      key: '_makeLogArea',
      value: function _makeLogArea() {
        var log, par;
        log = document.createElement('div');
        log.id = 'WikiMonkeyLog';
        par = document.createElement('p');
        par.appendChild(this.makeFilterLink());
        par.appendChild(document.createTextNode(' '));
        par.appendChild(this.makeSaveLink());
        log.appendChild(par);
        this.logarea = document.createElement('div');
        this.logarea.className = this.classes.log;
        log.appendChild(this.logarea);
        return log;
      }
    }, {
      key: 'makeFilterLink',
      value: function makeFilterLink() {
        var _this = this;

        var link;
        link = document.createElement('a');
        link.href = '#WikiMonkey';
        link.innerHTML = this.computeFilterLinkAnchor();
        link.addEventListener("click", function (event) {
          var i, len, msg, msgs;
          event.preventDefault();

          _this._currentInfoDisplayState = !_this._currentInfoDisplayState;
          link.innerHTML = _this.computeFilterLinkAnchor();
          msgs = _this.logarea.getElementsByClassName('minfo');
          for (i = 0, len = msgs.length; i < len; i++) {
            msg = msgs[i];
            msg.style.display = _this.computeInfoDisplayStyle();
          }
          return _this.scrollToBottom();
        }, false);
        return link;
      }
    }, {
      key: 'makeSaveLink',
      value: function makeSaveLink() {
        var _this2 = this;

        var link;
        link = document.createElement('a');
        link.href = '#';
        link.download = 'WikiMonkey.log';
        link.innerHTML = '[save log]';
        link.id = 'WikiMonkeyLog-Save';
        link.addEventListener("click", function () {
          link.href = 'data:text/plain;charset=utf-8,' + encodeURIComponent(_this2.composeSaveLogText());
          return link.download = _this2.composeSaveLogFilename();
        }, false);
        return link;
      }
    }, {
      key: 'composeSaveLogText',
      value: function composeSaveLogText() {
        var div, divs, i, len, level, message, ps, text, tstamp;
        divs = this.logarea.getElementsByTagName('div');
        text = '';
        for (i = 0, len = divs.length; i < len; i++) {
          div = divs[i];
          ps = div.getElementsByTagName('p');
          tstamp = ps[0].innerHTML;
          level = classesToLevels[div.className];
          message = ps[1].innerHTML;
          text += tstamp + '\t' + level + '\t' + message + '\n';
        }
        return text;
      }
    }, {
      key: 'composeSaveLogFilename',
      value: function composeSaveLogFilename() {
        var date;
        date = new Date();
        return 'WikiMonkey-' + date.getFullYear() + Str.padLeft(String(date.getMonth() + 1), '0', 2) + Str.padLeft(String(date.getDate()), '0', 2) + Str.padLeft(String(date.getHours()), '0', 2) + Str.padLeft(String(date.getMinutes()), '0', 2) + '.log';
      }
    }, {
      key: 'computeInfoDisplayStyle',
      value: function computeInfoDisplayStyle() {
        if (this._currentInfoDisplayState) {
          return 'flex';
        } else {
          return 'none';
        }
      }
    }, {
      key: 'computeFilterLinkAnchor',
      value: function computeFilterLinkAnchor() {
        if (this._currentInfoDisplayState) {
          return '[hide info messages]';
        } else {
          return '[show info messages]';
        }
      }
    }, {
      key: 'scrollToBottom',
      value: function scrollToBottom() {
        return this.logarea.scrollTop = this.logarea.scrollHeight - this.logarea.clientHeight;
      }
    }, {
      key: 'appendMessage',
      value: function appendMessage(text, type) {
        var line, msg, now, test, tstamp;
        tstamp = document.createElement('p');
        tstamp.className = 'timestamp';
        now = new Date();
        tstamp.innerHTML = now.toLocaleTimeString();
        msg = document.createElement('p');
        msg.className = 'message';

        msg.innerHTML = text ? text : " ";
        line = document.createElement('div');
        line.appendChild(tstamp);
        line.appendChild(msg);
        line.className = type;
        if (type === 'minfo') {
          line.style.display = this.computeInfoDisplayStyle();
        }

        test = this.logarea.scrollTop + this.logarea.clientHeight === this.logarea.scrollHeight;
        this.logarea.appendChild(line);
        if (test) {
          return this.scrollToBottom();
        }
      }
    }, {
      key: 'logHidden',
      value: function logHidden(text) {
        return this.appendMessage(text, 'mhidden');
      }
    }, {
      key: 'logJson',
      value: function logJson(component, data) {
        var text;
        text = JSON.stringify({
          "component": component,
          "data": data
        });
        return this.appendMessage(text, 'mjson');
      }
    }, {
      key: 'logDebug',
      value: function logDebug(text) {
        return this.appendMessage(text, 'mdebug');
      }
    }, {
      key: 'logInfo',
      value: function logInfo(text) {
        return this.appendMessage(text, 'minfo');
      }
    }, {
      key: 'logWarning',
      value: function logWarning(text) {
        return this.appendMessage(text, 'mwarning');
      }
    }, {
      key: 'logError',
      value: function logError(text) {
        return this.appendMessage(text, 'merror');
      }
    }, {
      key: 'linkToPage',
      value: function linkToPage(url, anchor) {
        return "<a href=\"" + url + "\">" + anchor + "</a>";
      }
    }, {
      key: 'linkToWikiPage',
      value: function linkToWikiPage(title, anchor) {
        var wikiUrls;

        wikiUrls = this.WM.MW.getWikiUrls();
        return "<a href=\"" + wikiUrls.short + title + "\">" + anchor + "</a>";
      }
    }]);

    return exports;
  }();

  ;

  classesToLevels = {
    'mhidden': 'HDN',
    'mjson': 'JSN',
    'mdebug': 'DBG',
    'minfo': 'INF',
    'mwarning': 'WRN',
    'merror': 'ERR'
  };

  return exports;
}.call(undefined);

},{"./libs":415,"@kynikos/misc/dist/Str":7}],405:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var A, HTTP, Obj;

HTTP = require('@kynikos/misc/dist/HTTP');

Obj = require('@kynikos/misc/dist/Obj');

var _require = require('./libs');

A = _require.A;


module.exports = function () {
  var interwikiFixes, localWikiPaths, localWikiUrls, wikiPaths;

  var exports = function () {
    function exports(WM) {
      _classCallCheck(this, exports);

      var hostname, key, wpaths;
      this.WM = WM;
      this.api = new mw.Api();
      wpaths = this._getWikiPaths(location.href);
      hostname = wpaths[0];
      this.userInfo = null;
      localWikiPaths = wpaths[1];
      localWikiUrls = {};
      for (key in localWikiPaths) {
        localWikiUrls[key] = hostname + localWikiPaths[key];
      }
    }

    _createClass(exports, [{
      key: '_getWikiPaths',
      value: function _getWikiPaths(href) {
        var hostname, match, p, paths, r, re;

        for (r in wikiPaths.known) {
          re = new RegExp(r, "i");
          match = re.exec(href);
          if (match) {
            hostname = match[0];
            paths = {};
            for (p in wikiPaths.known[r]) {
              paths[p] = wikiPaths.known[r][p];
            }
            break;
          }
        }
        if (!paths) {
          hostname = HTTP.getUrlLocation(href).hostname;
          paths = {};
          for (p in wikiPaths.default_) {
            paths[p] = wikiPaths.default_[p];
          }
        }
        return [hostname, paths];
      }
    }, {
      key: 'getWikiPaths',
      value: function getWikiPaths(href) {
        if (href) {
          return this._getWikiPaths(href)[1];
        } else {
          return localWikiPaths;
        }
      }
    }, {
      key: 'linkArticle',
      value: function linkArticle(page, label) {
        return A({
          href: mw.util.getUrl(page)
        }, label || page);
      }
    }, {
      key: 'getWikiUrls',
      value: function getWikiUrls(href) {
        var hostname, key, paths, urls, wpaths;
        if (href) {
          wpaths = this._getWikiPaths(href);
          hostname = wpaths[0];
          paths = wpaths[1];
          urls = {};
          for (key in paths) {
            urls[key] = hostname + paths[key];
          }
          return urls;
        } else {
          return localWikiUrls;
        }
      }
    }, {
      key: 'getTitleFromWikiUrl',
      value: function getTitleFromWikiUrl(url) {
        var match, pathname, r, re, title;
        title = HTTP.getURIParameters(url).title;

        if (!title) {
          pathname = HTTP.getUrlLocation(url).pathname;
          for (r in wikiPaths.known) {
            re = new RegExp(r, "i");
            match = re.exec(url);
            if (match) {
              if (pathname.indexOf(wikiPaths.known[r].short) === 0) {
                title = pathname.substr(wikiPaths.known[r].short.length);
              } else {
                title = false;
              }
              break;
            }
          }
          if (!title) {
            if (pathname.indexOf(wikiPaths.default_.short) === 0) {
              title = pathname.substr(wikiPaths.default_.short.length);
            } else {
              title = false;
            }
          }
        }
        return title;
      }
    }, {
      key: 'failedQueryError',
      value: function failedQueryError(url) {
        if (url) {
          return 'Failed query: ' + this.WM.Log.linkToPage(url, url);
        }
        return "Failed query";
      }
    }, {
      key: 'callAPIGet',
      value: function callAPIGet(params, call, callArgs, callError) {
        var _this = this;

        params.format = "json";
        return this.api.get(params).done(function (data, textStatus, jqXHR) {
          if (call) {
            return call(data, callArgs);
          }
        }).fail(function (jqXHR, textStatus, errorThrown) {
          console.error(jqXHR, textStatus, errorThrown);
          _this.WM.Log.logError(_this.failedQueryError());
          if (confirm("Wiki Monkey error: Failed query\n\nDo you want " + "to retry?")) {
            _this.WM.Log.logInfo("Retrying ...");
            return _this.callAPIGet(params, call, callArgs, callError);
          } else if (callError) {
            return callError(callArgs);
          }
        });
      }
    }, {
      key: 'callAPIPost',
      value: function callAPIPost(params, call, callArgs, callError) {
        var _this2 = this;

        params.format = "json";
        return this.api.post(params).done(function (data, textStatus, jqXHR) {
          if (call) {
            return call(data, callArgs);
          }
        }).fail(function (jqXHR, textStatus, errorThrown) {
          console.error(jqXHR, textStatus, errorThrown);
          _this2.WM.Log.logError(_this2.failedQueryError());
          if (confirm("Wiki Monkey error: Failed query\n\nDo you want " + "to retry?")) {
            _this2.WM.Log.logInfo("Retrying ...");
            return _this2.callAPIPost(params, call, callArgs, callError);
          } else if (callError) {
            return callError(callArgs);
          }
        });
      }
    }, {
      key: 'callQuery',
      value: function () {
        var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(params, call, callArgs, callError) {
          var error, page, res;
          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  params.action = "query";
                  _context.prev = 1;
                  _context.next = 4;
                  return this.callAPIGet(params);

                case 4:
                  res = _context.sent;
                  _context.next = 13;
                  break;

                case 7:
                  _context.prev = 7;
                  _context.t0 = _context['catch'](1);

                  error = _context.t0;

                  if (!callError) {
                    _context.next = 12;
                    break;
                  }

                  return _context.abrupt('return', callError(callArgs));

                case 12:
                  throw error;

                case 13:
                  page = Obj.getFirstItem(res.query.pages);

                  if (!call) {
                    _context.next = 16;
                    break;
                  }

                  return _context.abrupt('return', call(page, callArgs));

                case 16:
                  return _context.abrupt('return', page);

                case 17:
                case 'end':
                  return _context.stop();
              }
            }
          }, _callee, this, [[1, 7]]);
        }));

        function callQuery(_x, _x2, _x3, _x4) {
          return _ref.apply(this, arguments);
        }

        return callQuery;
      }()
    }, {
      key: 'callQueryEdit',
      value: function () {
        var _ref2 = _asyncToGenerator(regeneratorRuntime.mark(function _callee2(title, call, callArgs) {
          var edittoken, page, source, timestamp;
          return regeneratorRuntime.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  _context2.next = 2;
                  return this.callQuery({
                    prop: "info|revisions",
                    rvprop: "content|timestamp",
                    intoken: "edit",
                    titles: title
                  });

                case 2:
                  page = _context2.sent;

                  source = page.revisions[0]["*"];
                  timestamp = page.revisions[0].timestamp;
                  edittoken = page.edittoken;

                  if (!call) {
                    _context2.next = 8;
                    break;
                  }

                  return _context2.abrupt('return', call(title, source, timestamp, edittoken, callArgs));

                case 8:
                  return _context2.abrupt('return', { source: source, timestamp: timestamp, edittoken: edittoken });

                case 9:
                case 'end':
                  return _context2.stop();
              }
            }
          }, _callee2, this);
        }));

        function callQueryEdit(_x5, _x6, _x7) {
          return _ref2.apply(this, arguments);
        }

        return callQueryEdit;
      }()
    }, {
      key: 'getUserInfo',
      value: function getUserInfo(call) {
        var _this3 = this;

        var pars, storeInfo;
        storeInfo = function storeInfo(res, call) {
          _this3.userInfo = res;
          return call();
        };
        if (!this.userInfo) {
          pars = {
            action: "query",
            meta: "userinfo",
            uiprop: "groups"
          };
          return this.callAPIGet(pars, storeInfo, call, null);
        } else {
          return call();
        }
      }
    }, {
      key: 'isLoggedIn',
      value: function isLoggedIn(call, args) {
        var _this4 = this;

        return this.getUserInfo(function () {
          var test;
          test = _this4.userInfo.query.userinfo.id !== 0;
          return call(test, args);
        });
      }
    }, {
      key: 'getUserName',
      value: function getUserName(call, args) {
        var _this5 = this;

        return this.getUserInfo(function () {
          return call(_this5.userInfo.query.userinfo.name, args);
        });
      }
    }, {
      key: 'isUserBot',
      value: function isUserBot(call, args) {
        var _this6 = this;

        return this.getUserInfo(function () {
          var groups, res;
          groups = _this6.userInfo.query.userinfo.groups;
          res = groups.indexOf("bot") > -1;
          return call(res, args);
        });
      }
    }, {
      key: 'getBacklinks',
      value: function getBacklinks(bltitle, blnamespace, call, callArgs) {
        var query;
        query = {
          action: "query",
          list: "backlinks",
          bltitle: bltitle,
          bllimit: 500
        };
        if (blnamespace) {
          query.blnamespace = blnamespace;
        }
        return this._getBacklinksContinue(query, call, callArgs, []);
      }
    }, {
      key: '_getBacklinksContinue',
      value: function _getBacklinksContinue(query, call, callArgs, backlinks) {
        var _this7 = this;

        return this.callAPIGet(query, function (res, args) {
          backlinks = backlinks.concat(res.query.backlinks);
          if (res["query-continue"]) {
            query.blcontinue = res["query-continue"].backlinks.blcontinue;
            return _this7._getBacklinksContinue(query, call, args, backlinks);
          } else {
            return call(backlinks, args);
          }
        }, callArgs, null);
      }
    }, {
      key: 'getLanglinks',
      value: function getLanglinks(title, iwmap, call, callArgs) {
        var query;
        query = {
          action: "query",
          prop: "langlinks",
          titles: title,
          lllimit: 500,
          llurl: "1",
          redirects: "1"
        };
        if (iwmap) {
          query.meta = "siteinfo";
          query.siprop = "interwikimap";
          query.sifilteriw = "local";
        }
        return this._getLanglinksContinue(query, call, callArgs, [], null);
      }
    }, {
      key: '_getLanglinksContinue',
      value: function _getLanglinksContinue(query, call, callArgs, langlinks, iwmap) {
        var _this8 = this;

        return this.callAPIGet(query, function (res, args) {
          var page;
          page = Obj.getFirstItem(res.query.pages);
          langlinks = langlinks.concat(page.langlinks);
          if (res.query.interwikimap) {
            iwmap = res.query.interwikimap;
          }
          if (query.meta) {
            delete query.meta;
            delete query.siprop;
            delete query.sifilteriw;
          }
          if (res["query-continue"]) {
            query.llcontinue = res["query-continue"].langlinks.llcontinue;
            return _this8._getLanglinksContinue(query, call, args, langlinks, iwmap);
          } else {
            return call(langlinks, iwmap, args);
          }
        }, callArgs, null);
      }
    }, {
      key: 'getInterwikiMap',
      value: function getInterwikiMap(title) {
        return this.callAPIGet({
          action: "query",
          meta: "siteinfo",
          siprop: "interwikimap"
        });
      }
    }, {
      key: 'getLocalInterwikiMap',
      value: function getLocalInterwikiMap(title, call, callArgs) {
        return this.callAPIGet({
          action: "query",
          meta: "siteinfo",
          siprop: "interwikimap",
          sifilteriw: "local"
        }, function (res, args) {
          return call(res.query.interwikimap, args);
        }, callArgs, null);
      }
    }, {
      key: 'fixInterwikiUrl',
      value: function fixInterwikiUrl(url) {
        var f, furl, i, ref;
        for (f = i = 0, ref = interwikiFixes.length; 0 <= ref ? i < ref : i > ref; f = 0 <= ref ? ++i : --i) {
          furl = url.replace(interwikiFixes[f][0], interwikiFixes[f][1]);
          if (furl !== url) {
            return furl;
          }
        }

        return url;
      }
    }, {
      key: 'getSpecialList',
      value: function () {
        var _ref3 = _asyncToGenerator(regeneratorRuntime.mark(function _callee3(qppage, siprop) {
          var info, key, query, ref, res, results, siteinfo;
          return regeneratorRuntime.wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  query = {
                    action: "query",
                    list: "querypage",
                    qppage: qppage,
                    qplimit: 500
                  };
                  if (siprop) {
                    query.meta = "siteinfo";
                    query.siprop = siprop;
                  }
                  results = [];
                  siteinfo = {};

                case 4:
                  if (!true) {
                    _context3.next = 19;
                    break;
                  }

                  _context3.next = 7;
                  return this.callAPIGet(query);

                case 7:
                  res = _context3.sent;

                  results = results.concat(res.query.querypage.results);
                  ref = res.query;
                  for (key in ref) {
                    info = ref[key];
                    if (key !== "querypage") {
                      siteinfo[key] = info;
                    }
                  }
                  delete query.meta;
                  delete query.siprop;

                  if (!res["query-continue"]) {
                    _context3.next = 16;
                    break;
                  }

                  query.qpoffset = res["query-continue"].querypage.qpoffset;
                  return _context3.abrupt('continue', 4);

                case 16:
                  return _context3.abrupt('return', { results: results, siteinfo: siteinfo });

                case 19:
                case 'end':
                  return _context3.stop();
              }
            }
          }, _callee3, this);
        }));

        function getSpecialList(_x8, _x9) {
          return _ref3.apply(this, arguments);
        }

        return getSpecialList;
      }()
    }, {
      key: 'getUserContribs',
      value: function getUserContribs(ucuser, ucstart, ucend, call, callArgs) {
        var query;
        query = {
          action: "query",
          list: "usercontribs",
          ucuser: ucuser,
          ucprop: "",
          ucstart: ucstart,
          ucend: ucend,
          uclimit: 500
        };
        return this._getUserContribsContinue(query, call, callArgs, []);
      }
    }, {
      key: '_getUserContribsContinue',
      value: function _getUserContribsContinue(query, call, callArgs, results) {
        var _this9 = this;

        return this.callAPIGet(query, function (res, args) {
          results = results.concat(res.query.usercontribs);
          if (res["query-continue"]) {
            query.uccontinue = res["query-continue"].usercontribs.uccontinue;
            return _this9._getUserContribsContinue(query, call, args, results);
          } else {
            return call(results, args);
          }
        }, callArgs, null);
      }
    }]);

    return exports;
  }();

  ;

  localWikiPaths = null;

  localWikiUrls = null;

  wikiPaths = {
    known: {
      "^https?://[^\.]+\.wikipedia\.org": {
        short: "/wiki/",
        full: "/w/index.php",
        api: "/w/api.php"
      },
      "^https?://wiki\.archlinux\.org": {
        short: "/index.php/",
        full: "/index.php",
        api: "/api.php"
      },
      "^https?://wiki\.archlinux\.de": {
        short: "/title/",
        full: "/index.php",
        api: "/api.php"
      },
      "^http://wiki\.archlinux\.fr": {
        short: "/",
        full: "/index.php",
        api: "/api.php"
      },
      "^https?://wiki\.archlinux\.jp": {
        short: "/index.php/",
        full: "/index.php",
        api: "/api.php"
      },
      "^http://wiki\.archlinux\.ro": {
        short: "/index.php/",
        full: "/index.php",
        api: "/api.php"
      },
      "^http://wiki\.archlinux\.ir": {
        short: "/index.php/",
        full: "/index.php",
        api: "/api.php"
      }
    },
    default_: {
      short: "/index.php?title=",
      full: "/index.php",
      api: "/api.php"
    }
  };

  interwikiFixes = [["https://wiki.archlinux.org/index.php/$1_(", "https://wiki.archlinux.org/index.php/$1%20("]];

  return exports;
}.call(undefined);

},{"./libs":415,"@kynikos/misc/dist/HTTP":4,"@kynikos/misc/dist/Obj":5}],406:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var CSS;

CSS = require('@kynikos/misc/dist/CSS');

module.exports = function () {
  var _executeGroupAction, makeChangeMenu, makeGroupAction;

  var exports = function () {
    function exports(WM) {
      _classCallCheck(this, exports);

      this.executeEntryAction = this.executeEntryAction.bind(this);
      this.warnInputNeeded = this.warnInputNeeded.bind(this);
      this.WM = WM;
    }

    _createClass(exports, [{
      key: '_makeUI',
      value: function _makeUI(page_type, plugins) {
        var Plugin, currId, currMenu, entry, execAll, groupAction, groupActions, i, j, len, m, mainDiv, menuSel, menus, parentId, parentMenu, plugin, pluginInst, ref;
        this.page_type = page_type;
        CSS.addStyleElement("#WikiMonkeyMenu input.margin {margin:0 0.33em 0.33em 0;}");
        mainDiv = $('<div/>').attr('id', 'WikiMonkeyMenu');
        groupActions = {};
        for (i = 0, len = plugins.length; i < len; i++) {
          Plugin = plugins[i];
          plugin = new Plugin(this.WM);
          pluginInst = plugin.conf[this.page_type + '_menu'];

          if (!pluginInst || !pluginInst.length) {
            continue;
          }
          if (plugin.makeUI) {
            groupAction = [this.warnInputNeeded, plugin];
          } else {
            groupAction = [this.executeEntryAction, plugin];
          }
          pluginInst.unshift("WikiMonkeyMenuRoot");
          currId = false;
          for (m = j = 0, ref = pluginInst.length - 1; 0 <= ref ? j < ref : j > ref; m = 0 <= ref ? ++j : --j) {
            parentId = currId;
            currId = pluginInst.slice(0, m + 1).join("-").replace(/ /g, "_");

            menuSel = mainDiv.children('div[id=\'' + currId + '\']');
            if (!menuSel.length) {
              currMenu = $("<div/>").attr("id", currId).hide().appendTo(mainDiv);
              groupActions[currId] = [];
              if (m > 0) {
                parentMenu = mainDiv.children('div[id=\'' + parentId + '\']');
                $('<input/>').attr('type', 'button').val('<').addClass('margin').click(makeChangeMenu(currMenu, parentMenu)).appendTo(currMenu);
                $('<input/>').attr('type', 'button').val(pluginInst[m]).click(makeGroupAction(groupActions[currId])).appendTo(parentMenu);
                $('<input/>').attr('type', 'button').val('>').addClass('margin').click(makeChangeMenu(parentMenu, currMenu)).appendTo(parentMenu);
              }
            } else {
              currMenu = menuSel.first();
            }
            groupActions[currId].push(groupAction);
          }
          entry = $("<input/>").attr('type', 'button').val(pluginInst[pluginInst.length - 1]).addClass('margin').appendTo(currMenu);
          if (plugin.makeUI) {
            entry.click(this.makeEntryUI(currMenu, plugin));
          } else {
            entry.click(this.makeEntryAction(plugin));
          }
        }
        menus = mainDiv.children();
        if (menus.length) {
          execAll = $('<input/>').attr('type', 'button').val("*").addClass('margin').click(makeGroupAction(groupActions["WikiMonkeyMenuRoot"]));

          mainDiv.children("div[id='WikiMonkeyMenuRoot']").first().prepend(execAll);
          menus.first().show();
          return mainDiv[0];
        } else {
          return false;
        }
      }
    }, {
      key: 'makeEntryUI',
      value: function makeEntryUI(currMenu, plugin) {
        var _this = this;

        return function (event) {
          var UI, UIdiv;
          currMenu.hide();
          UIdiv = $('<div/>');
          $('<input/>').attr('type', 'button').val('<').addClass('margin').click(function (event) {
            UIdiv.remove();
            return currMenu.show();
          }).appendTo(UIdiv);
          $('<input/>').attr('type', 'button').val('Execute').click(_this.makeEntryAction(plugin)).appendTo(UIdiv);
          UI = plugin.makeUI();
          return UIdiv.append(UI).insertAfter(currMenu);
        };
      }
    }, {
      key: 'makeEntryAction',
      value: function makeEntryAction(plugin) {
        var _this2 = this;

        return function (event) {
          return _this2.executeEntryAction(plugin, null);
        };
      }
    }, {
      key: 'executeEntryAction',
      value: function executeEntryAction(plugin, callNext) {
        this.WM.Log.logHidden("Plugin: " + plugin.constructor.name);
        return plugin['main_' + this.page_type](callNext);
      }
    }, {
      key: 'warnInputNeeded',
      value: function warnInputNeeded(plugin, callNext) {
        this.WM.Log.logWarning("Plugin " + plugin.constructor.name + " was not executed because it requires input from its interface.");
        if (callNext) {
          return callNext();
        }
      }
    }]);

    return exports;
  }();

  ;

  makeChangeMenu = function makeChangeMenu(currentMenu, changeMenu) {
    return function (event) {
      currentMenu.hide();
      return changeMenu.show();
    };
  };

  makeGroupAction = function makeGroupAction(subGroupActions) {
    return function (event) {
      return _executeGroupAction(subGroupActions, -1);
    };
  };

  _executeGroupAction = function executeGroupAction(subGroupActions, id) {
    var callContinue, fid;
    id++;
    if (subGroupActions[id]) {
      fid = subGroupActions[id];
      callContinue = function callContinue() {
        return _executeGroupAction(subGroupActions, id);
      };
      return fid[0](fid[1], callContinue);
    }
  };

  return exports;
}.call(undefined);

},{"@kynikos/misc/dist/CSS":2}],407:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var CSS;

CSS = require('@kynikos/misc/dist/CSS');

module.exports = function () {
  var disableEditSummarySubmitOnEnter, hideRollbackLinks, scrollToFirstHeading;

  var exports = function () {
    function exports(WM) {
      _classCallCheck(this, exports);

      this.WM = WM;
    }

    _createClass(exports, [{
      key: 'applyEditorMods',
      value: function applyEditorMods() {
        if (this.WM.conf.disable_edit_summary_submit_on_enter) {
          disableEditSummarySubmitOnEnter();
        }
        if (this.WM.conf.scroll_to_first_heading) {
          return scrollToFirstHeading();
        }
      }
    }, {
      key: 'applyRecentChangesMods',
      value: function applyRecentChangesMods() {
        if (this.WM.conf.hide_rollback_links) {
          return hideRollbackLinks();
        }
      }
    }, {
      key: 'applyContributionsMods',
      value: function applyContributionsMods() {
        if (this.WM.conf.hide_rollback_links) {
          return hideRollbackLinks();
        }
      }
    }]);

    return exports;
  }();

  ;

  disableEditSummarySubmitOnEnter = function disableEditSummarySubmitOnEnter() {
    return $('#wpSummary').keydown(function (event) {
      if (event.key === 'Enter' || typeof event.key === 'undefined' && event.keyCode === 13) {
        event.preventDefault();
        return false;
      }
    });
  };

  hideRollbackLinks = function hideRollbackLinks() {
    return CSS.addStyleElement("span.mw-rollback-link {display:none;}");
  };

  scrollToFirstHeading = function scrollToFirstHeading() {
    return window.scrollTo(0, $('#firstHeading').offset().top);
  };

  return exports;
}.call(undefined);

},{"@kynikos/misc/dist/CSS":2}],408:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var RegEx, Str;

RegEx = require('@kynikos/misc/dist/RegEx');

Str = require('@kynikos/misc/dist/Str');

module.exports = function () {
  var prepareRegexpWhitespace, prepareTitleCasing;

  var exports = function () {
    function exports(WM) {
      _classCallCheck(this, exports);

      this.WM = WM;
    }

    _createClass(exports, [{
      key: 'squashContiguousWhitespace',
      value: function squashContiguousWhitespace(title) {
        return title.replace(/[_ ]+/g, " ");
      }
    }, {
      key: 'neutralizeNowikiTags',
      value: function neutralizeNowikiTags(source) {
        var CLOSELENGTH, OPENLENGTH, i, len, maskLength, maskString, maskedText, prevId, tag, tags;

        OPENLENGTH = 8;
        CLOSELENGTH = 9;
        tags = Str.findSimpleEnclosures(source, /<nowiki>/i, OPENLENGTH, /<\/nowiki>/i, CLOSELENGTH);
        maskedText = "";
        prevId = 0;
        for (i = 0, len = tags.length; i < len; i++) {
          tag = tags[i];
          if (tag[1]) {
            maskLength = tag[1] - tag[0] + CLOSELENGTH;
            maskString = Str.padRight("", "x", maskLength);
            maskedText += source.substring(prevId, tag[0]) + maskString;
            prevId = tag[1] + CLOSELENGTH;
            continue;
          } else {
            maskLength = source.substr(tag[0]).length;
            maskString = Str.padRight("", "x", maskLength);
            maskedText += source.substring(prevId, tag[0]) + maskString;
            prevId = source.length;
            break;
          }
        }
        maskedText += source.substring(prevId);
        return maskedText;
      }
    }, {
      key: 'dotEncode',
      value: function dotEncode(text) {
        return encodeURIComponent(text).replace(/%/g, ".");
      }
    }, {
      key: 'dotEncodeLinkBreakingFragmentCharacters',
      value: function dotEncodeLinkBreakingFragmentCharacters(fragment) {
        fragment = fragment.replace(/\[/g, ".5B");
        fragment = fragment.replace(/\]/g, ".5D");
        fragment = fragment.replace(/\{/g, ".7B");
        fragment = fragment.replace(/\}/g, ".7D");
        fragment = fragment.replace(/\|/g, ".7C");
        return fragment;
      }
    }, {
      key: 'compareArticleTitles',
      value: function compareArticleTitles(title1, title2) {
        var t1, t2;

        t1 = prepareTitleCasing(this.squashContiguousWhitespace(title1).trim());
        t2 = prepareTitleCasing(this.squashContiguousWhitespace(title2).trim());
        return t1 === t2;
      }
    }, {
      key: 'findBehaviorSwitches',
      value: function findBehaviorSwitches(source, word) {
        var regExp;
        source = this.neutralizeNowikiTags(source);
        regExp;
        if (word) {
          regExp = new RegExp("__" + RegEx.escapePattern(word) + "__", "gi");
        } else {
          regExp = new RegExp("__(TOC|NOTOC|FORCETOC|NOEDITSECTION|" + "NEWSECTIONLINK|NONEWSECTIONLINK|NOGALLERY|HIDDENCAT|" + "NOCONTENTCONVERT|NOCC|NOTITLECONVERT|NOTC|INDEX|" + "NOINDEX|STATICREDIRECT|START|END)__", "gi");
        }
        return RegEx.matchAll(source, regExp);
      }
    }, {
      key: 'findLinksEngine',
      value: function findLinksEngine(source, titlePattern, specialOnly, caseSensitive) {
        var dbrace, dbraces, flags, i, inText, len, links, maskedText, match, nSource, nText, push, regExp, special;

        flags = caseSensitive ? "" : "i";

        special = specialOnly ? "(?:[ _]+:)?[ _]*" : "(?:\\:?[ _]*){0,2}";
        regExp = new RegExp("^" + special + "(" + titlePattern + ")" + "[ _]*(?:\\|[_\\s]*([\\s\\S]+?)[_\\s]*)?[_\\s]*$", flags);
        nSource = this.neutralizeNowikiTags(source);
        links = [];
        dbraces = Str.findInnermostEnclosures(nSource, "[[", "]]");
        for (i = 0, len = dbraces.length; i < len; i++) {
          dbrace = dbraces[i];
          inText = source.substring(dbrace[0] + 2, dbrace[1]);
          match = regExp.exec(inText);
          if (match) {
            push = true;
            if (match[6]) {
              nText = this.neutralizeNowikiTags(match[6]);
              maskedText = Str.findNestedEnclosures(nText, "{{", "}}", "x")[1];
              if (maskedText.search(/(\{\{|\}\})/) > -1) {
                this.WM.Log.logWarning("[[" + match[0] + "]] seems to contain part of a template, and the resulting behaviour cannot be predicted by this function, so the link will be ignored altogether");
                push = false;
              }
            }
            if (push) {
              links.push({
                "rawLink": "[[" + match[0] + "]]",
                "link": match[1],
                "rawTitle": match[2],
                "namespace": match[3],
                "title": match[4],
                "fragment": match[5],
                "anchor": match[6],
                "index": dbrace[0],
                "length": dbrace[1] + 2 - dbrace[0]
              });
            }
          }
        }
        return links;
      }
    }, {
      key: 'findSectionLinks',
      value: function findSectionLinks(source) {
        var fragmentChars, titlePattern;

        fragmentChars = "[^\\n\\{\\}\\[\\]\\|]*?";
        titlePattern = "(()())#(" + fragmentChars + ")";
        return this.findLinksEngine(source, titlePattern, false, true);
      }
    }, {
      key: 'findInternalLinks',
      value: function findInternalLinks(source, namespace, title) {
        var caseSensitive, fragmentChars, namespaceChars, rens, retitle, titleChars, titlePattern;

        namespaceChars = "[^\\n\\{\\}\\[\\]\\|\\:\\#]+?";
        titleChars = "[^\\n\\{\\}\\[\\]\\|\\#]+?";
        fragmentChars = "[^\\n\\{\\}\\[\\]\\|]*?";
        if (namespace) {
          rens = prepareRegexpWhitespace(RegEx.escapePattern(namespace));
          if (title) {
            retitle = prepareRegexpWhitespace(RegEx.escapePattern(title));
            titlePattern = "((" + rens + ")[ _]*:[ _]*" + "(" + retitle + "))" + "(?:[ _]*#(" + fragmentChars + "))?";

            caseSensitive = true;
          } else {
            titlePattern = "((" + rens + ")[ _]*:[ _]*" + "(" + titleChars + "))" + "(?:[ _]*#(" + fragmentChars + "))?";

            caseSensitive = false;
          }
        } else if (title) {
          retitle = prepareRegexpWhitespace(RegEx.escapePattern(title));

          titlePattern = "(()(" + retitle + "))" + "(?:[ _]*#(" + fragmentChars + "))?";

          caseSensitive = true;
        } else {
          titlePattern = "((?:(" + namespaceChars + ")[ _]*:[ _]*)?" + "(" + titleChars + "))" + "(?:[ _]*#(" + fragmentChars + "))?";
          caseSensitive = true;
        }
        return this.findLinksEngine(source, titlePattern, false, caseSensitive);
      }
    }, {
      key: 'findInterwikiLinks',
      value: function findInterwikiLinks(source, wiki) {
        return this.findInternalLinks(source, wiki);
      }
    }, {
      key: 'findSpecialLinks',
      value: function findSpecialLinks(source, pattern) {
        var fragmentChars, titleChars, titlePattern;

        titleChars = "[^\\n\\{\\}\\[\\]\\|\\#]+?";
        fragmentChars = "[^\\n\\{\\}\\[\\]\\|]*?";
        titlePattern = "((" + pattern + ")[ _]*:[ _]*" + "(" + titleChars + "))" + "(?:[ _]*#(" + fragmentChars + "))?";

        return this.findLinksEngine(source, titlePattern, true, false);
      }
    }, {
      key: 'findCategories',
      value: function findCategories(source) {
        return this.findSpecialLinks(source, "Category");
      }
    }, {
      key: 'findInterlanguageLinks',
      value: function findInterlanguageLinks(source, language) {
        return this.findSpecialLinks(source, RegEx.escapePattern(language));
      }
    }, {
      key: 'findVariables',
      value: function findVariables(source, variable) {
        var pattern;

        pattern = RegEx.escapePattern(variable);
        return this.findVariablesPattern(source, pattern);
      }
    }, {
      key: 'findVariablesPattern',
      value: function findVariablesPattern(source, pattern) {
        var dbracket, dbrackets, i, inText, len, match, nSource, regExp, results;

        nSource = this.neutralizeNowikiTags(source);
        results = [];
        dbrackets = Str.findNestedEnclosures(nSource, "{{", "}}", "x")[0];
        for (i = 0, len = dbrackets.length; i < len; i++) {
          dbracket = dbrackets[i];
          inText = source.substring(dbracket[0] + 2, dbracket[1]);

          regExp = new RegExp("^\\s*(" + pattern + ")" + "(?:\\:\\s*([\\s\\S]*?))?\\s*$", "");
          match = regExp.exec(inText);
          if (match) {
            results.push({
              "rawVariable": "{{" + match[0] + "}}",
              "name": match[1],
              "value": match[2],
              "index": dbracket[0],
              "length": dbracket[1] + 2 - dbracket[0]
            });
          }
        }
        return results;
      }
    }, {
      key: 'findTransclusionsEngine',
      value: function findTransclusionsEngine(source, pattern, templatesOnly) {
        var argIndex, dbracket, dbrackets, i, inText, len, match, nSource, regExp, transclusions;

        regExp = new RegExp("^(\\s*" + (templatesOnly ? "" : ":?") + "[_ ]*(" + pattern + ")[_ ]*\\s*)" + "(?:\\|([\\s\\S]*))?$", "");
        nSource = this.neutralizeNowikiTags(source);
        transclusions = [];
        dbrackets = Str.findNestedEnclosures(nSource, "{{", "}}", "x")[0];
        for (i = 0, len = dbrackets.length; i < len; i++) {
          dbracket = dbrackets[i];
          inText = source.substring(dbracket[0] + 2, dbracket[1]);
          match = regExp.exec(inText);
          if (match) {
            argIndex = dbracket[0] + match[1].length + 3;
            transclusions.push({
              "rawTransclusion": "{{" + match[0] + "}}",
              "title": match[2],
              "index": dbracket[0],
              "length": dbracket[1] - dbracket[0] + 2,
              "arguments": this.findTransclusionArguments(match, argIndex)
            });
          }
        }
        return transclusions;
      }
    }, {
      key: 'findTransclusionArguments',
      value: function findTransclusionArguments(match, argIndex) {
        var argL, args, argument, eqIndex, i, key, keyIndex, keyMatches, len, mArgs, mArgument, maskedArgs, nArgs, rawArguments, rawKey, reKey, relIndex, value, valueIndex;
        rawArguments = match[3];
        args = [];
        if (rawArguments) {
          nArgs = this.neutralizeNowikiTags(rawArguments);

          maskedArgs = Str.findNestedEnclosures(nArgs, "[[", "]]", "x")[1];

          maskedArgs = Str.findNestedEnclosures(maskedArgs, "{{", "}}", "x")[1];

          if (maskedArgs.search(/(\{\{|\}\}|\[\[|\]\])/) > -1) {
            this.WM.Log.logWarning("{{" + match[0] + "}} seems to contain part of a link or template, and the resulting behaviour cannot be predicted by this function, so the whole template will be ignored altogether");
          } else {
            mArgs = maskedArgs.split("|");
            relIndex = 0;
            for (i = 0, len = mArgs.length; i < len; i++) {
              mArgument = mArgs[i];
              argL = mArgument.length;
              argument = rawArguments.substr(relIndex, argL);
              eqIndex = mArgument.indexOf("=");

              if (eqIndex > 0) {
                rawKey = argument.substring(0, eqIndex);
                reKey = /^(\s*)(.+?)\s*$/;
                keyMatches = reKey.exec(rawKey);
                key = keyMatches[2];
                keyIndex = argIndex + (keyMatches[1] ? keyMatches[1].length : 0);

                value = argument.substr(eqIndex + 1);
                valueIndex = argIndex + keyMatches[0].length + 1;
              } else {
                key = null;
                keyIndex = null;
                value = argument;
                valueIndex = argIndex;
              }
              args.push({
                key: key,
                key_index: keyIndex,
                value: value,
                value_index: valueIndex
              });

              relIndex += argL + 1;
            }
          }
        }
        return args;
      }
    }, {
      key: 'findTemplates',
      value: function findTemplates(source, template) {
        var pattern;
        if (template) {
          pattern = RegEx.escapePattern(template);
          pattern = prepareRegexpWhitespace(pattern);
          pattern = prepareTitleCasing(pattern);
        } else {
          pattern = "[^\\n\\{\\}\\[\\]\\||\\#]+?";
        }
        return this.findTemplatesPattern(source, pattern);
      }
    }, {
      key: 'findTemplatesPattern',
      value: function findTemplatesPattern(source, pattern) {
        return this.findTransclusionsEngine(source, pattern, true);
      }
    }, {
      key: 'findTransclusions',
      value: function findTransclusions(source, namespace, title) {
        var namespacePattern, pattern, titleChars, titlePattern;

        titleChars = "[^\\n\\{\\}\\[\\]\\||\\#]+?";
        if (namespace) {
          namespacePattern = RegEx.escapePattern(namespace);
          namespacePattern = prepareRegexpWhitespace(namespacePattern);
          namespacePattern = prepareTitleCasing(namespacePattern);
        }
        if (title) {
          titlePattern = RegEx.escapePattern(title);
          titlePattern = prepareRegexpWhitespace(titlePattern);
          titlePattern = prepareTitleCasing(titlePattern);
        }
        if (namespacePattern && titlePattern) {
          pattern = namespacePattern + "[ _]*:[ _]*" + titlePattern;
        } else if (!namespacePattern && titlePattern) {
          pattern = titlePattern;
        } else if (namespacePattern && !titlePattern) {
          pattern = namespacePattern + "[ _]*:" + titleChars;
        } else {
          pattern = titleChars;
        }
        return this.findTransclusionsEngine(source, pattern, false);
      }
    }, {
      key: 'findSectionHeadings',
      value: function findSectionHeadings(source) {
        var L0, L1, MAXLEVEL, cleanheading, end, heading, i, len, level, line, match, maxTocLevel, minLevel, pLevel, prevLevels, rawheading, regExp, sections, start, tocLevel, tocPeer;

        MAXLEVEL = 6;
        sections = [];
        minLevel = MAXLEVEL;
        maxTocLevel = 0;
        tocLevel = 1;
        regExp = /^(\=+([ _]*(.+?)[ _]*)\=+)[ \t]*$/gm;
        while (true) {
          match = regExp.exec(source);
          if (match) {
            L0 = match[0].length;
            line = match[1];
            rawheading = match[2];
            heading = match[3];
            cleanheading = this.squashContiguousWhitespace(heading);
            L1 = line.length;
            level = 1;
            start = "=";
            end = "=";

            while (true) {
              start = line.substr(level, 1);
              end = line.substr(L1 - level - 1, 1);
              if (L1 - level * 2 > 2 && start === "=" && end === "=") {
                level++;
              } else {
                if (level > MAXLEVEL) {
                  level = MAXLEVEL;
                } else if (level < minLevel) {
                  minLevel = level;
                }
                break;
              }
            }
            if (level === minLevel) {
              tocLevel = 1;
              prevLevels = {};
              prevLevels[level] = 1;
              prevLevels.relMax = level;
              if (maxTocLevel === 0) {
                maxTocLevel = tocLevel;
              }
            } else if (level > prevLevels.relMax) {
              tocLevel++;
              prevLevels[level] = tocLevel;
              prevLevels.relMax = level;
              if (tocLevel > maxTocLevel) {
                maxTocLevel = tocLevel;
              }
            } else if (level < prevLevels.relMax) {
              if (prevLevels[level]) {
                tocLevel = prevLevels[level];
              } else {
                tocPeer = prevLevels.relMax;
                for (i = 0, len = prevLevels.length; i < len; i++) {
                  pLevel = prevLevels[i];
                  if (pLevel > level && pLevel < tocPeer) {
                    tocPeer = pLevel;
                  }
                }
                tocLevel = prevLevels[tocPeer];
                prevLevels[level] = tocLevel;
              }
              prevLevels.relMax = level;
            }
            sections.push({
              line: line,
              rawheading: rawheading,
              heading: heading,
              cleanheading: cleanheading,
              level: level,
              tocLevel: tocLevel,
              index: regExp.lastIndex - L0,
              length0: L0,
              length1: L1
            });
          } else {
            break;
          }
        }

        if (maxTocLevel === 0) {
          minLevel = 0;
        }
        return {
          sections: sections,
          minLevel: minLevel,
          maxTocLevel: maxTocLevel
        };
      }
    }]);

    return exports;
  }();

  ;

  prepareRegexpWhitespace = function prepareRegexpWhitespace(title) {
    return title.replace(/[_ ]+/g, "[_ ]+");
  };

  prepareTitleCasing = function prepareTitleCasing(pattern) {
    var fcLower, fcUpper, firstChar;
    firstChar = pattern.charAt(0);
    fcUpper = firstChar.toUpperCase();
    fcLower = firstChar.toLowerCase();
    if (fcUpper !== fcLower) {
      pattern = "[" + fcUpper + fcLower + "]" + pattern.substr(1);
    }
    return pattern;
  };

  return exports;
}.call(undefined);

},{"@kynikos/misc/dist/RegEx":6,"@kynikos/misc/dist/Str":7}],409:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

module.exports = function () {
  function exports(WM) {
    _classCallCheck(this, exports);

    this.WM = WM;
  }

  _createClass(exports, [{
    key: 'route',
    value: function route() {
      var UI, conf, display, displayLog, nextNode, specialPage;

      specialPage = function () {
        var spage;
        spage = mw.config.get('wgCanonicalSpecialPageName');
        if (spage) {
          return spage.toLowerCase();
        }
        return spage;
      }();
      display = true;
      displayLog = true;

      if ($('#editform').length) {
        nextNode = $('#wpSummaryLabel').parent().next()[0];
        conf = this.WM.Plugins.editor;
        UI = conf.length ? this.WM.Menu._makeUI('editor', conf) : null;
        this.WM.Mods.applyEditorMods();
      } else if (mw.config.get('wgDiffNewId')) {
        nextNode = $('#bodyContent h2').first()[0];
        conf = this.WM.Plugins.diff;
        UI = conf.length ? this.WM.Menu._makeUI('diff', conf) : null;
      } else if (mw.config.get('wgCanonicalNamespace') === 'Category') {
        nextNode = $('#contentSub')[0];
        conf = this.WM.Plugins.bot;
        UI = conf.length ? this.WM.Bot._makeUI(conf, [[$('#mw-pages')[0], 0, "Pages"], [$('#mw-subcategories')[0], 0, "Subcategories"]]) : null;
        display = false;
      } else if (specialPage === "whatlinkshere") {
        nextNode = $('#bodyContent form').first().next()[0];
        conf = this.WM.Plugins.bot;
        UI = conf.length ? this.WM.Bot._makeUI(conf, [[$('#mw-whatlinkshere-list')[0], 0, "Pages"]]) : null;
        display = false;
      } else if (specialPage === "linksearch" && $('#mw-content-text div.mw-spcontent').length) {
        nextNode = $('#mw-content-text div.mw-spcontent').first()[0];
        conf = this.WM.Plugins.bot;
        UI = conf.length ? this.WM.Bot._makeUI(conf, [[$(nextNode).first('ol.special').first()[0], 1, "Pages"]]) : null;
        display = false;
      } else if (specialPage === "prefixindex") {
        nextNode = $('#mw-content-text div.mw-prefixindex-body').first()[0];
        conf = this.WM.Plugins.bot;
        UI = conf.length ? this.WM.Bot._makeUI(conf, [[$(nextNode).find('ul.mw-prefixindex-list').first()[0], 0, "Pages"]]) : null;
        display = false;
      } else if (specialPage === "specialpages") {
        nextNode = $('#contentSub')[0];
        conf = this.WM.Plugins.special;
        UI = conf.length ? this.WM.Menu._makeUI('special', conf) : null;
      } else if (specialPage === "recentchanges") {
        nextNode = $('#mw-content-text h4').first()[0];
        conf = this.WM.Plugins.recentchanges;
        UI = conf.length ? this.WM.Filters._makeUI('recentchanges', conf) : null;
        displayLog = false;
        this.WM.Mods.applyRecentChangesMods();
      } else if (specialPage === "newpages") {
        nextNode = $('#mw-content-text ul').first()[0];
        conf = this.WM.Plugins.newpages;
        UI = conf.length ? this.WM.Filters._makeUI('newpages', conf) : null;
        displayLog = false;
      } else if (specialPage === "protectedpages") {
        nextNode = $('#mw-content-text table.mw-protectedpages').first()[0];
        conf = this.WM.Plugins.bot;
        UI = conf.length ? this.WM.Bot._makeUI(conf, [[$(nextNode).find('tbody').first()[0], 0, "Pages"]]) : null;
        display = false;
      } else if (specialPage === "contributions") {
        this.WM.Mods.applyContributionsMods();
      } else if (specialPage === "ancientpages" || specialPage === "brokenredirects" || specialPage === "deadendpages" || specialPage === "doubleredirects" || specialPage === "fewestrevisions" || specialPage === "lonelypages" || specialPage === "uncategorizedcategories" || specialPage === "uncategorizedpages" || specialPage === "uncategorizedtemplates" || specialPage === "unusedcategories" || specialPage === "unwatchedpages") {
        nextNode = $('#mw-content-text div.mw-spcontent').first()[0];
        conf = this.WM.Plugins.bot;
        UI = conf.length ? this.WM.Bot._makeUI(conf, [[$(nextNode).find('ol').first()[0], 0, "Pages"]]) : null;
        display = false;
      } else if (specialPage === "longpages" || specialPage === "shortpages") {
        nextNode = $('#mw-content-text div.mw-spcontent').first()[0];
        conf = this.WM.Plugins.bot;
        UI = conf.length ? this.WM.Bot._makeUI(conf, [[$(nextNode).find('ol').first()[0], 1, "Pages"]]) : null;
        display = false;
      } else if (specialPage === "withoutinterwiki") {
        nextNode = $('#mw-content-text div.mw-spcontent > p').first()[0];
        conf = this.WM.Plugins.bot;
        UI = conf.length ? this.WM.Bot._makeUI(conf, [[$(nextNode).nextAll('ol').first()[0], 0, "Pages"]]) : null;
        display = false;
      } else if (specialPage === "allpages") {
        nextNode = $('#mw-content-text div.mw-allpages-nav').first()[0];
        conf = this.WM.Plugins.bot;
        UI = conf.length ? this.WM.Bot._makeUI(conf, [[$(nextNode).nextAll('div.mw-allpages-body').first().find('ul').first()[0], 0, "Pages"]]) : null;
        display = false;
      }
      if (UI) {
        return this.WM.UI._makeUI({ display: display, displayLog: displayLog, nextNode: nextNode, UI: UI });
      }
    }
  }]);

  return exports;
}();

},{}],410:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Str;

Str = require('@kynikos/misc/dist/Str');

module.exports = function () {
  function exports(WM) {
    _classCallCheck(this, exports);

    this.WM = WM;
  }

  _createClass(exports, [{
    key: 'appendRow',
    value: function appendRow(source, mark, values) {
      var endtable, lastId, newText, row;
      lastId = source.lastIndexOf('|}' + mark);
      endtable = lastId > -1 ? lastId : source.lastIndexOf('|}');
      row = "|-\n|" + values.join("\n|") + "\n";
      newText = Str.insert(source, row, endtable);
      return newText;
    }
  }]);

  return exports;
}();

},{"@kynikos/misc/dist/Str":7}],411:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var CSS, version;

var _require = require('../../package.json');

version = _require.version;


CSS = require('@kynikos/misc/dist/CSS');

module.exports = function () {
  function exports(WM) {
    _classCallCheck(this, exports);

    this.WM = WM;
  }

  _createClass(exports, [{
    key: '_makeUI',
    value: function _makeUI(_ref) {
      var display = _ref.display,
          displayLog = _ref.displayLog,
          nextNode = _ref.nextNode,
          UI = _ref.UI;

      var date, hide, legend, logArea, main, main2;
      CSS.addStyleElement("#WikiMonkey {position:relative;} #WikiMonkey fieldset {margin:0 0 1em 0;}");
      main = document.createElement('fieldset');
      main.id = 'WikiMonkey';
      legend = document.createElement('legend');
      legend.appendChild(document.createTextNode('Wiki Monkey '));
      hide = document.createElement('a');
      hide.href = '#WikiMonkey';
      hide.innerHTML = '[hide]';
      hide.addEventListener("click", function (event) {
        var wmmain;
        event.preventDefault();
        wmmain = document.getElementById('WikiMonkeyMain');
        if (wmmain.style.display === 'none') {
          wmmain.style.display = 'block';
          return this.innerHTML = '[hide]';
        } else {
          wmmain.style.display = 'none';
          return this.innerHTML = '[show]';
        }
      }, false);
      legend.appendChild(hide);
      main.appendChild(legend);
      main2 = document.createElement('div');
      main2.id = 'WikiMonkeyMain';
      main2.appendChild(UI);
      logArea = this.WM.Log._makeLogArea();
      if (!displayLog) {
        logArea.style.display = 'none';
      }
      main2.appendChild(logArea);
      if (!display) {
        main2.style.display = 'none';
        hide.innerHTML = '[show]';
      }
      main.appendChild(main2);
      nextNode.parentNode.insertBefore(main, nextNode);
      this.WM.Log.logHidden('Wiki Monkey version: ' + version);
      date = new Date();
      this.WM.Log.logHidden('Date: ' + date.toString());
      return this.WM.Log.logHidden('URL: ' + location.href);
    }
  }]);

  return exports;
}();

},{"../../package.json":395,"@kynikos/misc/dist/CSS":2}],412:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var A,
    Br,
    Div,
    moment,
    version,
    indexOf = [].indexOf;

var _require = require('./libs');

moment = _require.moment;
A = _require.A;
Br = _require.Br;
Div = _require.Div;

var _require2 = require('../../package.json');

version = _require2.version;


module.exports = function () {
  var REPO_RAW_URL;

  var exports = function () {
    function exports(WM) {
      _classCallCheck(this, exports);

      this.WM = WM;
    }

    _createClass(exports, [{
      key: 'check_and_notify',
      value: function () {
        var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
          var _this = this;

          var upstream_package;
          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  if (!this.should_check()) {
                    _context.next = 9;
                    break;
                  }

                  _context.next = 3;
                  return $.getJSON(REPO_RAW_URL + '/' + this.WM.conf.update_check_branch + '/package.json');

                case 3:
                  upstream_package = _context.sent;

                  if (!(version !== upstream_package.version)) {
                    _context.next = 8;
                    break;
                  }

                  return _context.abrupt('return', this.display_notification(['Version ' + upstream_package.version + ' is available.', Br(), A({
                    href: "https://github.com/kynikos/wiki-monkey/wiki/Changelog" }, "Changelog"), Br(), A('Run upgrade', {
                    onclick: function onclick() {
                      return _this.upgrade(upstream_package.version);
                    }
                  })]));

                case 8:
                  return _context.abrupt('return', mw.storage.set('WikiMonkey-last-update-check', moment().format('YYYY-MM-DD')));

                case 9:
                case 'end':
                  return _context.stop();
              }
            }
          }, _callee, this);
        }));

        function check_and_notify() {
          return _ref.apply(this, arguments);
        }

        return check_and_notify;
      }()
    }, {
      key: 'should_check',
      value: function should_check() {
        var diff, lastupdcheck, ref;
        lastupdcheck = mw.storage.get('WikiMonkey-last-update-check');
        if (!lastupdcheck) {
          return true;
        }
        diff = moment().diff(moment(lastupdcheck), 'days');

        if (diff >= 1 && (ref = moment().day(), indexOf.call(this.WM.conf.update_check_wdays, ref) >= 0) || diff >= 7) {
          return true;
        }
        return false;
      }
    }, {
      key: 'display_notification',
      value: function display_notification(content, optionsoverride) {
        var options;
        options = {
          autoHide: false,
          tag: 'WikiMonkey-upgrade',
          title: 'Wiki Monkey',
          type: 'info'
        };
        $.extend(options, optionsoverride);
        return mw.notification.notify(content, options);
      }
    }, {
      key: 'upgrade',
      value: function upgrade(upstream_version) {
        var _this2 = this;

        var page, pagelink, regex;
        page = 'User:' + mw.user.getName() + '/common.js';
        pagelink = this.WM.MW.linkArticle(page);
        this.display_notification('Upgrading to version ' + upstream_version + '...');

        regex = RegExp('(["\']https?://.+?/kynikos/wiki-monkey/v)' + mw.RegExp.escape(version) + '(/dist/WikiMonkey-[^/]+\\.js["\'])', "g");
        return this.WM.MW.api.edit(page, function (revision) {
          var newtext;
          newtext = revision.content.replace(regex, '$1' + upstream_version + '$2');
          if (newtext === revision.content) {
            return Promise.reject(new Error("Could not find Wiki Monkey loader line"));
          }
          return {
            text: newtext,
            summary: 'Update Wiki Monkey to version ' + upstream_version,
            bot: true
          };
        }).done(function (result) {
          console.log(result);
          return _this2.display_notification(["Upgrade successful: you need to refresh the open wiki page(s) in order to use the new version.", Br(), A({
            href: "https://github.com/kynikos/wiki-monkey/wiki/Changelog"
          }, "Changelog")]);
        }).fail(function (code, error) {
          console.error(code, error);
          return _this2.display_notification(['Could not complete the upgrade to version ' + upstream_version + ': ', A({
            onclick: function onclick() {
              return _this2.upgrade(upstream_version);
            }
          }, "retry"), " in case it was a temporary problem; it is also possible that Wiki Monkey is installed in a non-standard way in ", pagelink, " and the upgrade should be executed manually; finally, it is possible that the upgrade was already launched and completed from another page: in this case refresh the page to verify."], {
            type: 'error'
          });
        });
      }
    }, {
      key: 'check_obsolete_config',
      value: function check_obsolete_config() {
        var _this3 = this;

        var blob, confhref, oldconf;

        oldconf = localStorage.getItem("WikiMonkey");
        if (oldconf !== null) {
          blob = new Blob([oldconf], {
            type: 'application/json'
          });
          confhref = window.URL.createObjectURL(blob);
          return this.display_notification(["Wiki Monkey 4.0.0 uses a completely rewritten configuration system. After updating, your old configuration was not automatically imported, but it is still saved in your browser's localStorage. You can decide to export it and then merge it manually, or simply remove it and use the default configuration options.", Br(), A({
            href: "https://github.com/kynikos/wiki-monkey/wiki/Configuration" }, "New configuration instructions"), Br(), A({
            href: confhref
          }, "View old configuration"), Br(), A({
            href: confhref,
            download: "wikimonkey_oldconf.json"
          }, "Export old configuration"), Br(), A({
            onclick: function onclick() {
              localStorage.removeItem("WikiMonkey");
              return _this3.display_notification("The old configuration was successfully removed.", {
                autoHide: true
              });
            }
          }, "Delete old configuration")]);
        }
      }
    }]);

    return exports;
  }();

  ;

  REPO_RAW_URL = "https://raw.githubusercontent.com/kynikos/wiki-monkey";

  return exports;
}.call(undefined);

},{"../../package.json":395,"./libs":415}],413:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

module.exports = function () {
  function exports(WM) {
    _classCallCheck(this, exports);

    this.WM = WM;
  }

  _createClass(exports, [{
    key: 'isWhatLinksHerePage',
    value: function isWhatLinksHerePage() {
      if (document.getElementById('mw-whatlinkshere-list')) {
        return true;
      } else {
        return false;
      }
    }
  }, {
    key: 'getTitle',
    value: function getTitle() {
      return document.getElementById('contentSub').getElementsByTagName('a')[0].title;
    }
  }]);

  return exports;
}();

},{}],414:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ArchWiki, Bot, Cat, Diff, Editor, Filters, Interlanguage, Log, MW, Menu, Mods, Parser, Plugin, Router, Tables, UI, Upgrade, WhatLinksHere, mwmodpromise;

mwmodpromise = mw.loader.using(['mediawiki.api.edit', 'mediawiki.notification']);

require('./libs');

ArchWiki = require('./ArchWiki');

Bot = require('./Bot');

Cat = require('./Cat');

Diff = require('./Diff');

Editor = require('./Editor');

Filters = require('./Filters');

Interlanguage = require('./Interlanguage');

Log = require('./Log');

Menu = require('./Menu');

Mods = require('./Mods');

MW = require('./MW');

Parser = require('./Parser');

Router = require('./Router');

Tables = require('./Tables');

UI = require('./UI');

Upgrade = require('./Upgrade');

WhatLinksHere = require('./WhatLinksHere');

var _require = require('../plugins/_Plugin');

Plugin = _require.Plugin;


module.exports.WM = function () {
  var WM = function () {
    function WM(wiki_name) {
      _classCallCheck(this, WM);

      this.init = this.init.bind(this);
      this.wiki_name = wiki_name;

      for (var _len = arguments.length, installed_plugins_temp = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        installed_plugins_temp[_key - 1] = arguments[_key];
      }

      this.installed_plugins_temp = installed_plugins_temp;
      this.setup();
      $.when(mwmodpromise, $.ready).done(this.init);
    }

    _createClass(WM, [{
      key: 'setup',
      value: function setup() {
        var PluginSub, error, i, interface_, len, option, pmod, pname, ref, user_config, value;

        user_config = window.wikiMonkeyConfig || window.wikimonkey_config || {};
        for (option in user_config) {
          value = user_config[option];
          if (!(option in this.conf)) {
            continue;
          }
          this.conf[option] = value;
          delete user_config[option];
        }
        this.Plugins = {
          bot: [],
          diff: [],
          editor: [],
          newpages: [],
          recentchanges: [],
          special: []
        };
        ref = this.installed_plugins_temp;
        for (i = 0, len = ref.length; i < len; i++) {
          pmod = ref[i];
          for (pname in pmod) {
            PluginSub = pmod[pname];
            if (!(PluginSub.prototype instanceof Plugin)) {
              continue;
            }
            try {
              PluginSub.__configure(this.wiki_name, user_config);
            } catch (error1) {
              error = error1;

              if (error.message === "Plugin disabled") {
                continue;
              }
              throw error;
            }
            for (interface_ in this.Plugins) {
              if (PluginSub.prototype['main_' + interface_]) {
                this.Plugins[interface_].push(PluginSub);
              }
            }
          }
        }
        if (!$.isEmptyObject(user_config)) {
          console.warn("Unkown configuration options", user_config);
        }
        return delete this.installed_plugins_temp;
      }
    }, {
      key: 'init',
      value: function init() {
        this.ArchWiki = new ArchWiki(this);
        this.Bot = new Bot(this);
        this.Cat = new Cat(this);
        this.Diff = new Diff(this);
        this.Editor = new Editor(this);
        this.Filters = new Filters(this);
        this.Interlanguage = new Interlanguage(this);
        this.Log = new Log(this);
        this.Menu = new Menu(this);
        this.Mods = new Mods(this);
        this.MW = new MW(this);
        this.Parser = new Parser(this);
        this.Router = new Router(this);
        this.Tables = new Tables(this);
        this.UI = new UI(this);
        this.Upgrade = new Upgrade(this);
        this.WhatLinksHere = new WhatLinksHere(this);
        this.Upgrade.check_obsolete_config();
        if (this.conf.update_check_wdays) {
          this.Upgrade.check_and_notify();
        }
        return this.Router.route();
      }
    }]);

    return WM;
  }();

  ;

  WM.prototype.conf = {
    default_bot_plugin: "SimpleReplace",
    default_recentchanges_plugin: null,
    default_newpages_plugin: null,
    update_check_wdays: [6],
    update_check_branch: 'master',
    hide_rollback_links: true,
    disable_edit_summary_submit_on_enter: true,
    scroll_to_first_heading: false
  };

  return WM;
}.call(undefined);

},{"../plugins/_Plugin":435,"./ArchWiki":397,"./Bot":398,"./Cat":399,"./Diff":400,"./Editor":401,"./Filters":402,"./Interlanguage":403,"./Log":404,"./MW":405,"./Menu":406,"./Mods":407,"./Parser":408,"./Router":409,"./Tables":410,"./UI":411,"./Upgrade":412,"./WhatLinksHere":413,"./libs":415}],415:[function(require,module,exports){
'use strict';

var helper, hh, jss, tag;

require('babel-polyfill');

hh = require('hyperscript-helpers')(require('hyperscript'));

for (tag in hh) {
  helper = hh[tag];

  module.exports[tag.charAt(0).toUpperCase() + tag.slice(1)] = helper;
}

module.exports.moment = require('moment');

jss = require('jss').default;

jss.setup(require('jss-preset-default').default());

module.exports.jss = jss;

},{"babel-polyfill":8,"hyperscript":342,"hyperscript-helpers":341,"jss":365,"jss-preset-default":354,"moment":389}],416:[function(require,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Plugin,
    indexOf = [].indexOf;

var _require = require('./_Plugin');

Plugin = _require.Plugin;


module.exports.ArchWikiFixHeader = function () {
  var ArchWikiFixHeader = function (_Plugin) {
    _inherits(ArchWikiFixHeader, _Plugin);

    function ArchWikiFixHeader() {
      _classCallCheck(this, ArchWikiFixHeader);

      return _possibleConstructorReturn(this, (ArchWikiFixHeader.__proto__ || Object.getPrototypeOf(ArchWikiFixHeader)).apply(this, arguments));
    }

    _createClass(ArchWikiFixHeader, [{
      key: "main_editor",
      value: function main_editor(callNext) {
        var b, behaviorswitches, bslist, bswitch, cat, categories, catlang, catlink, catlinks, catlist, cattext, cleantitle, content, contentId, displaytitle, dlct, dt, firstChar, fulllink, header, i, interlanguage, iwlinks, iwlist, j, k, l, language, lct, len, len1, len2, len3, link, linklang, linktext, linktitle, lowercasetitle, newText, ref, ref1, source, tempcontent, titlemod, titlemods;
        source = this.WM.Editor.readSource();
        language = this.WM.ArchWiki.detectLanguage(this.WM.Editor.getTitle())[1];
        header = "";
        content = source;

        content = content.replace(/^\s*<noinclude>/, "");
        if (content !== source) {
          header += "<noinclude>\n";
        }

        displaytitle = this.WM.Parser.findVariables(content, "DISPLAYTITLE");
        lowercasetitle = this.WM.Parser.findTemplates(content, "Lowercase title");
        titlemods = displaytitle.concat(lowercasetitle);
        titlemods.sort(function (a, b) {
          return a.index - b.index;
        });
        tempcontent = "";
        contentId = 0;
        for (i = 0, len = titlemods.length; i < len; i++) {
          titlemod = titlemods[i];
          tempcontent += content.substring(contentId, titlemod.index);
          contentId = titlemod.index + titlemod.length;
        }
        tempcontent += content.substring(contentId);
        content = tempcontent;
        dt = displaytitle.pop();
        lct = lowercasetitle.pop();
        dlct = "";
        if (dt && !lct) {
          dlct = "{{DISPLAYTITLE:" + dt.value + "}}";
        } else if (!dt && lct) {
          dlct = "{{Lowercase title}}";
        } else if (dt && lct) {
          dlct = dt.index < lct.index ? "{{Lowercase title}}" : "{{DISPLAYTITLE:" + dt.value + "}}";
        }
        if (displaytitle.length || lowercasetitle.length) {
          this.WM.Log.logWarning("Found multiple instances of {{DISPLAYTITLE:...}} or {{Lowercase title}}: only the last one has been used, the others have been deleted");
        }

        behaviorswitches = this.WM.Parser.findBehaviorSwitches(content);
        bslist = [];
        tempcontent = "";
        contentId = 0;
        for (b = j = 0, len1 = behaviorswitches.length; j < len1; b = ++j) {
          bswitch = behaviorswitches[b];
          if ((ref = bswitch.match[1]) === "TOC" || ref === "START" || ref === "END") {
            behaviorswitches.splice(b, 1);
          } else {
            if (ref1 = bswitch.match[0], indexOf.call(bslist, ref1) < 0) {
              bslist.push(bswitch.match[0]);
            } else {
              this.WM.Log.logWarning("Removed duplicate of " + bswitch.match[0]);
            }
            tempcontent += content.substring(contentId, bswitch.index);
            contentId = bswitch.index + bswitch.length;
          }
        }
        tempcontent += content.substring(contentId);
        content = tempcontent;
        if (!dlct && bslist.length) {
          header += bslist.join(" ") + "\n";
        } else if (dlct && !bslist.length) {
          header += dlct + "\n";
        } else if (dlct && bslist.length) {
          header += dlct + " " + bslist.join(" ") + "\n";
        }

        categories = this.WM.Parser.findCategories(content);
        catlist = [];
        catlinks = [];
        tempcontent = "";
        contentId = 0;
        for (k = 0, len2 = categories.length; k < len2; k++) {
          cat = categories[k];
          if (cat.fragment) {
            this.WM.Log.logWarning(this.WM.Log.linkToWikiPage(cat.link, cat.rawLink) + " contains a fragment reference, but it doesn't make sense in categories and will be removed");
          }
          cleantitle = this.WM.Parser.squashContiguousWhitespace(cat.title);
          cattext = "Category:" + cleantitle;

          catlang = this.WM.ArchWiki.detectLanguage(cattext)[1];
          catlink = "[[" + cattext + (cat.anchor ? "|" + cat.anchor : "") + "]]";
          if (language !== catlang) {
            this.WM.Log.logWarning(this.WM.Log.linkToWikiPage(cat.link, cattext) + " belongs to a different language than the one of the title (" + language + ")");
          }
          if (catlist.indexOf(cattext) < 0) {
            catlist.push(cattext);
            catlinks.push(catlink);
          } else {
            this.WM.Log.logWarning("Removed duplicate of " + this.WM.Log.linkToWikiPage(cat.link, cattext));
          }
          tempcontent += content.substring(contentId, cat.index);
          contentId = cat.index + cat.length;
        }
        if (catlist.length) {
          header += catlinks.join("\n") + "\n";
        } else {
          this.WM.Log.logWarning("The article is not categorized");
        }
        tempcontent += content.substring(contentId);
        content = tempcontent;

        interlanguage = this.WM.ArchWiki.findAllInterlanguageLinks(content);
        iwlist = [];
        iwlinks = [];
        tempcontent = "";
        contentId = 0;
        for (l = 0, len3 = interlanguage.length; l < len3; l++) {
          link = interlanguage[l];
          if (link.anchor) {
            this.WM.Log.logWarning(link.rawLink + " contains an alternative text, but it doesn't make sense in interlanguage links and will be removed");
          }

          linktitle = link.title;
          linklang = link.namespace;
          linktext = linklang + ":" + linktitle;
          fulllink = "[[" + linktext + (link.fragment ? "#" + link.fragment : "") + "]]";
          if (iwlist.indexOf(linktext) < 0) {
            iwlist.push(linktext);
            iwlinks.push(fulllink);
          } else {
            this.WM.Log.logWarning("Removed duplicate of " + linktext);
          }
          tempcontent += content.substring(contentId, link.index);
          contentId = link.index + link.length;
        }
        if (iwlist.length) {
          iwlinks.sort();
          header += iwlinks.join("\n") + "\n";
        }
        tempcontent += content.substring(contentId);
        content = tempcontent;
        firstChar = content.search(/[^\s]/);
        content = content.substr(firstChar);
        newText = header + content;
        if (newText !== source) {
          this.WM.Editor.writeSource(newText);
          this.WM.Log.logInfo("Fixed header");
        }
        if (callNext) {
          return callNext();
        }
      }
    }]);

    return ArchWikiFixHeader;
  }(Plugin);

  ;

  ArchWikiFixHeader.conf_default = {
    enabled: true,
    editor_menu: ["Text plugins", "Fix header"]
  };

  return ArchWikiFixHeader;
}.call(undefined);

},{"./_Plugin":435}],417:[function(require,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Plugin;

var _require = require('./_Plugin');

Plugin = _require.Plugin;


module.exports.ArchWikiFixHeadings = function () {
  var ArchWikiFixHeadings = function (_Plugin) {
    _inherits(ArchWikiFixHeadings, _Plugin);

    function ArchWikiFixHeadings() {
      _classCallCheck(this, ArchWikiFixHeadings);

      return _possibleConstructorReturn(this, (ArchWikiFixHeadings.__proto__ || Object.getPrototypeOf(ArchWikiFixHeadings)).apply(this, arguments));
    }

    _createClass(ArchWikiFixHeadings, [{
      key: "main_editor",
      value: function main_editor(callNext) {
        var i, increaseLevel, info, len, newtext, prevId, ref, section, source;
        source = this.WM.Editor.readSource();
        info = this.WM.Parser.findSectionHeadings(source);
        if (this.WM.Editor.isSection()) {
          increaseLevel = info.minLevel - 1;
        } else {
          if (info.maxTocLevel < 6) {
            increaseLevel = 1;
          } else {
            increaseLevel = 0;
            this.WM.Log.logWarning("There are 6 levels of headings, it has been necessary to start creating them from level 1 although usually it is suggested to start from level 2");
          }
        }
        newtext = "";
        prevId = 0;
        ref = info.sections;
        for (i = 0, len = ref.length; i < len; i++) {
          section = ref[i];
          newtext += source.substring(prevId, section.index);
          newtext += new Array(section.tocLevel + increaseLevel + 1).join("=");
          newtext += section.rawheading;
          newtext += new Array(section.tocLevel + increaseLevel + 1).join("=");
          prevId = section.index + section.length0;
        }
        newtext += source.substr(prevId);
        if (newtext !== source) {
          this.WM.Editor.writeSource(newtext);
          this.WM.Log.logInfo("Fixed section headings");
        }
        if (callNext) {
          return callNext();
        }
      }
    }]);

    return ArchWikiFixHeadings;
  }(Plugin);

  ;

  ArchWikiFixHeadings.conf_default = {
    enabled: true,
    editor_menu: ["Text plugins", "Fix headings"]
  };

  return ArchWikiFixHeadings;
}.call(undefined);

},{"./_Plugin":435}],418:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Plugin;

var _require = require('./_Plugin');

Plugin = _require.Plugin;


module.exports.ArchWikiFixLinks = function () {
  var ArchWikiFixLinks = function (_Plugin) {
    _inherits(ArchWikiFixLinks, _Plugin);

    function ArchWikiFixLinks() {
      _classCallCheck(this, ArchWikiFixLinks);

      return _possibleConstructorReturn(this, (ArchWikiFixLinks.__proto__ || Object.getPrototypeOf(ArchWikiFixLinks)).apply(this, arguments));
    }

    _createClass(ArchWikiFixLinks, [{
      key: 'doReplace',
      value: function doReplace(txt) {
        var L, match, newText, prevId, re;

        re = /http:\/\/([a-z]+\.)?archlinux\.org(?!\.[a-z])/ig;
        txt = txt.replace(re, 'https://$1archlinux.org');

        re = /\[https?:\/\/wiki\.archlinux\.org\/index\.php\/Category:([^\]]+?) (.+?)\]/ig;
        txt = txt.replace(re, '[[:Category:$1|$2]]');
        re = /\[https?:\/\/wiki\.archlinux\.org\/index\.php\/Category:(.+?)\]/ig;
        txt = txt.replace(re, '[[:Category:$1]]');
        re = /https?:\/\/wiki\.archlinux\.org\/index\.php\/Category:([^\s]+)/ig;
        txt = txt.replace(re, '[[:Category:$1]]');
        re = /\[https?:\/\/wiki\.archlinux\.org\/index\.php\/([^\]]+?) (.+?)\]/ig;
        txt = txt.replace(re, '[[$1|$2]]');
        re = /\[https?:\/\/wiki\.archlinux\.org\/index\.php\/(.+?)\]/ig;
        txt = txt.replace(re, '[[$1]]');
        re = /https?:\/\/wiki\.archlinux\.org\/index\.php\/([^\s]+)/ig;
        txt = txt.replace(re, '[[$1]]');
        re = /https?:\/\/wiki\.archlinux\.org(?!\.)/ig;
        if (re.test(txt)) {
          this.WM.Log.logWarning("It hasn't been possible to convert some " + "links to wiki.archlinux.org");
        }

        re = /\[https?:\/\/en\.wikipedia\.org\/wiki\/([^\]]+?) (.+?)\]/ig;
        txt = txt.replace(re, '[[wikipedia:$1|$2]]');
        re = /\[https?:\/\/en\.wikipedia\.org\/wiki\/(.+?)\]/ig;
        txt = txt.replace(re, '[[wikipedia:$1]]');
        re = /https?:\/\/en\.wikipedia\.org\/wiki\/([^\s]+)/ig;
        txt = txt.replace(re, '[[wikipedia:$1]]');
        re = /https?:\/\/([a-z]+?)\.wikipedia\.org(?!\.)/ig;
        if (re.test(txt)) {
          this.WM.Log.logWarning("It hasn't been possible to convert some " + "links to Wikipedia");
        }

        re = /\[https?:\/\/(?:www\.)?archlinux\.org\/packages\/(?:community|community-testing|core|extra|multilib|multilib-testing|testing)\/(?:any|i686|x86_64)\/([^\s]+?)\/? +(.+?)?\]/ig;
        newText = '';
        prevId = 0;
        while (true) {
          match = re.exec(txt);
          if (match) {
            if (match[1] === match[2]) {
              L = match[0].length;
              newText += txt.substring(prevId, re.lastIndex - L) + '{{Pkg|' + match[1] + '}}';
              prevId = re.lastIndex;
            }
          } else {
            break;
          }
        }
        newText += txt.substr(prevId);
        txt = newText;
        re = /\[https?:\/\/(?:www\.)?archlinux\.org\/packages\/(?:community|community-testing|core|extra|multilib|multilib-testing|testing)\/(?:any|i686|x86_64)\/([^\s]+?)\/?\]/ig;
        txt = txt.replace(re, '{{Pkg|$1}}');
        re = /([^\[])https?:\/\/(?:www\.)?archlinux\.org\/packages\/(?:community|community-testing|core|extra|multilib|multilib-testing|testing)\/(?:any|i686|x86_64)\/([^\s\/]+)\/?/ig;
        txt = txt.replace(re, '$1{{Pkg|$2}}');
        re = /https?:\/\/(?:www\.)?archlinux\.org\/packages(?!\/?\s)/ig;
        if (re.test(txt)) {
          this.WM.Log.logWarning("It hasn't been possible to convert some " + "links to archlinux.org/packages");
        }

        re = /\[https?:\/\/aur\.archlinux\.org\/packages\/([^\s]+?)\/? +(.+?)?\]/ig;
        newText = '';
        prevId = 0;
        while (true) {
          match = re.exec(txt);
          if (match) {
            if (match[1] === match[2]) {
              L = match[0].length;
              newText += txt.substring(prevId, re.lastIndex - L) + '{{AUR|' + match[1] + '}}';
              prevId = re.lastIndex;
            }
          } else {
            break;
          }
        }
        newText += txt.substr(prevId);
        txt = newText;
        re = /\[https?:\/\/aur\.archlinux\.org\/packages\/([^\s]+?)\/?\]/ig;
        txt = txt.replace(re, '{{AUR|$1}}');
        re = /([^\[])https?:\/\/aur\.archlinux\.org\/packages\/([^\s\/]+)\/?/ig;
        txt = txt.replace(re, '$1{{AUR|$2}}');
        re = /https?:\/\/aur\.archlinux\.org(?!(?:\.|(?:\/?packages)?\/?\s))/ig;
        if (re.test(txt)) {
          this.WM.Log.logWarning("It hasn't been possible to convert some links to aur.archlinux.org (try the \"Fix old AUR links\" function, if installed)");
        }

        re = /\[https?:\/\/bugs\.archlinux\.org\/task\/([^\s]+?)\/? +(.+?)?\]/ig;
        newText = '';
        prevId = 0;
        while (true) {
          match = re.exec(txt);
          if (match) {
            if (match[1] === match[2]) {
              L = match[0].length;
              newText += txt.substring(prevId, re.lastIndex - L) + '{{Bug|' + match[1] + '}}';
              prevId = re.lastIndex;
            }
          } else {
            break;
          }
        }
        newText += txt.substr(prevId);
        txt = newText;
        re = /\[https?:\/\/bugs\.archlinux\.org\/task\/([^\s]+?)\/?\]/ig;
        txt = txt.replace(re, '{{Bug|$1}}');
        re = /([^\[])https?:\/\/bugs\.archlinux\.org\/task\/([^\s\/]+)\/?/ig;
        txt = txt.replace(re, '$1{{Bug|$2}}');
        re = /https?:\/\/bugs\.archlinux\.org\/task/ig;
        if (re.test(txt)) {
          this.WM.Log.logWarning("It hasn't been possible to convert some " + "links to bugs.archlinux.org/task");
        }
        return txt;
      }
    }, {
      key: 'main_editor',
      value: function main_editor(callNext) {
        var newtext, source;
        source = this.WM.Editor.readSource();
        newtext = this.doReplace(source);
        if (newtext !== source) {
          this.WM.Editor.writeSource(newtext);
          this.WM.Log.logInfo("Fixed links");
        } else {
          this.WM.Log.logInfo("No fixable links found");
        }
        if (callNext) {
          return callNext();
        }
      }
    }]);

    return ArchWikiFixLinks;
  }(Plugin);

  ;

  ArchWikiFixLinks.conf_default = {
    enabled: true,
    editor_menu: ["Text plugins", "Fix external links"]
  };

  return ArchWikiFixLinks;
}.call(undefined);

},{"./_Plugin":435}],419:[function(require,module,exports){
'use strict';

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var CSS, Plugin;

var _require = require('./_Plugin');

Plugin = _require.Plugin;


CSS = require('@kynikos/misc/dist/CSS');

module.exports.ArchWikiNPFilter = function () {
  var ArchWikiNPFilter = function (_Plugin) {
    _inherits(ArchWikiNPFilter, _Plugin);

    function ArchWikiNPFilter() {
      _classCallCheck(this, ArchWikiNPFilter);

      return _possibleConstructorReturn(this, (ArchWikiNPFilter.__proto__ || Object.getPrototypeOf(ArchWikiNPFilter)).apply(this, arguments));
    }

    _createClass(ArchWikiNPFilter, [{
      key: 'main_newpages',
      value: function main_newpages() {
        var contentDiv, i, language, len, li, liList, link, pureTitle, ul;
        CSS.addStyleElement("#mw-content-text > h5 {background-color:#afa;}");
        contentDiv = $('#mw-content-text');
        ul = contentDiv.find('ul').first();
        liList = ul.children('li');
        for (i = 0, len = liList.length; i < len; i++) {
          li = liList[i];
          link = $(li).find('a.mw-newpages-pagename').first();

          var _WM$ArchWiki$detectLa = this.WM.ArchWiki.detectLanguage(link[0].title);

          var _WM$ArchWiki$detectLa2 = _slicedToArray(_WM$ArchWiki$detectLa, 2);

          pureTitle = _WM$ArchWiki$detectLa2[0];
          language = _WM$ArchWiki$detectLa2[1];

          if (language !== this.conf.default_language) {
            this.moveArticle(contentDiv, li, language);
          }
        }
        return this.WM.Log.logInfo("Grouped articles by language");
      }
    }, {
      key: 'moveArticle',
      value: function moveArticle(contentDiv, li, language) {
        var HLang, i, langFound, langHs, len, ul;
        langHs = contentDiv.children('h5');
        langFound = false;
        for (i = 0, len = langHs.length; i < len; i++) {
          HLang = langHs[i];
          if (HLang.innerHTML === language) {
            ul = $(HLang).next().append(li);
            langFound = true;
            break;
          }
        }
        if (!langFound) {
          return contentDiv.append($('<h5>').text(language), $('<ul>').append(li));
        }
      }
    }]);

    return ArchWikiNPFilter;
  }(Plugin);

  ;

  ArchWikiNPFilter.conf_default = {
    enabled: true,
    filter_label: "Default filter",
    default_language: "English"
  };

  return ArchWikiNPFilter;
}.call(undefined);

},{"./_Plugin":435,"@kynikos/misc/dist/CSS":2}],420:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Plugin;

var _require = require('./_Plugin');

Plugin = _require.Plugin;


module.exports.ArchWikiNewTemplates = function () {
  var ArchWikiNewTemplates = function (_Plugin) {
    _inherits(ArchWikiNewTemplates, _Plugin);

    function ArchWikiNewTemplates() {
      _classCallCheck(this, ArchWikiNewTemplates);

      return _possibleConstructorReturn(this, (ArchWikiNewTemplates.__proto__ || Object.getPrototypeOf(ArchWikiNewTemplates)).apply(this, arguments));
    }

    _createClass(ArchWikiNewTemplates, [{
      key: 'main_editor',
      value: function main_editor(callNext) {
        var i, len, newtext, re10, re11, re12, re13, re14, re15, re16, re8, re9, source, test, tests;
        source = this.WM.Editor.readSource();
        newtext = source;
        re8 = /<pre>(((?!<(pre|nowiki)>)[^\=\|])*?((?!<(pre|nowiki)>)[^\=\|\}]))<\/pre>/ig;
        re9 = /<pre>(((?!<(pre|nowiki)>)[^\|])*?((?!<(pre|nowiki)>)[^\|\}]))<\/pre>/ig;
        re10 = /<pre>(\n*((?!<(pre|nowiki)>).\n*)+?)<\/pre>/ig;
        re11 = /<code>(((?!<(code|nowiki)>)[^\=\|\n])*?((?!<(code|nowiki)>)[^\=\|\}\n]))<\/code>/ig;
        re12 = /<code>(((?!<(code|nowiki)>)[^\|\n])*?((?!<(code|nowiki)>)[^\|\}\n]))<\/code>/ig;
        re13 = /<code>(((?!<(code|nowiki)>)[^\n])+?)<\/code>/ig;
        re14 = /<tt>(((?!<(tt|nowiki)>)[^\=\|\n])*?((?!<(tt|nowiki)>)[^\=\|\}\n]))<\/tt>/ig;
        re15 = /<tt>(((?!<(tt|nowiki)>)[^\|\n])*?((?!<(tt|nowiki)>)[^\|\}\n]))<\/tt>/ig;
        re16 = /<tt>(((?!<(tt|nowiki)>)[^\n])+?)<\/tt>/ig;
        newtext = newtext.replace(re8, '{{bc|$1}}');
        newtext = newtext.replace(re9, '{{bc|1=$1}}');
        newtext = newtext.replace(re10, '{{bc|<nowiki>$1</nowiki>}}');
        newtext = newtext.replace(re11, '{{ic|$1}}');
        newtext = newtext.replace(re12, '{{ic|1=$1}}');
        newtext = newtext.replace(re13, '{{ic|<nowiki>$1</nowiki>}}');
        newtext = newtext.replace(re14, '{{ic|$1}}');
        newtext = newtext.replace(re15, '{{ic|1=$1}}');
        newtext = newtext.replace(re16, '{{ic|<nowiki>$1</nowiki>}}');
        if (newtext !== source) {
          this.WM.Editor.writeSource(newtext);
          this.WM.Log.logInfo("Turned HTML tags into proper templates");
        }
        tests = [['&lt;pre>', newtext.match(/<pre/ig)], ['&lt;code>', newtext.match(/<code/ig)], ['&lt;tt>', newtext.match(/<tt/ig)]];
        for (i = 0, len = tests.length; i < len; i++) {
          test = tests[i];
          if (test[1]) {
            this.WM.Log.logWarning(test[1].length + ' ' + test[0] + ' instances require manual intervention');
          }
        }
        if (callNext) {
          return callNext();
        }
      }
    }]);

    return ArchWikiNewTemplates;
  }(Plugin);

  ;

  ArchWikiNewTemplates.conf_default = {
    enabled: true,
    editor_menu: ["Text plugins", "Use code templates"]
  };

  return ArchWikiNewTemplates;
}.call(undefined);

},{"./_Plugin":435}],421:[function(require,module,exports){
'use strict';

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var CSS, Plugin;

var _require = require('./_Plugin');

Plugin = _require.Plugin;


CSS = require('@kynikos/misc/dist/CSS');

module.exports.ArchWikiRCFilter = function () {
  var ArchWikiRCFilter = function (_Plugin) {
    _inherits(ArchWikiRCFilter, _Plugin);

    function ArchWikiRCFilter() {
      _classCallCheck(this, ArchWikiRCFilter);

      return _possibleConstructorReturn(this, (ArchWikiRCFilter.__proto__ || Object.getPrototypeOf(ArchWikiRCFilter)).apply(this, arguments));
    }

    _createClass(ArchWikiRCFilter, [{
      key: 'main_recentchanges',
      value: function main_recentchanges() {
        var articleTable, groupDiv, h4, h4s, j, k, language, len, len1, link, pureTitle, ref;
        h4s = $('#mw-content-text .mw-changeslist > h4');
        if (h4s.eq(0).next()[0].localName.toLowerCase() !== 'div') {
          return this.WM.Log.logError("This filter is designed to work on top of MediaWiki's filter, which you can enable in your user preferences.");
        } else {
          CSS.addStyleElement("#mw-content-text > div > h4 {background-color:#aaf;} #mw-content-text > div > div > h5 {background-color:#afa;}");
          for (j = 0, len = h4s.length; j < len; j++) {
            h4 = h4s[j];
            groupDiv = $(h4).next();
            ref = groupDiv.children('table');
            for (k = 0, len1 = ref.length; k < len1; k++) {
              articleTable = ref[k];
              link = $(articleTable).find('a.mw-changeslist-title').first();
              if (link[0]) {
                var _WM$ArchWiki$detectLa = this.WM.ArchWiki.detectLanguage(link[0].title);

                var _WM$ArchWiki$detectLa2 = _slicedToArray(_WM$ArchWiki$detectLa, 2);

                pureTitle = _WM$ArchWiki$detectLa2[0];
                language = _WM$ArchWiki$detectLa2[1];

                if (language !== this.conf.default_language) {
                  this.moveArticle(groupDiv, articleTable, language);
                }
              }
            }
          }
          return this.WM.Log.logInfo("Grouped articles by language");
        }
      }
    }, {
      key: 'moveArticle',
      value: function moveArticle(groupDiv, articleTable, language) {
        var HLang, i, j, langFound, langHs, len;
        langHs = groupDiv.children('h5');
        langFound = false;
        for (i = j = 0, len = langHs.length; j < len; i = ++j) {
          HLang = langHs[i];
          if (HLang.innerHTML === language) {
            if (i + 1 < langHs.length) {
              langHs.eq(i + 1).before(articleTable);
            } else {
              groupDiv.append(articleTable);
            }
            langFound = true;
            break;
          }
        }
        if (!langFound) {
          return groupDiv.append($('<h5>').text(language), articleTable);
        }
      }
    }]);

    return ArchWikiRCFilter;
  }(Plugin);

  ;

  ArchWikiRCFilter.conf_default = {
    enabled: true,
    filter_label: "Default filter",
    default_language: "English"
  };

  return ArchWikiRCFilter;
}.call(undefined);

},{"./_Plugin":435,"@kynikos/misc/dist/CSS":2}],422:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var CSS,
    HTTP,
    Plugin,
    ref,
    boundMethodCheck = function boundMethodCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new Error('Bound instance method accessed before binding');
  }
};

var _require = require('./_Plugin');

Plugin = _require.Plugin;


CSS = require('@kynikos/misc/dist/CSS');

HTTP = require('@kynikos/misc/dist/HTTP');

ref = module.exports.ArchWikiSaveTalk = function () {
  var ArchWikiSaveTalk = function (_Plugin) {
    _inherits(ArchWikiSaveTalk, _Plugin);

    function ArchWikiSaveTalk() {
      _classCallCheck(this, ArchWikiSaveTalk);

      var _this = _possibleConstructorReturn(this, (ArchWikiSaveTalk.__proto__ || Object.getPrototypeOf(ArchWikiSaveTalk)).apply(this, arguments));

      _this.mainGetEndTimestamp = _this.mainGetEndTimestamp.bind(_this);
      _this.mainWrite = _this.mainWrite.bind(_this);
      _this.mainEnd = _this.mainEnd.bind(_this);
      return _this;
    }

    _createClass(ArchWikiSaveTalk, [{
      key: 'makeUI',
      value: function makeUI() {
        var article, link;
        CSS.addStyleElement("#WikiMonkey-ArchWikiSaveTalk {margin-left:0.33em;}");
        article = this.conf.page;
        link = document.createElement('a');
        link.id = "WikiMonkey-ArchWikiSaveTalk";
        link.href = "/index.php/" + article;
        link.innerHTML = article;
        return link;
      }
    }, {
      key: 'main_diff',
      value: function main_diff(callNext) {
        var article, summary;
        article = this.conf.page;
        summary = this.conf.edit_summary;
        this.WM.Log.logInfo('Appending diff to ' + this.WM.Log.linkToWikiPage(article, article) + " ...");
        return this.WM.Diff.getEndTimestamp(this.mainGetEndTimestamp, [article, summary, callNext]);
      }
    }, {
      key: 'mainGetEndTimestamp',
      value: function mainGetEndTimestamp(enddate, args) {
        var article, callNext, summary;
        boundMethodCheck(this, ref);
        article = args[0];
        summary = args[1];
        callNext = args[2];
        return this.WM.MW.callQueryEdit(article, this.mainWrite, [summary, enddate, callNext]);
      }
    }, {
      key: 'mainWrite',
      value: function mainWrite(article, source, timestamp, edittoken, args) {
        var callNext, enddate, newtext, pEnddate, summary, title;
        boundMethodCheck(this, ref);
        summary = args[0];
        enddate = args[1];
        callNext = args[2];
        title = HTTP.getURIParameter(null, 'title');
        pEnddate = enddate.substr(0, 10) + "&nbsp;" + enddate.substr(11, 8);
        newtext = this.WM.Tables.appendRow(source, "<!-- REPLY TABLE -->", ["[" + location.href + " " + title + "]", pEnddate]);
        return this.WM.MW.callAPIPost({
          action: "edit",
          bot: "1",
          title: article,
          summary: summary,
          text: newtext,
          basetimestamp: timestamp,
          token: edittoken
        }, this.mainEnd, [article, callNext], null);
      }
    }, {
      key: 'mainEnd',
      value: function mainEnd(res, args) {
        var article, callNext;
        boundMethodCheck(this, ref);
        article = args[0];
        callNext = args[1];
        if (res.edit && res.edit.result === 'Success') {
          this.WM.Log.logInfo('Diff correctly appended to ' + this.WM.Log.linkToWikiPage(article, article));
          if (callNext) {
            return callNext();
          }
        } else {
          return this.WM.Log.logError('The diff has not been appended!\n' + res['error']['info'] + " (" + res['error']['code'] + ")");
        }
      }
    }]);

    return ArchWikiSaveTalk;
  }(Plugin);

  ;

  ArchWikiSaveTalk.conf_default = {
    enabled: false,
    diff_menu: ["Save discussion"],
    page: null,
    edit_summary: "add discussion"
  };

  return ArchWikiSaveTalk;
}.call(undefined);

},{"./_Plugin":435,"@kynikos/misc/dist/CSS":2,"@kynikos/misc/dist/HTTP":4}],423:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Plugin,
    ref,
    boundMethodCheck = function boundMethodCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new Error('Bound instance method accessed before binding');
  }
};

var _require = require('./_Plugin');

Plugin = _require.Plugin;


ref = module.exports.ArchWikiSortContacts = function () {
  var endMark, regExp, startMark;

  var ArchWikiSortContacts = function (_Plugin) {
    _inherits(ArchWikiSortContacts, _Plugin);

    function ArchWikiSortContacts() {
      _classCallCheck(this, ArchWikiSortContacts);

      var _this = _possibleConstructorReturn(this, (ArchWikiSortContacts.__proto__ || Object.getPrototypeOf(ArchWikiSortContacts)).apply(this, arguments));

      _this.parseList = _this.parseList.bind(_this);
      _this.iterateUsers = _this.iterateUsers.bind(_this);
      _this.storeUserContribs = _this.storeUserContribs.bind(_this);
      _this.updateList = _this.updateList.bind(_this);
      _this.writePage = _this.writePage.bind(_this);
      return _this;
    }

    _createClass(ArchWikiSortContacts, [{
      key: 'main_special',
      value: function main_special(callNext) {
        return this.iteratePages(-1, callNext);
      }
    }, {
      key: 'iteratePages',
      value: function iteratePages(pageid, callNext) {
        var inactiveIntro, inactiveLimit, page, pconf, recentDays, summary;
        pageid++;
        pconf = this.conf.pages[pageid];
        if (pconf) {
          page = pconf.title;
          recentDays = pconf.recent_days;
          inactiveLimit = pconf.inactive_limit;
          inactiveIntro = pconf.inactive_message;
          summary = this.conf.edit_summary;
          this.WM.Log.logInfo("Sorting " + this.WM.Log.linkToWikiPage(page, page) + " ...");
          return this.WM.MW.callQueryEdit(page, this.parseList, [recentDays, inactiveLimit, inactiveIntro, summary, callNext, pageid]);
        } else if (callNext) {
          return callNext();
        }
      }
    }, {
      key: 'parseList',
      value: function parseList(title, source, timestamp, edittoken, args) {
        var callNext, date, endList, inactiveIntro, inactiveLimit, pageid, recentDays, startList, summary, ucend, ucstart, users, usersArray;
        boundMethodCheck(this, ref);
        recentDays = args[0];
        inactiveLimit = args[1];
        inactiveIntro = args[2];
        summary = args[3];
        callNext = args[4];
        pageid = args[5];
        startList = source.indexOf(startMark);
        endList = source.indexOf(endMark);
        if (startList > -1 && endList > -1) {
          startList += startMark.length;
          date = new Date();
          ucstart = Math.floor(Date.now() / 1000);
          ucend = ucstart - 86400 * recentDays;
          users = {
            active: [],
            inactive: []
          };
          usersArray = source.substring(startList, endList).split("\n");
          return this.iterateUsers(usersArray, -1, ucstart, ucend, users, title, source, startList, endList, timestamp, edittoken, inactiveLimit, inactiveIntro, summary, callNext, pageid);
        } else {
          return this.WM.Log.logError("Cannot find the needed marks");
        }
      }
    }, {
      key: 'iterateUsers',
      value: function iterateUsers(usersArray, index, ucstart, ucend, users, title, source, startList, endList, timestamp, edittoken, inactiveLimit, inactiveIntro, summary, callNext, pageid) {
        var match, ucuser, userString;
        boundMethodCheck(this, ref);
        index++;
        if (index < usersArray.length) {
          userString = usersArray[index];
          match = regExp.exec(userString);
          if (match) {
            ucuser = match[1].charAt(0).toUpperCase() + match[1].substr(1);
            if (match[2]) {
              ucuser += "|" + match[2].charAt(0).toUpperCase() + match[2].substr(1);
            }
            this.WM.Log.logInfo("Querying " + ucuser + " ...");
            return this.WM.MW.getUserContribs(ucuser, ucstart, ucend, this.storeUserContribs, [usersArray, index, ucstart, ucend, users, title, source, startList, endList, timestamp, edittoken, inactiveLimit, inactiveIntro, summary, callNext, pageid]);
          } else if (userString !== "" && userString.indexOf(inactiveIntro) !== 0) {
            return this.WM.Log.logError("An entry in the list may not be correctly " + "formatted");
          } else {
            return this.iterateUsers(usersArray, index, ucstart, ucend, users, title, source, startList, endList, timestamp, edittoken, inactiveLimit, inactiveIntro, summary, callNext, pageid);
          }
        } else {
          return this.updateList(users, title, source, startList, endList, timestamp, edittoken, inactiveIntro, summary, callNext, pageid);
        }
      }
    }, {
      key: 'storeUserContribs',
      value: function storeUserContribs(results, args) {
        var callNext, edits, edittoken, endList, inactiveIntro, inactiveLimit, index, pageid, source, startList, summary, timestamp, title, ucend, ucstart, users, usersArray;
        boundMethodCheck(this, ref);
        usersArray = args[0];
        index = args[1];
        ucstart = args[2];
        ucend = args[3];
        users = args[4];
        title = args[5];
        source = args[6];
        startList = args[7];
        endList = args[8];
        timestamp = args[9];
        edittoken = args[10];
        inactiveLimit = args[11];
        inactiveIntro = args[12];
        summary = args[13];
        callNext = args[14];
        pageid = args[15];
        edits = results.length;
        if (edits < inactiveLimit) {
          users.inactive.push({
            "text": usersArray[index],
            "edits": edits
          });
        } else {
          users.active.push({
            "text": usersArray[index],
            "edits": edits
          });
        }
        return this.iterateUsers(usersArray, index, ucstart, ucend, users, title, source, startList, endList, timestamp, edittoken, inactiveLimit, inactiveIntro, summary, callNext, pageid);
      }
    }, {
      key: 'updateList',
      value: function updateList(users, title, source, startList, endList, timestamp, edittoken, inactiveIntro, summary, callNext, pageid) {
        var i, j, len, len1, newList, newText, ref1, ref2, sorter, user;
        boundMethodCheck(this, ref);
        sorter = function sorter(a, b) {
          if (a.edits < b.edits) {
            return 1;
          } else if (a.edits > b.edits) {
            return -1;
          } else {
            return 0;
          }
        };
        users.active.sort(sorter);
        users.inactive.sort(sorter);
        newList = "\n";
        ref1 = users.active;
        for (i = 0, len = ref1.length; i < len; i++) {
          user = ref1[i];
          newList += user.text + "\n";
        }
        if (users.inactive.length > 0) {
          newList += "\n" + inactiveIntro + "\n\n";
          ref2 = users.inactive;
          for (j = 0, len1 = ref2.length; j < len1; j++) {
            user = ref2[j];
            newList += user.text + "\n";
          }
        }
        newText = source.substring(0, startList) + newList + source.substring(endList);
        if (newText !== source) {
          return this.WM.MW.callAPIPost({
            action: "edit",
            bot: "1",
            minor: "1",
            title: title,
            summary: summary,
            text: newText,
            b1asetimestamp: timestamp,
            token: edittoken
          }, this.writePage, [title, callNext, pageid], null);
        } else {
          this.WM.Log.logInfo(this.WM.Log.linkToWikiPage(title, title) + " was already up to date");
          return this.iteratePages(pageid, callNext);
        }
      }
    }, {
      key: 'writePage',
      value: function writePage(res, args) {
        var callNext, pageid, title;
        boundMethodCheck(this, ref);
        title = args[0];
        callNext = args[1];
        pageid = args[2];
        if (res.edit && res.edit.result === 'Success') {
          this.WM.Log.logInfo(this.WM.Log.linkToWikiPage(title, title) + " was correctly updated");
          return this.iteratePages(pageid, callNext);
        } else {
          return this.WM.Log.logError(res['error']['info'] + " (" + res['error']['code'] + ")");
        }
      }
    }]);

    return ArchWikiSortContacts;
  }(Plugin);

  ;

  startMark = "START AUTO LIST - DO NOT REMOVE OR MODIFY THIS MARK-->";

  endMark = "<!--END AUTO LIST - DO NOT REMOVE OR MODIFY THIS MARK";

  regExp = new RegExp("^\\*.*?\\[\\[User:(.+?)\\|.+?" + "(?: \\<!-- associated bot: (.+?) -->.*)?$", "");

  ArchWikiSortContacts.conf_default = {
    enabled: false,
    special_menu: ["Sort staff contacts"],
    edit_summary: "automatically sort list according to recent activity",
    pages: [{
      title: "ArchWiki:Administrators",
      recent_days: 30,
      inactive_limit: 30,
      inactive_message: "The following Administrators are currently inactive (less than 30 edits in the last 30 days):"
    }, {
      title: "ArchWiki:Maintainers",
      recent_days: 30,
      inactive_limit: 10,
      inactive_message: "The following Maintainers are currently inactive (less than 10 edits in the last 30 days):"
    }]
  };

  return ArchWikiSortContacts;
}.call(undefined);

},{"./_Plugin":435}],424:[function(require,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Plugin;

var _require = require('./_Plugin');

Plugin = _require.Plugin;


module.exports.ArchWikiWantedCategories = function () {
  var ArchWikiWantedCategories = function (_Plugin) {
    _inherits(ArchWikiWantedCategories, _Plugin);

    function ArchWikiWantedCategories() {
      _classCallCheck(this, ArchWikiWantedCategories);

      return _possibleConstructorReturn(this, (ArchWikiWantedCategories.__proto__ || Object.getPrototypeOf(ArchWikiWantedCategories)).apply(this, arguments));
    }

    _createClass(ArchWikiWantedCategories, [{
      key: "main_bot",
      value: function main_bot(title, callBot, chainArgs) {
        title = title.replace(" (page does not exist)", "");
        return this.WM.MW.callQuery({
          prop: "info",
          intoken: "edit",
          titles: title
        }, this.mainAutoWrite, [title, callBot], null);
      }
    }, {
      key: "mainAutoWrite",
      value: function mainAutoWrite(page, args) {
        var callBot, edittoken, language, summary, text, title;
        title = args[0];
        callBot = args[1];
        edittoken = page.edittoken;
        language = this.WM.ArchWiki.detectLanguage(title)[1];
        if (language !== this.WM.ArchWiki.getLocalLanguage()) {
          text = "[[Category:" + language + "]]";
          summary = "wanted category";
          return this.WM.MW.callAPIPost({
            action: "edit",
            bot: "1",
            title: title,
            summary: summary,
            text: text,
            createonly: "1",
            token: edittoken
          }, this.mainAutoEnd, callBot, null);
        } else {
          return callBot(0, null);
        }
      }
    }, {
      key: "mainAutoEnd",
      value: function mainAutoEnd(res, callBot) {
        if (res.edit && res.edit.result === 'Success') {
          return callBot(1, null);
        } else if (res.error) {
          this.WM.Log.logError(res.error.info + " (" + res.error.code + ")");
          return callBot(res.error.code, null);
        } else {
          return callBot(false, null);
        }
      }
    }]);

    return ArchWikiWantedCategories;
  }(Plugin);

  ;

  ArchWikiWantedCategories.conf_default = {
    enabled: false,
    bot_label: "Create wanted categories"
  };

  return ArchWikiWantedCategories;
}.call(undefined);

},{"./_Plugin":435}],425:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Plugin;

var _require = require('./_Plugin');

Plugin = _require.Plugin;


module.exports.DeletePages = function () {
  var DeletePages = function (_Plugin) {
    _inherits(DeletePages, _Plugin);

    function DeletePages() {
      _classCallCheck(this, DeletePages);

      return _possibleConstructorReturn(this, (DeletePages.__proto__ || Object.getPrototypeOf(DeletePages)).apply(this, arguments));
    }

    _createClass(DeletePages, [{
      key: 'main_bot',
      value: function main_bot(title, callBot, chainArgs) {
        var summary;
        summary = this.conf.edit_summary;
        return this.WM.MW.callQuery({
          prop: 'info',
          intoken: 'delete',
          titles: title
        }, this.mainAutoWrite, [title, summary, callBot], null);
      }
    }, {
      key: 'mainAutoWrite',
      value: function mainAutoWrite(page, args) {
        var callBot, deletetoken, summary, title;
        title = args[0];
        summary = args[1];
        callBot = args[2];
        deletetoken = page.deletetoken;
        return this.WM.MW.callAPIPost({
          action: 'delete',
          bot: '1',
          title: title,
          token: deletetoken,
          reason: summary
        }, this.mainAutoEnd, [title, callBot], null);
      }
    }, {
      key: 'mainAutoEnd',
      value: function mainAutoEnd(res, args) {
        var callBot, title;
        title = args[0];
        callBot = args[1];
        if (!res.delete) {
          if (res.error) {
            this.WM.Log.logError(this.WM.Log.linkToWikiPage(title, title) + ' has not been deleted!\n' + res.error.info + ' (' + res.error.code + ')');
            return callBot(res.error.code, null);
          } else {
            return callBot(false, null);
          }
        } else {
          return callBot(1, null);
        }
      }
    }]);

    return DeletePages;
  }(Plugin);

  ;

  DeletePages.conf_default = {
    enabled: false,
    bot_label: "Delete pages",
    edit_summary: "delete page"
  };

  return DeletePages;
}.call(undefined);

},{"./_Plugin":435}],426:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Plugin;

var _require = require('./_Plugin');

Plugin = _require.Plugin;


module.exports.ExpandContractions = function () {
  var ExpandContractions = function (_Plugin) {
    _inherits(ExpandContractions, _Plugin);

    function ExpandContractions() {
      _classCallCheck(this, ExpandContractions);

      return _possibleConstructorReturn(this, (ExpandContractions.__proto__ || Object.getPrototypeOf(ExpandContractions)).apply(this, arguments));
    }

    _createClass(ExpandContractions, [{
      key: 'replace',
      value: function replace(source, regExp, newString, checkString, checkStrings) {
        var newtext;
        newtext = source.replace(regExp, newString);
        if (checkStrings.length > 1 && newtext !== source) {
          this.WM.Log.logWarning('Replaced some "' + checkString + '" with "' + checkStrings[0] + '": check that it didn\'t mean "' + checkStrings.slice(1).join('\" or \"') + '" instead');
        }
        return newtext;
      }
    }, {
      key: 'main_editor',
      value: function main_editor(callNext) {
        var newtext, source, ss;
        source = this.WM.Editor.readSource();
        newtext = source;

        newtext = this.replace(newtext, /([a-z])'re/ig, '$1 are', "'re", ["are"]);
        newtext = this.replace(newtext, /([a-z])'ve/ig, '$1 have', "'ve", ["have"]);
        newtext = this.replace(newtext, /([a-z])'ll/ig, '$1 will', "'ll", ["will", "shall"]);
        newtext = this.replace(newtext, /([a-z])'d/ig, '$1 would', "'d", ["would", "had"]);
        newtext = this.replace(newtext, /(c)an't/ig, '$1annot', "can't", ["cannot"]);
        newtext = this.replace(newtext, /(w)on't/ig, '$1ill not', "won't", ["will not"]);
        newtext = this.replace(newtext, /([a-z])n't/ig, '$1 not', "n't", ["not"]);
        newtext = this.replace(newtext, /(here|there)'s/ig, '$1 is', "here/there's", ["here/there is", "here/there has"]);
        newtext = this.replace(newtext, /(g)onna/ig, '$1oing to', "gonna", ["going to"]);

        newtext = this.replace(newtext, /([a-z])'s (been)/ig, '$1 has $2', "'s been", ["has been"]);
        newtext = this.replace(newtext, /(let)'s/ig, '$1 us', "let's", ["let us"]);
        newtext = this.replace(newtext, /(it)'(s own)/ig, '$1$2', "it's own", ["its own"]);
        ss = newtext.match(/[a-z]'s/gi);
        if (ss) {
          this.WM.Log.logWarning("Found " + ss.length + " instances of \"'s\": " + "check if they can be replaced with \"is\", \"has\", ...");
        }
        if (newtext !== source) {
          this.WM.Editor.writeSource(newtext);
          this.WM.Log.logInfo("Expanded contractions");
        }
        if (callNext) {
          return callNext();
        }
      }
    }]);

    return ExpandContractions;
  }(Plugin);

  ;

  ExpandContractions.conf_default = {
    enabled: true,
    editor_menu: ["Text plugins", "Expand contractions"]
  };

  return ExpandContractions;
}.call(undefined);

},{"./_Plugin":435}],427:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var CSS,
    Plugin,
    ref,
    boundMethodCheck = function boundMethodCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new Error('Bound instance method accessed before binding');
  }
};

var _require = require('./_Plugin');

Plugin = _require.Plugin;


CSS = require('@kynikos/misc/dist/CSS');

ref = module.exports.FixBacklinkFragments = function () {
  var readTarget;

  var FixBacklinkFragments = function (_Plugin) {
    _inherits(FixBacklinkFragments, _Plugin);

    function FixBacklinkFragments() {
      _classCallCheck(this, FixBacklinkFragments);

      var _this = _possibleConstructorReturn(this, (FixBacklinkFragments.__proto__ || Object.getPrototypeOf(FixBacklinkFragments)).apply(this, arguments));

      _this.makeBotUI = _this.makeBotUI.bind(_this);
      _this.fixLinks = _this.fixLinks.bind(_this);
      _this.fixArchWikiLinks = _this.fixArchWikiLinks.bind(_this);
      _this.fixArchWikiLink = _this.fixArchWikiLink.bind(_this);
      _this.fixFragment = _this.fixFragment.bind(_this);
      _this.mainAutoFindSections = _this.mainAutoFindSections.bind(_this);
      _this.mainAutoRead = _this.mainAutoRead.bind(_this);
      _this.mainAutoWrite = _this.mainAutoWrite.bind(_this);
      _this.mainAutoEnd = _this.mainAutoEnd.bind(_this);
      return _this;
    }

    _createClass(FixBacklinkFragments, [{
      key: 'makeBotUI',
      value: function makeBotUI() {
        var divMain, label, target;
        boundMethodCheck(this, ref);
        CSS.addStyleElement("#WikiMonkey-FixBacklinkFragments " + "input[type='text'] {margin-left:0.33em;}");
        divMain = document.createElement('div');
        divMain.id = "WikiMonkey-FixBacklinkFragments";
        label = document.createElement('span');
        label.innerHTML = 'Target page:';
        divMain.appendChild(label);
        target = document.createElement('input');
        target.setAttribute('type', 'text');
        target.id = "WikiMonkey-FixBacklinkFragments-Target";
        if (this.WM.WhatLinksHere.isWhatLinksHerePage()) {
          target.value = this.WM.WhatLinksHere.getTitle();
        }
        divMain.appendChild(target);
        return divMain;
      }
    }, {
      key: 'fixLinks',
      value: function fixLinks(source, target, sections) {
        var fixedFragment, i, len, link, links, newText, newlink, oldlink, prevId, rawfragment;
        boundMethodCheck(this, ref);

        links = this.WM.Parser.findInternalLinks(source, null, target);
        newText = "";
        prevId = 0;
        for (i = 0, len = links.length; i < len; i++) {
          link = links[i];
          newText += source.substring(prevId, link.index);
          newlink = link.rawLink;
          rawfragment = link.fragment;
          if (rawfragment) {
            fixedFragment = this.fixFragment(rawfragment, sections);
            if (fixedFragment === true) {
              null;
            } else if (fixedFragment) {
              oldlink = newlink;
              newlink = "[[" + target + "#" + fixedFragment + (link.anchor ? "|" + link.anchor : "") + "]]";
              this.WM.Log.logInfo("Fixed broken link fragment: " + oldlink + " -> " + this.WM.Log.linkToWikiPage(link.link, newlink));
            } else {
              this.WM.Log.logWarning("Cannot fix broken link fragment: " + this.WM.Log.linkToWikiPage(link.link, newlink));
            }
          }
          newText += newlink;
          prevId = link.index + link.length;
        }
        newText += source.substr(prevId);

        if (location.hostname === 'wiki.archlinux.org') {
          newText = this.fixArchWikiLinks(newText, target, sections);
        }
        return newText;
      }
    }, {
      key: 'fixArchWikiLinks',
      value: function fixArchWikiLinks(source, target, sections) {
        var i, j, len, len1, link, link2, links, links2, newText1, newText2, prevId;
        boundMethodCheck(this, ref);
        links = this.WM.Parser.findTemplates(source, 'Related');
        newText1 = "";
        prevId = 0;
        for (i = 0, len = links.length; i < len; i++) {
          link = links[i];
          newText1 += source.substring(prevId, link.index);
          newText1 += this.fixArchWikiLink(target, sections, link, 1);
          prevId = link.index + link.length;
        }
        newText1 += source.substr(prevId);
        links2 = this.WM.Parser.findTemplates(newText1, 'Related2');
        newText2 = "";
        prevId = 0;
        for (j = 0, len1 = links2.length; j < len1; j++) {
          link2 = links2[j];
          newText2 += newText1.substring(prevId, link2.index);
          newText2 += this.fixArchWikiLink(target, sections, link2, 2);
          prevId = link2.index + link2.length;
        }
        newText2 += newText1.substr(prevId);
        return newText2;
      }
    }, {
      key: 'fixArchWikiLink',
      value: function fixArchWikiLink(target, sections, template, expectedArgs) {
        var anchor, args, fixedFragment, fragId, link, ltitle, newlink, rawfragment;
        boundMethodCheck(this, ref);
        args = template.arguments;

        if (args.length === expectedArgs) {
          link = args[0].value;
          fragId = link.indexOf('#');
          if (fragId > -1) {
            ltitle = link.substring(0, fragId);

            if (this.WM.Parser.compareArticleTitles(ltitle, target)) {
              rawfragment = link.substr(fragId + 1);
              fixedFragment = this.fixFragment(rawfragment, sections);
              if (fixedFragment === true) {
                null;
              } else if (fixedFragment) {
                anchor = args[1] ? "|" + args[1].value : "";
                newlink = "{{" + template.title + "|" + target + "#" + fixedFragment + anchor + "}}";
                this.WM.Log.logInfo("Fixed broken link fragment: " + template.rawTransclusion + " -> " + this.WM.Log.linkToWikiPage(link, newlink));
                return newlink;
              } else {
                this.WM.Log.logWarning("Cannot fix broken link fragment: " + this.WM.Log.linkToWikiPage(link, template.rawTransclusion));
              }
            }
          }
        } else {
          this.WM.Log.logWarning("Template:" + template.title + " must have " + expectedArgs + " and only " + expectedArgs + (expectedArgs > 1 ? " arguments: " : " argument: ") + template.rawTransclusion);
        }
        return template.rawTransclusion;
      }
    }, {
      key: 'fixFragment',
      value: function fixFragment(rawfragment, sections) {
        var fragment, i, len, section;
        boundMethodCheck(this, ref);
        if (rawfragment) {
          fragment = this.WM.Parser.squashContiguousWhitespace(rawfragment).trim();
          if (sections.indexOf(fragment) < 0) {
            for (i = 0, len = sections.length; i < len; i++) {
              section = sections[i];

              if (section.toLowerCase() === fragment.toLowerCase()) {
                return section;
              }
            }
            return false;
          } else {
            return true;
          }
        } else {
          return true;
        }
      }
    }, {
      key: 'main_bot',
      value: function main_bot(title, callBot, chainArgs) {
        var params, summary, target;
        summary = this.conf.edit_summary;
        target = readTarget();
        this.WM.Log.logHidden("Target page: " + target);
        if (target) {
          if (chainArgs === null) {
            params = {
              'action': 'parse',
              'prop': 'sections',
              'page': target,
              'redirects': 1
            };
            this.WM.Log.logWarning("If some articles in the list are linking to the target article through a redirect, you should process the backlinks of that redirect page separately through its Special:WhatLinksHere page, as this plugin can only fix links that exactly match the title of the target article.\nIn order to save time you are advised to hide the redirects in the page lists that allow to do so.");
            return this.WM.MW.callAPIGet(params, this.mainAutoFindSections, [title, target, summary, callBot], null);
          } else {
            return this.mainAutoRead(target, chainArgs, title, summary, callBot);
          }
        } else {
          this.WM.Log.logError('The target page cannot be empty');
          return callBot(false, null);
        }
      }
    }, {
      key: 'mainAutoFindSections',
      value: function mainAutoFindSections(res, args) {
        var callBot, i, len, ref1, section, sections, summary, target, title;
        boundMethodCheck(this, ref);
        title = args[0];
        target = args[1];
        summary = args[2];
        callBot = args[3];
        sections = [];
        if (res.parse) {
          ref1 = res.parse.sections;
          for (i = 0, len = ref1.length; i < len; i++) {
            section = ref1[i];
            sections.push(this.WM.Parser.squashContiguousWhitespace(section.line).trim());
          }
          return this.mainAutoRead(target, sections, title, summary, callBot);
        } else {
          this.WM.Log.logError("The set target page, " + target + ", seems not to exist");
          if (res.error) {
            return callBot(res.error.code, sections);
          } else {
            return callBot(false, sections);
          }
        }
      }
    }, {
      key: 'mainAutoRead',
      value: function mainAutoRead(target, sections, title, summary, callBot) {
        boundMethodCheck(this, ref);
        return this.WM.MW.callQueryEdit(title, this.mainAutoWrite, [target, summary, callBot, sections]);
      }
    }, {
      key: 'mainAutoWrite',
      value: function mainAutoWrite(title, source, timestamp, edittoken, args) {
        var callBot, newtext, sections, summary, target;
        boundMethodCheck(this, ref);
        target = args[0];
        summary = args[1];
        callBot = args[2];
        sections = args[3];
        newtext = this.fixLinks(source, target, sections);
        if (newtext !== source) {
          return this.WM.MW.callAPIPost({
            action: "edit",
            bot: "1",
            title: title,
            summary: summary,
            text: newtext,
            basetimestamp: timestamp,
            token: edittoken
          }, this.mainAutoEnd, [callBot, sections], null);
        } else {
          return callBot(0, sections);
        }
      }
    }, {
      key: 'mainAutoEnd',
      value: function mainAutoEnd(res, args) {
        var callBot, sections;
        boundMethodCheck(this, ref);
        callBot = args[0];
        sections = args[1];
        if (res.edit && res.edit.result === 'Success') {
          return callBot(1, sections);
        } else if (res.error) {
          this.WM.Log.logError(res.error.info + " (" + res.error.code + ")");
          return callBot(res.error.code, sections);
        } else {
          return callBot(false, sections);
        }
      }
    }]);

    return FixBacklinkFragments;
  }(Plugin);

  ;

  FixBacklinkFragments.conf_default = {
    enabled: true,
    bot_label: "Fix links to specific sections of a target page",
    edit_summary: "fix links to specific sections"
  };

  readTarget = function readTarget() {
    return document.getElementById("WikiMonkey-FixBacklinkFragments-Target").value;
  };

  return FixBacklinkFragments;
}.call(undefined);

},{"./_Plugin":435,"@kynikos/misc/dist/CSS":2}],428:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Plugin,
    Str,
    ref,
    boundMethodCheck = function boundMethodCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new Error('Bound instance method accessed before binding');
  }
};

var _require = require('./_Plugin');

Plugin = _require.Plugin;


Str = require('@kynikos/misc/dist/Str');

ref = module.exports.FixDoubleRedirects = function () {
  var FixDoubleRedirects = function (_Plugin) {
    _inherits(FixDoubleRedirects, _Plugin);

    function FixDoubleRedirects() {
      _classCallCheck(this, FixDoubleRedirects);

      var _this = _possibleConstructorReturn(this, (FixDoubleRedirects.__proto__ || Object.getPrototypeOf(FixDoubleRedirects)).apply(this, arguments));

      _this.process_redirect = _this.process_redirect.bind(_this);
      return _this;
    }

    _createClass(FixDoubleRedirects, [{
      key: 'main_special',
      value: function () {
        var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(callNext) {
          var doubleRedirect, error, i, len, namespaces, results, siteinfo, _ref2, _siteinfo;

          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  this.WM.Log.logInfo("Fixing double redirects ...");
                  _context.next = 3;
                  return this.WM.MW.getSpecialList("DoubleRedirects", "namespaces");

                case 3:
                  _ref2 = _context.sent;
                  results = _ref2.results;
                  siteinfo = _ref2.siteinfo;
                  _siteinfo = siteinfo;
                  namespaces = _siteinfo.namespaces;

                  results.reverse();
                  _context.prev = 9;
                  i = 0, len = results.length;

                case 11:
                  if (!(i < len)) {
                    _context.next = 18;
                    break;
                  }

                  doubleRedirect = results[i];
                  _context.next = 15;
                  return this.process_redirect(doubleRedirect, namespaces);

                case 15:
                  i++;
                  _context.next = 11;
                  break;

                case 18:
                  _context.next = 25;
                  break;

                case 20:
                  _context.prev = 20;
                  _context.t0 = _context['catch'](9);

                  error = _context.t0;
                  this.WM.Log.logError(error.message);
                  return _context.abrupt('return', false);

                case 25:
                  this.WM.Log.logInfo("Fixed double redirects");

                  if (!callNext) {
                    _context.next = 28;
                    break;
                  }

                  return _context.abrupt('return', callNext());

                case 28:
                case 'end':
                  return _context.stop();
              }
            }
          }, _callee, this, [[9, 20]]);
        }));

        function main_special(_x) {
          return _ref.apply(this, arguments);
        }

        return main_special;
      }()
    }, {
      key: 'process_redirect',
      value: function () {
        var _ref3 = _asyncToGenerator(regeneratorRuntime.mark(function _callee2(doubleRedirect, namespaces) {
          var doubleRedirectSource, edittoken, middleRedirect, middleRedirectSource, middleRedirectTitle, middleTarget, newTarget, newTargetAltAnchor, newTargetFragment, newTargetInterlanguage, newTargetNamespace, newTargetTitle, newText, oldTarget, rawMiddleTarget, rawOldTarget, res, source, timestamp, _ref4;

          return regeneratorRuntime.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  boundMethodCheck(this, ref);
                  _context2.next = 3;
                  return this.WM.MW.callQueryEdit(doubleRedirect.title);

                case 3:
                  _ref4 = _context2.sent;
                  source = _ref4.source;
                  timestamp = _ref4.timestamp;
                  edittoken = _ref4.edittoken;

                  doubleRedirectSource = source;
                  middleRedirectTitle = [namespaces[doubleRedirect.databaseResult.b_namespace]['*'], doubleRedirect.databaseResult.b_title].join(':');
                  _context2.next = 11;
                  return this.WM.MW.callQuery({
                    prop: "revisions",
                    rvprop: "content",
                    titles: middleRedirectTitle
                  });

                case 11:
                  middleRedirect = _context2.sent;

                  middleRedirectSource = middleRedirect.revisions[0]["*"];
                  this.WM.Log.logInfo('Processing ' + this.WM.Log.linkToWikiPage(doubleRedirect.title, doubleRedirect.title) + ' ...');
                  rawOldTarget = doubleRedirectSource.match(/\s*#redirect\s*[^\n]+/i);
                  oldTarget = this.WM.Parser.findInternalLinks(rawOldTarget[0], null)[0];
                  rawMiddleTarget = middleRedirectSource.match(/\s*#redirect\s*[^\n]+/i);
                  middleTarget = this.WM.Parser.findInternalLinks(rawMiddleTarget[0], null)[0];
                  newTargetFragment = function () {
                    if (oldTarget.fragment) {
                      return "#" + oldTarget.fragment;
                    } else if (middleTarget.fragment) {
                      return "#" + middleTarget.fragment;
                    }
                    return "";
                  }();
                  newTargetAltAnchor = function () {
                    if (oldTarget.anchor) {
                      return "|" + oldTarget.anchor;
                    } else if (middleTarget.anchor) {
                      return "|" + middleTarget.anchor;
                    }
                    return "";
                  }();
                  newTargetInterlanguage = doubleRedirect.databaseResult.c_interwiki ? doubleRedirect.databaseResult.c_interwiki + ":" : "";
                  newTargetNamespace = function () {
                    var cns;
                    cns = namespaces[doubleRedirect.databaseResult.c_namespace]["*"];
                    if (cns) {
                      return this.WM.Parser.squashContiguousWhitespace(cns) + ":";
                    }
                    return "";
                  }();
                  newTargetTitle = this.WM.Parser.squashContiguousWhitespace(doubleRedirect.databaseResult.c_title);
                  newTarget = '[[' + newTargetInterlanguage + newTargetNamespace + ('' + newTargetTitle + newTargetFragment + newTargetAltAnchor + ']]');
                  newText = Str.overwriteFor(doubleRedirectSource, newTarget, oldTarget.index, oldTarget.length);

                  if (!(newText !== doubleRedirectSource)) {
                    _context2.next = 33;
                    break;
                  }

                  _context2.next = 28;
                  return this.WM.MW.callAPIPost({
                    action: "edit",
                    bot: "1",
                    title: doubleRedirect.title,
                    summary: this.conf.edit_summary,
                    text: newText,
                    b1asetimestamp: timestamp,
                    token: edittoken
                  });

                case 28:
                  res = _context2.sent;

                  if (!(!res.edit || res.edit.result !== 'Success')) {
                    _context2.next = 31;
                    break;
                  }

                  throw new Error(res.error.info + ' (' + res.error.code + ')');

                case 31:
                  _context2.next = 34;
                  break;

                case 33:
                  return _context2.abrupt('return', this.WM.Log.logWarning('Could not fix ' + this.WM.Log.linkToWikiPage(doubleRedirect.title, doubleRedirect.title)));

                case 34:
                case 'end':
                  return _context2.stop();
              }
            }
          }, _callee2, this);
        }));

        function process_redirect(_x2, _x3) {
          return _ref3.apply(this, arguments);
        }

        return process_redirect;
      }()
    }]);

    return FixDoubleRedirects;
  }(Plugin);

  ;

  FixDoubleRedirects.conf_default = {
    enabled: true,
    special_menu: ["Fix double redirects"],
    edit_summary: "fix double redirect"
  };

  return FixDoubleRedirects;
}.call(undefined);

},{"./_Plugin":435,"@kynikos/misc/dist/Str":7}],429:[function(require,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Plugin;

var _require = require('./_Plugin');

Plugin = _require.Plugin;


module.exports.FixFragments = function () {
  var FixFragments = function (_Plugin) {
    _inherits(FixFragments, _Plugin);

    function FixFragments() {
      _classCallCheck(this, FixFragments);

      return _possibleConstructorReturn(this, (FixFragments.__proto__ || Object.getPrototypeOf(FixFragments)).apply(this, arguments));
    }

    _createClass(FixFragments, [{
      key: "fixLinks",
      value: function fixLinks(source) {
        var i, ilinks, j, len, len1, link, newtext1, newtext2, prevId, rawfragment, sections, slinks, title;
        title = this.WM.Editor.getTitle();
        sections = this.WM.Parser.findSectionHeadings(source).sections;
        slinks = this.WM.Parser.findSectionLinks(source);
        newtext1 = "";
        prevId = 0;
        for (i = 0, len = slinks.length; i < len; i++) {
          link = slinks[i];
          newtext1 += source.substring(prevId, link.index);
          newtext1 += this.fixLink(source, sections, link.rawLink, link.fragment, link.anchor);
          prevId = link.index + link.length;
        }
        newtext1 += source.substr(prevId);

        ilinks = this.WM.Parser.findInternalLinks(newtext1, null, title);
        newtext2 = "";
        prevId = 0;
        for (j = 0, len1 = ilinks.length; j < len1; j++) {
          link = ilinks[j];
          newtext2 += newtext1.substring(prevId, link.index);
          rawfragment = link.fragment;
          if (rawfragment) {
            newtext2 += this.fixLink(newtext1, sections, link.rawLink, rawfragment, link.anchor);
          } else {
            newtext2 += link.rawLink;
          }
          prevId = link.index + link.length;
        }
        newtext2 += newtext1.substr(prevId);
        return newtext2;
      }
    }, {
      key: "fixLink",
      value: function fixLink(source, sections, rawlink, rawfragment, lalt) {
        var dotFragment, dotHeading, escHeading, fragment, heading, i, len, section;
        fragment = this.WM.Parser.squashContiguousWhitespace(rawfragment).trim();
        for (i = 0, len = sections.length; i < len; i++) {
          section = sections[i];
          heading = section.cleanheading;
          dotHeading = this.WM.Parser.dotEncode(heading);
          dotFragment = this.WM.Parser.dotEncode(fragment);
          if (dotHeading.toLowerCase() === dotFragment.toLowerCase()) {
            if (fragment === dotFragment) {
              return "[[#" + dotHeading + (lalt ? "|" + lalt : "") + "]]";
            } else {
              escHeading = this.WM.Parser.dotEncodeLinkBreakingFragmentCharacters(heading);
              return "[[#" + escHeading + (lalt ? "|" + lalt : "") + "]]";
            }
          }
        }

        this.WM.Log.logWarning("Cannot fix broken section link: " + rawlink);
        return rawlink;
      }
    }, {
      key: "main_editor",
      value: function main_editor(callNext) {
        var newtext, source;
        source = this.WM.Editor.readSource();
        newtext = this.fixLinks(source);
        if (newtext !== source) {
          this.WM.Editor.writeSource(newtext);
          this.WM.Log.logInfo("Fixed section links");
        } else {
          this.WM.Log.logInfo("No fixable section links found");
        }
        if (callNext) {
          return callNext();
        }
      }
    }]);

    return FixFragments;
  }(Plugin);

  ;

  FixFragments.conf_default = {
    enabled: true,
    editor_menu: ["Text plugins", "Fix section links"]
  };

  return FixFragments;
}.call(undefined);

},{"./_Plugin":435}],430:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Plugin,
    ref,
    boundMethodCheck = function boundMethodCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new Error('Bound instance method accessed before binding');
  }
},
    indexOf = [].indexOf;

var _require = require('./_Plugin');

Plugin = _require.Plugin;


ref = module.exports.FixLinkFragments = function () {
  var FixLinkFragments = function (_Plugin) {
    _inherits(FixLinkFragments, _Plugin);

    function FixLinkFragments() {
      _classCallCheck(this, FixLinkFragments);

      var _this = _possibleConstructorReturn(this, (FixLinkFragments.__proto__ || Object.getPrototypeOf(FixLinkFragments)).apply(this, arguments));

      _this.processLink = _this.processLink.bind(_this);
      _this.processLinkContinue = _this.processLinkContinue.bind(_this);
      _this.fixFragment = _this.fixFragment.bind(_this);
      _this.findArchWikiLinks = _this.findArchWikiLinks.bind(_this);
      _this.findArchWikiLinks2 = _this.findArchWikiLinks2.bind(_this);
      _this.processArchWikiLink = _this.processArchWikiLink.bind(_this);
      _this.processArchWikiLinkContinue = _this.processArchWikiLinkContinue.bind(_this);
      _this.mainContinue = _this.mainContinue.bind(_this);
      _this.mainEnd = _this.mainEnd.bind(_this);
      return _this;
    }

    _createClass(FixLinkFragments, [{
      key: 'processLink',
      value: function processLink(title, iwprefixes, links, index, source, newText, prevId, call, callArgs) {
        var link, params, rawfragment, ref1, target;
        boundMethodCheck(this, ref);
        if (links[index]) {
          link = links[index];
          rawfragment = link.fragment;
          if (!(link.namespace != null && (ref1 = link.namespace.toLowerCase(), indexOf.call(iwprefixes, ref1) >= 0)) && rawfragment) {
            this.WM.Log.logInfo("Processing " + this.WM.Log.linkToWikiPage(link.link, link.rawLink) + " ...");
            target = (link.namespace ? link.namespace + ":" : "") + link.title;

            if (!this.WM.Parser.compareArticleTitles(target, title)) {
              params = {
                'action': 'parse',
                'prop': 'sections',
                'page': target,
                'redirects': 1
              };
              return this.WM.MW.callAPIGet(params, this.processLinkContinue, [link, target, rawfragment, iwprefixes, links, index, source, newText, prevId, title, call, callArgs], null);
            } else {
              index++;
              return this.processLink(title, iwprefixes, links, index, source, newText, prevId, call, callArgs);
            }
          } else {
            index++;
            return this.processLink(title, iwprefixes, links, index, source, newText, prevId, call, callArgs);
          }
        } else {
          newText += source.substr(prevId);
          return call(newText, iwprefixes, callArgs);
        }
      }
    }, {
      key: 'processLinkContinue',
      value: function processLinkContinue(res, args) {
        var call, callArgs, fixedFragment, i, index, iwprefixes, len, link, links, newText, prevId, rawfragment, ref1, section, sections, source, target, title;
        boundMethodCheck(this, ref);
        link = args[0];
        target = args[1];
        rawfragment = args[2];
        iwprefixes = args[3];
        links = args[4];
        index = args[5];
        source = args[6];
        newText = args[7];
        prevId = args[8];
        title = args[9];
        call = args[10];
        callArgs = args[11];

        if (res.parse) {
          sections = [];
          ref1 = res.parse.sections;
          for (i = 0, len = ref1.length; i < len; i++) {
            section = ref1[i];
            sections.push(this.WM.Parser.squashContiguousWhitespace(section.line).trim());
          }
          fixedFragment = this.fixFragment(rawfragment, sections);
          newText += source.substring(prevId, link.index);
          if (fixedFragment === true) {
            newText += link.rawLink;
          } else if (fixedFragment) {
            newText += "[[" + target + "#" + fixedFragment + (link.anchor ? "|" + link.anchor : "") + "]]";
          } else {
            this.WM.Log.logWarning("Cannot fix broken link fragment: " + this.WM.Log.linkToWikiPage(link.link, link.rawLink));
            newText += link.rawLink;
          }
          prevId = link.index + link.length;
        }
        index++;
        return this.processLink(title, iwprefixes, links, index, source, newText, prevId, call, callArgs);
      }
    }, {
      key: 'fixFragment',
      value: function fixFragment(rawfragment, sections) {
        var dotFragment, dotSection, fragment, i, len, section;
        boundMethodCheck(this, ref);
        fragment = this.WM.Parser.squashContiguousWhitespace(rawfragment).trim();
        if (sections.indexOf(fragment) < 0) {
          for (i = 0, len = sections.length; i < len; i++) {
            section = sections[i];
            dotSection = this.WM.Parser.dotEncode(section);
            dotFragment = this.WM.Parser.dotEncode(fragment);
            if (dotSection.toLowerCase() === dotFragment.toLowerCase()) {
              if (fragment === dotFragment) {
                return dotSection;
              } else {
                return this.WM.Parser.dotEncodeLinkBreakingFragmentCharacters(section);
              }
            }
          }
          return false;
        } else {
          return true;
        }
      }
    }, {
      key: 'findArchWikiLinks',
      value: function findArchWikiLinks(newText, iwprefixes, callArgs) {
        var templates, title;
        boundMethodCheck(this, ref);
        templates = this.WM.Parser.findTemplates(newText, 'Related');
        title = this.WM.Editor.getTitle();
        return this.processArchWikiLink(title, iwprefixes, templates, 1, 0, newText, "", 0, this.findArchWikiLinks2, callArgs);
      }
    }, {
      key: 'findArchWikiLinks2',
      value: function findArchWikiLinks2(newText, iwprefixes, callArgs) {
        var templates, title;
        boundMethodCheck(this, ref);
        templates = this.WM.Parser.findTemplates(newText, 'Related2');
        title = this.WM.Editor.getTitle();
        return this.processArchWikiLink(title, iwprefixes, templates, 2, 0, newText, "", 0, this.mainEnd, callArgs);
      }
    }, {
      key: 'processArchWikiLink',
      value: function processArchWikiLink(title, iwprefixes, templates, expectedArgs, index, source, newText, prevId, call, callArgs) {
        var args, fragId, link, params, rawfragment, rawtarget, target, template;
        boundMethodCheck(this, ref);
        if (templates[index]) {
          template = templates[index];
          args = template.arguments;

          if (args.length === expectedArgs) {
            link = args[0].value;
            fragId = link.indexOf('#');
            if (fragId > -1) {
              rawtarget = link.substring(0, fragId);
              target = this.WM.Parser.squashContiguousWhitespace(rawtarget).trim();
              rawfragment = link.substr(fragId + 1);
              if (rawfragment) {
                if (!this.WM.Parser.compareArticleTitles(target, title)) {
                  this.WM.Log.logInfo("Processing " + this.WM.Log.linkToWikiPage(link, template.rawTransclusion) + " ...");
                  params = {
                    'action': 'parse',
                    'prop': 'sections',
                    'page': target,
                    'redirects': 1
                  };
                  return this.WM.MW.callAPIGet(params, this.processArchWikiLinkContinue, [template, target, rawfragment, iwprefixes, templates, expectedArgs, index, source, newText, prevId, title, call, callArgs], null);
                } else {
                  index++;
                  return this.processArchWikiLink(title, iwprefixes, templates, expectedArgs, index, source, newText, prevId, call, callArgs);
                }
              } else {
                index++;
                return this.processArchWikiLink(title, iwprefixes, templates, expectedArgs, index, source, newText, prevId, call, callArgs);
              }
            } else {
              index++;
              return this.processArchWikiLink(title, iwprefixes, templates, expectedArgs, index, source, newText, prevId, call, callArgs);
            }
          } else {
            this.WM.Log.logWarning("Template:" + template.title + " must have " + expectedArgs + " and only " + expectedArgs + (expectedArgs > 1 ? " arguments: " : " argument: ") + template.rawTransclusion);
            index++;
            return this.processArchWikiLink(title, iwprefixes, templates, expectedArgs, index, source, newText, prevId, call, callArgs);
          }
        } else {
          newText += source.substr(prevId);
          return call(newText, iwprefixes, callArgs);
        }
      }
    }, {
      key: 'processArchWikiLinkContinue',
      value: function processArchWikiLinkContinue(res, args) {
        var anchor, call, callArgs, expectedArgs, fixedFragment, i, index, iwprefixes, len, newText, prevId, rawfragment, ref1, section, sections, source, target, template, templates, title;
        boundMethodCheck(this, ref);
        template = args[0];
        target = args[1];
        rawfragment = args[2];
        iwprefixes = args[3];
        templates = args[4];
        expectedArgs = args[5];
        index = args[6];
        source = args[7];
        newText = args[8];
        prevId = args[9];
        title = args[10];
        call = args[11];
        callArgs = args[12];

        if (res.parse) {
          sections = [];
          ref1 = res.parse.sections;
          for (i = 0, len = ref1.length; i < len; i++) {
            section = ref1[i];
            sections.push(this.WM.Parser.squashContiguousWhitespace(section.line).trim());
          }
          fixedFragment = this.fixFragment(rawfragment, sections);
          newText += source.substring(prevId, template.index);
          if (fixedFragment === true) {
            newText += template.rawTransclusion;
          } else if (fixedFragment) {
            anchor = template.arguments[1] ? "|" + template.arguments[1].value : "";
            newText += "{{" + template.title + "|" + target + "#" + fixedFragment + anchor + "}}";
          } else {
            this.WM.Log.logWarning("Cannot fix broken link fragment: " + this.WM.Log.linkToWikiPage(target, template.rawTransclusion));
            newText += template.rawTransclusion;
          }
          prevId = template.index + template.length;
        }
        index++;
        return this.processArchWikiLink(title, iwprefixes, templates, expectedArgs, index, source, newText, prevId, call, callArgs);
      }
    }, {
      key: 'main_editor',
      value: function () {
        var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(callNext) {
          var iw, iwprefixes, links, res, source, title;
          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  source = this.WM.Editor.readSource();
                  this.WM.Log.logInfo("Fixing links to sections of other articles ...");
                  title = this.WM.Editor.getTitle();
                  _context.next = 5;
                  return this.WM.MW.getInterwikiMap(title);

                case 5:
                  res = _context.sent;

                  iwprefixes = function () {
                    var i, len, ref1, results;
                    ref1 = res.query.interwikimap;
                    results = [];
                    for (i = 0, len = ref1.length; i < len; i++) {
                      iw = ref1[i];
                      results.push(iw.prefix);
                    }
                    return results;
                  }();
                  links = this.WM.Parser.findInternalLinks(source, null, null);
                  return _context.abrupt('return', this.processLink(title, iwprefixes, links, 0, source, "", 0, this.mainContinue, callNext));

                case 9:
                case 'end':
                  return _context.stop();
              }
            }
          }, _callee, this);
        }));

        function main_editor(_x) {
          return _ref.apply(this, arguments);
        }

        return main_editor;
      }()
    }, {
      key: 'mainContinue',
      value: function mainContinue(newText, iwprefixes, callNext) {
        var templates;
        boundMethodCheck(this, ref);

        if (location.hostname === 'wiki.archlinux.org') {
          return templates = this.findArchWikiLinks(newText, iwprefixes, callNext);
        } else {
          return this.mainEnd(newText, iwprefixes, callNext);
        }
      }
    }, {
      key: 'mainEnd',
      value: function mainEnd(newText, iwprefixes, callNext) {
        var source;
        boundMethodCheck(this, ref);
        source = this.WM.Editor.readSource();
        if (newText !== source) {
          this.WM.Editor.writeSource(newText);
          this.WM.Log.logInfo("Replaced links to sections of other articles");
        } else {
          this.WM.Log.logInfo("No fixable links to sections of other articles " + "found");
        }
        if (callNext) {
          return callNext();
        }
      }
    }]);

    return FixLinkFragments;
  }(Plugin);

  ;

  FixLinkFragments.conf_default = {
    enabled: true,
    editor_menu: ["Query plugins", "Fix external section links"]
  };

  return FixLinkFragments;
}.call(undefined);

},{"./_Plugin":435}],431:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Plugin;

var _require = require('./_Plugin');

Plugin = _require.Plugin;


module.exports.MultipleLineBreaks = function () {
  var MultipleLineBreaks = function (_Plugin) {
    _inherits(MultipleLineBreaks, _Plugin);

    function MultipleLineBreaks() {
      _classCallCheck(this, MultipleLineBreaks);

      return _possibleConstructorReturn(this, (MultipleLineBreaks.__proto__ || Object.getPrototypeOf(MultipleLineBreaks)).apply(this, arguments));
    }

    _createClass(MultipleLineBreaks, [{
      key: 'main_editor',
      value: function main_editor(callNext) {
        var newtext, source;
        source = this.WM.Editor.readSource();
        newtext = source;
        newtext = newtext.replace(/[\n]{3,}/g, '\n\n');
        if (newtext !== source) {
          this.WM.Editor.writeSource(newtext);
          this.WM.Log.logInfo("Removed multiple line breaks");
        }
        if (callNext) {
          return callNext();
        }
      }
    }]);

    return MultipleLineBreaks;
  }(Plugin);

  ;

  MultipleLineBreaks.conf_default = {
    enabled: true,
    editor_menu: ["Text plugins", "Squash multiple line breaks"]
  };

  return MultipleLineBreaks;
}.call(undefined);

},{"./_Plugin":435}],432:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var CSS,
    Plugin,
    ref,
    boundMethodCheck = function boundMethodCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new Error('Bound instance method accessed before binding');
  }
};

var _require = require('./_Plugin');

Plugin = _require.Plugin;


CSS = require('@kynikos/misc/dist/CSS');

ref = module.exports.SimpleReplace = function () {
  var configuration, _makeUI, storeRegExp;

  var SimpleReplace = function (_Plugin) {
    _inherits(SimpleReplace, _Plugin);

    function SimpleReplace() {
      _classCallCheck(this, SimpleReplace);

      var _this = _possibleConstructorReturn(this, (SimpleReplace.__proto__ || Object.getPrototypeOf(SimpleReplace)).apply(this, arguments));

      _this.storeConfiguration = _this.storeConfiguration.bind(_this);
      _this.mainAutoWrite = _this.mainAutoWrite.bind(_this);
      _this.mainAutoEnd = _this.mainAutoEnd.bind(_this);
      return _this;
    }

    _createClass(SimpleReplace, [{
      key: 'makeUI',
      value: function makeUI() {
        return _makeUI();
      }
    }, {
      key: 'makeBotUI',
      value: function makeBotUI() {
        var divMain, par3, summary, summaryLabel;
        divMain = _makeUI();
        par3 = document.createElement('div');
        summaryLabel = document.createElement('span');
        summaryLabel.innerHTML = 'Edit summary:';
        summary = document.createElement('input');
        summary.setAttribute('type', 'text');
        summary.id = "WikiMonkey-SimpleReplace-Summary";
        par3.appendChild(summaryLabel);
        par3.appendChild(summary);
        divMain.appendChild(par3);
        return divMain;
      }
    }, {
      key: 'storeConfiguration',
      value: function storeConfiguration() {
        boundMethodCheck(this, ref);
        configuration = {
          pattern: document.getElementById("WikiMonkey-SimpleReplace-RegExp").value,
          ignoreCase: document.getElementById("WikiMonkey-SimpleReplace-IgnoreCase").checked,
          newString: document.getElementById("WikiMonkey-SimpleReplace-NewString").value
        };
        this.WM.Log.logHidden("Pattern: " + configuration.pattern);
        this.WM.Log.logHidden("Ignore case: " + configuration.ignoreCase);
        return this.WM.Log.logHidden("New string: " + configuration.newString);
      }
    }, {
      key: 'main_editor',
      value: function main_editor(callNext) {
        var exc, newtext, source;
        this.storeConfiguration();
        try {
          storeRegExp();
        } catch (error) {
          exc = error;
          this.WM.Log.logError("Invalid pattern: " + exc);

          return false;
        }
        source = this.WM.Editor.readSource();
        newtext = source.replace(configuration.regExp, configuration.newString);
        if (newtext !== source) {
          this.WM.Editor.writeSource(newtext);
          this.WM.Log.logInfo("Text substituted");
        }
        if (callNext) {
          return callNext();
        }
      }
    }, {
      key: 'main_bot',
      value: function main_bot(title, callBot, chainArgs) {
        var exc, summary;
        this.storeConfiguration();
        try {
          storeRegExp();
        } catch (error) {
          exc = error;
          this.WM.Log.logError("Invalid pattern: " + exc);
          callBot(false, null);

          return false;
        }
        summary = document.getElementById("WikiMonkey-SimpleReplace-Summary").value;
        if (summary !== "") {
          return this.WM.MW.callQueryEdit(title, this.mainAutoWrite, [summary, callBot]);
        } else {
          this.WM.Log.logError("The edit summary cannot be empty");
          return callBot(false, null);
        }
      }
    }, {
      key: 'mainAutoWrite',
      value: function mainAutoWrite(title, source, timestamp, edittoken, args) {
        var callBot, newtext, summary;
        boundMethodCheck(this, ref);
        summary = args[0];
        callBot = args[1];
        newtext = source.replace(configuration.regExp, configuration.newString);
        if (newtext !== source) {
          return this.WM.MW.callAPIPost({
            action: "edit",
            bot: "1",
            title: title,
            summary: summary,
            text: newtext,
            basetimestamp: timestamp,
            token: edittoken
          }, this.mainAutoEnd, callBot, null);
        } else {
          return callBot(0, null);
        }
      }
    }, {
      key: 'mainAutoEnd',
      value: function mainAutoEnd(res, callBot) {
        boundMethodCheck(this, ref);
        if (res.edit && res.edit.result === 'Success') {
          return callBot(1, null);
        } else if (res.error) {
          this.WM.Log.logError(res.error.info + " (" + res.error.code + ")");
          return callBot(res.error.code, null);
        } else {
          return callBot(false, null);
        }
      }
    }]);

    return SimpleReplace;
  }(Plugin);

  ;

  SimpleReplace.conf_default = {
    enabled: true,
    editor_menu: ["RegExp substitution"],
    bot_label: "RegExp substitution"
  };

  _makeUI = function _makeUI() {
    var divMain, ignoreCase, ignoreCaseLabel, newString, newStringLabel, par1, par2, regexp, regexpLabel;
    CSS.addStyleElement("#WikiMonkey-SimpleReplace div " + "{margin-bottom:0.33em;} " + "#WikiMonkey-SimpleReplace input[type='text'] " + "{margin-left:0.33em; width:60%;}");
    divMain = document.createElement('div');
    divMain.id = "WikiMonkey-SimpleReplace";
    par1 = document.createElement('div');
    regexpLabel = document.createElement('span');
    regexpLabel.innerHTML = 'RegExp pattern:';
    regexp = document.createElement('input');
    regexp.setAttribute('type', 'text');
    regexp.id = "WikiMonkey-SimpleReplace-RegExp";
    ignoreCase = document.createElement('input');
    ignoreCase.setAttribute('type', 'checkbox');
    ignoreCase.id = "WikiMonkey-SimpleReplace-IgnoreCase";
    ignoreCaseLabel = document.createElement('span');
    ignoreCaseLabel.innerHTML = 'i';
    par1.appendChild(regexpLabel);
    par1.appendChild(regexp);
    par1.appendChild(ignoreCase);
    par1.appendChild(ignoreCaseLabel);
    par2 = document.createElement('div');
    newStringLabel = document.createElement('span');
    newStringLabel.innerHTML = 'New string:';
    newString = document.createElement('input');
    newString.setAttribute('type', 'text');
    newString.id = "WikiMonkey-SimpleReplace-NewString";
    par2.appendChild(newStringLabel);
    par2.appendChild(newString);
    divMain.appendChild(par1);
    divMain.appendChild(par2);
    return divMain;
  };

  configuration = null;

  storeRegExp = function storeRegExp() {
    return configuration.regExp = new RegExp(configuration.pattern, "g" + (configuration.ignoreCase ? "i" : ""));
  };

  return SimpleReplace;
}.call(undefined);

},{"./_Plugin":435,"@kynikos/misc/dist/CSS":2}],433:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Plugin,
    ref,
    boundMethodCheck = function boundMethodCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new Error('Bound instance method accessed before binding');
  }
};

var _require = require('./_Plugin');

Plugin = _require.Plugin;


ref = module.exports.SynchronizeInterlanguageLinks = function () {
  var SynchronizeInterlanguageLinks = function (_Plugin) {
    _inherits(SynchronizeInterlanguageLinks, _Plugin);

    function SynchronizeInterlanguageLinks() {
      _classCallCheck(this, SynchronizeInterlanguageLinks);

      var _this = _possibleConstructorReturn(this, (SynchronizeInterlanguageLinks.__proto__ || Object.getPrototypeOf(SynchronizeInterlanguageLinks)).apply(this, arguments));

      _this.detectLang = _this.detectLang.bind(_this);
      _this.computeWhiteList = _this.computeWhiteList.bind(_this);
      _this.computeSupportedLangs = _this.computeSupportedLangs.bind(_this);
      _this.mainContinue = _this.mainContinue.bind(_this);
      _this.mainEnd = _this.mainEnd.bind(_this);
      _this.mainAutoWrite = _this.mainAutoWrite.bind(_this);
      _this.mainAutoEnd = _this.mainAutoEnd.bind(_this);
      return _this;
    }

    _createClass(SynchronizeInterlanguageLinks, [{
      key: 'detectLang',
      value: function detectLang(title, tag) {
        var detect, pureTitle;
        boundMethodCheck(this, ref);

        if (tag === "ArchWiki") {
          detect = this.WM.ArchWiki.detectLanguage(title);
          pureTitle = detect[0];
          tag = this.WM.ArchWiki.getInterlanguageTag(detect[1]);
        } else {
          pureTitle = title;
        }
        return [pureTitle, tag];
      }
    }, {
      key: 'computeWhiteList',
      value: function computeWhiteList(whitelist) {
        boundMethodCheck(this, ref);

        if (whitelist === "ArchWiki") {
          return this.WM.ArchWiki.getInternalInterwikiLanguages();
        } else {
          return whitelist;
        }
      }
    }, {
      key: 'computeSupportedLangs',
      value: function computeSupportedLangs(supportedLangs) {
        boundMethodCheck(this, ref);

        if (supportedLangs === "ArchWiki") {
          return this.WM.ArchWiki.getInterwikiLanguages();
        } else {
          return supportedLangs;
        }
      }
    }, {
      key: 'main_editor',
      value: function main_editor(callNext) {
        var detect, pureTitle, supportedLangs, tag, title, whitelist;
        title = this.WM.Editor.getTitle();
        detect = this.detectLang(title, this.conf.language_tag);
        pureTitle = detect[0];
        tag = detect[1];
        whitelist = this.computeWhiteList(this.conf.tag_whitelist);
        supportedLangs = this.computeSupportedLangs(this.conf.supported_tags);
        this.WM.Log.logInfo("Synchronizing interlanguage links ...");
        return this.WM.MW.getLocalInterwikiMap(title, this.mainContinue, [tag, pureTitle, supportedLangs, whitelist, title, callNext]);
      }
    }, {
      key: 'mainContinue',
      value: function mainContinue(iwmap, args) {
        var callNext, i, langlinks, len, link, newlinks, nlink, pureTitle, source, supportedLangs, tag, title, url, visitedlinks, vlink, whitelist, wikiUrls;
        boundMethodCheck(this, ref);
        tag = args[0];
        pureTitle = args[1];
        supportedLangs = args[2];
        whitelist = args[3];
        title = args[4];
        callNext = args[5];
        source = this.WM.Editor.readSource();
        langlinks = this.WM.Interlanguage.parseLinks(supportedLangs, source, iwmap);
        wikiUrls = this.WM.MW.getWikiUrls();
        url = wikiUrls.short + encodeURIComponent(this.WM.Parser.squashContiguousWhitespace(title));
        visitedlinks = {};
        visitedlinks[tag.toLowerCase()] = this.WM.Interlanguage.createVisitedLink(tag, pureTitle, url, iwmap, source, null, null, langlinks);
        newlinks = {};
        this.WM.Log.logInfo("Reading " + this.WM.Log.linkToPage(url, "edited article") + " ...");
        if (langlinks) {
          for (i = 0, len = langlinks.length; i < len; i++) {
            link = langlinks[i];
            nlink = newlinks[link.lang.toLowerCase()];
            vlink = visitedlinks[link.lang.toLowerCase()];
            if (!vlink && !nlink) {
              newlinks[link.lang.toLowerCase()] = this.WM.Interlanguage.createNewLink(link.lang, link.title, link.url);
            } else if (vlink && vlink.url !== link.url) {
              this.WM.Log.logWarning("Possibly conflicting interlanguage " + "links: " + this.WM.Log.linkToPage(link.url, "[[" + link.lang + ":" + link.title + "]]") + " and " + this.WM.Log.linkToPage(vlink.url, "[[" + link.lang + ":" + visitedlinks[link.lang.toLowerCase()].title + "]]"));
            } else if (nlink && nlink.url !== link.url) {
              this.WM.Log.logWarning("Possibly conflicting interlanguage " + "links: " + this.WM.Log.linkToPage(link.url, "[[" + link.lang + ":" + link.title + "]]") + " and " + this.WM.Log.linkToPage(nlink.url, "[[" + link.lang + ":" + newlinks[link.lang.toLowerCase()].title + "]]"));
            }
          }
          return this.WM.Interlanguage.collectLinks(visitedlinks, newlinks, supportedLangs, whitelist, false, this.mainEnd, [tag, url, source, langlinks, iwmap, callNext]);
        } else {
          this.WM.Log.logInfo("No interlanguage links found");
          if (callNext) {
            return callNext();
          }
        }
      }
    }, {
      key: 'mainEnd',
      value: function mainEnd(links, args) {
        var callNext, iwmap, langlinks, newText, source, tag, url;
        boundMethodCheck(this, ref);
        tag = args[0];
        url = args[1];
        source = args[2];
        langlinks = args[3];
        iwmap = args[4];
        callNext = args[5];
        newText = this.WM.Interlanguage.updateLinks(tag, url, iwmap, source, langlinks, links);
        if (newText !== source) {
          this.WM.Editor.writeSource(newText);
          this.WM.Log.logInfo("Synchronized interlanguage links");
        } else {
          this.WM.Log.logInfo("Interlanguage links were already synchronized");
        }
        if (callNext) {
          return callNext();
        }
      }
    }, {
      key: 'main_bot',
      value: function main_bot(title, callBot, chainArgs) {
        var detect, newlinks, pureTitle, summary, supportedLangs, tag, url, visitedlinks, whitelist, wikiUrls;
        detect = this.detectLang(title, this.conf.language_tag);
        pureTitle = detect[0];
        tag = detect[1];
        whitelist = this.computeWhiteList(this.conf.tag_whitelist);
        supportedLangs = this.computeSupportedLangs(this.conf.supported_tags);
        summary = this.conf.edit_summary;
        wikiUrls = this.WM.MW.getWikiUrls();
        url = wikiUrls.short + encodeURIComponent(this.WM.Parser.squashContiguousWhitespace(title));
        visitedlinks = {};
        newlinks = {};
        newlinks[tag.toLowerCase()] = this.WM.Interlanguage.createNewLink(tag, pureTitle, url);
        return this.WM.Interlanguage.collectLinks(visitedlinks, newlinks, supportedLangs, whitelist, true, this.mainAutoWrite, [title, url, tag, summary, callBot]);
      }
    }, {
      key: 'mainAutoWrite',
      value: function mainAutoWrite(links, args) {
        var callBot, edittoken, iwmap, langlinks, lcTag, newText, source, summary, tag, timestamp, title, url;
        boundMethodCheck(this, ref);
        title = args[0];
        url = args[1];
        tag = args[2];
        summary = args[3];
        callBot = args[4];
        lcTag = tag.toLowerCase();

        iwmap = links[lcTag].iwmap;
        source = links[lcTag].source;
        langlinks = links[lcTag].links;
        timestamp = links[lcTag].timestamp;
        edittoken = links[lcTag].edittoken;
        newText = this.WM.Interlanguage.updateLinks(tag, url, iwmap, source, langlinks, links);
        if (newText !== source) {
          return this.WM.MW.callAPIPost({
            action: "edit",
            bot: "1",
            title: title,
            summary: summary,
            text: newText,
            basetimestamp: timestamp,
            token: edittoken
          }, this.mainAutoEnd, callBot, null);
        } else {
          return callBot(0, null);
        }
      }
    }, {
      key: 'mainAutoEnd',
      value: function mainAutoEnd(res, callBot) {
        boundMethodCheck(this, ref);
        if (res.edit && res.edit.result === 'Success') {
          return callBot(1, null);
        } else if (res.error) {
          this.WM.Log.logError(res.error.info + " (" + res.error.code + ")");
          return callBot(res.error.code, null);
        } else {
          return callBot(false, null);
        }
      }
    }]);

    return SynchronizeInterlanguageLinks;
  }(Plugin);

  ;

  SynchronizeInterlanguageLinks.conf_default = {
    enabled: true,
    editor_menu: ["Query plugins", "Sync interlanguage links"],
    bot_label: "Synchronize interlanguage links",
    language_tag: "en",
    tag_whitelist: ["en"],
    supported_tags: ["en"],
    edit_summary: "synchronized interlanguage links with the other wikis"
  };

  SynchronizeInterlanguageLinks.wiki_to_conf_default = {
    ArchWiki: {
      language_tag: "ArchWiki",
      tag_whitelist: "ArchWiki",
      supported_tags: "ArchWiki"
    },
    Wikipedia: {
      enabled: false
    }
  };

  return SynchronizeInterlanguageLinks;
}.call(undefined);

},{"./_Plugin":435}],434:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Plugin,
    Str,
    ref,
    boundMethodCheck = function boundMethodCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new Error('Bound instance method accessed before binding');
  }
},
    indexOf = [].indexOf;

var _require = require('./_Plugin');

Plugin = _require.Plugin;


Str = require('@kynikos/misc/dist/Str');

ref = module.exports.UpdateCategoryTree = function () {
  var UpdateCategoryTree = function (_Plugin) {
    _inherits(UpdateCategoryTree, _Plugin);

    function UpdateCategoryTree() {
      _classCallCheck(this, UpdateCategoryTree);

      var _this = _possibleConstructorReturn(this, (UpdateCategoryTree.__proto__ || Object.getPrototypeOf(UpdateCategoryTree)).apply(this, arguments));

      _this.mainContinue = _this.mainContinue.bind(_this);
      _this.readToC = _this.readToC.bind(_this);
      _this.processToC = _this.processToC.bind(_this);
      _this.storeAlternativeNames = _this.storeAlternativeNames.bind(_this);
      _this.processCategory = _this.processCategory.bind(_this);
      _this.processCategoryAddSuffix = _this.processCategoryAddSuffix.bind(_this);
      _this.processCategoryEnd = _this.processCategoryEnd.bind(_this);
      _this.createCatLink = _this.createCatLink.bind(_this);
      _this.writeToC = _this.writeToC.bind(_this);
      _this.checkWrite = _this.checkWrite.bind(_this);
      return _this;
    }

    _createClass(UpdateCategoryTree, [{
      key: 'main_special',
      value: function main_special(callNext) {
        return this.iteratePages(-1, callNext);
      }
    }, {
      key: 'iteratePages',
      value: function iteratePages(pageid, callNext) {
        var params, pconf, showRootAlsoIn, summary;
        pageid++;
        summary = this.conf.edit_summary;
        showRootAlsoIn = this.conf.show_root_also_in;
        pconf = this.conf.pages[pageid];
        if (pconf) {
          if ($.type(pconf) === "string") {
            params = this.WM.ArchWiki.getTableOfContents(pconf);
          } else {
            params = pconf;
          }
          return this.WM.MW.isUserBot(this.mainContinue, [params, showRootAlsoIn, summary, callNext, pageid]);
        } else if (callNext) {
          return callNext();
        }
      }
    }, {
      key: 'mainContinue',
      value: function mainContinue(botTest, args) {
        boundMethodCheck(this, ref);
        return this.readToC({
          params: args[0],
          minInterval: botTest ? 60000 : 21600000,
          edittoken: "",
          timestamp: "",
          source: "",
          startId: 0,
          endId: 0,
          treeText: "",
          startMark: "START AUTO TOC - DO NOT REMOVE OR MODIFY THIS MARK-->",
          endMark: "<!--END AUTO TOC - DO NOT REMOVE OR MODIFY THIS MARK",
          altNames: {},
          showRootAlsoIn: args[1],
          summary: args[2],
          callNext: args[3],
          pageid: args[4]
        });
      }
    }, {
      key: 'readToC',
      value: function readToC(args) {
        boundMethodCheck(this, ref);
        this.WM.Log.logInfo('Updating ' + this.WM.Log.linkToWikiPage(args.params.page, args.params.page) + " ...");
        return this.WM.MW.callQueryEdit(args.params.page, this.processToC, args);
      }
    }, {
      key: 'processToC',
      value: function processToC(title, source, timestamp, edittoken, args) {
        var end, msTimestamp, now, start;
        boundMethodCheck(this, ref);
        args.source = source;
        args.timestamp = timestamp;
        args.edittoken = edittoken;
        now = new Date();
        msTimestamp = Date.parse(args.timestamp);
        if (now.getTime() - msTimestamp >= args.minInterval) {
          start = args.source.indexOf(args.startMark);
          end = args.source.lastIndexOf(args.endMark);
          if (start > -1 && end > -1) {
            args.startId = start + args.startMark.length;
            args.endId = end;
            args.treeText = "";
            args.altNames = args.params.keepAltName ? this.storeAlternativeNames(args.source) : {};
            return this.WM.Cat.recurseTree({
              node: args.params.root,
              callNode: this.processCategory,
              callEnd: this.writeToC,
              callArgs: args
            });
          } else {
            this.WM.Log.logError("Cannot find insertion marks in " + this.WM.Log.linkToWikiPage(args.params.page, args.params.page));
            return this.iteratePages(args.pageid, args.callNext);
          }
        } else {
          this.WM.Log.logWarning(this.WM.Log.linkToWikiPage(args.params.page, args.params.page) + ' has been updated too recently');
          return this.iteratePages(args.pageid, args.callNext);
        }
      }
    }, {
      key: 'storeAlternativeNames',
      value: function storeAlternativeNames(source) {
        var dict, match, regExp;
        boundMethodCheck(this, ref);
        dict = {};
        regExp = /\[\[\:([Cc]ategory\:.+?)\|(.+?)\]\]/gm;
        while (true) {
          match = regExp.exec(source);
          if (match) {
            dict[match[1].toLowerCase()] = match[2];
          } else {
            break;
          }
        }
        return dict;
      }
    }, {
      key: 'processCategory',
      value: function processCategory(params) {
        var altName, args, indices, j, node, ref1, text;
        boundMethodCheck(this, ref);
        args = params.callArgs;
        this.WM.Log.logInfo("Processing " + this.WM.Log.linkToWikiPage(params.node, params.node) + " ...");
        text = "";
        for (j = 0, ref1 = params.ancestors.length; 0 <= ref1 ? j < ref1 : j > ref1; 0 <= ref1 ? j++ : j--) {
          text += args.params.indentType;
        }
        if (args.params.showIndices) {
          indices = [];
          node = params;
          while (node.parentIndex !== null) {
            indices.push(node.siblingIndex + 1);
            node = params.nodesList[node.parentIndex];
          }
          if (indices.length) {
            text += "<small>" + indices.reverse().join(".") + ".</small> ";
          }
        }
        altName = args.altNames[params.node.toLowerCase()] ? args.altNames[params.node.toLowerCase()] : null;
        text += this.createCatLink(params.node, args.params.replace, altName);
        text += args.params.rightToLeft ? "&lrm; " : " ";
        if (params.children === "loop") {
          text += "'''[LOOP]'''\n";
          this.WM.Log.logWarning("Loop in " + this.WM.Log.linkToWikiPage(params.node, params.node));
          return this.processCategoryEnd(params, args, text);
        } else {
          return this.WM.Cat.getParentsAndInfo(params.node, this.processCategoryAddSuffix, [params, args, text, altName]);
        }
      }
    }, {
      key: 'processCategoryAddSuffix',
      value: function processCategoryAddSuffix(parents, info, args_) {
        var alsoParents, altName, args, currParent, i, j, k, len, len1, par, params, parentTitles, text;
        boundMethodCheck(this, ref);
        params = args_[0];
        args = args_[1];
        text = args_[2];
        altName = args_[3];
        currParent = params.ancestors[params.ancestors.length - 1];
        alsoParents = [];
        text += "<small>(" + (info ? info.pages : 0) + ")";

        if (currParent || args.showRootAlsoIn) {
          for (j = 0, len = parents.length; j < len; j++) {
            par = parents[j];
            if (currParent !== par.title && !(indexOf.call(par, "hidden") >= 0)) {
              alsoParents.push(par);
            }
          }
          if (alsoParents.length) {
            parentTitles = [];
            for (k = 0, len1 = alsoParents.length; k < len1; k++) {
              i = alsoParents[k];
              altName = args.altNames[alsoParents[i].title.toLowerCase()] ? args.altNames[alsoParents[i].title.toLowerCase()] : null;
              parentTitles.push(this.createCatLink(alsoParents[i].title, args.params.replace, altName));
            }
            text += " (" + args.params.alsoIn + " " + parentTitles.join(", ") + ")";
          }
        }
        text += "</small>\n";
        return this.processCategoryEnd(params, args, text);
      }
    }, {
      key: 'processCategoryEnd',
      value: function processCategoryEnd(params, args, text) {
        boundMethodCheck(this, ref);
        args.treeText += text;
        params.callArgs = args;
        return this.WM.Cat.recurseTreeContinue(params);
      }
    }, {
      key: 'createCatLink',
      value: function createCatLink(cat, replace, altName) {
        var catName, regExp;
        boundMethodCheck(this, ref);
        if (altName) {
          catName = altName;
        } else if (replace) {
          regExp = new RegExp(replace[0], replace[1]);
          catName = cat.substr(9).replace(regExp, replace[2]);
        } else {
          catName = cat.substr(9);
        }
        return "[[:" + cat + "|" + catName + "]]";
      }
    }, {
      key: 'writeToC',
      value: function writeToC(params) {
        var args, newtext;
        boundMethodCheck(this, ref);
        args = params.callArgs;
        args.treeText = "\n" + args.treeText;
        newtext = Str.overwriteBetween(args.source, args.treeText, args.startId, args.endId);
        if (newtext !== args.source) {
          return this.WM.MW.callAPIPost({
            action: "edit",
            bot: "1",
            minor: "1",
            title: args.params.page,
            summary: args.summary,
            text: newtext,
            basetimestamp: args.timestamp,
            token: args.edittoken
          }, this.checkWrite, args, null);
        } else {
          this.WM.Log.logInfo(this.WM.Log.linkToWikiPage(args.params.page, args.params.page) + ' is already up to date');
          return this.iteratePages(args.pageid, args.callNext);
        }
      }
    }, {
      key: 'checkWrite',
      value: function checkWrite(res, args) {
        boundMethodCheck(this, ref);
        if (res.edit && res.edit.result === 'Success') {
          this.WM.Log.logInfo(this.WM.Log.linkToWikiPage(args.params.page, args.params.page) + ' correctly updated');
          return this.iteratePages(args.pageid, args.callNext);
        } else {
          return this.WM.Log.logError(this.WM.Log.linkToWikiPage(args.params.page, args.params.page) + ' has not been updated!\n' + res['error']['info'] + " (" + res['error']['code'] + ")");
        }
      }
    }]);

    return UpdateCategoryTree;
  }(Plugin);

  ;

  UpdateCategoryTree.conf_default = {
    enabled: false,
    special_menu: ["Update category trees"],
    edit_summary: "automatic update",
    show_root_also_in: false,
    pages: []
  };

  UpdateCategoryTree.wiki_to_conf_default = {
    ArchWiki: {
      pages: ["ar", "cs", "cs", "da", "el", "en", "es", "he", "hr", "hu", "id", "it", "ko", "lt", "nl", "pl", "pt", "ru", "sk", "sr", "th", "tr", "uk", "zh-hans", "zh-hant"]
    },
    Wikipedia: {}
  };

  return UpdateCategoryTree;
}.call(undefined);

},{"./_Plugin":435,"@kynikos/misc/dist/Str":7}],435:[function(require,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

module.exports.Plugin = function () {
  var Plugin = function () {
    _createClass(Plugin, null, [{
      key: "__configure",
      value: function __configure(wiki_name, user_config) {
        var option, ref, value;

        this.prototype.conf = {};
        if (this.conf_default != null) {
          $.extend(this.prototype.conf, this.conf_default);
        }
        if (this.wiki_to_conf_default != null && wiki_name in this.wiki_to_conf_default) {
          $.extend(this.prototype.conf, this.wiki_to_conf_default[wiki_name]);
        }
        if (this.name in user_config) {
          ref = user_config[this.name];

          for (option in ref) {
            value = ref[option];
            if (!(option in this.prototype.conf)) {
              continue;
            }
            this.prototype.conf[option] = value;
            delete user_config[this.name][option];
          }
        }
        if (!this.prototype.conf.enabled) {
          delete user_config[this.name];

          throw new Error("Plugin disabled");
        }
        if ($.isEmptyObject(user_config[this.name])) {
          return delete user_config[this.name];
        }
      }
    }]);

    function Plugin(WM) {
      _classCallCheck(this, Plugin);

      this.WM = WM;
    }

    return Plugin;
  }();

  ;

  Plugin.prototype.main_bot = null;

  Plugin.prototype.main_diff = null;

  Plugin.prototype.main_editor = null;

  Plugin.prototype.main_newpages = null;

  Plugin.prototype.main_recentchanges = null;

  Plugin.prototype.main_special = null;

  return Plugin;
}.call(undefined);

},{}]},{},[396])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvQGt5bmlrb3MvbWlzYy9kaXN0L0FzeW5jLmpzIiwibm9kZV9tb2R1bGVzL0BreW5pa29zL21pc2MvZGlzdC9DU1MuanMiLCJub2RlX21vZHVsZXMvQGt5bmlrb3MvbWlzYy9kaXN0L0NvbXBhdGliaWxpdHkuanMiLCJub2RlX21vZHVsZXMvQGt5bmlrb3MvbWlzYy9kaXN0L0hUVFAuanMiLCJub2RlX21vZHVsZXMvQGt5bmlrb3MvbWlzYy9kaXN0L09iai5qcyIsIm5vZGVfbW9kdWxlcy9Aa3luaWtvcy9taXNjL2Rpc3QvUmVnRXguanMiLCJub2RlX21vZHVsZXMvQGt5bmlrb3MvbWlzYy9kaXN0L1N0ci5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1wb2x5ZmlsbC9saWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcG9seWZpbGwvbm9kZV9tb2R1bGVzL3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyLXJlc29sdmUvZW1wdHkuanMiLCJub2RlX21vZHVsZXMvYnJvd3Nlci1zcGxpdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jbGFzcy1saXN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvZm4vcmVnZXhwL2VzY2FwZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2EtZnVuY3Rpb24uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hLW51bWJlci12YWx1ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FkZC10by11bnNjb3BhYmxlcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FuLWluc3RhbmNlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYW4tb2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYXJyYXktY29weS13aXRoaW4uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hcnJheS1maWxsLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYXJyYXktZnJvbS1pdGVyYWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FycmF5LWluY2x1ZGVzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYXJyYXktbWV0aG9kcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FycmF5LXJlZHVjZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FycmF5LXNwZWNpZXMtY29uc3RydWN0b3IuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hcnJheS1zcGVjaWVzLWNyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2JpbmQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jbGFzc29mLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY29mLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY29sbGVjdGlvbi1zdHJvbmcuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jb2xsZWN0aW9uLXRvLWpzb24uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jb2xsZWN0aW9uLXdlYWsuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jb2xsZWN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY29yZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NyZWF0ZS1wcm9wZXJ0eS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2N0eC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2RhdGUtdG8taXNvLXN0cmluZy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2RhdGUtdG8tcHJpbWl0aXZlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZGVmaW5lZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2Rlc2NyaXB0b3JzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZG9tLWNyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2VudW0tYnVnLWtleXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19lbnVtLWtleXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19leHBvcnQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19mYWlscy1pcy1yZWdleHAuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19mYWlscy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2ZpeC1yZS13a3MuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19mbGFncy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2ZsYXR0ZW4taW50by1hcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2Zvci1vZi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2dsb2JhbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2hhcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2hpZGUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19odG1sLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faWU4LWRvbS1kZWZpbmUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pbmhlcml0LWlmLXJlcXVpcmVkLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faW52b2tlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faW9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2lzLWFycmF5LWl0ZXIuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pcy1hcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2lzLWludGVnZXIuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pcy1vYmplY3QuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pcy1yZWdleHAuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pdGVyLWNhbGwuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pdGVyLWNyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2l0ZXItZGVmaW5lLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXRlci1kZXRlY3QuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pdGVyLXN0ZXAuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pdGVyYXRvcnMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19saWJyYXJ5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fbWF0aC1leHBtMS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX21hdGgtZnJvdW5kLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fbWF0aC1sb2cxcC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX21hdGgtc2NhbGUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19tYXRoLXNpZ24uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19tZXRhLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fbWV0YWRhdGEuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19taWNyb3Rhc2suanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19uZXctcHJvbWlzZS1jYXBhYmlsaXR5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWFzc2lnbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1jcmVhdGUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZHAuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZHBzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWZvcmNlZC1wYW0uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ29wZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1nb3BuLWV4dC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1nb3BuLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdvcHMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ3BvLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWtleXMtaW50ZXJuYWwuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3Qta2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1waWUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3Qtc2FwLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LXRvLWFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb3duLWtleXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19wYXJzZS1mbG9hdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3BhcnNlLWludC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3BlcmZvcm0uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19wcm9taXNlLXJlc29sdmUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19wcm9wZXJ0eS1kZXNjLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fcmVkZWZpbmUtYWxsLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fcmVkZWZpbmUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19yZXBsYWNlci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NhbWUtdmFsdWUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zZXQtY29sbGVjdGlvbi1mcm9tLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc2V0LWNvbGxlY3Rpb24tb2YuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zZXQtcHJvdG8uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zZXQtc3BlY2llcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NldC10by1zdHJpbmctdGFnLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc2hhcmVkLWtleS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NoYXJlZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NwZWNpZXMtY29uc3RydWN0b3IuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zdHJpY3QtbWV0aG9kLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLWF0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLWNvbnRleHQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zdHJpbmctaHRtbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy1wYWQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zdHJpbmctcmVwZWF0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLXRyaW0uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zdHJpbmctd3MuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190YXNrLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8tYWJzb2x1dGUtaW5kZXguanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLWludGVnZXIuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1pb2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8tbGVuZ3RoLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8tb2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8tcHJpbWl0aXZlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdHlwZWQtYXJyYXkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190eXBlZC1idWZmZXIuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190eXBlZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3VpZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3ZhbGlkYXRlLWNvbGxlY3Rpb24uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL193a3MtZGVmaW5lLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fd2tzLWV4dC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3drcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9jb3JlLnJlZ2V4cC5lc2NhcGUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5jb3B5LXdpdGhpbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmV2ZXJ5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZmlsbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmZpbHRlci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmZpbmQtaW5kZXguanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5maW5kLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZm9yLWVhY2guanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5mcm9tLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuaW5kZXgtb2YuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5pcy1hcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5Lml0ZXJhdG9yLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuam9pbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5Lmxhc3QtaW5kZXgtb2YuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5tYXAuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5vZi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LnJlZHVjZS1yaWdodC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LnJlZHVjZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LnNsaWNlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuc29tZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LnNvcnQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5zcGVjaWVzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuZGF0ZS5ub3cuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5kYXRlLnRvLWlzby1zdHJpbmcuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5kYXRlLnRvLWpzb24uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5kYXRlLnRvLXByaW1pdGl2ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmRhdGUudG8tc3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuZnVuY3Rpb24uYmluZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmZ1bmN0aW9uLmhhcy1pbnN0YW5jZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmZ1bmN0aW9uLm5hbWUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXAuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmFjb3NoLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5hc2luaC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguYXRhbmguanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmNicnQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmNsejMyLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5jb3NoLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5leHBtMS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguZnJvdW5kLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5oeXBvdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguaW11bC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGgubG9nMTAuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmxvZzFwLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5sb2cyLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5zaWduLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5zaW5oLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC50YW5oLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC50cnVuYy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5jb25zdHJ1Y3Rvci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5lcHNpbG9uLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLmlzLWZpbml0ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5pcy1pbnRlZ2VyLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLmlzLW5hbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5pcy1zYWZlLWludGVnZXIuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIubWF4LXNhZmUtaW50ZWdlci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5taW4tc2FmZS1pbnRlZ2VyLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLnBhcnNlLWZsb2F0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLnBhcnNlLWludC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci50by1maXhlZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci50by1wcmVjaXNpb24uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuYXNzaWduLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmNyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydGllcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydHkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuZnJlZXplLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtb3duLXByb3BlcnR5LW5hbWVzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmdldC1wcm90b3R5cGUtb2YuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuaXMtZXh0ZW5zaWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5pcy1mcm96ZW4uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuaXMtc2VhbGVkLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmlzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmtleXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QucHJldmVudC1leHRlbnNpb25zLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LnNlYWwuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3Quc2V0LXByb3RvdHlwZS1vZi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC50by1zdHJpbmcuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5wYXJzZS1mbG9hdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnBhcnNlLWludC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnByb21pc2UuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmFwcGx5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5jb25zdHJ1Y3QuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmRlZmluZS1wcm9wZXJ0eS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZGVsZXRlLXByb3BlcnR5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5lbnVtZXJhdGUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZ2V0LXByb3RvdHlwZS1vZi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZ2V0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5oYXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmlzLWV4dGVuc2libGUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0Lm93bi1rZXlzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5wcmV2ZW50LWV4dGVuc2lvbnMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LnNldC1wcm90b3R5cGUtb2YuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LnNldC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5jb25zdHJ1Y3Rvci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5mbGFncy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5tYXRjaC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5yZXBsYWNlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLnNlYXJjaC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5zcGxpdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC50by1zdHJpbmcuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zZXQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuYW5jaG9yLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmJpZy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5ibGluay5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5ib2xkLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmNvZGUtcG9pbnQtYXQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuZW5kcy13aXRoLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmZpeGVkLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmZvbnRjb2xvci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5mb250c2l6ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5mcm9tLWNvZGUtcG9pbnQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuaW5jbHVkZXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuaXRhbGljcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5saW5rLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnJhdy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5yZXBlYXQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuc21hbGwuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuc3RhcnRzLXdpdGguanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuc3RyaWtlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnN1Yi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5zdXAuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcudHJpbS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN5bWJvbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLmFycmF5LWJ1ZmZlci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLmRhdGEtdmlldy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLmZsb2F0MzItYXJyYXkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC5mbG9hdDY0LWFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQuaW50MTYtYXJyYXkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC5pbnQzMi1hcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLmludDgtYXJyYXkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC51aW50MTYtYXJyYXkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC51aW50MzItYXJyYXkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC51aW50OC1hcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLnVpbnQ4LWNsYW1wZWQtYXJyYXkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi53ZWFrLW1hcC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LndlYWstc2V0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuYXJyYXkuZmxhdC1tYXAuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5hcnJheS5mbGF0dGVuLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuYXJyYXkuaW5jbHVkZXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5hc2FwLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuZXJyb3IuaXMtZXJyb3IuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5nbG9iYWwuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5tYXAuZnJvbS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hcC5vZi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hcC50by1qc29uLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcubWF0aC5jbGFtcC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hdGguZGVnLXBlci1yYWQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5tYXRoLmRlZ3JlZXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5tYXRoLmZzY2FsZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hdGguaWFkZGguanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5tYXRoLmltdWxoLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcubWF0aC5pc3ViaC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hdGgucmFkLXBlci1kZWcuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5tYXRoLnJhZGlhbnMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5tYXRoLnNjYWxlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcubWF0aC5zaWduYml0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcubWF0aC51bXVsaC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm9iamVjdC5kZWZpbmUtZ2V0dGVyLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcub2JqZWN0LmRlZmluZS1zZXR0ZXIuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5vYmplY3QuZW50cmllcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3JzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcub2JqZWN0Lmxvb2t1cC1nZXR0ZXIuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5vYmplY3QubG9va3VwLXNldHRlci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm9iamVjdC52YWx1ZXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5vYnNlcnZhYmxlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcucHJvbWlzZS5maW5hbGx5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcucHJvbWlzZS50cnkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0LmRlZmluZS1tZXRhZGF0YS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QuZGVsZXRlLW1ldGFkYXRhLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcucmVmbGVjdC5nZXQtbWV0YWRhdGEta2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QuZ2V0LW1ldGFkYXRhLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcucmVmbGVjdC5nZXQtb3duLW1ldGFkYXRhLWtleXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0LmdldC1vd24tbWV0YWRhdGEuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0Lmhhcy1tZXRhZGF0YS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QuaGFzLW93bi1tZXRhZGF0YS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QubWV0YWRhdGEuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5zZXQuZnJvbS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnNldC5vZi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnNldC50by1qc29uLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuc3RyaW5nLmF0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuc3RyaW5nLm1hdGNoLWFsbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnN0cmluZy5wYWQtZW5kLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuc3RyaW5nLnBhZC1zdGFydC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnN0cmluZy50cmltLWxlZnQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5zdHJpbmcudHJpbS1yaWdodC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnN5bWJvbC5hc3luYy1pdGVyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnN5bWJvbC5vYnNlcnZhYmxlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuc3lzdGVtLmdsb2JhbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LndlYWstbWFwLmZyb20uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy53ZWFrLW1hcC5vZi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LndlYWstc2V0LmZyb20uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy53ZWFrLXNldC5vZi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvd2ViLmltbWVkaWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvd2ViLnRpbWVycy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL3NoaW0uanMiLCJub2RlX21vZHVsZXMvY3NzLXZlbmRvci9saWIvY2FtZWxpemUuanMiLCJub2RlX21vZHVsZXMvY3NzLXZlbmRvci9saWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY3NzLXZlbmRvci9saWIvcHJlZml4LmpzIiwibm9kZV9tb2R1bGVzL2Nzcy12ZW5kb3IvbGliL3N1cHBvcnRlZC1wcm9wZXJ0eS5qcyIsIm5vZGVfbW9kdWxlcy9jc3MtdmVuZG9yL2xpYi9zdXBwb3J0ZWQtdmFsdWUuanMiLCJub2RlX21vZHVsZXMvaHlwZXJzY3JpcHQtaGVscGVycy9kaXN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2h5cGVyc2NyaXB0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2luZGV4b2YvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXMtaW4tYnJvd3Nlci9kaXN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2pzcy1jYW1lbC1jYXNlL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9qc3MtY29tcG9zZS9saWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvanNzLWRlZmF1bHQtdW5pdC9saWIvZGVmYXVsdFVuaXRzLmpzIiwibm9kZV9tb2R1bGVzL2pzcy1kZWZhdWx0LXVuaXQvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2pzcy1leHBhbmQvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2pzcy1leHBhbmQvbGliL3Byb3BzLmpzIiwibm9kZV9tb2R1bGVzL2pzcy1leHRlbmQvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2pzcy1nbG9iYWwvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2pzcy1uZXN0ZWQvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2pzcy1wcmVzZXQtZGVmYXVsdC9saWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvanNzLXByb3BzLXNvcnQvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2pzcy10ZW1wbGF0ZS9saWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvanNzLXRlbXBsYXRlL2xpYi9wYXJzZS5qcyIsIm5vZGVfbW9kdWxlcy9qc3MtdmVuZG9yLXByZWZpeGVyL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9qc3MvbGliL0pzcy5qcyIsIm5vZGVfbW9kdWxlcy9qc3MvbGliL1BsdWdpbnNSZWdpc3RyeS5qcyIsIm5vZGVfbW9kdWxlcy9qc3MvbGliL1J1bGVMaXN0LmpzIiwibm9kZV9tb2R1bGVzL2pzcy9saWIvU2hlZXRzTWFuYWdlci5qcyIsIm5vZGVfbW9kdWxlcy9qc3MvbGliL1NoZWV0c1JlZ2lzdHJ5LmpzIiwibm9kZV9tb2R1bGVzL2pzcy9saWIvU3R5bGVTaGVldC5qcyIsIm5vZGVfbW9kdWxlcy9qc3MvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2pzcy9saWIvcGx1Z2lucy9mdW5jdGlvbnMuanMiLCJub2RlX21vZHVsZXMvanNzL2xpYi9wbHVnaW5zL29ic2VydmFibGVzLmpzIiwibm9kZV9tb2R1bGVzL2pzcy9saWIvcGx1Z2lucy9ydWxlcy5qcyIsIm5vZGVfbW9kdWxlcy9qc3MvbGliL3JlbmRlcmVycy9Eb21SZW5kZXJlci5qcyIsIm5vZGVfbW9kdWxlcy9qc3MvbGliL3JlbmRlcmVycy9WaXJ0dWFsUmVuZGVyZXIuanMiLCJub2RlX21vZHVsZXMvanNzL2xpYi9ydWxlcy9Db25kaXRpb25hbFJ1bGUuanMiLCJub2RlX21vZHVsZXMvanNzL2xpYi9ydWxlcy9Gb250RmFjZVJ1bGUuanMiLCJub2RlX21vZHVsZXMvanNzL2xpYi9ydWxlcy9LZXlmcmFtZXNSdWxlLmpzIiwibm9kZV9tb2R1bGVzL2pzcy9saWIvcnVsZXMvU2ltcGxlUnVsZS5qcyIsIm5vZGVfbW9kdWxlcy9qc3MvbGliL3J1bGVzL1N0eWxlUnVsZS5qcyIsIm5vZGVfbW9kdWxlcy9qc3MvbGliL3J1bGVzL1ZpZXdwb3J0UnVsZS5qcyIsIm5vZGVfbW9kdWxlcy9qc3MvbGliL3NoZWV0cy5qcyIsIm5vZGVfbW9kdWxlcy9qc3MvbGliL3V0aWxzL2Nsb25lU3R5bGUuanMiLCJub2RlX21vZHVsZXMvanNzL2xpYi91dGlscy9jcmVhdGVHZW5lcmF0ZUNsYXNzTmFtZS5qcyIsIm5vZGVfbW9kdWxlcy9qc3MvbGliL3V0aWxzL2NyZWF0ZVJ1bGUuanMiLCJub2RlX21vZHVsZXMvanNzL2xpYi91dGlscy9lc2NhcGUuanMiLCJub2RlX21vZHVsZXMvanNzL2xpYi91dGlscy9nZXREeW5hbWljU3R5bGVzLmpzIiwibm9kZV9tb2R1bGVzL2pzcy9saWIvdXRpbHMvaXNPYnNlcnZhYmxlLmpzIiwibm9kZV9tb2R1bGVzL2pzcy9saWIvdXRpbHMva2ViYWJDYXNlLmpzIiwibm9kZV9tb2R1bGVzL2pzcy9saWIvdXRpbHMvbGlua1J1bGUuanMiLCJub2RlX21vZHVsZXMvanNzL2xpYi91dGlscy9tb2R1bGVJZC5qcyIsIm5vZGVfbW9kdWxlcy9qc3MvbGliL3V0aWxzL3RvQ3NzLmpzIiwibm9kZV9tb2R1bGVzL2pzcy9saWIvdXRpbHMvdG9Dc3NWYWx1ZS5qcyIsIm5vZGVfbW9kdWxlcy9tb21lbnQvbW9tZW50LmpzIiwibm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9zeW1ib2wtb2JzZXJ2YWJsZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zeW1ib2wtb2JzZXJ2YWJsZS9saWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc3ltYm9sLW9ic2VydmFibGUvbGliL3BvbnlmaWxsLmpzIiwibm9kZV9tb2R1bGVzL3dhcm5pbmcvYnJvd3Nlci5qcyIsInBhY2thZ2UuanNvbiIsInNyYy9fbG9jYWwuY29mZmVlIiwic3JjL21vZHVsZXMvQXJjaFdpa2kuY29mZmVlIiwic3JjL21vZHVsZXMvQm90LmNvZmZlZSIsInNyYy9tb2R1bGVzL0NhdC5jb2ZmZWUiLCJzcmMvbW9kdWxlcy9EaWZmLmNvZmZlZSIsInNyYy9tb2R1bGVzL0VkaXRvci5jb2ZmZWUiLCJzcmMvbW9kdWxlcy9GaWx0ZXJzLmNvZmZlZSIsInNyYy9tb2R1bGVzL0ludGVybGFuZ3VhZ2UuY29mZmVlIiwic3JjL21vZHVsZXMvTG9nLmNvZmZlZSIsInNyYy9tb2R1bGVzL01XLmNvZmZlZSIsInNyYy9tb2R1bGVzL01lbnUuY29mZmVlIiwic3JjL21vZHVsZXMvTW9kcy5jb2ZmZWUiLCJzcmMvbW9kdWxlcy9QYXJzZXIuY29mZmVlIiwic3JjL21vZHVsZXMvUm91dGVyLmNvZmZlZSIsInNyYy9tb2R1bGVzL1RhYmxlcy5jb2ZmZWUiLCJzcmMvbW9kdWxlcy9VSS5jb2ZmZWUiLCJzcmMvbW9kdWxlcy9VcGdyYWRlLmNvZmZlZSIsInNyYy9tb2R1bGVzL1doYXRMaW5rc0hlcmUuY29mZmVlIiwic3JjL21vZHVsZXMvX0luaXQuY29mZmVlIiwic3JjL21vZHVsZXMvbGlicy5jb2ZmZWUiLCJzcmMvcGx1Z2lucy9BcmNoV2lraUZpeEhlYWRlci5jb2ZmZWUiLCJzcmMvcGx1Z2lucy9BcmNoV2lraUZpeEhlYWRpbmdzLmNvZmZlZSIsInNyYy9wbHVnaW5zL0FyY2hXaWtpRml4TGlua3MuY29mZmVlIiwic3JjL3BsdWdpbnMvQXJjaFdpa2lOUEZpbHRlci5jb2ZmZWUiLCJzcmMvcGx1Z2lucy9BcmNoV2lraU5ld1RlbXBsYXRlcy5jb2ZmZWUiLCJzcmMvcGx1Z2lucy9BcmNoV2lraVJDRmlsdGVyLmNvZmZlZSIsInNyYy9wbHVnaW5zL0FyY2hXaWtpU2F2ZVRhbGsuY29mZmVlIiwic3JjL3BsdWdpbnMvQXJjaFdpa2lTb3J0Q29udGFjdHMuY29mZmVlIiwic3JjL3BsdWdpbnMvQXJjaFdpa2lXYW50ZWRDYXRlZ29yaWVzLmNvZmZlZSIsInNyYy9wbHVnaW5zL0RlbGV0ZVBhZ2VzLmNvZmZlZSIsInNyYy9wbHVnaW5zL0V4cGFuZENvbnRyYWN0aW9ucy5jb2ZmZWUiLCJzcmMvcGx1Z2lucy9GaXhCYWNrbGlua0ZyYWdtZW50cy5jb2ZmZWUiLCJzcmMvcGx1Z2lucy9GaXhEb3VibGVSZWRpcmVjdHMuY29mZmVlIiwic3JjL3BsdWdpbnMvRml4RnJhZ21lbnRzLmNvZmZlZSIsInNyYy9wbHVnaW5zL0ZpeExpbmtGcmFnbWVudHMuY29mZmVlIiwic3JjL3BsdWdpbnMvTXVsdGlwbGVMaW5lQnJlYWtzLmNvZmZlZSIsInNyYy9wbHVnaW5zL1NpbXBsZVJlcGxhY2UuY29mZmVlIiwic3JjL3BsdWdpbnMvU3luY2hyb25pemVJbnRlcmxhbmd1YWdlTGlua3MuY29mZmVlIiwic3JjL3BsdWdpbnMvVXBkYXRlQ2F0ZWdvcnlUcmVlLmNvZmZlZSIsInNyYy9wbHVnaW5zL19QbHVnaW4uY29mZmVlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMxTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNodUJBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25HQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckZBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7O0FDREE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcFJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTs7QUNEQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3REQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDOWFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN4REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdjdJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hMQTtBQUNBOzs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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OztBQTBCZCxBQUFhLG9CQUFBOzs7QUFBQyxBQUFDLFdBQUEsS0FBRjtBQWpDakI7Ozs7Ozs7bUJBbUNJLFdBQVU7O21CQUNWLFlBQVc7O21CQUNYLGNBQWE7O21CQUNiLGdCQUFlOzttQkFDZixxQkFBb0I7O21CQUNwQixlQUFjIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIlwidXNlIHN0cmljdFwiO1xuXG4vLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDIuMS4xXG4vLyBKYXZhU2NyaXB0IGF1eGlsaWFyeSBsaWJyYXJ5XG4vLyBDb3B5cmlnaHQgKEMpIDIwMTIgRGFyaW8gR2lvdmFubmV0dGkgPGRldkBkYXJpb2dpb3Zhbm5ldHRpLm5ldD5cblxuLy8gVGhpcyBmaWxlIGlzIHBhcnQgb2YgSmF2YVNjcmlwdCBhdXhpbGlhcnkgbGlicmFyeS5cblxuLy8gSmF2YVNjcmlwdCBhdXhpbGlhcnkgbGlicmFyeSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdFxuLy8gYW5kL29yIG1vZGlmeSBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhcyBwdWJsaXNoZWQgYnkgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gM1xuLy8gb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbi8vIEphdmFTY3JpcHQgYXV4aWxpYXJ5IGxpYnJhcnkgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlXG4vLyB1c2VmdWwsIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCBKYXZhU2NyaXB0IGF1eGlsaWFyeSBsaWJyYXJ5LlxuLy8gSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxubW9kdWxlLmV4cG9ydHMuZXhlY3V0ZUFzeW5jID0gZnVuY3Rpb24gKGZ1bmN0aW9ucywgaWQpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB2YXIgY2FsbENvbnRpbnVlLCBmaWQ7XG4gIGlkKys7XG4gIGlmIChmdW5jdGlvbnNbaWRdKSB7XG4gICAgZmlkID0gZnVuY3Rpb25zW2lkXTtcbiAgICBjYWxsQ29udGludWUgPSBmdW5jdGlvbiBjYWxsQ29udGludWUoKSB7XG4gICAgICByZXR1cm4gX3RoaXMuZXhlY3V0ZUFzeW5jKGZ1bmN0aW9ucywgaWQpO1xuICAgIH07XG4gICAgcmV0dXJuIGZpZFswXShmaWRbMV0sIGNhbGxDb250aW51ZSk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzLnJlY3Vyc2VUcmVlQXN5bmMgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gIHZhciBwYXJlbnQ7XG4gIC8vIHBhcmFtcyA9IHtcbiAgLy8gICBub2RlOiAsXG4gIC8vICAgcGFyZW50SW5kZXg6ICxcbiAgLy8gICBzaWJsaW5nSW5kZXg6ICxcbiAgLy8gICBhbmNlc3RvcnM6ICxcbiAgLy8gICBjaGlsZHJlbjogLFxuICAvLyAgIGNhbGxDaGlsZHJlbjogLFxuICAvLyAgIGNhbGxOb2RlOiAsXG4gIC8vICAgY2FsbEVuZDogLFxuICAvLyAgIGNhbGxBcmdzOiAsXG4gIC8vICAgc3RhZ2U6ICxcbiAgLy8gICBub2Rlc0xpc3Q6XG4gIC8vIH1cblxuICAvLyBub2Rlc0xpc3Q6IFtcbiAgLy8gICB7XG4gIC8vICAgICBub2RlOiAsXG4gIC8vICAgICBwYXJlbnRJbmRleDogLFxuICAvLyAgICAgc2libGluZ0luZGV4OiAsXG4gIC8vICAgICBhbmNlc3RvcnM6IFsuLi5dLFxuICAvLyAgICAgY2hpbGRyZW46IFsuLi5dXG4gIC8vICAgfSxcbiAgLy8gICB7Li4ufVxuICAvLyBdXG5cbiAgLy8gRXhhbXBsZTpcblxuICAvLyByZWN1cnNlVHJlZUFzeW5jKHtcbiAgLy8gICBub2RlOiAsXG4gIC8vICAgY2FsbENoaWxkcmVuOiAsXG4gIC8vICAgY2FsbE5vZGU6ICxcbiAgLy8gICBjYWxsRW5kOiAsXG4gIC8vICAgY2FsbEFyZ3M6XG4gIC8vIH0pO1xuXG4gIC8vIGNhbGxDaGlsZHJlbihwYXJhbXMpIHtcbiAgLy8gICBwYXJhbXMuY2hpbGRyZW4gPSA7XG4gIC8vICAgcmVjdXJzZVRyZWVBc3luYyhwYXJhbXMpO1xuICAvLyB9XG5cbiAgLy8gY2FsbE5vZGUocGFyYW1zKSB7XG4gIC8vICAgcmVjdXJzZVRyZWVBc3luYyhwYXJhbXMpO1xuICAvLyB9XG5cbiAgLy8gY2FsbEVuZChwYXJhbXMpIHt9XG4gIHN3aXRjaCAocGFyYW1zLnN0YWdlKSB7XG4gICAgY2FzZSB2b2lkIDA6XG4gICAgICBwYXJhbXMucGFyZW50SW5kZXggPSBudWxsO1xuICAgICAgcGFyYW1zLnNpYmxpbmdJbmRleCA9IDA7XG4gICAgICBwYXJhbXMuYW5jZXN0b3JzID0gW107XG4gICAgICBwYXJhbXMuY2hpbGRyZW4gPSBbXTtcbiAgICAgIHBhcmFtcy5ub2Rlc0xpc3QgPSBbXTtcbiAgICAgIHBhcmFtcy5zdGFnZSA9IDE7XG4gICAgICByZXR1cm4gdGhpcy5yZWN1cnNlVHJlZUFzeW5jKHBhcmFtcyk7XG4gICAgY2FzZSAxOlxuICAgICAgcGFyYW1zLnN0YWdlID0gMjtcbiAgICAgIC8vIFByZXZlbnQgaW5maW5pdGUgbG9vcHNcbiAgICAgIGlmIChwYXJhbXMuYW5jZXN0b3JzLmluZGV4T2YocGFyYW1zLm5vZGUpID09PSAtMSkge1xuICAgICAgICByZXR1cm4gcGFyYW1zLmNhbGxDaGlsZHJlbihwYXJhbXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyYW1zLmNoaWxkcmVuID0gXCJsb29wXCI7XG4gICAgICAgIHJldHVybiB0aGlzLnJlY3Vyc2VUcmVlQXN5bmMocGFyYW1zKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMjpcbiAgICAgIHBhcmFtcy5ub2Rlc0xpc3QucHVzaCh7XG4gICAgICAgIG5vZGU6IHBhcmFtcy5ub2RlLFxuICAgICAgICBwYXJlbnRJbmRleDogcGFyYW1zLnBhcmVudEluZGV4LFxuICAgICAgICBzaWJsaW5nSW5kZXg6IHBhcmFtcy5zaWJsaW5nSW5kZXgsXG4gICAgICAgIGFuY2VzdG9yczogcGFyYW1zLmFuY2VzdG9ycy5zbGljZSgwKSxcbiAgICAgICAgY2hpbGRyZW46IHBhcmFtcy5jaGlsZHJlbi5zbGljZSgwKVxuICAgICAgfSk7XG4gICAgICBwYXJhbXMuc3RhZ2UgPSAzO1xuICAgICAgcmV0dXJuIHBhcmFtcy5jYWxsTm9kZShwYXJhbXMpO1xuICAgIGNhc2UgMzpcbiAgICAgIGlmIChwYXJhbXMuY2hpbGRyZW4ubGVuZ3RoICYmIHBhcmFtcy5jaGlsZHJlbiAhPT0gXCJsb29wXCIpIHtcbiAgICAgICAgLy8gR28gdG8gdGhlIGZpcnN0IGNoaWxkXG4gICAgICAgIHBhcmFtcy5hbmNlc3RvcnMucHVzaChwYXJhbXMubm9kZSk7XG4gICAgICAgIHBhcmFtcy5ub2RlID0gcGFyYW1zLmNoaWxkcmVuWzBdO1xuICAgICAgICBwYXJhbXMucGFyZW50SW5kZXggPSBwYXJhbXMubm9kZXNMaXN0Lmxlbmd0aCAtIDE7XG4gICAgICAgIHBhcmFtcy5zaWJsaW5nSW5kZXggPSAwO1xuICAgICAgICBwYXJhbXMuY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgcGFyYW1zLnN0YWdlID0gMTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVjdXJzZVRyZWVBc3luYyhwYXJhbXMpO1xuICAgICAgfSBlbHNlIGlmIChwYXJhbXMucGFyZW50SW5kZXggIT09IG51bGwpIHtcbiAgICAgICAgLy8gR28gdG8gdGhlIG5leHQgc2libGluZ1xuICAgICAgICBwYXJlbnQgPSBwYXJhbXMubm9kZXNMaXN0W3BhcmFtcy5wYXJlbnRJbmRleF07XG4gICAgICAgIHBhcmFtcy5zaWJsaW5nSW5kZXgrKztcbiAgICAgICAgcGFyYW1zLm5vZGUgPSBwYXJlbnQuY2hpbGRyZW5bcGFyYW1zLnNpYmxpbmdJbmRleF07XG4gICAgICAgIHBhcmFtcy5jaGlsZHJlbiA9IFtdO1xuICAgICAgICBpZiAocGFyYW1zLm5vZGUpIHtcbiAgICAgICAgICBwYXJhbXMuc3RhZ2UgPSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFRoZXJlIGFyZSBubyBtb3JlIHNpYmxpbmdzXG4gICAgICAgICAgcGFyYW1zLm5vZGUgPSBwYXJlbnQubm9kZTtcbiAgICAgICAgICBwYXJhbXMucGFyZW50SW5kZXggPSBwYXJlbnQucGFyZW50SW5kZXg7XG4gICAgICAgICAgcGFyYW1zLnNpYmxpbmdJbmRleCA9IHBhcmVudC5zaWJsaW5nSW5kZXg7XG4gICAgICAgICAgcGFyYW1zLmFuY2VzdG9ycyA9IHBhcmVudC5hbmNlc3RvcnMuc2xpY2UoMCk7XG4gICAgICAgICAgcGFyYW1zLnN0YWdlID0gMztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5yZWN1cnNlVHJlZUFzeW5jKHBhcmFtcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBFbmQgb2YgcmVjdXJzaW9uXG4gICAgICAgIHJldHVybiBwYXJhbXMuY2FsbEVuZChwYXJhbXMpO1xuICAgICAgfVxuICB9XG59OyIsIid1c2Ugc3RyaWN0JztcblxuLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAyLjEuMVxuLy8gSmF2YVNjcmlwdCBhdXhpbGlhcnkgbGlicmFyeVxuLy8gQ29weXJpZ2h0IChDKSAyMDEyIERhcmlvIEdpb3Zhbm5ldHRpIDxkZXZAZGFyaW9naW92YW5uZXR0aS5uZXQ+XG5cbi8vIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIEphdmFTY3JpcHQgYXV4aWxpYXJ5IGxpYnJhcnkuXG5cbi8vIEphdmFTY3JpcHQgYXV4aWxpYXJ5IGxpYnJhcnkgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXRcbi8vIGFuZC9vciBtb2RpZnkgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYXMgcHVibGlzaGVkIGJ5IHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDNcbi8vIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4vLyBKYXZhU2NyaXB0IGF1eGlsaWFyeSBsaWJyYXJ5IGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZVxuLy8gdXNlZnVsLCBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggSmF2YVNjcmlwdCBhdXhpbGlhcnkgbGlicmFyeS5cbi8vIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbm1vZHVsZS5leHBvcnRzLmFkZFN0eWxlRWxlbWVudCA9IGZ1bmN0aW9uIChjc3MpIHtcbiAgdmFyIHN0eWxlO1xuICBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gIHN0eWxlLnNldEF0dHJpYnV0ZSgndHlwZScsICd0ZXh0L2NzcycpO1xuICBzdHlsZS5pbm5lckhUTUwgPSBjc3M7XG4gIHJldHVybiBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHN0eWxlKTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDIuMS4xXG4vLyBKYXZhU2NyaXB0IGF1eGlsaWFyeSBsaWJyYXJ5XG4vLyBDb3B5cmlnaHQgKEMpIDIwMTIgRGFyaW8gR2lvdmFubmV0dGkgPGRldkBkYXJpb2dpb3Zhbm5ldHRpLm5ldD5cblxuLy8gVGhpcyBmaWxlIGlzIHBhcnQgb2YgSmF2YVNjcmlwdCBhdXhpbGlhcnkgbGlicmFyeS5cblxuLy8gSmF2YVNjcmlwdCBhdXhpbGlhcnkgbGlicmFyeSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdFxuLy8gYW5kL29yIG1vZGlmeSBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhcyBwdWJsaXNoZWQgYnkgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gM1xuLy8gb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbi8vIEphdmFTY3JpcHQgYXV4aWxpYXJ5IGxpYnJhcnkgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlXG4vLyB1c2VmdWwsIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCBKYXZhU2NyaXB0IGF1eGlsaWFyeSBsaWJyYXJ5LlxuLy8gSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxubW9kdWxlLmV4cG9ydHMubm9ybWFsaXplQ2FycmlhZ2VSZXR1cm5zID0gZnVuY3Rpb24gKHNvdXJjZSkge1xuICAvLyBPcGVyYSBhbmQgSUUgdXNlIFxcclxcbiBpbnN0ZWFkIG9mIFxcblxuICByZXR1cm4gc291cmNlLnJlcGxhY2UoL1xcclxcbi9nLCAnXFxuJyk7XG59OyIsIid1c2Ugc3RyaWN0JztcblxuLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAyLjEuMVxuLy8gSmF2YVNjcmlwdCBhdXhpbGlhcnkgbGlicmFyeVxuLy8gQ29weXJpZ2h0IChDKSAyMDEyIERhcmlvIEdpb3Zhbm5ldHRpIDxkZXZAZGFyaW9naW92YW5uZXR0aS5uZXQ+XG5cbi8vIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIEphdmFTY3JpcHQgYXV4aWxpYXJ5IGxpYnJhcnkuXG5cbi8vIEphdmFTY3JpcHQgYXV4aWxpYXJ5IGxpYnJhcnkgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXRcbi8vIGFuZC9vciBtb2RpZnkgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYXMgcHVibGlzaGVkIGJ5IHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDNcbi8vIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4vLyBKYXZhU2NyaXB0IGF1eGlsaWFyeSBsaWJyYXJ5IGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZVxuLy8gdXNlZnVsLCBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggSmF2YVNjcmlwdCBhdXhpbGlhcnkgbGlicmFyeS5cbi8vIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbm1vZHVsZS5leHBvcnRzLmdldFVybExvY2F0aW9uID0gZnVuY3Rpb24gKHVybCkge1xuICB2YXIgbGluaztcbiAgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgbGluay5ocmVmID0gdXJsO1xuICByZXR1cm4gbGluaztcbn07XG5cbm1vZHVsZS5leHBvcnRzLmdldFVSSVBhcmFtZXRlcnMgPSBmdW5jdGlvbiAodXJpKSB7XG4gIHZhciBpLCBsZW4sIHBhciwgcWFycmF5LCBxZGljdCwgcXN0cmluZywgcztcbiAgaWYgKHVyaSkge1xuICAgIHFzdHJpbmcgPSBtb2R1bGUuZXhwb3J0cy5nZXRVcmxMb2NhdGlvbih1cmkpLnNlYXJjaDtcbiAgfSBlbHNlIHtcbiAgICBxc3RyaW5nID0gbG9jYXRpb24uc2VhcmNoO1xuICB9XG4gIHFhcnJheSA9IHFzdHJpbmcuc3Vic3RyKDEpLnNwbGl0KCcmJyk7XG4gIHFkaWN0ID0gbmV3IE9iamVjdCgpO1xuICBzID0gbmV3IEFycmF5KCk7XG4gIGZvciAoaSA9IDAsIGxlbiA9IHFhcnJheS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHBhciA9IHFhcnJheVtpXTtcbiAgICBzID0gcGFyLnNwbGl0KCc9Jyk7XG4gICAgcWRpY3Rbc1swXV0gPSBzWzFdO1xuICB9XG4gIHJldHVybiBxZGljdDtcbn07XG5cbm1vZHVsZS5leHBvcnRzLmdldFVSSVBhcmFtZXRlciA9IGZ1bmN0aW9uICh1cmksIG5hbWUpIHtcbiAgcmV0dXJuIG1vZHVsZS5leHBvcnRzLmdldFVSSVBhcmFtZXRlcnModXJpKVtuYW1lXTtcbn07XG5cbm1vZHVsZS5leHBvcnRzLnNlbmRHZXRBc3luY1JlcXVlc3QgPSBmdW5jdGlvbiAodXJsLCBjYWxsKSB7XG4gIHZhciByZXE7XG4gIHJlcSA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICByZXEub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChyZXEucmVhZHlTdGF0ZSA9PT0gNCAmJiByZXEuc3RhdHVzID09PSAyMDApIHtcbiAgICAgIHJldHVybiBjYWxsKHJlcSk7XG4gICAgfVxuICB9O1xuICByZXEub3BlbihcIkdFVFwiLCB1cmwsIHRydWUpO1xuICByZXR1cm4gcmVxLnNlbmQoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzLnNlbmRHZXRTeW5jUmVxdWVzdCA9IGZ1bmN0aW9uICh1cmwpIHtcbiAgdmFyIHJlcTtcbiAgcmVxID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gIHJlcS5vcGVuKFwiR0VUXCIsIHVybCwgZmFsc2UpO1xuICByZXEuc2VuZCgpO1xuICByZXR1cm4gcmVxO1xufTtcblxubW9kdWxlLmV4cG9ydHMuc2VuZFBvc3RBc3luY1JlcXVlc3QgPSBmdW5jdGlvbiAodXJsLCBjYWxsLCBxdWVyeSwgaGVhZGVyLCBoZWFkZXJ2YWx1ZSkge1xuICB2YXIgcmVxO1xuICByZXEgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgcmVxLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAocmVxLnJlYWR5U3RhdGUgPT09IDQgJiYgcmVxLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICByZXR1cm4gY2FsbChyZXEpO1xuICAgIH1cbiAgfTtcbiAgcmVxLm9wZW4oXCJQT1NUXCIsIHVybCwgdHJ1ZSk7XG4gIGlmIChoZWFkZXIgJiYgaGVhZGVydmFsdWUpIHtcbiAgICByZXEuc2V0UmVxdWVzdEhlYWRlcihoZWFkZXIsIGhlYWRlcnZhbHVlKTtcbiAgfVxuICByZXR1cm4gcmVxLnNlbmQocXVlcnkpO1xufTtcblxubW9kdWxlLmV4cG9ydHMuc2VuZFBvc3RTeW5jUmVxdWVzdCA9IGZ1bmN0aW9uICh1cmwsIHF1ZXJ5LCBoZWFkZXIsIGhlYWRlcnZhbHVlKSB7XG4gIHZhciByZXE7XG4gIHJlcSA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICByZXEub3BlbihcIlBPU1RcIiwgdXJsLCBmYWxzZSk7XG4gIGlmIChoZWFkZXIgJiYgaGVhZGVydmFsdWUpIHtcbiAgICByZXEuc2V0UmVxdWVzdEhlYWRlcihoZWFkZXIsIGhlYWRlcnZhbHVlKTtcbiAgfVxuICByZXEuc2VuZChxdWVyeSk7XG4gIHJldHVybiByZXE7XG59OyIsIlwidXNlIHN0cmljdFwiO1xuXG4vLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDIuMS4xXG4vLyBKYXZhU2NyaXB0IGF1eGlsaWFyeSBsaWJyYXJ5XG4vLyBDb3B5cmlnaHQgKEMpIDIwMTIgRGFyaW8gR2lvdmFubmV0dGkgPGRldkBkYXJpb2dpb3Zhbm5ldHRpLm5ldD5cblxuLy8gVGhpcyBmaWxlIGlzIHBhcnQgb2YgSmF2YVNjcmlwdCBhdXhpbGlhcnkgbGlicmFyeS5cblxuLy8gSmF2YVNjcmlwdCBhdXhpbGlhcnkgbGlicmFyeSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdFxuLy8gYW5kL29yIG1vZGlmeSBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhcyBwdWJsaXNoZWQgYnkgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gM1xuLy8gb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbi8vIEphdmFTY3JpcHQgYXV4aWxpYXJ5IGxpYnJhcnkgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlXG4vLyB1c2VmdWwsIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCBKYXZhU2NyaXB0IGF1eGlsaWFyeSBsaWJyYXJ5LlxuLy8gSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxubW9kdWxlLmV4cG9ydHMuZ2V0S2V5cyA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgdmFyIGksIGtleXM7XG4gIGtleXMgPSBbXTtcbiAgZm9yIChpIGluIG9iamVjdCkge1xuICAgIGtleXMucHVzaChpKTtcbiAgfVxuICByZXR1cm4ga2V5cztcbn07XG5cbm1vZHVsZS5leHBvcnRzLmdldFZhbHVlcyA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgdmFyIGksIHZhbHVlcztcbiAgdmFsdWVzID0gW107XG4gIGZvciAoaSBpbiBvYmplY3QpIHtcbiAgICB2YWx1ZXMucHVzaChvYmplY3RbaV0pO1xuICB9XG4gIHJldHVybiB2YWx1ZXM7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5nZXRGaXJzdEl0ZW0gPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gIHZhciBpO1xuICBmb3IgKGkgaW4gb2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdFtpXTtcbiAgfVxufTsiLCJcInVzZSBzdHJpY3RcIjtcblxuLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAyLjEuMVxuLy8gSmF2YVNjcmlwdCBhdXhpbGlhcnkgbGlicmFyeVxuLy8gQ29weXJpZ2h0IChDKSAyMDEyIERhcmlvIEdpb3Zhbm5ldHRpIDxkZXZAZGFyaW9naW92YW5uZXR0aS5uZXQ+XG5cbi8vIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIEphdmFTY3JpcHQgYXV4aWxpYXJ5IGxpYnJhcnkuXG5cbi8vIEphdmFTY3JpcHQgYXV4aWxpYXJ5IGxpYnJhcnkgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXRcbi8vIGFuZC9vciBtb2RpZnkgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYXMgcHVibGlzaGVkIGJ5IHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDNcbi8vIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4vLyBKYXZhU2NyaXB0IGF1eGlsaWFyeSBsaWJyYXJ5IGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZVxuLy8gdXNlZnVsLCBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggSmF2YVNjcmlwdCBhdXhpbGlhcnkgbGlicmFyeS5cbi8vIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbm1vZHVsZS5leHBvcnRzLmVzY2FwZVBhdHRlcm4gPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gIC8vIEVzY2FwaW5nIGFueSBvdGhlciBjaGFyYWN0ZXJzIGlzIG5vdCBuZWNlc3NhcnksIHJlZmVyZW5jZXM6XG4gIC8vIC0gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9HdWlkZS9SZWd1bGFyX0V4cHJlc3Npb25zXG4gIC8vIC0gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8zNTYxNDkzL2lzLXRoZXJlLWEtcmVnZXhwLWVzY2FwZS1mdW5jdGlvbi1pbi1qYXZhc2NyaXB0XG4gIC8vIC0gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yNTkzNjM3L2hvdy10by1lc2NhcGUtcmVndWxhci1leHByZXNzaW9uLWluLWphdmFzY3JpcHRcbiAgLy8gLSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzQ5NDAzNS9ob3ctZG8teW91LXBhc3MtYS12YXJpYWJsZS10by1hLXJlZ3VsYXItZXhwcmVzc2lvbi1qYXZhc2NyaXB0XG4gIC8vIC0gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8zNDQ2MTcwL2VzY2FwZS1zdHJpbmctZm9yLXVzZS1pbi1qYXZhc2NyaXB0LXJlZ2V4XG4gIC8vIC0gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8zOTkwNzgvd2hhdC1zcGVjaWFsLWNoYXJhY3RlcnMtbXVzdC1iZS1lc2NhcGVkLWluLXJlZ3VsYXItZXhwcmVzc2lvbnNcblxuICAvLyBOb3RlIGZvciBXaWtpIE1vbmtleTogZG8gKm5vdCogZXNjYXBlICdcXHMnIGhlcmUgc28gdGhhdCBpdCB3aWxsIGJlXG4gIC8vIHNhZmUgdG8gdXNlIHByZXBhcmVSZWdleHBXaGl0ZXNwYWNlIGluIFdNLlBhcnNlclxuICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoL1stW1xcXXt9KCleJCorPy58XFxcXF0vZywgXCJcXFxcJCZcIik7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5tYXRjaEFsbCA9IGZ1bmN0aW9uIChzb3VyY2UsIHJlZ0V4cCkge1xuICB2YXIgTCwgbWF0Y2gsIHJlc3VsdDtcbiAgcmVzdWx0ID0gW107XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgbWF0Y2ggPSByZWdFeHAuZXhlYyhzb3VyY2UpO1xuICAgIGlmIChtYXRjaCkge1xuICAgICAgTCA9IG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgXCJtYXRjaFwiOiBtYXRjaCxcbiAgICAgICAgXCJpbmRleFwiOiByZWdFeHAubGFzdEluZGV4IC0gTCxcbiAgICAgICAgXCJsZW5ndGhcIjogTFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxubW9kdWxlLmV4cG9ydHMubWF0Y2hBbGxDb25kaXRpb25hbCA9IGZ1bmN0aW9uIChzb3VyY2UsIHJlZ0V4cCwgdGVzdCkge1xuICB2YXIgTCwgbWF0Y2gsIHJlc3VsdDtcbiAgcmVzdWx0ID0gW107XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgbWF0Y2ggPSByZWdFeHAuZXhlYyhzb3VyY2UpO1xuICAgIGlmIChtYXRjaCAmJiB0ZXN0KG1hdGNoKSkge1xuICAgICAgTCA9IG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgXCJtYXRjaFwiOiBtYXRjaCxcbiAgICAgICAgXCJpbmRleFwiOiByZWdFeHAubGFzdEluZGV4IC0gTCxcbiAgICAgICAgXCJsZW5ndGhcIjogTFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTsiLCJcInVzZSBzdHJpY3RcIjtcblxuLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAyLjEuMVxuLy8gSmF2YVNjcmlwdCBhdXhpbGlhcnkgbGlicmFyeVxuLy8gQ29weXJpZ2h0IChDKSAyMDEyIERhcmlvIEdpb3Zhbm5ldHRpIDxkZXZAZGFyaW9naW92YW5uZXR0aS5uZXQ+XG5cbi8vIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIEphdmFTY3JpcHQgYXV4aWxpYXJ5IGxpYnJhcnkuXG5cbi8vIEphdmFTY3JpcHQgYXV4aWxpYXJ5IGxpYnJhcnkgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXRcbi8vIGFuZC9vciBtb2RpZnkgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYXMgcHVibGlzaGVkIGJ5IHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDNcbi8vIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4vLyBKYXZhU2NyaXB0IGF1eGlsaWFyeSBsaWJyYXJ5IGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZVxuLy8gdXNlZnVsLCBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggSmF2YVNjcmlwdCBhdXhpbGlhcnkgbGlicmFyeS5cbi8vIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbm1vZHVsZS5leHBvcnRzLmluc2VydCA9IGZ1bmN0aW9uIChzdHJpbmcsIG5ld1N0cmluZywgaWQpIHtcbiAgaWYgKGlkID09IG51bGwpIHtcbiAgICBpZCA9IDA7XG4gIH1cbiAgcmV0dXJuIHN0cmluZy5zdWJzdHJpbmcoMCwgaWQpICsgbmV3U3RyaW5nICsgc3RyaW5nLnN1YnN0cihpZCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5vdmVyd3JpdGVGb3IgPSBmdW5jdGlvbiAoc3RyaW5nLCBuZXdTdHJpbmcsIGlkLCBsZW5ndGgpIHtcbiAgaWYgKGlkID09IG51bGwpIHtcbiAgICBpZCA9IDA7XG4gIH1cbiAgaWYgKCFsZW5ndGggfHwgbGVuZ3RoIDwgMCkge1xuICAgIGxlbmd0aCA9IDA7XG4gIH1cbiAgcmV0dXJuIHN0cmluZy5zdWJzdHJpbmcoMCwgaWQpICsgbmV3U3RyaW5nICsgc3RyaW5nLnN1YnN0cihpZCArIGxlbmd0aCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5vdmVyd3JpdGVBdCA9IGZ1bmN0aW9uIChzdHJpbmcsIG5ld1N0cmluZywgaWQpIHtcbiAgcmV0dXJuIG1vZHVsZS5leHBvcnRzLm92ZXJ3cml0ZUZvcihzdHJpbmcsIG5ld1N0cmluZywgaWQsIG5ld1N0cmluZy5sZW5ndGgpO1xufTtcblxubW9kdWxlLmV4cG9ydHMub3ZlcndyaXRlQmV0d2VlbiA9IGZ1bmN0aW9uIChzdHJpbmcsIG5ld1N0cmluZywgaWQxLCBpZDIpIHtcbiAgdmFyIHRlbXBpZDtcbiAgaWYgKGlkMSA9PSBudWxsKSB7XG4gICAgaWQxID0gMDtcbiAgfVxuICBpZiAoaWQyID09IG51bGwpIHtcbiAgICBpZDIgPSBpZDE7XG4gIH1cbiAgaWYgKGlkMSA+IGlkMikge1xuICAgIHRlbXBpZCA9IGlkMjtcbiAgICBpZDIgPSBpZDE7XG4gICAgaWQxID0gdGVtcGlkO1xuICB9XG4gIHJldHVybiBzdHJpbmcuc3Vic3RyaW5nKDAsIGlkMSkgKyBuZXdTdHJpbmcgKyBzdHJpbmcuc3Vic3RyKGlkMik7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5yZW1vdmVGb3IgPSBmdW5jdGlvbiAoc3RyaW5nLCBpZCwgbGVuZ3RoKSB7XG4gIHJldHVybiBtb2R1bGUuZXhwb3J0cy5vdmVyd3JpdGVGb3Ioc3RyaW5nLCBcIlwiLCBpZCwgbGVuZ3RoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzLnJlbW92ZUJldHdlZW4gPSBmdW5jdGlvbiAoc3RyaW5nLCBpZDEsIGlkMikge1xuICByZXR1cm4gbW9kdWxlLmV4cG9ydHMub3ZlcndyaXRlQmV0d2VlbihzdHJpbmcsIFwiXCIsIGlkMSwgaWQyKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzLnBhZExlZnQgPSBmdW5jdGlvbiAoc3RyaW5nLCBmaWxsZXIsIGxlbmd0aCkge1xuICB3aGlsZSAoc3RyaW5nLmxlbmd0aCA8IGxlbmd0aCkge1xuICAgIHN0cmluZyA9IGZpbGxlciArIHN0cmluZztcbiAgfVxuICByZXR1cm4gc3RyaW5nO1xufTtcblxubW9kdWxlLmV4cG9ydHMucGFkUmlnaHQgPSBmdW5jdGlvbiAoc3RyaW5nLCBmaWxsZXIsIGxlbmd0aCkge1xuICB3aGlsZSAoc3RyaW5nLmxlbmd0aCA8IGxlbmd0aCkge1xuICAgIHN0cmluZyArPSBmaWxsZXI7XG4gIH1cbiAgcmV0dXJuIHN0cmluZztcbn07XG5cbm1vZHVsZS5leHBvcnRzLmZpbmRTaW1wbGVFbmNsb3N1cmVzID0gZnVuY3Rpb24gKHN0cmluZywgb3BlblRhZywgb3Blbkxlbmd0aCwgY2xvc2VUYWcsIGNsb3NlTGVuZ3RoKSB7XG4gIHZhciBjSW5kZXgsIGNJbmRleFJlbCwgb0luZGV4LCBvSW5kZXhSZWwsIHJlc3VsdHMsIHNlYXJjaEluZGV4O1xuICAvLyBvcGVuVGFnIGFuZCBjbG9zZVRhZyBjYW4gYmUgc3RyaW5ncyBvciByZWd1bGFyIGV4cHJlc3Npb25zXG4gIC8vIElmIHRoZSBzdHJpbmcgaXMgXCI8PD4+XCIgYW5kIHRoZSB0YWdzIGFyZSBcIjxcIiBhbmQgXCI+XCIsIHRoZSByZXN1bHQgaXNcbiAgLy8gICBbWzAsIDJdLCBdXG4gIC8vIFJlc3VsdHMgYXJlIGd1YXJhbnRlZWQgdG8gYmUgaW4gb3JkZXIgb2YgYXBwZWFyYW5jZSBpbiB0aGUgb3JpZ2luYWxcbiAgLy8gICB0ZXh0XG4gIHJlc3VsdHMgPSBbXTtcbiAgc2VhcmNoSW5kZXggPSAwO1xuICBvSW5kZXhSZWwgPSBzdHJpbmcuc2VhcmNoKG9wZW5UYWcpO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGlmIChvSW5kZXhSZWwgPiAtMSkge1xuICAgICAgb0luZGV4ID0gc2VhcmNoSW5kZXggKyBvSW5kZXhSZWw7XG4gICAgICBjSW5kZXhSZWwgPSBzdHJpbmcuc3Vic3RyKG9JbmRleCArIG9wZW5MZW5ndGgpLnNlYXJjaChjbG9zZVRhZyk7XG4gICAgICBpZiAoY0luZGV4UmVsID4gLTEpIHtcbiAgICAgICAgY0luZGV4ID0gb0luZGV4ICsgb3Blbkxlbmd0aCArIGNJbmRleFJlbDtcbiAgICAgICAgcmVzdWx0cy5wdXNoKFtvSW5kZXgsIGNJbmRleF0pO1xuICAgICAgICBzZWFyY2hJbmRleCA9IGNJbmRleCArIGNsb3NlTGVuZ3RoO1xuICAgICAgICBpZiAoc2VhcmNoSW5kZXggPCBzdHJpbmcubGVuZ3RoKSB7XG4gICAgICAgICAgb0luZGV4UmVsID0gc3RyaW5nLnN1YnN0cihzZWFyY2hJbmRleCkuc2VhcmNoKG9wZW5UYWcpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBBIHRhZyBpcyBsZWZ0IG9wZW4gKG5vIGNsb3NpbmcgdGFnIGlzIGZvdW5kKVxuICAgICAgICAvLyBMZXQgZWFjaCBpbXBsZW1lbnRhdGlvbiBkZWNpZGUgd2hhdCB0byBkbyBpbiB0aGlzIGNhc2VcbiAgICAgICAgLy8gICAoZWl0aGVyIGNvbnNpZGVyIHRoZSB0YWcgd29ya2luZyB1bnRpbCB0aGUgZW5kIG9mIHRleHRcbiAgICAgICAgLy8gICBvciBub3QpXG4gICAgICAgIHJlc3VsdHMucHVzaChbb0luZGV4LCBmYWxzZV0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHRzO1xufTtcblxubW9kdWxlLmV4cG9ydHMuZmluZE5lc3RlZEVuY2xvc3VyZXMgPSBmdW5jdGlvbiAoc3RyaW5nLCBvcGVuVGFnLCBjbG9zZVRhZywgbWFza0NoYXIpIHtcbiAgdmFyIGNJbmRleCwgY0luZGV4UmVsLCBjbG9zZUxlbmd0aCwgbWFza0xlbmd0aCwgbWFza2VkU3RyaW5nLCBtYXNrZWRTdHJpbmcxLCBtYXNrZWRTdHJpbmcyLCBtYXNrZWRTdHJpbmczLCBvSW5kZXgsIG9JbmRleFJlbCwgb3Blbkxlbmd0aCwgcmVzdWx0cywgc2VhcmNoSW5kZXg7XG4gIC8vIG9wZW5UYWcgYW5kIGNsb3NlVGFnIG11c3QgYmUgc3RyaW5ncywgKm5vdCogcmVndWxhciBleHByZXNzaW9ucyxcbiAgLy8gICB1bmxpa2UgdGhpcy5maW5kU2ltcGxlRW5jbG9zdXJlc1xuICAvLyBtYXNrQ2hhciBtdXN0IGJlIGEgKjEqLWNoYXJhY3RlciBzdHJpbmcgYW5kIG11c3QgKm5vdCogYmUgcGFydCBvZlxuICAvLyAgIG5laXRoZXIgb3BlblRhZyBub3IgY2xvc2VUYWdcbiAgLy8gSWYgdGhlIHN0cmluZyBpcyBcIjw8Pj5cIiBhbmQgdGhlIHRhZ3MgYXJlIFwiPFwiIGFuZCBcIj5cIiwgdGhlIHJlc3VsdCBpc1xuICAvLyAgIFtbMSwgMl0sIFswLCAzXV1cbiAgb3Blbkxlbmd0aCA9IG9wZW5UYWcubGVuZ3RoO1xuICBjbG9zZUxlbmd0aCA9IGNsb3NlVGFnLmxlbmd0aDtcbiAgcmVzdWx0cyA9IFtdO1xuICBzZWFyY2hJbmRleCA9IDA7XG4gIGNJbmRleFJlbCA9IHN0cmluZy5pbmRleE9mKGNsb3NlVGFnKTtcbiAgbWFza2VkU3RyaW5nID0gc3RyaW5nO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGlmIChjSW5kZXhSZWwgPiAtMSkge1xuICAgICAgY0luZGV4ID0gc2VhcmNoSW5kZXggKyBjSW5kZXhSZWw7XG4gICAgICBvSW5kZXhSZWwgPSBtYXNrZWRTdHJpbmcuc3Vic3RyaW5nKHNlYXJjaEluZGV4LCBjSW5kZXgpLmxhc3RJbmRleE9mKG9wZW5UYWcpO1xuICAgICAgaWYgKG9JbmRleFJlbCA+IC0xKSB7XG4gICAgICAgIG9JbmRleCA9IHNlYXJjaEluZGV4ICsgb0luZGV4UmVsO1xuICAgICAgICByZXN1bHRzLnB1c2goW29JbmRleCwgY0luZGV4XSk7XG4gICAgICAgIG1hc2tlZFN0cmluZzEgPSBtYXNrZWRTdHJpbmcuc3Vic3RyaW5nKDAsIG9JbmRleCk7XG4gICAgICAgIG1hc2tMZW5ndGggPSBjSW5kZXggLSBvSW5kZXggKyBjbG9zZUxlbmd0aDtcbiAgICAgICAgbWFza2VkU3RyaW5nMiA9IG1vZHVsZS5leHBvcnRzLnBhZFJpZ2h0KFwiXCIsIG1hc2tDaGFyLCBtYXNrTGVuZ3RoKTtcbiAgICAgICAgbWFza2VkU3RyaW5nMyA9IG1hc2tlZFN0cmluZy5zdWJzdHJpbmcoY0luZGV4ICsgY2xvc2VMZW5ndGgpO1xuICAgICAgICBtYXNrZWRTdHJpbmcgPSBtYXNrZWRTdHJpbmcxICsgbWFza2VkU3RyaW5nMiArIG1hc2tlZFN0cmluZzM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBEbyAqbm90KiBpbmNyZW1lbnQgc2VhcmNoSW5kZXggaW4gdGhpcyBjYXNlLCBpbiBmYWN0IGluXG4gICAgICAgIC8vICAgd2UgZG9uJ3Qga25vdyB5ZXQgd2hldGhlciB0aGVyZSBhcmUgbW9yZSBvcGVuVGFnc1xuICAgICAgICAvLyAgIGJlZm9yZSB0aGUgb25lIGZvdW5kXG4gICAgICAgIHNlYXJjaEluZGV4ID0gY0luZGV4ICsgY2xvc2VMZW5ndGg7XG4gICAgICB9XG4gICAgICBjSW5kZXhSZWwgPSBtYXNrZWRTdHJpbmcuc3Vic3RyaW5nKHNlYXJjaEluZGV4KS5pbmRleE9mKGNsb3NlVGFnKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFtyZXN1bHRzLCBtYXNrZWRTdHJpbmddO1xufTtcblxubW9kdWxlLmV4cG9ydHMuZmluZElubmVybW9zdEVuY2xvc3VyZXMgPSBmdW5jdGlvbiAoc3RyaW5nLCBvcGVuVGFnLCBjbG9zZVRhZykge1xuICB2YXIgY0luZGV4LCBjSW5kZXhSZWwsIGNsb3NlTGVuZ3RoLCBvSW5kZXgsIG9JbmRleFJlbCwgb3Blbkxlbmd0aCwgcmVzdWx0cywgc2VhcmNoSW5kZXg7XG4gIC8vIG9wZW5UYWcgYW5kIGNsb3NlVGFnIG11c3QgYmUgc3RyaW5ncywgKm5vdCogcmVndWxhciBleHByZXNzaW9ucyxcbiAgLy8gICB1bmxpa2UgdGhpcy5maW5kU2ltcGxlRW5jbG9zdXJlc1xuICAvLyBJZiB0aGUgc3RyaW5nIGlzIFwiPDw+PlwiIGFuZCB0aGUgdGFncyBhcmUgXCI8XCIgYW5kIFwiPlwiLCB0aGUgcmVzdWx0IGlzXG4gIC8vICAgW1sxLCAyXSwgXVxuICBvcGVuTGVuZ3RoID0gb3BlblRhZy5sZW5ndGg7XG4gIGNsb3NlTGVuZ3RoID0gY2xvc2VUYWcubGVuZ3RoO1xuICByZXN1bHRzID0gW107XG4gIHNlYXJjaEluZGV4ID0gMDtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBjSW5kZXhSZWwgPSBzdHJpbmcuc3Vic3RyaW5nKHNlYXJjaEluZGV4KS5pbmRleE9mKGNsb3NlVGFnKTtcbiAgICBpZiAoY0luZGV4UmVsID4gLTEpIHtcbiAgICAgIGNJbmRleCA9IHNlYXJjaEluZGV4ICsgY0luZGV4UmVsO1xuICAgICAgb0luZGV4UmVsID0gc3RyaW5nLnN1YnN0cmluZyhzZWFyY2hJbmRleCwgY0luZGV4KS5sYXN0SW5kZXhPZihvcGVuVGFnKTtcbiAgICAgIGlmIChvSW5kZXhSZWwgPiAtMSkge1xuICAgICAgICBvSW5kZXggPSBzZWFyY2hJbmRleCArIG9JbmRleFJlbDtcbiAgICAgICAgcmVzdWx0cy5wdXNoKFtvSW5kZXgsIGNJbmRleF0pO1xuICAgICAgfVxuICAgICAgc2VhcmNoSW5kZXggPSBjSW5kZXggKyBjbG9zZUxlbmd0aDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdHM7XG59OyIsIlwidXNlIHN0cmljdFwiO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9zaGltXCIpO1xuXG5yZXF1aXJlKFwicmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9mbi9yZWdleHAvZXNjYXBlXCIpO1xuXG5pZiAoZ2xvYmFsLl9iYWJlbFBvbHlmaWxsKSB7XG4gIHRocm93IG5ldyBFcnJvcihcIm9ubHkgb25lIGluc3RhbmNlIG9mIGJhYmVsLXBvbHlmaWxsIGlzIGFsbG93ZWRcIik7XG59XG5nbG9iYWwuX2JhYmVsUG9seWZpbGwgPSB0cnVlO1xuXG52YXIgREVGSU5FX1BST1BFUlRZID0gXCJkZWZpbmVQcm9wZXJ0eVwiO1xuZnVuY3Rpb24gZGVmaW5lKE8sIGtleSwgdmFsdWUpIHtcbiAgT1trZXldIHx8IE9iamVjdFtERUZJTkVfUFJPUEVSVFldKE8sIGtleSwge1xuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogdmFsdWVcbiAgfSk7XG59XG5cbmRlZmluZShTdHJpbmcucHJvdG90eXBlLCBcInBhZExlZnRcIiwgXCJcIi5wYWRTdGFydCk7XG5kZWZpbmUoU3RyaW5nLnByb3RvdHlwZSwgXCJwYWRSaWdodFwiLCBcIlwiLnBhZEVuZCk7XG5cblwicG9wLHJldmVyc2Usc2hpZnQsa2V5cyx2YWx1ZXMsZW50cmllcyxpbmRleE9mLGV2ZXJ5LHNvbWUsZm9yRWFjaCxtYXAsZmlsdGVyLGZpbmQsZmluZEluZGV4LGluY2x1ZGVzLGpvaW4sc2xpY2UsY29uY2F0LHB1c2gsc3BsaWNlLHVuc2hpZnQsc29ydCxsYXN0SW5kZXhPZixyZWR1Y2UscmVkdWNlUmlnaHQsY29weVdpdGhpbixmaWxsXCIuc3BsaXQoXCIsXCIpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBbXVtrZXldICYmIGRlZmluZShBcnJheSwga2V5LCBGdW5jdGlvbi5jYWxsLmJpbmQoW11ba2V5XSkpO1xufSk7IiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogaHR0cHM6Ly9yYXcuZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9tYXN0ZXIvTElDRU5TRSBmaWxlLiBBblxuICogYWRkaXRpb25hbCBncmFudCBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluXG4gKiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKi9cblxuIShmdW5jdGlvbihnbG9iYWwpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgdmFyIE9wID0gT2JqZWN0LnByb3RvdHlwZTtcbiAgdmFyIGhhc093biA9IE9wLmhhc093blByb3BlcnR5O1xuICB2YXIgdW5kZWZpbmVkOyAvLyBNb3JlIGNvbXByZXNzaWJsZSB0aGFuIHZvaWQgMC5cbiAgdmFyICRTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgPyBTeW1ib2wgOiB7fTtcbiAgdmFyIGl0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5pdGVyYXRvciB8fCBcIkBAaXRlcmF0b3JcIjtcbiAgdmFyIGFzeW5jSXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLmFzeW5jSXRlcmF0b3IgfHwgXCJAQGFzeW5jSXRlcmF0b3JcIjtcbiAgdmFyIHRvU3RyaW5nVGFnU3ltYm9sID0gJFN5bWJvbC50b1N0cmluZ1RhZyB8fCBcIkBAdG9TdHJpbmdUYWdcIjtcblxuICB2YXIgaW5Nb2R1bGUgPSB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiO1xuICB2YXIgcnVudGltZSA9IGdsb2JhbC5yZWdlbmVyYXRvclJ1bnRpbWU7XG4gIGlmIChydW50aW1lKSB7XG4gICAgaWYgKGluTW9kdWxlKSB7XG4gICAgICAvLyBJZiByZWdlbmVyYXRvclJ1bnRpbWUgaXMgZGVmaW5lZCBnbG9iYWxseSBhbmQgd2UncmUgaW4gYSBtb2R1bGUsXG4gICAgICAvLyBtYWtlIHRoZSBleHBvcnRzIG9iamVjdCBpZGVudGljYWwgdG8gcmVnZW5lcmF0b3JSdW50aW1lLlxuICAgICAgbW9kdWxlLmV4cG9ydHMgPSBydW50aW1lO1xuICAgIH1cbiAgICAvLyBEb24ndCBib3RoZXIgZXZhbHVhdGluZyB0aGUgcmVzdCBvZiB0aGlzIGZpbGUgaWYgdGhlIHJ1bnRpbWUgd2FzXG4gICAgLy8gYWxyZWFkeSBkZWZpbmVkIGdsb2JhbGx5LlxuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIERlZmluZSB0aGUgcnVudGltZSBnbG9iYWxseSAoYXMgZXhwZWN0ZWQgYnkgZ2VuZXJhdGVkIGNvZGUpIGFzIGVpdGhlclxuICAvLyBtb2R1bGUuZXhwb3J0cyAoaWYgd2UncmUgaW4gYSBtb2R1bGUpIG9yIGEgbmV3LCBlbXB0eSBvYmplY3QuXG4gIHJ1bnRpbWUgPSBnbG9iYWwucmVnZW5lcmF0b3JSdW50aW1lID0gaW5Nb2R1bGUgPyBtb2R1bGUuZXhwb3J0cyA6IHt9O1xuXG4gIGZ1bmN0aW9uIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBJZiBvdXRlckZuIHByb3ZpZGVkIGFuZCBvdXRlckZuLnByb3RvdHlwZSBpcyBhIEdlbmVyYXRvciwgdGhlbiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvci5cbiAgICB2YXIgcHJvdG9HZW5lcmF0b3IgPSBvdXRlckZuICYmIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yID8gb3V0ZXJGbiA6IEdlbmVyYXRvcjtcbiAgICB2YXIgZ2VuZXJhdG9yID0gT2JqZWN0LmNyZWF0ZShwcm90b0dlbmVyYXRvci5wcm90b3R5cGUpO1xuICAgIHZhciBjb250ZXh0ID0gbmV3IENvbnRleHQodHJ5TG9jc0xpc3QgfHwgW10pO1xuXG4gICAgLy8gVGhlIC5faW52b2tlIG1ldGhvZCB1bmlmaWVzIHRoZSBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlIC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcy5cbiAgICBnZW5lcmF0b3IuX2ludm9rZSA9IG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG5cbiAgICByZXR1cm4gZ2VuZXJhdG9yO1xuICB9XG4gIHJ1bnRpbWUud3JhcCA9IHdyYXA7XG5cbiAgLy8gVHJ5L2NhdGNoIGhlbHBlciB0byBtaW5pbWl6ZSBkZW9wdGltaXphdGlvbnMuIFJldHVybnMgYSBjb21wbGV0aW9uXG4gIC8vIHJlY29yZCBsaWtlIGNvbnRleHQudHJ5RW50cmllc1tpXS5jb21wbGV0aW9uLiBUaGlzIGludGVyZmFjZSBjb3VsZFxuICAvLyBoYXZlIGJlZW4gKGFuZCB3YXMgcHJldmlvdXNseSkgZGVzaWduZWQgdG8gdGFrZSBhIGNsb3N1cmUgdG8gYmVcbiAgLy8gaW52b2tlZCB3aXRob3V0IGFyZ3VtZW50cywgYnV0IGluIGFsbCB0aGUgY2FzZXMgd2UgY2FyZSBhYm91dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYW4gZXhpc3RpbmcgbWV0aG9kIHdlIHdhbnQgdG8gY2FsbCwgc28gdGhlcmUncyBubyBuZWVkXG4gIC8vIHRvIGNyZWF0ZSBhIG5ldyBmdW5jdGlvbiBvYmplY3QuIFdlIGNhbiBldmVuIGdldCBhd2F5IHdpdGggYXNzdW1pbmdcbiAgLy8gdGhlIG1ldGhvZCB0YWtlcyBleGFjdGx5IG9uZSBhcmd1bWVudCwgc2luY2UgdGhhdCBoYXBwZW5zIHRvIGJlIHRydWVcbiAgLy8gaW4gZXZlcnkgY2FzZSwgc28gd2UgZG9uJ3QgaGF2ZSB0byB0b3VjaCB0aGUgYXJndW1lbnRzIG9iamVjdC4gVGhlXG4gIC8vIG9ubHkgYWRkaXRpb25hbCBhbGxvY2F0aW9uIHJlcXVpcmVkIGlzIHRoZSBjb21wbGV0aW9uIHJlY29yZCwgd2hpY2hcbiAgLy8gaGFzIGEgc3RhYmxlIHNoYXBlIGFuZCBzbyBob3BlZnVsbHkgc2hvdWxkIGJlIGNoZWFwIHRvIGFsbG9jYXRlLlxuICBmdW5jdGlvbiB0cnlDYXRjaChmbiwgb2JqLCBhcmcpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJub3JtYWxcIiwgYXJnOiBmbi5jYWxsKG9iaiwgYXJnKSB9O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJ0aHJvd1wiLCBhcmc6IGVyciB9O1xuICAgIH1cbiAgfVxuXG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0ID0gXCJzdXNwZW5kZWRTdGFydFwiO1xuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRZaWVsZCA9IFwic3VzcGVuZGVkWWllbGRcIjtcbiAgdmFyIEdlblN0YXRlRXhlY3V0aW5nID0gXCJleGVjdXRpbmdcIjtcbiAgdmFyIEdlblN0YXRlQ29tcGxldGVkID0gXCJjb21wbGV0ZWRcIjtcblxuICAvLyBSZXR1cm5pbmcgdGhpcyBvYmplY3QgZnJvbSB0aGUgaW5uZXJGbiBoYXMgdGhlIHNhbWUgZWZmZWN0IGFzXG4gIC8vIGJyZWFraW5nIG91dCBvZiB0aGUgZGlzcGF0Y2ggc3dpdGNoIHN0YXRlbWVudC5cbiAgdmFyIENvbnRpbnVlU2VudGluZWwgPSB7fTtcblxuICAvLyBEdW1teSBjb25zdHJ1Y3RvciBmdW5jdGlvbnMgdGhhdCB3ZSB1c2UgYXMgdGhlIC5jb25zdHJ1Y3RvciBhbmRcbiAgLy8gLmNvbnN0cnVjdG9yLnByb3RvdHlwZSBwcm9wZXJ0aWVzIGZvciBmdW5jdGlvbnMgdGhhdCByZXR1cm4gR2VuZXJhdG9yXG4gIC8vIG9iamVjdHMuIEZvciBmdWxsIHNwZWMgY29tcGxpYW5jZSwgeW91IG1heSB3aXNoIHRvIGNvbmZpZ3VyZSB5b3VyXG4gIC8vIG1pbmlmaWVyIG5vdCB0byBtYW5nbGUgdGhlIG5hbWVzIG9mIHRoZXNlIHR3byBmdW5jdGlvbnMuXG4gIGZ1bmN0aW9uIEdlbmVyYXRvcigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUoKSB7fVxuXG4gIC8vIFRoaXMgaXMgYSBwb2x5ZmlsbCBmb3IgJUl0ZXJhdG9yUHJvdG90eXBlJSBmb3IgZW52aXJvbm1lbnRzIHRoYXRcbiAgLy8gZG9uJ3QgbmF0aXZlbHkgc3VwcG9ydCBpdC5cbiAgdmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG4gIEl0ZXJhdG9yUHJvdG90eXBlW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICB2YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG4gIHZhciBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvICYmIGdldFByb3RvKGdldFByb3RvKHZhbHVlcyhbXSkpKTtcbiAgaWYgKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICYmXG4gICAgICBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAhPT0gT3AgJiZcbiAgICAgIGhhc093bi5jYWxsKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlLCBpdGVyYXRvclN5bWJvbCkpIHtcbiAgICAvLyBUaGlzIGVudmlyb25tZW50IGhhcyBhIG5hdGl2ZSAlSXRlcmF0b3JQcm90b3R5cGUlOyB1c2UgaXQgaW5zdGVhZFxuICAgIC8vIG9mIHRoZSBwb2x5ZmlsbC5cbiAgICBJdGVyYXRvclByb3RvdHlwZSA9IE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlO1xuICB9XG5cbiAgdmFyIEdwID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUucHJvdG90eXBlID1cbiAgICBHZW5lcmF0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSk7XG4gIEdlbmVyYXRvckZ1bmN0aW9uLnByb3RvdHlwZSA9IEdwLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb247XG4gIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlW3RvU3RyaW5nVGFnU3ltYm9sXSA9XG4gICAgR2VuZXJhdG9yRnVuY3Rpb24uZGlzcGxheU5hbWUgPSBcIkdlbmVyYXRvckZ1bmN0aW9uXCI7XG5cbiAgLy8gSGVscGVyIGZvciBkZWZpbmluZyB0aGUgLm5leHQsIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcyBvZiB0aGVcbiAgLy8gSXRlcmF0b3IgaW50ZXJmYWNlIGluIHRlcm1zIG9mIGEgc2luZ2xlIC5faW52b2tlIG1ldGhvZC5cbiAgZnVuY3Rpb24gZGVmaW5lSXRlcmF0b3JNZXRob2RzKHByb3RvdHlwZSkge1xuICAgIFtcIm5leHRcIiwgXCJ0aHJvd1wiLCBcInJldHVyblwiXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgcHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludm9rZShtZXRob2QsIGFyZyk7XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgcnVudGltZS5pc0dlbmVyYXRvckZ1bmN0aW9uID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgdmFyIGN0b3IgPSB0eXBlb2YgZ2VuRnVuID09PSBcImZ1bmN0aW9uXCIgJiYgZ2VuRnVuLmNvbnN0cnVjdG9yO1xuICAgIHJldHVybiBjdG9yXG4gICAgICA/IGN0b3IgPT09IEdlbmVyYXRvckZ1bmN0aW9uIHx8XG4gICAgICAgIC8vIEZvciB0aGUgbmF0aXZlIEdlbmVyYXRvckZ1bmN0aW9uIGNvbnN0cnVjdG9yLCB0aGUgYmVzdCB3ZSBjYW5cbiAgICAgICAgLy8gZG8gaXMgdG8gY2hlY2sgaXRzIC5uYW1lIHByb3BlcnR5LlxuICAgICAgICAoY3Rvci5kaXNwbGF5TmFtZSB8fCBjdG9yLm5hbWUpID09PSBcIkdlbmVyYXRvckZ1bmN0aW9uXCJcbiAgICAgIDogZmFsc2U7XG4gIH07XG5cbiAgcnVudGltZS5tYXJrID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgaWYgKE9iamVjdC5zZXRQcm90b3R5cGVPZikge1xuICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGdlbkZ1biwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnZW5GdW4uX19wcm90b19fID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gICAgICBpZiAoISh0b1N0cmluZ1RhZ1N5bWJvbCBpbiBnZW5GdW4pKSB7XG4gICAgICAgIGdlbkZ1blt0b1N0cmluZ1RhZ1N5bWJvbF0gPSBcIkdlbmVyYXRvckZ1bmN0aW9uXCI7XG4gICAgICB9XG4gICAgfVxuICAgIGdlbkZ1bi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEdwKTtcbiAgICByZXR1cm4gZ2VuRnVuO1xuICB9O1xuXG4gIC8vIFdpdGhpbiB0aGUgYm9keSBvZiBhbnkgYXN5bmMgZnVuY3Rpb24sIGBhd2FpdCB4YCBpcyB0cmFuc2Zvcm1lZCB0b1xuICAvLyBgeWllbGQgcmVnZW5lcmF0b3JSdW50aW1lLmF3cmFwKHgpYCwgc28gdGhhdCB0aGUgcnVudGltZSBjYW4gdGVzdFxuICAvLyBgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKWAgdG8gZGV0ZXJtaW5lIGlmIHRoZSB5aWVsZGVkIHZhbHVlIGlzXG4gIC8vIG1lYW50IHRvIGJlIGF3YWl0ZWQuXG4gIHJ1bnRpbWUuYXdyYXAgPSBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4geyBfX2F3YWl0OiBhcmcgfTtcbiAgfTtcblxuICBmdW5jdGlvbiBBc3luY0l0ZXJhdG9yKGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goZ2VuZXJhdG9yW21ldGhvZF0sIGdlbmVyYXRvciwgYXJnKTtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHJlamVjdChyZWNvcmQuYXJnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByZXN1bHQgPSByZWNvcmQuYXJnO1xuICAgICAgICB2YXIgdmFsdWUgPSByZXN1bHQudmFsdWU7XG4gICAgICAgIGlmICh2YWx1ZSAmJlxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZS5fX2F3YWl0KS50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJuZXh0XCIsIHZhbHVlLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgaW52b2tlKFwidGhyb3dcIiwgZXJyLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbih1bndyYXBwZWQpIHtcbiAgICAgICAgICAvLyBXaGVuIGEgeWllbGRlZCBQcm9taXNlIGlzIHJlc29sdmVkLCBpdHMgZmluYWwgdmFsdWUgYmVjb21lc1xuICAgICAgICAgIC8vIHRoZSAudmFsdWUgb2YgdGhlIFByb21pc2U8e3ZhbHVlLGRvbmV9PiByZXN1bHQgZm9yIHRoZVxuICAgICAgICAgIC8vIGN1cnJlbnQgaXRlcmF0aW9uLiBJZiB0aGUgUHJvbWlzZSBpcyByZWplY3RlZCwgaG93ZXZlciwgdGhlXG4gICAgICAgICAgLy8gcmVzdWx0IGZvciB0aGlzIGl0ZXJhdGlvbiB3aWxsIGJlIHJlamVjdGVkIHdpdGggdGhlIHNhbWVcbiAgICAgICAgICAvLyByZWFzb24uIE5vdGUgdGhhdCByZWplY3Rpb25zIG9mIHlpZWxkZWQgUHJvbWlzZXMgYXJlIG5vdFxuICAgICAgICAgIC8vIHRocm93biBiYWNrIGludG8gdGhlIGdlbmVyYXRvciBmdW5jdGlvbiwgYXMgaXMgdGhlIGNhc2VcbiAgICAgICAgICAvLyB3aGVuIGFuIGF3YWl0ZWQgUHJvbWlzZSBpcyByZWplY3RlZC4gVGhpcyBkaWZmZXJlbmNlIGluXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYmV0d2VlbiB5aWVsZCBhbmQgYXdhaXQgaXMgaW1wb3J0YW50LCBiZWNhdXNlIGl0XG4gICAgICAgICAgLy8gYWxsb3dzIHRoZSBjb25zdW1lciB0byBkZWNpZGUgd2hhdCB0byBkbyB3aXRoIHRoZSB5aWVsZGVkXG4gICAgICAgICAgLy8gcmVqZWN0aW9uIChzd2FsbG93IGl0IGFuZCBjb250aW51ZSwgbWFudWFsbHkgLnRocm93IGl0IGJhY2tcbiAgICAgICAgICAvLyBpbnRvIHRoZSBnZW5lcmF0b3IsIGFiYW5kb24gaXRlcmF0aW9uLCB3aGF0ZXZlcikuIFdpdGhcbiAgICAgICAgICAvLyBhd2FpdCwgYnkgY29udHJhc3QsIHRoZXJlIGlzIG5vIG9wcG9ydHVuaXR5IHRvIGV4YW1pbmUgdGhlXG4gICAgICAgICAgLy8gcmVqZWN0aW9uIHJlYXNvbiBvdXRzaWRlIHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24sIHNvIHRoZVxuICAgICAgICAgIC8vIG9ubHkgb3B0aW9uIGlzIHRvIHRocm93IGl0IGZyb20gdGhlIGF3YWl0IGV4cHJlc3Npb24sIGFuZFxuICAgICAgICAgIC8vIGxldCB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uIGhhbmRsZSB0aGUgZXhjZXB0aW9uLlxuICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IHVud3JhcHBlZDtcbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0sIHJlamVjdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBnbG9iYWwucHJvY2VzcyA9PT0gXCJvYmplY3RcIiAmJiBnbG9iYWwucHJvY2Vzcy5kb21haW4pIHtcbiAgICAgIGludm9rZSA9IGdsb2JhbC5wcm9jZXNzLmRvbWFpbi5iaW5kKGludm9rZSk7XG4gICAgfVxuXG4gICAgdmFyIHByZXZpb3VzUHJvbWlzZTtcblxuICAgIGZ1bmN0aW9uIGVucXVldWUobWV0aG9kLCBhcmcpIHtcbiAgICAgIGZ1bmN0aW9uIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByZXZpb3VzUHJvbWlzZSA9XG4gICAgICAgIC8vIElmIGVucXVldWUgaGFzIGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIHdhaXQgdW50aWxcbiAgICAgICAgLy8gYWxsIHByZXZpb3VzIFByb21pc2VzIGhhdmUgYmVlbiByZXNvbHZlZCBiZWZvcmUgY2FsbGluZyBpbnZva2UsXG4gICAgICAgIC8vIHNvIHRoYXQgcmVzdWx0cyBhcmUgYWx3YXlzIGRlbGl2ZXJlZCBpbiB0aGUgY29ycmVjdCBvcmRlci4gSWZcbiAgICAgICAgLy8gZW5xdWV1ZSBoYXMgbm90IGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiBpdCBpcyBpbXBvcnRhbnQgdG9cbiAgICAgICAgLy8gY2FsbCBpbnZva2UgaW1tZWRpYXRlbHksIHdpdGhvdXQgd2FpdGluZyBvbiBhIGNhbGxiYWNrIHRvIGZpcmUsXG4gICAgICAgIC8vIHNvIHRoYXQgdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBoYXMgdGhlIG9wcG9ydHVuaXR5IHRvIGRvXG4gICAgICAgIC8vIGFueSBuZWNlc3Nhcnkgc2V0dXAgaW4gYSBwcmVkaWN0YWJsZSB3YXkuIFRoaXMgcHJlZGljdGFiaWxpdHlcbiAgICAgICAgLy8gaXMgd2h5IHRoZSBQcm9taXNlIGNvbnN0cnVjdG9yIHN5bmNocm9ub3VzbHkgaW52b2tlcyBpdHNcbiAgICAgICAgLy8gZXhlY3V0b3IgY2FsbGJhY2ssIGFuZCB3aHkgYXN5bmMgZnVuY3Rpb25zIHN5bmNocm9ub3VzbHlcbiAgICAgICAgLy8gZXhlY3V0ZSBjb2RlIGJlZm9yZSB0aGUgZmlyc3QgYXdhaXQuIFNpbmNlIHdlIGltcGxlbWVudCBzaW1wbGVcbiAgICAgICAgLy8gYXN5bmMgZnVuY3Rpb25zIGluIHRlcm1zIG9mIGFzeW5jIGdlbmVyYXRvcnMsIGl0IGlzIGVzcGVjaWFsbHlcbiAgICAgICAgLy8gaW1wb3J0YW50IHRvIGdldCB0aGlzIHJpZ2h0LCBldmVuIHRob3VnaCBpdCByZXF1aXJlcyBjYXJlLlxuICAgICAgICBwcmV2aW91c1Byb21pc2UgPyBwcmV2aW91c1Byb21pc2UudGhlbihcbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZyxcbiAgICAgICAgICAvLyBBdm9pZCBwcm9wYWdhdGluZyBmYWlsdXJlcyB0byBQcm9taXNlcyByZXR1cm5lZCBieSBsYXRlclxuICAgICAgICAgIC8vIGludm9jYXRpb25zIG9mIHRoZSBpdGVyYXRvci5cbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZ1xuICAgICAgICApIDogY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKTtcbiAgICB9XG5cbiAgICAvLyBEZWZpbmUgdGhlIHVuaWZpZWQgaGVscGVyIG1ldGhvZCB0aGF0IGlzIHVzZWQgdG8gaW1wbGVtZW50IC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gKHNlZSBkZWZpbmVJdGVyYXRvck1ldGhvZHMpLlxuICAgIHRoaXMuX2ludm9rZSA9IGVucXVldWU7XG4gIH1cblxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUpO1xuICBBc3luY0l0ZXJhdG9yLnByb3RvdHlwZVthc3luY0l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgcnVudGltZS5Bc3luY0l0ZXJhdG9yID0gQXN5bmNJdGVyYXRvcjtcblxuICAvLyBOb3RlIHRoYXQgc2ltcGxlIGFzeW5jIGZ1bmN0aW9ucyBhcmUgaW1wbGVtZW50ZWQgb24gdG9wIG9mXG4gIC8vIEFzeW5jSXRlcmF0b3Igb2JqZWN0czsgdGhleSBqdXN0IHJldHVybiBhIFByb21pc2UgZm9yIHRoZSB2YWx1ZSBvZlxuICAvLyB0aGUgZmluYWwgcmVzdWx0IHByb2R1Y2VkIGJ5IHRoZSBpdGVyYXRvci5cbiAgcnVudGltZS5hc3luYyA9IGZ1bmN0aW9uKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgdmFyIGl0ZXIgPSBuZXcgQXN5bmNJdGVyYXRvcihcbiAgICAgIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpXG4gICAgKTtcblxuICAgIHJldHVybiBydW50aW1lLmlzR2VuZXJhdG9yRnVuY3Rpb24ob3V0ZXJGbilcbiAgICAgID8gaXRlciAvLyBJZiBvdXRlckZuIGlzIGEgZ2VuZXJhdG9yLCByZXR1cm4gdGhlIGZ1bGwgaXRlcmF0b3IuXG4gICAgICA6IGl0ZXIubmV4dCgpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdC5kb25lID8gcmVzdWx0LnZhbHVlIDogaXRlci5uZXh0KCk7XG4gICAgICAgIH0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCkge1xuICAgIHZhciBzdGF0ZSA9IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQ7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlRXhlY3V0aW5nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVDb21wbGV0ZWQpIHtcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgdGhyb3cgYXJnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQmUgZm9yZ2l2aW5nLCBwZXIgMjUuMy4zLjMuMyBvZiB0aGUgc3BlYzpcbiAgICAgICAgLy8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLWdlbmVyYXRvcnJlc3VtZVxuICAgICAgICByZXR1cm4gZG9uZVJlc3VsdCgpO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IG1ldGhvZDtcbiAgICAgIGNvbnRleHQuYXJnID0gYXJnO1xuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgZGVsZWdhdGUgPSBjb250ZXh0LmRlbGVnYXRlO1xuICAgICAgICBpZiAoZGVsZWdhdGUpIHtcbiAgICAgICAgICB2YXIgZGVsZWdhdGVSZXN1bHQgPSBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcbiAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQpIHtcbiAgICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCA9PT0gQ29udGludWVTZW50aW5lbCkgY29udGludWU7XG4gICAgICAgICAgICByZXR1cm4gZGVsZWdhdGVSZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAgIC8vIFNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICAgICAgY29udGV4dC5zZW50ID0gY29udGV4dC5fc2VudCA9IGNvbnRleHQuYXJnO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydCkge1xuICAgICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAgIHRocm93IGNvbnRleHQuYXJnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgICBjb250ZXh0LmFicnVwdChcInJldHVyblwiLCBjb250ZXh0LmFyZyk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZSA9IEdlblN0YXRlRXhlY3V0aW5nO1xuXG4gICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiKSB7XG4gICAgICAgICAgLy8gSWYgYW4gZXhjZXB0aW9uIGlzIHRocm93biBmcm9tIGlubmVyRm4sIHdlIGxlYXZlIHN0YXRlID09PVxuICAgICAgICAgIC8vIEdlblN0YXRlRXhlY3V0aW5nIGFuZCBsb29wIGJhY2sgZm9yIGFub3RoZXIgaW52b2NhdGlvbi5cbiAgICAgICAgICBzdGF0ZSA9IGNvbnRleHQuZG9uZVxuICAgICAgICAgICAgPyBHZW5TdGF0ZUNvbXBsZXRlZFxuICAgICAgICAgICAgOiBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkO1xuXG4gICAgICAgICAgaWYgKHJlY29yZC5hcmcgPT09IENvbnRpbnVlU2VudGluZWwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogcmVjb3JkLmFyZyxcbiAgICAgICAgICAgIGRvbmU6IGNvbnRleHQuZG9uZVxuICAgICAgICAgIH07XG5cbiAgICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAvLyBEaXNwYXRjaCB0aGUgZXhjZXB0aW9uIGJ5IGxvb3BpbmcgYmFjayBhcm91bmQgdG8gdGhlXG4gICAgICAgICAgLy8gY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZykgY2FsbCBhYm92ZS5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLy8gQ2FsbCBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF0oY29udGV4dC5hcmcpIGFuZCBoYW5kbGUgdGhlXG4gIC8vIHJlc3VsdCwgZWl0aGVyIGJ5IHJldHVybmluZyBhIHsgdmFsdWUsIGRvbmUgfSByZXN1bHQgZnJvbSB0aGVcbiAgLy8gZGVsZWdhdGUgaXRlcmF0b3IsIG9yIGJ5IG1vZGlmeWluZyBjb250ZXh0Lm1ldGhvZCBhbmQgY29udGV4dC5hcmcsXG4gIC8vIHNldHRpbmcgY29udGV4dC5kZWxlZ2F0ZSB0byBudWxsLCBhbmQgcmV0dXJuaW5nIHRoZSBDb250aW51ZVNlbnRpbmVsLlxuICBmdW5jdGlvbiBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIG1ldGhvZCA9IGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXTtcbiAgICBpZiAobWV0aG9kID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEEgLnRocm93IG9yIC5yZXR1cm4gd2hlbiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIG5vIC50aHJvd1xuICAgICAgLy8gbWV0aG9kIGFsd2F5cyB0ZXJtaW5hdGVzIHRoZSB5aWVsZCogbG9vcC5cbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICBpZiAoZGVsZWdhdGUuaXRlcmF0b3IucmV0dXJuKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBhIHJldHVybiBtZXRob2QsIGdpdmUgaXQgYVxuICAgICAgICAgIC8vIGNoYW5jZSB0byBjbGVhbiB1cC5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG5cbiAgICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgLy8gSWYgbWF5YmVJbnZva2VEZWxlZ2F0ZShjb250ZXh0KSBjaGFuZ2VkIGNvbnRleHQubWV0aG9kIGZyb21cbiAgICAgICAgICAgIC8vIFwicmV0dXJuXCIgdG8gXCJ0aHJvd1wiLCBsZXQgdGhhdCBvdmVycmlkZSB0aGUgVHlwZUVycm9yIGJlbG93LlxuICAgICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICBcIlRoZSBpdGVyYXRvciBkb2VzIG5vdCBwcm92aWRlIGEgJ3Rocm93JyBtZXRob2RcIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChtZXRob2QsIGRlbGVnYXRlLml0ZXJhdG9yLCBjb250ZXh0LmFyZyk7XG5cbiAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciBpbmZvID0gcmVjb3JkLmFyZztcblxuICAgIGlmICghIGluZm8pIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFwiaXRlcmF0b3IgcmVzdWx0IGlzIG5vdCBhbiBvYmplY3RcIik7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgIC8vIEFzc2lnbiB0aGUgcmVzdWx0IG9mIHRoZSBmaW5pc2hlZCBkZWxlZ2F0ZSB0byB0aGUgdGVtcG9yYXJ5XG4gICAgICAvLyB2YXJpYWJsZSBzcGVjaWZpZWQgYnkgZGVsZWdhdGUucmVzdWx0TmFtZSAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dFtkZWxlZ2F0ZS5yZXN1bHROYW1lXSA9IGluZm8udmFsdWU7XG5cbiAgICAgIC8vIFJlc3VtZSBleGVjdXRpb24gYXQgdGhlIGRlc2lyZWQgbG9jYXRpb24gKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHQubmV4dCA9IGRlbGVnYXRlLm5leHRMb2M7XG5cbiAgICAgIC8vIElmIGNvbnRleHQubWV0aG9kIHdhcyBcInRocm93XCIgYnV0IHRoZSBkZWxlZ2F0ZSBoYW5kbGVkIHRoZVxuICAgICAgLy8gZXhjZXB0aW9uLCBsZXQgdGhlIG91dGVyIGdlbmVyYXRvciBwcm9jZWVkIG5vcm1hbGx5LiBJZlxuICAgICAgLy8gY29udGV4dC5tZXRob2Qgd2FzIFwibmV4dFwiLCBmb3JnZXQgY29udGV4dC5hcmcgc2luY2UgaXQgaGFzIGJlZW5cbiAgICAgIC8vIFwiY29uc3VtZWRcIiBieSB0aGUgZGVsZWdhdGUgaXRlcmF0b3IuIElmIGNvbnRleHQubWV0aG9kIHdhc1xuICAgICAgLy8gXCJyZXR1cm5cIiwgYWxsb3cgdGhlIG9yaWdpbmFsIC5yZXR1cm4gY2FsbCB0byBjb250aW51ZSBpbiB0aGVcbiAgICAgIC8vIG91dGVyIGdlbmVyYXRvci5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCAhPT0gXCJyZXR1cm5cIikge1xuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZS15aWVsZCB0aGUgcmVzdWx0IHJldHVybmVkIGJ5IHRoZSBkZWxlZ2F0ZSBtZXRob2QuXG4gICAgICByZXR1cm4gaW5mbztcbiAgICB9XG5cbiAgICAvLyBUaGUgZGVsZWdhdGUgaXRlcmF0b3IgaXMgZmluaXNoZWQsIHNvIGZvcmdldCBpdCBhbmQgY29udGludWUgd2l0aFxuICAgIC8vIHRoZSBvdXRlciBnZW5lcmF0b3IuXG4gICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gIH1cblxuICAvLyBEZWZpbmUgR2VuZXJhdG9yLnByb3RvdHlwZS57bmV4dCx0aHJvdyxyZXR1cm59IGluIHRlcm1zIG9mIHRoZVxuICAvLyB1bmlmaWVkIC5faW52b2tlIGhlbHBlciBtZXRob2QuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhHcCk7XG5cbiAgR3BbdG9TdHJpbmdUYWdTeW1ib2xdID0gXCJHZW5lcmF0b3JcIjtcblxuICAvLyBBIEdlbmVyYXRvciBzaG91bGQgYWx3YXlzIHJldHVybiBpdHNlbGYgYXMgdGhlIGl0ZXJhdG9yIG9iamVjdCB3aGVuIHRoZVxuICAvLyBAQGl0ZXJhdG9yIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBpdC4gU29tZSBicm93c2VycycgaW1wbGVtZW50YXRpb25zIG9mIHRoZVxuICAvLyBpdGVyYXRvciBwcm90b3R5cGUgY2hhaW4gaW5jb3JyZWN0bHkgaW1wbGVtZW50IHRoaXMsIGNhdXNpbmcgdGhlIEdlbmVyYXRvclxuICAvLyBvYmplY3QgdG8gbm90IGJlIHJldHVybmVkIGZyb20gdGhpcyBjYWxsLiBUaGlzIGVuc3VyZXMgdGhhdCBkb2Vzbid0IGhhcHBlbi5cbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9pc3N1ZXMvMjc0IGZvciBtb3JlIGRldGFpbHMuXG4gIEdwW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEdwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwiW29iamVjdCBHZW5lcmF0b3JdXCI7XG4gIH07XG5cbiAgZnVuY3Rpb24gcHVzaFRyeUVudHJ5KGxvY3MpIHtcbiAgICB2YXIgZW50cnkgPSB7IHRyeUxvYzogbG9jc1swXSB9O1xuXG4gICAgaWYgKDEgaW4gbG9jcykge1xuICAgICAgZW50cnkuY2F0Y2hMb2MgPSBsb2NzWzFdO1xuICAgIH1cblxuICAgIGlmICgyIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmZpbmFsbHlMb2MgPSBsb2NzWzJdO1xuICAgICAgZW50cnkuYWZ0ZXJMb2MgPSBsb2NzWzNdO1xuICAgIH1cblxuICAgIHRoaXMudHJ5RW50cmllcy5wdXNoKGVudHJ5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0VHJ5RW50cnkoZW50cnkpIHtcbiAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbiB8fCB7fTtcbiAgICByZWNvcmQudHlwZSA9IFwibm9ybWFsXCI7XG4gICAgZGVsZXRlIHJlY29yZC5hcmc7XG4gICAgZW50cnkuY29tcGxldGlvbiA9IHJlY29yZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIENvbnRleHQodHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBUaGUgcm9vdCBlbnRyeSBvYmplY3QgKGVmZmVjdGl2ZWx5IGEgdHJ5IHN0YXRlbWVudCB3aXRob3V0IGEgY2F0Y2hcbiAgICAvLyBvciBhIGZpbmFsbHkgYmxvY2spIGdpdmVzIHVzIGEgcGxhY2UgdG8gc3RvcmUgdmFsdWVzIHRocm93biBmcm9tXG4gICAgLy8gbG9jYXRpb25zIHdoZXJlIHRoZXJlIGlzIG5vIGVuY2xvc2luZyB0cnkgc3RhdGVtZW50LlxuICAgIHRoaXMudHJ5RW50cmllcyA9IFt7IHRyeUxvYzogXCJyb290XCIgfV07XG4gICAgdHJ5TG9jc0xpc3QuZm9yRWFjaChwdXNoVHJ5RW50cnksIHRoaXMpO1xuICAgIHRoaXMucmVzZXQodHJ1ZSk7XG4gIH1cblxuICBydW50aW1lLmtleXMgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgIGtleXMucHVzaChrZXkpO1xuICAgIH1cbiAgICBrZXlzLnJldmVyc2UoKTtcblxuICAgIC8vIFJhdGhlciB0aGFuIHJldHVybmluZyBhbiBvYmplY3Qgd2l0aCBhIG5leHQgbWV0aG9kLCB3ZSBrZWVwXG4gICAgLy8gdGhpbmdzIHNpbXBsZSBhbmQgcmV0dXJuIHRoZSBuZXh0IGZ1bmN0aW9uIGl0c2VsZi5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIHdoaWxlIChrZXlzLmxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0ga2V5cy5wb3AoKTtcbiAgICAgICAgaWYgKGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICBuZXh0LnZhbHVlID0ga2V5O1xuICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRvIGF2b2lkIGNyZWF0aW5nIGFuIGFkZGl0aW9uYWwgb2JqZWN0LCB3ZSBqdXN0IGhhbmcgdGhlIC52YWx1ZVxuICAgICAgLy8gYW5kIC5kb25lIHByb3BlcnRpZXMgb2ZmIHRoZSBuZXh0IGZ1bmN0aW9uIG9iamVjdCBpdHNlbGYuIFRoaXNcbiAgICAgIC8vIGFsc28gZW5zdXJlcyB0aGF0IHRoZSBtaW5pZmllciB3aWxsIG5vdCBhbm9ueW1pemUgdGhlIGZ1bmN0aW9uLlxuICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gdmFsdWVzKGl0ZXJhYmxlKSB7XG4gICAgaWYgKGl0ZXJhYmxlKSB7XG4gICAgICB2YXIgaXRlcmF0b3JNZXRob2QgPSBpdGVyYWJsZVtpdGVyYXRvclN5bWJvbF07XG4gICAgICBpZiAoaXRlcmF0b3JNZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yTWV0aG9kLmNhbGwoaXRlcmFibGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhYmxlLm5leHQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gaXRlcmFibGU7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNOYU4oaXRlcmFibGUubGVuZ3RoKSkge1xuICAgICAgICB2YXIgaSA9IC0xLCBuZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICB3aGlsZSAoKytpIDwgaXRlcmFibGUubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwoaXRlcmFibGUsIGkpKSB7XG4gICAgICAgICAgICAgIG5leHQudmFsdWUgPSBpdGVyYWJsZVtpXTtcbiAgICAgICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG5leHQudmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcblxuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBuZXh0Lm5leHQgPSBuZXh0O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJldHVybiBhbiBpdGVyYXRvciB3aXRoIG5vIHZhbHVlcy5cbiAgICByZXR1cm4geyBuZXh0OiBkb25lUmVzdWx0IH07XG4gIH1cbiAgcnVudGltZS52YWx1ZXMgPSB2YWx1ZXM7XG5cbiAgZnVuY3Rpb24gZG9uZVJlc3VsdCgpIHtcbiAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIH1cblxuICBDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogQ29udGV4dCxcblxuICAgIHJlc2V0OiBmdW5jdGlvbihza2lwVGVtcFJlc2V0KSB7XG4gICAgICB0aGlzLnByZXYgPSAwO1xuICAgICAgdGhpcy5uZXh0ID0gMDtcbiAgICAgIC8vIFJlc2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgdGhpcy5zZW50ID0gdGhpcy5fc2VudCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcblxuICAgICAgdGhpcy50cnlFbnRyaWVzLmZvckVhY2gocmVzZXRUcnlFbnRyeSk7XG5cbiAgICAgIGlmICghc2tpcFRlbXBSZXNldCkge1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMpIHtcbiAgICAgICAgICAvLyBOb3Qgc3VyZSBhYm91dCB0aGUgb3B0aW1hbCBvcmRlciBvZiB0aGVzZSBjb25kaXRpb25zOlxuICAgICAgICAgIGlmIChuYW1lLmNoYXJBdCgwKSA9PT0gXCJ0XCIgJiZcbiAgICAgICAgICAgICAgaGFzT3duLmNhbGwodGhpcywgbmFtZSkgJiZcbiAgICAgICAgICAgICAgIWlzTmFOKCtuYW1lLnNsaWNlKDEpKSkge1xuICAgICAgICAgICAgdGhpc1tuYW1lXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuXG4gICAgICB2YXIgcm9vdEVudHJ5ID0gdGhpcy50cnlFbnRyaWVzWzBdO1xuICAgICAgdmFyIHJvb3RSZWNvcmQgPSByb290RW50cnkuY29tcGxldGlvbjtcbiAgICAgIGlmIChyb290UmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByb290UmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucnZhbDtcbiAgICB9LFxuXG4gICAgZGlzcGF0Y2hFeGNlcHRpb246IGZ1bmN0aW9uKGV4Y2VwdGlvbikge1xuICAgICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgICB9XG5cbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcbiAgICAgIGZ1bmN0aW9uIGhhbmRsZShsb2MsIGNhdWdodCkge1xuICAgICAgICByZWNvcmQudHlwZSA9IFwidGhyb3dcIjtcbiAgICAgICAgcmVjb3JkLmFyZyA9IGV4Y2VwdGlvbjtcbiAgICAgICAgY29udGV4dC5uZXh0ID0gbG9jO1xuXG4gICAgICAgIGlmIChjYXVnaHQpIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZGlzcGF0Y2hlZCBleGNlcHRpb24gd2FzIGNhdWdodCBieSBhIGNhdGNoIGJsb2NrLFxuICAgICAgICAgIC8vIHRoZW4gbGV0IHRoYXQgY2F0Y2ggYmxvY2sgaGFuZGxlIHRoZSBleGNlcHRpb24gbm9ybWFsbHkuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAhISBjYXVnaHQ7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSBcInJvb3RcIikge1xuICAgICAgICAgIC8vIEV4Y2VwdGlvbiB0aHJvd24gb3V0c2lkZSBvZiBhbnkgdHJ5IGJsb2NrIHRoYXQgY291bGQgaGFuZGxlXG4gICAgICAgICAgLy8gaXQsIHNvIHNldCB0aGUgY29tcGxldGlvbiB2YWx1ZSBvZiB0aGUgZW50aXJlIGZ1bmN0aW9uIHRvXG4gICAgICAgICAgLy8gdGhyb3cgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICByZXR1cm4gaGFuZGxlKFwiZW5kXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYpIHtcbiAgICAgICAgICB2YXIgaGFzQ2F0Y2ggPSBoYXNPd24uY2FsbChlbnRyeSwgXCJjYXRjaExvY1wiKTtcbiAgICAgICAgICB2YXIgaGFzRmluYWxseSA9IGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIik7XG5cbiAgICAgICAgICBpZiAoaGFzQ2F0Y2ggJiYgaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0NhdGNoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJ5IHN0YXRlbWVudCB3aXRob3V0IGNhdGNoIG9yIGZpbmFsbHlcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGFicnVwdDogZnVuY3Rpb24odHlwZSwgYXJnKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIikgJiZcbiAgICAgICAgICAgIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB2YXIgZmluYWxseUVudHJ5ID0gZW50cnk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSAmJlxuICAgICAgICAgICh0eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICAgdHlwZSA9PT0gXCJjb250aW51ZVwiKSAmJlxuICAgICAgICAgIGZpbmFsbHlFbnRyeS50cnlMb2MgPD0gYXJnICYmXG4gICAgICAgICAgYXJnIDw9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgIC8vIElnbm9yZSB0aGUgZmluYWxseSBlbnRyeSBpZiBjb250cm9sIGlzIG5vdCBqdW1waW5nIHRvIGFcbiAgICAgICAgLy8gbG9jYXRpb24gb3V0c2lkZSB0aGUgdHJ5L2NhdGNoIGJsb2NrLlxuICAgICAgICBmaW5hbGx5RW50cnkgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVjb3JkID0gZmluYWxseUVudHJ5ID8gZmluYWxseUVudHJ5LmNvbXBsZXRpb24gOiB7fTtcbiAgICAgIHJlY29yZC50eXBlID0gdHlwZTtcbiAgICAgIHJlY29yZC5hcmcgPSBhcmc7XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkpIHtcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2M7XG4gICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5jb21wbGV0ZShyZWNvcmQpO1xuICAgIH0sXG5cbiAgICBjb21wbGV0ZTogZnVuY3Rpb24ocmVjb3JkLCBhZnRlckxvYykge1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICByZWNvcmQudHlwZSA9PT0gXCJjb250aW51ZVwiKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IHJlY29yZC5hcmc7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInJldHVyblwiKSB7XG4gICAgICAgIHRoaXMucnZhbCA9IHRoaXMuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICB0aGlzLm5leHQgPSBcImVuZFwiO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIiAmJiBhZnRlckxvYykge1xuICAgICAgICB0aGlzLm5leHQgPSBhZnRlckxvYztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfSxcblxuICAgIGZpbmlzaDogZnVuY3Rpb24oZmluYWxseUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSB7XG4gICAgICAgICAgdGhpcy5jb21wbGV0ZShlbnRyeS5jb21wbGV0aW9uLCBlbnRyeS5hZnRlckxvYyk7XG4gICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgXCJjYXRjaFwiOiBmdW5jdGlvbih0cnlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSB0cnlMb2MpIHtcbiAgICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcbiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgdmFyIHRocm93biA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRocm93bjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUaGUgY29udGV4dC5jYXRjaCBtZXRob2QgbXVzdCBvbmx5IGJlIGNhbGxlZCB3aXRoIGEgbG9jYXRpb25cbiAgICAgIC8vIGFyZ3VtZW50IHRoYXQgY29ycmVzcG9uZHMgdG8gYSBrbm93biBjYXRjaCBibG9jay5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKTtcbiAgICB9LFxuXG4gICAgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24oaXRlcmFibGUsIHJlc3VsdE5hbWUsIG5leHRMb2MpIHtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSB7XG4gICAgICAgIGl0ZXJhdG9yOiB2YWx1ZXMoaXRlcmFibGUpLFxuICAgICAgICByZXN1bHROYW1lOiByZXN1bHROYW1lLFxuICAgICAgICBuZXh0TG9jOiBuZXh0TG9jXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgIC8vIERlbGliZXJhdGVseSBmb3JnZXQgdGhlIGxhc3Qgc2VudCB2YWx1ZSBzbyB0aGF0IHdlIGRvbid0XG4gICAgICAgIC8vIGFjY2lkZW50YWxseSBwYXNzIGl0IG9uIHRvIHRoZSBkZWxlZ2F0ZS5cbiAgICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cbiAgfTtcbn0pKFxuICAvLyBBbW9uZyB0aGUgdmFyaW91cyB0cmlja3MgZm9yIG9idGFpbmluZyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsXG4gIC8vIG9iamVjdCwgdGhpcyBzZWVtcyB0byBiZSB0aGUgbW9zdCByZWxpYWJsZSB0ZWNobmlxdWUgdGhhdCBkb2VzIG5vdFxuICAvLyB1c2UgaW5kaXJlY3QgZXZhbCAod2hpY2ggdmlvbGF0ZXMgQ29udGVudCBTZWN1cml0eSBQb2xpY3kpLlxuICB0eXBlb2YgZ2xvYmFsID09PSBcIm9iamVjdFwiID8gZ2xvYmFsIDpcbiAgdHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIiA/IHdpbmRvdyA6XG4gIHR5cGVvZiBzZWxmID09PSBcIm9iamVjdFwiID8gc2VsZiA6IHRoaXNcbik7XG4iLCIiLCIvKiFcbiAqIENyb3NzLUJyb3dzZXIgU3BsaXQgMS4xLjFcbiAqIENvcHlyaWdodCAyMDA3LTIwMTIgU3RldmVuIExldml0aGFuIDxzdGV2ZW5sZXZpdGhhbi5jb20+XG4gKiBBdmFpbGFibGUgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKiBFQ01BU2NyaXB0IGNvbXBsaWFudCwgdW5pZm9ybSBjcm9zcy1icm93c2VyIHNwbGl0IG1ldGhvZFxuICovXG5cbi8qKlxuICogU3BsaXRzIGEgc3RyaW5nIGludG8gYW4gYXJyYXkgb2Ygc3RyaW5ncyB1c2luZyBhIHJlZ2V4IG9yIHN0cmluZyBzZXBhcmF0b3IuIE1hdGNoZXMgb2YgdGhlXG4gKiBzZXBhcmF0b3IgYXJlIG5vdCBpbmNsdWRlZCBpbiB0aGUgcmVzdWx0IGFycmF5LiBIb3dldmVyLCBpZiBgc2VwYXJhdG9yYCBpcyBhIHJlZ2V4IHRoYXQgY29udGFpbnNcbiAqIGNhcHR1cmluZyBncm91cHMsIGJhY2tyZWZlcmVuY2VzIGFyZSBzcGxpY2VkIGludG8gdGhlIHJlc3VsdCBlYWNoIHRpbWUgYHNlcGFyYXRvcmAgaXMgbWF0Y2hlZC5cbiAqIEZpeGVzIGJyb3dzZXIgYnVncyBjb21wYXJlZCB0byB0aGUgbmF0aXZlIGBTdHJpbmcucHJvdG90eXBlLnNwbGl0YCBhbmQgY2FuIGJlIHVzZWQgcmVsaWFibHlcbiAqIGNyb3NzLWJyb3dzZXIuXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIFN0cmluZyB0byBzcGxpdC5cbiAqIEBwYXJhbSB7UmVnRXhwfFN0cmluZ30gc2VwYXJhdG9yIFJlZ2V4IG9yIHN0cmluZyB0byB1c2UgZm9yIHNlcGFyYXRpbmcgdGhlIHN0cmluZy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbbGltaXRdIE1heGltdW0gbnVtYmVyIG9mIGl0ZW1zIHRvIGluY2x1ZGUgaW4gdGhlIHJlc3VsdCBhcnJheS5cbiAqIEByZXR1cm5zIHtBcnJheX0gQXJyYXkgb2Ygc3Vic3RyaW5ncy5cbiAqIEBleGFtcGxlXG4gKlxuICogLy8gQmFzaWMgdXNlXG4gKiBzcGxpdCgnYSBiIGMgZCcsICcgJyk7XG4gKiAvLyAtPiBbJ2EnLCAnYicsICdjJywgJ2QnXVxuICpcbiAqIC8vIFdpdGggbGltaXRcbiAqIHNwbGl0KCdhIGIgYyBkJywgJyAnLCAyKTtcbiAqIC8vIC0+IFsnYScsICdiJ11cbiAqXG4gKiAvLyBCYWNrcmVmZXJlbmNlcyBpbiByZXN1bHQgYXJyYXlcbiAqIHNwbGl0KCcuLndvcmQxIHdvcmQyLi4nLCAvKFthLXpdKykoXFxkKykvaSk7XG4gKiAvLyAtPiBbJy4uJywgJ3dvcmQnLCAnMScsICcgJywgJ3dvcmQnLCAnMicsICcuLiddXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uIHNwbGl0KHVuZGVmKSB7XG5cbiAgdmFyIG5hdGl2ZVNwbGl0ID0gU3RyaW5nLnByb3RvdHlwZS5zcGxpdCxcbiAgICBjb21wbGlhbnRFeGVjTnBjZyA9IC8oKT8/Ly5leGVjKFwiXCIpWzFdID09PSB1bmRlZixcbiAgICAvLyBOUENHOiBub25wYXJ0aWNpcGF0aW5nIGNhcHR1cmluZyBncm91cFxuICAgIHNlbGY7XG5cbiAgc2VsZiA9IGZ1bmN0aW9uKHN0ciwgc2VwYXJhdG9yLCBsaW1pdCkge1xuICAgIC8vIElmIGBzZXBhcmF0b3JgIGlzIG5vdCBhIHJlZ2V4LCB1c2UgYG5hdGl2ZVNwbGl0YFxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc2VwYXJhdG9yKSAhPT0gXCJbb2JqZWN0IFJlZ0V4cF1cIikge1xuICAgICAgcmV0dXJuIG5hdGl2ZVNwbGl0LmNhbGwoc3RyLCBzZXBhcmF0b3IsIGxpbWl0KTtcbiAgICB9XG4gICAgdmFyIG91dHB1dCA9IFtdLFxuICAgICAgZmxhZ3MgPSAoc2VwYXJhdG9yLmlnbm9yZUNhc2UgPyBcImlcIiA6IFwiXCIpICsgKHNlcGFyYXRvci5tdWx0aWxpbmUgPyBcIm1cIiA6IFwiXCIpICsgKHNlcGFyYXRvci5leHRlbmRlZCA/IFwieFwiIDogXCJcIikgKyAvLyBQcm9wb3NlZCBmb3IgRVM2XG4gICAgICAoc2VwYXJhdG9yLnN0aWNreSA/IFwieVwiIDogXCJcIiksXG4gICAgICAvLyBGaXJlZm94IDMrXG4gICAgICBsYXN0TGFzdEluZGV4ID0gMCxcbiAgICAgIC8vIE1ha2UgYGdsb2JhbGAgYW5kIGF2b2lkIGBsYXN0SW5kZXhgIGlzc3VlcyBieSB3b3JraW5nIHdpdGggYSBjb3B5XG4gICAgICBzZXBhcmF0b3IgPSBuZXcgUmVnRXhwKHNlcGFyYXRvci5zb3VyY2UsIGZsYWdzICsgXCJnXCIpLFxuICAgICAgc2VwYXJhdG9yMiwgbWF0Y2gsIGxhc3RJbmRleCwgbGFzdExlbmd0aDtcbiAgICBzdHIgKz0gXCJcIjsgLy8gVHlwZS1jb252ZXJ0XG4gICAgaWYgKCFjb21wbGlhbnRFeGVjTnBjZykge1xuICAgICAgLy8gRG9lc24ndCBuZWVkIGZsYWdzIGd5LCBidXQgdGhleSBkb24ndCBodXJ0XG4gICAgICBzZXBhcmF0b3IyID0gbmV3IFJlZ0V4cChcIl5cIiArIHNlcGFyYXRvci5zb3VyY2UgKyBcIiQoPyFcXFxccylcIiwgZmxhZ3MpO1xuICAgIH1cbiAgICAvKiBWYWx1ZXMgZm9yIGBsaW1pdGAsIHBlciB0aGUgc3BlYzpcbiAgICAgKiBJZiB1bmRlZmluZWQ6IDQyOTQ5NjcyOTUgLy8gTWF0aC5wb3coMiwgMzIpIC0gMVxuICAgICAqIElmIDAsIEluZmluaXR5LCBvciBOYU46IDBcbiAgICAgKiBJZiBwb3NpdGl2ZSBudW1iZXI6IGxpbWl0ID0gTWF0aC5mbG9vcihsaW1pdCk7IGlmIChsaW1pdCA+IDQyOTQ5NjcyOTUpIGxpbWl0IC09IDQyOTQ5NjcyOTY7XG4gICAgICogSWYgbmVnYXRpdmUgbnVtYmVyOiA0Mjk0OTY3Mjk2IC0gTWF0aC5mbG9vcihNYXRoLmFicyhsaW1pdCkpXG4gICAgICogSWYgb3RoZXI6IFR5cGUtY29udmVydCwgdGhlbiB1c2UgdGhlIGFib3ZlIHJ1bGVzXG4gICAgICovXG4gICAgbGltaXQgPSBsaW1pdCA9PT0gdW5kZWYgPyAtMSA+Pj4gMCA6IC8vIE1hdGgucG93KDIsIDMyKSAtIDFcbiAgICBsaW1pdCA+Pj4gMDsgLy8gVG9VaW50MzIobGltaXQpXG4gICAgd2hpbGUgKG1hdGNoID0gc2VwYXJhdG9yLmV4ZWMoc3RyKSkge1xuICAgICAgLy8gYHNlcGFyYXRvci5sYXN0SW5kZXhgIGlzIG5vdCByZWxpYWJsZSBjcm9zcy1icm93c2VyXG4gICAgICBsYXN0SW5kZXggPSBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgIGlmIChsYXN0SW5kZXggPiBsYXN0TGFzdEluZGV4KSB7XG4gICAgICAgIG91dHB1dC5wdXNoKHN0ci5zbGljZShsYXN0TGFzdEluZGV4LCBtYXRjaC5pbmRleCkpO1xuICAgICAgICAvLyBGaXggYnJvd3NlcnMgd2hvc2UgYGV4ZWNgIG1ldGhvZHMgZG9uJ3QgY29uc2lzdGVudGx5IHJldHVybiBgdW5kZWZpbmVkYCBmb3JcbiAgICAgICAgLy8gbm9ucGFydGljaXBhdGluZyBjYXB0dXJpbmcgZ3JvdXBzXG4gICAgICAgIGlmICghY29tcGxpYW50RXhlY05wY2cgJiYgbWF0Y2gubGVuZ3RoID4gMSkge1xuICAgICAgICAgIG1hdGNoWzBdLnJlcGxhY2Uoc2VwYXJhdG9yMiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGggLSAyOyBpKyspIHtcbiAgICAgICAgICAgICAgaWYgKGFyZ3VtZW50c1tpXSA9PT0gdW5kZWYpIHtcbiAgICAgICAgICAgICAgICBtYXRjaFtpXSA9IHVuZGVmO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hdGNoLmxlbmd0aCA+IDEgJiYgbWF0Y2guaW5kZXggPCBzdHIubGVuZ3RoKSB7XG4gICAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkob3V0cHV0LCBtYXRjaC5zbGljZSgxKSk7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdExlbmd0aCA9IG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgbGFzdExhc3RJbmRleCA9IGxhc3RJbmRleDtcbiAgICAgICAgaWYgKG91dHB1dC5sZW5ndGggPj0gbGltaXQpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHNlcGFyYXRvci5sYXN0SW5kZXggPT09IG1hdGNoLmluZGV4KSB7XG4gICAgICAgIHNlcGFyYXRvci5sYXN0SW5kZXgrKzsgLy8gQXZvaWQgYW4gaW5maW5pdGUgbG9vcFxuICAgICAgfVxuICAgIH1cbiAgICBpZiAobGFzdExhc3RJbmRleCA9PT0gc3RyLmxlbmd0aCkge1xuICAgICAgaWYgKGxhc3RMZW5ndGggfHwgIXNlcGFyYXRvci50ZXN0KFwiXCIpKSB7XG4gICAgICAgIG91dHB1dC5wdXNoKFwiXCIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXQucHVzaChzdHIuc2xpY2UobGFzdExhc3RJbmRleCkpO1xuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0Lmxlbmd0aCA+IGxpbWl0ID8gb3V0cHV0LnNsaWNlKDAsIGxpbWl0KSA6IG91dHB1dDtcbiAgfTtcblxuICByZXR1cm4gc2VsZjtcbn0pKCk7XG4iLCIvLyBjb250YWlucywgYWRkLCByZW1vdmUsIHRvZ2dsZVxudmFyIGluZGV4b2YgPSByZXF1aXJlKCdpbmRleG9mJylcblxubW9kdWxlLmV4cG9ydHMgPSBDbGFzc0xpc3RcblxuZnVuY3Rpb24gQ2xhc3NMaXN0KGVsZW0pIHtcbiAgICB2YXIgY2wgPSBlbGVtLmNsYXNzTGlzdFxuXG4gICAgaWYgKGNsKSB7XG4gICAgICAgIHJldHVybiBjbFxuICAgIH1cblxuICAgIHZhciBjbGFzc0xpc3QgPSB7XG4gICAgICAgIGFkZDogYWRkXG4gICAgICAgICwgcmVtb3ZlOiByZW1vdmVcbiAgICAgICAgLCBjb250YWluczogY29udGFpbnNcbiAgICAgICAgLCB0b2dnbGU6IHRvZ2dsZVxuICAgICAgICAsIHRvU3RyaW5nOiAkdG9TdHJpbmdcbiAgICAgICAgLCBsZW5ndGg6IDBcbiAgICAgICAgLCBpdGVtOiBpdGVtXG4gICAgfVxuXG4gICAgcmV0dXJuIGNsYXNzTGlzdFxuXG4gICAgZnVuY3Rpb24gYWRkKHRva2VuKSB7XG4gICAgICAgIHZhciBsaXN0ID0gZ2V0VG9rZW5zKClcbiAgICAgICAgaWYgKGluZGV4b2YobGlzdCwgdG9rZW4pID4gLTEpIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIGxpc3QucHVzaCh0b2tlbilcbiAgICAgICAgc2V0VG9rZW5zKGxpc3QpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlKHRva2VuKSB7XG4gICAgICAgIHZhciBsaXN0ID0gZ2V0VG9rZW5zKClcbiAgICAgICAgICAgICwgaW5kZXggPSBpbmRleG9mKGxpc3QsIHRva2VuKVxuXG4gICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgbGlzdC5zcGxpY2UoaW5kZXgsIDEpXG4gICAgICAgIHNldFRva2VucyhsaXN0KVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbnRhaW5zKHRva2VuKSB7XG4gICAgICAgIHJldHVybiBpbmRleG9mKGdldFRva2VucygpLCB0b2tlbikgPiAtMVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvZ2dsZSh0b2tlbikge1xuICAgICAgICBpZiAoY29udGFpbnModG9rZW4pKSB7XG4gICAgICAgICAgICByZW1vdmUodG9rZW4pXG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFkZCh0b2tlbilcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiAkdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBlbGVtLmNsYXNzTmFtZVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGl0ZW0oaW5kZXgpIHtcbiAgICAgICAgdmFyIHRva2VucyA9IGdldFRva2VucygpXG4gICAgICAgIHJldHVybiB0b2tlbnNbaW5kZXhdIHx8IG51bGxcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRUb2tlbnMoKSB7XG4gICAgICAgIHZhciBjbGFzc05hbWUgPSBlbGVtLmNsYXNzTmFtZVxuXG4gICAgICAgIHJldHVybiBmaWx0ZXIoY2xhc3NOYW1lLnNwbGl0KFwiIFwiKSwgaXNUcnV0aHkpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0VG9rZW5zKGxpc3QpIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IGxpc3QubGVuZ3RoXG5cbiAgICAgICAgZWxlbS5jbGFzc05hbWUgPSBsaXN0LmpvaW4oXCIgXCIpXG4gICAgICAgIGNsYXNzTGlzdC5sZW5ndGggPSBsZW5ndGhcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNsYXNzTGlzdFtpXSA9IGxpc3RbaV1cbiAgICAgICAgfVxuXG4gICAgICAgIGRlbGV0ZSBsaXN0W2xlbmd0aF1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGZpbHRlciAoYXJyLCBmbikge1xuICAgIHZhciByZXQgPSBbXVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChmbihhcnJbaV0pKSByZXQucHVzaChhcnJbaV0pXG4gICAgfVxuICAgIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gaXNUcnV0aHkodmFsdWUpIHtcbiAgICByZXR1cm4gISF2YWx1ZVxufVxuIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9jb3JlLnJlZ2V4cC5lc2NhcGUnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLlJlZ0V4cC5lc2NhcGU7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAodHlwZW9mIGl0ICE9ICdmdW5jdGlvbicpIHRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGEgZnVuY3Rpb24hJyk7XG4gIHJldHVybiBpdDtcbn07XG4iLCJ2YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgbXNnKSB7XG4gIGlmICh0eXBlb2YgaXQgIT0gJ251bWJlcicgJiYgY29mKGl0KSAhPSAnTnVtYmVyJykgdGhyb3cgVHlwZUVycm9yKG1zZyk7XG4gIHJldHVybiAraXQ7XG59O1xuIiwiLy8gMjIuMS4zLjMxIEFycmF5LnByb3RvdHlwZVtAQHVuc2NvcGFibGVzXVxudmFyIFVOU0NPUEFCTEVTID0gcmVxdWlyZSgnLi9fd2tzJykoJ3Vuc2NvcGFibGVzJyk7XG52YXIgQXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcbmlmIChBcnJheVByb3RvW1VOU0NPUEFCTEVTXSA9PSB1bmRlZmluZWQpIHJlcXVpcmUoJy4vX2hpZGUnKShBcnJheVByb3RvLCBVTlNDT1BBQkxFUywge30pO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIEFycmF5UHJvdG9bVU5TQ09QQUJMRVNdW2tleV0gPSB0cnVlO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBDb25zdHJ1Y3RvciwgbmFtZSwgZm9yYmlkZGVuRmllbGQpIHtcbiAgaWYgKCEoaXQgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikgfHwgKGZvcmJpZGRlbkZpZWxkICE9PSB1bmRlZmluZWQgJiYgZm9yYmlkZGVuRmllbGQgaW4gaXQpKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKG5hbWUgKyAnOiBpbmNvcnJlY3QgaW52b2NhdGlvbiEnKTtcbiAgfSByZXR1cm4gaXQ7XG59O1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoIWlzT2JqZWN0KGl0KSkgdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYW4gb2JqZWN0IScpO1xuICByZXR1cm4gaXQ7XG59O1xuIiwiLy8gMjIuMS4zLjMgQXJyYXkucHJvdG90eXBlLmNvcHlXaXRoaW4odGFyZ2V0LCBzdGFydCwgZW5kID0gdGhpcy5sZW5ndGgpXG4ndXNlIHN0cmljdCc7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciB0b0Fic29sdXRlSW5kZXggPSByZXF1aXJlKCcuL190by1hYnNvbHV0ZS1pbmRleCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gW10uY29weVdpdGhpbiB8fCBmdW5jdGlvbiBjb3B5V2l0aGluKHRhcmdldCAvKiA9IDAgKi8sIHN0YXJ0IC8qID0gMCwgZW5kID0gQGxlbmd0aCAqLykge1xuICB2YXIgTyA9IHRvT2JqZWN0KHRoaXMpO1xuICB2YXIgbGVuID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICB2YXIgdG8gPSB0b0Fic29sdXRlSW5kZXgodGFyZ2V0LCBsZW4pO1xuICB2YXIgZnJvbSA9IHRvQWJzb2x1dGVJbmRleChzdGFydCwgbGVuKTtcbiAgdmFyIGVuZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkO1xuICB2YXIgY291bnQgPSBNYXRoLm1pbigoZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB0b0Fic29sdXRlSW5kZXgoZW5kLCBsZW4pKSAtIGZyb20sIGxlbiAtIHRvKTtcbiAgdmFyIGluYyA9IDE7XG4gIGlmIChmcm9tIDwgdG8gJiYgdG8gPCBmcm9tICsgY291bnQpIHtcbiAgICBpbmMgPSAtMTtcbiAgICBmcm9tICs9IGNvdW50IC0gMTtcbiAgICB0byArPSBjb3VudCAtIDE7XG4gIH1cbiAgd2hpbGUgKGNvdW50LS0gPiAwKSB7XG4gICAgaWYgKGZyb20gaW4gTykgT1t0b10gPSBPW2Zyb21dO1xuICAgIGVsc2UgZGVsZXRlIE9bdG9dO1xuICAgIHRvICs9IGluYztcbiAgICBmcm9tICs9IGluYztcbiAgfSByZXR1cm4gTztcbn07XG4iLCIvLyAyMi4xLjMuNiBBcnJheS5wcm90b3R5cGUuZmlsbCh2YWx1ZSwgc3RhcnQgPSAwLCBlbmQgPSB0aGlzLmxlbmd0aClcbid1c2Ugc3RyaWN0JztcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyIHRvQWJzb2x1dGVJbmRleCA9IHJlcXVpcmUoJy4vX3RvLWFic29sdXRlLWluZGV4Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZmlsbCh2YWx1ZSAvKiAsIHN0YXJ0ID0gMCwgZW5kID0gQGxlbmd0aCAqLykge1xuICB2YXIgTyA9IHRvT2JqZWN0KHRoaXMpO1xuICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICB2YXIgYUxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHZhciBpbmRleCA9IHRvQWJzb2x1dGVJbmRleChhTGVuID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCwgbGVuZ3RoKTtcbiAgdmFyIGVuZCA9IGFMZW4gPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkO1xuICB2YXIgZW5kUG9zID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW5ndGggOiB0b0Fic29sdXRlSW5kZXgoZW5kLCBsZW5ndGgpO1xuICB3aGlsZSAoZW5kUG9zID4gaW5kZXgpIE9baW5kZXgrK10gPSB2YWx1ZTtcbiAgcmV0dXJuIE87XG59O1xuIiwidmFyIGZvck9mID0gcmVxdWlyZSgnLi9fZm9yLW9mJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0ZXIsIElURVJBVE9SKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yT2YoaXRlciwgZmFsc2UsIHJlc3VsdC5wdXNoLCByZXN1bHQsIElURVJBVE9SKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG4iLCIvLyBmYWxzZSAtPiBBcnJheSNpbmRleE9mXG4vLyB0cnVlICAtPiBBcnJheSNpbmNsdWRlc1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIHRvQWJzb2x1dGVJbmRleCA9IHJlcXVpcmUoJy4vX3RvLWFic29sdXRlLWluZGV4Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChJU19JTkNMVURFUykge1xuICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzLCBlbCwgZnJvbUluZGV4KSB7XG4gICAgdmFyIE8gPSB0b0lPYmplY3QoJHRoaXMpO1xuICAgIHZhciBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gICAgdmFyIGluZGV4ID0gdG9BYnNvbHV0ZUluZGV4KGZyb21JbmRleCwgbGVuZ3RoKTtcbiAgICB2YXIgdmFsdWU7XG4gICAgLy8gQXJyYXkjaW5jbHVkZXMgdXNlcyBTYW1lVmFsdWVaZXJvIGVxdWFsaXR5IGFsZ29yaXRobVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICBpZiAoSVNfSU5DTFVERVMgJiYgZWwgIT0gZWwpIHdoaWxlIChsZW5ndGggPiBpbmRleCkge1xuICAgICAgdmFsdWUgPSBPW2luZGV4KytdO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgICAgaWYgKHZhbHVlICE9IHZhbHVlKSByZXR1cm4gdHJ1ZTtcbiAgICAvLyBBcnJheSNpbmRleE9mIGlnbm9yZXMgaG9sZXMsIEFycmF5I2luY2x1ZGVzIC0gbm90XG4gICAgfSBlbHNlIGZvciAoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKSBpZiAoSVNfSU5DTFVERVMgfHwgaW5kZXggaW4gTykge1xuICAgICAgaWYgKE9baW5kZXhdID09PSBlbCkgcmV0dXJuIElTX0lOQ0xVREVTIHx8IGluZGV4IHx8IDA7XG4gICAgfSByZXR1cm4gIUlTX0lOQ0xVREVTICYmIC0xO1xuICB9O1xufTtcbiIsIi8vIDAgLT4gQXJyYXkjZm9yRWFjaFxuLy8gMSAtPiBBcnJheSNtYXBcbi8vIDIgLT4gQXJyYXkjZmlsdGVyXG4vLyAzIC0+IEFycmF5I3NvbWVcbi8vIDQgLT4gQXJyYXkjZXZlcnlcbi8vIDUgLT4gQXJyYXkjZmluZFxuLy8gNiAtPiBBcnJheSNmaW5kSW5kZXhcbnZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciBJT2JqZWN0ID0gcmVxdWlyZSgnLi9faW9iamVjdCcpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciBhc2MgPSByZXF1aXJlKCcuL19hcnJheS1zcGVjaWVzLWNyZWF0ZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoVFlQRSwgJGNyZWF0ZSkge1xuICB2YXIgSVNfTUFQID0gVFlQRSA9PSAxO1xuICB2YXIgSVNfRklMVEVSID0gVFlQRSA9PSAyO1xuICB2YXIgSVNfU09NRSA9IFRZUEUgPT0gMztcbiAgdmFyIElTX0VWRVJZID0gVFlQRSA9PSA0O1xuICB2YXIgSVNfRklORF9JTkRFWCA9IFRZUEUgPT0gNjtcbiAgdmFyIE5PX0hPTEVTID0gVFlQRSA9PSA1IHx8IElTX0ZJTkRfSU5ERVg7XG4gIHZhciBjcmVhdGUgPSAkY3JlYXRlIHx8IGFzYztcbiAgcmV0dXJuIGZ1bmN0aW9uICgkdGhpcywgY2FsbGJhY2tmbiwgdGhhdCkge1xuICAgIHZhciBPID0gdG9PYmplY3QoJHRoaXMpO1xuICAgIHZhciBzZWxmID0gSU9iamVjdChPKTtcbiAgICB2YXIgZiA9IGN0eChjYWxsYmFja2ZuLCB0aGF0LCAzKTtcbiAgICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgoc2VsZi5sZW5ndGgpO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIHJlc3VsdCA9IElTX01BUCA/IGNyZWF0ZSgkdGhpcywgbGVuZ3RoKSA6IElTX0ZJTFRFUiA/IGNyZWF0ZSgkdGhpcywgMCkgOiB1bmRlZmluZWQ7XG4gICAgdmFyIHZhbCwgcmVzO1xuICAgIGZvciAoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKSBpZiAoTk9fSE9MRVMgfHwgaW5kZXggaW4gc2VsZikge1xuICAgICAgdmFsID0gc2VsZltpbmRleF07XG4gICAgICByZXMgPSBmKHZhbCwgaW5kZXgsIE8pO1xuICAgICAgaWYgKFRZUEUpIHtcbiAgICAgICAgaWYgKElTX01BUCkgcmVzdWx0W2luZGV4XSA9IHJlczsgICAvLyBtYXBcbiAgICAgICAgZWxzZSBpZiAocmVzKSBzd2l0Y2ggKFRZUEUpIHtcbiAgICAgICAgICBjYXNlIDM6IHJldHVybiB0cnVlOyAgICAgICAgICAgICAvLyBzb21lXG4gICAgICAgICAgY2FzZSA1OiByZXR1cm4gdmFsOyAgICAgICAgICAgICAgLy8gZmluZFxuICAgICAgICAgIGNhc2UgNjogcmV0dXJuIGluZGV4OyAgICAgICAgICAgIC8vIGZpbmRJbmRleFxuICAgICAgICAgIGNhc2UgMjogcmVzdWx0LnB1c2godmFsKTsgICAgICAgIC8vIGZpbHRlclxuICAgICAgICB9IGVsc2UgaWYgKElTX0VWRVJZKSByZXR1cm4gZmFsc2U7IC8vIGV2ZXJ5XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBJU19GSU5EX0lOREVYID8gLTEgOiBJU19TT01FIHx8IElTX0VWRVJZID8gSVNfRVZFUlkgOiByZXN1bHQ7XG4gIH07XG59O1xuIiwidmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyIElPYmplY3QgPSByZXF1aXJlKCcuL19pb2JqZWN0Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodGhhdCwgY2FsbGJhY2tmbiwgYUxlbiwgbWVtbywgaXNSaWdodCkge1xuICBhRnVuY3Rpb24oY2FsbGJhY2tmbik7XG4gIHZhciBPID0gdG9PYmplY3QodGhhdCk7XG4gIHZhciBzZWxmID0gSU9iamVjdChPKTtcbiAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgdmFyIGluZGV4ID0gaXNSaWdodCA/IGxlbmd0aCAtIDEgOiAwO1xuICB2YXIgaSA9IGlzUmlnaHQgPyAtMSA6IDE7XG4gIGlmIChhTGVuIDwgMikgZm9yICg7Oykge1xuICAgIGlmIChpbmRleCBpbiBzZWxmKSB7XG4gICAgICBtZW1vID0gc2VsZltpbmRleF07XG4gICAgICBpbmRleCArPSBpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGluZGV4ICs9IGk7XG4gICAgaWYgKGlzUmlnaHQgPyBpbmRleCA8IDAgOiBsZW5ndGggPD0gaW5kZXgpIHtcbiAgICAgIHRocm93IFR5cGVFcnJvcignUmVkdWNlIG9mIGVtcHR5IGFycmF5IHdpdGggbm8gaW5pdGlhbCB2YWx1ZScpO1xuICAgIH1cbiAgfVxuICBmb3IgKDtpc1JpZ2h0ID8gaW5kZXggPj0gMCA6IGxlbmd0aCA+IGluZGV4OyBpbmRleCArPSBpKSBpZiAoaW5kZXggaW4gc2VsZikge1xuICAgIG1lbW8gPSBjYWxsYmFja2ZuKG1lbW8sIHNlbGZbaW5kZXhdLCBpbmRleCwgTyk7XG4gIH1cbiAgcmV0dXJuIG1lbW87XG59O1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJy4vX2lzLWFycmF5Jyk7XG52YXIgU1BFQ0lFUyA9IHJlcXVpcmUoJy4vX3drcycpKCdzcGVjaWVzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9yaWdpbmFsKSB7XG4gIHZhciBDO1xuICBpZiAoaXNBcnJheShvcmlnaW5hbCkpIHtcbiAgICBDID0gb3JpZ2luYWwuY29uc3RydWN0b3I7XG4gICAgLy8gY3Jvc3MtcmVhbG0gZmFsbGJhY2tcbiAgICBpZiAodHlwZW9mIEMgPT0gJ2Z1bmN0aW9uJyAmJiAoQyA9PT0gQXJyYXkgfHwgaXNBcnJheShDLnByb3RvdHlwZSkpKSBDID0gdW5kZWZpbmVkO1xuICAgIGlmIChpc09iamVjdChDKSkge1xuICAgICAgQyA9IENbU1BFQ0lFU107XG4gICAgICBpZiAoQyA9PT0gbnVsbCkgQyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0gcmV0dXJuIEMgPT09IHVuZGVmaW5lZCA/IEFycmF5IDogQztcbn07XG4iLCIvLyA5LjQuMi4zIEFycmF5U3BlY2llc0NyZWF0ZShvcmlnaW5hbEFycmF5LCBsZW5ndGgpXG52YXIgc3BlY2llc0NvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi9fYXJyYXktc3BlY2llcy1jb25zdHJ1Y3RvcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvcmlnaW5hbCwgbGVuZ3RoKSB7XG4gIHJldHVybiBuZXcgKHNwZWNpZXNDb25zdHJ1Y3RvcihvcmlnaW5hbCkpKGxlbmd0aCk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGludm9rZSA9IHJlcXVpcmUoJy4vX2ludm9rZScpO1xudmFyIGFycmF5U2xpY2UgPSBbXS5zbGljZTtcbnZhciBmYWN0b3JpZXMgPSB7fTtcblxudmFyIGNvbnN0cnVjdCA9IGZ1bmN0aW9uIChGLCBsZW4sIGFyZ3MpIHtcbiAgaWYgKCEobGVuIGluIGZhY3RvcmllcykpIHtcbiAgICBmb3IgKHZhciBuID0gW10sIGkgPSAwOyBpIDwgbGVuOyBpKyspIG5baV0gPSAnYVsnICsgaSArICddJztcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LWZ1bmNcbiAgICBmYWN0b3JpZXNbbGVuXSA9IEZ1bmN0aW9uKCdGLGEnLCAncmV0dXJuIG5ldyBGKCcgKyBuLmpvaW4oJywnKSArICcpJyk7XG4gIH0gcmV0dXJuIGZhY3Rvcmllc1tsZW5dKEYsIGFyZ3MpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBGdW5jdGlvbi5iaW5kIHx8IGZ1bmN0aW9uIGJpbmQodGhhdCAvKiAsIC4uLmFyZ3MgKi8pIHtcbiAgdmFyIGZuID0gYUZ1bmN0aW9uKHRoaXMpO1xuICB2YXIgcGFydEFyZ3MgPSBhcnJheVNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgdmFyIGJvdW5kID0gZnVuY3Rpb24gKC8qIGFyZ3MuLi4gKi8pIHtcbiAgICB2YXIgYXJncyA9IHBhcnRBcmdzLmNvbmNhdChhcnJheVNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG4gICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBib3VuZCA/IGNvbnN0cnVjdChmbiwgYXJncy5sZW5ndGgsIGFyZ3MpIDogaW52b2tlKGZuLCBhcmdzLCB0aGF0KTtcbiAgfTtcbiAgaWYgKGlzT2JqZWN0KGZuLnByb3RvdHlwZSkpIGJvdW5kLnByb3RvdHlwZSA9IGZuLnByb3RvdHlwZTtcbiAgcmV0dXJuIGJvdW5kO1xufTtcbiIsIi8vIGdldHRpbmcgdGFnIGZyb20gMTkuMS4zLjYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZygpXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG52YXIgVEFHID0gcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJyk7XG4vLyBFUzMgd3JvbmcgaGVyZVxudmFyIEFSRyA9IGNvZihmdW5jdGlvbiAoKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPT0gJ0FyZ3VtZW50cyc7XG5cbi8vIGZhbGxiYWNrIGZvciBJRTExIFNjcmlwdCBBY2Nlc3MgRGVuaWVkIGVycm9yXG52YXIgdHJ5R2V0ID0gZnVuY3Rpb24gKGl0LCBrZXkpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gaXRba2V5XTtcbiAgfSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgTywgVCwgQjtcbiAgcmV0dXJuIGl0ID09PSB1bmRlZmluZWQgPyAnVW5kZWZpbmVkJyA6IGl0ID09PSBudWxsID8gJ051bGwnXG4gICAgLy8gQEB0b1N0cmluZ1RhZyBjYXNlXG4gICAgOiB0eXBlb2YgKFQgPSB0cnlHZXQoTyA9IE9iamVjdChpdCksIFRBRykpID09ICdzdHJpbmcnID8gVFxuICAgIC8vIGJ1aWx0aW5UYWcgY2FzZVxuICAgIDogQVJHID8gY29mKE8pXG4gICAgLy8gRVMzIGFyZ3VtZW50cyBmYWxsYmFja1xuICAgIDogKEIgPSBjb2YoTykpID09ICdPYmplY3QnICYmIHR5cGVvZiBPLmNhbGxlZSA9PSAnZnVuY3Rpb24nID8gJ0FyZ3VtZW50cycgOiBCO1xufTtcbiIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChpdCkuc2xpY2UoOCwgLTEpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG52YXIgY3JlYXRlID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpO1xudmFyIHJlZGVmaW5lQWxsID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUtYWxsJyk7XG52YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG52YXIgYW5JbnN0YW5jZSA9IHJlcXVpcmUoJy4vX2FuLWluc3RhbmNlJyk7XG52YXIgZm9yT2YgPSByZXF1aXJlKCcuL19mb3Itb2YnKTtcbnZhciAkaXRlckRlZmluZSA9IHJlcXVpcmUoJy4vX2l0ZXItZGVmaW5lJyk7XG52YXIgc3RlcCA9IHJlcXVpcmUoJy4vX2l0ZXItc3RlcCcpO1xudmFyIHNldFNwZWNpZXMgPSByZXF1aXJlKCcuL19zZXQtc3BlY2llcycpO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKTtcbnZhciBmYXN0S2V5ID0gcmVxdWlyZSgnLi9fbWV0YScpLmZhc3RLZXk7XG52YXIgdmFsaWRhdGUgPSByZXF1aXJlKCcuL192YWxpZGF0ZS1jb2xsZWN0aW9uJyk7XG52YXIgU0laRSA9IERFU0NSSVBUT1JTID8gJ19zJyA6ICdzaXplJztcblxudmFyIGdldEVudHJ5ID0gZnVuY3Rpb24gKHRoYXQsIGtleSkge1xuICAvLyBmYXN0IGNhc2VcbiAgdmFyIGluZGV4ID0gZmFzdEtleShrZXkpO1xuICB2YXIgZW50cnk7XG4gIGlmIChpbmRleCAhPT0gJ0YnKSByZXR1cm4gdGhhdC5faVtpbmRleF07XG4gIC8vIGZyb3plbiBvYmplY3QgY2FzZVxuICBmb3IgKGVudHJ5ID0gdGhhdC5fZjsgZW50cnk7IGVudHJ5ID0gZW50cnkubikge1xuICAgIGlmIChlbnRyeS5rID09IGtleSkgcmV0dXJuIGVudHJ5O1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ2V0Q29uc3RydWN0b3I6IGZ1bmN0aW9uICh3cmFwcGVyLCBOQU1FLCBJU19NQVAsIEFEREVSKSB7XG4gICAgdmFyIEMgPSB3cmFwcGVyKGZ1bmN0aW9uICh0aGF0LCBpdGVyYWJsZSkge1xuICAgICAgYW5JbnN0YW5jZSh0aGF0LCBDLCBOQU1FLCAnX2knKTtcbiAgICAgIHRoYXQuX3QgPSBOQU1FOyAgICAgICAgIC8vIGNvbGxlY3Rpb24gdHlwZVxuICAgICAgdGhhdC5faSA9IGNyZWF0ZShudWxsKTsgLy8gaW5kZXhcbiAgICAgIHRoYXQuX2YgPSB1bmRlZmluZWQ7ICAgIC8vIGZpcnN0IGVudHJ5XG4gICAgICB0aGF0Ll9sID0gdW5kZWZpbmVkOyAgICAvLyBsYXN0IGVudHJ5XG4gICAgICB0aGF0W1NJWkVdID0gMDsgICAgICAgICAvLyBzaXplXG4gICAgICBpZiAoaXRlcmFibGUgIT0gdW5kZWZpbmVkKSBmb3JPZihpdGVyYWJsZSwgSVNfTUFQLCB0aGF0W0FEREVSXSwgdGhhdCk7XG4gICAgfSk7XG4gICAgcmVkZWZpbmVBbGwoQy5wcm90b3R5cGUsIHtcbiAgICAgIC8vIDIzLjEuMy4xIE1hcC5wcm90b3R5cGUuY2xlYXIoKVxuICAgICAgLy8gMjMuMi4zLjIgU2V0LnByb3RvdHlwZS5jbGVhcigpXG4gICAgICBjbGVhcjogZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICAgIGZvciAodmFyIHRoYXQgPSB2YWxpZGF0ZSh0aGlzLCBOQU1FKSwgZGF0YSA9IHRoYXQuX2ksIGVudHJ5ID0gdGhhdC5fZjsgZW50cnk7IGVudHJ5ID0gZW50cnkubikge1xuICAgICAgICAgIGVudHJ5LnIgPSB0cnVlO1xuICAgICAgICAgIGlmIChlbnRyeS5wKSBlbnRyeS5wID0gZW50cnkucC5uID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGRlbGV0ZSBkYXRhW2VudHJ5LmldO1xuICAgICAgICB9XG4gICAgICAgIHRoYXQuX2YgPSB0aGF0Ll9sID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGF0W1NJWkVdID0gMDtcbiAgICAgIH0sXG4gICAgICAvLyAyMy4xLjMuMyBNYXAucHJvdG90eXBlLmRlbGV0ZShrZXkpXG4gICAgICAvLyAyMy4yLjMuNCBTZXQucHJvdG90eXBlLmRlbGV0ZSh2YWx1ZSlcbiAgICAgICdkZWxldGUnOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciB0aGF0ID0gdmFsaWRhdGUodGhpcywgTkFNRSk7XG4gICAgICAgIHZhciBlbnRyeSA9IGdldEVudHJ5KHRoYXQsIGtleSk7XG4gICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgIHZhciBuZXh0ID0gZW50cnkubjtcbiAgICAgICAgICB2YXIgcHJldiA9IGVudHJ5LnA7XG4gICAgICAgICAgZGVsZXRlIHRoYXQuX2lbZW50cnkuaV07XG4gICAgICAgICAgZW50cnkuciA9IHRydWU7XG4gICAgICAgICAgaWYgKHByZXYpIHByZXYubiA9IG5leHQ7XG4gICAgICAgICAgaWYgKG5leHQpIG5leHQucCA9IHByZXY7XG4gICAgICAgICAgaWYgKHRoYXQuX2YgPT0gZW50cnkpIHRoYXQuX2YgPSBuZXh0O1xuICAgICAgICAgIGlmICh0aGF0Ll9sID09IGVudHJ5KSB0aGF0Ll9sID0gcHJldjtcbiAgICAgICAgICB0aGF0W1NJWkVdLS07XG4gICAgICAgIH0gcmV0dXJuICEhZW50cnk7XG4gICAgICB9LFxuICAgICAgLy8gMjMuMi4zLjYgU2V0LnByb3RvdHlwZS5mb3JFYWNoKGNhbGxiYWNrZm4sIHRoaXNBcmcgPSB1bmRlZmluZWQpXG4gICAgICAvLyAyMy4xLjMuNSBNYXAucHJvdG90eXBlLmZvckVhY2goY2FsbGJhY2tmbiwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbiAgICAgIGZvckVhY2g6IGZ1bmN0aW9uIGZvckVhY2goY2FsbGJhY2tmbiAvKiAsIHRoYXQgPSB1bmRlZmluZWQgKi8pIHtcbiAgICAgICAgdmFsaWRhdGUodGhpcywgTkFNRSk7XG4gICAgICAgIHZhciBmID0gY3R4KGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkLCAzKTtcbiAgICAgICAgdmFyIGVudHJ5O1xuICAgICAgICB3aGlsZSAoZW50cnkgPSBlbnRyeSA/IGVudHJ5Lm4gOiB0aGlzLl9mKSB7XG4gICAgICAgICAgZihlbnRyeS52LCBlbnRyeS5rLCB0aGlzKTtcbiAgICAgICAgICAvLyByZXZlcnQgdG8gdGhlIGxhc3QgZXhpc3RpbmcgZW50cnlcbiAgICAgICAgICB3aGlsZSAoZW50cnkgJiYgZW50cnkucikgZW50cnkgPSBlbnRyeS5wO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gMjMuMS4zLjcgTWFwLnByb3RvdHlwZS5oYXMoa2V5KVxuICAgICAgLy8gMjMuMi4zLjcgU2V0LnByb3RvdHlwZS5oYXModmFsdWUpXG4gICAgICBoYXM6IGZ1bmN0aW9uIGhhcyhrZXkpIHtcbiAgICAgICAgcmV0dXJuICEhZ2V0RW50cnkodmFsaWRhdGUodGhpcywgTkFNRSksIGtleSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKERFU0NSSVBUT1JTKSBkUChDLnByb3RvdHlwZSwgJ3NpemUnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlKHRoaXMsIE5BTUUpW1NJWkVdO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBDO1xuICB9LFxuICBkZWY6IGZ1bmN0aW9uICh0aGF0LCBrZXksIHZhbHVlKSB7XG4gICAgdmFyIGVudHJ5ID0gZ2V0RW50cnkodGhhdCwga2V5KTtcbiAgICB2YXIgcHJldiwgaW5kZXg7XG4gICAgLy8gY2hhbmdlIGV4aXN0aW5nIGVudHJ5XG4gICAgaWYgKGVudHJ5KSB7XG4gICAgICBlbnRyeS52ID0gdmFsdWU7XG4gICAgLy8gY3JlYXRlIG5ldyBlbnRyeVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGF0Ll9sID0gZW50cnkgPSB7XG4gICAgICAgIGk6IGluZGV4ID0gZmFzdEtleShrZXksIHRydWUpLCAvLyA8LSBpbmRleFxuICAgICAgICBrOiBrZXksICAgICAgICAgICAgICAgICAgICAgICAgLy8gPC0ga2V5XG4gICAgICAgIHY6IHZhbHVlLCAgICAgICAgICAgICAgICAgICAgICAvLyA8LSB2YWx1ZVxuICAgICAgICBwOiBwcmV2ID0gdGhhdC5fbCwgICAgICAgICAgICAgLy8gPC0gcHJldmlvdXMgZW50cnlcbiAgICAgICAgbjogdW5kZWZpbmVkLCAgICAgICAgICAgICAgICAgIC8vIDwtIG5leHQgZW50cnlcbiAgICAgICAgcjogZmFsc2UgICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIHJlbW92ZWRcbiAgICAgIH07XG4gICAgICBpZiAoIXRoYXQuX2YpIHRoYXQuX2YgPSBlbnRyeTtcbiAgICAgIGlmIChwcmV2KSBwcmV2Lm4gPSBlbnRyeTtcbiAgICAgIHRoYXRbU0laRV0rKztcbiAgICAgIC8vIGFkZCB0byBpbmRleFxuICAgICAgaWYgKGluZGV4ICE9PSAnRicpIHRoYXQuX2lbaW5kZXhdID0gZW50cnk7XG4gICAgfSByZXR1cm4gdGhhdDtcbiAgfSxcbiAgZ2V0RW50cnk6IGdldEVudHJ5LFxuICBzZXRTdHJvbmc6IGZ1bmN0aW9uIChDLCBOQU1FLCBJU19NQVApIHtcbiAgICAvLyBhZGQgLmtleXMsIC52YWx1ZXMsIC5lbnRyaWVzLCBbQEBpdGVyYXRvcl1cbiAgICAvLyAyMy4xLjMuNCwgMjMuMS4zLjgsIDIzLjEuMy4xMSwgMjMuMS4zLjEyLCAyMy4yLjMuNSwgMjMuMi4zLjgsIDIzLjIuMy4xMCwgMjMuMi4zLjExXG4gICAgJGl0ZXJEZWZpbmUoQywgTkFNRSwgZnVuY3Rpb24gKGl0ZXJhdGVkLCBraW5kKSB7XG4gICAgICB0aGlzLl90ID0gdmFsaWRhdGUoaXRlcmF0ZWQsIE5BTUUpOyAvLyB0YXJnZXRcbiAgICAgIHRoaXMuX2sgPSBraW5kOyAgICAgICAgICAgICAgICAgICAgIC8vIGtpbmRcbiAgICAgIHRoaXMuX2wgPSB1bmRlZmluZWQ7ICAgICAgICAgICAgICAgIC8vIHByZXZpb3VzXG4gICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgdmFyIGtpbmQgPSB0aGF0Ll9rO1xuICAgICAgdmFyIGVudHJ5ID0gdGhhdC5fbDtcbiAgICAgIC8vIHJldmVydCB0byB0aGUgbGFzdCBleGlzdGluZyBlbnRyeVxuICAgICAgd2hpbGUgKGVudHJ5ICYmIGVudHJ5LnIpIGVudHJ5ID0gZW50cnkucDtcbiAgICAgIC8vIGdldCBuZXh0IGVudHJ5XG4gICAgICBpZiAoIXRoYXQuX3QgfHwgISh0aGF0Ll9sID0gZW50cnkgPSBlbnRyeSA/IGVudHJ5Lm4gOiB0aGF0Ll90Ll9mKSkge1xuICAgICAgICAvLyBvciBmaW5pc2ggdGhlIGl0ZXJhdGlvblxuICAgICAgICB0aGF0Ll90ID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gc3RlcCgxKTtcbiAgICAgIH1cbiAgICAgIC8vIHJldHVybiBzdGVwIGJ5IGtpbmRcbiAgICAgIGlmIChraW5kID09ICdrZXlzJykgcmV0dXJuIHN0ZXAoMCwgZW50cnkuayk7XG4gICAgICBpZiAoa2luZCA9PSAndmFsdWVzJykgcmV0dXJuIHN0ZXAoMCwgZW50cnkudik7XG4gICAgICByZXR1cm4gc3RlcCgwLCBbZW50cnkuaywgZW50cnkudl0pO1xuICAgIH0sIElTX01BUCA/ICdlbnRyaWVzJyA6ICd2YWx1ZXMnLCAhSVNfTUFQLCB0cnVlKTtcblxuICAgIC8vIGFkZCBbQEBzcGVjaWVzXSwgMjMuMS4yLjIsIDIzLjIuMi4yXG4gICAgc2V0U3BlY2llcyhOQU1FKTtcbiAgfVxufTtcbiIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9EYXZpZEJydWFudC9NYXAtU2V0LnByb3RvdHlwZS50b0pTT05cbnZhciBjbGFzc29mID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpO1xudmFyIGZyb20gPSByZXF1aXJlKCcuL19hcnJheS1mcm9tLWl0ZXJhYmxlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChOQU1FKSB7XG4gIHJldHVybiBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgaWYgKGNsYXNzb2YodGhpcykgIT0gTkFNRSkgdGhyb3cgVHlwZUVycm9yKE5BTUUgKyBcIiN0b0pTT04gaXNuJ3QgZ2VuZXJpY1wiKTtcbiAgICByZXR1cm4gZnJvbSh0aGlzKTtcbiAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgcmVkZWZpbmVBbGwgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKTtcbnZhciBnZXRXZWFrID0gcmVxdWlyZSgnLi9fbWV0YScpLmdldFdlYWs7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGFuSW5zdGFuY2UgPSByZXF1aXJlKCcuL19hbi1pbnN0YW5jZScpO1xudmFyIGZvck9mID0gcmVxdWlyZSgnLi9fZm9yLW9mJyk7XG52YXIgY3JlYXRlQXJyYXlNZXRob2QgPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJyk7XG52YXIgJGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIHZhbGlkYXRlID0gcmVxdWlyZSgnLi9fdmFsaWRhdGUtY29sbGVjdGlvbicpO1xudmFyIGFycmF5RmluZCA9IGNyZWF0ZUFycmF5TWV0aG9kKDUpO1xudmFyIGFycmF5RmluZEluZGV4ID0gY3JlYXRlQXJyYXlNZXRob2QoNik7XG52YXIgaWQgPSAwO1xuXG4vLyBmYWxsYmFjayBmb3IgdW5jYXVnaHQgZnJvemVuIGtleXNcbnZhciB1bmNhdWdodEZyb3plblN0b3JlID0gZnVuY3Rpb24gKHRoYXQpIHtcbiAgcmV0dXJuIHRoYXQuX2wgfHwgKHRoYXQuX2wgPSBuZXcgVW5jYXVnaHRGcm96ZW5TdG9yZSgpKTtcbn07XG52YXIgVW5jYXVnaHRGcm96ZW5TdG9yZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5hID0gW107XG59O1xudmFyIGZpbmRVbmNhdWdodEZyb3plbiA9IGZ1bmN0aW9uIChzdG9yZSwga2V5KSB7XG4gIHJldHVybiBhcnJheUZpbmQoc3RvcmUuYSwgZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIGl0WzBdID09PSBrZXk7XG4gIH0pO1xufTtcblVuY2F1Z2h0RnJvemVuU3RvcmUucHJvdG90eXBlID0ge1xuICBnZXQ6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgZW50cnkgPSBmaW5kVW5jYXVnaHRGcm96ZW4odGhpcywga2V5KTtcbiAgICBpZiAoZW50cnkpIHJldHVybiBlbnRyeVsxXTtcbiAgfSxcbiAgaGFzOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuICEhZmluZFVuY2F1Z2h0RnJvemVuKHRoaXMsIGtleSk7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICB2YXIgZW50cnkgPSBmaW5kVW5jYXVnaHRGcm96ZW4odGhpcywga2V5KTtcbiAgICBpZiAoZW50cnkpIGVudHJ5WzFdID0gdmFsdWU7XG4gICAgZWxzZSB0aGlzLmEucHVzaChba2V5LCB2YWx1ZV0pO1xuICB9LFxuICAnZGVsZXRlJzogZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciBpbmRleCA9IGFycmF5RmluZEluZGV4KHRoaXMuYSwgZnVuY3Rpb24gKGl0KSB7XG4gICAgICByZXR1cm4gaXRbMF0gPT09IGtleTtcbiAgICB9KTtcbiAgICBpZiAofmluZGV4KSB0aGlzLmEuc3BsaWNlKGluZGV4LCAxKTtcbiAgICByZXR1cm4gISF+aW5kZXg7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBnZXRDb25zdHJ1Y3RvcjogZnVuY3Rpb24gKHdyYXBwZXIsIE5BTUUsIElTX01BUCwgQURERVIpIHtcbiAgICB2YXIgQyA9IHdyYXBwZXIoZnVuY3Rpb24gKHRoYXQsIGl0ZXJhYmxlKSB7XG4gICAgICBhbkluc3RhbmNlKHRoYXQsIEMsIE5BTUUsICdfaScpO1xuICAgICAgdGhhdC5fdCA9IE5BTUU7ICAgICAgLy8gY29sbGVjdGlvbiB0eXBlXG4gICAgICB0aGF0Ll9pID0gaWQrKzsgICAgICAvLyBjb2xsZWN0aW9uIGlkXG4gICAgICB0aGF0Ll9sID0gdW5kZWZpbmVkOyAvLyBsZWFrIHN0b3JlIGZvciB1bmNhdWdodCBmcm96ZW4gb2JqZWN0c1xuICAgICAgaWYgKGl0ZXJhYmxlICE9IHVuZGVmaW5lZCkgZm9yT2YoaXRlcmFibGUsIElTX01BUCwgdGhhdFtBRERFUl0sIHRoYXQpO1xuICAgIH0pO1xuICAgIHJlZGVmaW5lQWxsKEMucHJvdG90eXBlLCB7XG4gICAgICAvLyAyMy4zLjMuMiBXZWFrTWFwLnByb3RvdHlwZS5kZWxldGUoa2V5KVxuICAgICAgLy8gMjMuNC4zLjMgV2Vha1NldC5wcm90b3R5cGUuZGVsZXRlKHZhbHVlKVxuICAgICAgJ2RlbGV0ZSc6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKCFpc09iamVjdChrZXkpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHZhciBkYXRhID0gZ2V0V2VhayhrZXkpO1xuICAgICAgICBpZiAoZGF0YSA9PT0gdHJ1ZSkgcmV0dXJuIHVuY2F1Z2h0RnJvemVuU3RvcmUodmFsaWRhdGUodGhpcywgTkFNRSkpWydkZWxldGUnXShrZXkpO1xuICAgICAgICByZXR1cm4gZGF0YSAmJiAkaGFzKGRhdGEsIHRoaXMuX2kpICYmIGRlbGV0ZSBkYXRhW3RoaXMuX2ldO1xuICAgICAgfSxcbiAgICAgIC8vIDIzLjMuMy40IFdlYWtNYXAucHJvdG90eXBlLmhhcyhrZXkpXG4gICAgICAvLyAyMy40LjMuNCBXZWFrU2V0LnByb3RvdHlwZS5oYXModmFsdWUpXG4gICAgICBoYXM6IGZ1bmN0aW9uIGhhcyhrZXkpIHtcbiAgICAgICAgaWYgKCFpc09iamVjdChrZXkpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHZhciBkYXRhID0gZ2V0V2VhayhrZXkpO1xuICAgICAgICBpZiAoZGF0YSA9PT0gdHJ1ZSkgcmV0dXJuIHVuY2F1Z2h0RnJvemVuU3RvcmUodmFsaWRhdGUodGhpcywgTkFNRSkpLmhhcyhrZXkpO1xuICAgICAgICByZXR1cm4gZGF0YSAmJiAkaGFzKGRhdGEsIHRoaXMuX2kpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBDO1xuICB9LFxuICBkZWY6IGZ1bmN0aW9uICh0aGF0LCBrZXksIHZhbHVlKSB7XG4gICAgdmFyIGRhdGEgPSBnZXRXZWFrKGFuT2JqZWN0KGtleSksIHRydWUpO1xuICAgIGlmIChkYXRhID09PSB0cnVlKSB1bmNhdWdodEZyb3plblN0b3JlKHRoYXQpLnNldChrZXksIHZhbHVlKTtcbiAgICBlbHNlIGRhdGFbdGhhdC5faV0gPSB2YWx1ZTtcbiAgICByZXR1cm4gdGhhdDtcbiAgfSxcbiAgdWZzdG9yZTogdW5jYXVnaHRGcm96ZW5TdG9yZVxufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuL19yZWRlZmluZScpO1xudmFyIHJlZGVmaW5lQWxsID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUtYWxsJyk7XG52YXIgbWV0YSA9IHJlcXVpcmUoJy4vX21ldGEnKTtcbnZhciBmb3JPZiA9IHJlcXVpcmUoJy4vX2Zvci1vZicpO1xudmFyIGFuSW5zdGFuY2UgPSByZXF1aXJlKCcuL19hbi1pbnN0YW5jZScpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xudmFyICRpdGVyRGV0ZWN0ID0gcmVxdWlyZSgnLi9faXRlci1kZXRlY3QnKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJyk7XG52YXIgaW5oZXJpdElmUmVxdWlyZWQgPSByZXF1aXJlKCcuL19pbmhlcml0LWlmLXJlcXVpcmVkJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE5BTUUsIHdyYXBwZXIsIG1ldGhvZHMsIGNvbW1vbiwgSVNfTUFQLCBJU19XRUFLKSB7XG4gIHZhciBCYXNlID0gZ2xvYmFsW05BTUVdO1xuICB2YXIgQyA9IEJhc2U7XG4gIHZhciBBRERFUiA9IElTX01BUCA/ICdzZXQnIDogJ2FkZCc7XG4gIHZhciBwcm90byA9IEMgJiYgQy5wcm90b3R5cGU7XG4gIHZhciBPID0ge307XG4gIHZhciBmaXhNZXRob2QgPSBmdW5jdGlvbiAoS0VZKSB7XG4gICAgdmFyIGZuID0gcHJvdG9bS0VZXTtcbiAgICByZWRlZmluZShwcm90bywgS0VZLFxuICAgICAgS0VZID09ICdkZWxldGUnID8gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgcmV0dXJuIElTX1dFQUsgJiYgIWlzT2JqZWN0KGEpID8gZmFsc2UgOiBmbi5jYWxsKHRoaXMsIGEgPT09IDAgPyAwIDogYSk7XG4gICAgICB9IDogS0VZID09ICdoYXMnID8gZnVuY3Rpb24gaGFzKGEpIHtcbiAgICAgICAgcmV0dXJuIElTX1dFQUsgJiYgIWlzT2JqZWN0KGEpID8gZmFsc2UgOiBmbi5jYWxsKHRoaXMsIGEgPT09IDAgPyAwIDogYSk7XG4gICAgICB9IDogS0VZID09ICdnZXQnID8gZnVuY3Rpb24gZ2V0KGEpIHtcbiAgICAgICAgcmV0dXJuIElTX1dFQUsgJiYgIWlzT2JqZWN0KGEpID8gdW5kZWZpbmVkIDogZm4uY2FsbCh0aGlzLCBhID09PSAwID8gMCA6IGEpO1xuICAgICAgfSA6IEtFWSA9PSAnYWRkJyA/IGZ1bmN0aW9uIGFkZChhKSB7IGZuLmNhbGwodGhpcywgYSA9PT0gMCA/IDAgOiBhKTsgcmV0dXJuIHRoaXM7IH1cbiAgICAgICAgOiBmdW5jdGlvbiBzZXQoYSwgYikgeyBmbi5jYWxsKHRoaXMsIGEgPT09IDAgPyAwIDogYSwgYik7IHJldHVybiB0aGlzOyB9XG4gICAgKTtcbiAgfTtcbiAgaWYgKHR5cGVvZiBDICE9ICdmdW5jdGlvbicgfHwgIShJU19XRUFLIHx8IHByb3RvLmZvckVhY2ggJiYgIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICBuZXcgQygpLmVudHJpZXMoKS5uZXh0KCk7XG4gIH0pKSkge1xuICAgIC8vIGNyZWF0ZSBjb2xsZWN0aW9uIGNvbnN0cnVjdG9yXG4gICAgQyA9IGNvbW1vbi5nZXRDb25zdHJ1Y3Rvcih3cmFwcGVyLCBOQU1FLCBJU19NQVAsIEFEREVSKTtcbiAgICByZWRlZmluZUFsbChDLnByb3RvdHlwZSwgbWV0aG9kcyk7XG4gICAgbWV0YS5ORUVEID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBuZXcgQygpO1xuICAgIC8vIGVhcmx5IGltcGxlbWVudGF0aW9ucyBub3Qgc3VwcG9ydHMgY2hhaW5pbmdcbiAgICB2YXIgSEFTTlRfQ0hBSU5JTkcgPSBpbnN0YW5jZVtBRERFUl0oSVNfV0VBSyA/IHt9IDogLTAsIDEpICE9IGluc3RhbmNlO1xuICAgIC8vIFY4IH4gIENocm9taXVtIDQwLSB3ZWFrLWNvbGxlY3Rpb25zIHRocm93cyBvbiBwcmltaXRpdmVzLCBidXQgc2hvdWxkIHJldHVybiBmYWxzZVxuICAgIHZhciBUSFJPV1NfT05fUFJJTUlUSVZFUyA9IGZhaWxzKGZ1bmN0aW9uICgpIHsgaW5zdGFuY2UuaGFzKDEpOyB9KTtcbiAgICAvLyBtb3N0IGVhcmx5IGltcGxlbWVudGF0aW9ucyBkb2Vzbid0IHN1cHBvcnRzIGl0ZXJhYmxlcywgbW9zdCBtb2Rlcm4gLSBub3QgY2xvc2UgaXQgY29ycmVjdGx5XG4gICAgdmFyIEFDQ0VQVF9JVEVSQUJMRVMgPSAkaXRlckRldGVjdChmdW5jdGlvbiAoaXRlcikgeyBuZXcgQyhpdGVyKTsgfSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgLy8gZm9yIGVhcmx5IGltcGxlbWVudGF0aW9ucyAtMCBhbmQgKzAgbm90IHRoZSBzYW1lXG4gICAgdmFyIEJVR0dZX1pFUk8gPSAhSVNfV0VBSyAmJiBmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBWOCB+IENocm9taXVtIDQyLSBmYWlscyBvbmx5IHdpdGggNSsgZWxlbWVudHNcbiAgICAgIHZhciAkaW5zdGFuY2UgPSBuZXcgQygpO1xuICAgICAgdmFyIGluZGV4ID0gNTtcbiAgICAgIHdoaWxlIChpbmRleC0tKSAkaW5zdGFuY2VbQURERVJdKGluZGV4LCBpbmRleCk7XG4gICAgICByZXR1cm4gISRpbnN0YW5jZS5oYXMoLTApO1xuICAgIH0pO1xuICAgIGlmICghQUNDRVBUX0lURVJBQkxFUykge1xuICAgICAgQyA9IHdyYXBwZXIoZnVuY3Rpb24gKHRhcmdldCwgaXRlcmFibGUpIHtcbiAgICAgICAgYW5JbnN0YW5jZSh0YXJnZXQsIEMsIE5BTUUpO1xuICAgICAgICB2YXIgdGhhdCA9IGluaGVyaXRJZlJlcXVpcmVkKG5ldyBCYXNlKCksIHRhcmdldCwgQyk7XG4gICAgICAgIGlmIChpdGVyYWJsZSAhPSB1bmRlZmluZWQpIGZvck9mKGl0ZXJhYmxlLCBJU19NQVAsIHRoYXRbQURERVJdLCB0aGF0KTtcbiAgICAgICAgcmV0dXJuIHRoYXQ7XG4gICAgICB9KTtcbiAgICAgIEMucHJvdG90eXBlID0gcHJvdG87XG4gICAgICBwcm90by5jb25zdHJ1Y3RvciA9IEM7XG4gICAgfVxuICAgIGlmIChUSFJPV1NfT05fUFJJTUlUSVZFUyB8fCBCVUdHWV9aRVJPKSB7XG4gICAgICBmaXhNZXRob2QoJ2RlbGV0ZScpO1xuICAgICAgZml4TWV0aG9kKCdoYXMnKTtcbiAgICAgIElTX01BUCAmJiBmaXhNZXRob2QoJ2dldCcpO1xuICAgIH1cbiAgICBpZiAoQlVHR1lfWkVSTyB8fCBIQVNOVF9DSEFJTklORykgZml4TWV0aG9kKEFEREVSKTtcbiAgICAvLyB3ZWFrIGNvbGxlY3Rpb25zIHNob3VsZCBub3QgY29udGFpbnMgLmNsZWFyIG1ldGhvZFxuICAgIGlmIChJU19XRUFLICYmIHByb3RvLmNsZWFyKSBkZWxldGUgcHJvdG8uY2xlYXI7XG4gIH1cblxuICBzZXRUb1N0cmluZ1RhZyhDLCBOQU1FKTtcblxuICBPW05BTUVdID0gQztcbiAgJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAoQyAhPSBCYXNlKSwgTyk7XG5cbiAgaWYgKCFJU19XRUFLKSBjb21tb24uc2V0U3Ryb25nKEMsIE5BTUUsIElTX01BUCk7XG5cbiAgcmV0dXJuIEM7XG59O1xuIiwidmFyIGNvcmUgPSBtb2R1bGUuZXhwb3J0cyA9IHsgdmVyc2lvbjogJzIuNS4xJyB9O1xuaWYgKHR5cGVvZiBfX2UgPT0gJ251bWJlcicpIF9fZSA9IGNvcmU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcbnZhciBjcmVhdGVEZXNjID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmplY3QsIGluZGV4LCB2YWx1ZSkge1xuICBpZiAoaW5kZXggaW4gb2JqZWN0KSAkZGVmaW5lUHJvcGVydHkuZihvYmplY3QsIGluZGV4LCBjcmVhdGVEZXNjKDAsIHZhbHVlKSk7XG4gIGVsc2Ugb2JqZWN0W2luZGV4XSA9IHZhbHVlO1xufTtcbiIsIi8vIG9wdGlvbmFsIC8gc2ltcGxlIGNvbnRleHQgYmluZGluZ1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGZuLCB0aGF0LCBsZW5ndGgpIHtcbiAgYUZ1bmN0aW9uKGZuKTtcbiAgaWYgKHRoYXQgPT09IHVuZGVmaW5lZCkgcmV0dXJuIGZuO1xuICBzd2l0Y2ggKGxlbmd0aCkge1xuICAgIGNhc2UgMTogcmV0dXJuIGZ1bmN0aW9uIChhKSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhKTtcbiAgICB9O1xuICAgIGNhc2UgMjogcmV0dXJuIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiKTtcbiAgICB9O1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uIChhLCBiLCBjKSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiLCBjKTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBmdW5jdGlvbiAoLyogLi4uYXJncyAqLykge1xuICAgIHJldHVybiBmbi5hcHBseSh0aGF0LCBhcmd1bWVudHMpO1xuICB9O1xufTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIDIwLjMuNC4zNiAvIDE1LjkuNS40MyBEYXRlLnByb3RvdHlwZS50b0lTT1N0cmluZygpXG52YXIgZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xudmFyIGdldFRpbWUgPSBEYXRlLnByb3RvdHlwZS5nZXRUaW1lO1xudmFyICR0b0lTT1N0cmluZyA9IERhdGUucHJvdG90eXBlLnRvSVNPU3RyaW5nO1xuXG52YXIgbHogPSBmdW5jdGlvbiAobnVtKSB7XG4gIHJldHVybiBudW0gPiA5ID8gbnVtIDogJzAnICsgbnVtO1xufTtcblxuLy8gUGhhbnRvbUpTIC8gb2xkIFdlYktpdCBoYXMgYSBicm9rZW4gaW1wbGVtZW50YXRpb25zXG5tb2R1bGUuZXhwb3J0cyA9IChmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAkdG9JU09TdHJpbmcuY2FsbChuZXcgRGF0ZSgtNWUxMyAtIDEpKSAhPSAnMDM4NS0wNy0yNVQwNzowNjozOS45OTlaJztcbn0pIHx8ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gICR0b0lTT1N0cmluZy5jYWxsKG5ldyBEYXRlKE5hTikpO1xufSkpID8gZnVuY3Rpb24gdG9JU09TdHJpbmcoKSB7XG4gIGlmICghaXNGaW5pdGUoZ2V0VGltZS5jYWxsKHRoaXMpKSkgdGhyb3cgUmFuZ2VFcnJvcignSW52YWxpZCB0aW1lIHZhbHVlJyk7XG4gIHZhciBkID0gdGhpcztcbiAgdmFyIHkgPSBkLmdldFVUQ0Z1bGxZZWFyKCk7XG4gIHZhciBtID0gZC5nZXRVVENNaWxsaXNlY29uZHMoKTtcbiAgdmFyIHMgPSB5IDwgMCA/ICctJyA6IHkgPiA5OTk5ID8gJysnIDogJyc7XG4gIHJldHVybiBzICsgKCcwMDAwMCcgKyBNYXRoLmFicyh5KSkuc2xpY2UocyA/IC02IDogLTQpICtcbiAgICAnLScgKyBseihkLmdldFVUQ01vbnRoKCkgKyAxKSArICctJyArIGx6KGQuZ2V0VVRDRGF0ZSgpKSArXG4gICAgJ1QnICsgbHooZC5nZXRVVENIb3VycygpKSArICc6JyArIGx6KGQuZ2V0VVRDTWludXRlcygpKSArXG4gICAgJzonICsgbHooZC5nZXRVVENTZWNvbmRzKCkpICsgJy4nICsgKG0gPiA5OSA/IG0gOiAnMCcgKyBseihtKSkgKyAnWic7XG59IDogJHRvSVNPU3RyaW5nO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcbnZhciBOVU1CRVIgPSAnbnVtYmVyJztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaGludCkge1xuICBpZiAoaGludCAhPT0gJ3N0cmluZycgJiYgaGludCAhPT0gTlVNQkVSICYmIGhpbnQgIT09ICdkZWZhdWx0JykgdGhyb3cgVHlwZUVycm9yKCdJbmNvcnJlY3QgaGludCcpO1xuICByZXR1cm4gdG9QcmltaXRpdmUoYW5PYmplY3QodGhpcyksIGhpbnQgIT0gTlVNQkVSKTtcbn07XG4iLCIvLyA3LjIuMSBSZXF1aXJlT2JqZWN0Q29lcmNpYmxlKGFyZ3VtZW50KVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKGl0ID09IHVuZGVmaW5lZCkgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY2FsbCBtZXRob2Qgb24gIFwiICsgaXQpO1xuICByZXR1cm4gaXQ7XG59O1xuIiwiLy8gVGhhbmsncyBJRTggZm9yIGhpcyBmdW5ueSBkZWZpbmVQcm9wZXJ0eVxubW9kdWxlLmV4cG9ydHMgPSAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdhJywgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH0gfSkuYSAhPSA3O1xufSk7XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBkb2N1bWVudCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLmRvY3VtZW50O1xuLy8gdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgaXMgJ29iamVjdCcgaW4gb2xkIElFXG52YXIgaXMgPSBpc09iamVjdChkb2N1bWVudCkgJiYgaXNPYmplY3QoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXMgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGl0KSA6IHt9O1xufTtcbiIsIi8vIElFIDgtIGRvbid0IGVudW0gYnVnIGtleXNcbm1vZHVsZS5leHBvcnRzID0gKFxuICAnY29uc3RydWN0b3IsaGFzT3duUHJvcGVydHksaXNQcm90b3R5cGVPZixwcm9wZXJ0eUlzRW51bWVyYWJsZSx0b0xvY2FsZVN0cmluZyx0b1N0cmluZyx2YWx1ZU9mJ1xuKS5zcGxpdCgnLCcpO1xuIiwiLy8gYWxsIGVudW1lcmFibGUgb2JqZWN0IGtleXMsIGluY2x1ZGVzIHN5bWJvbHNcbnZhciBnZXRLZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcbnZhciBnT1BTID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcHMnKTtcbnZhciBwSUUgPSByZXF1aXJlKCcuL19vYmplY3QtcGllJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgcmVzdWx0ID0gZ2V0S2V5cyhpdCk7XG4gIHZhciBnZXRTeW1ib2xzID0gZ09QUy5mO1xuICBpZiAoZ2V0U3ltYm9scykge1xuICAgIHZhciBzeW1ib2xzID0gZ2V0U3ltYm9scyhpdCk7XG4gICAgdmFyIGlzRW51bSA9IHBJRS5mO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIga2V5O1xuICAgIHdoaWxlIChzeW1ib2xzLmxlbmd0aCA+IGkpIGlmIChpc0VudW0uY2FsbChpdCwga2V5ID0gc3ltYm9sc1tpKytdKSkgcmVzdWx0LnB1c2goa2V5KTtcbiAgfSByZXR1cm4gcmVzdWx0O1xufTtcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBjb3JlID0gcmVxdWlyZSgnLi9fY29yZScpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuL19yZWRlZmluZScpO1xudmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xuXG52YXIgJGV4cG9ydCA9IGZ1bmN0aW9uICh0eXBlLCBuYW1lLCBzb3VyY2UpIHtcbiAgdmFyIElTX0ZPUkNFRCA9IHR5cGUgJiAkZXhwb3J0LkY7XG4gIHZhciBJU19HTE9CQUwgPSB0eXBlICYgJGV4cG9ydC5HO1xuICB2YXIgSVNfU1RBVElDID0gdHlwZSAmICRleHBvcnQuUztcbiAgdmFyIElTX1BST1RPID0gdHlwZSAmICRleHBvcnQuUDtcbiAgdmFyIElTX0JJTkQgPSB0eXBlICYgJGV4cG9ydC5CO1xuICB2YXIgdGFyZ2V0ID0gSVNfR0xPQkFMID8gZ2xvYmFsIDogSVNfU1RBVElDID8gZ2xvYmFsW25hbWVdIHx8IChnbG9iYWxbbmFtZV0gPSB7fSkgOiAoZ2xvYmFsW25hbWVdIHx8IHt9KVtQUk9UT1RZUEVdO1xuICB2YXIgZXhwb3J0cyA9IElTX0dMT0JBTCA/IGNvcmUgOiBjb3JlW25hbWVdIHx8IChjb3JlW25hbWVdID0ge30pO1xuICB2YXIgZXhwUHJvdG8gPSBleHBvcnRzW1BST1RPVFlQRV0gfHwgKGV4cG9ydHNbUFJPVE9UWVBFXSA9IHt9KTtcbiAgdmFyIGtleSwgb3duLCBvdXQsIGV4cDtcbiAgaWYgKElTX0dMT0JBTCkgc291cmNlID0gbmFtZTtcbiAgZm9yIChrZXkgaW4gc291cmNlKSB7XG4gICAgLy8gY29udGFpbnMgaW4gbmF0aXZlXG4gICAgb3duID0gIUlTX0ZPUkNFRCAmJiB0YXJnZXQgJiYgdGFyZ2V0W2tleV0gIT09IHVuZGVmaW5lZDtcbiAgICAvLyBleHBvcnQgbmF0aXZlIG9yIHBhc3NlZFxuICAgIG91dCA9IChvd24gPyB0YXJnZXQgOiBzb3VyY2UpW2tleV07XG4gICAgLy8gYmluZCB0aW1lcnMgdG8gZ2xvYmFsIGZvciBjYWxsIGZyb20gZXhwb3J0IGNvbnRleHRcbiAgICBleHAgPSBJU19CSU5EICYmIG93biA/IGN0eChvdXQsIGdsb2JhbCkgOiBJU19QUk9UTyAmJiB0eXBlb2Ygb3V0ID09ICdmdW5jdGlvbicgPyBjdHgoRnVuY3Rpb24uY2FsbCwgb3V0KSA6IG91dDtcbiAgICAvLyBleHRlbmQgZ2xvYmFsXG4gICAgaWYgKHRhcmdldCkgcmVkZWZpbmUodGFyZ2V0LCBrZXksIG91dCwgdHlwZSAmICRleHBvcnQuVSk7XG4gICAgLy8gZXhwb3J0XG4gICAgaWYgKGV4cG9ydHNba2V5XSAhPSBvdXQpIGhpZGUoZXhwb3J0cywga2V5LCBleHApO1xuICAgIGlmIChJU19QUk9UTyAmJiBleHBQcm90b1trZXldICE9IG91dCkgZXhwUHJvdG9ba2V5XSA9IG91dDtcbiAgfVxufTtcbmdsb2JhbC5jb3JlID0gY29yZTtcbi8vIHR5cGUgYml0bWFwXG4kZXhwb3J0LkYgPSAxOyAgIC8vIGZvcmNlZFxuJGV4cG9ydC5HID0gMjsgICAvLyBnbG9iYWxcbiRleHBvcnQuUyA9IDQ7ICAgLy8gc3RhdGljXG4kZXhwb3J0LlAgPSA4OyAgIC8vIHByb3RvXG4kZXhwb3J0LkIgPSAxNjsgIC8vIGJpbmRcbiRleHBvcnQuVyA9IDMyOyAgLy8gd3JhcFxuJGV4cG9ydC5VID0gNjQ7ICAvLyBzYWZlXG4kZXhwb3J0LlIgPSAxMjg7IC8vIHJlYWwgcHJvdG8gbWV0aG9kIGZvciBgbGlicmFyeWBcbm1vZHVsZS5leHBvcnRzID0gJGV4cG9ydDtcbiIsInZhciBNQVRDSCA9IHJlcXVpcmUoJy4vX3drcycpKCdtYXRjaCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoS0VZKSB7XG4gIHZhciByZSA9IC8uLztcbiAgdHJ5IHtcbiAgICAnLy4vJ1tLRVldKHJlKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRyeSB7XG4gICAgICByZVtNQVRDSF0gPSBmYWxzZTtcbiAgICAgIHJldHVybiAhJy8uLydbS0VZXShyZSk7XG4gICAgfSBjYXRjaCAoZikgeyAvKiBlbXB0eSAqLyB9XG4gIH0gcmV0dXJuIHRydWU7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZXhlYykge1xuICB0cnkge1xuICAgIHJldHVybiAhIWV4ZWMoKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuL19yZWRlZmluZScpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xudmFyIHdrcyA9IHJlcXVpcmUoJy4vX3drcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChLRVksIGxlbmd0aCwgZXhlYykge1xuICB2YXIgU1lNQk9MID0gd2tzKEtFWSk7XG4gIHZhciBmbnMgPSBleGVjKGRlZmluZWQsIFNZTUJPTCwgJydbS0VZXSk7XG4gIHZhciBzdHJmbiA9IGZuc1swXTtcbiAgdmFyIHJ4Zm4gPSBmbnNbMV07XG4gIGlmIChmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgdmFyIE8gPSB7fTtcbiAgICBPW1NZTUJPTF0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9O1xuICAgIHJldHVybiAnJ1tLRVldKE8pICE9IDc7XG4gIH0pKSB7XG4gICAgcmVkZWZpbmUoU3RyaW5nLnByb3RvdHlwZSwgS0VZLCBzdHJmbik7XG4gICAgaGlkZShSZWdFeHAucHJvdG90eXBlLCBTWU1CT0wsIGxlbmd0aCA9PSAyXG4gICAgICAvLyAyMS4yLjUuOCBSZWdFeHAucHJvdG90eXBlW0BAcmVwbGFjZV0oc3RyaW5nLCByZXBsYWNlVmFsdWUpXG4gICAgICAvLyAyMS4yLjUuMTEgUmVnRXhwLnByb3RvdHlwZVtAQHNwbGl0XShzdHJpbmcsIGxpbWl0KVxuICAgICAgPyBmdW5jdGlvbiAoc3RyaW5nLCBhcmcpIHsgcmV0dXJuIHJ4Zm4uY2FsbChzdHJpbmcsIHRoaXMsIGFyZyk7IH1cbiAgICAgIC8vIDIxLjIuNS42IFJlZ0V4cC5wcm90b3R5cGVbQEBtYXRjaF0oc3RyaW5nKVxuICAgICAgLy8gMjEuMi41LjkgUmVnRXhwLnByb3RvdHlwZVtAQHNlYXJjaF0oc3RyaW5nKVxuICAgICAgOiBmdW5jdGlvbiAoc3RyaW5nKSB7IHJldHVybiByeGZuLmNhbGwoc3RyaW5nLCB0aGlzKTsgfVxuICAgICk7XG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG4vLyAyMS4yLjUuMyBnZXQgUmVnRXhwLnByb3RvdHlwZS5mbGFnc1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRoYXQgPSBhbk9iamVjdCh0aGlzKTtcbiAgdmFyIHJlc3VsdCA9ICcnO1xuICBpZiAodGhhdC5nbG9iYWwpIHJlc3VsdCArPSAnZyc7XG4gIGlmICh0aGF0Lmlnbm9yZUNhc2UpIHJlc3VsdCArPSAnaSc7XG4gIGlmICh0aGF0Lm11bHRpbGluZSkgcmVzdWx0ICs9ICdtJztcbiAgaWYgKHRoYXQudW5pY29kZSkgcmVzdWx0ICs9ICd1JztcbiAgaWYgKHRoYXQuc3RpY2t5KSByZXN1bHQgKz0gJ3knO1xuICByZXR1cm4gcmVzdWx0O1xufTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vcHJvcG9zYWwtZmxhdE1hcC8jc2VjLUZsYXR0ZW5JbnRvQXJyYXlcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi9faXMtYXJyYXknKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG52YXIgSVNfQ09OQ0FUX1NQUkVBREFCTEUgPSByZXF1aXJlKCcuL193a3MnKSgnaXNDb25jYXRTcHJlYWRhYmxlJyk7XG5cbmZ1bmN0aW9uIGZsYXR0ZW5JbnRvQXJyYXkodGFyZ2V0LCBvcmlnaW5hbCwgc291cmNlLCBzb3VyY2VMZW4sIHN0YXJ0LCBkZXB0aCwgbWFwcGVyLCB0aGlzQXJnKSB7XG4gIHZhciB0YXJnZXRJbmRleCA9IHN0YXJ0O1xuICB2YXIgc291cmNlSW5kZXggPSAwO1xuICB2YXIgbWFwRm4gPSBtYXBwZXIgPyBjdHgobWFwcGVyLCB0aGlzQXJnLCAzKSA6IGZhbHNlO1xuICB2YXIgZWxlbWVudCwgc3ByZWFkYWJsZTtcblxuICB3aGlsZSAoc291cmNlSW5kZXggPCBzb3VyY2VMZW4pIHtcbiAgICBpZiAoc291cmNlSW5kZXggaW4gc291cmNlKSB7XG4gICAgICBlbGVtZW50ID0gbWFwRm4gPyBtYXBGbihzb3VyY2Vbc291cmNlSW5kZXhdLCBzb3VyY2VJbmRleCwgb3JpZ2luYWwpIDogc291cmNlW3NvdXJjZUluZGV4XTtcblxuICAgICAgc3ByZWFkYWJsZSA9IGZhbHNlO1xuICAgICAgaWYgKGlzT2JqZWN0KGVsZW1lbnQpKSB7XG4gICAgICAgIHNwcmVhZGFibGUgPSBlbGVtZW50W0lTX0NPTkNBVF9TUFJFQURBQkxFXTtcbiAgICAgICAgc3ByZWFkYWJsZSA9IHNwcmVhZGFibGUgIT09IHVuZGVmaW5lZCA/ICEhc3ByZWFkYWJsZSA6IGlzQXJyYXkoZWxlbWVudCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzcHJlYWRhYmxlICYmIGRlcHRoID4gMCkge1xuICAgICAgICB0YXJnZXRJbmRleCA9IGZsYXR0ZW5JbnRvQXJyYXkodGFyZ2V0LCBvcmlnaW5hbCwgZWxlbWVudCwgdG9MZW5ndGgoZWxlbWVudC5sZW5ndGgpLCB0YXJnZXRJbmRleCwgZGVwdGggLSAxKSAtIDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGFyZ2V0SW5kZXggPj0gMHgxZmZmZmZmZmZmZmZmZikgdGhyb3cgVHlwZUVycm9yKCk7XG4gICAgICAgIHRhcmdldFt0YXJnZXRJbmRleF0gPSBlbGVtZW50O1xuICAgICAgfVxuXG4gICAgICB0YXJnZXRJbmRleCsrO1xuICAgIH1cbiAgICBzb3VyY2VJbmRleCsrO1xuICB9XG4gIHJldHVybiB0YXJnZXRJbmRleDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmbGF0dGVuSW50b0FycmF5O1xuIiwidmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyIGNhbGwgPSByZXF1aXJlKCcuL19pdGVyLWNhbGwnKTtcbnZhciBpc0FycmF5SXRlciA9IHJlcXVpcmUoJy4vX2lzLWFycmF5LWl0ZXInKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgZ2V0SXRlckZuID0gcmVxdWlyZSgnLi9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QnKTtcbnZhciBCUkVBSyA9IHt9O1xudmFyIFJFVFVSTiA9IHt9O1xudmFyIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdGVyYWJsZSwgZW50cmllcywgZm4sIHRoYXQsIElURVJBVE9SKSB7XG4gIHZhciBpdGVyRm4gPSBJVEVSQVRPUiA/IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGl0ZXJhYmxlOyB9IDogZ2V0SXRlckZuKGl0ZXJhYmxlKTtcbiAgdmFyIGYgPSBjdHgoZm4sIHRoYXQsIGVudHJpZXMgPyAyIDogMSk7XG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBsZW5ndGgsIHN0ZXAsIGl0ZXJhdG9yLCByZXN1bHQ7XG4gIGlmICh0eXBlb2YgaXRlckZuICE9ICdmdW5jdGlvbicpIHRocm93IFR5cGVFcnJvcihpdGVyYWJsZSArICcgaXMgbm90IGl0ZXJhYmxlIScpO1xuICAvLyBmYXN0IGNhc2UgZm9yIGFycmF5cyB3aXRoIGRlZmF1bHQgaXRlcmF0b3JcbiAgaWYgKGlzQXJyYXlJdGVyKGl0ZXJGbikpIGZvciAobGVuZ3RoID0gdG9MZW5ndGgoaXRlcmFibGUubGVuZ3RoKTsgbGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIHtcbiAgICByZXN1bHQgPSBlbnRyaWVzID8gZihhbk9iamVjdChzdGVwID0gaXRlcmFibGVbaW5kZXhdKVswXSwgc3RlcFsxXSkgOiBmKGl0ZXJhYmxlW2luZGV4XSk7XG4gICAgaWYgKHJlc3VsdCA9PT0gQlJFQUsgfHwgcmVzdWx0ID09PSBSRVRVUk4pIHJldHVybiByZXN1bHQ7XG4gIH0gZWxzZSBmb3IgKGl0ZXJhdG9yID0gaXRlckZuLmNhbGwoaXRlcmFibGUpOyAhKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmU7KSB7XG4gICAgcmVzdWx0ID0gY2FsbChpdGVyYXRvciwgZiwgc3RlcC52YWx1ZSwgZW50cmllcyk7XG4gICAgaWYgKHJlc3VsdCA9PT0gQlJFQUsgfHwgcmVzdWx0ID09PSBSRVRVUk4pIHJldHVybiByZXN1bHQ7XG4gIH1cbn07XG5leHBvcnRzLkJSRUFLID0gQlJFQUs7XG5leHBvcnRzLlJFVFVSTiA9IFJFVFVSTjtcbiIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy84NiNpc3N1ZWNvbW1lbnQtMTE1NzU5MDI4XG52YXIgZ2xvYmFsID0gbW9kdWxlLmV4cG9ydHMgPSB0eXBlb2Ygd2luZG93ICE9ICd1bmRlZmluZWQnICYmIHdpbmRvdy5NYXRoID09IE1hdGhcbiAgPyB3aW5kb3cgOiB0eXBlb2Ygc2VsZiAhPSAndW5kZWZpbmVkJyAmJiBzZWxmLk1hdGggPT0gTWF0aCA/IHNlbGZcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jXG4gIDogRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcbmlmICh0eXBlb2YgX19nID09ICdudW1iZXInKSBfX2cgPSBnbG9iYWw7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbiIsInZhciBoYXNPd25Qcm9wZXJ0eSA9IHt9Lmhhc093blByb3BlcnR5O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIGtleSkge1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChpdCwga2V5KTtcbn07XG4iLCJ2YXIgZFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcbnZhciBjcmVhdGVEZXNjID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICByZXR1cm4gZFAuZihvYmplY3QsIGtleSwgY3JlYXRlRGVzYygxLCB2YWx1ZSkpO1xufSA6IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgcmV0dXJuIG9iamVjdDtcbn07XG4iLCJ2YXIgZG9jdW1lbnQgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5kb2N1bWVudDtcbm1vZHVsZS5leHBvcnRzID0gZG9jdW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuIiwibW9kdWxlLmV4cG9ydHMgPSAhcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVxdWlyZSgnLi9fZG9tLWNyZWF0ZScpKCdkaXYnKSwgJ2EnLCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfSB9KS5hICE9IDc7XG59KTtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIHNldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fc2V0LXByb3RvJykuc2V0O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodGhhdCwgdGFyZ2V0LCBDKSB7XG4gIHZhciBTID0gdGFyZ2V0LmNvbnN0cnVjdG9yO1xuICB2YXIgUDtcbiAgaWYgKFMgIT09IEMgJiYgdHlwZW9mIFMgPT0gJ2Z1bmN0aW9uJyAmJiAoUCA9IFMucHJvdG90eXBlKSAhPT0gQy5wcm90b3R5cGUgJiYgaXNPYmplY3QoUCkgJiYgc2V0UHJvdG90eXBlT2YpIHtcbiAgICBzZXRQcm90b3R5cGVPZih0aGF0LCBQKTtcbiAgfSByZXR1cm4gdGhhdDtcbn07XG4iLCIvLyBmYXN0IGFwcGx5LCBodHRwOi8vanNwZXJmLmxua2l0LmNvbS9mYXN0LWFwcGx5LzVcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGZuLCBhcmdzLCB0aGF0KSB7XG4gIHZhciB1biA9IHRoYXQgPT09IHVuZGVmaW5lZDtcbiAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgIGNhc2UgMDogcmV0dXJuIHVuID8gZm4oKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0KTtcbiAgICBjYXNlIDE6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0pO1xuICAgIGNhc2UgMjogcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgY2FzZSAzOiByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICBjYXNlIDQ6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pO1xuICB9IHJldHVybiBmbi5hcHBseSh0aGF0LCBhcmdzKTtcbn07XG4iLCIvLyBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIGFuZCBub24tZW51bWVyYWJsZSBvbGQgVjggc3RyaW5nc1xudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QoJ3onKS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgwKSA/IE9iamVjdCA6IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gY29mKGl0KSA9PSAnU3RyaW5nJyA/IGl0LnNwbGl0KCcnKSA6IE9iamVjdChpdCk7XG59O1xuIiwiLy8gY2hlY2sgb24gZGVmYXVsdCBBcnJheSBpdGVyYXRvclxudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xudmFyIElURVJBVE9SID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyk7XG52YXIgQXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGl0ICE9PSB1bmRlZmluZWQgJiYgKEl0ZXJhdG9ycy5BcnJheSA9PT0gaXQgfHwgQXJyYXlQcm90b1tJVEVSQVRPUl0gPT09IGl0KTtcbn07XG4iLCIvLyA3LjIuMiBJc0FycmF5KGFyZ3VtZW50KVxudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xubW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIGlzQXJyYXkoYXJnKSB7XG4gIHJldHVybiBjb2YoYXJnKSA9PSAnQXJyYXknO1xufTtcbiIsIi8vIDIwLjEuMi4zIE51bWJlci5pc0ludGVnZXIobnVtYmVyKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0ludGVnZXIoaXQpIHtcbiAgcmV0dXJuICFpc09iamVjdChpdCkgJiYgaXNGaW5pdGUoaXQpICYmIGZsb29yKGl0KSA9PT0gaXQ7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PT0gJ29iamVjdCcgPyBpdCAhPT0gbnVsbCA6IHR5cGVvZiBpdCA9PT0gJ2Z1bmN0aW9uJztcbn07XG4iLCIvLyA3LjIuOCBJc1JlZ0V4cChhcmd1bWVudClcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xudmFyIE1BVENIID0gcmVxdWlyZSgnLi9fd2tzJykoJ21hdGNoJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgaXNSZWdFeHA7XG4gIHJldHVybiBpc09iamVjdChpdCkgJiYgKChpc1JlZ0V4cCA9IGl0W01BVENIXSkgIT09IHVuZGVmaW5lZCA/ICEhaXNSZWdFeHAgOiBjb2YoaXQpID09ICdSZWdFeHAnKTtcbn07XG4iLCIvLyBjYWxsIHNvbWV0aGluZyBvbiBpdGVyYXRvciBzdGVwIHdpdGggc2FmZSBjbG9zaW5nIG9uIGVycm9yXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0ZXJhdG9yLCBmbiwgdmFsdWUsIGVudHJpZXMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZW50cmllcyA/IGZuKGFuT2JqZWN0KHZhbHVlKVswXSwgdmFsdWVbMV0pIDogZm4odmFsdWUpO1xuICAvLyA3LjQuNiBJdGVyYXRvckNsb3NlKGl0ZXJhdG9yLCBjb21wbGV0aW9uKVxuICB9IGNhdGNoIChlKSB7XG4gICAgdmFyIHJldCA9IGl0ZXJhdG9yWydyZXR1cm4nXTtcbiAgICBpZiAocmV0ICE9PSB1bmRlZmluZWQpIGFuT2JqZWN0KHJldC5jYWxsKGl0ZXJhdG9yKSk7XG4gICAgdGhyb3cgZTtcbiAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBjcmVhdGUgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJyk7XG52YXIgZGVzY3JpcHRvciA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJyk7XG52YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcblxuLy8gMjUuMS4yLjEuMSAlSXRlcmF0b3JQcm90b3R5cGUlW0BAaXRlcmF0b3JdKClcbnJlcXVpcmUoJy4vX2hpZGUnKShJdGVyYXRvclByb3RvdHlwZSwgcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyksIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCkge1xuICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBjcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUsIHsgbmV4dDogZGVzY3JpcHRvcigxLCBuZXh0KSB9KTtcbiAgc2V0VG9TdHJpbmdUYWcoQ29uc3RydWN0b3IsIE5BTUUgKyAnIEl0ZXJhdG9yJyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIExJQlJBUlkgPSByZXF1aXJlKCcuL19saWJyYXJ5Jyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xudmFyICRpdGVyQ3JlYXRlID0gcmVxdWlyZSgnLi9faXRlci1jcmVhdGUnKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJyk7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJyk7XG52YXIgSVRFUkFUT1IgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKTtcbnZhciBCVUdHWSA9ICEoW10ua2V5cyAmJiAnbmV4dCcgaW4gW10ua2V5cygpKTsgLy8gU2FmYXJpIGhhcyBidWdneSBpdGVyYXRvcnMgdy9vIGBuZXh0YFxudmFyIEZGX0lURVJBVE9SID0gJ0BAaXRlcmF0b3InO1xudmFyIEtFWVMgPSAna2V5cyc7XG52YXIgVkFMVUVTID0gJ3ZhbHVlcyc7XG5cbnZhciByZXR1cm5UaGlzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQmFzZSwgTkFNRSwgQ29uc3RydWN0b3IsIG5leHQsIERFRkFVTFQsIElTX1NFVCwgRk9SQ0VEKSB7XG4gICRpdGVyQ3JlYXRlKENvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KTtcbiAgdmFyIGdldE1ldGhvZCA9IGZ1bmN0aW9uIChraW5kKSB7XG4gICAgaWYgKCFCVUdHWSAmJiBraW5kIGluIHByb3RvKSByZXR1cm4gcHJvdG9ba2luZF07XG4gICAgc3dpdGNoIChraW5kKSB7XG4gICAgICBjYXNlIEtFWVM6IHJldHVybiBmdW5jdGlvbiBrZXlzKCkgeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICAgICAgY2FzZSBWQUxVRVM6IHJldHVybiBmdW5jdGlvbiB2YWx1ZXMoKSB7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gICAgfSByZXR1cm4gZnVuY3Rpb24gZW50cmllcygpIHsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgfTtcbiAgdmFyIFRBRyA9IE5BTUUgKyAnIEl0ZXJhdG9yJztcbiAgdmFyIERFRl9WQUxVRVMgPSBERUZBVUxUID09IFZBTFVFUztcbiAgdmFyIFZBTFVFU19CVUcgPSBmYWxzZTtcbiAgdmFyIHByb3RvID0gQmFzZS5wcm90b3R5cGU7XG4gIHZhciAkbmF0aXZlID0gcHJvdG9bSVRFUkFUT1JdIHx8IHByb3RvW0ZGX0lURVJBVE9SXSB8fCBERUZBVUxUICYmIHByb3RvW0RFRkFVTFRdO1xuICB2YXIgJGRlZmF1bHQgPSAkbmF0aXZlIHx8IGdldE1ldGhvZChERUZBVUxUKTtcbiAgdmFyICRlbnRyaWVzID0gREVGQVVMVCA/ICFERUZfVkFMVUVTID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoJ2VudHJpZXMnKSA6IHVuZGVmaW5lZDtcbiAgdmFyICRhbnlOYXRpdmUgPSBOQU1FID09ICdBcnJheScgPyBwcm90by5lbnRyaWVzIHx8ICRuYXRpdmUgOiAkbmF0aXZlO1xuICB2YXIgbWV0aG9kcywga2V5LCBJdGVyYXRvclByb3RvdHlwZTtcbiAgLy8gRml4IG5hdGl2ZVxuICBpZiAoJGFueU5hdGl2ZSkge1xuICAgIEl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG90eXBlT2YoJGFueU5hdGl2ZS5jYWxsKG5ldyBCYXNlKCkpKTtcbiAgICBpZiAoSXRlcmF0b3JQcm90b3R5cGUgIT09IE9iamVjdC5wcm90b3R5cGUgJiYgSXRlcmF0b3JQcm90b3R5cGUubmV4dCkge1xuICAgICAgLy8gU2V0IEBAdG9TdHJpbmdUYWcgdG8gbmF0aXZlIGl0ZXJhdG9yc1xuICAgICAgc2V0VG9TdHJpbmdUYWcoSXRlcmF0b3JQcm90b3R5cGUsIFRBRywgdHJ1ZSk7XG4gICAgICAvLyBmaXggZm9yIHNvbWUgb2xkIGVuZ2luZXNcbiAgICAgIGlmICghTElCUkFSWSAmJiAhaGFzKEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUikpIGhpZGUoSXRlcmF0b3JQcm90b3R5cGUsIElURVJBVE9SLCByZXR1cm5UaGlzKTtcbiAgICB9XG4gIH1cbiAgLy8gZml4IEFycmF5I3t2YWx1ZXMsIEBAaXRlcmF0b3J9Lm5hbWUgaW4gVjggLyBGRlxuICBpZiAoREVGX1ZBTFVFUyAmJiAkbmF0aXZlICYmICRuYXRpdmUubmFtZSAhPT0gVkFMVUVTKSB7XG4gICAgVkFMVUVTX0JVRyA9IHRydWU7XG4gICAgJGRlZmF1bHQgPSBmdW5jdGlvbiB2YWx1ZXMoKSB7IHJldHVybiAkbmF0aXZlLmNhbGwodGhpcyk7IH07XG4gIH1cbiAgLy8gRGVmaW5lIGl0ZXJhdG9yXG4gIGlmICgoIUxJQlJBUlkgfHwgRk9SQ0VEKSAmJiAoQlVHR1kgfHwgVkFMVUVTX0JVRyB8fCAhcHJvdG9bSVRFUkFUT1JdKSkge1xuICAgIGhpZGUocHJvdG8sIElURVJBVE9SLCAkZGVmYXVsdCk7XG4gIH1cbiAgLy8gUGx1ZyBmb3IgbGlicmFyeVxuICBJdGVyYXRvcnNbTkFNRV0gPSAkZGVmYXVsdDtcbiAgSXRlcmF0b3JzW1RBR10gPSByZXR1cm5UaGlzO1xuICBpZiAoREVGQVVMVCkge1xuICAgIG1ldGhvZHMgPSB7XG4gICAgICB2YWx1ZXM6IERFRl9WQUxVRVMgPyAkZGVmYXVsdCA6IGdldE1ldGhvZChWQUxVRVMpLFxuICAgICAga2V5czogSVNfU0VUID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoS0VZUyksXG4gICAgICBlbnRyaWVzOiAkZW50cmllc1xuICAgIH07XG4gICAgaWYgKEZPUkNFRCkgZm9yIChrZXkgaW4gbWV0aG9kcykge1xuICAgICAgaWYgKCEoa2V5IGluIHByb3RvKSkgcmVkZWZpbmUocHJvdG8sIGtleSwgbWV0aG9kc1trZXldKTtcbiAgICB9IGVsc2UgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoQlVHR1kgfHwgVkFMVUVTX0JVRyksIE5BTUUsIG1ldGhvZHMpO1xuICB9XG4gIHJldHVybiBtZXRob2RzO1xufTtcbiIsInZhciBJVEVSQVRPUiA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpO1xudmFyIFNBRkVfQ0xPU0lORyA9IGZhbHNlO1xuXG50cnkge1xuICB2YXIgcml0ZXIgPSBbN11bSVRFUkFUT1JdKCk7XG4gIHJpdGVyWydyZXR1cm4nXSA9IGZ1bmN0aW9uICgpIHsgU0FGRV9DTE9TSU5HID0gdHJ1ZTsgfTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXRocm93LWxpdGVyYWxcbiAgQXJyYXkuZnJvbShyaXRlciwgZnVuY3Rpb24gKCkgeyB0aHJvdyAyOyB9KTtcbn0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChleGVjLCBza2lwQ2xvc2luZykge1xuICBpZiAoIXNraXBDbG9zaW5nICYmICFTQUZFX0NMT1NJTkcpIHJldHVybiBmYWxzZTtcbiAgdmFyIHNhZmUgPSBmYWxzZTtcbiAgdHJ5IHtcbiAgICB2YXIgYXJyID0gWzddO1xuICAgIHZhciBpdGVyID0gYXJyW0lURVJBVE9SXSgpO1xuICAgIGl0ZXIubmV4dCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHsgZG9uZTogc2FmZSA9IHRydWUgfTsgfTtcbiAgICBhcnJbSVRFUkFUT1JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gaXRlcjsgfTtcbiAgICBleGVjKGFycik7XG4gIH0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxuICByZXR1cm4gc2FmZTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChkb25lLCB2YWx1ZSkge1xuICByZXR1cm4geyB2YWx1ZTogdmFsdWUsIGRvbmU6ICEhZG9uZSB9O1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge307XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZhbHNlO1xuIiwiLy8gMjAuMi4yLjE0IE1hdGguZXhwbTEoeClcbnZhciAkZXhwbTEgPSBNYXRoLmV4cG0xO1xubW9kdWxlLmV4cG9ydHMgPSAoISRleHBtMVxuICAvLyBPbGQgRkYgYnVnXG4gIHx8ICRleHBtMSgxMCkgPiAyMjAyNS40NjU3OTQ4MDY3MTkgfHwgJGV4cG0xKDEwKSA8IDIyMDI1LjQ2NTc5NDgwNjcxNjUxNjhcbiAgLy8gVG9yIEJyb3dzZXIgYnVnXG4gIHx8ICRleHBtMSgtMmUtMTcpICE9IC0yZS0xN1xuKSA/IGZ1bmN0aW9uIGV4cG0xKHgpIHtcbiAgcmV0dXJuICh4ID0gK3gpID09IDAgPyB4IDogeCA+IC0xZS02ICYmIHggPCAxZS02ID8geCArIHggKiB4IC8gMiA6IE1hdGguZXhwKHgpIC0gMTtcbn0gOiAkZXhwbTE7XG4iLCIvLyAyMC4yLjIuMTYgTWF0aC5mcm91bmQoeClcbnZhciBzaWduID0gcmVxdWlyZSgnLi9fbWF0aC1zaWduJyk7XG52YXIgcG93ID0gTWF0aC5wb3c7XG52YXIgRVBTSUxPTiA9IHBvdygyLCAtNTIpO1xudmFyIEVQU0lMT04zMiA9IHBvdygyLCAtMjMpO1xudmFyIE1BWDMyID0gcG93KDIsIDEyNykgKiAoMiAtIEVQU0lMT04zMik7XG52YXIgTUlOMzIgPSBwb3coMiwgLTEyNik7XG5cbnZhciByb3VuZFRpZXNUb0V2ZW4gPSBmdW5jdGlvbiAobikge1xuICByZXR1cm4gbiArIDEgLyBFUFNJTE9OIC0gMSAvIEVQU0lMT047XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hdGguZnJvdW5kIHx8IGZ1bmN0aW9uIGZyb3VuZCh4KSB7XG4gIHZhciAkYWJzID0gTWF0aC5hYnMoeCk7XG4gIHZhciAkc2lnbiA9IHNpZ24oeCk7XG4gIHZhciBhLCByZXN1bHQ7XG4gIGlmICgkYWJzIDwgTUlOMzIpIHJldHVybiAkc2lnbiAqIHJvdW5kVGllc1RvRXZlbigkYWJzIC8gTUlOMzIgLyBFUFNJTE9OMzIpICogTUlOMzIgKiBFUFNJTE9OMzI7XG4gIGEgPSAoMSArIEVQU0lMT04zMiAvIEVQU0lMT04pICogJGFicztcbiAgcmVzdWx0ID0gYSAtIChhIC0gJGFicyk7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgaWYgKHJlc3VsdCA+IE1BWDMyIHx8IHJlc3VsdCAhPSByZXN1bHQpIHJldHVybiAkc2lnbiAqIEluZmluaXR5O1xuICByZXR1cm4gJHNpZ24gKiByZXN1bHQ7XG59O1xuIiwiLy8gMjAuMi4yLjIwIE1hdGgubG9nMXAoeClcbm1vZHVsZS5leHBvcnRzID0gTWF0aC5sb2cxcCB8fCBmdW5jdGlvbiBsb2cxcCh4KSB7XG4gIHJldHVybiAoeCA9ICt4KSA+IC0xZS04ICYmIHggPCAxZS04ID8geCAtIHggKiB4IC8gMiA6IE1hdGgubG9nKDEgKyB4KTtcbn07XG4iLCIvLyBodHRwczovL3J3YWxkcm9uLmdpdGh1Yi5pby9wcm9wb3NhbC1tYXRoLWV4dGVuc2lvbnMvXG5tb2R1bGUuZXhwb3J0cyA9IE1hdGguc2NhbGUgfHwgZnVuY3Rpb24gc2NhbGUoeCwgaW5Mb3csIGluSGlnaCwgb3V0TG93LCBvdXRIaWdoKSB7XG4gIGlmIChcbiAgICBhcmd1bWVudHMubGVuZ3RoID09PSAwXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgICB8fCB4ICE9IHhcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICAgIHx8IGluTG93ICE9IGluTG93XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgICB8fCBpbkhpZ2ggIT0gaW5IaWdoXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgICB8fCBvdXRMb3cgIT0gb3V0TG93XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgICB8fCBvdXRIaWdoICE9IG91dEhpZ2hcbiAgKSByZXR1cm4gTmFOO1xuICBpZiAoeCA9PT0gSW5maW5pdHkgfHwgeCA9PT0gLUluZmluaXR5KSByZXR1cm4geDtcbiAgcmV0dXJuICh4IC0gaW5Mb3cpICogKG91dEhpZ2ggLSBvdXRMb3cpIC8gKGluSGlnaCAtIGluTG93KSArIG91dExvdztcbn07XG4iLCIvLyAyMC4yLjIuMjggTWF0aC5zaWduKHgpXG5tb2R1bGUuZXhwb3J0cyA9IE1hdGguc2lnbiB8fCBmdW5jdGlvbiBzaWduKHgpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICByZXR1cm4gKHggPSAreCkgPT0gMCB8fCB4ICE9IHggPyB4IDogeCA8IDAgPyAtMSA6IDE7XG59O1xuIiwidmFyIE1FVEEgPSByZXF1aXJlKCcuL191aWQnKSgnbWV0YScpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgc2V0RGVzYyA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG52YXIgaWQgPSAwO1xudmFyIGlzRXh0ZW5zaWJsZSA9IE9iamVjdC5pc0V4dGVuc2libGUgfHwgZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdHJ1ZTtcbn07XG52YXIgRlJFRVpFID0gIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gaXNFeHRlbnNpYmxlKE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh7fSkpO1xufSk7XG52YXIgc2V0TWV0YSA9IGZ1bmN0aW9uIChpdCkge1xuICBzZXREZXNjKGl0LCBNRVRBLCB7IHZhbHVlOiB7XG4gICAgaTogJ08nICsgKytpZCwgLy8gb2JqZWN0IElEXG4gICAgdzoge30gICAgICAgICAgLy8gd2VhayBjb2xsZWN0aW9ucyBJRHNcbiAgfSB9KTtcbn07XG52YXIgZmFzdEtleSA9IGZ1bmN0aW9uIChpdCwgY3JlYXRlKSB7XG4gIC8vIHJldHVybiBwcmltaXRpdmUgd2l0aCBwcmVmaXhcbiAgaWYgKCFpc09iamVjdChpdCkpIHJldHVybiB0eXBlb2YgaXQgPT0gJ3N5bWJvbCcgPyBpdCA6ICh0eXBlb2YgaXQgPT0gJ3N0cmluZycgPyAnUycgOiAnUCcpICsgaXQ7XG4gIGlmICghaGFzKGl0LCBNRVRBKSkge1xuICAgIC8vIGNhbid0IHNldCBtZXRhZGF0YSB0byB1bmNhdWdodCBmcm96ZW4gb2JqZWN0XG4gICAgaWYgKCFpc0V4dGVuc2libGUoaXQpKSByZXR1cm4gJ0YnO1xuICAgIC8vIG5vdCBuZWNlc3NhcnkgdG8gYWRkIG1ldGFkYXRhXG4gICAgaWYgKCFjcmVhdGUpIHJldHVybiAnRSc7XG4gICAgLy8gYWRkIG1pc3NpbmcgbWV0YWRhdGFcbiAgICBzZXRNZXRhKGl0KTtcbiAgLy8gcmV0dXJuIG9iamVjdCBJRFxuICB9IHJldHVybiBpdFtNRVRBXS5pO1xufTtcbnZhciBnZXRXZWFrID0gZnVuY3Rpb24gKGl0LCBjcmVhdGUpIHtcbiAgaWYgKCFoYXMoaXQsIE1FVEEpKSB7XG4gICAgLy8gY2FuJ3Qgc2V0IG1ldGFkYXRhIHRvIHVuY2F1Z2h0IGZyb3plbiBvYmplY3RcbiAgICBpZiAoIWlzRXh0ZW5zaWJsZShpdCkpIHJldHVybiB0cnVlO1xuICAgIC8vIG5vdCBuZWNlc3NhcnkgdG8gYWRkIG1ldGFkYXRhXG4gICAgaWYgKCFjcmVhdGUpIHJldHVybiBmYWxzZTtcbiAgICAvLyBhZGQgbWlzc2luZyBtZXRhZGF0YVxuICAgIHNldE1ldGEoaXQpO1xuICAvLyByZXR1cm4gaGFzaCB3ZWFrIGNvbGxlY3Rpb25zIElEc1xuICB9IHJldHVybiBpdFtNRVRBXS53O1xufTtcbi8vIGFkZCBtZXRhZGF0YSBvbiBmcmVlemUtZmFtaWx5IG1ldGhvZHMgY2FsbGluZ1xudmFyIG9uRnJlZXplID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChGUkVFWkUgJiYgbWV0YS5ORUVEICYmIGlzRXh0ZW5zaWJsZShpdCkgJiYgIWhhcyhpdCwgTUVUQSkpIHNldE1ldGEoaXQpO1xuICByZXR1cm4gaXQ7XG59O1xudmFyIG1ldGEgPSBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgS0VZOiBNRVRBLFxuICBORUVEOiBmYWxzZSxcbiAgZmFzdEtleTogZmFzdEtleSxcbiAgZ2V0V2VhazogZ2V0V2VhayxcbiAgb25GcmVlemU6IG9uRnJlZXplXG59O1xuIiwidmFyIE1hcCA9IHJlcXVpcmUoJy4vZXM2Lm1hcCcpO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBzaGFyZWQgPSByZXF1aXJlKCcuL19zaGFyZWQnKSgnbWV0YWRhdGEnKTtcbnZhciBzdG9yZSA9IHNoYXJlZC5zdG9yZSB8fCAoc2hhcmVkLnN0b3JlID0gbmV3IChyZXF1aXJlKCcuL2VzNi53ZWFrLW1hcCcpKSgpKTtcblxudmFyIGdldE9yQ3JlYXRlTWV0YWRhdGFNYXAgPSBmdW5jdGlvbiAodGFyZ2V0LCB0YXJnZXRLZXksIGNyZWF0ZSkge1xuICB2YXIgdGFyZ2V0TWV0YWRhdGEgPSBzdG9yZS5nZXQodGFyZ2V0KTtcbiAgaWYgKCF0YXJnZXRNZXRhZGF0YSkge1xuICAgIGlmICghY3JlYXRlKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgIHN0b3JlLnNldCh0YXJnZXQsIHRhcmdldE1ldGFkYXRhID0gbmV3IE1hcCgpKTtcbiAgfVxuICB2YXIga2V5TWV0YWRhdGEgPSB0YXJnZXRNZXRhZGF0YS5nZXQodGFyZ2V0S2V5KTtcbiAgaWYgKCFrZXlNZXRhZGF0YSkge1xuICAgIGlmICghY3JlYXRlKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgIHRhcmdldE1ldGFkYXRhLnNldCh0YXJnZXRLZXksIGtleU1ldGFkYXRhID0gbmV3IE1hcCgpKTtcbiAgfSByZXR1cm4ga2V5TWV0YWRhdGE7XG59O1xudmFyIG9yZGluYXJ5SGFzT3duTWV0YWRhdGEgPSBmdW5jdGlvbiAoTWV0YWRhdGFLZXksIE8sIFApIHtcbiAgdmFyIG1ldGFkYXRhTWFwID0gZ2V0T3JDcmVhdGVNZXRhZGF0YU1hcChPLCBQLCBmYWxzZSk7XG4gIHJldHVybiBtZXRhZGF0YU1hcCA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBtZXRhZGF0YU1hcC5oYXMoTWV0YWRhdGFLZXkpO1xufTtcbnZhciBvcmRpbmFyeUdldE93bk1ldGFkYXRhID0gZnVuY3Rpb24gKE1ldGFkYXRhS2V5LCBPLCBQKSB7XG4gIHZhciBtZXRhZGF0YU1hcCA9IGdldE9yQ3JlYXRlTWV0YWRhdGFNYXAoTywgUCwgZmFsc2UpO1xuICByZXR1cm4gbWV0YWRhdGFNYXAgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IG1ldGFkYXRhTWFwLmdldChNZXRhZGF0YUtleSk7XG59O1xudmFyIG9yZGluYXJ5RGVmaW5lT3duTWV0YWRhdGEgPSBmdW5jdGlvbiAoTWV0YWRhdGFLZXksIE1ldGFkYXRhVmFsdWUsIE8sIFApIHtcbiAgZ2V0T3JDcmVhdGVNZXRhZGF0YU1hcChPLCBQLCB0cnVlKS5zZXQoTWV0YWRhdGFLZXksIE1ldGFkYXRhVmFsdWUpO1xufTtcbnZhciBvcmRpbmFyeU93bk1ldGFkYXRhS2V5cyA9IGZ1bmN0aW9uICh0YXJnZXQsIHRhcmdldEtleSkge1xuICB2YXIgbWV0YWRhdGFNYXAgPSBnZXRPckNyZWF0ZU1ldGFkYXRhTWFwKHRhcmdldCwgdGFyZ2V0S2V5LCBmYWxzZSk7XG4gIHZhciBrZXlzID0gW107XG4gIGlmIChtZXRhZGF0YU1hcCkgbWV0YWRhdGFNYXAuZm9yRWFjaChmdW5jdGlvbiAoXywga2V5KSB7IGtleXMucHVzaChrZXkpOyB9KTtcbiAgcmV0dXJuIGtleXM7XG59O1xudmFyIHRvTWV0YUtleSA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgaXQgPT0gJ3N5bWJvbCcgPyBpdCA6IFN0cmluZyhpdCk7XG59O1xudmFyIGV4cCA9IGZ1bmN0aW9uIChPKSB7XG4gICRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIE8pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHN0b3JlOiBzdG9yZSxcbiAgbWFwOiBnZXRPckNyZWF0ZU1ldGFkYXRhTWFwLFxuICBoYXM6IG9yZGluYXJ5SGFzT3duTWV0YWRhdGEsXG4gIGdldDogb3JkaW5hcnlHZXRPd25NZXRhZGF0YSxcbiAgc2V0OiBvcmRpbmFyeURlZmluZU93bk1ldGFkYXRhLFxuICBrZXlzOiBvcmRpbmFyeU93bk1ldGFkYXRhS2V5cyxcbiAga2V5OiB0b01ldGFLZXksXG4gIGV4cDogZXhwXG59O1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIG1hY3JvdGFzayA9IHJlcXVpcmUoJy4vX3Rhc2snKS5zZXQ7XG52YXIgT2JzZXJ2ZXIgPSBnbG9iYWwuTXV0YXRpb25PYnNlcnZlciB8fCBnbG9iYWwuV2ViS2l0TXV0YXRpb25PYnNlcnZlcjtcbnZhciBwcm9jZXNzID0gZ2xvYmFsLnByb2Nlc3M7XG52YXIgUHJvbWlzZSA9IGdsb2JhbC5Qcm9taXNlO1xudmFyIGlzTm9kZSA9IHJlcXVpcmUoJy4vX2NvZicpKHByb2Nlc3MpID09ICdwcm9jZXNzJztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBoZWFkLCBsYXN0LCBub3RpZnk7XG5cbiAgdmFyIGZsdXNoID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBwYXJlbnQsIGZuO1xuICAgIGlmIChpc05vZGUgJiYgKHBhcmVudCA9IHByb2Nlc3MuZG9tYWluKSkgcGFyZW50LmV4aXQoKTtcbiAgICB3aGlsZSAoaGVhZCkge1xuICAgICAgZm4gPSBoZWFkLmZuO1xuICAgICAgaGVhZCA9IGhlYWQubmV4dDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZuKCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChoZWFkKSBub3RpZnkoKTtcbiAgICAgICAgZWxzZSBsYXN0ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH0gbGFzdCA9IHVuZGVmaW5lZDtcbiAgICBpZiAocGFyZW50KSBwYXJlbnQuZW50ZXIoKTtcbiAgfTtcblxuICAvLyBOb2RlLmpzXG4gIGlmIChpc05vZGUpIHtcbiAgICBub3RpZnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGZsdXNoKTtcbiAgICB9O1xuICAvLyBicm93c2VycyB3aXRoIE11dGF0aW9uT2JzZXJ2ZXJcbiAgfSBlbHNlIGlmIChPYnNlcnZlcikge1xuICAgIHZhciB0b2dnbGUgPSB0cnVlO1xuICAgIHZhciBub2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpO1xuICAgIG5ldyBPYnNlcnZlcihmbHVzaCkub2JzZXJ2ZShub2RlLCB7IGNoYXJhY3RlckRhdGE6IHRydWUgfSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgbm90aWZ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgbm9kZS5kYXRhID0gdG9nZ2xlID0gIXRvZ2dsZTtcbiAgICB9O1xuICAvLyBlbnZpcm9ubWVudHMgd2l0aCBtYXliZSBub24tY29tcGxldGVseSBjb3JyZWN0LCBidXQgZXhpc3RlbnQgUHJvbWlzZVxuICB9IGVsc2UgaWYgKFByb21pc2UgJiYgUHJvbWlzZS5yZXNvbHZlKSB7XG4gICAgdmFyIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgICBub3RpZnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBwcm9taXNlLnRoZW4oZmx1c2gpO1xuICAgIH07XG4gIC8vIGZvciBvdGhlciBlbnZpcm9ubWVudHMgLSBtYWNyb3Rhc2sgYmFzZWQgb246XG4gIC8vIC0gc2V0SW1tZWRpYXRlXG4gIC8vIC0gTWVzc2FnZUNoYW5uZWxcbiAgLy8gLSB3aW5kb3cucG9zdE1lc3NhZ1xuICAvLyAtIG9ucmVhZHlzdGF0ZWNoYW5nZVxuICAvLyAtIHNldFRpbWVvdXRcbiAgfSBlbHNlIHtcbiAgICBub3RpZnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBzdHJhbmdlIElFICsgd2VicGFjayBkZXYgc2VydmVyIGJ1ZyAtIHVzZSAuY2FsbChnbG9iYWwpXG4gICAgICBtYWNyb3Rhc2suY2FsbChnbG9iYWwsIGZsdXNoKTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChmbikge1xuICAgIHZhciB0YXNrID0geyBmbjogZm4sIG5leHQ6IHVuZGVmaW5lZCB9O1xuICAgIGlmIChsYXN0KSBsYXN0Lm5leHQgPSB0YXNrO1xuICAgIGlmICghaGVhZCkge1xuICAgICAgaGVhZCA9IHRhc2s7XG4gICAgICBub3RpZnkoKTtcbiAgICB9IGxhc3QgPSB0YXNrO1xuICB9O1xufTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIDI1LjQuMS41IE5ld1Byb21pc2VDYXBhYmlsaXR5KEMpXG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xuXG5mdW5jdGlvbiBQcm9taXNlQ2FwYWJpbGl0eShDKSB7XG4gIHZhciByZXNvbHZlLCByZWplY3Q7XG4gIHRoaXMucHJvbWlzZSA9IG5ldyBDKGZ1bmN0aW9uICgkJHJlc29sdmUsICQkcmVqZWN0KSB7XG4gICAgaWYgKHJlc29sdmUgIT09IHVuZGVmaW5lZCB8fCByZWplY3QgIT09IHVuZGVmaW5lZCkgdGhyb3cgVHlwZUVycm9yKCdCYWQgUHJvbWlzZSBjb25zdHJ1Y3RvcicpO1xuICAgIHJlc29sdmUgPSAkJHJlc29sdmU7XG4gICAgcmVqZWN0ID0gJCRyZWplY3Q7XG4gIH0pO1xuICB0aGlzLnJlc29sdmUgPSBhRnVuY3Rpb24ocmVzb2x2ZSk7XG4gIHRoaXMucmVqZWN0ID0gYUZ1bmN0aW9uKHJlamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzLmYgPSBmdW5jdGlvbiAoQykge1xuICByZXR1cm4gbmV3IFByb21pc2VDYXBhYmlsaXR5KEMpO1xufTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIDE5LjEuMi4xIE9iamVjdC5hc3NpZ24odGFyZ2V0LCBzb3VyY2UsIC4uLilcbnZhciBnZXRLZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcbnZhciBnT1BTID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcHMnKTtcbnZhciBwSUUgPSByZXF1aXJlKCcuL19vYmplY3QtcGllJyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciBJT2JqZWN0ID0gcmVxdWlyZSgnLi9faW9iamVjdCcpO1xudmFyICRhc3NpZ24gPSBPYmplY3QuYXNzaWduO1xuXG4vLyBzaG91bGQgd29yayB3aXRoIHN5bWJvbHMgYW5kIHNob3VsZCBoYXZlIGRldGVybWluaXN0aWMgcHJvcGVydHkgb3JkZXIgKFY4IGJ1Zylcbm1vZHVsZS5leHBvcnRzID0gISRhc3NpZ24gfHwgcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHZhciBBID0ge307XG4gIHZhciBCID0ge307XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICB2YXIgUyA9IFN5bWJvbCgpO1xuICB2YXIgSyA9ICdhYmNkZWZnaGlqa2xtbm9wcXJzdCc7XG4gIEFbU10gPSA3O1xuICBLLnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7IEJba10gPSBrOyB9KTtcbiAgcmV0dXJuICRhc3NpZ24oe30sIEEpW1NdICE9IDcgfHwgT2JqZWN0LmtleXMoJGFzc2lnbih7fSwgQikpLmpvaW4oJycpICE9IEs7XG59KSA/IGZ1bmN0aW9uIGFzc2lnbih0YXJnZXQsIHNvdXJjZSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gIHZhciBUID0gdG9PYmplY3QodGFyZ2V0KTtcbiAgdmFyIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgaW5kZXggPSAxO1xuICB2YXIgZ2V0U3ltYm9scyA9IGdPUFMuZjtcbiAgdmFyIGlzRW51bSA9IHBJRS5mO1xuICB3aGlsZSAoYUxlbiA+IGluZGV4KSB7XG4gICAgdmFyIFMgPSBJT2JqZWN0KGFyZ3VtZW50c1tpbmRleCsrXSk7XG4gICAgdmFyIGtleXMgPSBnZXRTeW1ib2xzID8gZ2V0S2V5cyhTKS5jb25jYXQoZ2V0U3ltYm9scyhTKSkgOiBnZXRLZXlzKFMpO1xuICAgIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICB2YXIgaiA9IDA7XG4gICAgdmFyIGtleTtcbiAgICB3aGlsZSAobGVuZ3RoID4gaikgaWYgKGlzRW51bS5jYWxsKFMsIGtleSA9IGtleXNbaisrXSkpIFRba2V5XSA9IFNba2V5XTtcbiAgfSByZXR1cm4gVDtcbn0gOiAkYXNzaWduO1xuIiwiLy8gMTkuMS4yLjIgLyAxNS4yLjMuNSBPYmplY3QuY3JlYXRlKE8gWywgUHJvcGVydGllc10pXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBkUHMgPSByZXF1aXJlKCcuL19vYmplY3QtZHBzJyk7XG52YXIgZW51bUJ1Z0tleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJyk7XG52YXIgSUVfUFJPVE8gPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJyk7XG52YXIgRW1wdHkgPSBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH07XG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG5cbi8vIENyZWF0ZSBvYmplY3Qgd2l0aCBmYWtlIGBudWxsYCBwcm90b3R5cGU6IHVzZSBpZnJhbWUgT2JqZWN0IHdpdGggY2xlYXJlZCBwcm90b3R5cGVcbnZhciBjcmVhdGVEaWN0ID0gZnVuY3Rpb24gKCkge1xuICAvLyBUaHJhc2gsIHdhc3RlIGFuZCBzb2RvbXk6IElFIEdDIGJ1Z1xuICB2YXIgaWZyYW1lID0gcmVxdWlyZSgnLi9fZG9tLWNyZWF0ZScpKCdpZnJhbWUnKTtcbiAgdmFyIGkgPSBlbnVtQnVnS2V5cy5sZW5ndGg7XG4gIHZhciBsdCA9ICc8JztcbiAgdmFyIGd0ID0gJz4nO1xuICB2YXIgaWZyYW1lRG9jdW1lbnQ7XG4gIGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICByZXF1aXJlKCcuL19odG1sJykuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgaWZyYW1lLnNyYyA9ICdqYXZhc2NyaXB0Oic7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2NyaXB0LXVybFxuICAvLyBjcmVhdGVEaWN0ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuT2JqZWN0O1xuICAvLyBodG1sLnJlbW92ZUNoaWxkKGlmcmFtZSk7XG4gIGlmcmFtZURvY3VtZW50ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQ7XG4gIGlmcmFtZURvY3VtZW50Lm9wZW4oKTtcbiAgaWZyYW1lRG9jdW1lbnQud3JpdGUobHQgKyAnc2NyaXB0JyArIGd0ICsgJ2RvY3VtZW50LkY9T2JqZWN0JyArIGx0ICsgJy9zY3JpcHQnICsgZ3QpO1xuICBpZnJhbWVEb2N1bWVudC5jbG9zZSgpO1xuICBjcmVhdGVEaWN0ID0gaWZyYW1lRG9jdW1lbnQuRjtcbiAgd2hpbGUgKGktLSkgZGVsZXRlIGNyZWF0ZURpY3RbUFJPVE9UWVBFXVtlbnVtQnVnS2V5c1tpXV07XG4gIHJldHVybiBjcmVhdGVEaWN0KCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5jcmVhdGUgfHwgZnVuY3Rpb24gY3JlYXRlKE8sIFByb3BlcnRpZXMpIHtcbiAgdmFyIHJlc3VsdDtcbiAgaWYgKE8gIT09IG51bGwpIHtcbiAgICBFbXB0eVtQUk9UT1RZUEVdID0gYW5PYmplY3QoTyk7XG4gICAgcmVzdWx0ID0gbmV3IEVtcHR5KCk7XG4gICAgRW1wdHlbUFJPVE9UWVBFXSA9IG51bGw7XG4gICAgLy8gYWRkIFwiX19wcm90b19fXCIgZm9yIE9iamVjdC5nZXRQcm90b3R5cGVPZiBwb2x5ZmlsbFxuICAgIHJlc3VsdFtJRV9QUk9UT10gPSBPO1xuICB9IGVsc2UgcmVzdWx0ID0gY3JlYXRlRGljdCgpO1xuICByZXR1cm4gUHJvcGVydGllcyA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogZFBzKHJlc3VsdCwgUHJvcGVydGllcyk7XG59O1xuIiwidmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuL19pZTgtZG9tLWRlZmluZScpO1xudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7XG52YXIgZFAgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5cbmV4cG9ydHMuZiA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKSB7XG4gIGFuT2JqZWN0KE8pO1xuICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gIGFuT2JqZWN0KEF0dHJpYnV0ZXMpO1xuICBpZiAoSUU4X0RPTV9ERUZJTkUpIHRyeSB7XG4gICAgcmV0dXJuIGRQKE8sIFAsIEF0dHJpYnV0ZXMpO1xuICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cbiAgaWYgKCdnZXQnIGluIEF0dHJpYnV0ZXMgfHwgJ3NldCcgaW4gQXR0cmlidXRlcykgdGhyb3cgVHlwZUVycm9yKCdBY2Nlc3NvcnMgbm90IHN1cHBvcnRlZCEnKTtcbiAgaWYgKCd2YWx1ZScgaW4gQXR0cmlidXRlcykgT1tQXSA9IEF0dHJpYnV0ZXMudmFsdWU7XG4gIHJldHVybiBPO1xufTtcbiIsInZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgZ2V0S2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzIDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKSB7XG4gIGFuT2JqZWN0KE8pO1xuICB2YXIga2V5cyA9IGdldEtleXMoUHJvcGVydGllcyk7XG4gIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgdmFyIGkgPSAwO1xuICB2YXIgUDtcbiAgd2hpbGUgKGxlbmd0aCA+IGkpIGRQLmYoTywgUCA9IGtleXNbaSsrXSwgUHJvcGVydGllc1tQXSk7XG4gIHJldHVybiBPO1xufTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIEZvcmNlZCByZXBsYWNlbWVudCBwcm90b3R5cGUgYWNjZXNzb3JzIG1ldGhvZHNcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fbGlicmFyeScpIHx8ICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgdmFyIEsgPSBNYXRoLnJhbmRvbSgpO1xuICAvLyBJbiBGRiB0aHJvd3Mgb25seSBkZWZpbmUgbWV0aG9kc1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWYsIG5vLXVzZWxlc3MtY2FsbFxuICBfX2RlZmluZVNldHRlcl9fLmNhbGwobnVsbCwgSywgZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9KTtcbiAgZGVsZXRlIHJlcXVpcmUoJy4vX2dsb2JhbCcpW0tdO1xufSk7XG4iLCJ2YXIgcElFID0gcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpO1xudmFyIGNyZWF0ZURlc2MgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuL19pZTgtZG9tLWRlZmluZScpO1xudmFyIGdPUEQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG5leHBvcnRzLmYgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gZ09QRCA6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKSB7XG4gIE8gPSB0b0lPYmplY3QoTyk7XG4gIFAgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcbiAgaWYgKElFOF9ET01fREVGSU5FKSB0cnkge1xuICAgIHJldHVybiBnT1BEKE8sIFApO1xuICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cbiAgaWYgKGhhcyhPLCBQKSkgcmV0dXJuIGNyZWF0ZURlc2MoIXBJRS5mLmNhbGwoTywgUCksIE9bUF0pO1xufTtcbiIsIi8vIGZhbGxiYWNrIGZvciBJRTExIGJ1Z2d5IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHdpdGggaWZyYW1lIGFuZCB3aW5kb3dcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgZ09QTiA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuJykuZjtcbnZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG52YXIgd2luZG93TmFtZXMgPSB0eXBlb2Ygd2luZG93ID09ICdvYmplY3QnICYmIHdpbmRvdyAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lc1xuICA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHdpbmRvdykgOiBbXTtcblxudmFyIGdldFdpbmRvd05hbWVzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGdPUE4oaXQpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHdpbmRvd05hbWVzLnNsaWNlKCk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzLmYgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KSB7XG4gIHJldHVybiB3aW5kb3dOYW1lcyAmJiB0b1N0cmluZy5jYWxsKGl0KSA9PSAnW29iamVjdCBXaW5kb3ddJyA/IGdldFdpbmRvd05hbWVzKGl0KSA6IGdPUE4odG9JT2JqZWN0KGl0KSk7XG59O1xuIiwiLy8gMTkuMS4yLjcgLyAxNS4yLjMuNCBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPKVxudmFyICRrZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMtaW50ZXJuYWwnKTtcbnZhciBoaWRkZW5LZXlzID0gcmVxdWlyZSgnLi9fZW51bS1idWcta2V5cycpLmNvbmNhdCgnbGVuZ3RoJywgJ3Byb3RvdHlwZScpO1xuXG5leHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB8fCBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKE8pIHtcbiAgcmV0dXJuICRrZXlzKE8sIGhpZGRlbktleXMpO1xufTtcbiIsImV4cG9ydHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG4iLCIvLyAxOS4xLjIuOSAvIDE1LjIuMy4yIE9iamVjdC5nZXRQcm90b3R5cGVPZihPKVxudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgSUVfUFJPVE8gPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJyk7XG52YXIgT2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiAoTykge1xuICBPID0gdG9PYmplY3QoTyk7XG4gIGlmIChoYXMoTywgSUVfUFJPVE8pKSByZXR1cm4gT1tJRV9QUk9UT107XG4gIGlmICh0eXBlb2YgTy5jb25zdHJ1Y3RvciA9PSAnZnVuY3Rpb24nICYmIE8gaW5zdGFuY2VvZiBPLmNvbnN0cnVjdG9yKSB7XG4gICAgcmV0dXJuIE8uY29uc3RydWN0b3IucHJvdG90eXBlO1xuICB9IHJldHVybiBPIGluc3RhbmNlb2YgT2JqZWN0ID8gT2JqZWN0UHJvdG8gOiBudWxsO1xufTtcbiIsInZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgYXJyYXlJbmRleE9mID0gcmVxdWlyZSgnLi9fYXJyYXktaW5jbHVkZXMnKShmYWxzZSk7XG52YXIgSUVfUFJPVE8gPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iamVjdCwgbmFtZXMpIHtcbiAgdmFyIE8gPSB0b0lPYmplY3Qob2JqZWN0KTtcbiAgdmFyIGkgPSAwO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBrZXk7XG4gIGZvciAoa2V5IGluIE8pIGlmIChrZXkgIT0gSUVfUFJPVE8pIGhhcyhPLCBrZXkpICYmIHJlc3VsdC5wdXNoKGtleSk7XG4gIC8vIERvbid0IGVudW0gYnVnICYgaGlkZGVuIGtleXNcbiAgd2hpbGUgKG5hbWVzLmxlbmd0aCA+IGkpIGlmIChoYXMoTywga2V5ID0gbmFtZXNbaSsrXSkpIHtcbiAgICB+YXJyYXlJbmRleE9mKHJlc3VsdCwga2V5KSB8fCByZXN1bHQucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuIiwiLy8gMTkuMS4yLjE0IC8gMTUuMi4zLjE0IE9iamVjdC5rZXlzKE8pXG52YXIgJGtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cy1pbnRlcm5hbCcpO1xudmFyIGVudW1CdWdLZXlzID0gcmVxdWlyZSgnLi9fZW51bS1idWcta2V5cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMoTykge1xuICByZXR1cm4gJGtleXMoTywgZW51bUJ1Z0tleXMpO1xufTtcbiIsImV4cG9ydHMuZiA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuIiwiLy8gbW9zdCBPYmplY3QgbWV0aG9kcyBieSBFUzYgc2hvdWxkIGFjY2VwdCBwcmltaXRpdmVzXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGNvcmUgPSByZXF1aXJlKCcuL19jb3JlJyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoS0VZLCBleGVjKSB7XG4gIHZhciBmbiA9IChjb3JlLk9iamVjdCB8fCB7fSlbS0VZXSB8fCBPYmplY3RbS0VZXTtcbiAgdmFyIGV4cCA9IHt9O1xuICBleHBbS0VZXSA9IGV4ZWMoZm4pO1xuICAkZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIGZhaWxzKGZ1bmN0aW9uICgpIHsgZm4oMSk7IH0pLCAnT2JqZWN0JywgZXhwKTtcbn07XG4iLCJ2YXIgZ2V0S2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIGlzRW51bSA9IHJlcXVpcmUoJy4vX29iamVjdC1waWUnKS5mO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXNFbnRyaWVzKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoaXQpIHtcbiAgICB2YXIgTyA9IHRvSU9iamVjdChpdCk7XG4gICAgdmFyIGtleXMgPSBnZXRLZXlzKE8pO1xuICAgIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHZhciBrZXk7XG4gICAgd2hpbGUgKGxlbmd0aCA+IGkpIGlmIChpc0VudW0uY2FsbChPLCBrZXkgPSBrZXlzW2krK10pKSB7XG4gICAgICByZXN1bHQucHVzaChpc0VudHJpZXMgPyBba2V5LCBPW2tleV1dIDogT1trZXldKTtcbiAgICB9IHJldHVybiByZXN1bHQ7XG4gIH07XG59O1xuIiwiLy8gYWxsIG9iamVjdCBrZXlzLCBpbmNsdWRlcyBub24tZW51bWVyYWJsZSBhbmQgc3ltYm9sc1xudmFyIGdPUE4gPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbicpO1xudmFyIGdPUFMgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wcycpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgUmVmbGVjdCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLlJlZmxlY3Q7XG5tb2R1bGUuZXhwb3J0cyA9IFJlZmxlY3QgJiYgUmVmbGVjdC5vd25LZXlzIHx8IGZ1bmN0aW9uIG93bktleXMoaXQpIHtcbiAgdmFyIGtleXMgPSBnT1BOLmYoYW5PYmplY3QoaXQpKTtcbiAgdmFyIGdldFN5bWJvbHMgPSBnT1BTLmY7XG4gIHJldHVybiBnZXRTeW1ib2xzID8ga2V5cy5jb25jYXQoZ2V0U3ltYm9scyhpdCkpIDoga2V5cztcbn07XG4iLCJ2YXIgJHBhcnNlRmxvYXQgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5wYXJzZUZsb2F0O1xudmFyICR0cmltID0gcmVxdWlyZSgnLi9fc3RyaW5nLXRyaW0nKS50cmltO1xuXG5tb2R1bGUuZXhwb3J0cyA9IDEgLyAkcGFyc2VGbG9hdChyZXF1aXJlKCcuL19zdHJpbmctd3MnKSArICctMCcpICE9PSAtSW5maW5pdHkgPyBmdW5jdGlvbiBwYXJzZUZsb2F0KHN0cikge1xuICB2YXIgc3RyaW5nID0gJHRyaW0oU3RyaW5nKHN0ciksIDMpO1xuICB2YXIgcmVzdWx0ID0gJHBhcnNlRmxvYXQoc3RyaW5nKTtcbiAgcmV0dXJuIHJlc3VsdCA9PT0gMCAmJiBzdHJpbmcuY2hhckF0KDApID09ICctJyA/IC0wIDogcmVzdWx0O1xufSA6ICRwYXJzZUZsb2F0O1xuIiwidmFyICRwYXJzZUludCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLnBhcnNlSW50O1xudmFyICR0cmltID0gcmVxdWlyZSgnLi9fc3RyaW5nLXRyaW0nKS50cmltO1xudmFyIHdzID0gcmVxdWlyZSgnLi9fc3RyaW5nLXdzJyk7XG52YXIgaGV4ID0gL15bLStdPzBbeFhdLztcblxubW9kdWxlLmV4cG9ydHMgPSAkcGFyc2VJbnQod3MgKyAnMDgnKSAhPT0gOCB8fCAkcGFyc2VJbnQod3MgKyAnMHgxNicpICE9PSAyMiA/IGZ1bmN0aW9uIHBhcnNlSW50KHN0ciwgcmFkaXgpIHtcbiAgdmFyIHN0cmluZyA9ICR0cmltKFN0cmluZyhzdHIpLCAzKTtcbiAgcmV0dXJuICRwYXJzZUludChzdHJpbmcsIChyYWRpeCA+Pj4gMCkgfHwgKGhleC50ZXN0KHN0cmluZykgPyAxNiA6IDEwKSk7XG59IDogJHBhcnNlSW50O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZXhlYykge1xuICB0cnkge1xuICAgIHJldHVybiB7IGU6IGZhbHNlLCB2OiBleGVjKCkgfTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiB7IGU6IHRydWUsIHY6IGUgfTtcbiAgfVxufTtcbiIsInZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgbmV3UHJvbWlzZUNhcGFiaWxpdHkgPSByZXF1aXJlKCcuL19uZXctcHJvbWlzZS1jYXBhYmlsaXR5Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEMsIHgpIHtcbiAgYW5PYmplY3QoQyk7XG4gIGlmIChpc09iamVjdCh4KSAmJiB4LmNvbnN0cnVjdG9yID09PSBDKSByZXR1cm4geDtcbiAgdmFyIHByb21pc2VDYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkuZihDKTtcbiAgdmFyIHJlc29sdmUgPSBwcm9taXNlQ2FwYWJpbGl0eS5yZXNvbHZlO1xuICByZXNvbHZlKHgpO1xuICByZXR1cm4gcHJvbWlzZUNhcGFiaWxpdHkucHJvbWlzZTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChiaXRtYXAsIHZhbHVlKSB7XG4gIHJldHVybiB7XG4gICAgZW51bWVyYWJsZTogIShiaXRtYXAgJiAxKSxcbiAgICBjb25maWd1cmFibGU6ICEoYml0bWFwICYgMiksXG4gICAgd3JpdGFibGU6ICEoYml0bWFwICYgNCksXG4gICAgdmFsdWU6IHZhbHVlXG4gIH07XG59O1xuIiwidmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHRhcmdldCwgc3JjLCBzYWZlKSB7XG4gIGZvciAodmFyIGtleSBpbiBzcmMpIHJlZGVmaW5lKHRhcmdldCwga2V5LCBzcmNba2V5XSwgc2FmZSk7XG4gIHJldHVybiB0YXJnZXQ7XG59O1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgU1JDID0gcmVxdWlyZSgnLi9fdWlkJykoJ3NyYycpO1xudmFyIFRPX1NUUklORyA9ICd0b1N0cmluZyc7XG52YXIgJHRvU3RyaW5nID0gRnVuY3Rpb25bVE9fU1RSSU5HXTtcbnZhciBUUEwgPSAoJycgKyAkdG9TdHJpbmcpLnNwbGl0KFRPX1NUUklORyk7XG5cbnJlcXVpcmUoJy4vX2NvcmUnKS5pbnNwZWN0U291cmNlID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiAkdG9TdHJpbmcuY2FsbChpdCk7XG59O1xuXG4obW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTywga2V5LCB2YWwsIHNhZmUpIHtcbiAgdmFyIGlzRnVuY3Rpb24gPSB0eXBlb2YgdmFsID09ICdmdW5jdGlvbic7XG4gIGlmIChpc0Z1bmN0aW9uKSBoYXModmFsLCAnbmFtZScpIHx8IGhpZGUodmFsLCAnbmFtZScsIGtleSk7XG4gIGlmIChPW2tleV0gPT09IHZhbCkgcmV0dXJuO1xuICBpZiAoaXNGdW5jdGlvbikgaGFzKHZhbCwgU1JDKSB8fCBoaWRlKHZhbCwgU1JDLCBPW2tleV0gPyAnJyArIE9ba2V5XSA6IFRQTC5qb2luKFN0cmluZyhrZXkpKSk7XG4gIGlmIChPID09PSBnbG9iYWwpIHtcbiAgICBPW2tleV0gPSB2YWw7XG4gIH0gZWxzZSBpZiAoIXNhZmUpIHtcbiAgICBkZWxldGUgT1trZXldO1xuICAgIGhpZGUoTywga2V5LCB2YWwpO1xuICB9IGVsc2UgaWYgKE9ba2V5XSkge1xuICAgIE9ba2V5XSA9IHZhbDtcbiAgfSBlbHNlIHtcbiAgICBoaWRlKE8sIGtleSwgdmFsKTtcbiAgfVxuLy8gYWRkIGZha2UgRnVuY3Rpb24jdG9TdHJpbmcgZm9yIGNvcnJlY3Qgd29yayB3cmFwcGVkIG1ldGhvZHMgLyBjb25zdHJ1Y3RvcnMgd2l0aCBtZXRob2RzIGxpa2UgTG9EYXNoIGlzTmF0aXZlXG59KShGdW5jdGlvbi5wcm90b3R5cGUsIFRPX1NUUklORywgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gIHJldHVybiB0eXBlb2YgdGhpcyA9PSAnZnVuY3Rpb24nICYmIHRoaXNbU1JDXSB8fCAkdG9TdHJpbmcuY2FsbCh0aGlzKTtcbn0pO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocmVnRXhwLCByZXBsYWNlKSB7XG4gIHZhciByZXBsYWNlciA9IHJlcGxhY2UgPT09IE9iamVjdChyZXBsYWNlKSA/IGZ1bmN0aW9uIChwYXJ0KSB7XG4gICAgcmV0dXJuIHJlcGxhY2VbcGFydF07XG4gIH0gOiByZXBsYWNlO1xuICByZXR1cm4gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIFN0cmluZyhpdCkucmVwbGFjZShyZWdFeHAsIHJlcGxhY2VyKTtcbiAgfTtcbn07XG4iLCIvLyA3LjIuOSBTYW1lVmFsdWUoeCwgeSlcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmlzIHx8IGZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICByZXR1cm4geCA9PT0geSA/IHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5IDogeCAhPSB4ICYmIHkgIT0geTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL3Byb3Bvc2FsLXNldG1hcC1vZmZyb20vXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcbnZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciBmb3JPZiA9IHJlcXVpcmUoJy4vX2Zvci1vZicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChDT0xMRUNUSU9OKSB7XG4gICRleHBvcnQoJGV4cG9ydC5TLCBDT0xMRUNUSU9OLCB7IGZyb206IGZ1bmN0aW9uIGZyb20oc291cmNlIC8qICwgbWFwRm4sIHRoaXNBcmcgKi8pIHtcbiAgICB2YXIgbWFwRm4gPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIG1hcHBpbmcsIEEsIG4sIGNiO1xuICAgIGFGdW5jdGlvbih0aGlzKTtcbiAgICBtYXBwaW5nID0gbWFwRm4gIT09IHVuZGVmaW5lZDtcbiAgICBpZiAobWFwcGluZykgYUZ1bmN0aW9uKG1hcEZuKTtcbiAgICBpZiAoc291cmNlID09IHVuZGVmaW5lZCkgcmV0dXJuIG5ldyB0aGlzKCk7XG4gICAgQSA9IFtdO1xuICAgIGlmIChtYXBwaW5nKSB7XG4gICAgICBuID0gMDtcbiAgICAgIGNiID0gY3R4KG1hcEZuLCBhcmd1bWVudHNbMl0sIDIpO1xuICAgICAgZm9yT2Yoc291cmNlLCBmYWxzZSwgZnVuY3Rpb24gKG5leHRJdGVtKSB7XG4gICAgICAgIEEucHVzaChjYihuZXh0SXRlbSwgbisrKSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yT2Yoc291cmNlLCBmYWxzZSwgQS5wdXNoLCBBKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyB0aGlzKEEpO1xuICB9IH0pO1xufTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vcHJvcG9zYWwtc2V0bWFwLW9mZnJvbS9cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKENPTExFQ1RJT04pIHtcbiAgJGV4cG9ydCgkZXhwb3J0LlMsIENPTExFQ1RJT04sIHsgb2Y6IGZ1bmN0aW9uIG9mKCkge1xuICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBBID0gQXJyYXkobGVuZ3RoKTtcbiAgICB3aGlsZSAobGVuZ3RoLS0pIEFbbGVuZ3RoXSA9IGFyZ3VtZW50c1tsZW5ndGhdO1xuICAgIHJldHVybiBuZXcgdGhpcyhBKTtcbiAgfSB9KTtcbn07XG4iLCIvLyBXb3JrcyB3aXRoIF9fcHJvdG9fXyBvbmx5LiBPbGQgdjggY2FuJ3Qgd29yayB3aXRoIG51bGwgcHJvdG8gb2JqZWN0cy5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGNoZWNrID0gZnVuY3Rpb24gKE8sIHByb3RvKSB7XG4gIGFuT2JqZWN0KE8pO1xuICBpZiAoIWlzT2JqZWN0KHByb3RvKSAmJiBwcm90byAhPT0gbnVsbCkgdGhyb3cgVHlwZUVycm9yKHByb3RvICsgXCI6IGNhbid0IHNldCBhcyBwcm90b3R5cGUhXCIpO1xufTtcbm1vZHVsZS5leHBvcnRzID0ge1xuICBzZXQ6IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCAoJ19fcHJvdG9fXycgaW4ge30gPyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgZnVuY3Rpb24gKHRlc3QsIGJ1Z2d5LCBzZXQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHNldCA9IHJlcXVpcmUoJy4vX2N0eCcpKEZ1bmN0aW9uLmNhbGwsIHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJykuZihPYmplY3QucHJvdG90eXBlLCAnX19wcm90b19fJykuc2V0LCAyKTtcbiAgICAgICAgc2V0KHRlc3QsIFtdKTtcbiAgICAgICAgYnVnZ3kgPSAhKHRlc3QgaW5zdGFuY2VvZiBBcnJheSk7XG4gICAgICB9IGNhdGNoIChlKSB7IGJ1Z2d5ID0gdHJ1ZTsgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIHNldFByb3RvdHlwZU9mKE8sIHByb3RvKSB7XG4gICAgICAgIGNoZWNrKE8sIHByb3RvKTtcbiAgICAgICAgaWYgKGJ1Z2d5KSBPLl9fcHJvdG9fXyA9IHByb3RvO1xuICAgICAgICBlbHNlIHNldChPLCBwcm90byk7XG4gICAgICAgIHJldHVybiBPO1xuICAgICAgfTtcbiAgICB9KHt9LCBmYWxzZSkgOiB1bmRlZmluZWQpLFxuICBjaGVjazogY2hlY2tcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgZFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJyk7XG52YXIgU1BFQ0lFUyA9IHJlcXVpcmUoJy4vX3drcycpKCdzcGVjaWVzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEtFWSkge1xuICB2YXIgQyA9IGdsb2JhbFtLRVldO1xuICBpZiAoREVTQ1JJUFRPUlMgJiYgQyAmJiAhQ1tTUEVDSUVTXSkgZFAuZihDLCBTUEVDSUVTLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfVxuICB9KTtcbn07XG4iLCJ2YXIgZGVmID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciBUQUcgPSByZXF1aXJlKCcuL193a3MnKSgndG9TdHJpbmdUYWcnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIHRhZywgc3RhdCkge1xuICBpZiAoaXQgJiYgIWhhcyhpdCA9IHN0YXQgPyBpdCA6IGl0LnByb3RvdHlwZSwgVEFHKSkgZGVmKGl0LCBUQUcsIHsgY29uZmlndXJhYmxlOiB0cnVlLCB2YWx1ZTogdGFnIH0pO1xufTtcbiIsInZhciBzaGFyZWQgPSByZXF1aXJlKCcuL19zaGFyZWQnKSgna2V5cycpO1xudmFyIHVpZCA9IHJlcXVpcmUoJy4vX3VpZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiBzaGFyZWRba2V5XSB8fCAoc2hhcmVkW2tleV0gPSB1aWQoa2V5KSk7XG59O1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIFNIQVJFRCA9ICdfX2NvcmUtanNfc2hhcmVkX18nO1xudmFyIHN0b3JlID0gZ2xvYmFsW1NIQVJFRF0gfHwgKGdsb2JhbFtTSEFSRURdID0ge30pO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiBzdG9yZVtrZXldIHx8IChzdG9yZVtrZXldID0ge30pO1xufTtcbiIsIi8vIDcuMy4yMCBTcGVjaWVzQ29uc3RydWN0b3IoTywgZGVmYXVsdENvbnN0cnVjdG9yKVxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xudmFyIFNQRUNJRVMgPSByZXF1aXJlKCcuL193a3MnKSgnc3BlY2llcycpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTywgRCkge1xuICB2YXIgQyA9IGFuT2JqZWN0KE8pLmNvbnN0cnVjdG9yO1xuICB2YXIgUztcbiAgcmV0dXJuIEMgPT09IHVuZGVmaW5lZCB8fCAoUyA9IGFuT2JqZWN0KEMpW1NQRUNJRVNdKSA9PSB1bmRlZmluZWQgPyBEIDogYUZ1bmN0aW9uKFMpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG1ldGhvZCwgYXJnKSB7XG4gIHJldHVybiAhIW1ldGhvZCAmJiBmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVzZWxlc3MtY2FsbFxuICAgIGFyZyA/IG1ldGhvZC5jYWxsKG51bGwsIGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSwgMSkgOiBtZXRob2QuY2FsbChudWxsKTtcbiAgfSk7XG59O1xuIiwidmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xuLy8gdHJ1ZSAgLT4gU3RyaW5nI2F0XG4vLyBmYWxzZSAtPiBTdHJpbmcjY29kZVBvaW50QXRcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFRPX1NUUklORykge1xuICByZXR1cm4gZnVuY3Rpb24gKHRoYXQsIHBvcykge1xuICAgIHZhciBzID0gU3RyaW5nKGRlZmluZWQodGhhdCkpO1xuICAgIHZhciBpID0gdG9JbnRlZ2VyKHBvcyk7XG4gICAgdmFyIGwgPSBzLmxlbmd0aDtcbiAgICB2YXIgYSwgYjtcbiAgICBpZiAoaSA8IDAgfHwgaSA+PSBsKSByZXR1cm4gVE9fU1RSSU5HID8gJycgOiB1bmRlZmluZWQ7XG4gICAgYSA9IHMuY2hhckNvZGVBdChpKTtcbiAgICByZXR1cm4gYSA8IDB4ZDgwMCB8fCBhID4gMHhkYmZmIHx8IGkgKyAxID09PSBsIHx8IChiID0gcy5jaGFyQ29kZUF0KGkgKyAxKSkgPCAweGRjMDAgfHwgYiA+IDB4ZGZmZlxuICAgICAgPyBUT19TVFJJTkcgPyBzLmNoYXJBdChpKSA6IGFcbiAgICAgIDogVE9fU1RSSU5HID8gcy5zbGljZShpLCBpICsgMikgOiAoYSAtIDB4ZDgwMCA8PCAxMCkgKyAoYiAtIDB4ZGMwMCkgKyAweDEwMDAwO1xuICB9O1xufTtcbiIsIi8vIGhlbHBlciBmb3IgU3RyaW5nI3tzdGFydHNXaXRoLCBlbmRzV2l0aCwgaW5jbHVkZXN9XG52YXIgaXNSZWdFeHAgPSByZXF1aXJlKCcuL19pcy1yZWdleHAnKTtcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh0aGF0LCBzZWFyY2hTdHJpbmcsIE5BTUUpIHtcbiAgaWYgKGlzUmVnRXhwKHNlYXJjaFN0cmluZykpIHRocm93IFR5cGVFcnJvcignU3RyaW5nIycgKyBOQU1FICsgXCIgZG9lc24ndCBhY2NlcHQgcmVnZXghXCIpO1xuICByZXR1cm4gU3RyaW5nKGRlZmluZWQodGhhdCkpO1xufTtcbiIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG52YXIgcXVvdCA9IC9cIi9nO1xuLy8gQi4yLjMuMi4xIENyZWF0ZUhUTUwoc3RyaW5nLCB0YWcsIGF0dHJpYnV0ZSwgdmFsdWUpXG52YXIgY3JlYXRlSFRNTCA9IGZ1bmN0aW9uIChzdHJpbmcsIHRhZywgYXR0cmlidXRlLCB2YWx1ZSkge1xuICB2YXIgUyA9IFN0cmluZyhkZWZpbmVkKHN0cmluZykpO1xuICB2YXIgcDEgPSAnPCcgKyB0YWc7XG4gIGlmIChhdHRyaWJ1dGUgIT09ICcnKSBwMSArPSAnICcgKyBhdHRyaWJ1dGUgKyAnPVwiJyArIFN0cmluZyh2YWx1ZSkucmVwbGFjZShxdW90LCAnJnF1b3Q7JykgKyAnXCInO1xuICByZXR1cm4gcDEgKyAnPicgKyBTICsgJzwvJyArIHRhZyArICc+Jztcbn07XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChOQU1FLCBleGVjKSB7XG4gIHZhciBPID0ge307XG4gIE9bTkFNRV0gPSBleGVjKGNyZWF0ZUhUTUwpO1xuICAkZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdGVzdCA9ICcnW05BTUVdKCdcIicpO1xuICAgIHJldHVybiB0ZXN0ICE9PSB0ZXN0LnRvTG93ZXJDYXNlKCkgfHwgdGVzdC5zcGxpdCgnXCInKS5sZW5ndGggPiAzO1xuICB9KSwgJ1N0cmluZycsIE8pO1xufTtcbiIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLXN0cmluZy1wYWQtc3RhcnQtZW5kXG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciByZXBlYXQgPSByZXF1aXJlKCcuL19zdHJpbmctcmVwZWF0Jyk7XG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodGhhdCwgbWF4TGVuZ3RoLCBmaWxsU3RyaW5nLCBsZWZ0KSB7XG4gIHZhciBTID0gU3RyaW5nKGRlZmluZWQodGhhdCkpO1xuICB2YXIgc3RyaW5nTGVuZ3RoID0gUy5sZW5ndGg7XG4gIHZhciBmaWxsU3RyID0gZmlsbFN0cmluZyA9PT0gdW5kZWZpbmVkID8gJyAnIDogU3RyaW5nKGZpbGxTdHJpbmcpO1xuICB2YXIgaW50TWF4TGVuZ3RoID0gdG9MZW5ndGgobWF4TGVuZ3RoKTtcbiAgaWYgKGludE1heExlbmd0aCA8PSBzdHJpbmdMZW5ndGggfHwgZmlsbFN0ciA9PSAnJykgcmV0dXJuIFM7XG4gIHZhciBmaWxsTGVuID0gaW50TWF4TGVuZ3RoIC0gc3RyaW5nTGVuZ3RoO1xuICB2YXIgc3RyaW5nRmlsbGVyID0gcmVwZWF0LmNhbGwoZmlsbFN0ciwgTWF0aC5jZWlsKGZpbGxMZW4gLyBmaWxsU3RyLmxlbmd0aCkpO1xuICBpZiAoc3RyaW5nRmlsbGVyLmxlbmd0aCA+IGZpbGxMZW4pIHN0cmluZ0ZpbGxlciA9IHN0cmluZ0ZpbGxlci5zbGljZSgwLCBmaWxsTGVuKTtcbiAgcmV0dXJuIGxlZnQgPyBzdHJpbmdGaWxsZXIgKyBTIDogUyArIHN0cmluZ0ZpbGxlcjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcmVwZWF0KGNvdW50KSB7XG4gIHZhciBzdHIgPSBTdHJpbmcoZGVmaW5lZCh0aGlzKSk7XG4gIHZhciByZXMgPSAnJztcbiAgdmFyIG4gPSB0b0ludGVnZXIoY291bnQpO1xuICBpZiAobiA8IDAgfHwgbiA9PSBJbmZpbml0eSkgdGhyb3cgUmFuZ2VFcnJvcihcIkNvdW50IGNhbid0IGJlIG5lZ2F0aXZlXCIpO1xuICBmb3IgKDtuID4gMDsgKG4gPj4+PSAxKSAmJiAoc3RyICs9IHN0cikpIGlmIChuICYgMSkgcmVzICs9IHN0cjtcbiAgcmV0dXJuIHJlcztcbn07XG4iLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xudmFyIHNwYWNlcyA9IHJlcXVpcmUoJy4vX3N0cmluZy13cycpO1xudmFyIHNwYWNlID0gJ1snICsgc3BhY2VzICsgJ10nO1xudmFyIG5vbiA9ICdcXHUyMDBiXFx1MDA4NSc7XG52YXIgbHRyaW0gPSBSZWdFeHAoJ14nICsgc3BhY2UgKyBzcGFjZSArICcqJyk7XG52YXIgcnRyaW0gPSBSZWdFeHAoc3BhY2UgKyBzcGFjZSArICcqJCcpO1xuXG52YXIgZXhwb3J0ZXIgPSBmdW5jdGlvbiAoS0VZLCBleGVjLCBBTElBUykge1xuICB2YXIgZXhwID0ge307XG4gIHZhciBGT1JDRSA9IGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gISFzcGFjZXNbS0VZXSgpIHx8IG5vbltLRVldKCkgIT0gbm9uO1xuICB9KTtcbiAgdmFyIGZuID0gZXhwW0tFWV0gPSBGT1JDRSA/IGV4ZWModHJpbSkgOiBzcGFjZXNbS0VZXTtcbiAgaWYgKEFMSUFTKSBleHBbQUxJQVNdID0gZm47XG4gICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogRk9SQ0UsICdTdHJpbmcnLCBleHApO1xufTtcblxuLy8gMSAtPiBTdHJpbmcjdHJpbUxlZnRcbi8vIDIgLT4gU3RyaW5nI3RyaW1SaWdodFxuLy8gMyAtPiBTdHJpbmcjdHJpbVxudmFyIHRyaW0gPSBleHBvcnRlci50cmltID0gZnVuY3Rpb24gKHN0cmluZywgVFlQRSkge1xuICBzdHJpbmcgPSBTdHJpbmcoZGVmaW5lZChzdHJpbmcpKTtcbiAgaWYgKFRZUEUgJiAxKSBzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShsdHJpbSwgJycpO1xuICBpZiAoVFlQRSAmIDIpIHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKHJ0cmltLCAnJyk7XG4gIHJldHVybiBzdHJpbmc7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydGVyO1xuIiwibW9kdWxlLmV4cG9ydHMgPSAnXFx4MDlcXHgwQVxceDBCXFx4MENcXHgwRFxceDIwXFx4QTBcXHUxNjgwXFx1MTgwRVxcdTIwMDBcXHUyMDAxXFx1MjAwMlxcdTIwMDMnICtcbiAgJ1xcdTIwMDRcXHUyMDA1XFx1MjAwNlxcdTIwMDdcXHUyMDA4XFx1MjAwOVxcdTIwMEFcXHUyMDJGXFx1MjA1RlxcdTMwMDBcXHUyMDI4XFx1MjAyOVxcdUZFRkYnO1xuIiwidmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyIGludm9rZSA9IHJlcXVpcmUoJy4vX2ludm9rZScpO1xudmFyIGh0bWwgPSByZXF1aXJlKCcuL19odG1sJyk7XG52YXIgY2VsID0gcmVxdWlyZSgnLi9fZG9tLWNyZWF0ZScpO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIHByb2Nlc3MgPSBnbG9iYWwucHJvY2VzcztcbnZhciBzZXRUYXNrID0gZ2xvYmFsLnNldEltbWVkaWF0ZTtcbnZhciBjbGVhclRhc2sgPSBnbG9iYWwuY2xlYXJJbW1lZGlhdGU7XG52YXIgTWVzc2FnZUNoYW5uZWwgPSBnbG9iYWwuTWVzc2FnZUNoYW5uZWw7XG52YXIgRGlzcGF0Y2ggPSBnbG9iYWwuRGlzcGF0Y2g7XG52YXIgY291bnRlciA9IDA7XG52YXIgcXVldWUgPSB7fTtcbnZhciBPTlJFQURZU1RBVEVDSEFOR0UgPSAnb25yZWFkeXN0YXRlY2hhbmdlJztcbnZhciBkZWZlciwgY2hhbm5lbCwgcG9ydDtcbnZhciBydW4gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBpZCA9ICt0aGlzO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG4gIGlmIChxdWV1ZS5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICB2YXIgZm4gPSBxdWV1ZVtpZF07XG4gICAgZGVsZXRlIHF1ZXVlW2lkXTtcbiAgICBmbigpO1xuICB9XG59O1xudmFyIGxpc3RlbmVyID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gIHJ1bi5jYWxsKGV2ZW50LmRhdGEpO1xufTtcbi8vIE5vZGUuanMgMC45KyAmIElFMTArIGhhcyBzZXRJbW1lZGlhdGUsIG90aGVyd2lzZTpcbmlmICghc2V0VGFzayB8fCAhY2xlYXJUYXNrKSB7XG4gIHNldFRhc2sgPSBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoZm4pIHtcbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIHZhciBpID0gMTtcbiAgICB3aGlsZSAoYXJndW1lbnRzLmxlbmd0aCA+IGkpIGFyZ3MucHVzaChhcmd1bWVudHNbaSsrXSk7XG4gICAgcXVldWVbKytjb3VudGVyXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuY1xuICAgICAgaW52b2tlKHR5cGVvZiBmbiA9PSAnZnVuY3Rpb24nID8gZm4gOiBGdW5jdGlvbihmbiksIGFyZ3MpO1xuICAgIH07XG4gICAgZGVmZXIoY291bnRlcik7XG4gICAgcmV0dXJuIGNvdW50ZXI7XG4gIH07XG4gIGNsZWFyVGFzayA9IGZ1bmN0aW9uIGNsZWFySW1tZWRpYXRlKGlkKSB7XG4gICAgZGVsZXRlIHF1ZXVlW2lkXTtcbiAgfTtcbiAgLy8gTm9kZS5qcyAwLjgtXG4gIGlmIChyZXF1aXJlKCcuL19jb2YnKShwcm9jZXNzKSA9PSAncHJvY2VzcycpIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhjdHgocnVuLCBpZCwgMSkpO1xuICAgIH07XG4gIC8vIFNwaGVyZSAoSlMgZ2FtZSBlbmdpbmUpIERpc3BhdGNoIEFQSVxuICB9IGVsc2UgaWYgKERpc3BhdGNoICYmIERpc3BhdGNoLm5vdykge1xuICAgIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICBEaXNwYXRjaC5ub3coY3R4KHJ1biwgaWQsIDEpKTtcbiAgICB9O1xuICAvLyBCcm93c2VycyB3aXRoIE1lc3NhZ2VDaGFubmVsLCBpbmNsdWRlcyBXZWJXb3JrZXJzXG4gIH0gZWxzZSBpZiAoTWVzc2FnZUNoYW5uZWwpIHtcbiAgICBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgcG9ydCA9IGNoYW5uZWwucG9ydDI7XG4gICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBsaXN0ZW5lcjtcbiAgICBkZWZlciA9IGN0eChwb3J0LnBvc3RNZXNzYWdlLCBwb3J0LCAxKTtcbiAgLy8gQnJvd3NlcnMgd2l0aCBwb3N0TWVzc2FnZSwgc2tpcCBXZWJXb3JrZXJzXG4gIC8vIElFOCBoYXMgcG9zdE1lc3NhZ2UsIGJ1dCBpdCdzIHN5bmMgJiB0eXBlb2YgaXRzIHBvc3RNZXNzYWdlIGlzICdvYmplY3QnXG4gIH0gZWxzZSBpZiAoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIgJiYgdHlwZW9mIHBvc3RNZXNzYWdlID09ICdmdW5jdGlvbicgJiYgIWdsb2JhbC5pbXBvcnRTY3JpcHRzKSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShpZCArICcnLCAnKicpO1xuICAgIH07XG4gICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBsaXN0ZW5lciwgZmFsc2UpO1xuICAvLyBJRTgtXG4gIH0gZWxzZSBpZiAoT05SRUFEWVNUQVRFQ0hBTkdFIGluIGNlbCgnc2NyaXB0JykpIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgaHRtbC5hcHBlbmRDaGlsZChjZWwoJ3NjcmlwdCcpKVtPTlJFQURZU1RBVEVDSEFOR0VdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBodG1sLnJlbW92ZUNoaWxkKHRoaXMpO1xuICAgICAgICBydW4uY2FsbChpZCk7XG4gICAgICB9O1xuICAgIH07XG4gIC8vIFJlc3Qgb2xkIGJyb3dzZXJzXG4gIH0gZWxzZSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIHNldFRpbWVvdXQoY3R4KHJ1biwgaWQsIDEpLCAwKTtcbiAgICB9O1xuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2V0OiBzZXRUYXNrLFxuICBjbGVhcjogY2xlYXJUYXNrXG59O1xuIiwidmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcbnZhciBtYXggPSBNYXRoLm1heDtcbnZhciBtaW4gPSBNYXRoLm1pbjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGluZGV4LCBsZW5ndGgpIHtcbiAgaW5kZXggPSB0b0ludGVnZXIoaW5kZXgpO1xuICByZXR1cm4gaW5kZXggPCAwID8gbWF4KGluZGV4ICsgbGVuZ3RoLCAwKSA6IG1pbihpbmRleCwgbGVuZ3RoKTtcbn07XG4iLCIvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy10b2luZGV4XG52YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXQgPT09IHVuZGVmaW5lZCkgcmV0dXJuIDA7XG4gIHZhciBudW1iZXIgPSB0b0ludGVnZXIoaXQpO1xuICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgobnVtYmVyKTtcbiAgaWYgKG51bWJlciAhPT0gbGVuZ3RoKSB0aHJvdyBSYW5nZUVycm9yKCdXcm9uZyBsZW5ndGghJyk7XG4gIHJldHVybiBsZW5ndGg7XG59O1xuIiwiLy8gNy4xLjQgVG9JbnRlZ2VyXG52YXIgY2VpbCA9IE1hdGguY2VpbDtcbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXNOYU4oaXQgPSAraXQpID8gMCA6IChpdCA+IDAgPyBmbG9vciA6IGNlaWwpKGl0KTtcbn07XG4iLCIvLyB0byBpbmRleGVkIG9iamVjdCwgdG9PYmplY3Qgd2l0aCBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIHN0cmluZ3NcbnZhciBJT2JqZWN0ID0gcmVxdWlyZSgnLi9faW9iamVjdCcpO1xudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gSU9iamVjdChkZWZpbmVkKGl0KSk7XG59O1xuIiwiLy8gNy4xLjE1IFRvTGVuZ3RoXG52YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xudmFyIG1pbiA9IE1hdGgubWluO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGl0ID4gMCA/IG1pbih0b0ludGVnZXIoaXQpLCAweDFmZmZmZmZmZmZmZmZmKSA6IDA7IC8vIHBvdygyLCA1MykgLSAxID09IDkwMDcxOTkyNTQ3NDA5OTFcbn07XG4iLCIvLyA3LjEuMTMgVG9PYmplY3QoYXJndW1lbnQpXG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBPYmplY3QoZGVmaW5lZChpdCkpO1xufTtcbiIsIi8vIDcuMS4xIFRvUHJpbWl0aXZlKGlucHV0IFssIFByZWZlcnJlZFR5cGVdKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG4vLyBpbnN0ZWFkIG9mIHRoZSBFUzYgc3BlYyB2ZXJzaW9uLCB3ZSBkaWRuJ3QgaW1wbGVtZW50IEBAdG9QcmltaXRpdmUgY2FzZVxuLy8gYW5kIHRoZSBzZWNvbmQgYXJndW1lbnQgLSBmbGFnIC0gcHJlZmVycmVkIHR5cGUgaXMgYSBzdHJpbmdcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBTKSB7XG4gIGlmICghaXNPYmplY3QoaXQpKSByZXR1cm4gaXQ7XG4gIHZhciBmbiwgdmFsO1xuICBpZiAoUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSkgcmV0dXJuIHZhbDtcbiAgaWYgKHR5cGVvZiAoZm4gPSBpdC52YWx1ZU9mKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpIHJldHVybiB2YWw7XG4gIGlmICghUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSkgcmV0dXJuIHZhbDtcbiAgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gcHJpbWl0aXZlIHZhbHVlXCIpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbmlmIChyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpKSB7XG4gIHZhciBMSUJSQVJZID0gcmVxdWlyZSgnLi9fbGlicmFyeScpO1xuICB2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG4gIHZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG4gIHZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG4gIHZhciAkdHlwZWQgPSByZXF1aXJlKCcuL190eXBlZCcpO1xuICB2YXIgJGJ1ZmZlciA9IHJlcXVpcmUoJy4vX3R5cGVkLWJ1ZmZlcicpO1xuICB2YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG4gIHZhciBhbkluc3RhbmNlID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKTtcbiAgdmFyIHByb3BlcnR5RGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbiAgdmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG4gIHZhciByZWRlZmluZUFsbCA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpO1xuICB2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xuICB2YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbiAgdmFyIHRvSW5kZXggPSByZXF1aXJlKCcuL190by1pbmRleCcpO1xuICB2YXIgdG9BYnNvbHV0ZUluZGV4ID0gcmVxdWlyZSgnLi9fdG8tYWJzb2x1dGUtaW5kZXgnKTtcbiAgdmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7XG4gIHZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbiAgdmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuL19jbGFzc29mJyk7XG4gIHZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xuICB2YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbiAgdmFyIGlzQXJyYXlJdGVyID0gcmVxdWlyZSgnLi9faXMtYXJyYXktaXRlcicpO1xuICB2YXIgY3JlYXRlID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpO1xuICB2YXIgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJyk7XG4gIHZhciBnT1BOID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mO1xuICB2YXIgZ2V0SXRlckZuID0gcmVxdWlyZSgnLi9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QnKTtcbiAgdmFyIHVpZCA9IHJlcXVpcmUoJy4vX3VpZCcpO1xuICB2YXIgd2tzID0gcmVxdWlyZSgnLi9fd2tzJyk7XG4gIHZhciBjcmVhdGVBcnJheU1ldGhvZCA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKTtcbiAgdmFyIGNyZWF0ZUFycmF5SW5jbHVkZXMgPSByZXF1aXJlKCcuL19hcnJheS1pbmNsdWRlcycpO1xuICB2YXIgc3BlY2llc0NvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi9fc3BlY2llcy1jb25zdHJ1Y3RvcicpO1xuICB2YXIgQXJyYXlJdGVyYXRvcnMgPSByZXF1aXJlKCcuL2VzNi5hcnJheS5pdGVyYXRvcicpO1xuICB2YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG4gIHZhciAkaXRlckRldGVjdCA9IHJlcXVpcmUoJy4vX2l0ZXItZGV0ZWN0Jyk7XG4gIHZhciBzZXRTcGVjaWVzID0gcmVxdWlyZSgnLi9fc2V0LXNwZWNpZXMnKTtcbiAgdmFyIGFycmF5RmlsbCA9IHJlcXVpcmUoJy4vX2FycmF5LWZpbGwnKTtcbiAgdmFyIGFycmF5Q29weVdpdGhpbiA9IHJlcXVpcmUoJy4vX2FycmF5LWNvcHktd2l0aGluJyk7XG4gIHZhciAkRFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcbiAgdmFyICRHT1BEID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKTtcbiAgdmFyIGRQID0gJERQLmY7XG4gIHZhciBnT1BEID0gJEdPUEQuZjtcbiAgdmFyIFJhbmdlRXJyb3IgPSBnbG9iYWwuUmFuZ2VFcnJvcjtcbiAgdmFyIFR5cGVFcnJvciA9IGdsb2JhbC5UeXBlRXJyb3I7XG4gIHZhciBVaW50OEFycmF5ID0gZ2xvYmFsLlVpbnQ4QXJyYXk7XG4gIHZhciBBUlJBWV9CVUZGRVIgPSAnQXJyYXlCdWZmZXInO1xuICB2YXIgU0hBUkVEX0JVRkZFUiA9ICdTaGFyZWQnICsgQVJSQVlfQlVGRkVSO1xuICB2YXIgQllURVNfUEVSX0VMRU1FTlQgPSAnQllURVNfUEVSX0VMRU1FTlQnO1xuICB2YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG4gIHZhciBBcnJheVByb3RvID0gQXJyYXlbUFJPVE9UWVBFXTtcbiAgdmFyICRBcnJheUJ1ZmZlciA9ICRidWZmZXIuQXJyYXlCdWZmZXI7XG4gIHZhciAkRGF0YVZpZXcgPSAkYnVmZmVyLkRhdGFWaWV3O1xuICB2YXIgYXJyYXlGb3JFYWNoID0gY3JlYXRlQXJyYXlNZXRob2QoMCk7XG4gIHZhciBhcnJheUZpbHRlciA9IGNyZWF0ZUFycmF5TWV0aG9kKDIpO1xuICB2YXIgYXJyYXlTb21lID0gY3JlYXRlQXJyYXlNZXRob2QoMyk7XG4gIHZhciBhcnJheUV2ZXJ5ID0gY3JlYXRlQXJyYXlNZXRob2QoNCk7XG4gIHZhciBhcnJheUZpbmQgPSBjcmVhdGVBcnJheU1ldGhvZCg1KTtcbiAgdmFyIGFycmF5RmluZEluZGV4ID0gY3JlYXRlQXJyYXlNZXRob2QoNik7XG4gIHZhciBhcnJheUluY2x1ZGVzID0gY3JlYXRlQXJyYXlJbmNsdWRlcyh0cnVlKTtcbiAgdmFyIGFycmF5SW5kZXhPZiA9IGNyZWF0ZUFycmF5SW5jbHVkZXMoZmFsc2UpO1xuICB2YXIgYXJyYXlWYWx1ZXMgPSBBcnJheUl0ZXJhdG9ycy52YWx1ZXM7XG4gIHZhciBhcnJheUtleXMgPSBBcnJheUl0ZXJhdG9ycy5rZXlzO1xuICB2YXIgYXJyYXlFbnRyaWVzID0gQXJyYXlJdGVyYXRvcnMuZW50cmllcztcbiAgdmFyIGFycmF5TGFzdEluZGV4T2YgPSBBcnJheVByb3RvLmxhc3RJbmRleE9mO1xuICB2YXIgYXJyYXlSZWR1Y2UgPSBBcnJheVByb3RvLnJlZHVjZTtcbiAgdmFyIGFycmF5UmVkdWNlUmlnaHQgPSBBcnJheVByb3RvLnJlZHVjZVJpZ2h0O1xuICB2YXIgYXJyYXlKb2luID0gQXJyYXlQcm90by5qb2luO1xuICB2YXIgYXJyYXlTb3J0ID0gQXJyYXlQcm90by5zb3J0O1xuICB2YXIgYXJyYXlTbGljZSA9IEFycmF5UHJvdG8uc2xpY2U7XG4gIHZhciBhcnJheVRvU3RyaW5nID0gQXJyYXlQcm90by50b1N0cmluZztcbiAgdmFyIGFycmF5VG9Mb2NhbGVTdHJpbmcgPSBBcnJheVByb3RvLnRvTG9jYWxlU3RyaW5nO1xuICB2YXIgSVRFUkFUT1IgPSB3a3MoJ2l0ZXJhdG9yJyk7XG4gIHZhciBUQUcgPSB3a3MoJ3RvU3RyaW5nVGFnJyk7XG4gIHZhciBUWVBFRF9DT05TVFJVQ1RPUiA9IHVpZCgndHlwZWRfY29uc3RydWN0b3InKTtcbiAgdmFyIERFRl9DT05TVFJVQ1RPUiA9IHVpZCgnZGVmX2NvbnN0cnVjdG9yJyk7XG4gIHZhciBBTExfQ09OU1RSVUNUT1JTID0gJHR5cGVkLkNPTlNUUjtcbiAgdmFyIFRZUEVEX0FSUkFZID0gJHR5cGVkLlRZUEVEO1xuICB2YXIgVklFVyA9ICR0eXBlZC5WSUVXO1xuICB2YXIgV1JPTkdfTEVOR1RIID0gJ1dyb25nIGxlbmd0aCEnO1xuXG4gIHZhciAkbWFwID0gY3JlYXRlQXJyYXlNZXRob2QoMSwgZnVuY3Rpb24gKE8sIGxlbmd0aCkge1xuICAgIHJldHVybiBhbGxvY2F0ZShzcGVjaWVzQ29uc3RydWN0b3IoTywgT1tERUZfQ09OU1RSVUNUT1JdKSwgbGVuZ3RoKTtcbiAgfSk7XG5cbiAgdmFyIExJVFRMRV9FTkRJQU4gPSBmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KG5ldyBVaW50MTZBcnJheShbMV0pLmJ1ZmZlcilbMF0gPT09IDE7XG4gIH0pO1xuXG4gIHZhciBGT1JDRURfU0VUID0gISFVaW50OEFycmF5ICYmICEhVWludDhBcnJheVtQUk9UT1RZUEVdLnNldCAmJiBmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgbmV3IFVpbnQ4QXJyYXkoMSkuc2V0KHt9KTtcbiAgfSk7XG5cbiAgdmFyIHRvT2Zmc2V0ID0gZnVuY3Rpb24gKGl0LCBCWVRFUykge1xuICAgIHZhciBvZmZzZXQgPSB0b0ludGVnZXIoaXQpO1xuICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCAlIEJZVEVTKSB0aHJvdyBSYW5nZUVycm9yKCdXcm9uZyBvZmZzZXQhJyk7XG4gICAgcmV0dXJuIG9mZnNldDtcbiAgfTtcblxuICB2YXIgdmFsaWRhdGUgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICBpZiAoaXNPYmplY3QoaXQpICYmIFRZUEVEX0FSUkFZIGluIGl0KSByZXR1cm4gaXQ7XG4gICAgdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYSB0eXBlZCBhcnJheSEnKTtcbiAgfTtcblxuICB2YXIgYWxsb2NhdGUgPSBmdW5jdGlvbiAoQywgbGVuZ3RoKSB7XG4gICAgaWYgKCEoaXNPYmplY3QoQykgJiYgVFlQRURfQ09OU1RSVUNUT1IgaW4gQykpIHtcbiAgICAgIHRocm93IFR5cGVFcnJvcignSXQgaXMgbm90IGEgdHlwZWQgYXJyYXkgY29uc3RydWN0b3IhJyk7XG4gICAgfSByZXR1cm4gbmV3IEMobGVuZ3RoKTtcbiAgfTtcblxuICB2YXIgc3BlY2llc0Zyb21MaXN0ID0gZnVuY3Rpb24gKE8sIGxpc3QpIHtcbiAgICByZXR1cm4gZnJvbUxpc3Qoc3BlY2llc0NvbnN0cnVjdG9yKE8sIE9bREVGX0NPTlNUUlVDVE9SXSksIGxpc3QpO1xuICB9O1xuXG4gIHZhciBmcm9tTGlzdCA9IGZ1bmN0aW9uIChDLCBsaXN0KSB7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgbGVuZ3RoID0gbGlzdC5sZW5ndGg7XG4gICAgdmFyIHJlc3VsdCA9IGFsbG9jYXRlKEMsIGxlbmd0aCk7XG4gICAgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSByZXN1bHRbaW5kZXhdID0gbGlzdFtpbmRleCsrXTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIHZhciBhZGRHZXR0ZXIgPSBmdW5jdGlvbiAoaXQsIGtleSwgaW50ZXJuYWwpIHtcbiAgICBkUChpdCwga2V5LCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZFtpbnRlcm5hbF07IH0gfSk7XG4gIH07XG5cbiAgdmFyICRmcm9tID0gZnVuY3Rpb24gZnJvbShzb3VyY2UgLyogLCBtYXBmbiwgdGhpc0FyZyAqLykge1xuICAgIHZhciBPID0gdG9PYmplY3Qoc291cmNlKTtcbiAgICB2YXIgYUxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIG1hcGZuID0gYUxlbiA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQ7XG4gICAgdmFyIG1hcHBpbmcgPSBtYXBmbiAhPT0gdW5kZWZpbmVkO1xuICAgIHZhciBpdGVyRm4gPSBnZXRJdGVyRm4oTyk7XG4gICAgdmFyIGksIGxlbmd0aCwgdmFsdWVzLCByZXN1bHQsIHN0ZXAsIGl0ZXJhdG9yO1xuICAgIGlmIChpdGVyRm4gIT0gdW5kZWZpbmVkICYmICFpc0FycmF5SXRlcihpdGVyRm4pKSB7XG4gICAgICBmb3IgKGl0ZXJhdG9yID0gaXRlckZuLmNhbGwoTyksIHZhbHVlcyA9IFtdLCBpID0gMDsgIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lOyBpKyspIHtcbiAgICAgICAgdmFsdWVzLnB1c2goc3RlcC52YWx1ZSk7XG4gICAgICB9IE8gPSB2YWx1ZXM7XG4gICAgfVxuICAgIGlmIChtYXBwaW5nICYmIGFMZW4gPiAyKSBtYXBmbiA9IGN0eChtYXBmbiwgYXJndW1lbnRzWzJdLCAyKTtcbiAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCksIHJlc3VsdCA9IGFsbG9jYXRlKHRoaXMsIGxlbmd0aCk7IGxlbmd0aCA+IGk7IGkrKykge1xuICAgICAgcmVzdWx0W2ldID0gbWFwcGluZyA/IG1hcGZuKE9baV0sIGkpIDogT1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICB2YXIgJG9mID0gZnVuY3Rpb24gb2YoLyogLi4uaXRlbXMgKi8pIHtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciByZXN1bHQgPSBhbGxvY2F0ZSh0aGlzLCBsZW5ndGgpO1xuICAgIHdoaWxlIChsZW5ndGggPiBpbmRleCkgcmVzdWx0W2luZGV4XSA9IGFyZ3VtZW50c1tpbmRleCsrXTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIGlPUyBTYWZhcmkgNi54IGZhaWxzIGhlcmVcbiAgdmFyIFRPX0xPQ0FMRV9CVUcgPSAhIVVpbnQ4QXJyYXkgJiYgZmFpbHMoZnVuY3Rpb24gKCkgeyBhcnJheVRvTG9jYWxlU3RyaW5nLmNhbGwobmV3IFVpbnQ4QXJyYXkoMSkpOyB9KTtcblxuICB2YXIgJHRvTG9jYWxlU3RyaW5nID0gZnVuY3Rpb24gdG9Mb2NhbGVTdHJpbmcoKSB7XG4gICAgcmV0dXJuIGFycmF5VG9Mb2NhbGVTdHJpbmcuYXBwbHkoVE9fTE9DQUxFX0JVRyA/IGFycmF5U2xpY2UuY2FsbCh2YWxpZGF0ZSh0aGlzKSkgOiB2YWxpZGF0ZSh0aGlzKSwgYXJndW1lbnRzKTtcbiAgfTtcblxuICB2YXIgcHJvdG8gPSB7XG4gICAgY29weVdpdGhpbjogZnVuY3Rpb24gY29weVdpdGhpbih0YXJnZXQsIHN0YXJ0IC8qICwgZW5kICovKSB7XG4gICAgICByZXR1cm4gYXJyYXlDb3B5V2l0aGluLmNhbGwodmFsaWRhdGUodGhpcyksIHRhcmdldCwgc3RhcnQsIGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIGV2ZXJ5OiBmdW5jdGlvbiBldmVyeShjYWxsYmFja2ZuIC8qICwgdGhpc0FyZyAqLykge1xuICAgICAgcmV0dXJuIGFycmF5RXZlcnkodmFsaWRhdGUodGhpcyksIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIGZpbGw6IGZ1bmN0aW9uIGZpbGwodmFsdWUgLyogLCBzdGFydCwgZW5kICovKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIHJldHVybiBhcnJheUZpbGwuYXBwbHkodmFsaWRhdGUodGhpcyksIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICBmaWx0ZXI6IGZ1bmN0aW9uIGZpbHRlcihjYWxsYmFja2ZuIC8qICwgdGhpc0FyZyAqLykge1xuICAgICAgcmV0dXJuIHNwZWNpZXNGcm9tTGlzdCh0aGlzLCBhcnJheUZpbHRlcih2YWxpZGF0ZSh0aGlzKSwgY2FsbGJhY2tmbixcbiAgICAgICAgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpKTtcbiAgICB9LFxuICAgIGZpbmQ6IGZ1bmN0aW9uIGZpbmQocHJlZGljYXRlIC8qICwgdGhpc0FyZyAqLykge1xuICAgICAgcmV0dXJuIGFycmF5RmluZCh2YWxpZGF0ZSh0aGlzKSwgcHJlZGljYXRlLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBmaW5kSW5kZXg6IGZ1bmN0aW9uIGZpbmRJbmRleChwcmVkaWNhdGUgLyogLCB0aGlzQXJnICovKSB7XG4gICAgICByZXR1cm4gYXJyYXlGaW5kSW5kZXgodmFsaWRhdGUodGhpcyksIHByZWRpY2F0ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgZm9yRWFjaDogZnVuY3Rpb24gZm9yRWFjaChjYWxsYmFja2ZuIC8qICwgdGhpc0FyZyAqLykge1xuICAgICAgYXJyYXlGb3JFYWNoKHZhbGlkYXRlKHRoaXMpLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBpbmRleE9mOiBmdW5jdGlvbiBpbmRleE9mKHNlYXJjaEVsZW1lbnQgLyogLCBmcm9tSW5kZXggKi8pIHtcbiAgICAgIHJldHVybiBhcnJheUluZGV4T2YodmFsaWRhdGUodGhpcyksIHNlYXJjaEVsZW1lbnQsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIGluY2x1ZGVzOiBmdW5jdGlvbiBpbmNsdWRlcyhzZWFyY2hFbGVtZW50IC8qICwgZnJvbUluZGV4ICovKSB7XG4gICAgICByZXR1cm4gYXJyYXlJbmNsdWRlcyh2YWxpZGF0ZSh0aGlzKSwgc2VhcmNoRWxlbWVudCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgam9pbjogZnVuY3Rpb24gam9pbihzZXBhcmF0b3IpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgcmV0dXJuIGFycmF5Sm9pbi5hcHBseSh2YWxpZGF0ZSh0aGlzKSwgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIGxhc3RJbmRleE9mOiBmdW5jdGlvbiBsYXN0SW5kZXhPZihzZWFyY2hFbGVtZW50IC8qICwgZnJvbUluZGV4ICovKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIHJldHVybiBhcnJheUxhc3RJbmRleE9mLmFwcGx5KHZhbGlkYXRlKHRoaXMpLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgbWFwOiBmdW5jdGlvbiBtYXAobWFwZm4gLyogLCB0aGlzQXJnICovKSB7XG4gICAgICByZXR1cm4gJG1hcCh2YWxpZGF0ZSh0aGlzKSwgbWFwZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIHJlZHVjZTogZnVuY3Rpb24gcmVkdWNlKGNhbGxiYWNrZm4gLyogLCBpbml0aWFsVmFsdWUgKi8pIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgcmV0dXJuIGFycmF5UmVkdWNlLmFwcGx5KHZhbGlkYXRlKHRoaXMpLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgcmVkdWNlUmlnaHQ6IGZ1bmN0aW9uIHJlZHVjZVJpZ2h0KGNhbGxiYWNrZm4gLyogLCBpbml0aWFsVmFsdWUgKi8pIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgcmV0dXJuIGFycmF5UmVkdWNlUmlnaHQuYXBwbHkodmFsaWRhdGUodGhpcyksIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICByZXZlcnNlOiBmdW5jdGlvbiByZXZlcnNlKCkge1xuICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgdmFyIGxlbmd0aCA9IHZhbGlkYXRlKHRoYXQpLmxlbmd0aDtcbiAgICAgIHZhciBtaWRkbGUgPSBNYXRoLmZsb29yKGxlbmd0aCAvIDIpO1xuICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgIHZhciB2YWx1ZTtcbiAgICAgIHdoaWxlIChpbmRleCA8IG1pZGRsZSkge1xuICAgICAgICB2YWx1ZSA9IHRoYXRbaW5kZXhdO1xuICAgICAgICB0aGF0W2luZGV4KytdID0gdGhhdFstLWxlbmd0aF07XG4gICAgICAgIHRoYXRbbGVuZ3RoXSA9IHZhbHVlO1xuICAgICAgfSByZXR1cm4gdGhhdDtcbiAgICB9LFxuICAgIHNvbWU6IGZ1bmN0aW9uIHNvbWUoY2FsbGJhY2tmbiAvKiAsIHRoaXNBcmcgKi8pIHtcbiAgICAgIHJldHVybiBhcnJheVNvbWUodmFsaWRhdGUodGhpcyksIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIHNvcnQ6IGZ1bmN0aW9uIHNvcnQoY29tcGFyZWZuKSB7XG4gICAgICByZXR1cm4gYXJyYXlTb3J0LmNhbGwodmFsaWRhdGUodGhpcyksIGNvbXBhcmVmbik7XG4gICAgfSxcbiAgICBzdWJhcnJheTogZnVuY3Rpb24gc3ViYXJyYXkoYmVnaW4sIGVuZCkge1xuICAgICAgdmFyIE8gPSB2YWxpZGF0ZSh0aGlzKTtcbiAgICAgIHZhciBsZW5ndGggPSBPLmxlbmd0aDtcbiAgICAgIHZhciAkYmVnaW4gPSB0b0Fic29sdXRlSW5kZXgoYmVnaW4sIGxlbmd0aCk7XG4gICAgICByZXR1cm4gbmV3IChzcGVjaWVzQ29uc3RydWN0b3IoTywgT1tERUZfQ09OU1RSVUNUT1JdKSkoXG4gICAgICAgIE8uYnVmZmVyLFxuICAgICAgICBPLmJ5dGVPZmZzZXQgKyAkYmVnaW4gKiBPLkJZVEVTX1BFUl9FTEVNRU5ULFxuICAgICAgICB0b0xlbmd0aCgoZW5kID09PSB1bmRlZmluZWQgPyBsZW5ndGggOiB0b0Fic29sdXRlSW5kZXgoZW5kLCBsZW5ndGgpKSAtICRiZWdpbilcbiAgICAgICk7XG4gICAgfVxuICB9O1xuXG4gIHZhciAkc2xpY2UgPSBmdW5jdGlvbiBzbGljZShzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIHNwZWNpZXNGcm9tTGlzdCh0aGlzLCBhcnJheVNsaWNlLmNhbGwodmFsaWRhdGUodGhpcyksIHN0YXJ0LCBlbmQpKTtcbiAgfTtcblxuICB2YXIgJHNldCA9IGZ1bmN0aW9uIHNldChhcnJheUxpa2UgLyogLCBvZmZzZXQgKi8pIHtcbiAgICB2YWxpZGF0ZSh0aGlzKTtcbiAgICB2YXIgb2Zmc2V0ID0gdG9PZmZzZXQoYXJndW1lbnRzWzFdLCAxKTtcbiAgICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGg7XG4gICAgdmFyIHNyYyA9IHRvT2JqZWN0KGFycmF5TGlrZSk7XG4gICAgdmFyIGxlbiA9IHRvTGVuZ3RoKHNyYy5sZW5ndGgpO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgaWYgKGxlbiArIG9mZnNldCA+IGxlbmd0aCkgdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19MRU5HVEgpO1xuICAgIHdoaWxlIChpbmRleCA8IGxlbikgdGhpc1tvZmZzZXQgKyBpbmRleF0gPSBzcmNbaW5kZXgrK107XG4gIH07XG5cbiAgdmFyICRpdGVyYXRvcnMgPSB7XG4gICAgZW50cmllczogZnVuY3Rpb24gZW50cmllcygpIHtcbiAgICAgIHJldHVybiBhcnJheUVudHJpZXMuY2FsbCh2YWxpZGF0ZSh0aGlzKSk7XG4gICAgfSxcbiAgICBrZXlzOiBmdW5jdGlvbiBrZXlzKCkge1xuICAgICAgcmV0dXJuIGFycmF5S2V5cy5jYWxsKHZhbGlkYXRlKHRoaXMpKTtcbiAgICB9LFxuICAgIHZhbHVlczogZnVuY3Rpb24gdmFsdWVzKCkge1xuICAgICAgcmV0dXJuIGFycmF5VmFsdWVzLmNhbGwodmFsaWRhdGUodGhpcykpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgaXNUQUluZGV4ID0gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7XG4gICAgcmV0dXJuIGlzT2JqZWN0KHRhcmdldClcbiAgICAgICYmIHRhcmdldFtUWVBFRF9BUlJBWV1cbiAgICAgICYmIHR5cGVvZiBrZXkgIT0gJ3N5bWJvbCdcbiAgICAgICYmIGtleSBpbiB0YXJnZXRcbiAgICAgICYmIFN0cmluZygra2V5KSA9PSBTdHJpbmcoa2V5KTtcbiAgfTtcbiAgdmFyICRnZXREZXNjID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSB7XG4gICAgcmV0dXJuIGlzVEFJbmRleCh0YXJnZXQsIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSkpXG4gICAgICA/IHByb3BlcnR5RGVzYygyLCB0YXJnZXRba2V5XSlcbiAgICAgIDogZ09QRCh0YXJnZXQsIGtleSk7XG4gIH07XG4gIHZhciAkc2V0RGVzYyA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgaWYgKGlzVEFJbmRleCh0YXJnZXQsIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSkpXG4gICAgICAmJiBpc09iamVjdChkZXNjKVxuICAgICAgJiYgaGFzKGRlc2MsICd2YWx1ZScpXG4gICAgICAmJiAhaGFzKGRlc2MsICdnZXQnKVxuICAgICAgJiYgIWhhcyhkZXNjLCAnc2V0JylcbiAgICAgIC8vIFRPRE86IGFkZCB2YWxpZGF0aW9uIGRlc2NyaXB0b3Igdy9vIGNhbGxpbmcgYWNjZXNzb3JzXG4gICAgICAmJiAhZGVzYy5jb25maWd1cmFibGVcbiAgICAgICYmICghaGFzKGRlc2MsICd3cml0YWJsZScpIHx8IGRlc2Mud3JpdGFibGUpXG4gICAgICAmJiAoIWhhcyhkZXNjLCAnZW51bWVyYWJsZScpIHx8IGRlc2MuZW51bWVyYWJsZSlcbiAgICApIHtcbiAgICAgIHRhcmdldFtrZXldID0gZGVzYy52YWx1ZTtcbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfSByZXR1cm4gZFAodGFyZ2V0LCBrZXksIGRlc2MpO1xuICB9O1xuXG4gIGlmICghQUxMX0NPTlNUUlVDVE9SUykge1xuICAgICRHT1BELmYgPSAkZ2V0RGVzYztcbiAgICAkRFAuZiA9ICRzZXREZXNjO1xuICB9XG5cbiAgJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhQUxMX0NPTlNUUlVDVE9SUywgJ09iamVjdCcsIHtcbiAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6ICRnZXREZXNjLFxuICAgIGRlZmluZVByb3BlcnR5OiAkc2V0RGVzY1xuICB9KTtcblxuICBpZiAoZmFpbHMoZnVuY3Rpb24gKCkgeyBhcnJheVRvU3RyaW5nLmNhbGwoe30pOyB9KSkge1xuICAgIGFycmF5VG9TdHJpbmcgPSBhcnJheVRvTG9jYWxlU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gYXJyYXlKb2luLmNhbGwodGhpcyk7XG4gICAgfTtcbiAgfVxuXG4gIHZhciAkVHlwZWRBcnJheVByb3RvdHlwZSQgPSByZWRlZmluZUFsbCh7fSwgcHJvdG8pO1xuICByZWRlZmluZUFsbCgkVHlwZWRBcnJheVByb3RvdHlwZSQsICRpdGVyYXRvcnMpO1xuICBoaWRlKCRUeXBlZEFycmF5UHJvdG90eXBlJCwgSVRFUkFUT1IsICRpdGVyYXRvcnMudmFsdWVzKTtcbiAgcmVkZWZpbmVBbGwoJFR5cGVkQXJyYXlQcm90b3R5cGUkLCB7XG4gICAgc2xpY2U6ICRzbGljZSxcbiAgICBzZXQ6ICRzZXQsXG4gICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uICgpIHsgLyogbm9vcCAqLyB9LFxuICAgIHRvU3RyaW5nOiBhcnJheVRvU3RyaW5nLFxuICAgIHRvTG9jYWxlU3RyaW5nOiAkdG9Mb2NhbGVTdHJpbmdcbiAgfSk7XG4gIGFkZEdldHRlcigkVHlwZWRBcnJheVByb3RvdHlwZSQsICdidWZmZXInLCAnYicpO1xuICBhZGRHZXR0ZXIoJFR5cGVkQXJyYXlQcm90b3R5cGUkLCAnYnl0ZU9mZnNldCcsICdvJyk7XG4gIGFkZEdldHRlcigkVHlwZWRBcnJheVByb3RvdHlwZSQsICdieXRlTGVuZ3RoJywgJ2wnKTtcbiAgYWRkR2V0dGVyKCRUeXBlZEFycmF5UHJvdG90eXBlJCwgJ2xlbmd0aCcsICdlJyk7XG4gIGRQKCRUeXBlZEFycmF5UHJvdG90eXBlJCwgVEFHLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzW1RZUEVEX0FSUkFZXTsgfVxuICB9KTtcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LXN0YXRlbWVudHNcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoS0VZLCBCWVRFUywgd3JhcHBlciwgQ0xBTVBFRCkge1xuICAgIENMQU1QRUQgPSAhIUNMQU1QRUQ7XG4gICAgdmFyIE5BTUUgPSBLRVkgKyAoQ0xBTVBFRCA/ICdDbGFtcGVkJyA6ICcnKSArICdBcnJheSc7XG4gICAgdmFyIEdFVFRFUiA9ICdnZXQnICsgS0VZO1xuICAgIHZhciBTRVRURVIgPSAnc2V0JyArIEtFWTtcbiAgICB2YXIgVHlwZWRBcnJheSA9IGdsb2JhbFtOQU1FXTtcbiAgICB2YXIgQmFzZSA9IFR5cGVkQXJyYXkgfHwge307XG4gICAgdmFyIFRBQyA9IFR5cGVkQXJyYXkgJiYgZ2V0UHJvdG90eXBlT2YoVHlwZWRBcnJheSk7XG4gICAgdmFyIEZPUkNFRCA9ICFUeXBlZEFycmF5IHx8ICEkdHlwZWQuQUJWO1xuICAgIHZhciBPID0ge307XG4gICAgdmFyIFR5cGVkQXJyYXlQcm90b3R5cGUgPSBUeXBlZEFycmF5ICYmIFR5cGVkQXJyYXlbUFJPVE9UWVBFXTtcbiAgICB2YXIgZ2V0dGVyID0gZnVuY3Rpb24gKHRoYXQsIGluZGV4KSB7XG4gICAgICB2YXIgZGF0YSA9IHRoYXQuX2Q7XG4gICAgICByZXR1cm4gZGF0YS52W0dFVFRFUl0oaW5kZXggKiBCWVRFUyArIGRhdGEubywgTElUVExFX0VORElBTik7XG4gICAgfTtcbiAgICB2YXIgc2V0dGVyID0gZnVuY3Rpb24gKHRoYXQsIGluZGV4LCB2YWx1ZSkge1xuICAgICAgdmFyIGRhdGEgPSB0aGF0Ll9kO1xuICAgICAgaWYgKENMQU1QRUQpIHZhbHVlID0gKHZhbHVlID0gTWF0aC5yb3VuZCh2YWx1ZSkpIDwgMCA/IDAgOiB2YWx1ZSA+IDB4ZmYgPyAweGZmIDogdmFsdWUgJiAweGZmO1xuICAgICAgZGF0YS52W1NFVFRFUl0oaW5kZXggKiBCWVRFUyArIGRhdGEubywgdmFsdWUsIExJVFRMRV9FTkRJQU4pO1xuICAgIH07XG4gICAgdmFyIGFkZEVsZW1lbnQgPSBmdW5jdGlvbiAodGhhdCwgaW5kZXgpIHtcbiAgICAgIGRQKHRoYXQsIGluZGV4LCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBnZXR0ZXIodGhpcywgaW5kZXgpO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBzZXR0ZXIodGhpcywgaW5kZXgsIHZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBpZiAoRk9SQ0VEKSB7XG4gICAgICBUeXBlZEFycmF5ID0gd3JhcHBlcihmdW5jdGlvbiAodGhhdCwgZGF0YSwgJG9mZnNldCwgJGxlbmd0aCkge1xuICAgICAgICBhbkluc3RhbmNlKHRoYXQsIFR5cGVkQXJyYXksIE5BTUUsICdfZCcpO1xuICAgICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICAgICAgdmFyIGJ1ZmZlciwgYnl0ZUxlbmd0aCwgbGVuZ3RoLCBrbGFzcztcbiAgICAgICAgaWYgKCFpc09iamVjdChkYXRhKSkge1xuICAgICAgICAgIGxlbmd0aCA9IHRvSW5kZXgoZGF0YSk7XG4gICAgICAgICAgYnl0ZUxlbmd0aCA9IGxlbmd0aCAqIEJZVEVTO1xuICAgICAgICAgIGJ1ZmZlciA9IG5ldyAkQXJyYXlCdWZmZXIoYnl0ZUxlbmd0aCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mICRBcnJheUJ1ZmZlciB8fCAoa2xhc3MgPSBjbGFzc29mKGRhdGEpKSA9PSBBUlJBWV9CVUZGRVIgfHwga2xhc3MgPT0gU0hBUkVEX0JVRkZFUikge1xuICAgICAgICAgIGJ1ZmZlciA9IGRhdGE7XG4gICAgICAgICAgb2Zmc2V0ID0gdG9PZmZzZXQoJG9mZnNldCwgQllURVMpO1xuICAgICAgICAgIHZhciAkbGVuID0gZGF0YS5ieXRlTGVuZ3RoO1xuICAgICAgICAgIGlmICgkbGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICgkbGVuICUgQllURVMpIHRocm93IFJhbmdlRXJyb3IoV1JPTkdfTEVOR1RIKTtcbiAgICAgICAgICAgIGJ5dGVMZW5ndGggPSAkbGVuIC0gb2Zmc2V0O1xuICAgICAgICAgICAgaWYgKGJ5dGVMZW5ndGggPCAwKSB0aHJvdyBSYW5nZUVycm9yKFdST05HX0xFTkdUSCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJ5dGVMZW5ndGggPSB0b0xlbmd0aCgkbGVuZ3RoKSAqIEJZVEVTO1xuICAgICAgICAgICAgaWYgKGJ5dGVMZW5ndGggKyBvZmZzZXQgPiAkbGVuKSB0aHJvdyBSYW5nZUVycm9yKFdST05HX0xFTkdUSCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxlbmd0aCA9IGJ5dGVMZW5ndGggLyBCWVRFUztcbiAgICAgICAgfSBlbHNlIGlmIChUWVBFRF9BUlJBWSBpbiBkYXRhKSB7XG4gICAgICAgICAgcmV0dXJuIGZyb21MaXN0KFR5cGVkQXJyYXksIGRhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiAkZnJvbS5jYWxsKFR5cGVkQXJyYXksIGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGhpZGUodGhhdCwgJ19kJywge1xuICAgICAgICAgIGI6IGJ1ZmZlcixcbiAgICAgICAgICBvOiBvZmZzZXQsXG4gICAgICAgICAgbDogYnl0ZUxlbmd0aCxcbiAgICAgICAgICBlOiBsZW5ndGgsXG4gICAgICAgICAgdjogbmV3ICREYXRhVmlldyhidWZmZXIpXG4gICAgICAgIH0pO1xuICAgICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIGFkZEVsZW1lbnQodGhhdCwgaW5kZXgrKyk7XG4gICAgICB9KTtcbiAgICAgIFR5cGVkQXJyYXlQcm90b3R5cGUgPSBUeXBlZEFycmF5W1BST1RPVFlQRV0gPSBjcmVhdGUoJFR5cGVkQXJyYXlQcm90b3R5cGUkKTtcbiAgICAgIGhpZGUoVHlwZWRBcnJheVByb3RvdHlwZSwgJ2NvbnN0cnVjdG9yJywgVHlwZWRBcnJheSk7XG4gICAgfSBlbHNlIGlmICghZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgICAgVHlwZWRBcnJheSgxKTtcbiAgICB9KSB8fCAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgICAgbmV3IFR5cGVkQXJyYXkoLTEpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgIH0pIHx8ICEkaXRlckRldGVjdChmdW5jdGlvbiAoaXRlcikge1xuICAgICAgbmV3IFR5cGVkQXJyYXkoKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICAgIG5ldyBUeXBlZEFycmF5KG51bGwpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgICAgbmV3IFR5cGVkQXJyYXkoMS41KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICAgIG5ldyBUeXBlZEFycmF5KGl0ZXIpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgIH0sIHRydWUpKSB7XG4gICAgICBUeXBlZEFycmF5ID0gd3JhcHBlcihmdW5jdGlvbiAodGhhdCwgZGF0YSwgJG9mZnNldCwgJGxlbmd0aCkge1xuICAgICAgICBhbkluc3RhbmNlKHRoYXQsIFR5cGVkQXJyYXksIE5BTUUpO1xuICAgICAgICB2YXIga2xhc3M7XG4gICAgICAgIC8vIGB3c2AgbW9kdWxlIGJ1ZywgdGVtcG9yYXJpbHkgcmVtb3ZlIHZhbGlkYXRpb24gbGVuZ3RoIGZvciBVaW50OEFycmF5XG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJzb2NrZXRzL3dzL3B1bGwvNjQ1XG4gICAgICAgIGlmICghaXNPYmplY3QoZGF0YSkpIHJldHVybiBuZXcgQmFzZSh0b0luZGV4KGRhdGEpKTtcbiAgICAgICAgaWYgKGRhdGEgaW5zdGFuY2VvZiAkQXJyYXlCdWZmZXIgfHwgKGtsYXNzID0gY2xhc3NvZihkYXRhKSkgPT0gQVJSQVlfQlVGRkVSIHx8IGtsYXNzID09IFNIQVJFRF9CVUZGRVIpIHtcbiAgICAgICAgICByZXR1cm4gJGxlbmd0aCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IG5ldyBCYXNlKGRhdGEsIHRvT2Zmc2V0KCRvZmZzZXQsIEJZVEVTKSwgJGxlbmd0aClcbiAgICAgICAgICAgIDogJG9mZnNldCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgID8gbmV3IEJhc2UoZGF0YSwgdG9PZmZzZXQoJG9mZnNldCwgQllURVMpKVxuICAgICAgICAgICAgICA6IG5ldyBCYXNlKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChUWVBFRF9BUlJBWSBpbiBkYXRhKSByZXR1cm4gZnJvbUxpc3QoVHlwZWRBcnJheSwgZGF0YSk7XG4gICAgICAgIHJldHVybiAkZnJvbS5jYWxsKFR5cGVkQXJyYXksIGRhdGEpO1xuICAgICAgfSk7XG4gICAgICBhcnJheUZvckVhY2goVEFDICE9PSBGdW5jdGlvbi5wcm90b3R5cGUgPyBnT1BOKEJhc2UpLmNvbmNhdChnT1BOKFRBQykpIDogZ09QTihCYXNlKSwgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAoIShrZXkgaW4gVHlwZWRBcnJheSkpIGhpZGUoVHlwZWRBcnJheSwga2V5LCBCYXNlW2tleV0pO1xuICAgICAgfSk7XG4gICAgICBUeXBlZEFycmF5W1BST1RPVFlQRV0gPSBUeXBlZEFycmF5UHJvdG90eXBlO1xuICAgICAgaWYgKCFMSUJSQVJZKSBUeXBlZEFycmF5UHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVHlwZWRBcnJheTtcbiAgICB9XG4gICAgdmFyICRuYXRpdmVJdGVyYXRvciA9IFR5cGVkQXJyYXlQcm90b3R5cGVbSVRFUkFUT1JdO1xuICAgIHZhciBDT1JSRUNUX0lURVJfTkFNRSA9ICEhJG5hdGl2ZUl0ZXJhdG9yXG4gICAgICAmJiAoJG5hdGl2ZUl0ZXJhdG9yLm5hbWUgPT0gJ3ZhbHVlcycgfHwgJG5hdGl2ZUl0ZXJhdG9yLm5hbWUgPT0gdW5kZWZpbmVkKTtcbiAgICB2YXIgJGl0ZXJhdG9yID0gJGl0ZXJhdG9ycy52YWx1ZXM7XG4gICAgaGlkZShUeXBlZEFycmF5LCBUWVBFRF9DT05TVFJVQ1RPUiwgdHJ1ZSk7XG4gICAgaGlkZShUeXBlZEFycmF5UHJvdG90eXBlLCBUWVBFRF9BUlJBWSwgTkFNRSk7XG4gICAgaGlkZShUeXBlZEFycmF5UHJvdG90eXBlLCBWSUVXLCB0cnVlKTtcbiAgICBoaWRlKFR5cGVkQXJyYXlQcm90b3R5cGUsIERFRl9DT05TVFJVQ1RPUiwgVHlwZWRBcnJheSk7XG5cbiAgICBpZiAoQ0xBTVBFRCA/IG5ldyBUeXBlZEFycmF5KDEpW1RBR10gIT0gTkFNRSA6ICEoVEFHIGluIFR5cGVkQXJyYXlQcm90b3R5cGUpKSB7XG4gICAgICBkUChUeXBlZEFycmF5UHJvdG90eXBlLCBUQUcsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBOQU1FOyB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBPW05BTUVdID0gVHlwZWRBcnJheTtcblxuICAgICRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogKFR5cGVkQXJyYXkgIT0gQmFzZSksIE8pO1xuXG4gICAgJGV4cG9ydCgkZXhwb3J0LlMsIE5BTUUsIHtcbiAgICAgIEJZVEVTX1BFUl9FTEVNRU5UOiBCWVRFU1xuICAgIH0pO1xuXG4gICAgJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiBmYWlscyhmdW5jdGlvbiAoKSB7IEJhc2Uub2YuY2FsbChUeXBlZEFycmF5LCAxKTsgfSksIE5BTUUsIHtcbiAgICAgIGZyb206ICRmcm9tLFxuICAgICAgb2Y6ICRvZlxuICAgIH0pO1xuXG4gICAgaWYgKCEoQllURVNfUEVSX0VMRU1FTlQgaW4gVHlwZWRBcnJheVByb3RvdHlwZSkpIGhpZGUoVHlwZWRBcnJheVByb3RvdHlwZSwgQllURVNfUEVSX0VMRU1FTlQsIEJZVEVTKTtcblxuICAgICRleHBvcnQoJGV4cG9ydC5QLCBOQU1FLCBwcm90byk7XG5cbiAgICBzZXRTcGVjaWVzKE5BTUUpO1xuXG4gICAgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiBGT1JDRURfU0VULCBOQU1FLCB7IHNldDogJHNldCB9KTtcblxuICAgICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogIUNPUlJFQ1RfSVRFUl9OQU1FLCBOQU1FLCAkaXRlcmF0b3JzKTtcblxuICAgIGlmICghTElCUkFSWSAmJiBUeXBlZEFycmF5UHJvdG90eXBlLnRvU3RyaW5nICE9IGFycmF5VG9TdHJpbmcpIFR5cGVkQXJyYXlQcm90b3R5cGUudG9TdHJpbmcgPSBhcnJheVRvU3RyaW5nO1xuXG4gICAgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiBmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgICBuZXcgVHlwZWRBcnJheSgxKS5zbGljZSgpO1xuICAgIH0pLCBOQU1FLCB7IHNsaWNlOiAkc2xpY2UgfSk7XG5cbiAgICAkZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIChmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gWzEsIDJdLnRvTG9jYWxlU3RyaW5nKCkgIT0gbmV3IFR5cGVkQXJyYXkoWzEsIDJdKS50b0xvY2FsZVN0cmluZygpO1xuICAgIH0pIHx8ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgICBUeXBlZEFycmF5UHJvdG90eXBlLnRvTG9jYWxlU3RyaW5nLmNhbGwoWzEsIDJdKTtcbiAgICB9KSksIE5BTUUsIHsgdG9Mb2NhbGVTdHJpbmc6ICR0b0xvY2FsZVN0cmluZyB9KTtcblxuICAgIEl0ZXJhdG9yc1tOQU1FXSA9IENPUlJFQ1RfSVRFUl9OQU1FID8gJG5hdGl2ZUl0ZXJhdG9yIDogJGl0ZXJhdG9yO1xuICAgIGlmICghTElCUkFSWSAmJiAhQ09SUkVDVF9JVEVSX05BTUUpIGhpZGUoVHlwZWRBcnJheVByb3RvdHlwZSwgSVRFUkFUT1IsICRpdGVyYXRvcik7XG4gIH07XG59IGVsc2UgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpO1xudmFyIExJQlJBUlkgPSByZXF1aXJlKCcuL19saWJyYXJ5Jyk7XG52YXIgJHR5cGVkID0gcmVxdWlyZSgnLi9fdHlwZWQnKTtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xudmFyIHJlZGVmaW5lQWxsID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUtYWxsJyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xudmFyIGFuSW5zdGFuY2UgPSByZXF1aXJlKCcuL19hbi1pbnN0YW5jZScpO1xudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIHRvSW5kZXggPSByZXF1aXJlKCcuL190by1pbmRleCcpO1xudmFyIGdPUE4gPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbicpLmY7XG52YXIgZFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mO1xudmFyIGFycmF5RmlsbCA9IHJlcXVpcmUoJy4vX2FycmF5LWZpbGwnKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJyk7XG52YXIgQVJSQVlfQlVGRkVSID0gJ0FycmF5QnVmZmVyJztcbnZhciBEQVRBX1ZJRVcgPSAnRGF0YVZpZXcnO1xudmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xudmFyIFdST05HX0xFTkdUSCA9ICdXcm9uZyBsZW5ndGghJztcbnZhciBXUk9OR19JTkRFWCA9ICdXcm9uZyBpbmRleCEnO1xudmFyICRBcnJheUJ1ZmZlciA9IGdsb2JhbFtBUlJBWV9CVUZGRVJdO1xudmFyICREYXRhVmlldyA9IGdsb2JhbFtEQVRBX1ZJRVddO1xudmFyIE1hdGggPSBnbG9iYWwuTWF0aDtcbnZhciBSYW5nZUVycm9yID0gZ2xvYmFsLlJhbmdlRXJyb3I7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2hhZG93LXJlc3RyaWN0ZWQtbmFtZXNcbnZhciBJbmZpbml0eSA9IGdsb2JhbC5JbmZpbml0eTtcbnZhciBCYXNlQnVmZmVyID0gJEFycmF5QnVmZmVyO1xudmFyIGFicyA9IE1hdGguYWJzO1xudmFyIHBvdyA9IE1hdGgucG93O1xudmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbnZhciBsb2cgPSBNYXRoLmxvZztcbnZhciBMTjIgPSBNYXRoLkxOMjtcbnZhciBCVUZGRVIgPSAnYnVmZmVyJztcbnZhciBCWVRFX0xFTkdUSCA9ICdieXRlTGVuZ3RoJztcbnZhciBCWVRFX09GRlNFVCA9ICdieXRlT2Zmc2V0JztcbnZhciAkQlVGRkVSID0gREVTQ1JJUFRPUlMgPyAnX2InIDogQlVGRkVSO1xudmFyICRMRU5HVEggPSBERVNDUklQVE9SUyA/ICdfbCcgOiBCWVRFX0xFTkdUSDtcbnZhciAkT0ZGU0VUID0gREVTQ1JJUFRPUlMgPyAnX28nIDogQllURV9PRkZTRVQ7XG5cbi8vIElFRUU3NTQgY29udmVyc2lvbnMgYmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9pZWVlNzU0XG5mdW5jdGlvbiBwYWNrSUVFRTc1NCh2YWx1ZSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBidWZmZXIgPSBBcnJheShuQnl0ZXMpO1xuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMTtcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDE7XG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMTtcbiAgdmFyIHJ0ID0gbUxlbiA9PT0gMjMgPyBwb3coMiwgLTI0KSAtIHBvdygyLCAtNzcpIDogMDtcbiAgdmFyIGkgPSAwO1xuICB2YXIgcyA9IHZhbHVlIDwgMCB8fCB2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwID8gMSA6IDA7XG4gIHZhciBlLCBtLCBjO1xuICB2YWx1ZSA9IGFicyh2YWx1ZSk7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgaWYgKHZhbHVlICE9IHZhbHVlIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICBtID0gdmFsdWUgIT0gdmFsdWUgPyAxIDogMDtcbiAgICBlID0gZU1heDtcbiAgfSBlbHNlIHtcbiAgICBlID0gZmxvb3IobG9nKHZhbHVlKSAvIExOMik7XG4gICAgaWYgKHZhbHVlICogKGMgPSBwb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLTtcbiAgICAgIGMgKj0gMjtcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogcG93KDIsIDEgLSBlQmlhcyk7XG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrO1xuICAgICAgYyAvPSAyO1xuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwO1xuICAgICAgZSA9IGVNYXg7XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICh2YWx1ZSAqIGMgLSAxKSAqIHBvdygyLCBtTGVuKTtcbiAgICAgIGUgPSBlICsgZUJpYXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIHBvdygyLCBlQmlhcyAtIDEpICogcG93KDIsIG1MZW4pO1xuICAgICAgZSA9IDA7XG4gICAgfVxuICB9XG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltpKytdID0gbSAmIDI1NSwgbSAvPSAyNTYsIG1MZW4gLT0gOCk7XG4gIGUgPSBlIDw8IG1MZW4gfCBtO1xuICBlTGVuICs9IG1MZW47XG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW2krK10gPSBlICYgMjU1LCBlIC89IDI1NiwgZUxlbiAtPSA4KTtcbiAgYnVmZmVyWy0taV0gfD0gcyAqIDEyODtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cbmZ1bmN0aW9uIHVucGFja0lFRUU3NTQoYnVmZmVyLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDE7XG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxO1xuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDE7XG4gIHZhciBuQml0cyA9IGVMZW4gLSA3O1xuICB2YXIgaSA9IG5CeXRlcyAtIDE7XG4gIHZhciBzID0gYnVmZmVyW2ktLV07XG4gIHZhciBlID0gcyAmIDEyNztcbiAgdmFyIG07XG4gIHMgPj49IDc7XG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSBlICogMjU2ICsgYnVmZmVyW2ldLCBpLS0sIG5CaXRzIC09IDgpO1xuICBtID0gZSAmICgxIDw8IC1uQml0cykgLSAxO1xuICBlID4+PSAtbkJpdHM7XG4gIG5CaXRzICs9IG1MZW47XG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSBtICogMjU2ICsgYnVmZmVyW2ldLCBpLS0sIG5CaXRzIC09IDgpO1xuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXM7XG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogcyA/IC1JbmZpbml0eSA6IEluZmluaXR5O1xuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgcG93KDIsIG1MZW4pO1xuICAgIGUgPSBlIC0gZUJpYXM7XG4gIH0gcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBwb3coMiwgZSAtIG1MZW4pO1xufVxuXG5mdW5jdGlvbiB1bnBhY2tJMzIoYnl0ZXMpIHtcbiAgcmV0dXJuIGJ5dGVzWzNdIDw8IDI0IHwgYnl0ZXNbMl0gPDwgMTYgfCBieXRlc1sxXSA8PCA4IHwgYnl0ZXNbMF07XG59XG5mdW5jdGlvbiBwYWNrSTgoaXQpIHtcbiAgcmV0dXJuIFtpdCAmIDB4ZmZdO1xufVxuZnVuY3Rpb24gcGFja0kxNihpdCkge1xuICByZXR1cm4gW2l0ICYgMHhmZiwgaXQgPj4gOCAmIDB4ZmZdO1xufVxuZnVuY3Rpb24gcGFja0kzMihpdCkge1xuICByZXR1cm4gW2l0ICYgMHhmZiwgaXQgPj4gOCAmIDB4ZmYsIGl0ID4+IDE2ICYgMHhmZiwgaXQgPj4gMjQgJiAweGZmXTtcbn1cbmZ1bmN0aW9uIHBhY2tGNjQoaXQpIHtcbiAgcmV0dXJuIHBhY2tJRUVFNzU0KGl0LCA1MiwgOCk7XG59XG5mdW5jdGlvbiBwYWNrRjMyKGl0KSB7XG4gIHJldHVybiBwYWNrSUVFRTc1NChpdCwgMjMsIDQpO1xufVxuXG5mdW5jdGlvbiBhZGRHZXR0ZXIoQywga2V5LCBpbnRlcm5hbCkge1xuICBkUChDW1BST1RPVFlQRV0sIGtleSwgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXNbaW50ZXJuYWxdOyB9IH0pO1xufVxuXG5mdW5jdGlvbiBnZXQodmlldywgYnl0ZXMsIGluZGV4LCBpc0xpdHRsZUVuZGlhbikge1xuICB2YXIgbnVtSW5kZXggPSAraW5kZXg7XG4gIHZhciBpbnRJbmRleCA9IHRvSW5kZXgobnVtSW5kZXgpO1xuICBpZiAoaW50SW5kZXggKyBieXRlcyA+IHZpZXdbJExFTkdUSF0pIHRocm93IFJhbmdlRXJyb3IoV1JPTkdfSU5ERVgpO1xuICB2YXIgc3RvcmUgPSB2aWV3WyRCVUZGRVJdLl9iO1xuICB2YXIgc3RhcnQgPSBpbnRJbmRleCArIHZpZXdbJE9GRlNFVF07XG4gIHZhciBwYWNrID0gc3RvcmUuc2xpY2Uoc3RhcnQsIHN0YXJ0ICsgYnl0ZXMpO1xuICByZXR1cm4gaXNMaXR0bGVFbmRpYW4gPyBwYWNrIDogcGFjay5yZXZlcnNlKCk7XG59XG5mdW5jdGlvbiBzZXQodmlldywgYnl0ZXMsIGluZGV4LCBjb252ZXJzaW9uLCB2YWx1ZSwgaXNMaXR0bGVFbmRpYW4pIHtcbiAgdmFyIG51bUluZGV4ID0gK2luZGV4O1xuICB2YXIgaW50SW5kZXggPSB0b0luZGV4KG51bUluZGV4KTtcbiAgaWYgKGludEluZGV4ICsgYnl0ZXMgPiB2aWV3WyRMRU5HVEhdKSB0aHJvdyBSYW5nZUVycm9yKFdST05HX0lOREVYKTtcbiAgdmFyIHN0b3JlID0gdmlld1skQlVGRkVSXS5fYjtcbiAgdmFyIHN0YXJ0ID0gaW50SW5kZXggKyB2aWV3WyRPRkZTRVRdO1xuICB2YXIgcGFjayA9IGNvbnZlcnNpb24oK3ZhbHVlKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlczsgaSsrKSBzdG9yZVtzdGFydCArIGldID0gcGFja1tpc0xpdHRsZUVuZGlhbiA/IGkgOiBieXRlcyAtIGkgLSAxXTtcbn1cblxuaWYgKCEkdHlwZWQuQUJWKSB7XG4gICRBcnJheUJ1ZmZlciA9IGZ1bmN0aW9uIEFycmF5QnVmZmVyKGxlbmd0aCkge1xuICAgIGFuSW5zdGFuY2UodGhpcywgJEFycmF5QnVmZmVyLCBBUlJBWV9CVUZGRVIpO1xuICAgIHZhciBieXRlTGVuZ3RoID0gdG9JbmRleChsZW5ndGgpO1xuICAgIHRoaXMuX2IgPSBhcnJheUZpbGwuY2FsbChBcnJheShieXRlTGVuZ3RoKSwgMCk7XG4gICAgdGhpc1skTEVOR1RIXSA9IGJ5dGVMZW5ndGg7XG4gIH07XG5cbiAgJERhdGFWaWV3ID0gZnVuY3Rpb24gRGF0YVZpZXcoYnVmZmVyLCBieXRlT2Zmc2V0LCBieXRlTGVuZ3RoKSB7XG4gICAgYW5JbnN0YW5jZSh0aGlzLCAkRGF0YVZpZXcsIERBVEFfVklFVyk7XG4gICAgYW5JbnN0YW5jZShidWZmZXIsICRBcnJheUJ1ZmZlciwgREFUQV9WSUVXKTtcbiAgICB2YXIgYnVmZmVyTGVuZ3RoID0gYnVmZmVyWyRMRU5HVEhdO1xuICAgIHZhciBvZmZzZXQgPSB0b0ludGVnZXIoYnl0ZU9mZnNldCk7XG4gICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ID4gYnVmZmVyTGVuZ3RoKSB0aHJvdyBSYW5nZUVycm9yKCdXcm9uZyBvZmZzZXQhJyk7XG4gICAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPT09IHVuZGVmaW5lZCA/IGJ1ZmZlckxlbmd0aCAtIG9mZnNldCA6IHRvTGVuZ3RoKGJ5dGVMZW5ndGgpO1xuICAgIGlmIChvZmZzZXQgKyBieXRlTGVuZ3RoID4gYnVmZmVyTGVuZ3RoKSB0aHJvdyBSYW5nZUVycm9yKFdST05HX0xFTkdUSCk7XG4gICAgdGhpc1skQlVGRkVSXSA9IGJ1ZmZlcjtcbiAgICB0aGlzWyRPRkZTRVRdID0gb2Zmc2V0O1xuICAgIHRoaXNbJExFTkdUSF0gPSBieXRlTGVuZ3RoO1xuICB9O1xuXG4gIGlmIChERVNDUklQVE9SUykge1xuICAgIGFkZEdldHRlcigkQXJyYXlCdWZmZXIsIEJZVEVfTEVOR1RILCAnX2wnKTtcbiAgICBhZGRHZXR0ZXIoJERhdGFWaWV3LCBCVUZGRVIsICdfYicpO1xuICAgIGFkZEdldHRlcigkRGF0YVZpZXcsIEJZVEVfTEVOR1RILCAnX2wnKTtcbiAgICBhZGRHZXR0ZXIoJERhdGFWaWV3LCBCWVRFX09GRlNFVCwgJ19vJyk7XG4gIH1cblxuICByZWRlZmluZUFsbCgkRGF0YVZpZXdbUFJPVE9UWVBFXSwge1xuICAgIGdldEludDg6IGZ1bmN0aW9uIGdldEludDgoYnl0ZU9mZnNldCkge1xuICAgICAgcmV0dXJuIGdldCh0aGlzLCAxLCBieXRlT2Zmc2V0KVswXSA8PCAyNCA+PiAyNDtcbiAgICB9LFxuICAgIGdldFVpbnQ4OiBmdW5jdGlvbiBnZXRVaW50OChieXRlT2Zmc2V0KSB7XG4gICAgICByZXR1cm4gZ2V0KHRoaXMsIDEsIGJ5dGVPZmZzZXQpWzBdO1xuICAgIH0sXG4gICAgZ2V0SW50MTY6IGZ1bmN0aW9uIGdldEludDE2KGJ5dGVPZmZzZXQgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHZhciBieXRlcyA9IGdldCh0aGlzLCAyLCBieXRlT2Zmc2V0LCBhcmd1bWVudHNbMV0pO1xuICAgICAgcmV0dXJuIChieXRlc1sxXSA8PCA4IHwgYnl0ZXNbMF0pIDw8IDE2ID4+IDE2O1xuICAgIH0sXG4gICAgZ2V0VWludDE2OiBmdW5jdGlvbiBnZXRVaW50MTYoYnl0ZU9mZnNldCAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgdmFyIGJ5dGVzID0gZ2V0KHRoaXMsIDIsIGJ5dGVPZmZzZXQsIGFyZ3VtZW50c1sxXSk7XG4gICAgICByZXR1cm4gYnl0ZXNbMV0gPDwgOCB8IGJ5dGVzWzBdO1xuICAgIH0sXG4gICAgZ2V0SW50MzI6IGZ1bmN0aW9uIGdldEludDMyKGJ5dGVPZmZzZXQgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHJldHVybiB1bnBhY2tJMzIoZ2V0KHRoaXMsIDQsIGJ5dGVPZmZzZXQsIGFyZ3VtZW50c1sxXSkpO1xuICAgIH0sXG4gICAgZ2V0VWludDMyOiBmdW5jdGlvbiBnZXRVaW50MzIoYnl0ZU9mZnNldCAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgcmV0dXJuIHVucGFja0kzMihnZXQodGhpcywgNCwgYnl0ZU9mZnNldCwgYXJndW1lbnRzWzFdKSkgPj4+IDA7XG4gICAgfSxcbiAgICBnZXRGbG9hdDMyOiBmdW5jdGlvbiBnZXRGbG9hdDMyKGJ5dGVPZmZzZXQgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHJldHVybiB1bnBhY2tJRUVFNzU0KGdldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBhcmd1bWVudHNbMV0pLCAyMywgNCk7XG4gICAgfSxcbiAgICBnZXRGbG9hdDY0OiBmdW5jdGlvbiBnZXRGbG9hdDY0KGJ5dGVPZmZzZXQgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHJldHVybiB1bnBhY2tJRUVFNzU0KGdldCh0aGlzLCA4LCBieXRlT2Zmc2V0LCBhcmd1bWVudHNbMV0pLCA1MiwgOCk7XG4gICAgfSxcbiAgICBzZXRJbnQ4OiBmdW5jdGlvbiBzZXRJbnQ4KGJ5dGVPZmZzZXQsIHZhbHVlKSB7XG4gICAgICBzZXQodGhpcywgMSwgYnl0ZU9mZnNldCwgcGFja0k4LCB2YWx1ZSk7XG4gICAgfSxcbiAgICBzZXRVaW50ODogZnVuY3Rpb24gc2V0VWludDgoYnl0ZU9mZnNldCwgdmFsdWUpIHtcbiAgICAgIHNldCh0aGlzLCAxLCBieXRlT2Zmc2V0LCBwYWNrSTgsIHZhbHVlKTtcbiAgICB9LFxuICAgIHNldEludDE2OiBmdW5jdGlvbiBzZXRJbnQxNihieXRlT2Zmc2V0LCB2YWx1ZSAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgc2V0KHRoaXMsIDIsIGJ5dGVPZmZzZXQsIHBhY2tJMTYsIHZhbHVlLCBhcmd1bWVudHNbMl0pO1xuICAgIH0sXG4gICAgc2V0VWludDE2OiBmdW5jdGlvbiBzZXRVaW50MTYoYnl0ZU9mZnNldCwgdmFsdWUgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHNldCh0aGlzLCAyLCBieXRlT2Zmc2V0LCBwYWNrSTE2LCB2YWx1ZSwgYXJndW1lbnRzWzJdKTtcbiAgICB9LFxuICAgIHNldEludDMyOiBmdW5jdGlvbiBzZXRJbnQzMihieXRlT2Zmc2V0LCB2YWx1ZSAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgc2V0KHRoaXMsIDQsIGJ5dGVPZmZzZXQsIHBhY2tJMzIsIHZhbHVlLCBhcmd1bWVudHNbMl0pO1xuICAgIH0sXG4gICAgc2V0VWludDMyOiBmdW5jdGlvbiBzZXRVaW50MzIoYnl0ZU9mZnNldCwgdmFsdWUgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHNldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBwYWNrSTMyLCB2YWx1ZSwgYXJndW1lbnRzWzJdKTtcbiAgICB9LFxuICAgIHNldEZsb2F0MzI6IGZ1bmN0aW9uIHNldEZsb2F0MzIoYnl0ZU9mZnNldCwgdmFsdWUgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHNldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBwYWNrRjMyLCB2YWx1ZSwgYXJndW1lbnRzWzJdKTtcbiAgICB9LFxuICAgIHNldEZsb2F0NjQ6IGZ1bmN0aW9uIHNldEZsb2F0NjQoYnl0ZU9mZnNldCwgdmFsdWUgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHNldCh0aGlzLCA4LCBieXRlT2Zmc2V0LCBwYWNrRjY0LCB2YWx1ZSwgYXJndW1lbnRzWzJdKTtcbiAgICB9XG4gIH0pO1xufSBlbHNlIHtcbiAgaWYgKCFmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgJEFycmF5QnVmZmVyKDEpO1xuICB9KSB8fCAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIG5ldyAkQXJyYXlCdWZmZXIoLTEpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICB9KSB8fCBmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgbmV3ICRBcnJheUJ1ZmZlcigpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgIG5ldyAkQXJyYXlCdWZmZXIoMS41KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICBuZXcgJEFycmF5QnVmZmVyKE5hTik7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgcmV0dXJuICRBcnJheUJ1ZmZlci5uYW1lICE9IEFSUkFZX0JVRkZFUjtcbiAgfSkpIHtcbiAgICAkQXJyYXlCdWZmZXIgPSBmdW5jdGlvbiBBcnJheUJ1ZmZlcihsZW5ndGgpIHtcbiAgICAgIGFuSW5zdGFuY2UodGhpcywgJEFycmF5QnVmZmVyKTtcbiAgICAgIHJldHVybiBuZXcgQmFzZUJ1ZmZlcih0b0luZGV4KGxlbmd0aCkpO1xuICAgIH07XG4gICAgdmFyIEFycmF5QnVmZmVyUHJvdG8gPSAkQXJyYXlCdWZmZXJbUFJPVE9UWVBFXSA9IEJhc2VCdWZmZXJbUFJPVE9UWVBFXTtcbiAgICBmb3IgKHZhciBrZXlzID0gZ09QTihCYXNlQnVmZmVyKSwgaiA9IDAsIGtleTsga2V5cy5sZW5ndGggPiBqOykge1xuICAgICAgaWYgKCEoKGtleSA9IGtleXNbaisrXSkgaW4gJEFycmF5QnVmZmVyKSkgaGlkZSgkQXJyYXlCdWZmZXIsIGtleSwgQmFzZUJ1ZmZlcltrZXldKTtcbiAgICB9XG4gICAgaWYgKCFMSUJSQVJZKSBBcnJheUJ1ZmZlclByb3RvLmNvbnN0cnVjdG9yID0gJEFycmF5QnVmZmVyO1xuICB9XG4gIC8vIGlPUyBTYWZhcmkgNy54IGJ1Z1xuICB2YXIgdmlldyA9IG5ldyAkRGF0YVZpZXcobmV3ICRBcnJheUJ1ZmZlcigyKSk7XG4gIHZhciAkc2V0SW50OCA9ICREYXRhVmlld1tQUk9UT1RZUEVdLnNldEludDg7XG4gIHZpZXcuc2V0SW50OCgwLCAyMTQ3NDgzNjQ4KTtcbiAgdmlldy5zZXRJbnQ4KDEsIDIxNDc0ODM2NDkpO1xuICBpZiAodmlldy5nZXRJbnQ4KDApIHx8ICF2aWV3LmdldEludDgoMSkpIHJlZGVmaW5lQWxsKCREYXRhVmlld1tQUk9UT1RZUEVdLCB7XG4gICAgc2V0SW50ODogZnVuY3Rpb24gc2V0SW50OChieXRlT2Zmc2V0LCB2YWx1ZSkge1xuICAgICAgJHNldEludDguY2FsbCh0aGlzLCBieXRlT2Zmc2V0LCB2YWx1ZSA8PCAyNCA+PiAyNCk7XG4gICAgfSxcbiAgICBzZXRVaW50ODogZnVuY3Rpb24gc2V0VWludDgoYnl0ZU9mZnNldCwgdmFsdWUpIHtcbiAgICAgICRzZXRJbnQ4LmNhbGwodGhpcywgYnl0ZU9mZnNldCwgdmFsdWUgPDwgMjQgPj4gMjQpO1xuICAgIH1cbiAgfSwgdHJ1ZSk7XG59XG5zZXRUb1N0cmluZ1RhZygkQXJyYXlCdWZmZXIsIEFSUkFZX0JVRkZFUik7XG5zZXRUb1N0cmluZ1RhZygkRGF0YVZpZXcsIERBVEFfVklFVyk7XG5oaWRlKCREYXRhVmlld1tQUk9UT1RZUEVdLCAkdHlwZWQuVklFVywgdHJ1ZSk7XG5leHBvcnRzW0FSUkFZX0JVRkZFUl0gPSAkQXJyYXlCdWZmZXI7XG5leHBvcnRzW0RBVEFfVklFV10gPSAkRGF0YVZpZXc7XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciB1aWQgPSByZXF1aXJlKCcuL191aWQnKTtcbnZhciBUWVBFRCA9IHVpZCgndHlwZWRfYXJyYXknKTtcbnZhciBWSUVXID0gdWlkKCd2aWV3Jyk7XG52YXIgQUJWID0gISEoZ2xvYmFsLkFycmF5QnVmZmVyICYmIGdsb2JhbC5EYXRhVmlldyk7XG52YXIgQ09OU1RSID0gQUJWO1xudmFyIGkgPSAwO1xudmFyIGwgPSA5O1xudmFyIFR5cGVkO1xuXG52YXIgVHlwZWRBcnJheUNvbnN0cnVjdG9ycyA9IChcbiAgJ0ludDhBcnJheSxVaW50OEFycmF5LFVpbnQ4Q2xhbXBlZEFycmF5LEludDE2QXJyYXksVWludDE2QXJyYXksSW50MzJBcnJheSxVaW50MzJBcnJheSxGbG9hdDMyQXJyYXksRmxvYXQ2NEFycmF5J1xuKS5zcGxpdCgnLCcpO1xuXG53aGlsZSAoaSA8IGwpIHtcbiAgaWYgKFR5cGVkID0gZ2xvYmFsW1R5cGVkQXJyYXlDb25zdHJ1Y3RvcnNbaSsrXV0pIHtcbiAgICBoaWRlKFR5cGVkLnByb3RvdHlwZSwgVFlQRUQsIHRydWUpO1xuICAgIGhpZGUoVHlwZWQucHJvdG90eXBlLCBWSUVXLCB0cnVlKTtcbiAgfSBlbHNlIENPTlNUUiA9IGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgQUJWOiBBQlYsXG4gIENPTlNUUjogQ09OU1RSLFxuICBUWVBFRDogVFlQRUQsXG4gIFZJRVc6IFZJRVdcbn07XG4iLCJ2YXIgaWQgPSAwO1xudmFyIHB4ID0gTWF0aC5yYW5kb20oKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gJ1N5bWJvbCgnLmNvbmNhdChrZXkgPT09IHVuZGVmaW5lZCA/ICcnIDoga2V5LCAnKV8nLCAoKytpZCArIHB4KS50b1N0cmluZygzNikpO1xufTtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIFRZUEUpIHtcbiAgaWYgKCFpc09iamVjdChpdCkgfHwgaXQuX3QgIT09IFRZUEUpIHRocm93IFR5cGVFcnJvcignSW5jb21wYXRpYmxlIHJlY2VpdmVyLCAnICsgVFlQRSArICcgcmVxdWlyZWQhJyk7XG4gIHJldHVybiBpdDtcbn07XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgY29yZSA9IHJlcXVpcmUoJy4vX2NvcmUnKTtcbnZhciBMSUJSQVJZID0gcmVxdWlyZSgnLi9fbGlicmFyeScpO1xudmFyIHdrc0V4dCA9IHJlcXVpcmUoJy4vX3drcy1leHQnKTtcbnZhciBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHZhciAkU3ltYm9sID0gY29yZS5TeW1ib2wgfHwgKGNvcmUuU3ltYm9sID0gTElCUkFSWSA/IHt9IDogZ2xvYmFsLlN5bWJvbCB8fCB7fSk7XG4gIGlmIChuYW1lLmNoYXJBdCgwKSAhPSAnXycgJiYgIShuYW1lIGluICRTeW1ib2wpKSBkZWZpbmVQcm9wZXJ0eSgkU3ltYm9sLCBuYW1lLCB7IHZhbHVlOiB3a3NFeHQuZihuYW1lKSB9KTtcbn07XG4iLCJleHBvcnRzLmYgPSByZXF1aXJlKCcuL193a3MnKTtcbiIsInZhciBzdG9yZSA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpKCd3a3MnKTtcbnZhciB1aWQgPSByZXF1aXJlKCcuL191aWQnKTtcbnZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5TeW1ib2w7XG52YXIgVVNFX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT0gJ2Z1bmN0aW9uJztcblxudmFyICRleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gc3RvcmVbbmFtZV0gfHwgKHN0b3JlW25hbWVdID1cbiAgICBVU0VfU1lNQk9MICYmIFN5bWJvbFtuYW1lXSB8fCAoVVNFX1NZTUJPTCA/IFN5bWJvbCA6IHVpZCkoJ1N5bWJvbC4nICsgbmFtZSkpO1xufTtcblxuJGV4cG9ydHMuc3RvcmUgPSBzdG9yZTtcbiIsInZhciBjbGFzc29mID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpO1xudmFyIElURVJBVE9SID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyk7XG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2NvcmUnKS5nZXRJdGVyYXRvck1ldGhvZCA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXQgIT0gdW5kZWZpbmVkKSByZXR1cm4gaXRbSVRFUkFUT1JdXG4gICAgfHwgaXRbJ0BAaXRlcmF0b3InXVxuICAgIHx8IEl0ZXJhdG9yc1tjbGFzc29mKGl0KV07XG59O1xuIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL2JlbmphbWluZ3IvUmV4RXhwLmVzY2FwZVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkcmUgPSByZXF1aXJlKCcuL19yZXBsYWNlcicpKC9bXFxcXF4kKis/LigpfFtcXF17fV0vZywgJ1xcXFwkJicpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZ0V4cCcsIHsgZXNjYXBlOiBmdW5jdGlvbiBlc2NhcGUoaXQpIHsgcmV0dXJuICRyZShpdCk7IH0gfSk7XG4iLCIvLyAyMi4xLjMuMyBBcnJheS5wcm90b3R5cGUuY29weVdpdGhpbih0YXJnZXQsIHN0YXJ0LCBlbmQgPSB0aGlzLmxlbmd0aClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QLCAnQXJyYXknLCB7IGNvcHlXaXRoaW46IHJlcXVpcmUoJy4vX2FycmF5LWNvcHktd2l0aGluJykgfSk7XG5cbnJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpKCdjb3B5V2l0aGluJyk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRldmVyeSA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKSg0KTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKFtdLmV2ZXJ5LCB0cnVlKSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjMuNSAvIDE1LjQuNC4xNiBBcnJheS5wcm90b3R5cGUuZXZlcnkoY2FsbGJhY2tmbiBbLCB0aGlzQXJnXSlcbiAgZXZlcnk6IGZ1bmN0aW9uIGV2ZXJ5KGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKSB7XG4gICAgcmV0dXJuICRldmVyeSh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHNbMV0pO1xuICB9XG59KTtcbiIsIi8vIDIyLjEuMy42IEFycmF5LnByb3RvdHlwZS5maWxsKHZhbHVlLCBzdGFydCA9IDAsIGVuZCA9IHRoaXMubGVuZ3RoKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAsICdBcnJheScsIHsgZmlsbDogcmVxdWlyZSgnLi9fYXJyYXktZmlsbCcpIH0pO1xuXG5yZXF1aXJlKCcuL19hZGQtdG8tdW5zY29wYWJsZXMnKSgnZmlsbCcpO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkZmlsdGVyID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpKDIpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoW10uZmlsdGVyLCB0cnVlKSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjMuNyAvIDE1LjQuNC4yMCBBcnJheS5wcm90b3R5cGUuZmlsdGVyKGNhbGxiYWNrZm4gWywgdGhpc0FyZ10pXG4gIGZpbHRlcjogZnVuY3Rpb24gZmlsdGVyKGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKSB7XG4gICAgcmV0dXJuICRmaWx0ZXIodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzWzFdKTtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG4vLyAyMi4xLjMuOSBBcnJheS5wcm90b3R5cGUuZmluZEluZGV4KHByZWRpY2F0ZSwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJGZpbmQgPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJykoNik7XG52YXIgS0VZID0gJ2ZpbmRJbmRleCc7XG52YXIgZm9yY2VkID0gdHJ1ZTtcbi8vIFNob3VsZG4ndCBza2lwIGhvbGVzXG5pZiAoS0VZIGluIFtdKSBBcnJheSgxKVtLRVldKGZ1bmN0aW9uICgpIHsgZm9yY2VkID0gZmFsc2U7IH0pO1xuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiBmb3JjZWQsICdBcnJheScsIHtcbiAgZmluZEluZGV4OiBmdW5jdGlvbiBmaW5kSW5kZXgoY2FsbGJhY2tmbiAvKiAsIHRoYXQgPSB1bmRlZmluZWQgKi8pIHtcbiAgICByZXR1cm4gJGZpbmQodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICB9XG59KTtcbnJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpKEtFWSk7XG4iLCIndXNlIHN0cmljdCc7XG4vLyAyMi4xLjMuOCBBcnJheS5wcm90b3R5cGUuZmluZChwcmVkaWNhdGUsIHRoaXNBcmcgPSB1bmRlZmluZWQpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRmaW5kID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpKDUpO1xudmFyIEtFWSA9ICdmaW5kJztcbnZhciBmb3JjZWQgPSB0cnVlO1xuLy8gU2hvdWxkbid0IHNraXAgaG9sZXNcbmlmIChLRVkgaW4gW10pIEFycmF5KDEpW0tFWV0oZnVuY3Rpb24gKCkgeyBmb3JjZWQgPSBmYWxzZTsgfSk7XG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIGZvcmNlZCwgJ0FycmF5Jywge1xuICBmaW5kOiBmdW5jdGlvbiBmaW5kKGNhbGxiYWNrZm4gLyogLCB0aGF0ID0gdW5kZWZpbmVkICovKSB7XG4gICAgcmV0dXJuICRmaW5kKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgfVxufSk7XG5yZXF1aXJlKCcuL19hZGQtdG8tdW5zY29wYWJsZXMnKShLRVkpO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkZm9yRWFjaCA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKSgwKTtcbnZhciBTVFJJQ1QgPSByZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoW10uZm9yRWFjaCwgdHJ1ZSk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogIVNUUklDVCwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjMuMTAgLyAxNS40LjQuMTggQXJyYXkucHJvdG90eXBlLmZvckVhY2goY2FsbGJhY2tmbiBbLCB0aGlzQXJnXSlcbiAgZm9yRWFjaDogZnVuY3Rpb24gZm9yRWFjaChjYWxsYmFja2ZuIC8qICwgdGhpc0FyZyAqLykge1xuICAgIHJldHVybiAkZm9yRWFjaCh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHNbMV0pO1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciBjYWxsID0gcmVxdWlyZSgnLi9faXRlci1jYWxsJyk7XG52YXIgaXNBcnJheUl0ZXIgPSByZXF1aXJlKCcuL19pcy1hcnJheS1pdGVyJyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciBjcmVhdGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2NyZWF0ZS1wcm9wZXJ0eScpO1xudmFyIGdldEl0ZXJGbiA9IHJlcXVpcmUoJy4vY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX2l0ZXItZGV0ZWN0JykoZnVuY3Rpb24gKGl0ZXIpIHsgQXJyYXkuZnJvbShpdGVyKTsgfSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4yLjEgQXJyYXkuZnJvbShhcnJheUxpa2UsIG1hcGZuID0gdW5kZWZpbmVkLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxuICBmcm9tOiBmdW5jdGlvbiBmcm9tKGFycmF5TGlrZSAvKiAsIG1hcGZuID0gdW5kZWZpbmVkLCB0aGlzQXJnID0gdW5kZWZpbmVkICovKSB7XG4gICAgdmFyIE8gPSB0b09iamVjdChhcnJheUxpa2UpO1xuICAgIHZhciBDID0gdHlwZW9mIHRoaXMgPT0gJ2Z1bmN0aW9uJyA/IHRoaXMgOiBBcnJheTtcbiAgICB2YXIgYUxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIG1hcGZuID0gYUxlbiA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQ7XG4gICAgdmFyIG1hcHBpbmcgPSBtYXBmbiAhPT0gdW5kZWZpbmVkO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIGl0ZXJGbiA9IGdldEl0ZXJGbihPKTtcbiAgICB2YXIgbGVuZ3RoLCByZXN1bHQsIHN0ZXAsIGl0ZXJhdG9yO1xuICAgIGlmIChtYXBwaW5nKSBtYXBmbiA9IGN0eChtYXBmbiwgYUxlbiA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQsIDIpO1xuICAgIC8vIGlmIG9iamVjdCBpc24ndCBpdGVyYWJsZSBvciBpdCdzIGFycmF5IHdpdGggZGVmYXVsdCBpdGVyYXRvciAtIHVzZSBzaW1wbGUgY2FzZVxuICAgIGlmIChpdGVyRm4gIT0gdW5kZWZpbmVkICYmICEoQyA9PSBBcnJheSAmJiBpc0FycmF5SXRlcihpdGVyRm4pKSkge1xuICAgICAgZm9yIChpdGVyYXRvciA9IGl0ZXJGbi5jYWxsKE8pLCByZXN1bHQgPSBuZXcgQygpOyAhKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmU7IGluZGV4KyspIHtcbiAgICAgICAgY3JlYXRlUHJvcGVydHkocmVzdWx0LCBpbmRleCwgbWFwcGluZyA/IGNhbGwoaXRlcmF0b3IsIG1hcGZuLCBbc3RlcC52YWx1ZSwgaW5kZXhdLCB0cnVlKSA6IHN0ZXAudmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gICAgICBmb3IgKHJlc3VsdCA9IG5ldyBDKGxlbmd0aCk7IGxlbmd0aCA+IGluZGV4OyBpbmRleCsrKSB7XG4gICAgICAgIGNyZWF0ZVByb3BlcnR5KHJlc3VsdCwgaW5kZXgsIG1hcHBpbmcgPyBtYXBmbihPW2luZGV4XSwgaW5kZXgpIDogT1tpbmRleF0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXN1bHQubGVuZ3RoID0gaW5kZXg7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRpbmRleE9mID0gcmVxdWlyZSgnLi9fYXJyYXktaW5jbHVkZXMnKShmYWxzZSk7XG52YXIgJG5hdGl2ZSA9IFtdLmluZGV4T2Y7XG52YXIgTkVHQVRJVkVfWkVSTyA9ICEhJG5hdGl2ZSAmJiAxIC8gWzFdLmluZGV4T2YoMSwgLTApIDwgMDtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoTkVHQVRJVkVfWkVSTyB8fCAhcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKCRuYXRpdmUpKSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjMuMTEgLyAxNS40LjQuMTQgQXJyYXkucHJvdG90eXBlLmluZGV4T2Yoc2VhcmNoRWxlbWVudCBbLCBmcm9tSW5kZXhdKVxuICBpbmRleE9mOiBmdW5jdGlvbiBpbmRleE9mKHNlYXJjaEVsZW1lbnQgLyogLCBmcm9tSW5kZXggPSAwICovKSB7XG4gICAgcmV0dXJuIE5FR0FUSVZFX1pFUk9cbiAgICAgIC8vIGNvbnZlcnQgLTAgdG8gKzBcbiAgICAgID8gJG5hdGl2ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IDBcbiAgICAgIDogJGluZGV4T2YodGhpcywgc2VhcmNoRWxlbWVudCwgYXJndW1lbnRzWzFdKTtcbiAgfVxufSk7XG4iLCIvLyAyMi4xLjIuMiAvIDE1LjQuMy4yIEFycmF5LmlzQXJyYXkoYXJnKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdBcnJheScsIHsgaXNBcnJheTogcmVxdWlyZSgnLi9faXMtYXJyYXknKSB9KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBhZGRUb1Vuc2NvcGFibGVzID0gcmVxdWlyZSgnLi9fYWRkLXRvLXVuc2NvcGFibGVzJyk7XG52YXIgc3RlcCA9IHJlcXVpcmUoJy4vX2l0ZXItc3RlcCcpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcblxuLy8gMjIuMS4zLjQgQXJyYXkucHJvdG90eXBlLmVudHJpZXMoKVxuLy8gMjIuMS4zLjEzIEFycmF5LnByb3RvdHlwZS5rZXlzKClcbi8vIDIyLjEuMy4yOSBBcnJheS5wcm90b3R5cGUudmFsdWVzKClcbi8vIDIyLjEuMy4zMCBBcnJheS5wcm90b3R5cGVbQEBpdGVyYXRvcl0oKVxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19pdGVyLWRlZmluZScpKEFycmF5LCAnQXJyYXknLCBmdW5jdGlvbiAoaXRlcmF0ZWQsIGtpbmQpIHtcbiAgdGhpcy5fdCA9IHRvSU9iamVjdChpdGVyYXRlZCk7IC8vIHRhcmdldFxuICB0aGlzLl9pID0gMDsgICAgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxuICB0aGlzLl9rID0ga2luZDsgICAgICAgICAgICAgICAgLy8ga2luZFxuLy8gMjIuMS41LjIuMSAlQXJyYXlJdGVyYXRvclByb3RvdHlwZSUubmV4dCgpXG59LCBmdW5jdGlvbiAoKSB7XG4gIHZhciBPID0gdGhpcy5fdDtcbiAgdmFyIGtpbmQgPSB0aGlzLl9rO1xuICB2YXIgaW5kZXggPSB0aGlzLl9pKys7XG4gIGlmICghTyB8fCBpbmRleCA+PSBPLmxlbmd0aCkge1xuICAgIHRoaXMuX3QgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHN0ZXAoMSk7XG4gIH1cbiAgaWYgKGtpbmQgPT0gJ2tleXMnKSByZXR1cm4gc3RlcCgwLCBpbmRleCk7XG4gIGlmIChraW5kID09ICd2YWx1ZXMnKSByZXR1cm4gc3RlcCgwLCBPW2luZGV4XSk7XG4gIHJldHVybiBzdGVwKDAsIFtpbmRleCwgT1tpbmRleF1dKTtcbn0sICd2YWx1ZXMnKTtcblxuLy8gYXJndW1lbnRzTGlzdFtAQGl0ZXJhdG9yXSBpcyAlQXJyYXlQcm90b192YWx1ZXMlICg5LjQuNC42LCA5LjQuNC43KVxuSXRlcmF0b3JzLkFyZ3VtZW50cyA9IEl0ZXJhdG9ycy5BcnJheTtcblxuYWRkVG9VbnNjb3BhYmxlcygna2V5cycpO1xuYWRkVG9VbnNjb3BhYmxlcygndmFsdWVzJyk7XG5hZGRUb1Vuc2NvcGFibGVzKCdlbnRyaWVzJyk7XG4iLCIndXNlIHN0cmljdCc7XG4vLyAyMi4xLjMuMTMgQXJyYXkucHJvdG90eXBlLmpvaW4oc2VwYXJhdG9yKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgYXJyYXlKb2luID0gW10uam9pbjtcblxuLy8gZmFsbGJhY2sgZm9yIG5vdCBhcnJheS1saWtlIHN0cmluZ3NcbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKHJlcXVpcmUoJy4vX2lvYmplY3QnKSAhPSBPYmplY3QgfHwgIXJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKShhcnJheUpvaW4pKSwgJ0FycmF5Jywge1xuICBqb2luOiBmdW5jdGlvbiBqb2luKHNlcGFyYXRvcikge1xuICAgIHJldHVybiBhcnJheUpvaW4uY2FsbCh0b0lPYmplY3QodGhpcyksIHNlcGFyYXRvciA9PT0gdW5kZWZpbmVkID8gJywnIDogc2VwYXJhdG9yKTtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciAkbmF0aXZlID0gW10ubGFzdEluZGV4T2Y7XG52YXIgTkVHQVRJVkVfWkVSTyA9ICEhJG5hdGl2ZSAmJiAxIC8gWzFdLmxhc3RJbmRleE9mKDEsIC0wKSA8IDA7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKE5FR0FUSVZFX1pFUk8gfHwgIXJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKSgkbmF0aXZlKSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjE0IC8gMTUuNC40LjE1IEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZihzZWFyY2hFbGVtZW50IFssIGZyb21JbmRleF0pXG4gIGxhc3RJbmRleE9mOiBmdW5jdGlvbiBsYXN0SW5kZXhPZihzZWFyY2hFbGVtZW50IC8qICwgZnJvbUluZGV4ID0gQFsqLTFdICovKSB7XG4gICAgLy8gY29udmVydCAtMCB0byArMFxuICAgIGlmIChORUdBVElWRV9aRVJPKSByZXR1cm4gJG5hdGl2ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IDA7XG4gICAgdmFyIE8gPSB0b0lPYmplY3QodGhpcyk7XG4gICAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgICB2YXIgaW5kZXggPSBsZW5ndGggLSAxO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkgaW5kZXggPSBNYXRoLm1pbihpbmRleCwgdG9JbnRlZ2VyKGFyZ3VtZW50c1sxXSkpO1xuICAgIGlmIChpbmRleCA8IDApIGluZGV4ID0gbGVuZ3RoICsgaW5kZXg7XG4gICAgZm9yICg7aW5kZXggPj0gMDsgaW5kZXgtLSkgaWYgKGluZGV4IGluIE8pIGlmIChPW2luZGV4XSA9PT0gc2VhcmNoRWxlbWVudCkgcmV0dXJuIGluZGV4IHx8IDA7XG4gICAgcmV0dXJuIC0xO1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJG1hcCA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKSgxKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKFtdLm1hcCwgdHJ1ZSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjE1IC8gMTUuNC40LjE5IEFycmF5LnByb3RvdHlwZS5tYXAoY2FsbGJhY2tmbiBbLCB0aGlzQXJnXSlcbiAgbWFwOiBmdW5jdGlvbiBtYXAoY2FsbGJhY2tmbiAvKiAsIHRoaXNBcmcgKi8pIHtcbiAgICByZXR1cm4gJG1hcCh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHNbMV0pO1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgY3JlYXRlUHJvcGVydHkgPSByZXF1aXJlKCcuL19jcmVhdGUtcHJvcGVydHknKTtcblxuLy8gV2ViS2l0IEFycmF5Lm9mIGlzbid0IGdlbmVyaWNcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEYoKSB7IC8qIGVtcHR5ICovIH1cbiAgcmV0dXJuICEoQXJyYXkub2YuY2FsbChGKSBpbnN0YW5jZW9mIEYpO1xufSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4yLjMgQXJyYXkub2YoIC4uLml0ZW1zKVxuICBvZjogZnVuY3Rpb24gb2YoLyogLi4uYXJncyAqLykge1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciByZXN1bHQgPSBuZXcgKHR5cGVvZiB0aGlzID09ICdmdW5jdGlvbicgPyB0aGlzIDogQXJyYXkpKGFMZW4pO1xuICAgIHdoaWxlIChhTGVuID4gaW5kZXgpIGNyZWF0ZVByb3BlcnR5KHJlc3VsdCwgaW5kZXgsIGFyZ3VtZW50c1tpbmRleCsrXSk7XG4gICAgcmVzdWx0Lmxlbmd0aCA9IGFMZW47XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRyZWR1Y2UgPSByZXF1aXJlKCcuL19hcnJheS1yZWR1Y2UnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKFtdLnJlZHVjZVJpZ2h0LCB0cnVlKSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjMuMTkgLyAxNS40LjQuMjIgQXJyYXkucHJvdG90eXBlLnJlZHVjZVJpZ2h0KGNhbGxiYWNrZm4gWywgaW5pdGlhbFZhbHVlXSlcbiAgcmVkdWNlUmlnaHQ6IGZ1bmN0aW9uIHJlZHVjZVJpZ2h0KGNhbGxiYWNrZm4gLyogLCBpbml0aWFsVmFsdWUgKi8pIHtcbiAgICByZXR1cm4gJHJlZHVjZSh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoLCBhcmd1bWVudHNbMV0sIHRydWUpO1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJHJlZHVjZSA9IHJlcXVpcmUoJy4vX2FycmF5LXJlZHVjZScpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoW10ucmVkdWNlLCB0cnVlKSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjMuMTggLyAxNS40LjQuMjEgQXJyYXkucHJvdG90eXBlLnJlZHVjZShjYWxsYmFja2ZuIFssIGluaXRpYWxWYWx1ZV0pXG4gIHJlZHVjZTogZnVuY3Rpb24gcmVkdWNlKGNhbGxiYWNrZm4gLyogLCBpbml0aWFsVmFsdWUgKi8pIHtcbiAgICByZXR1cm4gJHJlZHVjZSh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoLCBhcmd1bWVudHNbMV0sIGZhbHNlKTtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGh0bWwgPSByZXF1aXJlKCcuL19odG1sJyk7XG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gcmVxdWlyZSgnLi9fdG8tYWJzb2x1dGUtaW5kZXgnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIGFycmF5U2xpY2UgPSBbXS5zbGljZTtcblxuLy8gZmFsbGJhY2sgZm9yIG5vdCBhcnJheS1saWtlIEVTMyBzdHJpbmdzIGFuZCBET00gb2JqZWN0c1xuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgaWYgKGh0bWwpIGFycmF5U2xpY2UuY2FsbChodG1sKTtcbn0pLCAnQXJyYXknLCB7XG4gIHNsaWNlOiBmdW5jdGlvbiBzbGljZShiZWdpbiwgZW5kKSB7XG4gICAgdmFyIGxlbiA9IHRvTGVuZ3RoKHRoaXMubGVuZ3RoKTtcbiAgICB2YXIga2xhc3MgPSBjb2YodGhpcyk7XG4gICAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiBlbmQ7XG4gICAgaWYgKGtsYXNzID09ICdBcnJheScpIHJldHVybiBhcnJheVNsaWNlLmNhbGwodGhpcywgYmVnaW4sIGVuZCk7XG4gICAgdmFyIHN0YXJ0ID0gdG9BYnNvbHV0ZUluZGV4KGJlZ2luLCBsZW4pO1xuICAgIHZhciB1cFRvID0gdG9BYnNvbHV0ZUluZGV4KGVuZCwgbGVuKTtcbiAgICB2YXIgc2l6ZSA9IHRvTGVuZ3RoKHVwVG8gLSBzdGFydCk7XG4gICAgdmFyIGNsb25lZCA9IEFycmF5KHNpemUpO1xuICAgIHZhciBpID0gMDtcbiAgICBmb3IgKDsgaSA8IHNpemU7IGkrKykgY2xvbmVkW2ldID0ga2xhc3MgPT0gJ1N0cmluZydcbiAgICAgID8gdGhpcy5jaGFyQXQoc3RhcnQgKyBpKVxuICAgICAgOiB0aGlzW3N0YXJ0ICsgaV07XG4gICAgcmV0dXJuIGNsb25lZDtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRzb21lID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpKDMpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoW10uc29tZSwgdHJ1ZSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjIzIC8gMTUuNC40LjE3IEFycmF5LnByb3RvdHlwZS5zb21lKGNhbGxiYWNrZm4gWywgdGhpc0FyZ10pXG4gIHNvbWU6IGZ1bmN0aW9uIHNvbWUoY2FsbGJhY2tmbiAvKiAsIHRoaXNBcmcgKi8pIHtcbiAgICByZXR1cm4gJHNvbWUodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzWzFdKTtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbnZhciAkc29ydCA9IFtdLnNvcnQ7XG52YXIgdGVzdCA9IFsxLCAyLCAzXTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvLyBJRTgtXG4gIHRlc3Quc29ydCh1bmRlZmluZWQpO1xufSkgfHwgIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgLy8gVjggYnVnXG4gIHRlc3Quc29ydChudWxsKTtcbiAgLy8gT2xkIFdlYktpdFxufSkgfHwgIXJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKSgkc29ydCkpLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy4yNSBBcnJheS5wcm90b3R5cGUuc29ydChjb21wYXJlZm4pXG4gIHNvcnQ6IGZ1bmN0aW9uIHNvcnQoY29tcGFyZWZuKSB7XG4gICAgcmV0dXJuIGNvbXBhcmVmbiA9PT0gdW5kZWZpbmVkXG4gICAgICA/ICRzb3J0LmNhbGwodG9PYmplY3QodGhpcykpXG4gICAgICA6ICRzb3J0LmNhbGwodG9PYmplY3QodGhpcyksIGFGdW5jdGlvbihjb21wYXJlZm4pKTtcbiAgfVxufSk7XG4iLCJyZXF1aXJlKCcuL19zZXQtc3BlY2llcycpKCdBcnJheScpO1xuIiwiLy8gMjAuMy4zLjEgLyAxNS45LjQuNCBEYXRlLm5vdygpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ0RhdGUnLCB7IG5vdzogZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7IH0gfSk7XG4iLCIvLyAyMC4zLjQuMzYgLyAxNS45LjUuNDMgRGF0ZS5wcm90b3R5cGUudG9JU09TdHJpbmcoKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciB0b0lTT1N0cmluZyA9IHJlcXVpcmUoJy4vX2RhdGUtdG8taXNvLXN0cmluZycpO1xuXG4vLyBQaGFudG9tSlMgLyBvbGQgV2ViS2l0IGhhcyBhIGJyb2tlbiBpbXBsZW1lbnRhdGlvbnNcbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKERhdGUucHJvdG90eXBlLnRvSVNPU3RyaW5nICE9PSB0b0lTT1N0cmluZyksICdEYXRlJywge1xuICB0b0lTT1N0cmluZzogdG9JU09TdHJpbmdcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBuZXcgRGF0ZShOYU4pLnRvSlNPTigpICE9PSBudWxsXG4gICAgfHwgRGF0ZS5wcm90b3R5cGUudG9KU09OLmNhbGwoeyB0b0lTT1N0cmluZzogZnVuY3Rpb24gKCkgeyByZXR1cm4gMTsgfSB9KSAhPT0gMTtcbn0pLCAnRGF0ZScsIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gIHRvSlNPTjogZnVuY3Rpb24gdG9KU09OKGtleSkge1xuICAgIHZhciBPID0gdG9PYmplY3QodGhpcyk7XG4gICAgdmFyIHB2ID0gdG9QcmltaXRpdmUoTyk7XG4gICAgcmV0dXJuIHR5cGVvZiBwdiA9PSAnbnVtYmVyJyAmJiAhaXNGaW5pdGUocHYpID8gbnVsbCA6IE8udG9JU09TdHJpbmcoKTtcbiAgfVxufSk7XG4iLCJ2YXIgVE9fUFJJTUlUSVZFID0gcmVxdWlyZSgnLi9fd2tzJykoJ3RvUHJpbWl0aXZlJyk7XG52YXIgcHJvdG8gPSBEYXRlLnByb3RvdHlwZTtcblxuaWYgKCEoVE9fUFJJTUlUSVZFIGluIHByb3RvKSkgcmVxdWlyZSgnLi9faGlkZScpKHByb3RvLCBUT19QUklNSVRJVkUsIHJlcXVpcmUoJy4vX2RhdGUtdG8tcHJpbWl0aXZlJykpO1xuIiwidmFyIERhdGVQcm90byA9IERhdGUucHJvdG90eXBlO1xudmFyIElOVkFMSURfREFURSA9ICdJbnZhbGlkIERhdGUnO1xudmFyIFRPX1NUUklORyA9ICd0b1N0cmluZyc7XG52YXIgJHRvU3RyaW5nID0gRGF0ZVByb3RvW1RPX1NUUklOR107XG52YXIgZ2V0VGltZSA9IERhdGVQcm90by5nZXRUaW1lO1xuaWYgKG5ldyBEYXRlKE5hTikgKyAnJyAhPSBJTlZBTElEX0RBVEUpIHtcbiAgcmVxdWlyZSgnLi9fcmVkZWZpbmUnKShEYXRlUHJvdG8sIFRPX1NUUklORywgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgdmFyIHZhbHVlID0gZ2V0VGltZS5jYWxsKHRoaXMpO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICByZXR1cm4gdmFsdWUgPT09IHZhbHVlID8gJHRvU3RyaW5nLmNhbGwodGhpcykgOiBJTlZBTElEX0RBVEU7XG4gIH0pO1xufVxuIiwiLy8gMTkuMi4zLjIgLyAxNS4zLjQuNSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCh0aGlzQXJnLCBhcmdzLi4uKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAsICdGdW5jdGlvbicsIHsgYmluZDogcmVxdWlyZSgnLi9fYmluZCcpIH0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJyk7XG52YXIgSEFTX0lOU1RBTkNFID0gcmVxdWlyZSgnLi9fd2tzJykoJ2hhc0luc3RhbmNlJyk7XG52YXIgRnVuY3Rpb25Qcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcbi8vIDE5LjIuMy42IEZ1bmN0aW9uLnByb3RvdHlwZVtAQGhhc0luc3RhbmNlXShWKVxuaWYgKCEoSEFTX0lOU1RBTkNFIGluIEZ1bmN0aW9uUHJvdG8pKSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mKEZ1bmN0aW9uUHJvdG8sIEhBU19JTlNUQU5DRSwgeyB2YWx1ZTogZnVuY3Rpb24gKE8pIHtcbiAgaWYgKHR5cGVvZiB0aGlzICE9ICdmdW5jdGlvbicgfHwgIWlzT2JqZWN0KE8pKSByZXR1cm4gZmFsc2U7XG4gIGlmICghaXNPYmplY3QodGhpcy5wcm90b3R5cGUpKSByZXR1cm4gTyBpbnN0YW5jZW9mIHRoaXM7XG4gIC8vIGZvciBlbnZpcm9ubWVudCB3L28gbmF0aXZlIGBAQGhhc0luc3RhbmNlYCBsb2dpYyBlbm91Z2ggYGluc3RhbmNlb2ZgLCBidXQgYWRkIHRoaXM6XG4gIHdoaWxlIChPID0gZ2V0UHJvdG90eXBlT2YoTykpIGlmICh0aGlzLnByb3RvdHlwZSA9PT0gTykgcmV0dXJuIHRydWU7XG4gIHJldHVybiBmYWxzZTtcbn0gfSk7XG4iLCJ2YXIgZFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mO1xudmFyIEZQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcbnZhciBuYW1lUkUgPSAvXlxccypmdW5jdGlvbiAoW14gKF0qKS87XG52YXIgTkFNRSA9ICduYW1lJztcblxuLy8gMTkuMi40LjIgbmFtZVxuTkFNRSBpbiBGUHJvdG8gfHwgcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiBkUChGUHJvdG8sIE5BTUUsIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuICgnJyArIHRoaXMpLm1hdGNoKG5hbWVSRSlbMV07XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgc3Ryb25nID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbi1zdHJvbmcnKTtcbnZhciB2YWxpZGF0ZSA9IHJlcXVpcmUoJy4vX3ZhbGlkYXRlLWNvbGxlY3Rpb24nKTtcbnZhciBNQVAgPSAnTWFwJztcblxuLy8gMjMuMSBNYXAgT2JqZWN0c1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19jb2xsZWN0aW9uJykoTUFQLCBmdW5jdGlvbiAoZ2V0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBNYXAoKSB7IHJldHVybiBnZXQodGhpcywgYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpOyB9O1xufSwge1xuICAvLyAyMy4xLjMuNiBNYXAucHJvdG90eXBlLmdldChrZXkpXG4gIGdldDogZnVuY3Rpb24gZ2V0KGtleSkge1xuICAgIHZhciBlbnRyeSA9IHN0cm9uZy5nZXRFbnRyeSh2YWxpZGF0ZSh0aGlzLCBNQVApLCBrZXkpO1xuICAgIHJldHVybiBlbnRyeSAmJiBlbnRyeS52O1xuICB9LFxuICAvLyAyMy4xLjMuOSBNYXAucHJvdG90eXBlLnNldChrZXksIHZhbHVlKVxuICBzZXQ6IGZ1bmN0aW9uIHNldChrZXksIHZhbHVlKSB7XG4gICAgcmV0dXJuIHN0cm9uZy5kZWYodmFsaWRhdGUodGhpcywgTUFQKSwga2V5ID09PSAwID8gMCA6IGtleSwgdmFsdWUpO1xuICB9XG59LCBzdHJvbmcsIHRydWUpO1xuIiwiLy8gMjAuMi4yLjMgTWF0aC5hY29zaCh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBsb2cxcCA9IHJlcXVpcmUoJy4vX21hdGgtbG9nMXAnKTtcbnZhciBzcXJ0ID0gTWF0aC5zcXJ0O1xudmFyICRhY29zaCA9IE1hdGguYWNvc2g7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogISgkYWNvc2hcbiAgLy8gVjggYnVnOiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzUwOVxuICAmJiBNYXRoLmZsb29yKCRhY29zaChOdW1iZXIuTUFYX1ZBTFVFKSkgPT0gNzEwXG4gIC8vIFRvciBCcm93c2VyIGJ1ZzogTWF0aC5hY29zaChJbmZpbml0eSkgLT4gTmFOXG4gICYmICRhY29zaChJbmZpbml0eSkgPT0gSW5maW5pdHlcbiksICdNYXRoJywge1xuICBhY29zaDogZnVuY3Rpb24gYWNvc2goeCkge1xuICAgIHJldHVybiAoeCA9ICt4KSA8IDEgPyBOYU4gOiB4ID4gOTQ5MDYyNjUuNjI0MjUxNTZcbiAgICAgID8gTWF0aC5sb2coeCkgKyBNYXRoLkxOMlxuICAgICAgOiBsb2cxcCh4IC0gMSArIHNxcnQoeCAtIDEpICogc3FydCh4ICsgMSkpO1xuICB9XG59KTtcbiIsIi8vIDIwLjIuMi41IE1hdGguYXNpbmgoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJGFzaW5oID0gTWF0aC5hc2luaDtcblxuZnVuY3Rpb24gYXNpbmgoeCkge1xuICByZXR1cm4gIWlzRmluaXRlKHggPSAreCkgfHwgeCA9PSAwID8geCA6IHggPCAwID8gLWFzaW5oKC14KSA6IE1hdGgubG9nKHggKyBNYXRoLnNxcnQoeCAqIHggKyAxKSk7XG59XG5cbi8vIFRvciBCcm93c2VyIGJ1ZzogTWF0aC5hc2luaCgwKSAtPiAtMFxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhKCRhc2luaCAmJiAxIC8gJGFzaW5oKDApID4gMCksICdNYXRoJywgeyBhc2luaDogYXNpbmggfSk7XG4iLCIvLyAyMC4yLjIuNyBNYXRoLmF0YW5oKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRhdGFuaCA9IE1hdGguYXRhbmg7XG5cbi8vIFRvciBCcm93c2VyIGJ1ZzogTWF0aC5hdGFuaCgtMCkgLT4gMFxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhKCRhdGFuaCAmJiAxIC8gJGF0YW5oKC0wKSA8IDApLCAnTWF0aCcsIHtcbiAgYXRhbmg6IGZ1bmN0aW9uIGF0YW5oKHgpIHtcbiAgICByZXR1cm4gKHggPSAreCkgPT0gMCA/IHggOiBNYXRoLmxvZygoMSArIHgpIC8gKDEgLSB4KSkgLyAyO1xuICB9XG59KTtcbiIsIi8vIDIwLjIuMi45IE1hdGguY2JydCh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBzaWduID0gcmVxdWlyZSgnLi9fbWF0aC1zaWduJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgY2JydDogZnVuY3Rpb24gY2JydCh4KSB7XG4gICAgcmV0dXJuIHNpZ24oeCA9ICt4KSAqIE1hdGgucG93KE1hdGguYWJzKHgpLCAxIC8gMyk7XG4gIH1cbn0pO1xuIiwiLy8gMjAuMi4yLjExIE1hdGguY2x6MzIoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgY2x6MzI6IGZ1bmN0aW9uIGNsejMyKHgpIHtcbiAgICByZXR1cm4gKHggPj4+PSAwKSA/IDMxIC0gTWF0aC5mbG9vcihNYXRoLmxvZyh4ICsgMC41KSAqIE1hdGguTE9HMkUpIDogMzI7XG4gIH1cbn0pO1xuIiwiLy8gMjAuMi4yLjEyIE1hdGguY29zaCh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBleHAgPSBNYXRoLmV4cDtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBjb3NoOiBmdW5jdGlvbiBjb3NoKHgpIHtcbiAgICByZXR1cm4gKGV4cCh4ID0gK3gpICsgZXhwKC14KSkgLyAyO1xuICB9XG59KTtcbiIsIi8vIDIwLjIuMi4xNCBNYXRoLmV4cG0xKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRleHBtMSA9IHJlcXVpcmUoJy4vX21hdGgtZXhwbTEnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoJGV4cG0xICE9IE1hdGguZXhwbTEpLCAnTWF0aCcsIHsgZXhwbTE6ICRleHBtMSB9KTtcbiIsIi8vIDIwLjIuMi4xNiBNYXRoLmZyb3VuZCh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywgeyBmcm91bmQ6IHJlcXVpcmUoJy4vX21hdGgtZnJvdW5kJykgfSk7XG4iLCIvLyAyMC4yLjIuMTcgTWF0aC5oeXBvdChbdmFsdWUxWywgdmFsdWUyWywg4oCmIF1dXSlcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgYWJzID0gTWF0aC5hYnM7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgaHlwb3Q6IGZ1bmN0aW9uIGh5cG90KHZhbHVlMSwgdmFsdWUyKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICB2YXIgc3VtID0gMDtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBsYXJnID0gMDtcbiAgICB2YXIgYXJnLCBkaXY7XG4gICAgd2hpbGUgKGkgPCBhTGVuKSB7XG4gICAgICBhcmcgPSBhYnMoYXJndW1lbnRzW2krK10pO1xuICAgICAgaWYgKGxhcmcgPCBhcmcpIHtcbiAgICAgICAgZGl2ID0gbGFyZyAvIGFyZztcbiAgICAgICAgc3VtID0gc3VtICogZGl2ICogZGl2ICsgMTtcbiAgICAgICAgbGFyZyA9IGFyZztcbiAgICAgIH0gZWxzZSBpZiAoYXJnID4gMCkge1xuICAgICAgICBkaXYgPSBhcmcgLyBsYXJnO1xuICAgICAgICBzdW0gKz0gZGl2ICogZGl2O1xuICAgICAgfSBlbHNlIHN1bSArPSBhcmc7XG4gICAgfVxuICAgIHJldHVybiBsYXJnID09PSBJbmZpbml0eSA/IEluZmluaXR5IDogbGFyZyAqIE1hdGguc3FydChzdW0pO1xuICB9XG59KTtcbiIsIi8vIDIwLjIuMi4xOCBNYXRoLmltdWwoeCwgeSlcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJGltdWwgPSBNYXRoLmltdWw7XG5cbi8vIHNvbWUgV2ViS2l0IHZlcnNpb25zIGZhaWxzIHdpdGggYmlnIG51bWJlcnMsIHNvbWUgaGFzIHdyb25nIGFyaXR5XG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gJGltdWwoMHhmZmZmZmZmZiwgNSkgIT0gLTUgfHwgJGltdWwubGVuZ3RoICE9IDI7XG59KSwgJ01hdGgnLCB7XG4gIGltdWw6IGZ1bmN0aW9uIGltdWwoeCwgeSkge1xuICAgIHZhciBVSU5UMTYgPSAweGZmZmY7XG4gICAgdmFyIHhuID0gK3g7XG4gICAgdmFyIHluID0gK3k7XG4gICAgdmFyIHhsID0gVUlOVDE2ICYgeG47XG4gICAgdmFyIHlsID0gVUlOVDE2ICYgeW47XG4gICAgcmV0dXJuIDAgfCB4bCAqIHlsICsgKChVSU5UMTYgJiB4biA+Pj4gMTYpICogeWwgKyB4bCAqIChVSU5UMTYgJiB5biA+Pj4gMTYpIDw8IDE2ID4+PiAwKTtcbiAgfVxufSk7XG4iLCIvLyAyMC4yLjIuMjEgTWF0aC5sb2cxMCh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBsb2cxMDogZnVuY3Rpb24gbG9nMTAoeCkge1xuICAgIHJldHVybiBNYXRoLmxvZyh4KSAqIE1hdGguTE9HMTBFO1xuICB9XG59KTtcbiIsIi8vIDIwLjIuMi4yMCBNYXRoLmxvZzFwKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7IGxvZzFwOiByZXF1aXJlKCcuL19tYXRoLWxvZzFwJykgfSk7XG4iLCIvLyAyMC4yLjIuMjIgTWF0aC5sb2cyKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGxvZzI6IGZ1bmN0aW9uIGxvZzIoeCkge1xuICAgIHJldHVybiBNYXRoLmxvZyh4KSAvIE1hdGguTE4yO1xuICB9XG59KTtcbiIsIi8vIDIwLjIuMi4yOCBNYXRoLnNpZ24oeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHsgc2lnbjogcmVxdWlyZSgnLi9fbWF0aC1zaWduJykgfSk7XG4iLCIvLyAyMC4yLjIuMzAgTWF0aC5zaW5oKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGV4cG0xID0gcmVxdWlyZSgnLi9fbWF0aC1leHBtMScpO1xudmFyIGV4cCA9IE1hdGguZXhwO1xuXG4vLyBWOCBuZWFyIENocm9taXVtIDM4IGhhcyBhIHByb2JsZW0gd2l0aCB2ZXJ5IHNtYWxsIG51bWJlcnNcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAhTWF0aC5zaW5oKC0yZS0xNykgIT0gLTJlLTE3O1xufSksICdNYXRoJywge1xuICBzaW5oOiBmdW5jdGlvbiBzaW5oKHgpIHtcbiAgICByZXR1cm4gTWF0aC5hYnMoeCA9ICt4KSA8IDFcbiAgICAgID8gKGV4cG0xKHgpIC0gZXhwbTEoLXgpKSAvIDJcbiAgICAgIDogKGV4cCh4IC0gMSkgLSBleHAoLXggLSAxKSkgKiAoTWF0aC5FIC8gMik7XG4gIH1cbn0pO1xuIiwiLy8gMjAuMi4yLjMzIE1hdGgudGFuaCh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBleHBtMSA9IHJlcXVpcmUoJy4vX21hdGgtZXhwbTEnKTtcbnZhciBleHAgPSBNYXRoLmV4cDtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICB0YW5oOiBmdW5jdGlvbiB0YW5oKHgpIHtcbiAgICB2YXIgYSA9IGV4cG0xKHggPSAreCk7XG4gICAgdmFyIGIgPSBleHBtMSgteCk7XG4gICAgcmV0dXJuIGEgPT0gSW5maW5pdHkgPyAxIDogYiA9PSBJbmZpbml0eSA/IC0xIDogKGEgLSBiKSAvIChleHAoeCkgKyBleHAoLXgpKTtcbiAgfVxufSk7XG4iLCIvLyAyMC4yLjIuMzQgTWF0aC50cnVuYyh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICB0cnVuYzogZnVuY3Rpb24gdHJ1bmMoaXQpIHtcbiAgICByZXR1cm4gKGl0ID4gMCA/IE1hdGguZmxvb3IgOiBNYXRoLmNlaWwpKGl0KTtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG52YXIgaW5oZXJpdElmUmVxdWlyZWQgPSByZXF1aXJlKCcuL19pbmhlcml0LWlmLXJlcXVpcmVkJyk7XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG52YXIgZ09QTiA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuJykuZjtcbnZhciBnT1BEID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKS5mO1xudmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbnZhciAkdHJpbSA9IHJlcXVpcmUoJy4vX3N0cmluZy10cmltJykudHJpbTtcbnZhciBOVU1CRVIgPSAnTnVtYmVyJztcbnZhciAkTnVtYmVyID0gZ2xvYmFsW05VTUJFUl07XG52YXIgQmFzZSA9ICROdW1iZXI7XG52YXIgcHJvdG8gPSAkTnVtYmVyLnByb3RvdHlwZTtcbi8vIE9wZXJhIH4xMiBoYXMgYnJva2VuIE9iamVjdCN0b1N0cmluZ1xudmFyIEJST0tFTl9DT0YgPSBjb2YocmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpKHByb3RvKSkgPT0gTlVNQkVSO1xudmFyIFRSSU0gPSAndHJpbScgaW4gU3RyaW5nLnByb3RvdHlwZTtcblxuLy8gNy4xLjMgVG9OdW1iZXIoYXJndW1lbnQpXG52YXIgdG9OdW1iZXIgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgdmFyIGl0ID0gdG9QcmltaXRpdmUoYXJndW1lbnQsIGZhbHNlKTtcbiAgaWYgKHR5cGVvZiBpdCA9PSAnc3RyaW5nJyAmJiBpdC5sZW5ndGggPiAyKSB7XG4gICAgaXQgPSBUUklNID8gaXQudHJpbSgpIDogJHRyaW0oaXQsIDMpO1xuICAgIHZhciBmaXJzdCA9IGl0LmNoYXJDb2RlQXQoMCk7XG4gICAgdmFyIHRoaXJkLCByYWRpeCwgbWF4Q29kZTtcbiAgICBpZiAoZmlyc3QgPT09IDQzIHx8IGZpcnN0ID09PSA0NSkge1xuICAgICAgdGhpcmQgPSBpdC5jaGFyQ29kZUF0KDIpO1xuICAgICAgaWYgKHRoaXJkID09PSA4OCB8fCB0aGlyZCA9PT0gMTIwKSByZXR1cm4gTmFOOyAvLyBOdW1iZXIoJysweDEnKSBzaG91bGQgYmUgTmFOLCBvbGQgVjggZml4XG4gICAgfSBlbHNlIGlmIChmaXJzdCA9PT0gNDgpIHtcbiAgICAgIHN3aXRjaCAoaXQuY2hhckNvZGVBdCgxKSkge1xuICAgICAgICBjYXNlIDY2OiBjYXNlIDk4OiByYWRpeCA9IDI7IG1heENvZGUgPSA0OTsgYnJlYWs7IC8vIGZhc3QgZXF1YWwgL14wYlswMV0rJC9pXG4gICAgICAgIGNhc2UgNzk6IGNhc2UgMTExOiByYWRpeCA9IDg7IG1heENvZGUgPSA1NTsgYnJlYWs7IC8vIGZhc3QgZXF1YWwgL14wb1swLTddKyQvaVxuICAgICAgICBkZWZhdWx0OiByZXR1cm4gK2l0O1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgZGlnaXRzID0gaXQuc2xpY2UoMiksIGkgPSAwLCBsID0gZGlnaXRzLmxlbmd0aCwgY29kZTsgaSA8IGw7IGkrKykge1xuICAgICAgICBjb2RlID0gZGlnaXRzLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIC8vIHBhcnNlSW50IHBhcnNlcyBhIHN0cmluZyB0byBhIGZpcnN0IHVuYXZhaWxhYmxlIHN5bWJvbFxuICAgICAgICAvLyBidXQgVG9OdW1iZXIgc2hvdWxkIHJldHVybiBOYU4gaWYgYSBzdHJpbmcgY29udGFpbnMgdW5hdmFpbGFibGUgc3ltYm9sc1xuICAgICAgICBpZiAoY29kZSA8IDQ4IHx8IGNvZGUgPiBtYXhDb2RlKSByZXR1cm4gTmFOO1xuICAgICAgfSByZXR1cm4gcGFyc2VJbnQoZGlnaXRzLCByYWRpeCk7XG4gICAgfVxuICB9IHJldHVybiAraXQ7XG59O1xuXG5pZiAoISROdW1iZXIoJyAwbzEnKSB8fCAhJE51bWJlcignMGIxJykgfHwgJE51bWJlcignKzB4MScpKSB7XG4gICROdW1iZXIgPSBmdW5jdGlvbiBOdW1iZXIodmFsdWUpIHtcbiAgICB2YXIgaXQgPSBhcmd1bWVudHMubGVuZ3RoIDwgMSA/IDAgOiB2YWx1ZTtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgcmV0dXJuIHRoYXQgaW5zdGFuY2VvZiAkTnVtYmVyXG4gICAgICAvLyBjaGVjayBvbiAxLi5jb25zdHJ1Y3Rvcihmb28pIGNhc2VcbiAgICAgICYmIChCUk9LRU5fQ09GID8gZmFpbHMoZnVuY3Rpb24gKCkgeyBwcm90by52YWx1ZU9mLmNhbGwodGhhdCk7IH0pIDogY29mKHRoYXQpICE9IE5VTUJFUilcbiAgICAgICAgPyBpbmhlcml0SWZSZXF1aXJlZChuZXcgQmFzZSh0b051bWJlcihpdCkpLCB0aGF0LCAkTnVtYmVyKSA6IHRvTnVtYmVyKGl0KTtcbiAgfTtcbiAgZm9yICh2YXIga2V5cyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBnT1BOKEJhc2UpIDogKFxuICAgIC8vIEVTMzpcbiAgICAnTUFYX1ZBTFVFLE1JTl9WQUxVRSxOYU4sTkVHQVRJVkVfSU5GSU5JVFksUE9TSVRJVkVfSU5GSU5JVFksJyArXG4gICAgLy8gRVM2IChpbiBjYXNlLCBpZiBtb2R1bGVzIHdpdGggRVM2IE51bWJlciBzdGF0aWNzIHJlcXVpcmVkIGJlZm9yZSk6XG4gICAgJ0VQU0lMT04saXNGaW5pdGUsaXNJbnRlZ2VyLGlzTmFOLGlzU2FmZUludGVnZXIsTUFYX1NBRkVfSU5URUdFUiwnICtcbiAgICAnTUlOX1NBRkVfSU5URUdFUixwYXJzZUZsb2F0LHBhcnNlSW50LGlzSW50ZWdlcidcbiAgKS5zcGxpdCgnLCcpLCBqID0gMCwga2V5OyBrZXlzLmxlbmd0aCA+IGo7IGorKykge1xuICAgIGlmIChoYXMoQmFzZSwga2V5ID0ga2V5c1tqXSkgJiYgIWhhcygkTnVtYmVyLCBrZXkpKSB7XG4gICAgICBkUCgkTnVtYmVyLCBrZXksIGdPUEQoQmFzZSwga2V5KSk7XG4gICAgfVxuICB9XG4gICROdW1iZXIucHJvdG90eXBlID0gcHJvdG87XG4gIHByb3RvLmNvbnN0cnVjdG9yID0gJE51bWJlcjtcbiAgcmVxdWlyZSgnLi9fcmVkZWZpbmUnKShnbG9iYWwsIE5VTUJFUiwgJE51bWJlcik7XG59XG4iLCIvLyAyMC4xLjIuMSBOdW1iZXIuRVBTSUxPTlxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdOdW1iZXInLCB7IEVQU0lMT046IE1hdGgucG93KDIsIC01MikgfSk7XG4iLCIvLyAyMC4xLjIuMiBOdW1iZXIuaXNGaW5pdGUobnVtYmVyKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBfaXNGaW5pdGUgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5pc0Zpbml0ZTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdOdW1iZXInLCB7XG4gIGlzRmluaXRlOiBmdW5jdGlvbiBpc0Zpbml0ZShpdCkge1xuICAgIHJldHVybiB0eXBlb2YgaXQgPT0gJ251bWJlcicgJiYgX2lzRmluaXRlKGl0KTtcbiAgfVxufSk7XG4iLCIvLyAyMC4xLjIuMyBOdW1iZXIuaXNJbnRlZ2VyKG51bWJlcilcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTnVtYmVyJywgeyBpc0ludGVnZXI6IHJlcXVpcmUoJy4vX2lzLWludGVnZXInKSB9KTtcbiIsIi8vIDIwLjEuMi40IE51bWJlci5pc05hTihudW1iZXIpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ051bWJlcicsIHtcbiAgaXNOYU46IGZ1bmN0aW9uIGlzTmFOKG51bWJlcikge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICByZXR1cm4gbnVtYmVyICE9IG51bWJlcjtcbiAgfVxufSk7XG4iLCIvLyAyMC4xLjIuNSBOdW1iZXIuaXNTYWZlSW50ZWdlcihudW1iZXIpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGlzSW50ZWdlciA9IHJlcXVpcmUoJy4vX2lzLWludGVnZXInKTtcbnZhciBhYnMgPSBNYXRoLmFicztcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdOdW1iZXInLCB7XG4gIGlzU2FmZUludGVnZXI6IGZ1bmN0aW9uIGlzU2FmZUludGVnZXIobnVtYmVyKSB7XG4gICAgcmV0dXJuIGlzSW50ZWdlcihudW1iZXIpICYmIGFicyhudW1iZXIpIDw9IDB4MWZmZmZmZmZmZmZmZmY7XG4gIH1cbn0pO1xuIiwiLy8gMjAuMS4yLjYgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTnVtYmVyJywgeyBNQVhfU0FGRV9JTlRFR0VSOiAweDFmZmZmZmZmZmZmZmZmIH0pO1xuIiwiLy8gMjAuMS4yLjEwIE51bWJlci5NSU5fU0FGRV9JTlRFR0VSXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ051bWJlcicsIHsgTUlOX1NBRkVfSU5URUdFUjogLTB4MWZmZmZmZmZmZmZmZmYgfSk7XG4iLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRwYXJzZUZsb2F0ID0gcmVxdWlyZSgnLi9fcGFyc2UtZmxvYXQnKTtcbi8vIDIwLjEuMi4xMiBOdW1iZXIucGFyc2VGbG9hdChzdHJpbmcpXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIChOdW1iZXIucGFyc2VGbG9hdCAhPSAkcGFyc2VGbG9hdCksICdOdW1iZXInLCB7IHBhcnNlRmxvYXQ6ICRwYXJzZUZsb2F0IH0pO1xuIiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkcGFyc2VJbnQgPSByZXF1aXJlKCcuL19wYXJzZS1pbnQnKTtcbi8vIDIwLjEuMi4xMyBOdW1iZXIucGFyc2VJbnQoc3RyaW5nLCByYWRpeClcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKE51bWJlci5wYXJzZUludCAhPSAkcGFyc2VJbnQpLCAnTnVtYmVyJywgeyBwYXJzZUludDogJHBhcnNlSW50IH0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG52YXIgYU51bWJlclZhbHVlID0gcmVxdWlyZSgnLi9fYS1udW1iZXItdmFsdWUnKTtcbnZhciByZXBlYXQgPSByZXF1aXJlKCcuL19zdHJpbmctcmVwZWF0Jyk7XG52YXIgJHRvRml4ZWQgPSAxLjAudG9GaXhlZDtcbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG52YXIgZGF0YSA9IFswLCAwLCAwLCAwLCAwLCAwXTtcbnZhciBFUlJPUiA9ICdOdW1iZXIudG9GaXhlZDogaW5jb3JyZWN0IGludm9jYXRpb24hJztcbnZhciBaRVJPID0gJzAnO1xuXG52YXIgbXVsdGlwbHkgPSBmdW5jdGlvbiAobiwgYykge1xuICB2YXIgaSA9IC0xO1xuICB2YXIgYzIgPSBjO1xuICB3aGlsZSAoKytpIDwgNikge1xuICAgIGMyICs9IG4gKiBkYXRhW2ldO1xuICAgIGRhdGFbaV0gPSBjMiAlIDFlNztcbiAgICBjMiA9IGZsb29yKGMyIC8gMWU3KTtcbiAgfVxufTtcbnZhciBkaXZpZGUgPSBmdW5jdGlvbiAobikge1xuICB2YXIgaSA9IDY7XG4gIHZhciBjID0gMDtcbiAgd2hpbGUgKC0taSA+PSAwKSB7XG4gICAgYyArPSBkYXRhW2ldO1xuICAgIGRhdGFbaV0gPSBmbG9vcihjIC8gbik7XG4gICAgYyA9IChjICUgbikgKiAxZTc7XG4gIH1cbn07XG52YXIgbnVtVG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBpID0gNjtcbiAgdmFyIHMgPSAnJztcbiAgd2hpbGUgKC0taSA+PSAwKSB7XG4gICAgaWYgKHMgIT09ICcnIHx8IGkgPT09IDAgfHwgZGF0YVtpXSAhPT0gMCkge1xuICAgICAgdmFyIHQgPSBTdHJpbmcoZGF0YVtpXSk7XG4gICAgICBzID0gcyA9PT0gJycgPyB0IDogcyArIHJlcGVhdC5jYWxsKFpFUk8sIDcgLSB0Lmxlbmd0aCkgKyB0O1xuICAgIH1cbiAgfSByZXR1cm4gcztcbn07XG52YXIgcG93ID0gZnVuY3Rpb24gKHgsIG4sIGFjYykge1xuICByZXR1cm4gbiA9PT0gMCA/IGFjYyA6IG4gJSAyID09PSAxID8gcG93KHgsIG4gLSAxLCBhY2MgKiB4KSA6IHBvdyh4ICogeCwgbiAvIDIsIGFjYyk7XG59O1xudmFyIGxvZyA9IGZ1bmN0aW9uICh4KSB7XG4gIHZhciBuID0gMDtcbiAgdmFyIHgyID0geDtcbiAgd2hpbGUgKHgyID49IDQwOTYpIHtcbiAgICBuICs9IDEyO1xuICAgIHgyIC89IDQwOTY7XG4gIH1cbiAgd2hpbGUgKHgyID49IDIpIHtcbiAgICBuICs9IDE7XG4gICAgeDIgLz0gMjtcbiAgfSByZXR1cm4gbjtcbn07XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKCEhJHRvRml4ZWQgJiYgKFxuICAwLjAwMDA4LnRvRml4ZWQoMykgIT09ICcwLjAwMCcgfHxcbiAgMC45LnRvRml4ZWQoMCkgIT09ICcxJyB8fFxuICAxLjI1NS50b0ZpeGVkKDIpICE9PSAnMS4yNScgfHxcbiAgMTAwMDAwMDAwMDAwMDAwMDEyOC4wLnRvRml4ZWQoMCkgIT09ICcxMDAwMDAwMDAwMDAwMDAwMTI4J1xuKSB8fCAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIC8vIFY4IH4gQW5kcm9pZCA0LjMtXG4gICR0b0ZpeGVkLmNhbGwoe30pO1xufSkpLCAnTnVtYmVyJywge1xuICB0b0ZpeGVkOiBmdW5jdGlvbiB0b0ZpeGVkKGZyYWN0aW9uRGlnaXRzKSB7XG4gICAgdmFyIHggPSBhTnVtYmVyVmFsdWUodGhpcywgRVJST1IpO1xuICAgIHZhciBmID0gdG9JbnRlZ2VyKGZyYWN0aW9uRGlnaXRzKTtcbiAgICB2YXIgcyA9ICcnO1xuICAgIHZhciBtID0gWkVSTztcbiAgICB2YXIgZSwgeiwgaiwgaztcbiAgICBpZiAoZiA8IDAgfHwgZiA+IDIwKSB0aHJvdyBSYW5nZUVycm9yKEVSUk9SKTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgaWYgKHggIT0geCkgcmV0dXJuICdOYU4nO1xuICAgIGlmICh4IDw9IC0xZTIxIHx8IHggPj0gMWUyMSkgcmV0dXJuIFN0cmluZyh4KTtcbiAgICBpZiAoeCA8IDApIHtcbiAgICAgIHMgPSAnLSc7XG4gICAgICB4ID0gLXg7XG4gICAgfVxuICAgIGlmICh4ID4gMWUtMjEpIHtcbiAgICAgIGUgPSBsb2coeCAqIHBvdygyLCA2OSwgMSkpIC0gNjk7XG4gICAgICB6ID0gZSA8IDAgPyB4ICogcG93KDIsIC1lLCAxKSA6IHggLyBwb3coMiwgZSwgMSk7XG4gICAgICB6ICo9IDB4MTAwMDAwMDAwMDAwMDA7XG4gICAgICBlID0gNTIgLSBlO1xuICAgICAgaWYgKGUgPiAwKSB7XG4gICAgICAgIG11bHRpcGx5KDAsIHopO1xuICAgICAgICBqID0gZjtcbiAgICAgICAgd2hpbGUgKGogPj0gNykge1xuICAgICAgICAgIG11bHRpcGx5KDFlNywgMCk7XG4gICAgICAgICAgaiAtPSA3O1xuICAgICAgICB9XG4gICAgICAgIG11bHRpcGx5KHBvdygxMCwgaiwgMSksIDApO1xuICAgICAgICBqID0gZSAtIDE7XG4gICAgICAgIHdoaWxlIChqID49IDIzKSB7XG4gICAgICAgICAgZGl2aWRlKDEgPDwgMjMpO1xuICAgICAgICAgIGogLT0gMjM7XG4gICAgICAgIH1cbiAgICAgICAgZGl2aWRlKDEgPDwgaik7XG4gICAgICAgIG11bHRpcGx5KDEsIDEpO1xuICAgICAgICBkaXZpZGUoMik7XG4gICAgICAgIG0gPSBudW1Ub1N0cmluZygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbXVsdGlwbHkoMCwgeik7XG4gICAgICAgIG11bHRpcGx5KDEgPDwgLWUsIDApO1xuICAgICAgICBtID0gbnVtVG9TdHJpbmcoKSArIHJlcGVhdC5jYWxsKFpFUk8sIGYpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZiA+IDApIHtcbiAgICAgIGsgPSBtLmxlbmd0aDtcbiAgICAgIG0gPSBzICsgKGsgPD0gZiA/ICcwLicgKyByZXBlYXQuY2FsbChaRVJPLCBmIC0gaykgKyBtIDogbS5zbGljZSgwLCBrIC0gZikgKyAnLicgKyBtLnNsaWNlKGsgLSBmKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSBzICsgbTtcbiAgICB9IHJldHVybiBtO1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbnZhciBhTnVtYmVyVmFsdWUgPSByZXF1aXJlKCcuL19hLW51bWJlci12YWx1ZScpO1xudmFyICR0b1ByZWNpc2lvbiA9IDEuMC50b1ByZWNpc2lvbjtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoJGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgLy8gSUU3LVxuICByZXR1cm4gJHRvUHJlY2lzaW9uLmNhbGwoMSwgdW5kZWZpbmVkKSAhPT0gJzEnO1xufSkgfHwgISRmYWlscyhmdW5jdGlvbiAoKSB7XG4gIC8vIFY4IH4gQW5kcm9pZCA0LjMtXG4gICR0b1ByZWNpc2lvbi5jYWxsKHt9KTtcbn0pKSwgJ051bWJlcicsIHtcbiAgdG9QcmVjaXNpb246IGZ1bmN0aW9uIHRvUHJlY2lzaW9uKHByZWNpc2lvbikge1xuICAgIHZhciB0aGF0ID0gYU51bWJlclZhbHVlKHRoaXMsICdOdW1iZXIjdG9QcmVjaXNpb246IGluY29ycmVjdCBpbnZvY2F0aW9uIScpO1xuICAgIHJldHVybiBwcmVjaXNpb24gPT09IHVuZGVmaW5lZCA/ICR0b1ByZWNpc2lvbi5jYWxsKHRoYXQpIDogJHRvUHJlY2lzaW9uLmNhbGwodGhhdCwgcHJlY2lzaW9uKTtcbiAgfVxufSk7XG4iLCIvLyAxOS4xLjMuMSBPYmplY3QuYXNzaWduKHRhcmdldCwgc291cmNlKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYsICdPYmplY3QnLCB7IGFzc2lnbjogcmVxdWlyZSgnLi9fb2JqZWN0LWFzc2lnbicpIH0pO1xuIiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbi8vIDE5LjEuMi4yIC8gMTUuMi4zLjUgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxuJGV4cG9ydCgkZXhwb3J0LlMsICdPYmplY3QnLCB7IGNyZWF0ZTogcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpIH0pO1xuIiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbi8vIDE5LjEuMi4zIC8gMTUuMi4zLjcgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcylcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJyksICdPYmplY3QnLCB7IGRlZmluZVByb3BlcnRpZXM6IHJlcXVpcmUoJy4vX29iamVjdC1kcHMnKSB9KTtcbiIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG4vLyAxOS4xLjIuNCAvIDE1LjIuMy42IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKVxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSwgJ09iamVjdCcsIHsgZGVmaW5lUHJvcGVydHk6IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmYgfSk7XG4iLCIvLyAxOS4xLjIuNSBPYmplY3QuZnJlZXplKE8pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBtZXRhID0gcmVxdWlyZSgnLi9fbWV0YScpLm9uRnJlZXplO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2ZyZWV6ZScsIGZ1bmN0aW9uICgkZnJlZXplKSB7XG4gIHJldHVybiBmdW5jdGlvbiBmcmVlemUoaXQpIHtcbiAgICByZXR1cm4gJGZyZWV6ZSAmJiBpc09iamVjdChpdCkgPyAkZnJlZXplKG1ldGEoaXQpKSA6IGl0O1xuICB9O1xufSk7XG4iLCIvLyAxOS4xLjIuNiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApXG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpLmY7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgnZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJywgZnVuY3Rpb24gKCkge1xuICByZXR1cm4gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGl0LCBrZXkpIHtcbiAgICByZXR1cm4gJGdldE93blByb3BlcnR5RGVzY3JpcHRvcih0b0lPYmplY3QoaXQpLCBrZXkpO1xuICB9O1xufSk7XG4iLCIvLyAxOS4xLjIuNyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPKVxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdnZXRPd25Qcm9wZXJ0eU5hbWVzJywgZnVuY3Rpb24gKCkge1xuICByZXR1cm4gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4tZXh0JykuZjtcbn0pO1xuIiwiLy8gMTkuMS4yLjkgT2JqZWN0LmdldFByb3RvdHlwZU9mKE8pXG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciAkZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJyk7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgnZ2V0UHJvdG90eXBlT2YnLCBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBmdW5jdGlvbiBnZXRQcm90b3R5cGVPZihpdCkge1xuICAgIHJldHVybiAkZ2V0UHJvdG90eXBlT2YodG9PYmplY3QoaXQpKTtcbiAgfTtcbn0pO1xuIiwiLy8gMTkuMS4yLjExIE9iamVjdC5pc0V4dGVuc2libGUoTylcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2lzRXh0ZW5zaWJsZScsIGZ1bmN0aW9uICgkaXNFeHRlbnNpYmxlKSB7XG4gIHJldHVybiBmdW5jdGlvbiBpc0V4dGVuc2libGUoaXQpIHtcbiAgICByZXR1cm4gaXNPYmplY3QoaXQpID8gJGlzRXh0ZW5zaWJsZSA/ICRpc0V4dGVuc2libGUoaXQpIDogdHJ1ZSA6IGZhbHNlO1xuICB9O1xufSk7XG4iLCIvLyAxOS4xLjIuMTIgT2JqZWN0LmlzRnJvemVuKE8pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdpc0Zyb3plbicsIGZ1bmN0aW9uICgkaXNGcm96ZW4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGlzRnJvemVuKGl0KSB7XG4gICAgcmV0dXJuIGlzT2JqZWN0KGl0KSA/ICRpc0Zyb3plbiA/ICRpc0Zyb3plbihpdCkgOiBmYWxzZSA6IHRydWU7XG4gIH07XG59KTtcbiIsIi8vIDE5LjEuMi4xMyBPYmplY3QuaXNTZWFsZWQoTylcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2lzU2VhbGVkJywgZnVuY3Rpb24gKCRpc1NlYWxlZCkge1xuICByZXR1cm4gZnVuY3Rpb24gaXNTZWFsZWQoaXQpIHtcbiAgICByZXR1cm4gaXNPYmplY3QoaXQpID8gJGlzU2VhbGVkID8gJGlzU2VhbGVkKGl0KSA6IGZhbHNlIDogdHJ1ZTtcbiAgfTtcbn0pO1xuIiwiLy8gMTkuMS4zLjEwIE9iamVjdC5pcyh2YWx1ZTEsIHZhbHVlMilcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG4kZXhwb3J0KCRleHBvcnQuUywgJ09iamVjdCcsIHsgaXM6IHJlcXVpcmUoJy4vX3NhbWUtdmFsdWUnKSB9KTtcbiIsIi8vIDE5LjEuMi4xNCBPYmplY3Qua2V5cyhPKVxudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgJGtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2tleXMnLCBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBmdW5jdGlvbiBrZXlzKGl0KSB7XG4gICAgcmV0dXJuICRrZXlzKHRvT2JqZWN0KGl0KSk7XG4gIH07XG59KTtcbiIsIi8vIDE5LjEuMi4xNSBPYmplY3QucHJldmVudEV4dGVuc2lvbnMoTylcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIG1ldGEgPSByZXF1aXJlKCcuL19tZXRhJykub25GcmVlemU7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgncHJldmVudEV4dGVuc2lvbnMnLCBmdW5jdGlvbiAoJHByZXZlbnRFeHRlbnNpb25zKSB7XG4gIHJldHVybiBmdW5jdGlvbiBwcmV2ZW50RXh0ZW5zaW9ucyhpdCkge1xuICAgIHJldHVybiAkcHJldmVudEV4dGVuc2lvbnMgJiYgaXNPYmplY3QoaXQpID8gJHByZXZlbnRFeHRlbnNpb25zKG1ldGEoaXQpKSA6IGl0O1xuICB9O1xufSk7XG4iLCIvLyAxOS4xLjIuMTcgT2JqZWN0LnNlYWwoTylcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIG1ldGEgPSByZXF1aXJlKCcuL19tZXRhJykub25GcmVlemU7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgnc2VhbCcsIGZ1bmN0aW9uICgkc2VhbCkge1xuICByZXR1cm4gZnVuY3Rpb24gc2VhbChpdCkge1xuICAgIHJldHVybiAkc2VhbCAmJiBpc09iamVjdChpdCkgPyAkc2VhbChtZXRhKGl0KSkgOiBpdDtcbiAgfTtcbn0pO1xuIiwiLy8gMTkuMS4zLjE5IE9iamVjdC5zZXRQcm90b3R5cGVPZihPLCBwcm90bylcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG4kZXhwb3J0KCRleHBvcnQuUywgJ09iamVjdCcsIHsgc2V0UHJvdG90eXBlT2Y6IHJlcXVpcmUoJy4vX3NldC1wcm90bycpLnNldCB9KTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIDE5LjEuMy42IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcoKVxudmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuL19jbGFzc29mJyk7XG52YXIgdGVzdCA9IHt9O1xudGVzdFtyZXF1aXJlKCcuL193a3MnKSgndG9TdHJpbmdUYWcnKV0gPSAneic7XG5pZiAodGVzdCArICcnICE9ICdbb2JqZWN0IHpdJykge1xuICByZXF1aXJlKCcuL19yZWRlZmluZScpKE9iamVjdC5wcm90b3R5cGUsICd0b1N0cmluZycsIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiAnW29iamVjdCAnICsgY2xhc3NvZih0aGlzKSArICddJztcbiAgfSwgdHJ1ZSk7XG59XG4iLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRwYXJzZUZsb2F0ID0gcmVxdWlyZSgnLi9fcGFyc2UtZmxvYXQnKTtcbi8vIDE4LjIuNCBwYXJzZUZsb2F0KHN0cmluZylcbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5GICogKHBhcnNlRmxvYXQgIT0gJHBhcnNlRmxvYXQpLCB7IHBhcnNlRmxvYXQ6ICRwYXJzZUZsb2F0IH0pO1xuIiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkcGFyc2VJbnQgPSByZXF1aXJlKCcuL19wYXJzZS1pbnQnKTtcbi8vIDE4LjIuNSBwYXJzZUludChzdHJpbmcsIHJhZGl4KVxuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LkYgKiAocGFyc2VJbnQgIT0gJHBhcnNlSW50KSwgeyBwYXJzZUludDogJHBhcnNlSW50IH0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIExJQlJBUlkgPSByZXF1aXJlKCcuL19saWJyYXJ5Jyk7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG52YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4vX2NsYXNzb2YnKTtcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG52YXIgYW5JbnN0YW5jZSA9IHJlcXVpcmUoJy4vX2FuLWluc3RhbmNlJyk7XG52YXIgZm9yT2YgPSByZXF1aXJlKCcuL19mb3Itb2YnKTtcbnZhciBzcGVjaWVzQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuL19zcGVjaWVzLWNvbnN0cnVjdG9yJyk7XG52YXIgdGFzayA9IHJlcXVpcmUoJy4vX3Rhc2snKS5zZXQ7XG52YXIgbWljcm90YXNrID0gcmVxdWlyZSgnLi9fbWljcm90YXNrJykoKTtcbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZSA9IHJlcXVpcmUoJy4vX25ldy1wcm9taXNlLWNhcGFiaWxpdHknKTtcbnZhciBwZXJmb3JtID0gcmVxdWlyZSgnLi9fcGVyZm9ybScpO1xudmFyIHByb21pc2VSZXNvbHZlID0gcmVxdWlyZSgnLi9fcHJvbWlzZS1yZXNvbHZlJyk7XG52YXIgUFJPTUlTRSA9ICdQcm9taXNlJztcbnZhciBUeXBlRXJyb3IgPSBnbG9iYWwuVHlwZUVycm9yO1xudmFyIHByb2Nlc3MgPSBnbG9iYWwucHJvY2VzcztcbnZhciAkUHJvbWlzZSA9IGdsb2JhbFtQUk9NSVNFXTtcbnZhciBpc05vZGUgPSBjbGFzc29mKHByb2Nlc3MpID09ICdwcm9jZXNzJztcbnZhciBlbXB0eSA9IGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfTtcbnZhciBJbnRlcm5hbCwgbmV3R2VuZXJpY1Byb21pc2VDYXBhYmlsaXR5LCBPd25Qcm9taXNlQ2FwYWJpbGl0eSwgV3JhcHBlcjtcbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eSA9IG5ld0dlbmVyaWNQcm9taXNlQ2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlLmY7XG5cbnZhciBVU0VfTkFUSVZFID0gISFmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgLy8gY29ycmVjdCBzdWJjbGFzc2luZyB3aXRoIEBAc3BlY2llcyBzdXBwb3J0XG4gICAgdmFyIHByb21pc2UgPSAkUHJvbWlzZS5yZXNvbHZlKDEpO1xuICAgIHZhciBGYWtlUHJvbWlzZSA9IChwcm9taXNlLmNvbnN0cnVjdG9yID0ge30pW3JlcXVpcmUoJy4vX3drcycpKCdzcGVjaWVzJyldID0gZnVuY3Rpb24gKGV4ZWMpIHtcbiAgICAgIGV4ZWMoZW1wdHksIGVtcHR5KTtcbiAgICB9O1xuICAgIC8vIHVuaGFuZGxlZCByZWplY3Rpb25zIHRyYWNraW5nIHN1cHBvcnQsIE5vZGVKUyBQcm9taXNlIHdpdGhvdXQgaXQgZmFpbHMgQEBzcGVjaWVzIHRlc3RcbiAgICByZXR1cm4gKGlzTm9kZSB8fCB0eXBlb2YgUHJvbWlzZVJlamVjdGlvbkV2ZW50ID09ICdmdW5jdGlvbicpICYmIHByb21pc2UudGhlbihlbXB0eSkgaW5zdGFuY2VvZiBGYWtlUHJvbWlzZTtcbiAgfSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG59KCk7XG5cbi8vIGhlbHBlcnNcbnZhciBpc1RoZW5hYmxlID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciB0aGVuO1xuICByZXR1cm4gaXNPYmplY3QoaXQpICYmIHR5cGVvZiAodGhlbiA9IGl0LnRoZW4pID09ICdmdW5jdGlvbicgPyB0aGVuIDogZmFsc2U7XG59O1xudmFyIG5vdGlmeSA9IGZ1bmN0aW9uIChwcm9taXNlLCBpc1JlamVjdCkge1xuICBpZiAocHJvbWlzZS5fbikgcmV0dXJuO1xuICBwcm9taXNlLl9uID0gdHJ1ZTtcbiAgdmFyIGNoYWluID0gcHJvbWlzZS5fYztcbiAgbWljcm90YXNrKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdmFsdWUgPSBwcm9taXNlLl92O1xuICAgIHZhciBvayA9IHByb21pc2UuX3MgPT0gMTtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIHJ1biA9IGZ1bmN0aW9uIChyZWFjdGlvbikge1xuICAgICAgdmFyIGhhbmRsZXIgPSBvayA/IHJlYWN0aW9uLm9rIDogcmVhY3Rpb24uZmFpbDtcbiAgICAgIHZhciByZXNvbHZlID0gcmVhY3Rpb24ucmVzb2x2ZTtcbiAgICAgIHZhciByZWplY3QgPSByZWFjdGlvbi5yZWplY3Q7XG4gICAgICB2YXIgZG9tYWluID0gcmVhY3Rpb24uZG9tYWluO1xuICAgICAgdmFyIHJlc3VsdCwgdGhlbjtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAgICAgaWYgKCFvaykge1xuICAgICAgICAgICAgaWYgKHByb21pc2UuX2ggPT0gMikgb25IYW5kbGVVbmhhbmRsZWQocHJvbWlzZSk7XG4gICAgICAgICAgICBwcm9taXNlLl9oID0gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGhhbmRsZXIgPT09IHRydWUpIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGRvbWFpbikgZG9tYWluLmVudGVyKCk7XG4gICAgICAgICAgICByZXN1bHQgPSBoYW5kbGVyKHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChkb21haW4pIGRvbWFpbi5leGl0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXN1bHQgPT09IHJlYWN0aW9uLnByb21pc2UpIHtcbiAgICAgICAgICAgIHJlamVjdChUeXBlRXJyb3IoJ1Byb21pc2UtY2hhaW4gY3ljbGUnKSk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGVuID0gaXNUaGVuYWJsZShyZXN1bHQpKSB7XG4gICAgICAgICAgICB0aGVuLmNhbGwocmVzdWx0LCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0gZWxzZSByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0gZWxzZSByZWplY3QodmFsdWUpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZWplY3QoZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB3aGlsZSAoY2hhaW4ubGVuZ3RoID4gaSkgcnVuKGNoYWluW2krK10pOyAvLyB2YXJpYWJsZSBsZW5ndGggLSBjYW4ndCB1c2UgZm9yRWFjaFxuICAgIHByb21pc2UuX2MgPSBbXTtcbiAgICBwcm9taXNlLl9uID0gZmFsc2U7XG4gICAgaWYgKGlzUmVqZWN0ICYmICFwcm9taXNlLl9oKSBvblVuaGFuZGxlZChwcm9taXNlKTtcbiAgfSk7XG59O1xudmFyIG9uVW5oYW5kbGVkID0gZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgdGFzay5jYWxsKGdsb2JhbCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciB2YWx1ZSA9IHByb21pc2UuX3Y7XG4gICAgdmFyIHVuaGFuZGxlZCA9IGlzVW5oYW5kbGVkKHByb21pc2UpO1xuICAgIHZhciByZXN1bHQsIGhhbmRsZXIsIGNvbnNvbGU7XG4gICAgaWYgKHVuaGFuZGxlZCkge1xuICAgICAgcmVzdWx0ID0gcGVyZm9ybShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpc05vZGUpIHtcbiAgICAgICAgICBwcm9jZXNzLmVtaXQoJ3VuaGFuZGxlZFJlamVjdGlvbicsIHZhbHVlLCBwcm9taXNlKTtcbiAgICAgICAgfSBlbHNlIGlmIChoYW5kbGVyID0gZ2xvYmFsLm9udW5oYW5kbGVkcmVqZWN0aW9uKSB7XG4gICAgICAgICAgaGFuZGxlcih7IHByb21pc2U6IHByb21pc2UsIHJlYXNvbjogdmFsdWUgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoKGNvbnNvbGUgPSBnbG9iYWwuY29uc29sZSkgJiYgY29uc29sZS5lcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1VuaGFuZGxlZCBwcm9taXNlIHJlamVjdGlvbicsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICAvLyBCcm93c2VycyBzaG91bGQgbm90IHRyaWdnZXIgYHJlamVjdGlvbkhhbmRsZWRgIGV2ZW50IGlmIGl0IHdhcyBoYW5kbGVkIGhlcmUsIE5vZGVKUyAtIHNob3VsZFxuICAgICAgcHJvbWlzZS5faCA9IGlzTm9kZSB8fCBpc1VuaGFuZGxlZChwcm9taXNlKSA/IDIgOiAxO1xuICAgIH0gcHJvbWlzZS5fYSA9IHVuZGVmaW5lZDtcbiAgICBpZiAodW5oYW5kbGVkICYmIHJlc3VsdC5lKSB0aHJvdyByZXN1bHQudjtcbiAgfSk7XG59O1xudmFyIGlzVW5oYW5kbGVkID0gZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgaWYgKHByb21pc2UuX2ggPT0gMSkgcmV0dXJuIGZhbHNlO1xuICB2YXIgY2hhaW4gPSBwcm9taXNlLl9hIHx8IHByb21pc2UuX2M7XG4gIHZhciBpID0gMDtcbiAgdmFyIHJlYWN0aW9uO1xuICB3aGlsZSAoY2hhaW4ubGVuZ3RoID4gaSkge1xuICAgIHJlYWN0aW9uID0gY2hhaW5baSsrXTtcbiAgICBpZiAocmVhY3Rpb24uZmFpbCB8fCAhaXNVbmhhbmRsZWQocmVhY3Rpb24ucHJvbWlzZSkpIHJldHVybiBmYWxzZTtcbiAgfSByZXR1cm4gdHJ1ZTtcbn07XG52YXIgb25IYW5kbGVVbmhhbmRsZWQgPSBmdW5jdGlvbiAocHJvbWlzZSkge1xuICB0YXNrLmNhbGwoZ2xvYmFsLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGhhbmRsZXI7XG4gICAgaWYgKGlzTm9kZSkge1xuICAgICAgcHJvY2Vzcy5lbWl0KCdyZWplY3Rpb25IYW5kbGVkJywgcHJvbWlzZSk7XG4gICAgfSBlbHNlIGlmIChoYW5kbGVyID0gZ2xvYmFsLm9ucmVqZWN0aW9uaGFuZGxlZCkge1xuICAgICAgaGFuZGxlcih7IHByb21pc2U6IHByb21pc2UsIHJlYXNvbjogcHJvbWlzZS5fdiB9KTtcbiAgICB9XG4gIH0pO1xufTtcbnZhciAkcmVqZWN0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHZhciBwcm9taXNlID0gdGhpcztcbiAgaWYgKHByb21pc2UuX2QpIHJldHVybjtcbiAgcHJvbWlzZS5fZCA9IHRydWU7XG4gIHByb21pc2UgPSBwcm9taXNlLl93IHx8IHByb21pc2U7IC8vIHVud3JhcFxuICBwcm9taXNlLl92ID0gdmFsdWU7XG4gIHByb21pc2UuX3MgPSAyO1xuICBpZiAoIXByb21pc2UuX2EpIHByb21pc2UuX2EgPSBwcm9taXNlLl9jLnNsaWNlKCk7XG4gIG5vdGlmeShwcm9taXNlLCB0cnVlKTtcbn07XG52YXIgJHJlc29sdmUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgdmFyIHByb21pc2UgPSB0aGlzO1xuICB2YXIgdGhlbjtcbiAgaWYgKHByb21pc2UuX2QpIHJldHVybjtcbiAgcHJvbWlzZS5fZCA9IHRydWU7XG4gIHByb21pc2UgPSBwcm9taXNlLl93IHx8IHByb21pc2U7IC8vIHVud3JhcFxuICB0cnkge1xuICAgIGlmIChwcm9taXNlID09PSB2YWx1ZSkgdGhyb3cgVHlwZUVycm9yKFwiUHJvbWlzZSBjYW4ndCBiZSByZXNvbHZlZCBpdHNlbGZcIik7XG4gICAgaWYgKHRoZW4gPSBpc1RoZW5hYmxlKHZhbHVlKSkge1xuICAgICAgbWljcm90YXNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHdyYXBwZXIgPSB7IF93OiBwcm9taXNlLCBfZDogZmFsc2UgfTsgLy8gd3JhcFxuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoZW4uY2FsbCh2YWx1ZSwgY3R4KCRyZXNvbHZlLCB3cmFwcGVyLCAxKSwgY3R4KCRyZWplY3QsIHdyYXBwZXIsIDEpKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICRyZWplY3QuY2FsbCh3cmFwcGVyLCBlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb21pc2UuX3YgPSB2YWx1ZTtcbiAgICAgIHByb21pc2UuX3MgPSAxO1xuICAgICAgbm90aWZ5KHByb21pc2UsIGZhbHNlKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAkcmVqZWN0LmNhbGwoeyBfdzogcHJvbWlzZSwgX2Q6IGZhbHNlIH0sIGUpOyAvLyB3cmFwXG4gIH1cbn07XG5cbi8vIGNvbnN0cnVjdG9yIHBvbHlmaWxsXG5pZiAoIVVTRV9OQVRJVkUpIHtcbiAgLy8gMjUuNC4zLjEgUHJvbWlzZShleGVjdXRvcilcbiAgJFByb21pc2UgPSBmdW5jdGlvbiBQcm9taXNlKGV4ZWN1dG9yKSB7XG4gICAgYW5JbnN0YW5jZSh0aGlzLCAkUHJvbWlzZSwgUFJPTUlTRSwgJ19oJyk7XG4gICAgYUZ1bmN0aW9uKGV4ZWN1dG9yKTtcbiAgICBJbnRlcm5hbC5jYWxsKHRoaXMpO1xuICAgIHRyeSB7XG4gICAgICBleGVjdXRvcihjdHgoJHJlc29sdmUsIHRoaXMsIDEpLCBjdHgoJHJlamVjdCwgdGhpcywgMSkpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgJHJlamVjdC5jYWxsKHRoaXMsIGVycik7XG4gICAgfVxuICB9O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgSW50ZXJuYWwgPSBmdW5jdGlvbiBQcm9taXNlKGV4ZWN1dG9yKSB7XG4gICAgdGhpcy5fYyA9IFtdOyAgICAgICAgICAgICAvLyA8LSBhd2FpdGluZyByZWFjdGlvbnNcbiAgICB0aGlzLl9hID0gdW5kZWZpbmVkOyAgICAgIC8vIDwtIGNoZWNrZWQgaW4gaXNVbmhhbmRsZWQgcmVhY3Rpb25zXG4gICAgdGhpcy5fcyA9IDA7ICAgICAgICAgICAgICAvLyA8LSBzdGF0ZVxuICAgIHRoaXMuX2QgPSBmYWxzZTsgICAgICAgICAgLy8gPC0gZG9uZVxuICAgIHRoaXMuX3YgPSB1bmRlZmluZWQ7ICAgICAgLy8gPC0gdmFsdWVcbiAgICB0aGlzLl9oID0gMDsgICAgICAgICAgICAgIC8vIDwtIHJlamVjdGlvbiBzdGF0ZSwgMCAtIGRlZmF1bHQsIDEgLSBoYW5kbGVkLCAyIC0gdW5oYW5kbGVkXG4gICAgdGhpcy5fbiA9IGZhbHNlOyAgICAgICAgICAvLyA8LSBub3RpZnlcbiAgfTtcbiAgSW50ZXJuYWwucHJvdG90eXBlID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUtYWxsJykoJFByb21pc2UucHJvdG90eXBlLCB7XG4gICAgLy8gMjUuNC41LjMgUHJvbWlzZS5wcm90b3R5cGUudGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZClcbiAgICB0aGVuOiBmdW5jdGlvbiB0aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gICAgICB2YXIgcmVhY3Rpb24gPSBuZXdQcm9taXNlQ2FwYWJpbGl0eShzcGVjaWVzQ29uc3RydWN0b3IodGhpcywgJFByb21pc2UpKTtcbiAgICAgIHJlYWN0aW9uLm9rID0gdHlwZW9mIG9uRnVsZmlsbGVkID09ICdmdW5jdGlvbicgPyBvbkZ1bGZpbGxlZCA6IHRydWU7XG4gICAgICByZWFjdGlvbi5mYWlsID0gdHlwZW9mIG9uUmVqZWN0ZWQgPT0gJ2Z1bmN0aW9uJyAmJiBvblJlamVjdGVkO1xuICAgICAgcmVhY3Rpb24uZG9tYWluID0gaXNOb2RlID8gcHJvY2Vzcy5kb21haW4gOiB1bmRlZmluZWQ7XG4gICAgICB0aGlzLl9jLnB1c2gocmVhY3Rpb24pO1xuICAgICAgaWYgKHRoaXMuX2EpIHRoaXMuX2EucHVzaChyZWFjdGlvbik7XG4gICAgICBpZiAodGhpcy5fcykgbm90aWZ5KHRoaXMsIGZhbHNlKTtcbiAgICAgIHJldHVybiByZWFjdGlvbi5wcm9taXNlO1xuICAgIH0sXG4gICAgLy8gMjUuNC41LjEgUHJvbWlzZS5wcm90b3R5cGUuY2F0Y2gob25SZWplY3RlZClcbiAgICAnY2F0Y2gnOiBmdW5jdGlvbiAob25SZWplY3RlZCkge1xuICAgICAgcmV0dXJuIHRoaXMudGhlbih1bmRlZmluZWQsIG9uUmVqZWN0ZWQpO1xuICAgIH1cbiAgfSk7XG4gIE93blByb21pc2VDYXBhYmlsaXR5ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBwcm9taXNlID0gbmV3IEludGVybmFsKCk7XG4gICAgdGhpcy5wcm9taXNlID0gcHJvbWlzZTtcbiAgICB0aGlzLnJlc29sdmUgPSBjdHgoJHJlc29sdmUsIHByb21pc2UsIDEpO1xuICAgIHRoaXMucmVqZWN0ID0gY3R4KCRyZWplY3QsIHByb21pc2UsIDEpO1xuICB9O1xuICBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZS5mID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkgPSBmdW5jdGlvbiAoQykge1xuICAgIHJldHVybiBDID09PSAkUHJvbWlzZSB8fCBDID09PSBXcmFwcGVyXG4gICAgICA/IG5ldyBPd25Qcm9taXNlQ2FwYWJpbGl0eShDKVxuICAgICAgOiBuZXdHZW5lcmljUHJvbWlzZUNhcGFiaWxpdHkoQyk7XG4gIH07XG59XG5cbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsIHsgUHJvbWlzZTogJFByb21pc2UgfSk7XG5yZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpKCRQcm9taXNlLCBQUk9NSVNFKTtcbnJlcXVpcmUoJy4vX3NldC1zcGVjaWVzJykoUFJPTUlTRSk7XG5XcmFwcGVyID0gcmVxdWlyZSgnLi9fY29yZScpW1BST01JU0VdO1xuXG4vLyBzdGF0aWNzXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCBQUk9NSVNFLCB7XG4gIC8vIDI1LjQuNC41IFByb21pc2UucmVqZWN0KHIpXG4gIHJlamVjdDogZnVuY3Rpb24gcmVqZWN0KHIpIHtcbiAgICB2YXIgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KHRoaXMpO1xuICAgIHZhciAkJHJlamVjdCA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgICQkcmVqZWN0KHIpO1xuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbn0pO1xuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoTElCUkFSWSB8fCAhVVNFX05BVElWRSksIFBST01JU0UsIHtcbiAgLy8gMjUuNC40LjYgUHJvbWlzZS5yZXNvbHZlKHgpXG4gIHJlc29sdmU6IGZ1bmN0aW9uIHJlc29sdmUoeCkge1xuICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZShMSUJSQVJZICYmIHRoaXMgPT09IFdyYXBwZXIgPyAkUHJvbWlzZSA6IHRoaXMsIHgpO1xuICB9XG59KTtcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIShVU0VfTkFUSVZFICYmIHJlcXVpcmUoJy4vX2l0ZXItZGV0ZWN0JykoZnVuY3Rpb24gKGl0ZXIpIHtcbiAgJFByb21pc2UuYWxsKGl0ZXIpWydjYXRjaCddKGVtcHR5KTtcbn0pKSwgUFJPTUlTRSwge1xuICAvLyAyNS40LjQuMSBQcm9taXNlLmFsbChpdGVyYWJsZSlcbiAgYWxsOiBmdW5jdGlvbiBhbGwoaXRlcmFibGUpIHtcbiAgICB2YXIgQyA9IHRoaXM7XG4gICAgdmFyIGNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eShDKTtcbiAgICB2YXIgcmVzb2x2ZSA9IGNhcGFiaWxpdHkucmVzb2x2ZTtcbiAgICB2YXIgcmVqZWN0ID0gY2FwYWJpbGl0eS5yZWplY3Q7XG4gICAgdmFyIHJlc3VsdCA9IHBlcmZvcm0oZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgIHZhciByZW1haW5pbmcgPSAxO1xuICAgICAgZm9yT2YoaXRlcmFibGUsIGZhbHNlLCBmdW5jdGlvbiAocHJvbWlzZSkge1xuICAgICAgICB2YXIgJGluZGV4ID0gaW5kZXgrKztcbiAgICAgICAgdmFyIGFscmVhZHlDYWxsZWQgPSBmYWxzZTtcbiAgICAgICAgdmFsdWVzLnB1c2godW5kZWZpbmVkKTtcbiAgICAgICAgcmVtYWluaW5nKys7XG4gICAgICAgIEMucmVzb2x2ZShwcm9taXNlKS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIGlmIChhbHJlYWR5Q2FsbGVkKSByZXR1cm47XG4gICAgICAgICAgYWxyZWFkeUNhbGxlZCA9IHRydWU7XG4gICAgICAgICAgdmFsdWVzWyRpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgICAtLXJlbWFpbmluZyB8fCByZXNvbHZlKHZhbHVlcyk7XG4gICAgICAgIH0sIHJlamVjdCk7XG4gICAgICB9KTtcbiAgICAgIC0tcmVtYWluaW5nIHx8IHJlc29sdmUodmFsdWVzKTtcbiAgICB9KTtcbiAgICBpZiAocmVzdWx0LmUpIHJlamVjdChyZXN1bHQudik7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfSxcbiAgLy8gMjUuNC40LjQgUHJvbWlzZS5yYWNlKGl0ZXJhYmxlKVxuICByYWNlOiBmdW5jdGlvbiByYWNlKGl0ZXJhYmxlKSB7XG4gICAgdmFyIEMgPSB0aGlzO1xuICAgIHZhciBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkoQyk7XG4gICAgdmFyIHJlamVjdCA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgIHZhciByZXN1bHQgPSBwZXJmb3JtKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvck9mKGl0ZXJhYmxlLCBmYWxzZSwgZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgICAgICAgQy5yZXNvbHZlKHByb21pc2UpLnRoZW4oY2FwYWJpbGl0eS5yZXNvbHZlLCByZWplY3QpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgaWYgKHJlc3VsdC5lKSByZWplY3QocmVzdWx0LnYpO1xuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbn0pO1xuIiwiLy8gMjYuMS4xIFJlZmxlY3QuYXBwbHkodGFyZ2V0LCB0aGlzQXJndW1lbnQsIGFyZ3VtZW50c0xpc3QpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIHJBcHBseSA9IChyZXF1aXJlKCcuL19nbG9iYWwnKS5SZWZsZWN0IHx8IHt9KS5hcHBseTtcbnZhciBmQXBwbHkgPSBGdW5jdGlvbi5hcHBseTtcbi8vIE1TIEVkZ2UgYXJndW1lbnRzTGlzdCBhcmd1bWVudCBpcyBvcHRpb25hbFxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHJBcHBseShmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH0pO1xufSksICdSZWZsZWN0Jywge1xuICBhcHBseTogZnVuY3Rpb24gYXBwbHkodGFyZ2V0LCB0aGlzQXJndW1lbnQsIGFyZ3VtZW50c0xpc3QpIHtcbiAgICB2YXIgVCA9IGFGdW5jdGlvbih0YXJnZXQpO1xuICAgIHZhciBMID0gYW5PYmplY3QoYXJndW1lbnRzTGlzdCk7XG4gICAgcmV0dXJuIHJBcHBseSA/IHJBcHBseShULCB0aGlzQXJndW1lbnQsIEwpIDogZkFwcGx5LmNhbGwoVCwgdGhpc0FyZ3VtZW50LCBMKTtcbiAgfVxufSk7XG4iLCIvLyAyNi4xLjIgUmVmbGVjdC5jb25zdHJ1Y3QodGFyZ2V0LCBhcmd1bWVudHNMaXN0IFssIG5ld1RhcmdldF0pXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGNyZWF0ZSA9IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKTtcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbnZhciBiaW5kID0gcmVxdWlyZSgnLi9fYmluZCcpO1xudmFyIHJDb25zdHJ1Y3QgPSAocmVxdWlyZSgnLi9fZ2xvYmFsJykuUmVmbGVjdCB8fCB7fSkuY29uc3RydWN0O1xuXG4vLyBNUyBFZGdlIHN1cHBvcnRzIG9ubHkgMiBhcmd1bWVudHMgYW5kIGFyZ3VtZW50c0xpc3QgYXJndW1lbnQgaXMgb3B0aW9uYWxcbi8vIEZGIE5pZ2h0bHkgc2V0cyB0aGlyZCBhcmd1bWVudCBhcyBgbmV3LnRhcmdldGAsIGJ1dCBkb2VzIG5vdCBjcmVhdGUgYHRoaXNgIGZyb20gaXRcbnZhciBORVdfVEFSR0VUX0JVRyA9IGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRigpIHsgLyogZW1wdHkgKi8gfVxuICByZXR1cm4gIShyQ29uc3RydWN0KGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSwgW10sIEYpIGluc3RhbmNlb2YgRik7XG59KTtcbnZhciBBUkdTX0JVRyA9ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHJDb25zdHJ1Y3QoZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9KTtcbn0pO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIChORVdfVEFSR0VUX0JVRyB8fCBBUkdTX0JVRyksICdSZWZsZWN0Jywge1xuICBjb25zdHJ1Y3Q6IGZ1bmN0aW9uIGNvbnN0cnVjdChUYXJnZXQsIGFyZ3MgLyogLCBuZXdUYXJnZXQgKi8pIHtcbiAgICBhRnVuY3Rpb24oVGFyZ2V0KTtcbiAgICBhbk9iamVjdChhcmdzKTtcbiAgICB2YXIgbmV3VGFyZ2V0ID0gYXJndW1lbnRzLmxlbmd0aCA8IDMgPyBUYXJnZXQgOiBhRnVuY3Rpb24oYXJndW1lbnRzWzJdKTtcbiAgICBpZiAoQVJHU19CVUcgJiYgIU5FV19UQVJHRVRfQlVHKSByZXR1cm4gckNvbnN0cnVjdChUYXJnZXQsIGFyZ3MsIG5ld1RhcmdldCk7XG4gICAgaWYgKFRhcmdldCA9PSBuZXdUYXJnZXQpIHtcbiAgICAgIC8vIHcvbyBhbHRlcmVkIG5ld1RhcmdldCwgb3B0aW1pemF0aW9uIGZvciAwLTQgYXJndW1lbnRzXG4gICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMDogcmV0dXJuIG5ldyBUYXJnZXQoKTtcbiAgICAgICAgY2FzZSAxOiByZXR1cm4gbmV3IFRhcmdldChhcmdzWzBdKTtcbiAgICAgICAgY2FzZSAyOiByZXR1cm4gbmV3IFRhcmdldChhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgICAgY2FzZSAzOiByZXR1cm4gbmV3IFRhcmdldChhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICAgICAgY2FzZSA0OiByZXR1cm4gbmV3IFRhcmdldChhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKTtcbiAgICAgIH1cbiAgICAgIC8vIHcvbyBhbHRlcmVkIG5ld1RhcmdldCwgbG90IG9mIGFyZ3VtZW50cyBjYXNlXG4gICAgICB2YXIgJGFyZ3MgPSBbbnVsbF07XG4gICAgICAkYXJncy5wdXNoLmFwcGx5KCRhcmdzLCBhcmdzKTtcbiAgICAgIHJldHVybiBuZXcgKGJpbmQuYXBwbHkoVGFyZ2V0LCAkYXJncykpKCk7XG4gICAgfVxuICAgIC8vIHdpdGggYWx0ZXJlZCBuZXdUYXJnZXQsIG5vdCBzdXBwb3J0IGJ1aWx0LWluIGNvbnN0cnVjdG9yc1xuICAgIHZhciBwcm90byA9IG5ld1RhcmdldC5wcm90b3R5cGU7XG4gICAgdmFyIGluc3RhbmNlID0gY3JlYXRlKGlzT2JqZWN0KHByb3RvKSA/IHByb3RvIDogT2JqZWN0LnByb3RvdHlwZSk7XG4gICAgdmFyIHJlc3VsdCA9IEZ1bmN0aW9uLmFwcGx5LmNhbGwoVGFyZ2V0LCBpbnN0YW5jZSwgYXJncyk7XG4gICAgcmV0dXJuIGlzT2JqZWN0KHJlc3VsdCkgPyByZXN1bHQgOiBpbnN0YW5jZTtcbiAgfVxufSk7XG4iLCIvLyAyNi4xLjMgUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5S2V5LCBhdHRyaWJ1dGVzKVxudmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcblxuLy8gTVMgRWRnZSBoYXMgYnJva2VuIFJlZmxlY3QuZGVmaW5lUHJvcGVydHkgLSB0aHJvd2luZyBpbnN0ZWFkIG9mIHJldHVybmluZyBmYWxzZVxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gIFJlZmxlY3QuZGVmaW5lUHJvcGVydHkoZFAuZih7fSwgMSwgeyB2YWx1ZTogMSB9KSwgMSwgeyB2YWx1ZTogMiB9KTtcbn0pLCAnUmVmbGVjdCcsIHtcbiAgZGVmaW5lUHJvcGVydHk6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHlLZXksIGF0dHJpYnV0ZXMpIHtcbiAgICBhbk9iamVjdCh0YXJnZXQpO1xuICAgIHByb3BlcnR5S2V5ID0gdG9QcmltaXRpdmUocHJvcGVydHlLZXksIHRydWUpO1xuICAgIGFuT2JqZWN0KGF0dHJpYnV0ZXMpO1xuICAgIHRyeSB7XG4gICAgICBkUC5mKHRhcmdldCwgcHJvcGVydHlLZXksIGF0dHJpYnV0ZXMpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxufSk7XG4iLCIvLyAyNi4xLjQgUmVmbGVjdC5kZWxldGVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5S2V5KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBnT1BEID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKS5mO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHtcbiAgZGVsZXRlUHJvcGVydHk6IGZ1bmN0aW9uIGRlbGV0ZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHlLZXkpIHtcbiAgICB2YXIgZGVzYyA9IGdPUEQoYW5PYmplY3QodGFyZ2V0KSwgcHJvcGVydHlLZXkpO1xuICAgIHJldHVybiBkZXNjICYmICFkZXNjLmNvbmZpZ3VyYWJsZSA/IGZhbHNlIDogZGVsZXRlIHRhcmdldFtwcm9wZXJ0eUtleV07XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gMjYuMS41IFJlZmxlY3QuZW51bWVyYXRlKHRhcmdldClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBFbnVtZXJhdGUgPSBmdW5jdGlvbiAoaXRlcmF0ZWQpIHtcbiAgdGhpcy5fdCA9IGFuT2JqZWN0KGl0ZXJhdGVkKTsgLy8gdGFyZ2V0XG4gIHRoaXMuX2kgPSAwOyAgICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXhcbiAgdmFyIGtleXMgPSB0aGlzLl9rID0gW107ICAgICAgLy8ga2V5c1xuICB2YXIga2V5O1xuICBmb3IgKGtleSBpbiBpdGVyYXRlZCkga2V5cy5wdXNoKGtleSk7XG59O1xucmVxdWlyZSgnLi9faXRlci1jcmVhdGUnKShFbnVtZXJhdGUsICdPYmplY3QnLCBmdW5jdGlvbiAoKSB7XG4gIHZhciB0aGF0ID0gdGhpcztcbiAgdmFyIGtleXMgPSB0aGF0Ll9rO1xuICB2YXIga2V5O1xuICBkbyB7XG4gICAgaWYgKHRoYXQuX2kgPj0ga2V5cy5sZW5ndGgpIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgfSB3aGlsZSAoISgoa2V5ID0ga2V5c1t0aGF0Ll9pKytdKSBpbiB0aGF0Ll90KSk7XG4gIHJldHVybiB7IHZhbHVlOiBrZXksIGRvbmU6IGZhbHNlIH07XG59KTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge1xuICBlbnVtZXJhdGU6IGZ1bmN0aW9uIGVudW1lcmF0ZSh0YXJnZXQpIHtcbiAgICByZXR1cm4gbmV3IEVudW1lcmF0ZSh0YXJnZXQpO1xuICB9XG59KTtcbiIsIi8vIDI2LjEuNyBSZWZsZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIHByb3BlcnR5S2V5KVxudmFyIGdPUEQgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7XG4gIGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwgcHJvcGVydHlLZXkpIHtcbiAgICByZXR1cm4gZ09QRC5mKGFuT2JqZWN0KHRhcmdldCksIHByb3BlcnR5S2V5KTtcbiAgfVxufSk7XG4iLCIvLyAyNi4xLjggUmVmbGVjdC5nZXRQcm90b3R5cGVPZih0YXJnZXQpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGdldFByb3RvID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHtcbiAgZ2V0UHJvdG90eXBlT2Y6IGZ1bmN0aW9uIGdldFByb3RvdHlwZU9mKHRhcmdldCkge1xuICAgIHJldHVybiBnZXRQcm90byhhbk9iamVjdCh0YXJnZXQpKTtcbiAgfVxufSk7XG4iLCIvLyAyNi4xLjYgUmVmbGVjdC5nZXQodGFyZ2V0LCBwcm9wZXJ0eUtleSBbLCByZWNlaXZlcl0pXG52YXIgZ09QRCA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJyk7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcblxuZnVuY3Rpb24gZ2V0KHRhcmdldCwgcHJvcGVydHlLZXkgLyogLCByZWNlaXZlciAqLykge1xuICB2YXIgcmVjZWl2ZXIgPSBhcmd1bWVudHMubGVuZ3RoIDwgMyA/IHRhcmdldCA6IGFyZ3VtZW50c1syXTtcbiAgdmFyIGRlc2MsIHByb3RvO1xuICBpZiAoYW5PYmplY3QodGFyZ2V0KSA9PT0gcmVjZWl2ZXIpIHJldHVybiB0YXJnZXRbcHJvcGVydHlLZXldO1xuICBpZiAoZGVzYyA9IGdPUEQuZih0YXJnZXQsIHByb3BlcnR5S2V5KSkgcmV0dXJuIGhhcyhkZXNjLCAndmFsdWUnKVxuICAgID8gZGVzYy52YWx1ZVxuICAgIDogZGVzYy5nZXQgIT09IHVuZGVmaW5lZFxuICAgICAgPyBkZXNjLmdldC5jYWxsKHJlY2VpdmVyKVxuICAgICAgOiB1bmRlZmluZWQ7XG4gIGlmIChpc09iamVjdChwcm90byA9IGdldFByb3RvdHlwZU9mKHRhcmdldCkpKSByZXR1cm4gZ2V0KHByb3RvLCBwcm9wZXJ0eUtleSwgcmVjZWl2ZXIpO1xufVxuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7IGdldDogZ2V0IH0pO1xuIiwiLy8gMjYuMS45IFJlZmxlY3QuaGFzKHRhcmdldCwgcHJvcGVydHlLZXkpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7XG4gIGhhczogZnVuY3Rpb24gaGFzKHRhcmdldCwgcHJvcGVydHlLZXkpIHtcbiAgICByZXR1cm4gcHJvcGVydHlLZXkgaW4gdGFyZ2V0O1xuICB9XG59KTtcbiIsIi8vIDI2LjEuMTAgUmVmbGVjdC5pc0V4dGVuc2libGUodGFyZ2V0KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyICRpc0V4dGVuc2libGUgPSBPYmplY3QuaXNFeHRlbnNpYmxlO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7XG4gIGlzRXh0ZW5zaWJsZTogZnVuY3Rpb24gaXNFeHRlbnNpYmxlKHRhcmdldCkge1xuICAgIGFuT2JqZWN0KHRhcmdldCk7XG4gICAgcmV0dXJuICRpc0V4dGVuc2libGUgPyAkaXNFeHRlbnNpYmxlKHRhcmdldCkgOiB0cnVlO1xuICB9XG59KTtcbiIsIi8vIDI2LjEuMTEgUmVmbGVjdC5vd25LZXlzKHRhcmdldClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHsgb3duS2V5czogcmVxdWlyZSgnLi9fb3duLWtleXMnKSB9KTtcbiIsIi8vIDI2LjEuMTIgUmVmbGVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh0YXJnZXQpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgJHByZXZlbnRFeHRlbnNpb25zID0gT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7XG4gIHByZXZlbnRFeHRlbnNpb25zOiBmdW5jdGlvbiBwcmV2ZW50RXh0ZW5zaW9ucyh0YXJnZXQpIHtcbiAgICBhbk9iamVjdCh0YXJnZXQpO1xuICAgIHRyeSB7XG4gICAgICBpZiAoJHByZXZlbnRFeHRlbnNpb25zKSAkcHJldmVudEV4dGVuc2lvbnModGFyZ2V0KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbn0pO1xuIiwiLy8gMjYuMS4xNCBSZWZsZWN0LnNldFByb3RvdHlwZU9mKHRhcmdldCwgcHJvdG8pXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHNldFByb3RvID0gcmVxdWlyZSgnLi9fc2V0LXByb3RvJyk7XG5cbmlmIChzZXRQcm90bykgJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge1xuICBzZXRQcm90b3R5cGVPZjogZnVuY3Rpb24gc2V0UHJvdG90eXBlT2YodGFyZ2V0LCBwcm90bykge1xuICAgIHNldFByb3RvLmNoZWNrKHRhcmdldCwgcHJvdG8pO1xuICAgIHRyeSB7XG4gICAgICBzZXRQcm90by5zZXQodGFyZ2V0LCBwcm90byk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG59KTtcbiIsIi8vIDI2LjEuMTMgUmVmbGVjdC5zZXQodGFyZ2V0LCBwcm9wZXJ0eUtleSwgViBbLCByZWNlaXZlcl0pXG52YXIgZFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcbnZhciBnT1BEID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKTtcbnZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5cbmZ1bmN0aW9uIHNldCh0YXJnZXQsIHByb3BlcnR5S2V5LCBWIC8qICwgcmVjZWl2ZXIgKi8pIHtcbiAgdmFyIHJlY2VpdmVyID0gYXJndW1lbnRzLmxlbmd0aCA8IDQgPyB0YXJnZXQgOiBhcmd1bWVudHNbM107XG4gIHZhciBvd25EZXNjID0gZ09QRC5mKGFuT2JqZWN0KHRhcmdldCksIHByb3BlcnR5S2V5KTtcbiAgdmFyIGV4aXN0aW5nRGVzY3JpcHRvciwgcHJvdG87XG4gIGlmICghb3duRGVzYykge1xuICAgIGlmIChpc09iamVjdChwcm90byA9IGdldFByb3RvdHlwZU9mKHRhcmdldCkpKSB7XG4gICAgICByZXR1cm4gc2V0KHByb3RvLCBwcm9wZXJ0eUtleSwgViwgcmVjZWl2ZXIpO1xuICAgIH1cbiAgICBvd25EZXNjID0gY3JlYXRlRGVzYygwKTtcbiAgfVxuICBpZiAoaGFzKG93bkRlc2MsICd2YWx1ZScpKSB7XG4gICAgaWYgKG93bkRlc2Mud3JpdGFibGUgPT09IGZhbHNlIHx8ICFpc09iamVjdChyZWNlaXZlcikpIHJldHVybiBmYWxzZTtcbiAgICBleGlzdGluZ0Rlc2NyaXB0b3IgPSBnT1BELmYocmVjZWl2ZXIsIHByb3BlcnR5S2V5KSB8fCBjcmVhdGVEZXNjKDApO1xuICAgIGV4aXN0aW5nRGVzY3JpcHRvci52YWx1ZSA9IFY7XG4gICAgZFAuZihyZWNlaXZlciwgcHJvcGVydHlLZXksIGV4aXN0aW5nRGVzY3JpcHRvcik7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIG93bkRlc2Muc2V0ID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IChvd25EZXNjLnNldC5jYWxsKHJlY2VpdmVyLCBWKSwgdHJ1ZSk7XG59XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHsgc2V0OiBzZXQgfSk7XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgaW5oZXJpdElmUmVxdWlyZWQgPSByZXF1aXJlKCcuL19pbmhlcml0LWlmLXJlcXVpcmVkJyk7XG52YXIgZFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mO1xudmFyIGdPUE4gPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbicpLmY7XG52YXIgaXNSZWdFeHAgPSByZXF1aXJlKCcuL19pcy1yZWdleHAnKTtcbnZhciAkZmxhZ3MgPSByZXF1aXJlKCcuL19mbGFncycpO1xudmFyICRSZWdFeHAgPSBnbG9iYWwuUmVnRXhwO1xudmFyIEJhc2UgPSAkUmVnRXhwO1xudmFyIHByb3RvID0gJFJlZ0V4cC5wcm90b3R5cGU7XG52YXIgcmUxID0gL2EvZztcbnZhciByZTIgPSAvYS9nO1xuLy8gXCJuZXdcIiBjcmVhdGVzIGEgbmV3IG9iamVjdCwgb2xkIHdlYmtpdCBidWdneSBoZXJlXG52YXIgQ09SUkVDVF9ORVcgPSBuZXcgJFJlZ0V4cChyZTEpICE9PSByZTE7XG5cbmlmIChyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmICghQ09SUkVDVF9ORVcgfHwgcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHJlMltyZXF1aXJlKCcuL193a3MnKSgnbWF0Y2gnKV0gPSBmYWxzZTtcbiAgLy8gUmVnRXhwIGNvbnN0cnVjdG9yIGNhbiBhbHRlciBmbGFncyBhbmQgSXNSZWdFeHAgd29ya3MgY29ycmVjdCB3aXRoIEBAbWF0Y2hcbiAgcmV0dXJuICRSZWdFeHAocmUxKSAhPSByZTEgfHwgJFJlZ0V4cChyZTIpID09IHJlMiB8fCAkUmVnRXhwKHJlMSwgJ2knKSAhPSAnL2EvaSc7XG59KSkpIHtcbiAgJFJlZ0V4cCA9IGZ1bmN0aW9uIFJlZ0V4cChwLCBmKSB7XG4gICAgdmFyIHRpUkUgPSB0aGlzIGluc3RhbmNlb2YgJFJlZ0V4cDtcbiAgICB2YXIgcGlSRSA9IGlzUmVnRXhwKHApO1xuICAgIHZhciBmaVUgPSBmID09PSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuICF0aVJFICYmIHBpUkUgJiYgcC5jb25zdHJ1Y3RvciA9PT0gJFJlZ0V4cCAmJiBmaVUgPyBwXG4gICAgICA6IGluaGVyaXRJZlJlcXVpcmVkKENPUlJFQ1RfTkVXXG4gICAgICAgID8gbmV3IEJhc2UocGlSRSAmJiAhZmlVID8gcC5zb3VyY2UgOiBwLCBmKVxuICAgICAgICA6IEJhc2UoKHBpUkUgPSBwIGluc3RhbmNlb2YgJFJlZ0V4cCkgPyBwLnNvdXJjZSA6IHAsIHBpUkUgJiYgZmlVID8gJGZsYWdzLmNhbGwocCkgOiBmKVxuICAgICAgLCB0aVJFID8gdGhpcyA6IHByb3RvLCAkUmVnRXhwKTtcbiAgfTtcbiAgdmFyIHByb3h5ID0gZnVuY3Rpb24gKGtleSkge1xuICAgIGtleSBpbiAkUmVnRXhwIHx8IGRQKCRSZWdFeHAsIGtleSwge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBCYXNlW2tleV07IH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIChpdCkgeyBCYXNlW2tleV0gPSBpdDsgfVxuICAgIH0pO1xuICB9O1xuICBmb3IgKHZhciBrZXlzID0gZ09QTihCYXNlKSwgaSA9IDA7IGtleXMubGVuZ3RoID4gaTspIHByb3h5KGtleXNbaSsrXSk7XG4gIHByb3RvLmNvbnN0cnVjdG9yID0gJFJlZ0V4cDtcbiAgJFJlZ0V4cC5wcm90b3R5cGUgPSBwcm90bztcbiAgcmVxdWlyZSgnLi9fcmVkZWZpbmUnKShnbG9iYWwsICdSZWdFeHAnLCAkUmVnRXhwKTtcbn1cblxucmVxdWlyZSgnLi9fc2V0LXNwZWNpZXMnKSgnUmVnRXhwJyk7XG4iLCIvLyAyMS4yLjUuMyBnZXQgUmVnRXhwLnByb3RvdHlwZS5mbGFncygpXG5pZiAocmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiAvLi9nLmZsYWdzICE9ICdnJykgcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZihSZWdFeHAucHJvdG90eXBlLCAnZmxhZ3MnLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZ2V0OiByZXF1aXJlKCcuL19mbGFncycpXG59KTtcbiIsIi8vIEBAbWF0Y2ggbG9naWNcbnJlcXVpcmUoJy4vX2ZpeC1yZS13a3MnKSgnbWF0Y2gnLCAxLCBmdW5jdGlvbiAoZGVmaW5lZCwgTUFUQ0gsICRtYXRjaCkge1xuICAvLyAyMS4xLjMuMTEgU3RyaW5nLnByb3RvdHlwZS5tYXRjaChyZWdleHApXG4gIHJldHVybiBbZnVuY3Rpb24gbWF0Y2gocmVnZXhwKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIHZhciBPID0gZGVmaW5lZCh0aGlzKTtcbiAgICB2YXIgZm4gPSByZWdleHAgPT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogcmVnZXhwW01BVENIXTtcbiAgICByZXR1cm4gZm4gIT09IHVuZGVmaW5lZCA/IGZuLmNhbGwocmVnZXhwLCBPKSA6IG5ldyBSZWdFeHAocmVnZXhwKVtNQVRDSF0oU3RyaW5nKE8pKTtcbiAgfSwgJG1hdGNoXTtcbn0pO1xuIiwiLy8gQEByZXBsYWNlIGxvZ2ljXG5yZXF1aXJlKCcuL19maXgtcmUtd2tzJykoJ3JlcGxhY2UnLCAyLCBmdW5jdGlvbiAoZGVmaW5lZCwgUkVQTEFDRSwgJHJlcGxhY2UpIHtcbiAgLy8gMjEuMS4zLjE0IFN0cmluZy5wcm90b3R5cGUucmVwbGFjZShzZWFyY2hWYWx1ZSwgcmVwbGFjZVZhbHVlKVxuICByZXR1cm4gW2Z1bmN0aW9uIHJlcGxhY2Uoc2VhcmNoVmFsdWUsIHJlcGxhY2VWYWx1ZSkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICB2YXIgTyA9IGRlZmluZWQodGhpcyk7XG4gICAgdmFyIGZuID0gc2VhcmNoVmFsdWUgPT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogc2VhcmNoVmFsdWVbUkVQTEFDRV07XG4gICAgcmV0dXJuIGZuICE9PSB1bmRlZmluZWRcbiAgICAgID8gZm4uY2FsbChzZWFyY2hWYWx1ZSwgTywgcmVwbGFjZVZhbHVlKVxuICAgICAgOiAkcmVwbGFjZS5jYWxsKFN0cmluZyhPKSwgc2VhcmNoVmFsdWUsIHJlcGxhY2VWYWx1ZSk7XG4gIH0sICRyZXBsYWNlXTtcbn0pO1xuIiwiLy8gQEBzZWFyY2ggbG9naWNcbnJlcXVpcmUoJy4vX2ZpeC1yZS13a3MnKSgnc2VhcmNoJywgMSwgZnVuY3Rpb24gKGRlZmluZWQsIFNFQVJDSCwgJHNlYXJjaCkge1xuICAvLyAyMS4xLjMuMTUgU3RyaW5nLnByb3RvdHlwZS5zZWFyY2gocmVnZXhwKVxuICByZXR1cm4gW2Z1bmN0aW9uIHNlYXJjaChyZWdleHApIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgdmFyIE8gPSBkZWZpbmVkKHRoaXMpO1xuICAgIHZhciBmbiA9IHJlZ2V4cCA9PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiByZWdleHBbU0VBUkNIXTtcbiAgICByZXR1cm4gZm4gIT09IHVuZGVmaW5lZCA/IGZuLmNhbGwocmVnZXhwLCBPKSA6IG5ldyBSZWdFeHAocmVnZXhwKVtTRUFSQ0hdKFN0cmluZyhPKSk7XG4gIH0sICRzZWFyY2hdO1xufSk7XG4iLCIvLyBAQHNwbGl0IGxvZ2ljXG5yZXF1aXJlKCcuL19maXgtcmUtd2tzJykoJ3NwbGl0JywgMiwgZnVuY3Rpb24gKGRlZmluZWQsIFNQTElULCAkc3BsaXQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuICB2YXIgaXNSZWdFeHAgPSByZXF1aXJlKCcuL19pcy1yZWdleHAnKTtcbiAgdmFyIF9zcGxpdCA9ICRzcGxpdDtcbiAgdmFyICRwdXNoID0gW10ucHVzaDtcbiAgdmFyICRTUExJVCA9ICdzcGxpdCc7XG4gIHZhciBMRU5HVEggPSAnbGVuZ3RoJztcbiAgdmFyIExBU1RfSU5ERVggPSAnbGFzdEluZGV4JztcbiAgaWYgKFxuICAgICdhYmJjJ1skU1BMSVRdKC8oYikqLylbMV0gPT0gJ2MnIHx8XG4gICAgJ3Rlc3QnWyRTUExJVF0oLyg/OikvLCAtMSlbTEVOR1RIXSAhPSA0IHx8XG4gICAgJ2FiJ1skU1BMSVRdKC8oPzphYikqLylbTEVOR1RIXSAhPSAyIHx8XG4gICAgJy4nWyRTUExJVF0oLyguPykoLj8pLylbTEVOR1RIXSAhPSA0IHx8XG4gICAgJy4nWyRTUExJVF0oLygpKCkvKVtMRU5HVEhdID4gMSB8fFxuICAgICcnWyRTUExJVF0oLy4/LylbTEVOR1RIXVxuICApIHtcbiAgICB2YXIgTlBDRyA9IC8oKT8/Ly5leGVjKCcnKVsxXSA9PT0gdW5kZWZpbmVkOyAvLyBub25wYXJ0aWNpcGF0aW5nIGNhcHR1cmluZyBncm91cFxuICAgIC8vIGJhc2VkIG9uIGVzNS1zaGltIGltcGxlbWVudGF0aW9uLCBuZWVkIHRvIHJld29yayBpdFxuICAgICRzcGxpdCA9IGZ1bmN0aW9uIChzZXBhcmF0b3IsIGxpbWl0KSB7XG4gICAgICB2YXIgc3RyaW5nID0gU3RyaW5nKHRoaXMpO1xuICAgICAgaWYgKHNlcGFyYXRvciA9PT0gdW5kZWZpbmVkICYmIGxpbWl0ID09PSAwKSByZXR1cm4gW107XG4gICAgICAvLyBJZiBgc2VwYXJhdG9yYCBpcyBub3QgYSByZWdleCwgdXNlIG5hdGl2ZSBzcGxpdFxuICAgICAgaWYgKCFpc1JlZ0V4cChzZXBhcmF0b3IpKSByZXR1cm4gX3NwbGl0LmNhbGwoc3RyaW5nLCBzZXBhcmF0b3IsIGxpbWl0KTtcbiAgICAgIHZhciBvdXRwdXQgPSBbXTtcbiAgICAgIHZhciBmbGFncyA9IChzZXBhcmF0b3IuaWdub3JlQ2FzZSA/ICdpJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAoc2VwYXJhdG9yLm11bHRpbGluZSA/ICdtJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAoc2VwYXJhdG9yLnVuaWNvZGUgPyAndScgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKHNlcGFyYXRvci5zdGlja3kgPyAneScgOiAnJyk7XG4gICAgICB2YXIgbGFzdExhc3RJbmRleCA9IDA7XG4gICAgICB2YXIgc3BsaXRMaW1pdCA9IGxpbWl0ID09PSB1bmRlZmluZWQgPyA0Mjk0OTY3Mjk1IDogbGltaXQgPj4+IDA7XG4gICAgICAvLyBNYWtlIGBnbG9iYWxgIGFuZCBhdm9pZCBgbGFzdEluZGV4YCBpc3N1ZXMgYnkgd29ya2luZyB3aXRoIGEgY29weVxuICAgICAgdmFyIHNlcGFyYXRvckNvcHkgPSBuZXcgUmVnRXhwKHNlcGFyYXRvci5zb3VyY2UsIGZsYWdzICsgJ2cnKTtcbiAgICAgIHZhciBzZXBhcmF0b3IyLCBtYXRjaCwgbGFzdEluZGV4LCBsYXN0TGVuZ3RoLCBpO1xuICAgICAgLy8gRG9lc24ndCBuZWVkIGZsYWdzIGd5LCBidXQgdGhleSBkb24ndCBodXJ0XG4gICAgICBpZiAoIU5QQ0cpIHNlcGFyYXRvcjIgPSBuZXcgUmVnRXhwKCdeJyArIHNlcGFyYXRvckNvcHkuc291cmNlICsgJyQoPyFcXFxccyknLCBmbGFncyk7XG4gICAgICB3aGlsZSAobWF0Y2ggPSBzZXBhcmF0b3JDb3B5LmV4ZWMoc3RyaW5nKSkge1xuICAgICAgICAvLyBgc2VwYXJhdG9yQ29weS5sYXN0SW5kZXhgIGlzIG5vdCByZWxpYWJsZSBjcm9zcy1icm93c2VyXG4gICAgICAgIGxhc3RJbmRleCA9IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF1bTEVOR1RIXTtcbiAgICAgICAgaWYgKGxhc3RJbmRleCA+IGxhc3RMYXN0SW5kZXgpIHtcbiAgICAgICAgICBvdXRwdXQucHVzaChzdHJpbmcuc2xpY2UobGFzdExhc3RJbmRleCwgbWF0Y2guaW5kZXgpKTtcbiAgICAgICAgICAvLyBGaXggYnJvd3NlcnMgd2hvc2UgYGV4ZWNgIG1ldGhvZHMgZG9uJ3QgY29uc2lzdGVudGx5IHJldHVybiBgdW5kZWZpbmVkYCBmb3IgTlBDR1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1sb29wLWZ1bmNcbiAgICAgICAgICBpZiAoIU5QQ0cgJiYgbWF0Y2hbTEVOR1RIXSA+IDEpIG1hdGNoWzBdLnJlcGxhY2Uoc2VwYXJhdG9yMiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZm9yIChpID0gMTsgaSA8IGFyZ3VtZW50c1tMRU5HVEhdIC0gMjsgaSsrKSBpZiAoYXJndW1lbnRzW2ldID09PSB1bmRlZmluZWQpIG1hdGNoW2ldID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChtYXRjaFtMRU5HVEhdID4gMSAmJiBtYXRjaC5pbmRleCA8IHN0cmluZ1tMRU5HVEhdKSAkcHVzaC5hcHBseShvdXRwdXQsIG1hdGNoLnNsaWNlKDEpKTtcbiAgICAgICAgICBsYXN0TGVuZ3RoID0gbWF0Y2hbMF1bTEVOR1RIXTtcbiAgICAgICAgICBsYXN0TGFzdEluZGV4ID0gbGFzdEluZGV4O1xuICAgICAgICAgIGlmIChvdXRwdXRbTEVOR1RIXSA+PSBzcGxpdExpbWl0KSBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VwYXJhdG9yQ29weVtMQVNUX0lOREVYXSA9PT0gbWF0Y2guaW5kZXgpIHNlcGFyYXRvckNvcHlbTEFTVF9JTkRFWF0rKzsgLy8gQXZvaWQgYW4gaW5maW5pdGUgbG9vcFxuICAgICAgfVxuICAgICAgaWYgKGxhc3RMYXN0SW5kZXggPT09IHN0cmluZ1tMRU5HVEhdKSB7XG4gICAgICAgIGlmIChsYXN0TGVuZ3RoIHx8ICFzZXBhcmF0b3JDb3B5LnRlc3QoJycpKSBvdXRwdXQucHVzaCgnJyk7XG4gICAgICB9IGVsc2Ugb3V0cHV0LnB1c2goc3RyaW5nLnNsaWNlKGxhc3RMYXN0SW5kZXgpKTtcbiAgICAgIHJldHVybiBvdXRwdXRbTEVOR1RIXSA+IHNwbGl0TGltaXQgPyBvdXRwdXQuc2xpY2UoMCwgc3BsaXRMaW1pdCkgOiBvdXRwdXQ7XG4gICAgfTtcbiAgLy8gQ2hha3JhLCBWOFxuICB9IGVsc2UgaWYgKCcwJ1skU1BMSVRdKHVuZGVmaW5lZCwgMClbTEVOR1RIXSkge1xuICAgICRzcGxpdCA9IGZ1bmN0aW9uIChzZXBhcmF0b3IsIGxpbWl0KSB7XG4gICAgICByZXR1cm4gc2VwYXJhdG9yID09PSB1bmRlZmluZWQgJiYgbGltaXQgPT09IDAgPyBbXSA6IF9zcGxpdC5jYWxsKHRoaXMsIHNlcGFyYXRvciwgbGltaXQpO1xuICAgIH07XG4gIH1cbiAgLy8gMjEuMS4zLjE3IFN0cmluZy5wcm90b3R5cGUuc3BsaXQoc2VwYXJhdG9yLCBsaW1pdClcbiAgcmV0dXJuIFtmdW5jdGlvbiBzcGxpdChzZXBhcmF0b3IsIGxpbWl0KSB7XG4gICAgdmFyIE8gPSBkZWZpbmVkKHRoaXMpO1xuICAgIHZhciBmbiA9IHNlcGFyYXRvciA9PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBzZXBhcmF0b3JbU1BMSVRdO1xuICAgIHJldHVybiBmbiAhPT0gdW5kZWZpbmVkID8gZm4uY2FsbChzZXBhcmF0b3IsIE8sIGxpbWl0KSA6ICRzcGxpdC5jYWxsKFN0cmluZyhPKSwgc2VwYXJhdG9yLCBsaW1pdCk7XG4gIH0sICRzcGxpdF07XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnJlcXVpcmUoJy4vZXM2LnJlZ2V4cC5mbGFncycpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgJGZsYWdzID0gcmVxdWlyZSgnLi9fZmxhZ3MnKTtcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJyk7XG52YXIgVE9fU1RSSU5HID0gJ3RvU3RyaW5nJztcbnZhciAkdG9TdHJpbmcgPSAvLi9bVE9fU1RSSU5HXTtcblxudmFyIGRlZmluZSA9IGZ1bmN0aW9uIChmbikge1xuICByZXF1aXJlKCcuL19yZWRlZmluZScpKFJlZ0V4cC5wcm90b3R5cGUsIFRPX1NUUklORywgZm4sIHRydWUpO1xufTtcblxuLy8gMjEuMi41LjE0IFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcoKVxuaWYgKHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkgeyByZXR1cm4gJHRvU3RyaW5nLmNhbGwoeyBzb3VyY2U6ICdhJywgZmxhZ3M6ICdiJyB9KSAhPSAnL2EvYic7IH0pKSB7XG4gIGRlZmluZShmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICB2YXIgUiA9IGFuT2JqZWN0KHRoaXMpO1xuICAgIHJldHVybiAnLycuY29uY2F0KFIuc291cmNlLCAnLycsXG4gICAgICAnZmxhZ3MnIGluIFIgPyBSLmZsYWdzIDogIURFU0NSSVBUT1JTICYmIFIgaW5zdGFuY2VvZiBSZWdFeHAgPyAkZmxhZ3MuY2FsbChSKSA6IHVuZGVmaW5lZCk7XG4gIH0pO1xuLy8gRkY0NC0gUmVnRXhwI3RvU3RyaW5nIGhhcyBhIHdyb25nIG5hbWVcbn0gZWxzZSBpZiAoJHRvU3RyaW5nLm5hbWUgIT0gVE9fU1RSSU5HKSB7XG4gIGRlZmluZShmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gJHRvU3RyaW5nLmNhbGwodGhpcyk7XG4gIH0pO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHN0cm9uZyA9IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24tc3Ryb25nJyk7XG52YXIgdmFsaWRhdGUgPSByZXF1aXJlKCcuL192YWxpZGF0ZS1jb2xsZWN0aW9uJyk7XG52YXIgU0VUID0gJ1NldCc7XG5cbi8vIDIzLjIgU2V0IE9iamVjdHNcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbicpKFNFVCwgZnVuY3Rpb24gKGdldCkge1xuICByZXR1cm4gZnVuY3Rpb24gU2V0KCkgeyByZXR1cm4gZ2V0KHRoaXMsIGFyZ3VtZW50cy5sZW5ndGggPiAwID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTsgfTtcbn0sIHtcbiAgLy8gMjMuMi4zLjEgU2V0LnByb3RvdHlwZS5hZGQodmFsdWUpXG4gIGFkZDogZnVuY3Rpb24gYWRkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHN0cm9uZy5kZWYodmFsaWRhdGUodGhpcywgU0VUKSwgdmFsdWUgPSB2YWx1ZSA9PT0gMCA/IDAgOiB2YWx1ZSwgdmFsdWUpO1xuICB9XG59LCBzdHJvbmcpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuMiBTdHJpbmcucHJvdG90eXBlLmFuY2hvcihuYW1lKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnYW5jaG9yJywgZnVuY3Rpb24gKGNyZWF0ZUhUTUwpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGFuY2hvcihuYW1lKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ2EnLCAnbmFtZScsIG5hbWUpO1xuICB9O1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy4zIFN0cmluZy5wcm90b3R5cGUuYmlnKClcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ2JpZycsIGZ1bmN0aW9uIChjcmVhdGVIVE1MKSB7XG4gIHJldHVybiBmdW5jdGlvbiBiaWcoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ2JpZycsICcnLCAnJyk7XG4gIH07XG59KTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjQgU3RyaW5nLnByb3RvdHlwZS5ibGluaygpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdibGluaycsIGZ1bmN0aW9uIChjcmVhdGVIVE1MKSB7XG4gIHJldHVybiBmdW5jdGlvbiBibGluaygpIHtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnYmxpbmsnLCAnJywgJycpO1xuICB9O1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy41IFN0cmluZy5wcm90b3R5cGUuYm9sZCgpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdib2xkJywgZnVuY3Rpb24gKGNyZWF0ZUhUTUwpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGJvbGQoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ2InLCAnJywgJycpO1xuICB9O1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRhdCA9IHJlcXVpcmUoJy4vX3N0cmluZy1hdCcpKGZhbHNlKTtcbiRleHBvcnQoJGV4cG9ydC5QLCAnU3RyaW5nJywge1xuICAvLyAyMS4xLjMuMyBTdHJpbmcucHJvdG90eXBlLmNvZGVQb2ludEF0KHBvcylcbiAgY29kZVBvaW50QXQ6IGZ1bmN0aW9uIGNvZGVQb2ludEF0KHBvcykge1xuICAgIHJldHVybiAkYXQodGhpcywgcG9zKTtcbiAgfVxufSk7XG4iLCIvLyAyMS4xLjMuNiBTdHJpbmcucHJvdG90eXBlLmVuZHNXaXRoKHNlYXJjaFN0cmluZyBbLCBlbmRQb3NpdGlvbl0pXG4ndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgY29udGV4dCA9IHJlcXVpcmUoJy4vX3N0cmluZy1jb250ZXh0Jyk7XG52YXIgRU5EU19XSVRIID0gJ2VuZHNXaXRoJztcbnZhciAkZW5kc1dpdGggPSAnJ1tFTkRTX1dJVEhdO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzLWlzLXJlZ2V4cCcpKEVORFNfV0lUSCksICdTdHJpbmcnLCB7XG4gIGVuZHNXaXRoOiBmdW5jdGlvbiBlbmRzV2l0aChzZWFyY2hTdHJpbmcgLyogLCBlbmRQb3NpdGlvbiA9IEBsZW5ndGggKi8pIHtcbiAgICB2YXIgdGhhdCA9IGNvbnRleHQodGhpcywgc2VhcmNoU3RyaW5nLCBFTkRTX1dJVEgpO1xuICAgIHZhciBlbmRQb3NpdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICAgIHZhciBsZW4gPSB0b0xlbmd0aCh0aGF0Lmxlbmd0aCk7XG4gICAgdmFyIGVuZCA9IGVuZFBvc2l0aW9uID09PSB1bmRlZmluZWQgPyBsZW4gOiBNYXRoLm1pbih0b0xlbmd0aChlbmRQb3NpdGlvbiksIGxlbik7XG4gICAgdmFyIHNlYXJjaCA9IFN0cmluZyhzZWFyY2hTdHJpbmcpO1xuICAgIHJldHVybiAkZW5kc1dpdGhcbiAgICAgID8gJGVuZHNXaXRoLmNhbGwodGhhdCwgc2VhcmNoLCBlbmQpXG4gICAgICA6IHRoYXQuc2xpY2UoZW5kIC0gc2VhcmNoLmxlbmd0aCwgZW5kKSA9PT0gc2VhcmNoO1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjYgU3RyaW5nLnByb3RvdHlwZS5maXhlZCgpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdmaXhlZCcsIGZ1bmN0aW9uIChjcmVhdGVIVE1MKSB7XG4gIHJldHVybiBmdW5jdGlvbiBmaXhlZCgpIHtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAndHQnLCAnJywgJycpO1xuICB9O1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy43IFN0cmluZy5wcm90b3R5cGUuZm9udGNvbG9yKGNvbG9yKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnZm9udGNvbG9yJywgZnVuY3Rpb24gKGNyZWF0ZUhUTUwpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGZvbnRjb2xvcihjb2xvcikge1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdmb250JywgJ2NvbG9yJywgY29sb3IpO1xuICB9O1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy44IFN0cmluZy5wcm90b3R5cGUuZm9udHNpemUoc2l6ZSlcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ2ZvbnRzaXplJywgZnVuY3Rpb24gKGNyZWF0ZUhUTUwpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGZvbnRzaXplKHNpemUpIHtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnZm9udCcsICdzaXplJywgc2l6ZSk7XG4gIH07XG59KTtcbiIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gcmVxdWlyZSgnLi9fdG8tYWJzb2x1dGUtaW5kZXgnKTtcbnZhciBmcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xudmFyICRmcm9tQ29kZVBvaW50ID0gU3RyaW5nLmZyb21Db2RlUG9pbnQ7XG5cbi8vIGxlbmd0aCBzaG91bGQgYmUgMSwgb2xkIEZGIHByb2JsZW1cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKCEhJGZyb21Db2RlUG9pbnQgJiYgJGZyb21Db2RlUG9pbnQubGVuZ3RoICE9IDEpLCAnU3RyaW5nJywge1xuICAvLyAyMS4xLjIuMiBTdHJpbmcuZnJvbUNvZGVQb2ludCguLi5jb2RlUG9pbnRzKVxuICBmcm9tQ29kZVBvaW50OiBmdW5jdGlvbiBmcm9tQ29kZVBvaW50KHgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIHZhciByZXMgPSBbXTtcbiAgICB2YXIgYUxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBjb2RlO1xuICAgIHdoaWxlIChhTGVuID4gaSkge1xuICAgICAgY29kZSA9ICthcmd1bWVudHNbaSsrXTtcbiAgICAgIGlmICh0b0Fic29sdXRlSW5kZXgoY29kZSwgMHgxMGZmZmYpICE9PSBjb2RlKSB0aHJvdyBSYW5nZUVycm9yKGNvZGUgKyAnIGlzIG5vdCBhIHZhbGlkIGNvZGUgcG9pbnQnKTtcbiAgICAgIHJlcy5wdXNoKGNvZGUgPCAweDEwMDAwXG4gICAgICAgID8gZnJvbUNoYXJDb2RlKGNvZGUpXG4gICAgICAgIDogZnJvbUNoYXJDb2RlKCgoY29kZSAtPSAweDEwMDAwKSA+PiAxMCkgKyAweGQ4MDAsIGNvZGUgJSAweDQwMCArIDB4ZGMwMClcbiAgICAgICk7XG4gICAgfSByZXR1cm4gcmVzLmpvaW4oJycpO1xuICB9XG59KTtcbiIsIi8vIDIxLjEuMy43IFN0cmluZy5wcm90b3R5cGUuaW5jbHVkZXMoc2VhcmNoU3RyaW5nLCBwb3NpdGlvbiA9IDApXG4ndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGNvbnRleHQgPSByZXF1aXJlKCcuL19zdHJpbmctY29udGV4dCcpO1xudmFyIElOQ0xVREVTID0gJ2luY2x1ZGVzJztcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscy1pcy1yZWdleHAnKShJTkNMVURFUyksICdTdHJpbmcnLCB7XG4gIGluY2x1ZGVzOiBmdW5jdGlvbiBpbmNsdWRlcyhzZWFyY2hTdHJpbmcgLyogLCBwb3NpdGlvbiA9IDAgKi8pIHtcbiAgICByZXR1cm4gISF+Y29udGV4dCh0aGlzLCBzZWFyY2hTdHJpbmcsIElOQ0xVREVTKVxuICAgICAgLmluZGV4T2Yoc2VhcmNoU3RyaW5nLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuOSBTdHJpbmcucHJvdG90eXBlLml0YWxpY3MoKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnaXRhbGljcycsIGZ1bmN0aW9uIChjcmVhdGVIVE1MKSB7XG4gIHJldHVybiBmdW5jdGlvbiBpdGFsaWNzKCkge1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdpJywgJycsICcnKTtcbiAgfTtcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRhdCA9IHJlcXVpcmUoJy4vX3N0cmluZy1hdCcpKHRydWUpO1xuXG4vLyAyMS4xLjMuMjcgU3RyaW5nLnByb3RvdHlwZVtAQGl0ZXJhdG9yXSgpXG5yZXF1aXJlKCcuL19pdGVyLWRlZmluZScpKFN0cmluZywgJ1N0cmluZycsIGZ1bmN0aW9uIChpdGVyYXRlZCkge1xuICB0aGlzLl90ID0gU3RyaW5nKGl0ZXJhdGVkKTsgLy8gdGFyZ2V0XG4gIHRoaXMuX2kgPSAwOyAgICAgICAgICAgICAgICAvLyBuZXh0IGluZGV4XG4vLyAyMS4xLjUuMi4xICVTdHJpbmdJdGVyYXRvclByb3RvdHlwZSUubmV4dCgpXG59LCBmdW5jdGlvbiAoKSB7XG4gIHZhciBPID0gdGhpcy5fdDtcbiAgdmFyIGluZGV4ID0gdGhpcy5faTtcbiAgdmFyIHBvaW50O1xuICBpZiAoaW5kZXggPj0gTy5sZW5ndGgpIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgcG9pbnQgPSAkYXQoTywgaW5kZXgpO1xuICB0aGlzLl9pICs9IHBvaW50Lmxlbmd0aDtcbiAgcmV0dXJuIHsgdmFsdWU6IHBvaW50LCBkb25lOiBmYWxzZSB9O1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy4xMCBTdHJpbmcucHJvdG90eXBlLmxpbmsodXJsKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnbGluaycsIGZ1bmN0aW9uIChjcmVhdGVIVE1MKSB7XG4gIHJldHVybiBmdW5jdGlvbiBsaW5rKHVybCkge1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdhJywgJ2hyZWYnLCB1cmwpO1xuICB9O1xufSk7XG4iLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1N0cmluZycsIHtcbiAgLy8gMjEuMS4yLjQgU3RyaW5nLnJhdyhjYWxsU2l0ZSwgLi4uc3Vic3RpdHV0aW9ucylcbiAgcmF3OiBmdW5jdGlvbiByYXcoY2FsbFNpdGUpIHtcbiAgICB2YXIgdHBsID0gdG9JT2JqZWN0KGNhbGxTaXRlLnJhdyk7XG4gICAgdmFyIGxlbiA9IHRvTGVuZ3RoKHRwbC5sZW5ndGgpO1xuICAgIHZhciBhTGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgcmVzID0gW107XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChsZW4gPiBpKSB7XG4gICAgICByZXMucHVzaChTdHJpbmcodHBsW2krK10pKTtcbiAgICAgIGlmIChpIDwgYUxlbikgcmVzLnB1c2goU3RyaW5nKGFyZ3VtZW50c1tpXSkpO1xuICAgIH0gcmV0dXJuIHJlcy5qb2luKCcnKTtcbiAgfVxufSk7XG4iLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCwgJ1N0cmluZycsIHtcbiAgLy8gMjEuMS4zLjEzIFN0cmluZy5wcm90b3R5cGUucmVwZWF0KGNvdW50KVxuICByZXBlYXQ6IHJlcXVpcmUoJy4vX3N0cmluZy1yZXBlYXQnKVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy4xMSBTdHJpbmcucHJvdG90eXBlLnNtYWxsKClcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ3NtYWxsJywgZnVuY3Rpb24gKGNyZWF0ZUhUTUwpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHNtYWxsKCkge1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdzbWFsbCcsICcnLCAnJyk7XG4gIH07XG59KTtcbiIsIi8vIDIxLjEuMy4xOCBTdHJpbmcucHJvdG90eXBlLnN0YXJ0c1dpdGgoc2VhcmNoU3RyaW5nIFssIHBvc2l0aW9uIF0pXG4ndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgY29udGV4dCA9IHJlcXVpcmUoJy4vX3N0cmluZy1jb250ZXh0Jyk7XG52YXIgU1RBUlRTX1dJVEggPSAnc3RhcnRzV2l0aCc7XG52YXIgJHN0YXJ0c1dpdGggPSAnJ1tTVEFSVFNfV0lUSF07XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogcmVxdWlyZSgnLi9fZmFpbHMtaXMtcmVnZXhwJykoU1RBUlRTX1dJVEgpLCAnU3RyaW5nJywge1xuICBzdGFydHNXaXRoOiBmdW5jdGlvbiBzdGFydHNXaXRoKHNlYXJjaFN0cmluZyAvKiAsIHBvc2l0aW9uID0gMCAqLykge1xuICAgIHZhciB0aGF0ID0gY29udGV4dCh0aGlzLCBzZWFyY2hTdHJpbmcsIFNUQVJUU19XSVRIKTtcbiAgICB2YXIgaW5kZXggPSB0b0xlbmd0aChNYXRoLm1pbihhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCwgdGhhdC5sZW5ndGgpKTtcbiAgICB2YXIgc2VhcmNoID0gU3RyaW5nKHNlYXJjaFN0cmluZyk7XG4gICAgcmV0dXJuICRzdGFydHNXaXRoXG4gICAgICA/ICRzdGFydHNXaXRoLmNhbGwodGhhdCwgc2VhcmNoLCBpbmRleClcbiAgICAgIDogdGhhdC5zbGljZShpbmRleCwgaW5kZXggKyBzZWFyY2gubGVuZ3RoKSA9PT0gc2VhcmNoO1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjEyIFN0cmluZy5wcm90b3R5cGUuc3RyaWtlKClcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ3N0cmlrZScsIGZ1bmN0aW9uIChjcmVhdGVIVE1MKSB7XG4gIHJldHVybiBmdW5jdGlvbiBzdHJpa2UoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ3N0cmlrZScsICcnLCAnJyk7XG4gIH07XG59KTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjEzIFN0cmluZy5wcm90b3R5cGUuc3ViKClcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ3N1YicsIGZ1bmN0aW9uIChjcmVhdGVIVE1MKSB7XG4gIHJldHVybiBmdW5jdGlvbiBzdWIoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ3N1YicsICcnLCAnJyk7XG4gIH07XG59KTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjE0IFN0cmluZy5wcm90b3R5cGUuc3VwKClcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ3N1cCcsIGZ1bmN0aW9uIChjcmVhdGVIVE1MKSB7XG4gIHJldHVybiBmdW5jdGlvbiBzdXAoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ3N1cCcsICcnLCAnJyk7XG4gIH07XG59KTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIDIxLjEuMy4yNSBTdHJpbmcucHJvdG90eXBlLnRyaW0oKVxucmVxdWlyZSgnLi9fc3RyaW5nLXRyaW0nKSgndHJpbScsIGZ1bmN0aW9uICgkdHJpbSkge1xuICByZXR1cm4gZnVuY3Rpb24gdHJpbSgpIHtcbiAgICByZXR1cm4gJHRyaW0odGhpcywgMyk7XG4gIH07XG59KTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIEVDTUFTY3JpcHQgNiBzeW1ib2xzIHNoaW1cbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcbnZhciBNRVRBID0gcmVxdWlyZSgnLi9fbWV0YScpLktFWTtcbnZhciAkZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xudmFyIHNoYXJlZCA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpO1xudmFyIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKTtcbnZhciB1aWQgPSByZXF1aXJlKCcuL191aWQnKTtcbnZhciB3a3MgPSByZXF1aXJlKCcuL193a3MnKTtcbnZhciB3a3NFeHQgPSByZXF1aXJlKCcuL193a3MtZXh0Jyk7XG52YXIgd2tzRGVmaW5lID0gcmVxdWlyZSgnLi9fd2tzLWRlZmluZScpO1xudmFyIGVudW1LZXlzID0gcmVxdWlyZSgnLi9fZW51bS1rZXlzJyk7XG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJy4vX2lzLWFycmF5Jyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcbnZhciBjcmVhdGVEZXNjID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xudmFyIF9jcmVhdGUgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJyk7XG52YXIgZ09QTkV4dCA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuLWV4dCcpO1xudmFyICRHT1BEID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKTtcbnZhciAkRFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcbnZhciAka2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG52YXIgZ09QRCA9ICRHT1BELmY7XG52YXIgZFAgPSAkRFAuZjtcbnZhciBnT1BOID0gZ09QTkV4dC5mO1xudmFyICRTeW1ib2wgPSBnbG9iYWwuU3ltYm9sO1xudmFyICRKU09OID0gZ2xvYmFsLkpTT047XG52YXIgX3N0cmluZ2lmeSA9ICRKU09OICYmICRKU09OLnN0cmluZ2lmeTtcbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcbnZhciBISURERU4gPSB3a3MoJ19oaWRkZW4nKTtcbnZhciBUT19QUklNSVRJVkUgPSB3a3MoJ3RvUHJpbWl0aXZlJyk7XG52YXIgaXNFbnVtID0ge30ucHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgU3ltYm9sUmVnaXN0cnkgPSBzaGFyZWQoJ3N5bWJvbC1yZWdpc3RyeScpO1xudmFyIEFsbFN5bWJvbHMgPSBzaGFyZWQoJ3N5bWJvbHMnKTtcbnZhciBPUFN5bWJvbHMgPSBzaGFyZWQoJ29wLXN5bWJvbHMnKTtcbnZhciBPYmplY3RQcm90byA9IE9iamVjdFtQUk9UT1RZUEVdO1xudmFyIFVTRV9OQVRJVkUgPSB0eXBlb2YgJFN5bWJvbCA9PSAnZnVuY3Rpb24nO1xudmFyIFFPYmplY3QgPSBnbG9iYWwuUU9iamVjdDtcbi8vIERvbid0IHVzZSBzZXR0ZXJzIGluIFF0IFNjcmlwdCwgaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzE3M1xudmFyIHNldHRlciA9ICFRT2JqZWN0IHx8ICFRT2JqZWN0W1BST1RPVFlQRV0gfHwgIVFPYmplY3RbUFJPVE9UWVBFXS5maW5kQ2hpbGQ7XG5cbi8vIGZhbGxiYWNrIGZvciBvbGQgQW5kcm9pZCwgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTY4N1xudmFyIHNldFN5bWJvbERlc2MgPSBERVNDUklQVE9SUyAmJiAkZmFpbHMoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gX2NyZWF0ZShkUCh7fSwgJ2EnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkUCh0aGlzLCAnYScsIHsgdmFsdWU6IDcgfSkuYTsgfVxuICB9KSkuYSAhPSA3O1xufSkgPyBmdW5jdGlvbiAoaXQsIGtleSwgRCkge1xuICB2YXIgcHJvdG9EZXNjID0gZ09QRChPYmplY3RQcm90bywga2V5KTtcbiAgaWYgKHByb3RvRGVzYykgZGVsZXRlIE9iamVjdFByb3RvW2tleV07XG4gIGRQKGl0LCBrZXksIEQpO1xuICBpZiAocHJvdG9EZXNjICYmIGl0ICE9PSBPYmplY3RQcm90bykgZFAoT2JqZWN0UHJvdG8sIGtleSwgcHJvdG9EZXNjKTtcbn0gOiBkUDtcblxudmFyIHdyYXAgPSBmdW5jdGlvbiAodGFnKSB7XG4gIHZhciBzeW0gPSBBbGxTeW1ib2xzW3RhZ10gPSBfY3JlYXRlKCRTeW1ib2xbUFJPVE9UWVBFXSk7XG4gIHN5bS5fayA9IHRhZztcbiAgcmV0dXJuIHN5bTtcbn07XG5cbnZhciBpc1N5bWJvbCA9IFVTRV9OQVRJVkUgJiYgdHlwZW9mICRTeW1ib2wuaXRlcmF0b3IgPT0gJ3N5bWJvbCcgPyBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJztcbn0gOiBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGl0IGluc3RhbmNlb2YgJFN5bWJvbDtcbn07XG5cbnZhciAkZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShpdCwga2V5LCBEKSB7XG4gIGlmIChpdCA9PT0gT2JqZWN0UHJvdG8pICRkZWZpbmVQcm9wZXJ0eShPUFN5bWJvbHMsIGtleSwgRCk7XG4gIGFuT2JqZWN0KGl0KTtcbiAga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKTtcbiAgYW5PYmplY3QoRCk7XG4gIGlmIChoYXMoQWxsU3ltYm9scywga2V5KSkge1xuICAgIGlmICghRC5lbnVtZXJhYmxlKSB7XG4gICAgICBpZiAoIWhhcyhpdCwgSElEREVOKSkgZFAoaXQsIEhJRERFTiwgY3JlYXRlRGVzYygxLCB7fSkpO1xuICAgICAgaXRbSElEREVOXVtrZXldID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGhhcyhpdCwgSElEREVOKSAmJiBpdFtISURERU5dW2tleV0pIGl0W0hJRERFTl1ba2V5XSA9IGZhbHNlO1xuICAgICAgRCA9IF9jcmVhdGUoRCwgeyBlbnVtZXJhYmxlOiBjcmVhdGVEZXNjKDAsIGZhbHNlKSB9KTtcbiAgICB9IHJldHVybiBzZXRTeW1ib2xEZXNjKGl0LCBrZXksIEQpO1xuICB9IHJldHVybiBkUChpdCwga2V5LCBEKTtcbn07XG52YXIgJGRlZmluZVByb3BlcnRpZXMgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKGl0LCBQKSB7XG4gIGFuT2JqZWN0KGl0KTtcbiAgdmFyIGtleXMgPSBlbnVtS2V5cyhQID0gdG9JT2JqZWN0KFApKTtcbiAgdmFyIGkgPSAwO1xuICB2YXIgbCA9IGtleXMubGVuZ3RoO1xuICB2YXIga2V5O1xuICB3aGlsZSAobCA+IGkpICRkZWZpbmVQcm9wZXJ0eShpdCwga2V5ID0ga2V5c1tpKytdLCBQW2tleV0pO1xuICByZXR1cm4gaXQ7XG59O1xudmFyICRjcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoaXQsIFApIHtcbiAgcmV0dXJuIFAgPT09IHVuZGVmaW5lZCA/IF9jcmVhdGUoaXQpIDogJGRlZmluZVByb3BlcnRpZXMoX2NyZWF0ZShpdCksIFApO1xufTtcbnZhciAkcHJvcGVydHlJc0VudW1lcmFibGUgPSBmdW5jdGlvbiBwcm9wZXJ0eUlzRW51bWVyYWJsZShrZXkpIHtcbiAgdmFyIEUgPSBpc0VudW0uY2FsbCh0aGlzLCBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpKTtcbiAgaWYgKHRoaXMgPT09IE9iamVjdFByb3RvICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICFoYXMoT1BTeW1ib2xzLCBrZXkpKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBFIHx8ICFoYXModGhpcywga2V5KSB8fCAhaGFzKEFsbFN5bWJvbHMsIGtleSkgfHwgaGFzKHRoaXMsIEhJRERFTikgJiYgdGhpc1tISURERU5dW2tleV0gPyBFIDogdHJ1ZTtcbn07XG52YXIgJGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihpdCwga2V5KSB7XG4gIGl0ID0gdG9JT2JqZWN0KGl0KTtcbiAga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKTtcbiAgaWYgKGl0ID09PSBPYmplY3RQcm90byAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhaGFzKE9QU3ltYm9scywga2V5KSkgcmV0dXJuO1xuICB2YXIgRCA9IGdPUEQoaXQsIGtleSk7XG4gIGlmIChEICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICEoaGFzKGl0LCBISURERU4pICYmIGl0W0hJRERFTl1ba2V5XSkpIEQuZW51bWVyYWJsZSA9IHRydWU7XG4gIHJldHVybiBEO1xufTtcbnZhciAkZ2V0T3duUHJvcGVydHlOYW1lcyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoaXQpIHtcbiAgdmFyIG5hbWVzID0gZ09QTih0b0lPYmplY3QoaXQpKTtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIgaSA9IDA7XG4gIHZhciBrZXk7XG4gIHdoaWxlIChuYW1lcy5sZW5ndGggPiBpKSB7XG4gICAgaWYgKCFoYXMoQWxsU3ltYm9scywga2V5ID0gbmFtZXNbaSsrXSkgJiYga2V5ICE9IEhJRERFTiAmJiBrZXkgIT0gTUVUQSkgcmVzdWx0LnB1c2goa2V5KTtcbiAgfSByZXR1cm4gcmVzdWx0O1xufTtcbnZhciAkZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlTeW1ib2xzKGl0KSB7XG4gIHZhciBJU19PUCA9IGl0ID09PSBPYmplY3RQcm90bztcbiAgdmFyIG5hbWVzID0gZ09QTihJU19PUCA/IE9QU3ltYm9scyA6IHRvSU9iamVjdChpdCkpO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBpID0gMDtcbiAgdmFyIGtleTtcbiAgd2hpbGUgKG5hbWVzLmxlbmd0aCA+IGkpIHtcbiAgICBpZiAoaGFzKEFsbFN5bWJvbHMsIGtleSA9IG5hbWVzW2krK10pICYmIChJU19PUCA/IGhhcyhPYmplY3RQcm90bywga2V5KSA6IHRydWUpKSByZXN1bHQucHVzaChBbGxTeW1ib2xzW2tleV0pO1xuICB9IHJldHVybiByZXN1bHQ7XG59O1xuXG4vLyAxOS40LjEuMSBTeW1ib2woW2Rlc2NyaXB0aW9uXSlcbmlmICghVVNFX05BVElWRSkge1xuICAkU3ltYm9sID0gZnVuY3Rpb24gU3ltYm9sKCkge1xuICAgIGlmICh0aGlzIGluc3RhbmNlb2YgJFN5bWJvbCkgdGhyb3cgVHlwZUVycm9yKCdTeW1ib2wgaXMgbm90IGEgY29uc3RydWN0b3IhJyk7XG4gICAgdmFyIHRhZyA9IHVpZChhcmd1bWVudHMubGVuZ3RoID4gMCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7XG4gICAgdmFyICRzZXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGlmICh0aGlzID09PSBPYmplY3RQcm90bykgJHNldC5jYWxsKE9QU3ltYm9scywgdmFsdWUpO1xuICAgICAgaWYgKGhhcyh0aGlzLCBISURERU4pICYmIGhhcyh0aGlzW0hJRERFTl0sIHRhZykpIHRoaXNbSElEREVOXVt0YWddID0gZmFsc2U7XG4gICAgICBzZXRTeW1ib2xEZXNjKHRoaXMsIHRhZywgY3JlYXRlRGVzYygxLCB2YWx1ZSkpO1xuICAgIH07XG4gICAgaWYgKERFU0NSSVBUT1JTICYmIHNldHRlcikgc2V0U3ltYm9sRGVzYyhPYmplY3RQcm90bywgdGFnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgc2V0OiAkc2V0IH0pO1xuICAgIHJldHVybiB3cmFwKHRhZyk7XG4gIH07XG4gIHJlZGVmaW5lKCRTeW1ib2xbUFJPVE9UWVBFXSwgJ3RvU3RyaW5nJywgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2s7XG4gIH0pO1xuXG4gICRHT1BELmYgPSAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuICAkRFAuZiA9ICRkZWZpbmVQcm9wZXJ0eTtcbiAgcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mID0gZ09QTkV4dC5mID0gJGdldE93blByb3BlcnR5TmFtZXM7XG4gIHJlcXVpcmUoJy4vX29iamVjdC1waWUnKS5mID0gJHByb3BlcnR5SXNFbnVtZXJhYmxlO1xuICByZXF1aXJlKCcuL19vYmplY3QtZ29wcycpLmYgPSAkZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG4gIGlmIChERVNDUklQVE9SUyAmJiAhcmVxdWlyZSgnLi9fbGlicmFyeScpKSB7XG4gICAgcmVkZWZpbmUoT2JqZWN0UHJvdG8sICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsICRwcm9wZXJ0eUlzRW51bWVyYWJsZSwgdHJ1ZSk7XG4gIH1cblxuICB3a3NFeHQuZiA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuIHdyYXAod2tzKG5hbWUpKTtcbiAgfTtcbn1cblxuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgeyBTeW1ib2w6ICRTeW1ib2wgfSk7XG5cbmZvciAodmFyIGVzNlN5bWJvbHMgPSAoXG4gIC8vIDE5LjQuMi4yLCAxOS40LjIuMywgMTkuNC4yLjQsIDE5LjQuMi42LCAxOS40LjIuOCwgMTkuNC4yLjksIDE5LjQuMi4xMCwgMTkuNC4yLjExLCAxOS40LjIuMTIsIDE5LjQuMi4xMywgMTkuNC4yLjE0XG4gICdoYXNJbnN0YW5jZSxpc0NvbmNhdFNwcmVhZGFibGUsaXRlcmF0b3IsbWF0Y2gscmVwbGFjZSxzZWFyY2gsc3BlY2llcyxzcGxpdCx0b1ByaW1pdGl2ZSx0b1N0cmluZ1RhZyx1bnNjb3BhYmxlcydcbikuc3BsaXQoJywnKSwgaiA9IDA7IGVzNlN5bWJvbHMubGVuZ3RoID4gajspd2tzKGVzNlN5bWJvbHNbaisrXSk7XG5cbmZvciAodmFyIHdlbGxLbm93blN5bWJvbHMgPSAka2V5cyh3a3Muc3RvcmUpLCBrID0gMDsgd2VsbEtub3duU3ltYm9scy5sZW5ndGggPiBrOykgd2tzRGVmaW5lKHdlbGxLbm93blN5bWJvbHNbaysrXSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsICdTeW1ib2wnLCB7XG4gIC8vIDE5LjQuMi4xIFN5bWJvbC5mb3Ioa2V5KVxuICAnZm9yJzogZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBoYXMoU3ltYm9sUmVnaXN0cnksIGtleSArPSAnJylcbiAgICAgID8gU3ltYm9sUmVnaXN0cnlba2V5XVxuICAgICAgOiBTeW1ib2xSZWdpc3RyeVtrZXldID0gJFN5bWJvbChrZXkpO1xuICB9LFxuICAvLyAxOS40LjIuNSBTeW1ib2wua2V5Rm9yKHN5bSlcbiAga2V5Rm9yOiBmdW5jdGlvbiBrZXlGb3Ioc3ltKSB7XG4gICAgaWYgKCFpc1N5bWJvbChzeW0pKSB0aHJvdyBUeXBlRXJyb3Ioc3ltICsgJyBpcyBub3QgYSBzeW1ib2whJyk7XG4gICAgZm9yICh2YXIga2V5IGluIFN5bWJvbFJlZ2lzdHJ5KSBpZiAoU3ltYm9sUmVnaXN0cnlba2V5XSA9PT0gc3ltKSByZXR1cm4ga2V5O1xuICB9LFxuICB1c2VTZXR0ZXI6IGZ1bmN0aW9uICgpIHsgc2V0dGVyID0gdHJ1ZTsgfSxcbiAgdXNlU2ltcGxlOiBmdW5jdGlvbiAoKSB7IHNldHRlciA9IGZhbHNlOyB9XG59KTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgJ09iamVjdCcsIHtcbiAgLy8gMTkuMS4yLjIgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxuICBjcmVhdGU6ICRjcmVhdGUsXG4gIC8vIDE5LjEuMi40IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKVxuICBkZWZpbmVQcm9wZXJ0eTogJGRlZmluZVByb3BlcnR5LFxuICAvLyAxOS4xLjIuMyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKVxuICBkZWZpbmVQcm9wZXJ0aWVzOiAkZGVmaW5lUHJvcGVydGllcyxcbiAgLy8gMTkuMS4yLjYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKVxuICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IsXG4gIC8vIDE5LjEuMi43IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE8pXG4gIGdldE93blByb3BlcnR5TmFtZXM6ICRnZXRPd25Qcm9wZXJ0eU5hbWVzLFxuICAvLyAxOS4xLjIuOCBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKE8pXG4gIGdldE93blByb3BlcnR5U3ltYm9sczogJGdldE93blByb3BlcnR5U3ltYm9sc1xufSk7XG5cbi8vIDI0LjMuMiBKU09OLnN0cmluZ2lmeSh2YWx1ZSBbLCByZXBsYWNlciBbLCBzcGFjZV1dKVxuJEpTT04gJiYgJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoIVVTRV9OQVRJVkUgfHwgJGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgdmFyIFMgPSAkU3ltYm9sKCk7XG4gIC8vIE1TIEVkZ2UgY29udmVydHMgc3ltYm9sIHZhbHVlcyB0byBKU09OIGFzIHt9XG4gIC8vIFdlYktpdCBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMgbnVsbFxuICAvLyBWOCB0aHJvd3Mgb24gYm94ZWQgc3ltYm9sc1xuICByZXR1cm4gX3N0cmluZ2lmeShbU10pICE9ICdbbnVsbF0nIHx8IF9zdHJpbmdpZnkoeyBhOiBTIH0pICE9ICd7fScgfHwgX3N0cmluZ2lmeShPYmplY3QoUykpICE9ICd7fSc7XG59KSksICdKU09OJywge1xuICBzdHJpbmdpZnk6IGZ1bmN0aW9uIHN0cmluZ2lmeShpdCkge1xuICAgIGlmIChpdCA9PT0gdW5kZWZpbmVkIHx8IGlzU3ltYm9sKGl0KSkgcmV0dXJuOyAvLyBJRTggcmV0dXJucyBzdHJpbmcgb24gdW5kZWZpbmVkXG4gICAgdmFyIGFyZ3MgPSBbaXRdO1xuICAgIHZhciBpID0gMTtcbiAgICB2YXIgcmVwbGFjZXIsICRyZXBsYWNlcjtcbiAgICB3aGlsZSAoYXJndW1lbnRzLmxlbmd0aCA+IGkpIGFyZ3MucHVzaChhcmd1bWVudHNbaSsrXSk7XG4gICAgcmVwbGFjZXIgPSBhcmdzWzFdO1xuICAgIGlmICh0eXBlb2YgcmVwbGFjZXIgPT0gJ2Z1bmN0aW9uJykgJHJlcGxhY2VyID0gcmVwbGFjZXI7XG4gICAgaWYgKCRyZXBsYWNlciB8fCAhaXNBcnJheShyZXBsYWNlcikpIHJlcGxhY2VyID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgIGlmICgkcmVwbGFjZXIpIHZhbHVlID0gJHJlcGxhY2VyLmNhbGwodGhpcywga2V5LCB2YWx1ZSk7XG4gICAgICBpZiAoIWlzU3ltYm9sKHZhbHVlKSkgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgYXJnc1sxXSA9IHJlcGxhY2VyO1xuICAgIHJldHVybiBfc3RyaW5naWZ5LmFwcGx5KCRKU09OLCBhcmdzKTtcbiAgfVxufSk7XG5cbi8vIDE5LjQuMy40IFN5bWJvbC5wcm90b3R5cGVbQEB0b1ByaW1pdGl2ZV0oaGludClcbiRTeW1ib2xbUFJPVE9UWVBFXVtUT19QUklNSVRJVkVdIHx8IHJlcXVpcmUoJy4vX2hpZGUnKSgkU3ltYm9sW1BST1RPVFlQRV0sIFRPX1BSSU1JVElWRSwgJFN5bWJvbFtQUk9UT1RZUEVdLnZhbHVlT2YpO1xuLy8gMTkuNC4zLjUgU3ltYm9sLnByb3RvdHlwZVtAQHRvU3RyaW5nVGFnXVxuc2V0VG9TdHJpbmdUYWcoJFN5bWJvbCwgJ1N5bWJvbCcpO1xuLy8gMjAuMi4xLjkgTWF0aFtAQHRvU3RyaW5nVGFnXVxuc2V0VG9TdHJpbmdUYWcoTWF0aCwgJ01hdGgnLCB0cnVlKTtcbi8vIDI0LjMuMyBKU09OW0BAdG9TdHJpbmdUYWddXG5zZXRUb1N0cmluZ1RhZyhnbG9iYWwuSlNPTiwgJ0pTT04nLCB0cnVlKTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJHR5cGVkID0gcmVxdWlyZSgnLi9fdHlwZWQnKTtcbnZhciBidWZmZXIgPSByZXF1aXJlKCcuL190eXBlZC1idWZmZXInKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIHRvQWJzb2x1dGVJbmRleCA9IHJlcXVpcmUoJy4vX3RvLWFic29sdXRlLWluZGV4Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIEFycmF5QnVmZmVyID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuQXJyYXlCdWZmZXI7XG52YXIgc3BlY2llc0NvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi9fc3BlY2llcy1jb25zdHJ1Y3RvcicpO1xudmFyICRBcnJheUJ1ZmZlciA9IGJ1ZmZlci5BcnJheUJ1ZmZlcjtcbnZhciAkRGF0YVZpZXcgPSBidWZmZXIuRGF0YVZpZXc7XG52YXIgJGlzVmlldyA9ICR0eXBlZC5BQlYgJiYgQXJyYXlCdWZmZXIuaXNWaWV3O1xudmFyICRzbGljZSA9ICRBcnJheUJ1ZmZlci5wcm90b3R5cGUuc2xpY2U7XG52YXIgVklFVyA9ICR0eXBlZC5WSUVXO1xudmFyIEFSUkFZX0JVRkZFUiA9ICdBcnJheUJ1ZmZlcic7XG5cbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogKEFycmF5QnVmZmVyICE9PSAkQXJyYXlCdWZmZXIpLCB7IEFycmF5QnVmZmVyOiAkQXJyYXlCdWZmZXIgfSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogISR0eXBlZC5DT05TVFIsIEFSUkFZX0JVRkZFUiwge1xuICAvLyAyNC4xLjMuMSBBcnJheUJ1ZmZlci5pc1ZpZXcoYXJnKVxuICBpc1ZpZXc6IGZ1bmN0aW9uIGlzVmlldyhpdCkge1xuICAgIHJldHVybiAkaXNWaWV3ICYmICRpc1ZpZXcoaXQpIHx8IGlzT2JqZWN0KGl0KSAmJiBWSUVXIGluIGl0O1xuICB9XG59KTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LlUgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICFuZXcgJEFycmF5QnVmZmVyKDIpLnNsaWNlKDEsIHVuZGVmaW5lZCkuYnl0ZUxlbmd0aDtcbn0pLCBBUlJBWV9CVUZGRVIsIHtcbiAgLy8gMjQuMS40LjMgQXJyYXlCdWZmZXIucHJvdG90eXBlLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHNsaWNlOiBmdW5jdGlvbiBzbGljZShzdGFydCwgZW5kKSB7XG4gICAgaWYgKCRzbGljZSAhPT0gdW5kZWZpbmVkICYmIGVuZCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gJHNsaWNlLmNhbGwoYW5PYmplY3QodGhpcyksIHN0YXJ0KTsgLy8gRkYgZml4XG4gICAgdmFyIGxlbiA9IGFuT2JqZWN0KHRoaXMpLmJ5dGVMZW5ndGg7XG4gICAgdmFyIGZpcnN0ID0gdG9BYnNvbHV0ZUluZGV4KHN0YXJ0LCBsZW4pO1xuICAgIHZhciBmaW5hbCA9IHRvQWJzb2x1dGVJbmRleChlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IGVuZCwgbGVuKTtcbiAgICB2YXIgcmVzdWx0ID0gbmV3IChzcGVjaWVzQ29uc3RydWN0b3IodGhpcywgJEFycmF5QnVmZmVyKSkodG9MZW5ndGgoZmluYWwgLSBmaXJzdCkpO1xuICAgIHZhciB2aWV3UyA9IG5ldyAkRGF0YVZpZXcodGhpcyk7XG4gICAgdmFyIHZpZXdUID0gbmV3ICREYXRhVmlldyhyZXN1bHQpO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgd2hpbGUgKGZpcnN0IDwgZmluYWwpIHtcbiAgICAgIHZpZXdULnNldFVpbnQ4KGluZGV4KyssIHZpZXdTLmdldFVpbnQ4KGZpcnN0KyspKTtcbiAgICB9IHJldHVybiByZXN1bHQ7XG4gIH1cbn0pO1xuXG5yZXF1aXJlKCcuL19zZXQtc3BlY2llcycpKEFSUkFZX0JVRkZFUik7XG4iLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fdHlwZWQnKS5BQlYsIHtcbiAgRGF0YVZpZXc6IHJlcXVpcmUoJy4vX3R5cGVkLWJ1ZmZlcicpLkRhdGFWaWV3XG59KTtcbiIsInJlcXVpcmUoJy4vX3R5cGVkLWFycmF5JykoJ0Zsb2F0MzInLCA0LCBmdW5jdGlvbiAoaW5pdCkge1xuICByZXR1cm4gZnVuY3Rpb24gRmxvYXQzMkFycmF5KGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59KTtcbiIsInJlcXVpcmUoJy4vX3R5cGVkLWFycmF5JykoJ0Zsb2F0NjQnLCA4LCBmdW5jdGlvbiAoaW5pdCkge1xuICByZXR1cm4gZnVuY3Rpb24gRmxvYXQ2NEFycmF5KGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59KTtcbiIsInJlcXVpcmUoJy4vX3R5cGVkLWFycmF5JykoJ0ludDE2JywgMiwgZnVuY3Rpb24gKGluaXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIEludDE2QXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcbn0pO1xuIiwicmVxdWlyZSgnLi9fdHlwZWQtYXJyYXknKSgnSW50MzInLCA0LCBmdW5jdGlvbiAoaW5pdCkge1xuICByZXR1cm4gZnVuY3Rpb24gSW50MzJBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7XG4iLCJyZXF1aXJlKCcuL190eXBlZC1hcnJheScpKCdJbnQ4JywgMSwgZnVuY3Rpb24gKGluaXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIEludDhBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7XG4iLCJyZXF1aXJlKCcuL190eXBlZC1hcnJheScpKCdVaW50MTYnLCAyLCBmdW5jdGlvbiAoaW5pdCkge1xuICByZXR1cm4gZnVuY3Rpb24gVWludDE2QXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcbn0pO1xuIiwicmVxdWlyZSgnLi9fdHlwZWQtYXJyYXknKSgnVWludDMyJywgNCwgZnVuY3Rpb24gKGluaXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIFVpbnQzMkFycmF5KGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59KTtcbiIsInJlcXVpcmUoJy4vX3R5cGVkLWFycmF5JykoJ1VpbnQ4JywgMSwgZnVuY3Rpb24gKGluaXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIFVpbnQ4QXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcbn0pO1xuIiwicmVxdWlyZSgnLi9fdHlwZWQtYXJyYXknKSgnVWludDgnLCAxLCBmdW5jdGlvbiAoaW5pdCkge1xuICByZXR1cm4gZnVuY3Rpb24gVWludDhDbGFtcGVkQXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcbn0sIHRydWUpO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGVhY2ggPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJykoMCk7XG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuL19yZWRlZmluZScpO1xudmFyIG1ldGEgPSByZXF1aXJlKCcuL19tZXRhJyk7XG52YXIgYXNzaWduID0gcmVxdWlyZSgnLi9fb2JqZWN0LWFzc2lnbicpO1xudmFyIHdlYWsgPSByZXF1aXJlKCcuL19jb2xsZWN0aW9uLXdlYWsnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbnZhciB2YWxpZGF0ZSA9IHJlcXVpcmUoJy4vX3ZhbGlkYXRlLWNvbGxlY3Rpb24nKTtcbnZhciBXRUFLX01BUCA9ICdXZWFrTWFwJztcbnZhciBnZXRXZWFrID0gbWV0YS5nZXRXZWFrO1xudmFyIGlzRXh0ZW5zaWJsZSA9IE9iamVjdC5pc0V4dGVuc2libGU7XG52YXIgdW5jYXVnaHRGcm96ZW5TdG9yZSA9IHdlYWsudWZzdG9yZTtcbnZhciB0bXAgPSB7fTtcbnZhciBJbnRlcm5hbE1hcDtcblxudmFyIHdyYXBwZXIgPSBmdW5jdGlvbiAoZ2V0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBXZWFrTWFwKCkge1xuICAgIHJldHVybiBnZXQodGhpcywgYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpO1xuICB9O1xufTtcblxudmFyIG1ldGhvZHMgPSB7XG4gIC8vIDIzLjMuMy4zIFdlYWtNYXAucHJvdG90eXBlLmdldChrZXkpXG4gIGdldDogZnVuY3Rpb24gZ2V0KGtleSkge1xuICAgIGlmIChpc09iamVjdChrZXkpKSB7XG4gICAgICB2YXIgZGF0YSA9IGdldFdlYWsoa2V5KTtcbiAgICAgIGlmIChkYXRhID09PSB0cnVlKSByZXR1cm4gdW5jYXVnaHRGcm96ZW5TdG9yZSh2YWxpZGF0ZSh0aGlzLCBXRUFLX01BUCkpLmdldChrZXkpO1xuICAgICAgcmV0dXJuIGRhdGEgPyBkYXRhW3RoaXMuX2ldIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgfSxcbiAgLy8gMjMuMy4zLjUgV2Vha01hcC5wcm90b3R5cGUuc2V0KGtleSwgdmFsdWUpXG4gIHNldDogZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpIHtcbiAgICByZXR1cm4gd2Vhay5kZWYodmFsaWRhdGUodGhpcywgV0VBS19NQVApLCBrZXksIHZhbHVlKTtcbiAgfVxufTtcblxuLy8gMjMuMyBXZWFrTWFwIE9iamVjdHNcbnZhciAkV2Vha01hcCA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbicpKFdFQUtfTUFQLCB3cmFwcGVyLCBtZXRob2RzLCB3ZWFrLCB0cnVlLCB0cnVlKTtcblxuLy8gSUUxMSBXZWFrTWFwIGZyb3plbiBrZXlzIGZpeFxuaWYgKGZhaWxzKGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyAkV2Vha01hcCgpLnNldCgoT2JqZWN0LmZyZWV6ZSB8fCBPYmplY3QpKHRtcCksIDcpLmdldCh0bXApICE9IDc7IH0pKSB7XG4gIEludGVybmFsTWFwID0gd2Vhay5nZXRDb25zdHJ1Y3Rvcih3cmFwcGVyLCBXRUFLX01BUCk7XG4gIGFzc2lnbihJbnRlcm5hbE1hcC5wcm90b3R5cGUsIG1ldGhvZHMpO1xuICBtZXRhLk5FRUQgPSB0cnVlO1xuICBlYWNoKFsnZGVsZXRlJywgJ2hhcycsICdnZXQnLCAnc2V0J10sIGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgcHJvdG8gPSAkV2Vha01hcC5wcm90b3R5cGU7XG4gICAgdmFyIG1ldGhvZCA9IHByb3RvW2tleV07XG4gICAgcmVkZWZpbmUocHJvdG8sIGtleSwgZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIC8vIHN0b3JlIGZyb3plbiBvYmplY3RzIG9uIGludGVybmFsIHdlYWttYXAgc2hpbVxuICAgICAgaWYgKGlzT2JqZWN0KGEpICYmICFpc0V4dGVuc2libGUoYSkpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9mKSB0aGlzLl9mID0gbmV3IEludGVybmFsTWFwKCk7XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLl9mW2tleV0oYSwgYik7XG4gICAgICAgIHJldHVybiBrZXkgPT0gJ3NldCcgPyB0aGlzIDogcmVzdWx0O1xuICAgICAgLy8gc3RvcmUgYWxsIHRoZSByZXN0IG9uIG5hdGl2ZSB3ZWFrbWFwXG4gICAgICB9IHJldHVybiBtZXRob2QuY2FsbCh0aGlzLCBhLCBiKTtcbiAgICB9KTtcbiAgfSk7XG59XG4iLCIndXNlIHN0cmljdCc7XG52YXIgd2VhayA9IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24td2VhaycpO1xudmFyIHZhbGlkYXRlID0gcmVxdWlyZSgnLi9fdmFsaWRhdGUtY29sbGVjdGlvbicpO1xudmFyIFdFQUtfU0VUID0gJ1dlYWtTZXQnO1xuXG4vLyAyMy40IFdlYWtTZXQgT2JqZWN0c1xucmVxdWlyZSgnLi9fY29sbGVjdGlvbicpKFdFQUtfU0VULCBmdW5jdGlvbiAoZ2V0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBXZWFrU2V0KCkgeyByZXR1cm4gZ2V0KHRoaXMsIGFyZ3VtZW50cy5sZW5ndGggPiAwID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTsgfTtcbn0sIHtcbiAgLy8gMjMuNC4zLjEgV2Vha1NldC5wcm90b3R5cGUuYWRkKHZhbHVlKVxuICBhZGQ6IGZ1bmN0aW9uIGFkZCh2YWx1ZSkge1xuICAgIHJldHVybiB3ZWFrLmRlZih2YWxpZGF0ZSh0aGlzLCBXRUFLX1NFVCksIHZhbHVlLCB0cnVlKTtcbiAgfVxufSwgd2VhaywgZmFsc2UsIHRydWUpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9wcm9wb3NhbC1mbGF0TWFwLyNzZWMtQXJyYXkucHJvdG90eXBlLmZsYXRNYXBcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgZmxhdHRlbkludG9BcnJheSA9IHJlcXVpcmUoJy4vX2ZsYXR0ZW4taW50by1hcnJheScpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG52YXIgYXJyYXlTcGVjaWVzQ3JlYXRlID0gcmVxdWlyZSgnLi9fYXJyYXktc3BlY2llcy1jcmVhdGUnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAsICdBcnJheScsIHtcbiAgZmxhdE1hcDogZnVuY3Rpb24gZmxhdE1hcChjYWxsYmFja2ZuIC8qICwgdGhpc0FyZyAqLykge1xuICAgIHZhciBPID0gdG9PYmplY3QodGhpcyk7XG4gICAgdmFyIHNvdXJjZUxlbiwgQTtcbiAgICBhRnVuY3Rpb24oY2FsbGJhY2tmbik7XG4gICAgc291cmNlTGVuID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICAgIEEgPSBhcnJheVNwZWNpZXNDcmVhdGUoTywgMCk7XG4gICAgZmxhdHRlbkludG9BcnJheShBLCBPLCBPLCBzb3VyY2VMZW4sIDAsIDEsIGNhbGxiYWNrZm4sIGFyZ3VtZW50c1sxXSk7XG4gICAgcmV0dXJuIEE7XG4gIH1cbn0pO1xuXG5yZXF1aXJlKCcuL19hZGQtdG8tdW5zY29wYWJsZXMnKSgnZmxhdE1hcCcpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9wcm9wb3NhbC1mbGF0TWFwLyNzZWMtQXJyYXkucHJvdG90eXBlLmZsYXR0ZW5cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgZmxhdHRlbkludG9BcnJheSA9IHJlcXVpcmUoJy4vX2ZsYXR0ZW4taW50by1hcnJheScpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG52YXIgYXJyYXlTcGVjaWVzQ3JlYXRlID0gcmVxdWlyZSgnLi9fYXJyYXktc3BlY2llcy1jcmVhdGUnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAsICdBcnJheScsIHtcbiAgZmxhdHRlbjogZnVuY3Rpb24gZmxhdHRlbigvKiBkZXB0aEFyZyA9IDEgKi8pIHtcbiAgICB2YXIgZGVwdGhBcmcgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIE8gPSB0b09iamVjdCh0aGlzKTtcbiAgICB2YXIgc291cmNlTGVuID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICAgIHZhciBBID0gYXJyYXlTcGVjaWVzQ3JlYXRlKE8sIDApO1xuICAgIGZsYXR0ZW5JbnRvQXJyYXkoQSwgTywgTywgc291cmNlTGVuLCAwLCBkZXB0aEFyZyA9PT0gdW5kZWZpbmVkID8gMSA6IHRvSW50ZWdlcihkZXB0aEFyZykpO1xuICAgIHJldHVybiBBO1xuICB9XG59KTtcblxucmVxdWlyZSgnLi9fYWRkLXRvLXVuc2NvcGFibGVzJykoJ2ZsYXR0ZW4nKTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L0FycmF5LnByb3RvdHlwZS5pbmNsdWRlc1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkaW5jbHVkZXMgPSByZXF1aXJlKCcuL19hcnJheS1pbmNsdWRlcycpKHRydWUpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCwgJ0FycmF5Jywge1xuICBpbmNsdWRlczogZnVuY3Rpb24gaW5jbHVkZXMoZWwgLyogLCBmcm9tSW5kZXggPSAwICovKSB7XG4gICAgcmV0dXJuICRpbmNsdWRlcyh0aGlzLCBlbCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICB9XG59KTtcblxucmVxdWlyZSgnLi9fYWRkLXRvLXVuc2NvcGFibGVzJykoJ2luY2x1ZGVzJyk7XG4iLCIvLyBodHRwczovL2dpdGh1Yi5jb20vcndhbGRyb24vdGMzOS1ub3Rlcy9ibG9iL21hc3Rlci9lczYvMjAxNC0wOS9zZXB0LTI1Lm1kIzUxMC1nbG9iYWxhc2FwLWZvci1lbnF1ZXVpbmctYS1taWNyb3Rhc2tcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgbWljcm90YXNrID0gcmVxdWlyZSgnLi9fbWljcm90YXNrJykoKTtcbnZhciBwcm9jZXNzID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykucHJvY2VzcztcbnZhciBpc05vZGUgPSByZXF1aXJlKCcuL19jb2YnKShwcm9jZXNzKSA9PSAncHJvY2Vzcyc7XG5cbiRleHBvcnQoJGV4cG9ydC5HLCB7XG4gIGFzYXA6IGZ1bmN0aW9uIGFzYXAoZm4pIHtcbiAgICB2YXIgZG9tYWluID0gaXNOb2RlICYmIHByb2Nlc3MuZG9tYWluO1xuICAgIG1pY3JvdGFzayhkb21haW4gPyBkb21haW4uYmluZChmbikgOiBmbik7XG4gIH1cbn0pO1xuIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL2xqaGFyYi9wcm9wb3NhbC1pcy1lcnJvclxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdFcnJvcicsIHtcbiAgaXNFcnJvcjogZnVuY3Rpb24gaXNFcnJvcihpdCkge1xuICAgIHJldHVybiBjb2YoaXQpID09PSAnRXJyb3InO1xuICB9XG59KTtcbiIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLWdsb2JhbFxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LkcsIHsgZ2xvYmFsOiByZXF1aXJlKCcuL19nbG9iYWwnKSB9KTtcbiIsIi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vcHJvcG9zYWwtc2V0bWFwLW9mZnJvbS8jc2VjLW1hcC5mcm9tXG5yZXF1aXJlKCcuL19zZXQtY29sbGVjdGlvbi1mcm9tJykoJ01hcCcpO1xuIiwiLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9wcm9wb3NhbC1zZXRtYXAtb2Zmcm9tLyNzZWMtbWFwLm9mXG5yZXF1aXJlKCcuL19zZXQtY29sbGVjdGlvbi1vZicpKCdNYXAnKTtcbiIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9EYXZpZEJydWFudC9NYXAtU2V0LnByb3RvdHlwZS50b0pTT05cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5SLCAnTWFwJywgeyB0b0pTT046IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24tdG8tanNvbicpKCdNYXAnKSB9KTtcbiIsIi8vIGh0dHBzOi8vcndhbGRyb24uZ2l0aHViLmlvL3Byb3Bvc2FsLW1hdGgtZXh0ZW5zaW9ucy9cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgY2xhbXA6IGZ1bmN0aW9uIGNsYW1wKHgsIGxvd2VyLCB1cHBlcikge1xuICAgIHJldHVybiBNYXRoLm1pbih1cHBlciwgTWF0aC5tYXgobG93ZXIsIHgpKTtcbiAgfVxufSk7XG4iLCIvLyBodHRwczovL3J3YWxkcm9uLmdpdGh1Yi5pby9wcm9wb3NhbC1tYXRoLWV4dGVuc2lvbnMvXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7IERFR19QRVJfUkFEOiBNYXRoLlBJIC8gMTgwIH0pO1xuIiwiLy8gaHR0cHM6Ly9yd2FsZHJvbi5naXRodWIuaW8vcHJvcG9zYWwtbWF0aC1leHRlbnNpb25zL1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBSQURfUEVSX0RFRyA9IDE4MCAvIE1hdGguUEk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgZGVncmVlczogZnVuY3Rpb24gZGVncmVlcyhyYWRpYW5zKSB7XG4gICAgcmV0dXJuIHJhZGlhbnMgKiBSQURfUEVSX0RFRztcbiAgfVxufSk7XG4iLCIvLyBodHRwczovL3J3YWxkcm9uLmdpdGh1Yi5pby9wcm9wb3NhbC1tYXRoLWV4dGVuc2lvbnMvXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHNjYWxlID0gcmVxdWlyZSgnLi9fbWF0aC1zY2FsZScpO1xudmFyIGZyb3VuZCA9IHJlcXVpcmUoJy4vX21hdGgtZnJvdW5kJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgZnNjYWxlOiBmdW5jdGlvbiBmc2NhbGUoeCwgaW5Mb3csIGluSGlnaCwgb3V0TG93LCBvdXRIaWdoKSB7XG4gICAgcmV0dXJuIGZyb3VuZChzY2FsZSh4LCBpbkxvdywgaW5IaWdoLCBvdXRMb3csIG91dEhpZ2gpKTtcbiAgfVxufSk7XG4iLCIvLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9CcmVuZGFuRWljaC80Mjk0ZDVjMjEyYTZkMjI1NDcwM1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBpYWRkaDogZnVuY3Rpb24gaWFkZGgoeDAsIHgxLCB5MCwgeTEpIHtcbiAgICB2YXIgJHgwID0geDAgPj4+IDA7XG4gICAgdmFyICR4MSA9IHgxID4+PiAwO1xuICAgIHZhciAkeTAgPSB5MCA+Pj4gMDtcbiAgICByZXR1cm4gJHgxICsgKHkxID4+PiAwKSArICgoJHgwICYgJHkwIHwgKCR4MCB8ICR5MCkgJiB+KCR4MCArICR5MCA+Pj4gMCkpID4+PiAzMSkgfCAwO1xuICB9XG59KTtcbiIsIi8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL0JyZW5kYW5FaWNoLzQyOTRkNWMyMTJhNmQyMjU0NzAzXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGltdWxoOiBmdW5jdGlvbiBpbXVsaCh1LCB2KSB7XG4gICAgdmFyIFVJTlQxNiA9IDB4ZmZmZjtcbiAgICB2YXIgJHUgPSArdTtcbiAgICB2YXIgJHYgPSArdjtcbiAgICB2YXIgdTAgPSAkdSAmIFVJTlQxNjtcbiAgICB2YXIgdjAgPSAkdiAmIFVJTlQxNjtcbiAgICB2YXIgdTEgPSAkdSA+PiAxNjtcbiAgICB2YXIgdjEgPSAkdiA+PiAxNjtcbiAgICB2YXIgdCA9ICh1MSAqIHYwID4+PiAwKSArICh1MCAqIHYwID4+PiAxNik7XG4gICAgcmV0dXJuIHUxICogdjEgKyAodCA+PiAxNikgKyAoKHUwICogdjEgPj4+IDApICsgKHQgJiBVSU5UMTYpID4+IDE2KTtcbiAgfVxufSk7XG4iLCIvLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9CcmVuZGFuRWljaC80Mjk0ZDVjMjEyYTZkMjI1NDcwM1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBpc3ViaDogZnVuY3Rpb24gaXN1YmgoeDAsIHgxLCB5MCwgeTEpIHtcbiAgICB2YXIgJHgwID0geDAgPj4+IDA7XG4gICAgdmFyICR4MSA9IHgxID4+PiAwO1xuICAgIHZhciAkeTAgPSB5MCA+Pj4gMDtcbiAgICByZXR1cm4gJHgxIC0gKHkxID4+PiAwKSAtICgofiR4MCAmICR5MCB8IH4oJHgwIF4gJHkwKSAmICR4MCAtICR5MCA+Pj4gMCkgPj4+IDMxKSB8IDA7XG4gIH1cbn0pO1xuIiwiLy8gaHR0cHM6Ly9yd2FsZHJvbi5naXRodWIuaW8vcHJvcG9zYWwtbWF0aC1leHRlbnNpb25zL1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywgeyBSQURfUEVSX0RFRzogMTgwIC8gTWF0aC5QSSB9KTtcbiIsIi8vIGh0dHBzOi8vcndhbGRyb24uZ2l0aHViLmlvL3Byb3Bvc2FsLW1hdGgtZXh0ZW5zaW9ucy9cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgREVHX1BFUl9SQUQgPSBNYXRoLlBJIC8gMTgwO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIHJhZGlhbnM6IGZ1bmN0aW9uIHJhZGlhbnMoZGVncmVlcykge1xuICAgIHJldHVybiBkZWdyZWVzICogREVHX1BFUl9SQUQ7XG4gIH1cbn0pO1xuIiwiLy8gaHR0cHM6Ly9yd2FsZHJvbi5naXRodWIuaW8vcHJvcG9zYWwtbWF0aC1leHRlbnNpb25zL1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywgeyBzY2FsZTogcmVxdWlyZSgnLi9fbWF0aC1zY2FsZScpIH0pO1xuIiwiLy8gaHR0cDovL2pmYmFzdGllbi5naXRodWIuaW8vcGFwZXJzL01hdGguc2lnbmJpdC5odG1sXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7IHNpZ25iaXQ6IGZ1bmN0aW9uIHNpZ25iaXQoeCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gIHJldHVybiAoeCA9ICt4KSAhPSB4ID8geCA6IHggPT0gMCA/IDEgLyB4ID09IEluZmluaXR5IDogeCA+IDA7XG59IH0pO1xuIiwiLy8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vQnJlbmRhbkVpY2gvNDI5NGQ1YzIxMmE2ZDIyNTQ3MDNcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgdW11bGg6IGZ1bmN0aW9uIHVtdWxoKHUsIHYpIHtcbiAgICB2YXIgVUlOVDE2ID0gMHhmZmZmO1xuICAgIHZhciAkdSA9ICt1O1xuICAgIHZhciAkdiA9ICt2O1xuICAgIHZhciB1MCA9ICR1ICYgVUlOVDE2O1xuICAgIHZhciB2MCA9ICR2ICYgVUlOVDE2O1xuICAgIHZhciB1MSA9ICR1ID4+PiAxNjtcbiAgICB2YXIgdjEgPSAkdiA+Pj4gMTY7XG4gICAgdmFyIHQgPSAodTEgKiB2MCA+Pj4gMCkgKyAodTAgKiB2MCA+Pj4gMTYpO1xuICAgIHJldHVybiB1MSAqIHYxICsgKHQgPj4+IDE2KSArICgodTAgKiB2MSA+Pj4gMCkgKyAodCAmIFVJTlQxNikgPj4+IDE2KTtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xudmFyICRkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xuXG4vLyBCLjIuMi4yIE9iamVjdC5wcm90b3R5cGUuX19kZWZpbmVHZXR0ZXJfXyhQLCBnZXR0ZXIpXG5yZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmICRleHBvcnQoJGV4cG9ydC5QICsgcmVxdWlyZSgnLi9fb2JqZWN0LWZvcmNlZC1wYW0nKSwgJ09iamVjdCcsIHtcbiAgX19kZWZpbmVHZXR0ZXJfXzogZnVuY3Rpb24gX19kZWZpbmVHZXR0ZXJfXyhQLCBnZXR0ZXIpIHtcbiAgICAkZGVmaW5lUHJvcGVydHkuZih0b09iamVjdCh0aGlzKSwgUCwgeyBnZXQ6IGFGdW5jdGlvbihnZXR0ZXIpLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSk7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcbnZhciAkZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcblxuLy8gQi4yLjIuMyBPYmplY3QucHJvdG90eXBlLl9fZGVmaW5lU2V0dGVyX18oUCwgc2V0dGVyKVxucmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiAkZXhwb3J0KCRleHBvcnQuUCArIHJlcXVpcmUoJy4vX29iamVjdC1mb3JjZWQtcGFtJyksICdPYmplY3QnLCB7XG4gIF9fZGVmaW5lU2V0dGVyX186IGZ1bmN0aW9uIF9fZGVmaW5lU2V0dGVyX18oUCwgc2V0dGVyKSB7XG4gICAgJGRlZmluZVByb3BlcnR5LmYodG9PYmplY3QodGhpcyksIFAsIHsgc2V0OiBhRnVuY3Rpb24oc2V0dGVyKSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0pO1xuICB9XG59KTtcbiIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLW9iamVjdC12YWx1ZXMtZW50cmllc1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkZW50cmllcyA9IHJlcXVpcmUoJy4vX29iamVjdC10by1hcnJheScpKHRydWUpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ09iamVjdCcsIHtcbiAgZW50cmllczogZnVuY3Rpb24gZW50cmllcyhpdCkge1xuICAgIHJldHVybiAkZW50cmllcyhpdCk7XG4gIH1cbn0pO1xuIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtb2JqZWN0LWdldG93bnByb3BlcnR5ZGVzY3JpcHRvcnNcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgb3duS2V5cyA9IHJlcXVpcmUoJy4vX293bi1rZXlzJyk7XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIGdPUEQgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpO1xudmFyIGNyZWF0ZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fY3JlYXRlLXByb3BlcnR5Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnT2JqZWN0Jywge1xuICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG9iamVjdCkge1xuICAgIHZhciBPID0gdG9JT2JqZWN0KG9iamVjdCk7XG4gICAgdmFyIGdldERlc2MgPSBnT1BELmY7XG4gICAgdmFyIGtleXMgPSBvd25LZXlzKE8pO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGtleSwgZGVzYztcbiAgICB3aGlsZSAoa2V5cy5sZW5ndGggPiBpKSB7XG4gICAgICBkZXNjID0gZ2V0RGVzYyhPLCBrZXkgPSBrZXlzW2krK10pO1xuICAgICAgaWYgKGRlc2MgIT09IHVuZGVmaW5lZCkgY3JlYXRlUHJvcGVydHkocmVzdWx0LCBrZXksIGRlc2MpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpO1xudmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpO1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJykuZjtcblxuLy8gQi4yLjIuNCBPYmplY3QucHJvdG90eXBlLl9fbG9va3VwR2V0dGVyX18oUClcbnJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgJGV4cG9ydCgkZXhwb3J0LlAgKyByZXF1aXJlKCcuL19vYmplY3QtZm9yY2VkLXBhbScpLCAnT2JqZWN0Jywge1xuICBfX2xvb2t1cEdldHRlcl9fOiBmdW5jdGlvbiBfX2xvb2t1cEdldHRlcl9fKFApIHtcbiAgICB2YXIgTyA9IHRvT2JqZWN0KHRoaXMpO1xuICAgIHZhciBLID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gICAgdmFyIEQ7XG4gICAgZG8ge1xuICAgICAgaWYgKEQgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgSykpIHJldHVybiBELmdldDtcbiAgICB9IHdoaWxlIChPID0gZ2V0UHJvdG90eXBlT2YoTykpO1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpO1xudmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpO1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJykuZjtcblxuLy8gQi4yLjIuNSBPYmplY3QucHJvdG90eXBlLl9fbG9va3VwU2V0dGVyX18oUClcbnJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgJGV4cG9ydCgkZXhwb3J0LlAgKyByZXF1aXJlKCcuL19vYmplY3QtZm9yY2VkLXBhbScpLCAnT2JqZWN0Jywge1xuICBfX2xvb2t1cFNldHRlcl9fOiBmdW5jdGlvbiBfX2xvb2t1cFNldHRlcl9fKFApIHtcbiAgICB2YXIgTyA9IHRvT2JqZWN0KHRoaXMpO1xuICAgIHZhciBLID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gICAgdmFyIEQ7XG4gICAgZG8ge1xuICAgICAgaWYgKEQgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgSykpIHJldHVybiBELnNldDtcbiAgICB9IHdoaWxlIChPID0gZ2V0UHJvdG90eXBlT2YoTykpO1xuICB9XG59KTtcbiIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLW9iamVjdC12YWx1ZXMtZW50cmllc1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkdmFsdWVzID0gcmVxdWlyZSgnLi9fb2JqZWN0LXRvLWFycmF5JykoZmFsc2UpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ09iamVjdCcsIHtcbiAgdmFsdWVzOiBmdW5jdGlvbiB2YWx1ZXMoaXQpIHtcbiAgICByZXR1cm4gJHZhbHVlcyhpdCk7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3plbnBhcnNpbmcvZXMtb2JzZXJ2YWJsZVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBjb3JlID0gcmVxdWlyZSgnLi9fY29yZScpO1xudmFyIG1pY3JvdGFzayA9IHJlcXVpcmUoJy4vX21pY3JvdGFzaycpKCk7XG52YXIgT0JTRVJWQUJMRSA9IHJlcXVpcmUoJy4vX3drcycpKCdvYnNlcnZhYmxlJyk7XG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgYW5JbnN0YW5jZSA9IHJlcXVpcmUoJy4vX2FuLWluc3RhbmNlJyk7XG52YXIgcmVkZWZpbmVBbGwgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKTtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xudmFyIGZvck9mID0gcmVxdWlyZSgnLi9fZm9yLW9mJyk7XG52YXIgUkVUVVJOID0gZm9yT2YuUkVUVVJOO1xuXG52YXIgZ2V0TWV0aG9kID0gZnVuY3Rpb24gKGZuKSB7XG4gIHJldHVybiBmbiA9PSBudWxsID8gdW5kZWZpbmVkIDogYUZ1bmN0aW9uKGZuKTtcbn07XG5cbnZhciBjbGVhbnVwU3Vic2NyaXB0aW9uID0gZnVuY3Rpb24gKHN1YnNjcmlwdGlvbikge1xuICB2YXIgY2xlYW51cCA9IHN1YnNjcmlwdGlvbi5fYztcbiAgaWYgKGNsZWFudXApIHtcbiAgICBzdWJzY3JpcHRpb24uX2MgPSB1bmRlZmluZWQ7XG4gICAgY2xlYW51cCgpO1xuICB9XG59O1xuXG52YXIgc3Vic2NyaXB0aW9uQ2xvc2VkID0gZnVuY3Rpb24gKHN1YnNjcmlwdGlvbikge1xuICByZXR1cm4gc3Vic2NyaXB0aW9uLl9vID09PSB1bmRlZmluZWQ7XG59O1xuXG52YXIgY2xvc2VTdWJzY3JpcHRpb24gPSBmdW5jdGlvbiAoc3Vic2NyaXB0aW9uKSB7XG4gIGlmICghc3Vic2NyaXB0aW9uQ2xvc2VkKHN1YnNjcmlwdGlvbikpIHtcbiAgICBzdWJzY3JpcHRpb24uX28gPSB1bmRlZmluZWQ7XG4gICAgY2xlYW51cFN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb24pO1xuICB9XG59O1xuXG52YXIgU3Vic2NyaXB0aW9uID0gZnVuY3Rpb24gKG9ic2VydmVyLCBzdWJzY3JpYmVyKSB7XG4gIGFuT2JqZWN0KG9ic2VydmVyKTtcbiAgdGhpcy5fYyA9IHVuZGVmaW5lZDtcbiAgdGhpcy5fbyA9IG9ic2VydmVyO1xuICBvYnNlcnZlciA9IG5ldyBTdWJzY3JpcHRpb25PYnNlcnZlcih0aGlzKTtcbiAgdHJ5IHtcbiAgICB2YXIgY2xlYW51cCA9IHN1YnNjcmliZXIob2JzZXJ2ZXIpO1xuICAgIHZhciBzdWJzY3JpcHRpb24gPSBjbGVhbnVwO1xuICAgIGlmIChjbGVhbnVwICE9IG51bGwpIHtcbiAgICAgIGlmICh0eXBlb2YgY2xlYW51cC51bnN1YnNjcmliZSA9PT0gJ2Z1bmN0aW9uJykgY2xlYW51cCA9IGZ1bmN0aW9uICgpIHsgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7IH07XG4gICAgICBlbHNlIGFGdW5jdGlvbihjbGVhbnVwKTtcbiAgICAgIHRoaXMuX2MgPSBjbGVhbnVwO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIG9ic2VydmVyLmVycm9yKGUpO1xuICAgIHJldHVybjtcbiAgfSBpZiAoc3Vic2NyaXB0aW9uQ2xvc2VkKHRoaXMpKSBjbGVhbnVwU3Vic2NyaXB0aW9uKHRoaXMpO1xufTtcblxuU3Vic2NyaXB0aW9uLnByb3RvdHlwZSA9IHJlZGVmaW5lQWxsKHt9LCB7XG4gIHVuc3Vic2NyaWJlOiBmdW5jdGlvbiB1bnN1YnNjcmliZSgpIHsgY2xvc2VTdWJzY3JpcHRpb24odGhpcyk7IH1cbn0pO1xuXG52YXIgU3Vic2NyaXB0aW9uT2JzZXJ2ZXIgPSBmdW5jdGlvbiAoc3Vic2NyaXB0aW9uKSB7XG4gIHRoaXMuX3MgPSBzdWJzY3JpcHRpb247XG59O1xuXG5TdWJzY3JpcHRpb25PYnNlcnZlci5wcm90b3R5cGUgPSByZWRlZmluZUFsbCh7fSwge1xuICBuZXh0OiBmdW5jdGlvbiBuZXh0KHZhbHVlKSB7XG4gICAgdmFyIHN1YnNjcmlwdGlvbiA9IHRoaXMuX3M7XG4gICAgaWYgKCFzdWJzY3JpcHRpb25DbG9zZWQoc3Vic2NyaXB0aW9uKSkge1xuICAgICAgdmFyIG9ic2VydmVyID0gc3Vic2NyaXB0aW9uLl9vO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIG0gPSBnZXRNZXRob2Qob2JzZXJ2ZXIubmV4dCk7XG4gICAgICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG9ic2VydmVyLCB2YWx1ZSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY2xvc2VTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBlcnJvcjogZnVuY3Rpb24gZXJyb3IodmFsdWUpIHtcbiAgICB2YXIgc3Vic2NyaXB0aW9uID0gdGhpcy5fcztcbiAgICBpZiAoc3Vic2NyaXB0aW9uQ2xvc2VkKHN1YnNjcmlwdGlvbikpIHRocm93IHZhbHVlO1xuICAgIHZhciBvYnNlcnZlciA9IHN1YnNjcmlwdGlvbi5fbztcbiAgICBzdWJzY3JpcHRpb24uX28gPSB1bmRlZmluZWQ7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBtID0gZ2V0TWV0aG9kKG9ic2VydmVyLmVycm9yKTtcbiAgICAgIGlmICghbSkgdGhyb3cgdmFsdWU7XG4gICAgICB2YWx1ZSA9IG0uY2FsbChvYnNlcnZlciwgdmFsdWUpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNsZWFudXBTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfSBjbGVhbnVwU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbik7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9LFxuICBjb21wbGV0ZTogZnVuY3Rpb24gY29tcGxldGUodmFsdWUpIHtcbiAgICB2YXIgc3Vic2NyaXB0aW9uID0gdGhpcy5fcztcbiAgICBpZiAoIXN1YnNjcmlwdGlvbkNsb3NlZChzdWJzY3JpcHRpb24pKSB7XG4gICAgICB2YXIgb2JzZXJ2ZXIgPSBzdWJzY3JpcHRpb24uX287XG4gICAgICBzdWJzY3JpcHRpb24uX28gPSB1bmRlZmluZWQ7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgbSA9IGdldE1ldGhvZChvYnNlcnZlci5jb21wbGV0ZSk7XG4gICAgICAgIHZhbHVlID0gbSA/IG0uY2FsbChvYnNlcnZlciwgdmFsdWUpIDogdW5kZWZpbmVkO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNsZWFudXBTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICB9IGNsZWFudXBTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uKTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH1cbn0pO1xuXG52YXIgJE9ic2VydmFibGUgPSBmdW5jdGlvbiBPYnNlcnZhYmxlKHN1YnNjcmliZXIpIHtcbiAgYW5JbnN0YW5jZSh0aGlzLCAkT2JzZXJ2YWJsZSwgJ09ic2VydmFibGUnLCAnX2YnKS5fZiA9IGFGdW5jdGlvbihzdWJzY3JpYmVyKTtcbn07XG5cbnJlZGVmaW5lQWxsKCRPYnNlcnZhYmxlLnByb3RvdHlwZSwge1xuICBzdWJzY3JpYmU6IGZ1bmN0aW9uIHN1YnNjcmliZShvYnNlcnZlcikge1xuICAgIHJldHVybiBuZXcgU3Vic2NyaXB0aW9uKG9ic2VydmVyLCB0aGlzLl9mKTtcbiAgfSxcbiAgZm9yRWFjaDogZnVuY3Rpb24gZm9yRWFjaChmbikge1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICByZXR1cm4gbmV3IChjb3JlLlByb21pc2UgfHwgZ2xvYmFsLlByb21pc2UpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIGFGdW5jdGlvbihmbik7XG4gICAgICB2YXIgc3Vic2NyaXB0aW9uID0gdGhhdC5zdWJzY3JpYmUoe1xuICAgICAgICBuZXh0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGZuKHZhbHVlKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yOiByZWplY3QsXG4gICAgICAgIGNvbXBsZXRlOiByZXNvbHZlXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufSk7XG5cbnJlZGVmaW5lQWxsKCRPYnNlcnZhYmxlLCB7XG4gIGZyb206IGZ1bmN0aW9uIGZyb20oeCkge1xuICAgIHZhciBDID0gdHlwZW9mIHRoaXMgPT09ICdmdW5jdGlvbicgPyB0aGlzIDogJE9ic2VydmFibGU7XG4gICAgdmFyIG1ldGhvZCA9IGdldE1ldGhvZChhbk9iamVjdCh4KVtPQlNFUlZBQkxFXSk7XG4gICAgaWYgKG1ldGhvZCkge1xuICAgICAgdmFyIG9ic2VydmFibGUgPSBhbk9iamVjdChtZXRob2QuY2FsbCh4KSk7XG4gICAgICByZXR1cm4gb2JzZXJ2YWJsZS5jb25zdHJ1Y3RvciA9PT0gQyA/IG9ic2VydmFibGUgOiBuZXcgQyhmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgICAgcmV0dXJuIG9ic2VydmFibGUuc3Vic2NyaWJlKG9ic2VydmVyKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEMoZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICB2YXIgZG9uZSA9IGZhbHNlO1xuICAgICAgbWljcm90YXNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFkb25lKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmb3JPZih4LCBmYWxzZSwgZnVuY3Rpb24gKGl0KSB7XG4gICAgICAgICAgICAgIG9ic2VydmVyLm5leHQoaXQpO1xuICAgICAgICAgICAgICBpZiAoZG9uZSkgcmV0dXJuIFJFVFVSTjtcbiAgICAgICAgICAgIH0pID09PSBSRVRVUk4pIHJldHVybjtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAoZG9uZSkgdGhyb3cgZTtcbiAgICAgICAgICAgIG9ic2VydmVyLmVycm9yKGUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gb2JzZXJ2ZXIuY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyBkb25lID0gdHJ1ZTsgfTtcbiAgICB9KTtcbiAgfSxcbiAgb2Y6IGZ1bmN0aW9uIG9mKCkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aCwgaXRlbXMgPSBBcnJheShsKTsgaSA8IGw7KSBpdGVtc1tpXSA9IGFyZ3VtZW50c1tpKytdO1xuICAgIHJldHVybiBuZXcgKHR5cGVvZiB0aGlzID09PSAnZnVuY3Rpb24nID8gdGhpcyA6ICRPYnNlcnZhYmxlKShmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgIHZhciBkb25lID0gZmFsc2U7XG4gICAgICBtaWNyb3Rhc2soZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWRvbmUpIHtcbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGl0ZW1zLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICBvYnNlcnZlci5uZXh0KGl0ZW1zW2pdKTtcbiAgICAgICAgICAgIGlmIChkb25lKSByZXR1cm47XG4gICAgICAgICAgfSBvYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IGRvbmUgPSB0cnVlOyB9O1xuICAgIH0pO1xuICB9XG59KTtcblxuaGlkZSgkT2JzZXJ2YWJsZS5wcm90b3R5cGUsIE9CU0VSVkFCTEUsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0pO1xuXG4kZXhwb3J0KCRleHBvcnQuRywgeyBPYnNlcnZhYmxlOiAkT2JzZXJ2YWJsZSB9KTtcblxucmVxdWlyZSgnLi9fc2V0LXNwZWNpZXMnKSgnT2JzZXJ2YWJsZScpO1xuIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtcHJvbWlzZS1maW5hbGx5XG4ndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGNvcmUgPSByZXF1aXJlKCcuL19jb3JlJyk7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgc3BlY2llc0NvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi9fc3BlY2llcy1jb25zdHJ1Y3RvcicpO1xudmFyIHByb21pc2VSZXNvbHZlID0gcmVxdWlyZSgnLi9fcHJvbWlzZS1yZXNvbHZlJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5SLCAnUHJvbWlzZScsIHsgJ2ZpbmFsbHknOiBmdW5jdGlvbiAob25GaW5hbGx5KSB7XG4gIHZhciBDID0gc3BlY2llc0NvbnN0cnVjdG9yKHRoaXMsIGNvcmUuUHJvbWlzZSB8fCBnbG9iYWwuUHJvbWlzZSk7XG4gIHZhciBpc0Z1bmN0aW9uID0gdHlwZW9mIG9uRmluYWxseSA9PSAnZnVuY3Rpb24nO1xuICByZXR1cm4gdGhpcy50aGVuKFxuICAgIGlzRnVuY3Rpb24gPyBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIHByb21pc2VSZXNvbHZlKEMsIG9uRmluYWxseSgpKS50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHg7IH0pO1xuICAgIH0gOiBvbkZpbmFsbHksXG4gICAgaXNGdW5jdGlvbiA/IGZ1bmN0aW9uIChlKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZVJlc29sdmUoQywgb25GaW5hbGx5KCkpLnRoZW4oZnVuY3Rpb24gKCkgeyB0aHJvdyBlOyB9KTtcbiAgICB9IDogb25GaW5hbGx5XG4gICk7XG59IH0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtcHJvbWlzZS10cnlcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgbmV3UHJvbWlzZUNhcGFiaWxpdHkgPSByZXF1aXJlKCcuL19uZXctcHJvbWlzZS1jYXBhYmlsaXR5Jyk7XG52YXIgcGVyZm9ybSA9IHJlcXVpcmUoJy4vX3BlcmZvcm0nKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdQcm9taXNlJywgeyAndHJ5JzogZnVuY3Rpb24gKGNhbGxiYWNrZm4pIHtcbiAgdmFyIHByb21pc2VDYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkuZih0aGlzKTtcbiAgdmFyIHJlc3VsdCA9IHBlcmZvcm0oY2FsbGJhY2tmbik7XG4gIChyZXN1bHQuZSA/IHByb21pc2VDYXBhYmlsaXR5LnJlamVjdCA6IHByb21pc2VDYXBhYmlsaXR5LnJlc29sdmUpKHJlc3VsdC52KTtcbiAgcmV0dXJuIHByb21pc2VDYXBhYmlsaXR5LnByb21pc2U7XG59IH0pO1xuIiwidmFyIG1ldGFkYXRhID0gcmVxdWlyZSgnLi9fbWV0YWRhdGEnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIHRvTWV0YUtleSA9IG1ldGFkYXRhLmtleTtcbnZhciBvcmRpbmFyeURlZmluZU93bk1ldGFkYXRhID0gbWV0YWRhdGEuc2V0O1xuXG5tZXRhZGF0YS5leHAoeyBkZWZpbmVNZXRhZGF0YTogZnVuY3Rpb24gZGVmaW5lTWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUsIHRhcmdldCwgdGFyZ2V0S2V5KSB7XG4gIG9yZGluYXJ5RGVmaW5lT3duTWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUsIGFuT2JqZWN0KHRhcmdldCksIHRvTWV0YUtleSh0YXJnZXRLZXkpKTtcbn0gfSk7XG4iLCJ2YXIgbWV0YWRhdGEgPSByZXF1aXJlKCcuL19tZXRhZGF0YScpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgdG9NZXRhS2V5ID0gbWV0YWRhdGEua2V5O1xudmFyIGdldE9yQ3JlYXRlTWV0YWRhdGFNYXAgPSBtZXRhZGF0YS5tYXA7XG52YXIgc3RvcmUgPSBtZXRhZGF0YS5zdG9yZTtcblxubWV0YWRhdGEuZXhwKHsgZGVsZXRlTWV0YWRhdGE6IGZ1bmN0aW9uIGRlbGV0ZU1ldGFkYXRhKG1ldGFkYXRhS2V5LCB0YXJnZXQgLyogLCB0YXJnZXRLZXkgKi8pIHtcbiAgdmFyIHRhcmdldEtleSA9IGFyZ3VtZW50cy5sZW5ndGggPCAzID8gdW5kZWZpbmVkIDogdG9NZXRhS2V5KGFyZ3VtZW50c1syXSk7XG4gIHZhciBtZXRhZGF0YU1hcCA9IGdldE9yQ3JlYXRlTWV0YWRhdGFNYXAoYW5PYmplY3QodGFyZ2V0KSwgdGFyZ2V0S2V5LCBmYWxzZSk7XG4gIGlmIChtZXRhZGF0YU1hcCA9PT0gdW5kZWZpbmVkIHx8ICFtZXRhZGF0YU1hcFsnZGVsZXRlJ10obWV0YWRhdGFLZXkpKSByZXR1cm4gZmFsc2U7XG4gIGlmIChtZXRhZGF0YU1hcC5zaXplKSByZXR1cm4gdHJ1ZTtcbiAgdmFyIHRhcmdldE1ldGFkYXRhID0gc3RvcmUuZ2V0KHRhcmdldCk7XG4gIHRhcmdldE1ldGFkYXRhWydkZWxldGUnXSh0YXJnZXRLZXkpO1xuICByZXR1cm4gISF0YXJnZXRNZXRhZGF0YS5zaXplIHx8IHN0b3JlWydkZWxldGUnXSh0YXJnZXQpO1xufSB9KTtcbiIsInZhciBTZXQgPSByZXF1aXJlKCcuL2VzNi5zZXQnKTtcbnZhciBmcm9tID0gcmVxdWlyZSgnLi9fYXJyYXktZnJvbS1pdGVyYWJsZScpO1xudmFyIG1ldGFkYXRhID0gcmVxdWlyZSgnLi9fbWV0YWRhdGEnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpO1xudmFyIG9yZGluYXJ5T3duTWV0YWRhdGFLZXlzID0gbWV0YWRhdGEua2V5cztcbnZhciB0b01ldGFLZXkgPSBtZXRhZGF0YS5rZXk7XG5cbnZhciBvcmRpbmFyeU1ldGFkYXRhS2V5cyA9IGZ1bmN0aW9uIChPLCBQKSB7XG4gIHZhciBvS2V5cyA9IG9yZGluYXJ5T3duTWV0YWRhdGFLZXlzKE8sIFApO1xuICB2YXIgcGFyZW50ID0gZ2V0UHJvdG90eXBlT2YoTyk7XG4gIGlmIChwYXJlbnQgPT09IG51bGwpIHJldHVybiBvS2V5cztcbiAgdmFyIHBLZXlzID0gb3JkaW5hcnlNZXRhZGF0YUtleXMocGFyZW50LCBQKTtcbiAgcmV0dXJuIHBLZXlzLmxlbmd0aCA/IG9LZXlzLmxlbmd0aCA/IGZyb20obmV3IFNldChvS2V5cy5jb25jYXQocEtleXMpKSkgOiBwS2V5cyA6IG9LZXlzO1xufTtcblxubWV0YWRhdGEuZXhwKHsgZ2V0TWV0YWRhdGFLZXlzOiBmdW5jdGlvbiBnZXRNZXRhZGF0YUtleXModGFyZ2V0IC8qICwgdGFyZ2V0S2V5ICovKSB7XG4gIHJldHVybiBvcmRpbmFyeU1ldGFkYXRhS2V5cyhhbk9iamVjdCh0YXJnZXQpLCBhcmd1bWVudHMubGVuZ3RoIDwgMiA/IHVuZGVmaW5lZCA6IHRvTWV0YUtleShhcmd1bWVudHNbMV0pKTtcbn0gfSk7XG4iLCJ2YXIgbWV0YWRhdGEgPSByZXF1aXJlKCcuL19tZXRhZGF0YScpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJyk7XG52YXIgb3JkaW5hcnlIYXNPd25NZXRhZGF0YSA9IG1ldGFkYXRhLmhhcztcbnZhciBvcmRpbmFyeUdldE93bk1ldGFkYXRhID0gbWV0YWRhdGEuZ2V0O1xudmFyIHRvTWV0YUtleSA9IG1ldGFkYXRhLmtleTtcblxudmFyIG9yZGluYXJ5R2V0TWV0YWRhdGEgPSBmdW5jdGlvbiAoTWV0YWRhdGFLZXksIE8sIFApIHtcbiAgdmFyIGhhc093biA9IG9yZGluYXJ5SGFzT3duTWV0YWRhdGEoTWV0YWRhdGFLZXksIE8sIFApO1xuICBpZiAoaGFzT3duKSByZXR1cm4gb3JkaW5hcnlHZXRPd25NZXRhZGF0YShNZXRhZGF0YUtleSwgTywgUCk7XG4gIHZhciBwYXJlbnQgPSBnZXRQcm90b3R5cGVPZihPKTtcbiAgcmV0dXJuIHBhcmVudCAhPT0gbnVsbCA/IG9yZGluYXJ5R2V0TWV0YWRhdGEoTWV0YWRhdGFLZXksIHBhcmVudCwgUCkgOiB1bmRlZmluZWQ7XG59O1xuXG5tZXRhZGF0YS5leHAoeyBnZXRNZXRhZGF0YTogZnVuY3Rpb24gZ2V0TWV0YWRhdGEobWV0YWRhdGFLZXksIHRhcmdldCAvKiAsIHRhcmdldEtleSAqLykge1xuICByZXR1cm4gb3JkaW5hcnlHZXRNZXRhZGF0YShtZXRhZGF0YUtleSwgYW5PYmplY3QodGFyZ2V0KSwgYXJndW1lbnRzLmxlbmd0aCA8IDMgPyB1bmRlZmluZWQgOiB0b01ldGFLZXkoYXJndW1lbnRzWzJdKSk7XG59IH0pO1xuIiwidmFyIG1ldGFkYXRhID0gcmVxdWlyZSgnLi9fbWV0YWRhdGEnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIG9yZGluYXJ5T3duTWV0YWRhdGFLZXlzID0gbWV0YWRhdGEua2V5cztcbnZhciB0b01ldGFLZXkgPSBtZXRhZGF0YS5rZXk7XG5cbm1ldGFkYXRhLmV4cCh7IGdldE93bk1ldGFkYXRhS2V5czogZnVuY3Rpb24gZ2V0T3duTWV0YWRhdGFLZXlzKHRhcmdldCAvKiAsIHRhcmdldEtleSAqLykge1xuICByZXR1cm4gb3JkaW5hcnlPd25NZXRhZGF0YUtleXMoYW5PYmplY3QodGFyZ2V0KSwgYXJndW1lbnRzLmxlbmd0aCA8IDIgPyB1bmRlZmluZWQgOiB0b01ldGFLZXkoYXJndW1lbnRzWzFdKSk7XG59IH0pO1xuIiwidmFyIG1ldGFkYXRhID0gcmVxdWlyZSgnLi9fbWV0YWRhdGEnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIG9yZGluYXJ5R2V0T3duTWV0YWRhdGEgPSBtZXRhZGF0YS5nZXQ7XG52YXIgdG9NZXRhS2V5ID0gbWV0YWRhdGEua2V5O1xuXG5tZXRhZGF0YS5leHAoeyBnZXRPd25NZXRhZGF0YTogZnVuY3Rpb24gZ2V0T3duTWV0YWRhdGEobWV0YWRhdGFLZXksIHRhcmdldCAvKiAsIHRhcmdldEtleSAqLykge1xuICByZXR1cm4gb3JkaW5hcnlHZXRPd25NZXRhZGF0YShtZXRhZGF0YUtleSwgYW5PYmplY3QodGFyZ2V0KVxuICAgICwgYXJndW1lbnRzLmxlbmd0aCA8IDMgPyB1bmRlZmluZWQgOiB0b01ldGFLZXkoYXJndW1lbnRzWzJdKSk7XG59IH0pO1xuIiwidmFyIG1ldGFkYXRhID0gcmVxdWlyZSgnLi9fbWV0YWRhdGEnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpO1xudmFyIG9yZGluYXJ5SGFzT3duTWV0YWRhdGEgPSBtZXRhZGF0YS5oYXM7XG52YXIgdG9NZXRhS2V5ID0gbWV0YWRhdGEua2V5O1xuXG52YXIgb3JkaW5hcnlIYXNNZXRhZGF0YSA9IGZ1bmN0aW9uIChNZXRhZGF0YUtleSwgTywgUCkge1xuICB2YXIgaGFzT3duID0gb3JkaW5hcnlIYXNPd25NZXRhZGF0YShNZXRhZGF0YUtleSwgTywgUCk7XG4gIGlmIChoYXNPd24pIHJldHVybiB0cnVlO1xuICB2YXIgcGFyZW50ID0gZ2V0UHJvdG90eXBlT2YoTyk7XG4gIHJldHVybiBwYXJlbnQgIT09IG51bGwgPyBvcmRpbmFyeUhhc01ldGFkYXRhKE1ldGFkYXRhS2V5LCBwYXJlbnQsIFApIDogZmFsc2U7XG59O1xuXG5tZXRhZGF0YS5leHAoeyBoYXNNZXRhZGF0YTogZnVuY3Rpb24gaGFzTWV0YWRhdGEobWV0YWRhdGFLZXksIHRhcmdldCAvKiAsIHRhcmdldEtleSAqLykge1xuICByZXR1cm4gb3JkaW5hcnlIYXNNZXRhZGF0YShtZXRhZGF0YUtleSwgYW5PYmplY3QodGFyZ2V0KSwgYXJndW1lbnRzLmxlbmd0aCA8IDMgPyB1bmRlZmluZWQgOiB0b01ldGFLZXkoYXJndW1lbnRzWzJdKSk7XG59IH0pO1xuIiwidmFyIG1ldGFkYXRhID0gcmVxdWlyZSgnLi9fbWV0YWRhdGEnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIG9yZGluYXJ5SGFzT3duTWV0YWRhdGEgPSBtZXRhZGF0YS5oYXM7XG52YXIgdG9NZXRhS2V5ID0gbWV0YWRhdGEua2V5O1xuXG5tZXRhZGF0YS5leHAoeyBoYXNPd25NZXRhZGF0YTogZnVuY3Rpb24gaGFzT3duTWV0YWRhdGEobWV0YWRhdGFLZXksIHRhcmdldCAvKiAsIHRhcmdldEtleSAqLykge1xuICByZXR1cm4gb3JkaW5hcnlIYXNPd25NZXRhZGF0YShtZXRhZGF0YUtleSwgYW5PYmplY3QodGFyZ2V0KVxuICAgICwgYXJndW1lbnRzLmxlbmd0aCA8IDMgPyB1bmRlZmluZWQgOiB0b01ldGFLZXkoYXJndW1lbnRzWzJdKSk7XG59IH0pO1xuIiwidmFyICRtZXRhZGF0YSA9IHJlcXVpcmUoJy4vX21ldGFkYXRhJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG52YXIgdG9NZXRhS2V5ID0gJG1ldGFkYXRhLmtleTtcbnZhciBvcmRpbmFyeURlZmluZU93bk1ldGFkYXRhID0gJG1ldGFkYXRhLnNldDtcblxuJG1ldGFkYXRhLmV4cCh7IG1ldGFkYXRhOiBmdW5jdGlvbiBtZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24gZGVjb3JhdG9yKHRhcmdldCwgdGFyZ2V0S2V5KSB7XG4gICAgb3JkaW5hcnlEZWZpbmVPd25NZXRhZGF0YShcbiAgICAgIG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlLFxuICAgICAgKHRhcmdldEtleSAhPT0gdW5kZWZpbmVkID8gYW5PYmplY3QgOiBhRnVuY3Rpb24pKHRhcmdldCksXG4gICAgICB0b01ldGFLZXkodGFyZ2V0S2V5KVxuICAgICk7XG4gIH07XG59IH0pO1xuIiwiLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9wcm9wb3NhbC1zZXRtYXAtb2Zmcm9tLyNzZWMtc2V0LmZyb21cbnJlcXVpcmUoJy4vX3NldC1jb2xsZWN0aW9uLWZyb20nKSgnU2V0Jyk7XG4iLCIvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL3Byb3Bvc2FsLXNldG1hcC1vZmZyb20vI3NlYy1zZXQub2ZcbnJlcXVpcmUoJy4vX3NldC1jb2xsZWN0aW9uLW9mJykoJ1NldCcpO1xuIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL0RhdmlkQnJ1YW50L01hcC1TZXQucHJvdG90eXBlLnRvSlNPTlxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LlIsICdTZXQnLCB7IHRvSlNPTjogcmVxdWlyZSgnLi9fY29sbGVjdGlvbi10by1qc29uJykoJ1NldCcpIH0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL21hdGhpYXNieW5lbnMvU3RyaW5nLnByb3RvdHlwZS5hdFxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkYXQgPSByZXF1aXJlKCcuL19zdHJpbmctYXQnKSh0cnVlKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAsICdTdHJpbmcnLCB7XG4gIGF0OiBmdW5jdGlvbiBhdChwb3MpIHtcbiAgICByZXR1cm4gJGF0KHRoaXMsIHBvcyk7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9TdHJpbmcucHJvdG90eXBlLm1hdGNoQWxsL1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgaXNSZWdFeHAgPSByZXF1aXJlKCcuL19pcy1yZWdleHAnKTtcbnZhciBnZXRGbGFncyA9IHJlcXVpcmUoJy4vX2ZsYWdzJyk7XG52YXIgUmVnRXhwUHJvdG8gPSBSZWdFeHAucHJvdG90eXBlO1xuXG52YXIgJFJlZ0V4cFN0cmluZ0l0ZXJhdG9yID0gZnVuY3Rpb24gKHJlZ2V4cCwgc3RyaW5nKSB7XG4gIHRoaXMuX3IgPSByZWdleHA7XG4gIHRoaXMuX3MgPSBzdHJpbmc7XG59O1xuXG5yZXF1aXJlKCcuL19pdGVyLWNyZWF0ZScpKCRSZWdFeHBTdHJpbmdJdGVyYXRvciwgJ1JlZ0V4cCBTdHJpbmcnLCBmdW5jdGlvbiBuZXh0KCkge1xuICB2YXIgbWF0Y2ggPSB0aGlzLl9yLmV4ZWModGhpcy5fcyk7XG4gIHJldHVybiB7IHZhbHVlOiBtYXRjaCwgZG9uZTogbWF0Y2ggPT09IG51bGwgfTtcbn0pO1xuXG4kZXhwb3J0KCRleHBvcnQuUCwgJ1N0cmluZycsIHtcbiAgbWF0Y2hBbGw6IGZ1bmN0aW9uIG1hdGNoQWxsKHJlZ2V4cCkge1xuICAgIGRlZmluZWQodGhpcyk7XG4gICAgaWYgKCFpc1JlZ0V4cChyZWdleHApKSB0aHJvdyBUeXBlRXJyb3IocmVnZXhwICsgJyBpcyBub3QgYSByZWdleHAhJyk7XG4gICAgdmFyIFMgPSBTdHJpbmcodGhpcyk7XG4gICAgdmFyIGZsYWdzID0gJ2ZsYWdzJyBpbiBSZWdFeHBQcm90byA/IFN0cmluZyhyZWdleHAuZmxhZ3MpIDogZ2V0RmxhZ3MuY2FsbChyZWdleHApO1xuICAgIHZhciByeCA9IG5ldyBSZWdFeHAocmVnZXhwLnNvdXJjZSwgfmZsYWdzLmluZGV4T2YoJ2cnKSA/IGZsYWdzIDogJ2cnICsgZmxhZ3MpO1xuICAgIHJ4Lmxhc3RJbmRleCA9IHRvTGVuZ3RoKHJlZ2V4cC5sYXN0SW5kZXgpO1xuICAgIHJldHVybiBuZXcgJFJlZ0V4cFN0cmluZ0l0ZXJhdG9yKHJ4LCBTKTtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG4vLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1zdHJpbmctcGFkLXN0YXJ0LWVuZFxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkcGFkID0gcmVxdWlyZSgnLi9fc3RyaW5nLXBhZCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCwgJ1N0cmluZycsIHtcbiAgcGFkRW5kOiBmdW5jdGlvbiBwYWRFbmQobWF4TGVuZ3RoIC8qICwgZmlsbFN0cmluZyA9ICcgJyAqLykge1xuICAgIHJldHVybiAkcGFkKHRoaXMsIG1heExlbmd0aCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQsIGZhbHNlKTtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG4vLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1zdHJpbmctcGFkLXN0YXJ0LWVuZFxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkcGFkID0gcmVxdWlyZSgnLi9fc3RyaW5nLXBhZCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCwgJ1N0cmluZycsIHtcbiAgcGFkU3RhcnQ6IGZ1bmN0aW9uIHBhZFN0YXJ0KG1heExlbmd0aCAvKiAsIGZpbGxTdHJpbmcgPSAnICcgKi8pIHtcbiAgICByZXR1cm4gJHBhZCh0aGlzLCBtYXhMZW5ndGgsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkLCB0cnVlKTtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG4vLyBodHRwczovL2dpdGh1Yi5jb20vc2VibWFya2JhZ2UvZWNtYXNjcmlwdC1zdHJpbmctbGVmdC1yaWdodC10cmltXG5yZXF1aXJlKCcuL19zdHJpbmctdHJpbScpKCd0cmltTGVmdCcsIGZ1bmN0aW9uICgkdHJpbSkge1xuICByZXR1cm4gZnVuY3Rpb24gdHJpbUxlZnQoKSB7XG4gICAgcmV0dXJuICR0cmltKHRoaXMsIDEpO1xuICB9O1xufSwgJ3RyaW1TdGFydCcpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3NlYm1hcmtiYWdlL2VjbWFzY3JpcHQtc3RyaW5nLWxlZnQtcmlnaHQtdHJpbVxucmVxdWlyZSgnLi9fc3RyaW5nLXRyaW0nKSgndHJpbVJpZ2h0JywgZnVuY3Rpb24gKCR0cmltKSB7XG4gIHJldHVybiBmdW5jdGlvbiB0cmltUmlnaHQoKSB7XG4gICAgcmV0dXJuICR0cmltKHRoaXMsIDIpO1xuICB9O1xufSwgJ3RyaW1FbmQnKTtcbiIsInJlcXVpcmUoJy4vX3drcy1kZWZpbmUnKSgnYXN5bmNJdGVyYXRvcicpO1xuIiwicmVxdWlyZSgnLi9fd2tzLWRlZmluZScpKCdvYnNlcnZhYmxlJyk7XG4iLCIvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1nbG9iYWxcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnU3lzdGVtJywgeyBnbG9iYWw6IHJlcXVpcmUoJy4vX2dsb2JhbCcpIH0pO1xuIiwiLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9wcm9wb3NhbC1zZXRtYXAtb2Zmcm9tLyNzZWMtd2Vha21hcC5mcm9tXG5yZXF1aXJlKCcuL19zZXQtY29sbGVjdGlvbi1mcm9tJykoJ1dlYWtNYXAnKTtcbiIsIi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vcHJvcG9zYWwtc2V0bWFwLW9mZnJvbS8jc2VjLXdlYWttYXAub2ZcbnJlcXVpcmUoJy4vX3NldC1jb2xsZWN0aW9uLW9mJykoJ1dlYWtNYXAnKTtcbiIsIi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vcHJvcG9zYWwtc2V0bWFwLW9mZnJvbS8jc2VjLXdlYWtzZXQuZnJvbVxucmVxdWlyZSgnLi9fc2V0LWNvbGxlY3Rpb24tZnJvbScpKCdXZWFrU2V0Jyk7XG4iLCIvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL3Byb3Bvc2FsLXNldG1hcC1vZmZyb20vI3NlYy13ZWFrc2V0Lm9mXG5yZXF1aXJlKCcuL19zZXQtY29sbGVjdGlvbi1vZicpKCdXZWFrU2V0Jyk7XG4iLCJ2YXIgJGl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vZXM2LmFycmF5Lml0ZXJhdG9yJyk7XG52YXIgZ2V0S2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuL19yZWRlZmluZScpO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG52YXIgd2tzID0gcmVxdWlyZSgnLi9fd2tzJyk7XG52YXIgSVRFUkFUT1IgPSB3a3MoJ2l0ZXJhdG9yJyk7XG52YXIgVE9fU1RSSU5HX1RBRyA9IHdrcygndG9TdHJpbmdUYWcnKTtcbnZhciBBcnJheVZhbHVlcyA9IEl0ZXJhdG9ycy5BcnJheTtcblxudmFyIERPTUl0ZXJhYmxlcyA9IHtcbiAgQ1NTUnVsZUxpc3Q6IHRydWUsIC8vIFRPRE86IE5vdCBzcGVjIGNvbXBsaWFudCwgc2hvdWxkIGJlIGZhbHNlLlxuICBDU1NTdHlsZURlY2xhcmF0aW9uOiBmYWxzZSxcbiAgQ1NTVmFsdWVMaXN0OiBmYWxzZSxcbiAgQ2xpZW50UmVjdExpc3Q6IGZhbHNlLFxuICBET01SZWN0TGlzdDogZmFsc2UsXG4gIERPTVN0cmluZ0xpc3Q6IGZhbHNlLFxuICBET01Ub2tlbkxpc3Q6IHRydWUsXG4gIERhdGFUcmFuc2Zlckl0ZW1MaXN0OiBmYWxzZSxcbiAgRmlsZUxpc3Q6IGZhbHNlLFxuICBIVE1MQWxsQ29sbGVjdGlvbjogZmFsc2UsXG4gIEhUTUxDb2xsZWN0aW9uOiBmYWxzZSxcbiAgSFRNTEZvcm1FbGVtZW50OiBmYWxzZSxcbiAgSFRNTFNlbGVjdEVsZW1lbnQ6IGZhbHNlLFxuICBNZWRpYUxpc3Q6IHRydWUsIC8vIFRPRE86IE5vdCBzcGVjIGNvbXBsaWFudCwgc2hvdWxkIGJlIGZhbHNlLlxuICBNaW1lVHlwZUFycmF5OiBmYWxzZSxcbiAgTmFtZWROb2RlTWFwOiBmYWxzZSxcbiAgTm9kZUxpc3Q6IHRydWUsXG4gIFBhaW50UmVxdWVzdExpc3Q6IGZhbHNlLFxuICBQbHVnaW46IGZhbHNlLFxuICBQbHVnaW5BcnJheTogZmFsc2UsXG4gIFNWR0xlbmd0aExpc3Q6IGZhbHNlLFxuICBTVkdOdW1iZXJMaXN0OiBmYWxzZSxcbiAgU1ZHUGF0aFNlZ0xpc3Q6IGZhbHNlLFxuICBTVkdQb2ludExpc3Q6IGZhbHNlLFxuICBTVkdTdHJpbmdMaXN0OiBmYWxzZSxcbiAgU1ZHVHJhbnNmb3JtTGlzdDogZmFsc2UsXG4gIFNvdXJjZUJ1ZmZlckxpc3Q6IGZhbHNlLFxuICBTdHlsZVNoZWV0TGlzdDogdHJ1ZSwgLy8gVE9ETzogTm90IHNwZWMgY29tcGxpYW50LCBzaG91bGQgYmUgZmFsc2UuXG4gIFRleHRUcmFja0N1ZUxpc3Q6IGZhbHNlLFxuICBUZXh0VHJhY2tMaXN0OiBmYWxzZSxcbiAgVG91Y2hMaXN0OiBmYWxzZVxufTtcblxuZm9yICh2YXIgY29sbGVjdGlvbnMgPSBnZXRLZXlzKERPTUl0ZXJhYmxlcyksIGkgPSAwOyBpIDwgY29sbGVjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgdmFyIE5BTUUgPSBjb2xsZWN0aW9uc1tpXTtcbiAgdmFyIGV4cGxpY2l0ID0gRE9NSXRlcmFibGVzW05BTUVdO1xuICB2YXIgQ29sbGVjdGlvbiA9IGdsb2JhbFtOQU1FXTtcbiAgdmFyIHByb3RvID0gQ29sbGVjdGlvbiAmJiBDb2xsZWN0aW9uLnByb3RvdHlwZTtcbiAgdmFyIGtleTtcbiAgaWYgKHByb3RvKSB7XG4gICAgaWYgKCFwcm90b1tJVEVSQVRPUl0pIGhpZGUocHJvdG8sIElURVJBVE9SLCBBcnJheVZhbHVlcyk7XG4gICAgaWYgKCFwcm90b1tUT19TVFJJTkdfVEFHXSkgaGlkZShwcm90bywgVE9fU1RSSU5HX1RBRywgTkFNRSk7XG4gICAgSXRlcmF0b3JzW05BTUVdID0gQXJyYXlWYWx1ZXM7XG4gICAgaWYgKGV4cGxpY2l0KSBmb3IgKGtleSBpbiAkaXRlcmF0b3JzKSBpZiAoIXByb3RvW2tleV0pIHJlZGVmaW5lKHByb3RvLCBrZXksICRpdGVyYXRvcnNba2V5XSwgdHJ1ZSk7XG4gIH1cbn1cbiIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJHRhc2sgPSByZXF1aXJlKCcuL190YXNrJyk7XG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuQiwge1xuICBzZXRJbW1lZGlhdGU6ICR0YXNrLnNldCxcbiAgY2xlYXJJbW1lZGlhdGU6ICR0YXNrLmNsZWFyXG59KTtcbiIsIi8vIGllOS0gc2V0VGltZW91dCAmIHNldEludGVydmFsIGFkZGl0aW9uYWwgcGFyYW1ldGVycyBmaXhcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgbmF2aWdhdG9yID0gZ2xvYmFsLm5hdmlnYXRvcjtcbnZhciBzbGljZSA9IFtdLnNsaWNlO1xudmFyIE1TSUUgPSAhIW5hdmlnYXRvciAmJiAvTVNJRSAuXFwuLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpOyAvLyA8LSBkaXJ0eSBpZTktIGNoZWNrXG52YXIgd3JhcCA9IGZ1bmN0aW9uIChzZXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChmbiwgdGltZSAvKiAsIC4uLmFyZ3MgKi8pIHtcbiAgICB2YXIgYm91bmRBcmdzID0gYXJndW1lbnRzLmxlbmd0aCA+IDI7XG4gICAgdmFyIGFyZ3MgPSBib3VuZEFyZ3MgPyBzbGljZS5jYWxsKGFyZ3VtZW50cywgMikgOiBmYWxzZTtcbiAgICByZXR1cm4gc2V0KGJvdW5kQXJncyA/IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuY1xuICAgICAgKHR5cGVvZiBmbiA9PSAnZnVuY3Rpb24nID8gZm4gOiBGdW5jdGlvbihmbikpLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH0gOiBmbiwgdGltZSk7XG4gIH07XG59O1xuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LkIgKyAkZXhwb3J0LkYgKiBNU0lFLCB7XG4gIHNldFRpbWVvdXQ6IHdyYXAoZ2xvYmFsLnNldFRpbWVvdXQpLFxuICBzZXRJbnRlcnZhbDogd3JhcChnbG9iYWwuc2V0SW50ZXJ2YWwpXG59KTtcbiIsInJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3ltYm9sJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5jcmVhdGUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmRlZmluZS1wcm9wZXJ0eScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuZGVmaW5lLXByb3BlcnRpZXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LXByb3RvdHlwZS1vZicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3Qua2V5cycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1uYW1lcycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuZnJlZXplJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5zZWFsJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5wcmV2ZW50LWV4dGVuc2lvbnMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmlzLWZyb3plbicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuaXMtc2VhbGVkJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5pcy1leHRlbnNpYmxlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5hc3NpZ24nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmlzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5zZXQtcHJvdG90eXBlLW9mJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC50by1zdHJpbmcnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuZnVuY3Rpb24uYmluZCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5mdW5jdGlvbi5uYW1lJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmZ1bmN0aW9uLmhhcy1pbnN0YW5jZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5wYXJzZS1pbnQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucGFyc2UtZmxvYXQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLmNvbnN0cnVjdG9yJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci50by1maXhlZCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIudG8tcHJlY2lzaW9uJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci5lcHNpbG9uJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci5pcy1maW5pdGUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLmlzLWludGVnZXInKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLmlzLW5hbicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIuaXMtc2FmZS1pbnRlZ2VyJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci5tYXgtc2FmZS1pbnRlZ2VyJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci5taW4tc2FmZS1pbnRlZ2VyJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci5wYXJzZS1mbG9hdCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIucGFyc2UtaW50Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGguYWNvc2gnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5hc2luaCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmF0YW5oJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGguY2JydCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmNsejMyJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGguY29zaCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmV4cG0xJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGguZnJvdW5kJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGguaHlwb3QnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5pbXVsJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGgubG9nMTAnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5sb2cxcCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmxvZzInKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5zaWduJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGguc2luaCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLnRhbmgnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC50cnVuYycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuZnJvbS1jb2RlLXBvaW50Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5yYXcnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLnRyaW0nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5jb2RlLXBvaW50LWF0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5lbmRzLXdpdGgnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmluY2x1ZGVzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5yZXBlYXQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLnN0YXJ0cy13aXRoJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5hbmNob3InKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmJpZycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuYmxpbmsnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmJvbGQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmZpeGVkJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5mb250Y29sb3InKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmZvbnRzaXplJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5pdGFsaWNzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5saW5rJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5zbWFsbCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuc3RyaWtlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5zdWInKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLnN1cCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5kYXRlLm5vdycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5kYXRlLnRvLWpzb24nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuZGF0ZS50by1pc28tc3RyaW5nJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmRhdGUudG8tc3RyaW5nJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmRhdGUudG8tcHJpbWl0aXZlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LmlzLWFycmF5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LmZyb20nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkub2YnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuam9pbicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5zbGljZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5zb3J0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LmZvci1lYWNoJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5Lm1hcCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5maWx0ZXInKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuc29tZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5ldmVyeScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5yZWR1Y2UnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkucmVkdWNlLXJpZ2h0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LmluZGV4LW9mJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5Lmxhc3QtaW5kZXgtb2YnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuY29weS13aXRoaW4nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuZmlsbCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5maW5kJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LmZpbmQtaW5kZXgnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuc3BlY2llcycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5pdGVyYXRvcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWdleHAuY29uc3RydWN0b3InKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVnZXhwLnRvLXN0cmluZycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWdleHAuZmxhZ3MnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVnZXhwLm1hdGNoJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZ2V4cC5yZXBsYWNlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZ2V4cC5zZWFyY2gnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVnZXhwLnNwbGl0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnByb21pc2UnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWFwJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnNldCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi53ZWFrLW1hcCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi53ZWFrLXNldCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi50eXBlZC5hcnJheS1idWZmZXInKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYudHlwZWQuZGF0YS12aWV3Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnR5cGVkLmludDgtYXJyYXknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYudHlwZWQudWludDgtYXJyYXknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYudHlwZWQudWludDgtY2xhbXBlZC1hcnJheScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi50eXBlZC5pbnQxNi1hcnJheScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi50eXBlZC51aW50MTYtYXJyYXknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYudHlwZWQuaW50MzItYXJyYXknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYudHlwZWQudWludDMyLWFycmF5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnR5cGVkLmZsb2F0MzItYXJyYXknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYudHlwZWQuZmxvYXQ2NC1hcnJheScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LmFwcGx5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3QuY29uc3RydWN0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3QuZGVmaW5lLXByb3BlcnR5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3QuZGVsZXRlLXByb3BlcnR5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3QuZW51bWVyYXRlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3QuZ2V0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3QuZ2V0LXByb3RvdHlwZS1vZicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LmhhcycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LmlzLWV4dGVuc2libGUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5vd24ta2V5cycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LnByZXZlbnQtZXh0ZW5zaW9ucycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LnNldCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LnNldC1wcm90b3R5cGUtb2YnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuYXJyYXkuaW5jbHVkZXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuYXJyYXkuZmxhdC1tYXAnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuYXJyYXkuZmxhdHRlbicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5zdHJpbmcuYXQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuc3RyaW5nLnBhZC1zdGFydCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5zdHJpbmcucGFkLWVuZCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5zdHJpbmcudHJpbS1sZWZ0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnN0cmluZy50cmltLXJpZ2h0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnN0cmluZy5tYXRjaC1hbGwnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuc3ltYm9sLmFzeW5jLWl0ZXJhdG9yJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnN5bWJvbC5vYnNlcnZhYmxlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3JzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm9iamVjdC52YWx1ZXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcub2JqZWN0LmVudHJpZXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcub2JqZWN0LmRlZmluZS1nZXR0ZXInKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcub2JqZWN0LmRlZmluZS1zZXR0ZXInKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcub2JqZWN0Lmxvb2t1cC1nZXR0ZXInKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcub2JqZWN0Lmxvb2t1cC1zZXR0ZXInKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcubWFwLnRvLWpzb24nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuc2V0LnRvLWpzb24nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcubWFwLm9mJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnNldC5vZicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy53ZWFrLW1hcC5vZicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy53ZWFrLXNldC5vZicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5tYXAuZnJvbScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5zZXQuZnJvbScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy53ZWFrLW1hcC5mcm9tJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LndlYWstc2V0LmZyb20nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuZ2xvYmFsJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnN5c3RlbS5nbG9iYWwnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuZXJyb3IuaXMtZXJyb3InKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcubWF0aC5jbGFtcCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5tYXRoLmRlZy1wZXItcmFkJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm1hdGguZGVncmVlcycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5tYXRoLmZzY2FsZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5tYXRoLmlhZGRoJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm1hdGguaXN1YmgnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcubWF0aC5pbXVsaCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5tYXRoLnJhZC1wZXItZGVnJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm1hdGgucmFkaWFucycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5tYXRoLnNjYWxlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm1hdGgudW11bGgnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcubWF0aC5zaWduYml0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnByb21pc2UuZmluYWxseScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5wcm9taXNlLnRyeScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5yZWZsZWN0LmRlZmluZS1tZXRhZGF0YScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5yZWZsZWN0LmRlbGV0ZS1tZXRhZGF0YScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5yZWZsZWN0LmdldC1tZXRhZGF0YScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5yZWZsZWN0LmdldC1tZXRhZGF0YS1rZXlzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnJlZmxlY3QuZ2V0LW93bi1tZXRhZGF0YScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5yZWZsZWN0LmdldC1vd24tbWV0YWRhdGEta2V5cycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5yZWZsZWN0Lmhhcy1tZXRhZGF0YScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5yZWZsZWN0Lmhhcy1vd24tbWV0YWRhdGEnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcucmVmbGVjdC5tZXRhZGF0YScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5hc2FwJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm9ic2VydmFibGUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy93ZWIudGltZXJzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvd2ViLmltbWVkaWF0ZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9tb2R1bGVzL19jb3JlJyk7XG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzWydkZWZhdWx0J10gPSBjYW1lbGl6ZTtcbnZhciByZWdFeHAgPSAvWy1cXHNdKyguKT8vZztcblxuLyoqXG4gKiBDb252ZXJ0IGRhc2ggc2VwYXJhdGVkIHN0cmluZ3MgdG8gY2FtZWwgY2FzZWQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5mdW5jdGlvbiBjYW1lbGl6ZShzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKHJlZ0V4cCwgdG9VcHBlcik7XG59XG5cbmZ1bmN0aW9uIHRvVXBwZXIobWF0Y2gsIGMpIHtcbiAgcmV0dXJuIGMgPyBjLnRvVXBwZXJDYXNlKCkgOiAnJztcbn0iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnN1cHBvcnRlZFZhbHVlID0gZXhwb3J0cy5zdXBwb3J0ZWRQcm9wZXJ0eSA9IGV4cG9ydHMucHJlZml4ID0gdW5kZWZpbmVkO1xuXG52YXIgX3ByZWZpeCA9IHJlcXVpcmUoJy4vcHJlZml4Jyk7XG5cbnZhciBfcHJlZml4MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3ByZWZpeCk7XG5cbnZhciBfc3VwcG9ydGVkUHJvcGVydHkgPSByZXF1aXJlKCcuL3N1cHBvcnRlZC1wcm9wZXJ0eScpO1xuXG52YXIgX3N1cHBvcnRlZFByb3BlcnR5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3N1cHBvcnRlZFByb3BlcnR5KTtcblxudmFyIF9zdXBwb3J0ZWRWYWx1ZSA9IHJlcXVpcmUoJy4vc3VwcG9ydGVkLXZhbHVlJyk7XG5cbnZhciBfc3VwcG9ydGVkVmFsdWUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3VwcG9ydGVkVmFsdWUpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IHtcbiAgcHJlZml4OiBfcHJlZml4MlsnZGVmYXVsdCddLFxuICBzdXBwb3J0ZWRQcm9wZXJ0eTogX3N1cHBvcnRlZFByb3BlcnR5MlsnZGVmYXVsdCddLFxuICBzdXBwb3J0ZWRWYWx1ZTogX3N1cHBvcnRlZFZhbHVlMlsnZGVmYXVsdCddXG59OyAvKipcbiAgICAqIENTUyBWZW5kb3IgcHJlZml4IGRldGVjdGlvbiBhbmQgcHJvcGVydHkgZmVhdHVyZSB0ZXN0aW5nLlxuICAgICpcbiAgICAqIEBjb3B5cmlnaHQgT2xlZyBTbG9ib2Rza29pIDIwMTVcbiAgICAqIEB3ZWJzaXRlIGh0dHBzOi8vZ2l0aHViLmNvbS9qc3N0eWxlcy9jc3MtdmVuZG9yXG4gICAgKiBAbGljZW5zZSBNSVRcbiAgICAqL1xuXG5leHBvcnRzLnByZWZpeCA9IF9wcmVmaXgyWydkZWZhdWx0J107XG5leHBvcnRzLnN1cHBvcnRlZFByb3BlcnR5ID0gX3N1cHBvcnRlZFByb3BlcnR5MlsnZGVmYXVsdCddO1xuZXhwb3J0cy5zdXBwb3J0ZWRWYWx1ZSA9IF9zdXBwb3J0ZWRWYWx1ZTJbJ2RlZmF1bHQnXTsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfaXNJbkJyb3dzZXIgPSByZXF1aXJlKCdpcy1pbi1icm93c2VyJyk7XG5cbnZhciBfaXNJbkJyb3dzZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaXNJbkJyb3dzZXIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBqcyA9ICcnOyAvKipcbiAgICAgICAgICAgICAgKiBFeHBvcnQgamF2YXNjcmlwdCBzdHlsZSBhbmQgY3NzIHN0eWxlIHZlbmRvciBwcmVmaXhlcy5cbiAgICAgICAgICAgICAgKiBCYXNlZCBvbiBcInRyYW5zZm9ybVwiIHN1cHBvcnQgdGVzdC5cbiAgICAgICAgICAgICAgKi9cblxudmFyIGNzcyA9ICcnO1xuXG4vLyBXZSBzaG91bGQgbm90IGRvIGFueXRoaW5nIGlmIHJlcXVpcmVkIHNlcnZlcnNpZGUuXG5pZiAoX2lzSW5Ccm93c2VyMlsnZGVmYXVsdCddKSB7XG4gIC8vIE9yZGVyIG1hdHRlcnMuIFdlIG5lZWQgdG8gY2hlY2sgV2Via2l0IHRoZSBsYXN0IG9uZSBiZWNhdXNlXG4gIC8vIG90aGVyIHZlbmRvcnMgdXNlIHRvIGFkZCBXZWJraXQgcHJlZml4ZXMgdG8gc29tZSBwcm9wZXJ0aWVzXG4gIHZhciBqc0Nzc01hcCA9IHtcbiAgICBNb3o6ICctbW96LScsXG4gICAgLy8gSUUgZGlkIGl0IHdyb25nIGFnYWluIC4uLlxuICAgIG1zOiAnLW1zLScsXG4gICAgTzogJy1vLScsXG4gICAgV2Via2l0OiAnLXdlYmtpdC0nXG4gIH07XG4gIHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3AnKS5zdHlsZTtcbiAgdmFyIHRlc3RQcm9wID0gJ1RyYW5zZm9ybSc7XG5cbiAgZm9yICh2YXIga2V5IGluIGpzQ3NzTWFwKSB7XG4gICAgaWYgKGtleSArIHRlc3RQcm9wIGluIHN0eWxlKSB7XG4gICAgICBqcyA9IGtleTtcbiAgICAgIGNzcyA9IGpzQ3NzTWFwW2tleV07XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBWZW5kb3IgcHJlZml4IHN0cmluZyBmb3IgdGhlIGN1cnJlbnQgYnJvd3Nlci5cbiAqXG4gKiBAdHlwZSB7e2pzOiBTdHJpbmcsIGNzczogU3RyaW5nfX1cbiAqIEBhcGkgcHVibGljXG4gKi9cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IHsganM6IGpzLCBjc3M6IGNzcyB9OyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IHN1cHBvcnRlZFByb3BlcnR5O1xuXG52YXIgX2lzSW5Ccm93c2VyID0gcmVxdWlyZSgnaXMtaW4tYnJvd3NlcicpO1xuXG52YXIgX2lzSW5Ccm93c2VyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2lzSW5Ccm93c2VyKTtcblxudmFyIF9wcmVmaXggPSByZXF1aXJlKCcuL3ByZWZpeCcpO1xuXG52YXIgX3ByZWZpeDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wcmVmaXgpO1xuXG52YXIgX2NhbWVsaXplID0gcmVxdWlyZSgnLi9jYW1lbGl6ZScpO1xuXG52YXIgX2NhbWVsaXplMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NhbWVsaXplKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgZWwgPSB2b2lkIDA7XG52YXIgY2FjaGUgPSB7fTtcblxuaWYgKF9pc0luQnJvd3NlcjJbJ2RlZmF1bHQnXSkge1xuICBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3AnKTtcblxuICAvKipcbiAgICogV2UgdGVzdCBldmVyeSBwcm9wZXJ0eSBvbiB2ZW5kb3IgcHJlZml4IHJlcXVpcmVtZW50LlxuICAgKiBPbmNlIHRlc3RlZCwgcmVzdWx0IGlzIGNhY2hlZC4gSXQgZ2l2ZXMgdXMgdXAgdG8gNzAlIHBlcmYgYm9vc3QuXG4gICAqIGh0dHA6Ly9qc3BlcmYuY29tL2VsZW1lbnQtc3R5bGUtb2JqZWN0LWFjY2Vzcy12cy1wbGFpbi1vYmplY3RcbiAgICpcbiAgICogUHJlZmlsbCBjYWNoZSB3aXRoIGtub3duIGNzcyBwcm9wZXJ0aWVzIHRvIHJlZHVjZSBhbW91bnQgb2ZcbiAgICogcHJvcGVydGllcyB3ZSBuZWVkIHRvIGZlYXR1cmUgdGVzdCBhdCBydW50aW1lLlxuICAgKiBodHRwOi8vZGF2aWR3YWxzaC5uYW1lL3ZlbmRvci1wcmVmaXhcbiAgICovXG4gIHZhciBjb21wdXRlZCA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgJycpO1xuICBmb3IgKHZhciBrZXkgaW4gY29tcHV0ZWQpIHtcbiAgICBpZiAoIWlzTmFOKGtleSkpIGNhY2hlW2NvbXB1dGVkW2tleV1dID0gY29tcHV0ZWRba2V5XTtcbiAgfVxufVxuXG4vKipcbiAqIFRlc3QgaWYgYSBwcm9wZXJ0eSBpcyBzdXBwb3J0ZWQsIHJldHVybnMgc3VwcG9ydGVkIHByb3BlcnR5IHdpdGggdmVuZG9yXG4gKiBwcmVmaXggaWYgcmVxdWlyZWQuIFJldHVybnMgYGZhbHNlYCBpZiBub3Qgc3VwcG9ydGVkLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wIGRhc2ggc2VwYXJhdGVkXG4gKiBAcmV0dXJuIHtTdHJpbmd8Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIHN1cHBvcnRlZFByb3BlcnR5KHByb3ApIHtcbiAgLy8gRm9yIHNlcnZlci1zaWRlIHJlbmRlcmluZy5cbiAgaWYgKCFlbCkgcmV0dXJuIHByb3A7XG5cbiAgLy8gV2UgaGF2ZSBub3QgdGVzdGVkIHRoaXMgcHJvcCB5ZXQsIGxldHMgZG8gdGhlIHRlc3QuXG4gIGlmIChjYWNoZVtwcm9wXSAhPSBudWxsKSByZXR1cm4gY2FjaGVbcHJvcF07XG5cbiAgLy8gQ2FtZWxpemF0aW9uIGlzIHJlcXVpcmVkIGJlY2F1c2Ugd2UgY2FuJ3QgdGVzdCB1c2luZ1xuICAvLyBjc3Mgc3ludGF4IGZvciBlLmcuIGluIEZGLlxuICAvLyBUZXN0IGlmIHByb3BlcnR5IGlzIHN1cHBvcnRlZCBhcyBpdCBpcy5cbiAgaWYgKCgwLCBfY2FtZWxpemUyWydkZWZhdWx0J10pKHByb3ApIGluIGVsLnN0eWxlKSB7XG4gICAgY2FjaGVbcHJvcF0gPSBwcm9wO1xuICB9XG4gIC8vIFRlc3QgaWYgcHJvcGVydHkgaXMgc3VwcG9ydGVkIHdpdGggdmVuZG9yIHByZWZpeC5cbiAgZWxzZSBpZiAoX3ByZWZpeDJbJ2RlZmF1bHQnXS5qcyArICgwLCBfY2FtZWxpemUyWydkZWZhdWx0J10pKCctJyArIHByb3ApIGluIGVsLnN0eWxlKSB7XG4gICAgICBjYWNoZVtwcm9wXSA9IF9wcmVmaXgyWydkZWZhdWx0J10uY3NzICsgcHJvcDtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FjaGVbcHJvcF0gPSBmYWxzZTtcbiAgICB9XG5cbiAgcmV0dXJuIGNhY2hlW3Byb3BdO1xufSIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IHN1cHBvcnRlZFZhbHVlO1xuXG52YXIgX2lzSW5Ccm93c2VyID0gcmVxdWlyZSgnaXMtaW4tYnJvd3NlcicpO1xuXG52YXIgX2lzSW5Ccm93c2VyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2lzSW5Ccm93c2VyKTtcblxudmFyIF9wcmVmaXggPSByZXF1aXJlKCcuL3ByZWZpeCcpO1xuXG52YXIgX3ByZWZpeDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wcmVmaXgpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBjYWNoZSA9IHt9O1xudmFyIGVsID0gdm9pZCAwO1xuXG5pZiAoX2lzSW5Ccm93c2VyMlsnZGVmYXVsdCddKSBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3AnKTtcblxuLyoqXG4gKiBSZXR1cm5zIHByZWZpeGVkIHZhbHVlIGlmIG5lZWRlZC4gUmV0dXJucyBgZmFsc2VgIGlmIHZhbHVlIGlzIG5vdCBzdXBwb3J0ZWQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5XG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAqIEByZXR1cm4ge1N0cmluZ3xCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gc3VwcG9ydGVkVmFsdWUocHJvcGVydHksIHZhbHVlKSB7XG4gIC8vIEZvciBzZXJ2ZXItc2lkZSByZW5kZXJpbmcuXG4gIGlmICghZWwpIHJldHVybiB2YWx1ZTtcblxuICAvLyBJdCBpcyBhIHN0cmluZyBvciBhIG51bWJlciBhcyBhIHN0cmluZyBsaWtlICcxJy5cbiAgLy8gV2Ugd2FudCBvbmx5IHByZWZpeGFibGUgdmFsdWVzIGhlcmUuXG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnIHx8ICFpc05hTihwYXJzZUludCh2YWx1ZSwgMTApKSkgcmV0dXJuIHZhbHVlO1xuXG4gIHZhciBjYWNoZUtleSA9IHByb3BlcnR5ICsgdmFsdWU7XG5cbiAgaWYgKGNhY2hlW2NhY2hlS2V5XSAhPSBudWxsKSByZXR1cm4gY2FjaGVbY2FjaGVLZXldO1xuXG4gIC8vIElFIGNhbiBldmVuIHRocm93IGFuIGVycm9yIGluIHNvbWUgY2FzZXMsIGZvciBlLmcuIHN0eWxlLmNvbnRlbnQgPSAnYmFyJ1xuICB0cnkge1xuICAgIC8vIFRlc3QgdmFsdWUgYXMgaXQgaXMuXG4gICAgZWwuc3R5bGVbcHJvcGVydHldID0gdmFsdWU7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNhY2hlW2NhY2hlS2V5XSA9IGZhbHNlO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIFZhbHVlIGlzIHN1cHBvcnRlZCBhcyBpdCBpcy5cbiAgaWYgKGVsLnN0eWxlW3Byb3BlcnR5XSAhPT0gJycpIHtcbiAgICBjYWNoZVtjYWNoZUtleV0gPSB2YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBUZXN0IHZhbHVlIHdpdGggdmVuZG9yIHByZWZpeC5cbiAgICB2YWx1ZSA9IF9wcmVmaXgyWydkZWZhdWx0J10uY3NzICsgdmFsdWU7XG5cbiAgICAvLyBIYXJkY29kZSB0ZXN0IHRvIGNvbnZlcnQgXCJmbGV4XCIgdG8gXCItbXMtZmxleGJveFwiIGZvciBJRTEwLlxuICAgIGlmICh2YWx1ZSA9PT0gJy1tcy1mbGV4JykgdmFsdWUgPSAnLW1zLWZsZXhib3gnO1xuXG4gICAgZWwuc3R5bGVbcHJvcGVydHldID0gdmFsdWU7XG5cbiAgICAvLyBWYWx1ZSBpcyBzdXBwb3J0ZWQgd2l0aCB2ZW5kb3IgcHJlZml4LlxuICAgIGlmIChlbC5zdHlsZVtwcm9wZXJ0eV0gIT09ICcnKSBjYWNoZVtjYWNoZUtleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIGlmICghY2FjaGVbY2FjaGVLZXldKSBjYWNoZVtjYWNoZUtleV0gPSBmYWxzZTtcblxuICAvLyBSZXNldCBzdHlsZSB2YWx1ZS5cbiAgZWwuc3R5bGVbcHJvcGVydHldID0gJyc7XG5cbiAgcmV0dXJuIGNhY2hlW2NhY2hlS2V5XTtcbn0iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xudmFyIGlzVmFsaWRTdHJpbmcgPSBmdW5jdGlvbiBpc1ZhbGlkU3RyaW5nKHBhcmFtKSB7XG4gIHJldHVybiB0eXBlb2YgcGFyYW0gPT09ICdzdHJpbmcnICYmIHBhcmFtLmxlbmd0aCA+IDA7XG59O1xuXG52YXIgc3RhcnRzV2l0aCA9IGZ1bmN0aW9uIHN0YXJ0c1dpdGgoc3RyaW5nLCBzdGFydCkge1xuICByZXR1cm4gc3RyaW5nWzBdID09PSBzdGFydDtcbn07XG5cbnZhciBpc1NlbGVjdG9yID0gZnVuY3Rpb24gaXNTZWxlY3RvcihwYXJhbSkge1xuICByZXR1cm4gaXNWYWxpZFN0cmluZyhwYXJhbSkgJiYgKHN0YXJ0c1dpdGgocGFyYW0sICcuJykgfHwgc3RhcnRzV2l0aChwYXJhbSwgJyMnKSk7XG59O1xuXG52YXIgbm9kZSA9IGZ1bmN0aW9uIG5vZGUoaCkge1xuICByZXR1cm4gZnVuY3Rpb24gKHRhZ05hbWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGZpcnN0KSB7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcmVzdCA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgcmVzdFtfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIGlmIChpc1NlbGVjdG9yKGZpcnN0KSkge1xuICAgICAgICByZXR1cm4gaC5hcHBseSh1bmRlZmluZWQsIFt0YWdOYW1lICsgZmlyc3RdLmNvbmNhdChyZXN0KSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBmaXJzdCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIGgodGFnTmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gaC5hcHBseSh1bmRlZmluZWQsIFt0YWdOYW1lLCBmaXJzdF0uY29uY2F0KHJlc3QpKTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xufTtcblxudmFyIFRBR19OQU1FUyA9IFsnYScsICdhYmJyJywgJ2Fjcm9ueW0nLCAnYWRkcmVzcycsICdhcHBsZXQnLCAnYXJlYScsICdhcnRpY2xlJywgJ2FzaWRlJywgJ2F1ZGlvJywgJ2InLCAnYmFzZScsICdiYXNlZm9udCcsICdiZGknLCAnYmRvJywgJ2Jnc291bmQnLCAnYmlnJywgJ2JsaW5rJywgJ2Jsb2NrcXVvdGUnLCAnYm9keScsICdicicsICdidXR0b24nLCAnY2FudmFzJywgJ2NhcHRpb24nLCAnY2VudGVyJywgJ2NpdGUnLCAnY29kZScsICdjb2wnLCAnY29sZ3JvdXAnLCAnY29tbWFuZCcsICdjb250ZW50JywgJ2RhdGEnLCAnZGF0YWxpc3QnLCAnZGQnLCAnZGVsJywgJ2RldGFpbHMnLCAnZGZuJywgJ2RpYWxvZycsICdkaXInLCAnZGl2JywgJ2RsJywgJ2R0JywgJ2VsZW1lbnQnLCAnZW0nLCAnZW1iZWQnLCAnZmllbGRzZXQnLCAnZmlnY2FwdGlvbicsICdmaWd1cmUnLCAnZm9udCcsICdmb290ZXInLCAnZm9ybScsICdmcmFtZScsICdmcmFtZXNldCcsICdoMScsICdoMicsICdoMycsICdoNCcsICdoNScsICdoNicsICdoZWFkJywgJ2hlYWRlcicsICdoZ3JvdXAnLCAnaHInLCAnaHRtbCcsICdpJywgJ2lmcmFtZScsICdpbWFnZScsICdpbWcnLCAnaW5wdXQnLCAnaW5zJywgJ2lzaW5kZXgnLCAna2JkJywgJ2tleWdlbicsICdsYWJlbCcsICdsZWdlbmQnLCAnbGknLCAnbGluaycsICdsaXN0aW5nJywgJ21haW4nLCAnbWFwJywgJ21hcmsnLCAnbWFycXVlZScsICdtYXRoJywgJ21lbnUnLCAnbWVudWl0ZW0nLCAnbWV0YScsICdtZXRlcicsICdtdWx0aWNvbCcsICduYXYnLCAnbmV4dGlkJywgJ25vYnInLCAnbm9lbWJlZCcsICdub2ZyYW1lcycsICdub3NjcmlwdCcsICdvYmplY3QnLCAnb2wnLCAnb3B0Z3JvdXAnLCAnb3B0aW9uJywgJ291dHB1dCcsICdwJywgJ3BhcmFtJywgJ3BpY3R1cmUnLCAncGxhaW50ZXh0JywgJ3ByZScsICdwcm9ncmVzcycsICdxJywgJ3JiJywgJ3JiYycsICdycCcsICdydCcsICdydGMnLCAncnVieScsICdzJywgJ3NhbXAnLCAnc2NyaXB0JywgJ3NlY3Rpb24nLCAnc2VsZWN0JywgJ3NoYWRvdycsICdzbG90JywgJ3NtYWxsJywgJ3NvdXJjZScsICdzcGFjZXInLCAnc3BhbicsICdzdHJpa2UnLCAnc3Ryb25nJywgJ3N0eWxlJywgJ3N1YicsICdzdW1tYXJ5JywgJ3N1cCcsICdzdmcnLCAndGFibGUnLCAndGJvZHknLCAndGQnLCAndGVtcGxhdGUnLCAndGV4dGFyZWEnLCAndGZvb3QnLCAndGgnLCAndGhlYWQnLCAndGltZScsICd0aXRsZScsICd0cicsICd0cmFjaycsICd0dCcsICd1JywgJ3VsJywgJ3ZhcicsICd2aWRlbycsICd3YnInLCAneG1wJ107XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGZ1bmN0aW9uIChoKSB7XG4gIHZhciBjcmVhdGVUYWcgPSBub2RlKGgpO1xuICB2YXIgZXhwb3J0ZWQgPSB7IFRBR19OQU1FUzogVEFHX05BTUVTLCBpc1NlbGVjdG9yOiBpc1NlbGVjdG9yLCBjcmVhdGVUYWc6IGNyZWF0ZVRhZyB9O1xuICBUQUdfTkFNRVMuZm9yRWFjaChmdW5jdGlvbiAobikge1xuICAgIGV4cG9ydGVkW25dID0gY3JlYXRlVGFnKG4pO1xuICB9KTtcbiAgcmV0dXJuIGV4cG9ydGVkO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107IiwidmFyIHNwbGl0ID0gcmVxdWlyZSgnYnJvd3Nlci1zcGxpdCcpXG52YXIgQ2xhc3NMaXN0ID0gcmVxdWlyZSgnY2xhc3MtbGlzdCcpXG5cbnZhciB3ID0gdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyByZXF1aXJlKCdodG1sLWVsZW1lbnQnKSA6IHdpbmRvd1xudmFyIGRvY3VtZW50ID0gdy5kb2N1bWVudFxudmFyIFRleHQgPSB3LlRleHRcblxuZnVuY3Rpb24gY29udGV4dCAoKSB7XG5cbiAgdmFyIGNsZWFudXBGdW5jcyA9IFtdXG5cbiAgZnVuY3Rpb24gaCgpIHtcbiAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKSwgZSA9IG51bGxcbiAgICBmdW5jdGlvbiBpdGVtIChsKSB7XG4gICAgICB2YXIgclxuICAgICAgZnVuY3Rpb24gcGFyc2VDbGFzcyAoc3RyaW5nKSB7XG4gICAgICAgIC8vIE91ciBtaW5pbWFsIHBhcnNlciBkb2VzbuKAmXQgdW5kZXJzdGFuZCBlc2NhcGluZyBDU1Mgc3BlY2lhbFxuICAgICAgICAvLyBjaGFyYWN0ZXJzIGxpa2UgYCNgLiBEb27igJl0IHVzZSB0aGVtLiBNb3JlIHJlYWRpbmc6XG4gICAgICAgIC8vIGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9jc3MtZXNjYXBlcyAuXG5cbiAgICAgICAgdmFyIG0gPSBzcGxpdChzdHJpbmcsIC8oW1xcLiNdP1teXFxzIy5dKykvKVxuICAgICAgICBpZigvXlxcLnwjLy50ZXN0KG1bMV0pKVxuICAgICAgICAgIGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgICAgICBmb3JFYWNoKG0sIGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgdmFyIHMgPSB2LnN1YnN0cmluZygxLHYubGVuZ3RoKVxuICAgICAgICAgIGlmKCF2KSByZXR1cm5cbiAgICAgICAgICBpZighZSlcbiAgICAgICAgICAgIGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHYpXG4gICAgICAgICAgZWxzZSBpZiAodlswXSA9PT0gJy4nKVxuICAgICAgICAgICAgQ2xhc3NMaXN0KGUpLmFkZChzKVxuICAgICAgICAgIGVsc2UgaWYgKHZbMF0gPT09ICcjJylcbiAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKCdpZCcsIHMpXG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIGlmKGwgPT0gbnVsbClcbiAgICAgICAgO1xuICAgICAgZWxzZSBpZignc3RyaW5nJyA9PT0gdHlwZW9mIGwpIHtcbiAgICAgICAgaWYoIWUpXG4gICAgICAgICAgcGFyc2VDbGFzcyhsKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgZS5hcHBlbmRDaGlsZChyID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobCkpXG4gICAgICB9XG4gICAgICBlbHNlIGlmKCdudW1iZXInID09PSB0eXBlb2YgbFxuICAgICAgICB8fCAnYm9vbGVhbicgPT09IHR5cGVvZiBsXG4gICAgICAgIHx8IGwgaW5zdGFuY2VvZiBEYXRlXG4gICAgICAgIHx8IGwgaW5zdGFuY2VvZiBSZWdFeHAgKSB7XG4gICAgICAgICAgZS5hcHBlbmRDaGlsZChyID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobC50b1N0cmluZygpKSlcbiAgICAgIH1cbiAgICAgIC8vdGhlcmUgbWlnaHQgYmUgYSBiZXR0ZXIgd2F5IHRvIGhhbmRsZSB0aGlzLi4uXG4gICAgICBlbHNlIGlmIChpc0FycmF5KGwpKVxuICAgICAgICBmb3JFYWNoKGwsIGl0ZW0pXG4gICAgICBlbHNlIGlmKGlzTm9kZShsKSlcbiAgICAgICAgZS5hcHBlbmRDaGlsZChyID0gbClcbiAgICAgIGVsc2UgaWYobCBpbnN0YW5jZW9mIFRleHQpXG4gICAgICAgIGUuYXBwZW5kQ2hpbGQociA9IGwpXG4gICAgICBlbHNlIGlmICgnb2JqZWN0JyA9PT0gdHlwZW9mIGwpIHtcbiAgICAgICAgZm9yICh2YXIgayBpbiBsKSB7XG4gICAgICAgICAgaWYoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGxba10pIHtcbiAgICAgICAgICAgIGlmKC9eb25cXHcrLy50ZXN0KGspKSB7XG4gICAgICAgICAgICAgIChmdW5jdGlvbiAoaywgbCkgeyAvLyBjYXB0dXJlIGssIGwgaW4gdGhlIGNsb3N1cmVcbiAgICAgICAgICAgICAgICBpZiAoZS5hZGRFdmVudExpc3RlbmVyKXtcbiAgICAgICAgICAgICAgICAgIGUuYWRkRXZlbnRMaXN0ZW5lcihrLnN1YnN0cmluZygyKSwgbFtrXSwgZmFsc2UpXG4gICAgICAgICAgICAgICAgICBjbGVhbnVwRnVuY3MucHVzaChmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICBlLnJlbW92ZUV2ZW50TGlzdGVuZXIoay5zdWJzdHJpbmcoMiksIGxba10sIGZhbHNlKVxuICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICAgIGUuYXR0YWNoRXZlbnQoaywgbFtrXSlcbiAgICAgICAgICAgICAgICAgIGNsZWFudXBGdW5jcy5wdXNoKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICAgIGUuZGV0YWNoRXZlbnQoaywgbFtrXSlcbiAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KShrLCBsKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gb2JzZXJ2YWJsZVxuICAgICAgICAgICAgICBlW2tdID0gbFtrXSgpXG4gICAgICAgICAgICAgIGNsZWFudXBGdW5jcy5wdXNoKGxba10oZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgICBlW2tdID0gdlxuICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZihrID09PSAnc3R5bGUnKSB7XG4gICAgICAgICAgICBpZignc3RyaW5nJyA9PT0gdHlwZW9mIGxba10pIHtcbiAgICAgICAgICAgICAgZS5zdHlsZS5jc3NUZXh0ID0gbFtrXVxuICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgIGZvciAodmFyIHMgaW4gbFtrXSkgKGZ1bmN0aW9uKHMsIHYpIHtcbiAgICAgICAgICAgICAgICBpZignZnVuY3Rpb24nID09PSB0eXBlb2Ygdikge1xuICAgICAgICAgICAgICAgICAgLy8gb2JzZXJ2YWJsZVxuICAgICAgICAgICAgICAgICAgZS5zdHlsZS5zZXRQcm9wZXJ0eShzLCB2KCkpXG4gICAgICAgICAgICAgICAgICBjbGVhbnVwRnVuY3MucHVzaCh2KGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5zdHlsZS5zZXRQcm9wZXJ0eShzLCB2YWwpXG4gICAgICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICAgIHZhciBtYXRjaCA9IGxba11bc10ubWF0Y2goLyguKilcXFcrIWltcG9ydGFudFxcVyokLyk7XG4gICAgICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5zdHlsZS5zZXRQcm9wZXJ0eShzLCBtYXRjaFsxXSwgJ2ltcG9ydGFudCcpXG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlLnN0eWxlLnNldFByb3BlcnR5KHMsIGxba11bc10pXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pKHMsIGxba11bc10pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmKGsgPT09ICdhdHRycycpIHtcbiAgICAgICAgICAgIGZvciAodmFyIHYgaW4gbFtrXSkge1xuICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZSh2LCBsW2tdW3ZdKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChrLnN1YnN0cigwLCA1KSA9PT0gXCJkYXRhLVwiKSB7XG4gICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrLCBsW2tdKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlW2tdID0gbFtrXVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgbCkge1xuICAgICAgICAvL2Fzc3VtZSBpdCdzIGFuIG9ic2VydmFibGUhXG4gICAgICAgIHZhciB2ID0gbCgpXG4gICAgICAgIGUuYXBwZW5kQ2hpbGQociA9IGlzTm9kZSh2KSA/IHYgOiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh2KSlcblxuICAgICAgICBjbGVhbnVwRnVuY3MucHVzaChsKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgaWYoaXNOb2RlKHYpICYmIHIucGFyZW50RWxlbWVudClcbiAgICAgICAgICAgIHIucGFyZW50RWxlbWVudC5yZXBsYWNlQ2hpbGQodiwgciksIHIgPSB2XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgci50ZXh0Q29udGVudCA9IHZcbiAgICAgICAgfSkpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiByXG4gICAgfVxuICAgIHdoaWxlKGFyZ3MubGVuZ3RoKVxuICAgICAgaXRlbShhcmdzLnNoaWZ0KCkpXG5cbiAgICByZXR1cm4gZVxuICB9XG5cbiAgaC5jbGVhbnVwID0gZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2xlYW51cEZ1bmNzLmxlbmd0aDsgaSsrKXtcbiAgICAgIGNsZWFudXBGdW5jc1tpXSgpXG4gICAgfVxuICAgIGNsZWFudXBGdW5jcy5sZW5ndGggPSAwXG4gIH1cblxuICByZXR1cm4gaFxufVxuXG52YXIgaCA9IG1vZHVsZS5leHBvcnRzID0gY29udGV4dCgpXG5oLmNvbnRleHQgPSBjb250ZXh0XG5cbmZ1bmN0aW9uIGlzTm9kZSAoZWwpIHtcbiAgcmV0dXJuIGVsICYmIGVsLm5vZGVOYW1lICYmIGVsLm5vZGVUeXBlXG59XG5cbmZ1bmN0aW9uIGZvckVhY2ggKGFyciwgZm4pIHtcbiAgaWYgKGFyci5mb3JFYWNoKSByZXR1cm4gYXJyLmZvckVhY2goZm4pXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSBmbihhcnJbaV0sIGkpXG59XG5cbmZ1bmN0aW9uIGlzQXJyYXkgKGFycikge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJ1xufVxuXG5cbiIsIlxudmFyIGluZGV4T2YgPSBbXS5pbmRleE9mO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGFyciwgb2JqKXtcbiAgaWYgKGluZGV4T2YpIHJldHVybiBhcnIuaW5kZXhPZihvYmopO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7ICsraSkge1xuICAgIGlmIChhcnJbaV0gPT09IG9iaikgcmV0dXJuIGk7XG4gIH1cbiAgcmV0dXJuIC0xO1xufTsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbnZhciBpc0Jyb3dzZXIgPSBleHBvcnRzLmlzQnJvd3NlciA9ICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2Yod2luZG93KSkgPT09IFwib2JqZWN0XCIgJiYgKHR5cGVvZiBkb2N1bWVudCA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKGRvY3VtZW50KSkgPT09ICdvYmplY3QnICYmIGRvY3VtZW50Lm5vZGVUeXBlID09PSA5O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBpc0Jyb3dzZXI7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IGNhbWVsQ2FzZTtcbnZhciByZWdFeHAgPSAvKFtBLVpdKS9nO1xuXG4vKipcbiAqIFJlcGxhY2UgYSBzdHJpbmcgcGFzc2VkIGZyb20gU3RyaW5nI3JlcGxhY2UuXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHJlcGxhY2Uoc3RyKSB7XG4gIHJldHVybiBcIi1cIiArIHN0ci50b0xvd2VyQ2FzZSgpO1xufVxuXG4vKipcbiAqIENvbnZlcnQgY2FtZWwgY2FzZWQgcHJvcGVydHkgbmFtZXMgdG8gZGFzaCBzZXBhcmF0ZWQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHN0eWxlXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRDYXNlKHN0eWxlKSB7XG4gIHZhciBjb252ZXJ0ZWQgPSB7fTtcblxuICBmb3IgKHZhciBwcm9wIGluIHN0eWxlKSB7XG4gICAgY29udmVydGVkW3Byb3AucmVwbGFjZShyZWdFeHAsIHJlcGxhY2UpXSA9IHN0eWxlW3Byb3BdO1xuICB9XG5cbiAgaWYgKHN0eWxlLmZhbGxiYWNrcykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHN0eWxlLmZhbGxiYWNrcykpIGNvbnZlcnRlZC5mYWxsYmFja3MgPSBzdHlsZS5mYWxsYmFja3MubWFwKGNvbnZlcnRDYXNlKTtlbHNlIGNvbnZlcnRlZC5mYWxsYmFja3MgPSBjb252ZXJ0Q2FzZShzdHlsZS5mYWxsYmFja3MpO1xuICB9XG5cbiAgcmV0dXJuIGNvbnZlcnRlZDtcbn1cblxuLyoqXG4gKiBBbGxvdyBjYW1lbCBjYXNlZCBwcm9wZXJ0eSBuYW1lcyBieSBjb252ZXJ0aW5nIHRoZW0gYmFjayB0byBkYXNoZXJpemVkLlxuICpcbiAqIEBwYXJhbSB7UnVsZX0gcnVsZVxuICovXG5mdW5jdGlvbiBjYW1lbENhc2UoKSB7XG4gIGZ1bmN0aW9uIG9uUHJvY2Vzc1N0eWxlKHN0eWxlKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc3R5bGUpKSB7XG4gICAgICAvLyBIYW5kbGUgcnVsZXMgbGlrZSBAZm9udC1mYWNlLCB3aGljaCBjYW4gaGF2ZSBtdWx0aXBsZSBzdHlsZXMgaW4gYW4gYXJyYXlcbiAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBzdHlsZS5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgc3R5bGVbaW5kZXhdID0gY29udmVydENhc2Uoc3R5bGVbaW5kZXhdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHlsZTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29udmVydENhc2Uoc3R5bGUpO1xuICB9XG5cbiAgcmV0dXJuIHsgb25Qcm9jZXNzU3R5bGU6IG9uUHJvY2Vzc1N0eWxlIH07XG59IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0ganNzQ29tcG9zZTtcblxudmFyIF93YXJuaW5nID0gcmVxdWlyZSgnd2FybmluZycpO1xuXG52YXIgX3dhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd2FybmluZyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8qKlxuICogU2V0IHNlbGVjdG9yLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcmlnaW5hbCBydWxlXG4gKiBAcGFyYW0ge1N0cmluZ30gY2xhc3NOYW1lIGNsYXNzIHN0cmluZ1xuICogQHJldHVybiB7Qm9vbGVhbn0gZmxhZywgaW5kaWNhdGluZyBmdW5jdGlvbiB3YXMgc3VjY2Vzc2Z1bGwgb3Igbm90XG4gKi9cbmZ1bmN0aW9uIHJlZ2lzdGVyQ2xhc3MocnVsZSwgY2xhc3NOYW1lKSB7XG4gIC8vIFNraXAgZmFsc3kgdmFsdWVzXG4gIGlmICghY2xhc3NOYW1lKSByZXR1cm4gdHJ1ZTtcblxuICAvLyBTdXBwb3J0IGFycmF5IG9mIGNsYXNzIG5hbWVzIGB7Y29tcG9zZXM6IFsnZm9vJywgJ2JhciddfWBcbiAgaWYgKEFycmF5LmlzQXJyYXkoY2xhc3NOYW1lKSkge1xuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBjbGFzc05hbWUubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICB2YXIgaXNTZXR0ZWQgPSByZWdpc3RlckNsYXNzKHJ1bGUsIGNsYXNzTmFtZVtpbmRleF0pO1xuICAgICAgaWYgKCFpc1NldHRlZCkgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gU3VwcG9ydCBzcGFjZSBzZXBhcmF0ZWQgY2xhc3MgbmFtZXMgYHtjb21wb3NlczogJ2ZvbyBiYXInfWBcbiAgaWYgKGNsYXNzTmFtZS5pbmRleE9mKCcgJykgPiAtMSkge1xuICAgIHJldHVybiByZWdpc3RlckNsYXNzKHJ1bGUsIGNsYXNzTmFtZS5zcGxpdCgnICcpKTtcbiAgfVxuXG4gIHZhciBwYXJlbnQgPSBydWxlLm9wdGlvbnMucGFyZW50O1xuXG4gIC8vIEl0IGlzIGEgcmVmIHRvIGEgbG9jYWwgcnVsZS5cblxuICBpZiAoY2xhc3NOYW1lWzBdID09PSAnJCcpIHtcbiAgICB2YXIgcmVmUnVsZSA9IHBhcmVudC5nZXRSdWxlKGNsYXNzTmFtZS5zdWJzdHIoMSkpO1xuXG4gICAgaWYgKCFyZWZSdWxlKSB7XG4gICAgICAoMCwgX3dhcm5pbmcyLmRlZmF1bHQpKGZhbHNlLCAnW0pTU10gUmVmZXJlbmNlZCBydWxlIGlzIG5vdCBkZWZpbmVkLiBcXHJcXG4lcycsIHJ1bGUpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChyZWZSdWxlID09PSBydWxlKSB7XG4gICAgICAoMCwgX3dhcm5pbmcyLmRlZmF1bHQpKGZhbHNlLCAnW0pTU10gQ3ljbGljIGNvbXBvc2l0aW9uIGRldGVjdGVkLiBcXHJcXG4lcycsIHJ1bGUpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHBhcmVudC5jbGFzc2VzW3J1bGUua2V5XSArPSAnICcgKyBwYXJlbnQuY2xhc3Nlc1tyZWZSdWxlLmtleV07XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJ1bGUub3B0aW9ucy5wYXJlbnQuY2xhc3Nlc1tydWxlLmtleV0gKz0gJyAnICsgY2xhc3NOYW1lO1xuXG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIENvbnZlcnQgY29tcG9zZSBwcm9wZXJ0eSB0byBhZGRpdGlvbmFsIGNsYXNzLCByZW1vdmUgcHJvcGVydHkgZnJvbSBvcmlnaW5hbCBzdHlsZXMuXG4gKlxuICogQHBhcmFtIHtSdWxlfSBydWxlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5mdW5jdGlvbiBqc3NDb21wb3NlKCkge1xuICBmdW5jdGlvbiBvblByb2Nlc3NTdHlsZShzdHlsZSwgcnVsZSkge1xuICAgIGlmICghc3R5bGUuY29tcG9zZXMpIHJldHVybiBzdHlsZTtcbiAgICByZWdpc3RlckNsYXNzKHJ1bGUsIHN0eWxlLmNvbXBvc2VzKTtcbiAgICAvLyBSZW1vdmUgY29tcG9zZXMgcHJvcGVydHkgdG8gcHJldmVudCBpbmZpbml0ZSBsb29wLlxuICAgIGRlbGV0ZSBzdHlsZS5jb21wb3NlcztcbiAgICByZXR1cm4gc3R5bGU7XG4gIH1cbiAgcmV0dXJuIHsgb25Qcm9jZXNzU3R5bGU6IG9uUHJvY2Vzc1N0eWxlIH07XG59IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuLyoqXG4gKiBHZW5lcmF0ZWQganNzLWRlZmF1bHQtdW5pdCBDU1MgcHJvcGVydHkgdW5pdHNcbiAqXG4gKiBAdHlwZSBvYmplY3RcbiAqL1xuZXhwb3J0c1snZGVmYXVsdCddID0ge1xuICAnYW5pbWF0aW9uLWRlbGF5JzogJ21zJyxcbiAgJ2FuaW1hdGlvbi1kdXJhdGlvbic6ICdtcycsXG4gICdiYWNrZ3JvdW5kLXBvc2l0aW9uJzogJ3B4JyxcbiAgJ2JhY2tncm91bmQtcG9zaXRpb24teCc6ICdweCcsXG4gICdiYWNrZ3JvdW5kLXBvc2l0aW9uLXknOiAncHgnLFxuICAnYmFja2dyb3VuZC1zaXplJzogJ3B4JyxcbiAgYm9yZGVyOiAncHgnLFxuICAnYm9yZGVyLWJvdHRvbSc6ICdweCcsXG4gICdib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzJzogJ3B4JyxcbiAgJ2JvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzJzogJ3B4JyxcbiAgJ2JvcmRlci1ib3R0b20td2lkdGgnOiAncHgnLFxuICAnYm9yZGVyLWxlZnQnOiAncHgnLFxuICAnYm9yZGVyLWxlZnQtd2lkdGgnOiAncHgnLFxuICAnYm9yZGVyLXJhZGl1cyc6ICdweCcsXG4gICdib3JkZXItcmlnaHQnOiAncHgnLFxuICAnYm9yZGVyLXJpZ2h0LXdpZHRoJzogJ3B4JyxcbiAgJ2JvcmRlci1zcGFjaW5nJzogJ3B4JyxcbiAgJ2JvcmRlci10b3AnOiAncHgnLFxuICAnYm9yZGVyLXRvcC1sZWZ0LXJhZGl1cyc6ICdweCcsXG4gICdib3JkZXItdG9wLXJpZ2h0LXJhZGl1cyc6ICdweCcsXG4gICdib3JkZXItdG9wLXdpZHRoJzogJ3B4JyxcbiAgJ2JvcmRlci13aWR0aCc6ICdweCcsXG4gICdib3JkZXItYWZ0ZXItd2lkdGgnOiAncHgnLFxuICAnYm9yZGVyLWJlZm9yZS13aWR0aCc6ICdweCcsXG4gICdib3JkZXItZW5kLXdpZHRoJzogJ3B4JyxcbiAgJ2JvcmRlci1ob3Jpem9udGFsLXNwYWNpbmcnOiAncHgnLFxuICAnYm9yZGVyLXN0YXJ0LXdpZHRoJzogJ3B4JyxcbiAgJ2JvcmRlci12ZXJ0aWNhbC1zcGFjaW5nJzogJ3B4JyxcbiAgYm90dG9tOiAncHgnLFxuICAnYm94LXNoYWRvdyc6ICdweCcsXG4gICdjb2x1bW4tZ2FwJzogJ3B4JyxcbiAgJ2NvbHVtbi1ydWxlJzogJ3B4JyxcbiAgJ2NvbHVtbi1ydWxlLXdpZHRoJzogJ3B4JyxcbiAgJ2NvbHVtbi13aWR0aCc6ICdweCcsXG4gICdmbGV4LWJhc2lzJzogJ3B4JyxcbiAgJ2ZvbnQtc2l6ZSc6ICdweCcsXG4gICdmb250LXNpemUtZGVsdGEnOiAncHgnLFxuICBoZWlnaHQ6ICdweCcsXG4gIGxlZnQ6ICdweCcsXG4gICdsZXR0ZXItc3BhY2luZyc6ICdweCcsXG4gICdsb2dpY2FsLWhlaWdodCc6ICdweCcsXG4gICdsb2dpY2FsLXdpZHRoJzogJ3B4JyxcbiAgbWFyZ2luOiAncHgnLFxuICAnbWFyZ2luLWFmdGVyJzogJ3B4JyxcbiAgJ21hcmdpbi1iZWZvcmUnOiAncHgnLFxuICAnbWFyZ2luLWJvdHRvbSc6ICdweCcsXG4gICdtYXJnaW4tbGVmdCc6ICdweCcsXG4gICdtYXJnaW4tcmlnaHQnOiAncHgnLFxuICAnbWFyZ2luLXRvcCc6ICdweCcsXG4gICdtYXgtaGVpZ2h0JzogJ3B4JyxcbiAgJ21heC13aWR0aCc6ICdweCcsXG4gICdtYXJnaW4tZW5kJzogJ3B4JyxcbiAgJ21hcmdpbi1zdGFydCc6ICdweCcsXG4gICdtYXNrLXBvc2l0aW9uLXgnOiAncHgnLFxuICAnbWFzay1wb3NpdGlvbi15JzogJ3B4JyxcbiAgJ21hc2stc2l6ZSc6ICdweCcsXG4gICdtYXgtbG9naWNhbC1oZWlnaHQnOiAncHgnLFxuICAnbWF4LWxvZ2ljYWwtd2lkdGgnOiAncHgnLFxuICAnbWluLWhlaWdodCc6ICdweCcsXG4gICdtaW4td2lkdGgnOiAncHgnLFxuICAnbWluLWxvZ2ljYWwtaGVpZ2h0JzogJ3B4JyxcbiAgJ21pbi1sb2dpY2FsLXdpZHRoJzogJ3B4JyxcbiAgbW90aW9uOiAncHgnLFxuICAnbW90aW9uLW9mZnNldCc6ICdweCcsXG4gIG91dGxpbmU6ICdweCcsXG4gICdvdXRsaW5lLW9mZnNldCc6ICdweCcsXG4gICdvdXRsaW5lLXdpZHRoJzogJ3B4JyxcbiAgcGFkZGluZzogJ3B4JyxcbiAgJ3BhZGRpbmctYm90dG9tJzogJ3B4JyxcbiAgJ3BhZGRpbmctbGVmdCc6ICdweCcsXG4gICdwYWRkaW5nLXJpZ2h0JzogJ3B4JyxcbiAgJ3BhZGRpbmctdG9wJzogJ3B4JyxcbiAgJ3BhZGRpbmctYWZ0ZXInOiAncHgnLFxuICAncGFkZGluZy1iZWZvcmUnOiAncHgnLFxuICAncGFkZGluZy1lbmQnOiAncHgnLFxuICAncGFkZGluZy1zdGFydCc6ICdweCcsXG4gICdwZXJzcGVjdGl2ZS1vcmlnaW4teCc6ICclJyxcbiAgJ3BlcnNwZWN0aXZlLW9yaWdpbi15JzogJyUnLFxuICBwZXJzcGVjdGl2ZTogJ3B4JyxcbiAgcmlnaHQ6ICdweCcsXG4gICdzaGFwZS1tYXJnaW4nOiAncHgnLFxuICBzaXplOiAncHgnLFxuICAndGV4dC1pbmRlbnQnOiAncHgnLFxuICAndGV4dC1zdHJva2UnOiAncHgnLFxuICAndGV4dC1zdHJva2Utd2lkdGgnOiAncHgnLFxuICB0b3A6ICdweCcsXG4gICd0cmFuc2Zvcm0tb3JpZ2luJzogJyUnLFxuICAndHJhbnNmb3JtLW9yaWdpbi14JzogJyUnLFxuICAndHJhbnNmb3JtLW9yaWdpbi15JzogJyUnLFxuICAndHJhbnNmb3JtLW9yaWdpbi16JzogJyUnLFxuICAndHJhbnNpdGlvbi1kZWxheSc6ICdtcycsXG4gICd0cmFuc2l0aW9uLWR1cmF0aW9uJzogJ21zJyxcbiAgJ3ZlcnRpY2FsLWFsaWduJzogJ3B4JyxcbiAgd2lkdGg6ICdweCcsXG4gICd3b3JkLXNwYWNpbmcnOiAncHgnLFxuICAvLyBOb3QgZXhpc3RpbmcgcHJvcGVydGllcy5cbiAgLy8gVXNlZCB0byBhdm9pZCBpc3N1ZXMgd2l0aCBqc3MtZXhwYW5kIGludGVyZ3JhdGlvbi5cbiAgJ2JveC1zaGFkb3cteCc6ICdweCcsXG4gICdib3gtc2hhZG93LXknOiAncHgnLFxuICAnYm94LXNoYWRvdy1ibHVyJzogJ3B4JyxcbiAgJ2JveC1zaGFkb3ctc3ByZWFkJzogJ3B4JyxcbiAgJ2ZvbnQtbGluZS1oZWlnaHQnOiAncHgnLFxuICAndGV4dC1zaGFkb3cteCc6ICdweCcsXG4gICd0ZXh0LXNoYWRvdy15JzogJ3B4JyxcbiAgJ3RleHQtc2hhZG93LWJsdXInOiAncHgnXG59OyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBkZWZhdWx0VW5pdDtcblxudmFyIF9kZWZhdWx0VW5pdHMgPSByZXF1aXJlKCcuL2RlZmF1bHRVbml0cycpO1xuXG52YXIgX2RlZmF1bHRVbml0czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kZWZhdWx0VW5pdHMpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbi8qKlxuICogQ2xvbmVzIHRoZSBvYmplY3QgYW5kIGFkZHMgYSBjYW1lbCBjYXNlZCBwcm9wZXJ0eSB2ZXJzaW9uLlxuICovXG5mdW5jdGlvbiBhZGRDYW1lbENhc2VkVmVyc2lvbihvYmopIHtcbiAgdmFyIHJlZ0V4cCA9IC8oLVthLXpdKS9nO1xuICB2YXIgcmVwbGFjZSA9IGZ1bmN0aW9uIHJlcGxhY2Uoc3RyKSB7XG4gICAgcmV0dXJuIHN0clsxXS50b1VwcGVyQ2FzZSgpO1xuICB9O1xuICB2YXIgbmV3T2JqID0ge307XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBuZXdPYmpba2V5XSA9IG9ialtrZXldO1xuICAgIG5ld09ialtrZXkucmVwbGFjZShyZWdFeHAsIHJlcGxhY2UpXSA9IG9ialtrZXldO1xuICB9XG4gIHJldHVybiBuZXdPYmo7XG59XG5cbnZhciB1bml0cyA9IGFkZENhbWVsQ2FzZWRWZXJzaW9uKF9kZWZhdWx0VW5pdHMyWydkZWZhdWx0J10pO1xuXG4vKipcbiAqIFJlY3Vyc2l2ZSBkZWVwIHN0eWxlIHBhc3NpbmcgZnVuY3Rpb25cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gY3VycmVudCBwcm9wZXJ0eVxuICogQHBhcmFtIHsoT2JqZWN0fEFycmF5fE51bWJlcnxTdHJpbmcpfSBwcm9wZXJ0eSB2YWx1ZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4geyhPYmplY3R8QXJyYXl8TnVtYmVyfFN0cmluZyl9IHJlc3VsdGluZyB2YWx1ZVxuICovXG5mdW5jdGlvbiBpdGVyYXRlKHByb3AsIHZhbHVlLCBvcHRpb25zKSB7XG4gIGlmICghdmFsdWUpIHJldHVybiB2YWx1ZTtcblxuICB2YXIgY29udmVydGVkVmFsdWUgPSB2YWx1ZTtcblxuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YodmFsdWUpO1xuICBpZiAodHlwZSA9PT0gJ29iamVjdCcgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHR5cGUgPSAnYXJyYXknO1xuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICBpZiAocHJvcCA9PT0gJ2ZhbGxiYWNrcycpIHtcbiAgICAgICAgZm9yICh2YXIgaW5uZXJQcm9wIGluIHZhbHVlKSB7XG4gICAgICAgICAgdmFsdWVbaW5uZXJQcm9wXSA9IGl0ZXJhdGUoaW5uZXJQcm9wLCB2YWx1ZVtpbm5lclByb3BdLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIF9pbm5lclByb3AgaW4gdmFsdWUpIHtcbiAgICAgICAgdmFsdWVbX2lubmVyUHJvcF0gPSBpdGVyYXRlKHByb3AgKyAnLScgKyBfaW5uZXJQcm9wLCB2YWx1ZVtfaW5uZXJQcm9wXSwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICdhcnJheSc6XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhbHVlW2ldID0gaXRlcmF0ZShwcm9wLCB2YWx1ZVtpXSwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICdudW1iZXInOlxuICAgICAgaWYgKHZhbHVlICE9PSAwKSB7XG4gICAgICAgIGNvbnZlcnRlZFZhbHVlID0gdmFsdWUgKyAob3B0aW9uc1twcm9wXSB8fCB1bml0c1twcm9wXSB8fCAnJyk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgYnJlYWs7XG4gIH1cblxuICByZXR1cm4gY29udmVydGVkVmFsdWU7XG59XG5cbi8qKlxuICogQWRkIHVuaXQgdG8gbnVtZXJpYyB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIGRlZmF1bHRVbml0KCkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgdmFyIGNhbWVsQ2FzZWRPcHRpb25zID0gYWRkQ2FtZWxDYXNlZFZlcnNpb24ob3B0aW9ucyk7XG5cbiAgZnVuY3Rpb24gb25Qcm9jZXNzU3R5bGUoc3R5bGUsIHJ1bGUpIHtcbiAgICBpZiAocnVsZS50eXBlICE9PSAnc3R5bGUnKSByZXR1cm4gc3R5bGU7XG5cbiAgICBmb3IgKHZhciBwcm9wIGluIHN0eWxlKSB7XG4gICAgICBzdHlsZVtwcm9wXSA9IGl0ZXJhdGUocHJvcCwgc3R5bGVbcHJvcF0sIGNhbWVsQ2FzZWRPcHRpb25zKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3R5bGU7XG4gIH1cblxuICBmdW5jdGlvbiBvbkNoYW5nZVZhbHVlKHZhbHVlLCBwcm9wKSB7XG4gICAgcmV0dXJuIGl0ZXJhdGUocHJvcCwgdmFsdWUsIGNhbWVsQ2FzZWRPcHRpb25zKTtcbiAgfVxuXG4gIHJldHVybiB7IG9uUHJvY2Vzc1N0eWxlOiBvblByb2Nlc3NTdHlsZSwgb25DaGFuZ2VWYWx1ZTogb25DaGFuZ2VWYWx1ZSB9O1xufSIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBqc3NFeHBhbmQ7XG5cbnZhciBfcHJvcHMgPSByZXF1aXJlKCcuL3Byb3BzJyk7XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbi8qKlxuICogTWFwIHZhbHVlcyBieSBnaXZlbiBwcm9wLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IG9mIHZhbHVlc1xuICogQHBhcmFtIHtTdHJpbmd9IG9yaWdpbmFsIHByb3BlcnR5XG4gKiBAcGFyYW0ge1N0cmluZ30gb3JpZ2luYWwgcnVsZVxuICogQHJldHVybiB7U3RyaW5nfSBtYXBwZWQgdmFsdWVzXG4gKi9cbmZ1bmN0aW9uIG1hcFZhbHVlc0J5UHJvcCh2YWx1ZSwgcHJvcCwgcnVsZSkge1xuICByZXR1cm4gdmFsdWUubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgcmV0dXJuIG9iamVjdFRvU3RyaW5nKGl0ZW0sIHByb3AsIHJ1bGUpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGFycmF5IHRvIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBvZiB2YWx1ZXNcbiAqIEBwYXJhbSB7U3RyaW5nfSBvcmlnaW5hbCBwcm9wZXJ0eVxuICogQHBhcmFtIHtPYmplY3R9IHNoZW1lLCBmb3IgY29udmVydGluZyBhcnJheXMgaW4gc3RyaW5nc1xuICogQHBhcmFtIHtPYmplY3R9IG9yaWdpbmFsIHJ1bGVcbiAqIEByZXR1cm4ge1N0cmluZ30gY29udmVydGVkIHN0cmluZ1xuICovXG5mdW5jdGlvbiBhcnJheVRvU3RyaW5nKHZhbHVlLCBwcm9wLCBzY2hlbWUsIHJ1bGUpIHtcbiAgaWYgKHNjaGVtZVtwcm9wXSA9PSBudWxsKSByZXR1cm4gdmFsdWUuam9pbignLCcpO1xuICBpZiAodmFsdWUubGVuZ3RoID09PSAwKSByZXR1cm4gJyc7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlWzBdKSkgcmV0dXJuIGFycmF5VG9TdHJpbmcodmFsdWVbMF0sIHByb3AsIHNjaGVtZSk7XG4gIGlmIChfdHlwZW9mKHZhbHVlWzBdKSA9PT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbWFwVmFsdWVzQnlQcm9wKHZhbHVlLCBwcm9wLCBydWxlKTtcbiAgfVxuICByZXR1cm4gdmFsdWUuam9pbignICcpO1xufVxuXG4vKipcbiAqIENvbnZlcnQgb2JqZWN0IHRvIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IG9mIHZhbHVlc1xuICogQHBhcmFtIHtTdHJpbmd9IG9yaWdpbmFsIHByb3BlcnR5XG4gKiBAcGFyYW0ge09iamVjdH0gb3JpZ2luYWwgcnVsZVxuICogQHBhcmFtIHtCb29sZWFufSBpcyBmYWxsYmFjayBwcm9wXG4gKiBAcmV0dXJuIHtTdHJpbmd9IGNvbnZlcnRlZCBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcodmFsdWUsIHByb3AsIHJ1bGUsIGlzRmFsbGJhY2spIHtcbiAgaWYgKCEoX3Byb3BzLnByb3BPYmpbcHJvcF0gfHwgX3Byb3BzLmN1c3RvbVByb3BPYmpbcHJvcF0pKSByZXR1cm4gJyc7XG5cbiAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gIC8vIENoZWNrIGlmIGV4aXN0cyBhbnkgbm9uLXN0YW5kYXJ0IHByb3BlcnR5XG4gIGlmIChfcHJvcHMuY3VzdG9tUHJvcE9ialtwcm9wXSkge1xuICAgIHZhbHVlID0gY3VzdG9tUHJvcHNUb1N0eWxlKHZhbHVlLCBydWxlLCBfcHJvcHMuY3VzdG9tUHJvcE9ialtwcm9wXSwgaXNGYWxsYmFjayk7XG4gIH1cblxuICAvLyBQYXNzIHRocm91Z2h0IGFsbCBzdGFuZGFydCBwcm9wc1xuICBpZiAoT2JqZWN0LmtleXModmFsdWUpLmxlbmd0aCkge1xuICAgIGZvciAodmFyIGJhc2VQcm9wIGluIF9wcm9wcy5wcm9wT2JqW3Byb3BdKSB7XG4gICAgICBpZiAodmFsdWVbYmFzZVByb3BdKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlW2Jhc2VQcm9wXSkpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChhcnJheVRvU3RyaW5nKHZhbHVlW2Jhc2VQcm9wXSwgYmFzZVByb3AsIF9wcm9wcy5wcm9wQXJyYXlJbk9iaikpO1xuICAgICAgICB9IGVsc2UgcmVzdWx0LnB1c2godmFsdWVbYmFzZVByb3BdKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIEFkZCBkZWZhdWx0IHZhbHVlIGZyb20gcHJvcHMgY29uZmlnLlxuICAgICAgaWYgKF9wcm9wcy5wcm9wT2JqW3Byb3BdW2Jhc2VQcm9wXSAhPSBudWxsKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKF9wcm9wcy5wcm9wT2JqW3Byb3BdW2Jhc2VQcm9wXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdC5qb2luKCcgJyk7XG59XG5cbi8qKlxuICogQ29udmVydCBjdXN0b20gcHJvcGVydGllcyB2YWx1ZXMgdG8gc3R5bGVzIGFkZGluZyB0aGVtIHRvIHJ1bGUgZGlyZWN0bHlcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IG9mIHZhbHVlc1xuICogQHBhcmFtIHtPYmplY3R9IG9yaWdpbmFsIHJ1bGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eSwgdGhhdCBjb250YWluIHBhcnRpYWwgY3VzdG9tIHByb3BlcnRpZXNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaXMgZmFsbGJhY2sgcHJvcFxuICogQHJldHVybiB7T2JqZWN0fSB2YWx1ZSB3aXRob3V0IGN1c3RvbSBwcm9wZXJ0aWVzLCB0aGF0IHdhcyBhbHJlYWR5IGFkZGVkIHRvIHJ1bGVcbiAqL1xuZnVuY3Rpb24gY3VzdG9tUHJvcHNUb1N0eWxlKHZhbHVlLCBydWxlLCBjdXN0b21Qcm9wcywgaXNGYWxsYmFjaykge1xuICBmb3IgKHZhciBwcm9wIGluIGN1c3RvbVByb3BzKSB7XG4gICAgdmFyIHByb3BOYW1lID0gY3VzdG9tUHJvcHNbcHJvcF07XG5cbiAgICAvLyBJZiBjdXJyZW50IHByb3BlcnR5IGRvZXNuJ3QgZXhpc3QgYWxyZWFkeSBpbiBydWxlIC0gYWRkIG5ldyBvbmVcbiAgICBpZiAodHlwZW9mIHZhbHVlW3Byb3BdICE9PSAndW5kZWZpbmVkJyAmJiAoaXNGYWxsYmFjayB8fCAhcnVsZS5wcm9wKHByb3BOYW1lKSkpIHtcbiAgICAgIHZhciBhcHBlbmRlZFZhbHVlID0gc3R5bGVEZXRlY3RvcihfZGVmaW5lUHJvcGVydHkoe30sIHByb3BOYW1lLCB2YWx1ZVtwcm9wXSksIHJ1bGUpW3Byb3BOYW1lXTtcblxuICAgICAgLy8gQWRkIHN0eWxlIGRpcmVjdGx5IGluIHJ1bGVcbiAgICAgIGlmIChpc0ZhbGxiYWNrKSBydWxlLnN0eWxlLmZhbGxiYWNrc1twcm9wTmFtZV0gPSBhcHBlbmRlZFZhbHVlO2Vsc2UgcnVsZS5zdHlsZVtwcm9wTmFtZV0gPSBhcHBlbmRlZFZhbHVlO1xuICAgIH1cbiAgICAvLyBEZWxldGUgY29udmVydGVkIHByb3BlcnR5IHRvIGF2b2lkIGRvdWJsZSBjb252ZXJ0aW5nXG4gICAgZGVsZXRlIHZhbHVlW3Byb3BdO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG4vKipcbiAqIERldGVjdCBpZiBhIHN0eWxlIG5lZWRzIHRvIGJlIGNvbnZlcnRlZC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gc3R5bGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBydWxlXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGlzIGZhbGxiYWNrIHByb3BcbiAqIEByZXR1cm4ge09iamVjdH0gY29udmVydGVkU3R5bGVcbiAqL1xuZnVuY3Rpb24gc3R5bGVEZXRlY3RvcihzdHlsZSwgcnVsZSwgaXNGYWxsYmFjaykge1xuICBmb3IgKHZhciBwcm9wIGluIHN0eWxlKSB7XG4gICAgdmFyIHZhbHVlID0gc3R5bGVbcHJvcF07XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIC8vIENoZWNrIGRvdWJsZSBhcnJheXMgdG8gYXZvaWQgcmVjdXJzaW9uLlxuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlWzBdKSkge1xuICAgICAgICBpZiAocHJvcCA9PT0gJ2ZhbGxiYWNrcycpIHtcbiAgICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgc3R5bGUuZmFsbGJhY2tzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgc3R5bGUuZmFsbGJhY2tzW2luZGV4XSA9IHN0eWxlRGV0ZWN0b3Ioc3R5bGUuZmFsbGJhY2tzW2luZGV4XSwgcnVsZSwgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgc3R5bGVbcHJvcF0gPSBhcnJheVRvU3RyaW5nKHZhbHVlLCBwcm9wLCBfcHJvcHMucHJvcEFycmF5KTtcbiAgICAgICAgLy8gQXZvaWQgY3JlYXRpbmcgcHJvcGVydGllcyB3aXRoIGVtcHR5IHZhbHVlc1xuICAgICAgICBpZiAoIXN0eWxlW3Byb3BdKSBkZWxldGUgc3R5bGVbcHJvcF07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICgodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih2YWx1ZSkpID09PSAnb2JqZWN0Jykge1xuICAgICAgaWYgKHByb3AgPT09ICdmYWxsYmFja3MnKSB7XG4gICAgICAgIHN0eWxlLmZhbGxiYWNrcyA9IHN0eWxlRGV0ZWN0b3Ioc3R5bGUuZmFsbGJhY2tzLCBydWxlLCB0cnVlKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHN0eWxlW3Byb3BdID0gb2JqZWN0VG9TdHJpbmcodmFsdWUsIHByb3AsIHJ1bGUsIGlzRmFsbGJhY2spO1xuICAgICAgLy8gQXZvaWQgY3JlYXRpbmcgcHJvcGVydGllcyB3aXRoIGVtcHR5IHZhbHVlc1xuICAgICAgaWYgKCFzdHlsZVtwcm9wXSkgZGVsZXRlIHN0eWxlW3Byb3BdO1xuICAgIH1cblxuICAgIC8vIE1heWJlIGEgY29tcHV0ZWQgdmFsdWUgcmVzdWx0aW5nIGluIGFuIGVtcHR5IHN0cmluZ1xuICAgIGVsc2UgaWYgKHN0eWxlW3Byb3BdID09PSAnJykgZGVsZXRlIHN0eWxlW3Byb3BdO1xuICB9XG5cbiAgcmV0dXJuIHN0eWxlO1xufVxuXG4vKipcbiAqIEFkZHMgcG9zc2liaWxpdHkgdG8gd3JpdGUgZXhwYW5kZWQgc3R5bGVzLlxuICpcbiAqIEBwYXJhbSB7UnVsZX0gcnVsZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuZnVuY3Rpb24ganNzRXhwYW5kKCkge1xuICBmdW5jdGlvbiBvblByb2Nlc3NTdHlsZShzdHlsZSwgcnVsZSkge1xuICAgIGlmICghc3R5bGUgfHwgcnVsZS50eXBlICE9PSAnc3R5bGUnKSByZXR1cm4gc3R5bGU7XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShzdHlsZSkpIHtcbiAgICAgIC8vIFBhc3MgcnVsZXMgb25lIGJ5IG9uZSBhbmQgcmVmb3JtYXQgdGhlbVxuICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IHN0eWxlLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICBzdHlsZVtpbmRleF0gPSBzdHlsZURldGVjdG9yKHN0eWxlW2luZGV4XSwgcnVsZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3R5bGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0eWxlRGV0ZWN0b3Ioc3R5bGUsIHJ1bGUpO1xuICB9XG5cbiAgcmV0dXJuIHsgb25Qcm9jZXNzU3R5bGU6IG9uUHJvY2Vzc1N0eWxlIH07XG59IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuLyoqXG4gKiBBIHNjaGVtZSBmb3IgY29udmVydGluZyBwcm9wZXJ0aWVzIGZyb20gYXJyYXkgdG8gcmVndWxhciBzdHlsZS5cbiAqIEFsbCBwcm9wZXJ0aWVzIGxpc3RlZCBiZWxvdyB3aWxsIGJlIHRyYW5zZm9ybWVkIHRvIGEgc3RyaW5nIHNlcGFyYXRlZCBieSBzcGFjZS5cbiAqL1xudmFyIHByb3BBcnJheSA9IGV4cG9ydHMucHJvcEFycmF5ID0ge1xuICAnYmFja2dyb3VuZC1zaXplJzogdHJ1ZSxcbiAgJ2JhY2tncm91bmQtcG9zaXRpb24nOiB0cnVlLFxuICBib3JkZXI6IHRydWUsXG4gICdib3JkZXItYm90dG9tJzogdHJ1ZSxcbiAgJ2JvcmRlci1sZWZ0JzogdHJ1ZSxcbiAgJ2JvcmRlci10b3AnOiB0cnVlLFxuICAnYm9yZGVyLXJpZ2h0JzogdHJ1ZSxcbiAgJ2JvcmRlci1yYWRpdXMnOiB0cnVlLFxuICAnYm9yZGVyLWltYWdlJzogdHJ1ZSxcbiAgJ2JveC1zaGFkb3cnOiB0cnVlLFxuICBmbGV4OiB0cnVlLFxuICBtYXJnaW46IHRydWUsXG4gIHBhZGRpbmc6IHRydWUsXG4gIG91dGxpbmU6IHRydWUsXG4gICd0cmFuc2Zvcm0tb3JpZ2luJzogdHJ1ZSxcbiAgdHJhbnNmb3JtOiB0cnVlLFxuICB0cmFuc2l0aW9uOiB0cnVlXG5cbiAgLyoqXG4gICAqIEEgc2NoZW1lIGZvciBjb252ZXJ0aW5nIGFycmF5cyB0byByZWd1bGFyIHN0eWxlcyBpbnNpZGUgb2Ygb2JqZWN0cy5cbiAgICogRm9yIGUuZy46IFwie3Bvc2l0aW9uOiBbMCwgMF19XCIgPT4gXCJiYWNrZ3JvdW5kLXBvc2l0aW9uOiAwIDA7XCIuXG4gICAqL1xufTt2YXIgcHJvcEFycmF5SW5PYmogPSBleHBvcnRzLnByb3BBcnJheUluT2JqID0ge1xuICBwb3NpdGlvbjogdHJ1ZSwgLy8gYmFja2dyb3VuZC1wb3NpdGlvblxuICBzaXplOiB0cnVlIC8vIGJhY2tncm91bmQtc2l6ZVxuXG5cbiAgLyoqXG4gICAqIEEgc2NoZW1lIGZvciBwYXJzaW5nIGFuZCBidWlsZGluZyBjb3JyZWN0IHN0eWxlcyBmcm9tIHBhc3NlZCBvYmplY3RzLlxuICAgKi9cbn07dmFyIHByb3BPYmogPSBleHBvcnRzLnByb3BPYmogPSB7XG4gIHBhZGRpbmc6IHtcbiAgICB0b3A6IDAsXG4gICAgcmlnaHQ6IDAsXG4gICAgYm90dG9tOiAwLFxuICAgIGxlZnQ6IDBcbiAgfSxcbiAgbWFyZ2luOiB7XG4gICAgdG9wOiAwLFxuICAgIHJpZ2h0OiAwLFxuICAgIGJvdHRvbTogMCxcbiAgICBsZWZ0OiAwXG4gIH0sXG4gIGJhY2tncm91bmQ6IHtcbiAgICBhdHRhY2htZW50OiBudWxsLFxuICAgIGNvbG9yOiBudWxsLFxuICAgIGltYWdlOiBudWxsLFxuICAgIHBvc2l0aW9uOiBudWxsLFxuICAgIHJlcGVhdDogbnVsbFxuICB9LFxuICBib3JkZXI6IHtcbiAgICB3aWR0aDogbnVsbCxcbiAgICBzdHlsZTogbnVsbCxcbiAgICBjb2xvcjogbnVsbFxuICB9LFxuICAnYm9yZGVyLXRvcCc6IHtcbiAgICB3aWR0aDogbnVsbCxcbiAgICBzdHlsZTogbnVsbCxcbiAgICBjb2xvcjogbnVsbFxuICB9LFxuICAnYm9yZGVyLXJpZ2h0Jzoge1xuICAgIHdpZHRoOiBudWxsLFxuICAgIHN0eWxlOiBudWxsLFxuICAgIGNvbG9yOiBudWxsXG4gIH0sXG4gICdib3JkZXItYm90dG9tJzoge1xuICAgIHdpZHRoOiBudWxsLFxuICAgIHN0eWxlOiBudWxsLFxuICAgIGNvbG9yOiBudWxsXG4gIH0sXG4gICdib3JkZXItbGVmdCc6IHtcbiAgICB3aWR0aDogbnVsbCxcbiAgICBzdHlsZTogbnVsbCxcbiAgICBjb2xvcjogbnVsbFxuICB9LFxuICBvdXRsaW5lOiB7XG4gICAgd2lkdGg6IG51bGwsXG4gICAgc3R5bGU6IG51bGwsXG4gICAgY29sb3I6IG51bGxcbiAgfSxcbiAgJ2xpc3Qtc3R5bGUnOiB7XG4gICAgdHlwZTogbnVsbCxcbiAgICBwb3NpdGlvbjogbnVsbCxcbiAgICBpbWFnZTogbnVsbFxuICB9LFxuICB0cmFuc2l0aW9uOiB7XG4gICAgcHJvcGVydHk6IG51bGwsXG4gICAgZHVyYXRpb246IG51bGwsXG4gICAgJ3RpbWluZy1mdW5jdGlvbic6IG51bGwsXG4gICAgdGltaW5nRnVuY3Rpb246IG51bGwsIC8vIE5lZWRlZCBmb3IgYXZvaWRpbmcgY29taWxhdGlvbiBpc3N1ZXMgd2l0aCBqc3MtY2FtZWwtY2FzZVxuICAgIGRlbGF5OiBudWxsXG4gIH0sXG4gIGFuaW1hdGlvbjoge1xuICAgIG5hbWU6IG51bGwsXG4gICAgZHVyYXRpb246IG51bGwsXG4gICAgJ3RpbWluZy1mdW5jdGlvbic6IG51bGwsXG4gICAgdGltaW5nRnVuY3Rpb246IG51bGwsIC8vIE5lZWRlZCB0byBhdm9pZCBjb21waWxhdGlvbiBpc3N1ZXMgd2l0aCBqc3MtY2FtZWwtY2FzZVxuICAgIGRlbGF5OiBudWxsLFxuICAgICdpdGVyYXRpb24tY291bnQnOiBudWxsLFxuICAgIGl0ZXJhdGlvbkNvdW50OiBudWxsLCAvLyBOZWVkZWQgdG8gYXZvaWQgY29tcGlsYXRpb24gaXNzdWVzIHdpdGgganNzLWNhbWVsLWNhc2VcbiAgICBkaXJlY3Rpb246IG51bGwsXG4gICAgJ2ZpbGwtbW9kZSc6IG51bGwsXG4gICAgZmlsbE1vZGU6IG51bGwsIC8vIE5lZWRlZCB0byBhdm9pZCBjb21waWxhdGlvbiBpc3N1ZXMgd2l0aCBqc3MtY2FtZWwtY2FzZVxuICAgICdwbGF5LXN0YXRlJzogbnVsbCxcbiAgICBwbGF5U3RhdGU6IG51bGwgLy8gTmVlZGVkIHRvIGF2b2lkIGNvbXBpbGF0aW9uIGlzc3VlcyB3aXRoIGpzcy1jYW1lbC1jYXNlXG4gIH0sXG4gICdib3gtc2hhZG93Jzoge1xuICAgIHg6IDAsXG4gICAgeTogMCxcbiAgICBibHVyOiAwLFxuICAgIHNwcmVhZDogMCxcbiAgICBjb2xvcjogbnVsbCxcbiAgICBpbnNldDogbnVsbFxuICB9LFxuICAndGV4dC1zaGFkb3cnOiB7XG4gICAgeDogMCxcbiAgICB5OiAwLFxuICAgIGJsdXI6IG51bGwsXG4gICAgY29sb3I6IG51bGxcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNjaGVtZSBmb3IgY29udmVydGluZyBub24tc3RhbmRhcnQgcHJvcGVydGllcyBpbnNpZGUgb2JqZWN0LlxuICAgKiBGb3IgZS5nLjogaW5jbHVkZSAnYm9yZGVyLXJhZGl1cycgcHJvcGVydHkgaW5zaWRlICdib3JkZXInIG9iamVjdC5cbiAgICovXG59O3ZhciBjdXN0b21Qcm9wT2JqID0gZXhwb3J0cy5jdXN0b21Qcm9wT2JqID0ge1xuICBib3JkZXI6IHtcbiAgICByYWRpdXM6ICdib3JkZXItcmFkaXVzJyxcbiAgICBpbWFnZTogJ2JvcmRlci1pbWFnZSdcbiAgfSxcbiAgYmFja2dyb3VuZDoge1xuICAgIHNpemU6ICdiYWNrZ3JvdW5kLXNpemUnLFxuICAgIGltYWdlOiAnYmFja2dyb3VuZC1pbWFnZSdcbiAgfSxcbiAgZm9udDoge1xuICAgIHN0eWxlOiAnZm9udC1zdHlsZScsXG4gICAgdmFyaWFudDogJ2ZvbnQtdmFyaWFudCcsXG4gICAgd2VpZ2h0OiAnZm9udC13ZWlnaHQnLFxuICAgIHN0cmV0Y2g6ICdmb250LXN0cmV0Y2gnLFxuICAgIHNpemU6ICdmb250LXNpemUnLFxuICAgIGZhbWlseTogJ2ZvbnQtZmFtaWx5JyxcbiAgICBsaW5lSGVpZ2h0OiAnbGluZS1oZWlnaHQnLCAvLyBOZWVkZWQgdG8gYXZvaWQgY29tcGlsYXRpb24gaXNzdWVzIHdpdGgganNzLWNhbWVsLWNhc2VcbiAgICAnbGluZS1oZWlnaHQnOiAnbGluZS1oZWlnaHQnXG4gIH0sXG4gIGZsZXg6IHtcbiAgICBncm93OiAnZmxleC1ncm93JyxcbiAgICBiYXNpczogJ2ZsZXgtYmFzaXMnLFxuICAgIGRpcmVjdGlvbjogJ2ZsZXgtZGlyZWN0aW9uJyxcbiAgICB3cmFwOiAnZmxleC13cmFwJyxcbiAgICBmbG93OiAnZmxleC1mbG93JyxcbiAgICBzaHJpbms6ICdmbGV4LXNocmluaydcbiAgfSxcbiAgYWxpZ246IHtcbiAgICBzZWxmOiAnYWxpZ24tc2VsZicsXG4gICAgaXRlbXM6ICdhbGlnbi1pdGVtcycsXG4gICAgY29udGVudDogJ2FsaWduLWNvbnRlbnQnXG4gIH1cbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGpzc0V4dGVuZDtcblxudmFyIF93YXJuaW5nID0gcmVxdWlyZSgnd2FybmluZycpO1xuXG52YXIgX3dhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd2FybmluZyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIGlzT2JqZWN0ID0gZnVuY3Rpb24gaXNPYmplY3Qob2JqKSB7XG4gIHJldHVybiBvYmogJiYgKHR5cGVvZiBvYmogPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKG9iaikpID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShvYmopO1xufTtcblxuLyoqXG4gKiBSZWN1cnNpdmVseSBleHRlbmQgc3R5bGVzLlxuICovXG5mdW5jdGlvbiBleHRlbmQoc3R5bGUsIHJ1bGUsIHNoZWV0KSB7XG4gIHZhciBuZXdTdHlsZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDoge307XG5cbiAgaWYgKHR5cGVvZiBzdHlsZS5leHRlbmQgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHNoZWV0KSB7XG4gICAgICB2YXIgcmVmUnVsZSA9IHNoZWV0LmdldFJ1bGUoc3R5bGUuZXh0ZW5kKTtcbiAgICAgIGlmIChyZWZSdWxlKSB7XG4gICAgICAgIGlmIChyZWZSdWxlID09PSBydWxlKSAoMCwgX3dhcm5pbmcyWydkZWZhdWx0J10pKGZhbHNlLCAnW0pTU10gQSBydWxlIHRyaWVzIHRvIGV4dGVuZCBpdHNlbGYgXFxyXFxuJXMnLCBydWxlKTtlbHNlIGlmIChyZWZSdWxlLm9wdGlvbnMucGFyZW50KSB7XG4gICAgICAgICAgdmFyIG9yaWdpbmFsU3R5bGUgPSByZWZSdWxlLm9wdGlvbnMucGFyZW50LnJ1bGVzLnJhd1tzdHlsZS5leHRlbmRdO1xuICAgICAgICAgIGV4dGVuZChvcmlnaW5hbFN0eWxlLCBydWxlLCBzaGVldCwgbmV3U3R5bGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoc3R5bGUuZXh0ZW5kKSkge1xuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBzdHlsZS5leHRlbmQubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICBleHRlbmQoc3R5bGUuZXh0ZW5kW2luZGV4XSwgcnVsZSwgc2hlZXQsIG5ld1N0eWxlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgcHJvcCBpbiBzdHlsZS5leHRlbmQpIHtcbiAgICAgIGlmIChwcm9wID09PSAnZXh0ZW5kJykge1xuICAgICAgICBleHRlbmQoc3R5bGUuZXh0ZW5kLmV4dGVuZCwgcnVsZSwgc2hlZXQsIG5ld1N0eWxlKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3Qoc3R5bGUuZXh0ZW5kW3Byb3BdKSkge1xuICAgICAgICBpZiAoIW5ld1N0eWxlW3Byb3BdKSBuZXdTdHlsZVtwcm9wXSA9IHt9O1xuICAgICAgICBleHRlbmQoc3R5bGUuZXh0ZW5kW3Byb3BdLCBydWxlLCBzaGVldCwgbmV3U3R5bGVbcHJvcF0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV3U3R5bGVbcHJvcF0gPSBzdHlsZS5leHRlbmRbcHJvcF07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vIENvcHkgYmFzZSBzdHlsZS5cbiAgZm9yICh2YXIgX3Byb3AgaW4gc3R5bGUpIHtcbiAgICBpZiAoX3Byb3AgPT09ICdleHRlbmQnKSBjb250aW51ZTtcbiAgICBpZiAoaXNPYmplY3QobmV3U3R5bGVbX3Byb3BdKSAmJiBpc09iamVjdChzdHlsZVtfcHJvcF0pKSB7XG4gICAgICBleHRlbmQoc3R5bGVbX3Byb3BdLCBydWxlLCBzaGVldCwgbmV3U3R5bGVbX3Byb3BdKTtcbiAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KHN0eWxlW19wcm9wXSkpIHtcbiAgICAgIG5ld1N0eWxlW19wcm9wXSA9IGV4dGVuZChzdHlsZVtfcHJvcF0sIHJ1bGUsIHNoZWV0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV3U3R5bGVbX3Byb3BdID0gc3R5bGVbX3Byb3BdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXdTdHlsZTtcbn1cblxuLyoqXG4gKiBIYW5kbGUgYGV4dGVuZGAgcHJvcGVydHkuXG4gKlxuICogQHBhcmFtIHtSdWxlfSBydWxlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5mdW5jdGlvbiBqc3NFeHRlbmQoKSB7XG4gIGZ1bmN0aW9uIG9uUHJvY2Vzc1N0eWxlKHN0eWxlLCBydWxlLCBzaGVldCkge1xuICAgIHJldHVybiBzdHlsZS5leHRlbmQgPyBleHRlbmQoc3R5bGUsIHJ1bGUsIHNoZWV0KSA6IHN0eWxlO1xuICB9XG5cbiAgcmV0dXJuIHsgb25Qcm9jZXNzU3R5bGU6IG9uUHJvY2Vzc1N0eWxlIH07XG59IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBqc3NHbG9iYWw7XG5cbnZhciBfanNzID0gcmVxdWlyZSgnanNzJyk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBwcm9wS2V5ID0gJ0BnbG9iYWwnO1xudmFyIHByZWZpeEtleSA9ICdAZ2xvYmFsICc7XG5cbnZhciBHbG9iYWxDb250YWluZXJSdWxlID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBHbG9iYWxDb250YWluZXJSdWxlKGtleSwgc3R5bGVzLCBvcHRpb25zKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEdsb2JhbENvbnRhaW5lclJ1bGUpO1xuXG4gICAgdGhpcy50eXBlID0gJ2dsb2JhbCc7XG5cbiAgICB0aGlzLmtleSA9IGtleTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMucnVsZXMgPSBuZXcgX2pzcy5SdWxlTGlzdChfZXh0ZW5kcyh7fSwgb3B0aW9ucywge1xuICAgICAgcGFyZW50OiB0aGlzXG4gICAgfSkpO1xuXG4gICAgZm9yICh2YXIgc2VsZWN0b3IgaW4gc3R5bGVzKSB7XG4gICAgICB0aGlzLnJ1bGVzLmFkZChzZWxlY3Rvciwgc3R5bGVzW3NlbGVjdG9yXSwgeyBzZWxlY3Rvcjogc2VsZWN0b3IgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5ydWxlcy5wcm9jZXNzKCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgcnVsZS5cbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoR2xvYmFsQ29udGFpbmVyUnVsZSwgW3tcbiAgICBrZXk6ICdnZXRSdWxlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UnVsZShuYW1lKSB7XG4gICAgICByZXR1cm4gdGhpcy5ydWxlcy5nZXQobmFtZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuZCByZWdpc3RlciBydWxlLCBydW4gcGx1Z2lucy5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnYWRkUnVsZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZFJ1bGUobmFtZSwgc3R5bGUsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBydWxlID0gdGhpcy5ydWxlcy5hZGQobmFtZSwgc3R5bGUsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5vcHRpb25zLmpzcy5wbHVnaW5zLm9uUHJvY2Vzc1J1bGUocnVsZSk7XG4gICAgICByZXR1cm4gcnVsZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgaW5kZXggb2YgYSBydWxlLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdpbmRleE9mJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5kZXhPZihydWxlKSB7XG4gICAgICByZXR1cm4gdGhpcy5ydWxlcy5pbmRleE9mKHJ1bGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhIENTUyBzdHJpbmcuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3RvU3RyaW5nJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gdGhpcy5ydWxlcy50b1N0cmluZygpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBHbG9iYWxDb250YWluZXJSdWxlO1xufSgpO1xuXG52YXIgR2xvYmFsUHJlZml4ZWRSdWxlID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBHbG9iYWxQcmVmaXhlZFJ1bGUobmFtZSwgc3R5bGUsIG9wdGlvbnMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgR2xvYmFsUHJlZml4ZWRSdWxlKTtcblxuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB2YXIgc2VsZWN0b3IgPSBuYW1lLnN1YnN0cihwcmVmaXhLZXkubGVuZ3RoKTtcbiAgICB0aGlzLnJ1bGUgPSBvcHRpb25zLmpzcy5jcmVhdGVSdWxlKHNlbGVjdG9yLCBzdHlsZSwgX2V4dGVuZHMoe30sIG9wdGlvbnMsIHtcbiAgICAgIHBhcmVudDogdGhpcyxcbiAgICAgIHNlbGVjdG9yOiBzZWxlY3RvclxuICAgIH0pKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhHbG9iYWxQcmVmaXhlZFJ1bGUsIFt7XG4gICAga2V5OiAndG9TdHJpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZyhvcHRpb25zKSB7XG4gICAgICByZXR1cm4gdGhpcy5ydWxlLnRvU3RyaW5nKG9wdGlvbnMpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBHbG9iYWxQcmVmaXhlZFJ1bGU7XG59KCk7XG5cbnZhciBzZXBhcmF0b3JSZWdFeHAgPSAvXFxzKixcXHMqL2c7XG5cbmZ1bmN0aW9uIGFkZFNjb3BlKHNlbGVjdG9yLCBzY29wZSkge1xuICB2YXIgcGFydHMgPSBzZWxlY3Rvci5zcGxpdChzZXBhcmF0b3JSZWdFeHApO1xuICB2YXIgc2NvcGVkID0gJyc7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICBzY29wZWQgKz0gc2NvcGUgKyAnICcgKyBwYXJ0c1tpXS50cmltKCk7XG4gICAgaWYgKHBhcnRzW2kgKyAxXSkgc2NvcGVkICs9ICcsICc7XG4gIH1cbiAgcmV0dXJuIHNjb3BlZDtcbn1cblxuZnVuY3Rpb24gaGFuZGxlTmVzdGVkR2xvYmFsQ29udGFpbmVyUnVsZShydWxlKSB7XG4gIHZhciBvcHRpb25zID0gcnVsZS5vcHRpb25zLFxuICAgICAgc3R5bGUgPSBydWxlLnN0eWxlO1xuXG4gIHZhciBydWxlcyA9IHN0eWxlW3Byb3BLZXldO1xuXG4gIGlmICghcnVsZXMpIHJldHVybjtcblxuICBmb3IgKHZhciBuYW1lIGluIHJ1bGVzKSB7XG4gICAgb3B0aW9ucy5zaGVldC5hZGRSdWxlKG5hbWUsIHJ1bGVzW25hbWVdLCBfZXh0ZW5kcyh7fSwgb3B0aW9ucywge1xuICAgICAgc2VsZWN0b3I6IGFkZFNjb3BlKG5hbWUsIHJ1bGUuc2VsZWN0b3IpXG4gICAgfSkpO1xuICB9XG5cbiAgZGVsZXRlIHN0eWxlW3Byb3BLZXldO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVQcmVmaXhlZEdsb2JhbFJ1bGUocnVsZSkge1xuICB2YXIgb3B0aW9ucyA9IHJ1bGUub3B0aW9ucyxcbiAgICAgIHN0eWxlID0gcnVsZS5zdHlsZTtcblxuICBmb3IgKHZhciBwcm9wIGluIHN0eWxlKSB7XG4gICAgaWYgKHByb3Auc3Vic3RyKDAsIHByb3BLZXkubGVuZ3RoKSAhPT0gcHJvcEtleSkgY29udGludWU7XG5cbiAgICB2YXIgc2VsZWN0b3IgPSBhZGRTY29wZShwcm9wLnN1YnN0cihwcm9wS2V5Lmxlbmd0aCksIHJ1bGUuc2VsZWN0b3IpO1xuICAgIG9wdGlvbnMuc2hlZXQuYWRkUnVsZShzZWxlY3Rvciwgc3R5bGVbcHJvcF0sIF9leHRlbmRzKHt9LCBvcHRpb25zLCB7XG4gICAgICBzZWxlY3Rvcjogc2VsZWN0b3JcbiAgICB9KSk7XG4gICAgZGVsZXRlIHN0eWxlW3Byb3BdO1xuICB9XG59XG5cbi8qKlxuICogQ29udmVydCBuZXN0ZWQgcnVsZXMgdG8gc2VwYXJhdGUsIHJlbW92ZSB0aGVtIGZyb20gb3JpZ2luYWwgc3R5bGVzLlxuICpcbiAqIEBwYXJhbSB7UnVsZX0gcnVsZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuZnVuY3Rpb24ganNzR2xvYmFsKCkge1xuICBmdW5jdGlvbiBvbkNyZWF0ZVJ1bGUobmFtZSwgc3R5bGVzLCBvcHRpb25zKSB7XG4gICAgaWYgKG5hbWUgPT09IHByb3BLZXkpIHtcbiAgICAgIHJldHVybiBuZXcgR2xvYmFsQ29udGFpbmVyUnVsZShuYW1lLCBzdHlsZXMsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIGlmIChuYW1lWzBdID09PSAnQCcgJiYgbmFtZS5zdWJzdHIoMCwgcHJlZml4S2V5Lmxlbmd0aCkgPT09IHByZWZpeEtleSkge1xuICAgICAgcmV0dXJuIG5ldyBHbG9iYWxQcmVmaXhlZFJ1bGUobmFtZSwgc3R5bGVzLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICB2YXIgcGFyZW50ID0gb3B0aW9ucy5wYXJlbnQ7XG5cblxuICAgIGlmIChwYXJlbnQpIHtcbiAgICAgIGlmIChwYXJlbnQudHlwZSA9PT0gJ2dsb2JhbCcgfHwgcGFyZW50Lm9wdGlvbnMucGFyZW50LnR5cGUgPT09ICdnbG9iYWwnKSB7XG4gICAgICAgIG9wdGlvbnMuZ2xvYmFsID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5nbG9iYWwpIG9wdGlvbnMuc2VsZWN0b3IgPSBuYW1lO1xuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBvblByb2Nlc3NSdWxlKHJ1bGUpIHtcbiAgICBpZiAocnVsZS50eXBlICE9PSAnc3R5bGUnKSByZXR1cm47XG5cbiAgICBoYW5kbGVOZXN0ZWRHbG9iYWxDb250YWluZXJSdWxlKHJ1bGUpO1xuICAgIGhhbmRsZVByZWZpeGVkR2xvYmFsUnVsZShydWxlKTtcbiAgfVxuXG4gIHJldHVybiB7IG9uQ3JlYXRlUnVsZTogb25DcmVhdGVSdWxlLCBvblByb2Nlc3NSdWxlOiBvblByb2Nlc3NSdWxlIH07XG59IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBqc3NOZXN0ZWQ7XG5cbnZhciBfd2FybmluZyA9IHJlcXVpcmUoJ3dhcm5pbmcnKTtcblxudmFyIF93YXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dhcm5pbmcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgc2VwYXJhdG9yUmVnRXhwID0gL1xccyosXFxzKi9nO1xudmFyIHBhcmVudFJlZ0V4cCA9IC8mL2c7XG52YXIgcmVmUmVnRXhwID0gL1xcJChbXFx3LV0rKS9nO1xuXG4vKipcbiAqIENvbnZlcnQgbmVzdGVkIHJ1bGVzIHRvIHNlcGFyYXRlLCByZW1vdmUgdGhlbSBmcm9tIG9yaWdpbmFsIHN0eWxlcy5cbiAqXG4gKiBAcGFyYW0ge1J1bGV9IHJ1bGVcbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIGpzc05lc3RlZCgpIHtcbiAgLy8gR2V0IGEgZnVuY3Rpb24gdG8gYmUgdXNlZCBmb3IgJHJlZiByZXBsYWNlbWVudC5cbiAgZnVuY3Rpb24gZ2V0UmVwbGFjZVJlZihjb250YWluZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG1hdGNoLCBrZXkpIHtcbiAgICAgIHZhciBydWxlID0gY29udGFpbmVyLmdldFJ1bGUoa2V5KTtcbiAgICAgIGlmIChydWxlKSByZXR1cm4gcnVsZS5zZWxlY3RvcjtcbiAgICAgICgwLCBfd2FybmluZzIuZGVmYXVsdCkoZmFsc2UsICdbSlNTXSBDb3VsZCBub3QgZmluZCB0aGUgcmVmZXJlbmNlZCBydWxlICVzIGluICVzLicsIGtleSwgY29udGFpbmVyLm9wdGlvbnMubWV0YSB8fCBjb250YWluZXIpO1xuICAgICAgcmV0dXJuIGtleTtcbiAgICB9O1xuICB9XG5cbiAgdmFyIGhhc0FuZCA9IGZ1bmN0aW9uIGhhc0FuZChzdHIpIHtcbiAgICByZXR1cm4gc3RyLmluZGV4T2YoJyYnKSAhPT0gLTE7XG4gIH07XG5cbiAgZnVuY3Rpb24gcmVwbGFjZVBhcmVudFJlZnMobmVzdGVkUHJvcCwgcGFyZW50UHJvcCkge1xuICAgIHZhciBwYXJlbnRTZWxlY3RvcnMgPSBwYXJlbnRQcm9wLnNwbGl0KHNlcGFyYXRvclJlZ0V4cCk7XG4gICAgdmFyIG5lc3RlZFNlbGVjdG9ycyA9IG5lc3RlZFByb3Auc3BsaXQoc2VwYXJhdG9yUmVnRXhwKTtcblxuICAgIHZhciByZXN1bHQgPSAnJztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyZW50U2VsZWN0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcGFyZW50ID0gcGFyZW50U2VsZWN0b3JzW2ldO1xuXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG5lc3RlZFNlbGVjdG9ycy5sZW5ndGg7IGorKykge1xuICAgICAgICB2YXIgbmVzdGVkID0gbmVzdGVkU2VsZWN0b3JzW2pdO1xuICAgICAgICBpZiAocmVzdWx0KSByZXN1bHQgKz0gJywgJztcbiAgICAgICAgLy8gUmVwbGFjZSBhbGwgJiBieSB0aGUgcGFyZW50IG9yIHByZWZpeCAmIHdpdGggdGhlIHBhcmVudC5cbiAgICAgICAgcmVzdWx0ICs9IGhhc0FuZChuZXN0ZWQpID8gbmVzdGVkLnJlcGxhY2UocGFyZW50UmVnRXhwLCBwYXJlbnQpIDogcGFyZW50ICsgJyAnICsgbmVzdGVkO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRPcHRpb25zKHJ1bGUsIGNvbnRhaW5lciwgb3B0aW9ucykge1xuICAgIC8vIE9wdGlvbnMgaGFzIGJlZW4gYWxyZWFkeSBjcmVhdGVkLCBub3cgd2Ugb25seSBpbmNyZWFzZSBpbmRleC5cbiAgICBpZiAob3B0aW9ucykgcmV0dXJuIF9leHRlbmRzKHt9LCBvcHRpb25zLCB7IGluZGV4OiBvcHRpb25zLmluZGV4ICsgMSB9KTtcblxuICAgIHZhciBuZXN0aW5nTGV2ZWwgPSBydWxlLm9wdGlvbnMubmVzdGluZ0xldmVsO1xuXG4gICAgbmVzdGluZ0xldmVsID0gbmVzdGluZ0xldmVsID09PSB1bmRlZmluZWQgPyAxIDogbmVzdGluZ0xldmVsICsgMTtcblxuICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgcnVsZS5vcHRpb25zLCB7XG4gICAgICBuZXN0aW5nTGV2ZWw6IG5lc3RpbmdMZXZlbCxcbiAgICAgIGluZGV4OiBjb250YWluZXIuaW5kZXhPZihydWxlKSArIDFcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uUHJvY2Vzc1N0eWxlKHN0eWxlLCBydWxlKSB7XG4gICAgaWYgKHJ1bGUudHlwZSAhPT0gJ3N0eWxlJykgcmV0dXJuIHN0eWxlO1xuICAgIHZhciBjb250YWluZXIgPSBydWxlLm9wdGlvbnMucGFyZW50O1xuICAgIHZhciBvcHRpb25zID0gdm9pZCAwO1xuICAgIHZhciByZXBsYWNlUmVmID0gdm9pZCAwO1xuICAgIGZvciAodmFyIHByb3AgaW4gc3R5bGUpIHtcbiAgICAgIHZhciBpc05lc3RlZCA9IGhhc0FuZChwcm9wKTtcbiAgICAgIHZhciBpc05lc3RlZENvbmRpdGlvbmFsID0gcHJvcFswXSA9PT0gJ0AnO1xuXG4gICAgICBpZiAoIWlzTmVzdGVkICYmICFpc05lc3RlZENvbmRpdGlvbmFsKSBjb250aW51ZTtcblxuICAgICAgb3B0aW9ucyA9IGdldE9wdGlvbnMocnVsZSwgY29udGFpbmVyLCBvcHRpb25zKTtcblxuICAgICAgaWYgKGlzTmVzdGVkKSB7XG4gICAgICAgIHZhciBzZWxlY3RvciA9IHJlcGxhY2VQYXJlbnRSZWZzKHByb3AsIHJ1bGUuc2VsZWN0b3JcbiAgICAgICAgLy8gTGF6aWx5IGNyZWF0ZSB0aGUgcmVmIHJlcGxhY2VyIGZ1bmN0aW9uIGp1c3Qgb25jZSBmb3JcbiAgICAgICAgLy8gYWxsIG5lc3RlZCBydWxlcyB3aXRoaW4gdGhlIHNoZWV0LlxuICAgICAgICApO2lmICghcmVwbGFjZVJlZikgcmVwbGFjZVJlZiA9IGdldFJlcGxhY2VSZWYoY29udGFpbmVyXG4gICAgICAgIC8vIFJlcGxhY2UgYWxsICRyZWZzLlxuICAgICAgICApO3NlbGVjdG9yID0gc2VsZWN0b3IucmVwbGFjZShyZWZSZWdFeHAsIHJlcGxhY2VSZWYpO1xuXG4gICAgICAgIGNvbnRhaW5lci5hZGRSdWxlKHNlbGVjdG9yLCBzdHlsZVtwcm9wXSwgX2V4dGVuZHMoe30sIG9wdGlvbnMsIHsgc2VsZWN0b3I6IHNlbGVjdG9yIH0pKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNOZXN0ZWRDb25kaXRpb25hbCkge1xuICAgICAgICBjb250YWluZXJcbiAgICAgICAgLy8gUGxhY2UgY29uZGl0aW9uYWwgcmlnaHQgYWZ0ZXIgdGhlIHBhcmVudCBydWxlIHRvIGVuc3VyZSByaWdodCBvcmRlcmluZy5cbiAgICAgICAgLmFkZFJ1bGUocHJvcCwgbnVsbCwgb3B0aW9ucykuYWRkUnVsZShydWxlLmtleSwgc3R5bGVbcHJvcF0sIHsgc2VsZWN0b3I6IHJ1bGUuc2VsZWN0b3IgfSk7XG4gICAgICB9XG5cbiAgICAgIGRlbGV0ZSBzdHlsZVtwcm9wXTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3R5bGU7XG4gIH1cblxuICByZXR1cm4geyBvblByb2Nlc3NTdHlsZTogb25Qcm9jZXNzU3R5bGUgfTtcbn0iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfanNzVGVtcGxhdGUgPSByZXF1aXJlKCdqc3MtdGVtcGxhdGUnKTtcblxudmFyIF9qc3NUZW1wbGF0ZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9qc3NUZW1wbGF0ZSk7XG5cbnZhciBfanNzR2xvYmFsID0gcmVxdWlyZSgnanNzLWdsb2JhbCcpO1xuXG52YXIgX2pzc0dsb2JhbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9qc3NHbG9iYWwpO1xuXG52YXIgX2pzc0V4dGVuZCA9IHJlcXVpcmUoJ2pzcy1leHRlbmQnKTtcblxudmFyIF9qc3NFeHRlbmQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfanNzRXh0ZW5kKTtcblxudmFyIF9qc3NOZXN0ZWQgPSByZXF1aXJlKCdqc3MtbmVzdGVkJyk7XG5cbnZhciBfanNzTmVzdGVkMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2pzc05lc3RlZCk7XG5cbnZhciBfanNzQ29tcG9zZSA9IHJlcXVpcmUoJ2pzcy1jb21wb3NlJyk7XG5cbnZhciBfanNzQ29tcG9zZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9qc3NDb21wb3NlKTtcblxudmFyIF9qc3NDYW1lbENhc2UgPSByZXF1aXJlKCdqc3MtY2FtZWwtY2FzZScpO1xuXG52YXIgX2pzc0NhbWVsQ2FzZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9qc3NDYW1lbENhc2UpO1xuXG52YXIgX2pzc0RlZmF1bHRVbml0ID0gcmVxdWlyZSgnanNzLWRlZmF1bHQtdW5pdCcpO1xuXG52YXIgX2pzc0RlZmF1bHRVbml0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2pzc0RlZmF1bHRVbml0KTtcblxudmFyIF9qc3NFeHBhbmQgPSByZXF1aXJlKCdqc3MtZXhwYW5kJyk7XG5cbnZhciBfanNzRXhwYW5kMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2pzc0V4cGFuZCk7XG5cbnZhciBfanNzVmVuZG9yUHJlZml4ZXIgPSByZXF1aXJlKCdqc3MtdmVuZG9yLXByZWZpeGVyJyk7XG5cbnZhciBfanNzVmVuZG9yUHJlZml4ZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfanNzVmVuZG9yUHJlZml4ZXIpO1xuXG52YXIgX2pzc1Byb3BzU29ydCA9IHJlcXVpcmUoJ2pzcy1wcm9wcy1zb3J0Jyk7XG5cbnZhciBfanNzUHJvcHNTb3J0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2pzc1Byb3BzU29ydCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICByZXR1cm4ge1xuICAgIHBsdWdpbnM6IFsoMCwgX2pzc1RlbXBsYXRlMi5kZWZhdWx0KShvcHRpb25zLnRlbXBsYXRlKSwgKDAsIF9qc3NHbG9iYWwyLmRlZmF1bHQpKG9wdGlvbnMuZ2xvYmFsKSwgKDAsIF9qc3NFeHRlbmQyLmRlZmF1bHQpKG9wdGlvbnMuZXh0ZW5kKSwgKDAsIF9qc3NOZXN0ZWQyLmRlZmF1bHQpKG9wdGlvbnMubmVzdGVkKSwgKDAsIF9qc3NDb21wb3NlMi5kZWZhdWx0KShvcHRpb25zLmNvbXBvc2UpLCAoMCwgX2pzc0NhbWVsQ2FzZTIuZGVmYXVsdCkob3B0aW9ucy5jYW1lbENhc2UpLCAoMCwgX2pzc0RlZmF1bHRVbml0Mi5kZWZhdWx0KShvcHRpb25zLmRlZmF1bHRVbml0KSwgKDAsIF9qc3NFeHBhbmQyLmRlZmF1bHQpKG9wdGlvbnMuZXhwYW5kKSwgKDAsIF9qc3NWZW5kb3JQcmVmaXhlcjIuZGVmYXVsdCkob3B0aW9ucy52ZW5kb3JQcmVmaXhlciksICgwLCBfanNzUHJvcHNTb3J0Mi5kZWZhdWx0KShvcHRpb25zLnByb3BzU29ydCldXG4gIH07XG59OyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGpzc1Byb3BzU29ydDtcbi8qKlxuICogU29ydCBwcm9wcyBieSBsZW5ndGguXG4gKi9cbmZ1bmN0aW9uIGpzc1Byb3BzU29ydCgpIHtcbiAgZnVuY3Rpb24gc29ydChwcm9wMCwgcHJvcDEpIHtcbiAgICByZXR1cm4gcHJvcDAubGVuZ3RoIC0gcHJvcDEubGVuZ3RoO1xuICB9XG5cbiAgZnVuY3Rpb24gb25Qcm9jZXNzU3R5bGUoc3R5bGUsIHJ1bGUpIHtcbiAgICBpZiAocnVsZS50eXBlICE9PSAnc3R5bGUnKSByZXR1cm4gc3R5bGU7XG5cbiAgICB2YXIgbmV3U3R5bGUgPSB7fTtcbiAgICB2YXIgcHJvcHMgPSBPYmplY3Qua2V5cyhzdHlsZSkuc29ydChzb3J0KTtcbiAgICBmb3IgKHZhciBwcm9wIGluIHByb3BzKSB7XG4gICAgICBuZXdTdHlsZVtwcm9wc1twcm9wXV0gPSBzdHlsZVtwcm9wc1twcm9wXV07XG4gICAgfVxuICAgIHJldHVybiBuZXdTdHlsZTtcbiAgfVxuXG4gIHJldHVybiB7IG9uUHJvY2Vzc1N0eWxlOiBvblByb2Nlc3NTdHlsZSB9O1xufSIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9wYXJzZSA9IHJlcXVpcmUoJy4vcGFyc2UnKTtcblxudmFyIF9wYXJzZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wYXJzZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIG9uUHJvY2Vzc1J1bGUgPSBmdW5jdGlvbiBvblByb2Nlc3NSdWxlKHJ1bGUpIHtcbiAgaWYgKHR5cGVvZiBydWxlLnN0eWxlID09PSAnc3RyaW5nJykge1xuICAgIHJ1bGUuc3R5bGUgPSAoMCwgX3BhcnNlMlsnZGVmYXVsdCddKShydWxlLnN0eWxlKTtcbiAgfVxufTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4geyBvblByb2Nlc3NSdWxlOiBvblByb2Nlc3NSdWxlIH07XG59OyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF93YXJuaW5nID0gcmVxdWlyZSgnd2FybmluZycpO1xuXG52YXIgX3dhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd2FybmluZyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIHNlbWlXaXRoTmwgPSAvO1xcbi87XG5cbi8qKlxuICogTmFpdmUgQ1NTIHBhcnNlci5cbiAqIC0gU3VwcG9ydHMgb25seSBydWxlIGJvZHkgKG5vIHNlbGVjdG9ycylcbiAqIC0gUmVxdWlyZXMgc2VtaWNvbG9uIGFuZCBuZXcgbGluZSBhZnRlciB0aGUgdmFsdWUgKGV4Y2VwdCBvZiBsYXN0IGxpbmUpXG4gKiAtIE5vIG5lc3RlZCBydWxlcyBzdXBwb3J0XG4gKi9cblxuZXhwb3J0c1snZGVmYXVsdCddID0gZnVuY3Rpb24gKGNzc1RleHQpIHtcbiAgdmFyIHN0eWxlID0ge307XG4gIHZhciBzcGxpdCA9IGNzc1RleHQuc3BsaXQoc2VtaVdpdGhObCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3BsaXQubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVjbCA9IChzcGxpdFtpXSB8fCAnJykudHJpbSgpO1xuXG4gICAgaWYgKCFkZWNsKSBjb250aW51ZTtcbiAgICB2YXIgY29sb25JbmRleCA9IGRlY2wuaW5kZXhPZignOicpO1xuICAgIGlmIChjb2xvbkluZGV4ID09PSAtMSkge1xuICAgICAgKDAsIF93YXJuaW5nMlsnZGVmYXVsdCddKShmYWxzZSwgJ01hbGZvcm1lZCBDU1Mgc3RyaW5nIFwiJXNcIicsIGRlY2wpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBwcm9wID0gZGVjbC5zdWJzdHIoMCwgY29sb25JbmRleCkudHJpbSgpO1xuICAgIHZhciB2YWx1ZSA9IGRlY2wuc3Vic3RyKGNvbG9uSW5kZXggKyAxKS50cmltKCk7XG4gICAgc3R5bGVbcHJvcF0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gc3R5bGU7XG59OyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGpzc1ZlbmRvclByZWZpeGVyO1xuXG52YXIgX2Nzc1ZlbmRvciA9IHJlcXVpcmUoJ2Nzcy12ZW5kb3InKTtcblxudmFyIHZlbmRvciA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9jc3NWZW5kb3IpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gbmV3T2JqWydkZWZhdWx0J10gPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG4vKipcbiAqIEFkZCB2ZW5kb3IgcHJlZml4IHRvIGEgcHJvcGVydHkgbmFtZSB3aGVuIG5lZWRlZC5cbiAqXG4gKiBAcGFyYW0ge1J1bGV9IHJ1bGVcbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIGpzc1ZlbmRvclByZWZpeGVyKCkge1xuICBmdW5jdGlvbiBvblByb2Nlc3NSdWxlKHJ1bGUpIHtcbiAgICBpZiAocnVsZS50eXBlID09PSAna2V5ZnJhbWVzJykge1xuICAgICAgcnVsZS5rZXkgPSAnQCcgKyB2ZW5kb3IucHJlZml4LmNzcyArIHJ1bGUua2V5LnN1YnN0cigxKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvblByb2Nlc3NTdHlsZShzdHlsZSwgcnVsZSkge1xuICAgIGlmIChydWxlLnR5cGUgIT09ICdzdHlsZScpIHJldHVybiBzdHlsZTtcblxuICAgIGZvciAodmFyIHByb3AgaW4gc3R5bGUpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHN0eWxlW3Byb3BdO1xuXG4gICAgICB2YXIgY2hhbmdlUHJvcCA9IGZhbHNlO1xuICAgICAgdmFyIHN1cHBvcnRlZFByb3AgPSB2ZW5kb3Iuc3VwcG9ydGVkUHJvcGVydHkocHJvcCk7XG4gICAgICBpZiAoc3VwcG9ydGVkUHJvcCAmJiBzdXBwb3J0ZWRQcm9wICE9PSBwcm9wKSBjaGFuZ2VQcm9wID0gdHJ1ZTtcblxuICAgICAgdmFyIGNoYW5nZVZhbHVlID0gZmFsc2U7XG4gICAgICB2YXIgc3VwcG9ydGVkVmFsdWUgPSB2ZW5kb3Iuc3VwcG9ydGVkVmFsdWUoc3VwcG9ydGVkUHJvcCwgdmFsdWUpO1xuICAgICAgaWYgKHN1cHBvcnRlZFZhbHVlICYmIHN1cHBvcnRlZFZhbHVlICE9PSB2YWx1ZSkgY2hhbmdlVmFsdWUgPSB0cnVlO1xuXG4gICAgICBpZiAoY2hhbmdlUHJvcCB8fCBjaGFuZ2VWYWx1ZSkge1xuICAgICAgICBpZiAoY2hhbmdlUHJvcCkgZGVsZXRlIHN0eWxlW3Byb3BdO1xuICAgICAgICBzdHlsZVtzdXBwb3J0ZWRQcm9wIHx8IHByb3BdID0gc3VwcG9ydGVkVmFsdWUgfHwgdmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0eWxlO1xuICB9XG5cbiAgZnVuY3Rpb24gb25DaGFuZ2VWYWx1ZSh2YWx1ZSwgcHJvcCkge1xuICAgIHJldHVybiB2ZW5kb3Iuc3VwcG9ydGVkVmFsdWUocHJvcCwgdmFsdWUpO1xuICB9XG5cbiAgcmV0dXJuIHsgb25Qcm9jZXNzUnVsZTogb25Qcm9jZXNzUnVsZSwgb25Qcm9jZXNzU3R5bGU6IG9uUHJvY2Vzc1N0eWxlLCBvbkNoYW5nZVZhbHVlOiBvbkNoYW5nZVZhbHVlIH07XG59IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfaXNJbkJyb3dzZXIgPSByZXF1aXJlKCdpcy1pbi1icm93c2VyJyk7XG5cbnZhciBfaXNJbkJyb3dzZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaXNJbkJyb3dzZXIpO1xuXG52YXIgX1N0eWxlU2hlZXQgPSByZXF1aXJlKCcuL1N0eWxlU2hlZXQnKTtcblxudmFyIF9TdHlsZVNoZWV0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1N0eWxlU2hlZXQpO1xuXG52YXIgX1BsdWdpbnNSZWdpc3RyeSA9IHJlcXVpcmUoJy4vUGx1Z2luc1JlZ2lzdHJ5Jyk7XG5cbnZhciBfUGx1Z2luc1JlZ2lzdHJ5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1BsdWdpbnNSZWdpc3RyeSk7XG5cbnZhciBfcnVsZXMgPSByZXF1aXJlKCcuL3BsdWdpbnMvcnVsZXMnKTtcblxudmFyIF9ydWxlczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ydWxlcyk7XG5cbnZhciBfb2JzZXJ2YWJsZXMgPSByZXF1aXJlKCcuL3BsdWdpbnMvb2JzZXJ2YWJsZXMnKTtcblxudmFyIF9vYnNlcnZhYmxlczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9vYnNlcnZhYmxlcyk7XG5cbnZhciBfZnVuY3Rpb25zID0gcmVxdWlyZSgnLi9wbHVnaW5zL2Z1bmN0aW9ucycpO1xuXG52YXIgX2Z1bmN0aW9uczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9mdW5jdGlvbnMpO1xuXG52YXIgX3NoZWV0cyA9IHJlcXVpcmUoJy4vc2hlZXRzJyk7XG5cbnZhciBfc2hlZXRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3NoZWV0cyk7XG5cbnZhciBfU3R5bGVSdWxlID0gcmVxdWlyZSgnLi9ydWxlcy9TdHlsZVJ1bGUnKTtcblxudmFyIF9TdHlsZVJ1bGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU3R5bGVSdWxlKTtcblxudmFyIF9jcmVhdGVHZW5lcmF0ZUNsYXNzTmFtZSA9IHJlcXVpcmUoJy4vdXRpbHMvY3JlYXRlR2VuZXJhdGVDbGFzc05hbWUnKTtcblxudmFyIF9jcmVhdGVHZW5lcmF0ZUNsYXNzTmFtZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVHZW5lcmF0ZUNsYXNzTmFtZSk7XG5cbnZhciBfY3JlYXRlUnVsZTIgPSByZXF1aXJlKCcuL3V0aWxzL2NyZWF0ZVJ1bGUnKTtcblxudmFyIF9jcmVhdGVSdWxlMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZVJ1bGUyKTtcblxudmFyIF9Eb21SZW5kZXJlciA9IHJlcXVpcmUoJy4vcmVuZGVyZXJzL0RvbVJlbmRlcmVyJyk7XG5cbnZhciBfRG9tUmVuZGVyZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfRG9tUmVuZGVyZXIpO1xuXG52YXIgX1ZpcnR1YWxSZW5kZXJlciA9IHJlcXVpcmUoJy4vcmVuZGVyZXJzL1ZpcnR1YWxSZW5kZXJlcicpO1xuXG52YXIgX1ZpcnR1YWxSZW5kZXJlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9WaXJ0dWFsUmVuZGVyZXIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBkZWZhdWx0UGx1Z2lucyA9IF9ydWxlczJbJ2RlZmF1bHQnXS5jb25jYXQoW19vYnNlcnZhYmxlczJbJ2RlZmF1bHQnXSwgX2Z1bmN0aW9uczJbJ2RlZmF1bHQnXV0pO1xuXG52YXIgaW5zdGFuY2VDb3VudGVyID0gMDtcblxudmFyIEpzcyA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gSnNzKG9wdGlvbnMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSnNzKTtcblxuICAgIHRoaXMuaWQgPSBpbnN0YW5jZUNvdW50ZXIrKztcbiAgICB0aGlzLnZlcnNpb24gPSBcIjkuNS4xXCI7XG4gICAgdGhpcy5wbHVnaW5zID0gbmV3IF9QbHVnaW5zUmVnaXN0cnkyWydkZWZhdWx0J10oKTtcbiAgICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgICBjcmVhdGVHZW5lcmF0ZUNsYXNzTmFtZTogX2NyZWF0ZUdlbmVyYXRlQ2xhc3NOYW1lMlsnZGVmYXVsdCddLFxuICAgICAgUmVuZGVyZXI6IF9pc0luQnJvd3NlcjJbJ2RlZmF1bHQnXSA/IF9Eb21SZW5kZXJlcjJbJ2RlZmF1bHQnXSA6IF9WaXJ0dWFsUmVuZGVyZXIyWydkZWZhdWx0J10sXG4gICAgICBwbHVnaW5zOiBbXVxuICAgIH07XG4gICAgdGhpcy5nZW5lcmF0ZUNsYXNzTmFtZSA9ICgwLCBfY3JlYXRlR2VuZXJhdGVDbGFzc05hbWUyWydkZWZhdWx0J10pKCk7XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLXNwcmVhZFxuICAgIHRoaXMudXNlLmFwcGx5KHRoaXMsIGRlZmF1bHRQbHVnaW5zKTtcbiAgICB0aGlzLnNldHVwKG9wdGlvbnMpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEpzcywgW3tcbiAgICBrZXk6ICdzZXR1cCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldHVwKCkge1xuICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgICBpZiAob3B0aW9ucy5jcmVhdGVHZW5lcmF0ZUNsYXNzTmFtZSkge1xuICAgICAgICB0aGlzLm9wdGlvbnMuY3JlYXRlR2VuZXJhdGVDbGFzc05hbWUgPSBvcHRpb25zLmNyZWF0ZUdlbmVyYXRlQ2xhc3NOYW1lO1xuICAgICAgICAvLyAkRmxvd0ZpeE1lXG4gICAgICAgIHRoaXMuZ2VuZXJhdGVDbGFzc05hbWUgPSBvcHRpb25zLmNyZWF0ZUdlbmVyYXRlQ2xhc3NOYW1lKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLmluc2VydGlvblBvaW50ICE9IG51bGwpIHRoaXMub3B0aW9ucy5pbnNlcnRpb25Qb2ludCA9IG9wdGlvbnMuaW5zZXJ0aW9uUG9pbnQ7XG4gICAgICBpZiAob3B0aW9ucy52aXJ0dWFsIHx8IG9wdGlvbnMuUmVuZGVyZXIpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLlJlbmRlcmVyID0gb3B0aW9ucy5SZW5kZXJlciB8fCAob3B0aW9ucy52aXJ0dWFsID8gX1ZpcnR1YWxSZW5kZXJlcjJbJ2RlZmF1bHQnXSA6IF9Eb21SZW5kZXJlcjJbJ2RlZmF1bHQnXSk7XG4gICAgICB9XG5cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItc3ByZWFkXG4gICAgICBpZiAob3B0aW9ucy5wbHVnaW5zKSB0aGlzLnVzZS5hcHBseSh0aGlzLCBvcHRpb25zLnBsdWdpbnMpO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBTdHlsZSBTaGVldC5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnY3JlYXRlU3R5bGVTaGVldCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZVN0eWxlU2hlZXQoc3R5bGVzKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICAgIHZhciBpbmRleCA9IG9wdGlvbnMuaW5kZXg7XG4gICAgICBpZiAodHlwZW9mIGluZGV4ICE9PSAnbnVtYmVyJykge1xuICAgICAgICBpbmRleCA9IF9zaGVldHMyWydkZWZhdWx0J10uaW5kZXggPT09IDAgPyAwIDogX3NoZWV0czJbJ2RlZmF1bHQnXS5pbmRleCArIDE7XG4gICAgICB9XG4gICAgICB2YXIgc2hlZXQgPSBuZXcgX1N0eWxlU2hlZXQyWydkZWZhdWx0J10oc3R5bGVzLCBfZXh0ZW5kcyh7fSwgb3B0aW9ucywge1xuICAgICAgICBqc3M6IHRoaXMsXG4gICAgICAgIGdlbmVyYXRlQ2xhc3NOYW1lOiBvcHRpb25zLmdlbmVyYXRlQ2xhc3NOYW1lIHx8IHRoaXMuZ2VuZXJhdGVDbGFzc05hbWUsXG4gICAgICAgIGluc2VydGlvblBvaW50OiB0aGlzLm9wdGlvbnMuaW5zZXJ0aW9uUG9pbnQsXG4gICAgICAgIFJlbmRlcmVyOiB0aGlzLm9wdGlvbnMuUmVuZGVyZXIsXG4gICAgICAgIGluZGV4OiBpbmRleFxuICAgICAgfSkpO1xuICAgICAgdGhpcy5wbHVnaW5zLm9uUHJvY2Vzc1NoZWV0KHNoZWV0KTtcblxuICAgICAgcmV0dXJuIHNoZWV0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERldGFjaCB0aGUgU3R5bGUgU2hlZXQgYW5kIHJlbW92ZSBpdCBmcm9tIHRoZSByZWdpc3RyeS5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAncmVtb3ZlU3R5bGVTaGVldCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZVN0eWxlU2hlZXQoc2hlZXQpIHtcbiAgICAgIHNoZWV0LmRldGFjaCgpO1xuICAgICAgX3NoZWV0czJbJ2RlZmF1bHQnXS5yZW1vdmUoc2hlZXQpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgcnVsZSB3aXRob3V0IGEgU3R5bGUgU2hlZXQuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2NyZWF0ZVJ1bGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVSdWxlKG5hbWUpIHtcbiAgICAgIHZhciBzdHlsZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG5cbiAgICAgIC8vIEVuYWJsZSBydWxlIHdpdGhvdXQgbmFtZSBmb3IgaW5saW5lIHN0eWxlcy5cbiAgICAgIGlmICgodHlwZW9mIG5hbWUgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKG5hbWUpKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgb3B0aW9ucyA9IHN0eWxlO1xuICAgICAgICBzdHlsZSA9IG5hbWU7XG4gICAgICAgIG5hbWUgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIC8vIENhc3QgZnJvbSBSdWxlRmFjdG9yeU9wdGlvbnMgdG8gUnVsZU9wdGlvbnNcbiAgICAgIC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzQxMzI4NzI4L2ZvcmNlLWNhc3RpbmctaW4tZmxvd1xuICAgICAgdmFyIHJ1bGVPcHRpb25zID0gb3B0aW9ucztcblxuICAgICAgcnVsZU9wdGlvbnMuanNzID0gdGhpcztcbiAgICAgIHJ1bGVPcHRpb25zLlJlbmRlcmVyID0gdGhpcy5vcHRpb25zLlJlbmRlcmVyO1xuICAgICAgaWYgKCFydWxlT3B0aW9ucy5nZW5lcmF0ZUNsYXNzTmFtZSkgcnVsZU9wdGlvbnMuZ2VuZXJhdGVDbGFzc05hbWUgPSB0aGlzLmdlbmVyYXRlQ2xhc3NOYW1lO1xuICAgICAgaWYgKCFydWxlT3B0aW9ucy5jbGFzc2VzKSBydWxlT3B0aW9ucy5jbGFzc2VzID0ge307XG4gICAgICB2YXIgcnVsZSA9ICgwLCBfY3JlYXRlUnVsZTNbJ2RlZmF1bHQnXSkobmFtZSwgc3R5bGUsIHJ1bGVPcHRpb25zKTtcblxuICAgICAgaWYgKCFydWxlT3B0aW9ucy5zZWxlY3RvciAmJiBydWxlIGluc3RhbmNlb2YgX1N0eWxlUnVsZTJbJ2RlZmF1bHQnXSkge1xuICAgICAgICBydWxlLnNlbGVjdG9yID0gJy4nICsgcnVsZU9wdGlvbnMuZ2VuZXJhdGVDbGFzc05hbWUocnVsZSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucGx1Z2lucy5vblByb2Nlc3NSdWxlKHJ1bGUpO1xuXG4gICAgICByZXR1cm4gcnVsZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlciBwbHVnaW4uIFBhc3NlZCBmdW5jdGlvbiB3aWxsIGJlIGludm9rZWQgd2l0aCBhIHJ1bGUgaW5zdGFuY2UuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3VzZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVzZSgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBwbHVnaW5zID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIHBsdWdpbnNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIHBsdWdpbnMuZm9yRWFjaChmdW5jdGlvbiAocGx1Z2luKSB7XG4gICAgICAgIC8vIEF2b2lkcyBhcHBseWluZyBzYW1lIHBsdWdpbiB0d2ljZSwgYXQgbGVhc3QgYmFzZWQgb24gcmVmLlxuICAgICAgICBpZiAoX3RoaXMub3B0aW9ucy5wbHVnaW5zLmluZGV4T2YocGx1Z2luKSA9PT0gLTEpIHtcbiAgICAgICAgICBfdGhpcy5vcHRpb25zLnBsdWdpbnMucHVzaChwbHVnaW4pO1xuICAgICAgICAgIF90aGlzLnBsdWdpbnMudXNlKHBsdWdpbik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gSnNzO1xufSgpO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBKc3M7IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX3dhcm5pbmcgPSByZXF1aXJlKCd3YXJuaW5nJyk7XG5cbnZhciBfd2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93YXJuaW5nKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgUGx1Z2luc1JlZ2lzdHJ5ID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBQbHVnaW5zUmVnaXN0cnkoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBsdWdpbnNSZWdpc3RyeSk7XG5cbiAgICB0aGlzLmhvb2tzID0ge1xuICAgICAgb25DcmVhdGVSdWxlOiBbXSxcbiAgICAgIG9uUHJvY2Vzc1J1bGU6IFtdLFxuICAgICAgb25Qcm9jZXNzU3R5bGU6IFtdLFxuICAgICAgb25Qcm9jZXNzU2hlZXQ6IFtdLFxuICAgICAgb25DaGFuZ2VWYWx1ZTogW10sXG4gICAgICBvblVwZGF0ZTogW11cblxuICAgICAgLyoqXG4gICAgICAgKiBDYWxsIGBvbkNyZWF0ZVJ1bGVgIGhvb2tzIGFuZCByZXR1cm4gYW4gb2JqZWN0IGlmIHJldHVybmVkIGJ5IGEgaG9vay5cbiAgICAgICAqL1xuICAgIH07XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoUGx1Z2luc1JlZ2lzdHJ5LCBbe1xuICAgIGtleTogJ29uQ3JlYXRlUnVsZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uQ3JlYXRlUnVsZShuYW1lLCBkZWNsLCBvcHRpb25zKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaG9va3Mub25DcmVhdGVSdWxlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBydWxlID0gdGhpcy5ob29rcy5vbkNyZWF0ZVJ1bGVbaV0obmFtZSwgZGVjbCwgb3B0aW9ucyk7XG4gICAgICAgIGlmIChydWxlKSByZXR1cm4gcnVsZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGwgYG9uUHJvY2Vzc1J1bGVgIGhvb2tzLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdvblByb2Nlc3NSdWxlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25Qcm9jZXNzUnVsZShydWxlKSB7XG4gICAgICBpZiAocnVsZS5pc1Byb2Nlc3NlZCkgcmV0dXJuO1xuICAgICAgdmFyIHNoZWV0ID0gcnVsZS5vcHRpb25zLnNoZWV0O1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaG9va3Mub25Qcm9jZXNzUnVsZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLmhvb2tzLm9uUHJvY2Vzc1J1bGVbaV0ocnVsZSwgc2hlZXQpO1xuICAgICAgfVxuXG4gICAgICAvLyAkRmxvd0ZpeE1lXG4gICAgICBpZiAocnVsZS5zdHlsZSkgdGhpcy5vblByb2Nlc3NTdHlsZShydWxlLnN0eWxlLCBydWxlLCBzaGVldCk7XG5cbiAgICAgIHJ1bGUuaXNQcm9jZXNzZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGwgYG9uUHJvY2Vzc1N0eWxlYCBob29rcy5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnb25Qcm9jZXNzU3R5bGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvblByb2Nlc3NTdHlsZShzdHlsZSwgcnVsZSwgc2hlZXQpIHtcbiAgICAgIHZhciBuZXh0U3R5bGUgPSBzdHlsZTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmhvb2tzLm9uUHJvY2Vzc1N0eWxlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG5leHRTdHlsZSA9IHRoaXMuaG9va3Mub25Qcm9jZXNzU3R5bGVbaV0obmV4dFN0eWxlLCBydWxlLCBzaGVldCk7XG4gICAgICAgIC8vICRGbG93Rml4TWVcbiAgICAgICAgcnVsZS5zdHlsZSA9IG5leHRTdHlsZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxsIGBvblByb2Nlc3NTaGVldGAgaG9va3MuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ29uUHJvY2Vzc1NoZWV0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25Qcm9jZXNzU2hlZXQoc2hlZXQpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ob29rcy5vblByb2Nlc3NTaGVldC5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLmhvb2tzLm9uUHJvY2Vzc1NoZWV0W2ldKHNoZWV0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxsIGBvblVwZGF0ZWAgaG9va3MuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ29uVXBkYXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25VcGRhdGUoZGF0YSwgcnVsZSwgc2hlZXQpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ob29rcy5vblVwZGF0ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLmhvb2tzLm9uVXBkYXRlW2ldKGRhdGEsIHJ1bGUsIHNoZWV0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxsIGBvbkNoYW5nZVZhbHVlYCBob29rcy5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnb25DaGFuZ2VWYWx1ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uQ2hhbmdlVmFsdWUodmFsdWUsIHByb3AsIHJ1bGUpIHtcbiAgICAgIHZhciBwcm9jZXNzZWRWYWx1ZSA9IHZhbHVlO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmhvb2tzLm9uQ2hhbmdlVmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcHJvY2Vzc2VkVmFsdWUgPSB0aGlzLmhvb2tzLm9uQ2hhbmdlVmFsdWVbaV0ocHJvY2Vzc2VkVmFsdWUsIHByb3AsIHJ1bGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHByb2Nlc3NlZFZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIGEgcGx1Z2luLlxuICAgICAqIElmIGZ1bmN0aW9uIGlzIHBhc3NlZCwgaXQgaXMgYSBzaG9ydGN1dCBmb3IgYHtvblByb2Nlc3NSdWxlfWAuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3VzZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVzZShwbHVnaW4pIHtcbiAgICAgIGZvciAodmFyIG5hbWUgaW4gcGx1Z2luKSB7XG4gICAgICAgIGlmICh0aGlzLmhvb2tzW25hbWVdKSB0aGlzLmhvb2tzW25hbWVdLnB1c2gocGx1Z2luW25hbWVdKTtlbHNlICgwLCBfd2FybmluZzJbJ2RlZmF1bHQnXSkoZmFsc2UsICdbSlNTXSBVbmtub3duIGhvb2sgXCIlc1wiLicsIG5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBQbHVnaW5zUmVnaXN0cnk7XG59KCk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IFBsdWdpbnNSZWdpc3RyeTsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfY3JlYXRlUnVsZSA9IHJlcXVpcmUoJy4vdXRpbHMvY3JlYXRlUnVsZScpO1xuXG52YXIgX2NyZWF0ZVJ1bGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlUnVsZSk7XG5cbnZhciBfbGlua1J1bGUgPSByZXF1aXJlKCcuL3V0aWxzL2xpbmtSdWxlJyk7XG5cbnZhciBfbGlua1J1bGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbGlua1J1bGUpO1xuXG52YXIgX1N0eWxlUnVsZSA9IHJlcXVpcmUoJy4vcnVsZXMvU3R5bGVSdWxlJyk7XG5cbnZhciBfU3R5bGVSdWxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1N0eWxlUnVsZSk7XG5cbnZhciBfZXNjYXBlID0gcmVxdWlyZSgnLi91dGlscy9lc2NhcGUnKTtcblxudmFyIF9lc2NhcGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZXNjYXBlKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4vKipcbiAqIENvbnRhaW5zIHJ1bGVzIG9iamVjdHMgYW5kIGFsbG93cyBhZGRpbmcvcmVtb3ZpbmcgZXRjLlxuICogSXMgdXNlZCBmb3IgZS5nLiBieSBgU3R5bGVTaGVldGAgb3IgYENvbmRpdGlvbmFsUnVsZWAuXG4gKi9cbnZhciBSdWxlTGlzdCA9IGZ1bmN0aW9uICgpIHtcblxuICAvLyBPcmlnaW5hbCBzdHlsZXMgb2JqZWN0LlxuICBmdW5jdGlvbiBSdWxlTGlzdChvcHRpb25zKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJ1bGVMaXN0KTtcblxuICAgIHRoaXMubWFwID0ge307XG4gICAgdGhpcy5yYXcgPSB7fTtcbiAgICB0aGlzLmluZGV4ID0gW107XG5cbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuY2xhc3NlcyA9IG9wdGlvbnMuY2xhc3NlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW5kIHJlZ2lzdGVyIHJ1bGUuXG4gICAqXG4gICAqIFdpbGwgbm90IHJlbmRlciBhZnRlciBTdHlsZSBTaGVldCB3YXMgcmVuZGVyZWQgdGhlIGZpcnN0IHRpbWUuXG4gICAqL1xuXG5cbiAgLy8gVXNlZCB0byBlbnN1cmUgY29ycmVjdCBydWxlcyBvcmRlci5cblxuICAvLyBSdWxlcyByZWdpc3RyeSBmb3IgYWNjZXNzIGJ5IC5nZXQoKSBtZXRob2QuXG4gIC8vIEl0IGNvbnRhaW5zIHRoZSBzYW1lIHJ1bGUgcmVnaXN0ZXJlZCBieSBuYW1lIGFuZCBieSBzZWxlY3Rvci5cblxuXG4gIF9jcmVhdGVDbGFzcyhSdWxlTGlzdCwgW3tcbiAgICBrZXk6ICdhZGQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGQobmFtZSwgZGVjbCwgb3B0aW9ucykge1xuICAgICAgdmFyIF9vcHRpb25zID0gdGhpcy5vcHRpb25zLFxuICAgICAgICAgIHBhcmVudCA9IF9vcHRpb25zLnBhcmVudCxcbiAgICAgICAgICBzaGVldCA9IF9vcHRpb25zLnNoZWV0LFxuICAgICAgICAgIGpzcyA9IF9vcHRpb25zLmpzcyxcbiAgICAgICAgICBSZW5kZXJlciA9IF9vcHRpb25zLlJlbmRlcmVyLFxuICAgICAgICAgIGdlbmVyYXRlQ2xhc3NOYW1lID0gX29wdGlvbnMuZ2VuZXJhdGVDbGFzc05hbWU7XG5cblxuICAgICAgb3B0aW9ucyA9IF9leHRlbmRzKHtcbiAgICAgICAgY2xhc3NlczogdGhpcy5jbGFzc2VzLFxuICAgICAgICBwYXJlbnQ6IHBhcmVudCxcbiAgICAgICAgc2hlZXQ6IHNoZWV0LFxuICAgICAgICBqc3M6IGpzcyxcbiAgICAgICAgUmVuZGVyZXI6IFJlbmRlcmVyLFxuICAgICAgICBnZW5lcmF0ZUNsYXNzTmFtZTogZ2VuZXJhdGVDbGFzc05hbWVcbiAgICAgIH0sIG9wdGlvbnMpO1xuXG4gICAgICBpZiAoIW9wdGlvbnMuc2VsZWN0b3IgJiYgdGhpcy5jbGFzc2VzW25hbWVdKSB7XG4gICAgICAgIG9wdGlvbnMuc2VsZWN0b3IgPSAnLicgKyAoMCwgX2VzY2FwZTJbJ2RlZmF1bHQnXSkodGhpcy5jbGFzc2VzW25hbWVdKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5yYXdbbmFtZV0gPSBkZWNsO1xuXG4gICAgICB2YXIgcnVsZSA9ICgwLCBfY3JlYXRlUnVsZTJbJ2RlZmF1bHQnXSkobmFtZSwgZGVjbCwgb3B0aW9ucyk7XG5cbiAgICAgIHZhciBjbGFzc05hbWUgPSB2b2lkIDA7XG5cbiAgICAgIGlmICghb3B0aW9ucy5zZWxlY3RvciAmJiBydWxlIGluc3RhbmNlb2YgX1N0eWxlUnVsZTJbJ2RlZmF1bHQnXSkge1xuICAgICAgICBjbGFzc05hbWUgPSBnZW5lcmF0ZUNsYXNzTmFtZShydWxlLCBzaGVldCk7XG4gICAgICAgIHJ1bGUuc2VsZWN0b3IgPSAnLicgKyAoMCwgX2VzY2FwZTJbJ2RlZmF1bHQnXSkoY2xhc3NOYW1lKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5yZWdpc3RlcihydWxlLCBjbGFzc05hbWUpO1xuXG4gICAgICB2YXIgaW5kZXggPSBvcHRpb25zLmluZGV4ID09PSB1bmRlZmluZWQgPyB0aGlzLmluZGV4Lmxlbmd0aCA6IG9wdGlvbnMuaW5kZXg7XG4gICAgICB0aGlzLmluZGV4LnNwbGljZShpbmRleCwgMCwgcnVsZSk7XG5cbiAgICAgIHJldHVybiBydWxlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBhIHJ1bGUuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2dldCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldChuYW1lKSB7XG4gICAgICByZXR1cm4gdGhpcy5tYXBbbmFtZV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVsZXRlIGEgcnVsZS5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAncmVtb3ZlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlKHJ1bGUpIHtcbiAgICAgIHRoaXMudW5yZWdpc3RlcihydWxlKTtcbiAgICAgIHRoaXMuaW5kZXguc3BsaWNlKHRoaXMuaW5kZXhPZihydWxlKSwgMSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGluZGV4IG9mIGEgcnVsZS5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnaW5kZXhPZicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluZGV4T2YocnVsZSkge1xuICAgICAgcmV0dXJuIHRoaXMuaW5kZXguaW5kZXhPZihydWxlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSdW4gYG9uUHJvY2Vzc1J1bGUoKWAgcGx1Z2lucyBvbiBldmVyeSBydWxlLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdwcm9jZXNzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJvY2VzcygpIHtcbiAgICAgIHZhciBwbHVnaW5zID0gdGhpcy5vcHRpb25zLmpzcy5wbHVnaW5zO1xuICAgICAgLy8gV2UgbmVlZCB0byBjbG9uZSBhcnJheSBiZWNhdXNlIGlmIHdlIG1vZGlmeSB0aGUgaW5kZXggc29tZXdoZXJlIGVsc2UgZHVyaW5nIGEgbG9vcFxuICAgICAgLy8gd2UgZW5kIHVwIHdpdGggdmVyeSBoYXJkLXRvLXRyYWNrLWRvd24gc2lkZSBlZmZlY3RzLlxuXG4gICAgICB0aGlzLmluZGV4LnNsaWNlKDApLmZvckVhY2gocGx1Z2lucy5vblByb2Nlc3NSdWxlLCBwbHVnaW5zKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlciBhIHJ1bGUgaW4gYC5tYXBgIGFuZCBgLmNsYXNzZXNgIG1hcHMuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3JlZ2lzdGVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVnaXN0ZXIocnVsZSwgY2xhc3NOYW1lKSB7XG4gICAgICB0aGlzLm1hcFtydWxlLmtleV0gPSBydWxlO1xuICAgICAgaWYgKHJ1bGUgaW5zdGFuY2VvZiBfU3R5bGVSdWxlMlsnZGVmYXVsdCddKSB7XG4gICAgICAgIHRoaXMubWFwW3J1bGUuc2VsZWN0b3JdID0gcnVsZTtcbiAgICAgICAgaWYgKGNsYXNzTmFtZSkgdGhpcy5jbGFzc2VzW3J1bGUua2V5XSA9IGNsYXNzTmFtZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVbnJlZ2lzdGVyIGEgcnVsZS5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAndW5yZWdpc3RlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVucmVnaXN0ZXIocnVsZSkge1xuICAgICAgZGVsZXRlIHRoaXMubWFwW3J1bGUua2V5XTtcbiAgICAgIGlmIChydWxlIGluc3RhbmNlb2YgX1N0eWxlUnVsZTJbJ2RlZmF1bHQnXSkge1xuICAgICAgICBkZWxldGUgdGhpcy5tYXBbcnVsZS5zZWxlY3Rvcl07XG4gICAgICAgIGRlbGV0ZSB0aGlzLmNsYXNzZXNbcnVsZS5rZXldO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgZnVuY3Rpb24gdmFsdWVzIHdpdGggYSBuZXcgZGF0YS5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAndXBkYXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlKG5hbWUsIGRhdGEpIHtcbiAgICAgIHZhciBfb3B0aW9uczIgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgICAgcGx1Z2lucyA9IF9vcHRpb25zMi5qc3MucGx1Z2lucyxcbiAgICAgICAgICBzaGVldCA9IF9vcHRpb25zMi5zaGVldDtcblxuICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJykge1xuICAgICAgICBwbHVnaW5zLm9uVXBkYXRlKGRhdGEsIHRoaXMuZ2V0KG5hbWUpLCBzaGVldCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IHRoaXMuaW5kZXgubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIHBsdWdpbnMub25VcGRhdGUobmFtZSwgdGhpcy5pbmRleFtpbmRleF0sIHNoZWV0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMaW5rIHJlbmRlcmFibGUgcnVsZXMgd2l0aCBDU1NSdWxlTGlzdC5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnbGluaycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxpbmsoY3NzUnVsZXMpIHtcbiAgICAgIHZhciBtYXAgPSB0aGlzLm9wdGlvbnMuc2hlZXQucmVuZGVyZXIuZ2V0VW5lc2NhcGVkS2V5c01hcCh0aGlzLmluZGV4KTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjc3NSdWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY3NzUnVsZSA9IGNzc1J1bGVzW2ldO1xuICAgICAgICB2YXIgX2tleSA9IHRoaXMub3B0aW9ucy5zaGVldC5yZW5kZXJlci5nZXRLZXkoY3NzUnVsZSk7XG4gICAgICAgIGlmIChtYXBbX2tleV0pIF9rZXkgPSBtYXBbX2tleV07XG4gICAgICAgIHZhciBydWxlID0gdGhpcy5tYXBbX2tleV07XG4gICAgICAgIGlmIChydWxlKSAoMCwgX2xpbmtSdWxlMlsnZGVmYXVsdCddKShydWxlLCBjc3NSdWxlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IHJ1bGVzIHRvIGEgQ1NTIHN0cmluZy5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAndG9TdHJpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZyhvcHRpb25zKSB7XG4gICAgICB2YXIgc3RyID0gJyc7XG4gICAgICB2YXIgc2hlZXQgPSB0aGlzLm9wdGlvbnMuc2hlZXQ7XG5cbiAgICAgIHZhciBsaW5rID0gc2hlZXQgPyBzaGVldC5vcHRpb25zLmxpbmsgOiBmYWxzZTtcblxuICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IHRoaXMuaW5kZXgubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIHZhciBydWxlID0gdGhpcy5pbmRleFtpbmRleF07XG4gICAgICAgIHZhciBjc3MgPSBydWxlLnRvU3RyaW5nKG9wdGlvbnMpO1xuXG4gICAgICAgIC8vIE5vIG5lZWQgdG8gcmVuZGVyIGFuIGVtcHR5IHJ1bGUuXG4gICAgICAgIGlmICghY3NzICYmICFsaW5rKSBjb250aW51ZTtcblxuICAgICAgICBpZiAoc3RyKSBzdHIgKz0gJ1xcbic7XG4gICAgICAgIHN0ciArPSBjc3M7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFJ1bGVMaXN0O1xufSgpO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBSdWxlTGlzdDsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfd2FybmluZyA9IHJlcXVpcmUoJ3dhcm5pbmcnKTtcblxudmFyIF93YXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dhcm5pbmcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbi8qKlxuICogU2hlZXRzTWFuYWdlciBpcyBsaWtlIGEgV2Vha01hcCB3aGljaCBpcyBkZXNpZ25lZCB0byBjb3VudCBTdHlsZVNoZWV0XG4gKiBpbnN0YW5jZXMgYW5kIGF0dGFjaC9kZXRhY2ggYXV0b21hdGljYWxseS5cbiAqL1xudmFyIFNoZWV0c01hbmFnZXIgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFNoZWV0c01hbmFnZXIoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNoZWV0c01hbmFnZXIpO1xuXG4gICAgdGhpcy5zaGVldHMgPSBbXTtcbiAgICB0aGlzLnJlZnMgPSBbXTtcbiAgICB0aGlzLmtleXMgPSBbXTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhTaGVldHNNYW5hZ2VyLCBbe1xuICAgIGtleTogJ2dldCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldChrZXkpIHtcbiAgICAgIHZhciBpbmRleCA9IHRoaXMua2V5cy5pbmRleE9mKGtleSk7XG4gICAgICByZXR1cm4gdGhpcy5zaGVldHNbaW5kZXhdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2FkZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZChrZXksIHNoZWV0KSB7XG4gICAgICB2YXIgc2hlZXRzID0gdGhpcy5zaGVldHMsXG4gICAgICAgICAgcmVmcyA9IHRoaXMucmVmcyxcbiAgICAgICAgICBrZXlzID0gdGhpcy5rZXlzO1xuXG4gICAgICB2YXIgaW5kZXggPSBzaGVldHMuaW5kZXhPZihzaGVldCk7XG5cbiAgICAgIGlmIChpbmRleCAhPT0gLTEpIHJldHVybiBpbmRleDtcblxuICAgICAgc2hlZXRzLnB1c2goc2hlZXQpO1xuICAgICAgcmVmcy5wdXNoKDApO1xuICAgICAga2V5cy5wdXNoKGtleSk7XG5cbiAgICAgIHJldHVybiBzaGVldHMubGVuZ3RoIC0gMTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdtYW5hZ2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYW5hZ2Uoa2V5KSB7XG4gICAgICB2YXIgaW5kZXggPSB0aGlzLmtleXMuaW5kZXhPZihrZXkpO1xuICAgICAgdmFyIHNoZWV0ID0gdGhpcy5zaGVldHNbaW5kZXhdO1xuICAgICAgaWYgKHRoaXMucmVmc1tpbmRleF0gPT09IDApIHNoZWV0LmF0dGFjaCgpO1xuICAgICAgdGhpcy5yZWZzW2luZGV4XSsrO1xuICAgICAgaWYgKCF0aGlzLmtleXNbaW5kZXhdKSB0aGlzLmtleXMuc3BsaWNlKGluZGV4LCAwLCBrZXkpO1xuICAgICAgcmV0dXJuIHNoZWV0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3VubWFuYWdlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW5tYW5hZ2Uoa2V5KSB7XG4gICAgICB2YXIgaW5kZXggPSB0aGlzLmtleXMuaW5kZXhPZihrZXkpO1xuICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICAvLyBlc2xpbnQtaWdub3JlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICgwLCBfd2FybmluZzJbJ2RlZmF1bHQnXSkoZmFsc2UsICdTaGVldHNNYW5hZ2VyOiBjYW5cXCd0IGZpbmQgc2hlZXQgdG8gdW5tYW5hZ2UnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMucmVmc1tpbmRleF0gPiAwKSB7XG4gICAgICAgIHRoaXMucmVmc1tpbmRleF0tLTtcbiAgICAgICAgaWYgKHRoaXMucmVmc1tpbmRleF0gPT09IDApIHRoaXMuc2hlZXRzW2luZGV4XS5kZXRhY2goKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdzaXplJyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmtleXMubGVuZ3RoO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTaGVldHNNYW5hZ2VyO1xufSgpO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBTaGVldHNNYW5hZ2VyOyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuLyoqXG4gKiBTaGVldHMgcmVnaXN0cnkgdG8gYWNjZXNzIHRoZW0gYWxsIGF0IG9uZSBwbGFjZS5cbiAqL1xudmFyIFNoZWV0c1JlZ2lzdHJ5ID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTaGVldHNSZWdpc3RyeSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU2hlZXRzUmVnaXN0cnkpO1xuXG4gICAgdGhpcy5yZWdpc3RyeSA9IFtdO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFNoZWV0c1JlZ2lzdHJ5LCBbe1xuICAgIGtleTogJ2FkZCcsXG5cblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIGEgU3R5bGUgU2hlZXQuXG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZChzaGVldCkge1xuICAgICAgdmFyIHJlZ2lzdHJ5ID0gdGhpcy5yZWdpc3RyeTtcbiAgICAgIHZhciBpbmRleCA9IHNoZWV0Lm9wdGlvbnMuaW5kZXg7XG5cblxuICAgICAgaWYgKHJlZ2lzdHJ5LmluZGV4T2Yoc2hlZXQpICE9PSAtMSkgcmV0dXJuO1xuXG4gICAgICBpZiAocmVnaXN0cnkubGVuZ3RoID09PSAwIHx8IGluZGV4ID49IHRoaXMuaW5kZXgpIHtcbiAgICAgICAgcmVnaXN0cnkucHVzaChzaGVldCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gRmluZCBhIHBvc2l0aW9uLlxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZWdpc3RyeS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAocmVnaXN0cnlbaV0ub3B0aW9ucy5pbmRleCA+IGluZGV4KSB7XG4gICAgICAgICAgcmVnaXN0cnkuc3BsaWNlKGksIDAsIHNoZWV0KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXNldCB0aGUgcmVnaXN0cnkuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3Jlc2V0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICB0aGlzLnJlZ2lzdHJ5ID0gW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGEgU3R5bGUgU2hlZXQuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3JlbW92ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZShzaGVldCkge1xuICAgICAgdmFyIGluZGV4ID0gdGhpcy5yZWdpc3RyeS5pbmRleE9mKHNoZWV0KTtcbiAgICAgIHRoaXMucmVnaXN0cnkuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IGFsbCBhdHRhY2hlZCBzaGVldHMgdG8gYSBDU1Mgc3RyaW5nLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICd0b1N0cmluZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlZ2lzdHJ5LmZpbHRlcihmdW5jdGlvbiAoc2hlZXQpIHtcbiAgICAgICAgcmV0dXJuIHNoZWV0LmF0dGFjaGVkO1xuICAgICAgfSkubWFwKGZ1bmN0aW9uIChzaGVldCkge1xuICAgICAgICByZXR1cm4gc2hlZXQudG9TdHJpbmcob3B0aW9ucyk7XG4gICAgICB9KS5qb2luKCdcXG4nKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdpbmRleCcsXG5cblxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgaGlnaGVzdCBpbmRleCBudW1iZXIuXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZWdpc3RyeS5sZW5ndGggPT09IDAgPyAwIDogdGhpcy5yZWdpc3RyeVt0aGlzLnJlZ2lzdHJ5Lmxlbmd0aCAtIDFdLm9wdGlvbnMuaW5kZXg7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFNoZWV0c1JlZ2lzdHJ5O1xufSgpO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBTaGVldHNSZWdpc3RyeTsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfbGlua1J1bGUgPSByZXF1aXJlKCcuL3V0aWxzL2xpbmtSdWxlJyk7XG5cbnZhciBfbGlua1J1bGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbGlua1J1bGUpO1xuXG52YXIgX1J1bGVMaXN0ID0gcmVxdWlyZSgnLi9SdWxlTGlzdCcpO1xuXG52YXIgX1J1bGVMaXN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1J1bGVMaXN0KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgU3R5bGVTaGVldCA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU3R5bGVTaGVldChzdHlsZXMsIG9wdGlvbnMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3R5bGVTaGVldCk7XG5cbiAgICB0aGlzLmF0dGFjaGVkID0gZmFsc2U7XG4gICAgdGhpcy5kZXBsb3llZCA9IGZhbHNlO1xuICAgIHRoaXMubGlua2VkID0gZmFsc2U7XG4gICAgdGhpcy5jbGFzc2VzID0ge307XG4gICAgdGhpcy5vcHRpb25zID0gX2V4dGVuZHMoe30sIG9wdGlvbnMsIHtcbiAgICAgIHNoZWV0OiB0aGlzLFxuICAgICAgcGFyZW50OiB0aGlzLFxuICAgICAgY2xhc3NlczogdGhpcy5jbGFzc2VzXG4gICAgfSk7XG4gICAgdGhpcy5yZW5kZXJlciA9IG5ldyBvcHRpb25zLlJlbmRlcmVyKHRoaXMpO1xuICAgIHRoaXMucnVsZXMgPSBuZXcgX1J1bGVMaXN0MlsnZGVmYXVsdCddKHRoaXMub3B0aW9ucyk7XG5cbiAgICBmb3IgKHZhciBuYW1lIGluIHN0eWxlcykge1xuICAgICAgdGhpcy5ydWxlcy5hZGQobmFtZSwgc3R5bGVzW25hbWVdKTtcbiAgICB9XG5cbiAgICB0aGlzLnJ1bGVzLnByb2Nlc3MoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBdHRhY2ggcmVuZGVyYWJsZSB0byB0aGUgcmVuZGVyIHRyZWUuXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKFN0eWxlU2hlZXQsIFt7XG4gICAga2V5OiAnYXR0YWNoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXR0YWNoKCkge1xuICAgICAgaWYgKHRoaXMuYXR0YWNoZWQpIHJldHVybiB0aGlzO1xuICAgICAgaWYgKCF0aGlzLmRlcGxveWVkKSB0aGlzLmRlcGxveSgpO1xuICAgICAgdGhpcy5yZW5kZXJlci5hdHRhY2goKTtcbiAgICAgIGlmICghdGhpcy5saW5rZWQgJiYgdGhpcy5vcHRpb25zLmxpbmspIHRoaXMubGluaygpO1xuICAgICAgdGhpcy5hdHRhY2hlZCA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgcmVuZGVyYWJsZSBmcm9tIHJlbmRlciB0cmVlLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdkZXRhY2gnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXRhY2goKSB7XG4gICAgICBpZiAoIXRoaXMuYXR0YWNoZWQpIHJldHVybiB0aGlzO1xuICAgICAgdGhpcy5yZW5kZXJlci5kZXRhY2goKTtcbiAgICAgIHRoaXMuYXR0YWNoZWQgPSBmYWxzZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZCBhIHJ1bGUgdG8gdGhlIGN1cnJlbnQgc3R5bGVzaGVldC5cbiAgICAgKiBXaWxsIGluc2VydCBhIHJ1bGUgYWxzbyBhZnRlciB0aGUgc3R5bGVzaGVldCBoYXMgYmVlbiByZW5kZXJlZCBmaXJzdCB0aW1lLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdhZGRSdWxlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkUnVsZShuYW1lLCBkZWNsLCBvcHRpb25zKSB7XG4gICAgICB2YXIgcXVldWUgPSB0aGlzLnF1ZXVlO1xuXG4gICAgICAvLyBQbHVnaW5zIGNhbiBjcmVhdGUgcnVsZXMuXG4gICAgICAvLyBJbiBvcmRlciB0byBwcmVzZXJ2ZSB0aGUgcmlnaHQgb3JkZXIsIHdlIG5lZWQgdG8gcXVldWUgYWxsIGAuYWRkUnVsZWAgY2FsbHMsXG4gICAgICAvLyB3aGljaCBoYXBwZW4gYWZ0ZXIgdGhlIGZpcnN0IGBydWxlcy5hZGQoKWAgY2FsbC5cblxuICAgICAgaWYgKHRoaXMuYXR0YWNoZWQgJiYgIXF1ZXVlKSB0aGlzLnF1ZXVlID0gW107XG5cbiAgICAgIHZhciBydWxlID0gdGhpcy5ydWxlcy5hZGQobmFtZSwgZGVjbCwgb3B0aW9ucyk7XG4gICAgICB0aGlzLm9wdGlvbnMuanNzLnBsdWdpbnMub25Qcm9jZXNzUnVsZShydWxlKTtcblxuICAgICAgaWYgKHRoaXMuYXR0YWNoZWQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRlcGxveWVkKSByZXR1cm4gcnVsZTtcbiAgICAgICAgLy8gRG9uJ3QgaW5zZXJ0IHJ1bGUgZGlyZWN0bHkgaWYgdGhlcmUgaXMgbm8gc3RyaW5naWZpZWQgdmVyc2lvbiB5ZXQuXG4gICAgICAgIC8vIEl0IHdpbGwgYmUgaW5zZXJ0ZWQgYWxsIHRvZ2V0aGVyIHdoZW4gLmF0dGFjaCBpcyBjYWxsZWQuXG4gICAgICAgIGlmIChxdWV1ZSkgcXVldWUucHVzaChydWxlKTtlbHNlIHtcbiAgICAgICAgICB0aGlzLmluc2VydFJ1bGUocnVsZSk7XG4gICAgICAgICAgaWYgKHRoaXMucXVldWUpIHtcbiAgICAgICAgICAgIHRoaXMucXVldWUuZm9yRWFjaCh0aGlzLmluc2VydFJ1bGUsIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5xdWV1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJ1bGU7XG4gICAgICB9XG5cbiAgICAgIC8vIFdlIGNhbid0IGFkZCBydWxlcyB0byBhIGRldGFjaGVkIHN0eWxlIG5vZGUuXG4gICAgICAvLyBXZSB3aWxsIHJlZGVwbG95IHRoZSBzaGVldCBvbmNlIHVzZXIgd2lsbCBhdHRhY2ggaXQuXG4gICAgICB0aGlzLmRlcGxveWVkID0gZmFsc2U7XG5cbiAgICAgIHJldHVybiBydWxlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluc2VydCBydWxlIGludG8gdGhlIFN0eWxlU2hlZXRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnaW5zZXJ0UnVsZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluc2VydFJ1bGUocnVsZSkge1xuICAgICAgdmFyIHJlbmRlcmFibGUgPSB0aGlzLnJlbmRlcmVyLmluc2VydFJ1bGUocnVsZSk7XG4gICAgICBpZiAocmVuZGVyYWJsZSAmJiB0aGlzLm9wdGlvbnMubGluaykgKDAsIF9saW5rUnVsZTJbJ2RlZmF1bHQnXSkocnVsZSwgcmVuZGVyYWJsZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuZCBhZGQgcnVsZXMuXG4gICAgICogV2lsbCByZW5kZXIgYWxzbyBhZnRlciBTdHlsZSBTaGVldCB3YXMgcmVuZGVyZWQgdGhlIGZpcnN0IHRpbWUuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2FkZFJ1bGVzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkUnVsZXMoc3R5bGVzLCBvcHRpb25zKSB7XG4gICAgICB2YXIgYWRkZWQgPSBbXTtcbiAgICAgIGZvciAodmFyIG5hbWUgaW4gc3R5bGVzKSB7XG4gICAgICAgIGFkZGVkLnB1c2godGhpcy5hZGRSdWxlKG5hbWUsIHN0eWxlc1tuYW1lXSwgb3B0aW9ucykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFkZGVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBhIHJ1bGUgYnkgbmFtZS5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZ2V0UnVsZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFJ1bGUobmFtZSkge1xuICAgICAgcmV0dXJuIHRoaXMucnVsZXMuZ2V0KG5hbWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBhIHJ1bGUgYnkgbmFtZS5cbiAgICAgKiBSZXR1cm5zIGB0cnVlYDogaWYgcnVsZSBoYXMgYmVlbiBkZWxldGVkIGZyb20gdGhlIERPTS5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZGVsZXRlUnVsZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlbGV0ZVJ1bGUobmFtZSkge1xuICAgICAgdmFyIHJ1bGUgPSB0aGlzLnJ1bGVzLmdldChuYW1lKTtcblxuICAgICAgaWYgKCFydWxlKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgIHRoaXMucnVsZXMucmVtb3ZlKHJ1bGUpO1xuXG4gICAgICBpZiAodGhpcy5hdHRhY2hlZCAmJiBydWxlLnJlbmRlcmFibGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIuZGVsZXRlUnVsZShydWxlLnJlbmRlcmFibGUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgaW5kZXggb2YgYSBydWxlLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdpbmRleE9mJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5kZXhPZihydWxlKSB7XG4gICAgICByZXR1cm4gdGhpcy5ydWxlcy5pbmRleE9mKHJ1bGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlcGxveSBwdXJlIENTUyBzdHJpbmcgdG8gYSByZW5kZXJhYmxlLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdkZXBsb3knLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXBsb3koKSB7XG4gICAgICB0aGlzLnJlbmRlcmVyLmRlcGxveSgpO1xuICAgICAgdGhpcy5kZXBsb3llZCA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMaW5rIHJlbmRlcmFibGUgQ1NTIHJ1bGVzIGZyb20gc2hlZXQgd2l0aCB0aGVpciBjb3JyZXNwb25kaW5nIG1vZGVscy5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnbGluaycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxpbmsoKSB7XG4gICAgICB2YXIgY3NzUnVsZXMgPSB0aGlzLnJlbmRlcmVyLmdldFJ1bGVzKCk7XG5cbiAgICAgIC8vIElzIHVuZGVmaW5lZCB3aGVuIFZpcnR1YWxSZW5kZXJlciBpcyB1c2VkLlxuICAgICAgaWYgKGNzc1J1bGVzKSB0aGlzLnJ1bGVzLmxpbmsoY3NzUnVsZXMpO1xuICAgICAgdGhpcy5saW5rZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSBmdW5jdGlvbiB2YWx1ZXMgd2l0aCBhIG5ldyBkYXRhLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICd1cGRhdGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGUobmFtZSwgZGF0YSkge1xuICAgICAgdGhpcy5ydWxlcy51cGRhdGUobmFtZSwgZGF0YSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IHJ1bGVzIHRvIGEgQ1NTIHN0cmluZy5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAndG9TdHJpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZyhvcHRpb25zKSB7XG4gICAgICByZXR1cm4gdGhpcy5ydWxlcy50b1N0cmluZyhvcHRpb25zKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU3R5bGVTaGVldDtcbn0oKTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gU3R5bGVTaGVldDsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmNyZWF0ZSA9IGV4cG9ydHMuY3JlYXRlR2VuZXJhdGVDbGFzc05hbWUgPSBleHBvcnRzLnNoZWV0cyA9IGV4cG9ydHMuUnVsZUxpc3QgPSBleHBvcnRzLlNoZWV0c01hbmFnZXIgPSBleHBvcnRzLlNoZWV0c1JlZ2lzdHJ5ID0gZXhwb3J0cy50b0Nzc1ZhbHVlID0gZXhwb3J0cy5nZXREeW5hbWljU3R5bGVzID0gdW5kZWZpbmVkO1xuXG52YXIgX2dldER5bmFtaWNTdHlsZXMgPSByZXF1aXJlKCcuL3V0aWxzL2dldER5bmFtaWNTdHlsZXMnKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdnZXREeW5hbWljU3R5bGVzJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0RHluYW1pY1N0eWxlcylbJ2RlZmF1bHQnXTtcbiAgfVxufSk7XG5cbnZhciBfdG9Dc3NWYWx1ZSA9IHJlcXVpcmUoJy4vdXRpbHMvdG9Dc3NWYWx1ZScpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ3RvQ3NzVmFsdWUnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90b0Nzc1ZhbHVlKVsnZGVmYXVsdCddO1xuICB9XG59KTtcblxudmFyIF9TaGVldHNSZWdpc3RyeSA9IHJlcXVpcmUoJy4vU2hlZXRzUmVnaXN0cnknKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdTaGVldHNSZWdpc3RyeScsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1NoZWV0c1JlZ2lzdHJ5KVsnZGVmYXVsdCddO1xuICB9XG59KTtcblxudmFyIF9TaGVldHNNYW5hZ2VyID0gcmVxdWlyZSgnLi9TaGVldHNNYW5hZ2VyJyk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnU2hlZXRzTWFuYWdlcicsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1NoZWV0c01hbmFnZXIpWydkZWZhdWx0J107XG4gIH1cbn0pO1xuXG52YXIgX1J1bGVMaXN0ID0gcmVxdWlyZSgnLi9SdWxlTGlzdCcpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ1J1bGVMaXN0Jywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUnVsZUxpc3QpWydkZWZhdWx0J107XG4gIH1cbn0pO1xuXG52YXIgX3NoZWV0cyA9IHJlcXVpcmUoJy4vc2hlZXRzJyk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnc2hlZXRzJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc2hlZXRzKVsnZGVmYXVsdCddO1xuICB9XG59KTtcblxudmFyIF9jcmVhdGVHZW5lcmF0ZUNsYXNzTmFtZSA9IHJlcXVpcmUoJy4vdXRpbHMvY3JlYXRlR2VuZXJhdGVDbGFzc05hbWUnKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdjcmVhdGVHZW5lcmF0ZUNsYXNzTmFtZScsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZUdlbmVyYXRlQ2xhc3NOYW1lKVsnZGVmYXVsdCddO1xuICB9XG59KTtcblxudmFyIF9Kc3MgPSByZXF1aXJlKCcuL0pzcycpO1xuXG52YXIgX0pzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Kc3MpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBKc3MuXG4gKi9cbnZhciBjcmVhdGUgPSBleHBvcnRzLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgX0pzczJbJ2RlZmF1bHQnXShvcHRpb25zKTtcbn07XG5cbi8qKlxuICogQSBnbG9iYWwgSnNzIGluc3RhbmNlLlxuICovXG5leHBvcnRzWydkZWZhdWx0J10gPSBjcmVhdGUoKTsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfUnVsZUxpc3QgPSByZXF1aXJlKCcuLi9SdWxlTGlzdCcpO1xuXG52YXIgX1J1bGVMaXN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1J1bGVMaXN0KTtcblxudmFyIF9TdHlsZVJ1bGUgPSByZXF1aXJlKCcuLi9ydWxlcy9TdHlsZVJ1bGUnKTtcblxudmFyIF9TdHlsZVJ1bGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU3R5bGVSdWxlKTtcblxudmFyIF9rZWJhYkNhc2UgPSByZXF1aXJlKCcuLi91dGlscy9rZWJhYkNhc2UnKTtcblxudmFyIF9rZWJhYkNhc2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfa2ViYWJDYXNlKTtcblxudmFyIF9jcmVhdGVSdWxlID0gcmVxdWlyZSgnLi4vdXRpbHMvY3JlYXRlUnVsZScpO1xuXG52YXIgX2NyZWF0ZVJ1bGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlUnVsZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuLy8gQSBzeW1ib2wgcmVwbGFjZW1lbnQuXG52YXIgbm93ID0gRGF0ZS5ub3coKTtcbnZhciBmblZhbHVlc05zID0gJ2ZuVmFsdWVzJyArIG5vdztcbnZhciBmblN0eWxlTnMgPSAnZm5TdHlsZScgKyArK25vdztcblxuZXhwb3J0c1snZGVmYXVsdCddID0ge1xuICBvbkNyZWF0ZVJ1bGU6IGZ1bmN0aW9uIG9uQ3JlYXRlUnVsZShuYW1lLCBkZWNsLCBvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBkZWNsICE9PSAnZnVuY3Rpb24nKSByZXR1cm4gbnVsbDtcbiAgICB2YXIgcnVsZSA9ICgwLCBfY3JlYXRlUnVsZTJbJ2RlZmF1bHQnXSkobmFtZSwge30sIG9wdGlvbnMpO1xuICAgIHJ1bGVbZm5TdHlsZU5zXSA9IGRlY2w7XG4gICAgcmV0dXJuIHJ1bGU7XG4gIH0sXG4gIG9uUHJvY2Vzc1N0eWxlOiBmdW5jdGlvbiBvblByb2Nlc3NTdHlsZShzdHlsZSwgcnVsZSkge1xuICAgIHZhciBmbiA9IHt9O1xuICAgIGZvciAodmFyIHByb3AgaW4gc3R5bGUpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHN0eWxlW3Byb3BdO1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ2Z1bmN0aW9uJykgY29udGludWU7XG4gICAgICBkZWxldGUgc3R5bGVbcHJvcF07XG4gICAgICBmblsoMCwgX2tlYmFiQ2FzZTJbJ2RlZmF1bHQnXSkocHJvcCldID0gdmFsdWU7XG4gICAgfVxuICAgIHJ1bGUgPSBydWxlO1xuICAgIHJ1bGVbZm5WYWx1ZXNOc10gPSBmbjtcbiAgICByZXR1cm4gc3R5bGU7XG4gIH0sXG4gIG9uVXBkYXRlOiBmdW5jdGlvbiBvblVwZGF0ZShkYXRhLCBydWxlKSB7XG4gICAgLy8gSXQgaXMgYSBydWxlcyBjb250YWluZXIgbGlrZSBmb3IgZS5nLiBDb25kaXRpb25hbFJ1bGUuXG4gICAgaWYgKHJ1bGUucnVsZXMgaW5zdGFuY2VvZiBfUnVsZUxpc3QyWydkZWZhdWx0J10pIHtcbiAgICAgIHJ1bGUucnVsZXMudXBkYXRlKGRhdGEpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIShydWxlIGluc3RhbmNlb2YgX1N0eWxlUnVsZTJbJ2RlZmF1bHQnXSkpIHJldHVybjtcblxuICAgIHJ1bGUgPSBydWxlO1xuXG4gICAgLy8gSWYgd2UgaGF2ZSBhIGZuIHZhbHVlcyBtYXAsIGl0IGlzIGEgcnVsZSB3aXRoIGZ1bmN0aW9uIHZhbHVlcy5cbiAgICBpZiAocnVsZVtmblZhbHVlc05zXSkge1xuICAgICAgZm9yICh2YXIgcHJvcCBpbiBydWxlW2ZuVmFsdWVzTnNdKSB7XG4gICAgICAgIHJ1bGUucHJvcChwcm9wLCBydWxlW2ZuVmFsdWVzTnNdW3Byb3BdKGRhdGEpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBydWxlID0gcnVsZTtcblxuICAgIHZhciBmblN0eWxlID0gcnVsZVtmblN0eWxlTnNdO1xuXG4gICAgLy8gSWYgd2UgaGF2ZSBhIHN0eWxlIGZ1bmN0aW9uLCB0aGUgZW50aXJlIHJ1bGUgaXMgZHluYW1pYyBhbmQgc3R5bGUgb2JqZWN0XG4gICAgLy8gd2lsbCBiZSByZXR1cm5lZCBmcm9tIHRoYXQgZnVuY3Rpb24uXG4gICAgaWYgKGZuU3R5bGUpIHtcbiAgICAgIHZhciBzdHlsZSA9IGZuU3R5bGUoZGF0YSk7XG4gICAgICBmb3IgKHZhciBfcHJvcCBpbiBzdHlsZSkge1xuICAgICAgICBydWxlLnByb3AoX3Byb3AsIHN0eWxlW19wcm9wXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59OyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9TdHlsZVJ1bGUgPSByZXF1aXJlKCcuLi9ydWxlcy9TdHlsZVJ1bGUnKTtcblxudmFyIF9TdHlsZVJ1bGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU3R5bGVSdWxlKTtcblxudmFyIF9jcmVhdGVSdWxlID0gcmVxdWlyZSgnLi4vdXRpbHMvY3JlYXRlUnVsZScpO1xuXG52YXIgX2NyZWF0ZVJ1bGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlUnVsZSk7XG5cbnZhciBfaXNPYnNlcnZhYmxlID0gcmVxdWlyZSgnLi4vdXRpbHMvaXNPYnNlcnZhYmxlJyk7XG5cbnZhciBfaXNPYnNlcnZhYmxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2lzT2JzZXJ2YWJsZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZXhwb3J0c1snZGVmYXVsdCddID0ge1xuICBvbkNyZWF0ZVJ1bGU6IGZ1bmN0aW9uIG9uQ3JlYXRlUnVsZShuYW1lLCBkZWNsLCBvcHRpb25zKSB7XG4gICAgaWYgKCEoMCwgX2lzT2JzZXJ2YWJsZTJbJ2RlZmF1bHQnXSkoZGVjbCkpIHJldHVybiBudWxsO1xuXG4gICAgLy8gQ2FzdCBgZGVjbGAgdG8gYE9ic2VydmFibGVgLCBzaW5jZSBpdCBwYXNzZWQgdGhlIHR5cGUgZ3VhcmQuXG4gICAgdmFyIHN0eWxlJCA9IGRlY2w7XG5cbiAgICB2YXIgcnVsZSA9ICgwLCBfY3JlYXRlUnVsZTJbJ2RlZmF1bHQnXSkobmFtZSwge30sIG9wdGlvbnMpO1xuXG4gICAgLy8gVE9ET1xuICAgIC8vIENhbGwgYHN0cmVhbS5zdWJzY3JpYmUoKWAgcmV0dXJucyBhIHN1YnNjcmlwdGlvbiwgd2hpY2ggc2hvdWxkIGJlIGV4cGxpY2l0bHlcbiAgICAvLyB1bnN1YnNjcmliZWQgZnJvbSB3aGVuIHdlIGtub3cgdGhpcyBzaGVldCBpcyBubyBsb25nZXIgbmVlZGVkLlxuICAgIHN0eWxlJC5zdWJzY3JpYmUoZnVuY3Rpb24gKHN0eWxlKSB7XG4gICAgICBmb3IgKHZhciBwcm9wIGluIHN0eWxlKSB7XG4gICAgICAgIHJ1bGUucHJvcChwcm9wLCBzdHlsZVtwcm9wXSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcnVsZTtcbiAgfSxcbiAgb25Qcm9jZXNzUnVsZTogZnVuY3Rpb24gb25Qcm9jZXNzUnVsZShydWxlKSB7XG4gICAgaWYgKCEocnVsZSBpbnN0YW5jZW9mIF9TdHlsZVJ1bGUyWydkZWZhdWx0J10pKSByZXR1cm47XG4gICAgdmFyIHN0eWxlUnVsZSA9IHJ1bGU7XG4gICAgdmFyIHN0eWxlID0gc3R5bGVSdWxlLnN0eWxlO1xuXG4gICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AocHJvcCkge1xuICAgICAgdmFyIHZhbHVlID0gc3R5bGVbcHJvcF07XG4gICAgICBpZiAoISgwLCBfaXNPYnNlcnZhYmxlMlsnZGVmYXVsdCddKSh2YWx1ZSkpIHJldHVybiAnY29udGludWUnO1xuICAgICAgZGVsZXRlIHN0eWxlW3Byb3BdO1xuICAgICAgdmFsdWUuc3Vic2NyaWJlKHtcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gbmV4dChuZXh0VmFsdWUpIHtcbiAgICAgICAgICBzdHlsZVJ1bGUucHJvcChwcm9wLCBuZXh0VmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgZm9yICh2YXIgcHJvcCBpbiBzdHlsZSkge1xuICAgICAgdmFyIF9yZXQgPSBfbG9vcChwcm9wKTtcblxuICAgICAgaWYgKF9yZXQgPT09ICdjb250aW51ZScpIGNvbnRpbnVlO1xuICAgIH1cbiAgfVxufTsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfU2ltcGxlUnVsZSA9IHJlcXVpcmUoJy4uL3J1bGVzL1NpbXBsZVJ1bGUnKTtcblxudmFyIF9TaW1wbGVSdWxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1NpbXBsZVJ1bGUpO1xuXG52YXIgX0tleWZyYW1lc1J1bGUgPSByZXF1aXJlKCcuLi9ydWxlcy9LZXlmcmFtZXNSdWxlJyk7XG5cbnZhciBfS2V5ZnJhbWVzUnVsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9LZXlmcmFtZXNSdWxlKTtcblxudmFyIF9Db25kaXRpb25hbFJ1bGUgPSByZXF1aXJlKCcuLi9ydWxlcy9Db25kaXRpb25hbFJ1bGUnKTtcblxudmFyIF9Db25kaXRpb25hbFJ1bGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQ29uZGl0aW9uYWxSdWxlKTtcblxudmFyIF9Gb250RmFjZVJ1bGUgPSByZXF1aXJlKCcuLi9ydWxlcy9Gb250RmFjZVJ1bGUnKTtcblxudmFyIF9Gb250RmFjZVJ1bGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfRm9udEZhY2VSdWxlKTtcblxudmFyIF9WaWV3cG9ydFJ1bGUgPSByZXF1aXJlKCcuLi9ydWxlcy9WaWV3cG9ydFJ1bGUnKTtcblxudmFyIF9WaWV3cG9ydFJ1bGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVmlld3BvcnRSdWxlKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgY2xhc3NlcyA9IHtcbiAgJ0BjaGFyc2V0JzogX1NpbXBsZVJ1bGUyWydkZWZhdWx0J10sXG4gICdAaW1wb3J0JzogX1NpbXBsZVJ1bGUyWydkZWZhdWx0J10sXG4gICdAbmFtZXNwYWNlJzogX1NpbXBsZVJ1bGUyWydkZWZhdWx0J10sXG4gICdAa2V5ZnJhbWVzJzogX0tleWZyYW1lc1J1bGUyWydkZWZhdWx0J10sXG4gICdAbWVkaWEnOiBfQ29uZGl0aW9uYWxSdWxlMlsnZGVmYXVsdCddLFxuICAnQHN1cHBvcnRzJzogX0NvbmRpdGlvbmFsUnVsZTJbJ2RlZmF1bHQnXSxcbiAgJ0Bmb250LWZhY2UnOiBfRm9udEZhY2VSdWxlMlsnZGVmYXVsdCddLFxuICAnQHZpZXdwb3J0JzogX1ZpZXdwb3J0UnVsZTJbJ2RlZmF1bHQnXSxcbiAgJ0AtbXMtdmlld3BvcnQnOiBfVmlld3BvcnRSdWxlMlsnZGVmYXVsdCddXG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIHBsdWdpbnMgd2hpY2ggd2lsbCByZWdpc3RlciBhbGwgcnVsZXMuXG4gICAqL1xufTtcbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IE9iamVjdC5rZXlzKGNsYXNzZXMpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gIC8vIGh0dHBzOi8vanNwZXJmLmNvbS9pbmRleG9mLXZzLXN1YnN0ci12cy1yZWdleC1hdC10aGUtYmVnaW5uaW5nLTNcbiAgdmFyIHJlID0gbmV3IFJlZ0V4cCgnXicgKyBrZXkpO1xuICB2YXIgb25DcmVhdGVSdWxlID0gZnVuY3Rpb24gb25DcmVhdGVSdWxlKG5hbWUsIGRlY2wsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gcmUudGVzdChuYW1lKSA/IG5ldyBjbGFzc2VzW2tleV0obmFtZSwgZGVjbCwgb3B0aW9ucykgOiBudWxsO1xuICB9O1xuICByZXR1cm4geyBvbkNyZWF0ZVJ1bGU6IG9uQ3JlYXRlUnVsZSB9O1xufSk7IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX3dhcm5pbmcgPSByZXF1aXJlKCd3YXJuaW5nJyk7XG5cbnZhciBfd2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93YXJuaW5nKTtcblxudmFyIF9zaGVldHMgPSByZXF1aXJlKCcuLi9zaGVldHMnKTtcblxudmFyIF9zaGVldHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc2hlZXRzKTtcblxudmFyIF9TdHlsZVJ1bGUgPSByZXF1aXJlKCcuLi9ydWxlcy9TdHlsZVJ1bGUnKTtcblxudmFyIF9TdHlsZVJ1bGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU3R5bGVSdWxlKTtcblxudmFyIF90b0Nzc1ZhbHVlID0gcmVxdWlyZSgnLi4vdXRpbHMvdG9Dc3NWYWx1ZScpO1xuXG52YXIgX3RvQ3NzVmFsdWUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdG9Dc3NWYWx1ZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuLyoqXG4gKiBHZXQgYSBzdHlsZSBwcm9wZXJ0eS5cbiAqL1xuZnVuY3Rpb24gZ2V0U3R5bGUoY3NzUnVsZSwgcHJvcCkge1xuICB0cnkge1xuICAgIHJldHVybiBjc3NSdWxlLnN0eWxlLmdldFByb3BlcnR5VmFsdWUocHJvcCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIElFIG1heSB0aHJvdyBpZiBwcm9wZXJ0eSBpcyB1bmtub3duLlxuICAgIHJldHVybiAnJztcbiAgfVxufVxuXG4vKipcbiAqIFNldCBhIHN0eWxlIHByb3BlcnR5LlxuICovXG5mdW5jdGlvbiBzZXRTdHlsZShjc3NSdWxlLCBwcm9wLCB2YWx1ZSkge1xuICB0cnkge1xuICAgIHZhciBjc3NWYWx1ZSA9IHZhbHVlO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICBjc3NWYWx1ZSA9ICgwLCBfdG9Dc3NWYWx1ZTJbJ2RlZmF1bHQnXSkodmFsdWUsIHRydWUpO1xuXG4gICAgICBpZiAodmFsdWVbdmFsdWUubGVuZ3RoIC0gMV0gPT09ICchaW1wb3J0YW50Jykge1xuICAgICAgICBjc3NSdWxlLnN0eWxlLnNldFByb3BlcnR5KHByb3AsIGNzc1ZhbHVlLCAnaW1wb3J0YW50Jyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNzc1J1bGUuc3R5bGUuc2V0UHJvcGVydHkocHJvcCwgY3NzVmFsdWUpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyBJRSBtYXkgdGhyb3cgaWYgcHJvcGVydHkgaXMgdW5rbm93bi5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbnZhciBDU1NSdWxlVHlwZXMgPSB7XG4gIFNUWUxFX1JVTEU6IDEsXG4gIEtFWUZSQU1FU19SVUxFOiA3XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgQ1NTIFJ1bGUga2V5LlxuICAgKi9cblxufTt2YXIgZ2V0S2V5ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZXh0cmFjdEtleSA9IGZ1bmN0aW9uIGV4dHJhY3RLZXkoY3NzVGV4dCkge1xuICAgIHZhciBmcm9tID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuICAgIHJldHVybiBjc3NUZXh0LnN1YnN0cihmcm9tLCBjc3NUZXh0LmluZGV4T2YoJ3snKSAtIDEpO1xuICB9O1xuXG4gIHJldHVybiBmdW5jdGlvbiAoY3NzUnVsZSkge1xuICAgIGlmIChjc3NSdWxlLnR5cGUgPT09IENTU1J1bGVUeXBlcy5TVFlMRV9SVUxFKSByZXR1cm4gY3NzUnVsZS5zZWxlY3RvclRleHQ7XG4gICAgaWYgKGNzc1J1bGUudHlwZSA9PT0gQ1NTUnVsZVR5cGVzLktFWUZSQU1FU19SVUxFKSB7XG4gICAgICB2YXIgbmFtZSA9IGNzc1J1bGUubmFtZTtcblxuICAgICAgaWYgKG5hbWUpIHJldHVybiAnQGtleWZyYW1lcyAnICsgbmFtZTtcblxuICAgICAgLy8gVGhlcmUgaXMgbm8gcnVsZS5uYW1lIGluIHRoZSBmb2xsb3dpbmcgYnJvd3NlcnM6XG4gICAgICAvLyAtIElFIDlcbiAgICAgIC8vIC0gU2FmYXJpIDcuMS44XG4gICAgICAvLyAtIE1vYmlsZSBTYWZhcmkgOS4wLjBcbiAgICAgIHZhciBjc3NUZXh0ID0gY3NzUnVsZS5jc3NUZXh0O1xuXG4gICAgICByZXR1cm4gJ0AnICsgZXh0cmFjdEtleShjc3NUZXh0LCBjc3NUZXh0LmluZGV4T2YoJ2tleWZyYW1lcycpKTtcbiAgICB9XG5cbiAgICAvLyBDb25kaXRpb25hbHMuXG4gICAgcmV0dXJuIGV4dHJhY3RLZXkoY3NzUnVsZS5jc3NUZXh0KTtcbiAgfTtcbn0oKTtcblxuLyoqXG4gKiBTZXQgdGhlIHNlbGVjdG9yLlxuICovXG5mdW5jdGlvbiBzZXRTZWxlY3Rvcihjc3NSdWxlLCBzZWxlY3RvclRleHQpIHtcbiAgY3NzUnVsZS5zZWxlY3RvclRleHQgPSBzZWxlY3RvclRleHQ7XG5cbiAgLy8gUmV0dXJuIGZhbHNlIGlmIHNldHRlciB3YXMgbm90IHN1Y2Nlc3NmdWwuXG4gIC8vIEN1cnJlbnRseSB3b3JrcyBpbiBjaHJvbWUgb25seS5cbiAgcmV0dXJuIGNzc1J1bGUuc2VsZWN0b3JUZXh0ID09PSBzZWxlY3RvclRleHQ7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgYGhlYWRgIGVsZW1lbnQgdXBvbiB0aGUgZmlyc3QgY2FsbCBhbmQgY2FjaGVzIGl0LlxuICovXG52YXIgZ2V0SGVhZCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhlYWQgPSB2b2lkIDA7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFoZWFkKSBoZWFkID0gZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdO1xuICAgIHJldHVybiBoZWFkO1xuICB9O1xufSgpO1xuXG4vKipcbiAqIEdldHMgYSBtYXAgb2YgcnVsZSBrZXlzLCB3aGVyZSB0aGUgcHJvcGVydHkgaXMgYW4gdW5lc2NhcGVkIGtleSBhbmQgdmFsdWVcbiAqIGlzIGEgcG90ZW50aWFsbHkgZXNjYXBlZCBvbmUuXG4gKiBJdCBpcyB1c2VkIHRvIGlkZW50aWZ5IENTUyBydWxlcyBhbmQgdGhlIGNvcnJlc3BvbmRpbmcgSlNTIHJ1bGVzLiBBcyBhbiBpZGVudGlmaWVyXG4gKiBmb3IgQ1NTU3R5bGVSdWxlIHdlIG5vcm1hbGx5IHVzZSBgc2VsZWN0b3JUZXh0YC4gVGhvdWdoIGlmIG9yaWdpbmFsIHNlbGVjdG9yIHRleHRcbiAqIGNvbnRhaW5zIGVzY2FwZWQgY29kZSBwb2ludHMgZS5nLiBgOm5vdCgjXFxcXDIwKWAsIENTU09NIHdpbGwgY29tcGlsZSBpdCB0byBgOm5vdCgjIClgXG4gKiBhbmQgc28gQ1NTIHJ1bGUncyBgc2VsZWN0b3JUZXh0YCB3b24ndCBtYXRjaCBKU1MgcnVsZSBzZWxlY3Rvci5cbiAqXG4gKiBodHRwczovL3d3dy53My5vcmcvSW50ZXJuYXRpb25hbC9xdWVzdGlvbnMvcWEtZXNjYXBlcyNjc3Nlc2NhcGVzXG4gKi9cbnZhciBnZXRVbmVzY2FwZWRLZXlzTWFwID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3R5bGUgPSB2b2lkIDA7XG4gIHZhciBpc0F0dGFjaGVkID0gZmFsc2U7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChydWxlcykge1xuICAgIHZhciBtYXAgPSB7fTtcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmxvdy9pc3N1ZXMvMjY5NlxuICAgIGlmICghc3R5bGUpIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJ1bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcnVsZSA9IHJ1bGVzW2ldO1xuICAgICAgaWYgKCEocnVsZSBpbnN0YW5jZW9mIF9TdHlsZVJ1bGUyWydkZWZhdWx0J10pKSBjb250aW51ZTtcbiAgICAgIHZhciBzZWxlY3RvciA9IHJ1bGUuc2VsZWN0b3I7XG4gICAgICAvLyBPbmx5IHVuZXNjYXBlIHNlbGVjdG9yIG92ZXIgQ1NTT00gaWYgaXQgY29udGFpbnMgYSBiYWNrIHNsYXNoLlxuXG4gICAgICBpZiAoc2VsZWN0b3IgJiYgc2VsZWN0b3IuaW5kZXhPZignXFxcXCcpICE9PSAtMSkge1xuICAgICAgICAvLyBMYXppbGx5IGF0dGFjaCB3aGVuIG5lZWRlZC5cbiAgICAgICAgaWYgKCFpc0F0dGFjaGVkKSB7XG4gICAgICAgICAgZ2V0SGVhZCgpLmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgICAgICAgICBpc0F0dGFjaGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBzdHlsZS50ZXh0Q29udGVudCA9IHNlbGVjdG9yICsgJyB7fSc7XG4gICAgICAgIHZhciBfc3R5bGUgPSBzdHlsZSxcbiAgICAgICAgICAgIHNoZWV0ID0gX3N0eWxlLnNoZWV0O1xuXG4gICAgICAgIGlmIChzaGVldCkge1xuICAgICAgICAgIHZhciBjc3NSdWxlcyA9IHNoZWV0LmNzc1J1bGVzO1xuXG4gICAgICAgICAgaWYgKGNzc1J1bGVzKSBtYXBbY3NzUnVsZXNbMF0uc2VsZWN0b3JUZXh0XSA9IHJ1bGUua2V5O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc0F0dGFjaGVkKSB7XG4gICAgICBnZXRIZWFkKCkucmVtb3ZlQ2hpbGQoc3R5bGUpO1xuICAgICAgaXNBdHRhY2hlZCA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gbWFwO1xuICB9O1xufSgpO1xuXG4vKipcbiAqIEZpbmQgYXR0YWNoZWQgc2hlZXQgd2l0aCBhbiBpbmRleCBoaWdoZXIgdGhhbiB0aGUgcGFzc2VkIG9uZS5cbiAqL1xuZnVuY3Rpb24gZmluZEhpZ2hlclNoZWV0KHJlZ2lzdHJ5LCBvcHRpb25zKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmVnaXN0cnkubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc2hlZXQgPSByZWdpc3RyeVtpXTtcbiAgICBpZiAoc2hlZXQuYXR0YWNoZWQgJiYgc2hlZXQub3B0aW9ucy5pbmRleCA+IG9wdGlvbnMuaW5kZXggJiYgc2hlZXQub3B0aW9ucy5pbnNlcnRpb25Qb2ludCA9PT0gb3B0aW9ucy5pbnNlcnRpb25Qb2ludCkge1xuICAgICAgcmV0dXJuIHNoZWV0O1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBGaW5kIGF0dGFjaGVkIHNoZWV0IHdpdGggdGhlIGhpZ2hlc3QgaW5kZXguXG4gKi9cbmZ1bmN0aW9uIGZpbmRIaWdoZXN0U2hlZXQocmVnaXN0cnksIG9wdGlvbnMpIHtcbiAgZm9yICh2YXIgaSA9IHJlZ2lzdHJ5Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIHNoZWV0ID0gcmVnaXN0cnlbaV07XG4gICAgaWYgKHNoZWV0LmF0dGFjaGVkICYmIHNoZWV0Lm9wdGlvbnMuaW5zZXJ0aW9uUG9pbnQgPT09IG9wdGlvbnMuaW5zZXJ0aW9uUG9pbnQpIHtcbiAgICAgIHJldHVybiBzaGVldDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogRmluZCBhIGNvbW1lbnQgd2l0aCBcImpzc1wiIGluc2lkZS5cbiAqL1xuZnVuY3Rpb24gZmluZENvbW1lbnROb2RlKHRleHQpIHtcbiAgdmFyIGhlYWQgPSBnZXRIZWFkKCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaGVhZC5jaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG5vZGUgPSBoZWFkLmNoaWxkTm9kZXNbaV07XG4gICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDggJiYgbm9kZS5ub2RlVmFsdWUudHJpbSgpID09PSB0ZXh0KSB7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogRmluZCBhIG5vZGUgYmVmb3JlIHdoaWNoIHdlIGNhbiBpbnNlcnQgdGhlIHNoZWV0LlxuICovXG5mdW5jdGlvbiBmaW5kUHJldk5vZGUob3B0aW9ucykge1xuICB2YXIgcmVnaXN0cnkgPSBfc2hlZXRzMlsnZGVmYXVsdCddLnJlZ2lzdHJ5O1xuXG5cbiAgaWYgKHJlZ2lzdHJ5Lmxlbmd0aCA+IDApIHtcbiAgICAvLyBUcnkgdG8gaW5zZXJ0IGJlZm9yZSB0aGUgbmV4dCBoaWdoZXIgc2hlZXQuXG4gICAgdmFyIHNoZWV0ID0gZmluZEhpZ2hlclNoZWV0KHJlZ2lzdHJ5LCBvcHRpb25zKTtcbiAgICBpZiAoc2hlZXQpIHJldHVybiBzaGVldC5yZW5kZXJlci5lbGVtZW50O1xuXG4gICAgLy8gT3RoZXJ3aXNlIGluc2VydCBhZnRlciB0aGUgbGFzdCBhdHRhY2hlZC5cbiAgICBzaGVldCA9IGZpbmRIaWdoZXN0U2hlZXQocmVnaXN0cnksIG9wdGlvbnMpO1xuICAgIGlmIChzaGVldCkgcmV0dXJuIHNoZWV0LnJlbmRlcmVyLmVsZW1lbnQubmV4dEVsZW1lbnRTaWJsaW5nO1xuICB9XG5cbiAgLy8gVHJ5IHRvIGZpbmQgYSBjb21tZW50IHBsYWNlaG9sZGVyIGlmIHJlZ2lzdHJ5IGlzIGVtcHR5LlxuICB2YXIgaW5zZXJ0aW9uUG9pbnQgPSBvcHRpb25zLmluc2VydGlvblBvaW50O1xuXG4gIGlmIChpbnNlcnRpb25Qb2ludCAmJiB0eXBlb2YgaW5zZXJ0aW9uUG9pbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIGNvbW1lbnQgPSBmaW5kQ29tbWVudE5vZGUoaW5zZXJ0aW9uUG9pbnQpO1xuICAgIGlmIChjb21tZW50KSByZXR1cm4gY29tbWVudC5uZXh0U2libGluZztcbiAgICAvLyBJZiB1c2VyIHNwZWNpZmllcyBhbiBpbnNlcnRpb24gcG9pbnQgYW5kIGl0IGNhbid0IGJlIGZvdW5kIGluIHRoZSBkb2N1bWVudCAtXG4gICAgLy8gYmFkIHNwZWNpZmljaXR5IGlzc3VlcyBtYXkgYXBwZWFyLlxuICAgICgwLCBfd2FybmluZzJbJ2RlZmF1bHQnXSkoaW5zZXJ0aW9uUG9pbnQgPT09ICdqc3MnLCAnW0pTU10gSW5zZXJ0aW9uIHBvaW50IFwiJXNcIiBub3QgZm91bmQuJywgaW5zZXJ0aW9uUG9pbnQpO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogSW5zZXJ0IHN0eWxlIGVsZW1lbnQgaW50byB0aGUgRE9NLlxuICovXG5mdW5jdGlvbiBpbnNlcnRTdHlsZShzdHlsZSwgb3B0aW9ucykge1xuICB2YXIgaW5zZXJ0aW9uUG9pbnQgPSBvcHRpb25zLmluc2VydGlvblBvaW50O1xuXG4gIHZhciBwcmV2Tm9kZSA9IGZpbmRQcmV2Tm9kZShvcHRpb25zKTtcblxuICBpZiAocHJldk5vZGUpIHtcbiAgICB2YXIgcGFyZW50Tm9kZSA9IHByZXZOb2RlLnBhcmVudE5vZGU7XG5cbiAgICBpZiAocGFyZW50Tm9kZSkgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoc3R5bGUsIHByZXZOb2RlKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBXb3JrcyB3aXRoIGlmcmFtZXMgYW5kIGFueSBub2RlIHR5cGVzLlxuICBpZiAoaW5zZXJ0aW9uUG9pbnQgJiYgdHlwZW9mIGluc2VydGlvblBvaW50Lm5vZGVUeXBlID09PSAnbnVtYmVyJykge1xuICAgIC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzQxMzI4NzI4L2ZvcmNlLWNhc3RpbmctaW4tZmxvd1xuICAgIHZhciBpbnNlcnRpb25Qb2ludEVsZW1lbnQgPSBpbnNlcnRpb25Qb2ludDtcbiAgICB2YXIgX3BhcmVudE5vZGUgPSBpbnNlcnRpb25Qb2ludEVsZW1lbnQucGFyZW50Tm9kZTtcblxuICAgIGlmIChfcGFyZW50Tm9kZSkgX3BhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHN0eWxlLCBpbnNlcnRpb25Qb2ludEVsZW1lbnQubmV4dFNpYmxpbmcpO2Vsc2UgKDAsIF93YXJuaW5nMlsnZGVmYXVsdCddKShmYWxzZSwgJ1tKU1NdIEluc2VydGlvbiBwb2ludCBpcyBub3QgaW4gdGhlIERPTS4nKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBnZXRIZWFkKCkuaW5zZXJ0QmVmb3JlKHN0eWxlLCBwcmV2Tm9kZSk7XG59XG5cbnZhciBEb21SZW5kZXJlciA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRG9tUmVuZGVyZXIoc2hlZXQpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRG9tUmVuZGVyZXIpO1xuXG4gICAgdGhpcy5nZXRTdHlsZSA9IGdldFN0eWxlO1xuICAgIHRoaXMuc2V0U3R5bGUgPSBzZXRTdHlsZTtcbiAgICB0aGlzLnNldFNlbGVjdG9yID0gc2V0U2VsZWN0b3I7XG4gICAgdGhpcy5nZXRLZXkgPSBnZXRLZXk7XG4gICAgdGhpcy5nZXRVbmVzY2FwZWRLZXlzTWFwID0gZ2V0VW5lc2NhcGVkS2V5c01hcDtcbiAgICB0aGlzLmhhc0luc2VydGVkUnVsZXMgPSBmYWxzZTtcblxuICAgIC8vIFRoZXJlIGlzIG5vIHNoZWV0IHdoZW4gdGhlIHJlbmRlcmVyIGlzIHVzZWQgZnJvbSBhIHN0YW5kYWxvbmUgU3R5bGVSdWxlLlxuICAgIGlmIChzaGVldCkgX3NoZWV0czJbJ2RlZmF1bHQnXS5hZGQoc2hlZXQpO1xuXG4gICAgdGhpcy5zaGVldCA9IHNoZWV0O1xuXG4gICAgdmFyIF9yZWYgPSB0aGlzLnNoZWV0ID8gdGhpcy5zaGVldC5vcHRpb25zIDoge30sXG4gICAgICAgIG1lZGlhID0gX3JlZi5tZWRpYSxcbiAgICAgICAgbWV0YSA9IF9yZWYubWV0YSxcbiAgICAgICAgZWxlbWVudCA9IF9yZWYuZWxlbWVudDtcblxuICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICB0aGlzLmVsZW1lbnQudHlwZSA9ICd0ZXh0L2Nzcyc7XG4gICAgdGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZSgnZGF0YS1qc3MnLCAnJyk7XG4gICAgaWYgKG1lZGlhKSB0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKCdtZWRpYScsIG1lZGlhKTtcbiAgICBpZiAobWV0YSkgdGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZSgnZGF0YS1tZXRhJywgbWV0YSk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVyc2NvcmUtZGFuZ2xlXG4gICAgdmFyIG5vbmNlID0gZ2xvYmFsLl9fd2VicGFja19ub25jZV9fO1xuICAgIGlmIChub25jZSkgdGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZSgnbm9uY2UnLCBub25jZSk7XG4gIH1cblxuICAvKipcbiAgICogSW5zZXJ0IHN0eWxlIGVsZW1lbnQgaW50byByZW5kZXIgdHJlZS5cbiAgICovXG5cblxuICAvLyBIVE1MU3R5bGVFbGVtZW50IG5lZWRzIGZpeGluZyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmxvdy9pc3N1ZXMvMjY5NlxuXG5cbiAgX2NyZWF0ZUNsYXNzKERvbVJlbmRlcmVyLCBbe1xuICAgIGtleTogJ2F0dGFjaCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGF0dGFjaCgpIHtcbiAgICAgIC8vIEluIHRoZSBjYXNlIHRoZSBlbGVtZW50IG5vZGUgaXMgZXh0ZXJuYWwgYW5kIGl0IGlzIGFscmVhZHkgaW4gdGhlIERPTS5cbiAgICAgIGlmICh0aGlzLmVsZW1lbnQucGFyZW50Tm9kZSB8fCAhdGhpcy5zaGVldCkgcmV0dXJuO1xuXG4gICAgICAvLyBXaGVuIHJ1bGVzIGFyZSBpbnNlcnRlZCB1c2luZyBgaW5zZXJ0UnVsZWAgQVBJLCBhZnRlciBgc2hlZXQuZGV0YWNoKCkuYXR0YWNoKClgXG4gICAgICAvLyBicm93c2VycyByZW1vdmUgdGhvc2UgcnVsZXMuXG4gICAgICAvLyBUT0RPIGZpZ3VyZSBvdXQgaWYgaXRzIGEgYnVnIGFuZCBpZiBpdCBpcyBrbm93bi5cbiAgICAgIC8vIFdvcmthcm91bmQgaXMgdG8gcmVkZXBsb3kgdGhlIHNoZWV0IGJlZm9yZSBhdHRhY2hpbmcgYXMgYSBzdHJpbmcuXG4gICAgICBpZiAodGhpcy5oYXNJbnNlcnRlZFJ1bGVzKSB7XG4gICAgICAgIHRoaXMuZGVwbG95KCk7XG4gICAgICAgIHRoaXMuaGFzSW5zZXJ0ZWRSdWxlcyA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpbnNlcnRTdHlsZSh0aGlzLmVsZW1lbnQsIHRoaXMuc2hlZXQub3B0aW9ucyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIHN0eWxlIGVsZW1lbnQgZnJvbSByZW5kZXIgdHJlZS5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZGV0YWNoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGV0YWNoKCkge1xuICAgICAgdGhpcy5lbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5lbGVtZW50KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbmplY3QgQ1NTIHN0cmluZyBpbnRvIGVsZW1lbnQuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2RlcGxveScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlcGxveSgpIHtcbiAgICAgIGlmICghdGhpcy5zaGVldCkgcmV0dXJuO1xuICAgICAgdGhpcy5lbGVtZW50LnRleHRDb250ZW50ID0gJ1xcbicgKyB0aGlzLnNoZWV0LnRvU3RyaW5nKCkgKyAnXFxuJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnNlcnQgYSBydWxlIGludG8gZWxlbWVudC5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnaW5zZXJ0UnVsZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluc2VydFJ1bGUocnVsZSwgaW5kZXgpIHtcbiAgICAgIHZhciBzaGVldCA9IHRoaXMuZWxlbWVudC5zaGVldDtcbiAgICAgIHZhciBjc3NSdWxlcyA9IHNoZWV0LmNzc1J1bGVzO1xuXG4gICAgICB2YXIgc3RyID0gcnVsZS50b1N0cmluZygpO1xuICAgICAgaWYgKCFpbmRleCkgaW5kZXggPSBjc3NSdWxlcy5sZW5ndGg7XG5cbiAgICAgIGlmICghc3RyKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHNoZWV0Lmluc2VydFJ1bGUoc3RyLCBpbmRleCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgKDAsIF93YXJuaW5nMlsnZGVmYXVsdCddKShmYWxzZSwgJ1tKU1NdIENhbiBub3QgaW5zZXJ0IGFuIHVuc3VwcG9ydGVkIHJ1bGUgXFxuXFxyJXMnLCBydWxlKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdGhpcy5oYXNJbnNlcnRlZFJ1bGVzID0gdHJ1ZTtcblxuICAgICAgcmV0dXJuIGNzc1J1bGVzW2luZGV4XTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWxldGUgYSBydWxlLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdkZWxldGVSdWxlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVsZXRlUnVsZShjc3NSdWxlKSB7XG4gICAgICB2YXIgc2hlZXQgPSB0aGlzLmVsZW1lbnQuc2hlZXQ7XG5cbiAgICAgIHZhciBpbmRleCA9IHRoaXMuaW5kZXhPZihjc3NSdWxlKTtcbiAgICAgIGlmIChpbmRleCA9PT0gLTEpIHJldHVybiBmYWxzZTtcbiAgICAgIHNoZWV0LmRlbGV0ZVJ1bGUoaW5kZXgpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGluZGV4IG9mIGEgQ1NTIFJ1bGUuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2luZGV4T2YnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbmRleE9mKGNzc1J1bGUpIHtcbiAgICAgIHZhciBjc3NSdWxlcyA9IHRoaXMuZWxlbWVudC5zaGVldC5jc3NSdWxlcztcblxuICAgICAgZm9yICh2YXIgX2luZGV4ID0gMDsgX2luZGV4IDwgY3NzUnVsZXMubGVuZ3RoOyBfaW5kZXgrKykge1xuICAgICAgICBpZiAoY3NzUnVsZSA9PT0gY3NzUnVsZXNbX2luZGV4XSkgcmV0dXJuIF9pbmRleDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBhIG5ldyBDU1MgcnVsZSBhbmQgcmVwbGFjZSB0aGUgZXhpc3Rpbmcgb25lLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdyZXBsYWNlUnVsZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlcGxhY2VSdWxlKGNzc1J1bGUsIHJ1bGUpIHtcbiAgICAgIHZhciBpbmRleCA9IHRoaXMuaW5kZXhPZihjc3NSdWxlKTtcbiAgICAgIHZhciBuZXdDc3NSdWxlID0gdGhpcy5pbnNlcnRSdWxlKHJ1bGUsIGluZGV4KTtcbiAgICAgIHRoaXMuZWxlbWVudC5zaGVldC5kZWxldGVSdWxlKGluZGV4KTtcbiAgICAgIHJldHVybiBuZXdDc3NSdWxlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBhbGwgcnVsZXMgZWxlbWVudHMuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2dldFJ1bGVzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UnVsZXMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbGVtZW50LnNoZWV0LmNzc1J1bGVzO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBEb21SZW5kZXJlcjtcbn0oKTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gRG9tUmVuZGVyZXI7IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4vKiBlc2xpbnQtZGlzYWJsZSBjbGFzcy1tZXRob2RzLXVzZS10aGlzICovXG5cbi8qKlxuICogUmVuZGVyaW5nIGJhY2tlbmQgdG8gZG8gbm90aGluZyBpbiBub2RlanMuXG4gKi9cbnZhciBWaXJ0dWFsUmVuZGVyZXIgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFZpcnR1YWxSZW5kZXJlcigpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVmlydHVhbFJlbmRlcmVyKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhWaXJ0dWFsUmVuZGVyZXIsIFt7XG4gICAga2V5OiAnc2V0U3R5bGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRTdHlsZSgpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2dldFN0eWxlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U3R5bGUoKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc2V0U2VsZWN0b3InLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRTZWxlY3RvcigpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2dldEtleScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEtleSgpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdhdHRhY2gnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhdHRhY2goKSB7fVxuICB9LCB7XG4gICAga2V5OiAnZGV0YWNoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGV0YWNoKCkge31cbiAgfSwge1xuICAgIGtleTogJ2RlcGxveScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlcGxveSgpIHt9XG4gIH0sIHtcbiAgICBrZXk6ICdpbnNlcnRSdWxlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5zZXJ0UnVsZSgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdkZWxldGVSdWxlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVsZXRlUnVsZSgpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3JlcGxhY2VSdWxlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVwbGFjZVJ1bGUoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0UnVsZXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRSdWxlcygpIHt9XG4gIH0sIHtcbiAgICBrZXk6ICdpbmRleE9mJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5kZXhPZigpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gVmlydHVhbFJlbmRlcmVyO1xufSgpO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBWaXJ0dWFsUmVuZGVyZXI7IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX1J1bGVMaXN0ID0gcmVxdWlyZSgnLi4vUnVsZUxpc3QnKTtcblxudmFyIF9SdWxlTGlzdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9SdWxlTGlzdCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuLyoqXG4gKiBDb25kaXRpb25hbCBydWxlIGZvciBAbWVkaWEsIEBzdXBwb3J0c1xuICovXG52YXIgQ29uZGl0aW9uYWxSdWxlID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDb25kaXRpb25hbFJ1bGUoa2V5LCBzdHlsZXMsIG9wdGlvbnMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29uZGl0aW9uYWxSdWxlKTtcblxuICAgIHRoaXMudHlwZSA9ICdjb25kaXRpb25hbCc7XG4gICAgdGhpcy5pc1Byb2Nlc3NlZCA9IGZhbHNlO1xuXG4gICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLnJ1bGVzID0gbmV3IF9SdWxlTGlzdDJbJ2RlZmF1bHQnXShfZXh0ZW5kcyh7fSwgb3B0aW9ucywgeyBwYXJlbnQ6IHRoaXMgfSkpO1xuXG4gICAgZm9yICh2YXIgbmFtZSBpbiBzdHlsZXMpIHtcbiAgICAgIHRoaXMucnVsZXMuYWRkKG5hbWUsIHN0eWxlc1tuYW1lXSk7XG4gICAgfVxuXG4gICAgdGhpcy5ydWxlcy5wcm9jZXNzKCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgcnVsZS5cbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoQ29uZGl0aW9uYWxSdWxlLCBbe1xuICAgIGtleTogJ2dldFJ1bGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRSdWxlKG5hbWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnJ1bGVzLmdldChuYW1lKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgaW5kZXggb2YgYSBydWxlLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdpbmRleE9mJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5kZXhPZihydWxlKSB7XG4gICAgICByZXR1cm4gdGhpcy5ydWxlcy5pbmRleE9mKHJ1bGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbmQgcmVnaXN0ZXIgcnVsZSwgcnVuIHBsdWdpbnMuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2FkZFJ1bGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRSdWxlKG5hbWUsIHN0eWxlLCBvcHRpb25zKSB7XG4gICAgICB2YXIgcnVsZSA9IHRoaXMucnVsZXMuYWRkKG5hbWUsIHN0eWxlLCBvcHRpb25zKTtcbiAgICAgIHRoaXMub3B0aW9ucy5qc3MucGx1Z2lucy5vblByb2Nlc3NSdWxlKHJ1bGUpO1xuICAgICAgcmV0dXJuIHJ1bGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGEgQ1NTIHN0cmluZy5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAndG9TdHJpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7IGluZGVudDogMSB9O1xuXG4gICAgICB2YXIgaW5uZXIgPSB0aGlzLnJ1bGVzLnRvU3RyaW5nKG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIGlubmVyID8gdGhpcy5rZXkgKyAnIHtcXG4nICsgaW5uZXIgKyAnXFxufScgOiAnJztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQ29uZGl0aW9uYWxSdWxlO1xufSgpO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBDb25kaXRpb25hbFJ1bGU7IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX3RvQ3NzID0gcmVxdWlyZSgnLi4vdXRpbHMvdG9Dc3MnKTtcblxudmFyIF90b0NzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90b0Nzcyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIEZvbnRGYWNlUnVsZSA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRm9udEZhY2VSdWxlKGtleSwgc3R5bGUsIG9wdGlvbnMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRm9udEZhY2VSdWxlKTtcblxuICAgIHRoaXMudHlwZSA9ICdmb250LWZhY2UnO1xuICAgIHRoaXMuaXNQcm9jZXNzZWQgPSBmYWxzZTtcblxuICAgIHRoaXMua2V5ID0ga2V5O1xuICAgIHRoaXMuc3R5bGUgPSBzdHlsZTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhIENTUyBzdHJpbmcuXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKEZvbnRGYWNlUnVsZSwgW3tcbiAgICBrZXk6ICd0b1N0cmluZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKG9wdGlvbnMpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMuc3R5bGUpKSB7XG4gICAgICAgIHZhciBzdHIgPSAnJztcbiAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IHRoaXMuc3R5bGUubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgc3RyICs9ICgwLCBfdG9Dc3MyWydkZWZhdWx0J10pKHRoaXMua2V5LCB0aGlzLnN0eWxlW2luZGV4XSk7XG4gICAgICAgICAgaWYgKHRoaXMuc3R5bGVbaW5kZXggKyAxXSkgc3RyICs9ICdcXG4nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAoMCwgX3RvQ3NzMlsnZGVmYXVsdCddKSh0aGlzLmtleSwgdGhpcy5zdHlsZSwgb3B0aW9ucyk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEZvbnRGYWNlUnVsZTtcbn0oKTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gRm9udEZhY2VSdWxlOyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9SdWxlTGlzdCA9IHJlcXVpcmUoJy4uL1J1bGVMaXN0Jyk7XG5cbnZhciBfUnVsZUxpc3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUnVsZUxpc3QpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbi8qKlxuICogUnVsZSBmb3IgQGtleWZyYW1lc1xuICovXG52YXIgS2V5ZnJhbWVzUnVsZSA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gS2V5ZnJhbWVzUnVsZShrZXksIGZyYW1lcywgb3B0aW9ucykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBLZXlmcmFtZXNSdWxlKTtcblxuICAgIHRoaXMudHlwZSA9ICdrZXlmcmFtZXMnO1xuICAgIHRoaXMuaXNQcm9jZXNzZWQgPSBmYWxzZTtcblxuICAgIHRoaXMua2V5ID0ga2V5O1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5ydWxlcyA9IG5ldyBfUnVsZUxpc3QyWydkZWZhdWx0J10oX2V4dGVuZHMoe30sIG9wdGlvbnMsIHsgcGFyZW50OiB0aGlzIH0pKTtcblxuICAgIGZvciAodmFyIG5hbWUgaW4gZnJhbWVzKSB7XG4gICAgICB0aGlzLnJ1bGVzLmFkZChuYW1lLCBmcmFtZXNbbmFtZV0sIF9leHRlbmRzKHt9LCB0aGlzLm9wdGlvbnMsIHtcbiAgICAgICAgcGFyZW50OiB0aGlzLFxuICAgICAgICBzZWxlY3RvcjogbmFtZVxuICAgICAgfSkpO1xuICAgIH1cblxuICAgIHRoaXMucnVsZXMucHJvY2VzcygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhIENTUyBzdHJpbmcuXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKEtleWZyYW1lc1J1bGUsIFt7XG4gICAga2V5OiAndG9TdHJpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7IGluZGVudDogMSB9O1xuXG4gICAgICB2YXIgaW5uZXIgPSB0aGlzLnJ1bGVzLnRvU3RyaW5nKG9wdGlvbnMpO1xuICAgICAgaWYgKGlubmVyKSBpbm5lciArPSAnXFxuJztcbiAgICAgIHJldHVybiB0aGlzLmtleSArICcge1xcbicgKyBpbm5lciArICd9JztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gS2V5ZnJhbWVzUnVsZTtcbn0oKTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gS2V5ZnJhbWVzUnVsZTsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBTaW1wbGVSdWxlID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTaW1wbGVSdWxlKGtleSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU2ltcGxlUnVsZSk7XG5cbiAgICB0aGlzLnR5cGUgPSAnc2ltcGxlJztcbiAgICB0aGlzLmlzUHJvY2Vzc2VkID0gZmFsc2U7XG5cbiAgICB0aGlzLmtleSA9IGtleTtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYSBDU1Mgc3RyaW5nLlxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG5cblxuICBfY3JlYXRlQ2xhc3MoU2ltcGxlUnVsZSwgW3tcbiAgICBrZXk6ICd0b1N0cmluZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKG9wdGlvbnMpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMudmFsdWUpKSB7XG4gICAgICAgIHZhciBzdHIgPSAnJztcbiAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IHRoaXMudmFsdWUubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgc3RyICs9IHRoaXMua2V5ICsgJyAnICsgdGhpcy52YWx1ZVtpbmRleF0gKyAnOyc7XG4gICAgICAgICAgaWYgKHRoaXMudmFsdWVbaW5kZXggKyAxXSkgc3RyICs9ICdcXG4nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmtleSArICcgJyArIHRoaXMudmFsdWUgKyAnOyc7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFNpbXBsZVJ1bGU7XG59KCk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IFNpbXBsZVJ1bGU7IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfd2FybmluZyA9IHJlcXVpcmUoJ3dhcm5pbmcnKTtcblxudmFyIF93YXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dhcm5pbmcpO1xuXG52YXIgX3RvQ3NzID0gcmVxdWlyZSgnLi4vdXRpbHMvdG9Dc3MnKTtcblxudmFyIF90b0NzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90b0Nzcyk7XG5cbnZhciBfdG9Dc3NWYWx1ZSA9IHJlcXVpcmUoJy4uL3V0aWxzL3RvQ3NzVmFsdWUnKTtcblxudmFyIF90b0Nzc1ZhbHVlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RvQ3NzVmFsdWUpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBTdHlsZVJ1bGUgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFN0eWxlUnVsZShrZXksIHN0eWxlLCBvcHRpb25zKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFN0eWxlUnVsZSk7XG5cbiAgICB0aGlzLnR5cGUgPSAnc3R5bGUnO1xuICAgIHRoaXMuaXNQcm9jZXNzZWQgPSBmYWxzZTtcbiAgICB2YXIgc2hlZXQgPSBvcHRpb25zLnNoZWV0LFxuICAgICAgICBSZW5kZXJlciA9IG9wdGlvbnMuUmVuZGVyZXIsXG4gICAgICAgIHNlbGVjdG9yID0gb3B0aW9ucy5zZWxlY3RvcjtcblxuICAgIHRoaXMua2V5ID0ga2V5O1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5zdHlsZSA9IHN0eWxlO1xuICAgIGlmIChzZWxlY3RvcikgdGhpcy5zZWxlY3RvclRleHQgPSBzZWxlY3RvcjtcbiAgICB0aGlzLnJlbmRlcmVyID0gc2hlZXQgPyBzaGVldC5yZW5kZXJlciA6IG5ldyBSZW5kZXJlcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBzZWxlY3RvciBzdHJpbmcuXG4gICAqIEF0dGVudGlvbjogdXNlIHRoaXMgd2l0aCBjYXV0aW9uLiBNb3N0IGJyb3dzZXJzIGRpZG4ndCBpbXBsZW1lbnRcbiAgICogc2VsZWN0b3JUZXh0IHNldHRlciwgc28gdGhpcyBtYXkgcmVzdWx0IGluIHJlcmVuZGVyaW5nIG9mIGVudGlyZSBTdHlsZSBTaGVldC5cbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoU3R5bGVSdWxlLCBbe1xuICAgIGtleTogJ3Byb3AnLFxuXG5cbiAgICAvKipcbiAgICAgKiBHZXQgb3Igc2V0IGEgc3R5bGUgcHJvcGVydHkuXG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByb3AobmFtZSwgbmV4dFZhbHVlKSB7XG4gICAgICAvLyBJdCdzIGEgc2V0dGVyLlxuICAgICAgaWYgKG5leHRWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIC8vIERvbid0IGRvIGFueXRoaW5nIGlmIHRoZSB2YWx1ZSBoYXMgbm90IGNoYW5nZWQuXG4gICAgICAgIGlmICh0aGlzLnN0eWxlW25hbWVdICE9PSBuZXh0VmFsdWUpIHtcbiAgICAgICAgICBuZXh0VmFsdWUgPSB0aGlzLm9wdGlvbnMuanNzLnBsdWdpbnMub25DaGFuZ2VWYWx1ZShuZXh0VmFsdWUsIG5hbWUsIHRoaXMpO1xuICAgICAgICAgIHRoaXMuc3R5bGVbbmFtZV0gPSBuZXh0VmFsdWU7XG5cbiAgICAgICAgICAvLyBSZW5kZXJhYmxlIGlzIGRlZmluZWQgaWYgU3R5bGVTaGVldCBvcHRpb24gYGxpbmtgIGlzIHRydWUuXG4gICAgICAgICAgaWYgKHRoaXMucmVuZGVyYWJsZSkgdGhpcy5yZW5kZXJlci5zZXRTdHlsZSh0aGlzLnJlbmRlcmFibGUsIG5hbWUsIG5leHRWYWx1ZSk7ZWxzZSB7XG4gICAgICAgICAgICB2YXIgc2hlZXQgPSB0aGlzLm9wdGlvbnMuc2hlZXQ7XG5cbiAgICAgICAgICAgIGlmIChzaGVldCAmJiBzaGVldC5hdHRhY2hlZCkge1xuICAgICAgICAgICAgICAoMCwgX3dhcm5pbmcyWydkZWZhdWx0J10pKGZhbHNlLCAnUnVsZSBpcyBub3QgbGlua2VkLiBNaXNzaW5nIHNoZWV0IG9wdGlvbiBcImxpbms6IHRydWVcIi4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnN0eWxlW25hbWVdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFwcGx5IHJ1bGUgdG8gYW4gZWxlbWVudCBpbmxpbmUuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2FwcGx5VG8nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBseVRvKHJlbmRlcmFibGUpIHtcbiAgICAgIHZhciBqc29uID0gdGhpcy50b0pTT04oKTtcbiAgICAgIGZvciAodmFyIHByb3AgaW4ganNvbikge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKHJlbmRlcmFibGUsIHByb3AsIGpzb25bcHJvcF0pO1xuICAgICAgfXJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgSlNPTiByZXByZXNlbnRhdGlvbiBvZiB0aGUgcnVsZS5cbiAgICAgKiBGYWxsYmFja3MgYXJlIG5vdCBzdXBwb3J0ZWQuXG4gICAgICogVXNlZnVsIGZvciBpbmxpbmUgc3R5bGVzLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICd0b0pTT04nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICB2YXIganNvbiA9IHt9O1xuICAgICAgZm9yICh2YXIgcHJvcCBpbiB0aGlzLnN0eWxlKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuc3R5bGVbcHJvcF07XG4gICAgICAgIGlmICgodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih2YWx1ZSkpICE9PSAnb2JqZWN0JykganNvbltwcm9wXSA9IHZhbHVlO2Vsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSBqc29uW3Byb3BdID0gKDAsIF90b0Nzc1ZhbHVlMlsnZGVmYXVsdCddKSh2YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4ganNvbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSBDU1Mgc3RyaW5nLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICd0b1N0cmluZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKG9wdGlvbnMpIHtcbiAgICAgIHZhciBzaGVldCA9IHRoaXMub3B0aW9ucy5zaGVldDtcblxuICAgICAgdmFyIGxpbmsgPSBzaGVldCA/IHNoZWV0Lm9wdGlvbnMubGluayA6IGZhbHNlO1xuICAgICAgdmFyIG9wdHMgPSBsaW5rID8gX2V4dGVuZHMoe30sIG9wdGlvbnMsIHsgYWxsb3dFbXB0eTogdHJ1ZSB9KSA6IG9wdGlvbnM7XG4gICAgICByZXR1cm4gKDAsIF90b0NzczJbJ2RlZmF1bHQnXSkodGhpcy5zZWxlY3RvciwgdGhpcy5zdHlsZSwgb3B0cyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc2VsZWN0b3InLFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHNlbGVjdG9yKSB7XG4gICAgICBpZiAoc2VsZWN0b3IgPT09IHRoaXMuc2VsZWN0b3JUZXh0KSByZXR1cm47XG5cbiAgICAgIHRoaXMuc2VsZWN0b3JUZXh0ID0gc2VsZWN0b3I7XG5cbiAgICAgIGlmICh0aGlzLnJlbmRlcmFibGUpIHtcbiAgICAgICAgdmFyIGhhc0NoYW5nZWQgPSB0aGlzLnJlbmRlcmVyLnNldFNlbGVjdG9yKHRoaXMucmVuZGVyYWJsZSwgc2VsZWN0b3IpO1xuXG4gICAgICAgIC8vIElmIHNlbGVjdG9yIHNldHRlciBpcyBub3QgaW1wbGVtZW50ZWQsIHJlcmVuZGVyIHRoZSBydWxlLlxuICAgICAgICBpZiAoIWhhc0NoYW5nZWQgJiYgdGhpcy5yZW5kZXJhYmxlKSB7XG4gICAgICAgICAgdmFyIHJlbmRlcmFibGUgPSB0aGlzLnJlbmRlcmVyLnJlcGxhY2VSdWxlKHRoaXMucmVuZGVyYWJsZSwgdGhpcyk7XG4gICAgICAgICAgaWYgKHJlbmRlcmFibGUpIHRoaXMucmVuZGVyYWJsZSA9IHJlbmRlcmFibGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgc2VsZWN0b3Igc3RyaW5nLlxuICAgICAqL1xuICAgICxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNlbGVjdG9yVGV4dDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU3R5bGVSdWxlO1xufSgpO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBTdHlsZVJ1bGU7IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX3RvQ3NzID0gcmVxdWlyZSgnLi4vdXRpbHMvdG9Dc3MnKTtcblxudmFyIF90b0NzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90b0Nzcyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIFZpZXdwb3J0UnVsZSA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVmlld3BvcnRSdWxlKGtleSwgc3R5bGUsIG9wdGlvbnMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVmlld3BvcnRSdWxlKTtcblxuICAgIHRoaXMudHlwZSA9ICd2aWV3cG9ydCc7XG4gICAgdGhpcy5pc1Byb2Nlc3NlZCA9IGZhbHNlO1xuXG4gICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgdGhpcy5zdHlsZSA9IHN0eWxlO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGVzIGEgQ1NTIHN0cmluZy5cbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoVmlld3BvcnRSdWxlLCBbe1xuICAgIGtleTogJ3RvU3RyaW5nJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcob3B0aW9ucykge1xuICAgICAgcmV0dXJuICgwLCBfdG9Dc3MyWydkZWZhdWx0J10pKHRoaXMua2V5LCB0aGlzLnN0eWxlLCBvcHRpb25zKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gVmlld3BvcnRSdWxlO1xufSgpO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBWaWV3cG9ydFJ1bGU7IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX1NoZWV0c1JlZ2lzdHJ5ID0gcmVxdWlyZSgnLi9TaGVldHNSZWdpc3RyeScpO1xuXG52YXIgX1NoZWV0c1JlZ2lzdHJ5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1NoZWV0c1JlZ2lzdHJ5KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG4vKipcbiAqIFRoaXMgaXMgYSBnbG9iYWwgc2hlZXRzIHJlZ2lzdHJ5LiBPbmx5IERvbVJlbmRlcmVyIHdpbGwgYWRkIHNoZWV0cyB0byBpdC5cbiAqIE9uIHRoZSBzZXJ2ZXIgb25lIHNob3VsZCB1c2UgYW4gb3duIFNoZWV0c1JlZ2lzdHJ5IGluc3RhbmNlIGFuZCBhZGQgdGhlXG4gKiBzaGVldHMgdG8gaXQsIGJlY2F1c2UgeW91IG5lZWQgdG8gbWFrZSBzdXJlIHRvIGNyZWF0ZSBhIG5ldyByZWdpc3RyeSBmb3JcbiAqIGVhY2ggcmVxdWVzdCBpbiBvcmRlciB0byBub3QgbGVhayBzaGVldHMgYWNyb3NzIHJlcXVlc3RzLlxuICovXG5leHBvcnRzWydkZWZhdWx0J10gPSBuZXcgX1NoZWV0c1JlZ2lzdHJ5MlsnZGVmYXVsdCddKCk7IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGNsb25lU3R5bGU7XG5cbnZhciBfaXNPYnNlcnZhYmxlID0gcmVxdWlyZSgnLi9pc09ic2VydmFibGUnKTtcblxudmFyIF9pc09ic2VydmFibGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaXNPYnNlcnZhYmxlKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5mdW5jdGlvbiBjbG9uZVN0eWxlKHN0eWxlKSB7XG4gIC8vIFN1cHBvcnQgZW1wdHkgdmFsdWVzIGluIGNhc2UgdXNlciBlbmRzIHVwIHdpdGggdGhlbSBieSBhY2NpZGVudC5cbiAgaWYgKHN0eWxlID09IG51bGwpIHJldHVybiBzdHlsZTtcblxuICAvLyBTdXBwb3J0IHN0cmluZyB2YWx1ZSBmb3IgU2ltcGxlUnVsZS5cbiAgdmFyIHR5cGVPZlN0eWxlID0gdHlwZW9mIHN0eWxlID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihzdHlsZSk7XG5cbiAgaWYgKHR5cGVPZlN0eWxlID09PSAnc3RyaW5nJyB8fCB0eXBlT2ZTdHlsZSA9PT0gJ251bWJlcicgfHwgdHlwZU9mU3R5bGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gc3R5bGU7XG4gIH1cblxuICAvLyBTdXBwb3J0IGFycmF5IGZvciBGb250RmFjZVJ1bGUuXG4gIGlmIChpc0FycmF5KHN0eWxlKSkgcmV0dXJuIHN0eWxlLm1hcChjbG9uZVN0eWxlKTtcblxuICAvLyBTdXBwb3J0IE9ic2VydmFibGUgc3R5bGVzLiAgT2JzZXJ2YWJsZXMgYXJlIGltbXV0YWJsZSwgc28gd2UgZG9uJ3QgbmVlZCB0b1xuICAvLyBjb3B5IHRoZW0uXG4gIGlmICgoMCwgX2lzT2JzZXJ2YWJsZTJbJ2RlZmF1bHQnXSkoc3R5bGUpKSByZXR1cm4gc3R5bGU7XG5cbiAgdmFyIG5ld1N0eWxlID0ge307XG4gIGZvciAodmFyIG5hbWUgaW4gc3R5bGUpIHtcbiAgICB2YXIgdmFsdWUgPSBzdHlsZVtuYW1lXTtcbiAgICBpZiAoKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YodmFsdWUpKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIG5ld1N0eWxlW25hbWVdID0gY2xvbmVTdHlsZSh2YWx1ZSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgbmV3U3R5bGVbbmFtZV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBuZXdTdHlsZTtcbn0iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfd2FybmluZyA9IHJlcXVpcmUoJ3dhcm5pbmcnKTtcblxudmFyIF93YXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dhcm5pbmcpO1xuXG52YXIgX1N0eWxlU2hlZXQgPSByZXF1aXJlKCcuLi9TdHlsZVNoZWV0Jyk7XG5cbnZhciBfU3R5bGVTaGVldDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9TdHlsZVNoZWV0KTtcblxudmFyIF9tb2R1bGVJZCA9IHJlcXVpcmUoJy4vbW9kdWxlSWQnKTtcblxudmFyIF9tb2R1bGVJZDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9tb2R1bGVJZCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIG1heFJ1bGVzID0gMWUxMDtcblxuXG52YXIgZW52ID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlY7XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHdoaWNoIGdlbmVyYXRlcyB1bmlxdWUgY2xhc3MgbmFtZXMgYmFzZWQgb24gY291bnRlcnMuXG4gKiBXaGVuIG5ldyBnZW5lcmF0b3IgZnVuY3Rpb24gaXMgY3JlYXRlZCwgcnVsZSBjb3VudGVyIGlzIHJlc2V0ZWQuXG4gKiBXZSBuZWVkIHRvIHJlc2V0IHRoZSBydWxlIGNvdW50ZXIgZm9yIFNTUiBmb3IgZWFjaCByZXF1ZXN0LlxuICovXG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHJ1bGVDb3VudGVyID0gMDtcbiAgdmFyIGRlZmF1bHRQcmVmaXggPSBlbnYgPT09ICdwcm9kdWN0aW9uJyA/ICdjJyA6ICcnO1xuXG4gIHJldHVybiBmdW5jdGlvbiAocnVsZSwgc2hlZXQpIHtcbiAgICBydWxlQ291bnRlciArPSAxO1xuXG4gICAgaWYgKHJ1bGVDb3VudGVyID4gbWF4UnVsZXMpIHtcbiAgICAgICgwLCBfd2FybmluZzJbJ2RlZmF1bHQnXSkoZmFsc2UsICdbSlNTXSBZb3UgbWlnaHQgaGF2ZSBhIG1lbW9yeSBsZWFrLiBSdWxlIGNvdW50ZXIgaXMgYXQgJXMuJywgcnVsZUNvdW50ZXIpO1xuICAgIH1cblxuICAgIHZhciBwcmVmaXggPSBkZWZhdWx0UHJlZml4O1xuICAgIHZhciBqc3NJZCA9ICcnO1xuXG4gICAgaWYgKHNoZWV0KSB7XG4gICAgICBwcmVmaXggPSBzaGVldC5vcHRpb25zLmNsYXNzTmFtZVByZWZpeCB8fCBkZWZhdWx0UHJlZml4O1xuICAgICAgaWYgKHNoZWV0Lm9wdGlvbnMuanNzLmlkICE9IG51bGwpIGpzc0lkICs9IHNoZWV0Lm9wdGlvbnMuanNzLmlkO1xuICAgIH1cblxuICAgIGlmIChlbnYgPT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgcmV0dXJuICcnICsgcHJlZml4ICsgX21vZHVsZUlkMlsnZGVmYXVsdCddICsganNzSWQgKyBydWxlQ291bnRlcjtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJlZml4ICsgcnVsZS5rZXkgKyAnLScgKyBfbW9kdWxlSWQyWydkZWZhdWx0J10gKyAoanNzSWQgJiYgJy0nICsganNzSWQpICsgJy0nICsgcnVsZUNvdW50ZXI7XG4gIH07XG59OyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGNyZWF0ZVJ1bGU7XG5cbnZhciBfd2FybmluZyA9IHJlcXVpcmUoJ3dhcm5pbmcnKTtcblxudmFyIF93YXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dhcm5pbmcpO1xuXG52YXIgX1N0eWxlUnVsZSA9IHJlcXVpcmUoJy4uL3J1bGVzL1N0eWxlUnVsZScpO1xuXG52YXIgX1N0eWxlUnVsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9TdHlsZVJ1bGUpO1xuXG52YXIgX2Nsb25lU3R5bGUgPSByZXF1aXJlKCcuLi91dGlscy9jbG9uZVN0eWxlJyk7XG5cbnZhciBfY2xvbmVTdHlsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbG9uZVN0eWxlKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG4vKipcbiAqIENyZWF0ZSBhIHJ1bGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVJ1bGUoKSB7XG4gIHZhciBuYW1lID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAndW5uYW1lZCc7XG4gIHZhciBkZWNsID0gYXJndW1lbnRzWzFdO1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50c1syXTtcbiAgdmFyIGpzcyA9IG9wdGlvbnMuanNzO1xuXG4gIHZhciBkZWNsQ29weSA9ICgwLCBfY2xvbmVTdHlsZTJbJ2RlZmF1bHQnXSkoZGVjbCk7XG5cbiAgdmFyIHJ1bGUgPSBqc3MucGx1Z2lucy5vbkNyZWF0ZVJ1bGUobmFtZSwgZGVjbENvcHksIG9wdGlvbnMpO1xuICBpZiAocnVsZSkgcmV0dXJuIHJ1bGU7XG5cbiAgLy8gSXQgaXMgYW4gYXQtcnVsZSBhbmQgaXQgaGFzIG5vIGluc3RhbmNlLlxuICBpZiAobmFtZVswXSA9PT0gJ0AnKSB7XG4gICAgKDAsIF93YXJuaW5nMlsnZGVmYXVsdCddKShmYWxzZSwgJ1tKU1NdIFVua25vd24gYXQtcnVsZSAlcycsIG5hbWUpO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBfU3R5bGVSdWxlMlsnZGVmYXVsdCddKG5hbWUsIGRlY2xDb3B5LCBvcHRpb25zKTtcbn0iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG52YXIgQ1NTID0gZ2xvYmFsLkNTUztcblxudmFyIGVudiA9IHByb2Nlc3MuZW52Lk5PREVfRU5WO1xuXG52YXIgZXNjYXBlUmVnZXggPSAvKFtbXFxdLiMqJD48K349fF46KCksXCInYF0pL2c7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgLy8gV2UgZG9uJ3QgbmVlZCB0byBlc2NhcGUgaXQgaW4gcHJvZHVjdGlvbiwgYmVjYXVzZSB3ZSBhcmUgbm90IHVzaW5nIHVzZXInc1xuICAvLyBpbnB1dCBmb3Igc2VsZWN0b3JzLCB3ZSBhcmUgZ2VuZXJhdGluZyBhIHZhbGlkIHNlbGVjdG9yLlxuICBpZiAoZW52ID09PSAncHJvZHVjdGlvbicpIHJldHVybiBzdHI7XG5cbiAgaWYgKCFDU1MgfHwgIUNTUy5lc2NhcGUpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoZXNjYXBlUmVnZXgsICdcXFxcJDEnKTtcbiAgfVxuXG4gIHJldHVybiBDU1MuZXNjYXBlKHN0cik7XG59OyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG4vKipcbiAqIEV4dHJhY3RzIGEgc3R5bGVzIG9iamVjdCB3aXRoIG9ubHkgcHJvcHMgdGhhdCBjb250YWluIGZ1bmN0aW9uIHZhbHVlcy5cbiAqL1xuZXhwb3J0c1snZGVmYXVsdCddID0gZnVuY3Rpb24gKHN0eWxlcykge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2hhZG93XG4gIGZ1bmN0aW9uIGV4dHJhY3Qoc3R5bGVzKSB7XG4gICAgdmFyIHRvID0gbnVsbDtcblxuICAgIGZvciAodmFyIGtleSBpbiBzdHlsZXMpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHN0eWxlc1trZXldO1xuICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHZhbHVlKTtcblxuICAgICAgaWYgKHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaWYgKCF0bykgdG8gPSB7fTtcbiAgICAgICAgdG9ba2V5XSA9IHZhbHVlO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgdmFyIGV4dHJhY3RlZCA9IGV4dHJhY3QodmFsdWUpO1xuICAgICAgICBpZiAoZXh0cmFjdGVkKSB7XG4gICAgICAgICAgaWYgKCF0bykgdG8gPSB7fTtcbiAgICAgICAgICB0b1trZXldID0gZXh0cmFjdGVkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRvO1xuICB9XG5cbiAgcmV0dXJuIGV4dHJhY3Qoc3R5bGVzKTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3N5bWJvbE9ic2VydmFibGUgPSByZXF1aXJlKCdzeW1ib2wtb2JzZXJ2YWJsZScpO1xuXG52YXIgX3N5bWJvbE9ic2VydmFibGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3ltYm9sT2JzZXJ2YWJsZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZXhwb3J0c1snZGVmYXVsdCddID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAmJiB2YWx1ZVtfc3ltYm9sT2JzZXJ2YWJsZTJbJ2RlZmF1bHQnXV0gJiYgdmFsdWUgPT09IHZhbHVlW19zeW1ib2xPYnNlcnZhYmxlMlsnZGVmYXVsdCddXSgpO1xufTsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbnZhciByZWdFeHAgPSAvKFtBLVpdKS9nO1xudmFyIHJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlKHN0cikge1xuICByZXR1cm4gXCItXCIgKyBzdHIudG9Mb3dlckNhc2UoKTtcbn07XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gZnVuY3Rpb24gKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UocmVnRXhwLCByZXBsYWNlKTtcbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IGxpbmtSdWxlO1xuLyoqXG4gKiBMaW5rIHJ1bGUgd2l0aCBDU1NTdHlsZVJ1bGUgYW5kIG5lc3RlZCBydWxlcyB3aXRoIGNvcnJlc3BvbmRpbmcgbmVzdGVkIGNzc1J1bGVzIGlmIGJvdGggZXhpc3RzLlxuICovXG5mdW5jdGlvbiBsaW5rUnVsZShydWxlLCBjc3NSdWxlKSB7XG4gIHJ1bGUucmVuZGVyYWJsZSA9IGNzc1J1bGU7XG4gIGlmIChydWxlLnJ1bGVzICYmIGNzc1J1bGUuY3NzUnVsZXMpIHJ1bGUucnVsZXMubGluayhjc3NSdWxlLmNzc1J1bGVzKTtcbn0iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG52YXIgbnMgPSAnMmYxYWNjNmMzYTYwNmIwODJlNWVlZjVlNTQ0MTRmZmInO1xuaWYgKGdsb2JhbFtuc10gPT0gbnVsbCkgZ2xvYmFsW25zXSA9IDA7XG5cbi8vIEJ1bmRsZSBtYXkgY29udGFpbiBtdWx0aXBsZSBKU1MgdmVyc2lvbnMgYXQgdGhlIHNhbWUgdGltZS4gSW4gb3JkZXIgdG8gaWRlbnRpZnlcbi8vIHRoZSBjdXJyZW50IHZlcnNpb24gd2l0aCBqdXN0IG9uZSBzaG9ydCBudW1iZXIgYW5kIHVzZSBpdCBmb3IgY2xhc3NlcyBnZW5lcmF0aW9uXG4vLyB3ZSB1c2UgYSBjb3VudGVyLiBBbHNvIGl0IGlzIG1vcmUgYWNjdXJhdGUsIGJlY2F1c2UgdXNlciBjYW4gbWFudWFsbHkgcmVldmFsdWF0ZVxuLy8gdGhlIG1vZHVsZS5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGdsb2JhbFtuc10rKzsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzWydkZWZhdWx0J10gPSB0b0NzcztcblxudmFyIF90b0Nzc1ZhbHVlID0gcmVxdWlyZSgnLi90b0Nzc1ZhbHVlJyk7XG5cbnZhciBfdG9Dc3NWYWx1ZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90b0Nzc1ZhbHVlKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG4vKipcbiAqIEluZGVudCBhIHN0cmluZy5cbiAqIGh0dHA6Ly9qc3BlcmYuY29tL2FycmF5LWpvaW4tdnMtZm9yXG4gKi9cbmZ1bmN0aW9uIGluZGVudFN0cihzdHIsIGluZGVudCkge1xuICB2YXIgcmVzdWx0ID0gJyc7XG4gIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBpbmRlbnQ7IGluZGV4KyspIHtcbiAgICByZXN1bHQgKz0gJyAgJztcbiAgfXJldHVybiByZXN1bHQgKyBzdHI7XG59XG5cbi8qKlxuICogQ29udmVydHMgYSBSdWxlIHRvIENTUyBzdHJpbmcuXG4gKi9cblxuZnVuY3Rpb24gdG9Dc3Moc2VsZWN0b3IsIHN0eWxlKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcblxuICB2YXIgcmVzdWx0ID0gJyc7XG5cbiAgaWYgKCFzdHlsZSkgcmV0dXJuIHJlc3VsdDtcblxuICB2YXIgX29wdGlvbnMkaW5kZW50ID0gb3B0aW9ucy5pbmRlbnQsXG4gICAgICBpbmRlbnQgPSBfb3B0aW9ucyRpbmRlbnQgPT09IHVuZGVmaW5lZCA/IDAgOiBfb3B0aW9ucyRpbmRlbnQ7XG4gIHZhciBmYWxsYmFja3MgPSBzdHlsZS5mYWxsYmFja3M7XG5cblxuICBpbmRlbnQrKztcblxuICAvLyBBcHBseSBmYWxsYmFja3MgZmlyc3QuXG4gIGlmIChmYWxsYmFja3MpIHtcbiAgICAvLyBBcnJheSBzeW50YXgge2ZhbGxiYWNrczogW3twcm9wOiB2YWx1ZX1dfVxuICAgIGlmIChBcnJheS5pc0FycmF5KGZhbGxiYWNrcykpIHtcbiAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBmYWxsYmFja3MubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIHZhciBmYWxsYmFjayA9IGZhbGxiYWNrc1tpbmRleF07XG4gICAgICAgIGZvciAodmFyIHByb3AgaW4gZmFsbGJhY2spIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBmYWxsYmFja1twcm9wXTtcbiAgICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0ICs9ICdcXG4nICsgaW5kZW50U3RyKHByb3AgKyAnOiAnICsgKDAsIF90b0Nzc1ZhbHVlMlsnZGVmYXVsdCddKSh2YWx1ZSkgKyAnOycsIGluZGVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIE9iamVjdCBzeW50YXgge2ZhbGxiYWNrczoge3Byb3A6IHZhbHVlfX1cbiAgICBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgX3Byb3AgaW4gZmFsbGJhY2tzKSB7XG4gICAgICAgICAgdmFyIF92YWx1ZSA9IGZhbGxiYWNrc1tfcHJvcF07XG4gICAgICAgICAgaWYgKF92YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gJ1xcbicgKyBpbmRlbnRTdHIoX3Byb3AgKyAnOiAnICsgKDAsIF90b0Nzc1ZhbHVlMlsnZGVmYXVsdCddKShfdmFsdWUpICsgJzsnLCBpbmRlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICB9XG5cbiAgZm9yICh2YXIgX3Byb3AyIGluIHN0eWxlKSB7XG4gICAgdmFyIF92YWx1ZTIgPSBzdHlsZVtfcHJvcDJdO1xuICAgIGlmIChfdmFsdWUyICE9IG51bGwgJiYgX3Byb3AyICE9PSAnZmFsbGJhY2tzJykge1xuICAgICAgcmVzdWx0ICs9ICdcXG4nICsgaW5kZW50U3RyKF9wcm9wMiArICc6ICcgKyAoMCwgX3RvQ3NzVmFsdWUyWydkZWZhdWx0J10pKF92YWx1ZTIpICsgJzsnLCBpbmRlbnQpO1xuICAgIH1cbiAgfVxuXG4gIC8vIEFsbG93IGVtcHR5IHN0eWxlIGluIHRoaXMgY2FzZSwgYmVjYXVzZSBwcm9wZXJ0aWVzIHdpbGwgYmUgYWRkZWQgZHluYW1pY2FsbHkuXG4gIGlmICghcmVzdWx0ICYmICFvcHRpb25zLmFsbG93RW1wdHkpIHJldHVybiByZXN1bHQ7XG5cbiAgaW5kZW50LS07XG4gIHJlc3VsdCA9IGluZGVudFN0cihzZWxlY3RvciArICcgeycgKyByZXN1bHQgKyAnXFxuJywgaW5kZW50KSArIGluZGVudFN0cignfScsIGluZGVudCk7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn0iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzWydkZWZhdWx0J10gPSB0b0Nzc1ZhbHVlO1xudmFyIGpvaW4gPSBmdW5jdGlvbiBqb2luKHZhbHVlLCBieSkge1xuICB2YXIgcmVzdWx0ID0gJyc7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBSZW1vdmUgIWltcG9ydGFudCBmcm9tIHRoZSB2YWx1ZSwgaXQgd2lsbCBiZSByZWFkZGVkIGxhdGVyLlxuICAgIGlmICh2YWx1ZVtpXSA9PT0gJyFpbXBvcnRhbnQnKSBicmVhaztcbiAgICBpZiAocmVzdWx0KSByZXN1bHQgKz0gYnk7XG4gICAgcmVzdWx0ICs9IHZhbHVlW2ldO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGFycmF5IHZhbHVlcyB0byBzdHJpbmcuXG4gKlxuICogYG1hcmdpbjogW1snNXB4JywgJzEwcHgnXV1gID4gYG1hcmdpbjogNXB4IDEwcHg7YFxuICogYGJvcmRlcjogWycxcHgnLCAnMnB4J11gID4gYGJvcmRlcjogMXB4LCAycHg7YFxuICogYG1hcmdpbjogW1snNXB4JywgJzEwcHgnXSwgJyFpbXBvcnRhbnQnXWAgPiBgbWFyZ2luOiA1cHggMTBweCAhaW1wb3J0YW50O2BcbiAqIGBjb2xvcjogWydyZWQnLCAhaW1wb3J0YW50XWAgPiBgY29sb3I6IHJlZCAhaW1wb3J0YW50O2BcbiAqL1xuZnVuY3Rpb24gdG9Dc3NWYWx1ZSh2YWx1ZSkge1xuICB2YXIgaWdub3JlSW1wb3J0YW50ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcblxuICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSByZXR1cm4gdmFsdWU7XG5cbiAgdmFyIGNzc1ZhbHVlID0gJyc7XG5cbiAgLy8gU3VwcG9ydCBzcGFjZSBzZXBhcmF0ZWQgdmFsdWVzIHZpYSBgW1snNXB4JywgJzEwcHgnXV1gLlxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZVswXSkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodmFsdWVbaV0gPT09ICchaW1wb3J0YW50JykgYnJlYWs7XG4gICAgICBpZiAoY3NzVmFsdWUpIGNzc1ZhbHVlICs9ICcsICc7XG4gICAgICBjc3NWYWx1ZSArPSBqb2luKHZhbHVlW2ldLCAnICcpO1xuICAgIH1cbiAgfSBlbHNlIGNzc1ZhbHVlID0gam9pbih2YWx1ZSwgJywgJyk7XG5cbiAgLy8gQWRkICFpbXBvcnRhbnQsIGJlY2F1c2UgaXQgd2FzIGlnbm9yZWQuXG4gIGlmICghaWdub3JlSW1wb3J0YW50ICYmIHZhbHVlW3ZhbHVlLmxlbmd0aCAtIDFdID09PSAnIWltcG9ydGFudCcpIHtcbiAgICBjc3NWYWx1ZSArPSAnICFpbXBvcnRhbnQnO1xuICB9XG5cbiAgcmV0dXJuIGNzc1ZhbHVlO1xufSIsIi8vISBtb21lbnQuanNcbi8vISB2ZXJzaW9uIDogMi4yMC4xXG4vLyEgYXV0aG9ycyA6IFRpbSBXb29kLCBJc2tyZW4gQ2hlcm5ldiwgTW9tZW50LmpzIGNvbnRyaWJ1dG9yc1xuLy8hIGxpY2Vuc2UgOiBNSVRcbi8vISBtb21lbnRqcy5jb21cblxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxuICAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG4gICAgZ2xvYmFsLm1vbWVudCA9IGZhY3RvcnkoKVxufSh0aGlzLCAoZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbnZhciBob29rQ2FsbGJhY2s7XG5cbmZ1bmN0aW9uIGhvb2tzICgpIHtcbiAgICByZXR1cm4gaG9va0NhbGxiYWNrLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59XG5cbi8vIFRoaXMgaXMgZG9uZSB0byByZWdpc3RlciB0aGUgbWV0aG9kIGNhbGxlZCB3aXRoIG1vbWVudCgpXG4vLyB3aXRob3V0IGNyZWF0aW5nIGNpcmN1bGFyIGRlcGVuZGVuY2llcy5cbmZ1bmN0aW9uIHNldEhvb2tDYWxsYmFjayAoY2FsbGJhY2spIHtcbiAgICBob29rQ2FsbGJhY2sgPSBjYWxsYmFjaztcbn1cblxuZnVuY3Rpb24gaXNBcnJheShpbnB1dCkge1xuICAgIHJldHVybiBpbnB1dCBpbnN0YW5jZW9mIEFycmF5IHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGlucHV0KSB7XG4gICAgLy8gSUU4IHdpbGwgdHJlYXQgdW5kZWZpbmVkIGFuZCBudWxsIGFzIG9iamVjdCBpZiBpdCB3YXNuJ3QgZm9yXG4gICAgLy8gaW5wdXQgIT0gbnVsbFxuICAgIHJldHVybiBpbnB1dCAhPSBudWxsICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09ICdbb2JqZWN0IE9iamVjdF0nO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdEVtcHR5KG9iaikge1xuICAgIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcykge1xuICAgICAgICByZXR1cm4gKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaikubGVuZ3RoID09PSAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgaztcbiAgICAgICAgZm9yIChrIGluIG9iaikge1xuICAgICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGlucHV0KSB7XG4gICAgcmV0dXJuIGlucHV0ID09PSB2b2lkIDA7XG59XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGlucHV0KSB7XG4gICAgcmV0dXJuIHR5cGVvZiBpbnB1dCA9PT0gJ251bWJlcicgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gJ1tvYmplY3QgTnVtYmVyXSc7XG59XG5cbmZ1bmN0aW9uIGlzRGF0ZShpbnB1dCkge1xuICAgIHJldHVybiBpbnB1dCBpbnN0YW5jZW9mIERhdGUgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuXG5mdW5jdGlvbiBtYXAoYXJyLCBmbikge1xuICAgIHZhciByZXMgPSBbXSwgaTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHJlcy5wdXNoKGZuKGFycltpXSwgaSkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuXG5mdW5jdGlvbiBoYXNPd25Qcm9wKGEsIGIpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGEsIGIpO1xufVxuXG5mdW5jdGlvbiBleHRlbmQoYSwgYikge1xuICAgIGZvciAodmFyIGkgaW4gYikge1xuICAgICAgICBpZiAoaGFzT3duUHJvcChiLCBpKSkge1xuICAgICAgICAgICAgYVtpXSA9IGJbaV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaGFzT3duUHJvcChiLCAndG9TdHJpbmcnKSkge1xuICAgICAgICBhLnRvU3RyaW5nID0gYi50b1N0cmluZztcbiAgICB9XG5cbiAgICBpZiAoaGFzT3duUHJvcChiLCAndmFsdWVPZicpKSB7XG4gICAgICAgIGEudmFsdWVPZiA9IGIudmFsdWVPZjtcbiAgICB9XG5cbiAgICByZXR1cm4gYTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlVVRDIChpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCkge1xuICAgIHJldHVybiBjcmVhdGVMb2NhbE9yVVRDKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0LCB0cnVlKS51dGMoKTtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdFBhcnNpbmdGbGFncygpIHtcbiAgICAvLyBXZSBuZWVkIHRvIGRlZXAgY2xvbmUgdGhpcyBvYmplY3QuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW1wdHkgICAgICAgICAgIDogZmFsc2UsXG4gICAgICAgIHVudXNlZFRva2VucyAgICA6IFtdLFxuICAgICAgICB1bnVzZWRJbnB1dCAgICAgOiBbXSxcbiAgICAgICAgb3ZlcmZsb3cgICAgICAgIDogLTIsXG4gICAgICAgIGNoYXJzTGVmdE92ZXIgICA6IDAsXG4gICAgICAgIG51bGxJbnB1dCAgICAgICA6IGZhbHNlLFxuICAgICAgICBpbnZhbGlkTW9udGggICAgOiBudWxsLFxuICAgICAgICBpbnZhbGlkRm9ybWF0ICAgOiBmYWxzZSxcbiAgICAgICAgdXNlckludmFsaWRhdGVkIDogZmFsc2UsXG4gICAgICAgIGlzbyAgICAgICAgICAgICA6IGZhbHNlLFxuICAgICAgICBwYXJzZWREYXRlUGFydHMgOiBbXSxcbiAgICAgICAgbWVyaWRpZW0gICAgICAgIDogbnVsbCxcbiAgICAgICAgcmZjMjgyMiAgICAgICAgIDogZmFsc2UsXG4gICAgICAgIHdlZWtkYXlNaXNtYXRjaCA6IGZhbHNlXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0UGFyc2luZ0ZsYWdzKG0pIHtcbiAgICBpZiAobS5fcGYgPT0gbnVsbCkge1xuICAgICAgICBtLl9wZiA9IGRlZmF1bHRQYXJzaW5nRmxhZ3MoKTtcbiAgICB9XG4gICAgcmV0dXJuIG0uX3BmO1xufVxuXG52YXIgc29tZTtcbmlmIChBcnJheS5wcm90b3R5cGUuc29tZSkge1xuICAgIHNvbWUgPSBBcnJheS5wcm90b3R5cGUuc29tZTtcbn0gZWxzZSB7XG4gICAgc29tZSA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICAgICAgdmFyIHQgPSBPYmplY3QodGhpcyk7XG4gICAgICAgIHZhciBsZW4gPSB0Lmxlbmd0aCA+Pj4gMDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaSBpbiB0ICYmIGZ1bi5jYWxsKHRoaXMsIHRbaV0sIGksIHQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gaXNWYWxpZChtKSB7XG4gICAgaWYgKG0uX2lzVmFsaWQgPT0gbnVsbCkge1xuICAgICAgICB2YXIgZmxhZ3MgPSBnZXRQYXJzaW5nRmxhZ3MobSk7XG4gICAgICAgIHZhciBwYXJzZWRQYXJ0cyA9IHNvbWUuY2FsbChmbGFncy5wYXJzZWREYXRlUGFydHMsIGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICByZXR1cm4gaSAhPSBudWxsO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGlzTm93VmFsaWQgPSAhaXNOYU4obS5fZC5nZXRUaW1lKCkpICYmXG4gICAgICAgICAgICBmbGFncy5vdmVyZmxvdyA8IDAgJiZcbiAgICAgICAgICAgICFmbGFncy5lbXB0eSAmJlxuICAgICAgICAgICAgIWZsYWdzLmludmFsaWRNb250aCAmJlxuICAgICAgICAgICAgIWZsYWdzLmludmFsaWRXZWVrZGF5ICYmXG4gICAgICAgICAgICAhZmxhZ3Mud2Vla2RheU1pc21hdGNoICYmXG4gICAgICAgICAgICAhZmxhZ3MubnVsbElucHV0ICYmXG4gICAgICAgICAgICAhZmxhZ3MuaW52YWxpZEZvcm1hdCAmJlxuICAgICAgICAgICAgIWZsYWdzLnVzZXJJbnZhbGlkYXRlZCAmJlxuICAgICAgICAgICAgKCFmbGFncy5tZXJpZGllbSB8fCAoZmxhZ3MubWVyaWRpZW0gJiYgcGFyc2VkUGFydHMpKTtcblxuICAgICAgICBpZiAobS5fc3RyaWN0KSB7XG4gICAgICAgICAgICBpc05vd1ZhbGlkID0gaXNOb3dWYWxpZCAmJlxuICAgICAgICAgICAgICAgIGZsYWdzLmNoYXJzTGVmdE92ZXIgPT09IDAgJiZcbiAgICAgICAgICAgICAgICBmbGFncy51bnVzZWRUb2tlbnMubGVuZ3RoID09PSAwICYmXG4gICAgICAgICAgICAgICAgZmxhZ3MuYmlnSG91ciA9PT0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKE9iamVjdC5pc0Zyb3plbiA9PSBudWxsIHx8ICFPYmplY3QuaXNGcm96ZW4obSkpIHtcbiAgICAgICAgICAgIG0uX2lzVmFsaWQgPSBpc05vd1ZhbGlkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGlzTm93VmFsaWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG0uX2lzVmFsaWQ7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUludmFsaWQgKGZsYWdzKSB7XG4gICAgdmFyIG0gPSBjcmVhdGVVVEMoTmFOKTtcbiAgICBpZiAoZmxhZ3MgIT0gbnVsbCkge1xuICAgICAgICBleHRlbmQoZ2V0UGFyc2luZ0ZsYWdzKG0pLCBmbGFncyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MobSkudXNlckludmFsaWRhdGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbTtcbn1cblxuLy8gUGx1Z2lucyB0aGF0IGFkZCBwcm9wZXJ0aWVzIHNob3VsZCBhbHNvIGFkZCB0aGUga2V5IGhlcmUgKG51bGwgdmFsdWUpLFxuLy8gc28gd2UgY2FuIHByb3Blcmx5IGNsb25lIG91cnNlbHZlcy5cbnZhciBtb21lbnRQcm9wZXJ0aWVzID0gaG9va3MubW9tZW50UHJvcGVydGllcyA9IFtdO1xuXG5mdW5jdGlvbiBjb3B5Q29uZmlnKHRvLCBmcm9tKSB7XG4gICAgdmFyIGksIHByb3AsIHZhbDtcblxuICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5faXNBTW9tZW50T2JqZWN0KSkge1xuICAgICAgICB0by5faXNBTW9tZW50T2JqZWN0ID0gZnJvbS5faXNBTW9tZW50T2JqZWN0O1xuICAgIH1cbiAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2kpKSB7XG4gICAgICAgIHRvLl9pID0gZnJvbS5faTtcbiAgICB9XG4gICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9mKSkge1xuICAgICAgICB0by5fZiA9IGZyb20uX2Y7XG4gICAgfVxuICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fbCkpIHtcbiAgICAgICAgdG8uX2wgPSBmcm9tLl9sO1xuICAgIH1cbiAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX3N0cmljdCkpIHtcbiAgICAgICAgdG8uX3N0cmljdCA9IGZyb20uX3N0cmljdDtcbiAgICB9XG4gICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl90em0pKSB7XG4gICAgICAgIHRvLl90em0gPSBmcm9tLl90em07XG4gICAgfVxuICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5faXNVVEMpKSB7XG4gICAgICAgIHRvLl9pc1VUQyA9IGZyb20uX2lzVVRDO1xuICAgIH1cbiAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX29mZnNldCkpIHtcbiAgICAgICAgdG8uX29mZnNldCA9IGZyb20uX29mZnNldDtcbiAgICB9XG4gICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9wZikpIHtcbiAgICAgICAgdG8uX3BmID0gZ2V0UGFyc2luZ0ZsYWdzKGZyb20pO1xuICAgIH1cbiAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2xvY2FsZSkpIHtcbiAgICAgICAgdG8uX2xvY2FsZSA9IGZyb20uX2xvY2FsZTtcbiAgICB9XG5cbiAgICBpZiAobW9tZW50UHJvcGVydGllcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBtb21lbnRQcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBwcm9wID0gbW9tZW50UHJvcGVydGllc1tpXTtcbiAgICAgICAgICAgIHZhbCA9IGZyb21bcHJvcF07XG4gICAgICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKHZhbCkpIHtcbiAgICAgICAgICAgICAgICB0b1twcm9wXSA9IHZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0bztcbn1cblxudmFyIHVwZGF0ZUluUHJvZ3Jlc3MgPSBmYWxzZTtcblxuLy8gTW9tZW50IHByb3RvdHlwZSBvYmplY3RcbmZ1bmN0aW9uIE1vbWVudChjb25maWcpIHtcbiAgICBjb3B5Q29uZmlnKHRoaXMsIGNvbmZpZyk7XG4gICAgdGhpcy5fZCA9IG5ldyBEYXRlKGNvbmZpZy5fZCAhPSBudWxsID8gY29uZmlnLl9kLmdldFRpbWUoKSA6IE5hTik7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICB0aGlzLl9kID0gbmV3IERhdGUoTmFOKTtcbiAgICB9XG4gICAgLy8gUHJldmVudCBpbmZpbml0ZSBsb29wIGluIGNhc2UgdXBkYXRlT2Zmc2V0IGNyZWF0ZXMgbmV3IG1vbWVudFxuICAgIC8vIG9iamVjdHMuXG4gICAgaWYgKHVwZGF0ZUluUHJvZ3Jlc3MgPT09IGZhbHNlKSB7XG4gICAgICAgIHVwZGF0ZUluUHJvZ3Jlc3MgPSB0cnVlO1xuICAgICAgICBob29rcy51cGRhdGVPZmZzZXQodGhpcyk7XG4gICAgICAgIHVwZGF0ZUluUHJvZ3Jlc3MgPSBmYWxzZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGlzTW9tZW50IChvYmopIHtcbiAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgTW9tZW50IHx8IChvYmogIT0gbnVsbCAmJiBvYmouX2lzQU1vbWVudE9iamVjdCAhPSBudWxsKTtcbn1cblxuZnVuY3Rpb24gYWJzRmxvb3IgKG51bWJlcikge1xuICAgIGlmIChudW1iZXIgPCAwKSB7XG4gICAgICAgIC8vIC0wIC0+IDBcbiAgICAgICAgcmV0dXJuIE1hdGguY2VpbChudW1iZXIpIHx8IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IobnVtYmVyKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHRvSW50KGFyZ3VtZW50Rm9yQ29lcmNpb24pIHtcbiAgICB2YXIgY29lcmNlZE51bWJlciA9ICthcmd1bWVudEZvckNvZXJjaW9uLFxuICAgICAgICB2YWx1ZSA9IDA7XG5cbiAgICBpZiAoY29lcmNlZE51bWJlciAhPT0gMCAmJiBpc0Zpbml0ZShjb2VyY2VkTnVtYmVyKSkge1xuICAgICAgICB2YWx1ZSA9IGFic0Zsb29yKGNvZXJjZWROdW1iZXIpO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbn1cblxuLy8gY29tcGFyZSB0d28gYXJyYXlzLCByZXR1cm4gdGhlIG51bWJlciBvZiBkaWZmZXJlbmNlc1xuZnVuY3Rpb24gY29tcGFyZUFycmF5cyhhcnJheTEsIGFycmF5MiwgZG9udENvbnZlcnQpIHtcbiAgICB2YXIgbGVuID0gTWF0aC5taW4oYXJyYXkxLmxlbmd0aCwgYXJyYXkyLmxlbmd0aCksXG4gICAgICAgIGxlbmd0aERpZmYgPSBNYXRoLmFicyhhcnJheTEubGVuZ3RoIC0gYXJyYXkyLmxlbmd0aCksXG4gICAgICAgIGRpZmZzID0gMCxcbiAgICAgICAgaTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKChkb250Q29udmVydCAmJiBhcnJheTFbaV0gIT09IGFycmF5MltpXSkgfHxcbiAgICAgICAgICAgICghZG9udENvbnZlcnQgJiYgdG9JbnQoYXJyYXkxW2ldKSAhPT0gdG9JbnQoYXJyYXkyW2ldKSkpIHtcbiAgICAgICAgICAgIGRpZmZzKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRpZmZzICsgbGVuZ3RoRGlmZjtcbn1cblxuZnVuY3Rpb24gd2Fybihtc2cpIHtcbiAgICBpZiAoaG9va3Muc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmdzID09PSBmYWxzZSAmJlxuICAgICAgICAgICAgKHR5cGVvZiBjb25zb2xlICE9PSAgJ3VuZGVmaW5lZCcpICYmIGNvbnNvbGUud2Fybikge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0RlcHJlY2F0aW9uIHdhcm5pbmc6ICcgKyBtc2cpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZGVwcmVjYXRlKG1zZywgZm4pIHtcbiAgICB2YXIgZmlyc3RUaW1lID0gdHJ1ZTtcblxuICAgIHJldHVybiBleHRlbmQoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaG9va3MuZGVwcmVjYXRpb25IYW5kbGVyICE9IG51bGwpIHtcbiAgICAgICAgICAgIGhvb2tzLmRlcHJlY2F0aW9uSGFuZGxlcihudWxsLCBtc2cpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaXJzdFRpbWUpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgICAgICB2YXIgYXJnO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBhcmcgPSAnJztcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1tpXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgYXJnICs9ICdcXG5bJyArIGkgKyAnXSAnO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gYXJndW1lbnRzWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmcgKz0ga2V5ICsgJzogJyArIGFyZ3VtZW50c1swXVtrZXldICsgJywgJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhcmcgPSBhcmcuc2xpY2UoMCwgLTIpOyAvLyBSZW1vdmUgdHJhaWxpbmcgY29tbWEgYW5kIHNwYWNlXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYXJnID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhcmdzLnB1c2goYXJnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdhcm4obXNnICsgJ1xcbkFyZ3VtZW50czogJyArIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MpLmpvaW4oJycpICsgJ1xcbicgKyAobmV3IEVycm9yKCkpLnN0YWNrKTtcbiAgICAgICAgICAgIGZpcnN0VGltZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sIGZuKTtcbn1cblxudmFyIGRlcHJlY2F0aW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBkZXByZWNhdGVTaW1wbGUobmFtZSwgbXNnKSB7XG4gICAgaWYgKGhvb2tzLmRlcHJlY2F0aW9uSGFuZGxlciAhPSBudWxsKSB7XG4gICAgICAgIGhvb2tzLmRlcHJlY2F0aW9uSGFuZGxlcihuYW1lLCBtc2cpO1xuICAgIH1cbiAgICBpZiAoIWRlcHJlY2F0aW9uc1tuYW1lXSkge1xuICAgICAgICB3YXJuKG1zZyk7XG4gICAgICAgIGRlcHJlY2F0aW9uc1tuYW1lXSA9IHRydWU7XG4gICAgfVxufVxuXG5ob29rcy5zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZ3MgPSBmYWxzZTtcbmhvb2tzLmRlcHJlY2F0aW9uSGFuZGxlciA9IG51bGw7XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oaW5wdXQpIHtcbiAgICByZXR1cm4gaW5wdXQgaW5zdGFuY2VvZiBGdW5jdGlvbiB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xufVxuXG5mdW5jdGlvbiBzZXQgKGNvbmZpZykge1xuICAgIHZhciBwcm9wLCBpO1xuICAgIGZvciAoaSBpbiBjb25maWcpIHtcbiAgICAgICAgcHJvcCA9IGNvbmZpZ1tpXTtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24ocHJvcCkpIHtcbiAgICAgICAgICAgIHRoaXNbaV0gPSBwcm9wO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpc1snXycgKyBpXSA9IHByb3A7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fY29uZmlnID0gY29uZmlnO1xuICAgIC8vIExlbmllbnQgb3JkaW5hbCBwYXJzaW5nIGFjY2VwdHMganVzdCBhIG51bWJlciBpbiBhZGRpdGlvbiB0b1xuICAgIC8vIG51bWJlciArIChwb3NzaWJseSkgc3R1ZmYgY29taW5nIGZyb20gX2RheU9mTW9udGhPcmRpbmFsUGFyc2UuXG4gICAgLy8gVE9ETzogUmVtb3ZlIFwib3JkaW5hbFBhcnNlXCIgZmFsbGJhY2sgaW4gbmV4dCBtYWpvciByZWxlYXNlLlxuICAgIHRoaXMuX2RheU9mTW9udGhPcmRpbmFsUGFyc2VMZW5pZW50ID0gbmV3IFJlZ0V4cChcbiAgICAgICAgKHRoaXMuX2RheU9mTW9udGhPcmRpbmFsUGFyc2Uuc291cmNlIHx8IHRoaXMuX29yZGluYWxQYXJzZS5zb3VyY2UpICtcbiAgICAgICAgICAgICd8JyArICgvXFxkezEsMn0vKS5zb3VyY2UpO1xufVxuXG5mdW5jdGlvbiBtZXJnZUNvbmZpZ3MocGFyZW50Q29uZmlnLCBjaGlsZENvbmZpZykge1xuICAgIHZhciByZXMgPSBleHRlbmQoe30sIHBhcmVudENvbmZpZyksIHByb3A7XG4gICAgZm9yIChwcm9wIGluIGNoaWxkQ29uZmlnKSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wKGNoaWxkQ29uZmlnLCBwcm9wKSkge1xuICAgICAgICAgICAgaWYgKGlzT2JqZWN0KHBhcmVudENvbmZpZ1twcm9wXSkgJiYgaXNPYmplY3QoY2hpbGRDb25maWdbcHJvcF0pKSB7XG4gICAgICAgICAgICAgICAgcmVzW3Byb3BdID0ge307XG4gICAgICAgICAgICAgICAgZXh0ZW5kKHJlc1twcm9wXSwgcGFyZW50Q29uZmlnW3Byb3BdKTtcbiAgICAgICAgICAgICAgICBleHRlbmQocmVzW3Byb3BdLCBjaGlsZENvbmZpZ1twcm9wXSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNoaWxkQ29uZmlnW3Byb3BdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXNbcHJvcF0gPSBjaGlsZENvbmZpZ1twcm9wXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHJlc1twcm9wXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKHByb3AgaW4gcGFyZW50Q29uZmlnKSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wKHBhcmVudENvbmZpZywgcHJvcCkgJiZcbiAgICAgICAgICAgICAgICAhaGFzT3duUHJvcChjaGlsZENvbmZpZywgcHJvcCkgJiZcbiAgICAgICAgICAgICAgICBpc09iamVjdChwYXJlbnRDb25maWdbcHJvcF0pKSB7XG4gICAgICAgICAgICAvLyBtYWtlIHN1cmUgY2hhbmdlcyB0byBwcm9wZXJ0aWVzIGRvbid0IG1vZGlmeSBwYXJlbnQgY29uZmlnXG4gICAgICAgICAgICByZXNbcHJvcF0gPSBleHRlbmQoe30sIHJlc1twcm9wXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cblxuZnVuY3Rpb24gTG9jYWxlKGNvbmZpZykge1xuICAgIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgICAgICB0aGlzLnNldChjb25maWcpO1xuICAgIH1cbn1cblxudmFyIGtleXM7XG5cbmlmIChPYmplY3Qua2V5cykge1xuICAgIGtleXMgPSBPYmplY3Qua2V5cztcbn0gZWxzZSB7XG4gICAga2V5cyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgdmFyIGksIHJlcyA9IFtdO1xuICAgICAgICBmb3IgKGkgaW4gb2JqKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcChvYmosIGkpKSB7XG4gICAgICAgICAgICAgICAgcmVzLnB1c2goaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xufVxuXG52YXIgZGVmYXVsdENhbGVuZGFyID0ge1xuICAgIHNhbWVEYXkgOiAnW1RvZGF5IGF0XSBMVCcsXG4gICAgbmV4dERheSA6ICdbVG9tb3Jyb3cgYXRdIExUJyxcbiAgICBuZXh0V2VlayA6ICdkZGRkIFthdF0gTFQnLFxuICAgIGxhc3REYXkgOiAnW1llc3RlcmRheSBhdF0gTFQnLFxuICAgIGxhc3RXZWVrIDogJ1tMYXN0XSBkZGRkIFthdF0gTFQnLFxuICAgIHNhbWVFbHNlIDogJ0wnXG59O1xuXG5mdW5jdGlvbiBjYWxlbmRhciAoa2V5LCBtb20sIG5vdykge1xuICAgIHZhciBvdXRwdXQgPSB0aGlzLl9jYWxlbmRhcltrZXldIHx8IHRoaXMuX2NhbGVuZGFyWydzYW1lRWxzZSddO1xuICAgIHJldHVybiBpc0Z1bmN0aW9uKG91dHB1dCkgPyBvdXRwdXQuY2FsbChtb20sIG5vdykgOiBvdXRwdXQ7XG59XG5cbnZhciBkZWZhdWx0TG9uZ0RhdGVGb3JtYXQgPSB7XG4gICAgTFRTICA6ICdoOm1tOnNzIEEnLFxuICAgIExUICAgOiAnaDptbSBBJyxcbiAgICBMICAgIDogJ01NL0REL1lZWVknLFxuICAgIExMICAgOiAnTU1NTSBELCBZWVlZJyxcbiAgICBMTEwgIDogJ01NTU0gRCwgWVlZWSBoOm1tIEEnLFxuICAgIExMTEwgOiAnZGRkZCwgTU1NTSBELCBZWVlZIGg6bW0gQSdcbn07XG5cbmZ1bmN0aW9uIGxvbmdEYXRlRm9ybWF0IChrZXkpIHtcbiAgICB2YXIgZm9ybWF0ID0gdGhpcy5fbG9uZ0RhdGVGb3JtYXRba2V5XSxcbiAgICAgICAgZm9ybWF0VXBwZXIgPSB0aGlzLl9sb25nRGF0ZUZvcm1hdFtrZXkudG9VcHBlckNhc2UoKV07XG5cbiAgICBpZiAoZm9ybWF0IHx8ICFmb3JtYXRVcHBlcikge1xuICAgICAgICByZXR1cm4gZm9ybWF0O1xuICAgIH1cblxuICAgIHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleV0gPSBmb3JtYXRVcHBlci5yZXBsYWNlKC9NTU1NfE1NfEREfGRkZGQvZywgZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICByZXR1cm4gdmFsLnNsaWNlKDEpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleV07XG59XG5cbnZhciBkZWZhdWx0SW52YWxpZERhdGUgPSAnSW52YWxpZCBkYXRlJztcblxuZnVuY3Rpb24gaW52YWxpZERhdGUgKCkge1xuICAgIHJldHVybiB0aGlzLl9pbnZhbGlkRGF0ZTtcbn1cblxudmFyIGRlZmF1bHRPcmRpbmFsID0gJyVkJztcbnZhciBkZWZhdWx0RGF5T2ZNb250aE9yZGluYWxQYXJzZSA9IC9cXGR7MSwyfS87XG5cbmZ1bmN0aW9uIG9yZGluYWwgKG51bWJlcikge1xuICAgIHJldHVybiB0aGlzLl9vcmRpbmFsLnJlcGxhY2UoJyVkJywgbnVtYmVyKTtcbn1cblxudmFyIGRlZmF1bHRSZWxhdGl2ZVRpbWUgPSB7XG4gICAgZnV0dXJlIDogJ2luICVzJyxcbiAgICBwYXN0ICAgOiAnJXMgYWdvJyxcbiAgICBzICA6ICdhIGZldyBzZWNvbmRzJyxcbiAgICBzcyA6ICclZCBzZWNvbmRzJyxcbiAgICBtICA6ICdhIG1pbnV0ZScsXG4gICAgbW0gOiAnJWQgbWludXRlcycsXG4gICAgaCAgOiAnYW4gaG91cicsXG4gICAgaGggOiAnJWQgaG91cnMnLFxuICAgIGQgIDogJ2EgZGF5JyxcbiAgICBkZCA6ICclZCBkYXlzJyxcbiAgICBNICA6ICdhIG1vbnRoJyxcbiAgICBNTSA6ICclZCBtb250aHMnLFxuICAgIHkgIDogJ2EgeWVhcicsXG4gICAgeXkgOiAnJWQgeWVhcnMnXG59O1xuXG5mdW5jdGlvbiByZWxhdGl2ZVRpbWUgKG51bWJlciwgd2l0aG91dFN1ZmZpeCwgc3RyaW5nLCBpc0Z1dHVyZSkge1xuICAgIHZhciBvdXRwdXQgPSB0aGlzLl9yZWxhdGl2ZVRpbWVbc3RyaW5nXTtcbiAgICByZXR1cm4gKGlzRnVuY3Rpb24ob3V0cHV0KSkgP1xuICAgICAgICBvdXRwdXQobnVtYmVyLCB3aXRob3V0U3VmZml4LCBzdHJpbmcsIGlzRnV0dXJlKSA6XG4gICAgICAgIG91dHB1dC5yZXBsYWNlKC8lZC9pLCBudW1iZXIpO1xufVxuXG5mdW5jdGlvbiBwYXN0RnV0dXJlIChkaWZmLCBvdXRwdXQpIHtcbiAgICB2YXIgZm9ybWF0ID0gdGhpcy5fcmVsYXRpdmVUaW1lW2RpZmYgPiAwID8gJ2Z1dHVyZScgOiAncGFzdCddO1xuICAgIHJldHVybiBpc0Z1bmN0aW9uKGZvcm1hdCkgPyBmb3JtYXQob3V0cHV0KSA6IGZvcm1hdC5yZXBsYWNlKC8lcy9pLCBvdXRwdXQpO1xufVxuXG52YXIgYWxpYXNlcyA9IHt9O1xuXG5mdW5jdGlvbiBhZGRVbml0QWxpYXMgKHVuaXQsIHNob3J0aGFuZCkge1xuICAgIHZhciBsb3dlckNhc2UgPSB1bml0LnRvTG93ZXJDYXNlKCk7XG4gICAgYWxpYXNlc1tsb3dlckNhc2VdID0gYWxpYXNlc1tsb3dlckNhc2UgKyAncyddID0gYWxpYXNlc1tzaG9ydGhhbmRdID0gdW5pdDtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplVW5pdHModW5pdHMpIHtcbiAgICByZXR1cm4gdHlwZW9mIHVuaXRzID09PSAnc3RyaW5nJyA/IGFsaWFzZXNbdW5pdHNdIHx8IGFsaWFzZXNbdW5pdHMudG9Mb3dlckNhc2UoKV0gOiB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZU9iamVjdFVuaXRzKGlucHV0T2JqZWN0KSB7XG4gICAgdmFyIG5vcm1hbGl6ZWRJbnB1dCA9IHt9LFxuICAgICAgICBub3JtYWxpemVkUHJvcCxcbiAgICAgICAgcHJvcDtcblxuICAgIGZvciAocHJvcCBpbiBpbnB1dE9iamVjdCkge1xuICAgICAgICBpZiAoaGFzT3duUHJvcChpbnB1dE9iamVjdCwgcHJvcCkpIHtcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRQcm9wID0gbm9ybWFsaXplVW5pdHMocHJvcCk7XG4gICAgICAgICAgICBpZiAobm9ybWFsaXplZFByb3ApIHtcbiAgICAgICAgICAgICAgICBub3JtYWxpemVkSW5wdXRbbm9ybWFsaXplZFByb3BdID0gaW5wdXRPYmplY3RbcHJvcF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbm9ybWFsaXplZElucHV0O1xufVxuXG52YXIgcHJpb3JpdGllcyA9IHt9O1xuXG5mdW5jdGlvbiBhZGRVbml0UHJpb3JpdHkodW5pdCwgcHJpb3JpdHkpIHtcbiAgICBwcmlvcml0aWVzW3VuaXRdID0gcHJpb3JpdHk7XG59XG5cbmZ1bmN0aW9uIGdldFByaW9yaXRpemVkVW5pdHModW5pdHNPYmopIHtcbiAgICB2YXIgdW5pdHMgPSBbXTtcbiAgICBmb3IgKHZhciB1IGluIHVuaXRzT2JqKSB7XG4gICAgICAgIHVuaXRzLnB1c2goe3VuaXQ6IHUsIHByaW9yaXR5OiBwcmlvcml0aWVzW3VdfSk7XG4gICAgfVxuICAgIHVuaXRzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEucHJpb3JpdHkgLSBiLnByaW9yaXR5O1xuICAgIH0pO1xuICAgIHJldHVybiB1bml0cztcbn1cblxuZnVuY3Rpb24gemVyb0ZpbGwobnVtYmVyLCB0YXJnZXRMZW5ndGgsIGZvcmNlU2lnbikge1xuICAgIHZhciBhYnNOdW1iZXIgPSAnJyArIE1hdGguYWJzKG51bWJlciksXG4gICAgICAgIHplcm9zVG9GaWxsID0gdGFyZ2V0TGVuZ3RoIC0gYWJzTnVtYmVyLmxlbmd0aCxcbiAgICAgICAgc2lnbiA9IG51bWJlciA+PSAwO1xuICAgIHJldHVybiAoc2lnbiA/IChmb3JjZVNpZ24gPyAnKycgOiAnJykgOiAnLScpICtcbiAgICAgICAgTWF0aC5wb3coMTAsIE1hdGgubWF4KDAsIHplcm9zVG9GaWxsKSkudG9TdHJpbmcoKS5zdWJzdHIoMSkgKyBhYnNOdW1iZXI7XG59XG5cbnZhciBmb3JtYXR0aW5nVG9rZW5zID0gLyhcXFtbXlxcW10qXFxdKXwoXFxcXCk/KFtIaF1tbShzcyk/fE1vfE1NP00/TT98RG98REREb3xERD9EP0Q/fGRkZD9kP3xkbz98d1tvfHddP3xXW298V10/fFFvP3xZWVlZWVl8WVlZWVl8WVlZWXxZWXxnZyhnZ2c/KT98R0coR0dHPyk/fGV8RXxhfEF8aGg/fEhIP3xraz98bW0/fHNzP3xTezEsOX18eHxYfHp6P3xaWj98LikvZztcblxudmFyIGxvY2FsRm9ybWF0dGluZ1Rva2VucyA9IC8oXFxbW15cXFtdKlxcXSl8KFxcXFwpPyhMVFN8TFR8TEw/TD9MP3xsezEsNH0pL2c7XG5cbnZhciBmb3JtYXRGdW5jdGlvbnMgPSB7fTtcblxudmFyIGZvcm1hdFRva2VuRnVuY3Rpb25zID0ge307XG5cbi8vIHRva2VuOiAgICAnTSdcbi8vIHBhZGRlZDogICBbJ01NJywgMl1cbi8vIG9yZGluYWw6ICAnTW8nXG4vLyBjYWxsYmFjazogZnVuY3Rpb24gKCkgeyB0aGlzLm1vbnRoKCkgKyAxIH1cbmZ1bmN0aW9uIGFkZEZvcm1hdFRva2VuICh0b2tlbiwgcGFkZGVkLCBvcmRpbmFsLCBjYWxsYmFjaykge1xuICAgIHZhciBmdW5jID0gY2FsbGJhY2s7XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzW2NhbGxiYWNrXSgpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgZm9ybWF0VG9rZW5GdW5jdGlvbnNbdG9rZW5dID0gZnVuYztcbiAgICB9XG4gICAgaWYgKHBhZGRlZCkge1xuICAgICAgICBmb3JtYXRUb2tlbkZ1bmN0aW9uc1twYWRkZWRbMF1dID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHplcm9GaWxsKGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgcGFkZGVkWzFdLCBwYWRkZWRbMl0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAob3JkaW5hbCkge1xuICAgICAgICBmb3JtYXRUb2tlbkZ1bmN0aW9uc1tvcmRpbmFsXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5vcmRpbmFsKGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgdG9rZW4pO1xuICAgICAgICB9O1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlRm9ybWF0dGluZ1Rva2VucyhpbnB1dCkge1xuICAgIGlmIChpbnB1dC5tYXRjaCgvXFxbW1xcc1xcU10vKSkge1xuICAgICAgICByZXR1cm4gaW5wdXQucmVwbGFjZSgvXlxcW3xcXF0kL2csICcnKTtcbiAgICB9XG4gICAgcmV0dXJuIGlucHV0LnJlcGxhY2UoL1xcXFwvZywgJycpO1xufVxuXG5mdW5jdGlvbiBtYWtlRm9ybWF0RnVuY3Rpb24oZm9ybWF0KSB7XG4gICAgdmFyIGFycmF5ID0gZm9ybWF0Lm1hdGNoKGZvcm1hdHRpbmdUb2tlbnMpLCBpLCBsZW5ndGg7XG5cbiAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBhcnJheS5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoZm9ybWF0VG9rZW5GdW5jdGlvbnNbYXJyYXlbaV1dKSB7XG4gICAgICAgICAgICBhcnJheVtpXSA9IGZvcm1hdFRva2VuRnVuY3Rpb25zW2FycmF5W2ldXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFycmF5W2ldID0gcmVtb3ZlRm9ybWF0dGluZ1Rva2VucyhhcnJheVtpXSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKG1vbSkge1xuICAgICAgICB2YXIgb3V0cHV0ID0gJycsIGk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgb3V0cHV0ICs9IGlzRnVuY3Rpb24oYXJyYXlbaV0pID8gYXJyYXlbaV0uY2FsbChtb20sIGZvcm1hdCkgOiBhcnJheVtpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH07XG59XG5cbi8vIGZvcm1hdCBkYXRlIHVzaW5nIG5hdGl2ZSBkYXRlIG9iamVjdFxuZnVuY3Rpb24gZm9ybWF0TW9tZW50KG0sIGZvcm1hdCkge1xuICAgIGlmICghbS5pc1ZhbGlkKCkpIHtcbiAgICAgICAgcmV0dXJuIG0ubG9jYWxlRGF0YSgpLmludmFsaWREYXRlKCk7XG4gICAgfVxuXG4gICAgZm9ybWF0ID0gZXhwYW5kRm9ybWF0KGZvcm1hdCwgbS5sb2NhbGVEYXRhKCkpO1xuICAgIGZvcm1hdEZ1bmN0aW9uc1tmb3JtYXRdID0gZm9ybWF0RnVuY3Rpb25zW2Zvcm1hdF0gfHwgbWFrZUZvcm1hdEZ1bmN0aW9uKGZvcm1hdCk7XG5cbiAgICByZXR1cm4gZm9ybWF0RnVuY3Rpb25zW2Zvcm1hdF0obSk7XG59XG5cbmZ1bmN0aW9uIGV4cGFuZEZvcm1hdChmb3JtYXQsIGxvY2FsZSkge1xuICAgIHZhciBpID0gNTtcblxuICAgIGZ1bmN0aW9uIHJlcGxhY2VMb25nRGF0ZUZvcm1hdFRva2VucyhpbnB1dCkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLmxvbmdEYXRlRm9ybWF0KGlucHV0KSB8fCBpbnB1dDtcbiAgICB9XG5cbiAgICBsb2NhbEZvcm1hdHRpbmdUb2tlbnMubGFzdEluZGV4ID0gMDtcbiAgICB3aGlsZSAoaSA+PSAwICYmIGxvY2FsRm9ybWF0dGluZ1Rva2Vucy50ZXN0KGZvcm1hdCkpIHtcbiAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UobG9jYWxGb3JtYXR0aW5nVG9rZW5zLCByZXBsYWNlTG9uZ0RhdGVGb3JtYXRUb2tlbnMpO1xuICAgICAgICBsb2NhbEZvcm1hdHRpbmdUb2tlbnMubGFzdEluZGV4ID0gMDtcbiAgICAgICAgaSAtPSAxO1xuICAgIH1cblxuICAgIHJldHVybiBmb3JtYXQ7XG59XG5cbnZhciBtYXRjaDEgICAgICAgICA9IC9cXGQvOyAgICAgICAgICAgIC8vICAgICAgIDAgLSA5XG52YXIgbWF0Y2gyICAgICAgICAgPSAvXFxkXFxkLzsgICAgICAgICAgLy8gICAgICAwMCAtIDk5XG52YXIgbWF0Y2gzICAgICAgICAgPSAvXFxkezN9LzsgICAgICAgICAvLyAgICAgMDAwIC0gOTk5XG52YXIgbWF0Y2g0ICAgICAgICAgPSAvXFxkezR9LzsgICAgICAgICAvLyAgICAwMDAwIC0gOTk5OVxudmFyIG1hdGNoNiAgICAgICAgID0gL1srLV0/XFxkezZ9LzsgICAgLy8gLTk5OTk5OSAtIDk5OTk5OVxudmFyIG1hdGNoMXRvMiAgICAgID0gL1xcZFxcZD8vOyAgICAgICAgIC8vICAgICAgIDAgLSA5OVxudmFyIG1hdGNoM3RvNCAgICAgID0gL1xcZFxcZFxcZFxcZD8vOyAgICAgLy8gICAgIDk5OSAtIDk5OTlcbnZhciBtYXRjaDV0bzYgICAgICA9IC9cXGRcXGRcXGRcXGRcXGRcXGQ/LzsgLy8gICA5OTk5OSAtIDk5OTk5OVxudmFyIG1hdGNoMXRvMyAgICAgID0gL1xcZHsxLDN9LzsgICAgICAgLy8gICAgICAgMCAtIDk5OVxudmFyIG1hdGNoMXRvNCAgICAgID0gL1xcZHsxLDR9LzsgICAgICAgLy8gICAgICAgMCAtIDk5OTlcbnZhciBtYXRjaDF0bzYgICAgICA9IC9bKy1dP1xcZHsxLDZ9LzsgIC8vIC05OTk5OTkgLSA5OTk5OTlcblxudmFyIG1hdGNoVW5zaWduZWQgID0gL1xcZCsvOyAgICAgICAgICAgLy8gICAgICAgMCAtIGluZlxudmFyIG1hdGNoU2lnbmVkICAgID0gL1srLV0/XFxkKy87ICAgICAgLy8gICAgLWluZiAtIGluZlxuXG52YXIgbWF0Y2hPZmZzZXQgICAgPSAvWnxbKy1dXFxkXFxkOj9cXGRcXGQvZ2k7IC8vICswMDowMCAtMDA6MDAgKzAwMDAgLTAwMDAgb3IgWlxudmFyIG1hdGNoU2hvcnRPZmZzZXQgPSAvWnxbKy1dXFxkXFxkKD86Oj9cXGRcXGQpPy9naTsgLy8gKzAwIC0wMCArMDA6MDAgLTAwOjAwICswMDAwIC0wMDAwIG9yIFpcblxudmFyIG1hdGNoVGltZXN0YW1wID0gL1srLV0/XFxkKyhcXC5cXGR7MSwzfSk/LzsgLy8gMTIzNDU2Nzg5IDEyMzQ1Njc4OS4xMjNcblxuLy8gYW55IHdvcmQgKG9yIHR3bykgY2hhcmFjdGVycyBvciBudW1iZXJzIGluY2x1ZGluZyB0d28vdGhyZWUgd29yZCBtb250aCBpbiBhcmFiaWMuXG4vLyBpbmNsdWRlcyBzY290dGlzaCBnYWVsaWMgdHdvIHdvcmQgYW5kIGh5cGhlbmF0ZWQgbW9udGhzXG52YXIgbWF0Y2hXb3JkID0gL1swLTldezAsMjU2fVsnYS16XFx1MDBBMC1cXHUwNUZGXFx1MDcwMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRjA3XFx1RkYxMC1cXHVGRkVGXXsxLDI1Nn18W1xcdTA2MDAtXFx1MDZGRlxcL117MSwyNTZ9KFxccyo/W1xcdTA2MDAtXFx1MDZGRl17MSwyNTZ9KXsxLDJ9L2k7XG5cblxudmFyIHJlZ2V4ZXMgPSB7fTtcblxuZnVuY3Rpb24gYWRkUmVnZXhUb2tlbiAodG9rZW4sIHJlZ2V4LCBzdHJpY3RSZWdleCkge1xuICAgIHJlZ2V4ZXNbdG9rZW5dID0gaXNGdW5jdGlvbihyZWdleCkgPyByZWdleCA6IGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlRGF0YSkge1xuICAgICAgICByZXR1cm4gKGlzU3RyaWN0ICYmIHN0cmljdFJlZ2V4KSA/IHN0cmljdFJlZ2V4IDogcmVnZXg7XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0UGFyc2VSZWdleEZvclRva2VuICh0b2tlbiwgY29uZmlnKSB7XG4gICAgaWYgKCFoYXNPd25Qcm9wKHJlZ2V4ZXMsIHRva2VuKSkge1xuICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cCh1bmVzY2FwZUZvcm1hdCh0b2tlbikpO1xuICAgIH1cblxuICAgIHJldHVybiByZWdleGVzW3Rva2VuXShjb25maWcuX3N0cmljdCwgY29uZmlnLl9sb2NhbGUpO1xufVxuXG4vLyBDb2RlIGZyb20gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8zNTYxNDkzL2lzLXRoZXJlLWEtcmVnZXhwLWVzY2FwZS1mdW5jdGlvbi1pbi1qYXZhc2NyaXB0XG5mdW5jdGlvbiB1bmVzY2FwZUZvcm1hdChzKSB7XG4gICAgcmV0dXJuIHJlZ2V4RXNjYXBlKHMucmVwbGFjZSgnXFxcXCcsICcnKS5yZXBsYWNlKC9cXFxcKFxcWyl8XFxcXChcXF0pfFxcWyhbXlxcXVxcW10qKVxcXXxcXFxcKC4pL2csIGZ1bmN0aW9uIChtYXRjaGVkLCBwMSwgcDIsIHAzLCBwNCkge1xuICAgICAgICByZXR1cm4gcDEgfHwgcDIgfHwgcDMgfHwgcDQ7XG4gICAgfSkpO1xufVxuXG5mdW5jdGlvbiByZWdleEVzY2FwZShzKSB7XG4gICAgcmV0dXJuIHMucmVwbGFjZSgvWy1cXC9cXFxcXiQqKz8uKCl8W1xcXXt9XS9nLCAnXFxcXCQmJyk7XG59XG5cbnZhciB0b2tlbnMgPSB7fTtcblxuZnVuY3Rpb24gYWRkUGFyc2VUb2tlbiAodG9rZW4sIGNhbGxiYWNrKSB7XG4gICAgdmFyIGksIGZ1bmMgPSBjYWxsYmFjaztcbiAgICBpZiAodHlwZW9mIHRva2VuID09PSAnc3RyaW5nJykge1xuICAgICAgICB0b2tlbiA9IFt0b2tlbl07XG4gICAgfVxuICAgIGlmIChpc051bWJlcihjYWxsYmFjaykpIHtcbiAgICAgICAgZnVuYyA9IGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgICAgIGFycmF5W2NhbGxiYWNrXSA9IHRvSW50KGlucHV0KTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IHRva2VuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRva2Vuc1t0b2tlbltpXV0gPSBmdW5jO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gYWRkV2Vla1BhcnNlVG9rZW4gKHRva2VuLCBjYWxsYmFjaykge1xuICAgIGFkZFBhcnNlVG9rZW4odG9rZW4sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgY29uZmlnLl93ID0gY29uZmlnLl93IHx8IHt9O1xuICAgICAgICBjYWxsYmFjayhpbnB1dCwgY29uZmlnLl93LCBjb25maWcsIHRva2VuKTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gYWRkVGltZVRvQXJyYXlGcm9tVG9rZW4odG9rZW4sIGlucHV0LCBjb25maWcpIHtcbiAgICBpZiAoaW5wdXQgIT0gbnVsbCAmJiBoYXNPd25Qcm9wKHRva2VucywgdG9rZW4pKSB7XG4gICAgICAgIHRva2Vuc1t0b2tlbl0oaW5wdXQsIGNvbmZpZy5fYSwgY29uZmlnLCB0b2tlbik7XG4gICAgfVxufVxuXG52YXIgWUVBUiA9IDA7XG52YXIgTU9OVEggPSAxO1xudmFyIERBVEUgPSAyO1xudmFyIEhPVVIgPSAzO1xudmFyIE1JTlVURSA9IDQ7XG52YXIgU0VDT05EID0gNTtcbnZhciBNSUxMSVNFQ09ORCA9IDY7XG52YXIgV0VFSyA9IDc7XG52YXIgV0VFS0RBWSA9IDg7XG5cbi8vIEZPUk1BVFRJTkdcblxuYWRkRm9ybWF0VG9rZW4oJ1knLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHkgPSB0aGlzLnllYXIoKTtcbiAgICByZXR1cm4geSA8PSA5OTk5ID8gJycgKyB5IDogJysnICsgeTtcbn0pO1xuXG5hZGRGb3JtYXRUb2tlbigwLCBbJ1lZJywgMl0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy55ZWFyKCkgJSAxMDA7XG59KTtcblxuYWRkRm9ybWF0VG9rZW4oMCwgWydZWVlZJywgICA0XSwgICAgICAgMCwgJ3llYXInKTtcbmFkZEZvcm1hdFRva2VuKDAsIFsnWVlZWVknLCAgNV0sICAgICAgIDAsICd5ZWFyJyk7XG5hZGRGb3JtYXRUb2tlbigwLCBbJ1lZWVlZWScsIDYsIHRydWVdLCAwLCAneWVhcicpO1xuXG4vLyBBTElBU0VTXG5cbmFkZFVuaXRBbGlhcygneWVhcicsICd5Jyk7XG5cbi8vIFBSSU9SSVRJRVNcblxuYWRkVW5pdFByaW9yaXR5KCd5ZWFyJywgMSk7XG5cbi8vIFBBUlNJTkdcblxuYWRkUmVnZXhUb2tlbignWScsICAgICAgbWF0Y2hTaWduZWQpO1xuYWRkUmVnZXhUb2tlbignWVknLCAgICAgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuYWRkUmVnZXhUb2tlbignWVlZWScsICAgbWF0Y2gxdG80LCBtYXRjaDQpO1xuYWRkUmVnZXhUb2tlbignWVlZWVknLCAgbWF0Y2gxdG82LCBtYXRjaDYpO1xuYWRkUmVnZXhUb2tlbignWVlZWVlZJywgbWF0Y2gxdG82LCBtYXRjaDYpO1xuXG5hZGRQYXJzZVRva2VuKFsnWVlZWVknLCAnWVlZWVlZJ10sIFlFQVIpO1xuYWRkUGFyc2VUb2tlbignWVlZWScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICBhcnJheVtZRUFSXSA9IGlucHV0Lmxlbmd0aCA9PT0gMiA/IGhvb2tzLnBhcnNlVHdvRGlnaXRZZWFyKGlucHV0KSA6IHRvSW50KGlucHV0KTtcbn0pO1xuYWRkUGFyc2VUb2tlbignWVknLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgYXJyYXlbWUVBUl0gPSBob29rcy5wYXJzZVR3b0RpZ2l0WWVhcihpbnB1dCk7XG59KTtcbmFkZFBhcnNlVG9rZW4oJ1knLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgYXJyYXlbWUVBUl0gPSBwYXJzZUludChpbnB1dCwgMTApO1xufSk7XG5cbi8vIEhFTFBFUlNcblxuZnVuY3Rpb24gZGF5c0luWWVhcih5ZWFyKSB7XG4gICAgcmV0dXJuIGlzTGVhcFllYXIoeWVhcikgPyAzNjYgOiAzNjU7XG59XG5cbmZ1bmN0aW9uIGlzTGVhcFllYXIoeWVhcikge1xuICAgIHJldHVybiAoeWVhciAlIDQgPT09IDAgJiYgeWVhciAlIDEwMCAhPT0gMCkgfHwgeWVhciAlIDQwMCA9PT0gMDtcbn1cblxuLy8gSE9PS1NcblxuaG9va3MucGFyc2VUd29EaWdpdFllYXIgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICByZXR1cm4gdG9JbnQoaW5wdXQpICsgKHRvSW50KGlucHV0KSA+IDY4ID8gMTkwMCA6IDIwMDApO1xufTtcblxuLy8gTU9NRU5UU1xuXG52YXIgZ2V0U2V0WWVhciA9IG1ha2VHZXRTZXQoJ0Z1bGxZZWFyJywgdHJ1ZSk7XG5cbmZ1bmN0aW9uIGdldElzTGVhcFllYXIgKCkge1xuICAgIHJldHVybiBpc0xlYXBZZWFyKHRoaXMueWVhcigpKTtcbn1cblxuZnVuY3Rpb24gbWFrZUdldFNldCAodW5pdCwga2VlcFRpbWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBzZXQkMSh0aGlzLCB1bml0LCB2YWx1ZSk7XG4gICAgICAgICAgICBob29rcy51cGRhdGVPZmZzZXQodGhpcywga2VlcFRpbWUpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0KHRoaXMsIHVuaXQpO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0IChtb20sIHVuaXQpIHtcbiAgICByZXR1cm4gbW9tLmlzVmFsaWQoKSA/XG4gICAgICAgIG1vbS5fZFsnZ2V0JyArIChtb20uX2lzVVRDID8gJ1VUQycgOiAnJykgKyB1bml0XSgpIDogTmFOO1xufVxuXG5mdW5jdGlvbiBzZXQkMSAobW9tLCB1bml0LCB2YWx1ZSkge1xuICAgIGlmIChtb20uaXNWYWxpZCgpICYmICFpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgaWYgKHVuaXQgPT09ICdGdWxsWWVhcicgJiYgaXNMZWFwWWVhcihtb20ueWVhcigpKSAmJiBtb20ubW9udGgoKSA9PT0gMSAmJiBtb20uZGF0ZSgpID09PSAyOSkge1xuICAgICAgICAgICAgbW9tLl9kWydzZXQnICsgKG1vbS5faXNVVEMgPyAnVVRDJyA6ICcnKSArIHVuaXRdKHZhbHVlLCBtb20ubW9udGgoKSwgZGF5c0luTW9udGgodmFsdWUsIG1vbS5tb250aCgpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtb20uX2RbJ3NldCcgKyAobW9tLl9pc1VUQyA/ICdVVEMnIDogJycpICsgdW5pdF0odmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vLyBNT01FTlRTXG5cbmZ1bmN0aW9uIHN0cmluZ0dldCAodW5pdHMpIHtcbiAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICBpZiAoaXNGdW5jdGlvbih0aGlzW3VuaXRzXSkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbdW5pdHNdKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufVxuXG5cbmZ1bmN0aW9uIHN0cmluZ1NldCAodW5pdHMsIHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB1bml0cyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVPYmplY3RVbml0cyh1bml0cyk7XG4gICAgICAgIHZhciBwcmlvcml0aXplZCA9IGdldFByaW9yaXRpemVkVW5pdHModW5pdHMpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByaW9yaXRpemVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzW3ByaW9yaXRpemVkW2ldLnVuaXRdKHVuaXRzW3ByaW9yaXRpemVkW2ldLnVuaXRdKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgICAgICBpZiAoaXNGdW5jdGlvbih0aGlzW3VuaXRzXSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzW3VuaXRzXSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59XG5cbmZ1bmN0aW9uIG1vZChuLCB4KSB7XG4gICAgcmV0dXJuICgobiAlIHgpICsgeCkgJSB4O1xufVxuXG52YXIgaW5kZXhPZjtcblxuaWYgKEFycmF5LnByb3RvdHlwZS5pbmRleE9mKSB7XG4gICAgaW5kZXhPZiA9IEFycmF5LnByb3RvdHlwZS5pbmRleE9mO1xufSBlbHNlIHtcbiAgICBpbmRleE9mID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgLy8gSSBrbm93XG4gICAgICAgIHZhciBpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKHRoaXNbaV0gPT09IG8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gZGF5c0luTW9udGgoeWVhciwgbW9udGgpIHtcbiAgICBpZiAoaXNOYU4oeWVhcikgfHwgaXNOYU4obW9udGgpKSB7XG4gICAgICAgIHJldHVybiBOYU47XG4gICAgfVxuICAgIHZhciBtb2RNb250aCA9IG1vZChtb250aCwgMTIpO1xuICAgIHllYXIgKz0gKG1vbnRoIC0gbW9kTW9udGgpIC8gMTI7XG4gICAgcmV0dXJuIG1vZE1vbnRoID09PSAxID8gKGlzTGVhcFllYXIoeWVhcikgPyAyOSA6IDI4KSA6ICgzMSAtIG1vZE1vbnRoICUgNyAlIDIpO1xufVxuXG4vLyBGT1JNQVRUSU5HXG5cbmFkZEZvcm1hdFRva2VuKCdNJywgWydNTScsIDJdLCAnTW8nLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMubW9udGgoKSArIDE7XG59KTtcblxuYWRkRm9ybWF0VG9rZW4oJ01NTScsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkubW9udGhzU2hvcnQodGhpcywgZm9ybWF0KTtcbn0pO1xuXG5hZGRGb3JtYXRUb2tlbignTU1NTScsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkubW9udGhzKHRoaXMsIGZvcm1hdCk7XG59KTtcblxuLy8gQUxJQVNFU1xuXG5hZGRVbml0QWxpYXMoJ21vbnRoJywgJ00nKTtcblxuLy8gUFJJT1JJVFlcblxuYWRkVW5pdFByaW9yaXR5KCdtb250aCcsIDgpO1xuXG4vLyBQQVJTSU5HXG5cbmFkZFJlZ2V4VG9rZW4oJ00nLCAgICBtYXRjaDF0bzIpO1xuYWRkUmVnZXhUb2tlbignTU0nLCAgIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbmFkZFJlZ2V4VG9rZW4oJ01NTScsICBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgIHJldHVybiBsb2NhbGUubW9udGhzU2hvcnRSZWdleChpc1N0cmljdCk7XG59KTtcbmFkZFJlZ2V4VG9rZW4oJ01NTU0nLCBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgIHJldHVybiBsb2NhbGUubW9udGhzUmVnZXgoaXNTdHJpY3QpO1xufSk7XG5cbmFkZFBhcnNlVG9rZW4oWydNJywgJ01NJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICBhcnJheVtNT05USF0gPSB0b0ludChpbnB1dCkgLSAxO1xufSk7XG5cbmFkZFBhcnNlVG9rZW4oWydNTU0nLCAnTU1NTSddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcsIHRva2VuKSB7XG4gICAgdmFyIG1vbnRoID0gY29uZmlnLl9sb2NhbGUubW9udGhzUGFyc2UoaW5wdXQsIHRva2VuLCBjb25maWcuX3N0cmljdCk7XG4gICAgLy8gaWYgd2UgZGlkbid0IGZpbmQgYSBtb250aCBuYW1lLCBtYXJrIHRoZSBkYXRlIGFzIGludmFsaWQuXG4gICAgaWYgKG1vbnRoICE9IG51bGwpIHtcbiAgICAgICAgYXJyYXlbTU9OVEhdID0gbW9udGg7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuaW52YWxpZE1vbnRoID0gaW5wdXQ7XG4gICAgfVxufSk7XG5cbi8vIExPQ0FMRVNcblxudmFyIE1PTlRIU19JTl9GT1JNQVQgPSAvRFtvRF0/KFxcW1teXFxbXFxdXSpcXF18XFxzKStNTU1NPy87XG52YXIgZGVmYXVsdExvY2FsZU1vbnRocyA9ICdKYW51YXJ5X0ZlYnJ1YXJ5X01hcmNoX0FwcmlsX01heV9KdW5lX0p1bHlfQXVndXN0X1NlcHRlbWJlcl9PY3RvYmVyX05vdmVtYmVyX0RlY2VtYmVyJy5zcGxpdCgnXycpO1xuZnVuY3Rpb24gbG9jYWxlTW9udGhzIChtLCBmb3JtYXQpIHtcbiAgICBpZiAoIW0pIHtcbiAgICAgICAgcmV0dXJuIGlzQXJyYXkodGhpcy5fbW9udGhzKSA/IHRoaXMuX21vbnRocyA6XG4gICAgICAgICAgICB0aGlzLl9tb250aHNbJ3N0YW5kYWxvbmUnXTtcbiAgICB9XG4gICAgcmV0dXJuIGlzQXJyYXkodGhpcy5fbW9udGhzKSA/IHRoaXMuX21vbnRoc1ttLm1vbnRoKCldIDpcbiAgICAgICAgdGhpcy5fbW9udGhzWyh0aGlzLl9tb250aHMuaXNGb3JtYXQgfHwgTU9OVEhTX0lOX0ZPUk1BVCkudGVzdChmb3JtYXQpID8gJ2Zvcm1hdCcgOiAnc3RhbmRhbG9uZSddW20ubW9udGgoKV07XG59XG5cbnZhciBkZWZhdWx0TG9jYWxlTW9udGhzU2hvcnQgPSAnSmFuX0ZlYl9NYXJfQXByX01heV9KdW5fSnVsX0F1Z19TZXBfT2N0X05vdl9EZWMnLnNwbGl0KCdfJyk7XG5mdW5jdGlvbiBsb2NhbGVNb250aHNTaG9ydCAobSwgZm9ybWF0KSB7XG4gICAgaWYgKCFtKSB7XG4gICAgICAgIHJldHVybiBpc0FycmF5KHRoaXMuX21vbnRoc1Nob3J0KSA/IHRoaXMuX21vbnRoc1Nob3J0IDpcbiAgICAgICAgICAgIHRoaXMuX21vbnRoc1Nob3J0WydzdGFuZGFsb25lJ107XG4gICAgfVxuICAgIHJldHVybiBpc0FycmF5KHRoaXMuX21vbnRoc1Nob3J0KSA/IHRoaXMuX21vbnRoc1Nob3J0W20ubW9udGgoKV0gOlxuICAgICAgICB0aGlzLl9tb250aHNTaG9ydFtNT05USFNfSU5fRk9STUFULnRlc3QoZm9ybWF0KSA/ICdmb3JtYXQnIDogJ3N0YW5kYWxvbmUnXVttLm1vbnRoKCldO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVTdHJpY3RQYXJzZShtb250aE5hbWUsIGZvcm1hdCwgc3RyaWN0KSB7XG4gICAgdmFyIGksIGlpLCBtb20sIGxsYyA9IG1vbnRoTmFtZS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgIGlmICghdGhpcy5fbW9udGhzUGFyc2UpIHtcbiAgICAgICAgLy8gdGhpcyBpcyBub3QgdXNlZFxuICAgICAgICB0aGlzLl9tb250aHNQYXJzZSA9IFtdO1xuICAgICAgICB0aGlzLl9sb25nTW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgdGhpcy5fc2hvcnRNb250aHNQYXJzZSA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTI7ICsraSkge1xuICAgICAgICAgICAgbW9tID0gY3JlYXRlVVRDKFsyMDAwLCBpXSk7XG4gICAgICAgICAgICB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlW2ldID0gdGhpcy5tb250aHNTaG9ydChtb20sICcnKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgdGhpcy5fbG9uZ01vbnRoc1BhcnNlW2ldID0gdGhpcy5tb250aHMobW9tLCAnJykudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzdHJpY3QpIHtcbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ01NTScpIHtcbiAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0TW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbG9uZ01vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmb3JtYXQgPT09ICdNTU0nKSB7XG4gICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydE1vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX2xvbmdNb250aHNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9sb25nTW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRNb250aHNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGxvY2FsZU1vbnRoc1BhcnNlIChtb250aE5hbWUsIGZvcm1hdCwgc3RyaWN0KSB7XG4gICAgdmFyIGksIG1vbSwgcmVnZXg7XG5cbiAgICBpZiAodGhpcy5fbW9udGhzUGFyc2VFeGFjdCkge1xuICAgICAgICByZXR1cm4gaGFuZGxlU3RyaWN0UGFyc2UuY2FsbCh0aGlzLCBtb250aE5hbWUsIGZvcm1hdCwgc3RyaWN0KTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX21vbnRoc1BhcnNlKSB7XG4gICAgICAgIHRoaXMuX21vbnRoc1BhcnNlID0gW107XG4gICAgICAgIHRoaXMuX2xvbmdNb250aHNQYXJzZSA9IFtdO1xuICAgICAgICB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlID0gW107XG4gICAgfVxuXG4gICAgLy8gVE9ETzogYWRkIHNvcnRpbmdcbiAgICAvLyBTb3J0aW5nIG1ha2VzIHN1cmUgaWYgb25lIG1vbnRoIChvciBhYmJyKSBpcyBhIHByZWZpeCBvZiBhbm90aGVyXG4gICAgLy8gc2VlIHNvcnRpbmcgaW4gY29tcHV0ZU1vbnRoc1BhcnNlXG4gICAgZm9yIChpID0gMDsgaSA8IDEyOyBpKyspIHtcbiAgICAgICAgLy8gbWFrZSB0aGUgcmVnZXggaWYgd2UgZG9uJ3QgaGF2ZSBpdCBhbHJlYWR5XG4gICAgICAgIG1vbSA9IGNyZWF0ZVVUQyhbMjAwMCwgaV0pO1xuICAgICAgICBpZiAoc3RyaWN0ICYmICF0aGlzLl9sb25nTW9udGhzUGFyc2VbaV0pIHtcbiAgICAgICAgICAgIHRoaXMuX2xvbmdNb250aHNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoJ14nICsgdGhpcy5tb250aHMobW9tLCAnJykucmVwbGFjZSgnLicsICcnKSArICckJywgJ2knKTtcbiAgICAgICAgICAgIHRoaXMuX3Nob3J0TW9udGhzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKCdeJyArIHRoaXMubW9udGhzU2hvcnQobW9tLCAnJykucmVwbGFjZSgnLicsICcnKSArICckJywgJ2knKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXN0cmljdCAmJiAhdGhpcy5fbW9udGhzUGFyc2VbaV0pIHtcbiAgICAgICAgICAgIHJlZ2V4ID0gJ14nICsgdGhpcy5tb250aHMobW9tLCAnJykgKyAnfF4nICsgdGhpcy5tb250aHNTaG9ydChtb20sICcnKTtcbiAgICAgICAgICAgIHRoaXMuX21vbnRoc1BhcnNlW2ldID0gbmV3IFJlZ0V4cChyZWdleC5yZXBsYWNlKCcuJywgJycpLCAnaScpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRlc3QgdGhlIHJlZ2V4XG4gICAgICAgIGlmIChzdHJpY3QgJiYgZm9ybWF0ID09PSAnTU1NTScgJiYgdGhpcy5fbG9uZ01vbnRoc1BhcnNlW2ldLnRlc3QobW9udGhOYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RyaWN0ICYmIGZvcm1hdCA9PT0gJ01NTScgJiYgdGhpcy5fc2hvcnRNb250aHNQYXJzZVtpXS50ZXN0KG1vbnRoTmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9IGVsc2UgaWYgKCFzdHJpY3QgJiYgdGhpcy5fbW9udGhzUGFyc2VbaV0udGVzdChtb250aE5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLy8gTU9NRU5UU1xuXG5mdW5jdGlvbiBzZXRNb250aCAobW9tLCB2YWx1ZSkge1xuICAgIHZhciBkYXlPZk1vbnRoO1xuXG4gICAgaWYgKCFtb20uaXNWYWxpZCgpKSB7XG4gICAgICAgIC8vIE5vIG9wXG4gICAgICAgIHJldHVybiBtb207XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKC9eXFxkKyQvLnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHRvSW50KHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlID0gbW9tLmxvY2FsZURhdGEoKS5tb250aHNQYXJzZSh2YWx1ZSk7XG4gICAgICAgICAgICAvLyBUT0RPOiBBbm90aGVyIHNpbGVudCBmYWlsdXJlP1xuICAgICAgICAgICAgaWYgKCFpc051bWJlcih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbW9tO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZGF5T2ZNb250aCA9IE1hdGgubWluKG1vbS5kYXRlKCksIGRheXNJbk1vbnRoKG1vbS55ZWFyKCksIHZhbHVlKSk7XG4gICAgbW9tLl9kWydzZXQnICsgKG1vbS5faXNVVEMgPyAnVVRDJyA6ICcnKSArICdNb250aCddKHZhbHVlLCBkYXlPZk1vbnRoKTtcbiAgICByZXR1cm4gbW9tO1xufVxuXG5mdW5jdGlvbiBnZXRTZXRNb250aCAodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRNb250aCh0aGlzLCB2YWx1ZSk7XG4gICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldCh0aGlzLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGdldCh0aGlzLCAnTW9udGgnKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGdldERheXNJbk1vbnRoICgpIHtcbiAgICByZXR1cm4gZGF5c0luTW9udGgodGhpcy55ZWFyKCksIHRoaXMubW9udGgoKSk7XG59XG5cbnZhciBkZWZhdWx0TW9udGhzU2hvcnRSZWdleCA9IG1hdGNoV29yZDtcbmZ1bmN0aW9uIG1vbnRoc1Nob3J0UmVnZXggKGlzU3RyaWN0KSB7XG4gICAgaWYgKHRoaXMuX21vbnRoc1BhcnNlRXhhY3QpIHtcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfbW9udGhzUmVnZXgnKSkge1xuICAgICAgICAgICAgY29tcHV0ZU1vbnRoc1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzU3RyaWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU2hvcnRTdHJpY3RSZWdleDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHNTaG9ydFJlZ2V4O1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfbW9udGhzU2hvcnRSZWdleCcpKSB7XG4gICAgICAgICAgICB0aGlzLl9tb250aHNTaG9ydFJlZ2V4ID0gZGVmYXVsdE1vbnRoc1Nob3J0UmVnZXg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1Nob3J0U3RyaWN0UmVnZXggJiYgaXNTdHJpY3QgP1xuICAgICAgICAgICAgdGhpcy5fbW9udGhzU2hvcnRTdHJpY3RSZWdleCA6IHRoaXMuX21vbnRoc1Nob3J0UmVnZXg7XG4gICAgfVxufVxuXG52YXIgZGVmYXVsdE1vbnRoc1JlZ2V4ID0gbWF0Y2hXb3JkO1xuZnVuY3Rpb24gbW9udGhzUmVnZXggKGlzU3RyaWN0KSB7XG4gICAgaWYgKHRoaXMuX21vbnRoc1BhcnNlRXhhY3QpIHtcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfbW9udGhzUmVnZXgnKSkge1xuICAgICAgICAgICAgY29tcHV0ZU1vbnRoc1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzU3RyaWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU3RyaWN0UmVnZXg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzUmVnZXg7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ19tb250aHNSZWdleCcpKSB7XG4gICAgICAgICAgICB0aGlzLl9tb250aHNSZWdleCA9IGRlZmF1bHRNb250aHNSZWdleDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU3RyaWN0UmVnZXggJiYgaXNTdHJpY3QgP1xuICAgICAgICAgICAgdGhpcy5fbW9udGhzU3RyaWN0UmVnZXggOiB0aGlzLl9tb250aHNSZWdleDtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVNb250aHNQYXJzZSAoKSB7XG4gICAgZnVuY3Rpb24gY21wTGVuUmV2KGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGIubGVuZ3RoIC0gYS5sZW5ndGg7XG4gICAgfVxuXG4gICAgdmFyIHNob3J0UGllY2VzID0gW10sIGxvbmdQaWVjZXMgPSBbXSwgbWl4ZWRQaWVjZXMgPSBbXSxcbiAgICAgICAgaSwgbW9tO1xuICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgIC8vIG1ha2UgdGhlIHJlZ2V4IGlmIHdlIGRvbid0IGhhdmUgaXQgYWxyZWFkeVxuICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIGldKTtcbiAgICAgICAgc2hvcnRQaWVjZXMucHVzaCh0aGlzLm1vbnRoc1Nob3J0KG1vbSwgJycpKTtcbiAgICAgICAgbG9uZ1BpZWNlcy5wdXNoKHRoaXMubW9udGhzKG1vbSwgJycpKTtcbiAgICAgICAgbWl4ZWRQaWVjZXMucHVzaCh0aGlzLm1vbnRocyhtb20sICcnKSk7XG4gICAgICAgIG1peGVkUGllY2VzLnB1c2godGhpcy5tb250aHNTaG9ydChtb20sICcnKSk7XG4gICAgfVxuICAgIC8vIFNvcnRpbmcgbWFrZXMgc3VyZSBpZiBvbmUgbW9udGggKG9yIGFiYnIpIGlzIGEgcHJlZml4IG9mIGFub3RoZXIgaXRcbiAgICAvLyB3aWxsIG1hdGNoIHRoZSBsb25nZXIgcGllY2UuXG4gICAgc2hvcnRQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgIGxvbmdQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgIG1peGVkUGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgICBzaG9ydFBpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKHNob3J0UGllY2VzW2ldKTtcbiAgICAgICAgbG9uZ1BpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKGxvbmdQaWVjZXNbaV0pO1xuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgMjQ7IGkrKykge1xuICAgICAgICBtaXhlZFBpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKG1peGVkUGllY2VzW2ldKTtcbiAgICB9XG5cbiAgICB0aGlzLl9tb250aHNSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIG1peGVkUGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbiAgICB0aGlzLl9tb250aHNTaG9ydFJlZ2V4ID0gdGhpcy5fbW9udGhzUmVnZXg7XG4gICAgdGhpcy5fbW9udGhzU3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBsb25nUGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbiAgICB0aGlzLl9tb250aHNTaG9ydFN0cmljdFJlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgc2hvcnRQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVEYXRlICh5LCBtLCBkLCBoLCBNLCBzLCBtcykge1xuICAgIC8vIGNhbid0IGp1c3QgYXBwbHkoKSB0byBjcmVhdGUgYSBkYXRlOlxuICAgIC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcS8xODEzNDhcbiAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKHksIG0sIGQsIGgsIE0sIHMsIG1zKTtcblxuICAgIC8vIHRoZSBkYXRlIGNvbnN0cnVjdG9yIHJlbWFwcyB5ZWFycyAwLTk5IHRvIDE5MDAtMTk5OVxuICAgIGlmICh5IDwgMTAwICYmIHkgPj0gMCAmJiBpc0Zpbml0ZShkYXRlLmdldEZ1bGxZZWFyKCkpKSB7XG4gICAgICAgIGRhdGUuc2V0RnVsbFllYXIoeSk7XG4gICAgfVxuICAgIHJldHVybiBkYXRlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVVVENEYXRlICh5KSB7XG4gICAgdmFyIGRhdGUgPSBuZXcgRGF0ZShEYXRlLlVUQy5hcHBseShudWxsLCBhcmd1bWVudHMpKTtcblxuICAgIC8vIHRoZSBEYXRlLlVUQyBmdW5jdGlvbiByZW1hcHMgeWVhcnMgMC05OSB0byAxOTAwLTE5OTlcbiAgICBpZiAoeSA8IDEwMCAmJiB5ID49IDAgJiYgaXNGaW5pdGUoZGF0ZS5nZXRVVENGdWxsWWVhcigpKSkge1xuICAgICAgICBkYXRlLnNldFVUQ0Z1bGxZZWFyKHkpO1xuICAgIH1cbiAgICByZXR1cm4gZGF0ZTtcbn1cblxuLy8gc3RhcnQtb2YtZmlyc3Qtd2VlayAtIHN0YXJ0LW9mLXllYXJcbmZ1bmN0aW9uIGZpcnN0V2Vla09mZnNldCh5ZWFyLCBkb3csIGRveSkge1xuICAgIHZhciAvLyBmaXJzdC13ZWVrIGRheSAtLSB3aGljaCBqYW51YXJ5IGlzIGFsd2F5cyBpbiB0aGUgZmlyc3Qgd2VlayAoNCBmb3IgaXNvLCAxIGZvciBvdGhlcilcbiAgICAgICAgZndkID0gNyArIGRvdyAtIGRveSxcbiAgICAgICAgLy8gZmlyc3Qtd2VlayBkYXkgbG9jYWwgd2Vla2RheSAtLSB3aGljaCBsb2NhbCB3ZWVrZGF5IGlzIGZ3ZFxuICAgICAgICBmd2RsdyA9ICg3ICsgY3JlYXRlVVRDRGF0ZSh5ZWFyLCAwLCBmd2QpLmdldFVUQ0RheSgpIC0gZG93KSAlIDc7XG5cbiAgICByZXR1cm4gLWZ3ZGx3ICsgZndkIC0gMTtcbn1cblxuLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPX3dlZWtfZGF0ZSNDYWxjdWxhdGluZ19hX2RhdGVfZ2l2ZW5fdGhlX3llYXIuMkNfd2Vla19udW1iZXJfYW5kX3dlZWtkYXlcbmZ1bmN0aW9uIGRheU9mWWVhckZyb21XZWVrcyh5ZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSkge1xuICAgIHZhciBsb2NhbFdlZWtkYXkgPSAoNyArIHdlZWtkYXkgLSBkb3cpICUgNyxcbiAgICAgICAgd2Vla09mZnNldCA9IGZpcnN0V2Vla09mZnNldCh5ZWFyLCBkb3csIGRveSksXG4gICAgICAgIGRheU9mWWVhciA9IDEgKyA3ICogKHdlZWsgLSAxKSArIGxvY2FsV2Vla2RheSArIHdlZWtPZmZzZXQsXG4gICAgICAgIHJlc1llYXIsIHJlc0RheU9mWWVhcjtcblxuICAgIGlmIChkYXlPZlllYXIgPD0gMCkge1xuICAgICAgICByZXNZZWFyID0geWVhciAtIDE7XG4gICAgICAgIHJlc0RheU9mWWVhciA9IGRheXNJblllYXIocmVzWWVhcikgKyBkYXlPZlllYXI7XG4gICAgfSBlbHNlIGlmIChkYXlPZlllYXIgPiBkYXlzSW5ZZWFyKHllYXIpKSB7XG4gICAgICAgIHJlc1llYXIgPSB5ZWFyICsgMTtcbiAgICAgICAgcmVzRGF5T2ZZZWFyID0gZGF5T2ZZZWFyIC0gZGF5c0luWWVhcih5ZWFyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXNZZWFyID0geWVhcjtcbiAgICAgICAgcmVzRGF5T2ZZZWFyID0gZGF5T2ZZZWFyO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIHllYXI6IHJlc1llYXIsXG4gICAgICAgIGRheU9mWWVhcjogcmVzRGF5T2ZZZWFyXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gd2Vla09mWWVhcihtb20sIGRvdywgZG95KSB7XG4gICAgdmFyIHdlZWtPZmZzZXQgPSBmaXJzdFdlZWtPZmZzZXQobW9tLnllYXIoKSwgZG93LCBkb3kpLFxuICAgICAgICB3ZWVrID0gTWF0aC5mbG9vcigobW9tLmRheU9mWWVhcigpIC0gd2Vla09mZnNldCAtIDEpIC8gNykgKyAxLFxuICAgICAgICByZXNXZWVrLCByZXNZZWFyO1xuXG4gICAgaWYgKHdlZWsgPCAxKSB7XG4gICAgICAgIHJlc1llYXIgPSBtb20ueWVhcigpIC0gMTtcbiAgICAgICAgcmVzV2VlayA9IHdlZWsgKyB3ZWVrc0luWWVhcihyZXNZZWFyLCBkb3csIGRveSk7XG4gICAgfSBlbHNlIGlmICh3ZWVrID4gd2Vla3NJblllYXIobW9tLnllYXIoKSwgZG93LCBkb3kpKSB7XG4gICAgICAgIHJlc1dlZWsgPSB3ZWVrIC0gd2Vla3NJblllYXIobW9tLnllYXIoKSwgZG93LCBkb3kpO1xuICAgICAgICByZXNZZWFyID0gbW9tLnllYXIoKSArIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmVzWWVhciA9IG1vbS55ZWFyKCk7XG4gICAgICAgIHJlc1dlZWsgPSB3ZWVrO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIHdlZWs6IHJlc1dlZWssXG4gICAgICAgIHllYXI6IHJlc1llYXJcbiAgICB9O1xufVxuXG5mdW5jdGlvbiB3ZWVrc0luWWVhcih5ZWFyLCBkb3csIGRveSkge1xuICAgIHZhciB3ZWVrT2Zmc2V0ID0gZmlyc3RXZWVrT2Zmc2V0KHllYXIsIGRvdywgZG95KSxcbiAgICAgICAgd2Vla09mZnNldE5leHQgPSBmaXJzdFdlZWtPZmZzZXQoeWVhciArIDEsIGRvdywgZG95KTtcbiAgICByZXR1cm4gKGRheXNJblllYXIoeWVhcikgLSB3ZWVrT2Zmc2V0ICsgd2Vla09mZnNldE5leHQpIC8gNztcbn1cblxuLy8gRk9STUFUVElOR1xuXG5hZGRGb3JtYXRUb2tlbigndycsIFsnd3cnLCAyXSwgJ3dvJywgJ3dlZWsnKTtcbmFkZEZvcm1hdFRva2VuKCdXJywgWydXVycsIDJdLCAnV28nLCAnaXNvV2VlaycpO1xuXG4vLyBBTElBU0VTXG5cbmFkZFVuaXRBbGlhcygnd2VlaycsICd3Jyk7XG5hZGRVbml0QWxpYXMoJ2lzb1dlZWsnLCAnVycpO1xuXG4vLyBQUklPUklUSUVTXG5cbmFkZFVuaXRQcmlvcml0eSgnd2VlaycsIDUpO1xuYWRkVW5pdFByaW9yaXR5KCdpc29XZWVrJywgNSk7XG5cbi8vIFBBUlNJTkdcblxuYWRkUmVnZXhUb2tlbigndycsICBtYXRjaDF0bzIpO1xuYWRkUmVnZXhUb2tlbignd3cnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG5hZGRSZWdleFRva2VuKCdXJywgIG1hdGNoMXRvMik7XG5hZGRSZWdleFRva2VuKCdXVycsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcblxuYWRkV2Vla1BhcnNlVG9rZW4oWyd3JywgJ3d3JywgJ1cnLCAnV1cnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgd2Vla1t0b2tlbi5zdWJzdHIoMCwgMSldID0gdG9JbnQoaW5wdXQpO1xufSk7XG5cbi8vIEhFTFBFUlNcblxuLy8gTE9DQUxFU1xuXG5mdW5jdGlvbiBsb2NhbGVXZWVrIChtb20pIHtcbiAgICByZXR1cm4gd2Vla09mWWVhcihtb20sIHRoaXMuX3dlZWsuZG93LCB0aGlzLl93ZWVrLmRveSkud2Vlaztcbn1cblxudmFyIGRlZmF1bHRMb2NhbGVXZWVrID0ge1xuICAgIGRvdyA6IDAsIC8vIFN1bmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgIGRveSA6IDYgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDFzdCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbn07XG5cbmZ1bmN0aW9uIGxvY2FsZUZpcnN0RGF5T2ZXZWVrICgpIHtcbiAgICByZXR1cm4gdGhpcy5fd2Vlay5kb3c7XG59XG5cbmZ1bmN0aW9uIGxvY2FsZUZpcnN0RGF5T2ZZZWFyICgpIHtcbiAgICByZXR1cm4gdGhpcy5fd2Vlay5kb3k7XG59XG5cbi8vIE1PTUVOVFNcblxuZnVuY3Rpb24gZ2V0U2V0V2VlayAoaW5wdXQpIHtcbiAgICB2YXIgd2VlayA9IHRoaXMubG9jYWxlRGF0YSgpLndlZWsodGhpcyk7XG4gICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyB3ZWVrIDogdGhpcy5hZGQoKGlucHV0IC0gd2VlaykgKiA3LCAnZCcpO1xufVxuXG5mdW5jdGlvbiBnZXRTZXRJU09XZWVrIChpbnB1dCkge1xuICAgIHZhciB3ZWVrID0gd2Vla09mWWVhcih0aGlzLCAxLCA0KS53ZWVrO1xuICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gd2VlayA6IHRoaXMuYWRkKChpbnB1dCAtIHdlZWspICogNywgJ2QnKTtcbn1cblxuLy8gRk9STUFUVElOR1xuXG5hZGRGb3JtYXRUb2tlbignZCcsIDAsICdkbycsICdkYXknKTtcblxuYWRkRm9ybWF0VG9rZW4oJ2RkJywgMCwgMCwgZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS53ZWVrZGF5c01pbih0aGlzLCBmb3JtYXQpO1xufSk7XG5cbmFkZEZvcm1hdFRva2VuKCdkZGQnLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLndlZWtkYXlzU2hvcnQodGhpcywgZm9ybWF0KTtcbn0pO1xuXG5hZGRGb3JtYXRUb2tlbignZGRkZCcsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkud2Vla2RheXModGhpcywgZm9ybWF0KTtcbn0pO1xuXG5hZGRGb3JtYXRUb2tlbignZScsIDAsIDAsICd3ZWVrZGF5Jyk7XG5hZGRGb3JtYXRUb2tlbignRScsIDAsIDAsICdpc29XZWVrZGF5Jyk7XG5cbi8vIEFMSUFTRVNcblxuYWRkVW5pdEFsaWFzKCdkYXknLCAnZCcpO1xuYWRkVW5pdEFsaWFzKCd3ZWVrZGF5JywgJ2UnKTtcbmFkZFVuaXRBbGlhcygnaXNvV2Vla2RheScsICdFJyk7XG5cbi8vIFBSSU9SSVRZXG5hZGRVbml0UHJpb3JpdHkoJ2RheScsIDExKTtcbmFkZFVuaXRQcmlvcml0eSgnd2Vla2RheScsIDExKTtcbmFkZFVuaXRQcmlvcml0eSgnaXNvV2Vla2RheScsIDExKTtcblxuLy8gUEFSU0lOR1xuXG5hZGRSZWdleFRva2VuKCdkJywgICAgbWF0Y2gxdG8yKTtcbmFkZFJlZ2V4VG9rZW4oJ2UnLCAgICBtYXRjaDF0bzIpO1xuYWRkUmVnZXhUb2tlbignRScsICAgIG1hdGNoMXRvMik7XG5hZGRSZWdleFRva2VuKCdkZCcsICAgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICByZXR1cm4gbG9jYWxlLndlZWtkYXlzTWluUmVnZXgoaXNTdHJpY3QpO1xufSk7XG5hZGRSZWdleFRva2VuKCdkZGQnLCAgIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgcmV0dXJuIGxvY2FsZS53ZWVrZGF5c1Nob3J0UmVnZXgoaXNTdHJpY3QpO1xufSk7XG5hZGRSZWdleFRva2VuKCdkZGRkJywgICBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgIHJldHVybiBsb2NhbGUud2Vla2RheXNSZWdleChpc1N0cmljdCk7XG59KTtcblxuYWRkV2Vla1BhcnNlVG9rZW4oWydkZCcsICdkZGQnLCAnZGRkZCddLCBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcbiAgICB2YXIgd2Vla2RheSA9IGNvbmZpZy5fbG9jYWxlLndlZWtkYXlzUGFyc2UoaW5wdXQsIHRva2VuLCBjb25maWcuX3N0cmljdCk7XG4gICAgLy8gaWYgd2UgZGlkbid0IGdldCBhIHdlZWtkYXkgbmFtZSwgbWFyayB0aGUgZGF0ZSBhcyBpbnZhbGlkXG4gICAgaWYgKHdlZWtkYXkgIT0gbnVsbCkge1xuICAgICAgICB3ZWVrLmQgPSB3ZWVrZGF5O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmludmFsaWRXZWVrZGF5ID0gaW5wdXQ7XG4gICAgfVxufSk7XG5cbmFkZFdlZWtQYXJzZVRva2VuKFsnZCcsICdlJywgJ0UnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgd2Vla1t0b2tlbl0gPSB0b0ludChpbnB1dCk7XG59KTtcblxuLy8gSEVMUEVSU1xuXG5mdW5jdGlvbiBwYXJzZVdlZWtkYXkoaW5wdXQsIGxvY2FsZSkge1xuICAgIGlmICh0eXBlb2YgaW5wdXQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBpbnB1dDtcbiAgICB9XG5cbiAgICBpZiAoIWlzTmFOKGlucHV0KSkge1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQoaW5wdXQsIDEwKTtcbiAgICB9XG5cbiAgICBpbnB1dCA9IGxvY2FsZS53ZWVrZGF5c1BhcnNlKGlucHV0KTtcbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIHBhcnNlSXNvV2Vla2RheShpbnB1dCwgbG9jYWxlKSB7XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS53ZWVrZGF5c1BhcnNlKGlucHV0KSAlIDcgfHwgNztcbiAgICB9XG4gICAgcmV0dXJuIGlzTmFOKGlucHV0KSA/IG51bGwgOiBpbnB1dDtcbn1cblxuLy8gTE9DQUxFU1xuXG52YXIgZGVmYXVsdExvY2FsZVdlZWtkYXlzID0gJ1N1bmRheV9Nb25kYXlfVHVlc2RheV9XZWRuZXNkYXlfVGh1cnNkYXlfRnJpZGF5X1NhdHVyZGF5Jy5zcGxpdCgnXycpO1xuZnVuY3Rpb24gbG9jYWxlV2Vla2RheXMgKG0sIGZvcm1hdCkge1xuICAgIGlmICghbSkge1xuICAgICAgICByZXR1cm4gaXNBcnJheSh0aGlzLl93ZWVrZGF5cykgPyB0aGlzLl93ZWVrZGF5cyA6XG4gICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1snc3RhbmRhbG9uZSddO1xuICAgIH1cbiAgICByZXR1cm4gaXNBcnJheSh0aGlzLl93ZWVrZGF5cykgPyB0aGlzLl93ZWVrZGF5c1ttLmRheSgpXSA6XG4gICAgICAgIHRoaXMuX3dlZWtkYXlzW3RoaXMuX3dlZWtkYXlzLmlzRm9ybWF0LnRlc3QoZm9ybWF0KSA/ICdmb3JtYXQnIDogJ3N0YW5kYWxvbmUnXVttLmRheSgpXTtcbn1cblxudmFyIGRlZmF1bHRMb2NhbGVXZWVrZGF5c1Nob3J0ID0gJ1N1bl9Nb25fVHVlX1dlZF9UaHVfRnJpX1NhdCcuc3BsaXQoJ18nKTtcbmZ1bmN0aW9uIGxvY2FsZVdlZWtkYXlzU2hvcnQgKG0pIHtcbiAgICByZXR1cm4gKG0pID8gdGhpcy5fd2Vla2RheXNTaG9ydFttLmRheSgpXSA6IHRoaXMuX3dlZWtkYXlzU2hvcnQ7XG59XG5cbnZhciBkZWZhdWx0TG9jYWxlV2Vla2RheXNNaW4gPSAnU3VfTW9fVHVfV2VfVGhfRnJfU2EnLnNwbGl0KCdfJyk7XG5mdW5jdGlvbiBsb2NhbGVXZWVrZGF5c01pbiAobSkge1xuICAgIHJldHVybiAobSkgPyB0aGlzLl93ZWVrZGF5c01pblttLmRheSgpXSA6IHRoaXMuX3dlZWtkYXlzTWluO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVTdHJpY3RQYXJzZSQxKHdlZWtkYXlOYW1lLCBmb3JtYXQsIHN0cmljdCkge1xuICAgIHZhciBpLCBpaSwgbW9tLCBsbGMgPSB3ZWVrZGF5TmFtZS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgIGlmICghdGhpcy5fd2Vla2RheXNQYXJzZSkge1xuICAgICAgICB0aGlzLl93ZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgIHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZSA9IFtdO1xuICAgICAgICB0aGlzLl9taW5XZWVrZGF5c1BhcnNlID0gW107XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDc7ICsraSkge1xuICAgICAgICAgICAgbW9tID0gY3JlYXRlVVRDKFsyMDAwLCAxXSkuZGF5KGkpO1xuICAgICAgICAgICAgdGhpcy5fbWluV2Vla2RheXNQYXJzZVtpXSA9IHRoaXMud2Vla2RheXNNaW4obW9tLCAnJykudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgICAgIHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZVtpXSA9IHRoaXMud2Vla2RheXNTaG9ydChtb20sICcnKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNQYXJzZVtpXSA9IHRoaXMud2Vla2RheXMobW9tLCAnJykudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzdHJpY3QpIHtcbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ2RkZGQnKSB7XG4gICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl93ZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgfSBlbHNlIGlmIChmb3JtYXQgPT09ICdkZGQnKSB7XG4gICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbWluV2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZm9ybWF0ID09PSAnZGRkZCcpIHtcbiAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3dlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX21pbldlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gJ2RkZCcpIHtcbiAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl93ZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX21pbldlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbWluV2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl93ZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGxvY2FsZVdlZWtkYXlzUGFyc2UgKHdlZWtkYXlOYW1lLCBmb3JtYXQsIHN0cmljdCkge1xuICAgIHZhciBpLCBtb20sIHJlZ2V4O1xuXG4gICAgaWYgKHRoaXMuX3dlZWtkYXlzUGFyc2VFeGFjdCkge1xuICAgICAgICByZXR1cm4gaGFuZGxlU3RyaWN0UGFyc2UkMS5jYWxsKHRoaXMsIHdlZWtkYXlOYW1lLCBmb3JtYXQsIHN0cmljdCk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl93ZWVrZGF5c1BhcnNlKSB7XG4gICAgICAgIHRoaXMuX3dlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgdGhpcy5fbWluV2Vla2RheXNQYXJzZSA9IFtdO1xuICAgICAgICB0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgdGhpcy5fZnVsbFdlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgIC8vIG1ha2UgdGhlIHJlZ2V4IGlmIHdlIGRvbid0IGhhdmUgaXQgYWxyZWFkeVxuXG4gICAgICAgIG1vbSA9IGNyZWF0ZVVUQyhbMjAwMCwgMV0pLmRheShpKTtcbiAgICAgICAgaWYgKHN0cmljdCAmJiAhdGhpcy5fZnVsbFdlZWtkYXlzUGFyc2VbaV0pIHtcbiAgICAgICAgICAgIHRoaXMuX2Z1bGxXZWVrZGF5c1BhcnNlW2ldID0gbmV3IFJlZ0V4cCgnXicgKyB0aGlzLndlZWtkYXlzKG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnXFwuPycpICsgJyQnLCAnaScpO1xuICAgICAgICAgICAgdGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlW2ldID0gbmV3IFJlZ0V4cCgnXicgKyB0aGlzLndlZWtkYXlzU2hvcnQobW9tLCAnJykucmVwbGFjZSgnLicsICdcXC4/JykgKyAnJCcsICdpJyk7XG4gICAgICAgICAgICB0aGlzLl9taW5XZWVrZGF5c1BhcnNlW2ldID0gbmV3IFJlZ0V4cCgnXicgKyB0aGlzLndlZWtkYXlzTWluKG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnXFwuPycpICsgJyQnLCAnaScpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5fd2Vla2RheXNQYXJzZVtpXSkge1xuICAgICAgICAgICAgcmVnZXggPSAnXicgKyB0aGlzLndlZWtkYXlzKG1vbSwgJycpICsgJ3xeJyArIHRoaXMud2Vla2RheXNTaG9ydChtb20sICcnKSArICd8XicgKyB0aGlzLndlZWtkYXlzTWluKG1vbSwgJycpO1xuICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNQYXJzZVtpXSA9IG5ldyBSZWdFeHAocmVnZXgucmVwbGFjZSgnLicsICcnKSwgJ2knKTtcbiAgICAgICAgfVxuICAgICAgICAvLyB0ZXN0IHRoZSByZWdleFxuICAgICAgICBpZiAoc3RyaWN0ICYmIGZvcm1hdCA9PT0gJ2RkZGQnICYmIHRoaXMuX2Z1bGxXZWVrZGF5c1BhcnNlW2ldLnRlc3Qod2Vla2RheU5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfSBlbHNlIGlmIChzdHJpY3QgJiYgZm9ybWF0ID09PSAnZGRkJyAmJiB0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2VbaV0udGVzdCh3ZWVrZGF5TmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9IGVsc2UgaWYgKHN0cmljdCAmJiBmb3JtYXQgPT09ICdkZCcgJiYgdGhpcy5fbWluV2Vla2RheXNQYXJzZVtpXS50ZXN0KHdlZWtkYXlOYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH0gZWxzZSBpZiAoIXN0cmljdCAmJiB0aGlzLl93ZWVrZGF5c1BhcnNlW2ldLnRlc3Qod2Vla2RheU5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLy8gTU9NRU5UU1xuXG5mdW5jdGlvbiBnZXRTZXREYXlPZldlZWsgKGlucHV0KSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICByZXR1cm4gaW5wdXQgIT0gbnVsbCA/IHRoaXMgOiBOYU47XG4gICAgfVxuICAgIHZhciBkYXkgPSB0aGlzLl9pc1VUQyA/IHRoaXMuX2QuZ2V0VVRDRGF5KCkgOiB0aGlzLl9kLmdldERheSgpO1xuICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgIGlucHV0ID0gcGFyc2VXZWVrZGF5KGlucHV0LCB0aGlzLmxvY2FsZURhdGEoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZChpbnB1dCAtIGRheSwgJ2QnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZGF5O1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZ2V0U2V0TG9jYWxlRGF5T2ZXZWVrIChpbnB1dCkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgPyB0aGlzIDogTmFOO1xuICAgIH1cbiAgICB2YXIgd2Vla2RheSA9ICh0aGlzLmRheSgpICsgNyAtIHRoaXMubG9jYWxlRGF0YSgpLl93ZWVrLmRvdykgJSA3O1xuICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gd2Vla2RheSA6IHRoaXMuYWRkKGlucHV0IC0gd2Vla2RheSwgJ2QnKTtcbn1cblxuZnVuY3Rpb24gZ2V0U2V0SVNPRGF5T2ZXZWVrIChpbnB1dCkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgPyB0aGlzIDogTmFOO1xuICAgIH1cblxuICAgIC8vIGJlaGF2ZXMgdGhlIHNhbWUgYXMgbW9tZW50I2RheSBleGNlcHRcbiAgICAvLyBhcyBhIGdldHRlciwgcmV0dXJucyA3IGluc3RlYWQgb2YgMCAoMS03IHJhbmdlIGluc3RlYWQgb2YgMC02KVxuICAgIC8vIGFzIGEgc2V0dGVyLCBzdW5kYXkgc2hvdWxkIGJlbG9uZyB0byB0aGUgcHJldmlvdXMgd2Vlay5cblxuICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgIHZhciB3ZWVrZGF5ID0gcGFyc2VJc29XZWVrZGF5KGlucHV0LCB0aGlzLmxvY2FsZURhdGEoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLmRheSh0aGlzLmRheSgpICUgNyA/IHdlZWtkYXkgOiB3ZWVrZGF5IC0gNyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF5KCkgfHwgNztcbiAgICB9XG59XG5cbnZhciBkZWZhdWx0V2Vla2RheXNSZWdleCA9IG1hdGNoV29yZDtcbmZ1bmN0aW9uIHdlZWtkYXlzUmVnZXggKGlzU3RyaWN0KSB7XG4gICAgaWYgKHRoaXMuX3dlZWtkYXlzUGFyc2VFeGFjdCkge1xuICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ193ZWVrZGF5c1JlZ2V4JykpIHtcbiAgICAgICAgICAgIGNvbXB1dGVXZWVrZGF5c1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzU3RyaWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTdHJpY3RSZWdleDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1JlZ2V4O1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNSZWdleCcpKSB7XG4gICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1JlZ2V4ID0gZGVmYXVsdFdlZWtkYXlzUmVnZXg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzU3RyaWN0UmVnZXggJiYgaXNTdHJpY3QgP1xuICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNTdHJpY3RSZWdleCA6IHRoaXMuX3dlZWtkYXlzUmVnZXg7XG4gICAgfVxufVxuXG52YXIgZGVmYXVsdFdlZWtkYXlzU2hvcnRSZWdleCA9IG1hdGNoV29yZDtcbmZ1bmN0aW9uIHdlZWtkYXlzU2hvcnRSZWdleCAoaXNTdHJpY3QpIHtcbiAgICBpZiAodGhpcy5fd2Vla2RheXNQYXJzZUV4YWN0KSB7XG4gICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzUmVnZXgnKSkge1xuICAgICAgICAgICAgY29tcHV0ZVdlZWtkYXlzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNTdHJpY3QpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1Nob3J0U3RyaWN0UmVnZXg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTaG9ydFJlZ2V4O1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNTaG9ydFJlZ2V4JykpIHtcbiAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzU2hvcnRSZWdleCA9IGRlZmF1bHRXZWVrZGF5c1Nob3J0UmVnZXg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzU2hvcnRTdHJpY3RSZWdleCAmJiBpc1N0cmljdCA/XG4gICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1Nob3J0U3RyaWN0UmVnZXggOiB0aGlzLl93ZWVrZGF5c1Nob3J0UmVnZXg7XG4gICAgfVxufVxuXG52YXIgZGVmYXVsdFdlZWtkYXlzTWluUmVnZXggPSBtYXRjaFdvcmQ7XG5mdW5jdGlvbiB3ZWVrZGF5c01pblJlZ2V4IChpc1N0cmljdCkge1xuICAgIGlmICh0aGlzLl93ZWVrZGF5c1BhcnNlRXhhY3QpIHtcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNSZWdleCcpKSB7XG4gICAgICAgICAgICBjb21wdXRlV2Vla2RheXNQYXJzZS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1N0cmljdCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzTWluU3RyaWN0UmVnZXg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNNaW5SZWdleDtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzTWluUmVnZXgnKSkge1xuICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNNaW5SZWdleCA9IGRlZmF1bHRXZWVrZGF5c01pblJlZ2V4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c01pblN0cmljdFJlZ2V4ICYmIGlzU3RyaWN0ID9cbiAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzTWluU3RyaWN0UmVnZXggOiB0aGlzLl93ZWVrZGF5c01pblJlZ2V4O1xuICAgIH1cbn1cblxuXG5mdW5jdGlvbiBjb21wdXRlV2Vla2RheXNQYXJzZSAoKSB7XG4gICAgZnVuY3Rpb24gY21wTGVuUmV2KGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGIubGVuZ3RoIC0gYS5sZW5ndGg7XG4gICAgfVxuXG4gICAgdmFyIG1pblBpZWNlcyA9IFtdLCBzaG9ydFBpZWNlcyA9IFtdLCBsb25nUGllY2VzID0gW10sIG1peGVkUGllY2VzID0gW10sXG4gICAgICAgIGksIG1vbSwgbWlucCwgc2hvcnRwLCBsb25ncDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgIC8vIG1ha2UgdGhlIHJlZ2V4IGlmIHdlIGRvbid0IGhhdmUgaXQgYWxyZWFkeVxuICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIDFdKS5kYXkoaSk7XG4gICAgICAgIG1pbnAgPSB0aGlzLndlZWtkYXlzTWluKG1vbSwgJycpO1xuICAgICAgICBzaG9ydHAgPSB0aGlzLndlZWtkYXlzU2hvcnQobW9tLCAnJyk7XG4gICAgICAgIGxvbmdwID0gdGhpcy53ZWVrZGF5cyhtb20sICcnKTtcbiAgICAgICAgbWluUGllY2VzLnB1c2gobWlucCk7XG4gICAgICAgIHNob3J0UGllY2VzLnB1c2goc2hvcnRwKTtcbiAgICAgICAgbG9uZ1BpZWNlcy5wdXNoKGxvbmdwKTtcbiAgICAgICAgbWl4ZWRQaWVjZXMucHVzaChtaW5wKTtcbiAgICAgICAgbWl4ZWRQaWVjZXMucHVzaChzaG9ydHApO1xuICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKGxvbmdwKTtcbiAgICB9XG4gICAgLy8gU29ydGluZyBtYWtlcyBzdXJlIGlmIG9uZSB3ZWVrZGF5IChvciBhYmJyKSBpcyBhIHByZWZpeCBvZiBhbm90aGVyIGl0XG4gICAgLy8gd2lsbCBtYXRjaCB0aGUgbG9uZ2VyIHBpZWNlLlxuICAgIG1pblBpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgc2hvcnRQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgIGxvbmdQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgIG1peGVkUGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgIHNob3J0UGllY2VzW2ldID0gcmVnZXhFc2NhcGUoc2hvcnRQaWVjZXNbaV0pO1xuICAgICAgICBsb25nUGllY2VzW2ldID0gcmVnZXhFc2NhcGUobG9uZ1BpZWNlc1tpXSk7XG4gICAgICAgIG1peGVkUGllY2VzW2ldID0gcmVnZXhFc2NhcGUobWl4ZWRQaWVjZXNbaV0pO1xuICAgIH1cblxuICAgIHRoaXMuX3dlZWtkYXlzUmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBtaXhlZFBpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgdGhpcy5fd2Vla2RheXNTaG9ydFJlZ2V4ID0gdGhpcy5fd2Vla2RheXNSZWdleDtcbiAgICB0aGlzLl93ZWVrZGF5c01pblJlZ2V4ID0gdGhpcy5fd2Vla2RheXNSZWdleDtcblxuICAgIHRoaXMuX3dlZWtkYXlzU3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBsb25nUGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbiAgICB0aGlzLl93ZWVrZGF5c1Nob3J0U3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBzaG9ydFBpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgdGhpcy5fd2Vla2RheXNNaW5TdHJpY3RSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIG1pblBpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG59XG5cbi8vIEZPUk1BVFRJTkdcblxuZnVuY3Rpb24gaEZvcm1hdCgpIHtcbiAgICByZXR1cm4gdGhpcy5ob3VycygpICUgMTIgfHwgMTI7XG59XG5cbmZ1bmN0aW9uIGtGb3JtYXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaG91cnMoKSB8fCAyNDtcbn1cblxuYWRkRm9ybWF0VG9rZW4oJ0gnLCBbJ0hIJywgMl0sIDAsICdob3VyJyk7XG5hZGRGb3JtYXRUb2tlbignaCcsIFsnaGgnLCAyXSwgMCwgaEZvcm1hdCk7XG5hZGRGb3JtYXRUb2tlbignaycsIFsna2snLCAyXSwgMCwga0Zvcm1hdCk7XG5cbmFkZEZvcm1hdFRva2VuKCdobW0nLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICcnICsgaEZvcm1hdC5hcHBseSh0aGlzKSArIHplcm9GaWxsKHRoaXMubWludXRlcygpLCAyKTtcbn0pO1xuXG5hZGRGb3JtYXRUb2tlbignaG1tc3MnLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICcnICsgaEZvcm1hdC5hcHBseSh0aGlzKSArIHplcm9GaWxsKHRoaXMubWludXRlcygpLCAyKSArXG4gICAgICAgIHplcm9GaWxsKHRoaXMuc2Vjb25kcygpLCAyKTtcbn0pO1xuXG5hZGRGb3JtYXRUb2tlbignSG1tJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAnJyArIHRoaXMuaG91cnMoKSArIHplcm9GaWxsKHRoaXMubWludXRlcygpLCAyKTtcbn0pO1xuXG5hZGRGb3JtYXRUb2tlbignSG1tc3MnLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICcnICsgdGhpcy5ob3VycygpICsgemVyb0ZpbGwodGhpcy5taW51dGVzKCksIDIpICtcbiAgICAgICAgemVyb0ZpbGwodGhpcy5zZWNvbmRzKCksIDIpO1xufSk7XG5cbmZ1bmN0aW9uIG1lcmlkaWVtICh0b2tlbiwgbG93ZXJjYXNlKSB7XG4gICAgYWRkRm9ybWF0VG9rZW4odG9rZW4sIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm1lcmlkaWVtKHRoaXMuaG91cnMoKSwgdGhpcy5taW51dGVzKCksIGxvd2VyY2FzZSk7XG4gICAgfSk7XG59XG5cbm1lcmlkaWVtKCdhJywgdHJ1ZSk7XG5tZXJpZGllbSgnQScsIGZhbHNlKTtcblxuLy8gQUxJQVNFU1xuXG5hZGRVbml0QWxpYXMoJ2hvdXInLCAnaCcpO1xuXG4vLyBQUklPUklUWVxuYWRkVW5pdFByaW9yaXR5KCdob3VyJywgMTMpO1xuXG4vLyBQQVJTSU5HXG5cbmZ1bmN0aW9uIG1hdGNoTWVyaWRpZW0gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICByZXR1cm4gbG9jYWxlLl9tZXJpZGllbVBhcnNlO1xufVxuXG5hZGRSZWdleFRva2VuKCdhJywgIG1hdGNoTWVyaWRpZW0pO1xuYWRkUmVnZXhUb2tlbignQScsICBtYXRjaE1lcmlkaWVtKTtcbmFkZFJlZ2V4VG9rZW4oJ0gnLCAgbWF0Y2gxdG8yKTtcbmFkZFJlZ2V4VG9rZW4oJ2gnLCAgbWF0Y2gxdG8yKTtcbmFkZFJlZ2V4VG9rZW4oJ2snLCAgbWF0Y2gxdG8yKTtcbmFkZFJlZ2V4VG9rZW4oJ0hIJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuYWRkUmVnZXhUb2tlbignaGgnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG5hZGRSZWdleFRva2VuKCdraycsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcblxuYWRkUmVnZXhUb2tlbignaG1tJywgbWF0Y2gzdG80KTtcbmFkZFJlZ2V4VG9rZW4oJ2htbXNzJywgbWF0Y2g1dG82KTtcbmFkZFJlZ2V4VG9rZW4oJ0htbScsIG1hdGNoM3RvNCk7XG5hZGRSZWdleFRva2VuKCdIbW1zcycsIG1hdGNoNXRvNik7XG5cbmFkZFBhcnNlVG9rZW4oWydIJywgJ0hIJ10sIEhPVVIpO1xuYWRkUGFyc2VUb2tlbihbJ2snLCAna2snXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgdmFyIGtJbnB1dCA9IHRvSW50KGlucHV0KTtcbiAgICBhcnJheVtIT1VSXSA9IGtJbnB1dCA9PT0gMjQgPyAwIDoga0lucHV0O1xufSk7XG5hZGRQYXJzZVRva2VuKFsnYScsICdBJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgIGNvbmZpZy5faXNQbSA9IGNvbmZpZy5fbG9jYWxlLmlzUE0oaW5wdXQpO1xuICAgIGNvbmZpZy5fbWVyaWRpZW0gPSBpbnB1dDtcbn0pO1xuYWRkUGFyc2VUb2tlbihbJ2gnLCAnaGgnXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dCk7XG4gICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9IHRydWU7XG59KTtcbmFkZFBhcnNlVG9rZW4oJ2htbScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgIHZhciBwb3MgPSBpbnB1dC5sZW5ndGggLSAyO1xuICAgIGFycmF5W0hPVVJdID0gdG9JbnQoaW5wdXQuc3Vic3RyKDAsIHBvcykpO1xuICAgIGFycmF5W01JTlVURV0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zKSk7XG4gICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9IHRydWU7XG59KTtcbmFkZFBhcnNlVG9rZW4oJ2htbXNzJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgdmFyIHBvczEgPSBpbnB1dC5sZW5ndGggLSA0O1xuICAgIHZhciBwb3MyID0gaW5wdXQubGVuZ3RoIC0gMjtcbiAgICBhcnJheVtIT1VSXSA9IHRvSW50KGlucHV0LnN1YnN0cigwLCBwb3MxKSk7XG4gICAgYXJyYXlbTUlOVVRFXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MxLCAyKSk7XG4gICAgYXJyYXlbU0VDT05EXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MyKSk7XG4gICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9IHRydWU7XG59KTtcbmFkZFBhcnNlVG9rZW4oJ0htbScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgIHZhciBwb3MgPSBpbnB1dC5sZW5ndGggLSAyO1xuICAgIGFycmF5W0hPVVJdID0gdG9JbnQoaW5wdXQuc3Vic3RyKDAsIHBvcykpO1xuICAgIGFycmF5W01JTlVURV0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zKSk7XG59KTtcbmFkZFBhcnNlVG9rZW4oJ0htbXNzJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgdmFyIHBvczEgPSBpbnB1dC5sZW5ndGggLSA0O1xuICAgIHZhciBwb3MyID0gaW5wdXQubGVuZ3RoIC0gMjtcbiAgICBhcnJheVtIT1VSXSA9IHRvSW50KGlucHV0LnN1YnN0cigwLCBwb3MxKSk7XG4gICAgYXJyYXlbTUlOVVRFXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MxLCAyKSk7XG4gICAgYXJyYXlbU0VDT05EXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MyKSk7XG59KTtcblxuLy8gTE9DQUxFU1xuXG5mdW5jdGlvbiBsb2NhbGVJc1BNIChpbnB1dCkge1xuICAgIC8vIElFOCBRdWlya3MgTW9kZSAmIElFNyBTdGFuZGFyZHMgTW9kZSBkbyBub3QgYWxsb3cgYWNjZXNzaW5nIHN0cmluZ3MgbGlrZSBhcnJheXNcbiAgICAvLyBVc2luZyBjaGFyQXQgc2hvdWxkIGJlIG1vcmUgY29tcGF0aWJsZS5cbiAgICByZXR1cm4gKChpbnB1dCArICcnKS50b0xvd2VyQ2FzZSgpLmNoYXJBdCgwKSA9PT0gJ3AnKTtcbn1cblxudmFyIGRlZmF1bHRMb2NhbGVNZXJpZGllbVBhcnNlID0gL1thcF1cXC4/bT9cXC4/L2k7XG5mdW5jdGlvbiBsb2NhbGVNZXJpZGllbSAoaG91cnMsIG1pbnV0ZXMsIGlzTG93ZXIpIHtcbiAgICBpZiAoaG91cnMgPiAxMSkge1xuICAgICAgICByZXR1cm4gaXNMb3dlciA/ICdwbScgOiAnUE0nO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBpc0xvd2VyID8gJ2FtJyA6ICdBTSc7XG4gICAgfVxufVxuXG5cbi8vIE1PTUVOVFNcblxuLy8gU2V0dGluZyB0aGUgaG91ciBzaG91bGQga2VlcCB0aGUgdGltZSwgYmVjYXVzZSB0aGUgdXNlciBleHBsaWNpdGx5XG4vLyBzcGVjaWZpZWQgd2hpY2ggaG91ciBoZSB3YW50cy4gU28gdHJ5aW5nIHRvIG1haW50YWluIHRoZSBzYW1lIGhvdXIgKGluXG4vLyBhIG5ldyB0aW1lem9uZSkgbWFrZXMgc2Vuc2UuIEFkZGluZy9zdWJ0cmFjdGluZyBob3VycyBkb2VzIG5vdCBmb2xsb3dcbi8vIHRoaXMgcnVsZS5cbnZhciBnZXRTZXRIb3VyID0gbWFrZUdldFNldCgnSG91cnMnLCB0cnVlKTtcblxuLy8gbW9udGhzXG4vLyB3ZWVrXG4vLyB3ZWVrZGF5c1xuLy8gbWVyaWRpZW1cbnZhciBiYXNlQ29uZmlnID0ge1xuICAgIGNhbGVuZGFyOiBkZWZhdWx0Q2FsZW5kYXIsXG4gICAgbG9uZ0RhdGVGb3JtYXQ6IGRlZmF1bHRMb25nRGF0ZUZvcm1hdCxcbiAgICBpbnZhbGlkRGF0ZTogZGVmYXVsdEludmFsaWREYXRlLFxuICAgIG9yZGluYWw6IGRlZmF1bHRPcmRpbmFsLFxuICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2U6IGRlZmF1bHREYXlPZk1vbnRoT3JkaW5hbFBhcnNlLFxuICAgIHJlbGF0aXZlVGltZTogZGVmYXVsdFJlbGF0aXZlVGltZSxcblxuICAgIG1vbnRoczogZGVmYXVsdExvY2FsZU1vbnRocyxcbiAgICBtb250aHNTaG9ydDogZGVmYXVsdExvY2FsZU1vbnRoc1Nob3J0LFxuXG4gICAgd2VlazogZGVmYXVsdExvY2FsZVdlZWssXG5cbiAgICB3ZWVrZGF5czogZGVmYXVsdExvY2FsZVdlZWtkYXlzLFxuICAgIHdlZWtkYXlzTWluOiBkZWZhdWx0TG9jYWxlV2Vla2RheXNNaW4sXG4gICAgd2Vla2RheXNTaG9ydDogZGVmYXVsdExvY2FsZVdlZWtkYXlzU2hvcnQsXG5cbiAgICBtZXJpZGllbVBhcnNlOiBkZWZhdWx0TG9jYWxlTWVyaWRpZW1QYXJzZVxufTtcblxuLy8gaW50ZXJuYWwgc3RvcmFnZSBmb3IgbG9jYWxlIGNvbmZpZyBmaWxlc1xudmFyIGxvY2FsZXMgPSB7fTtcbnZhciBsb2NhbGVGYW1pbGllcyA9IHt9O1xudmFyIGdsb2JhbExvY2FsZTtcblxuZnVuY3Rpb24gbm9ybWFsaXplTG9jYWxlKGtleSkge1xuICAgIHJldHVybiBrZXkgPyBrZXkudG9Mb3dlckNhc2UoKS5yZXBsYWNlKCdfJywgJy0nKSA6IGtleTtcbn1cblxuLy8gcGljayB0aGUgbG9jYWxlIGZyb20gdGhlIGFycmF5XG4vLyB0cnkgWydlbi1hdScsICdlbi1nYiddIGFzICdlbi1hdScsICdlbi1nYicsICdlbicsIGFzIGluIG1vdmUgdGhyb3VnaCB0aGUgbGlzdCB0cnlpbmcgZWFjaFxuLy8gc3Vic3RyaW5nIGZyb20gbW9zdCBzcGVjaWZpYyB0byBsZWFzdCwgYnV0IG1vdmUgdG8gdGhlIG5leHQgYXJyYXkgaXRlbSBpZiBpdCdzIGEgbW9yZSBzcGVjaWZpYyB2YXJpYW50IHRoYW4gdGhlIGN1cnJlbnQgcm9vdFxuZnVuY3Rpb24gY2hvb3NlTG9jYWxlKG5hbWVzKSB7XG4gICAgdmFyIGkgPSAwLCBqLCBuZXh0LCBsb2NhbGUsIHNwbGl0O1xuXG4gICAgd2hpbGUgKGkgPCBuYW1lcy5sZW5ndGgpIHtcbiAgICAgICAgc3BsaXQgPSBub3JtYWxpemVMb2NhbGUobmFtZXNbaV0pLnNwbGl0KCctJyk7XG4gICAgICAgIGogPSBzcGxpdC5sZW5ndGg7XG4gICAgICAgIG5leHQgPSBub3JtYWxpemVMb2NhbGUobmFtZXNbaSArIDFdKTtcbiAgICAgICAgbmV4dCA9IG5leHQgPyBuZXh0LnNwbGl0KCctJykgOiBudWxsO1xuICAgICAgICB3aGlsZSAoaiA+IDApIHtcbiAgICAgICAgICAgIGxvY2FsZSA9IGxvYWRMb2NhbGUoc3BsaXQuc2xpY2UoMCwgaikuam9pbignLScpKTtcbiAgICAgICAgICAgIGlmIChsb2NhbGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9jYWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5leHQgJiYgbmV4dC5sZW5ndGggPj0gaiAmJiBjb21wYXJlQXJyYXlzKHNwbGl0LCBuZXh0LCB0cnVlKSA+PSBqIC0gMSkge1xuICAgICAgICAgICAgICAgIC8vdGhlIG5leHQgYXJyYXkgaXRlbSBpcyBiZXR0ZXIgdGhhbiBhIHNoYWxsb3dlciBzdWJzdHJpbmcgb2YgdGhpcyBvbmVcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGotLTtcbiAgICAgICAgfVxuICAgICAgICBpKys7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBsb2FkTG9jYWxlKG5hbWUpIHtcbiAgICB2YXIgb2xkTG9jYWxlID0gbnVsbDtcbiAgICAvLyBUT0RPOiBGaW5kIGEgYmV0dGVyIHdheSB0byByZWdpc3RlciBhbmQgbG9hZCBhbGwgdGhlIGxvY2FsZXMgaW4gTm9kZVxuICAgIGlmICghbG9jYWxlc1tuYW1lXSAmJiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpICYmXG4gICAgICAgICAgICBtb2R1bGUgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG9sZExvY2FsZSA9IGdsb2JhbExvY2FsZS5fYWJicjtcbiAgICAgICAgICAgIHZhciBhbGlhc2VkUmVxdWlyZSA9IHJlcXVpcmU7XG4gICAgICAgICAgICBhbGlhc2VkUmVxdWlyZSgnLi9sb2NhbGUvJyArIG5hbWUpO1xuICAgICAgICAgICAgZ2V0U2V0R2xvYmFsTG9jYWxlKG9sZExvY2FsZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgfVxuICAgIHJldHVybiBsb2NhbGVzW25hbWVdO1xufVxuXG4vLyBUaGlzIGZ1bmN0aW9uIHdpbGwgbG9hZCBsb2NhbGUgYW5kIHRoZW4gc2V0IHRoZSBnbG9iYWwgbG9jYWxlLiAgSWZcbi8vIG5vIGFyZ3VtZW50cyBhcmUgcGFzc2VkIGluLCBpdCB3aWxsIHNpbXBseSByZXR1cm4gdGhlIGN1cnJlbnQgZ2xvYmFsXG4vLyBsb2NhbGUga2V5LlxuZnVuY3Rpb24gZ2V0U2V0R2xvYmFsTG9jYWxlIChrZXksIHZhbHVlcykge1xuICAgIHZhciBkYXRhO1xuICAgIGlmIChrZXkpIHtcbiAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlcykpIHtcbiAgICAgICAgICAgIGRhdGEgPSBnZXRMb2NhbGUoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRhdGEgPSBkZWZpbmVMb2NhbGUoa2V5LCB2YWx1ZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgIC8vIG1vbWVudC5kdXJhdGlvbi5fbG9jYWxlID0gbW9tZW50Ll9sb2NhbGUgPSBkYXRhO1xuICAgICAgICAgICAgZ2xvYmFsTG9jYWxlID0gZGF0YTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBnbG9iYWxMb2NhbGUuX2FiYnI7XG59XG5cbmZ1bmN0aW9uIGRlZmluZUxvY2FsZSAobmFtZSwgY29uZmlnKSB7XG4gICAgaWYgKGNvbmZpZyAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgcGFyZW50Q29uZmlnID0gYmFzZUNvbmZpZztcbiAgICAgICAgY29uZmlnLmFiYnIgPSBuYW1lO1xuICAgICAgICBpZiAobG9jYWxlc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICBkZXByZWNhdGVTaW1wbGUoJ2RlZmluZUxvY2FsZU92ZXJyaWRlJyxcbiAgICAgICAgICAgICAgICAgICAgJ3VzZSBtb21lbnQudXBkYXRlTG9jYWxlKGxvY2FsZU5hbWUsIGNvbmZpZykgdG8gY2hhbmdlICcgK1xuICAgICAgICAgICAgICAgICAgICAnYW4gZXhpc3RpbmcgbG9jYWxlLiBtb21lbnQuZGVmaW5lTG9jYWxlKGxvY2FsZU5hbWUsICcgK1xuICAgICAgICAgICAgICAgICAgICAnY29uZmlnKSBzaG91bGQgb25seSBiZSB1c2VkIGZvciBjcmVhdGluZyBhIG5ldyBsb2NhbGUgJyArXG4gICAgICAgICAgICAgICAgICAgICdTZWUgaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9kZWZpbmUtbG9jYWxlLyBmb3IgbW9yZSBpbmZvLicpO1xuICAgICAgICAgICAgcGFyZW50Q29uZmlnID0gbG9jYWxlc1tuYW1lXS5fY29uZmlnO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbmZpZy5wYXJlbnRMb2NhbGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGxvY2FsZXNbY29uZmlnLnBhcmVudExvY2FsZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHBhcmVudENvbmZpZyA9IGxvY2FsZXNbY29uZmlnLnBhcmVudExvY2FsZV0uX2NvbmZpZztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCFsb2NhbGVGYW1pbGllc1tjb25maWcucGFyZW50TG9jYWxlXSkge1xuICAgICAgICAgICAgICAgICAgICBsb2NhbGVGYW1pbGllc1tjb25maWcucGFyZW50TG9jYWxlXSA9IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsb2NhbGVGYW1pbGllc1tjb25maWcucGFyZW50TG9jYWxlXS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnOiBjb25maWdcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsb2NhbGVzW25hbWVdID0gbmV3IExvY2FsZShtZXJnZUNvbmZpZ3MocGFyZW50Q29uZmlnLCBjb25maWcpKTtcblxuICAgICAgICBpZiAobG9jYWxlRmFtaWxpZXNbbmFtZV0pIHtcbiAgICAgICAgICAgIGxvY2FsZUZhbWlsaWVzW25hbWVdLmZvckVhY2goZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgICBkZWZpbmVMb2NhbGUoeC5uYW1lLCB4LmNvbmZpZyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGJhY2t3YXJkcyBjb21wYXQgZm9yIG5vdzogYWxzbyBzZXQgdGhlIGxvY2FsZVxuICAgICAgICAvLyBtYWtlIHN1cmUgd2Ugc2V0IHRoZSBsb2NhbGUgQUZURVIgYWxsIGNoaWxkIGxvY2FsZXMgaGF2ZSBiZWVuXG4gICAgICAgIC8vIGNyZWF0ZWQsIHNvIHdlIHdvbid0IGVuZCB1cCB3aXRoIHRoZSBjaGlsZCBsb2NhbGUgc2V0LlxuICAgICAgICBnZXRTZXRHbG9iYWxMb2NhbGUobmFtZSk7XG5cblxuICAgICAgICByZXR1cm4gbG9jYWxlc1tuYW1lXTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyB1c2VmdWwgZm9yIHRlc3RpbmdcbiAgICAgICAgZGVsZXRlIGxvY2FsZXNbbmFtZV07XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlTG9jYWxlKG5hbWUsIGNvbmZpZykge1xuICAgIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgICAgICB2YXIgbG9jYWxlLCB0bXBMb2NhbGUsIHBhcmVudENvbmZpZyA9IGJhc2VDb25maWc7XG4gICAgICAgIC8vIE1FUkdFXG4gICAgICAgIHRtcExvY2FsZSA9IGxvYWRMb2NhbGUobmFtZSk7XG4gICAgICAgIGlmICh0bXBMb2NhbGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgcGFyZW50Q29uZmlnID0gdG1wTG9jYWxlLl9jb25maWc7XG4gICAgICAgIH1cbiAgICAgICAgY29uZmlnID0gbWVyZ2VDb25maWdzKHBhcmVudENvbmZpZywgY29uZmlnKTtcbiAgICAgICAgbG9jYWxlID0gbmV3IExvY2FsZShjb25maWcpO1xuICAgICAgICBsb2NhbGUucGFyZW50TG9jYWxlID0gbG9jYWxlc1tuYW1lXTtcbiAgICAgICAgbG9jYWxlc1tuYW1lXSA9IGxvY2FsZTtcblxuICAgICAgICAvLyBiYWNrd2FyZHMgY29tcGF0IGZvciBub3c6IGFsc28gc2V0IHRoZSBsb2NhbGVcbiAgICAgICAgZ2V0U2V0R2xvYmFsTG9jYWxlKG5hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHBhc3MgbnVsbCBmb3IgY29uZmlnIHRvIHVudXBkYXRlLCB1c2VmdWwgZm9yIHRlc3RzXG4gICAgICAgIGlmIChsb2NhbGVzW25hbWVdICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChsb2NhbGVzW25hbWVdLnBhcmVudExvY2FsZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxlc1tuYW1lXSA9IGxvY2FsZXNbbmFtZV0ucGFyZW50TG9jYWxlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChsb2NhbGVzW25hbWVdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgbG9jYWxlc1tuYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbG9jYWxlc1tuYW1lXTtcbn1cblxuLy8gcmV0dXJucyBsb2NhbGUgZGF0YVxuZnVuY3Rpb24gZ2V0TG9jYWxlIChrZXkpIHtcbiAgICB2YXIgbG9jYWxlO1xuXG4gICAgaWYgKGtleSAmJiBrZXkuX2xvY2FsZSAmJiBrZXkuX2xvY2FsZS5fYWJicikge1xuICAgICAgICBrZXkgPSBrZXkuX2xvY2FsZS5fYWJicjtcbiAgICB9XG5cbiAgICBpZiAoIWtleSkge1xuICAgICAgICByZXR1cm4gZ2xvYmFsTG9jYWxlO1xuICAgIH1cblxuICAgIGlmICghaXNBcnJheShrZXkpKSB7XG4gICAgICAgIC8vc2hvcnQtY2lyY3VpdCBldmVyeXRoaW5nIGVsc2VcbiAgICAgICAgbG9jYWxlID0gbG9hZExvY2FsZShrZXkpO1xuICAgICAgICBpZiAobG9jYWxlKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxlO1xuICAgICAgICB9XG4gICAgICAgIGtleSA9IFtrZXldO1xuICAgIH1cblxuICAgIHJldHVybiBjaG9vc2VMb2NhbGUoa2V5KTtcbn1cblxuZnVuY3Rpb24gbGlzdExvY2FsZXMoKSB7XG4gICAgcmV0dXJuIGtleXMobG9jYWxlcyk7XG59XG5cbmZ1bmN0aW9uIGNoZWNrT3ZlcmZsb3cgKG0pIHtcbiAgICB2YXIgb3ZlcmZsb3c7XG4gICAgdmFyIGEgPSBtLl9hO1xuXG4gICAgaWYgKGEgJiYgZ2V0UGFyc2luZ0ZsYWdzKG0pLm92ZXJmbG93ID09PSAtMikge1xuICAgICAgICBvdmVyZmxvdyA9XG4gICAgICAgICAgICBhW01PTlRIXSAgICAgICA8IDAgfHwgYVtNT05USF0gICAgICAgPiAxMSAgPyBNT05USCA6XG4gICAgICAgICAgICBhW0RBVEVdICAgICAgICA8IDEgfHwgYVtEQVRFXSAgICAgICAgPiBkYXlzSW5Nb250aChhW1lFQVJdLCBhW01PTlRIXSkgPyBEQVRFIDpcbiAgICAgICAgICAgIGFbSE9VUl0gICAgICAgIDwgMCB8fCBhW0hPVVJdICAgICAgICA+IDI0IHx8IChhW0hPVVJdID09PSAyNCAmJiAoYVtNSU5VVEVdICE9PSAwIHx8IGFbU0VDT05EXSAhPT0gMCB8fCBhW01JTExJU0VDT05EXSAhPT0gMCkpID8gSE9VUiA6XG4gICAgICAgICAgICBhW01JTlVURV0gICAgICA8IDAgfHwgYVtNSU5VVEVdICAgICAgPiA1OSAgPyBNSU5VVEUgOlxuICAgICAgICAgICAgYVtTRUNPTkRdICAgICAgPCAwIHx8IGFbU0VDT05EXSAgICAgID4gNTkgID8gU0VDT05EIDpcbiAgICAgICAgICAgIGFbTUlMTElTRUNPTkRdIDwgMCB8fCBhW01JTExJU0VDT05EXSA+IDk5OSA/IE1JTExJU0VDT05EIDpcbiAgICAgICAgICAgIC0xO1xuXG4gICAgICAgIGlmIChnZXRQYXJzaW5nRmxhZ3MobSkuX292ZXJmbG93RGF5T2ZZZWFyICYmIChvdmVyZmxvdyA8IFlFQVIgfHwgb3ZlcmZsb3cgPiBEQVRFKSkge1xuICAgICAgICAgICAgb3ZlcmZsb3cgPSBEQVRFO1xuICAgICAgICB9XG4gICAgICAgIGlmIChnZXRQYXJzaW5nRmxhZ3MobSkuX292ZXJmbG93V2Vla3MgJiYgb3ZlcmZsb3cgPT09IC0xKSB7XG4gICAgICAgICAgICBvdmVyZmxvdyA9IFdFRUs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdldFBhcnNpbmdGbGFncyhtKS5fb3ZlcmZsb3dXZWVrZGF5ICYmIG92ZXJmbG93ID09PSAtMSkge1xuICAgICAgICAgICAgb3ZlcmZsb3cgPSBXRUVLREFZO1xuICAgICAgICB9XG5cbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKG0pLm92ZXJmbG93ID0gb3ZlcmZsb3c7XG4gICAgfVxuXG4gICAgcmV0dXJuIG07XG59XG5cbi8vIFBpY2sgdGhlIGZpcnN0IGRlZmluZWQgb2YgdHdvIG9yIHRocmVlIGFyZ3VtZW50cy5cbmZ1bmN0aW9uIGRlZmF1bHRzKGEsIGIsIGMpIHtcbiAgICBpZiAoYSAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBhO1xuICAgIH1cbiAgICBpZiAoYiAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBiO1xuICAgIH1cbiAgICByZXR1cm4gYztcbn1cblxuZnVuY3Rpb24gY3VycmVudERhdGVBcnJheShjb25maWcpIHtcbiAgICAvLyBob29rcyBpcyBhY3R1YWxseSB0aGUgZXhwb3J0ZWQgbW9tZW50IG9iamVjdFxuICAgIHZhciBub3dWYWx1ZSA9IG5ldyBEYXRlKGhvb2tzLm5vdygpKTtcbiAgICBpZiAoY29uZmlnLl91c2VVVEMpIHtcbiAgICAgICAgcmV0dXJuIFtub3dWYWx1ZS5nZXRVVENGdWxsWWVhcigpLCBub3dWYWx1ZS5nZXRVVENNb250aCgpLCBub3dWYWx1ZS5nZXRVVENEYXRlKCldO1xuICAgIH1cbiAgICByZXR1cm4gW25vd1ZhbHVlLmdldEZ1bGxZZWFyKCksIG5vd1ZhbHVlLmdldE1vbnRoKCksIG5vd1ZhbHVlLmdldERhdGUoKV07XG59XG5cbi8vIGNvbnZlcnQgYW4gYXJyYXkgdG8gYSBkYXRlLlxuLy8gdGhlIGFycmF5IHNob3VsZCBtaXJyb3IgdGhlIHBhcmFtZXRlcnMgYmVsb3dcbi8vIG5vdGU6IGFsbCB2YWx1ZXMgcGFzdCB0aGUgeWVhciBhcmUgb3B0aW9uYWwgYW5kIHdpbGwgZGVmYXVsdCB0byB0aGUgbG93ZXN0IHBvc3NpYmxlIHZhbHVlLlxuLy8gW3llYXIsIG1vbnRoLCBkYXkgLCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmRdXG5mdW5jdGlvbiBjb25maWdGcm9tQXJyYXkgKGNvbmZpZykge1xuICAgIHZhciBpLCBkYXRlLCBpbnB1dCA9IFtdLCBjdXJyZW50RGF0ZSwgZXhwZWN0ZWRXZWVrZGF5LCB5ZWFyVG9Vc2U7XG5cbiAgICBpZiAoY29uZmlnLl9kKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjdXJyZW50RGF0ZSA9IGN1cnJlbnREYXRlQXJyYXkoY29uZmlnKTtcblxuICAgIC8vY29tcHV0ZSBkYXkgb2YgdGhlIHllYXIgZnJvbSB3ZWVrcyBhbmQgd2Vla2RheXNcbiAgICBpZiAoY29uZmlnLl93ICYmIGNvbmZpZy5fYVtEQVRFXSA9PSBudWxsICYmIGNvbmZpZy5fYVtNT05USF0gPT0gbnVsbCkge1xuICAgICAgICBkYXlPZlllYXJGcm9tV2Vla0luZm8oY29uZmlnKTtcbiAgICB9XG5cbiAgICAvL2lmIHRoZSBkYXkgb2YgdGhlIHllYXIgaXMgc2V0LCBmaWd1cmUgb3V0IHdoYXQgaXQgaXNcbiAgICBpZiAoY29uZmlnLl9kYXlPZlllYXIgIT0gbnVsbCkge1xuICAgICAgICB5ZWFyVG9Vc2UgPSBkZWZhdWx0cyhjb25maWcuX2FbWUVBUl0sIGN1cnJlbnREYXRlW1lFQVJdKTtcblxuICAgICAgICBpZiAoY29uZmlnLl9kYXlPZlllYXIgPiBkYXlzSW5ZZWFyKHllYXJUb1VzZSkgfHwgY29uZmlnLl9kYXlPZlllYXIgPT09IDApIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLl9vdmVyZmxvd0RheU9mWWVhciA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBkYXRlID0gY3JlYXRlVVRDRGF0ZSh5ZWFyVG9Vc2UsIDAsIGNvbmZpZy5fZGF5T2ZZZWFyKTtcbiAgICAgICAgY29uZmlnLl9hW01PTlRIXSA9IGRhdGUuZ2V0VVRDTW9udGgoKTtcbiAgICAgICAgY29uZmlnLl9hW0RBVEVdID0gZGF0ZS5nZXRVVENEYXRlKCk7XG4gICAgfVxuXG4gICAgLy8gRGVmYXVsdCB0byBjdXJyZW50IGRhdGUuXG4gICAgLy8gKiBpZiBubyB5ZWFyLCBtb250aCwgZGF5IG9mIG1vbnRoIGFyZSBnaXZlbiwgZGVmYXVsdCB0byB0b2RheVxuICAgIC8vICogaWYgZGF5IG9mIG1vbnRoIGlzIGdpdmVuLCBkZWZhdWx0IG1vbnRoIGFuZCB5ZWFyXG4gICAgLy8gKiBpZiBtb250aCBpcyBnaXZlbiwgZGVmYXVsdCBvbmx5IHllYXJcbiAgICAvLyAqIGlmIHllYXIgaXMgZ2l2ZW4sIGRvbid0IGRlZmF1bHQgYW55dGhpbmdcbiAgICBmb3IgKGkgPSAwOyBpIDwgMyAmJiBjb25maWcuX2FbaV0gPT0gbnVsbDsgKytpKSB7XG4gICAgICAgIGNvbmZpZy5fYVtpXSA9IGlucHV0W2ldID0gY3VycmVudERhdGVbaV07XG4gICAgfVxuXG4gICAgLy8gWmVybyBvdXQgd2hhdGV2ZXIgd2FzIG5vdCBkZWZhdWx0ZWQsIGluY2x1ZGluZyB0aW1lXG4gICAgZm9yICg7IGkgPCA3OyBpKyspIHtcbiAgICAgICAgY29uZmlnLl9hW2ldID0gaW5wdXRbaV0gPSAoY29uZmlnLl9hW2ldID09IG51bGwpID8gKGkgPT09IDIgPyAxIDogMCkgOiBjb25maWcuX2FbaV07XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgZm9yIDI0OjAwOjAwLjAwMFxuICAgIGlmIChjb25maWcuX2FbSE9VUl0gPT09IDI0ICYmXG4gICAgICAgICAgICBjb25maWcuX2FbTUlOVVRFXSA9PT0gMCAmJlxuICAgICAgICAgICAgY29uZmlnLl9hW1NFQ09ORF0gPT09IDAgJiZcbiAgICAgICAgICAgIGNvbmZpZy5fYVtNSUxMSVNFQ09ORF0gPT09IDApIHtcbiAgICAgICAgY29uZmlnLl9uZXh0RGF5ID0gdHJ1ZTtcbiAgICAgICAgY29uZmlnLl9hW0hPVVJdID0gMDtcbiAgICB9XG5cbiAgICBjb25maWcuX2QgPSAoY29uZmlnLl91c2VVVEMgPyBjcmVhdGVVVENEYXRlIDogY3JlYXRlRGF0ZSkuYXBwbHkobnVsbCwgaW5wdXQpO1xuICAgIGV4cGVjdGVkV2Vla2RheSA9IGNvbmZpZy5fdXNlVVRDID8gY29uZmlnLl9kLmdldFVUQ0RheSgpIDogY29uZmlnLl9kLmdldERheSgpO1xuXG4gICAgLy8gQXBwbHkgdGltZXpvbmUgb2Zmc2V0IGZyb20gaW5wdXQuIFRoZSBhY3R1YWwgdXRjT2Zmc2V0IGNhbiBiZSBjaGFuZ2VkXG4gICAgLy8gd2l0aCBwYXJzZVpvbmUuXG4gICAgaWYgKGNvbmZpZy5fdHptICE9IG51bGwpIHtcbiAgICAgICAgY29uZmlnLl9kLnNldFVUQ01pbnV0ZXMoY29uZmlnLl9kLmdldFVUQ01pbnV0ZXMoKSAtIGNvbmZpZy5fdHptKTtcbiAgICB9XG5cbiAgICBpZiAoY29uZmlnLl9uZXh0RGF5KSB7XG4gICAgICAgIGNvbmZpZy5fYVtIT1VSXSA9IDI0O1xuICAgIH1cblxuICAgIC8vIGNoZWNrIGZvciBtaXNtYXRjaGluZyBkYXkgb2Ygd2Vla1xuICAgIGlmIChjb25maWcuX3cgJiYgdHlwZW9mIGNvbmZpZy5fdy5kICE9PSAndW5kZWZpbmVkJyAmJiBjb25maWcuX3cuZCAhPT0gZXhwZWN0ZWRXZWVrZGF5KSB7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLndlZWtkYXlNaXNtYXRjaCA9IHRydWU7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkYXlPZlllYXJGcm9tV2Vla0luZm8oY29uZmlnKSB7XG4gICAgdmFyIHcsIHdlZWtZZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSwgdGVtcCwgd2Vla2RheU92ZXJmbG93O1xuXG4gICAgdyA9IGNvbmZpZy5fdztcbiAgICBpZiAody5HRyAhPSBudWxsIHx8IHcuVyAhPSBudWxsIHx8IHcuRSAhPSBudWxsKSB7XG4gICAgICAgIGRvdyA9IDE7XG4gICAgICAgIGRveSA9IDQ7XG5cbiAgICAgICAgLy8gVE9ETzogV2UgbmVlZCB0byB0YWtlIHRoZSBjdXJyZW50IGlzb1dlZWtZZWFyLCBidXQgdGhhdCBkZXBlbmRzIG9uXG4gICAgICAgIC8vIGhvdyB3ZSBpbnRlcnByZXQgbm93IChsb2NhbCwgdXRjLCBmaXhlZCBvZmZzZXQpLiBTbyBjcmVhdGVcbiAgICAgICAgLy8gYSBub3cgdmVyc2lvbiBvZiBjdXJyZW50IGNvbmZpZyAodGFrZSBsb2NhbC91dGMvb2Zmc2V0IGZsYWdzLCBhbmRcbiAgICAgICAgLy8gY3JlYXRlIG5vdykuXG4gICAgICAgIHdlZWtZZWFyID0gZGVmYXVsdHMody5HRywgY29uZmlnLl9hW1lFQVJdLCB3ZWVrT2ZZZWFyKGNyZWF0ZUxvY2FsKCksIDEsIDQpLnllYXIpO1xuICAgICAgICB3ZWVrID0gZGVmYXVsdHMody5XLCAxKTtcbiAgICAgICAgd2Vla2RheSA9IGRlZmF1bHRzKHcuRSwgMSk7XG4gICAgICAgIGlmICh3ZWVrZGF5IDwgMSB8fCB3ZWVrZGF5ID4gNykge1xuICAgICAgICAgICAgd2Vla2RheU92ZXJmbG93ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGRvdyA9IGNvbmZpZy5fbG9jYWxlLl93ZWVrLmRvdztcbiAgICAgICAgZG95ID0gY29uZmlnLl9sb2NhbGUuX3dlZWsuZG95O1xuXG4gICAgICAgIHZhciBjdXJXZWVrID0gd2Vla09mWWVhcihjcmVhdGVMb2NhbCgpLCBkb3csIGRveSk7XG5cbiAgICAgICAgd2Vla1llYXIgPSBkZWZhdWx0cyh3LmdnLCBjb25maWcuX2FbWUVBUl0sIGN1cldlZWsueWVhcik7XG5cbiAgICAgICAgLy8gRGVmYXVsdCB0byBjdXJyZW50IHdlZWsuXG4gICAgICAgIHdlZWsgPSBkZWZhdWx0cyh3LncsIGN1cldlZWsud2Vlayk7XG5cbiAgICAgICAgaWYgKHcuZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyB3ZWVrZGF5IC0tIGxvdyBkYXkgbnVtYmVycyBhcmUgY29uc2lkZXJlZCBuZXh0IHdlZWtcbiAgICAgICAgICAgIHdlZWtkYXkgPSB3LmQ7XG4gICAgICAgICAgICBpZiAod2Vla2RheSA8IDAgfHwgd2Vla2RheSA+IDYpIHtcbiAgICAgICAgICAgICAgICB3ZWVrZGF5T3ZlcmZsb3cgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHcuZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBsb2NhbCB3ZWVrZGF5IC0tIGNvdW50aW5nIHN0YXJ0cyBmcm9tIGJlZ2luaW5nIG9mIHdlZWtcbiAgICAgICAgICAgIHdlZWtkYXkgPSB3LmUgKyBkb3c7XG4gICAgICAgICAgICBpZiAody5lIDwgMCB8fCB3LmUgPiA2KSB7XG4gICAgICAgICAgICAgICAgd2Vla2RheU92ZXJmbG93ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGRlZmF1bHQgdG8gYmVnaW5pbmcgb2Ygd2Vla1xuICAgICAgICAgICAgd2Vla2RheSA9IGRvdztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAod2VlayA8IDEgfHwgd2VlayA+IHdlZWtzSW5ZZWFyKHdlZWtZZWFyLCBkb3csIGRveSkpIHtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuX292ZXJmbG93V2Vla3MgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAod2Vla2RheU92ZXJmbG93ICE9IG51bGwpIHtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuX292ZXJmbG93V2Vla2RheSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGVtcCA9IGRheU9mWWVhckZyb21XZWVrcyh3ZWVrWWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpO1xuICAgICAgICBjb25maWcuX2FbWUVBUl0gPSB0ZW1wLnllYXI7XG4gICAgICAgIGNvbmZpZy5fZGF5T2ZZZWFyID0gdGVtcC5kYXlPZlllYXI7XG4gICAgfVxufVxuXG4vLyBpc28gODYwMSByZWdleFxuLy8gMDAwMC0wMC0wMCAwMDAwLVcwMCBvciAwMDAwLVcwMC0wICsgVCArIDAwIG9yIDAwOjAwIG9yIDAwOjAwOjAwIG9yIDAwOjAwOjAwLjAwMCArICswMDowMCBvciArMDAwMCBvciArMDApXG52YXIgZXh0ZW5kZWRJc29SZWdleCA9IC9eXFxzKigoPzpbKy1dXFxkezZ9fFxcZHs0fSktKD86XFxkXFxkLVxcZFxcZHxXXFxkXFxkLVxcZHxXXFxkXFxkfFxcZFxcZFxcZHxcXGRcXGQpKSg/OihUfCApKFxcZFxcZCg/OjpcXGRcXGQoPzo6XFxkXFxkKD86Wy4sXVxcZCspPyk/KT8pKFtcXCtcXC1dXFxkXFxkKD86Oj9cXGRcXGQpP3xcXHMqWik/KT8kLztcbnZhciBiYXNpY0lzb1JlZ2V4ID0gL15cXHMqKCg/OlsrLV1cXGR7Nn18XFxkezR9KSg/OlxcZFxcZFxcZFxcZHxXXFxkXFxkXFxkfFdcXGRcXGR8XFxkXFxkXFxkfFxcZFxcZCkpKD86KFR8ICkoXFxkXFxkKD86XFxkXFxkKD86XFxkXFxkKD86Wy4sXVxcZCspPyk/KT8pKFtcXCtcXC1dXFxkXFxkKD86Oj9cXGRcXGQpP3xcXHMqWik/KT8kLztcblxudmFyIHR6UmVnZXggPSAvWnxbKy1dXFxkXFxkKD86Oj9cXGRcXGQpPy87XG5cbnZhciBpc29EYXRlcyA9IFtcbiAgICBbJ1lZWVlZWS1NTS1ERCcsIC9bKy1dXFxkezZ9LVxcZFxcZC1cXGRcXGQvXSxcbiAgICBbJ1lZWVktTU0tREQnLCAvXFxkezR9LVxcZFxcZC1cXGRcXGQvXSxcbiAgICBbJ0dHR0ctW1ddV1ctRScsIC9cXGR7NH0tV1xcZFxcZC1cXGQvXSxcbiAgICBbJ0dHR0ctW1ddV1cnLCAvXFxkezR9LVdcXGRcXGQvLCBmYWxzZV0sXG4gICAgWydZWVlZLURERCcsIC9cXGR7NH0tXFxkezN9L10sXG4gICAgWydZWVlZLU1NJywgL1xcZHs0fS1cXGRcXGQvLCBmYWxzZV0sXG4gICAgWydZWVlZWVlNTUREJywgL1srLV1cXGR7MTB9L10sXG4gICAgWydZWVlZTU1ERCcsIC9cXGR7OH0vXSxcbiAgICAvLyBZWVlZTU0gaXMgTk9UIGFsbG93ZWQgYnkgdGhlIHN0YW5kYXJkXG4gICAgWydHR0dHW1ddV1dFJywgL1xcZHs0fVdcXGR7M30vXSxcbiAgICBbJ0dHR0dbV11XVycsIC9cXGR7NH1XXFxkezJ9LywgZmFsc2VdLFxuICAgIFsnWVlZWURERCcsIC9cXGR7N30vXVxuXTtcblxuLy8gaXNvIHRpbWUgZm9ybWF0cyBhbmQgcmVnZXhlc1xudmFyIGlzb1RpbWVzID0gW1xuICAgIFsnSEg6bW06c3MuU1NTUycsIC9cXGRcXGQ6XFxkXFxkOlxcZFxcZFxcLlxcZCsvXSxcbiAgICBbJ0hIOm1tOnNzLFNTU1MnLCAvXFxkXFxkOlxcZFxcZDpcXGRcXGQsXFxkKy9dLFxuICAgIFsnSEg6bW06c3MnLCAvXFxkXFxkOlxcZFxcZDpcXGRcXGQvXSxcbiAgICBbJ0hIOm1tJywgL1xcZFxcZDpcXGRcXGQvXSxcbiAgICBbJ0hIbW1zcy5TU1NTJywgL1xcZFxcZFxcZFxcZFxcZFxcZFxcLlxcZCsvXSxcbiAgICBbJ0hIbW1zcyxTU1NTJywgL1xcZFxcZFxcZFxcZFxcZFxcZCxcXGQrL10sXG4gICAgWydISG1tc3MnLCAvXFxkXFxkXFxkXFxkXFxkXFxkL10sXG4gICAgWydISG1tJywgL1xcZFxcZFxcZFxcZC9dLFxuICAgIFsnSEgnLCAvXFxkXFxkL11cbl07XG5cbnZhciBhc3BOZXRKc29uUmVnZXggPSAvXlxcLz9EYXRlXFwoKFxcLT9cXGQrKS9pO1xuXG4vLyBkYXRlIGZyb20gaXNvIGZvcm1hdFxuZnVuY3Rpb24gY29uZmlnRnJvbUlTTyhjb25maWcpIHtcbiAgICB2YXIgaSwgbCxcbiAgICAgICAgc3RyaW5nID0gY29uZmlnLl9pLFxuICAgICAgICBtYXRjaCA9IGV4dGVuZGVkSXNvUmVnZXguZXhlYyhzdHJpbmcpIHx8IGJhc2ljSXNvUmVnZXguZXhlYyhzdHJpbmcpLFxuICAgICAgICBhbGxvd1RpbWUsIGRhdGVGb3JtYXQsIHRpbWVGb3JtYXQsIHR6Rm9ybWF0O1xuXG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmlzbyA9IHRydWU7XG5cbiAgICAgICAgZm9yIChpID0gMCwgbCA9IGlzb0RhdGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgaWYgKGlzb0RhdGVzW2ldWzFdLmV4ZWMobWF0Y2hbMV0pKSB7XG4gICAgICAgICAgICAgICAgZGF0ZUZvcm1hdCA9IGlzb0RhdGVzW2ldWzBdO1xuICAgICAgICAgICAgICAgIGFsbG93VGltZSA9IGlzb0RhdGVzW2ldWzJdICE9PSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0ZUZvcm1hdCA9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF0Y2hbM10pIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSBpc29UaW1lcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNvVGltZXNbaV1bMV0uZXhlYyhtYXRjaFszXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbWF0Y2hbMl0gc2hvdWxkIGJlICdUJyBvciBzcGFjZVxuICAgICAgICAgICAgICAgICAgICB0aW1lRm9ybWF0ID0gKG1hdGNoWzJdIHx8ICcgJykgKyBpc29UaW1lc1tpXVswXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRpbWVGb3JtYXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWFsbG93VGltZSAmJiB0aW1lRm9ybWF0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXRjaFs0XSkge1xuICAgICAgICAgICAgaWYgKHR6UmVnZXguZXhlYyhtYXRjaFs0XSkpIHtcbiAgICAgICAgICAgICAgICB0ekZvcm1hdCA9ICdaJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbmZpZy5fZiA9IGRhdGVGb3JtYXQgKyAodGltZUZvcm1hdCB8fCAnJykgKyAodHpGb3JtYXQgfHwgJycpO1xuICAgICAgICBjb25maWdGcm9tU3RyaW5nQW5kRm9ybWF0KGNvbmZpZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgfVxufVxuXG4vLyBSRkMgMjgyMiByZWdleDogRm9yIGRldGFpbHMgc2VlIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMyODIyI3NlY3Rpb24tMy4zXG52YXIgcmZjMjgyMiA9IC9eKD86KE1vbnxUdWV8V2VkfFRodXxGcml8U2F0fFN1biksP1xccyk/KFxcZHsxLDJ9KVxccyhKYW58RmVifE1hcnxBcHJ8TWF5fEp1bnxKdWx8QXVnfFNlcHxPY3R8Tm92fERlYylcXHMoXFxkezIsNH0pXFxzKFxcZFxcZCk6KFxcZFxcZCkoPzo6KFxcZFxcZCkpP1xccyg/OihVVHxHTVR8W0VDTVBdW1NEXVQpfChbWnpdKXwoWystXVxcZHs0fSkpJC87XG5cbmZ1bmN0aW9uIGV4dHJhY3RGcm9tUkZDMjgyMlN0cmluZ3MoeWVhclN0ciwgbW9udGhTdHIsIGRheVN0ciwgaG91clN0ciwgbWludXRlU3RyLCBzZWNvbmRTdHIpIHtcbiAgICB2YXIgcmVzdWx0ID0gW1xuICAgICAgICB1bnRydW5jYXRlWWVhcih5ZWFyU3RyKSxcbiAgICAgICAgZGVmYXVsdExvY2FsZU1vbnRoc1Nob3J0LmluZGV4T2YobW9udGhTdHIpLFxuICAgICAgICBwYXJzZUludChkYXlTdHIsIDEwKSxcbiAgICAgICAgcGFyc2VJbnQoaG91clN0ciwgMTApLFxuICAgICAgICBwYXJzZUludChtaW51dGVTdHIsIDEwKVxuICAgIF07XG5cbiAgICBpZiAoc2Vjb25kU3RyKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHBhcnNlSW50KHNlY29uZFN0ciwgMTApKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiB1bnRydW5jYXRlWWVhcih5ZWFyU3RyKSB7XG4gICAgdmFyIHllYXIgPSBwYXJzZUludCh5ZWFyU3RyLCAxMCk7XG4gICAgaWYgKHllYXIgPD0gNDkpIHtcbiAgICAgICAgcmV0dXJuIDIwMDAgKyB5ZWFyO1xuICAgIH0gZWxzZSBpZiAoeWVhciA8PSA5OTkpIHtcbiAgICAgICAgcmV0dXJuIDE5MDAgKyB5ZWFyO1xuICAgIH1cbiAgICByZXR1cm4geWVhcjtcbn1cblxuZnVuY3Rpb24gcHJlcHJvY2Vzc1JGQzI4MjIocykge1xuICAgIC8vIFJlbW92ZSBjb21tZW50cyBhbmQgZm9sZGluZyB3aGl0ZXNwYWNlIGFuZCByZXBsYWNlIG11bHRpcGxlLXNwYWNlcyB3aXRoIGEgc2luZ2xlIHNwYWNlXG4gICAgcmV0dXJuIHMucmVwbGFjZSgvXFwoW14pXSpcXCl8W1xcblxcdF0vZywgJyAnKS5yZXBsYWNlKC8oXFxzXFxzKykvZywgJyAnKS50cmltKCk7XG59XG5cbmZ1bmN0aW9uIGNoZWNrV2Vla2RheSh3ZWVrZGF5U3RyLCBwYXJzZWRJbnB1dCwgY29uZmlnKSB7XG4gICAgaWYgKHdlZWtkYXlTdHIpIHtcbiAgICAgICAgLy8gVE9ETzogUmVwbGFjZSB0aGUgdmFuaWxsYSBKUyBEYXRlIG9iamVjdCB3aXRoIGFuIGluZGVwZW50ZW50IGRheS1vZi13ZWVrIGNoZWNrLlxuICAgICAgICB2YXIgd2Vla2RheVByb3ZpZGVkID0gZGVmYXVsdExvY2FsZVdlZWtkYXlzU2hvcnQuaW5kZXhPZih3ZWVrZGF5U3RyKSxcbiAgICAgICAgICAgIHdlZWtkYXlBY3R1YWwgPSBuZXcgRGF0ZShwYXJzZWRJbnB1dFswXSwgcGFyc2VkSW5wdXRbMV0sIHBhcnNlZElucHV0WzJdKS5nZXREYXkoKTtcbiAgICAgICAgaWYgKHdlZWtkYXlQcm92aWRlZCAhPT0gd2Vla2RheUFjdHVhbCkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykud2Vla2RheU1pc21hdGNoID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuXG52YXIgb2JzT2Zmc2V0cyA9IHtcbiAgICBVVDogMCxcbiAgICBHTVQ6IDAsXG4gICAgRURUOiAtNCAqIDYwLFxuICAgIEVTVDogLTUgKiA2MCxcbiAgICBDRFQ6IC01ICogNjAsXG4gICAgQ1NUOiAtNiAqIDYwLFxuICAgIE1EVDogLTYgKiA2MCxcbiAgICBNU1Q6IC03ICogNjAsXG4gICAgUERUOiAtNyAqIDYwLFxuICAgIFBTVDogLTggKiA2MFxufTtcblxuZnVuY3Rpb24gY2FsY3VsYXRlT2Zmc2V0KG9ic09mZnNldCwgbWlsaXRhcnlPZmZzZXQsIG51bU9mZnNldCkge1xuICAgIGlmIChvYnNPZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIG9ic09mZnNldHNbb2JzT2Zmc2V0XTtcbiAgICB9IGVsc2UgaWYgKG1pbGl0YXJ5T2Zmc2V0KSB7XG4gICAgICAgIC8vIHRoZSBvbmx5IGFsbG93ZWQgbWlsaXRhcnkgdHogaXMgWlxuICAgICAgICByZXR1cm4gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgaG0gPSBwYXJzZUludChudW1PZmZzZXQsIDEwKTtcbiAgICAgICAgdmFyIG0gPSBobSAlIDEwMCwgaCA9IChobSAtIG0pIC8gMTAwO1xuICAgICAgICByZXR1cm4gaCAqIDYwICsgbTtcbiAgICB9XG59XG5cbi8vIGRhdGUgYW5kIHRpbWUgZnJvbSByZWYgMjgyMiBmb3JtYXRcbmZ1bmN0aW9uIGNvbmZpZ0Zyb21SRkMyODIyKGNvbmZpZykge1xuICAgIHZhciBtYXRjaCA9IHJmYzI4MjIuZXhlYyhwcmVwcm9jZXNzUkZDMjgyMihjb25maWcuX2kpKTtcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgdmFyIHBhcnNlZEFycmF5ID0gZXh0cmFjdEZyb21SRkMyODIyU3RyaW5ncyhtYXRjaFs0XSwgbWF0Y2hbM10sIG1hdGNoWzJdLCBtYXRjaFs1XSwgbWF0Y2hbNl0sIG1hdGNoWzddKTtcbiAgICAgICAgaWYgKCFjaGVja1dlZWtkYXkobWF0Y2hbMV0sIHBhcnNlZEFycmF5LCBjb25maWcpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25maWcuX2EgPSBwYXJzZWRBcnJheTtcbiAgICAgICAgY29uZmlnLl90em0gPSBjYWxjdWxhdGVPZmZzZXQobWF0Y2hbOF0sIG1hdGNoWzldLCBtYXRjaFsxMF0pO1xuXG4gICAgICAgIGNvbmZpZy5fZCA9IGNyZWF0ZVVUQ0RhdGUuYXBwbHkobnVsbCwgY29uZmlnLl9hKTtcbiAgICAgICAgY29uZmlnLl9kLnNldFVUQ01pbnV0ZXMoY29uZmlnLl9kLmdldFVUQ01pbnV0ZXMoKSAtIGNvbmZpZy5fdHptKTtcblxuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5yZmMyODIyID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICB9XG59XG5cbi8vIGRhdGUgZnJvbSBpc28gZm9ybWF0IG9yIGZhbGxiYWNrXG5mdW5jdGlvbiBjb25maWdGcm9tU3RyaW5nKGNvbmZpZykge1xuICAgIHZhciBtYXRjaGVkID0gYXNwTmV0SnNvblJlZ2V4LmV4ZWMoY29uZmlnLl9pKTtcblxuICAgIGlmIChtYXRjaGVkICE9PSBudWxsKSB7XG4gICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKCttYXRjaGVkWzFdKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbmZpZ0Zyb21JU08oY29uZmlnKTtcbiAgICBpZiAoY29uZmlnLl9pc1ZhbGlkID09PSBmYWxzZSkge1xuICAgICAgICBkZWxldGUgY29uZmlnLl9pc1ZhbGlkO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25maWdGcm9tUkZDMjgyMihjb25maWcpO1xuICAgIGlmIChjb25maWcuX2lzVmFsaWQgPT09IGZhbHNlKSB7XG4gICAgICAgIGRlbGV0ZSBjb25maWcuX2lzVmFsaWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEZpbmFsIGF0dGVtcHQsIHVzZSBJbnB1dCBGYWxsYmFja1xuICAgIGhvb2tzLmNyZWF0ZUZyb21JbnB1dEZhbGxiYWNrKGNvbmZpZyk7XG59XG5cbmhvb2tzLmNyZWF0ZUZyb21JbnB1dEZhbGxiYWNrID0gZGVwcmVjYXRlKFxuICAgICd2YWx1ZSBwcm92aWRlZCBpcyBub3QgaW4gYSByZWNvZ25pemVkIFJGQzI4MjIgb3IgSVNPIGZvcm1hdC4gbW9tZW50IGNvbnN0cnVjdGlvbiBmYWxscyBiYWNrIHRvIGpzIERhdGUoKSwgJyArXG4gICAgJ3doaWNoIGlzIG5vdCByZWxpYWJsZSBhY3Jvc3MgYWxsIGJyb3dzZXJzIGFuZCB2ZXJzaW9ucy4gTm9uIFJGQzI4MjIvSVNPIGRhdGUgZm9ybWF0cyBhcmUgJyArXG4gICAgJ2Rpc2NvdXJhZ2VkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gYW4gdXBjb21pbmcgbWFqb3IgcmVsZWFzZS4gUGxlYXNlIHJlZmVyIHRvICcgK1xuICAgICdodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL2pzLWRhdGUvIGZvciBtb3JlIGluZm8uJyxcbiAgICBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKGNvbmZpZy5faSArIChjb25maWcuX3VzZVVUQyA/ICcgVVRDJyA6ICcnKSk7XG4gICAgfVxuKTtcblxuLy8gY29uc3RhbnQgdGhhdCByZWZlcnMgdG8gdGhlIElTTyBzdGFuZGFyZFxuaG9va3MuSVNPXzg2MDEgPSBmdW5jdGlvbiAoKSB7fTtcblxuLy8gY29uc3RhbnQgdGhhdCByZWZlcnMgdG8gdGhlIFJGQyAyODIyIGZvcm1cbmhvb2tzLlJGQ18yODIyID0gZnVuY3Rpb24gKCkge307XG5cbi8vIGRhdGUgZnJvbSBzdHJpbmcgYW5kIGZvcm1hdCBzdHJpbmdcbmZ1bmN0aW9uIGNvbmZpZ0Zyb21TdHJpbmdBbmRGb3JtYXQoY29uZmlnKSB7XG4gICAgLy8gVE9ETzogTW92ZSB0aGlzIHRvIGFub3RoZXIgcGFydCBvZiB0aGUgY3JlYXRpb24gZmxvdyB0byBwcmV2ZW50IGNpcmN1bGFyIGRlcHNcbiAgICBpZiAoY29uZmlnLl9mID09PSBob29rcy5JU09fODYwMSkge1xuICAgICAgICBjb25maWdGcm9tSVNPKGNvbmZpZyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGNvbmZpZy5fZiA9PT0gaG9va3MuUkZDXzI4MjIpIHtcbiAgICAgICAgY29uZmlnRnJvbVJGQzI4MjIoY29uZmlnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25maWcuX2EgPSBbXTtcbiAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5lbXB0eSA9IHRydWU7XG5cbiAgICAvLyBUaGlzIGFycmF5IGlzIHVzZWQgdG8gbWFrZSBhIERhdGUsIGVpdGhlciB3aXRoIGBuZXcgRGF0ZWAgb3IgYERhdGUuVVRDYFxuICAgIHZhciBzdHJpbmcgPSAnJyArIGNvbmZpZy5faSxcbiAgICAgICAgaSwgcGFyc2VkSW5wdXQsIHRva2VucywgdG9rZW4sIHNraXBwZWQsXG4gICAgICAgIHN0cmluZ0xlbmd0aCA9IHN0cmluZy5sZW5ndGgsXG4gICAgICAgIHRvdGFsUGFyc2VkSW5wdXRMZW5ndGggPSAwO1xuXG4gICAgdG9rZW5zID0gZXhwYW5kRm9ybWF0KGNvbmZpZy5fZiwgY29uZmlnLl9sb2NhbGUpLm1hdGNoKGZvcm1hdHRpbmdUb2tlbnMpIHx8IFtdO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0b2tlbiA9IHRva2Vuc1tpXTtcbiAgICAgICAgcGFyc2VkSW5wdXQgPSAoc3RyaW5nLm1hdGNoKGdldFBhcnNlUmVnZXhGb3JUb2tlbih0b2tlbiwgY29uZmlnKSkgfHwgW10pWzBdO1xuICAgICAgICAvLyBjb25zb2xlLmxvZygndG9rZW4nLCB0b2tlbiwgJ3BhcnNlZElucHV0JywgcGFyc2VkSW5wdXQsXG4gICAgICAgIC8vICAgICAgICAgJ3JlZ2V4JywgZ2V0UGFyc2VSZWdleEZvclRva2VuKHRva2VuLCBjb25maWcpKTtcbiAgICAgICAgaWYgKHBhcnNlZElucHV0KSB7XG4gICAgICAgICAgICBza2lwcGVkID0gc3RyaW5nLnN1YnN0cigwLCBzdHJpbmcuaW5kZXhPZihwYXJzZWRJbnB1dCkpO1xuICAgICAgICAgICAgaWYgKHNraXBwZWQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnVudXNlZElucHV0LnB1c2goc2tpcHBlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHJpbmcgPSBzdHJpbmcuc2xpY2Uoc3RyaW5nLmluZGV4T2YocGFyc2VkSW5wdXQpICsgcGFyc2VkSW5wdXQubGVuZ3RoKTtcbiAgICAgICAgICAgIHRvdGFsUGFyc2VkSW5wdXRMZW5ndGggKz0gcGFyc2VkSW5wdXQubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIC8vIGRvbid0IHBhcnNlIGlmIGl0J3Mgbm90IGEga25vd24gdG9rZW5cbiAgICAgICAgaWYgKGZvcm1hdFRva2VuRnVuY3Rpb25zW3Rva2VuXSkge1xuICAgICAgICAgICAgaWYgKHBhcnNlZElucHV0KSB7XG4gICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuZW1wdHkgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnVudXNlZFRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFkZFRpbWVUb0FycmF5RnJvbVRva2VuKHRva2VuLCBwYXJzZWRJbnB1dCwgY29uZmlnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb25maWcuX3N0cmljdCAmJiAhcGFyc2VkSW5wdXQpIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnVudXNlZFRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGFkZCByZW1haW5pbmcgdW5wYXJzZWQgaW5wdXQgbGVuZ3RoIHRvIHRoZSBzdHJpbmdcbiAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5jaGFyc0xlZnRPdmVyID0gc3RyaW5nTGVuZ3RoIC0gdG90YWxQYXJzZWRJbnB1dExlbmd0aDtcbiAgICBpZiAoc3RyaW5nLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykudW51c2VkSW5wdXQucHVzaChzdHJpbmcpO1xuICAgIH1cblxuICAgIC8vIGNsZWFyIF8xMmggZmxhZyBpZiBob3VyIGlzIDw9IDEyXG4gICAgaWYgKGNvbmZpZy5fYVtIT1VSXSA8PSAxMiAmJlxuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5iaWdIb3VyID09PSB0cnVlICYmXG4gICAgICAgIGNvbmZpZy5fYVtIT1VSXSA+IDApIHtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5wYXJzZWREYXRlUGFydHMgPSBjb25maWcuX2Euc2xpY2UoMCk7XG4gICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykubWVyaWRpZW0gPSBjb25maWcuX21lcmlkaWVtO1xuICAgIC8vIGhhbmRsZSBtZXJpZGllbVxuICAgIGNvbmZpZy5fYVtIT1VSXSA9IG1lcmlkaWVtRml4V3JhcChjb25maWcuX2xvY2FsZSwgY29uZmlnLl9hW0hPVVJdLCBjb25maWcuX21lcmlkaWVtKTtcblxuICAgIGNvbmZpZ0Zyb21BcnJheShjb25maWcpO1xuICAgIGNoZWNrT3ZlcmZsb3coY29uZmlnKTtcbn1cblxuXG5mdW5jdGlvbiBtZXJpZGllbUZpeFdyYXAgKGxvY2FsZSwgaG91ciwgbWVyaWRpZW0pIHtcbiAgICB2YXIgaXNQbTtcblxuICAgIGlmIChtZXJpZGllbSA9PSBudWxsKSB7XG4gICAgICAgIC8vIG5vdGhpbmcgdG8gZG9cbiAgICAgICAgcmV0dXJuIGhvdXI7XG4gICAgfVxuICAgIGlmIChsb2NhbGUubWVyaWRpZW1Ib3VyICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS5tZXJpZGllbUhvdXIoaG91ciwgbWVyaWRpZW0pO1xuICAgIH0gZWxzZSBpZiAobG9jYWxlLmlzUE0gIT0gbnVsbCkge1xuICAgICAgICAvLyBGYWxsYmFja1xuICAgICAgICBpc1BtID0gbG9jYWxlLmlzUE0obWVyaWRpZW0pO1xuICAgICAgICBpZiAoaXNQbSAmJiBob3VyIDwgMTIpIHtcbiAgICAgICAgICAgIGhvdXIgKz0gMTI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1BtICYmIGhvdXIgPT09IDEyKSB7XG4gICAgICAgICAgICBob3VyID0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaG91cjtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyB0aGlzIGlzIG5vdCBzdXBwb3NlZCB0byBoYXBwZW5cbiAgICAgICAgcmV0dXJuIGhvdXI7XG4gICAgfVxufVxuXG4vLyBkYXRlIGZyb20gc3RyaW5nIGFuZCBhcnJheSBvZiBmb3JtYXQgc3RyaW5nc1xuZnVuY3Rpb24gY29uZmlnRnJvbVN0cmluZ0FuZEFycmF5KGNvbmZpZykge1xuICAgIHZhciB0ZW1wQ29uZmlnLFxuICAgICAgICBiZXN0TW9tZW50LFxuXG4gICAgICAgIHNjb3JlVG9CZWF0LFxuICAgICAgICBpLFxuICAgICAgICBjdXJyZW50U2NvcmU7XG5cbiAgICBpZiAoY29uZmlnLl9mLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5pbnZhbGlkRm9ybWF0ID0gdHJ1ZTtcbiAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoTmFOKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCBjb25maWcuX2YubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY3VycmVudFNjb3JlID0gMDtcbiAgICAgICAgdGVtcENvbmZpZyA9IGNvcHlDb25maWcoe30sIGNvbmZpZyk7XG4gICAgICAgIGlmIChjb25maWcuX3VzZVVUQyAhPSBudWxsKSB7XG4gICAgICAgICAgICB0ZW1wQ29uZmlnLl91c2VVVEMgPSBjb25maWcuX3VzZVVUQztcbiAgICAgICAgfVxuICAgICAgICB0ZW1wQ29uZmlnLl9mID0gY29uZmlnLl9mW2ldO1xuICAgICAgICBjb25maWdGcm9tU3RyaW5nQW5kRm9ybWF0KHRlbXBDb25maWcpO1xuXG4gICAgICAgIGlmICghaXNWYWxpZCh0ZW1wQ29uZmlnKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB0aGVyZSBpcyBhbnkgaW5wdXQgdGhhdCB3YXMgbm90IHBhcnNlZCBhZGQgYSBwZW5hbHR5IGZvciB0aGF0IGZvcm1hdFxuICAgICAgICBjdXJyZW50U2NvcmUgKz0gZ2V0UGFyc2luZ0ZsYWdzKHRlbXBDb25maWcpLmNoYXJzTGVmdE92ZXI7XG5cbiAgICAgICAgLy9vciB0b2tlbnNcbiAgICAgICAgY3VycmVudFNjb3JlICs9IGdldFBhcnNpbmdGbGFncyh0ZW1wQ29uZmlnKS51bnVzZWRUb2tlbnMubGVuZ3RoICogMTA7XG5cbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKHRlbXBDb25maWcpLnNjb3JlID0gY3VycmVudFNjb3JlO1xuXG4gICAgICAgIGlmIChzY29yZVRvQmVhdCA9PSBudWxsIHx8IGN1cnJlbnRTY29yZSA8IHNjb3JlVG9CZWF0KSB7XG4gICAgICAgICAgICBzY29yZVRvQmVhdCA9IGN1cnJlbnRTY29yZTtcbiAgICAgICAgICAgIGJlc3RNb21lbnQgPSB0ZW1wQ29uZmlnO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZXh0ZW5kKGNvbmZpZywgYmVzdE1vbWVudCB8fCB0ZW1wQ29uZmlnKTtcbn1cblxuZnVuY3Rpb24gY29uZmlnRnJvbU9iamVjdChjb25maWcpIHtcbiAgICBpZiAoY29uZmlnLl9kKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgaSA9IG5vcm1hbGl6ZU9iamVjdFVuaXRzKGNvbmZpZy5faSk7XG4gICAgY29uZmlnLl9hID0gbWFwKFtpLnllYXIsIGkubW9udGgsIGkuZGF5IHx8IGkuZGF0ZSwgaS5ob3VyLCBpLm1pbnV0ZSwgaS5zZWNvbmQsIGkubWlsbGlzZWNvbmRdLCBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogJiYgcGFyc2VJbnQob2JqLCAxMCk7XG4gICAgfSk7XG5cbiAgICBjb25maWdGcm9tQXJyYXkoY29uZmlnKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRnJvbUNvbmZpZyAoY29uZmlnKSB7XG4gICAgdmFyIHJlcyA9IG5ldyBNb21lbnQoY2hlY2tPdmVyZmxvdyhwcmVwYXJlQ29uZmlnKGNvbmZpZykpKTtcbiAgICBpZiAocmVzLl9uZXh0RGF5KSB7XG4gICAgICAgIC8vIEFkZGluZyBpcyBzbWFydCBlbm91Z2ggYXJvdW5kIERTVFxuICAgICAgICByZXMuYWRkKDEsICdkJyk7XG4gICAgICAgIHJlcy5fbmV4dERheSA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xufVxuXG5mdW5jdGlvbiBwcmVwYXJlQ29uZmlnIChjb25maWcpIHtcbiAgICB2YXIgaW5wdXQgPSBjb25maWcuX2ksXG4gICAgICAgIGZvcm1hdCA9IGNvbmZpZy5fZjtcblxuICAgIGNvbmZpZy5fbG9jYWxlID0gY29uZmlnLl9sb2NhbGUgfHwgZ2V0TG9jYWxlKGNvbmZpZy5fbCk7XG5cbiAgICBpZiAoaW5wdXQgPT09IG51bGwgfHwgKGZvcm1hdCA9PT0gdW5kZWZpbmVkICYmIGlucHV0ID09PSAnJykpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUludmFsaWQoe251bGxJbnB1dDogdHJ1ZX0pO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNvbmZpZy5faSA9IGlucHV0ID0gY29uZmlnLl9sb2NhbGUucHJlcGFyc2UoaW5wdXQpO1xuICAgIH1cblxuICAgIGlmIChpc01vbWVudChpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNb21lbnQoY2hlY2tPdmVyZmxvdyhpbnB1dCkpO1xuICAgIH0gZWxzZSBpZiAoaXNEYXRlKGlucHV0KSkge1xuICAgICAgICBjb25maWcuX2QgPSBpbnB1dDtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkoZm9ybWF0KSkge1xuICAgICAgICBjb25maWdGcm9tU3RyaW5nQW5kQXJyYXkoY29uZmlnKTtcbiAgICB9IGVsc2UgaWYgKGZvcm1hdCkge1xuICAgICAgICBjb25maWdGcm9tU3RyaW5nQW5kRm9ybWF0KGNvbmZpZyk7XG4gICAgfSAgZWxzZSB7XG4gICAgICAgIGNvbmZpZ0Zyb21JbnB1dChjb25maWcpO1xuICAgIH1cblxuICAgIGlmICghaXNWYWxpZChjb25maWcpKSB7XG4gICAgICAgIGNvbmZpZy5fZCA9IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbmZpZztcbn1cblxuZnVuY3Rpb24gY29uZmlnRnJvbUlucHV0KGNvbmZpZykge1xuICAgIHZhciBpbnB1dCA9IGNvbmZpZy5faTtcbiAgICBpZiAoaXNVbmRlZmluZWQoaW5wdXQpKSB7XG4gICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKGhvb2tzLm5vdygpKTtcbiAgICB9IGVsc2UgaWYgKGlzRGF0ZShpbnB1dCkpIHtcbiAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoaW5wdXQudmFsdWVPZigpKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29uZmlnRnJvbVN0cmluZyhjb25maWcpO1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgY29uZmlnLl9hID0gbWFwKGlucHV0LnNsaWNlKDApLCBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQob2JqLCAxMCk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25maWdGcm9tQXJyYXkoY29uZmlnKTtcbiAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KGlucHV0KSkge1xuICAgICAgICBjb25maWdGcm9tT2JqZWN0KGNvbmZpZyk7XG4gICAgfSBlbHNlIGlmIChpc051bWJlcihpbnB1dCkpIHtcbiAgICAgICAgLy8gZnJvbSBtaWxsaXNlY29uZHNcbiAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoaW5wdXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGhvb2tzLmNyZWF0ZUZyb21JbnB1dEZhbGxiYWNrKGNvbmZpZyk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVMb2NhbE9yVVRDIChpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCwgaXNVVEMpIHtcbiAgICB2YXIgYyA9IHt9O1xuXG4gICAgaWYgKGxvY2FsZSA9PT0gdHJ1ZSB8fCBsb2NhbGUgPT09IGZhbHNlKSB7XG4gICAgICAgIHN0cmljdCA9IGxvY2FsZTtcbiAgICAgICAgbG9jYWxlID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGlmICgoaXNPYmplY3QoaW5wdXQpICYmIGlzT2JqZWN0RW1wdHkoaW5wdXQpKSB8fFxuICAgICAgICAgICAgKGlzQXJyYXkoaW5wdXQpICYmIGlucHV0Lmxlbmd0aCA9PT0gMCkpIHtcbiAgICAgICAgaW5wdXQgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8vIG9iamVjdCBjb25zdHJ1Y3Rpb24gbXVzdCBiZSBkb25lIHRoaXMgd2F5LlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L2lzc3Vlcy8xNDIzXG4gICAgYy5faXNBTW9tZW50T2JqZWN0ID0gdHJ1ZTtcbiAgICBjLl91c2VVVEMgPSBjLl9pc1VUQyA9IGlzVVRDO1xuICAgIGMuX2wgPSBsb2NhbGU7XG4gICAgYy5faSA9IGlucHV0O1xuICAgIGMuX2YgPSBmb3JtYXQ7XG4gICAgYy5fc3RyaWN0ID0gc3RyaWN0O1xuXG4gICAgcmV0dXJuIGNyZWF0ZUZyb21Db25maWcoYyk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUxvY2FsIChpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCkge1xuICAgIHJldHVybiBjcmVhdGVMb2NhbE9yVVRDKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0LCBmYWxzZSk7XG59XG5cbnZhciBwcm90b3R5cGVNaW4gPSBkZXByZWNhdGUoXG4gICAgJ21vbWVudCgpLm1pbiBpcyBkZXByZWNhdGVkLCB1c2UgbW9tZW50Lm1heCBpbnN0ZWFkLiBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL21pbi1tYXgvJyxcbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvdGhlciA9IGNyZWF0ZUxvY2FsLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgIGlmICh0aGlzLmlzVmFsaWQoKSAmJiBvdGhlci5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBvdGhlciA8IHRoaXMgPyB0aGlzIDogb3RoZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlSW52YWxpZCgpO1xuICAgICAgICB9XG4gICAgfVxuKTtcblxudmFyIHByb3RvdHlwZU1heCA9IGRlcHJlY2F0ZShcbiAgICAnbW9tZW50KCkubWF4IGlzIGRlcHJlY2F0ZWQsIHVzZSBtb21lbnQubWluIGluc3RlYWQuIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvbWluLW1heC8nLFxuICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG90aGVyID0gY3JlYXRlTG9jYWwuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgaWYgKHRoaXMuaXNWYWxpZCgpICYmIG90aGVyLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG90aGVyID4gdGhpcyA/IHRoaXMgOiBvdGhlcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVJbnZhbGlkKCk7XG4gICAgICAgIH1cbiAgICB9XG4pO1xuXG4vLyBQaWNrIGEgbW9tZW50IG0gZnJvbSBtb21lbnRzIHNvIHRoYXQgbVtmbl0ob3RoZXIpIGlzIHRydWUgZm9yIGFsbFxuLy8gb3RoZXIuIFRoaXMgcmVsaWVzIG9uIHRoZSBmdW5jdGlvbiBmbiB0byBiZSB0cmFuc2l0aXZlLlxuLy9cbi8vIG1vbWVudHMgc2hvdWxkIGVpdGhlciBiZSBhbiBhcnJheSBvZiBtb21lbnQgb2JqZWN0cyBvciBhbiBhcnJheSwgd2hvc2Vcbi8vIGZpcnN0IGVsZW1lbnQgaXMgYW4gYXJyYXkgb2YgbW9tZW50IG9iamVjdHMuXG5mdW5jdGlvbiBwaWNrQnkoZm4sIG1vbWVudHMpIHtcbiAgICB2YXIgcmVzLCBpO1xuICAgIGlmIChtb21lbnRzLmxlbmd0aCA9PT0gMSAmJiBpc0FycmF5KG1vbWVudHNbMF0pKSB7XG4gICAgICAgIG1vbWVudHMgPSBtb21lbnRzWzBdO1xuICAgIH1cbiAgICBpZiAoIW1vbWVudHMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVMb2NhbCgpO1xuICAgIH1cbiAgICByZXMgPSBtb21lbnRzWzBdO1xuICAgIGZvciAoaSA9IDE7IGkgPCBtb21lbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmICghbW9tZW50c1tpXS5pc1ZhbGlkKCkgfHwgbW9tZW50c1tpXVtmbl0ocmVzKSkge1xuICAgICAgICAgICAgcmVzID0gbW9tZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuXG4vLyBUT0RPOiBVc2UgW10uc29ydCBpbnN0ZWFkP1xuZnVuY3Rpb24gbWluICgpIHtcbiAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcblxuICAgIHJldHVybiBwaWNrQnkoJ2lzQmVmb3JlJywgYXJncyk7XG59XG5cbmZ1bmN0aW9uIG1heCAoKSB7XG4gICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG5cbiAgICByZXR1cm4gcGlja0J5KCdpc0FmdGVyJywgYXJncyk7XG59XG5cbnZhciBub3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIERhdGUubm93ID8gRGF0ZS5ub3coKSA6ICsobmV3IERhdGUoKSk7XG59O1xuXG52YXIgb3JkZXJpbmcgPSBbJ3llYXInLCAncXVhcnRlcicsICdtb250aCcsICd3ZWVrJywgJ2RheScsICdob3VyJywgJ21pbnV0ZScsICdzZWNvbmQnLCAnbWlsbGlzZWNvbmQnXTtcblxuZnVuY3Rpb24gaXNEdXJhdGlvblZhbGlkKG0pIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gbSkge1xuICAgICAgICBpZiAoIShpbmRleE9mLmNhbGwob3JkZXJpbmcsIGtleSkgIT09IC0xICYmIChtW2tleV0gPT0gbnVsbCB8fCAhaXNOYU4obVtrZXldKSkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdW5pdEhhc0RlY2ltYWwgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9yZGVyaW5nLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmIChtW29yZGVyaW5nW2ldXSkge1xuICAgICAgICAgICAgaWYgKHVuaXRIYXNEZWNpbWFsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBvbmx5IGFsbG93IG5vbi1pbnRlZ2VycyBmb3Igc21hbGxlc3QgdW5pdFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcnNlRmxvYXQobVtvcmRlcmluZ1tpXV0pICE9PSB0b0ludChtW29yZGVyaW5nW2ldXSkpIHtcbiAgICAgICAgICAgICAgICB1bml0SGFzRGVjaW1hbCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaXNWYWxpZCQxKCkge1xuICAgIHJldHVybiB0aGlzLl9pc1ZhbGlkO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVJbnZhbGlkJDEoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUR1cmF0aW9uKE5hTik7XG59XG5cbmZ1bmN0aW9uIER1cmF0aW9uIChkdXJhdGlvbikge1xuICAgIHZhciBub3JtYWxpemVkSW5wdXQgPSBub3JtYWxpemVPYmplY3RVbml0cyhkdXJhdGlvbiksXG4gICAgICAgIHllYXJzID0gbm9ybWFsaXplZElucHV0LnllYXIgfHwgMCxcbiAgICAgICAgcXVhcnRlcnMgPSBub3JtYWxpemVkSW5wdXQucXVhcnRlciB8fCAwLFxuICAgICAgICBtb250aHMgPSBub3JtYWxpemVkSW5wdXQubW9udGggfHwgMCxcbiAgICAgICAgd2Vla3MgPSBub3JtYWxpemVkSW5wdXQud2VlayB8fCAwLFxuICAgICAgICBkYXlzID0gbm9ybWFsaXplZElucHV0LmRheSB8fCAwLFxuICAgICAgICBob3VycyA9IG5vcm1hbGl6ZWRJbnB1dC5ob3VyIHx8IDAsXG4gICAgICAgIG1pbnV0ZXMgPSBub3JtYWxpemVkSW5wdXQubWludXRlIHx8IDAsXG4gICAgICAgIHNlY29uZHMgPSBub3JtYWxpemVkSW5wdXQuc2Vjb25kIHx8IDAsXG4gICAgICAgIG1pbGxpc2Vjb25kcyA9IG5vcm1hbGl6ZWRJbnB1dC5taWxsaXNlY29uZCB8fCAwO1xuXG4gICAgdGhpcy5faXNWYWxpZCA9IGlzRHVyYXRpb25WYWxpZChub3JtYWxpemVkSW5wdXQpO1xuXG4gICAgLy8gcmVwcmVzZW50YXRpb24gZm9yIGRhdGVBZGRSZW1vdmVcbiAgICB0aGlzLl9taWxsaXNlY29uZHMgPSArbWlsbGlzZWNvbmRzICtcbiAgICAgICAgc2Vjb25kcyAqIDFlMyArIC8vIDEwMDBcbiAgICAgICAgbWludXRlcyAqIDZlNCArIC8vIDEwMDAgKiA2MFxuICAgICAgICBob3VycyAqIDEwMDAgKiA2MCAqIDYwOyAvL3VzaW5nIDEwMDAgKiA2MCAqIDYwIGluc3RlYWQgb2YgMzZlNSB0byBhdm9pZCBmbG9hdGluZyBwb2ludCByb3VuZGluZyBlcnJvcnMgaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvaXNzdWVzLzI5NzhcbiAgICAvLyBCZWNhdXNlIG9mIGRhdGVBZGRSZW1vdmUgdHJlYXRzIDI0IGhvdXJzIGFzIGRpZmZlcmVudCBmcm9tIGFcbiAgICAvLyBkYXkgd2hlbiB3b3JraW5nIGFyb3VuZCBEU1QsIHdlIG5lZWQgdG8gc3RvcmUgdGhlbSBzZXBhcmF0ZWx5XG4gICAgdGhpcy5fZGF5cyA9ICtkYXlzICtcbiAgICAgICAgd2Vla3MgKiA3O1xuICAgIC8vIEl0IGlzIGltcG9zc2libGUgdG8gdHJhbnNsYXRlIG1vbnRocyBpbnRvIGRheXMgd2l0aG91dCBrbm93aW5nXG4gICAgLy8gd2hpY2ggbW9udGhzIHlvdSBhcmUgYXJlIHRhbGtpbmcgYWJvdXQsIHNvIHdlIGhhdmUgdG8gc3RvcmVcbiAgICAvLyBpdCBzZXBhcmF0ZWx5LlxuICAgIHRoaXMuX21vbnRocyA9ICttb250aHMgK1xuICAgICAgICBxdWFydGVycyAqIDMgK1xuICAgICAgICB5ZWFycyAqIDEyO1xuXG4gICAgdGhpcy5fZGF0YSA9IHt9O1xuXG4gICAgdGhpcy5fbG9jYWxlID0gZ2V0TG9jYWxlKCk7XG5cbiAgICB0aGlzLl9idWJibGUoKTtcbn1cblxuZnVuY3Rpb24gaXNEdXJhdGlvbiAob2JqKSB7XG4gICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIER1cmF0aW9uO1xufVxuXG5mdW5jdGlvbiBhYnNSb3VuZCAobnVtYmVyKSB7XG4gICAgaWYgKG51bWJlciA8IDApIHtcbiAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoLTEgKiBudW1iZXIpICogLTE7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIE1hdGgucm91bmQobnVtYmVyKTtcbiAgICB9XG59XG5cbi8vIEZPUk1BVFRJTkdcblxuZnVuY3Rpb24gb2Zmc2V0ICh0b2tlbiwgc2VwYXJhdG9yKSB7XG4gICAgYWRkRm9ybWF0VG9rZW4odG9rZW4sIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMudXRjT2Zmc2V0KCk7XG4gICAgICAgIHZhciBzaWduID0gJysnO1xuICAgICAgICBpZiAob2Zmc2V0IDwgMCkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gLW9mZnNldDtcbiAgICAgICAgICAgIHNpZ24gPSAnLSc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNpZ24gKyB6ZXJvRmlsbCh+fihvZmZzZXQgLyA2MCksIDIpICsgc2VwYXJhdG9yICsgemVyb0ZpbGwofn4ob2Zmc2V0KSAlIDYwLCAyKTtcbiAgICB9KTtcbn1cblxub2Zmc2V0KCdaJywgJzonKTtcbm9mZnNldCgnWlonLCAnJyk7XG5cbi8vIFBBUlNJTkdcblxuYWRkUmVnZXhUb2tlbignWicsICBtYXRjaFNob3J0T2Zmc2V0KTtcbmFkZFJlZ2V4VG9rZW4oJ1paJywgbWF0Y2hTaG9ydE9mZnNldCk7XG5hZGRQYXJzZVRva2VuKFsnWicsICdaWiddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICBjb25maWcuX3VzZVVUQyA9IHRydWU7XG4gICAgY29uZmlnLl90em0gPSBvZmZzZXRGcm9tU3RyaW5nKG1hdGNoU2hvcnRPZmZzZXQsIGlucHV0KTtcbn0pO1xuXG4vLyBIRUxQRVJTXG5cbi8vIHRpbWV6b25lIGNodW5rZXJcbi8vICcrMTA6MDAnID4gWycxMCcsICAnMDAnXVxuLy8gJy0xNTMwJyAgPiBbJy0xNScsICczMCddXG52YXIgY2h1bmtPZmZzZXQgPSAvKFtcXCtcXC1dfFxcZFxcZCkvZ2k7XG5cbmZ1bmN0aW9uIG9mZnNldEZyb21TdHJpbmcobWF0Y2hlciwgc3RyaW5nKSB7XG4gICAgdmFyIG1hdGNoZXMgPSAoc3RyaW5nIHx8ICcnKS5tYXRjaChtYXRjaGVyKTtcblxuICAgIGlmIChtYXRjaGVzID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBjaHVuayAgID0gbWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdIHx8IFtdO1xuICAgIHZhciBwYXJ0cyAgID0gKGNodW5rICsgJycpLm1hdGNoKGNodW5rT2Zmc2V0KSB8fCBbJy0nLCAwLCAwXTtcbiAgICB2YXIgbWludXRlcyA9ICsocGFydHNbMV0gKiA2MCkgKyB0b0ludChwYXJ0c1syXSk7XG5cbiAgICByZXR1cm4gbWludXRlcyA9PT0gMCA/XG4gICAgICAwIDpcbiAgICAgIHBhcnRzWzBdID09PSAnKycgPyBtaW51dGVzIDogLW1pbnV0ZXM7XG59XG5cbi8vIFJldHVybiBhIG1vbWVudCBmcm9tIGlucHV0LCB0aGF0IGlzIGxvY2FsL3V0Yy96b25lIGVxdWl2YWxlbnQgdG8gbW9kZWwuXG5mdW5jdGlvbiBjbG9uZVdpdGhPZmZzZXQoaW5wdXQsIG1vZGVsKSB7XG4gICAgdmFyIHJlcywgZGlmZjtcbiAgICBpZiAobW9kZWwuX2lzVVRDKSB7XG4gICAgICAgIHJlcyA9IG1vZGVsLmNsb25lKCk7XG4gICAgICAgIGRpZmYgPSAoaXNNb21lbnQoaW5wdXQpIHx8IGlzRGF0ZShpbnB1dCkgPyBpbnB1dC52YWx1ZU9mKCkgOiBjcmVhdGVMb2NhbChpbnB1dCkudmFsdWVPZigpKSAtIHJlcy52YWx1ZU9mKCk7XG4gICAgICAgIC8vIFVzZSBsb3ctbGV2ZWwgYXBpLCBiZWNhdXNlIHRoaXMgZm4gaXMgbG93LWxldmVsIGFwaS5cbiAgICAgICAgcmVzLl9kLnNldFRpbWUocmVzLl9kLnZhbHVlT2YoKSArIGRpZmYpO1xuICAgICAgICBob29rcy51cGRhdGVPZmZzZXQocmVzLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUxvY2FsKGlucHV0KS5sb2NhbCgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZ2V0RGF0ZU9mZnNldCAobSkge1xuICAgIC8vIE9uIEZpcmVmb3guMjQgRGF0ZSNnZXRUaW1lem9uZU9mZnNldCByZXR1cm5zIGEgZmxvYXRpbmcgcG9pbnQuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvcHVsbC8xODcxXG4gICAgcmV0dXJuIC1NYXRoLnJvdW5kKG0uX2QuZ2V0VGltZXpvbmVPZmZzZXQoKSAvIDE1KSAqIDE1O1xufVxuXG4vLyBIT09LU1xuXG4vLyBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIHdoZW5ldmVyIGEgbW9tZW50IGlzIG11dGF0ZWQuXG4vLyBJdCBpcyBpbnRlbmRlZCB0byBrZWVwIHRoZSBvZmZzZXQgaW4gc3luYyB3aXRoIHRoZSB0aW1lem9uZS5cbmhvb2tzLnVwZGF0ZU9mZnNldCA9IGZ1bmN0aW9uICgpIHt9O1xuXG4vLyBNT01FTlRTXG5cbi8vIGtlZXBMb2NhbFRpbWUgPSB0cnVlIG1lYW5zIG9ubHkgY2hhbmdlIHRoZSB0aW1lem9uZSwgd2l0aG91dFxuLy8gYWZmZWN0aW5nIHRoZSBsb2NhbCBob3VyLiBTbyA1OjMxOjI2ICswMzAwIC0tW3V0Y09mZnNldCgyLCB0cnVlKV0tLT5cbi8vIDU6MzE6MjYgKzAyMDAgSXQgaXMgcG9zc2libGUgdGhhdCA1OjMxOjI2IGRvZXNuJ3QgZXhpc3Qgd2l0aCBvZmZzZXRcbi8vICswMjAwLCBzbyB3ZSBhZGp1c3QgdGhlIHRpbWUgYXMgbmVlZGVkLCB0byBiZSB2YWxpZC5cbi8vXG4vLyBLZWVwaW5nIHRoZSB0aW1lIGFjdHVhbGx5IGFkZHMvc3VidHJhY3RzIChvbmUgaG91cilcbi8vIGZyb20gdGhlIGFjdHVhbCByZXByZXNlbnRlZCB0aW1lLiBUaGF0IGlzIHdoeSB3ZSBjYWxsIHVwZGF0ZU9mZnNldFxuLy8gYSBzZWNvbmQgdGltZS4gSW4gY2FzZSBpdCB3YW50cyB1cyB0byBjaGFuZ2UgdGhlIG9mZnNldCBhZ2FpblxuLy8gX2NoYW5nZUluUHJvZ3Jlc3MgPT0gdHJ1ZSBjYXNlLCB0aGVuIHdlIGhhdmUgdG8gYWRqdXN0LCBiZWNhdXNlXG4vLyB0aGVyZSBpcyBubyBzdWNoIHRpbWUgaW4gdGhlIGdpdmVuIHRpbWV6b25lLlxuZnVuY3Rpb24gZ2V0U2V0T2Zmc2V0IChpbnB1dCwga2VlcExvY2FsVGltZSwga2VlcE1pbnV0ZXMpIHtcbiAgICB2YXIgb2Zmc2V0ID0gdGhpcy5fb2Zmc2V0IHx8IDAsXG4gICAgICAgIGxvY2FsQWRqdXN0O1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgPyB0aGlzIDogTmFOO1xuICAgIH1cbiAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaW5wdXQgPSBvZmZzZXRGcm9tU3RyaW5nKG1hdGNoU2hvcnRPZmZzZXQsIGlucHV0KTtcbiAgICAgICAgICAgIGlmIChpbnB1dCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKE1hdGguYWJzKGlucHV0KSA8IDE2ICYmICFrZWVwTWludXRlcykge1xuICAgICAgICAgICAgaW5wdXQgPSBpbnB1dCAqIDYwO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5faXNVVEMgJiYga2VlcExvY2FsVGltZSkge1xuICAgICAgICAgICAgbG9jYWxBZGp1c3QgPSBnZXREYXRlT2Zmc2V0KHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX29mZnNldCA9IGlucHV0O1xuICAgICAgICB0aGlzLl9pc1VUQyA9IHRydWU7XG4gICAgICAgIGlmIChsb2NhbEFkanVzdCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmFkZChsb2NhbEFkanVzdCwgJ20nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2Zmc2V0ICE9PSBpbnB1dCkge1xuICAgICAgICAgICAgaWYgKCFrZWVwTG9jYWxUaW1lIHx8IHRoaXMuX2NoYW5nZUluUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICBhZGRTdWJ0cmFjdCh0aGlzLCBjcmVhdGVEdXJhdGlvbihpbnB1dCAtIG9mZnNldCwgJ20nKSwgMSwgZmFsc2UpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5fY2hhbmdlSW5Qcm9ncmVzcykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5nZUluUHJvZ3Jlc3MgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldCh0aGlzLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jaGFuZ2VJblByb2dyZXNzID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNVVEMgPyBvZmZzZXQgOiBnZXREYXRlT2Zmc2V0KHRoaXMpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZ2V0U2V0Wm9uZSAoaW5wdXQsIGtlZXBMb2NhbFRpbWUpIHtcbiAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaW5wdXQgPSAtaW5wdXQ7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnV0Y09mZnNldChpbnB1dCwga2VlcExvY2FsVGltZSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIC10aGlzLnV0Y09mZnNldCgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gc2V0T2Zmc2V0VG9VVEMgKGtlZXBMb2NhbFRpbWUpIHtcbiAgICByZXR1cm4gdGhpcy51dGNPZmZzZXQoMCwga2VlcExvY2FsVGltZSk7XG59XG5cbmZ1bmN0aW9uIHNldE9mZnNldFRvTG9jYWwgKGtlZXBMb2NhbFRpbWUpIHtcbiAgICBpZiAodGhpcy5faXNVVEMpIHtcbiAgICAgICAgdGhpcy51dGNPZmZzZXQoMCwga2VlcExvY2FsVGltZSk7XG4gICAgICAgIHRoaXMuX2lzVVRDID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKGtlZXBMb2NhbFRpbWUpIHtcbiAgICAgICAgICAgIHRoaXMuc3VidHJhY3QoZ2V0RGF0ZU9mZnNldCh0aGlzKSwgJ20nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn1cblxuZnVuY3Rpb24gc2V0T2Zmc2V0VG9QYXJzZWRPZmZzZXQgKCkge1xuICAgIGlmICh0aGlzLl90em0gIT0gbnVsbCkge1xuICAgICAgICB0aGlzLnV0Y09mZnNldCh0aGlzLl90em0sIGZhbHNlLCB0cnVlKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLl9pID09PSAnc3RyaW5nJykge1xuICAgICAgICB2YXIgdFpvbmUgPSBvZmZzZXRGcm9tU3RyaW5nKG1hdGNoT2Zmc2V0LCB0aGlzLl9pKTtcbiAgICAgICAgaWYgKHRab25lICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KHRab25lKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KDAsIHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufVxuXG5mdW5jdGlvbiBoYXNBbGlnbmVkSG91ck9mZnNldCAoaW5wdXQpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaW5wdXQgPSBpbnB1dCA/IGNyZWF0ZUxvY2FsKGlucHV0KS51dGNPZmZzZXQoKSA6IDA7XG5cbiAgICByZXR1cm4gKHRoaXMudXRjT2Zmc2V0KCkgLSBpbnB1dCkgJSA2MCA9PT0gMDtcbn1cblxuZnVuY3Rpb24gaXNEYXlsaWdodFNhdmluZ1RpbWUgKCkge1xuICAgIHJldHVybiAoXG4gICAgICAgIHRoaXMudXRjT2Zmc2V0KCkgPiB0aGlzLmNsb25lKCkubW9udGgoMCkudXRjT2Zmc2V0KCkgfHxcbiAgICAgICAgdGhpcy51dGNPZmZzZXQoKSA+IHRoaXMuY2xvbmUoKS5tb250aCg1KS51dGNPZmZzZXQoKVxuICAgICk7XG59XG5cbmZ1bmN0aW9uIGlzRGF5bGlnaHRTYXZpbmdUaW1lU2hpZnRlZCAoKSB7XG4gICAgaWYgKCFpc1VuZGVmaW5lZCh0aGlzLl9pc0RTVFNoaWZ0ZWQpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc0RTVFNoaWZ0ZWQ7XG4gICAgfVxuXG4gICAgdmFyIGMgPSB7fTtcblxuICAgIGNvcHlDb25maWcoYywgdGhpcyk7XG4gICAgYyA9IHByZXBhcmVDb25maWcoYyk7XG5cbiAgICBpZiAoYy5fYSkge1xuICAgICAgICB2YXIgb3RoZXIgPSBjLl9pc1VUQyA/IGNyZWF0ZVVUQyhjLl9hKSA6IGNyZWF0ZUxvY2FsKGMuX2EpO1xuICAgICAgICB0aGlzLl9pc0RTVFNoaWZ0ZWQgPSB0aGlzLmlzVmFsaWQoKSAmJlxuICAgICAgICAgICAgY29tcGFyZUFycmF5cyhjLl9hLCBvdGhlci50b0FycmF5KCkpID4gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9pc0RTVFNoaWZ0ZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5faXNEU1RTaGlmdGVkO1xufVxuXG5mdW5jdGlvbiBpc0xvY2FsICgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyAhdGhpcy5faXNVVEMgOiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNVdGNPZmZzZXQgKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/IHRoaXMuX2lzVVRDIDogZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVXRjICgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyB0aGlzLl9pc1VUQyAmJiB0aGlzLl9vZmZzZXQgPT09IDAgOiBmYWxzZTtcbn1cblxuLy8gQVNQLk5FVCBqc29uIGRhdGUgZm9ybWF0IHJlZ2V4XG52YXIgYXNwTmV0UmVnZXggPSAvXihcXC18XFwrKT8oPzooXFxkKilbLiBdKT8oXFxkKylcXDooXFxkKykoPzpcXDooXFxkKykoXFwuXFxkKik/KT8kLztcblxuLy8gZnJvbSBodHRwOi8vZG9jcy5jbG9zdXJlLWxpYnJhcnkuZ29vZ2xlY29kZS5jb20vZ2l0L2Nsb3N1cmVfZ29vZ19kYXRlX2RhdGUuanMuc291cmNlLmh0bWxcbi8vIHNvbWV3aGF0IG1vcmUgaW4gbGluZSB3aXRoIDQuNC4zLjIgMjAwNCBzcGVjLCBidXQgYWxsb3dzIGRlY2ltYWwgYW55d2hlcmVcbi8vIGFuZCBmdXJ0aGVyIG1vZGlmaWVkIHRvIGFsbG93IGZvciBzdHJpbmdzIGNvbnRhaW5pbmcgYm90aCB3ZWVrIGFuZCBkYXlcbnZhciBpc29SZWdleCA9IC9eKC18XFwrKT9QKD86KFstK10/WzAtOSwuXSopWSk/KD86KFstK10/WzAtOSwuXSopTSk/KD86KFstK10/WzAtOSwuXSopVyk/KD86KFstK10/WzAtOSwuXSopRCk/KD86VCg/OihbLStdP1swLTksLl0qKUgpPyg/OihbLStdP1swLTksLl0qKU0pPyg/OihbLStdP1swLTksLl0qKVMpPyk/JC87XG5cbmZ1bmN0aW9uIGNyZWF0ZUR1cmF0aW9uIChpbnB1dCwga2V5KSB7XG4gICAgdmFyIGR1cmF0aW9uID0gaW5wdXQsXG4gICAgICAgIC8vIG1hdGNoaW5nIGFnYWluc3QgcmVnZXhwIGlzIGV4cGVuc2l2ZSwgZG8gaXQgb24gZGVtYW5kXG4gICAgICAgIG1hdGNoID0gbnVsbCxcbiAgICAgICAgc2lnbixcbiAgICAgICAgcmV0LFxuICAgICAgICBkaWZmUmVzO1xuXG4gICAgaWYgKGlzRHVyYXRpb24oaW5wdXQpKSB7XG4gICAgICAgIGR1cmF0aW9uID0ge1xuICAgICAgICAgICAgbXMgOiBpbnB1dC5fbWlsbGlzZWNvbmRzLFxuICAgICAgICAgICAgZCAgOiBpbnB1dC5fZGF5cyxcbiAgICAgICAgICAgIE0gIDogaW5wdXQuX21vbnRoc1xuICAgICAgICB9O1xuICAgIH0gZWxzZSBpZiAoaXNOdW1iZXIoaW5wdXQpKSB7XG4gICAgICAgIGR1cmF0aW9uID0ge307XG4gICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgIGR1cmF0aW9uW2tleV0gPSBpbnB1dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGR1cmF0aW9uLm1pbGxpc2Vjb25kcyA9IGlucHV0O1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmICghIShtYXRjaCA9IGFzcE5ldFJlZ2V4LmV4ZWMoaW5wdXQpKSkge1xuICAgICAgICBzaWduID0gKG1hdGNoWzFdID09PSAnLScpID8gLTEgOiAxO1xuICAgICAgICBkdXJhdGlvbiA9IHtcbiAgICAgICAgICAgIHkgIDogMCxcbiAgICAgICAgICAgIGQgIDogdG9JbnQobWF0Y2hbREFURV0pICAgICAgICAgICAgICAgICAgICAgICAgICogc2lnbixcbiAgICAgICAgICAgIGggIDogdG9JbnQobWF0Y2hbSE9VUl0pICAgICAgICAgICAgICAgICAgICAgICAgICogc2lnbixcbiAgICAgICAgICAgIG0gIDogdG9JbnQobWF0Y2hbTUlOVVRFXSkgICAgICAgICAgICAgICAgICAgICAgICogc2lnbixcbiAgICAgICAgICAgIHMgIDogdG9JbnQobWF0Y2hbU0VDT05EXSkgICAgICAgICAgICAgICAgICAgICAgICogc2lnbixcbiAgICAgICAgICAgIG1zIDogdG9JbnQoYWJzUm91bmQobWF0Y2hbTUlMTElTRUNPTkRdICogMTAwMCkpICogc2lnbiAvLyB0aGUgbWlsbGlzZWNvbmQgZGVjaW1hbCBwb2ludCBpcyBpbmNsdWRlZCBpbiB0aGUgbWF0Y2hcbiAgICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKCEhKG1hdGNoID0gaXNvUmVnZXguZXhlYyhpbnB1dCkpKSB7XG4gICAgICAgIHNpZ24gPSAobWF0Y2hbMV0gPT09ICctJykgPyAtMSA6IChtYXRjaFsxXSA9PT0gJysnKSA/IDEgOiAxO1xuICAgICAgICBkdXJhdGlvbiA9IHtcbiAgICAgICAgICAgIHkgOiBwYXJzZUlzbyhtYXRjaFsyXSwgc2lnbiksXG4gICAgICAgICAgICBNIDogcGFyc2VJc28obWF0Y2hbM10sIHNpZ24pLFxuICAgICAgICAgICAgdyA6IHBhcnNlSXNvKG1hdGNoWzRdLCBzaWduKSxcbiAgICAgICAgICAgIGQgOiBwYXJzZUlzbyhtYXRjaFs1XSwgc2lnbiksXG4gICAgICAgICAgICBoIDogcGFyc2VJc28obWF0Y2hbNl0sIHNpZ24pLFxuICAgICAgICAgICAgbSA6IHBhcnNlSXNvKG1hdGNoWzddLCBzaWduKSxcbiAgICAgICAgICAgIHMgOiBwYXJzZUlzbyhtYXRjaFs4XSwgc2lnbilcbiAgICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGR1cmF0aW9uID09IG51bGwpIHsvLyBjaGVja3MgZm9yIG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgIGR1cmF0aW9uID0ge307XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZHVyYXRpb24gPT09ICdvYmplY3QnICYmICgnZnJvbScgaW4gZHVyYXRpb24gfHwgJ3RvJyBpbiBkdXJhdGlvbikpIHtcbiAgICAgICAgZGlmZlJlcyA9IG1vbWVudHNEaWZmZXJlbmNlKGNyZWF0ZUxvY2FsKGR1cmF0aW9uLmZyb20pLCBjcmVhdGVMb2NhbChkdXJhdGlvbi50bykpO1xuXG4gICAgICAgIGR1cmF0aW9uID0ge307XG4gICAgICAgIGR1cmF0aW9uLm1zID0gZGlmZlJlcy5taWxsaXNlY29uZHM7XG4gICAgICAgIGR1cmF0aW9uLk0gPSBkaWZmUmVzLm1vbnRocztcbiAgICB9XG5cbiAgICByZXQgPSBuZXcgRHVyYXRpb24oZHVyYXRpb24pO1xuXG4gICAgaWYgKGlzRHVyYXRpb24oaW5wdXQpICYmIGhhc093blByb3AoaW5wdXQsICdfbG9jYWxlJykpIHtcbiAgICAgICAgcmV0Ll9sb2NhbGUgPSBpbnB1dC5fbG9jYWxlO1xuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG59XG5cbmNyZWF0ZUR1cmF0aW9uLmZuID0gRHVyYXRpb24ucHJvdG90eXBlO1xuY3JlYXRlRHVyYXRpb24uaW52YWxpZCA9IGNyZWF0ZUludmFsaWQkMTtcblxuZnVuY3Rpb24gcGFyc2VJc28gKGlucCwgc2lnbikge1xuICAgIC8vIFdlJ2Qgbm9ybWFsbHkgdXNlIH5+aW5wIGZvciB0aGlzLCBidXQgdW5mb3J0dW5hdGVseSBpdCBhbHNvXG4gICAgLy8gY29udmVydHMgZmxvYXRzIHRvIGludHMuXG4gICAgLy8gaW5wIG1heSBiZSB1bmRlZmluZWQsIHNvIGNhcmVmdWwgY2FsbGluZyByZXBsYWNlIG9uIGl0LlxuICAgIHZhciByZXMgPSBpbnAgJiYgcGFyc2VGbG9hdChpbnAucmVwbGFjZSgnLCcsICcuJykpO1xuICAgIC8vIGFwcGx5IHNpZ24gd2hpbGUgd2UncmUgYXQgaXRcbiAgICByZXR1cm4gKGlzTmFOKHJlcykgPyAwIDogcmVzKSAqIHNpZ247XG59XG5cbmZ1bmN0aW9uIHBvc2l0aXZlTW9tZW50c0RpZmZlcmVuY2UoYmFzZSwgb3RoZXIpIHtcbiAgICB2YXIgcmVzID0ge21pbGxpc2Vjb25kczogMCwgbW9udGhzOiAwfTtcblxuICAgIHJlcy5tb250aHMgPSBvdGhlci5tb250aCgpIC0gYmFzZS5tb250aCgpICtcbiAgICAgICAgKG90aGVyLnllYXIoKSAtIGJhc2UueWVhcigpKSAqIDEyO1xuICAgIGlmIChiYXNlLmNsb25lKCkuYWRkKHJlcy5tb250aHMsICdNJykuaXNBZnRlcihvdGhlcikpIHtcbiAgICAgICAgLS1yZXMubW9udGhzO1xuICAgIH1cblxuICAgIHJlcy5taWxsaXNlY29uZHMgPSArb3RoZXIgLSArKGJhc2UuY2xvbmUoKS5hZGQocmVzLm1vbnRocywgJ00nKSk7XG5cbiAgICByZXR1cm4gcmVzO1xufVxuXG5mdW5jdGlvbiBtb21lbnRzRGlmZmVyZW5jZShiYXNlLCBvdGhlcikge1xuICAgIHZhciByZXM7XG4gICAgaWYgKCEoYmFzZS5pc1ZhbGlkKCkgJiYgb3RoZXIuaXNWYWxpZCgpKSkge1xuICAgICAgICByZXR1cm4ge21pbGxpc2Vjb25kczogMCwgbW9udGhzOiAwfTtcbiAgICB9XG5cbiAgICBvdGhlciA9IGNsb25lV2l0aE9mZnNldChvdGhlciwgYmFzZSk7XG4gICAgaWYgKGJhc2UuaXNCZWZvcmUob3RoZXIpKSB7XG4gICAgICAgIHJlcyA9IHBvc2l0aXZlTW9tZW50c0RpZmZlcmVuY2UoYmFzZSwgb3RoZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJlcyA9IHBvc2l0aXZlTW9tZW50c0RpZmZlcmVuY2Uob3RoZXIsIGJhc2UpO1xuICAgICAgICByZXMubWlsbGlzZWNvbmRzID0gLXJlcy5taWxsaXNlY29uZHM7XG4gICAgICAgIHJlcy5tb250aHMgPSAtcmVzLm1vbnRocztcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xufVxuXG4vLyBUT0RPOiByZW1vdmUgJ25hbWUnIGFyZyBhZnRlciBkZXByZWNhdGlvbiBpcyByZW1vdmVkXG5mdW5jdGlvbiBjcmVhdGVBZGRlcihkaXJlY3Rpb24sIG5hbWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHZhbCwgcGVyaW9kKSB7XG4gICAgICAgIHZhciBkdXIsIHRtcDtcbiAgICAgICAgLy9pbnZlcnQgdGhlIGFyZ3VtZW50cywgYnV0IGNvbXBsYWluIGFib3V0IGl0XG4gICAgICAgIGlmIChwZXJpb2QgIT09IG51bGwgJiYgIWlzTmFOKCtwZXJpb2QpKSB7XG4gICAgICAgICAgICBkZXByZWNhdGVTaW1wbGUobmFtZSwgJ21vbWVudCgpLicgKyBuYW1lICArICcocGVyaW9kLCBudW1iZXIpIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgbW9tZW50KCkuJyArIG5hbWUgKyAnKG51bWJlciwgcGVyaW9kKS4gJyArXG4gICAgICAgICAgICAnU2VlIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvYWRkLWludmVydGVkLXBhcmFtLyBmb3IgbW9yZSBpbmZvLicpO1xuICAgICAgICAgICAgdG1wID0gdmFsOyB2YWwgPSBwZXJpb2Q7IHBlcmlvZCA9IHRtcDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhbCA9IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnID8gK3ZhbCA6IHZhbDtcbiAgICAgICAgZHVyID0gY3JlYXRlRHVyYXRpb24odmFsLCBwZXJpb2QpO1xuICAgICAgICBhZGRTdWJ0cmFjdCh0aGlzLCBkdXIsIGRpcmVjdGlvbik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG59XG5cbmZ1bmN0aW9uIGFkZFN1YnRyYWN0IChtb20sIGR1cmF0aW9uLCBpc0FkZGluZywgdXBkYXRlT2Zmc2V0KSB7XG4gICAgdmFyIG1pbGxpc2Vjb25kcyA9IGR1cmF0aW9uLl9taWxsaXNlY29uZHMsXG4gICAgICAgIGRheXMgPSBhYnNSb3VuZChkdXJhdGlvbi5fZGF5cyksXG4gICAgICAgIG1vbnRocyA9IGFic1JvdW5kKGR1cmF0aW9uLl9tb250aHMpO1xuXG4gICAgaWYgKCFtb20uaXNWYWxpZCgpKSB7XG4gICAgICAgIC8vIE5vIG9wXG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB1cGRhdGVPZmZzZXQgPSB1cGRhdGVPZmZzZXQgPT0gbnVsbCA/IHRydWUgOiB1cGRhdGVPZmZzZXQ7XG5cbiAgICBpZiAobW9udGhzKSB7XG4gICAgICAgIHNldE1vbnRoKG1vbSwgZ2V0KG1vbSwgJ01vbnRoJykgKyBtb250aHMgKiBpc0FkZGluZyk7XG4gICAgfVxuICAgIGlmIChkYXlzKSB7XG4gICAgICAgIHNldCQxKG1vbSwgJ0RhdGUnLCBnZXQobW9tLCAnRGF0ZScpICsgZGF5cyAqIGlzQWRkaW5nKTtcbiAgICB9XG4gICAgaWYgKG1pbGxpc2Vjb25kcykge1xuICAgICAgICBtb20uX2Quc2V0VGltZShtb20uX2QudmFsdWVPZigpICsgbWlsbGlzZWNvbmRzICogaXNBZGRpbmcpO1xuICAgIH1cbiAgICBpZiAodXBkYXRlT2Zmc2V0KSB7XG4gICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldChtb20sIGRheXMgfHwgbW9udGhzKTtcbiAgICB9XG59XG5cbnZhciBhZGQgICAgICA9IGNyZWF0ZUFkZGVyKDEsICdhZGQnKTtcbnZhciBzdWJ0cmFjdCA9IGNyZWF0ZUFkZGVyKC0xLCAnc3VidHJhY3QnKTtcblxuZnVuY3Rpb24gZ2V0Q2FsZW5kYXJGb3JtYXQobXlNb21lbnQsIG5vdykge1xuICAgIHZhciBkaWZmID0gbXlNb21lbnQuZGlmZihub3csICdkYXlzJywgdHJ1ZSk7XG4gICAgcmV0dXJuIGRpZmYgPCAtNiA/ICdzYW1lRWxzZScgOlxuICAgICAgICAgICAgZGlmZiA8IC0xID8gJ2xhc3RXZWVrJyA6XG4gICAgICAgICAgICBkaWZmIDwgMCA/ICdsYXN0RGF5JyA6XG4gICAgICAgICAgICBkaWZmIDwgMSA/ICdzYW1lRGF5JyA6XG4gICAgICAgICAgICBkaWZmIDwgMiA/ICduZXh0RGF5JyA6XG4gICAgICAgICAgICBkaWZmIDwgNyA/ICduZXh0V2VlaycgOiAnc2FtZUVsc2UnO1xufVxuXG5mdW5jdGlvbiBjYWxlbmRhciQxICh0aW1lLCBmb3JtYXRzKSB7XG4gICAgLy8gV2Ugd2FudCB0byBjb21wYXJlIHRoZSBzdGFydCBvZiB0b2RheSwgdnMgdGhpcy5cbiAgICAvLyBHZXR0aW5nIHN0YXJ0LW9mLXRvZGF5IGRlcGVuZHMgb24gd2hldGhlciB3ZSdyZSBsb2NhbC91dGMvb2Zmc2V0IG9yIG5vdC5cbiAgICB2YXIgbm93ID0gdGltZSB8fCBjcmVhdGVMb2NhbCgpLFxuICAgICAgICBzb2QgPSBjbG9uZVdpdGhPZmZzZXQobm93LCB0aGlzKS5zdGFydE9mKCdkYXknKSxcbiAgICAgICAgZm9ybWF0ID0gaG9va3MuY2FsZW5kYXJGb3JtYXQodGhpcywgc29kKSB8fCAnc2FtZUVsc2UnO1xuXG4gICAgdmFyIG91dHB1dCA9IGZvcm1hdHMgJiYgKGlzRnVuY3Rpb24oZm9ybWF0c1tmb3JtYXRdKSA/IGZvcm1hdHNbZm9ybWF0XS5jYWxsKHRoaXMsIG5vdykgOiBmb3JtYXRzW2Zvcm1hdF0pO1xuXG4gICAgcmV0dXJuIHRoaXMuZm9ybWF0KG91dHB1dCB8fCB0aGlzLmxvY2FsZURhdGEoKS5jYWxlbmRhcihmb3JtYXQsIHRoaXMsIGNyZWF0ZUxvY2FsKG5vdykpKTtcbn1cblxuZnVuY3Rpb24gY2xvbmUgKCkge1xuICAgIHJldHVybiBuZXcgTW9tZW50KHRoaXMpO1xufVxuXG5mdW5jdGlvbiBpc0FmdGVyIChpbnB1dCwgdW5pdHMpIHtcbiAgICB2YXIgbG9jYWxJbnB1dCA9IGlzTW9tZW50KGlucHV0KSA/IGlucHV0IDogY3JlYXRlTG9jYWwoaW5wdXQpO1xuICAgIGlmICghKHRoaXMuaXNWYWxpZCgpICYmIGxvY2FsSW5wdXQuaXNWYWxpZCgpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHMoIWlzVW5kZWZpbmVkKHVuaXRzKSA/IHVuaXRzIDogJ21pbGxpc2Vjb25kJyk7XG4gICAgaWYgKHVuaXRzID09PSAnbWlsbGlzZWNvbmQnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlT2YoKSA+IGxvY2FsSW5wdXQudmFsdWVPZigpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBsb2NhbElucHV0LnZhbHVlT2YoKSA8IHRoaXMuY2xvbmUoKS5zdGFydE9mKHVuaXRzKS52YWx1ZU9mKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBpc0JlZm9yZSAoaW5wdXQsIHVuaXRzKSB7XG4gICAgdmFyIGxvY2FsSW5wdXQgPSBpc01vbWVudChpbnB1dCkgPyBpbnB1dCA6IGNyZWF0ZUxvY2FsKGlucHV0KTtcbiAgICBpZiAoISh0aGlzLmlzVmFsaWQoKSAmJiBsb2NhbElucHV0LmlzVmFsaWQoKSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKCFpc1VuZGVmaW5lZCh1bml0cykgPyB1bml0cyA6ICdtaWxsaXNlY29uZCcpO1xuICAgIGlmICh1bml0cyA9PT0gJ21pbGxpc2Vjb25kJykge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZU9mKCkgPCBsb2NhbElucHV0LnZhbHVlT2YoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmVuZE9mKHVuaXRzKS52YWx1ZU9mKCkgPCBsb2NhbElucHV0LnZhbHVlT2YoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGlzQmV0d2VlbiAoZnJvbSwgdG8sIHVuaXRzLCBpbmNsdXNpdml0eSkge1xuICAgIGluY2x1c2l2aXR5ID0gaW5jbHVzaXZpdHkgfHwgJygpJztcbiAgICByZXR1cm4gKGluY2x1c2l2aXR5WzBdID09PSAnKCcgPyB0aGlzLmlzQWZ0ZXIoZnJvbSwgdW5pdHMpIDogIXRoaXMuaXNCZWZvcmUoZnJvbSwgdW5pdHMpKSAmJlxuICAgICAgICAoaW5jbHVzaXZpdHlbMV0gPT09ICcpJyA/IHRoaXMuaXNCZWZvcmUodG8sIHVuaXRzKSA6ICF0aGlzLmlzQWZ0ZXIodG8sIHVuaXRzKSk7XG59XG5cbmZ1bmN0aW9uIGlzU2FtZSAoaW5wdXQsIHVuaXRzKSB7XG4gICAgdmFyIGxvY2FsSW5wdXQgPSBpc01vbWVudChpbnB1dCkgPyBpbnB1dCA6IGNyZWF0ZUxvY2FsKGlucHV0KSxcbiAgICAgICAgaW5wdXRNcztcbiAgICBpZiAoISh0aGlzLmlzVmFsaWQoKSAmJiBsb2NhbElucHV0LmlzVmFsaWQoKSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzIHx8ICdtaWxsaXNlY29uZCcpO1xuICAgIGlmICh1bml0cyA9PT0gJ21pbGxpc2Vjb25kJykge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZU9mKCkgPT09IGxvY2FsSW5wdXQudmFsdWVPZigpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGlucHV0TXMgPSBsb2NhbElucHV0LnZhbHVlT2YoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5zdGFydE9mKHVuaXRzKS52YWx1ZU9mKCkgPD0gaW5wdXRNcyAmJiBpbnB1dE1zIDw9IHRoaXMuY2xvbmUoKS5lbmRPZih1bml0cykudmFsdWVPZigpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaXNTYW1lT3JBZnRlciAoaW5wdXQsIHVuaXRzKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNTYW1lKGlucHV0LCB1bml0cykgfHwgdGhpcy5pc0FmdGVyKGlucHV0LHVuaXRzKTtcbn1cblxuZnVuY3Rpb24gaXNTYW1lT3JCZWZvcmUgKGlucHV0LCB1bml0cykge1xuICAgIHJldHVybiB0aGlzLmlzU2FtZShpbnB1dCwgdW5pdHMpIHx8IHRoaXMuaXNCZWZvcmUoaW5wdXQsdW5pdHMpO1xufVxuXG5mdW5jdGlvbiBkaWZmIChpbnB1dCwgdW5pdHMsIGFzRmxvYXQpIHtcbiAgICB2YXIgdGhhdCxcbiAgICAgICAgem9uZURlbHRhLFxuICAgICAgICBkZWx0YSwgb3V0cHV0O1xuXG4gICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICByZXR1cm4gTmFOO1xuICAgIH1cblxuICAgIHRoYXQgPSBjbG9uZVdpdGhPZmZzZXQoaW5wdXQsIHRoaXMpO1xuXG4gICAgaWYgKCF0aGF0LmlzVmFsaWQoKSkge1xuICAgICAgICByZXR1cm4gTmFOO1xuICAgIH1cblxuICAgIHpvbmVEZWx0YSA9ICh0aGF0LnV0Y09mZnNldCgpIC0gdGhpcy51dGNPZmZzZXQoKSkgKiA2ZTQ7XG5cbiAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcblxuICAgIHN3aXRjaCAodW5pdHMpIHtcbiAgICAgICAgY2FzZSAneWVhcic6IG91dHB1dCA9IG1vbnRoRGlmZih0aGlzLCB0aGF0KSAvIDEyOyBicmVhaztcbiAgICAgICAgY2FzZSAnbW9udGgnOiBvdXRwdXQgPSBtb250aERpZmYodGhpcywgdGhhdCk7IGJyZWFrO1xuICAgICAgICBjYXNlICdxdWFydGVyJzogb3V0cHV0ID0gbW9udGhEaWZmKHRoaXMsIHRoYXQpIC8gMzsgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3NlY29uZCc6IG91dHB1dCA9ICh0aGlzIC0gdGhhdCkgLyAxZTM7IGJyZWFrOyAvLyAxMDAwXG4gICAgICAgIGNhc2UgJ21pbnV0ZSc6IG91dHB1dCA9ICh0aGlzIC0gdGhhdCkgLyA2ZTQ7IGJyZWFrOyAvLyAxMDAwICogNjBcbiAgICAgICAgY2FzZSAnaG91cic6IG91dHB1dCA9ICh0aGlzIC0gdGhhdCkgLyAzNmU1OyBicmVhazsgLy8gMTAwMCAqIDYwICogNjBcbiAgICAgICAgY2FzZSAnZGF5Jzogb3V0cHV0ID0gKHRoaXMgLSB0aGF0IC0gem9uZURlbHRhKSAvIDg2NGU1OyBicmVhazsgLy8gMTAwMCAqIDYwICogNjAgKiAyNCwgbmVnYXRlIGRzdFxuICAgICAgICBjYXNlICd3ZWVrJzogb3V0cHV0ID0gKHRoaXMgLSB0aGF0IC0gem9uZURlbHRhKSAvIDYwNDhlNTsgYnJlYWs7IC8vIDEwMDAgKiA2MCAqIDYwICogMjQgKiA3LCBuZWdhdGUgZHN0XG4gICAgICAgIGRlZmF1bHQ6IG91dHB1dCA9IHRoaXMgLSB0aGF0O1xuICAgIH1cblxuICAgIHJldHVybiBhc0Zsb2F0ID8gb3V0cHV0IDogYWJzRmxvb3Iob3V0cHV0KTtcbn1cblxuZnVuY3Rpb24gbW9udGhEaWZmIChhLCBiKSB7XG4gICAgLy8gZGlmZmVyZW5jZSBpbiBtb250aHNcbiAgICB2YXIgd2hvbGVNb250aERpZmYgPSAoKGIueWVhcigpIC0gYS55ZWFyKCkpICogMTIpICsgKGIubW9udGgoKSAtIGEubW9udGgoKSksXG4gICAgICAgIC8vIGIgaXMgaW4gKGFuY2hvciAtIDEgbW9udGgsIGFuY2hvciArIDEgbW9udGgpXG4gICAgICAgIGFuY2hvciA9IGEuY2xvbmUoKS5hZGQod2hvbGVNb250aERpZmYsICdtb250aHMnKSxcbiAgICAgICAgYW5jaG9yMiwgYWRqdXN0O1xuXG4gICAgaWYgKGIgLSBhbmNob3IgPCAwKSB7XG4gICAgICAgIGFuY2hvcjIgPSBhLmNsb25lKCkuYWRkKHdob2xlTW9udGhEaWZmIC0gMSwgJ21vbnRocycpO1xuICAgICAgICAvLyBsaW5lYXIgYWNyb3NzIHRoZSBtb250aFxuICAgICAgICBhZGp1c3QgPSAoYiAtIGFuY2hvcikgLyAoYW5jaG9yIC0gYW5jaG9yMik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYW5jaG9yMiA9IGEuY2xvbmUoKS5hZGQod2hvbGVNb250aERpZmYgKyAxLCAnbW9udGhzJyk7XG4gICAgICAgIC8vIGxpbmVhciBhY3Jvc3MgdGhlIG1vbnRoXG4gICAgICAgIGFkanVzdCA9IChiIC0gYW5jaG9yKSAvIChhbmNob3IyIC0gYW5jaG9yKTtcbiAgICB9XG5cbiAgICAvL2NoZWNrIGZvciBuZWdhdGl2ZSB6ZXJvLCByZXR1cm4gemVybyBpZiBuZWdhdGl2ZSB6ZXJvXG4gICAgcmV0dXJuIC0od2hvbGVNb250aERpZmYgKyBhZGp1c3QpIHx8IDA7XG59XG5cbmhvb2tzLmRlZmF1bHRGb3JtYXQgPSAnWVlZWS1NTS1ERFRISDptbTpzc1onO1xuaG9va3MuZGVmYXVsdEZvcm1hdFV0YyA9ICdZWVlZLU1NLUREVEhIOm1tOnNzW1pdJztcblxuZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkubG9jYWxlKCdlbicpLmZvcm1hdCgnZGRkIE1NTSBERCBZWVlZIEhIOm1tOnNzIFtHTVRdWlonKTtcbn1cblxuZnVuY3Rpb24gdG9JU09TdHJpbmcoa2VlcE9mZnNldCkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciB1dGMgPSBrZWVwT2Zmc2V0ICE9PSB0cnVlO1xuICAgIHZhciBtID0gdXRjID8gdGhpcy5jbG9uZSgpLnV0YygpIDogdGhpcztcbiAgICBpZiAobS55ZWFyKCkgPCAwIHx8IG0ueWVhcigpID4gOTk5OSkge1xuICAgICAgICByZXR1cm4gZm9ybWF0TW9tZW50KG0sIHV0YyA/ICdZWVlZWVktTU0tRERbVF1ISDptbTpzcy5TU1NbWl0nIDogJ1lZWVlZWS1NTS1ERFtUXUhIOm1tOnNzLlNTU1onKTtcbiAgICB9XG4gICAgaWYgKGlzRnVuY3Rpb24oRGF0ZS5wcm90b3R5cGUudG9JU09TdHJpbmcpKSB7XG4gICAgICAgIC8vIG5hdGl2ZSBpbXBsZW1lbnRhdGlvbiBpcyB+NTB4IGZhc3RlciwgdXNlIGl0IHdoZW4gd2UgY2FuXG4gICAgICAgIGlmICh1dGMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUodGhpcy5fZC52YWx1ZU9mKCkpLnRvSVNPU3RyaW5nKCkucmVwbGFjZSgnWicsIGZvcm1hdE1vbWVudChtLCAnWicpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZm9ybWF0TW9tZW50KG0sIHV0YyA/ICdZWVlZLU1NLUREW1RdSEg6bW06c3MuU1NTW1pdJyA6ICdZWVlZLU1NLUREW1RdSEg6bW06c3MuU1NTWicpO1xufVxuXG4vKipcbiAqIFJldHVybiBhIGh1bWFuIHJlYWRhYmxlIHJlcHJlc2VudGF0aW9uIG9mIGEgbW9tZW50IHRoYXQgY2FuXG4gKiBhbHNvIGJlIGV2YWx1YXRlZCB0byBnZXQgYSBuZXcgbW9tZW50IHdoaWNoIGlzIHRoZSBzYW1lXG4gKlxuICogQGxpbmsgaHR0cHM6Ly9ub2RlanMub3JnL2Rpc3QvbGF0ZXN0L2RvY3MvYXBpL3V0aWwuaHRtbCN1dGlsX2N1c3RvbV9pbnNwZWN0X2Z1bmN0aW9uX29uX29iamVjdHNcbiAqL1xuZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICByZXR1cm4gJ21vbWVudC5pbnZhbGlkKC8qICcgKyB0aGlzLl9pICsgJyAqLyknO1xuICAgIH1cbiAgICB2YXIgZnVuYyA9ICdtb21lbnQnO1xuICAgIHZhciB6b25lID0gJyc7XG4gICAgaWYgKCF0aGlzLmlzTG9jYWwoKSkge1xuICAgICAgICBmdW5jID0gdGhpcy51dGNPZmZzZXQoKSA9PT0gMCA/ICdtb21lbnQudXRjJyA6ICdtb21lbnQucGFyc2Vab25lJztcbiAgICAgICAgem9uZSA9ICdaJztcbiAgICB9XG4gICAgdmFyIHByZWZpeCA9ICdbJyArIGZ1bmMgKyAnKFwiXSc7XG4gICAgdmFyIHllYXIgPSAoMCA8PSB0aGlzLnllYXIoKSAmJiB0aGlzLnllYXIoKSA8PSA5OTk5KSA/ICdZWVlZJyA6ICdZWVlZWVknO1xuICAgIHZhciBkYXRldGltZSA9ICctTU0tRERbVF1ISDptbTpzcy5TU1MnO1xuICAgIHZhciBzdWZmaXggPSB6b25lICsgJ1tcIildJztcblxuICAgIHJldHVybiB0aGlzLmZvcm1hdChwcmVmaXggKyB5ZWFyICsgZGF0ZXRpbWUgKyBzdWZmaXgpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXQgKGlucHV0U3RyaW5nKSB7XG4gICAgaWYgKCFpbnB1dFN0cmluZykge1xuICAgICAgICBpbnB1dFN0cmluZyA9IHRoaXMuaXNVdGMoKSA/IGhvb2tzLmRlZmF1bHRGb3JtYXRVdGMgOiBob29rcy5kZWZhdWx0Rm9ybWF0O1xuICAgIH1cbiAgICB2YXIgb3V0cHV0ID0gZm9ybWF0TW9tZW50KHRoaXMsIGlucHV0U3RyaW5nKTtcbiAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkucG9zdGZvcm1hdChvdXRwdXQpO1xufVxuXG5mdW5jdGlvbiBmcm9tICh0aW1lLCB3aXRob3V0U3VmZml4KSB7XG4gICAgaWYgKHRoaXMuaXNWYWxpZCgpICYmXG4gICAgICAgICAgICAoKGlzTW9tZW50KHRpbWUpICYmIHRpbWUuaXNWYWxpZCgpKSB8fFxuICAgICAgICAgICAgIGNyZWF0ZUxvY2FsKHRpbWUpLmlzVmFsaWQoKSkpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUR1cmF0aW9uKHt0bzogdGhpcywgZnJvbTogdGltZX0pLmxvY2FsZSh0aGlzLmxvY2FsZSgpKS5odW1hbml6ZSghd2l0aG91dFN1ZmZpeCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLmludmFsaWREYXRlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBmcm9tTm93ICh3aXRob3V0U3VmZml4KSB7XG4gICAgcmV0dXJuIHRoaXMuZnJvbShjcmVhdGVMb2NhbCgpLCB3aXRob3V0U3VmZml4KTtcbn1cblxuZnVuY3Rpb24gdG8gKHRpbWUsIHdpdGhvdXRTdWZmaXgpIHtcbiAgICBpZiAodGhpcy5pc1ZhbGlkKCkgJiZcbiAgICAgICAgICAgICgoaXNNb21lbnQodGltZSkgJiYgdGltZS5pc1ZhbGlkKCkpIHx8XG4gICAgICAgICAgICAgY3JlYXRlTG9jYWwodGltZSkuaXNWYWxpZCgpKSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlRHVyYXRpb24oe2Zyb206IHRoaXMsIHRvOiB0aW1lfSkubG9jYWxlKHRoaXMubG9jYWxlKCkpLmh1bWFuaXplKCF3aXRob3V0U3VmZml4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkuaW52YWxpZERhdGUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHRvTm93ICh3aXRob3V0U3VmZml4KSB7XG4gICAgcmV0dXJuIHRoaXMudG8oY3JlYXRlTG9jYWwoKSwgd2l0aG91dFN1ZmZpeCk7XG59XG5cbi8vIElmIHBhc3NlZCBhIGxvY2FsZSBrZXksIGl0IHdpbGwgc2V0IHRoZSBsb2NhbGUgZm9yIHRoaXNcbi8vIGluc3RhbmNlLiAgT3RoZXJ3aXNlLCBpdCB3aWxsIHJldHVybiB0aGUgbG9jYWxlIGNvbmZpZ3VyYXRpb25cbi8vIHZhcmlhYmxlcyBmb3IgdGhpcyBpbnN0YW5jZS5cbmZ1bmN0aW9uIGxvY2FsZSAoa2V5KSB7XG4gICAgdmFyIG5ld0xvY2FsZURhdGE7XG5cbiAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2FsZS5fYWJicjtcbiAgICB9IGVsc2Uge1xuICAgICAgICBuZXdMb2NhbGVEYXRhID0gZ2V0TG9jYWxlKGtleSk7XG4gICAgICAgIGlmIChuZXdMb2NhbGVEYXRhICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvY2FsZSA9IG5ld0xvY2FsZURhdGE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuXG52YXIgbGFuZyA9IGRlcHJlY2F0ZShcbiAgICAnbW9tZW50KCkubGFuZygpIGlzIGRlcHJlY2F0ZWQuIEluc3RlYWQsIHVzZSBtb21lbnQoKS5sb2NhbGVEYXRhKCkgdG8gZ2V0IHRoZSBsYW5ndWFnZSBjb25maWd1cmF0aW9uLiBVc2UgbW9tZW50KCkubG9jYWxlKCkgdG8gY2hhbmdlIGxhbmd1YWdlcy4nLFxuICAgIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGUoa2V5KTtcbiAgICAgICAgfVxuICAgIH1cbik7XG5cbmZ1bmN0aW9uIGxvY2FsZURhdGEgKCkge1xuICAgIHJldHVybiB0aGlzLl9sb2NhbGU7XG59XG5cbmZ1bmN0aW9uIHN0YXJ0T2YgKHVuaXRzKSB7XG4gICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgLy8gdGhlIGZvbGxvd2luZyBzd2l0Y2ggaW50ZW50aW9uYWxseSBvbWl0cyBicmVhayBrZXl3b3Jkc1xuICAgIC8vIHRvIHV0aWxpemUgZmFsbGluZyB0aHJvdWdoIHRoZSBjYXNlcy5cbiAgICBzd2l0Y2ggKHVuaXRzKSB7XG4gICAgICAgIGNhc2UgJ3llYXInOlxuICAgICAgICAgICAgdGhpcy5tb250aCgwKTtcbiAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgY2FzZSAncXVhcnRlcic6XG4gICAgICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgICAgICAgIHRoaXMuZGF0ZSgxKTtcbiAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgY2FzZSAnd2Vlayc6XG4gICAgICAgIGNhc2UgJ2lzb1dlZWsnOlxuICAgICAgICBjYXNlICdkYXknOlxuICAgICAgICBjYXNlICdkYXRlJzpcbiAgICAgICAgICAgIHRoaXMuaG91cnMoMCk7XG4gICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgIGNhc2UgJ2hvdXInOlxuICAgICAgICAgICAgdGhpcy5taW51dGVzKDApO1xuICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICBjYXNlICdtaW51dGUnOlxuICAgICAgICAgICAgdGhpcy5zZWNvbmRzKDApO1xuICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICBjYXNlICdzZWNvbmQnOlxuICAgICAgICAgICAgdGhpcy5taWxsaXNlY29uZHMoMCk7XG4gICAgfVxuXG4gICAgLy8gd2Vla3MgYXJlIGEgc3BlY2lhbCBjYXNlXG4gICAgaWYgKHVuaXRzID09PSAnd2VlaycpIHtcbiAgICAgICAgdGhpcy53ZWVrZGF5KDApO1xuICAgIH1cbiAgICBpZiAodW5pdHMgPT09ICdpc29XZWVrJykge1xuICAgICAgICB0aGlzLmlzb1dlZWtkYXkoMSk7XG4gICAgfVxuXG4gICAgLy8gcXVhcnRlcnMgYXJlIGFsc28gc3BlY2lhbFxuICAgIGlmICh1bml0cyA9PT0gJ3F1YXJ0ZXInKSB7XG4gICAgICAgIHRoaXMubW9udGgoTWF0aC5mbG9vcih0aGlzLm1vbnRoKCkgLyAzKSAqIDMpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xufVxuXG5mdW5jdGlvbiBlbmRPZiAodW5pdHMpIHtcbiAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICBpZiAodW5pdHMgPT09IHVuZGVmaW5lZCB8fCB1bml0cyA9PT0gJ21pbGxpc2Vjb25kJykge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyAnZGF0ZScgaXMgYW4gYWxpYXMgZm9yICdkYXknLCBzbyBpdCBzaG91bGQgYmUgY29uc2lkZXJlZCBhcyBzdWNoLlxuICAgIGlmICh1bml0cyA9PT0gJ2RhdGUnKSB7XG4gICAgICAgIHVuaXRzID0gJ2RheSc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3RhcnRPZih1bml0cykuYWRkKDEsICh1bml0cyA9PT0gJ2lzb1dlZWsnID8gJ3dlZWsnIDogdW5pdHMpKS5zdWJ0cmFjdCgxLCAnbXMnKTtcbn1cblxuZnVuY3Rpb24gdmFsdWVPZiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2QudmFsdWVPZigpIC0gKCh0aGlzLl9vZmZzZXQgfHwgMCkgKiA2MDAwMCk7XG59XG5cbmZ1bmN0aW9uIHVuaXggKCkge1xuICAgIHJldHVybiBNYXRoLmZsb29yKHRoaXMudmFsdWVPZigpIC8gMTAwMCk7XG59XG5cbmZ1bmN0aW9uIHRvRGF0ZSAoKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKHRoaXMudmFsdWVPZigpKTtcbn1cblxuZnVuY3Rpb24gdG9BcnJheSAoKSB7XG4gICAgdmFyIG0gPSB0aGlzO1xuICAgIHJldHVybiBbbS55ZWFyKCksIG0ubW9udGgoKSwgbS5kYXRlKCksIG0uaG91cigpLCBtLm1pbnV0ZSgpLCBtLnNlY29uZCgpLCBtLm1pbGxpc2Vjb25kKCldO1xufVxuXG5mdW5jdGlvbiB0b09iamVjdCAoKSB7XG4gICAgdmFyIG0gPSB0aGlzO1xuICAgIHJldHVybiB7XG4gICAgICAgIHllYXJzOiBtLnllYXIoKSxcbiAgICAgICAgbW9udGhzOiBtLm1vbnRoKCksXG4gICAgICAgIGRhdGU6IG0uZGF0ZSgpLFxuICAgICAgICBob3VyczogbS5ob3VycygpLFxuICAgICAgICBtaW51dGVzOiBtLm1pbnV0ZXMoKSxcbiAgICAgICAgc2Vjb25kczogbS5zZWNvbmRzKCksXG4gICAgICAgIG1pbGxpc2Vjb25kczogbS5taWxsaXNlY29uZHMoKVxuICAgIH07XG59XG5cbmZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gICAgLy8gbmV3IERhdGUoTmFOKS50b0pTT04oKSA9PT0gbnVsbFxuICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/IHRoaXMudG9JU09TdHJpbmcoKSA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzVmFsaWQkMiAoKSB7XG4gICAgcmV0dXJuIGlzVmFsaWQodGhpcyk7XG59XG5cbmZ1bmN0aW9uIHBhcnNpbmdGbGFncyAoKSB7XG4gICAgcmV0dXJuIGV4dGVuZCh7fSwgZ2V0UGFyc2luZ0ZsYWdzKHRoaXMpKTtcbn1cblxuZnVuY3Rpb24gaW52YWxpZEF0ICgpIHtcbiAgICByZXR1cm4gZ2V0UGFyc2luZ0ZsYWdzKHRoaXMpLm92ZXJmbG93O1xufVxuXG5mdW5jdGlvbiBjcmVhdGlvbkRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaW5wdXQ6IHRoaXMuX2ksXG4gICAgICAgIGZvcm1hdDogdGhpcy5fZixcbiAgICAgICAgbG9jYWxlOiB0aGlzLl9sb2NhbGUsXG4gICAgICAgIGlzVVRDOiB0aGlzLl9pc1VUQyxcbiAgICAgICAgc3RyaWN0OiB0aGlzLl9zdHJpY3RcbiAgICB9O1xufVxuXG4vLyBGT1JNQVRUSU5HXG5cbmFkZEZvcm1hdFRva2VuKDAsIFsnZ2cnLCAyXSwgMCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLndlZWtZZWFyKCkgJSAxMDA7XG59KTtcblxuYWRkRm9ybWF0VG9rZW4oMCwgWydHRycsIDJdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNvV2Vla1llYXIoKSAlIDEwMDtcbn0pO1xuXG5mdW5jdGlvbiBhZGRXZWVrWWVhckZvcm1hdFRva2VuICh0b2tlbiwgZ2V0dGVyKSB7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgW3Rva2VuLCB0b2tlbi5sZW5ndGhdLCAwLCBnZXR0ZXIpO1xufVxuXG5hZGRXZWVrWWVhckZvcm1hdFRva2VuKCdnZ2dnJywgICAgICd3ZWVrWWVhcicpO1xuYWRkV2Vla1llYXJGb3JtYXRUb2tlbignZ2dnZ2cnLCAgICAnd2Vla1llYXInKTtcbmFkZFdlZWtZZWFyRm9ybWF0VG9rZW4oJ0dHR0cnLCAgJ2lzb1dlZWtZZWFyJyk7XG5hZGRXZWVrWWVhckZvcm1hdFRva2VuKCdHR0dHRycsICdpc29XZWVrWWVhcicpO1xuXG4vLyBBTElBU0VTXG5cbmFkZFVuaXRBbGlhcygnd2Vla1llYXInLCAnZ2cnKTtcbmFkZFVuaXRBbGlhcygnaXNvV2Vla1llYXInLCAnR0cnKTtcblxuLy8gUFJJT1JJVFlcblxuYWRkVW5pdFByaW9yaXR5KCd3ZWVrWWVhcicsIDEpO1xuYWRkVW5pdFByaW9yaXR5KCdpc29XZWVrWWVhcicsIDEpO1xuXG5cbi8vIFBBUlNJTkdcblxuYWRkUmVnZXhUb2tlbignRycsICAgICAgbWF0Y2hTaWduZWQpO1xuYWRkUmVnZXhUb2tlbignZycsICAgICAgbWF0Y2hTaWduZWQpO1xuYWRkUmVnZXhUb2tlbignR0cnLCAgICAgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuYWRkUmVnZXhUb2tlbignZ2cnLCAgICAgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuYWRkUmVnZXhUb2tlbignR0dHRycsICAgbWF0Y2gxdG80LCBtYXRjaDQpO1xuYWRkUmVnZXhUb2tlbignZ2dnZycsICAgbWF0Y2gxdG80LCBtYXRjaDQpO1xuYWRkUmVnZXhUb2tlbignR0dHR0cnLCAgbWF0Y2gxdG82LCBtYXRjaDYpO1xuYWRkUmVnZXhUb2tlbignZ2dnZ2cnLCAgbWF0Y2gxdG82LCBtYXRjaDYpO1xuXG5hZGRXZWVrUGFyc2VUb2tlbihbJ2dnZ2cnLCAnZ2dnZ2cnLCAnR0dHRycsICdHR0dHRyddLCBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcbiAgICB3ZWVrW3Rva2VuLnN1YnN0cigwLCAyKV0gPSB0b0ludChpbnB1dCk7XG59KTtcblxuYWRkV2Vla1BhcnNlVG9rZW4oWydnZycsICdHRyddLCBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcbiAgICB3ZWVrW3Rva2VuXSA9IGhvb2tzLnBhcnNlVHdvRGlnaXRZZWFyKGlucHV0KTtcbn0pO1xuXG4vLyBNT01FTlRTXG5cbmZ1bmN0aW9uIGdldFNldFdlZWtZZWFyIChpbnB1dCkge1xuICAgIHJldHVybiBnZXRTZXRXZWVrWWVhckhlbHBlci5jYWxsKHRoaXMsXG4gICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgIHRoaXMud2VlaygpLFxuICAgICAgICAgICAgdGhpcy53ZWVrZGF5KCksXG4gICAgICAgICAgICB0aGlzLmxvY2FsZURhdGEoKS5fd2Vlay5kb3csXG4gICAgICAgICAgICB0aGlzLmxvY2FsZURhdGEoKS5fd2Vlay5kb3kpO1xufVxuXG5mdW5jdGlvbiBnZXRTZXRJU09XZWVrWWVhciAoaW5wdXQpIHtcbiAgICByZXR1cm4gZ2V0U2V0V2Vla1llYXJIZWxwZXIuY2FsbCh0aGlzLFxuICAgICAgICAgICAgaW5wdXQsIHRoaXMuaXNvV2VlaygpLCB0aGlzLmlzb1dlZWtkYXkoKSwgMSwgNCk7XG59XG5cbmZ1bmN0aW9uIGdldElTT1dlZWtzSW5ZZWFyICgpIHtcbiAgICByZXR1cm4gd2Vla3NJblllYXIodGhpcy55ZWFyKCksIDEsIDQpO1xufVxuXG5mdW5jdGlvbiBnZXRXZWVrc0luWWVhciAoKSB7XG4gICAgdmFyIHdlZWtJbmZvID0gdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWs7XG4gICAgcmV0dXJuIHdlZWtzSW5ZZWFyKHRoaXMueWVhcigpLCB3ZWVrSW5mby5kb3csIHdlZWtJbmZvLmRveSk7XG59XG5cbmZ1bmN0aW9uIGdldFNldFdlZWtZZWFySGVscGVyKGlucHV0LCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSkge1xuICAgIHZhciB3ZWVrc1RhcmdldDtcbiAgICBpZiAoaW5wdXQgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gd2Vla09mWWVhcih0aGlzLCBkb3csIGRveSkueWVhcjtcbiAgICB9IGVsc2Uge1xuICAgICAgICB3ZWVrc1RhcmdldCA9IHdlZWtzSW5ZZWFyKGlucHV0LCBkb3csIGRveSk7XG4gICAgICAgIGlmICh3ZWVrID4gd2Vla3NUYXJnZXQpIHtcbiAgICAgICAgICAgIHdlZWsgPSB3ZWVrc1RhcmdldDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2V0V2Vla0FsbC5jYWxsKHRoaXMsIGlucHV0LCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBzZXRXZWVrQWxsKHdlZWtZZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSkge1xuICAgIHZhciBkYXlPZlllYXJEYXRhID0gZGF5T2ZZZWFyRnJvbVdlZWtzKHdlZWtZZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSksXG4gICAgICAgIGRhdGUgPSBjcmVhdGVVVENEYXRlKGRheU9mWWVhckRhdGEueWVhciwgMCwgZGF5T2ZZZWFyRGF0YS5kYXlPZlllYXIpO1xuXG4gICAgdGhpcy55ZWFyKGRhdGUuZ2V0VVRDRnVsbFllYXIoKSk7XG4gICAgdGhpcy5tb250aChkYXRlLmdldFVUQ01vbnRoKCkpO1xuICAgIHRoaXMuZGF0ZShkYXRlLmdldFVUQ0RhdGUoKSk7XG4gICAgcmV0dXJuIHRoaXM7XG59XG5cbi8vIEZPUk1BVFRJTkdcblxuYWRkRm9ybWF0VG9rZW4oJ1EnLCAwLCAnUW8nLCAncXVhcnRlcicpO1xuXG4vLyBBTElBU0VTXG5cbmFkZFVuaXRBbGlhcygncXVhcnRlcicsICdRJyk7XG5cbi8vIFBSSU9SSVRZXG5cbmFkZFVuaXRQcmlvcml0eSgncXVhcnRlcicsIDcpO1xuXG4vLyBQQVJTSU5HXG5cbmFkZFJlZ2V4VG9rZW4oJ1EnLCBtYXRjaDEpO1xuYWRkUGFyc2VUb2tlbignUScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICBhcnJheVtNT05USF0gPSAodG9JbnQoaW5wdXQpIC0gMSkgKiAzO1xufSk7XG5cbi8vIE1PTUVOVFNcblxuZnVuY3Rpb24gZ2V0U2V0UXVhcnRlciAoaW5wdXQpIHtcbiAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IE1hdGguY2VpbCgodGhpcy5tb250aCgpICsgMSkgLyAzKSA6IHRoaXMubW9udGgoKGlucHV0IC0gMSkgKiAzICsgdGhpcy5tb250aCgpICUgMyk7XG59XG5cbi8vIEZPUk1BVFRJTkdcblxuYWRkRm9ybWF0VG9rZW4oJ0QnLCBbJ0REJywgMl0sICdEbycsICdkYXRlJyk7XG5cbi8vIEFMSUFTRVNcblxuYWRkVW5pdEFsaWFzKCdkYXRlJywgJ0QnKTtcblxuLy8gUFJJT1JPSVRZXG5hZGRVbml0UHJpb3JpdHkoJ2RhdGUnLCA5KTtcblxuLy8gUEFSU0lOR1xuXG5hZGRSZWdleFRva2VuKCdEJywgIG1hdGNoMXRvMik7XG5hZGRSZWdleFRva2VuKCdERCcsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbmFkZFJlZ2V4VG9rZW4oJ0RvJywgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAvLyBUT0RPOiBSZW1vdmUgXCJvcmRpbmFsUGFyc2VcIiBmYWxsYmFjayBpbiBuZXh0IG1ham9yIHJlbGVhc2UuXG4gICAgcmV0dXJuIGlzU3RyaWN0ID9cbiAgICAgIChsb2NhbGUuX2RheU9mTW9udGhPcmRpbmFsUGFyc2UgfHwgbG9jYWxlLl9vcmRpbmFsUGFyc2UpIDpcbiAgICAgIGxvY2FsZS5fZGF5T2ZNb250aE9yZGluYWxQYXJzZUxlbmllbnQ7XG59KTtcblxuYWRkUGFyc2VUb2tlbihbJ0QnLCAnREQnXSwgREFURSk7XG5hZGRQYXJzZVRva2VuKCdEbycsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICBhcnJheVtEQVRFXSA9IHRvSW50KGlucHV0Lm1hdGNoKG1hdGNoMXRvMilbMF0pO1xufSk7XG5cbi8vIE1PTUVOVFNcblxudmFyIGdldFNldERheU9mTW9udGggPSBtYWtlR2V0U2V0KCdEYXRlJywgdHJ1ZSk7XG5cbi8vIEZPUk1BVFRJTkdcblxuYWRkRm9ybWF0VG9rZW4oJ0RERCcsIFsnRERERCcsIDNdLCAnREREbycsICdkYXlPZlllYXInKTtcblxuLy8gQUxJQVNFU1xuXG5hZGRVbml0QWxpYXMoJ2RheU9mWWVhcicsICdEREQnKTtcblxuLy8gUFJJT1JJVFlcbmFkZFVuaXRQcmlvcml0eSgnZGF5T2ZZZWFyJywgNCk7XG5cbi8vIFBBUlNJTkdcblxuYWRkUmVnZXhUb2tlbignREREJywgIG1hdGNoMXRvMyk7XG5hZGRSZWdleFRva2VuKCdEREREJywgbWF0Y2gzKTtcbmFkZFBhcnNlVG9rZW4oWydEREQnLCAnRERERCddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICBjb25maWcuX2RheU9mWWVhciA9IHRvSW50KGlucHV0KTtcbn0pO1xuXG4vLyBIRUxQRVJTXG5cbi8vIE1PTUVOVFNcblxuZnVuY3Rpb24gZ2V0U2V0RGF5T2ZZZWFyIChpbnB1dCkge1xuICAgIHZhciBkYXlPZlllYXIgPSBNYXRoLnJvdW5kKCh0aGlzLmNsb25lKCkuc3RhcnRPZignZGF5JykgLSB0aGlzLmNsb25lKCkuc3RhcnRPZigneWVhcicpKSAvIDg2NGU1KSArIDE7XG4gICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyBkYXlPZlllYXIgOiB0aGlzLmFkZCgoaW5wdXQgLSBkYXlPZlllYXIpLCAnZCcpO1xufVxuXG4vLyBGT1JNQVRUSU5HXG5cbmFkZEZvcm1hdFRva2VuKCdtJywgWydtbScsIDJdLCAwLCAnbWludXRlJyk7XG5cbi8vIEFMSUFTRVNcblxuYWRkVW5pdEFsaWFzKCdtaW51dGUnLCAnbScpO1xuXG4vLyBQUklPUklUWVxuXG5hZGRVbml0UHJpb3JpdHkoJ21pbnV0ZScsIDE0KTtcblxuLy8gUEFSU0lOR1xuXG5hZGRSZWdleFRva2VuKCdtJywgIG1hdGNoMXRvMik7XG5hZGRSZWdleFRva2VuKCdtbScsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbmFkZFBhcnNlVG9rZW4oWydtJywgJ21tJ10sIE1JTlVURSk7XG5cbi8vIE1PTUVOVFNcblxudmFyIGdldFNldE1pbnV0ZSA9IG1ha2VHZXRTZXQoJ01pbnV0ZXMnLCBmYWxzZSk7XG5cbi8vIEZPUk1BVFRJTkdcblxuYWRkRm9ybWF0VG9rZW4oJ3MnLCBbJ3NzJywgMl0sIDAsICdzZWNvbmQnKTtcblxuLy8gQUxJQVNFU1xuXG5hZGRVbml0QWxpYXMoJ3NlY29uZCcsICdzJyk7XG5cbi8vIFBSSU9SSVRZXG5cbmFkZFVuaXRQcmlvcml0eSgnc2Vjb25kJywgMTUpO1xuXG4vLyBQQVJTSU5HXG5cbmFkZFJlZ2V4VG9rZW4oJ3MnLCAgbWF0Y2gxdG8yKTtcbmFkZFJlZ2V4VG9rZW4oJ3NzJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuYWRkUGFyc2VUb2tlbihbJ3MnLCAnc3MnXSwgU0VDT05EKTtcblxuLy8gTU9NRU5UU1xuXG52YXIgZ2V0U2V0U2Vjb25kID0gbWFrZUdldFNldCgnU2Vjb25kcycsIGZhbHNlKTtcblxuLy8gRk9STUFUVElOR1xuXG5hZGRGb3JtYXRUb2tlbignUycsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gfn4odGhpcy5taWxsaXNlY29uZCgpIC8gMTAwKTtcbn0pO1xuXG5hZGRGb3JtYXRUb2tlbigwLCBbJ1NTJywgMl0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gfn4odGhpcy5taWxsaXNlY29uZCgpIC8gMTApO1xufSk7XG5cbmFkZEZvcm1hdFRva2VuKDAsIFsnU1NTJywgM10sIDAsICdtaWxsaXNlY29uZCcpO1xuYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTJywgNF0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTA7XG59KTtcbmFkZEZvcm1hdFRva2VuKDAsIFsnU1NTU1MnLCA1XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDA7XG59KTtcbmFkZEZvcm1hdFRva2VuKDAsIFsnU1NTU1NTJywgNl0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwMDtcbn0pO1xuYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTU1NTJywgN10sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwMDA7XG59KTtcbmFkZEZvcm1hdFRva2VuKDAsIFsnU1NTU1NTU1MnLCA4XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDAwMDA7XG59KTtcbmFkZEZvcm1hdFRva2VuKDAsIFsnU1NTU1NTU1NTJywgOV0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwMDAwMDtcbn0pO1xuXG5cbi8vIEFMSUFTRVNcblxuYWRkVW5pdEFsaWFzKCdtaWxsaXNlY29uZCcsICdtcycpO1xuXG4vLyBQUklPUklUWVxuXG5hZGRVbml0UHJpb3JpdHkoJ21pbGxpc2Vjb25kJywgMTYpO1xuXG4vLyBQQVJTSU5HXG5cbmFkZFJlZ2V4VG9rZW4oJ1MnLCAgICBtYXRjaDF0bzMsIG1hdGNoMSk7XG5hZGRSZWdleFRva2VuKCdTUycsICAgbWF0Y2gxdG8zLCBtYXRjaDIpO1xuYWRkUmVnZXhUb2tlbignU1NTJywgIG1hdGNoMXRvMywgbWF0Y2gzKTtcblxudmFyIHRva2VuO1xuZm9yICh0b2tlbiA9ICdTU1NTJzsgdG9rZW4ubGVuZ3RoIDw9IDk7IHRva2VuICs9ICdTJykge1xuICAgIGFkZFJlZ2V4VG9rZW4odG9rZW4sIG1hdGNoVW5zaWduZWQpO1xufVxuXG5mdW5jdGlvbiBwYXJzZU1zKGlucHV0LCBhcnJheSkge1xuICAgIGFycmF5W01JTExJU0VDT05EXSA9IHRvSW50KCgnMC4nICsgaW5wdXQpICogMTAwMCk7XG59XG5cbmZvciAodG9rZW4gPSAnUyc7IHRva2VuLmxlbmd0aCA8PSA5OyB0b2tlbiArPSAnUycpIHtcbiAgICBhZGRQYXJzZVRva2VuKHRva2VuLCBwYXJzZU1zKTtcbn1cbi8vIE1PTUVOVFNcblxudmFyIGdldFNldE1pbGxpc2Vjb25kID0gbWFrZUdldFNldCgnTWlsbGlzZWNvbmRzJywgZmFsc2UpO1xuXG4vLyBGT1JNQVRUSU5HXG5cbmFkZEZvcm1hdFRva2VuKCd6JywgIDAsIDAsICd6b25lQWJicicpO1xuYWRkRm9ybWF0VG9rZW4oJ3p6JywgMCwgMCwgJ3pvbmVOYW1lJyk7XG5cbi8vIE1PTUVOVFNcblxuZnVuY3Rpb24gZ2V0Wm9uZUFiYnIgKCkge1xuICAgIHJldHVybiB0aGlzLl9pc1VUQyA/ICdVVEMnIDogJyc7XG59XG5cbmZ1bmN0aW9uIGdldFpvbmVOYW1lICgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNVVEMgPyAnQ29vcmRpbmF0ZWQgVW5pdmVyc2FsIFRpbWUnIDogJyc7XG59XG5cbnZhciBwcm90byA9IE1vbWVudC5wcm90b3R5cGU7XG5cbnByb3RvLmFkZCAgICAgICAgICAgICAgID0gYWRkO1xucHJvdG8uY2FsZW5kYXIgICAgICAgICAgPSBjYWxlbmRhciQxO1xucHJvdG8uY2xvbmUgICAgICAgICAgICAgPSBjbG9uZTtcbnByb3RvLmRpZmYgICAgICAgICAgICAgID0gZGlmZjtcbnByb3RvLmVuZE9mICAgICAgICAgICAgID0gZW5kT2Y7XG5wcm90by5mb3JtYXQgICAgICAgICAgICA9IGZvcm1hdDtcbnByb3RvLmZyb20gICAgICAgICAgICAgID0gZnJvbTtcbnByb3RvLmZyb21Ob3cgICAgICAgICAgID0gZnJvbU5vdztcbnByb3RvLnRvICAgICAgICAgICAgICAgID0gdG87XG5wcm90by50b05vdyAgICAgICAgICAgICA9IHRvTm93O1xucHJvdG8uZ2V0ICAgICAgICAgICAgICAgPSBzdHJpbmdHZXQ7XG5wcm90by5pbnZhbGlkQXQgICAgICAgICA9IGludmFsaWRBdDtcbnByb3RvLmlzQWZ0ZXIgICAgICAgICAgID0gaXNBZnRlcjtcbnByb3RvLmlzQmVmb3JlICAgICAgICAgID0gaXNCZWZvcmU7XG5wcm90by5pc0JldHdlZW4gICAgICAgICA9IGlzQmV0d2VlbjtcbnByb3RvLmlzU2FtZSAgICAgICAgICAgID0gaXNTYW1lO1xucHJvdG8uaXNTYW1lT3JBZnRlciAgICAgPSBpc1NhbWVPckFmdGVyO1xucHJvdG8uaXNTYW1lT3JCZWZvcmUgICAgPSBpc1NhbWVPckJlZm9yZTtcbnByb3RvLmlzVmFsaWQgICAgICAgICAgID0gaXNWYWxpZCQyO1xucHJvdG8ubGFuZyAgICAgICAgICAgICAgPSBsYW5nO1xucHJvdG8ubG9jYWxlICAgICAgICAgICAgPSBsb2NhbGU7XG5wcm90by5sb2NhbGVEYXRhICAgICAgICA9IGxvY2FsZURhdGE7XG5wcm90by5tYXggICAgICAgICAgICAgICA9IHByb3RvdHlwZU1heDtcbnByb3RvLm1pbiAgICAgICAgICAgICAgID0gcHJvdG90eXBlTWluO1xucHJvdG8ucGFyc2luZ0ZsYWdzICAgICAgPSBwYXJzaW5nRmxhZ3M7XG5wcm90by5zZXQgICAgICAgICAgICAgICA9IHN0cmluZ1NldDtcbnByb3RvLnN0YXJ0T2YgICAgICAgICAgID0gc3RhcnRPZjtcbnByb3RvLnN1YnRyYWN0ICAgICAgICAgID0gc3VidHJhY3Q7XG5wcm90by50b0FycmF5ICAgICAgICAgICA9IHRvQXJyYXk7XG5wcm90by50b09iamVjdCAgICAgICAgICA9IHRvT2JqZWN0O1xucHJvdG8udG9EYXRlICAgICAgICAgICAgPSB0b0RhdGU7XG5wcm90by50b0lTT1N0cmluZyAgICAgICA9IHRvSVNPU3RyaW5nO1xucHJvdG8uaW5zcGVjdCAgICAgICAgICAgPSBpbnNwZWN0O1xucHJvdG8udG9KU09OICAgICAgICAgICAgPSB0b0pTT047XG5wcm90by50b1N0cmluZyAgICAgICAgICA9IHRvU3RyaW5nO1xucHJvdG8udW5peCAgICAgICAgICAgICAgPSB1bml4O1xucHJvdG8udmFsdWVPZiAgICAgICAgICAgPSB2YWx1ZU9mO1xucHJvdG8uY3JlYXRpb25EYXRhICAgICAgPSBjcmVhdGlvbkRhdGE7XG5cbi8vIFllYXJcbnByb3RvLnllYXIgICAgICAgPSBnZXRTZXRZZWFyO1xucHJvdG8uaXNMZWFwWWVhciA9IGdldElzTGVhcFllYXI7XG5cbi8vIFdlZWsgWWVhclxucHJvdG8ud2Vla1llYXIgICAgPSBnZXRTZXRXZWVrWWVhcjtcbnByb3RvLmlzb1dlZWtZZWFyID0gZ2V0U2V0SVNPV2Vla1llYXI7XG5cbi8vIFF1YXJ0ZXJcbnByb3RvLnF1YXJ0ZXIgPSBwcm90by5xdWFydGVycyA9IGdldFNldFF1YXJ0ZXI7XG5cbi8vIE1vbnRoXG5wcm90by5tb250aCAgICAgICA9IGdldFNldE1vbnRoO1xucHJvdG8uZGF5c0luTW9udGggPSBnZXREYXlzSW5Nb250aDtcblxuLy8gV2Vla1xucHJvdG8ud2VlayAgICAgICAgICAgPSBwcm90by53ZWVrcyAgICAgICAgPSBnZXRTZXRXZWVrO1xucHJvdG8uaXNvV2VlayAgICAgICAgPSBwcm90by5pc29XZWVrcyAgICAgPSBnZXRTZXRJU09XZWVrO1xucHJvdG8ud2Vla3NJblllYXIgICAgPSBnZXRXZWVrc0luWWVhcjtcbnByb3RvLmlzb1dlZWtzSW5ZZWFyID0gZ2V0SVNPV2Vla3NJblllYXI7XG5cbi8vIERheVxucHJvdG8uZGF0ZSAgICAgICA9IGdldFNldERheU9mTW9udGg7XG5wcm90by5kYXkgICAgICAgID0gcHJvdG8uZGF5cyAgICAgICAgICAgICA9IGdldFNldERheU9mV2VlaztcbnByb3RvLndlZWtkYXkgICAgPSBnZXRTZXRMb2NhbGVEYXlPZldlZWs7XG5wcm90by5pc29XZWVrZGF5ID0gZ2V0U2V0SVNPRGF5T2ZXZWVrO1xucHJvdG8uZGF5T2ZZZWFyICA9IGdldFNldERheU9mWWVhcjtcblxuLy8gSG91clxucHJvdG8uaG91ciA9IHByb3RvLmhvdXJzID0gZ2V0U2V0SG91cjtcblxuLy8gTWludXRlXG5wcm90by5taW51dGUgPSBwcm90by5taW51dGVzID0gZ2V0U2V0TWludXRlO1xuXG4vLyBTZWNvbmRcbnByb3RvLnNlY29uZCA9IHByb3RvLnNlY29uZHMgPSBnZXRTZXRTZWNvbmQ7XG5cbi8vIE1pbGxpc2Vjb25kXG5wcm90by5taWxsaXNlY29uZCA9IHByb3RvLm1pbGxpc2Vjb25kcyA9IGdldFNldE1pbGxpc2Vjb25kO1xuXG4vLyBPZmZzZXRcbnByb3RvLnV0Y09mZnNldCAgICAgICAgICAgID0gZ2V0U2V0T2Zmc2V0O1xucHJvdG8udXRjICAgICAgICAgICAgICAgICAgPSBzZXRPZmZzZXRUb1VUQztcbnByb3RvLmxvY2FsICAgICAgICAgICAgICAgID0gc2V0T2Zmc2V0VG9Mb2NhbDtcbnByb3RvLnBhcnNlWm9uZSAgICAgICAgICAgID0gc2V0T2Zmc2V0VG9QYXJzZWRPZmZzZXQ7XG5wcm90by5oYXNBbGlnbmVkSG91ck9mZnNldCA9IGhhc0FsaWduZWRIb3VyT2Zmc2V0O1xucHJvdG8uaXNEU1QgICAgICAgICAgICAgICAgPSBpc0RheWxpZ2h0U2F2aW5nVGltZTtcbnByb3RvLmlzTG9jYWwgICAgICAgICAgICAgID0gaXNMb2NhbDtcbnByb3RvLmlzVXRjT2Zmc2V0ICAgICAgICAgID0gaXNVdGNPZmZzZXQ7XG5wcm90by5pc1V0YyAgICAgICAgICAgICAgICA9IGlzVXRjO1xucHJvdG8uaXNVVEMgICAgICAgICAgICAgICAgPSBpc1V0YztcblxuLy8gVGltZXpvbmVcbnByb3RvLnpvbmVBYmJyID0gZ2V0Wm9uZUFiYnI7XG5wcm90by56b25lTmFtZSA9IGdldFpvbmVOYW1lO1xuXG4vLyBEZXByZWNhdGlvbnNcbnByb3RvLmRhdGVzICA9IGRlcHJlY2F0ZSgnZGF0ZXMgYWNjZXNzb3IgaXMgZGVwcmVjYXRlZC4gVXNlIGRhdGUgaW5zdGVhZC4nLCBnZXRTZXREYXlPZk1vbnRoKTtcbnByb3RvLm1vbnRocyA9IGRlcHJlY2F0ZSgnbW9udGhzIGFjY2Vzc29yIGlzIGRlcHJlY2F0ZWQuIFVzZSBtb250aCBpbnN0ZWFkJywgZ2V0U2V0TW9udGgpO1xucHJvdG8ueWVhcnMgID0gZGVwcmVjYXRlKCd5ZWFycyBhY2Nlc3NvciBpcyBkZXByZWNhdGVkLiBVc2UgeWVhciBpbnN0ZWFkJywgZ2V0U2V0WWVhcik7XG5wcm90by56b25lICAgPSBkZXByZWNhdGUoJ21vbWVudCgpLnpvbmUgaXMgZGVwcmVjYXRlZCwgdXNlIG1vbWVudCgpLnV0Y09mZnNldCBpbnN0ZWFkLiBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL3pvbmUvJywgZ2V0U2V0Wm9uZSk7XG5wcm90by5pc0RTVFNoaWZ0ZWQgPSBkZXByZWNhdGUoJ2lzRFNUU2hpZnRlZCBpcyBkZXByZWNhdGVkLiBTZWUgaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9kc3Qtc2hpZnRlZC8gZm9yIG1vcmUgaW5mb3JtYXRpb24nLCBpc0RheWxpZ2h0U2F2aW5nVGltZVNoaWZ0ZWQpO1xuXG5mdW5jdGlvbiBjcmVhdGVVbml4IChpbnB1dCkge1xuICAgIHJldHVybiBjcmVhdGVMb2NhbChpbnB1dCAqIDEwMDApO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVJblpvbmUgKCkge1xuICAgIHJldHVybiBjcmVhdGVMb2NhbC5hcHBseShudWxsLCBhcmd1bWVudHMpLnBhcnNlWm9uZSgpO1xufVxuXG5mdW5jdGlvbiBwcmVQYXJzZVBvc3RGb3JtYXQgKHN0cmluZykge1xuICAgIHJldHVybiBzdHJpbmc7XG59XG5cbnZhciBwcm90byQxID0gTG9jYWxlLnByb3RvdHlwZTtcblxucHJvdG8kMS5jYWxlbmRhciAgICAgICAgPSBjYWxlbmRhcjtcbnByb3RvJDEubG9uZ0RhdGVGb3JtYXQgID0gbG9uZ0RhdGVGb3JtYXQ7XG5wcm90byQxLmludmFsaWREYXRlICAgICA9IGludmFsaWREYXRlO1xucHJvdG8kMS5vcmRpbmFsICAgICAgICAgPSBvcmRpbmFsO1xucHJvdG8kMS5wcmVwYXJzZSAgICAgICAgPSBwcmVQYXJzZVBvc3RGb3JtYXQ7XG5wcm90byQxLnBvc3Rmb3JtYXQgICAgICA9IHByZVBhcnNlUG9zdEZvcm1hdDtcbnByb3RvJDEucmVsYXRpdmVUaW1lICAgID0gcmVsYXRpdmVUaW1lO1xucHJvdG8kMS5wYXN0RnV0dXJlICAgICAgPSBwYXN0RnV0dXJlO1xucHJvdG8kMS5zZXQgICAgICAgICAgICAgPSBzZXQ7XG5cbi8vIE1vbnRoXG5wcm90byQxLm1vbnRocyAgICAgICAgICAgID0gICAgICAgIGxvY2FsZU1vbnRocztcbnByb3RvJDEubW9udGhzU2hvcnQgICAgICAgPSAgICAgICAgbG9jYWxlTW9udGhzU2hvcnQ7XG5wcm90byQxLm1vbnRoc1BhcnNlICAgICAgID0gICAgICAgIGxvY2FsZU1vbnRoc1BhcnNlO1xucHJvdG8kMS5tb250aHNSZWdleCAgICAgICA9IG1vbnRoc1JlZ2V4O1xucHJvdG8kMS5tb250aHNTaG9ydFJlZ2V4ICA9IG1vbnRoc1Nob3J0UmVnZXg7XG5cbi8vIFdlZWtcbnByb3RvJDEud2VlayA9IGxvY2FsZVdlZWs7XG5wcm90byQxLmZpcnN0RGF5T2ZZZWFyID0gbG9jYWxlRmlyc3REYXlPZlllYXI7XG5wcm90byQxLmZpcnN0RGF5T2ZXZWVrID0gbG9jYWxlRmlyc3REYXlPZldlZWs7XG5cbi8vIERheSBvZiBXZWVrXG5wcm90byQxLndlZWtkYXlzICAgICAgID0gICAgICAgIGxvY2FsZVdlZWtkYXlzO1xucHJvdG8kMS53ZWVrZGF5c01pbiAgICA9ICAgICAgICBsb2NhbGVXZWVrZGF5c01pbjtcbnByb3RvJDEud2Vla2RheXNTaG9ydCAgPSAgICAgICAgbG9jYWxlV2Vla2RheXNTaG9ydDtcbnByb3RvJDEud2Vla2RheXNQYXJzZSAgPSAgICAgICAgbG9jYWxlV2Vla2RheXNQYXJzZTtcblxucHJvdG8kMS53ZWVrZGF5c1JlZ2V4ICAgICAgID0gICAgICAgIHdlZWtkYXlzUmVnZXg7XG5wcm90byQxLndlZWtkYXlzU2hvcnRSZWdleCAgPSAgICAgICAgd2Vla2RheXNTaG9ydFJlZ2V4O1xucHJvdG8kMS53ZWVrZGF5c01pblJlZ2V4ICAgID0gICAgICAgIHdlZWtkYXlzTWluUmVnZXg7XG5cbi8vIEhvdXJzXG5wcm90byQxLmlzUE0gPSBsb2NhbGVJc1BNO1xucHJvdG8kMS5tZXJpZGllbSA9IGxvY2FsZU1lcmlkaWVtO1xuXG5mdW5jdGlvbiBnZXQkMSAoZm9ybWF0LCBpbmRleCwgZmllbGQsIHNldHRlcikge1xuICAgIHZhciBsb2NhbGUgPSBnZXRMb2NhbGUoKTtcbiAgICB2YXIgdXRjID0gY3JlYXRlVVRDKCkuc2V0KHNldHRlciwgaW5kZXgpO1xuICAgIHJldHVybiBsb2NhbGVbZmllbGRdKHV0YywgZm9ybWF0KTtcbn1cblxuZnVuY3Rpb24gbGlzdE1vbnRoc0ltcGwgKGZvcm1hdCwgaW5kZXgsIGZpZWxkKSB7XG4gICAgaWYgKGlzTnVtYmVyKGZvcm1hdCkpIHtcbiAgICAgICAgaW5kZXggPSBmb3JtYXQ7XG4gICAgICAgIGZvcm1hdCA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBmb3JtYXQgPSBmb3JtYXQgfHwgJyc7XG5cbiAgICBpZiAoaW5kZXggIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZ2V0JDEoZm9ybWF0LCBpbmRleCwgZmllbGQsICdtb250aCcpO1xuICAgIH1cblxuICAgIHZhciBpO1xuICAgIHZhciBvdXQgPSBbXTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgICBvdXRbaV0gPSBnZXQkMShmb3JtYXQsIGksIGZpZWxkLCAnbW9udGgnKTtcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbn1cblxuLy8gKClcbi8vICg1KVxuLy8gKGZtdCwgNSlcbi8vIChmbXQpXG4vLyAodHJ1ZSlcbi8vICh0cnVlLCA1KVxuLy8gKHRydWUsIGZtdCwgNSlcbi8vICh0cnVlLCBmbXQpXG5mdW5jdGlvbiBsaXN0V2Vla2RheXNJbXBsIChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgsIGZpZWxkKSB7XG4gICAgaWYgKHR5cGVvZiBsb2NhbGVTb3J0ZWQgPT09ICdib29sZWFuJykge1xuICAgICAgICBpZiAoaXNOdW1iZXIoZm9ybWF0KSkge1xuICAgICAgICAgICAgaW5kZXggPSBmb3JtYXQ7XG4gICAgICAgICAgICBmb3JtYXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBmb3JtYXQgPSBmb3JtYXQgfHwgJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9ybWF0ID0gbG9jYWxlU29ydGVkO1xuICAgICAgICBpbmRleCA9IGZvcm1hdDtcbiAgICAgICAgbG9jYWxlU29ydGVkID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKGlzTnVtYmVyKGZvcm1hdCkpIHtcbiAgICAgICAgICAgIGluZGV4ID0gZm9ybWF0O1xuICAgICAgICAgICAgZm9ybWF0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9ybWF0ID0gZm9ybWF0IHx8ICcnO1xuICAgIH1cblxuICAgIHZhciBsb2NhbGUgPSBnZXRMb2NhbGUoKSxcbiAgICAgICAgc2hpZnQgPSBsb2NhbGVTb3J0ZWQgPyBsb2NhbGUuX3dlZWsuZG93IDogMDtcblxuICAgIGlmIChpbmRleCAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBnZXQkMShmb3JtYXQsIChpbmRleCArIHNoaWZ0KSAlIDcsIGZpZWxkLCAnZGF5Jyk7XG4gICAgfVxuXG4gICAgdmFyIGk7XG4gICAgdmFyIG91dCA9IFtdO1xuICAgIGZvciAoaSA9IDA7IGkgPCA3OyBpKyspIHtcbiAgICAgICAgb3V0W2ldID0gZ2V0JDEoZm9ybWF0LCAoaSArIHNoaWZ0KSAlIDcsIGZpZWxkLCAnZGF5Jyk7XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG59XG5cbmZ1bmN0aW9uIGxpc3RNb250aHMgKGZvcm1hdCwgaW5kZXgpIHtcbiAgICByZXR1cm4gbGlzdE1vbnRoc0ltcGwoZm9ybWF0LCBpbmRleCwgJ21vbnRocycpO1xufVxuXG5mdW5jdGlvbiBsaXN0TW9udGhzU2hvcnQgKGZvcm1hdCwgaW5kZXgpIHtcbiAgICByZXR1cm4gbGlzdE1vbnRoc0ltcGwoZm9ybWF0LCBpbmRleCwgJ21vbnRoc1Nob3J0Jyk7XG59XG5cbmZ1bmN0aW9uIGxpc3RXZWVrZGF5cyAobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4KSB7XG4gICAgcmV0dXJuIGxpc3RXZWVrZGF5c0ltcGwobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4LCAnd2Vla2RheXMnKTtcbn1cblxuZnVuY3Rpb24gbGlzdFdlZWtkYXlzU2hvcnQgKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCkge1xuICAgIHJldHVybiBsaXN0V2Vla2RheXNJbXBsKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCwgJ3dlZWtkYXlzU2hvcnQnKTtcbn1cblxuZnVuY3Rpb24gbGlzdFdlZWtkYXlzTWluIChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgpIHtcbiAgICByZXR1cm4gbGlzdFdlZWtkYXlzSW1wbChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgsICd3ZWVrZGF5c01pbicpO1xufVxuXG5nZXRTZXRHbG9iYWxMb2NhbGUoJ2VuJywge1xuICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2U6IC9cXGR7MSwyfSh0aHxzdHxuZHxyZCkvLFxuICAgIG9yZGluYWwgOiBmdW5jdGlvbiAobnVtYmVyKSB7XG4gICAgICAgIHZhciBiID0gbnVtYmVyICUgMTAsXG4gICAgICAgICAgICBvdXRwdXQgPSAodG9JbnQobnVtYmVyICUgMTAwIC8gMTApID09PSAxKSA/ICd0aCcgOlxuICAgICAgICAgICAgKGIgPT09IDEpID8gJ3N0JyA6XG4gICAgICAgICAgICAoYiA9PT0gMikgPyAnbmQnIDpcbiAgICAgICAgICAgIChiID09PSAzKSA/ICdyZCcgOiAndGgnO1xuICAgICAgICByZXR1cm4gbnVtYmVyICsgb3V0cHV0O1xuICAgIH1cbn0pO1xuXG4vLyBTaWRlIGVmZmVjdCBpbXBvcnRzXG5ob29rcy5sYW5nID0gZGVwcmVjYXRlKCdtb21lbnQubGFuZyBpcyBkZXByZWNhdGVkLiBVc2UgbW9tZW50LmxvY2FsZSBpbnN0ZWFkLicsIGdldFNldEdsb2JhbExvY2FsZSk7XG5ob29rcy5sYW5nRGF0YSA9IGRlcHJlY2F0ZSgnbW9tZW50LmxhbmdEYXRhIGlzIGRlcHJlY2F0ZWQuIFVzZSBtb21lbnQubG9jYWxlRGF0YSBpbnN0ZWFkLicsIGdldExvY2FsZSk7XG5cbnZhciBtYXRoQWJzID0gTWF0aC5hYnM7XG5cbmZ1bmN0aW9uIGFicyAoKSB7XG4gICAgdmFyIGRhdGEgICAgICAgICAgID0gdGhpcy5fZGF0YTtcblxuICAgIHRoaXMuX21pbGxpc2Vjb25kcyA9IG1hdGhBYnModGhpcy5fbWlsbGlzZWNvbmRzKTtcbiAgICB0aGlzLl9kYXlzICAgICAgICAgPSBtYXRoQWJzKHRoaXMuX2RheXMpO1xuICAgIHRoaXMuX21vbnRocyAgICAgICA9IG1hdGhBYnModGhpcy5fbW9udGhzKTtcblxuICAgIGRhdGEubWlsbGlzZWNvbmRzICA9IG1hdGhBYnMoZGF0YS5taWxsaXNlY29uZHMpO1xuICAgIGRhdGEuc2Vjb25kcyAgICAgICA9IG1hdGhBYnMoZGF0YS5zZWNvbmRzKTtcbiAgICBkYXRhLm1pbnV0ZXMgICAgICAgPSBtYXRoQWJzKGRhdGEubWludXRlcyk7XG4gICAgZGF0YS5ob3VycyAgICAgICAgID0gbWF0aEFicyhkYXRhLmhvdXJzKTtcbiAgICBkYXRhLm1vbnRocyAgICAgICAgPSBtYXRoQWJzKGRhdGEubW9udGhzKTtcbiAgICBkYXRhLnllYXJzICAgICAgICAgPSBtYXRoQWJzKGRhdGEueWVhcnMpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59XG5cbmZ1bmN0aW9uIGFkZFN1YnRyYWN0JDEgKGR1cmF0aW9uLCBpbnB1dCwgdmFsdWUsIGRpcmVjdGlvbikge1xuICAgIHZhciBvdGhlciA9IGNyZWF0ZUR1cmF0aW9uKGlucHV0LCB2YWx1ZSk7XG5cbiAgICBkdXJhdGlvbi5fbWlsbGlzZWNvbmRzICs9IGRpcmVjdGlvbiAqIG90aGVyLl9taWxsaXNlY29uZHM7XG4gICAgZHVyYXRpb24uX2RheXMgICAgICAgICArPSBkaXJlY3Rpb24gKiBvdGhlci5fZGF5cztcbiAgICBkdXJhdGlvbi5fbW9udGhzICAgICAgICs9IGRpcmVjdGlvbiAqIG90aGVyLl9tb250aHM7XG5cbiAgICByZXR1cm4gZHVyYXRpb24uX2J1YmJsZSgpO1xufVxuXG4vLyBzdXBwb3J0cyBvbmx5IDIuMC1zdHlsZSBhZGQoMSwgJ3MnKSBvciBhZGQoZHVyYXRpb24pXG5mdW5jdGlvbiBhZGQkMSAoaW5wdXQsIHZhbHVlKSB7XG4gICAgcmV0dXJuIGFkZFN1YnRyYWN0JDEodGhpcywgaW5wdXQsIHZhbHVlLCAxKTtcbn1cblxuLy8gc3VwcG9ydHMgb25seSAyLjAtc3R5bGUgc3VidHJhY3QoMSwgJ3MnKSBvciBzdWJ0cmFjdChkdXJhdGlvbilcbmZ1bmN0aW9uIHN1YnRyYWN0JDEgKGlucHV0LCB2YWx1ZSkge1xuICAgIHJldHVybiBhZGRTdWJ0cmFjdCQxKHRoaXMsIGlucHV0LCB2YWx1ZSwgLTEpO1xufVxuXG5mdW5jdGlvbiBhYnNDZWlsIChudW1iZXIpIHtcbiAgICBpZiAobnVtYmVyIDwgMCkge1xuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihudW1iZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBNYXRoLmNlaWwobnVtYmVyKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGJ1YmJsZSAoKSB7XG4gICAgdmFyIG1pbGxpc2Vjb25kcyA9IHRoaXMuX21pbGxpc2Vjb25kcztcbiAgICB2YXIgZGF5cyAgICAgICAgID0gdGhpcy5fZGF5cztcbiAgICB2YXIgbW9udGhzICAgICAgID0gdGhpcy5fbW9udGhzO1xuICAgIHZhciBkYXRhICAgICAgICAgPSB0aGlzLl9kYXRhO1xuICAgIHZhciBzZWNvbmRzLCBtaW51dGVzLCBob3VycywgeWVhcnMsIG1vbnRoc0Zyb21EYXlzO1xuXG4gICAgLy8gaWYgd2UgaGF2ZSBhIG1peCBvZiBwb3NpdGl2ZSBhbmQgbmVnYXRpdmUgdmFsdWVzLCBidWJibGUgZG93biBmaXJzdFxuICAgIC8vIGNoZWNrOiBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9pc3N1ZXMvMjE2NlxuICAgIGlmICghKChtaWxsaXNlY29uZHMgPj0gMCAmJiBkYXlzID49IDAgJiYgbW9udGhzID49IDApIHx8XG4gICAgICAgICAgICAobWlsbGlzZWNvbmRzIDw9IDAgJiYgZGF5cyA8PSAwICYmIG1vbnRocyA8PSAwKSkpIHtcbiAgICAgICAgbWlsbGlzZWNvbmRzICs9IGFic0NlaWwobW9udGhzVG9EYXlzKG1vbnRocykgKyBkYXlzKSAqIDg2NGU1O1xuICAgICAgICBkYXlzID0gMDtcbiAgICAgICAgbW9udGhzID0gMDtcbiAgICB9XG5cbiAgICAvLyBUaGUgZm9sbG93aW5nIGNvZGUgYnViYmxlcyB1cCB2YWx1ZXMsIHNlZSB0aGUgdGVzdHMgZm9yXG4gICAgLy8gZXhhbXBsZXMgb2Ygd2hhdCB0aGF0IG1lYW5zLlxuICAgIGRhdGEubWlsbGlzZWNvbmRzID0gbWlsbGlzZWNvbmRzICUgMTAwMDtcblxuICAgIHNlY29uZHMgICAgICAgICAgID0gYWJzRmxvb3IobWlsbGlzZWNvbmRzIC8gMTAwMCk7XG4gICAgZGF0YS5zZWNvbmRzICAgICAgPSBzZWNvbmRzICUgNjA7XG5cbiAgICBtaW51dGVzICAgICAgICAgICA9IGFic0Zsb29yKHNlY29uZHMgLyA2MCk7XG4gICAgZGF0YS5taW51dGVzICAgICAgPSBtaW51dGVzICUgNjA7XG5cbiAgICBob3VycyAgICAgICAgICAgICA9IGFic0Zsb29yKG1pbnV0ZXMgLyA2MCk7XG4gICAgZGF0YS5ob3VycyAgICAgICAgPSBob3VycyAlIDI0O1xuXG4gICAgZGF5cyArPSBhYnNGbG9vcihob3VycyAvIDI0KTtcblxuICAgIC8vIGNvbnZlcnQgZGF5cyB0byBtb250aHNcbiAgICBtb250aHNGcm9tRGF5cyA9IGFic0Zsb29yKGRheXNUb01vbnRocyhkYXlzKSk7XG4gICAgbW9udGhzICs9IG1vbnRoc0Zyb21EYXlzO1xuICAgIGRheXMgLT0gYWJzQ2VpbChtb250aHNUb0RheXMobW9udGhzRnJvbURheXMpKTtcblxuICAgIC8vIDEyIG1vbnRocyAtPiAxIHllYXJcbiAgICB5ZWFycyA9IGFic0Zsb29yKG1vbnRocyAvIDEyKTtcbiAgICBtb250aHMgJT0gMTI7XG5cbiAgICBkYXRhLmRheXMgICA9IGRheXM7XG4gICAgZGF0YS5tb250aHMgPSBtb250aHM7XG4gICAgZGF0YS55ZWFycyAgPSB5ZWFycztcblxuICAgIHJldHVybiB0aGlzO1xufVxuXG5mdW5jdGlvbiBkYXlzVG9Nb250aHMgKGRheXMpIHtcbiAgICAvLyA0MDAgeWVhcnMgaGF2ZSAxNDYwOTcgZGF5cyAodGFraW5nIGludG8gYWNjb3VudCBsZWFwIHllYXIgcnVsZXMpXG4gICAgLy8gNDAwIHllYXJzIGhhdmUgMTIgbW9udGhzID09PSA0ODAwXG4gICAgcmV0dXJuIGRheXMgKiA0ODAwIC8gMTQ2MDk3O1xufVxuXG5mdW5jdGlvbiBtb250aHNUb0RheXMgKG1vbnRocykge1xuICAgIC8vIHRoZSByZXZlcnNlIG9mIGRheXNUb01vbnRoc1xuICAgIHJldHVybiBtb250aHMgKiAxNDYwOTcgLyA0ODAwO1xufVxuXG5mdW5jdGlvbiBhcyAodW5pdHMpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgIHJldHVybiBOYU47XG4gICAgfVxuICAgIHZhciBkYXlzO1xuICAgIHZhciBtb250aHM7XG4gICAgdmFyIG1pbGxpc2Vjb25kcyA9IHRoaXMuX21pbGxpc2Vjb25kcztcblxuICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuXG4gICAgaWYgKHVuaXRzID09PSAnbW9udGgnIHx8IHVuaXRzID09PSAneWVhcicpIHtcbiAgICAgICAgZGF5cyAgID0gdGhpcy5fZGF5cyAgICsgbWlsbGlzZWNvbmRzIC8gODY0ZTU7XG4gICAgICAgIG1vbnRocyA9IHRoaXMuX21vbnRocyArIGRheXNUb01vbnRocyhkYXlzKTtcbiAgICAgICAgcmV0dXJuIHVuaXRzID09PSAnbW9udGgnID8gbW9udGhzIDogbW9udGhzIC8gMTI7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gaGFuZGxlIG1pbGxpc2Vjb25kcyBzZXBhcmF0ZWx5IGJlY2F1c2Ugb2YgZmxvYXRpbmcgcG9pbnQgbWF0aCBlcnJvcnMgKGlzc3VlICMxODY3KVxuICAgICAgICBkYXlzID0gdGhpcy5fZGF5cyArIE1hdGgucm91bmQobW9udGhzVG9EYXlzKHRoaXMuX21vbnRocykpO1xuICAgICAgICBzd2l0Y2ggKHVuaXRzKSB7XG4gICAgICAgICAgICBjYXNlICd3ZWVrJyAgIDogcmV0dXJuIGRheXMgLyA3ICAgICArIG1pbGxpc2Vjb25kcyAvIDYwNDhlNTtcbiAgICAgICAgICAgIGNhc2UgJ2RheScgICAgOiByZXR1cm4gZGF5cyAgICAgICAgICsgbWlsbGlzZWNvbmRzIC8gODY0ZTU7XG4gICAgICAgICAgICBjYXNlICdob3VyJyAgIDogcmV0dXJuIGRheXMgKiAyNCAgICArIG1pbGxpc2Vjb25kcyAvIDM2ZTU7XG4gICAgICAgICAgICBjYXNlICdtaW51dGUnIDogcmV0dXJuIGRheXMgKiAxNDQwICArIG1pbGxpc2Vjb25kcyAvIDZlNDtcbiAgICAgICAgICAgIGNhc2UgJ3NlY29uZCcgOiByZXR1cm4gZGF5cyAqIDg2NDAwICsgbWlsbGlzZWNvbmRzIC8gMTAwMDtcbiAgICAgICAgICAgIC8vIE1hdGguZmxvb3IgcHJldmVudHMgZmxvYXRpbmcgcG9pbnQgbWF0aCBlcnJvcnMgaGVyZVxuICAgICAgICAgICAgY2FzZSAnbWlsbGlzZWNvbmQnOiByZXR1cm4gTWF0aC5mbG9vcihkYXlzICogODY0ZTUpICsgbWlsbGlzZWNvbmRzO1xuICAgICAgICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHVuaXQgJyArIHVuaXRzKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLy8gVE9ETzogVXNlIHRoaXMuYXMoJ21zJyk/XG5mdW5jdGlvbiB2YWx1ZU9mJDEgKCkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG4gICAgcmV0dXJuIChcbiAgICAgICAgdGhpcy5fbWlsbGlzZWNvbmRzICtcbiAgICAgICAgdGhpcy5fZGF5cyAqIDg2NGU1ICtcbiAgICAgICAgKHRoaXMuX21vbnRocyAlIDEyKSAqIDI1OTJlNiArXG4gICAgICAgIHRvSW50KHRoaXMuX21vbnRocyAvIDEyKSAqIDMxNTM2ZTZcbiAgICApO1xufVxuXG5mdW5jdGlvbiBtYWtlQXMgKGFsaWFzKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXMoYWxpYXMpO1xuICAgIH07XG59XG5cbnZhciBhc01pbGxpc2Vjb25kcyA9IG1ha2VBcygnbXMnKTtcbnZhciBhc1NlY29uZHMgICAgICA9IG1ha2VBcygncycpO1xudmFyIGFzTWludXRlcyAgICAgID0gbWFrZUFzKCdtJyk7XG52YXIgYXNIb3VycyAgICAgICAgPSBtYWtlQXMoJ2gnKTtcbnZhciBhc0RheXMgICAgICAgICA9IG1ha2VBcygnZCcpO1xudmFyIGFzV2Vla3MgICAgICAgID0gbWFrZUFzKCd3Jyk7XG52YXIgYXNNb250aHMgICAgICAgPSBtYWtlQXMoJ00nKTtcbnZhciBhc1llYXJzICAgICAgICA9IG1ha2VBcygneScpO1xuXG5mdW5jdGlvbiBjbG9uZSQxICgpIHtcbiAgICByZXR1cm4gY3JlYXRlRHVyYXRpb24odGhpcyk7XG59XG5cbmZ1bmN0aW9uIGdldCQyICh1bml0cykge1xuICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/IHRoaXNbdW5pdHMgKyAncyddKCkgOiBOYU47XG59XG5cbmZ1bmN0aW9uIG1ha2VHZXR0ZXIobmFtZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/IHRoaXMuX2RhdGFbbmFtZV0gOiBOYU47XG4gICAgfTtcbn1cblxudmFyIG1pbGxpc2Vjb25kcyA9IG1ha2VHZXR0ZXIoJ21pbGxpc2Vjb25kcycpO1xudmFyIHNlY29uZHMgICAgICA9IG1ha2VHZXR0ZXIoJ3NlY29uZHMnKTtcbnZhciBtaW51dGVzICAgICAgPSBtYWtlR2V0dGVyKCdtaW51dGVzJyk7XG52YXIgaG91cnMgICAgICAgID0gbWFrZUdldHRlcignaG91cnMnKTtcbnZhciBkYXlzICAgICAgICAgPSBtYWtlR2V0dGVyKCdkYXlzJyk7XG52YXIgbW9udGhzICAgICAgID0gbWFrZUdldHRlcignbW9udGhzJyk7XG52YXIgeWVhcnMgICAgICAgID0gbWFrZUdldHRlcigneWVhcnMnKTtcblxuZnVuY3Rpb24gd2Vla3MgKCkge1xuICAgIHJldHVybiBhYnNGbG9vcih0aGlzLmRheXMoKSAvIDcpO1xufVxuXG52YXIgcm91bmQgPSBNYXRoLnJvdW5kO1xudmFyIHRocmVzaG9sZHMgPSB7XG4gICAgc3M6IDQ0LCAgICAgICAgIC8vIGEgZmV3IHNlY29uZHMgdG8gc2Vjb25kc1xuICAgIHMgOiA0NSwgICAgICAgICAvLyBzZWNvbmRzIHRvIG1pbnV0ZVxuICAgIG0gOiA0NSwgICAgICAgICAvLyBtaW51dGVzIHRvIGhvdXJcbiAgICBoIDogMjIsICAgICAgICAgLy8gaG91cnMgdG8gZGF5XG4gICAgZCA6IDI2LCAgICAgICAgIC8vIGRheXMgdG8gbW9udGhcbiAgICBNIDogMTEgICAgICAgICAgLy8gbW9udGhzIHRvIHllYXJcbn07XG5cbi8vIGhlbHBlciBmdW5jdGlvbiBmb3IgbW9tZW50LmZuLmZyb20sIG1vbWVudC5mbi5mcm9tTm93LCBhbmQgbW9tZW50LmR1cmF0aW9uLmZuLmh1bWFuaXplXG5mdW5jdGlvbiBzdWJzdGl0dXRlVGltZUFnbyhzdHJpbmcsIG51bWJlciwgd2l0aG91dFN1ZmZpeCwgaXNGdXR1cmUsIGxvY2FsZSkge1xuICAgIHJldHVybiBsb2NhbGUucmVsYXRpdmVUaW1lKG51bWJlciB8fCAxLCAhIXdpdGhvdXRTdWZmaXgsIHN0cmluZywgaXNGdXR1cmUpO1xufVxuXG5mdW5jdGlvbiByZWxhdGl2ZVRpbWUkMSAocG9zTmVnRHVyYXRpb24sIHdpdGhvdXRTdWZmaXgsIGxvY2FsZSkge1xuICAgIHZhciBkdXJhdGlvbiA9IGNyZWF0ZUR1cmF0aW9uKHBvc05lZ0R1cmF0aW9uKS5hYnMoKTtcbiAgICB2YXIgc2Vjb25kcyAgPSByb3VuZChkdXJhdGlvbi5hcygncycpKTtcbiAgICB2YXIgbWludXRlcyAgPSByb3VuZChkdXJhdGlvbi5hcygnbScpKTtcbiAgICB2YXIgaG91cnMgICAgPSByb3VuZChkdXJhdGlvbi5hcygnaCcpKTtcbiAgICB2YXIgZGF5cyAgICAgPSByb3VuZChkdXJhdGlvbi5hcygnZCcpKTtcbiAgICB2YXIgbW9udGhzICAgPSByb3VuZChkdXJhdGlvbi5hcygnTScpKTtcbiAgICB2YXIgeWVhcnMgICAgPSByb3VuZChkdXJhdGlvbi5hcygneScpKTtcblxuICAgIHZhciBhID0gc2Vjb25kcyA8PSB0aHJlc2hvbGRzLnNzICYmIFsncycsIHNlY29uZHNdICB8fFxuICAgICAgICAgICAgc2Vjb25kcyA8IHRocmVzaG9sZHMucyAgICYmIFsnc3MnLCBzZWNvbmRzXSB8fFxuICAgICAgICAgICAgbWludXRlcyA8PSAxICAgICAgICAgICAgICYmIFsnbSddICAgICAgICAgICB8fFxuICAgICAgICAgICAgbWludXRlcyA8IHRocmVzaG9sZHMubSAgICYmIFsnbW0nLCBtaW51dGVzXSB8fFxuICAgICAgICAgICAgaG91cnMgICA8PSAxICAgICAgICAgICAgICYmIFsnaCddICAgICAgICAgICB8fFxuICAgICAgICAgICAgaG91cnMgICA8IHRocmVzaG9sZHMuaCAgICYmIFsnaGgnLCBob3Vyc10gICB8fFxuICAgICAgICAgICAgZGF5cyAgICA8PSAxICAgICAgICAgICAgICYmIFsnZCddICAgICAgICAgICB8fFxuICAgICAgICAgICAgZGF5cyAgICA8IHRocmVzaG9sZHMuZCAgICYmIFsnZGQnLCBkYXlzXSAgICB8fFxuICAgICAgICAgICAgbW9udGhzICA8PSAxICAgICAgICAgICAgICYmIFsnTSddICAgICAgICAgICB8fFxuICAgICAgICAgICAgbW9udGhzICA8IHRocmVzaG9sZHMuTSAgICYmIFsnTU0nLCBtb250aHNdICB8fFxuICAgICAgICAgICAgeWVhcnMgICA8PSAxICAgICAgICAgICAgICYmIFsneSddICAgICAgICAgICB8fCBbJ3l5JywgeWVhcnNdO1xuXG4gICAgYVsyXSA9IHdpdGhvdXRTdWZmaXg7XG4gICAgYVszXSA9ICtwb3NOZWdEdXJhdGlvbiA+IDA7XG4gICAgYVs0XSA9IGxvY2FsZTtcbiAgICByZXR1cm4gc3Vic3RpdHV0ZVRpbWVBZ28uYXBwbHkobnVsbCwgYSk7XG59XG5cbi8vIFRoaXMgZnVuY3Rpb24gYWxsb3dzIHlvdSB0byBzZXQgdGhlIHJvdW5kaW5nIGZ1bmN0aW9uIGZvciByZWxhdGl2ZSB0aW1lIHN0cmluZ3NcbmZ1bmN0aW9uIGdldFNldFJlbGF0aXZlVGltZVJvdW5kaW5nIChyb3VuZGluZ0Z1bmN0aW9uKSB7XG4gICAgaWYgKHJvdW5kaW5nRnVuY3Rpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gcm91bmQ7XG4gICAgfVxuICAgIGlmICh0eXBlb2Yocm91bmRpbmdGdW5jdGlvbikgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcm91bmQgPSByb3VuZGluZ0Z1bmN0aW9uO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyBUaGlzIGZ1bmN0aW9uIGFsbG93cyB5b3UgdG8gc2V0IGEgdGhyZXNob2xkIGZvciByZWxhdGl2ZSB0aW1lIHN0cmluZ3NcbmZ1bmN0aW9uIGdldFNldFJlbGF0aXZlVGltZVRocmVzaG9sZCAodGhyZXNob2xkLCBsaW1pdCkge1xuICAgIGlmICh0aHJlc2hvbGRzW3RocmVzaG9sZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChsaW1pdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB0aHJlc2hvbGRzW3RocmVzaG9sZF07XG4gICAgfVxuICAgIHRocmVzaG9sZHNbdGhyZXNob2xkXSA9IGxpbWl0O1xuICAgIGlmICh0aHJlc2hvbGQgPT09ICdzJykge1xuICAgICAgICB0aHJlc2hvbGRzLnNzID0gbGltaXQgLSAxO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaHVtYW5pemUgKHdpdGhTdWZmaXgpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xuICAgIH1cblxuICAgIHZhciBsb2NhbGUgPSB0aGlzLmxvY2FsZURhdGEoKTtcbiAgICB2YXIgb3V0cHV0ID0gcmVsYXRpdmVUaW1lJDEodGhpcywgIXdpdGhTdWZmaXgsIGxvY2FsZSk7XG5cbiAgICBpZiAod2l0aFN1ZmZpeCkge1xuICAgICAgICBvdXRwdXQgPSBsb2NhbGUucGFzdEZ1dHVyZSgrdGhpcywgb3V0cHV0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbG9jYWxlLnBvc3Rmb3JtYXQob3V0cHV0KTtcbn1cblxudmFyIGFicyQxID0gTWF0aC5hYnM7XG5cbmZ1bmN0aW9uIHNpZ24oeCkge1xuICAgIHJldHVybiAoKHggPiAwKSAtICh4IDwgMCkpIHx8ICt4O1xufVxuXG5mdW5jdGlvbiB0b0lTT1N0cmluZyQxKCkge1xuICAgIC8vIGZvciBJU08gc3RyaW5ncyB3ZSBkbyBub3QgdXNlIHRoZSBub3JtYWwgYnViYmxpbmcgcnVsZXM6XG4gICAgLy8gICogbWlsbGlzZWNvbmRzIGJ1YmJsZSB1cCB1bnRpbCB0aGV5IGJlY29tZSBob3Vyc1xuICAgIC8vICAqIGRheXMgZG8gbm90IGJ1YmJsZSBhdCBhbGxcbiAgICAvLyAgKiBtb250aHMgYnViYmxlIHVwIHVudGlsIHRoZXkgYmVjb21lIHllYXJzXG4gICAgLy8gVGhpcyBpcyBiZWNhdXNlIHRoZXJlIGlzIG5vIGNvbnRleHQtZnJlZSBjb252ZXJzaW9uIGJldHdlZW4gaG91cnMgYW5kIGRheXNcbiAgICAvLyAodGhpbmsgb2YgY2xvY2sgY2hhbmdlcylcbiAgICAvLyBhbmQgYWxzbyBub3QgYmV0d2VlbiBkYXlzIGFuZCBtb250aHMgKDI4LTMxIGRheXMgcGVyIG1vbnRoKVxuICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLmludmFsaWREYXRlKCk7XG4gICAgfVxuXG4gICAgdmFyIHNlY29uZHMgPSBhYnMkMSh0aGlzLl9taWxsaXNlY29uZHMpIC8gMTAwMDtcbiAgICB2YXIgZGF5cyAgICAgICAgID0gYWJzJDEodGhpcy5fZGF5cyk7XG4gICAgdmFyIG1vbnRocyAgICAgICA9IGFicyQxKHRoaXMuX21vbnRocyk7XG4gICAgdmFyIG1pbnV0ZXMsIGhvdXJzLCB5ZWFycztcblxuICAgIC8vIDM2MDAgc2Vjb25kcyAtPiA2MCBtaW51dGVzIC0+IDEgaG91clxuICAgIG1pbnV0ZXMgICAgICAgICAgID0gYWJzRmxvb3Ioc2Vjb25kcyAvIDYwKTtcbiAgICBob3VycyAgICAgICAgICAgICA9IGFic0Zsb29yKG1pbnV0ZXMgLyA2MCk7XG4gICAgc2Vjb25kcyAlPSA2MDtcbiAgICBtaW51dGVzICU9IDYwO1xuXG4gICAgLy8gMTIgbW9udGhzIC0+IDEgeWVhclxuICAgIHllYXJzICA9IGFic0Zsb29yKG1vbnRocyAvIDEyKTtcbiAgICBtb250aHMgJT0gMTI7XG5cblxuICAgIC8vIGluc3BpcmVkIGJ5IGh0dHBzOi8vZ2l0aHViLmNvbS9kb3JkaWxsZS9tb21lbnQtaXNvZHVyYXRpb24vYmxvYi9tYXN0ZXIvbW9tZW50Lmlzb2R1cmF0aW9uLmpzXG4gICAgdmFyIFkgPSB5ZWFycztcbiAgICB2YXIgTSA9IG1vbnRocztcbiAgICB2YXIgRCA9IGRheXM7XG4gICAgdmFyIGggPSBob3VycztcbiAgICB2YXIgbSA9IG1pbnV0ZXM7XG4gICAgdmFyIHMgPSBzZWNvbmRzID8gc2Vjb25kcy50b0ZpeGVkKDMpLnJlcGxhY2UoL1xcLj8wKyQvLCAnJykgOiAnJztcbiAgICB2YXIgdG90YWwgPSB0aGlzLmFzU2Vjb25kcygpO1xuXG4gICAgaWYgKCF0b3RhbCkge1xuICAgICAgICAvLyB0aGlzIGlzIHRoZSBzYW1lIGFzIEMjJ3MgKE5vZGEpIGFuZCBweXRob24gKGlzb2RhdGUpLi4uXG4gICAgICAgIC8vIGJ1dCBub3Qgb3RoZXIgSlMgKGdvb2cuZGF0ZSlcbiAgICAgICAgcmV0dXJuICdQMEQnO1xuICAgIH1cblxuICAgIHZhciB0b3RhbFNpZ24gPSB0b3RhbCA8IDAgPyAnLScgOiAnJztcbiAgICB2YXIgeW1TaWduID0gc2lnbih0aGlzLl9tb250aHMpICE9PSBzaWduKHRvdGFsKSA/ICctJyA6ICcnO1xuICAgIHZhciBkYXlzU2lnbiA9IHNpZ24odGhpcy5fZGF5cykgIT09IHNpZ24odG90YWwpID8gJy0nIDogJyc7XG4gICAgdmFyIGhtc1NpZ24gPSBzaWduKHRoaXMuX21pbGxpc2Vjb25kcykgIT09IHNpZ24odG90YWwpID8gJy0nIDogJyc7XG5cbiAgICByZXR1cm4gdG90YWxTaWduICsgJ1AnICtcbiAgICAgICAgKFkgPyB5bVNpZ24gKyBZICsgJ1knIDogJycpICtcbiAgICAgICAgKE0gPyB5bVNpZ24gKyBNICsgJ00nIDogJycpICtcbiAgICAgICAgKEQgPyBkYXlzU2lnbiArIEQgKyAnRCcgOiAnJykgK1xuICAgICAgICAoKGggfHwgbSB8fCBzKSA/ICdUJyA6ICcnKSArXG4gICAgICAgIChoID8gaG1zU2lnbiArIGggKyAnSCcgOiAnJykgK1xuICAgICAgICAobSA/IGhtc1NpZ24gKyBtICsgJ00nIDogJycpICtcbiAgICAgICAgKHMgPyBobXNTaWduICsgcyArICdTJyA6ICcnKTtcbn1cblxudmFyIHByb3RvJDIgPSBEdXJhdGlvbi5wcm90b3R5cGU7XG5cbnByb3RvJDIuaXNWYWxpZCAgICAgICAgPSBpc1ZhbGlkJDE7XG5wcm90byQyLmFicyAgICAgICAgICAgID0gYWJzO1xucHJvdG8kMi5hZGQgICAgICAgICAgICA9IGFkZCQxO1xucHJvdG8kMi5zdWJ0cmFjdCAgICAgICA9IHN1YnRyYWN0JDE7XG5wcm90byQyLmFzICAgICAgICAgICAgID0gYXM7XG5wcm90byQyLmFzTWlsbGlzZWNvbmRzID0gYXNNaWxsaXNlY29uZHM7XG5wcm90byQyLmFzU2Vjb25kcyAgICAgID0gYXNTZWNvbmRzO1xucHJvdG8kMi5hc01pbnV0ZXMgICAgICA9IGFzTWludXRlcztcbnByb3RvJDIuYXNIb3VycyAgICAgICAgPSBhc0hvdXJzO1xucHJvdG8kMi5hc0RheXMgICAgICAgICA9IGFzRGF5cztcbnByb3RvJDIuYXNXZWVrcyAgICAgICAgPSBhc1dlZWtzO1xucHJvdG8kMi5hc01vbnRocyAgICAgICA9IGFzTW9udGhzO1xucHJvdG8kMi5hc1llYXJzICAgICAgICA9IGFzWWVhcnM7XG5wcm90byQyLnZhbHVlT2YgICAgICAgID0gdmFsdWVPZiQxO1xucHJvdG8kMi5fYnViYmxlICAgICAgICA9IGJ1YmJsZTtcbnByb3RvJDIuY2xvbmUgICAgICAgICAgPSBjbG9uZSQxO1xucHJvdG8kMi5nZXQgICAgICAgICAgICA9IGdldCQyO1xucHJvdG8kMi5taWxsaXNlY29uZHMgICA9IG1pbGxpc2Vjb25kcztcbnByb3RvJDIuc2Vjb25kcyAgICAgICAgPSBzZWNvbmRzO1xucHJvdG8kMi5taW51dGVzICAgICAgICA9IG1pbnV0ZXM7XG5wcm90byQyLmhvdXJzICAgICAgICAgID0gaG91cnM7XG5wcm90byQyLmRheXMgICAgICAgICAgID0gZGF5cztcbnByb3RvJDIud2Vla3MgICAgICAgICAgPSB3ZWVrcztcbnByb3RvJDIubW9udGhzICAgICAgICAgPSBtb250aHM7XG5wcm90byQyLnllYXJzICAgICAgICAgID0geWVhcnM7XG5wcm90byQyLmh1bWFuaXplICAgICAgID0gaHVtYW5pemU7XG5wcm90byQyLnRvSVNPU3RyaW5nICAgID0gdG9JU09TdHJpbmckMTtcbnByb3RvJDIudG9TdHJpbmcgICAgICAgPSB0b0lTT1N0cmluZyQxO1xucHJvdG8kMi50b0pTT04gICAgICAgICA9IHRvSVNPU3RyaW5nJDE7XG5wcm90byQyLmxvY2FsZSAgICAgICAgID0gbG9jYWxlO1xucHJvdG8kMi5sb2NhbGVEYXRhICAgICA9IGxvY2FsZURhdGE7XG5cbi8vIERlcHJlY2F0aW9uc1xucHJvdG8kMi50b0lzb1N0cmluZyA9IGRlcHJlY2F0ZSgndG9Jc29TdHJpbmcoKSBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIHRvSVNPU3RyaW5nKCkgaW5zdGVhZCAobm90aWNlIHRoZSBjYXBpdGFscyknLCB0b0lTT1N0cmluZyQxKTtcbnByb3RvJDIubGFuZyA9IGxhbmc7XG5cbi8vIFNpZGUgZWZmZWN0IGltcG9ydHNcblxuLy8gRk9STUFUVElOR1xuXG5hZGRGb3JtYXRUb2tlbignWCcsIDAsIDAsICd1bml4Jyk7XG5hZGRGb3JtYXRUb2tlbigneCcsIDAsIDAsICd2YWx1ZU9mJyk7XG5cbi8vIFBBUlNJTkdcblxuYWRkUmVnZXhUb2tlbigneCcsIG1hdGNoU2lnbmVkKTtcbmFkZFJlZ2V4VG9rZW4oJ1gnLCBtYXRjaFRpbWVzdGFtcCk7XG5hZGRQYXJzZVRva2VuKCdYJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgY29uZmlnLl9kID0gbmV3IERhdGUocGFyc2VGbG9hdChpbnB1dCwgMTApICogMTAwMCk7XG59KTtcbmFkZFBhcnNlVG9rZW4oJ3gnLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICBjb25maWcuX2QgPSBuZXcgRGF0ZSh0b0ludChpbnB1dCkpO1xufSk7XG5cbi8vIFNpZGUgZWZmZWN0IGltcG9ydHNcblxuXG5ob29rcy52ZXJzaW9uID0gJzIuMjAuMSc7XG5cbnNldEhvb2tDYWxsYmFjayhjcmVhdGVMb2NhbCk7XG5cbmhvb2tzLmZuICAgICAgICAgICAgICAgICAgICA9IHByb3RvO1xuaG9va3MubWluICAgICAgICAgICAgICAgICAgID0gbWluO1xuaG9va3MubWF4ICAgICAgICAgICAgICAgICAgID0gbWF4O1xuaG9va3Mubm93ICAgICAgICAgICAgICAgICAgID0gbm93O1xuaG9va3MudXRjICAgICAgICAgICAgICAgICAgID0gY3JlYXRlVVRDO1xuaG9va3MudW5peCAgICAgICAgICAgICAgICAgID0gY3JlYXRlVW5peDtcbmhvb2tzLm1vbnRocyAgICAgICAgICAgICAgICA9IGxpc3RNb250aHM7XG5ob29rcy5pc0RhdGUgICAgICAgICAgICAgICAgPSBpc0RhdGU7XG5ob29rcy5sb2NhbGUgICAgICAgICAgICAgICAgPSBnZXRTZXRHbG9iYWxMb2NhbGU7XG5ob29rcy5pbnZhbGlkICAgICAgICAgICAgICAgPSBjcmVhdGVJbnZhbGlkO1xuaG9va3MuZHVyYXRpb24gICAgICAgICAgICAgID0gY3JlYXRlRHVyYXRpb247XG5ob29rcy5pc01vbWVudCAgICAgICAgICAgICAgPSBpc01vbWVudDtcbmhvb2tzLndlZWtkYXlzICAgICAgICAgICAgICA9IGxpc3RXZWVrZGF5cztcbmhvb2tzLnBhcnNlWm9uZSAgICAgICAgICAgICA9IGNyZWF0ZUluWm9uZTtcbmhvb2tzLmxvY2FsZURhdGEgICAgICAgICAgICA9IGdldExvY2FsZTtcbmhvb2tzLmlzRHVyYXRpb24gICAgICAgICAgICA9IGlzRHVyYXRpb247XG5ob29rcy5tb250aHNTaG9ydCAgICAgICAgICAgPSBsaXN0TW9udGhzU2hvcnQ7XG5ob29rcy53ZWVrZGF5c01pbiAgICAgICAgICAgPSBsaXN0V2Vla2RheXNNaW47XG5ob29rcy5kZWZpbmVMb2NhbGUgICAgICAgICAgPSBkZWZpbmVMb2NhbGU7XG5ob29rcy51cGRhdGVMb2NhbGUgICAgICAgICAgPSB1cGRhdGVMb2NhbGU7XG5ob29rcy5sb2NhbGVzICAgICAgICAgICAgICAgPSBsaXN0TG9jYWxlcztcbmhvb2tzLndlZWtkYXlzU2hvcnQgICAgICAgICA9IGxpc3RXZWVrZGF5c1Nob3J0O1xuaG9va3Mubm9ybWFsaXplVW5pdHMgICAgICAgID0gbm9ybWFsaXplVW5pdHM7XG5ob29rcy5yZWxhdGl2ZVRpbWVSb3VuZGluZyAgPSBnZXRTZXRSZWxhdGl2ZVRpbWVSb3VuZGluZztcbmhvb2tzLnJlbGF0aXZlVGltZVRocmVzaG9sZCA9IGdldFNldFJlbGF0aXZlVGltZVRocmVzaG9sZDtcbmhvb2tzLmNhbGVuZGFyRm9ybWF0ICAgICAgICA9IGdldENhbGVuZGFyRm9ybWF0O1xuaG9va3MucHJvdG90eXBlICAgICAgICAgICAgID0gcHJvdG87XG5cbi8vIGN1cnJlbnRseSBIVE1MNSBpbnB1dCB0eXBlIG9ubHkgc3VwcG9ydHMgMjQtaG91ciBmb3JtYXRzXG5ob29rcy5IVE1MNV9GTVQgPSB7XG4gICAgREFURVRJTUVfTE9DQUw6ICdZWVlZLU1NLUREVEhIOm1tJywgICAgICAgICAgICAgLy8gPGlucHV0IHR5cGU9XCJkYXRldGltZS1sb2NhbFwiIC8+XG4gICAgREFURVRJTUVfTE9DQUxfU0VDT05EUzogJ1lZWVktTU0tRERUSEg6bW06c3MnLCAgLy8gPGlucHV0IHR5cGU9XCJkYXRldGltZS1sb2NhbFwiIHN0ZXA9XCIxXCIgLz5cbiAgICBEQVRFVElNRV9MT0NBTF9NUzogJ1lZWVktTU0tRERUSEg6bW06c3MuU1NTJywgICAvLyA8aW5wdXQgdHlwZT1cImRhdGV0aW1lLWxvY2FsXCIgc3RlcD1cIjAuMDAxXCIgLz5cbiAgICBEQVRFOiAnWVlZWS1NTS1ERCcsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyA8aW5wdXQgdHlwZT1cImRhdGVcIiAvPlxuICAgIFRJTUU6ICdISDptbScsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDxpbnB1dCB0eXBlPVwidGltZVwiIC8+XG4gICAgVElNRV9TRUNPTkRTOiAnSEg6bW06c3MnLCAgICAgICAgICAgICAgICAgICAgICAgLy8gPGlucHV0IHR5cGU9XCJ0aW1lXCIgc3RlcD1cIjFcIiAvPlxuICAgIFRJTUVfTVM6ICdISDptbTpzcy5TU1MnLCAgICAgICAgICAgICAgICAgICAgICAgIC8vIDxpbnB1dCB0eXBlPVwidGltZVwiIHN0ZXA9XCIwLjAwMVwiIC8+XG4gICAgV0VFSzogJ1lZWVktW1ddV1cnLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gPGlucHV0IHR5cGU9XCJ3ZWVrXCIgLz5cbiAgICBNT05USDogJ1lZWVktTU0nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyA8aW5wdXQgdHlwZT1cIm1vbnRoXCIgLz5cbn07XG5cbnJldHVybiBob29rcztcblxufSkpKTtcbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL2luZGV4Jyk7XG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfcG9ueWZpbGwgPSByZXF1aXJlKCcuL3BvbnlmaWxsLmpzJyk7XG5cbnZhciBfcG9ueWZpbGwyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcG9ueWZpbGwpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciByb290OyAvKiBnbG9iYWwgd2luZG93ICovXG5cblxuaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykge1xuICByb290ID0gc2VsZjtcbn0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgcm9vdCA9IHdpbmRvdztcbn0gZWxzZSBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgcm9vdCA9IGdsb2JhbDtcbn0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgcm9vdCA9IG1vZHVsZTtcbn0gZWxzZSB7XG4gIHJvb3QgPSBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xufVxuXG52YXIgcmVzdWx0ID0gKDAsIF9wb255ZmlsbDJbJ2RlZmF1bHQnXSkocm9vdCk7XG5leHBvcnRzWydkZWZhdWx0J10gPSByZXN1bHQ7IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0dmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0c1snZGVmYXVsdCddID0gc3ltYm9sT2JzZXJ2YWJsZVBvbnlmaWxsO1xuZnVuY3Rpb24gc3ltYm9sT2JzZXJ2YWJsZVBvbnlmaWxsKHJvb3QpIHtcblx0dmFyIHJlc3VsdDtcblx0dmFyIF9TeW1ib2wgPSByb290LlN5bWJvbDtcblxuXHRpZiAodHlwZW9mIF9TeW1ib2wgPT09ICdmdW5jdGlvbicpIHtcblx0XHRpZiAoX1N5bWJvbC5vYnNlcnZhYmxlKSB7XG5cdFx0XHRyZXN1bHQgPSBfU3ltYm9sLm9ic2VydmFibGU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJlc3VsdCA9IF9TeW1ib2woJ29ic2VydmFibGUnKTtcblx0XHRcdF9TeW1ib2wub2JzZXJ2YWJsZSA9IHJlc3VsdDtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0cmVzdWx0ID0gJ0BAb2JzZXJ2YWJsZSc7XG5cdH1cblxuXHRyZXR1cm4gcmVzdWx0O1xufTsiLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogU2ltaWxhciB0byBpbnZhcmlhbnQgYnV0IG9ubHkgbG9ncyBhIHdhcm5pbmcgaWYgdGhlIGNvbmRpdGlvbiBpcyBub3QgbWV0LlxuICogVGhpcyBjYW4gYmUgdXNlZCB0byBsb2cgaXNzdWVzIGluIGRldmVsb3BtZW50IGVudmlyb25tZW50cyBpbiBjcml0aWNhbFxuICogcGF0aHMuIFJlbW92aW5nIHRoZSBsb2dnaW5nIGNvZGUgZm9yIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRzIHdpbGwga2VlcCB0aGVcbiAqIHNhbWUgbG9naWMgYW5kIGZvbGxvdyB0aGUgc2FtZSBjb2RlIHBhdGhzLlxuICovXG5cbnZhciB3YXJuaW5nID0gZnVuY3Rpb24oKSB7fTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgd2FybmluZyA9IGZ1bmN0aW9uKGNvbmRpdGlvbiwgZm9ybWF0LCBhcmdzKSB7XG4gICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgYXJncyA9IG5ldyBBcnJheShsZW4gPiAyID8gbGVuIC0gMiA6IDApO1xuICAgIGZvciAodmFyIGtleSA9IDI7IGtleSA8IGxlbjsga2V5KyspIHtcbiAgICAgIGFyZ3Nba2V5IC0gMl0gPSBhcmd1bWVudHNba2V5XTtcbiAgICB9XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdgd2FybmluZyhjb25kaXRpb24sIGZvcm1hdCwgLi4uYXJncylgIHJlcXVpcmVzIGEgd2FybmluZyAnICtcbiAgICAgICAgJ21lc3NhZ2UgYXJndW1lbnQnXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChmb3JtYXQubGVuZ3RoIDwgMTAgfHwgKC9eW3NcXFddKiQvKS50ZXN0KGZvcm1hdCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1RoZSB3YXJuaW5nIGZvcm1hdCBzaG91bGQgYmUgYWJsZSB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzICcgK1xuICAgICAgICAnd2FybmluZy4gUGxlYXNlLCB1c2UgYSBtb3JlIGRlc2NyaXB0aXZlIGZvcm1hdCB0aGFuOiAnICsgZm9ybWF0XG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArXG4gICAgICAgIGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gYXJnc1thcmdJbmRleCsrXTtcbiAgICAgICAgfSk7XG4gICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IHlvdSBjYW4gdXNlIHRoaXMgc3RhY2tcbiAgICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgIH0gY2F0Y2goeCkge31cbiAgICB9XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gd2FybmluZztcbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCJuYW1lXCI6IFwiQGt5bmlrb3Mvd2lraS1tb25rZXlcIixcbiAgXCJ2ZXJzaW9uXCI6IFwiNC4xLjBcIixcbiAgXCJhdXRob3JcIjogXCJEYXJpbyBHaW92YW5uZXR0aVwiLFxuICBcImRlc2NyaXB0aW9uXCI6IFwiTWVkaWFXaWtpIGJvdCBhbmQgZWRpdG9yLWFzc2lzdGFudCB1c2VyIHNjcmlwdC5cIixcbiAgXCJsaWNlbnNlXCI6IFwiR1BMLTMuMFwiLFxuICBcInJlcG9zaXRvcnlcIjoge1xuICAgIFwidHlwZVwiOiBcImdpdFwiLFxuICAgIFwidXJsXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL2t5bmlrb3Mvd2lraS1tb25rZXkuZ2l0XCJcbiAgfSxcbiAgXCJrZXl3b3Jkc1wiOiBbXG4gICAgXCJ3aWtpIG1lZGlhd2lraSBib3RcIlxuICBdLFxuICBcImRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJAa3luaWtvcy9taXNjXCI6IFwiXjAuMS4zXCIsXG4gICAgXCJiYWJlbC1wb2x5ZmlsbFwiOiBcIl42LjI2LjBcIixcbiAgICBcImh5cGVyc2NyaXB0XCI6IFwiXjIuMC4yXCIsXG4gICAgXCJoeXBlcnNjcmlwdC1oZWxwZXJzXCI6IFwiXjMuMC4zXCIsXG4gICAgXCJqc3NcIjogXCJeOS41LjFcIixcbiAgICBcImpzcy1wcmVzZXQtZGVmYXVsdFwiOiBcIl40LjEuMFwiLFxuICAgIFwibW9tZW50XCI6IFwiXjIuMjAuMVwiXG4gIH0sXG4gIFwiZGV2RGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcIkBreW5pa29zL2Jyb3dzZXJpZnktaGVscGVyc1wiOiBcIl4xLjAuOFwiLFxuICAgIFwiYmFiZWwtY29yZVwiOiBcIl42LjI2LjBcIixcbiAgICBcImJhYmVsLXByZXNldC1lbnZcIjogXCJeMS42LjFcIixcbiAgICBcImNvZmZlZWxpbnRcIjogXCJeMi4wLjdcIixcbiAgICBcImNvZmZlZXNjcmlwdFwiOiBcIl4yLjEuMVwiLFxuICAgIFwiaHR0cC1zZXJ2ZXJcIjogXCJeMC4xMS4xXCJcbiAgfVxufVxuIiwiIyBXaWtpIE1vbmtleSAtIE1lZGlhV2lraSBib3QgYW5kIGVkaXRvci1hc3Npc3RhbnQgdXNlciBzY3JpcHRcbiMgQ29weXJpZ2h0IChDKSAyMDExIERhcmlvIEdpb3Zhbm5ldHRpIDxkZXZAZGFyaW9naW92YW5uZXR0aS5uZXQ+XG4jXG4jIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFdpa2kgTW9ua2V5LlxuI1xuIyBXaWtpIE1vbmtleSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4jIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4jIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4jIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4jXG4jIFdpa2kgTW9ua2V5IGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4jIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4jIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiMgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbiNcbiMgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiMgYWxvbmcgd2l0aCBXaWtpIE1vbmtleS4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cblxue1dNfSA9IHJlcXVpcmUoJy4vbW9kdWxlcy9fSW5pdCcpXG5cbm5ldyBXTShcbiAgICBcIkFyY2hXaWtpXCIsXG5cbiAgICAjIFRoZSByZXF1aXJlIHBhdGhzIGNhbid0IGJlIGNvbnN0cnVjdGVkIGR5bmFtaWNhbGx5LCBvciBicm93c2VyaWZ5IHdvbid0XG4gICAgIyB1bmRlcnN0YW5kIGFuZCBpbXBvcnQgdGhlbVxuICAgIHJlcXVpcmUoXCIuL3BsdWdpbnMvQXJjaFdpa2lGaXhIZWFkZXJcIiksXG4gICAgcmVxdWlyZShcIi4vcGx1Z2lucy9BcmNoV2lraUZpeEhlYWRpbmdzXCIpLFxuICAgIHJlcXVpcmUoXCIuL3BsdWdpbnMvQXJjaFdpa2lGaXhMaW5rc1wiKSxcbiAgICByZXF1aXJlKFwiLi9wbHVnaW5zL0FyY2hXaWtpTmV3VGVtcGxhdGVzXCIpLFxuICAgIHJlcXVpcmUoXCIuL3BsdWdpbnMvQXJjaFdpa2lOUEZpbHRlclwiKSxcbiAgICByZXF1aXJlKFwiLi9wbHVnaW5zL0FyY2hXaWtpUkNGaWx0ZXJcIiksXG4gICAgcmVxdWlyZShcIi4vcGx1Z2lucy9BcmNoV2lraVNhdmVUYWxrXCIpLFxuICAgIHJlcXVpcmUoXCIuL3BsdWdpbnMvQXJjaFdpa2lTb3J0Q29udGFjdHNcIiksXG4gICAgIyBUaGUgQXJjaFBhY2thZ2VzIG1vZHVsZSBpcyBjdXJyZW50bHkgdW51c2FibGVcbiAgICAjcmVxdWlyZShcIi4vcGx1Z2lucy9BcmNoV2lraVVwZGF0ZVBhY2thZ2VUZW1wbGF0ZXNcIiksXG4gICAgcmVxdWlyZShcIi4vcGx1Z2lucy9BcmNoV2lraVdhbnRlZENhdGVnb3JpZXNcIiksXG4gICAgcmVxdWlyZShcIi4vcGx1Z2lucy9EZWxldGVQYWdlc1wiKSxcbiAgICByZXF1aXJlKFwiLi9wbHVnaW5zL0V4cGFuZENvbnRyYWN0aW9uc1wiKSxcbiAgICByZXF1aXJlKFwiLi9wbHVnaW5zL0ZpeEJhY2tsaW5rRnJhZ21lbnRzXCIpLFxuICAgIHJlcXVpcmUoXCIuL3BsdWdpbnMvRml4RG91YmxlUmVkaXJlY3RzXCIpLFxuICAgIHJlcXVpcmUoXCIuL3BsdWdpbnMvRml4RnJhZ21lbnRzXCIpLFxuICAgIHJlcXVpcmUoXCIuL3BsdWdpbnMvRml4TGlua0ZyYWdtZW50c1wiKSxcbiAgICByZXF1aXJlKFwiLi9wbHVnaW5zL011bHRpcGxlTGluZUJyZWFrc1wiKSxcbiAgICByZXF1aXJlKFwiLi9wbHVnaW5zL1NpbXBsZVJlcGxhY2VcIiksXG4gICAgcmVxdWlyZShcIi4vcGx1Z2lucy9TeW5jaHJvbml6ZUludGVybGFuZ3VhZ2VMaW5rc1wiKSxcbiAgICByZXF1aXJlKFwiLi9wbHVnaW5zL1VwZGF0ZUNhdGVnb3J5VHJlZVwiKSxcbilcbiIsIiMgV2lraSBNb25rZXkgLSBNZWRpYVdpa2kgYm90IGFuZCBlZGl0b3ItYXNzaXN0YW50IHVzZXIgc2NyaXB0XG4jIENvcHlyaWdodCAoQykgMjAxMSBEYXJpbyBHaW92YW5uZXR0aSA8ZGV2QGRhcmlvZ2lvdmFubmV0dGkubmV0PlxuI1xuIyBUaGlzIGZpbGUgaXMgcGFydCBvZiBXaWtpIE1vbmtleS5cbiNcbiMgV2lraSBNb25rZXkgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuIyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuIyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuIyAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuI1xuIyBXaWtpIE1vbmtleSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuIyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuIyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4jIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4jXG4jIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4jIGFsb25nIHdpdGggV2lraSBNb25rZXkuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG5cblxuY2xhc3MgbW9kdWxlLmV4cG9ydHNcbiAgICBjb25zdHJ1Y3RvcjogKEBXTSkgLT5cblxuICAgIGxhbmd1YWdlcyA9IHtcbiAgICAgICAgbG9jYWw6IFwiRW5nbGlzaFwiLFxuICAgICAgICBuYW1lczoge1xuICAgICAgICAgICAgXCLYp9mE2LnYsdio2YrYqVwiOiB7c3VidGFnOiBcImFyXCIsIGVuZ2xpc2g6IFwiQXJhYmljXCJ9LFxuICAgICAgICAgICAgXCLQkdGK0LvQs9Cw0YDRgdC60LhcIjoge3N1YnRhZzogXCJiZ1wiLCBlbmdsaXNoOiBcIkJ1bGdhcmlhblwifSxcbiAgICAgICAgICAgIFwiQ2F0YWzDoFwiOiB7c3VidGFnOiBcImNhXCIsIGVuZ2xpc2g6IFwiQ2F0YWxhblwifSxcbiAgICAgICAgICAgIFwixIxlc2t5XCI6IHtzdWJ0YWc6IFwiY3NcIiwgZW5nbGlzaDogXCJDemVjaFwifSxcbiAgICAgICAgICAgIFwiRGFuc2tcIjoge3N1YnRhZzogXCJkYVwiLCBlbmdsaXNoOiBcIkRhbmlzaFwifSxcbiAgICAgICAgICAgIFwiRGV1dHNjaFwiOiB7c3VidGFnOiBcImRlXCIsIGVuZ2xpc2g6IFwiR2VybWFuXCJ9LFxuICAgICAgICAgICAgXCLOlc67zrvOt869zrnOus6sXCI6IHtzdWJ0YWc6IFwiZWxcIiwgZW5nbGlzaDogXCJHcmVla1wifSxcbiAgICAgICAgICAgIFwiRW5nbGlzaFwiOiB7c3VidGFnOiBcImVuXCIsIGVuZ2xpc2g6IFwiRW5nbGlzaFwifSxcbiAgICAgICAgICAgIFwiRXNwZXJhbnRvXCI6IHtzdWJ0YWc6IFwiZW9cIiwgZW5nbGlzaDogXCJFc3BlcmFudG9cIn0sXG4gICAgICAgICAgICBcIkVzcGHDsW9sXCI6IHtzdWJ0YWc6IFwiZXNcIiwgZW5nbGlzaDogXCJTcGFuaXNoXCJ9LFxuICAgICAgICAgICAgXCLZgdin2LHYs9uMXCI6IHtzdWJ0YWc6IFwiZmFcIiwgZW5nbGlzaDogXCJQZXJzaWFuXCJ9LFxuICAgICAgICAgICAgXCJTdW9taVwiOiB7c3VidGFnOiBcImZpXCIsIGVuZ2xpc2g6IFwiRmlubmlzaFwifSxcbiAgICAgICAgICAgIFwiRnJhbsOnYWlzXCI6IHtzdWJ0YWc6IFwiZnJcIiwgZW5nbGlzaDogXCJGcmVuY2hcIn0sXG4gICAgICAgICAgICBcItei15HXqNeZ16pcIjoge3N1YnRhZzogXCJoZVwiLCBlbmdsaXNoOiBcIkhlYnJld1wifSxcbiAgICAgICAgICAgIFwiSHJ2YXRza2lcIjoge3N1YnRhZzogXCJoclwiLCBlbmdsaXNoOiBcIkNyb2F0aWFuXCJ9LFxuICAgICAgICAgICAgXCJNYWd5YXJcIjoge3N1YnRhZzogXCJodVwiLCBlbmdsaXNoOiBcIkh1bmdhcmlhblwifSxcbiAgICAgICAgICAgIFwiSW5kb25lc2lhXCI6IHtzdWJ0YWc6IFwiaWRcIiwgZW5nbGlzaDogXCJJbmRvbmVzaWFuXCJ9LFxuICAgICAgICAgICAgXCJJdGFsaWFub1wiOiB7c3VidGFnOiBcIml0XCIsIGVuZ2xpc2g6IFwiSXRhbGlhblwifSxcbiAgICAgICAgICAgIFwi5pel5pys6KqeXCI6IHtzdWJ0YWc6IFwiamFcIiwgZW5nbGlzaDogXCJKYXBhbmVzZVwifSxcbiAgICAgICAgICAgIFwi7ZWc6rWt7Ja0XCI6IHtzdWJ0YWc6IFwia29cIiwgZW5nbGlzaDogXCJLb3JlYW5cIn0sXG4gICAgICAgICAgICBcIkxpZXR1dmnFoWthaVwiOiB7c3VidGFnOiBcImx0XCIsIGVuZ2xpc2g6IFwiTGl0aHVhbmlhblwifSxcbiAgICAgICAgICAgIFwiTm9yc2sgQm9rbcOlbFwiOiB7c3VidGFnOiBcIm5iXCIsIGVuZ2xpc2g6IFwiTm9yd2VnaWFuIChCb2ttw6VsKVwifSxcbiAgICAgICAgICAgIFwiTmVkZXJsYW5kc1wiOiB7c3VidGFnOiBcIm5sXCIsIGVuZ2xpc2g6IFwiRHV0Y2hcIn0sXG4gICAgICAgICAgICBcIlBvbHNraVwiOiB7c3VidGFnOiBcInBsXCIsIGVuZ2xpc2g6IFwiUG9saXNoXCJ9LFxuICAgICAgICAgICAgXCJQb3J0dWd1w6pzXCI6IHtzdWJ0YWc6IFwicHRcIiwgZW5nbGlzaDogXCJQb3J0dWd1ZXNlXCJ9LFxuICAgICAgICAgICAgXCJSb23Dom7Eg1wiOiB7c3VidGFnOiBcInJvXCIsIGVuZ2xpc2g6IFwiUm9tYW5pYW5cIn0sXG4gICAgICAgICAgICBcItCg0YPRgdGB0LrQuNC5XCI6IHtzdWJ0YWc6IFwicnVcIiwgZW5nbGlzaDogXCJSdXNzaWFuXCJ9LFxuICAgICAgICAgICAgXCJTbG92ZW5za8O9XCI6IHtzdWJ0YWc6IFwic2tcIiwgZW5nbGlzaDogXCJTbG92YWtcIn0sXG4gICAgICAgICAgICBcItCh0YDQv9GB0LrQuFwiOiB7c3VidGFnOiBcInNyXCIsIGVuZ2xpc2g6IFwiU2VyYmlhblwifSxcbiAgICAgICAgICAgIFwiU3ZlbnNrYVwiOiB7c3VidGFnOiBcInN2XCIsIGVuZ2xpc2g6IFwiU3dlZGlzaFwifSxcbiAgICAgICAgICAgIFwi4LmE4LiX4LiiXCI6IHtzdWJ0YWc6IFwidGhcIiwgZW5nbGlzaDogXCJUaGFpXCJ9LFxuICAgICAgICAgICAgXCJUw7xya8OnZVwiOiB7c3VidGFnOiBcInRyXCIsIGVuZ2xpc2g6IFwiVHVya2lzaFwifSxcbiAgICAgICAgICAgIFwi0KPQutGA0LDRl9C90YHRjNC60LBcIjoge3N1YnRhZzogXCJ1a1wiLCBlbmdsaXNoOiBcIlVrcmFpbmlhblwifSxcbiAgICAgICAgICAgIFwiVGnhur9uZyBWaeG7h3RcIjoge3N1YnRhZzogXCJ2aVwiLCBlbmdsaXNoOiBcIlZpZXRuYW1lc2VcIn0sXG4gICAgICAgICAgICBcIueugOS9k+S4reaWh1wiOiB7c3VidGFnOiBcInpoLWhhbnNcIiwgZW5nbGlzaDogXCJDaGluZXNlIChTaW1wbGlmaWVkKVwifSxcbiAgICAgICAgICAgIFwi5q2j6auU5Lit5paHXCI6IHtzdWJ0YWc6IFwiemgtaGFudFwiLCBlbmdsaXNoOiBcIkNoaW5lc2UgKFRyYWRpdGlvbmFsKVwifVxuICAgICAgICB9LFxuICAgICAgICBjYXRlZ29yaWVzOiBbXG4gICAgICAgICAgICBcItin2YTYudix2KjZitipXCIsXG4gICAgICAgICAgICBcItCR0YrQu9Cz0LDRgNGB0LrQuFwiLFxuICAgICAgICAgICAgXCJDYXRhbMOgXCIsXG4gICAgICAgICAgICBcIsSMZXNreVwiLFxuICAgICAgICAgICAgXCJEYW5za1wiLFxuICAgICAgICAgICAgXCLOlc67zrvOt869zrnOus6sXCIsXG4gICAgICAgICAgICBcIkVuZ2xpc2hcIixcbiAgICAgICAgICAgIFwiRXNwZXJhbnRvXCIsXG4gICAgICAgICAgICBcIkVzcGHDsW9sXCIsXG4gICAgICAgICAgICBcIlN1b21pXCIsXG4gICAgICAgICAgICBcItei15HXqNeZ16pcIixcbiAgICAgICAgICAgIFwiSHJ2YXRza2lcIixcbiAgICAgICAgICAgIFwiTWFneWFyXCIsXG4gICAgICAgICAgICBcIkluZG9uZXNpYVwiLFxuICAgICAgICAgICAgXCJJdGFsaWFub1wiLFxuICAgICAgICAgICAgXCLml6XmnKzoqp5cIixcbiAgICAgICAgICAgIFwi7ZWc6rWt7Ja0XCIsXG4gICAgICAgICAgICBcIkxpZXR1dmnFoWthaVwiLFxuICAgICAgICAgICAgXCJOb3JzayBCb2ttw6VsXCIsXG4gICAgICAgICAgICBcIk5lZGVybGFuZHNcIixcbiAgICAgICAgICAgIFwiUG9sc2tpXCIsXG4gICAgICAgICAgICBcIlBvcnR1Z3XDqnNcIixcbiAgICAgICAgICAgIFwi0KDRg9GB0YHQutC40LlcIixcbiAgICAgICAgICAgIFwiU2xvdmVuc2vDvVwiLFxuICAgICAgICAgICAgXCLQodGA0L/RgdC60LhcIixcbiAgICAgICAgICAgIFwi4LmE4LiX4LiiXCIsXG4gICAgICAgICAgICBcIlTDvHJrw6dlXCIsXG4gICAgICAgICAgICBcItCj0LrRgNCw0ZfQvdGB0YzQutCwXCIsXG4gICAgICAgICAgICBcIueugOS9k+S4reaWh1wiLFxuICAgICAgICAgICAgXCLmraPpq5TkuK3mlodcIlxuICAgICAgICBdLFxuICAgICAgICBpbnRlcmxhbmd1YWdlOiB7XG4gICAgICAgICAgICBleHRlcm5hbDogW1wiZGVcIiwgXCJmYVwiLCBcImZyXCIsIFwiamFcIiwgXCJyb1wiXSxcbiAgICAgICAgICAgIGludGVybmFsOiBbXCJhclwiLCBcImJnXCIsIFwiY3NcIiwgXCJkYVwiLCBcImVsXCIsIFwiZW5cIiwgXCJlc1wiLCBcImZpXCIsIFwiaGVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgXCJoclwiLCBcImh1XCIsIFwiaWRcIiwgXCJpdFwiLCBcImtvXCIsIFwibHRcIiwgXCJubFwiLCBcInBsXCIsIFwicHRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgXCJydVwiLCBcInNrXCIsIFwic3JcIiwgXCJzdlwiLCBcInRoXCIsIFwidHJcIiwgXCJ1a1wiLCBcInpoLWhhbnNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgXCJ6aC1oYW50XCJdLFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGFibGVzT2ZDb250ZW50cyA9IHtcbiAgICAgICAgXCJhclwiOiB7XG4gICAgICAgICAgICBcInBhZ2VcIjogXCJUYWJsZSBvZiBjb250ZW50cyAo2KfZhNi52LHYqNmK2KkpXCIsXG4gICAgICAgICAgICBcInJvb3RcIjogXCJDYXRlZ29yeTrYp9mE2LnYsdio2YrYqVwiLFxuICAgICAgICAgICAgXCJhbHNvSW5cIjogXCJhbHNvIGluXCIsICAjIFRPRE86IFVudHJhbnNsYXRlZCwgUmlnaHQtdG8tbGVmdCBwcm9ibGVtc1xuICAgICAgICAgICAgXCJpbmRlbnRUeXBlXCI6IFwiOlwiLFxuICAgICAgICAgICAgXCJyZXBsYWNlXCI6IFtcIlsgX11cXFxcKNin2YTYudix2KjZitipXFxcXClcIiwgXCJcIiwgXCJcIl0sXG4gICAgICAgICAgICBcImtlZXBBbHROYW1lXCI6IHRydWUsXG4gICAgICAgICAgICBcInNob3dJbmRpY2VzXCI6IHRydWUsXG4gICAgICAgICAgICBcInJpZ2h0VG9MZWZ0XCI6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgXCJiZ1wiOiB7XG4gICAgICAgICAgICBcInBhZ2VcIjogXCJUYWJsZSBvZiBjb250ZW50cyAo0JHRitC70LPQsNGA0YHQutC4KVwiLFxuICAgICAgICAgICAgXCJyb290XCI6IFwiQ2F0ZWdvcnk60JHRitC70LPQsNGA0YHQutC4XCIsXG4gICAgICAgICAgICBcImFsc29JblwiOiBcItGB0YrRidC+INCyXCIsICAjIFVuY29uZmlybWVkXG4gICAgICAgICAgICBcImluZGVudFR5cGVcIjogXCI6XCIsXG4gICAgICAgICAgICBcInJlcGxhY2VcIjogW1wiWyBfXVxcXFwo0JHRitC70LPQsNGA0YHQutC4XFxcXClcIiwgXCJcIiwgXCJcIl0sXG4gICAgICAgICAgICBcImtlZXBBbHROYW1lXCI6IHRydWUsXG4gICAgICAgICAgICBcInNob3dJbmRpY2VzXCI6IHRydWUsXG4gICAgICAgICAgICBcInJpZ2h0VG9MZWZ0XCI6IGZhbHNlXG4gICAgICAgIH0sXG4gICAgICAgIFwiY3NcIjoge1xuICAgICAgICAgICAgXCJwYWdlXCI6IFwiVGFibGUgb2YgY29udGVudHMgKMSMZXNreSlcIixcbiAgICAgICAgICAgIFwicm9vdFwiOiBcIkNhdGVnb3J5OsSMZXNreVwiLFxuICAgICAgICAgICAgXCJhbHNvSW5cIjogXCJ0YWvDqSB2XCIsXG4gICAgICAgICAgICBcImluZGVudFR5cGVcIjogXCI6XCIsXG4gICAgICAgICAgICBcInJlcGxhY2VcIjogW1wiWyBfXVxcXFwoxIxlc2t5XFxcXClcIiwgXCJcIiwgXCJcIl0sXG4gICAgICAgICAgICBcImtlZXBBbHROYW1lXCI6IHRydWUsXG4gICAgICAgICAgICBcInNob3dJbmRpY2VzXCI6IHRydWUsXG4gICAgICAgICAgICBcInJpZ2h0VG9MZWZ0XCI6IGZhbHNlXG4gICAgICAgIH0sXG4gICAgICAgIFwiZGFcIjoge1xuICAgICAgICAgICAgXCJwYWdlXCI6IFwiVGFibGUgb2YgY29udGVudHMgKERhbnNrKVwiLFxuICAgICAgICAgICAgXCJyb290XCI6IFwiQ2F0ZWdvcnk6RGFuc2tcIixcbiAgICAgICAgICAgIFwiYWxzb0luXCI6IFwib2dzw6UgaVwiLCAgIyBVbmNvbmZpcm1lZFxuICAgICAgICAgICAgXCJpbmRlbnRUeXBlXCI6IFwiOlwiLFxuICAgICAgICAgICAgXCJyZXBsYWNlXCI6IFtcIlsgX11cXFxcKERhbnNrXFxcXClcIiwgXCJcIiwgXCJcIl0sXG4gICAgICAgICAgICBcImtlZXBBbHROYW1lXCI6IHRydWUsXG4gICAgICAgICAgICBcInNob3dJbmRpY2VzXCI6IHRydWUsXG4gICAgICAgICAgICBcInJpZ2h0VG9MZWZ0XCI6IGZhbHNlXG4gICAgICAgIH0sXG4gICAgICAgIFwiZWxcIjoge1xuICAgICAgICAgICAgXCJwYWdlXCI6IFwiVGFibGUgb2YgY29udGVudHMgKM6VzrvOu863zr3Ouc66zqwpXCIsXG4gICAgICAgICAgICBcInJvb3RcIjogXCJDYXRlZ29yeTrOlc67zrvOt869zrnOus6sXCIsXG4gICAgICAgICAgICBcImFsc29JblwiOiBcIs61z4DOr8+DzrfPgiDPg861XCIsICAjIFVuY29uZmlybWVkXG4gICAgICAgICAgICBcImluZGVudFR5cGVcIjogXCI6XCIsXG4gICAgICAgICAgICBcInJlcGxhY2VcIjogW1wiWyBfXVxcXFwozpXOu867zrfOvc65zrrOrFxcXFwpXCIsIFwiXCIsIFwiXCJdLFxuICAgICAgICAgICAgXCJrZWVwQWx0TmFtZVwiOiB0cnVlLFxuICAgICAgICAgICAgXCJzaG93SW5kaWNlc1wiOiB0cnVlLFxuICAgICAgICAgICAgXCJyaWdodFRvTGVmdFwiOiBmYWxzZVxuICAgICAgICB9LFxuICAgICAgICBcImVuXCI6IHtcbiAgICAgICAgICAgIFwicGFnZVwiOiBcIlRhYmxlIG9mIGNvbnRlbnRzXCIsXG4gICAgICAgICAgICBcInJvb3RcIjogXCJDYXRlZ29yeTpFbmdsaXNoXCIsXG4gICAgICAgICAgICBcImFsc29JblwiOiBcImFsc28gaW5cIixcbiAgICAgICAgICAgIFwiaW5kZW50VHlwZVwiOiBcIjpcIixcbiAgICAgICAgICAgIFwicmVwbGFjZVwiOiBudWxsLFxuICAgICAgICAgICAgXCJrZWVwQWx0TmFtZVwiOiBmYWxzZSxcbiAgICAgICAgICAgIFwic2hvd0luZGljZXNcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwicmlnaHRUb0xlZnRcIjogZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgXCJlc1wiOiB7XG4gICAgICAgICAgICBcInBhZ2VcIjogXCJUYWJsZSBvZiBjb250ZW50cyAoRXNwYcOxb2wpXCIsXG4gICAgICAgICAgICBcInJvb3RcIjogXCJDYXRlZ29yeTpFc3Bhw7FvbFwiLFxuICAgICAgICAgICAgXCJhbHNvSW5cIjogXCJ0YW1iacOpbiBlblwiLFxuICAgICAgICAgICAgXCJpbmRlbnRUeXBlXCI6IFwiOlwiLFxuICAgICAgICAgICAgXCJyZXBsYWNlXCI6IFtcIlsgX11cXFxcKEVzcGHDsW9sXFxcXClcIiwgXCJcIiwgXCJcIl0sXG4gICAgICAgICAgICBcImtlZXBBbHROYW1lXCI6IHRydWUsXG4gICAgICAgICAgICBcInNob3dJbmRpY2VzXCI6IHRydWUsXG4gICAgICAgICAgICBcInJpZ2h0VG9MZWZ0XCI6IGZhbHNlXG4gICAgICAgIH0sXG4gICAgICAgIFwiaGVcIjoge1xuICAgICAgICAgICAgXCJwYWdlXCI6IFwiVGFibGUgb2YgY29udGVudHMgKNei15HXqNeZ16opXCIsXG4gICAgICAgICAgICBcInJvb3RcIjogXCJDYXRlZ29yeTrXoteR16jXmdeqXCIsXG4gICAgICAgICAgICBcImFsc29JblwiOiBcImFsc28gaW5cIiwgICMgVE9ETzogVW50cmFuc2xhdGVkLCBSaWdodC10by1sZWZ0IHByb2JsZW1zXG4gICAgICAgICAgICBcImluZGVudFR5cGVcIjogXCI6XCIsXG4gICAgICAgICAgICBcInJlcGxhY2VcIjogW1wiWyBfXVxcXFwo16LXkdeo15nXqlxcXFwpXCIsIFwiXCIsIFwiXCJdLFxuICAgICAgICAgICAgXCJrZWVwQWx0TmFtZVwiOiB0cnVlLFxuICAgICAgICAgICAgXCJzaG93SW5kaWNlc1wiOiB0cnVlLFxuICAgICAgICAgICAgXCJyaWdodFRvTGVmdFwiOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIFwiaHJcIjoge1xuICAgICAgICAgICAgXCJwYWdlXCI6IFwiVGFibGUgb2YgY29udGVudHMgKEhydmF0c2tpKVwiLFxuICAgICAgICAgICAgXCJyb290XCI6IFwiQ2F0ZWdvcnk6SHJ2YXRza2lcIixcbiAgICAgICAgICAgIFwiYWxzb0luXCI6IFwidGFrb8SRZXIgdVwiLCAgIyBVbmNvbmZpcm1lZFxuICAgICAgICAgICAgXCJpbmRlbnRUeXBlXCI6IFwiOlwiLFxuICAgICAgICAgICAgXCJyZXBsYWNlXCI6IFtcIlsgX11cXFxcKEhydmF0c2tpXFxcXClcIiwgXCJcIiwgXCJcIl0sXG4gICAgICAgICAgICBcImtlZXBBbHROYW1lXCI6IHRydWUsXG4gICAgICAgICAgICBcInNob3dJbmRpY2VzXCI6IHRydWUsXG4gICAgICAgICAgICBcInJpZ2h0VG9MZWZ0XCI6IGZhbHNlXG4gICAgICAgIH0sXG4gICAgICAgIFwiaHVcIjoge1xuICAgICAgICAgICAgXCJwYWdlXCI6IFwiVGFibGUgb2YgY29udGVudHMgKE1hZ3lhcilcIixcbiAgICAgICAgICAgIFwicm9vdFwiOiBcIkNhdGVnb3J5Ok1hZ3lhclwiLFxuICAgICAgICAgICAgXCJhbHNvSW5cIjogXCJpc1wiLCAgIyBVbmNvbmZpcm1lZFxuICAgICAgICAgICAgXCJpbmRlbnRUeXBlXCI6IFwiOlwiLFxuICAgICAgICAgICAgXCJyZXBsYWNlXCI6IFtcIlsgX11cXFxcKE1hZ3lhclxcXFwpXCIsIFwiXCIsIFwiXCJdLFxuICAgICAgICAgICAgXCJrZWVwQWx0TmFtZVwiOiB0cnVlLFxuICAgICAgICAgICAgXCJzaG93SW5kaWNlc1wiOiB0cnVlLFxuICAgICAgICAgICAgXCJyaWdodFRvTGVmdFwiOiBmYWxzZVxuICAgICAgICB9LFxuICAgICAgICBcImlkXCI6IHtcbiAgICAgICAgICAgIFwicGFnZVwiOiBcIlRhYmxlIG9mIGNvbnRlbnRzIChJbmRvbmVzaWEpXCIsXG4gICAgICAgICAgICBcInJvb3RcIjogXCJDYXRlZ29yeTpJbmRvbmVzaWFcIixcbiAgICAgICAgICAgIFwiYWxzb0luXCI6IFwianVnYSBkaVwiLCAgIyBVbmNvbmZpcm1lZFxuICAgICAgICAgICAgXCJpbmRlbnRUeXBlXCI6IFwiOlwiLFxuICAgICAgICAgICAgXCJyZXBsYWNlXCI6IFtcIlsgX11cXFxcKEluZG9uZXNpYVxcXFwpXCIsIFwiXCIsIFwiXCJdLFxuICAgICAgICAgICAgXCJrZWVwQWx0TmFtZVwiOiB0cnVlLFxuICAgICAgICAgICAgXCJzaG93SW5kaWNlc1wiOiB0cnVlLFxuICAgICAgICAgICAgXCJyaWdodFRvTGVmdFwiOiBmYWxzZVxuICAgICAgICB9LFxuICAgICAgICBcIml0XCI6IHtcbiAgICAgICAgICAgIFwicGFnZVwiOiBcIlRhYmxlIG9mIGNvbnRlbnRzIChJdGFsaWFubylcIixcbiAgICAgICAgICAgIFwicm9vdFwiOiBcIkNhdGVnb3J5Okl0YWxpYW5vXCIsXG4gICAgICAgICAgICBcImFsc29JblwiOiBcImFuY2hlIGluXCIsXG4gICAgICAgICAgICBcImluZGVudFR5cGVcIjogXCI6XCIsXG4gICAgICAgICAgICBcInJlcGxhY2VcIjogW1wiWyBfXVxcXFwoSXRhbGlhbm9cXFxcKVwiLCBcIlwiLCBcIlwiXSxcbiAgICAgICAgICAgIFwia2VlcEFsdE5hbWVcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwic2hvd0luZGljZXNcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwicmlnaHRUb0xlZnRcIjogZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgXCJrb1wiOiB7XG4gICAgICAgICAgICBcInBhZ2VcIjogXCJUYWJsZSBvZiBjb250ZW50cyAo7ZWc6rWt7Ja0KVwiLFxuICAgICAgICAgICAgXCJyb290XCI6IFwiQ2F0ZWdvcnk67ZWc6rWt7Ja0XCIsXG4gICAgICAgICAgICBcImFsc29JblwiOiBcIuuYkO2VnCDsl5BcIiwgICMgVW5jb25maXJtZWRcbiAgICAgICAgICAgIFwiaW5kZW50VHlwZVwiOiBcIjpcIixcbiAgICAgICAgICAgIFwicmVwbGFjZVwiOiBbXCJbIF9dXFxcXCjtlZzqta3slrRcXFxcKVwiLCBcIlwiLCBcIlwiXSxcbiAgICAgICAgICAgIFwia2VlcEFsdE5hbWVcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwic2hvd0luZGljZXNcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwicmlnaHRUb0xlZnRcIjogZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgXCJsdFwiOiB7XG4gICAgICAgICAgICBcInBhZ2VcIjogXCJUYWJsZSBvZiBjb250ZW50cyAoTGlldHV2acWha2FpKVwiLFxuICAgICAgICAgICAgXCJyb290XCI6IFwiQ2F0ZWdvcnk6TGlldHV2acWha2FpXCIsXG4gICAgICAgICAgICBcImFsc29JblwiOiBcInRhaXAgcGF0IGlyXCIsICAjIFVuY29uZmlybWVkXG4gICAgICAgICAgICBcImluZGVudFR5cGVcIjogXCI6XCIsXG4gICAgICAgICAgICBcInJlcGxhY2VcIjogW1wiWyBfXVxcXFwoTGlldHV2acWha2FpXFxcXClcIiwgXCJcIiwgXCJcIl0sXG4gICAgICAgICAgICBcImtlZXBBbHROYW1lXCI6IHRydWUsXG4gICAgICAgICAgICBcInNob3dJbmRpY2VzXCI6IHRydWUsXG4gICAgICAgICAgICBcInJpZ2h0VG9MZWZ0XCI6IGZhbHNlXG4gICAgICAgIH0sXG4gICAgICAgIFwibmxcIjoge1xuICAgICAgICAgICAgXCJwYWdlXCI6IFwiVGFibGUgb2YgY29udGVudHMgKE5lZGVybGFuZHMpXCIsXG4gICAgICAgICAgICBcInJvb3RcIjogXCJDYXRlZ29yeTpOZWRlcmxhbmRzXCIsXG4gICAgICAgICAgICBcImFsc29JblwiOiBcIm9vayBpblwiLCAgIyBVbmNvbmZpcm1lZFxuICAgICAgICAgICAgXCJpbmRlbnRUeXBlXCI6IFwiOlwiLFxuICAgICAgICAgICAgXCJyZXBsYWNlXCI6IFtcIlsgX11cXFxcKE5lZGVybGFuZHNcXFxcKVwiLCBcIlwiLCBcIlwiXSxcbiAgICAgICAgICAgIFwia2VlcEFsdE5hbWVcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwic2hvd0luZGljZXNcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwicmlnaHRUb0xlZnRcIjogZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgXCJwbFwiOiB7XG4gICAgICAgICAgICBcInBhZ2VcIjogXCJUYWJsZSBvZiBjb250ZW50cyAoUG9sc2tpKVwiLFxuICAgICAgICAgICAgXCJyb290XCI6IFwiQ2F0ZWdvcnk6UG9sc2tpXCIsXG4gICAgICAgICAgICBcImFsc29JblwiOiBcInLDs3duaWXFvCB3XCIsICAjIFVuY29uZmlybWVkXG4gICAgICAgICAgICBcImluZGVudFR5cGVcIjogXCI6XCIsXG4gICAgICAgICAgICBcInJlcGxhY2VcIjogW1wiWyBfXVxcXFwoUG9sc2tpXFxcXClcIiwgXCJcIiwgXCJcIl0sXG4gICAgICAgICAgICBcImtlZXBBbHROYW1lXCI6IHRydWUsXG4gICAgICAgICAgICBcInNob3dJbmRpY2VzXCI6IHRydWUsXG4gICAgICAgICAgICBcInJpZ2h0VG9MZWZ0XCI6IGZhbHNlXG4gICAgICAgIH0sXG4gICAgICAgIFwicHRcIjoge1xuICAgICAgICAgICAgXCJwYWdlXCI6IFwiVGFibGUgb2YgY29udGVudHMgKFBvcnR1Z3XDqnMpXCIsXG4gICAgICAgICAgICBcInJvb3RcIjogXCJDYXRlZ29yeTpQb3J0dWd1w6pzXCIsXG4gICAgICAgICAgICBcImFsc29JblwiOiBcInRhbWLDqW0gZW1cIixcbiAgICAgICAgICAgIFwiaW5kZW50VHlwZVwiOiBcIjpcIixcbiAgICAgICAgICAgIFwicmVwbGFjZVwiOiBbXCJbIF9dXFxcXChQb3J0dWd1w6pzXFxcXClcIiwgXCJcIiwgXCJcIl0sXG4gICAgICAgICAgICBcImtlZXBBbHROYW1lXCI6IHRydWUsXG4gICAgICAgICAgICBcInNob3dJbmRpY2VzXCI6IHRydWUsXG4gICAgICAgICAgICBcInJpZ2h0VG9MZWZ0XCI6IGZhbHNlXG4gICAgICAgIH0sXG4gICAgICAgIFwicnVcIjoge1xuICAgICAgICAgICAgXCJwYWdlXCI6IFwiVGFibGUgb2YgY29udGVudHMgKNCg0YPRgdGB0LrQuNC5KVwiLFxuICAgICAgICAgICAgXCJyb290XCI6IFwiQ2F0ZWdvcnk60KDRg9GB0YHQutC40LlcIixcbiAgICAgICAgICAgIFwiYWxzb0luXCI6IFwi0KLQsNC60LbQtSDQslwiLFxuICAgICAgICAgICAgXCJpbmRlbnRUeXBlXCI6IFwiOlwiLFxuICAgICAgICAgICAgXCJyZXBsYWNlXCI6IFtcIlsgX11cXFxcKNCg0YPRgdGB0LrQuNC5XFxcXClcIiwgXCJcIiwgXCJcIl0sXG4gICAgICAgICAgICBcImtlZXBBbHROYW1lXCI6IHRydWUsXG4gICAgICAgICAgICBcInNob3dJbmRpY2VzXCI6IHRydWUsXG4gICAgICAgICAgICBcInJpZ2h0VG9MZWZ0XCI6IGZhbHNlXG4gICAgICAgIH0sXG4gICAgICAgIFwic2tcIjoge1xuICAgICAgICAgICAgXCJwYWdlXCI6IFwiVGFibGUgb2YgY29udGVudHMgKFNsb3ZlbnNrw70pXCIsXG4gICAgICAgICAgICBcInJvb3RcIjogXCJDYXRlZ29yeTpTbG92ZW5za8O9XCIsXG4gICAgICAgICAgICBcImFsc29JblwiOiBcInRpZcW+IHZcIixcbiAgICAgICAgICAgIFwiaW5kZW50VHlwZVwiOiBcIjpcIixcbiAgICAgICAgICAgIFwicmVwbGFjZVwiOiBbXCJbIF9dXFxcXChTbG92ZW5za8O9XFxcXClcIiwgXCJcIiwgXCJcIl0sXG4gICAgICAgICAgICBcImtlZXBBbHROYW1lXCI6IHRydWUsXG4gICAgICAgICAgICBcInNob3dJbmRpY2VzXCI6IHRydWUsXG4gICAgICAgICAgICBcInJpZ2h0VG9MZWZ0XCI6IGZhbHNlXG4gICAgICAgIH0sXG4gICAgICAgIFwic3JcIjoge1xuICAgICAgICAgICAgXCJwYWdlXCI6IFwiVGFibGUgb2YgY29udGVudHMgKNCh0YDQv9GB0LrQuClcIixcbiAgICAgICAgICAgIFwicm9vdFwiOiBcIkNhdGVnb3J5OtCh0YDQv9GB0LrQuFwiLFxuICAgICAgICAgICAgXCJhbHNvSW5cIjogXCLRgtCw0LrQvtGS0LUg0YNcIiwgICMgVW5jb25maXJtZWRcbiAgICAgICAgICAgIFwiaW5kZW50VHlwZVwiOiBcIjpcIixcbiAgICAgICAgICAgIFwicmVwbGFjZVwiOiBbXCJbIF9dXFxcXCjQodGA0L/RgdC60LhcXFxcKVwiLCBcIlwiLCBcIlwiXSxcbiAgICAgICAgICAgIFwia2VlcEFsdE5hbWVcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwic2hvd0luZGljZXNcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwicmlnaHRUb0xlZnRcIjogZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgXCJ0aFwiOiB7XG4gICAgICAgICAgICBcInBhZ2VcIjogXCJUYWJsZSBvZiBjb250ZW50cyAo4LmE4LiX4LiiKVwiLFxuICAgICAgICAgICAgXCJyb290XCI6IFwiQ2F0ZWdvcnk64LmE4LiX4LiiXCIsXG4gICAgICAgICAgICBcImFsc29JblwiOiBcIuC4ouC4seC4h+C4reC4ouC4ueC5iOC5g+C4mVwiLCAgIyBVbmNvbmZpcm1lZFxuICAgICAgICAgICAgXCJpbmRlbnRUeXBlXCI6IFwiOlwiLFxuICAgICAgICAgICAgXCJyZXBsYWNlXCI6IFtcIlsgX11cXFxcKOC5hOC4l+C4olxcXFwpXCIsIFwiXCIsIFwiXCJdLFxuICAgICAgICAgICAgXCJrZWVwQWx0TmFtZVwiOiB0cnVlLFxuICAgICAgICAgICAgXCJzaG93SW5kaWNlc1wiOiB0cnVlLFxuICAgICAgICAgICAgXCJyaWdodFRvTGVmdFwiOiBmYWxzZVxuICAgICAgICB9LFxuICAgICAgICBcInRyXCI6IHtcbiAgICAgICAgICAgIFwicGFnZVwiOiBcIlRhYmxlIG9mIGNvbnRlbnRzIChUw7xya8OnZSlcIixcbiAgICAgICAgICAgIFwicm9vdFwiOiBcIkNhdGVnb3J5OlTDvHJrw6dlXCIsXG4gICAgICAgICAgICBcImFsc29JblwiOiBcImF5csSxY2FcIiwgICMgVW5jb25maXJtZWRcbiAgICAgICAgICAgIFwiaW5kZW50VHlwZVwiOiBcIjpcIixcbiAgICAgICAgICAgIFwicmVwbGFjZVwiOiBbXCJbIF9dXFxcXChUw7xya8OnZVxcXFwpXCIsIFwiXCIsIFwiXCJdLFxuICAgICAgICAgICAgXCJrZWVwQWx0TmFtZVwiOiB0cnVlLFxuICAgICAgICAgICAgXCJzaG93SW5kaWNlc1wiOiB0cnVlLFxuICAgICAgICAgICAgXCJyaWdodFRvTGVmdFwiOiBmYWxzZVxuICAgICAgICB9LFxuICAgICAgICBcInVrXCI6IHtcbiAgICAgICAgICAgIFwicGFnZVwiOiBcIlRhYmxlIG9mIGNvbnRlbnRzICjQo9C60YDQsNGX0L3RgdGM0LrQsClcIixcbiAgICAgICAgICAgIFwicm9vdFwiOiBcIkNhdGVnb3J5OtCj0LrRgNCw0ZfQvdGB0YzQutCwXCIsXG4gICAgICAgICAgICBcImFsc29JblwiOiBcItGC0LDQutC+0LYg0LJcIiwgICMgVW5jb25maXJtZWRcbiAgICAgICAgICAgIFwiaW5kZW50VHlwZVwiOiBcIjpcIixcbiAgICAgICAgICAgIFwicmVwbGFjZVwiOiBbXCJbIF9dXFxcXCjQo9C60YDQsNGX0L3RgdGM0LrQsFxcXFwpXCIsIFwiXCIsIFwiXCJdLFxuICAgICAgICAgICAgXCJrZWVwQWx0TmFtZVwiOiB0cnVlLFxuICAgICAgICAgICAgXCJzaG93SW5kaWNlc1wiOiB0cnVlLFxuICAgICAgICAgICAgXCJyaWdodFRvTGVmdFwiOiBmYWxzZVxuICAgICAgICB9LFxuICAgICAgICBcInpoLWhhbnNcIjoge1xuICAgICAgICAgICAgXCJwYWdlXCI6IFwiVGFibGUgb2YgY29udGVudHMgKOeugOS9k+S4reaWhylcIixcbiAgICAgICAgICAgIFwicm9vdFwiOiBcIkNhdGVnb3J5OueugOS9k+S4reaWh1wiLFxuICAgICAgICAgICAgXCJhbHNvSW5cIjogXCLlkIzml7bov5jlsZ7kuo5cIixcbiAgICAgICAgICAgIFwiaW5kZW50VHlwZVwiOiBcIjpcIixcbiAgICAgICAgICAgIFwicmVwbGFjZVwiOiBbXCJbIF9dXFxcXCjnroDkvZPkuK3mlodcXFxcKVwiLCBcIlwiLCBcIlwiXSxcbiAgICAgICAgICAgIFwia2VlcEFsdE5hbWVcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwic2hvd0luZGljZXNcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwicmlnaHRUb0xlZnRcIjogZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgXCJ6aC1oYW50XCI6IHtcbiAgICAgICAgICAgIFwicGFnZVwiOiBcIlRhYmxlIG9mIGNvbnRlbnRzICjmraPpq5TkuK3mlocpXCIsXG4gICAgICAgICAgICBcInJvb3RcIjogXCJDYXRlZ29yeTrmraPpq5TkuK3mlodcIixcbiAgICAgICAgICAgIFwiYWxzb0luXCI6IFwi6YKE5ZyoXCIsICAjIFVuY29uZmlybWVkXG4gICAgICAgICAgICBcImluZGVudFR5cGVcIjogXCI6XCIsXG4gICAgICAgICAgICBcInJlcGxhY2VcIjogW1wiWyBfXVxcXFwo5q2j6auU5Lit5paHXFxcXClcIiwgXCJcIiwgXCJcIl0sXG4gICAgICAgICAgICBcImtlZXBBbHROYW1lXCI6IHRydWUsXG4gICAgICAgICAgICBcInNob3dJbmRpY2VzXCI6IHRydWUsXG4gICAgICAgICAgICBcInJpZ2h0VG9MZWZ0XCI6IGZhbHNlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRMb2NhbExhbmd1YWdlOiAtPlxuICAgICAgICByZXR1cm4gbGFuZ3VhZ2VzLmxvY2FsXG5cbiAgICBnZXRDYXRlZ29yeUxhbmd1YWdlczogLT5cbiAgICAgICAgcmV0dXJuIGxhbmd1YWdlcy5jYXRlZ29yaWVzXG5cbiAgICBpc0NhdGVnb3J5TGFuZ3VhZ2U6IChsYW5nKSAtPlxuICAgICAgICByZXR1cm4gbGFuZ3VhZ2VzLmNhdGVnb3JpZXMuaW5kZXhPZihsYW5nKSA+IC0xXG5cbiAgICBnZXRJbnRlcndpa2lMYW5ndWFnZXM6IC0+XG4gICAgICAgIHJldHVybiBsYW5ndWFnZXMuaW50ZXJsYW5ndWFnZS5leHRlcm5hbC5jb25jYXQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhbmd1YWdlcy5pbnRlcmxhbmd1YWdlLmludGVybmFsKVxuXG4gICAgaXNJbnRlcndpa2lMYW5ndWFnZTogKGxhbmcpIC0+XG4gICAgICAgIHJldHVybiB0aGlzLmdldEludGVyd2lraUxhbmd1YWdlcygpLmluZGV4T2YobGFuZykgPiAtMVxuXG4gICAgZ2V0SW50ZXJuYWxJbnRlcndpa2lMYW5ndWFnZXM6IC0+XG4gICAgICAgIHJldHVybiBsYW5ndWFnZXMuaW50ZXJsYW5ndWFnZS5pbnRlcm5hbFxuXG4gICAgaXNJbnRlcm5hbEludGVyd2lraUxhbmd1YWdlOiAobGFuZykgLT5cbiAgICAgICAgcmV0dXJuIGxhbmd1YWdlcy5pbnRlcmxhbmd1YWdlLmludGVybmFsLmluZGV4T2YobGFuZykgPiAtMVxuXG4gICAgZ2V0SW50ZXJsYW5ndWFnZVRhZzogKGxhbmd1YWdlKSAtPlxuICAgICAgICByZXR1cm4gbGFuZ3VhZ2VzLm5hbWVzW2xhbmd1YWdlXS5zdWJ0YWdcblxuICAgIGRldGVjdExhbmd1YWdlOiAodGl0bGUpIC0+XG4gICAgICAgIG1hdGNoZXMgPSB0aXRsZS5tYXRjaCgvXiguKz8pKD86WyBfXVxcKChbXlxcKF0rKVxcKSk/JC8pXG4gICAgICAgIHB1cmVUaXRsZSA9IG1hdGNoZXNbMV1cbiAgICAgICAgZGV0ZWN0ZWRMYW5ndWFnZSA9IG1hdGNoZXNbMl1cblxuICAgICAgICBpZiBub3QgZGV0ZWN0ZWRMYW5ndWFnZSBvciBub3QgQGlzQ2F0ZWdvcnlMYW5ndWFnZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV0ZWN0ZWRMYW5ndWFnZSlcbiAgICAgICAgICAgICMgTGFuZ3VhZ2UgY2F0ZWdvcmllcyBhcmUgZXhjZXB0aW9uc1xuICAgICAgICAgICAgIyBEb24ndCBqdXN0IHVzZSAvXlsgX10qKC4rPylbIF9dKiQvIGJ1dCByZXF1aXJlIHRoZSB3aG9sZVxuICAgICAgICAgICAgIyAgIG5hbWVzcGFjZSt0aXRsZSB0byBiZSBwYXNzZWQgYXMgdGhlIGFyZ3VtZW50IChpLmUuIGluY2x1ZGluZ1xuICAgICAgICAgICAgIyAgIFwiQ2F0ZWdvcnk6XCIpXG4gICAgICAgICAgICB0ZXN0TGFuZ0NhdCA9IG1hdGNoZXNbMV0ubWF0Y2goXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvXlsgX10qW0NjXWF0ZWdvcnlbIF9dKjpbIF9dKiguKz8pWyBfXSokLylcbiAgICAgICAgICAgIGlmIHRlc3RMYW5nQ2F0IGFuZCBAaXNDYXRlZ29yeUxhbmd1YWdlKHRlc3RMYW5nQ2F0WzFdKVxuICAgICAgICAgICAgICAgIGRldGVjdGVkTGFuZ3VhZ2UgPSB0ZXN0TGFuZ0NhdFsxXVxuICAgICAgICAgICAgICAgIHB1cmVUaXRsZSA9IG1hdGNoZXNbMV1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBkZXRlY3RlZExhbmd1YWdlID0gdGhpcy5nZXRMb2NhbExhbmd1YWdlKClcbiAgICAgICAgICAgICAgICBwdXJlVGl0bGUgPSBtYXRjaGVzWzBdXG5cbiAgICAgICAgcmV0dXJuIFtwdXJlVGl0bGUsIGRldGVjdGVkTGFuZ3VhZ2VdXG5cbiAgICBmaW5kQWxsSW50ZXJsYW5ndWFnZUxpbmtzOiAoc291cmNlKSAtPlxuICAgICAgICAjIFNlZSBhbHNvIEBXTS5QYXJzZXIuZmluZEludGVybGFuZ3VhZ2VMaW5rcyEhIVxuICAgICAgICByZXR1cm4gQFdNLlBhcnNlci5maW5kU3BlY2lhbExpbmtzKHNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0SW50ZXJ3aWtpTGFuZ3VhZ2VzKCkuam9pbihcInxcIikpXG5cbiAgICBmaW5kSW50ZXJuYWxJbnRlcmxhbmd1YWdlTGlua3M6IChzb3VyY2UpIC0+XG4gICAgICAgICMgU2VlIGFsc28gQFdNLlBhcnNlci5maW5kSW50ZXJsYW5ndWFnZUxpbmtzISEhXG4gICAgICAgIHJldHVybiBAV00uUGFyc2VyLmZpbmRTcGVjaWFsTGlua3Moc291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0SW50ZXJuYWxJbnRlcndpa2lMYW5ndWFnZXMoKS5qb2luKFwifFwiKSlcblxuICAgIGdldFRhYmxlT2ZDb250ZW50czogKHRhZykgLT5cbiAgICAgICAgcmV0dXJuIHRhYmxlc09mQ29udGVudHNbdGFnXVxuIiwiIyBXaWtpIE1vbmtleSAtIE1lZGlhV2lraSBib3QgYW5kIGVkaXRvci1hc3Npc3RhbnQgdXNlciBzY3JpcHRcbiMgQ29weXJpZ2h0IChDKSAyMDExIERhcmlvIEdpb3Zhbm5ldHRpIDxkZXZAZGFyaW9naW92YW5uZXR0aS5uZXQ+XG4jXG4jIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFdpa2kgTW9ua2V5LlxuI1xuIyBXaWtpIE1vbmtleSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4jIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4jIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4jIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4jXG4jIFdpa2kgTW9ua2V5IGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4jIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4jIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiMgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbiNcbiMgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiMgYWxvbmcgd2l0aCBXaWtpIE1vbmtleS4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cblxuQ1NTID0gcmVxdWlyZSgnQGt5bmlrb3MvbWlzYy9kaXN0L0NTUycpXG5cblxuY2xhc3MgbW9kdWxlLmV4cG9ydHNcbiAgICBjb25zdHJ1Y3RvcjogKEBXTSkgLT5cbiAgICAgICAgQGNvbmZpZ3VyYXRpb24gPVxuICAgICAgICAgICAgcGx1Z2luX25hbWU6IG51bGxcbiAgICAgICAgICAgIGZ1bmN0aW9uXzogLT5cbiAgICAgICAgICAgIGZpbHRlcnM6IFtdXG4gICAgICAgICAgICBsaXN0OlxuICAgICAgICAgICAgICAgIGN1cnJlbnQ6IG51bGxcbiAgICAgICAgICAgICAgICBwcmV2aW91czogbnVsbFxuICAgICAgICAgICAgdmlzaXRlZDogW11cblxuICAgICAgICAjIGxvY2FsU3RvcmFnZSBjYW4gb25seSBzdG9yZSBzdHJpbmdzXG4gICAgICAgIEBib3RUb2tlbiA9IFwiMFwiXG5cbiAgICBfbWFrZVVJOiAoZnVuY3Rpb25zLCBsaXN0cykgLT5cbiAgICAgICAgZGl2Q29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICAgICAgZGl2Q29udGFpbmVyLmlkID0gJ1dpa2lNb25rZXlCb3QnXG5cbiAgICAgICAgQ1NTLmFkZFN0eWxlRWxlbWVudChcIiNXaWtpTW9ua2V5Qm90LVBsdWdpblNlbGVjdCB7d2lkdGg6MTAwJTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJnaW4tYm90dG9tOjFlbTt9XG4gICAgICAgICAgICAgICAgICAgICNXaWtpTW9ua2V5Qm90LUxpc3RTZWxlY3Qge21hcmdpbi1ib3R0b206MWVtO31cbiAgICAgICAgICAgICAgICAgICAgI1dpa2lNb25rZXlCb3RGaWx0ZXIge2hlaWdodDo2ZW07IG1hcmdpbi1ib3R0b206MWVtO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNpemU6dmVydGljYWw7fVxuICAgICAgICAgICAgICAgICAgICAjV2lraU1vbmtleUJvdFN0YXJ0LCAjV2lraU1vbmtleUJvdFN0b3BcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge21hcmdpbi1yaWdodDowLjMzZW07IG1hcmdpbi1ib3R0b206MWVtO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb250LXdlaWdodDpib2xkO31cbiAgICAgICAgICAgICAgICAgICAgYS5XaWtpTW9ua2V5Qm90U2VsZWN0ZWQge2JhY2tncm91bmQtY29sb3I6I2ZhYTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWRkaW5nOjAuMmVtIDAuNGVtO31cbiAgICAgICAgICAgICAgICAgICAgYS5XaWtpTW9ua2V5Qm90UHJvY2Vzc2luZyB7YmFja2dyb3VuZC1jb2xvcjojZmY4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZGRpbmc6MC4yZW0gMC40ZW07fVxuICAgICAgICAgICAgICAgICAgICBhLldpa2lNb25rZXlCb3RDaGFuZ2VkIHtiYWNrZ3JvdW5kLWNvbG9yOiNhZmE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFkZGluZzowLjJlbSAwLjRlbTt9XG4gICAgICAgICAgICAgICAgICAgIGEuV2lraU1vbmtleUJvdFVuY2hhbmdlZCB7YmFja2dyb3VuZC1jb2xvcjojYWFmO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZGRpbmc6MC4yZW0gMC40ZW07fVxuICAgICAgICAgICAgICAgICAgICBhLldpa2lNb25rZXlCb3RCeXBhc3NlZCB7YmFja2dyb3VuZC1jb2xvcjpvcmFuZ2VyZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFkZGluZzowLjJlbSAwLjRlbTt9XG4gICAgICAgICAgICAgICAgICAgIGEuV2lraU1vbmtleUJvdEZhaWxlZCB7YmFja2dyb3VuZC1jb2xvcjpyZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFkZGluZzowLjJlbSAwLjRlbTt9XCIpXG5cbiAgICAgICAgZmRpdiA9IEBtYWtlRnVuY3Rpb25VSShmdW5jdGlvbnMpXG5cbiAgICAgICAgaWYgZmRpdlxuICAgICAgICAgICAgZGl2Q29udGFpbmVyLmFwcGVuZENoaWxkKGZkaXYpXG4gICAgICAgICAgICBkaXZDb250YWluZXIuYXBwZW5kQ2hpbGQoQG1ha2VDb25mVUkobGlzdHMpKVxuICAgICAgICAgICAgcmV0dXJuIGRpdkNvbnRhaW5lclxuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcblxuICAgIG1ha2VGdW5jdGlvblVJOiAoZnVuY3Rpb25zKSAtPlxuICAgICAgICBzZWxmID0gdGhpc1xuICAgICAgICBmaWVsZHNldCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ZpZWxkc2V0JylcblxuICAgICAgICBsZWdlbmQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsZWdlbmQnKVxuICAgICAgICBsZWdlbmQuaW5uZXJIVE1MID0gJ1BsdWdpbidcblxuICAgICAgICBzZWxlY3RGdW5jdGlvbnMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzZWxlY3QnKVxuICAgICAgICBzZWxlY3RGdW5jdGlvbnMuaWQgPSAnV2lraU1vbmtleUJvdC1QbHVnaW5TZWxlY3QnXG5cbiAgICAgICAgZmZ1bmN0aW9ucyA9IFtdXG5cbiAgICAgICAgZm9yIFBsdWdpbiBpbiBmdW5jdGlvbnNcbiAgICAgICAgICAgIHBsdWdpbiA9IG5ldyBQbHVnaW4oQFdNKVxuICAgICAgICAgICAgcGx1Z2luSW5zdCA9IHBsdWdpbi5jb25mLmJvdF9sYWJlbFxuXG4gICAgICAgICAgICAjIFRoaXMgYWxsb3dzIHRvIGRpc2FibGUgYW4gZW50cnkgYnkgZ2l2aW5nIGl0IGFueSBzZWNvbmRcbiAgICAgICAgICAgICMgcGFyYW1ldGVyIHRoYXQgZXZhbHVhdGVzIHRvIGZhbHNlXG4gICAgICAgICAgICBpZiBub3QgcGx1Z2luSW5zdCBvciBub3QgcGx1Z2luSW5zdC5sZW5ndGhcbiAgICAgICAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgICAgICBmZnVuY3Rpb25zLnB1c2gocGx1Z2luKVxuICAgICAgICAgICAgb3B0aW9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnb3B0aW9uJylcbiAgICAgICAgICAgIG9wdGlvbi5pbm5lckhUTUwgPSBwbHVnaW5JbnN0XG5cbiAgICAgICAgICAgIGlmIHBsdWdpbi5jb25zdHJ1Y3Rvci5uYW1lIGlzIEBXTS5jb25mLmRlZmF1bHRfYm90X3BsdWdpblxuICAgICAgICAgICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IHRydWVcblxuICAgICAgICAgICAgc2VsZWN0RnVuY3Rpb25zLmFwcGVuZENoaWxkKG9wdGlvbilcblxuICAgICAgICBpZiBmZnVuY3Rpb25zLmxlbmd0aFxuICAgICAgICAgICAgc2VsZWN0RnVuY3Rpb25zLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgKCAoZmZ1bmN0aW9ucykgLT5cbiAgICAgICAgICAgICAgICByZXR1cm4gLT5cbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnV2lraU1vbmtleUJvdC1QbHVnaW5TZWxlY3QnKVxuICAgICAgICAgICAgICAgICAgICBpZCA9IHNlbGVjdC5zZWxlY3RlZEluZGV4XG4gICAgICAgICAgICAgICAgICAgIFVJID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ1dpa2lNb25rZXlCb3RGdW5jdGlvbicpXG4gICAgICAgICAgICAgICAgICAgIHBsdWdpbiA9IGZmdW5jdGlvbnNbaWRdXG4gICAgICAgICAgICAgICAgICAgICMgWzFdIE5vdGUgdGhhdCB0aGlzIG11c3QgYWxzbyBiZSBleGVjdXRlZCBpbW1lZGlhdGVseSxcbiAgICAgICAgICAgICAgICAgICAgIyAgIHNlZSBbMl1cbiAgICAgICAgICAgICAgICAgICAgbWFrZVVJID0gcGx1Z2luLm1ha2VCb3RVSVxuICAgICAgICAgICAgICAgICAgICBpZiBtYWtlVUkgaW5zdGFuY2VvZiBGdW5jdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgVUkucmVwbGFjZUNoaWxkKG1ha2VVSSgpLCBVSS5maXJzdENoaWxkKVxuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAjIERvbid0IHJlbW92ZUNoaWxkLCBvdGhlcndpc2UgaWYgYW5vdGhlciBwbHVnaW4gd2l0aFxuICAgICAgICAgICAgICAgICAgICAgICAgIyBpbnRlcmZhY2UgaXMgc2VsZWN0ZWQsIHJlcGxhY2VDaGlsZCB3b24ndCB3b3JrXG4gICAgICAgICAgICAgICAgICAgICAgICBVSS5yZXBsYWNlQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVUkuZmlyc3RDaGlsZClcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jb25maWd1cmF0aW9uLnBsdWdpbl9uYW1lID0gcGx1Z2luLmNvbnN0cnVjdG9yLm5hbWVcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jb25maWd1cmF0aW9uLmZ1bmN0aW9uXyA9ICh0aXRsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsQ29udGludWUsIGNoYWluQXJncykgLT5cbiAgICAgICAgICAgICAgICAgICAgICAgIHBsdWdpbi5tYWluX2JvdCh0aXRsZSwgY2FsbENvbnRpbnVlLCBjaGFpbkFyZ3MpXG4gICAgICAgICAgICApKGZmdW5jdGlvbnMpLCBmYWxzZSlcblxuICAgICAgICAgICAgZGl2RnVuY3Rpb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgICAgICAgICAgZGl2RnVuY3Rpb24uaWQgPSBcIldpa2lNb25rZXlCb3RGdW5jdGlvblwiXG5cbiAgICAgICAgICAgIHBsdWdpbiA9IGZmdW5jdGlvbnNbc2VsZWN0RnVuY3Rpb25zLnNlbGVjdGVkSW5kZXhdXG5cbiAgICAgICAgICAgICMgWzJdIE5vdGUgdGhhdCB0aGlzIGlzIGFsc28gZXhlY3V0ZWQgb25jaGFuZ2UsIHNlZSBbMV1cbiAgICAgICAgICAgIG1ha2VVSSA9IHBsdWdpbi5tYWtlQm90VUlcbiAgICAgICAgICAgIGlmIG1ha2VVSSBpbnN0YW5jZW9mIEZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgZGl2RnVuY3Rpb24uYXBwZW5kQ2hpbGQobWFrZVVJKCkpXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgZGl2RnVuY3Rpb24uYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JykpXG4gICAgICAgICAgICBAY29uZmlndXJhdGlvbi5wbHVnaW5fbmFtZSA9IHBsdWdpbi5jb25zdHJ1Y3Rvci5uYW1lXG4gICAgICAgICAgICBAY29uZmlndXJhdGlvbi5mdW5jdGlvbl8gPSAodGl0bGUsIGNhbGxDb250aW51ZSwgY2hhaW5BcmdzKSAtPlxuICAgICAgICAgICAgICAgIHBsdWdpbi5tYWluX2JvdCh0aXRsZSwgY2FsbENvbnRpbnVlLCBjaGFpbkFyZ3MpXG5cbiAgICAgICAgICAgIGZpZWxkc2V0LmFwcGVuZENoaWxkKGxlZ2VuZClcbiAgICAgICAgICAgIGZpZWxkc2V0LmFwcGVuZENoaWxkKHNlbGVjdEZ1bmN0aW9ucylcbiAgICAgICAgICAgIGZpZWxkc2V0LmFwcGVuZENoaWxkKGRpdkZ1bmN0aW9uKVxuXG4gICAgICAgICAgICByZXR1cm4gZmllbGRzZXRcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG5cbiAgICBtYWtlTGlzdFNlbGVjdG9yOiAobGlzdHMpIC0+XG4gICAgICAgIHNlbGYgPSB0aGlzXG4gICAgICAgIHNlbGVjdExpc3RzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2VsZWN0JylcbiAgICAgICAgc2VsZWN0TGlzdHMuaWQgPSAnV2lraU1vbmtleUJvdC1MaXN0U2VsZWN0J1xuXG4gICAgICAgIGZvciBsaXN0IGluIGxpc3RzXG4gICAgICAgICAgICBpZiBsaXN0WzBdXG4gICAgICAgICAgICAgICAgb3B0aW9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnb3B0aW9uJylcbiAgICAgICAgICAgICAgICBvcHRpb24uaW5uZXJIVE1MID0gbGlzdFsyXVxuICAgICAgICAgICAgICAgIHNlbGVjdExpc3RzLmFwcGVuZENoaWxkKG9wdGlvbilcblxuICAgICAgICAgICAgICAgIGlmIG5vdCBAY29uZmlndXJhdGlvbi5saXN0LmN1cnJlbnRcbiAgICAgICAgICAgICAgICAgICAgIyBbMV0gTm90ZSB0aGF0IHRoaXMgaXMgYWxzbyBleGVjdXRlZCBvbmNoYW5nZSwgc2VlIFsyXVxuICAgICAgICAgICAgICAgICAgICBAY29uZmlndXJhdGlvbi5saXN0LmN1cnJlbnQgPSBsaXN0XG5cbiAgICAgICAgc2VsZWN0TGlzdHMuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCAoIChsc3MpIC0+XG4gICAgICAgICAgICByZXR1cm4gLT5cbiAgICAgICAgICAgICAgICBzZWxlY3QgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdXaWtpTW9ua2V5Qm90LUxpc3RTZWxlY3QnKVxuICAgICAgICAgICAgICAgIGlkID0gc2VsZWN0LnNlbGVjdGVkSW5kZXhcbiAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZ3VyYXRpb24ubGlzdC5wcmV2aW91cyA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29uZmlndXJhdGlvbi5saXN0LmN1cnJlbnRcbiAgICAgICAgICAgICAgICAjIFsyXSBOb3RlIHRoYXQgdGhpcyBtdXN0IGFsc28gYmUgZXhlY3V0ZWQgaW1tZWRpYXRlbHksXG4gICAgICAgICAgICAgICAgIyAgIHNlZSBbMV1cbiAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZ3VyYXRpb24ubGlzdC5jdXJyZW50ID0gbHNzW2lkXVxuICAgICAgICApKGxpc3RzKSwgZmFsc2UpXG5cbiAgICAgICAgcmV0dXJuIHNlbGVjdExpc3RzXG5cbiAgICBtYWtlQ29uZlVJOiAobGlzdHMpIC0+XG4gICAgICAgIHNlbGYgPSB0aGlzXG4gICAgICAgIGJvdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG5cbiAgICAgICAgZmllbGRzZXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdmaWVsZHNldCcpXG5cbiAgICAgICAgbGVnZW5kID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGVnZW5kJylcbiAgICAgICAgbGVnZW5kLmlubmVySFRNTCA9ICdGaWx0ZXInXG5cbiAgICAgICAgbGlzdFNlbGVjdCA9IEBtYWtlTGlzdFNlbGVjdG9yKGxpc3RzKVxuXG4gICAgICAgIGZpbHRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RleHRhcmVhJylcbiAgICAgICAgZmlsdGVyLmlkID0gJ1dpa2lNb25rZXlCb3RGaWx0ZXInXG5cbiAgICAgICAgcHJldmlldyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0JylcbiAgICAgICAgcHJldmlldy5pZCA9ICdXaWtpTW9ua2V5Qm90UHJldmlldydcbiAgICAgICAgcHJldmlldy50eXBlID0gJ2J1dHRvbidcbiAgICAgICAgcHJldmlldy52YWx1ZSA9ICdQcmV2aWV3J1xuXG4gICAgICAgIGR1cGxpY2F0ZXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpXG4gICAgICAgIGR1cGxpY2F0ZXMudHlwZSA9ICdjaGVja2JveCdcbiAgICAgICAgZHVwbGljYXRlcy5pZCA9ICdXaWtpTW9ua2V5Qm90RHVwbGljYXRlcydcblxuICAgICAgICBpbnZlcnNlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKVxuICAgICAgICBpbnZlcnNlLnR5cGUgPSAnY2hlY2tib3gnXG4gICAgICAgIGludmVyc2UuaWQgPSAnV2lraU1vbmtleUJvdEludmVyc2UnXG5cbiAgICAgICAgZWxlbXMgPSBbZmlsdGVyLCBkdXBsaWNhdGVzLCBpbnZlcnNlXVxuXG4gICAgICAgIGZvciBlbGVtIGluIGVsZW1zXG4gICAgICAgICAgICBlbGVtLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgLT5cbiAgICAgICAgICAgICAgICBzZWxmLl9kaXNhYmxlU3RhcnRCb3QoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdGaWx0ZXJzIGhhdmUgY2hhbmdlZCwgcHJldmlldyB0aGUgc2VsZWN0aW9uJylcbiAgICAgICAgICAgICwgZmFsc2UpXG5cbiAgICAgICAgZHVwbGljYXRlc3RhZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKVxuICAgICAgICBkdXBsaWNhdGVzdGFnLmlubmVySFRNTCA9ICdEdXBsaWNhdGVzJ1xuXG4gICAgICAgIGludmVyc2V0YWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJylcbiAgICAgICAgaW52ZXJzZXRhZy5pbm5lckhUTUwgPSAnSW52ZXJzZSdcblxuICAgICAgICBwcmV2aWV3LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBAX3ByZXZpZXdGaWx0ZXIsIGZhbHNlKVxuXG4gICAgICAgIGZpZWxkc2V0LmFwcGVuZENoaWxkKGxlZ2VuZClcbiAgICAgICAgaWYgbGlzdFNlbGVjdC5sZW5ndGggPiAxXG4gICAgICAgICAgICBmaWVsZHNldC5hcHBlbmRDaGlsZChsaXN0U2VsZWN0KVxuICAgICAgICBmaWVsZHNldC5hcHBlbmRDaGlsZChmaWx0ZXIpXG4gICAgICAgIGZpZWxkc2V0LmFwcGVuZENoaWxkKHByZXZpZXcpXG4gICAgICAgIGZpZWxkc2V0LmFwcGVuZENoaWxkKGR1cGxpY2F0ZXMpXG4gICAgICAgIGZpZWxkc2V0LmFwcGVuZENoaWxkKGR1cGxpY2F0ZXN0YWcpXG4gICAgICAgIGZpZWxkc2V0LmFwcGVuZENoaWxkKGludmVyc2UpXG4gICAgICAgIGZpZWxkc2V0LmFwcGVuZENoaWxkKGludmVyc2V0YWcpXG5cbiAgICAgICAgc3RhcnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpXG4gICAgICAgIHN0YXJ0LnR5cGUgPSAnYnV0dG9uJ1xuICAgICAgICBzdGFydC52YWx1ZSA9ICdTdGFydCBib3QnXG4gICAgICAgIHN0YXJ0LmlkID0gJ1dpa2lNb25rZXlCb3RTdGFydCdcblxuICAgICAgICBzdGFydC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgQF9zdGFydEF1dG9tYXRpYywgZmFsc2UpXG5cbiAgICAgICAgc3RhcnQuZGlzYWJsZWQgPSB0cnVlXG5cbiAgICAgICAgc3RhcnRNc2cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJylcbiAgICAgICAgc3RhcnRNc2cuaW5uZXJIVE1MID0gJ1NldCBhbmQgcHJldmlldyB0aGUgZmlsdGVyIGZpcnN0J1xuICAgICAgICBzdGFydE1zZy5pZCA9ICdXaWtpTW9ua2V5Qm90U3RhcnRNc2cnXG5cbiAgICAgICAgZm9yY2VTdGFydCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKVxuICAgICAgICBmb3JjZVN0YXJ0LmlkID0gJ1dpa2lNb25rZXlCb3RGb3JjZVN0YXJ0J1xuXG4gICAgICAgIGZvcmNlU3RhcnRDQiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0JylcbiAgICAgICAgZm9yY2VTdGFydENCLnR5cGUgPSAnY2hlY2tib3gnXG4gICAgICAgIGZvcmNlU3RhcnRDQi5kaXNhYmxlZCA9IHRydWVcblxuICAgICAgICBmb3JjZVN0YXJ0TGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJylcbiAgICAgICAgZm9yY2VTdGFydExhYmVsLmlubmVySFRNTCA9ICdGb3JjZSBzdGFydCwgc3RvcHBpbmcgYW55IG90aGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudGx5IHJ1bm5pbmcgYm90cydcblxuICAgICAgICBmb3JjZVN0YXJ0LnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIlxuICAgICAgICBmb3JjZVN0YXJ0LmFwcGVuZENoaWxkKGZvcmNlU3RhcnRDQilcbiAgICAgICAgZm9yY2VTdGFydC5hcHBlbmRDaGlsZChmb3JjZVN0YXJ0TGFiZWwpXG5cbiAgICAgICAgYm90LmFwcGVuZENoaWxkKGZpZWxkc2V0KVxuICAgICAgICBib3QuYXBwZW5kQ2hpbGQoc3RhcnQpXG4gICAgICAgIGJvdC5hcHBlbmRDaGlsZChzdGFydE1zZylcbiAgICAgICAgYm90LmFwcGVuZENoaWxkKGZvcmNlU3RhcnQpXG5cbiAgICAgICAgcmV0dXJuIGJvdFxuXG4gICAgX2VuYWJsZVN0YXJ0Qm90OiAtPlxuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnV2lraU1vbmtleUJvdFN0YXJ0TXNnJykuaW5uZXJIVE1MID0gJydcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ1dpa2lNb25rZXlCb3RTdGFydCcpLmRpc2FibGVkID0gZmFsc2VcblxuICAgIF9kaXNhYmxlU3RhcnRCb3Q6IChtZXNzYWdlKSAtPlxuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnV2lraU1vbmtleUJvdFN0YXJ0TXNnJykuaW5uZXJIVE1MID0gbWVzc2FnZVxuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnV2lraU1vbmtleUJvdFN0YXJ0JykuZGlzYWJsZWQgPSB0cnVlXG5cbiAgICBfZW5hYmxlU3RvcEJvdDogKHN0b3BJZCkgLT5cbiAgICAgICAgc2VsZiA9IHRoaXNcbiAgICAgICAgc3RvcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0JylcbiAgICAgICAgc3RvcC50eXBlID0gJ2J1dHRvbidcbiAgICAgICAgc3RvcC52YWx1ZSA9ICdTdG9wIGJvdCdcbiAgICAgICAgc3RvcC5pZCA9ICdXaWtpTW9ua2V5Qm90U3RvcCdcblxuICAgICAgICBzdG9wLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoIChpZCkgLT5cbiAgICAgICAgICAgIHJldHVybiAtPlxuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChpZClcbiAgICAgICAgICAgICAgICAjIHJ1biBfZGlzYWJsZVN0b3BCb3QoKSBoZXJlLCBub3QgaW4gX2VuZEF1dG9tYXRpYygpXG4gICAgICAgICAgICAgICAgc2VsZi5fZGlzYWJsZVN0b3BCb3QoKVxuICAgICAgICAgICAgICAgIHNlbGYuX2VuZEF1dG9tYXRpYyh0cnVlKVxuICAgICAgICAgICAgICAgIHNlbGYuV00uTG9nLmxvZ0luZm8oJ0JvdCBzdG9wcGVkIG1hbnVhbGx5JylcbiAgICAgICAgKShzdG9wSWQpLCBmYWxzZSlcblxuICAgICAgICBzdGFydCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdXaWtpTW9ua2V5Qm90U3RhcnQnKVxuICAgICAgICBzdGFydC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShzdG9wLCBzdGFydClcbiAgICAgICAgc3RhcnQuc3R5bGUuZGlzcGxheSA9ICdub25lJ1xuXG4gICAgX2Rpc2FibGVTdG9wQm90OiAtPlxuICAgICAgICBzdG9wID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ1dpa2lNb25rZXlCb3RTdG9wJylcbiAgICAgICAgc3RvcC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0b3ApXG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdXaWtpTW9ua2V5Qm90U3RhcnQnKS5zdHlsZS5kaXNwbGF5ID0gJ2lubGluZSdcblxuICAgIF9kaXNhYmxlQ29udHJvbHM6IC0+XG4gICAgICAgIEBfc2V0RW5hYmxlQ29udHJvbHModHJ1ZSlcblxuICAgIF9yZUVuYWJsZUNvbnRyb2xzOiAtPlxuICAgICAgICBAX3NldEVuYWJsZUNvbnRyb2xzKGZhbHNlKVxuXG4gICAgX3NldEVuYWJsZUNvbnRyb2xzOiAoZmxhZykgLT5cbiAgICAgICAgZnNldHMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnV2lraU1vbmtleUJvdCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnZmllbGRzZXQnKVxuICAgICAgICBmb3IgZnNldCBpbiBmc2V0c1xuICAgICAgICAgICAgIyBIVE1MNS1jb21wbGlhbnRcbiAgICAgICAgICAgIGZzZXQuZGlzYWJsZWQgPSBmbGFnXG5cbiAgICBfZW5hYmxlRm9yY2VTdGFydDogLT5cbiAgICAgICAgZm9yY2UgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnV2lraU1vbmtleUJvdEZvcmNlU3RhcnQnKVxuICAgICAgICBmb3JjZS5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaW5wdXQnKVswXS5kaXNhYmxlZCA9IGZhbHNlXG4gICAgICAgIGZvcmNlLnN0eWxlLmRpc3BsYXkgPSAnaW5saW5lJ1xuXG4gICAgX2Rpc2FibGVGb3JjZVN0YXJ0OiAtPlxuICAgICAgICBmb3JjZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdXaWtpTW9ua2V5Qm90Rm9yY2VTdGFydCcpXG4gICAgICAgIGZvcmNlLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdpbnB1dCcpWzBdLmNoZWNrZWQgPSBmYWxzZVxuICAgICAgICBmb3JjZS5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaW5wdXQnKVswXS5kaXNhYmxlZCA9IHRydWVcbiAgICAgICAgZm9yY2Uuc3R5bGUuZGlzcGxheSA9ICdub25lJ1xuXG4gICAgX2NhbkZvcmNlU3RhcnQ6IC0+XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnV2lraU1vbmtleUJvdEZvcmNlU3RhcnQnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdpbnB1dCcpWzBdLmNoZWNrZWRcblxuICAgIG1ha2VGaWx0ZXJzOiAtPlxuICAgICAgICBAY29uZmlndXJhdGlvbi5maWx0ZXJzID0gW11cbiAgICAgICAgZmlsdGVycyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdXaWtpTW9ua2V5Qm90RmlsdGVyJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnZhbHVlLnNwbGl0KCdcXG4nKVxuXG4gICAgICAgIGZvciBmaWx0ZXIgaW4gZmlsdGVyc1xuICAgICAgICAgICAgIyBmaWx0ZXIgY291bGQgYmUgYW4gZW1wdHkgc3RyaW5nXG4gICAgICAgICAgICBpZiBmaWx0ZXJcbiAgICAgICAgICAgICAgICBmaXJzdFNsYXNoID0gZmlsdGVyLmluZGV4T2YoJy8nKVxuICAgICAgICAgICAgICAgIGxhc3RTbGFzaCA9IGZpbHRlci5sYXN0SW5kZXhPZignLycpXG4gICAgICAgICAgICAgICAgcGF0dGVybiA9IGZpbHRlci5zdWJzdHJpbmcoZmlyc3RTbGFzaCArIDEsIGxhc3RTbGFzaClcbiAgICAgICAgICAgICAgICBtb2RpZmllcnMgPSBmaWx0ZXIuc3Vic3RyaW5nKGxhc3RTbGFzaCArIDEpXG4gICAgICAgICAgICAgICAgbmVnYXRpdmUgPSBmaWx0ZXIuY2hhckF0KDApID09ICchJ1xuXG4gICAgICAgICAgICAgICAgdHJ5XG4gICAgICAgICAgICAgICAgICAgIHJlZ2V4cCA9IG5ldyBSZWdFeHAocGF0dGVybiwgbW9kaWZpZXJzKVxuICAgICAgICAgICAgICAgIGNhdGNoIGV4Y1xuICAgICAgICAgICAgICAgICAgICBAV00uTG9nLmxvZ0Vycm9yKCdJbnZhbGlkIHJlZ2V4cDogJyArIGV4YylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG5cbiAgICAgICAgICAgICAgICBAY29uZmlndXJhdGlvbi5maWx0ZXJzLnB1c2goW3JlZ2V4cCwgbmVnYXRpdmVdKVxuICAgICAgICAgICAgICAgICMgRG8gbm90IHJldHVybiBub3IgYnJlYWssIHNvIHRoYXQgaWYgYW1vbmcgdGhlIGZpbHRlcnNcbiAgICAgICAgICAgICAgICAjICAgdGhlcmUncyBhbiBpbnZhbGlkIHJlZ2V4cCB0aGUgZnVuY3Rpb24gcmV0dXJucyBmYWxzZVxuXG4gICAgICAgIHJldHVybiB0cnVlXG5cbiAgICBjYW5Qcm9jZXNzUGFnZTogKGxpbmspIC0+XG4gICAgICAgICMgRXhjbHVkZSByZWQgbGlua3MgKHRoZXkgY2FuIGJlIGZvdW5kIGluIHNvbWUgc3BlY2lhbCBwYWdlcylcbiAgICAgICAgaWYgbGluay5jbGFzc05hbWUuc3BsaXQoXCIgXCIpLmluZGV4T2YoXCJuZXdcIikgPCAwXG4gICAgICAgICAgICAjIERvbid0IHVzZSBsaW5rLnRpdGxlIGJlY2F1c2UgZm9yIGV4YW1wbGUgaW4gQ2F0ZWdvcnkgcGFnZXMgYWxsXG4gICAgICAgICAgICAjICAgc3VicGFnZXMgd291bGQgaW5jbHVkZSBcIkNhdGVnb3J5OlwiLCB0aHVzIGFsd2F5cyBtYXRjaGluZ1xuICAgICAgICAgICAgIyAgIGZpbHRlcnMgbGlrZSBcIi9hL1wiLCBcIi90L1wiIGV0Yy5cbiAgICAgICAgICAgIHRpdGxlID0gbGluay5pbm5lckhUTUxcbiAgICAgICAgICAgIGR1cGxpY2F0ZXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnV2lraU1vbmtleUJvdER1cGxpY2F0ZXMnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY2hlY2tlZFxuXG4gICAgICAgICAgICBpZiBkdXBsaWNhdGVzIG9yIEBjb25maWd1cmF0aW9uLnZpc2l0ZWQuaW5kZXhPZihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZSkgPCAwXG4gICAgICAgICAgICAgICAgQGNvbmZpZ3VyYXRpb24udmlzaXRlZC5wdXNoKHRpdGxlKVxuICAgICAgICAgICAgICAgIGZpbHRlcnMgPSBAY29uZmlndXJhdGlvbi5maWx0ZXJzXG4gICAgICAgICAgICAgICAgaW52ZXJzZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdXaWtpTW9ua2V5Qm90SW52ZXJzZScpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jaGVja2VkXG5cbiAgICAgICAgICAgICAgICBpZiBmaWx0ZXJzLmxlbmd0aCA+IDBcbiAgICAgICAgICAgICAgICAgICAgZm9yIGZpbHRlciBpbiBmaWx0ZXJzXG4gICAgICAgICAgICAgICAgICAgICAgICByZWdleHAgPSBmaWx0ZXJbMF1cbiAgICAgICAgICAgICAgICAgICAgICAgIG5lZ2F0aXZlID0gZmlsdGVyWzFdXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXN0ID0gcmVnZXhwLnRlc3QodGl0bGUpXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIHRlc3QgIT0gbmVnYXRpdmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWYgaW52ZXJzZSB0aGVuIGZhbHNlIGVsc2UgdHJ1ZVxuXG4gICAgICAgICAgICAgICAgICAgICMgTm8gKHRlc3QgIT0gbmVnYXRpdmUpIGNvbmRpdGlvbiBoYXMgYmVlbiBtZXQgaW4gdGhlIGxvb3BcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlmIGludmVyc2UgdGhlbiB0cnVlIGVsc2UgZmFsc2VcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpZiBpbnZlcnNlIHRoZW4gZmFsc2UgZWxzZSB0cnVlXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuXG4gICAgY2hhbmdlV2lraU1vbmtleUxpbmtDbGFzc05hbWU6IChjbGFzc05hbWUsIG5ld0NsYXNzKSAtPlxuICAgICAgICBjbGFzc2VzID0gY2xhc3NOYW1lLnNwbGl0KFwiIFwiKVxuICAgICAgICBuZXdDbGFzc2VzID0gW11cblxuICAgICAgICBmb3IgY2xzIGluIGNsYXNzZXNcbiAgICAgICAgICAgIGlmIGNscy5pbmRleE9mKFwiV2lraU1vbmtleVwiKSA8IDBcbiAgICAgICAgICAgICAgICBuZXdDbGFzc2VzLnB1c2goY2xzKVxuXG4gICAgICAgICMgRG9uJ3QgcHVzaCBpbiBhbiBlbHNlIGJsb2NrIGluc2lkZSB0aGUgbG9vcCwgc28gdGhhdCBpZiB0aGVyZSB3YXNcbiAgICAgICAgIyBubyBXaWtpTW9ua2V5IGNsYXNzIHNldCwgaXQgd2lsbCBiZSBhZGRlZFxuICAgICAgICBuZXdDbGFzc2VzLnB1c2gobmV3Q2xhc3MpXG5cbiAgICAgICAgcmV0dXJuIG5ld0NsYXNzZXMuam9pbihcIiBcIilcblxuICAgIHJlc3RvcmVPcmlnaW5hbExpbmtDbGFzc05hbWU6IChjbGFzc05hbWUpIC0+XG4gICAgICAgIGNsYXNzZXMgPSBjbGFzc05hbWUuc3BsaXQoXCIgXCIpXG4gICAgICAgIG9yaWdDbGFzc2VzID0gW11cblxuICAgICAgICBmb3IgY2xzIGluIGNsYXNzZXNcbiAgICAgICAgICAgIGlmIGNscy5pbmRleE9mKFwiV2lraU1vbmtleVwiKSA8IDBcbiAgICAgICAgICAgICAgICBvcmlnQ2xhc3Nlcy5wdXNoKGNscylcblxuICAgICAgICByZXR1cm4gb3JpZ0NsYXNzZXMuam9pbihcIiBcIilcblxuICAgIF9wcmV2aWV3RmlsdGVyOiA9PlxuICAgICAgICBAV00uTG9nLmxvZ0luZm8oJ1VwZGF0aW5nIGZpbHRlciBwcmV2aWV3LCBwbGVhc2Ugd2FpdCAuLi4nKVxuICAgICAgICBAX2Rpc2FibGVTdGFydEJvdCgnVXBkYXRpbmcgZmlsdGVyIHByZXZpZXcgLi4uJylcblxuICAgICAgICBpZiBAY29uZmlndXJhdGlvbi5saXN0LnByZXZpb3VzXG4gICAgICAgICAgICBpZiBAY29uZmlndXJhdGlvbi5saXN0LmN1cnJlbnRbMF0ubm9kZU5hbWUgPT0gJ1RCT0RZJ1xuICAgICAgICAgICAgICAgIGl0ZW1zID0gQGNvbmZpZ3VyYXRpb24ubGlzdC5wcmV2aW91c1swXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmdldEVsZW1lbnRzQnlUYWdOYW1lKCd0ZCcpXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgaXRlbXMgPSBAY29uZmlndXJhdGlvbi5saXN0LnByZXZpb3VzWzBdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2xpJylcbiAgICAgICAgICAgIGxpbmtJZCA9IEBjb25maWd1cmF0aW9uLmxpc3QucHJldmlvdXNbMV1cblxuICAgICAgICAgICAgZm9yIGl0ZW0gaW4gaXRlbXNcbiAgICAgICAgICAgICAgICBsaW5rID0gaXRlbS5nZXRFbGVtZW50c0J5VGFnTmFtZSgnYScpW2xpbmtJZF1cblxuICAgICAgICAgICAgICAgICMgVGhlIGxpc3QgaXRlbSBjb3VsZCByZWZlciB0byBhbiBpbnZhbGlkIHRpdGxlLCByZXByZXNlbnRlZFxuICAgICAgICAgICAgICAgICMgYnkgZS5nLiA8c3BhbiBjbGFzcz1cIm13LWludmFsaWR0aXRsZVwiPkludmFsaWQgdGl0bGUgd2l0aFxuICAgICAgICAgICAgICAgICMgbmFtZXNwYWNlIFwiQ2F0ZWdvcnlcIiBhbmQgdGV4dCBcIlwiPC9zcGFuPlxuICAgICAgICAgICAgICAgIGlmIGxpbmtcbiAgICAgICAgICAgICAgICAgICAgbGluay5jbGFzc05hbWUgPSBAcmVzdG9yZU9yaWdpbmFsTGlua0NsYXNzTmFtZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmsuY2xhc3NOYW1lKVxuXG4gICAgICAgIEBjb25maWd1cmF0aW9uLnZpc2l0ZWQgPSBbXVxuXG4gICAgICAgIGxpbmtJZCA9IEBjb25maWd1cmF0aW9uLmxpc3QuY3VycmVudFsxXVxuICAgICAgICBlbmFibGUgPSBmYWxzZVxuICAgICAgICBOID0gMFxuXG4gICAgICAgIGlmIEBtYWtlRmlsdGVycygpXG4gICAgICAgICAgICBpZiBAY29uZmlndXJhdGlvbi5saXN0LmN1cnJlbnRbMF0ubm9kZU5hbWUgPT0gJ1RCT0RZJ1xuICAgICAgICAgICAgICAgIGl0ZW1zID1cbiAgICAgICAgICAgICAgICAgICAgQGNvbmZpZ3VyYXRpb24ubGlzdC5jdXJyZW50WzBdLmdldEVsZW1lbnRzQnlUYWdOYW1lKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3RkJylcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBpdGVtcyA9XG4gICAgICAgICAgICAgICAgICAgIEBjb25maWd1cmF0aW9uLmxpc3QuY3VycmVudFswXS5nZXRFbGVtZW50c0J5VGFnTmFtZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdsaScpXG5cbiAgICAgICAgICAgIGZvciBpdGVtIGluIGl0ZW1zXG4gICAgICAgICAgICAgICAgbGluayA9IGl0ZW0uZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2EnKVtsaW5rSWRdXG5cbiAgICAgICAgICAgICAgICAjIEFsc28gdGVzdCAnbGluaycgaXRzZWxmLCBiZWNhdXNlIHRoZSBsaXN0IGl0ZW0gY291bGQgcmVmZXJcbiAgICAgICAgICAgICAgICAjIHRvIGFuIGludmFsaWQgdGl0bGUsIHJlcHJlc2VudGVkIGJ5IGUuZy5cbiAgICAgICAgICAgICAgICAjIDxzcGFuIGNsYXNzPVwibXctaW52YWxpZHRpdGxlXCI+SW52YWxpZCB0aXRsZSB3aXRoIG5hbWVzcGFjZVxuICAgICAgICAgICAgICAgICMgXCJDYXRlZ29yeVwiIGFuZCB0ZXh0IFwiXCI8L3NwYW4+XG4gICAgICAgICAgICAgICAgaWYgbGlua1xuICAgICAgICAgICAgICAgICAgICBpZiBAY2FuUHJvY2Vzc1BhZ2UobGluaylcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmsuY2xhc3NOYW1lID0gQGNoYW5nZVdpa2lNb25rZXlMaW5rQ2xhc3NOYW1lKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluay5jbGFzc05hbWUsICdXaWtpTW9ua2V5Qm90U2VsZWN0ZWQnKVxuICAgICAgICAgICAgICAgICAgICAgICAgZW5hYmxlID0gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgTisrXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmsuY2xhc3NOYW1lID0gQHJlc3RvcmVPcmlnaW5hbExpbmtDbGFzc05hbWUoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rLmNsYXNzTmFtZSlcblxuICAgICAgICBAV00uTG9nLmxvZ0luZm8oJ1ByZXZpZXcgdXBkYXRlZCAoJyArIE4gKyAnIHBhZ2VzIHNlbGVjdGVkKScpXG5cbiAgICAgICAgaWYgZW5hYmxlXG4gICAgICAgICAgICBAX2VuYWJsZVN0YXJ0Qm90KClcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgQF9kaXNhYmxlU3RhcnRCb3QoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ05vIHBhZ2VzIHNlbGVjdGVkLCByZXNldCBhbmQgcHJldmlldyB0aGUgZmlsdGVyJylcblxuICAgIF9zZXRCb3RUb2tlbjogLT5cbiAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKClcbiAgICAgICAgdG9rZW4gPSBkYXRlLmdldFRpbWUoKSArIFwiXCJcbiAgICAgICAgQGJvdFRva2VuID0gdG9rZW5cbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ1dpa2lNb25rZXlCb3RUb2tlbicsIHRva2VuKVxuXG4gICAgX3Jlc2V0Qm90VG9rZW46IChyZXNldCkgLT5cbiAgICAgICAgQGJvdFRva2VuID0gXCIwXCJcbiAgICAgICAgaWYgcmVzZXRcbiAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdXaWtpTW9ua2V5Qm90VG9rZW4nLCBcIjBcIilcblxuICAgIF9nZXRCb3RUb2tlbjogLT5cbiAgICAgICAgcmV0dXJuIEBib3RUb2tlblxuXG4gICAgX2NoZWNrT3RoZXJCb3RzUnVubmluZzogLT5cbiAgICAgICAgdmFsdWUgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnV2lraU1vbmtleUJvdFRva2VuJylcblxuICAgICAgICAjIHZhbHVlIG1heSBiZSBudWxsIGlmIGl0J3MgbmV2ZXIgYmVlbiBzdG9yZWQgaW4gbG9jYWxTdG9yYWdlXG4gICAgICAgIHJldHVybiB2YWx1ZSBhbmQgdmFsdWUgIT0gXCIwXCIgYW5kIHZhbHVlICE9IEBfZ2V0Qm90VG9rZW4oKVxuXG4gICAgX3N0YXJ0QXV0b21hdGljOiA9PlxuICAgICAgICBpZiBAX2NoZWNrT3RoZXJCb3RzUnVubmluZygpIGFuZCBub3QgQF9jYW5Gb3JjZVN0YXJ0KClcbiAgICAgICAgICAgIEBXTS5Mb2cubG9nRXJyb3IoXCJJdCdzIG5vdCBwb3NzaWJsZSB0byBzdGFydCB0aGUgYm90ICh3aXRob3V0XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JjaW5nIGl0KSBmb3Igb25lIG9mIHRoZSBmb2xsb3dpbmcgcmVhc29uczo8YnI+XG4gICAgICAgICAgICAgICAgICAgICAgICAqIGFub3RoZXIgYm90IGluc3RhbmNlIGlzIGN1cnJlbnRseSBydW5uaW5nPGJyPlxuICAgICAgICAgICAgICAgICAgICAgICAgKiBhIHByZXZpb3VzbHkgcnVubmluZyBib3QgaGFzIHN0b3BwZWQgZHVlIHRvIGFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2UgcHJvY2Vzc2luZyBlcnJvcjxicj5cbiAgICAgICAgICAgICAgICAgICAgICAgICogYSBwcmV2aW91c2x5IHJ1bm5pbmcgYm90IGhhcyBzdG9wcGVkIGR1ZSB0byBhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSmF2YXNjcmlwdCBlcnJvcjxicj5cbiAgICAgICAgICAgICAgICAgICAgICAgICogYSBwcmV2aW91c2x5IHJ1bm5pbmcgYm90IGhhcyBiZWVuIGludGVycnVwdGVkIGJ5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYSBicm93c2VyIHBhZ2UgcmVmcmVzaFwiKVxuICAgICAgICAgICAgQF9lbmFibGVGb3JjZVN0YXJ0KClcbiAgICAgICAgZWxzZSBpZiBAbWFrZUZpbHRlcnMoKVxuICAgICAgICAgICAgaWYgQGNvbmZpZ3VyYXRpb24ubGlzdC5jdXJyZW50WzBdLm5vZGVOYW1lID09ICdUQk9EWSdcbiAgICAgICAgICAgICAgICBpdGVtc0RPTSA9IEBjb25maWd1cmF0aW9uLmxpc3QuY3VycmVudFswXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmdldEVsZW1lbnRzQnlUYWdOYW1lKCd0ZCcpXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgaXRlbXNET00gPSBAY29uZmlndXJhdGlvbi5saXN0LmN1cnJlbnRbMF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnbGknKVxuXG4gICAgICAgICAgICAjIFBhc3NpbmcgdGhlIGxpdmUgY29sbGVjdGlvbiB3aXRoIHRoZSBjYWxsYmFjayBmdW5jdGlvbiB3YXNcbiAgICAgICAgICAgICMgICBjYXVzaW5nIGl0IHRvIGJlIGxvc3QgaW4gYW4gYXBwYXJlbnRseSByYW5kb20gbWFubmVyXG4gICAgICAgICAgICBpdGVtcyA9IFtdXG5cbiAgICAgICAgICAgIGZvciBpdGVtIGluIGl0ZW1zRE9NXG4gICAgICAgICAgICAgICAgaXRlbXMucHVzaChpdGVtKVxuXG4gICAgICAgICAgICBsaW5rSWQgPSBAY29uZmlndXJhdGlvbi5saXN0LmN1cnJlbnRbMV1cblxuICAgICAgICAgICAgQF9kaXNhYmxlRm9yY2VTdGFydCgpXG4gICAgICAgICAgICBAX3NldEJvdFRva2VuKClcbiAgICAgICAgICAgIEBXTS5Mb2cubG9nSW5mbygnU3RhcnRpbmcgYm90IC4uLicpXG4gICAgICAgICAgICBAV00uTG9nLmxvZ0hpZGRlbihcIlBsdWdpbjogXCIgKyBAY29uZmlndXJhdGlvbi5wbHVnaW5fbmFtZSlcbiAgICAgICAgICAgIEBXTS5Mb2cubG9nSGlkZGVuKFwiRmlsdGVyOiBcIiArIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1dpa2lNb25rZXlCb3RGaWx0ZXInKS52YWx1ZSlcbiAgICAgICAgICAgIEBfZGlzYWJsZVN0YXJ0Qm90KCdCb3QgaXMgcnVubmluZyAuLi4nKVxuICAgICAgICAgICAgQF9kaXNhYmxlQ29udHJvbHMoKVxuICAgICAgICAgICAgQGNvbmZpZ3VyYXRpb24udmlzaXRlZCA9IFtdXG5cbiAgICAgICAgICAgIEBXTS5NVy5pc1VzZXJCb3QoQF9zdGFydEF1dG9tYXRpY0NvbnRpbnVlLCBbaXRlbXMsIGxpbmtJZF0pXG5cbiAgICBfc3RhcnRBdXRvbWF0aWNDb250aW51ZTogKGJvdFRlc3QsIGFyZ3MpID0+XG4gICAgICAgIGl0ZW1zID0gYXJnc1swXVxuICAgICAgICBsaW5rSWQgPSBhcmdzWzFdXG5cbiAgICAgICAgQGNvbmZpZ3VyYXRpb24uaW50ZXJ2YWwgPSBpZiBib3RUZXN0IHRoZW4gMzAwMCBlbHNlIDMwMDAwXG4gICAgICAgIEBfcHJvY2Vzc0l0ZW0oMCwgaXRlbXMsIDAsIGxpbmtJZCwgbnVsbClcblxuICAgIG1ha2VDYWxsQ29udGludWU6IChsaXMsIGlkLCBsaW5rSWQsIGxuLCBhcnRpY2xlKSAtPlxuICAgICAgICBzZWxmID0gdGhpc1xuICAgICAgICByZXR1cm4gKHN0YXR1cywgcmVzQXJncykgLT5cbiAgICAgICAgICAgIHN3aXRjaCBzdGF0dXNcbiAgICAgICAgICAgICAgICAjIFRoZSBhcnRpY2xlIGhhc24ndCBiZWVuIHNhdmVkXG4gICAgICAgICAgICAgICAgd2hlbiAwXG4gICAgICAgICAgICAgICAgICAgIGxuLmNsYXNzTmFtZSA9IHNlbGYuY2hhbmdlV2lraU1vbmtleUxpbmtDbGFzc05hbWUobG4uY2xhc3NOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdXaWtpTW9ua2V5Qm90VW5jaGFuZ2VkJylcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5XTS5Mb2cubG9nSW5mbyhzZWxmLldNLkxvZy5saW5rVG9XaWtpUGFnZShhcnRpY2xlLCBhcnRpY2xlKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgcHJvY2Vzc2VkICh1bmNoYW5nZWQpXCIpXG4gICAgICAgICAgICAgICAgICAgIGlkKytcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fcHJvY2Vzc0l0ZW0oc3RhdHVzLCBsaXMsIGlkLCBsaW5rSWQsIHJlc0FyZ3MpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgIyBUaGUgYXJ0aWNsZSBoYXMgYmVlbiBzYXZlZFxuICAgICAgICAgICAgICAgIHdoZW4gMVxuICAgICAgICAgICAgICAgICAgICBsbi5jbGFzc05hbWUgPSBzZWxmLmNoYW5nZVdpa2lNb25rZXlMaW5rQ2xhc3NOYW1lKGxuLmNsYXNzTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnV2lraU1vbmtleUJvdENoYW5nZWQnKVxuICAgICAgICAgICAgICAgICAgICBzZWxmLldNLkxvZy5sb2dJbmZvKHNlbGYuV00uTG9nLmxpbmtUb1dpa2lQYWdlKGFydGljbGUsIGFydGljbGUpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIiBwcm9jZXNzZWQgKGNoYW5nZWQpXCIpXG4gICAgICAgICAgICAgICAgICAgIGlkKytcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fcHJvY2Vzc0l0ZW0oc3RhdHVzLCBsaXMsIGlkLCBsaW5rSWQsIHJlc0FyZ3MpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgIyBUaGUgcGx1Z2luIGhhcyBlbmNvdW50ZXJlZCBhIHByb3RlY3RlZHBhZ2UgZXJyb3JcbiAgICAgICAgICAgICAgICB3aGVuICdwcm90ZWN0ZWRwYWdlJ1xuICAgICAgICAgICAgICAgICAgICBsbi5jbGFzc05hbWUgPSBzZWxmLmNoYW5nZVdpa2lNb25rZXlMaW5rQ2xhc3NOYW1lKGxuLmNsYXNzTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnV2lraU1vbmtleUJvdEJ5cGFzc2VkJylcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5XTS5Mb2cubG9nV2FybmluZyhcIlRoaXMgdXNlciBkb2Vzbid0IGhhdmUgdGhlIHJpZ2h0cyB0byBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImVkaXQgXCIgKyBzZWxmLldNLkxvZy5saW5rVG9XaWtpUGFnZShhcnRpY2xlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJ0aWNsZSkgKyBcIiwgYnlwYXNzaW5nIGl0IC4uLlwiKVxuICAgICAgICAgICAgICAgICAgICBpZCsrXG4gICAgICAgICAgICAgICAgICAgICMgQ2hhbmdlIHN0YXR1cyB0byAwIChwYWdlIG5vdCBjaGFuZ2VkKVxuICAgICAgICAgICAgICAgICAgICBzZWxmLl9wcm9jZXNzSXRlbSgwLCBsaXMsIGlkLCBsaW5rSWQsIHJlc0FyZ3MpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgIyBUaGUgcGx1Z2luIGhhcyBlbmNvdW50ZXJlZCBhIGNyaXRpY2FsIGVycm9yXG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBsbi5jbGFzc05hbWUgPSBzZWxmLmNoYW5nZVdpa2lNb25rZXlMaW5rQ2xhc3NOYW1lKGxuLmNsYXNzTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1dpa2lNb25rZXlCb3RGYWlsZWQnKVxuICAgICAgICAgICAgICAgICAgICBzZWxmLldNLkxvZy5sb2dFcnJvcihcIkVycm9yIHByb2Nlc3NpbmcgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5XTS5Mb2cubGlua1RvV2lraVBhZ2UoYXJ0aWNsZSwgYXJ0aWNsZSkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsIHN0b3BwaW5nIHRoZSBib3RcIilcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fZW5kQXV0b21hdGljKHRydWUpXG5cbiAgICBfcHJvY2Vzc0l0ZW06IChzdGF0dXMsIGl0ZW1zLCBpbmRleCwgbGlua0lkLCBjaGFpbkFyZ3MpIC0+XG4gICAgICAgIHNlbGYgPSB0aGlzXG4gICAgICAgIGlmIGl0ZW1zW2luZGV4XVxuICAgICAgICAgICAgbGluayA9IGl0ZW1zW2luZGV4XS5nZXRFbGVtZW50c0J5VGFnTmFtZSgnYScpW2xpbmtJZF1cblxuICAgICAgICAgICAgIyBBbHNvIHRlc3QgJ2xpbmsnIGl0c2VsZiwgYmVjYXVzZSB0aGUgbGlzdCBpdGVtIGNvdWxkIHJlZmVyIHRvIGFuXG4gICAgICAgICAgICAjIGludmFsaWQgdGl0bGUsIHJlcHJlc2VudGVkIGJ5IGUuZy5cbiAgICAgICAgICAgICMgPHNwYW4gY2xhc3M9XCJtdy1pbnZhbGlkdGl0bGVcIj5JbnZhbGlkIHRpdGxlIHdpdGggbmFtZXNwYWNlXG4gICAgICAgICAgICAjIFwiQ2F0ZWdvcnlcIiBhbmQgdGV4dCBcIlwiPC9zcGFuPlxuICAgICAgICAgICAgaWYgbGluayBhbmQgQGNhblByb2Nlc3NQYWdlKGxpbmspXG4gICAgICAgICAgICAgICAgdGl0bGUgPSBsaW5rLnRpdGxlXG5cbiAgICAgICAgICAgICAgICBpZiBzdGF0dXMgPT0gMFxuICAgICAgICAgICAgICAgICAgICBpbnRlcnZhbCA9IDEwMDBcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGludGVydmFsID0gQGNvbmZpZ3VyYXRpb24uaW50ZXJ2YWxcblxuICAgICAgICAgICAgICAgIEBXTS5Mb2cubG9nSW5mbygnV2FpdGluZyAnICsgKGludGVydmFsIC8gMTAwMCkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyBzZWNvbmRzIC4uLicpXG5cbiAgICAgICAgICAgICAgICBzdG9wSWQgPSBzZXRUaW1lb3V0KCggKGxpcywgaWQsIGxuLCBhcnRpY2xlLCBjaGFpbkFyZ3MpIC0+XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtPlxuICAgICAgICAgICAgICAgICAgICAgICAgIyBTdG9wIG11c3QgYmUgZGlzYWJsZWQgYmVmb3JlIGFueSBjaGVjayBpcyBwZXJmb3JtZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX2Rpc2FibGVTdG9wQm90KClcblxuICAgICAgICAgICAgICAgICAgICAgICAgIyBDaGVjayBoZXJlIGlmIG90aGVyIGJvdHMgaGF2ZSBiZWVuIHN0YXJ0ZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAjIF9ub3RfIGJlZm9yZSBzZXRUaW1lb3V0IVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgbm90IHNlbGYuX2NoZWNrT3RoZXJCb3RzUnVubmluZygpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG4uY2xhc3NOYW1lID0gc2VsZi5jaGFuZ2VXaWtpTW9ua2V5TGlua0NsYXNzTmFtZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxuLmNsYXNzTmFtZSwgJ1dpa2lNb25rZXlCb3RQcm9jZXNzaW5nJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLldNLkxvZy5sb2dJbmZvKFwiUHJvY2Vzc2luZyBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLldNLkxvZy5saW5rVG9XaWtpUGFnZShhcnRpY2xlLCBhcnRpY2xlKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIiAuLi5cIilcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29uZmlndXJhdGlvbi5mdW5jdGlvbl8oYXJ0aWNsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5tYWtlQ2FsbENvbnRpbnVlKGxpcywgaWQsIGxpbmtJZCwgbG4sIGFydGljbGUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFpbkFyZ3MpXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5XTS5Mb2cubG9nRXJyb3IoJ0Fub3RoZXIgYm90IGhhcyBiZWVuICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2ZvcmNlLXN0YXJ0ZWQsIHN0b3BwaW5nIC4uLicpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fZW5kQXV0b21hdGljKGZhbHNlKVxuICAgICAgICAgICAgICAgICkoaXRlbXMsIGluZGV4LCBsaW5rLCB0aXRsZSwgY2hhaW5BcmdzKSwgaW50ZXJ2YWwpXG5cbiAgICAgICAgICAgICAgICBAX2VuYWJsZVN0b3BCb3Qoc3RvcElkKVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGluZGV4KytcbiAgICAgICAgICAgICAgICBAX3Byb2Nlc3NJdGVtKHN0YXR1cywgaXRlbXMsIGluZGV4LCBsaW5rSWQsIGNoYWluQXJncylcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgQF9lbmRBdXRvbWF0aWModHJ1ZSlcblxuICAgIF9lbmRBdXRvbWF0aWM6IChyZXNldCkgLT5cbiAgICAgICAgQF9yZXNldEJvdFRva2VuKHJlc2V0KVxuICAgICAgICBAV00uTG9nLmxvZ0luZm8oJ0JvdCBvcGVyYXRpb25zIGNvbXBsZXRlZCAoY2hlY2sgdGhlIGxvZyBmb3IgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICd3YXJuaW5ncyBvciBlcnJvcnMpJylcbiAgICAgICAgQF9kaXNhYmxlU3RhcnRCb3QoJ0JvdCBvcGVyYXRpb25zIGNvbXBsZXRlZCwgcmVzZXQgYW5kIHByZXZpZXcgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3RoZSBmaWx0ZXInKVxuICAgICAgICBAX3JlRW5hYmxlQ29udHJvbHMoKVxuIiwiIyBXaWtpIE1vbmtleSAtIE1lZGlhV2lraSBib3QgYW5kIGVkaXRvci1hc3Npc3RhbnQgdXNlciBzY3JpcHRcbiMgQ29weXJpZ2h0IChDKSAyMDExIERhcmlvIEdpb3Zhbm5ldHRpIDxkZXZAZGFyaW9naW92YW5uZXR0aS5uZXQ+XG4jXG4jIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFdpa2kgTW9ua2V5LlxuI1xuIyBXaWtpIE1vbmtleSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4jIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4jIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4jIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4jXG4jIFdpa2kgTW9ua2V5IGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4jIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4jIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiMgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbiNcbiMgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiMgYWxvbmcgd2l0aCBXaWtpIE1vbmtleS4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cblxuQXN5bmMgPSByZXF1aXJlKCdAa3luaWtvcy9taXNjL2Rpc3QvQXN5bmMnKVxuT2JqID0gcmVxdWlyZSgnQGt5bmlrb3MvbWlzYy9kaXN0L09iaicpXG5cblxuY2xhc3MgbW9kdWxlLmV4cG9ydHNcbiAgICBjb25zdHJ1Y3RvcjogKEBXTSkgLT5cblxuICAgIHJlY3Vyc2VUcmVlOiAocGFyYW1zKSAtPlxuICAgICAgICBwYXJhbXMuY2FsbENoaWxkcmVuID0gQFdNLkNhdC5fcmVjdXJzZVRyZWVDYWxsQ2hpbGRyZW5cbiAgICAgICAgQXN5bmMucmVjdXJzZVRyZWVBc3luYyhwYXJhbXMpXG5cbiAgICByZWN1cnNlVHJlZUNvbnRpbnVlOiAocGFyYW1zKSAtPlxuICAgICAgICBBc3luYy5yZWN1cnNlVHJlZUFzeW5jKHBhcmFtcylcblxuICAgIF9yZWN1cnNlVHJlZUNhbGxDaGlsZHJlbjogKHBhcmFtcykgLT5cbiAgICAgICAgQFdNLkNhdC5nZXRTdWJDYXRlZ29yaWVzKHBhcmFtcy5ub2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEBXTS5DYXQuX3JlY3Vyc2VUcmVlQ2FsbENoaWxkcmVuQ29udGludWUsIHBhcmFtcylcblxuICAgIF9yZWN1cnNlVHJlZUNhbGxDaGlsZHJlbkNvbnRpbnVlOiAoc3ViQ2F0cywgcGFyYW1zKSAtPlxuICAgICAgICBmb3Igc3ViQ2F0IGluIHN1YkNhdHNcbiAgICAgICAgICAgIHBhcmFtcy5jaGlsZHJlbi5wdXNoKHN1YkNhdC50aXRsZSlcbiAgICAgICAgQXN5bmMucmVjdXJzZVRyZWVBc3luYyhwYXJhbXMpXG5cbiAgICBnZXRTdWJDYXRlZ29yaWVzOiAocGFyZW50LCBjYWxsLCBjYWxsQXJncykgLT5cbiAgICAgICAgQFdNLkNhdC5fZ2V0TWVtYmVycyhwYXJlbnQsIFwic3ViY2F0XCIsIGNhbGwsIGNhbGxBcmdzKVxuXG4gICAgZ2V0QWxsTWVtYmVyczogKHBhcmVudCwgY2FsbCwgY2FsbEFyZ3MpIC0+XG4gICAgICAgIEBXTS5DYXQuX2dldE1lbWJlcnMocGFyZW50LCBudWxsLCBjYWxsLCBjYWxsQXJncylcblxuICAgIF9nZXRNZW1iZXJzOiAobmFtZSwgY210eXBlLCBjYWxsLCBjYWxsQXJncykgLT5cbiAgICAgICAgcXVlcnkgPVxuICAgICAgICAgICAgYWN0aW9uOiBcInF1ZXJ5XCJcbiAgICAgICAgICAgIGxpc3Q6IFwiY2F0ZWdvcnltZW1iZXJzXCJcbiAgICAgICAgICAgIGNtdGl0bGU6IG5hbWVcbiAgICAgICAgICAgIGNtbGltaXQ6IDUwMFxuXG4gICAgICAgIGlmIGNtdHlwZVxuICAgICAgICAgICAgcXVlcnkuY210eXBlID0gY210eXBlXG5cbiAgICAgICAgQF9nZXRNZW1iZXJzQ29udGludWUocXVlcnksIGNhbGwsIGNhbGxBcmdzLCBbXSlcblxuICAgIF9nZXRNZW1iZXJzQ29udGludWU6IChxdWVyeSwgY2FsbCwgY2FsbEFyZ3MsIG1lbWJlcnMpIC0+XG4gICAgICAgIEBXTS5NVy5jYWxsQVBJR2V0KHF1ZXJ5LCAocmVzLCBhcmdzKSAtPlxuICAgICAgICAgICAgbWVtYmVycyA9IG1lbWJlcnMuY29uY2F0KHJlcy5xdWVyeS5jYXRlZ29yeW1lbWJlcnMpXG4gICAgICAgICAgICBpZiByZXNbXCJxdWVyeS1jb250aW51ZVwiXVxuICAgICAgICAgICAgICAgIHF1ZXJ5LmNtY29udGludWUgPSByZXNbXCJxdWVyeS1jb250aW51ZVwiXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNhdGVnb3J5bWVtYmVycy5jbWNvbnRpbnVlXG4gICAgICAgICAgICAgICAgQF9nZXRNZW1iZXJzQ29udGludWUocXVlcnksIGNhbGwsIGFyZ3MsIG1lbWJlcnMpXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgY2FsbChtZW1iZXJzLCBhcmdzKVxuICAgICAgICAsXG4gICAgICAgIGNhbGxBcmdzLCBudWxsKVxuXG4gICAgZ2V0UGFyZW50c0FuZEluZm86IChuYW1lLCBjYWxsLCBjYWxsQXJncykgLT5cbiAgICAgICAgcXVlcnkgPVxuICAgICAgICAgICAgYWN0aW9uOiBcInF1ZXJ5XCJcbiAgICAgICAgICAgIHByb3A6IFwiY2F0ZWdvcmllc3xjYXRlZ29yeWluZm9cIlxuICAgICAgICAgICAgdGl0bGVzOiBuYW1lXG4gICAgICAgICAgICBjbHByb3A6IFwiaGlkZGVuXCJcbiAgICAgICAgICAgIGNsbGltaXQ6IDUwMFxuXG4gICAgICAgIEBfZ2V0UGFyZW50c0FuZEluZm9Db250aW51ZShxdWVyeSwgY2FsbCwgY2FsbEFyZ3MsIFtdLCBudWxsKVxuXG4gICAgX2dldFBhcmVudHNBbmRJbmZvQ29udGludWU6IChxdWVyeSwgY2FsbCwgY2FsbEFyZ3MsIHBhcmVudHMsIGluZm8pIC0+XG4gICAgICAgIEBXTS5NVy5jYWxsQVBJR2V0KHF1ZXJ5LCAocmVzLCBhcmdzKSAtPlxuICAgICAgICAgICAgcGFnZSA9IE9iai5nZXRGaXJzdEl0ZW0ocmVzLnF1ZXJ5LnBhZ2VzKVxuXG4gICAgICAgICAgICBpZiBwYWdlLmNhdGVnb3JpZXNcbiAgICAgICAgICAgICAgICBwYXJlbnRzID0gcGFyZW50cy5jb25jYXQocGFnZS5jYXRlZ29yaWVzKVxuXG4gICAgICAgICAgICBpZiBwYWdlLmNhdGVnb3J5aW5mb1xuICAgICAgICAgICAgICAgIGluZm8gPSBwYWdlLmNhdGVnb3J5aW5mb1xuXG4gICAgICAgICAgICBpZiByZXNbXCJxdWVyeS1jb250aW51ZVwiXVxuICAgICAgICAgICAgICAgICMgUmVxdWVzdCBjYXRlZ29yeWluZm8gb25seSBvbmNlXG4gICAgICAgICAgICAgICAgcXVlcnkucHJvcCA9IFwiY2F0ZWdvcmllc1wiXG4gICAgICAgICAgICAgICAgcXVlcnkuY2xjb250aW51ZSA9IHJlc1tcInF1ZXJ5LWNvbnRpbnVlXCJdLmNhdGVnb3JpZXMuY2xjb250aW51ZVxuICAgICAgICAgICAgICAgIEBfZ2V0UGFyZW50c0FuZEluZm9Db250aW51ZShxdWVyeSwgY2FsbCwgYXJncywgcGFyZW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZm8pXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgY2FsbChwYXJlbnRzLCBpbmZvLCBhcmdzKVxuICAgICAgICAsXG4gICAgICAgIGNhbGxBcmdzLCBudWxsKVxuIiwiIyBXaWtpIE1vbmtleSAtIE1lZGlhV2lraSBib3QgYW5kIGVkaXRvci1hc3Npc3RhbnQgdXNlciBzY3JpcHRcbiMgQ29weXJpZ2h0IChDKSAyMDExIERhcmlvIEdpb3Zhbm5ldHRpIDxkZXZAZGFyaW9naW92YW5uZXR0aS5uZXQ+XG4jXG4jIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFdpa2kgTW9ua2V5LlxuI1xuIyBXaWtpIE1vbmtleSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4jIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4jIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4jIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4jXG4jIFdpa2kgTW9ua2V5IGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4jIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4jIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiMgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbiNcbiMgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiMgYWxvbmcgd2l0aCBXaWtpIE1vbmtleS4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cblxuSFRUUCA9IHJlcXVpcmUoJ0BreW5pa29zL21pc2MvZGlzdC9IVFRQJylcblxuXG5jbGFzcyBtb2R1bGUuZXhwb3J0c1xuICAgIGNvbnN0cnVjdG9yOiAoQFdNKSAtPlxuXG4gICAgZ2V0RW5kVGltZXN0YW1wOiAoY2FsbCwgY2FsbEFyZ3MpIC0+XG4gICAgICAgIHRpdGxlID0gZGVjb2RlVVJJQ29tcG9uZW50KEhUVFAuZ2V0VVJJUGFyYW1ldGVyKG51bGwsICd0aXRsZScpKVxuICAgICAgICBkaWZmID0gSFRUUC5nZXRVUklQYXJhbWV0ZXIobnVsbCwgJ2RpZmYnKVxuICAgICAgICBvbGRpZCA9IEhUVFAuZ2V0VVJJUGFyYW1ldGVyKG51bGwsICdvbGRpZCcpXG5cbiAgICAgICAgZ2l2ZUVuZFRpbWVzdGFtcCA9IChwYWdlLCBpZCkgLT5cbiAgICAgICAgICAgIGNhbGwocGFnZS5yZXZpc2lvbnNbaWRdLnRpbWVzdGFtcCwgY2FsbEFyZ3MpXG5cbiAgICAgICAgc3dpdGNoIGRpZmZcbiAgICAgICAgICAgIHdoZW4gJ25leHQnXG4gICAgICAgICAgICAgICAgcGFycyA9XG4gICAgICAgICAgICAgICAgICAgIHByb3A6IFwicmV2aXNpb25zXCJcbiAgICAgICAgICAgICAgICAgICAgdGl0bGVzOiB0aXRsZVxuICAgICAgICAgICAgICAgICAgICBydmxpbWl0OiBcIjJcIlxuICAgICAgICAgICAgICAgICAgICBydnByb3A6IFwidGltZXN0YW1wXCJcbiAgICAgICAgICAgICAgICAgICAgcnZkaXI6IFwibmV3ZXJcIlxuICAgICAgICAgICAgICAgICAgICBydnN0YXJ0aWQ6IG9sZGlkXG4gICAgICAgICAgICAgICAgQFdNLk1XLmNhbGxRdWVyeShwYXJzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2l2ZUVuZFRpbWVzdGFtcCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudWxsKVxuICAgICAgICAgICAgd2hlbiAncHJldidcbiAgICAgICAgICAgICAgICBwYXJzID1cbiAgICAgICAgICAgICAgICAgICAgcHJvcDogXCJyZXZpc2lvbnNcIlxuICAgICAgICAgICAgICAgICAgICByZXZpZHM6IG9sZGlkXG4gICAgICAgICAgICAgICAgICAgIHJ2cHJvcDogXCJ0aW1lc3RhbXBcIlxuICAgICAgICAgICAgICAgIEBXTS5NVy5jYWxsUXVlcnkocGFycyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdpdmVFbmRUaW1lc3RhbXAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVsbClcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBwYXJzID1cbiAgICAgICAgICAgICAgICAgICAgcHJvcDogXCJyZXZpc2lvbnNcIlxuICAgICAgICAgICAgICAgICAgICByZXZpZHM6IGRpZmZcbiAgICAgICAgICAgICAgICAgICAgcnZwcm9wOiBcInRpbWVzdGFtcFwiXG4gICAgICAgICAgICAgICAgQFdNLk1XLmNhbGxRdWVyeShwYXJzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2l2ZUVuZFRpbWVzdGFtcCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudWxsKVxuIiwiIyBXaWtpIE1vbmtleSAtIE1lZGlhV2lraSBib3QgYW5kIGVkaXRvci1hc3Npc3RhbnQgdXNlciBzY3JpcHRcbiMgQ29weXJpZ2h0IChDKSAyMDExIERhcmlvIEdpb3Zhbm5ldHRpIDxkZXZAZGFyaW9naW92YW5uZXR0aS5uZXQ+XG4jXG4jIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFdpa2kgTW9ua2V5LlxuI1xuIyBXaWtpIE1vbmtleSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4jIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4jIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4jIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4jXG4jIFdpa2kgTW9ua2V5IGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4jIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4jIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiMgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbiNcbiMgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiMgYWxvbmcgd2l0aCBXaWtpIE1vbmtleS4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cblxuQ29tcGF0aWJpbGl0eSA9IHJlcXVpcmUoJ0BreW5pa29zL21pc2MvZGlzdC9Db21wYXRpYmlsaXR5JylcbkhUVFAgPSByZXF1aXJlKCdAa3luaWtvcy9taXNjL2Rpc3QvSFRUUCcpXG5cblxuY2xhc3MgbW9kdWxlLmV4cG9ydHNcbiAgICBjb25zdHJ1Y3RvcjogKEBXTSkgLT5cblxuICAgIGdldFRpdGxlOiAtPlxuICAgICAgICByZXR1cm4gQFdNLlBhcnNlci5zcXVhc2hDb250aWd1b3VzV2hpdGVzcGFjZShkZWNvZGVVUklDb21wb25lbnQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBIVFRQLmdldFVSSVBhcmFtZXRlcihudWxsLCAndGl0bGUnKSkpXG5cbiAgICBpc1NlY3Rpb246IC0+XG4gICAgICAgIHJldHVybiBpZiBkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZSgnd3BTZWN0aW9uJylbMF0udmFsdWUgdGhlbiB0cnVlIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlXG5cbiAgICByZWFkU291cmNlOiAtPlxuICAgICAgICB2YWx1ZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd3cFRleHRib3gxJykudmFsdWVcbiAgICAgICAgIyBGb3IgY29tcGF0aWJpbGl0eSB3aXRoIE9wZXJhIGFuZCBJRVxuICAgICAgICByZXR1cm4gQ29tcGF0aWJpbGl0eS5ub3JtYWxpemVDYXJyaWFnZVJldHVybnModmFsdWUpXG5cbiAgICB3cml0ZVNvdXJjZTogKHRleHQpIC0+XG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd3cFRleHRib3gxJykudmFsdWUgPSB0ZXh0XG5cbiAgICByZWFkU3VtbWFyeTogLT5cbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd3cFN1bW1hcnknKS5nZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKVxuXG4gICAgd3JpdGVTdW1tYXJ5OiAodGV4dCkgLT5cbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3dwU3VtbWFyeScpLnNldEF0dHJpYnV0ZShcInZhbHVlXCIsIHRleHQpXG5cbiAgICBhcHBlbmRUb1N1bW1hcnk6ICh0ZXh0KSAtPlxuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnd3BTdW1tYXJ5Jykuc2V0QXR0cmlidXRlKFwidmFsdWVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRTdW1tYXJ5KCkgKyB0ZXh0KVxuIiwiIyBXaWtpIE1vbmtleSAtIE1lZGlhV2lraSBib3QgYW5kIGVkaXRvci1hc3Npc3RhbnQgdXNlciBzY3JpcHRcbiMgQ29weXJpZ2h0IChDKSAyMDExIERhcmlvIEdpb3Zhbm5ldHRpIDxkZXZAZGFyaW9naW92YW5uZXR0aS5uZXQ+XG4jXG4jIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFdpa2kgTW9ua2V5LlxuI1xuIyBXaWtpIE1vbmtleSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4jIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4jIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4jIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4jXG4jIFdpa2kgTW9ua2V5IGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4jIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4jIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiMgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbiNcbiMgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiMgYWxvbmcgd2l0aCBXaWtpIE1vbmtleS4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cblxuQ1NTID0gcmVxdWlyZSgnQGt5bmlrb3MvbWlzYy9kaXN0L0NTUycpXG5cblxuY2xhc3MgbW9kdWxlLmV4cG9ydHNcbiAgICBjb25zdHJ1Y3RvcjogKEBXTSkgLT5cblxuICAgIF9tYWtlVUk6IChAcGFnZV90eXBlLCBwbHVnaW5zKSAtPlxuICAgICAgICBDU1MuYWRkU3R5bGVFbGVtZW50KFwiI1dpa2lNb25rZXlGaWx0ZXJzLUNvbW1hbmRzIHtkaXNwbGF5OmZsZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbGlnbi1pdGVtczpjZW50ZXI7IGp1c3RpZnktY29udGVudDpzcGFjZS1iZXR3ZWVuO31cbiAgICAgICAgICAgICAgICAgICAgI1dpa2lNb25rZXlGaWx0ZXJzLUNvbW1hbmRzID4gc2VsZWN0IHtmbGV4OmF1dG87fVxuICAgICAgICAgICAgICAgICAgICAjV2lraU1vbmtleUZpbHRlcnMtQ29tbWFuZHMgPiBzZWxlY3QsXG4gICAgICAgICAgICAgICAgICAgICNXaWtpTW9ua2V5RmlsdGVycy1Db21tYW5kcyA+IGlucHV0W3R5cGU9J2J1dHRvbiddXG4gICAgICAgICAgICAgICAgICAgICAgICB7bWFyZ2luLXJpZ2h0OjFlbTt9XG4gICAgICAgICAgICAgICAgICAgICNXaWtpTW9ua2V5RmlsdGVycy1Db21tYW5kcyA+IGlucHV0W3R5cGU9J2NoZWNrYm94J11cbiAgICAgICAgICAgICAgICAgICAgICAgIHttYXJnaW4tcmlnaHQ6MC40ZW07fVwiKVxuXG4gICAgICAgIGZpbHRlcnMgPSBbXVxuICAgICAgICBzZWxlY3RGaWx0ZXIgPSAkKCc8c2VsZWN0Lz4nKS5jaGFuZ2UoQHVwZGF0ZUZpbHRlclVJKGZpbHRlcnMpKVxuXG4gICAgICAgIGZvciBQbHVnaW4gaW4gcGx1Z2luc1xuICAgICAgICAgICAgcGx1Z2luID0gbmV3IFBsdWdpbihAV00pXG4gICAgICAgICAgICBwbHVnaW5JbnN0ID0gcGx1Z2luLmNvbmYuZmlsdGVyX2xhYmVsXG5cbiAgICAgICAgICAgICMgVGhpcyBhbGxvd3MgdG8gZGlzYWJsZSBhbiBlbnRyeSBieSBnaXZpbmcgaXQgYW55IHNlY29uZFxuICAgICAgICAgICAgIyBwYXJhbWV0ZXIgdGhhdCBldmFsdWF0ZXMgdG8gZmFsc2VcbiAgICAgICAgICAgIGlmIG5vdCBwbHVnaW5JbnN0XG4gICAgICAgICAgICAgICAgY29udGludWVcblxuICAgICAgICAgICAgZmlsdGVycy5wdXNoKHBsdWdpbilcbiAgICAgICAgICAgIG9wdGlvbiA9ICQoJzxvcHRpb24vPicpLnRleHQocGx1Z2luSW5zdClcblxuICAgICAgICAgICAgaWYgcGx1Z2luLmNvbnN0cnVjdG9yLm5hbWUgaXMgQFdNLmNvbmZbXCJkZWZhdWx0XyN7QHBhZ2VfdHlwZX1fcGx1Z2luXCJdXG4gICAgICAgICAgICAgICAgb3B0aW9uWzBdLnNlbGVjdGVkID0gdHJ1ZVxuXG4gICAgICAgICAgICBvcHRpb24uYXBwZW5kVG8oc2VsZWN0RmlsdGVyKVxuXG4gICAgICAgIGlmIGZpbHRlcnMubGVuZ3RoXG4gICAgICAgICAgICBjb21tYW5kc0ZpbHRlckRpdiA9ICQoJzxkaXYvPicpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2lkJywgJ1dpa2lNb25rZXlGaWx0ZXJzLUNvbW1hbmRzJylcblxuICAgICAgICAgICAgY29tbWFuZHNGaWx0ZXJEaXYuYXBwZW5kKHNlbGVjdEZpbHRlcilcblxuICAgICAgICAgICAgJCgnPGlucHV0Lz4nKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd0eXBlJywgJ2J1dHRvbicpXG4gICAgICAgICAgICAgICAgLnZhbCgnQXBwbHkgZmlsdGVyJylcbiAgICAgICAgICAgICAgICAuY2xpY2soQGV4ZWN1dGVQbHVnaW4oZmlsdGVycykpXG4gICAgICAgICAgICAgICAgLmFwcGVuZFRvKGNvbW1hbmRzRmlsdGVyRGl2KVxuXG4gICAgICAgICAgICAkKCc8aW5wdXQvPicpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3R5cGUnLCAnY2hlY2tib3gnKVxuICAgICAgICAgICAgICAgIC5jaGFuZ2UoQHRvZ2dsZUxvZylcbiAgICAgICAgICAgICAgICAuYXBwZW5kVG8oY29tbWFuZHNGaWx0ZXJEaXYpXG5cbiAgICAgICAgICAgICQoJzxzcGFuLz4nKVxuICAgICAgICAgICAgICAgIC50ZXh0KCdTaG93IExvZycpXG4gICAgICAgICAgICAgICAgLmFwcGVuZFRvKGNvbW1hbmRzRmlsdGVyRGl2KVxuXG4gICAgICAgICAgICBkaXZGaWx0ZXIgPSAkKCc8ZGl2Lz4nKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdpZCcsIFwiV2lraU1vbmtleUZpbHRlcnMtT3B0aW9uc1wiKVxuXG4gICAgICAgICAgICAjIFRoaXMgYWxsb3dzIHVwZGF0ZUZpbHRlclVJIHJlcGxhY2UgaXQgdGhlIGZpcnN0IHRpbWVcbiAgICAgICAgICAgICQoJzxkaXYvPicpLmFwcGVuZFRvKGRpdkZpbHRlcilcbiAgICAgICAgICAgIEBkb1VwZGF0ZUZpbHRlclVJKGRpdkZpbHRlciwgZmlsdGVycywgc2VsZWN0RmlsdGVyWzBdLnNlbGVjdGVkSW5kZXgpXG5cbiAgICAgICAgICAgIGRpdiA9ICQoJzxkaXYvPicpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2lkJywgJ1dpa2lNb25rZXlGaWx0ZXJzJylcbiAgICAgICAgICAgICAgICAuYXBwZW5kKGNvbW1hbmRzRmlsdGVyRGl2KVxuICAgICAgICAgICAgICAgIC5hcHBlbmQoZGl2RmlsdGVyKVxuICAgICAgICAgICAgcmV0dXJuIGRpdlswXVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcblxuICAgIHVwZGF0ZUZpbHRlclVJOiAoZmlsdGVycykgPT5cbiAgICAgICAgcmV0dXJuIChldmVudCkgPT5cbiAgICAgICAgICAgIFVJID0gJCgnI1dpa2lNb25rZXlGaWx0ZXJzLU9wdGlvbnMnKVxuICAgICAgICAgICAgc2VsZWN0ID0gJCgnI1dpa2lNb25rZXlGaWx0ZXJzLUNvbW1hbmRzJylcbiAgICAgICAgICAgICAgICAuZmluZCgnc2VsZWN0JylcbiAgICAgICAgICAgICAgICAuZmlyc3QoKVxuICAgICAgICAgICAgaWQgPSBzZWxlY3RbMF0uc2VsZWN0ZWRJbmRleFxuXG4gICAgICAgICAgICBAZG9VcGRhdGVGaWx0ZXJVSShVSSwgZmlsdGVycywgaWQpXG5cbiAgICBkb1VwZGF0ZUZpbHRlclVJOiAoVUksIGZpbHRlcnMsIGlkKSAtPlxuICAgICAgICBtYWtlVUkgPSBmaWx0ZXJzW2lkXS5tYWtlVUlcblxuICAgICAgICBpZiBtYWtlVUkgaW5zdGFuY2VvZiBGdW5jdGlvblxuICAgICAgICAgICAgVUkuY2hpbGRyZW4oKS5maXJzdCgpLnJlcGxhY2VXaXRoKG1ha2VVSSgpKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICAjIERvbid0IHJlbW92ZSwgb3RoZXJ3aXNlIGlmIGFub3RoZXIgcGx1Z2luIHdpdGggaW50ZXJmYWNlIGlzXG4gICAgICAgICAgICAjIHNlbGVjdGVkLCByZXBsYWNlV2l0aCB3b24ndCB3b3JrXG4gICAgICAgICAgICBVSS5jaGlsZHJlbigpLmZpcnN0KCkucmVwbGFjZVdpdGgoJCgnPGRpdi8+JykpXG5cbiAgICBleGVjdXRlUGx1Z2luOiAoZmlsdGVycykgPT5cbiAgICAgICAgcmV0dXJuIChldmVudCkgPT5cbiAgICAgICAgICAgIHNlbGVjdCA9ICQoJyNXaWtpTW9ua2V5RmlsdGVycy1Db21tYW5kcycpXG4gICAgICAgICAgICAgICAgLmZpbmQoJ3NlbGVjdCcpXG4gICAgICAgICAgICAgICAgLmZpcnN0KClcbiAgICAgICAgICAgIGlkID0gc2VsZWN0WzBdLnNlbGVjdGVkSW5kZXhcblxuICAgICAgICAgICAgZmlsdGVyc1tpZF1bXCJtYWluXyN7QHBhZ2VfdHlwZX1cIl0oKVxuXG4gICAgICAgICAgICBldmVudC50YXJnZXQuZGlzYWJsZWQgPSB0cnVlXG5cbiAgICB0b2dnbGVMb2c6IChldmVudCkgLT5cbiAgICAgICAgaWYgQGNoZWNrZWRcbiAgICAgICAgICAgICQoJyNXaWtpTW9ua2V5TG9nJykuc2hvdygpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgICQoJyNXaWtpTW9ua2V5TG9nJykuaGlkZSgpXG4iLCIjIFdpa2kgTW9ua2V5IC0gTWVkaWFXaWtpIGJvdCBhbmQgZWRpdG9yLWFzc2lzdGFudCB1c2VyIHNjcmlwdFxuIyBDb3B5cmlnaHQgKEMpIDIwMTEgRGFyaW8gR2lvdmFubmV0dGkgPGRldkBkYXJpb2dpb3Zhbm5ldHRpLm5ldD5cbiNcbiMgVGhpcyBmaWxlIGlzIHBhcnQgb2YgV2lraSBNb25rZXkuXG4jXG4jIFdpa2kgTW9ua2V5IGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiMgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiMgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiMgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbiNcbiMgV2lraSBNb25rZXkgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiMgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiMgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuIyBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuI1xuIyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuIyBhbG9uZyB3aXRoIFdpa2kgTW9ua2V5LiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuXG5PYmogPSByZXF1aXJlKCdAa3luaWtvcy9taXNjL2Rpc3QvT2JqJylcblxuXG5jbGFzcyBtb2R1bGUuZXhwb3J0c1xuICAgIGNvbnN0cnVjdG9yOiAoQFdNKSAtPlxuXG4gICAgcGFyc2VMaW5rczogKHN1cHBvcnRlZExhbmdzLCBzb3VyY2UsIGl3bWFwKSA9PlxuICAgICAgICBwYXJzZWRMaW5rcyA9IEBXTS5QYXJzZXIuZmluZFNwZWNpYWxMaW5rcyhcbiAgICAgICAgICAgIHNvdXJjZSxcbiAgICAgICAgICAgIHN1cHBvcnRlZExhbmdzLmpvaW4oXCJ8XCIpXG4gICAgICAgIClcblxuICAgICAgICBsYW5nbGlua3MgPSBbXVxuICAgICAgICBmb3IgbGluayBpbiBwYXJzZWRMaW5rc1xuICAgICAgICAgICAgIyBEbyBub3Qgc3RvcmUgdGhlIHRhZyBsb3dlcmNhc2VkLCBzaW5jZSBpdCBzaG91bGQgYmUga2VwdCBhc1xuICAgICAgICAgICAgIyBvcmlnaW5hbFxuICAgICAgICAgICAgbHRhZyA9IGxpbmsubmFtZXNwYWNlXG4gICAgICAgICAgICBsdGl0bGUgPSBsaW5rLnRpdGxlICsgKGlmIGxpbmsuZnJhZ21lbnQgdGhlbiAoXCIjXCIgKyBsaW5rLmZyYWdtZW50KSBlbHNlIFwiXCIpXG4gICAgICAgICAgICBmb3IgaXcgaW4gaXdtYXBcbiAgICAgICAgICAgICAgICBpZiBpdy5wcmVmaXgudG9Mb3dlckNhc2UoKSA9PSBsdGFnLnRvTG93ZXJDYXNlKClcbiAgICAgICAgICAgICAgICAgICAgIyBGaXggdGhlIHVybCBfYmVmb3JlXyByZXBsYWNpbmcgJDFcbiAgICAgICAgICAgICAgICAgICAgbHVybCA9IEBXTS5NVy5maXhJbnRlcndpa2lVcmwoaXcudXJsKVxuICAgICAgICAgICAgICAgICAgICBsdXJsID0gbHVybC5yZXBsYWNlKFwiJDFcIiwgZW5jb2RlVVJJQ29tcG9uZW50KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBAV00uUGFyc2VyLnNxdWFzaENvbnRpZ3VvdXNXaGl0ZXNwYWNlKGx0aXRsZSkpKVxuICAgICAgICAgICAgICAgICAgICBicmVha1xuXG4gICAgICAgICAgICBsYW5nbGlua3MucHVzaCh7bGFuZzogbHRhZywgdGl0bGU6IGx0aXRsZSwgdXJsOiBsdXJsLCBpbmRleDogbGluay5pbmRleCwgbGVuZ3RoOiBsaW5rLmxlbmd0aH0pXG5cbiAgICAgICAgcmV0dXJuIGxhbmdsaW5rc1xuXG4gICAgcXVlcnlMaW5rczogKHF1ZXJ5VGl0bGUsIHRpdGxlLCBzdXBwb3J0ZWRMYW5ncyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaXRlbGlzdCwgZmlyc3RQYWdlLCBjYWxsRW5kLCBjYWxsQXJncykgPT5cbiAgICAgICAgcXVlcnkgPVxuICAgICAgICAgICAgYWN0aW9uOiBcInF1ZXJ5XCJcbiAgICAgICAgICAgIHByb3A6IFwiaW5mb3xyZXZpc2lvbnNcIlxuICAgICAgICAgICAgcnZwcm9wOiBcImNvbnRlbnR8dGltZXN0YW1wXCJcbiAgICAgICAgICAgIGludG9rZW46IFwiZWRpdFwiXG4gICAgICAgICAgICB0aXRsZXM6IHF1ZXJ5VGl0bGVcbiAgICAgICAgICAgIG1ldGE6IFwic2l0ZWluZm9cIlxuICAgICAgICAgICAgc2lwcm9wOiBcImludGVyd2lraW1hcFwiXG4gICAgICAgICAgICBzaWZpbHRlcml3OiBcImxvY2FsXCJcblxuICAgICAgICAjIFdoZW4gY2FsbGVkIGJ5IHRoZSBib3QsIGlmIHRoZSBzdGFydCBwYWdlIGlzIGEgcmVkaXJlY3QgaXRzZWxmLCBpdFxuICAgICAgICAjIHNob3VkbG4ndCBiZSByZXNvbHZlZFxuICAgICAgICBpZiBub3QgZmlyc3RQYWdlXG4gICAgICAgICAgICBxdWVyeS5yZWRpcmVjdHMgPSBcIjFcIlxuXG4gICAgICAgIEBXTS5NVy5jYWxsQVBJR2V0KFxuICAgICAgICAgICAgcXVlcnksXG4gICAgICAgICAgICAocmVzLCBhcmdzKSA9PlxuICAgICAgICAgICAgICAgIGlmIHJlcy5xdWVyeS5wYWdlc1xuICAgICAgICAgICAgICAgICAgICBwYWdlID0gT2JqLmdldEZpcnN0SXRlbShyZXMucXVlcnkucGFnZXMpXG4gICAgICAgICAgICAgICAgICAgIGlmIHBhZ2UucmV2aXNpb25zXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvciA9IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZSA9IHBhZ2UucmV2aXNpb25zWzBdW1wiKlwiXVxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZXN0YW1wID0gcGFnZS5yZXZpc2lvbnNbMF0udGltZXN0YW1wXG4gICAgICAgICAgICAgICAgICAgICAgICBlZGl0dG9rZW4gPSBwYWdlLmVkaXR0b2tlblxuICAgICAgICAgICAgICAgICAgICAgICAgaXdtYXAgPSByZXMucXVlcnkuaW50ZXJ3aWtpbWFwXG4gICAgICAgICAgICAgICAgICAgICAgICBsYW5nbGlua3MgPSBAV00uSW50ZXJsYW5ndWFnZS5wYXJzZUxpbmtzKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VwcG9ydGVkTGFuZ3MsIHNvdXJjZSwgaXdtYXApXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICMgVGhlIHJlcXVlc3RlZCBhcnRpY2xlIGRvZXNuJ3QgZXhpc3RcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yID0gJ25vbmV4aXN0aW5nJ1xuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlID0gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcCA9IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBlZGl0dG9rZW4gPSBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgaXdtYXAgPSByZXMucXVlcnkuaW50ZXJ3aWtpbWFwXG4gICAgICAgICAgICAgICAgICAgICAgICBsYW5nbGlua3MgPSBmYWxzZVxuXG4gICAgICAgICAgICAgICAgZWxzZSBpZiByZXMucXVlcnkucmVkaXJlY3RzXG4gICAgICAgICAgICAgICAgICAgICMgVGhlIHJlcXVlc3RlZCBhcnRpY2xlIGlzIGFuIHVuc29sdmVkIHJlZGlyZWN0XG4gICAgICAgICAgICAgICAgICAgICMgKHJlZGlyZWN0IG92ZXIgaW50ZXJ3aWtpIGxpbms/KVxuICAgICAgICAgICAgICAgICAgICBlcnJvciA9ICd1bnNvbHZlZHJlZGlyZWN0J1xuICAgICAgICAgICAgICAgICAgICBzb3VyY2UgPSBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXAgPSBmYWxzZVxuICAgICAgICAgICAgICAgICAgICBlZGl0dG9rZW4gPSBmYWxzZVxuICAgICAgICAgICAgICAgICAgICBpd21hcCA9IHJlcy5xdWVyeS5pbnRlcndpa2ltYXBcbiAgICAgICAgICAgICAgICAgICAgbGFuZ2xpbmtzID0gZmFsc2VcblxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgIyBVbmtub3duIGVycm9yXG4gICAgICAgICAgICAgICAgICAgIGVycm9yID0gJ3Vua25vd24nXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZSA9IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcCA9IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIGVkaXR0b2tlbiA9IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIGl3bWFwID0gcmVzLnF1ZXJ5LmludGVyd2lraW1hcFxuICAgICAgICAgICAgICAgICAgICBsYW5nbGlua3MgPSBmYWxzZVxuXG4gICAgICAgICAgICAgICAgY2FsbEVuZChcbiAgICAgICAgICAgICAgICAgICAgdGl0bGUsXG4gICAgICAgICAgICAgICAgICAgIHN1cHBvcnRlZExhbmdzLFxuICAgICAgICAgICAgICAgICAgICB3aGl0ZWxpc3QsXG4gICAgICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgICAgICAgICAgbGFuZ2xpbmtzLFxuICAgICAgICAgICAgICAgICAgICBpd21hcCxcbiAgICAgICAgICAgICAgICAgICAgc291cmNlLFxuICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXAsXG4gICAgICAgICAgICAgICAgICAgIGVkaXR0b2tlbixcbiAgICAgICAgICAgICAgICAgICAgYXJnc1xuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICxcbiAgICAgICAgICAgIGNhbGxBcmdzLFxuICAgICAgICAgICAgKGFyZ3MpIC0+XG4gICAgICAgICAgICAgICAgY2FsbEVuZChcbiAgICAgICAgICAgICAgICAgICAgdGl0bGUsXG4gICAgICAgICAgICAgICAgICAgIHN1cHBvcnRlZExhbmdzLFxuICAgICAgICAgICAgICAgICAgICB3aGl0ZWxpc3QsXG4gICAgICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAndW5rbm93bicsXG4gICAgICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgYXJnc1xuICAgICAgICAgICAgICAgIClcbiAgICAgICAgKVxuXG4gICAgY3JlYXRlTmV3TGluazogKG9yaWdUYWcsIHRpdGxlLCB1cmwpID0+XG4gICAgICAgIHJldHVybiB7b3JpZ1RhZzogb3JpZ1RhZywgdGl0bGU6IHRpdGxlLCB1cmw6IHVybH1cblxuICAgIGNyZWF0ZVZpc2l0ZWRMaW5rOiAob3JpZ1RhZywgdGl0bGUsIHVybCwgaXdtYXAsIHNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcCwgZWRpdHRva2VuLCBsaW5rcykgPT5cbiAgICAgICAgZW50cnkgPVxuICAgICAgICAgICAgb3JpZ1RhZzogb3JpZ1RhZ1xuICAgICAgICAgICAgdGl0bGU6IHRpdGxlXG4gICAgICAgICAgICB1cmw6IHVybFxuICAgICAgICAgICAgaXdtYXA6IGl3bWFwXG4gICAgICAgICAgICBzb3VyY2U6IHNvdXJjZVxuICAgICAgICAgICAgdGltZXN0YW1wOiB0aW1lc3RhbXBcbiAgICAgICAgICAgIGVkaXR0b2tlbjogZWRpdHRva2VuXG4gICAgICAgICAgICBsaW5rczogW11cblxuICAgICAgICBmb3IgbGluayBpbiBsaW5rc1xuICAgICAgICAgICAgZW50cnkubGlua3MucHVzaChsaW5rKVxuXG4gICAgICAgIHJldHVybiBlbnRyeVxuXG4gICAgY29sbGVjdExpbmtzOiAodmlzaXRlZGxpbmtzLCBuZXdsaW5rcywgc3VwcG9ydGVkTGFuZ3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGl0ZWxpc3QsIGZpcnN0UGFnZSwgY2FsbEVuZCwgY2FsbEFyZ3MpID0+XG4gICAgICAgIGZvciB0YWcgb2YgbmV3bGlua3NcbiAgICAgICAgICAgIGxpbmsgPSBuZXdsaW5rc1t0YWddXG4gICAgICAgICAgICBicmVha1xuXG4gICAgICAgIGlmIGxpbmtcbiAgICAgICAgICAgIGRlbGV0ZSBuZXdsaW5rc1t0YWddXG5cbiAgICAgICAgICAgIHVybCA9IGxpbmsudXJsXG5cbiAgICAgICAgICAgICMgRG9uJ3QgdXNlIEBXTS5NVy5nZXRUaXRsZUZyb21XaWtpVXJsKGRlY29kZVVSSSh1cmwpKSBiZWNhdXNlXG4gICAgICAgICAgICAjIGl0IHdvdWxkbid0IGRlY29kZSBzb21lIGNoYXJhY3RlcnMgbGlrZSBjb2xvbnMsIHdoaWNoIGFyZVxuICAgICAgICAgICAgIyByZXF1aXJlZCB0byBiZSBkZWNvZGVkIGluc3RlYWQgd2hlbiBtYWtpbmcgYW4gQVBJIGNhbGxcbiAgICAgICAgICAgIHF1ZXJ5VGl0bGUgPSBkZWNvZGVVUklDb21wb25lbnQoQFdNLk1XLmdldFRpdGxlRnJvbVdpa2lVcmwodXJsKSlcblxuICAgICAgICAgICAgaWYgcXVlcnlUaXRsZVxuICAgICAgICAgICAgICAgIG9yaWdUYWcgPSBsaW5rLm9yaWdUYWdcbiAgICAgICAgICAgICAgICB0aXRsZSA9IGxpbmsudGl0bGVcblxuICAgICAgICAgICAgICAgICMgSWYgdGhpcyBpcyB0aGUgZmlyc3QgcHJvY2Vzc2VkIHBhZ2UsIGl0J3MgbG9jYWwgZm9yIHN1cmUsIHNvXG4gICAgICAgICAgICAgICAgIyAgIHF1ZXJ5IGl0cyBsaW5rcyBpbiBhbnkgY2FzZS4gVGhpcyBlLmcuIHByZXZlbnRzIHRoZVxuICAgICAgICAgICAgICAgICMgICBhcHBsaWNhdGlvbiBmcm9tIGNyYXNoaW5nIGluIGNhc2UgdGhlIGxvY2FsIHBhZ2UgaXMgaW4gYVxuICAgICAgICAgICAgICAgICMgICBsYW5ndWFnZSB3aG9zZSBsYW5ndWFnZSB0YWcgaXMgbm90IGluIHRoZSB3aGl0ZSBsaXN0XG4gICAgICAgICAgICAgICAgIyB0YWcgaXMgYWxyZWFkeSBsb3dlci1jYXNlZFxuICAgICAgICAgICAgICAgIGlmIGZpcnN0UGFnZSBvciB3aGl0ZWxpc3QuaW5kZXhPZih0YWcpID4gLTFcbiAgICAgICAgICAgICAgICAgICAgQFdNLkxvZy5sb2dJbmZvKFwiUmVhZGluZyBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEBXTS5Mb2cubGlua1RvUGFnZSh1cmwsIFwiW1tcIiArIG9yaWdUYWcgKyBcIjpcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlICsgXCJdXVwiKSArIFwiIC4uLlwiKVxuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucXVlcnlMaW5rcyhcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5VGl0bGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1cHBvcnRlZExhbmdzLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpdGVsaXN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3RQYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgQFdNLkludGVybGFuZ3VhZ2UuX2NvbGxlY3RMaW5rc0NvbnRpbnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgW3VybCwgdGFnLCBvcmlnVGFnLCB2aXNpdGVkbGlua3MsIG5ld2xpbmtzLCBjYWxsRW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsQXJnc11cbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgQFdNLkludGVybGFuZ3VhZ2UuX2NvbGxlY3RMaW5rc0NvbnRpbnVlKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdXBwb3J0ZWRMYW5ncyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaXRlbGlzdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0UGFnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdub3RpbndoaXRlbGlzdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgW3VybCwgdGFnLCBvcmlnVGFnLCB2aXNpdGVkbGlua3MsIG5ld2xpbmtzLCBjYWxsRW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsQXJnc11cbiAgICAgICAgICAgICAgICAgICAgKVxuXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgQFdNLkxvZy5sb2dXYXJuaW5nKFwiQ2Fubm90IGV4dHJhY3QgdGhlIHBhZ2UgdGl0bGUgZnJvbSBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQFdNLkxvZy5saW5rVG9QYWdlKHVybCwgZGVjb2RlVVJJKHVybCkpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIiwgcmVtb3ZpbmcgaXQgaWYgaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YXMgbGlua2VkIGZyb20gdGhlIHByb2Nlc3NlZCBhcnRpY2xlXCIpXG4gICAgICAgICAgICAgICAgQFdNLkludGVybGFuZ3VhZ2UuY29sbGVjdExpbmtzKFxuICAgICAgICAgICAgICAgICAgICB2aXNpdGVkbGlua3MsXG4gICAgICAgICAgICAgICAgICAgIG5ld2xpbmtzLFxuICAgICAgICAgICAgICAgICAgICBzdXBwb3J0ZWRMYW5ncyxcbiAgICAgICAgICAgICAgICAgICAgd2hpdGVsaXN0LFxuICAgICAgICAgICAgICAgICAgICBmaXJzdFBhZ2UsXG4gICAgICAgICAgICAgICAgICAgIGNhbGxFbmQsXG4gICAgICAgICAgICAgICAgICAgIGNhbGxBcmdzXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICBjYWxsRW5kKHZpc2l0ZWRsaW5rcywgY2FsbEFyZ3MpXG5cbiAgICBfY29sbGVjdExpbmtzQ29udGludWU6ICh0aXRsZSwgc3VwcG9ydGVkTGFuZ3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaXRlbGlzdCwgZmlyc3RQYWdlLCBlcnJvciwgbGFuZ2xpbmtzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpd21hcCwgc291cmNlLCB0aW1lc3RhbXAsIGVkaXR0b2tlbiwgYXJncykgPT5cbiAgICAgICAgdXJsID0gYXJnc1swXVxuICAgICAgICB0YWcgPSBhcmdzWzFdXG4gICAgICAgIG9yaWdUYWcgPSBhcmdzWzJdXG4gICAgICAgIHZpc2l0ZWRsaW5rcyA9IGFyZ3NbM11cbiAgICAgICAgbmV3bGlua3MgPSBhcmdzWzRdXG4gICAgICAgIGNhbGxFbmQgPSBhcmdzWzVdXG4gICAgICAgIGNhbGxBcmdzID0gYXJnc1s2XVxuXG4gICAgICAgIGlmIGVycm9yID09ICdub25leGlzdGluZydcbiAgICAgICAgICAgIEBXTS5Mb2cubG9nV2FybmluZyhAV00uTG9nLmxpbmtUb1BhZ2UodXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIltbXCIgKyBvcmlnVGFnICsgXCI6XCIgKyB0aXRsZSArIFwiXV1cIikgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIiBzZWVtcyB0byBwb2ludFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byBhIG5vbi1leGlzdGluZyBhcnRpY2xlOiByZW1vdmluZyBpdCBpZlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdCB3YXMgbGlua2VkIGZyb20gdGhlIHByb2Nlc3NlZCBhcnRpY2xlXCIpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGlmIGVycm9yID09ICd1bnNvbHZlZHJlZGlyZWN0J1xuICAgICAgICAgICAgICAgIEBXTS5Mb2cubG9nV2FybmluZyhAV00uTG9nLmxpbmtUb1BhZ2UodXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIltbXCIgKyBvcmlnVGFnICsgXCI6XCIgKyB0aXRsZSArIFwiXV1cIikgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIiB3aWxsIG5vdCBiZSBjaGVja2VkIGJlY2F1c2UgaXQgcG9pbnRzIHRvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuIGV4dGVybmFsIHJlZGlyZWN0XCIpXG4gICAgICAgICAgICBlbHNlIGlmIGVycm9yID09ICd1bmtub3duJ1xuICAgICAgICAgICAgICAgIEBXTS5Mb2cubG9nV2FybmluZyhAV00uTG9nLmxpbmtUb1BhZ2UodXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIltbXCIgKyBvcmlnVGFnICsgXCI6XCIgKyB0aXRsZSArIFwiXV1cIikgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIiB3aWxsIG5vdCBiZSBjaGVja2VkIGJlY2F1c2Ugb2YgYW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5zcGVjaWZpZWQgcHJvYmxlbVwiKVxuICAgICAgICAgICAgZWxzZSBpZiBlcnJvciA9PSAnbm90aW53aGl0ZWxpc3QnXG4gICAgICAgICAgICAgICAgQFdNLkxvZy5sb2dXYXJuaW5nKEBXTS5Mb2cubGlua1RvUGFnZSh1cmwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiW1tcIiArIG9yaWdUYWcgKyBcIjpcIiArIHRpdGxlICsgXCJdXVwiKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiIHdpbGwgbm90IGJlIGNoZWNrZWQgYmVjYXVzZSBcIiArIHRhZyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiIGlzIG5vdCBpbmNsdWRlZCBpbiB0aGUgd2hpdGVsaXN0IGRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW4gdGhlIGNvbmZpZ3VyYXRpb25cIilcblxuICAgICAgICAgICAgdmlzaXRlZGxpbmtzW3RhZ10gPSBAV00uSW50ZXJsYW5ndWFnZS5jcmVhdGVWaXNpdGVkTGluayhvcmlnVGFnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZSwgdXJsLCBpd21hcCwgc291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXAsIGVkaXR0b2tlbiwgbGFuZ2xpbmtzKVxuXG4gICAgICAgICAgICBmb3IgbGluayBpbiBsYW5nbGlua3NcbiAgICAgICAgICAgICAgICBubGluayA9IG5ld2xpbmtzW2xpbmsubGFuZy50b0xvd2VyQ2FzZSgpXVxuICAgICAgICAgICAgICAgIHZsaW5rID0gdmlzaXRlZGxpbmtzW2xpbmsubGFuZy50b0xvd2VyQ2FzZSgpXVxuXG4gICAgICAgICAgICAgICAgaWYgbm90IHZsaW5rIGFuZCBub3QgbmxpbmtcbiAgICAgICAgICAgICAgICAgICAgbmV3bGlua3NbbGluay5sYW5nLnRvTG93ZXJDYXNlKCldID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEBXTS5JbnRlcmxhbmd1YWdlLmNyZWF0ZU5ld0xpbmsobGluay5sYW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rLnRpdGxlLCBsaW5rLnVybClcbiAgICAgICAgICAgICAgICBlbHNlIGlmIHZsaW5rIGFuZCB2bGluay51cmwgIT0gbGluay51cmxcbiAgICAgICAgICAgICAgICAgICAgIyBKdXN0IGlnbm9yZSBhbnkgY29uZmxpY3RpbmcgbGlua3MgYW5kIHdhcm4gdGhlIHVzZXI6XG4gICAgICAgICAgICAgICAgICAgICMgaWYgaXQncyBhIHJlYWwgY29uZmxpY3QsIHRoZSB1c2VyIHdpbGwgaW52ZXN0aWdhdGUgaXQsXG4gICAgICAgICAgICAgICAgICAgICMgb3RoZXJ3aXNlIHRoZSB1c2VyIHdpbGwgaWdub3JlIGl0XG4gICAgICAgICAgICAgICAgICAgIEBXTS5Mb2cubG9nV2FybmluZyhcIlBvc3NpYmx5IGNvbmZsaWN0aW5nIGludGVybGFuZ3VhZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmtzOiBcIiArIEBXTS5Mb2cubGlua1RvUGFnZShsaW5rLnVybCwgXCJbW1wiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmsubGFuZyArIFwiOlwiICsgbGluay50aXRsZSArIFwiXV1cIikgKyBcIiBhbmQgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgQFdNLkxvZy5saW5rVG9QYWdlKHZsaW5rLnVybCwgXCJbW1wiICsgbGluay5sYW5nICsgXCI6XCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgdmlzaXRlZGxpbmtzW2xpbmsubGFuZy50b0xvd2VyQ2FzZSgpXS50aXRsZSArIFwiXV1cIikpXG5cbiAgICAgICAgICAgICAgICBlbHNlIGlmIG5saW5rIGFuZCBubGluay51cmwgIT0gbGluay51cmxcbiAgICAgICAgICAgICAgICAgICAgIyBKdXN0IGlnbm9yZSBhbnkgY29uZmxpY3RpbmcgbGlua3MgYW5kIHdhcm4gdGhlIHVzZXI6XG4gICAgICAgICAgICAgICAgICAgICMgaWYgaXQncyBhIHJlYWwgY29uZmxpY3QsIHRoZSB1c2VyIHdpbGwgaW52ZXN0aWdhdGUgaXQsXG4gICAgICAgICAgICAgICAgICAgICMgb3RoZXJ3aXNlIHRoZSB1c2VyIHdpbGwgaWdub3JlIGl0XG4gICAgICAgICAgICAgICAgICAgIEBXTS5Mb2cubG9nV2FybmluZyhcIlBvc3NpYmx5IGNvbmZsaWN0aW5nIGludGVybGFuZ3VhZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmtzOiBcIiArIEBXTS5Mb2cubGlua1RvUGFnZShsaW5rLnVybCwgXCJbW1wiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmsubGFuZyArIFwiOlwiICsgbGluay50aXRsZSArIFwiXV1cIikgKyBcIiBhbmQgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgQFdNLkxvZy5saW5rVG9QYWdlKG5saW5rLnVybCwgXCJbW1wiICsgbGluay5sYW5nICsgXCI6XCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3bGlua3NbbGluay5sYW5nLnRvTG93ZXJDYXNlKCldLnRpdGxlICsgXCJdXVwiKSlcblxuICAgICAgICBAV00uSW50ZXJsYW5ndWFnZS5jb2xsZWN0TGlua3MoXG4gICAgICAgICAgICB2aXNpdGVkbGlua3MsXG4gICAgICAgICAgICBuZXdsaW5rcyxcbiAgICAgICAgICAgIHN1cHBvcnRlZExhbmdzLFxuICAgICAgICAgICAgd2hpdGVsaXN0LFxuICAgICAgICAgICAgZmlyc3RQYWdlLFxuICAgICAgICAgICAgY2FsbEVuZCxcbiAgICAgICAgICAgIGNhbGxBcmdzXG4gICAgICAgIClcblxuICAgIHVwZGF0ZUxpbmtzOiAobGFuZywgdXJsLCBpd21hcCwgc291cmNlLCBvbGRsaW5rcywgbmV3bGlua3MpID0+XG4gICAgICAgIGxhbmcgPSBsYW5nLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbGlua0xpc3QgPSBbXVxuXG4gICAgICAgIGZvciB0YWcgb2YgbmV3bGlua3NcbiAgICAgICAgICAgIGlmIHRhZyAhPSBsYW5nXG4gICAgICAgICAgICAgICAgbGluayA9IG5ld2xpbmtzW3RhZ11cbiAgICAgICAgICAgICAgICB0YWdGb3VuZCA9IGZhbHNlXG5cbiAgICAgICAgICAgICAgICAjIE5ldyBsaW5rcyB0aGF0IHdlcmUgbm90IGluIHRoZSB3aGl0ZSBsaXN0IHdpbGwgaGF2ZSB0aGVcbiAgICAgICAgICAgICAgICAjIFwiaXdtYXBcIiBhdHRyaWJ1dGUgZmFsc2UsIFwidGltZXN0YW1wXCIgYW5kIFwiZWRpdHRva2VuXCIgbnVsbFxuICAgICAgICAgICAgICAgICMgYW5kIFwibGlua3NcIiBhcyBhbiBlbXB0eSBhcnJheVxuICAgICAgICAgICAgICAgICMgTm90ZSB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuICdpd21hcCcgYW5kICdsaW5rLml3bWFwJ1xuICAgICAgICAgICAgICAgIGZvciBpdyBpbiBpd21hcFxuICAgICAgICAgICAgICAgICAgICBpZiBpdy5wcmVmaXgudG9Mb3dlckNhc2UoKSA9PSB0YWcudG9Mb3dlckNhc2UoKVxuICAgICAgICAgICAgICAgICAgICAgICAgbGlua0xpc3QucHVzaChcIltbXCIgKyBsaW5rLm9yaWdUYWcgKyBcIjpcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmsudGl0bGUgKyBcIl1dXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWdGb3VuZCA9IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgICAgICAgICBpZiBub3QgdGFnRm91bmRcbiAgICAgICAgICAgICAgICAgICAgQFdNLkxvZy5sb2dXYXJuaW5nKHRhZyArIFwiIGludGVybGFuZ3VhZ2UgbGlua3MgYXJlIG5vdFxuICAgICAgICAgICAgICAgICAgICAgICAgc3VwcG9ydGVkIGluIFwiICsgQFdNLkxvZy5saW5rVG9QYWdlKHVybCwgXCJbW1wiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmsub3JpZ1RhZyArIFwiOlwiICsgbGluay50aXRsZSArIFwiXV1cIikgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCIgLCBpZ25vcmluZyB0aGVtXCIpXG5cbiAgICAgICAgbGlua0xpc3Quc29ydChcbiAgICAgICAgICAgIChhLCBiKSAtPlxuICAgICAgICAgICAgICAgICMgU29ydGluZyBpcyBjYXNlIHNlbnNpdGl2ZSBieSBkZWZhdWx0XG4gICAgICAgICAgICAgICAgaWYgYS50b0xvd2VyQ2FzZSgpID4gYi50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAxXG4gICAgICAgICAgICAgICAgaWYgYi50b0xvd2VyQ2FzZSgpID4gYS50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtMVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDBcbiAgICAgICAgKVxuXG4gICAgICAgIGNsZWFuVGV4dCA9IFwiXCJcbiAgICAgICAgdGV4dElkID0gMFxuXG4gICAgICAgIGZvciBsaW5rIGluIG9sZGxpbmtzXG4gICAgICAgICAgICBjbGVhblRleHQgKz0gc291cmNlLnN1YnN0cmluZyh0ZXh0SWQsIGxpbmsuaW5kZXgpXG4gICAgICAgICAgICB0ZXh0SWQgPSBsaW5rLmluZGV4ICsgbGluay5sZW5ndGhcblxuICAgICAgICBjbGVhblRleHQgKz0gc291cmNlLnN1YnN0cmluZyh0ZXh0SWQpXG5cbiAgICAgICAgaWYgb2xkbGlua3MubGVuZ3RoXG4gICAgICAgICAgICAjIEluc2VydCB0aGUgbmV3IGxpbmtzIGF0IHRoZSBpbmRleCBvZiB0aGUgZmlyc3QgcHJldmlvdXMgbGlua1xuICAgICAgICAgICAgZmlyc3RMaW5rID0gb2xkbGlua3NbMF0uaW5kZXhcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmlyc3RMaW5rID0gMFxuXG4gICAgICAgIHBhcnRzID0gW11cbiAgICAgICAgIyBEbyBub3QgYWRkIGVtcHR5IHN0cmluZ3MgdG8gcGFydHMsIG90aGVyd2lzZSB3aGVuIGl0J3Mgam9pbmVkXG4gICAgICAgICMgICB1bm5lY2Vzc2FyeSBsaW5lIGJyZWFrcyB3aWxsIGJlIGFkZGVkXG5cbiAgICAgICAgaGVhZCA9IGNsZWFuVGV4dC5zdWJzdHJpbmcoMCwgZmlyc3RMaW5rKS50cmltKClcblxuICAgICAgICBpZiBoZWFkXG4gICAgICAgICAgICBwYXJ0cy5wdXNoKGhlYWQpXG5cbiAgICAgICAgbGlua3MgPSBsaW5rTGlzdC5qb2luKFwiXFxuXCIpXG5cbiAgICAgICAgaWYgbGlua3NcbiAgICAgICAgICAgIHBhcnRzLnB1c2gobGlua3MpXG5cbiAgICAgICAgYm9keSA9IGNsZWFuVGV4dC5zdWJzdHIoZmlyc3RMaW5rKS50cmltKClcblxuICAgICAgICBpZiBib2R5XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKGJvZHkpXG5cbiAgICAgICAgIyBNYWtlIHN1cmUgdG8gcHJlc2VydmUgdGhlIG9yaWdpbmFsIHdoaXRlIHNwYWNlIGF0IHRoZSBlbmQsIG90aGVyd2lzZVxuICAgICAgICAjICAgdGhlIGZpbmFsIChuZXdUZXh0ICE9IHNvdXJjZSkgbWF5IHJldHVybiB0cnVlIGV2ZW4gd2hlbiBubyBhY3R1YWxcbiAgICAgICAgIyAgIGNoYW5nZSBoYXMgYmVlbiBtYWRlXG4gICAgICAgICMgTm90ZSB0aGF0IC9cXHMrJC8gd291bGQgcmV0dXJuIG51bGwgaW4gdGhlIGFic2VuY2Ugb2YgdHJhaWxpbmdcbiAgICAgICAgIyAgIHdoaXRlc3BhY2UsIHNvIGEgZnVydGhlciBjaGVjayBzaG91bGQgYmUgbWFkZSwgd2hpbGUgL1xccyokL1xuICAgICAgICAjICAgc2FmZWx5IHJldHVybnMgYW4gZW1wdHkgc3RyaW5nIGluIHRoYXQgY2FzZVxuICAgICAgICB0cmFpbHdzID0gL1xccyokL1xuXG4gICAgICAgIHJldHVybiBwYXJ0cy5qb2luKFwiXFxuXCIpICsgdHJhaWx3cy5leGVjKHNvdXJjZSlcbiIsIiMgV2lraSBNb25rZXkgLSBNZWRpYVdpa2kgYm90IGFuZCBlZGl0b3ItYXNzaXN0YW50IHVzZXIgc2NyaXB0XG4jIENvcHlyaWdodCAoQykgMjAxMSBEYXJpbyBHaW92YW5uZXR0aSA8ZGV2QGRhcmlvZ2lvdmFubmV0dGkubmV0PlxuI1xuIyBUaGlzIGZpbGUgaXMgcGFydCBvZiBXaWtpIE1vbmtleS5cbiNcbiMgV2lraSBNb25rZXkgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuIyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuIyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuIyAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuI1xuIyBXaWtpIE1vbmtleSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuIyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuIyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4jIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4jXG4jIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4jIGFsb25nIHdpdGggV2lraSBNb25rZXkuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG5cbntqc3N9ID0gcmVxdWlyZSgnLi9saWJzJylcblN0ciA9IHJlcXVpcmUoJ0BreW5pa29zL21pc2MvZGlzdC9TdHInKVxuXG5cbmNsYXNzIG1vZHVsZS5leHBvcnRzXG4gICAgY29uc3RydWN0b3I6IChAV00pIC0+XG4gICAgICAgIEBfY3VycmVudEluZm9EaXNwbGF5U3RhdGUgPSB0cnVlXG5cbiAgICAgICAgIyBUaGUgLndhcm5pbmcgYW5kIC5lcnJvciBjbGFzc2VzIGFyZSBhbHJlYWR5IHVzZWQgYnlcbiAgICAgICAgIyBNZWRpYVdpa2ksIHdpdGhvdXQgYXNzb2NpYXRpbmcgdGhlbSB3aXRoIGFuIGlkIGFuZCBhIHRhZ1xuICAgICAgICBzdHlsZXMgPVxuICAgICAgICAgICAgbG9nOlxuICAgICAgICAgICAgICAgIGhlaWdodDogJzEwZW0nXG4gICAgICAgICAgICAgICAgYm9yZGVyOiAnMnB4IHNvbGlkICMwN2InXG4gICAgICAgICAgICAgICAgcGFkZGluZzogJzAuNWVtJ1xuICAgICAgICAgICAgICAgIG92ZXJmbG93OiAnYXV0bydcbiAgICAgICAgICAgICAgICByZXNpemU6ICd2ZXJ0aWNhbCdcbiAgICAgICAgICAgICAgICAnYmFja2dyb3VuZC1jb2xvcic6ICcjMTExJ1xuXG4gICAgICAgICAgICAgICAgJyYgcC50aW1lc3RhbXAsICYgcC5tZXNzYWdlJzpcbiAgICAgICAgICAgICAgICAgICAgYm9yZGVyOiAnbm9uZSdcbiAgICAgICAgICAgICAgICAgICAgcGFkZGluZzogMFxuICAgICAgICAgICAgICAgICAgICAnZm9udC1mYW1pbHknOiAnbW9ub3NwYWNlJ1xuICAgICAgICAgICAgICAgICAgICBjb2xvcjogJyNlZWUnXG5cbiAgICAgICAgICAgICAgICAnJiBwLnRpbWVzdGFtcCc6XG4gICAgICAgICAgICAgICAgICAgIG1hcmdpbjogJzAgMWVtIDAgMCdcbiAgICAgICAgICAgICAgICAgICAgJ3doaXRlLXNwYWNlJzogJ25vd3JhcCdcblxuICAgICAgICAgICAgICAgICcmIHAubWVzc2FnZSc6XG4gICAgICAgICAgICAgICAgICAgIG1hcmdpbjogMFxuXG4gICAgICAgICAgICAgICAgJyYgZGl2Lm1kZWJ1ZywgJiBkaXYubWluZm8sICYgZGl2Lm13YXJuaW5nLCAmIGRpdi5tZXJyb3InOlxuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiAnZmxleCdcblxuICAgICAgICAgICAgICAgICcmIGRpdi5taGlkZGVuJzpcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogJ25vbmUnXG5cbiAgICAgICAgICAgICAgICAnJiBkaXYubWpzb24nOlxuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiAnbm9uZSdcblxuICAgICAgICAgICAgICAgICcmIGRpdi5tZGVidWcgcC5tZXNzYWdlJzpcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6ICdjeWFuJ1xuXG4gICAgICAgICAgICAgICAgJyYgZGl2Lm13YXJuaW5nIHAubWVzc2FnZSc6XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiAnZ29sZCdcblxuICAgICAgICAgICAgICAgICcmIGRpdi5tZXJyb3IgcC5tZXNzYWdlJzpcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6ICdyZWQnXG5cbiAgICAgICAgICAgICAgICAnJiBhJzpcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6ICdpbmhlcml0J1xuICAgICAgICAgICAgICAgICAgICAndGV4dC1kZWNvcmF0aW9uJzogJ3VuZGVybGluZSdcblxuICAgICAgICB7Y2xhc3Nlc30gPSBqc3MuY3JlYXRlU3R5bGVTaGVldChcbiAgICAgICAgICAgIHN0eWxlcywge2NsYXNzTmFtZVByZWZpeDogXCJXaWtpTW9ua2V5LVwifSkuYXR0YWNoKClcbiAgICAgICAgQGNsYXNzZXMgPSBjbGFzc2VzXG5cbiAgICBfbWFrZUxvZ0FyZWE6IC0+XG4gICAgICAgIGxvZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgICAgIGxvZy5pZCA9ICdXaWtpTW9ua2V5TG9nJ1xuXG4gICAgICAgIHBhciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3AnKVxuICAgICAgICBwYXIuYXBwZW5kQ2hpbGQoQG1ha2VGaWx0ZXJMaW5rKCkpXG4gICAgICAgIHBhci5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnICcpKVxuICAgICAgICBwYXIuYXBwZW5kQ2hpbGQoQG1ha2VTYXZlTGluaygpKVxuICAgICAgICBsb2cuYXBwZW5kQ2hpbGQocGFyKVxuXG4gICAgICAgIEBsb2dhcmVhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICAgICAgQGxvZ2FyZWEuY2xhc3NOYW1lID0gQGNsYXNzZXMubG9nXG4gICAgICAgIGxvZy5hcHBlbmRDaGlsZChAbG9nYXJlYSlcblxuICAgICAgICByZXR1cm4gbG9nXG5cbiAgICBtYWtlRmlsdGVyTGluazogLT5cbiAgICAgICAgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKVxuICAgICAgICBsaW5rLmhyZWYgPSAnI1dpa2lNb25rZXknXG4gICAgICAgIGxpbmsuaW5uZXJIVE1MID0gQGNvbXB1dGVGaWx0ZXJMaW5rQW5jaG9yKClcblxuICAgICAgICBsaW5rLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoZXZlbnQpID0+XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgICAgICAjIENoYW5nZSBfY3VycmVudEluZm9EaXNwbGF5U3RhdGUgKmJlZm9yZSogdGhlIGxvb3AsIHRvIHByZXZlbnRcbiAgICAgICAgICAgICMgcmFjZSBidWdzXG4gICAgICAgICAgICBAX2N1cnJlbnRJbmZvRGlzcGxheVN0YXRlID0gbm90IEBfY3VycmVudEluZm9EaXNwbGF5U3RhdGVcbiAgICAgICAgICAgIGxpbmsuaW5uZXJIVE1MID0gQGNvbXB1dGVGaWx0ZXJMaW5rQW5jaG9yKClcblxuICAgICAgICAgICAgbXNncyA9IEBsb2dhcmVhLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ21pbmZvJylcblxuICAgICAgICAgICAgZm9yIG1zZyBpbiBtc2dzXG4gICAgICAgICAgICAgICAgbXNnLnN0eWxlLmRpc3BsYXkgPSBAY29tcHV0ZUluZm9EaXNwbGF5U3R5bGUoKVxuXG4gICAgICAgICAgICBAc2Nyb2xsVG9Cb3R0b20oKVxuICAgICAgICAsIGZhbHNlKVxuXG4gICAgICAgIHJldHVybiBsaW5rXG5cbiAgICBtYWtlU2F2ZUxpbms6IC0+XG4gICAgICAgIGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJylcbiAgICAgICAgbGluay5ocmVmID0gJyMnXG4gICAgICAgIGxpbmsuZG93bmxvYWQgPSAnV2lraU1vbmtleS5sb2cnXG4gICAgICAgIGxpbmsuaW5uZXJIVE1MID0gJ1tzYXZlIGxvZ10nXG4gICAgICAgIGxpbmsuaWQgPSAnV2lraU1vbmtleUxvZy1TYXZlJ1xuXG4gICAgICAgIGxpbmsuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsID0+XG4gICAgICAgICAgICBsaW5rLmhyZWYgPSAnZGF0YTp0ZXh0L3BsYWluO2NoYXJzZXQ9dXRmLTgsJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoQGNvbXBvc2VTYXZlTG9nVGV4dCgpKVxuICAgICAgICAgICAgbGluay5kb3dubG9hZCA9IEBjb21wb3NlU2F2ZUxvZ0ZpbGVuYW1lKClcbiAgICAgICAgLCBmYWxzZSlcblxuICAgICAgICByZXR1cm4gbGlua1xuXG4gICAgY2xhc3Nlc1RvTGV2ZWxzID1cbiAgICAgICAgJ21oaWRkZW4nOiAnSEROJ1xuICAgICAgICAnbWpzb24nOiAnSlNOJ1xuICAgICAgICAnbWRlYnVnJzogJ0RCRydcbiAgICAgICAgJ21pbmZvJzogJ0lORidcbiAgICAgICAgJ213YXJuaW5nJzogJ1dSTidcbiAgICAgICAgJ21lcnJvcic6ICdFUlInXG5cbiAgICBjb21wb3NlU2F2ZUxvZ1RleHQ6IC0+XG4gICAgICAgIGRpdnMgPSBAbG9nYXJlYS5nZXRFbGVtZW50c0J5VGFnTmFtZSgnZGl2JylcbiAgICAgICAgdGV4dCA9ICcnXG5cbiAgICAgICAgZm9yIGRpdiBpbiBkaXZzXG4gICAgICAgICAgICBwcyA9IGRpdi5nZXRFbGVtZW50c0J5VGFnTmFtZSgncCcpXG4gICAgICAgICAgICB0c3RhbXAgPSBwc1swXS5pbm5lckhUTUxcbiAgICAgICAgICAgIGxldmVsID0gY2xhc3Nlc1RvTGV2ZWxzW2Rpdi5jbGFzc05hbWVdXG4gICAgICAgICAgICBtZXNzYWdlID0gcHNbMV0uaW5uZXJIVE1MXG5cbiAgICAgICAgICAgIHRleHQgKz0gdHN0YW1wICsgJ1xcdCcgKyBsZXZlbCArICdcXHQnICsgbWVzc2FnZSArICdcXG4nXG5cbiAgICAgICAgcmV0dXJuIHRleHRcblxuICAgIGNvbXBvc2VTYXZlTG9nRmlsZW5hbWU6IC0+XG4gICAgICAgIGRhdGUgPSBuZXcgRGF0ZSgpXG4gICAgICAgIHJldHVybiAnV2lraU1vbmtleS0nICsgZGF0ZS5nZXRGdWxsWWVhcigpICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFN0ci5wYWRMZWZ0KFN0cmluZyhkYXRlLmdldE1vbnRoKCkgKyAxKSwgJzAnLCAyKSArXG4gICAgICAgICAgICAgICAgICAgICAgICBTdHIucGFkTGVmdChTdHJpbmcoZGF0ZS5nZXREYXRlKCkpLCAnMCcsIDIpICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFN0ci5wYWRMZWZ0KFN0cmluZyhkYXRlLmdldEhvdXJzKCkpLCAnMCcsIDIpICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFN0ci5wYWRMZWZ0KFN0cmluZyhkYXRlLmdldE1pbnV0ZXMoKSksICcwJywgMikgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJy5sb2cnXG5cbiAgICBjb21wdXRlSW5mb0Rpc3BsYXlTdHlsZTogLT5cbiAgICAgICAgcmV0dXJuIGlmIEBfY3VycmVudEluZm9EaXNwbGF5U3RhdGUgdGhlbiAnZmxleCcgZWxzZSAnbm9uZSdcblxuICAgIGNvbXB1dGVGaWx0ZXJMaW5rQW5jaG9yOiAtPlxuICAgICAgICByZXR1cm4gaWYgQF9jdXJyZW50SW5mb0Rpc3BsYXlTdGF0ZSB0aGVuICdbaGlkZSBpbmZvIG1lc3NhZ2VzXScgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnW3Nob3cgaW5mbyBtZXNzYWdlc10nXG5cbiAgICBzY3JvbGxUb0JvdHRvbTogLT5cbiAgICAgICAgQGxvZ2FyZWEuc2Nyb2xsVG9wID0gQGxvZ2FyZWEuc2Nyb2xsSGVpZ2h0IC0gQGxvZ2FyZWEuY2xpZW50SGVpZ2h0XG5cbiAgICBhcHBlbmRNZXNzYWdlOiAodGV4dCwgdHlwZSkgLT5cbiAgICAgICAgdHN0YW1wID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncCcpXG4gICAgICAgIHRzdGFtcC5jbGFzc05hbWUgPSAndGltZXN0YW1wJ1xuICAgICAgICBub3cgPSBuZXcgRGF0ZSgpXG4gICAgICAgIHRzdGFtcC5pbm5lckhUTUwgPSBub3cudG9Mb2NhbGVUaW1lU3RyaW5nKClcblxuICAgICAgICBtc2cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwJylcbiAgICAgICAgbXNnLmNsYXNzTmFtZSA9ICdtZXNzYWdlJ1xuICAgICAgICAjIERvIG5vdCBhbGxvdyB0aGUgZW1wdHkgc3RyaW5nLCBvdGhlcndpc2UgdGhlIHJlc3VsdGluZyBodG1sIGVsZW1lbnRcbiAgICAgICAgIyBtYXkgbm90IGJlIHJlbmRlcmVkIGJ5IHRoZSBicm93c2VyXG4gICAgICAgIG1zZy5pbm5lckhUTUwgPSBpZiB0ZXh0IHRoZW4gdGV4dCBlbHNlIFwiIFwiXG5cbiAgICAgICAgbGluZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgICAgIGxpbmUuYXBwZW5kQ2hpbGQodHN0YW1wKVxuICAgICAgICBsaW5lLmFwcGVuZENoaWxkKG1zZylcbiAgICAgICAgbGluZS5jbGFzc05hbWUgPSB0eXBlXG5cbiAgICAgICAgaWYgdHlwZSA9PSAnbWluZm8nXG4gICAgICAgICAgICBsaW5lLnN0eWxlLmRpc3BsYXkgPSBAY29tcHV0ZUluZm9EaXNwbGF5U3R5bGUoKVxuXG4gICAgICAgICMgVGhpcyB0ZXN0IG11c3QgYmUgZG9uZSAqYmVmb3JlKiBhcHBlbmRpbmcgdGhlIG5ldyBsaW5lXG4gICAgICAgIHRlc3QgPSBAbG9nYXJlYS5zY3JvbGxUb3AgKyBAbG9nYXJlYS5jbGllbnRIZWlnaHQgPT0gXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQGxvZ2FyZWEuc2Nyb2xsSGVpZ2h0XG5cbiAgICAgICAgQGxvZ2FyZWEuYXBwZW5kQ2hpbGQobGluZSlcblxuICAgICAgICBpZiB0ZXN0XG4gICAgICAgICAgICBAc2Nyb2xsVG9Cb3R0b20oKVxuXG4gICAgbG9nSGlkZGVuOiAodGV4dCkgLT5cbiAgICAgICAgQGFwcGVuZE1lc3NhZ2UodGV4dCwgJ21oaWRkZW4nKVxuXG4gICAgbG9nSnNvbjogKGNvbXBvbmVudCwgZGF0YSkgLT5cbiAgICAgICAgdGV4dCA9IEpTT04uc3RyaW5naWZ5KHtcImNvbXBvbmVudFwiOiBjb21wb25lbnQsIFwiZGF0YVwiOiBkYXRhfSlcbiAgICAgICAgQGFwcGVuZE1lc3NhZ2UodGV4dCwgJ21qc29uJylcblxuICAgIGxvZ0RlYnVnOiAodGV4dCkgLT5cbiAgICAgICAgQGFwcGVuZE1lc3NhZ2UodGV4dCwgJ21kZWJ1ZycpXG5cbiAgICBsb2dJbmZvOiAodGV4dCkgLT5cbiAgICAgICAgQGFwcGVuZE1lc3NhZ2UodGV4dCwgJ21pbmZvJylcblxuICAgIGxvZ1dhcm5pbmc6ICh0ZXh0KSAtPlxuICAgICAgICBAYXBwZW5kTWVzc2FnZSh0ZXh0LCAnbXdhcm5pbmcnKVxuXG4gICAgbG9nRXJyb3I6ICh0ZXh0KSAtPlxuICAgICAgICBAYXBwZW5kTWVzc2FnZSh0ZXh0LCAnbWVycm9yJylcblxuICAgIGxpbmtUb1BhZ2U6ICh1cmwsIGFuY2hvcikgLT5cbiAgICAgICAgIyBNdXN0IHJldHVybiBhIHN0cmluZywgbm90IGEgRE9NIGVsZW1lbnRcbiAgICAgICAgcmV0dXJuIFwiPGEgaHJlZj1cXFwiXCIgKyB1cmwgKyBcIlxcXCI+XCIgKyBhbmNob3IgKyBcIjwvYT5cIlxuXG4gICAgbGlua1RvV2lraVBhZ2U6ICh0aXRsZSwgYW5jaG9yKSAtPlxuICAgICAgICAjIE11c3QgcmV0dXJuIGEgc3RyaW5nLCBub3QgYSBET00gZWxlbWVudFxuICAgICAgICAjIFVzZSBhbiBhYnNvbHV0ZSAoZnVsbCkgVVJMIHNvIGl0IHdpbGwgYmUgdXNhYmxlIGluIHRoZSBkb3dubG9hZGFibGVcbiAgICAgICAgIyAgIHZlcnNpb24gb2YgdGhlIGxvZ1xuICAgICAgICAjIERvICpub3QqIHVzZSBlbmNvZGVVUklDb21wb25lbnQodGl0bGUpIGJlY2F1c2UgdGhlIHBhc3NlZCB0aXRsZSBtYXlcbiAgICAgICAgIyAgIGhhdmUgYSBmcmFnbWVudCBvciBhIHF1ZXJ5IHN0cmluZyB0aGF0IHdvdWxkIHRoZW4gYmUgZW5jb2RlZFxuICAgICAgICAjICAgTWVkaWFXaWtpIHNob3VsZCBiZSBhYmxlIHRvIGNvcnJlY3RseSByZXNvbHZlIHRoZSB0aXRsZSBhbnl3YXlcbiAgICAgICAgd2lraVVybHMgPSBAV00uTVcuZ2V0V2lraVVybHMoKVxuICAgICAgICByZXR1cm4gXCI8YSBocmVmPVxcXCJcIiArIHdpa2lVcmxzLnNob3J0ICsgdGl0bGUgKyBcIlxcXCI+XCIgKyBhbmNob3IgKyBcIjwvYT5cIlxuIiwiIyBXaWtpIE1vbmtleSAtIE1lZGlhV2lraSBib3QgYW5kIGVkaXRvci1hc3Npc3RhbnQgdXNlciBzY3JpcHRcbiMgQ29weXJpZ2h0IChDKSAyMDExIERhcmlvIEdpb3Zhbm5ldHRpIDxkZXZAZGFyaW9naW92YW5uZXR0aS5uZXQ+XG4jXG4jIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFdpa2kgTW9ua2V5LlxuI1xuIyBXaWtpIE1vbmtleSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4jIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4jIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4jIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4jXG4jIFdpa2kgTW9ua2V5IGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4jIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4jIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiMgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbiNcbiMgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiMgYWxvbmcgd2l0aCBXaWtpIE1vbmtleS4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cblxuSFRUUCA9IHJlcXVpcmUoJ0BreW5pa29zL21pc2MvZGlzdC9IVFRQJylcbk9iaiA9IHJlcXVpcmUoJ0BreW5pa29zL21pc2MvZGlzdC9PYmonKVxue0F9ID0gcmVxdWlyZSgnLi9saWJzJylcblxuXG5jbGFzcyBtb2R1bGUuZXhwb3J0c1xuICAgIGxvY2FsV2lraVBhdGhzID0gbnVsbFxuICAgIGxvY2FsV2lraVVybHMgPSBudWxsXG5cbiAgICBjb25zdHJ1Y3RvcjogKEBXTSkgLT5cbiAgICAgICAgQGFwaSA9IG5ldyBtdy5BcGkoKVxuXG4gICAgICAgIHdwYXRocyA9IEBfZ2V0V2lraVBhdGhzKGxvY2F0aW9uLmhyZWYpXG4gICAgICAgIGhvc3RuYW1lID0gd3BhdGhzWzBdXG5cbiAgICAgICAgQHVzZXJJbmZvID0gbnVsbFxuXG4gICAgICAgIGxvY2FsV2lraVBhdGhzID0gd3BhdGhzWzFdXG4gICAgICAgIGxvY2FsV2lraVVybHMgPSB7fVxuXG4gICAgICAgIGZvciBrZXkgb2YgbG9jYWxXaWtpUGF0aHNcbiAgICAgICAgICAgIGxvY2FsV2lraVVybHNba2V5XSA9IGhvc3RuYW1lICsgbG9jYWxXaWtpUGF0aHNba2V5XVxuXG4gICAgd2lraVBhdGhzID1cbiAgICAgICAga25vd246XG4gICAgICAgICAgICBcIl5odHRwcz86Ly9bXlxcLl0rXFwud2lraXBlZGlhXFwub3JnXCI6XG4gICAgICAgICAgICAgICAgc2hvcnQ6IFwiL3dpa2kvXCJcbiAgICAgICAgICAgICAgICBmdWxsOiBcIi93L2luZGV4LnBocFwiXG4gICAgICAgICAgICAgICAgYXBpOiBcIi93L2FwaS5waHBcIlxuICAgICAgICAgICAgXCJeaHR0cHM/Oi8vd2lraVxcLmFyY2hsaW51eFxcLm9yZ1wiOlxuICAgICAgICAgICAgICAgIHNob3J0OiBcIi9pbmRleC5waHAvXCJcbiAgICAgICAgICAgICAgICBmdWxsOiBcIi9pbmRleC5waHBcIlxuICAgICAgICAgICAgICAgIGFwaTogXCIvYXBpLnBocFwiXG4gICAgICAgICAgICBcIl5odHRwcz86Ly93aWtpXFwuYXJjaGxpbnV4XFwuZGVcIjpcbiAgICAgICAgICAgICAgICBzaG9ydDogXCIvdGl0bGUvXCJcbiAgICAgICAgICAgICAgICBmdWxsOiBcIi9pbmRleC5waHBcIlxuICAgICAgICAgICAgICAgIGFwaTogXCIvYXBpLnBocFwiXG4gICAgICAgICAgICBcIl5odHRwOi8vd2lraVxcLmFyY2hsaW51eFxcLmZyXCI6XG4gICAgICAgICAgICAgICAgc2hvcnQ6IFwiL1wiXG4gICAgICAgICAgICAgICAgZnVsbDogXCIvaW5kZXgucGhwXCJcbiAgICAgICAgICAgICAgICBhcGk6IFwiL2FwaS5waHBcIlxuICAgICAgICAgICAgXCJeaHR0cHM/Oi8vd2lraVxcLmFyY2hsaW51eFxcLmpwXCI6XG4gICAgICAgICAgICAgICAgc2hvcnQ6IFwiL2luZGV4LnBocC9cIlxuICAgICAgICAgICAgICAgIGZ1bGw6IFwiL2luZGV4LnBocFwiXG4gICAgICAgICAgICAgICAgYXBpOiBcIi9hcGkucGhwXCJcbiAgICAgICAgICAgIFwiXmh0dHA6Ly93aWtpXFwuYXJjaGxpbnV4XFwucm9cIjpcbiAgICAgICAgICAgICAgICBzaG9ydDogXCIvaW5kZXgucGhwL1wiXG4gICAgICAgICAgICAgICAgZnVsbDogXCIvaW5kZXgucGhwXCJcbiAgICAgICAgICAgICAgICBhcGk6IFwiL2FwaS5waHBcIlxuICAgICAgICAgICAgXCJeaHR0cDovL3dpa2lcXC5hcmNobGludXhcXC5pclwiOlxuICAgICAgICAgICAgICAgIHNob3J0OiBcIi9pbmRleC5waHAvXCJcbiAgICAgICAgICAgICAgICBmdWxsOiBcIi9pbmRleC5waHBcIlxuICAgICAgICAgICAgICAgIGFwaTogXCIvYXBpLnBocFwiXG4gICAgICAgIGRlZmF1bHRfOlxuICAgICAgICAgICAgc2hvcnQ6IFwiL2luZGV4LnBocD90aXRsZT1cIlxuICAgICAgICAgICAgZnVsbDogXCIvaW5kZXgucGhwXCJcbiAgICAgICAgICAgIGFwaTogXCIvYXBpLnBocFwiXG5cbiAgICBpbnRlcndpa2lGaXhlcyA9IFtcbiAgICAgICAgW1wiaHR0cHM6Ly93aWtpLmFyY2hsaW51eC5vcmcvaW5kZXgucGhwLyQxXyhcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJodHRwczovL3dpa2kuYXJjaGxpbnV4Lm9yZy9pbmRleC5waHAvJDElMjAoXCJdXG4gICAgXVxuXG4gICAgX2dldFdpa2lQYXRoczogKGhyZWYpIC0+XG4gICAgICAgICMgSXQncyBuZWNlc3NhcnkgdG8ga2VlcCB0aGlzIGZ1bmN0aW9uIGluIGEgcHJpdmF0ZSBhdHRyaWJ1dGUsXG4gICAgICAgICMgb3RoZXJ3aXNlIGxvY2FsV2lraVBhdGhzIGFuZCBsb2NhbFdpa2lVcmxzIGNhbm5vdCBiZSBpbml0aWFsaXplZFxuICAgICAgICBmb3IgciBvZiB3aWtpUGF0aHMua25vd25cbiAgICAgICAgICAgIHJlID0gbmV3IFJlZ0V4cChyLCBcImlcIilcbiAgICAgICAgICAgIG1hdGNoID0gcmUuZXhlYyhocmVmKVxuXG4gICAgICAgICAgICBpZiBtYXRjaFxuICAgICAgICAgICAgICAgIGhvc3RuYW1lID0gbWF0Y2hbMF1cbiAgICAgICAgICAgICAgICBwYXRocyA9IHt9XG5cbiAgICAgICAgICAgICAgICBmb3IgcCBvZiB3aWtpUGF0aHMua25vd25bcl1cbiAgICAgICAgICAgICAgICAgICAgcGF0aHNbcF0gPSB3aWtpUGF0aHMua25vd25bcl1bcF1cblxuICAgICAgICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgaWYgbm90IHBhdGhzXG4gICAgICAgICAgICBob3N0bmFtZSA9IEhUVFAuZ2V0VXJsTG9jYXRpb24oaHJlZikuaG9zdG5hbWVcbiAgICAgICAgICAgIHBhdGhzID0ge31cblxuICAgICAgICAgICAgZm9yIHAgb2Ygd2lraVBhdGhzLmRlZmF1bHRfXG4gICAgICAgICAgICAgICAgcGF0aHNbcF0gPSB3aWtpUGF0aHMuZGVmYXVsdF9bcF1cblxuICAgICAgICByZXR1cm4gW2hvc3RuYW1lLCBwYXRoc11cblxuICAgIGdldFdpa2lQYXRoczogKGhyZWYpIC0+XG4gICAgICAgIGlmIGhyZWZcbiAgICAgICAgICAgIHJldHVybiBAX2dldFdpa2lQYXRocyhocmVmKVsxXVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gbG9jYWxXaWtpUGF0aHNcblxuICAgIGxpbmtBcnRpY2xlOiAocGFnZSwgbGFiZWwpIC0+XG4gICAgICAgIHJldHVybiBBKHtocmVmOiBtdy51dGlsLmdldFVybChwYWdlKX0sIGxhYmVsIG9yIHBhZ2UpXG5cbiAgICBnZXRXaWtpVXJsczogKGhyZWYpIC0+XG4gICAgICAgIGlmIGhyZWZcbiAgICAgICAgICAgIHdwYXRocyA9IEBfZ2V0V2lraVBhdGhzKGhyZWYpXG4gICAgICAgICAgICBob3N0bmFtZSA9IHdwYXRoc1swXVxuICAgICAgICAgICAgcGF0aHMgPSB3cGF0aHNbMV1cblxuICAgICAgICAgICAgdXJscyA9IHt9XG5cbiAgICAgICAgICAgIGZvciBrZXkgb2YgcGF0aHNcbiAgICAgICAgICAgICAgICB1cmxzW2tleV0gPSBob3N0bmFtZSArIHBhdGhzW2tleV1cblxuICAgICAgICAgICAgcmV0dXJuIHVybHNcblxuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gbG9jYWxXaWtpVXJsc1xuXG4gICAgZ2V0VGl0bGVGcm9tV2lraVVybDogKHVybCkgLT5cbiAgICAgICAgdGl0bGUgPSBIVFRQLmdldFVSSVBhcmFtZXRlcnModXJsKS50aXRsZVxuXG4gICAgICAgICMgVGVzdCB0aGlzICpiZWZvcmUqIHRoZSBzaG9ydCBwYXRocywgaW4gZmFjdCBhIHNob3J0IHBhdGggbWF5IGp1c3QgYmVcbiAgICAgICAgIyB0aGUgZnVsbCBvbmUgd2l0aCB0aGUgXCJ0aXRsZVwiIHBhcmFtZXRlciBwcmUtYWRkZWRcbiAgICAgICAgaWYgbm90IHRpdGxlXG4gICAgICAgICAgICBwYXRobmFtZSA9IEhUVFAuZ2V0VXJsTG9jYXRpb24odXJsKS5wYXRobmFtZVxuXG4gICAgICAgICAgICBmb3IgciBvZiB3aWtpUGF0aHMua25vd25cbiAgICAgICAgICAgICAgICByZSA9IG5ldyBSZWdFeHAociwgXCJpXCIpXG4gICAgICAgICAgICAgICAgbWF0Y2ggPSByZS5leGVjKHVybClcblxuICAgICAgICAgICAgICAgIGlmIG1hdGNoXG4gICAgICAgICAgICAgICAgICAgIGlmIHBhdGhuYW1lLmluZGV4T2Yod2lraVBhdGhzLmtub3duW3JdLnNob3J0KSA9PSAwXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZSA9IHBhdGhuYW1lLnN1YnN0cih3aWtpUGF0aHMua25vd25bcl1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zaG9ydC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlID0gZmFsc2VcblxuICAgICAgICAgICAgICAgICAgICBicmVha1xuXG4gICAgICAgICAgICBpZiBub3QgdGl0bGVcbiAgICAgICAgICAgICAgICBpZiBwYXRobmFtZS5pbmRleE9mKHdpa2lQYXRocy5kZWZhdWx0Xy5zaG9ydCkgPT0gMFxuICAgICAgICAgICAgICAgICAgICB0aXRsZSA9IHBhdGhuYW1lLnN1YnN0cih3aWtpUGF0aHMuZGVmYXVsdF8uc2hvcnQubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdGl0bGUgPSBmYWxzZVxuXG4gICAgICAgIHJldHVybiB0aXRsZVxuXG4gICAgZmFpbGVkUXVlcnlFcnJvcjogKHVybCkgLT5cbiAgICAgICAgaWYgdXJsXG4gICAgICAgICAgICByZXR1cm4gXCJGYWlsZWQgcXVlcnk6ICN7QFdNLkxvZy5saW5rVG9QYWdlKHVybCwgdXJsKX1cIlxuICAgICAgICByZXR1cm4gXCJGYWlsZWQgcXVlcnlcIlxuXG4gICAgY2FsbEFQSUdldDogKHBhcmFtcywgY2FsbCwgY2FsbEFyZ3MsIGNhbGxFcnJvcikgLT5cbiAgICAgICAgcGFyYW1zLmZvcm1hdCA9IFwianNvblwiXG5cbiAgICAgICAgcmV0dXJuIEBhcGkuZ2V0KHBhcmFtcylcbiAgICAgICAgLmRvbmUoKGRhdGEsIHRleHRTdGF0dXMsIGpxWEhSKSA9PlxuICAgICAgICAgICAgaWYgY2FsbFxuICAgICAgICAgICAgICAgIGNhbGwoZGF0YSwgY2FsbEFyZ3MpXG4gICAgICAgICkuZmFpbCgoanFYSFIsIHRleHRTdGF0dXMsIGVycm9yVGhyb3duKSA9PlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihqcVhIUiwgdGV4dFN0YXR1cywgZXJyb3JUaHJvd24pXG4gICAgICAgICAgICBAV00uTG9nLmxvZ0Vycm9yKEBmYWlsZWRRdWVyeUVycm9yKCkpXG4gICAgICAgICAgICBpZiBjb25maXJtKFwiV2lraSBNb25rZXkgZXJyb3I6IEZhaWxlZCBxdWVyeVxcblxcbkRvIHlvdSB3YW50IFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwidG8gcmV0cnk/XCIpXG4gICAgICAgICAgICAgICAgQFdNLkxvZy5sb2dJbmZvKFwiUmV0cnlpbmcgLi4uXCIpXG4gICAgICAgICAgICAgICAgQGNhbGxBUElHZXQocGFyYW1zLCBjYWxsLCBjYWxsQXJncywgY2FsbEVycm9yKVxuICAgICAgICAgICAgZWxzZSBpZiBjYWxsRXJyb3JcbiAgICAgICAgICAgICAgICBjYWxsRXJyb3IoY2FsbEFyZ3MpXG4gICAgICAgIClcblxuICAgIGNhbGxBUElQb3N0OiAocGFyYW1zLCBjYWxsLCBjYWxsQXJncywgY2FsbEVycm9yKSAtPlxuICAgICAgICBwYXJhbXMuZm9ybWF0ID0gXCJqc29uXCJcblxuICAgICAgICByZXR1cm4gQGFwaS5wb3N0KHBhcmFtcylcbiAgICAgICAgLmRvbmUoKGRhdGEsIHRleHRTdGF0dXMsIGpxWEhSKSA9PlxuICAgICAgICAgICAgaWYgY2FsbFxuICAgICAgICAgICAgICAgIGNhbGwoZGF0YSwgY2FsbEFyZ3MpXG4gICAgICAgICkuZmFpbCgoanFYSFIsIHRleHRTdGF0dXMsIGVycm9yVGhyb3duKSA9PlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihqcVhIUiwgdGV4dFN0YXR1cywgZXJyb3JUaHJvd24pXG4gICAgICAgICAgICBAV00uTG9nLmxvZ0Vycm9yKEBmYWlsZWRRdWVyeUVycm9yKCkpXG4gICAgICAgICAgICBpZiBjb25maXJtKFwiV2lraSBNb25rZXkgZXJyb3I6IEZhaWxlZCBxdWVyeVxcblxcbkRvIHlvdSB3YW50IFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwidG8gcmV0cnk/XCIpXG4gICAgICAgICAgICAgICAgQFdNLkxvZy5sb2dJbmZvKFwiUmV0cnlpbmcgLi4uXCIpXG4gICAgICAgICAgICAgICAgQGNhbGxBUElQb3N0KHBhcmFtcywgY2FsbCwgY2FsbEFyZ3MsIGNhbGxFcnJvcilcblxuICAgICAgICAgICAgZWxzZSBpZiBjYWxsRXJyb3JcbiAgICAgICAgICAgICAgICBjYWxsRXJyb3IoY2FsbEFyZ3MpXG4gICAgICAgIClcblxuICAgIGNhbGxRdWVyeTogKHBhcmFtcywgY2FsbCwgY2FsbEFyZ3MsIGNhbGxFcnJvcikgLT5cbiAgICAgICAgcGFyYW1zLmFjdGlvbiA9IFwicXVlcnlcIlxuXG4gICAgICAgIHRyeVxuICAgICAgICAgICAgcmVzID0gYXdhaXQgQGNhbGxBUElHZXQocGFyYW1zKVxuICAgICAgICBjYXRjaCBlcnJvclxuICAgICAgICAgICAgaWYgY2FsbEVycm9yXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxFcnJvcihjYWxsQXJncylcbiAgICAgICAgICAgIHRocm93IGVycm9yXG5cbiAgICAgICAgcGFnZSA9IE9iai5nZXRGaXJzdEl0ZW0ocmVzLnF1ZXJ5LnBhZ2VzKVxuXG4gICAgICAgIGlmIGNhbGxcbiAgICAgICAgICAgIHJldHVybiBjYWxsKHBhZ2UsIGNhbGxBcmdzKVxuICAgICAgICByZXR1cm4gcGFnZVxuXG4gICAgY2FsbFF1ZXJ5RWRpdDogKHRpdGxlLCBjYWxsLCBjYWxsQXJncykgLT5cbiAgICAgICAgcGFnZSA9IGF3YWl0IEBjYWxsUXVlcnkoXG4gICAgICAgICAgICBwcm9wOiBcImluZm98cmV2aXNpb25zXCJcbiAgICAgICAgICAgIHJ2cHJvcDogXCJjb250ZW50fHRpbWVzdGFtcFwiXG4gICAgICAgICAgICBpbnRva2VuOiBcImVkaXRcIlxuICAgICAgICAgICAgdGl0bGVzOiB0aXRsZVxuICAgICAgICApXG5cbiAgICAgICAgc291cmNlID0gcGFnZS5yZXZpc2lvbnNbMF1bXCIqXCJdXG4gICAgICAgIHRpbWVzdGFtcCA9IHBhZ2UucmV2aXNpb25zWzBdLnRpbWVzdGFtcFxuICAgICAgICBlZGl0dG9rZW4gPSBwYWdlLmVkaXR0b2tlblxuXG4gICAgICAgIGlmIGNhbGxcbiAgICAgICAgICAgIHJldHVybiBjYWxsKHRpdGxlLCBzb3VyY2UsIHRpbWVzdGFtcCwgZWRpdHRva2VuLCBjYWxsQXJncylcbiAgICAgICAgcmV0dXJuIHtzb3VyY2UsIHRpbWVzdGFtcCwgZWRpdHRva2VufVxuXG4gICAgZ2V0VXNlckluZm86IChjYWxsKSAtPlxuICAgICAgICBzdG9yZUluZm8gPSAocmVzLCBjYWxsKSA9PlxuICAgICAgICAgICAgQHVzZXJJbmZvID0gcmVzXG4gICAgICAgICAgICBjYWxsKClcblxuICAgICAgICBpZiBub3QgQHVzZXJJbmZvXG4gICAgICAgICAgICBwYXJzID1cbiAgICAgICAgICAgICAgICBhY3Rpb246IFwicXVlcnlcIlxuICAgICAgICAgICAgICAgIG1ldGE6IFwidXNlcmluZm9cIlxuICAgICAgICAgICAgICAgIHVpcHJvcDogXCJncm91cHNcIlxuICAgICAgICAgICAgQGNhbGxBUElHZXQocGFycywgc3RvcmVJbmZvLCBjYWxsLCBudWxsKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICBjYWxsKClcblxuICAgIGlzTG9nZ2VkSW46IChjYWxsLCBhcmdzKSAtPlxuICAgICAgICBAZ2V0VXNlckluZm8oID0+XG4gICAgICAgICAgICB0ZXN0ID0gQHVzZXJJbmZvLnF1ZXJ5LnVzZXJpbmZvLmlkICE9IDBcbiAgICAgICAgICAgIGNhbGwodGVzdCwgYXJncylcbiAgICAgICAgKVxuXG4gICAgZ2V0VXNlck5hbWU6IChjYWxsLCBhcmdzKSAtPlxuICAgICAgICBAZ2V0VXNlckluZm8oID0+XG4gICAgICAgICAgICBjYWxsKEB1c2VySW5mby5xdWVyeS51c2VyaW5mby5uYW1lLCBhcmdzKVxuICAgICAgICApXG5cbiAgICBpc1VzZXJCb3Q6IChjYWxsLCBhcmdzKSAtPlxuICAgICAgICBAZ2V0VXNlckluZm8oID0+XG4gICAgICAgICAgICBncm91cHMgPSBAdXNlckluZm8ucXVlcnkudXNlcmluZm8uZ3JvdXBzXG4gICAgICAgICAgICByZXMgPSBncm91cHMuaW5kZXhPZihcImJvdFwiKSA+IC0xXG4gICAgICAgICAgICBjYWxsKHJlcywgYXJncylcbiAgICAgICAgKVxuXG4gICAgZ2V0QmFja2xpbmtzOiAoYmx0aXRsZSwgYmxuYW1lc3BhY2UsIGNhbGwsIGNhbGxBcmdzKSAtPlxuICAgICAgICBxdWVyeSA9XG4gICAgICAgICAgICBhY3Rpb246IFwicXVlcnlcIlxuICAgICAgICAgICAgbGlzdDogXCJiYWNrbGlua3NcIlxuICAgICAgICAgICAgYmx0aXRsZTogYmx0aXRsZVxuICAgICAgICAgICAgYmxsaW1pdDogNTAwXG5cbiAgICAgICAgaWYgYmxuYW1lc3BhY2VcbiAgICAgICAgICAgIHF1ZXJ5LmJsbmFtZXNwYWNlID0gYmxuYW1lc3BhY2VcblxuICAgICAgICBAX2dldEJhY2tsaW5rc0NvbnRpbnVlKHF1ZXJ5LCBjYWxsLCBjYWxsQXJncywgW10pXG5cbiAgICBfZ2V0QmFja2xpbmtzQ29udGludWU6IChxdWVyeSwgY2FsbCwgY2FsbEFyZ3MsIGJhY2tsaW5rcykgLT5cbiAgICAgICAgQGNhbGxBUElHZXQocXVlcnksIChyZXMsIGFyZ3MpID0+XG4gICAgICAgICAgICBiYWNrbGlua3MgPSBiYWNrbGlua3MuY29uY2F0KHJlcy5xdWVyeS5iYWNrbGlua3MpXG4gICAgICAgICAgICBpZiByZXNbXCJxdWVyeS1jb250aW51ZVwiXVxuICAgICAgICAgICAgICAgIHF1ZXJ5LmJsY29udGludWUgPSByZXNbXCJxdWVyeS1jb250aW51ZVwiXS5iYWNrbGlua3MuYmxjb250aW51ZVxuICAgICAgICAgICAgICAgIEBfZ2V0QmFja2xpbmtzQ29udGludWUocXVlcnksIGNhbGwsIGFyZ3MsIGJhY2tsaW5rcylcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBjYWxsKGJhY2tsaW5rcywgYXJncylcbiAgICAgICAgLFxuICAgICAgICBjYWxsQXJncywgbnVsbClcblxuICAgIGdldExhbmdsaW5rczogKHRpdGxlLCBpd21hcCwgY2FsbCwgY2FsbEFyZ3MpIC0+XG4gICAgICAgIHF1ZXJ5ID1cbiAgICAgICAgICAgIGFjdGlvbjogXCJxdWVyeVwiXG4gICAgICAgICAgICBwcm9wOiBcImxhbmdsaW5rc1wiXG4gICAgICAgICAgICB0aXRsZXM6IHRpdGxlXG4gICAgICAgICAgICBsbGxpbWl0OiA1MDBcbiAgICAgICAgICAgIGxsdXJsOiBcIjFcIlxuICAgICAgICAgICAgcmVkaXJlY3RzOiBcIjFcIlxuXG4gICAgICAgIGlmIGl3bWFwXG4gICAgICAgICAgICBxdWVyeS5tZXRhID0gXCJzaXRlaW5mb1wiXG4gICAgICAgICAgICBxdWVyeS5zaXByb3AgPSBcImludGVyd2lraW1hcFwiXG4gICAgICAgICAgICBxdWVyeS5zaWZpbHRlcml3ID0gXCJsb2NhbFwiXG5cbiAgICAgICAgQF9nZXRMYW5nbGlua3NDb250aW51ZShxdWVyeSwgY2FsbCwgY2FsbEFyZ3MsIFtdLCBudWxsKVxuXG4gICAgX2dldExhbmdsaW5rc0NvbnRpbnVlOiAocXVlcnksIGNhbGwsIGNhbGxBcmdzLCBsYW5nbGlua3MsIGl3bWFwKSAtPlxuICAgICAgICBAY2FsbEFQSUdldChxdWVyeSwgKHJlcywgYXJncykgPT5cbiAgICAgICAgICAgIHBhZ2UgPSBPYmouZ2V0Rmlyc3RJdGVtKHJlcy5xdWVyeS5wYWdlcylcbiAgICAgICAgICAgIGxhbmdsaW5rcyA9IGxhbmdsaW5rcy5jb25jYXQocGFnZS5sYW5nbGlua3MpXG5cbiAgICAgICAgICAgIGlmIHJlcy5xdWVyeS5pbnRlcndpa2ltYXBcbiAgICAgICAgICAgICAgICBpd21hcCA9IHJlcy5xdWVyeS5pbnRlcndpa2ltYXBcblxuICAgICAgICAgICAgaWYgcXVlcnkubWV0YVxuICAgICAgICAgICAgICAgIGRlbGV0ZSBxdWVyeS5tZXRhXG4gICAgICAgICAgICAgICAgZGVsZXRlIHF1ZXJ5LnNpcHJvcFxuICAgICAgICAgICAgICAgIGRlbGV0ZSBxdWVyeS5zaWZpbHRlcml3XG5cbiAgICAgICAgICAgIGlmIHJlc1tcInF1ZXJ5LWNvbnRpbnVlXCJdXG4gICAgICAgICAgICAgICAgcXVlcnkubGxjb250aW51ZSA9IHJlc1tcInF1ZXJ5LWNvbnRpbnVlXCJdLmxhbmdsaW5rcy5sbGNvbnRpbnVlXG4gICAgICAgICAgICAgICAgQF9nZXRMYW5nbGlua3NDb250aW51ZShxdWVyeSwgY2FsbCwgYXJncywgbGFuZ2xpbmtzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXdtYXApXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgY2FsbChsYW5nbGlua3MsIGl3bWFwLCBhcmdzKVxuICAgICAgICAsXG4gICAgICAgIGNhbGxBcmdzLCBudWxsKVxuXG4gICAgZ2V0SW50ZXJ3aWtpTWFwOiAodGl0bGUpIC0+XG4gICAgICAgIHJldHVybiBAY2FsbEFQSUdldCh7XG4gICAgICAgICAgICBhY3Rpb246IFwicXVlcnlcIlxuICAgICAgICAgICAgbWV0YTogXCJzaXRlaW5mb1wiXG4gICAgICAgICAgICBzaXByb3A6IFwiaW50ZXJ3aWtpbWFwXCJcbiAgICAgICAgfSlcblxuICAgIGdldExvY2FsSW50ZXJ3aWtpTWFwOiAodGl0bGUsIGNhbGwsIGNhbGxBcmdzKSAtPlxuICAgICAgICBAY2FsbEFQSUdldChcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBhY3Rpb246IFwicXVlcnlcIlxuICAgICAgICAgICAgICAgIG1ldGE6IFwic2l0ZWluZm9cIlxuICAgICAgICAgICAgICAgIHNpcHJvcDogXCJpbnRlcndpa2ltYXBcIlxuICAgICAgICAgICAgICAgIHNpZmlsdGVyaXc6IFwibG9jYWxcIlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKHJlcywgYXJncykgPT5cbiAgICAgICAgICAgICAgICBjYWxsKHJlcy5xdWVyeS5pbnRlcndpa2ltYXAsIGFyZ3MpXG4gICAgICAgICAgICBjYWxsQXJnc1xuICAgICAgICAgICAgbnVsbFxuICAgICAgICApXG5cbiAgICBmaXhJbnRlcndpa2lVcmw6ICh1cmwpIC0+XG4gICAgICAgIGZvciBmIGluIFswLi4uaW50ZXJ3aWtpRml4ZXMubGVuZ3RoXVxuICAgICAgICAgICAgZnVybCA9IHVybC5yZXBsYWNlKGludGVyd2lraUZpeGVzW2ZdWzBdLCBpbnRlcndpa2lGaXhlc1tmXVsxXSlcblxuICAgICAgICAgICAgaWYgZnVybCAhPSB1cmxcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVybFxuXG4gICAgICAgICMgUmV0dXJuIHRoZSB1bm1vZGlmaWVkIHVybCBpZiBubyByZXBsYWNlbWVudCBoYXMgYmVlbiBkb25lXG4gICAgICAgIHJldHVybiB1cmxcblxuICAgIGdldFNwZWNpYWxMaXN0OiAocXBwYWdlLCBzaXByb3ApIC0+XG4gICAgICAgIHF1ZXJ5ID1cbiAgICAgICAgICAgIGFjdGlvbjogXCJxdWVyeVwiXG4gICAgICAgICAgICBsaXN0OiBcInF1ZXJ5cGFnZVwiXG4gICAgICAgICAgICBxcHBhZ2U6IHFwcGFnZVxuICAgICAgICAgICAgcXBsaW1pdDogNTAwXG5cbiAgICAgICAgaWYgc2lwcm9wXG4gICAgICAgICAgICBxdWVyeS5tZXRhID0gXCJzaXRlaW5mb1wiXG4gICAgICAgICAgICBxdWVyeS5zaXByb3AgPSBzaXByb3BcblxuICAgICAgICByZXN1bHRzID0gW11cbiAgICAgICAgc2l0ZWluZm8gPSB7fVxuXG4gICAgICAgIGxvb3BcbiAgICAgICAgICAgIHJlcyA9IGF3YWl0IEBjYWxsQVBJR2V0KHF1ZXJ5KVxuICAgICAgICAgICAgcmVzdWx0cyA9IHJlc3VsdHMuY29uY2F0KHJlcy5xdWVyeS5xdWVyeXBhZ2UucmVzdWx0cylcblxuICAgICAgICAgICAgZm9yIGtleSwgaW5mbyBvZiByZXMucXVlcnkgd2hlbiBrZXkgIT0gXCJxdWVyeXBhZ2VcIlxuICAgICAgICAgICAgICAgIHNpdGVpbmZvW2tleV0gPSBpbmZvXG5cbiAgICAgICAgICAgIGRlbGV0ZSBxdWVyeS5tZXRhXG4gICAgICAgICAgICBkZWxldGUgcXVlcnkuc2lwcm9wXG5cbiAgICAgICAgICAgIGlmIHJlc1tcInF1ZXJ5LWNvbnRpbnVlXCJdXG4gICAgICAgICAgICAgICAgcXVlcnkucXBvZmZzZXQgPSByZXNbXCJxdWVyeS1jb250aW51ZVwiXS5xdWVyeXBhZ2UucXBvZmZzZXRcbiAgICAgICAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgICAgICByZXR1cm4ge3Jlc3VsdHMsIHNpdGVpbmZvfVxuXG4gICAgZ2V0VXNlckNvbnRyaWJzOiAodWN1c2VyLCB1Y3N0YXJ0LCB1Y2VuZCwgY2FsbCwgY2FsbEFyZ3MpIC0+XG4gICAgICAgIHF1ZXJ5ID1cbiAgICAgICAgICAgIGFjdGlvbjogXCJxdWVyeVwiXG4gICAgICAgICAgICBsaXN0OiBcInVzZXJjb250cmlic1wiXG4gICAgICAgICAgICB1Y3VzZXI6IHVjdXNlclxuICAgICAgICAgICAgdWNwcm9wOiBcIlwiXG4gICAgICAgICAgICB1Y3N0YXJ0OiB1Y3N0YXJ0XG4gICAgICAgICAgICB1Y2VuZDogdWNlbmRcbiAgICAgICAgICAgIHVjbGltaXQ6IDUwMFxuXG4gICAgICAgIEBfZ2V0VXNlckNvbnRyaWJzQ29udGludWUocXVlcnksIGNhbGwsIGNhbGxBcmdzLCBbXSlcblxuICAgIF9nZXRVc2VyQ29udHJpYnNDb250aW51ZTogKHF1ZXJ5LCBjYWxsLCBjYWxsQXJncywgcmVzdWx0cykgLT5cbiAgICAgICAgQGNhbGxBUElHZXQocXVlcnksIChyZXMsIGFyZ3MpID0+XG4gICAgICAgICAgICByZXN1bHRzID0gcmVzdWx0cy5jb25jYXQocmVzLnF1ZXJ5LnVzZXJjb250cmlicylcblxuICAgICAgICAgICAgaWYgcmVzW1wicXVlcnktY29udGludWVcIl1cbiAgICAgICAgICAgICAgICBxdWVyeS51Y2NvbnRpbnVlID0gcmVzW1wicXVlcnktY29udGludWVcIl0udXNlcmNvbnRyaWJzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnVjY29udGludWVcbiAgICAgICAgICAgICAgICBAX2dldFVzZXJDb250cmlic0NvbnRpbnVlKHF1ZXJ5LCBjYWxsLCBhcmdzLCByZXN1bHRzKVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGNhbGwocmVzdWx0cywgYXJncylcbiAgICAgICAgLFxuICAgICAgICBjYWxsQXJncywgbnVsbClcbiIsIiMgV2lraSBNb25rZXkgLSBNZWRpYVdpa2kgYm90IGFuZCBlZGl0b3ItYXNzaXN0YW50IHVzZXIgc2NyaXB0XG4jIENvcHlyaWdodCAoQykgMjAxMSBEYXJpbyBHaW92YW5uZXR0aSA8ZGV2QGRhcmlvZ2lvdmFubmV0dGkubmV0PlxuI1xuIyBUaGlzIGZpbGUgaXMgcGFydCBvZiBXaWtpIE1vbmtleS5cbiNcbiMgV2lraSBNb25rZXkgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuIyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuIyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuIyAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuI1xuIyBXaWtpIE1vbmtleSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuIyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuIyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4jIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4jXG4jIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4jIGFsb25nIHdpdGggV2lraSBNb25rZXkuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG5cbkNTUyA9IHJlcXVpcmUoJ0BreW5pa29zL21pc2MvZGlzdC9DU1MnKVxuXG5cbmNsYXNzIG1vZHVsZS5leHBvcnRzXG4gICAgY29uc3RydWN0b3I6IChAV00pIC0+XG5cbiAgICBfbWFrZVVJOiAoQHBhZ2VfdHlwZSwgcGx1Z2lucykgLT5cbiAgICAgICAgQ1NTLmFkZFN0eWxlRWxlbWVudChcbiAgICAgICAgICAgICAgICBcIiNXaWtpTW9ua2V5TWVudSBpbnB1dC5tYXJnaW4ge21hcmdpbjowIDAuMzNlbSAwLjMzZW0gMDt9XCIpXG5cbiAgICAgICAgbWFpbkRpdiA9ICQoJzxkaXYvPicpLmF0dHIoJ2lkJywgJ1dpa2lNb25rZXlNZW51JylcbiAgICAgICAgZ3JvdXBBY3Rpb25zID0ge31cblxuICAgICAgICBmb3IgUGx1Z2luIGluIHBsdWdpbnNcbiAgICAgICAgICAgIHBsdWdpbiA9IG5ldyBQbHVnaW4oQFdNKVxuICAgICAgICAgICAgcGx1Z2luSW5zdCA9IHBsdWdpbi5jb25mW1wiI3tAcGFnZV90eXBlfV9tZW51XCJdXG5cbiAgICAgICAgICAgICMgVGhpcyBhbGxvd3MgdG8gZGlzYWJsZSBhbiBlbnRyeSBieSBnaXZpbmcgaXQgYSBtZW51X2VudHJ5XG4gICAgICAgICAgICAjIHBhcmFtZXRlciB0aGF0IGV2YWx1YXRlcyB0byBmYWxzZVxuICAgICAgICAgICAgaWYgbm90IHBsdWdpbkluc3Qgb3Igbm90IHBsdWdpbkluc3QubGVuZ3RoXG4gICAgICAgICAgICAgICAgY29udGludWVcblxuICAgICAgICAgICAgaWYgcGx1Z2luLm1ha2VVSVxuICAgICAgICAgICAgICAgIGdyb3VwQWN0aW9uID0gW0B3YXJuSW5wdXROZWVkZWQsIHBsdWdpbl1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBncm91cEFjdGlvbiA9IFtAZXhlY3V0ZUVudHJ5QWN0aW9uLCBwbHVnaW5dXG5cbiAgICAgICAgICAgIHBsdWdpbkluc3QudW5zaGlmdChcIldpa2lNb25rZXlNZW51Um9vdFwiKVxuICAgICAgICAgICAgY3VycklkID0gZmFsc2VcblxuICAgICAgICAgICAgZm9yIG0gaW4gWzAuLi5wbHVnaW5JbnN0Lmxlbmd0aCAtIDFdXG4gICAgICAgICAgICAgICAgcGFyZW50SWQgPSBjdXJySWRcbiAgICAgICAgICAgICAgICBjdXJySWQgPSBwbHVnaW5JbnN0LnNsaWNlKDAsIG0gKyAxKS5qb2luKFwiLVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8gL2csIFwiX1wiKVxuXG4gICAgICAgICAgICAgICAgIyBJIGNhbid0IHNpbXBseSBkbyAkKFwiI1wiICsgY3VycklkKSBiZWNhdXNlIG1haW5EaXZcbiAgICAgICAgICAgICAgICAjIGhhc24ndCBiZWVuIGFkZGVkIHRvIHRoZSBET00gdHJlZSB5ZXRcbiAgICAgICAgICAgICAgICBtZW51U2VsID0gbWFpbkRpdi5jaGlsZHJlbihcImRpdltpZD0nI3tjdXJySWR9J11cIilcblxuICAgICAgICAgICAgICAgIGlmIG5vdCBtZW51U2VsLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICBjdXJyTWVudSA9ICQoXCI8ZGl2Lz5cIilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiaWRcIiwgY3VycklkKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmhpZGUoKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZFRvKG1haW5EaXYpXG5cbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBBY3Rpb25zW2N1cnJJZF0gPSBbXVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIG0gPiAwXG4gICAgICAgICAgICAgICAgICAgICAgICAjIEkgY2FuJ3Qgc2ltcGx5IGRvICQoXCIjXCIgKyBjdXJySWQpIGJlY2F1c2UgbWFpbkRpdlxuICAgICAgICAgICAgICAgICAgICAgICAgIyBoYXNuJ3QgYmVlbiBhZGRlZCB0byB0aGUgRE9NIHRyZWUgeWV0XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRNZW51ID0gbWFpbkRpdi5jaGlsZHJlbihcImRpdltpZD0nI3twYXJlbnRJZH0nXVwiKVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAkKCc8aW5wdXQvPicpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3R5cGUnLCAnYnV0dG9uJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudmFsKCc8JylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoJ21hcmdpbicpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNsaWNrKG1ha2VDaGFuZ2VNZW51KGN1cnJNZW51LCBwYXJlbnRNZW51KSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kVG8oY3Vyck1lbnUpXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICQoJzxpbnB1dC8+JylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigndHlwZScsICdidXR0b24nKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC52YWwocGx1Z2luSW5zdFttXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY2xpY2sobWFrZUdyb3VwQWN0aW9uKGdyb3VwQWN0aW9uc1tjdXJySWRdKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kVG8ocGFyZW50TWVudSlcblxuICAgICAgICAgICAgICAgICAgICAgICAgJCgnPGlucHV0Lz4nKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0eXBlJywgJ2J1dHRvbicpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnZhbCgnPicpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKCdtYXJnaW4nKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jbGljayhtYWtlQ2hhbmdlTWVudShwYXJlbnRNZW51LCBjdXJyTWVudSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZFRvKHBhcmVudE1lbnUpXG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBjdXJyTWVudSA9IG1lbnVTZWwuZmlyc3QoKVxuXG4gICAgICAgICAgICAgICAgZ3JvdXBBY3Rpb25zW2N1cnJJZF0ucHVzaChncm91cEFjdGlvbilcblxuICAgICAgICAgICAgZW50cnkgPSAkKFwiPGlucHV0Lz5cIilcbiAgICAgICAgICAgICAgICAuYXR0cigndHlwZScsICdidXR0b24nKVxuICAgICAgICAgICAgICAgIC52YWwocGx1Z2luSW5zdFtwbHVnaW5JbnN0Lmxlbmd0aCAtIDFdKVxuICAgICAgICAgICAgICAgIC5hZGRDbGFzcygnbWFyZ2luJylcbiAgICAgICAgICAgICAgICAuYXBwZW5kVG8oY3Vyck1lbnUpXG5cbiAgICAgICAgICAgIGlmIHBsdWdpbi5tYWtlVUlcbiAgICAgICAgICAgICAgICBlbnRyeS5jbGljayhAbWFrZUVudHJ5VUkoY3Vyck1lbnUsIHBsdWdpbikpXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgZW50cnkuY2xpY2soQG1ha2VFbnRyeUFjdGlvbihwbHVnaW4pKVxuXG4gICAgICAgIG1lbnVzID0gbWFpbkRpdi5jaGlsZHJlbigpXG5cbiAgICAgICAgaWYgbWVudXMubGVuZ3RoXG4gICAgICAgICAgICBleGVjQWxsID0gJCgnPGlucHV0Lz4nKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd0eXBlJywgJ2J1dHRvbicpXG4gICAgICAgICAgICAgICAgLnZhbChcIipcIilcbiAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoJ21hcmdpbicpXG4gICAgICAgICAgICAgICAgLmNsaWNrKG1ha2VHcm91cEFjdGlvbihncm91cEFjdGlvbnNbXCJXaWtpTW9ua2V5TWVudVJvb3RcIl0pKVxuXG4gICAgICAgICAgICAjIEkgY2FuJ3Qgc2ltcGx5IGRvICQoXCIjXCIgKyBjdXJySWQpIGJlY2F1c2UgbWFpbkRpdlxuICAgICAgICAgICAgIyBoYXNuJ3QgYmVlbiBhZGRlZCB0byB0aGUgRE9NIHRyZWUgeWV0XG4gICAgICAgICAgICBtYWluRGl2XG4gICAgICAgICAgICAgICAgLmNoaWxkcmVuKFwiZGl2W2lkPSdXaWtpTW9ua2V5TWVudVJvb3QnXVwiKVxuICAgICAgICAgICAgICAgIC5maXJzdCgpXG4gICAgICAgICAgICAgICAgLnByZXBlbmQoZXhlY0FsbClcblxuICAgICAgICAgICAgbWVudXMuZmlyc3QoKS5zaG93KClcbiAgICAgICAgICAgIHJldHVybiBtYWluRGl2WzBdXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuXG4gICAgbWFrZUNoYW5nZU1lbnUgPSAoY3VycmVudE1lbnUsIGNoYW5nZU1lbnUpIC0+XG4gICAgICAgIHJldHVybiAoZXZlbnQpIC0+XG4gICAgICAgICAgICBjdXJyZW50TWVudS5oaWRlKClcbiAgICAgICAgICAgIGNoYW5nZU1lbnUuc2hvdygpXG5cbiAgICBtYWtlRW50cnlVSTogKGN1cnJNZW51LCBwbHVnaW4pIC0+XG4gICAgICAgIHJldHVybiAoZXZlbnQpID0+XG4gICAgICAgICAgICBjdXJyTWVudS5oaWRlKClcbiAgICAgICAgICAgIFVJZGl2ID0gJCgnPGRpdi8+JylcblxuICAgICAgICAgICAgJCgnPGlucHV0Lz4nKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd0eXBlJywgJ2J1dHRvbicpXG4gICAgICAgICAgICAgICAgLnZhbCgnPCcpXG4gICAgICAgICAgICAgICAgLmFkZENsYXNzKCdtYXJnaW4nKVxuICAgICAgICAgICAgICAgIC5jbGljayggKGV2ZW50KSAtPlxuICAgICAgICAgICAgICAgICAgICBVSWRpdi5yZW1vdmUoKVxuICAgICAgICAgICAgICAgICAgICBjdXJyTWVudS5zaG93KClcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgLmFwcGVuZFRvKFVJZGl2KVxuXG4gICAgICAgICAgICAkKCc8aW5wdXQvPicpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3R5cGUnLCAnYnV0dG9uJylcbiAgICAgICAgICAgICAgICAudmFsKCdFeGVjdXRlJylcbiAgICAgICAgICAgICAgICAuY2xpY2soQG1ha2VFbnRyeUFjdGlvbihwbHVnaW4pKVxuICAgICAgICAgICAgICAgIC5hcHBlbmRUbyhVSWRpdilcblxuICAgICAgICAgICAgVUkgPSBwbHVnaW4ubWFrZVVJKClcbiAgICAgICAgICAgIFVJZGl2LmFwcGVuZChVSSkuaW5zZXJ0QWZ0ZXIoY3Vyck1lbnUpXG5cbiAgICBtYWtlRW50cnlBY3Rpb246IChwbHVnaW4pIC0+XG4gICAgICAgIHJldHVybiAoZXZlbnQpID0+XG4gICAgICAgICAgICBAZXhlY3V0ZUVudHJ5QWN0aW9uKHBsdWdpbiwgbnVsbClcblxuICAgIGV4ZWN1dGVFbnRyeUFjdGlvbjogKHBsdWdpbiwgY2FsbE5leHQpID0+XG4gICAgICAgIEBXTS5Mb2cubG9nSGlkZGVuKFwiUGx1Z2luOiBcIiArIHBsdWdpbi5jb25zdHJ1Y3Rvci5uYW1lKVxuICAgICAgICBwbHVnaW5bXCJtYWluXyN7QHBhZ2VfdHlwZX1cIl0oY2FsbE5leHQpXG5cbiAgICB3YXJuSW5wdXROZWVkZWQ6IChwbHVnaW4sIGNhbGxOZXh0KSA9PlxuICAgICAgICBAV00uTG9nLmxvZ1dhcm5pbmcoXCJQbHVnaW4gXCIgKyBwbHVnaW4uY29uc3RydWN0b3IubmFtZSArXG4gICAgICAgICAgICBcIiB3YXMgbm90IGV4ZWN1dGVkIGJlY2F1c2UgaXQgcmVxdWlyZXMgaW5wdXQgZnJvbSBpdHMgaW50ZXJmYWNlLlwiKVxuXG4gICAgICAgIGlmIGNhbGxOZXh0XG4gICAgICAgICAgICBjYWxsTmV4dCgpXG5cbiAgICBtYWtlR3JvdXBBY3Rpb24gPSAoc3ViR3JvdXBBY3Rpb25zKSAtPlxuICAgICAgICByZXR1cm4gKGV2ZW50KSAtPlxuICAgICAgICAgICAgZXhlY3V0ZUdyb3VwQWN0aW9uKHN1Ykdyb3VwQWN0aW9ucywgLTEpXG5cbiAgICBleGVjdXRlR3JvdXBBY3Rpb24gPSAoc3ViR3JvdXBBY3Rpb25zLCBpZCkgLT5cbiAgICAgICAgaWQrK1xuICAgICAgICBpZiBzdWJHcm91cEFjdGlvbnNbaWRdXG4gICAgICAgICAgICBmaWQgPSBzdWJHcm91cEFjdGlvbnNbaWRdXG4gICAgICAgICAgICBjYWxsQ29udGludWUgPSA9PlxuICAgICAgICAgICAgICAgIGV4ZWN1dGVHcm91cEFjdGlvbihzdWJHcm91cEFjdGlvbnMsIGlkKVxuICAgICAgICAgICAgZmlkWzBdKGZpZFsxXSwgY2FsbENvbnRpbnVlKVxuIiwiIyBXaWtpIE1vbmtleSAtIE1lZGlhV2lraSBib3QgYW5kIGVkaXRvci1hc3Npc3RhbnQgdXNlciBzY3JpcHRcbiMgQ29weXJpZ2h0IChDKSAyMDExIERhcmlvIEdpb3Zhbm5ldHRpIDxkZXZAZGFyaW9naW92YW5uZXR0aS5uZXQ+XG4jXG4jIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFdpa2kgTW9ua2V5LlxuI1xuIyBXaWtpIE1vbmtleSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4jIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4jIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4jIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4jXG4jIFdpa2kgTW9ua2V5IGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4jIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4jIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiMgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbiNcbiMgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiMgYWxvbmcgd2l0aCBXaWtpIE1vbmtleS4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cblxuQ1NTID0gcmVxdWlyZSgnQGt5bmlrb3MvbWlzYy9kaXN0L0NTUycpXG5cblxuY2xhc3MgbW9kdWxlLmV4cG9ydHNcbiAgICBjb25zdHJ1Y3RvcjogKEBXTSkgLT5cblxuICAgIGRpc2FibGVFZGl0U3VtbWFyeVN1Ym1pdE9uRW50ZXIgPSAtPlxuICAgICAgICAkKCcjd3BTdW1tYXJ5Jykua2V5ZG93biggKGV2ZW50KSAtPlxuICAgICAgICAgICAgIyAna2V5Q29kZScgaXMgZGVwcmVjYXRlZCwgYnV0IG5vdCBhbGwgYnJvd3NlcnMgc3VwcG9ydCAna2V5JyB5ZXRcbiAgICAgICAgICAgIGlmIGV2ZW50LmtleSA9PSAnRW50ZXInIG9yICh0eXBlb2YgZXZlbnQua2V5ID09ICd1bmRlZmluZWQnIGFuZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudC5rZXlDb2RlID09IDEzKVxuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgKVxuXG4gICAgaGlkZVJvbGxiYWNrTGlua3MgPSAtPlxuICAgICAgICBDU1MuYWRkU3R5bGVFbGVtZW50KFwic3Bhbi5tdy1yb2xsYmFjay1saW5rIHtkaXNwbGF5Om5vbmU7fVwiKVxuXG4gICAgc2Nyb2xsVG9GaXJzdEhlYWRpbmcgPSAtPlxuICAgICAgICB3aW5kb3cuc2Nyb2xsVG8oMCwgJCgnI2ZpcnN0SGVhZGluZycpLm9mZnNldCgpLnRvcClcblxuICAgIGFwcGx5RWRpdG9yTW9kczogLT5cbiAgICAgICAgaWYgQFdNLmNvbmYuZGlzYWJsZV9lZGl0X3N1bW1hcnlfc3VibWl0X29uX2VudGVyXG4gICAgICAgICAgICBkaXNhYmxlRWRpdFN1bW1hcnlTdWJtaXRPbkVudGVyKClcbiAgICAgICAgaWYgQFdNLmNvbmYuc2Nyb2xsX3RvX2ZpcnN0X2hlYWRpbmdcbiAgICAgICAgICAgIHNjcm9sbFRvRmlyc3RIZWFkaW5nKClcblxuICAgIGFwcGx5UmVjZW50Q2hhbmdlc01vZHM6IC0+XG4gICAgICAgIGlmIEBXTS5jb25mLmhpZGVfcm9sbGJhY2tfbGlua3NcbiAgICAgICAgICAgIGhpZGVSb2xsYmFja0xpbmtzKClcblxuICAgIGFwcGx5Q29udHJpYnV0aW9uc01vZHM6IC0+XG4gICAgICAgIGlmIEBXTS5jb25mLmhpZGVfcm9sbGJhY2tfbGlua3NcbiAgICAgICAgICAgIGhpZGVSb2xsYmFja0xpbmtzKClcbiIsIiMgV2lraSBNb25rZXkgLSBNZWRpYVdpa2kgYm90IGFuZCBlZGl0b3ItYXNzaXN0YW50IHVzZXIgc2NyaXB0XG4jIENvcHlyaWdodCAoQykgMjAxMSBEYXJpbyBHaW92YW5uZXR0aSA8ZGV2QGRhcmlvZ2lvdmFubmV0dGkubmV0PlxuI1xuIyBUaGlzIGZpbGUgaXMgcGFydCBvZiBXaWtpIE1vbmtleS5cbiNcbiMgV2lraSBNb25rZXkgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuIyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuIyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuIyAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuI1xuIyBXaWtpIE1vbmtleSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuIyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuIyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4jIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4jXG4jIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4jIGFsb25nIHdpdGggV2lraSBNb25rZXkuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG5cblJlZ0V4ID0gcmVxdWlyZSgnQGt5bmlrb3MvbWlzYy9kaXN0L1JlZ0V4JylcblN0ciA9IHJlcXVpcmUoJ0BreW5pa29zL21pc2MvZGlzdC9TdHInKVxuXG5cbmNsYXNzIG1vZHVsZS5leHBvcnRzXG4gICAgY29uc3RydWN0b3I6IChAV00pIC0+XG5cbiAgICBzcXVhc2hDb250aWd1b3VzV2hpdGVzcGFjZTogKHRpdGxlKSAtPlxuICAgICAgICAjIE1lZGlhV2lraSB0cmVhdHMgY29uc2VjdXRpdmUgd2hpdGVzcGFjZSBjaGFyYWN0ZXJzIGluIHRpdGxlcyBhbmRcbiAgICAgICAgIyAgIHNlY3Rpb24gbmFtZXMgYXMgb25lXG4gICAgICAgICMgRm9yIGV4YW1wbGUgW1tNYWluIF9fIFBhZ2UjRmlyc3QgXyBfc2VjdGlvbl1dIGlzIHRoZSBzYW1lIGFzXG4gICAgICAgICMgICBbW01haW4gUGFnZSNGaXJzdCBzZWN0aW9uXV1cbiAgICAgICAgIyBDb25zaWRlciB0cmltbWluZyB0aGUgcmV0dXJuZWQgdGV4dFxuICAgICAgICByZXR1cm4gdGl0bGUucmVwbGFjZSgvW18gXSsvZywgXCIgXCIpXG5cbiAgICBuZXV0cmFsaXplTm93aWtpVGFnczogKHNvdXJjZSkgLT5cbiAgICAgICAgIyBFbXB0eSBub3dpa2kgdGFncyAoPG5vd2lraT48L25vd2lraT4pIG11c3QgYmUgbmV1dHJhbGl6ZWQgYXMgd2VsbCxcbiAgICAgICAgIyAgIG90aGVyd2lzZSBUYW1wZXJtb25rZXkgd2lsbCBoYW5nLCBzZWUgYWxzb1xuICAgICAgICAjICAgaHR0cHM6Ly9naXRodWIuY29tL2t5bmlrb3Mvd2lraS1tb25rZXkvaXNzdWVzLzEzM1xuICAgICAgICAjIE5vdGUgdGhhdCB0aGUgY29uY2VwdCBvZiBcIm5lc3RpbmdcIiBkb2Vzbid0IG1ha2Ugc2Vuc2Ugd2l0aCA8bm93aWtpPlxuICAgICAgICAjICAgdGFncywgc28gZG8gKm5vdCogdXNlIFN0ci5maW5kTmVzdGVkRW5jbG9zdXJlc1xuICAgICAgICBPUEVOTEVOR1RIID0gOFxuICAgICAgICBDTE9TRUxFTkdUSCA9IDlcbiAgICAgICAgdGFncyA9IFN0ci5maW5kU2ltcGxlRW5jbG9zdXJlcyhzb3VyY2UsIC88bm93aWtpPi9pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT1BFTkxFTkdUSCwgLzxcXC9ub3dpa2k+L2ksIENMT1NFTEVOR1RIKVxuICAgICAgICBtYXNrZWRUZXh0ID0gXCJcIlxuICAgICAgICBwcmV2SWQgPSAwXG5cbiAgICAgICAgZm9yIHRhZyBpbiB0YWdzXG4gICAgICAgICAgICBpZiB0YWdbMV1cbiAgICAgICAgICAgICAgICBtYXNrTGVuZ3RoID0gdGFnWzFdIC0gdGFnWzBdICsgQ0xPU0VMRU5HVEhcbiAgICAgICAgICAgICAgICBtYXNrU3RyaW5nID0gU3RyLnBhZFJpZ2h0KFwiXCIsIFwieFwiLCBtYXNrTGVuZ3RoKVxuICAgICAgICAgICAgICAgIG1hc2tlZFRleHQgKz0gc291cmNlLnN1YnN0cmluZyhwcmV2SWQsIHRhZ1swXSkgKyBtYXNrU3RyaW5nXG4gICAgICAgICAgICAgICAgcHJldklkID0gdGFnWzFdICsgQ0xPU0VMRU5HVEhcbiAgICAgICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICMgSWYgYSA8bm93aWtpPiB0YWcgaXMgbGVmdCBvcGVuIChubyBjbG9zaW5nIHRhZyBpcyBmb3VuZCksIGl0XG4gICAgICAgICAgICAgICAgIyAgIGRvZXMgaXRzIGpvYiB1bnRpbCB0aGUgZW5kIG9mIHRoZSB0ZXh0XG4gICAgICAgICAgICAgICAgIyBUaGlzIGFsc28gbmV1dHJhbGl6ZXMgdGhlIGZpbmFsIFxcbiwgYnV0IGl0IHNob3VsZG4ndCBtYXR0ZXJcbiAgICAgICAgICAgICAgICBtYXNrTGVuZ3RoID0gc291cmNlLnN1YnN0cih0YWdbMF0pLmxlbmd0aFxuICAgICAgICAgICAgICAgIG1hc2tTdHJpbmcgPSBTdHIucGFkUmlnaHQoXCJcIiwgXCJ4XCIsIG1hc2tMZW5ndGgpXG4gICAgICAgICAgICAgICAgbWFza2VkVGV4dCArPSBzb3VyY2Uuc3Vic3RyaW5nKHByZXZJZCwgdGFnWzBdKSArIG1hc2tTdHJpbmdcbiAgICAgICAgICAgICAgICBwcmV2SWQgPSBzb3VyY2UubGVuZ3RoXG4gICAgICAgICAgICAgICAgYnJlYWtcblxuICAgICAgICBtYXNrZWRUZXh0ICs9IHNvdXJjZS5zdWJzdHJpbmcocHJldklkKVxuXG4gICAgICAgIHJldHVybiBtYXNrZWRUZXh0XG5cbiAgICBkb3RFbmNvZGU6ICh0ZXh0KSAtPlxuICAgICAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHRleHQpLnJlcGxhY2UoLyUvZywgXCIuXCIpXG5cbiAgICBkb3RFbmNvZGVMaW5rQnJlYWtpbmdGcmFnbWVudENoYXJhY3RlcnM6IChmcmFnbWVudCkgLT5cbiAgICAgICAgIyBUaGVzZSBjaGFyYWN0ZXJzIGFyZSBrbm93biB0byBicmVhayBpbnRlcm5hbCBsaW5rcyBpZiBmb3VuZCBpblxuICAgICAgICAjICAgZnJhZ21lbnRzXG4gICAgICAgICMgVGhpcyBmdW5jdGlvbiBpcyBub3QgdGVzdGVkIG9uIGxpbmsgcGF0aHMgb3IgYW5jaG9ycyFcbiAgICAgICAgZnJhZ21lbnQgPSBmcmFnbWVudC5yZXBsYWNlKC9cXFsvZywgXCIuNUJcIilcbiAgICAgICAgZnJhZ21lbnQgPSBmcmFnbWVudC5yZXBsYWNlKC9cXF0vZywgXCIuNURcIilcbiAgICAgICAgZnJhZ21lbnQgPSBmcmFnbWVudC5yZXBsYWNlKC9cXHsvZywgXCIuN0JcIilcbiAgICAgICAgZnJhZ21lbnQgPSBmcmFnbWVudC5yZXBsYWNlKC9cXH0vZywgXCIuN0RcIilcbiAgICAgICAgZnJhZ21lbnQgPSBmcmFnbWVudC5yZXBsYWNlKC9cXHwvZywgXCIuN0NcIilcbiAgICAgICAgcmV0dXJuIGZyYWdtZW50XG5cbiAgICBwcmVwYXJlUmVnZXhwV2hpdGVzcGFjZSA9ICh0aXRsZSkgLT5cbiAgICAgICAgIyBNZWRpYVdpa2kgdHJlYXRzIGNvbnNlY3V0aXZlIHdoaXRlc3BhY2UgY2hhcmFjdGVycyBpbiB0aXRsZXMgYW5kXG4gICAgICAgICMgICBzZWN0aW9uIG5hbWVzIGFzIG9uZVxuICAgICAgICAjIEZvciBleGFtcGxlIFtbTWFpbiBfXyBQYWdlI0ZpcnN0IF8gX3NlY3Rpb25dXSBpcyB0aGUgc2FtZSBhc1xuICAgICAgICAjICAgW1tNYWluIFBhZ2UjRmlyc3Qgc2VjdGlvbl1dXG4gICAgICAgICMgQ29uc2lkZXIgdHJpbW1pbmcgdGhlIHRpdGxlIGJlZm9yZSBwYXNzaW5nIGl0IGhlcmVcbiAgICAgICAgcmV0dXJuIHRpdGxlLnJlcGxhY2UoL1tfIF0rL2csIFwiW18gXStcIilcblxuICAgIHByZXBhcmVUaXRsZUNhc2luZyA9IChwYXR0ZXJuKSAtPlxuICAgICAgICBmaXJzdENoYXIgPSBwYXR0ZXJuLmNoYXJBdCgwKVxuICAgICAgICBmY1VwcGVyID0gZmlyc3RDaGFyLnRvVXBwZXJDYXNlKClcbiAgICAgICAgZmNMb3dlciA9IGZpcnN0Q2hhci50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGlmIGZjVXBwZXIgIT0gZmNMb3dlclxuICAgICAgICAgICAgcGF0dGVybiA9IFwiW1wiICsgZmNVcHBlciArIGZjTG93ZXIgKyBcIl1cIiArIHBhdHRlcm4uc3Vic3RyKDEpXG4gICAgICAgIHJldHVybiBwYXR0ZXJuXG5cbiAgICBjb21wYXJlQXJ0aWNsZVRpdGxlczogKHRpdGxlMSwgdGl0bGUyKSAtPlxuICAgICAgICAjIEFjdHVhbGx5IGFsc28gbmFtZXNwYWNlcyBzaG91bGQgYmUga2VwdCBpbnRvIGFjY291bnQsXG4gICAgICAgICMgZS5nLiAnSGVscDpUaXRsZScgYW5kICdIZWxwOnRpdGxlJyBzaG91bGQgcmV0dXJuIHRydWVcbiAgICAgICAgdDEgPSBwcmVwYXJlVGl0bGVDYXNpbmcodGhpcy5zcXVhc2hDb250aWd1b3VzV2hpdGVzcGFjZSh0aXRsZTEpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50cmltKCkpXG4gICAgICAgIHQyID0gcHJlcGFyZVRpdGxlQ2FzaW5nKHRoaXMuc3F1YXNoQ29udGlndW91c1doaXRlc3BhY2UodGl0bGUyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAudHJpbSgpKVxuICAgICAgICByZXR1cm4gdDEgPT0gdDJcblxuICAgIGZpbmRCZWhhdmlvclN3aXRjaGVzOiAoc291cmNlLCB3b3JkKSAtPlxuICAgICAgICBzb3VyY2UgPSB0aGlzLm5ldXRyYWxpemVOb3dpa2lUYWdzKHNvdXJjZSlcbiAgICAgICAgcmVnRXhwXG4gICAgICAgIGlmIHdvcmRcbiAgICAgICAgICAgICMgQmVoYXZpb3Igc3dpdGNoZXMgYXJlbid0IGNhc2Utc2Vuc2l0aXZlXG4gICAgICAgICAgICByZWdFeHAgPSBuZXcgUmVnRXhwKFwiX19cIiArIFJlZ0V4LmVzY2FwZVBhdHRlcm4od29yZCkgKyBcIl9fXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImdpXCIpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgICMgQmVoYXZpb3Igc3dpdGNoZXMgYXJlbid0IGNhc2Utc2Vuc2l0aXZlXG4gICAgICAgICAgICByZWdFeHAgPSBuZXcgUmVnRXhwKFwiX18oVE9DfE5PVE9DfEZPUkNFVE9DfE5PRURJVFNFQ1RJT058XCIgK1xuICAgICAgICAgICAgICAgICAgICBcIk5FV1NFQ1RJT05MSU5LfE5PTkVXU0VDVElPTkxJTkt8Tk9HQUxMRVJZfEhJRERFTkNBVHxcIiArXG4gICAgICAgICAgICAgICAgICAgIFwiTk9DT05URU5UQ09OVkVSVHxOT0NDfE5PVElUTEVDT05WRVJUfE5PVEN8SU5ERVh8XCIgK1xuICAgICAgICAgICAgICAgICAgICBcIk5PSU5ERVh8U1RBVElDUkVESVJFQ1R8U1RBUlR8RU5EKV9fXCIsIFwiZ2lcIilcbiAgICAgICAgcmV0dXJuIFJlZ0V4Lm1hdGNoQWxsKHNvdXJjZSwgcmVnRXhwKVxuXG4gICAgZmluZExpbmtzRW5naW5lOiAoc291cmNlLCB0aXRsZVBhdHRlcm4sIHNwZWNpYWxPbmx5LCBjYXNlU2Vuc2l0aXZlKSAtPlxuICAgICAgICAjIExpbmtzIGNhbm5vdCBjb250YWluIG90aGVyIGxpbmtzLCBub3QgZXZlbiBpbiB0aGUgYWx0ZXJuYXRpdmUgdGV4dFxuICAgICAgICAjICAgKG9ubHkgdGhlIGlubmVybW9zdCBsaW5rcyBhcmUgdmFsaWQpXG4gICAgICAgICMgTWFrZSBzdXJlIHRvIHByZXBhcmUgd2hpdGVzcGFjZSBpbiB0aXRsZVBhdHRlcm4gbGlrZSBpblxuICAgICAgICAjICAgcHJlcGFyZVJlZ2V4cFdoaXRlc3BhY2VcbiAgICAgICAgIyBEbyAqbm90KiB1c2UgdGhlIGcgZmxhZywgb3Igd2hlbiB1c2luZyBSZWdFeHAuZXhlYyB0aGUgaW5kZXggd2lsbFxuICAgICAgICAjICAgaGF2ZSB0byBiZSByZXNldCBhdCBldmVyeSBsb29wXG4gICAgICAgIGZsYWdzID0gaWYgY2FzZVNlbnNpdGl2ZSB0aGVuIFwiXCIgZWxzZSBcImlcIlxuICAgICAgICAjIFRoZSBmb2xsb3dpbmcgY29sb24vc3BhY2UgY29tYmluYXRpb25zIGFyZSB2YWxpZFxuICAgICAgICAjICAgXCJbW2E6YiNjfGRdXVwiXG4gICAgICAgICMgICBcIltbIGE6YiNjfGRdXVwiXG4gICAgICAgICMgICBcIltbIDphOmIjY3xkXV1cIlxuICAgICAgICAjICAgXCJbWyA6IGE6YiNjfGRdXVwiXG4gICAgICAgICMgICBcIltbOmE6YiNjfGRdXVwiXG4gICAgICAgICMgICBcIltbOiBhOmIjY3xkXV1cIlxuICAgICAgICAjICAgXCJbWzo6YTpiI2N8ZF1dXCJcbiAgICAgICAgIyAgIFwiW1s6IDphOmIjY3xkXV1cIlxuICAgICAgICAjICAgXCJbWzo6IGE6YiNjfGRdXVwiXG4gICAgICAgICMgICBcIltbOiA6IGE6YiNjfGRdXVwiXG4gICAgICAgICMgQSBsaW5rIGxpa2UgXCJbWyA6OmE6YiNjfGRdXVwiIGlzbid0IHZhbGlkLCBidXQgaXQgd291bGQgc3RpbGwgYmVcbiAgICAgICAgIyAgIGZvdW5kIHdoZW4gc3BlY2lhbE9ubHkgaXMgZmFsc2UgKGJ1ZyAjMTY2KVxuICAgICAgICBzcGVjaWFsID0gaWYgc3BlY2lhbE9ubHkgdGhlbiBcIig/OlsgX10rOik/WyBfXSpcIiBlbHNlIFwiKD86XFxcXDo/WyBfXSopezAsMn1cIlxuICAgICAgICByZWdFeHAgPSBuZXcgUmVnRXhwKFwiXlwiICsgc3BlY2lhbCArIFwiKFwiICsgdGl0bGVQYXR0ZXJuICsgXCIpXCIgK1xuICAgICAgICAgICAgICAgICAgICBcIlsgX10qKD86XFxcXHxbX1xcXFxzXSooW1xcXFxzXFxcXFNdKz8pW19cXFxcc10qKT9bX1xcXFxzXSokXCIsIGZsYWdzKVxuICAgICAgICBuU291cmNlID0gQG5ldXRyYWxpemVOb3dpa2lUYWdzKHNvdXJjZSlcbiAgICAgICAgbGlua3MgPSBbXVxuICAgICAgICBkYnJhY2VzID0gU3RyLmZpbmRJbm5lcm1vc3RFbmNsb3N1cmVzKG5Tb3VyY2UsIFwiW1tcIiwgXCJdXVwiKVxuXG4gICAgICAgIGZvciBkYnJhY2UgaW4gZGJyYWNlc1xuICAgICAgICAgICAgaW5UZXh0ID0gc291cmNlLnN1YnN0cmluZyhkYnJhY2VbMF0gKyAyLCBkYnJhY2VbMV0pXG4gICAgICAgICAgICBtYXRjaCA9IHJlZ0V4cC5leGVjKGluVGV4dClcblxuICAgICAgICAgICAgaWYgbWF0Y2hcbiAgICAgICAgICAgICAgICBwdXNoID0gdHJ1ZVxuXG4gICAgICAgICAgICAgICAgaWYgbWF0Y2hbNl1cbiAgICAgICAgICAgICAgICAgICAgIyBJbmNvbXBsZXRlIHRlbXBsYXRlcyBpbiB0aGUgYWx0ZXJuYXRpdmUgdGV4dCBoYXZlIGFuXG4gICAgICAgICAgICAgICAgICAgICMgICBhcHBhcmVudGx5IHdlaXJkIGJlaGF2aW91ciwgaGFyZCB0byByZXZlcnNlLWVuZ2luZWVyLFxuICAgICAgICAgICAgICAgICAgICAjICAgc28gaXNzdWUgYSB3YXJuaW5nIHdoZW4gb25lIGlzIGZvdW5kXG4gICAgICAgICAgICAgICAgICAgICMgICBTZWUgYWxzbyB0aGUgZXhhbXBsZXMgaW4gQGZpbmRUcmFuc2NsdXNpb25Bcmd1bWVudHNcbiAgICAgICAgICAgICAgICAgICAgIyBOb3RlIHRoYXQgdGhlIHRpdGxlIGFscmVhZHkgZG9lc24ndCBhbGxvdyBcIntcIiBvciBcIn1cIlxuICAgICAgICAgICAgICAgICAgICBuVGV4dCA9IEBuZXV0cmFsaXplTm93aWtpVGFncyhtYXRjaFs2XSlcbiAgICAgICAgICAgICAgICAgICAgbWFza2VkVGV4dCA9IFN0ci5maW5kTmVzdGVkRW5jbG9zdXJlcyhuVGV4dCwgXCJ7e1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwifX1cIiwgXCJ4XCIpWzFdXG5cbiAgICAgICAgICAgICAgICAgICAgaWYgbWFza2VkVGV4dC5zZWFyY2goLyhcXHtcXHt8XFx9XFx9KS8pID4gLTFcbiAgICAgICAgICAgICAgICAgICAgICAgIEBXTS5Mb2cubG9nV2FybmluZyhcIltbXCIgKyBtYXRjaFswXSArIFwiXV0gc2VlbXMgdG9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250YWluIHBhcnQgb2YgYSB0ZW1wbGF0ZSwgYW5kIHRoZSByZXN1bHRpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZWhhdmlvdXIgY2Fubm90IGJlIHByZWRpY3RlZCBieSB0aGlzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24sIHNvIHRoZSBsaW5rIHdpbGwgYmUgaWdub3JlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsdG9nZXRoZXJcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHB1c2ggPSBmYWxzZVxuXG4gICAgICAgICAgICAgICAgaWYgcHVzaFxuICAgICAgICAgICAgICAgICAgICBsaW5rcy5wdXNoKFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJyYXdMaW5rXCI6IFwiW1tcIiArIG1hdGNoWzBdICsgXCJdXVwiXG4gICAgICAgICAgICAgICAgICAgICAgICBcImxpbmtcIjogbWF0Y2hbMV1cbiAgICAgICAgICAgICAgICAgICAgICAgIFwicmF3VGl0bGVcIjogbWF0Y2hbMl1cbiAgICAgICAgICAgICAgICAgICAgICAgIFwibmFtZXNwYWNlXCI6IG1hdGNoWzNdXG4gICAgICAgICAgICAgICAgICAgICAgICBcInRpdGxlXCI6IG1hdGNoWzRdXG4gICAgICAgICAgICAgICAgICAgICAgICBcImZyYWdtZW50XCI6IG1hdGNoWzVdXG4gICAgICAgICAgICAgICAgICAgICAgICBcImFuY2hvclwiOiBtYXRjaFs2XVxuICAgICAgICAgICAgICAgICAgICAgICAgXCJpbmRleFwiOiBkYnJhY2VbMF1cbiAgICAgICAgICAgICAgICAgICAgICAgIFwibGVuZ3RoXCI6IGRicmFjZVsxXSArIDIgLSBkYnJhY2VbMF0pXG5cbiAgICAgICAgcmV0dXJuIGxpbmtzXG5cbiAgICBmaW5kU2VjdGlvbkxpbmtzOiAoc291cmNlKSAtPlxuICAgICAgICAjIEtlZXAgdGhlIGNhcHR1cmluZyBncm91cHMgYXMgcmVxdWlyZWQgYnkgQGZpbmRMaW5rc0VuZ2luZVxuICAgICAgICBmcmFnbWVudENoYXJzID0gXCJbXlxcXFxuXFxcXHtcXFxcfVxcXFxbXFxcXF1cXFxcfF0qP1wiXG4gICAgICAgIHRpdGxlUGF0dGVybiA9IFwiKCgpKCkpIyhcIiArIGZyYWdtZW50Q2hhcnMgKyBcIilcIlxuICAgICAgICByZXR1cm4gQGZpbmRMaW5rc0VuZ2luZShzb3VyY2UsIHRpdGxlUGF0dGVybiwgZmFsc2UsIHRydWUpXG5cbiAgICBmaW5kSW50ZXJuYWxMaW5rczogKHNvdXJjZSwgbmFtZXNwYWNlLCB0aXRsZSkgLT5cbiAgICAgICAgIyBLZWVwIHRoZSBjYXB0dXJpbmcgZ3JvdXBzIGFzIHJlcXVpcmVkIGJ5IEBmaW5kTGlua3NFbmdpbmVcbiAgICAgICAgbmFtZXNwYWNlQ2hhcnMgPSBcIlteXFxcXG5cXFxce1xcXFx9XFxcXFtcXFxcXVxcXFx8XFxcXDpcXFxcI10rP1wiXG4gICAgICAgIHRpdGxlQ2hhcnMgPSBcIlteXFxcXG5cXFxce1xcXFx9XFxcXFtcXFxcXVxcXFx8XFxcXCNdKz9cIlxuICAgICAgICBmcmFnbWVudENoYXJzID0gXCJbXlxcXFxuXFxcXHtcXFxcfVxcXFxbXFxcXF1cXFxcfF0qP1wiXG5cbiAgICAgICAgaWYgbmFtZXNwYWNlXG4gICAgICAgICAgICByZW5zID0gcHJlcGFyZVJlZ2V4cFdoaXRlc3BhY2UoUmVnRXguZXNjYXBlUGF0dGVybihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lc3BhY2UpKVxuXG4gICAgICAgICAgICBpZiB0aXRsZVxuICAgICAgICAgICAgICAgIHJldGl0bGUgPSBwcmVwYXJlUmVnZXhwV2hpdGVzcGFjZShSZWdFeC5lc2NhcGVQYXR0ZXJuKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZSkpXG4gICAgICAgICAgICAgICAgdGl0bGVQYXR0ZXJuID0gXCIoKFwiICsgcmVucyArIFwiKVsgX10qOlsgX10qXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiKFwiICsgcmV0aXRsZSArIFwiKSlcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIoPzpbIF9dKiMoXCIgKyBmcmFnbWVudENoYXJzICsgXCIpKT9cIlxuXG4gICAgICAgICAgICAgICAgIyBOYW1lc3BhY2VzIHdvdWxkbid0IGJlIGNhc2Utc2Vuc2l0aXZlLCBidXQgdGl0bGVzIGFyZSwgc28gYmVcbiAgICAgICAgICAgICAgICAjICAgc2FmZSBhbmQgZG9uJ3QgdXNlIHRoZSBpIGZsYWdcbiAgICAgICAgICAgICAgICBjYXNlU2Vuc2l0aXZlID0gdHJ1ZVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRpdGxlUGF0dGVybiA9IFwiKChcIiArIHJlbnMgKyBcIilbIF9dKjpbIF9dKlwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIihcIiArIHRpdGxlQ2hhcnMgKyBcIikpXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiKD86WyBfXSojKFwiICsgZnJhZ21lbnRDaGFycyArIFwiKSk/XCJcblxuICAgICAgICAgICAgICAgICMgTmFtZXNwYWNlcyBhcmVuJ3QgY2FzZS1zZW5zaXRpdmVcbiAgICAgICAgICAgICAgICBjYXNlU2Vuc2l0aXZlID0gZmFsc2VcbiAgICAgICAgZWxzZSBpZiB0aXRsZVxuICAgICAgICAgICAgcmV0aXRsZSA9IHByZXBhcmVSZWdleHBXaGl0ZXNwYWNlKFJlZ0V4LmVzY2FwZVBhdHRlcm4oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlKSlcblxuICAgICAgICAgICAgIyBLZWVwIHRoZSBjYXB0dXJpbmcgZ3JvdXBzIGFzIHJlcXVpcmVkIGJ5IEBmaW5kTGlua3NFbmdpbmVcbiAgICAgICAgICAgIHRpdGxlUGF0dGVybiA9IFwiKCgpKFwiICsgcmV0aXRsZSArIFwiKSlcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIoPzpbIF9dKiMoXCIgKyBmcmFnbWVudENoYXJzICsgXCIpKT9cIlxuXG4gICAgICAgICAgICAjIFRpdGxlcyBhcmUgY2FzZS1zZW5zaXRpdmVcbiAgICAgICAgICAgIGNhc2VTZW5zaXRpdmUgPSB0cnVlXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRpdGxlUGF0dGVybiA9IFwiKCg/OihcIiArIG5hbWVzcGFjZUNoYXJzICsgXCIpWyBfXSo6WyBfXSopP1wiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIihcIiArIHRpdGxlQ2hhcnMgKyBcIikpXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiKD86WyBfXSojKFwiICsgZnJhZ21lbnRDaGFycyArIFwiKSk/XCJcbiAgICAgICAgICAgIGNhc2VTZW5zaXRpdmUgPSB0cnVlXG5cbiAgICAgICAgcmV0dXJuIEBmaW5kTGlua3NFbmdpbmUoc291cmNlLCB0aXRsZVBhdHRlcm4sIGZhbHNlLCBjYXNlU2Vuc2l0aXZlKVxuXG4gICAgZmluZEludGVyd2lraUxpbmtzOiAoc291cmNlLCB3aWtpKSAtPlxuICAgICAgICByZXR1cm4gdGhpcy5maW5kSW50ZXJuYWxMaW5rcyhzb3VyY2UsIHdpa2kpXG5cbiAgICBmaW5kU3BlY2lhbExpbmtzOiAoc291cmNlLCBwYXR0ZXJuKSAtPlxuICAgICAgICAjIE1ha2Ugc3VyZSB0byBwcmVwYXJlIHdoaXRlc3BhY2UgaW4gcGF0dGVybiBsaWtlIGluXG4gICAgICAgICMgICBwcmVwYXJlUmVnZXhwV2hpdGVzcGFjZVxuICAgICAgICAjIEtlZXAgdGhlIGNhcHR1cmluZyBncm91cHMgYXMgcmVxdWlyZWQgYnkgQGZpbmRMaW5rc0VuZ2luZVxuICAgICAgICAjIFNlZSBhbHNvIEBXTS5BcmNoV2lraS5maW5kQWxsSW50ZXJsYW5ndWFnZUxpbmtzXG4gICAgICAgIHRpdGxlQ2hhcnMgPSBcIlteXFxcXG5cXFxce1xcXFx9XFxcXFtcXFxcXVxcXFx8XFxcXCNdKz9cIlxuICAgICAgICBmcmFnbWVudENoYXJzID0gXCJbXlxcXFxuXFxcXHtcXFxcfVxcXFxbXFxcXF1cXFxcfF0qP1wiXG4gICAgICAgIHRpdGxlUGF0dGVybiA9IFwiKChcIiArIHBhdHRlcm4gKyBcIilbIF9dKjpbIF9dKlwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIihcIiArIHRpdGxlQ2hhcnMgKyBcIikpXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiKD86WyBfXSojKFwiICsgZnJhZ21lbnRDaGFycyArIFwiKSk/XCJcbiAgICAgICAgIyBDYXRlZ29yaWVzIGFuZCBsYW5ndWFnZSB0YWdzIGFyZW4ndCBjYXNlLXNlbnNpdGl2ZVxuICAgICAgICByZXR1cm4gQGZpbmRMaW5rc0VuZ2luZShzb3VyY2UsIHRpdGxlUGF0dGVybiwgdHJ1ZSwgZmFsc2UpXG5cbiAgICBmaW5kQ2F0ZWdvcmllczogKHNvdXJjZSkgLT5cbiAgICAgICAgcmV0dXJuIHRoaXMuZmluZFNwZWNpYWxMaW5rcyhzb3VyY2UsIFwiQ2F0ZWdvcnlcIilcblxuICAgIGZpbmRJbnRlcmxhbmd1YWdlTGlua3M6IChzb3VyY2UsIGxhbmd1YWdlKSAtPlxuICAgICAgICAjIFNlZSBhbHNvIEBXTS5BcmNoV2lraS5maW5kQWxsSW50ZXJsYW5ndWFnZUxpbmtzXG4gICAgICAgIHJldHVybiB0aGlzLmZpbmRTcGVjaWFsTGlua3Moc291cmNlLCBSZWdFeC5lc2NhcGVQYXR0ZXJuKGxhbmd1YWdlKSlcblxuICAgIGZpbmRWYXJpYWJsZXM6IChzb3VyY2UsIHZhcmlhYmxlKSAtPlxuICAgICAgICAjIFRoZXJlIGRvbid0IHNlZW0gdG8gZXhpc3QgdmFyaWFibGUgbmFtZXMgd2l0aCB3aGl0ZXNwYWNlLCBhcHBseWluZ1xuICAgICAgICAjICAgcHJlcGFyZVJlZ2V4cFdoaXRlc3BhY2UgY291bGQgYmUgZGFuZ2Vyb3VzIGluIHRoaXMgY2FzZVxuICAgICAgICBwYXR0ZXJuID0gUmVnRXguZXNjYXBlUGF0dGVybih2YXJpYWJsZSlcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluZFZhcmlhYmxlc1BhdHRlcm4oc291cmNlLCBwYXR0ZXJuKVxuXG4gICAgZmluZFZhcmlhYmxlc1BhdHRlcm46IChzb3VyY2UsIHBhdHRlcm4pIC0+XG4gICAgICAgICMgcGF0dGVybiBtdXN0IGJlIGEgc3RyaW5nIGFuZCBJVCBNVVNUIE5PVCBIQVZFIEFOWSBDQVBUVVJJTkdcbiAgICAgICAgIyAgIEdST1VQU1xuICAgICAgICAjIFRoZXJlIGNhbid0IGJlIGFuIHVuZGVyc2NvcmUgYmVmb3JlIHRoZSB2YXJpYWJsZSBuYW1lXG4gICAgICAgICMgVGhlcmUgY2FuJ3QgYmUgYSB3aGl0ZXNwYWNlIGJldHdlZW4gdGhlIHZhcmlhYmxlIG5hbWUgYW5kIHRoZSBjb2xvblxuICAgICAgICBuU291cmNlID0gdGhpcy5uZXV0cmFsaXplTm93aWtpVGFncyhzb3VyY2UpXG4gICAgICAgIHJlc3VsdHMgPSBbXVxuICAgICAgICBkYnJhY2tldHMgPSBTdHIuZmluZE5lc3RlZEVuY2xvc3VyZXMoblNvdXJjZSwgXCJ7e1wiLCBcIn19XCIsIFwieFwiKVswXVxuXG4gICAgICAgIGZvciBkYnJhY2tldCBpbiBkYnJhY2tldHNcbiAgICAgICAgICAgIGluVGV4dCA9IHNvdXJjZS5zdWJzdHJpbmcoZGJyYWNrZXRbMF0gKyAyLCBkYnJhY2tldFsxXSlcblxuICAgICAgICAgICAgIyBWYXJpYWJsZXMgYXJlIGNhc2Utc2Vuc2l0aXZlXG4gICAgICAgICAgICAjIERvICpub3QqIHVzZSB0aGUgZyBmbGFnLCBvciB3aGVuIHVzaW5nIFJlZ0V4cC5leGVjIHRoZSBpbmRleFxuICAgICAgICAgICAgIyAgIHdpbGwgaGF2ZSB0byBiZSByZXNldCBhdCBldmVyeSBsb29wXG4gICAgICAgICAgICByZWdFeHAgPSBuZXcgUmVnRXhwKFwiXlxcXFxzKihcIiArIHBhdHRlcm4gKyBcIilcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIoPzpcXFxcOlxcXFxzKihbXFxcXHNcXFxcU10qPykpP1xcXFxzKiRcIiwgXCJcIilcbiAgICAgICAgICAgIG1hdGNoID0gcmVnRXhwLmV4ZWMoaW5UZXh0KVxuXG4gICAgICAgICAgICBpZiBtYXRjaFxuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChcbiAgICAgICAgICAgICAgICAgICAgXCJyYXdWYXJpYWJsZVwiOiBcInt7XCIgKyBtYXRjaFswXSArIFwifX1cIlxuICAgICAgICAgICAgICAgICAgICBcIm5hbWVcIjogbWF0Y2hbMV1cbiAgICAgICAgICAgICAgICAgICAgXCJ2YWx1ZVwiOiBtYXRjaFsyXVxuICAgICAgICAgICAgICAgICAgICBcImluZGV4XCI6IGRicmFja2V0WzBdXG4gICAgICAgICAgICAgICAgICAgIFwibGVuZ3RoXCI6IGRicmFja2V0WzFdICsgMiAtIGRicmFja2V0WzBdKVxuXG4gICAgICAgIHJldHVybiByZXN1bHRzXG5cbiAgICBmaW5kVHJhbnNjbHVzaW9uc0VuZ2luZTogKHNvdXJjZSwgcGF0dGVybiwgdGVtcGxhdGVzT25seSkgLT5cbiAgICAgICAgIyBwYXR0ZXJuIG11c3QgYmUgYSBzdHJpbmcgYW5kIElUIE1VU1QgTk9UIEhBVkUgQU5ZIENBUFRVUklOR1xuICAgICAgICAjICAgR1JPVVBTXG4gICAgICAgICMgTWFrZSBzdXJlIHRvIHByZXBhcmUgd2hpdGVzcGFjZSBpbiBwYXR0ZXJuIGxpa2UgaW5cbiAgICAgICAgIyAgIHByZXBhcmVSZWdleHBXaGl0ZXNwYWNlXG4gICAgICAgICMgVGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBnZW5lcmljIHRyYW5zY2x1c2lvbnMgYW5kIHRlbXBsYXRlcyBpcyB0aGVcbiAgICAgICAgIyAgIHBvc3NpYmlsaXR5IG9mIGEgY29sb24gYmVmb3JlIHRoZSB0aXRsZSB3aGljaCBmb3JjZXMgdGhlXG4gICAgICAgICMgICB0cmFuc2NsdXNpb24gb2YgYSBwYWdlIGluc3RlYWQgb2YgYSB0ZW1wbGF0ZVxuICAgICAgICAjIFRoZXJlIGNhbid0IGJlIGFuIHVuZGVyc2NvcmUgYmVmb3JlIHRoZSBjb2xvblxuICAgICAgICAjIFRoZSB0aXRsZSBtdXN0IG5vdCBiZSBicm9rZW4gYnkgbmV3IGxpbmUgY2hhcmFjdGVyczsgYW55IHVuZGVyc2NvcmVzXG4gICAgICAgICMgICBtdXN0IGJlIGluIHRoZSBzYW1lIGxpbmUgYXMgdGhlIHRpdGxlLCBldmVuIHRob3VnaCB0aGVuIHRoZXkgYXJlXG4gICAgICAgICMgICBjb25zaWRlcmVkIGFzIHdoaXRlc3BhY2VcbiAgICAgICAgIyBUZW1wbGF0ZSBuYW1lcyBhcmUgY2FzZS1zZW5zaXRpdmUsIGp1c3QgbWFrZSBzdXJlIHRvIHByZXBhcmUgdGhlbVxuICAgICAgICAjICAgd2l0aCBwcmVwYXJlVGl0bGVDYXNpbmdcbiAgICAgICAgIyBEbyAqbm90KiB1c2UgdGhlIGcgZmxhZywgb3Igd2hlbiB1c2luZyBSZWdFeHAuZXhlYyB0aGUgaW5kZXggd2lsbFxuICAgICAgICAjICAgaGF2ZSB0byBiZSByZXNldCBhdCBldmVyeSBsb29wXG4gICAgICAgIHJlZ0V4cCA9IG5ldyBSZWdFeHAoXCJeKFxcXFxzKlwiICsgKGlmIHRlbXBsYXRlc09ubHkgdGhlbiBcIlwiIGVsc2UgXCI6P1wiKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJbXyBdKihcIiArIHBhdHRlcm4gKyBcIilbXyBdKlxcXFxzKilcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIoPzpcXFxcfChbXFxcXHNcXFxcU10qKSk/JFwiLCBcIlwiKVxuXG4gICAgICAgIG5Tb3VyY2UgPSBAbmV1dHJhbGl6ZU5vd2lraVRhZ3Moc291cmNlKVxuICAgICAgICB0cmFuc2NsdXNpb25zID0gW11cbiAgICAgICAgZGJyYWNrZXRzID0gU3RyLmZpbmROZXN0ZWRFbmNsb3N1cmVzKG5Tb3VyY2UsIFwie3tcIiwgXCJ9fVwiLCBcInhcIilbMF1cblxuICAgICAgICBmb3IgZGJyYWNrZXQgaW4gZGJyYWNrZXRzXG4gICAgICAgICAgICBpblRleHQgPSBzb3VyY2Uuc3Vic3RyaW5nKGRicmFja2V0WzBdICsgMiwgZGJyYWNrZXRbMV0pXG4gICAgICAgICAgICBtYXRjaCA9IHJlZ0V4cC5leGVjKGluVGV4dClcblxuICAgICAgICAgICAgaWYgbWF0Y2hcbiAgICAgICAgICAgICAgICAjIDMgaXMgdGhlIGxlbmd0aCBvZiBcInt7XCIgKyB0aGUgZmlyc3QgXCJ8XCJcbiAgICAgICAgICAgICAgICBhcmdJbmRleCA9IGRicmFja2V0WzBdICsgbWF0Y2hbMV0ubGVuZ3RoICsgM1xuXG4gICAgICAgICAgICAgICAgdHJhbnNjbHVzaW9ucy5wdXNoKFxuICAgICAgICAgICAgICAgICAgICBcInJhd1RyYW5zY2x1c2lvblwiOiBcInt7XCIgKyBtYXRjaFswXSArIFwifX1cIlxuICAgICAgICAgICAgICAgICAgICBcInRpdGxlXCI6IG1hdGNoWzJdXG4gICAgICAgICAgICAgICAgICAgIFwiaW5kZXhcIjogZGJyYWNrZXRbMF1cbiAgICAgICAgICAgICAgICAgICAgXCJsZW5ndGhcIjogZGJyYWNrZXRbMV0gLSBkYnJhY2tldFswXSArIDJcbiAgICAgICAgICAgICAgICAgICAgXCJhcmd1bWVudHNcIjogQGZpbmRUcmFuc2NsdXNpb25Bcmd1bWVudHMobWF0Y2gsIGFyZ0luZGV4KVxuICAgICAgICAgICAgICAgIClcblxuICAgICAgICByZXR1cm4gdHJhbnNjbHVzaW9uc1xuXG4gICAgZmluZFRyYW5zY2x1c2lvbkFyZ3VtZW50czogKG1hdGNoLCBhcmdJbmRleCkgLT5cbiAgICAgICAgcmF3QXJndW1lbnRzID0gbWF0Y2hbM11cbiAgICAgICAgYXJncyA9IFtdXG5cbiAgICAgICAgaWYgcmF3QXJndW1lbnRzXG4gICAgICAgICAgICBuQXJncyA9IEBuZXV0cmFsaXplTm93aWtpVGFncyhyYXdBcmd1bWVudHMpXG5cbiAgICAgICAgICAgICMgTWFzayBhbnkgaW5uZXIgbGlua3MsIHNvIHRoYXQgdGhlaXIgXCJ8XCIgY2hhcmFjdGVycyB3b24ndCBiZVxuICAgICAgICAgICAgIyAgIGludGVycHJldGVkIGFzIGJlbG9uZ2luZyB0byB0aGUgdGVtcGxhdGVcbiAgICAgICAgICAgICMgICBOb3RlIHRoYXQgZG91YmxlIGJyYWNlcyAoXCJbW11dXCIpIFwiZXNjYXBlXCIgYSBwaXBlIGluIGEgdGVtcGxhdGVcbiAgICAgICAgICAgICMgICBhcmd1bWVudCBldmVuIGlmIGEgbGluayBpcyBub3QgY29ycmVjdGx5IGZvcm1lZCwgZS5nLiBbW3xdXSBvclxuICAgICAgICAgICAgIyAgIHVzaW5nIHVuYWxsb3dlZCBjaGFyYWN0ZXJzIGV0Yy5cbiAgICAgICAgICAgIG1hc2tlZEFyZ3MgPSBTdHIuZmluZE5lc3RlZEVuY2xvc3VyZXMobkFyZ3MsIFwiW1tcIiwgXCJdXVwiLCBcInhcIilbMV1cblxuICAgICAgICAgICAgIyBNYXNrIGFueSBpbm5lciB0ZW1wbGF0ZXMsIHNvIHRoYXQgdGhlaXIgXCJ8XCIgY2hhcmFjdGVycyB3b24ndCBiZVxuICAgICAgICAgICAgIyAgIGludGVycHJldGVkIGFzIGJlbG9uZ2luZyB0byB0aGUgb3V0ZXIgdGVtcGxhdGVcbiAgICAgICAgICAgIG1hc2tlZEFyZ3MgPSBTdHIuZmluZE5lc3RlZEVuY2xvc3VyZXMobWFza2VkQXJncywgXCJ7e1wiLCBcIn19XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwieFwiKVsxXVxuXG4gICAgICAgICAgICAjIEFsc28gdGFibGVzIHdvdWxkIGhhdmUgcGlwZXMsIGJ1dCB1c2luZyB0YWJsZXMgaW5zaWRlIHRlbXBsYXRlc1xuICAgICAgICAgICAgIyAgIGRvZXNuJ3Qgc2VlbSB0byBiZSBzdXBwb3J0ZWQgYnkgTWVkaWFXaWtpLCBleGNlcHQgaWYgZW5jbG9zaW5nXG4gICAgICAgICAgICAjICAgdGhlbSBpbiBzcGVjaWFsIHBhcnNlciBmdW5jdGlvbnMsIGUuZy5cbiAgICAgICAgICAgICMgICBodHRwOi8vd3d3Lm1lZGlhd2lraS5vcmcvd2lraS9FeHRlbnNpb246UGlwZV9Fc2NhcGUgd2hpY2hcbiAgICAgICAgICAgICMgICB3b3VsZCB0aGVuIGJlIHNhZmVseSBtYXNrZWQgYnkgdGhlIGZ1bmN0aW9uIGFib3ZlXG5cbiAgICAgICAgICAgICMgSW5jb21wbGV0ZSBsaW5rcyBhbmQgdGVtcGxhdGVzIGluIHRoZSBhcmd1bWVudHMgdGV4dCBoYXZlIGFuXG4gICAgICAgICAgICAjICAgYXBwYXJlbnRseSB3ZWlyZCBiZWhhdmlvdXIsIGhhcmQgdG8gcmV2ZXJzZS1lbmdpbmVlciwgc28gaXNzdWVcbiAgICAgICAgICAgICMgICBhIHdhcm5pbmcgd2hlbiBvbmUgaXMgZm91bmRcbiAgICAgICAgICAgICMgICBUcnkgZm9yIGV4YW1wbGUgdGhlIGZvbGxvd2luZyBjYXNlczpcbiAgICAgICAgICAgICMgICAgIDAwMHt7aGN8QkJCW1tBQUF8WlpafX1DQ0NdXTExMVxuICAgICAgICAgICAgIyAgICAgMDAwe3toY3xCQkJbW0FBQX19Q0NDfFpaWl1dMTExXG4gICAgICAgICAgICAjICAgICAwMDBbW0JCQnt7aGN8QUFBfFpaWl1dQ0NDfX0xMTFcbiAgICAgICAgICAgICMgICAgIDAwMHt7aGN8QkJCW1tBQUF8WlpafX1bW0tLS11dMTExMDAwe3toY3xBQUF8QkJCfX0xMTFcbiAgICAgICAgICAgICMgICAgIHt7YmN8e3tBY2N1cmFjeXxbW3Rlc3R9fV1dfX1cbiAgICAgICAgICAgICMgICAgIHt7YmN8e3tBY2N1cmFjeXxbW3Rlc3R8fX1dXX19XG4gICAgICAgICAgICAjICAgICB7e0FjY3VyYWN5fFtbfX1dXVxuICAgICAgICAgICAgIyAgICAge3tBY2N1cmFjeXxbW3Rlc3R8fX1dXVxuICAgICAgICAgICAgIyAgICAgW1t7e0FjY3VyYWN5fF1dfX1cbiAgICAgICAgICAgICMgICAgIFtbdGVzdHx7e0FjY3VyYWN5fF1dfX1cbiAgICAgICAgICAgICMgICAgIFtbdGVzdHx7e0FjY3VyYWN5fF1dXG4gICAgICAgICAgICAjICAgICBbW3Rlc3R8e3tpY3xhYWFdXX19XG4gICAgICAgICAgICAjICAgTm90ZSB0aGF0IHRoZSB0aXRsZSBhbHJlYWR5IGRvZXNuJ3QgYWxsb3cgXCJ7XCIsIFwifVwiLCBcIltcIiBub3JcbiAgICAgICAgICAgICMgICAgIFwiXVwiXG4gICAgICAgICAgICBpZiBtYXNrZWRBcmdzLnNlYXJjaCgvKFxce1xce3xcXH1cXH18XFxbXFxbfFxcXVxcXSkvKSA+IC0xXG4gICAgICAgICAgICAgICAgQFdNLkxvZy5sb2dXYXJuaW5nKFwie3tcIiArIG1hdGNoWzBdICsgXCJ9fSBzZWVtcyB0b1xuICAgICAgICAgICAgICAgICAgICBjb250YWluIHBhcnQgb2YgYSBsaW5rIG9yIHRlbXBsYXRlLCBhbmQgdGhlIHJlc3VsdGluZ1xuICAgICAgICAgICAgICAgICAgICBiZWhhdmlvdXIgY2Fubm90IGJlIHByZWRpY3RlZCBieSB0aGlzIGZ1bmN0aW9uLCBzb1xuICAgICAgICAgICAgICAgICAgICB0aGUgd2hvbGUgdGVtcGxhdGUgd2lsbCBiZSBpZ25vcmVkIGFsdG9nZXRoZXJcIilcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBtQXJncyA9IG1hc2tlZEFyZ3Muc3BsaXQoXCJ8XCIpXG4gICAgICAgICAgICAgICAgcmVsSW5kZXggPSAwXG5cbiAgICAgICAgICAgICAgICBmb3IgbUFyZ3VtZW50IGluIG1BcmdzXG4gICAgICAgICAgICAgICAgICAgIGFyZ0wgPSBtQXJndW1lbnQubGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50ID0gcmF3QXJndW1lbnRzLnN1YnN0cihyZWxJbmRleCwgYXJnTClcbiAgICAgICAgICAgICAgICAgICAgZXFJbmRleCA9IG1Bcmd1bWVudC5pbmRleE9mKFwiPVwiKVxuXG4gICAgICAgICAgICAgICAgICAgICMgZXFJbmRleCBtdXN0IGJlID4gMCwgbm90IC0xLCBpbiBmYWN0IHRoZSBrZXkgbXVzdCBub3QgYmVcbiAgICAgICAgICAgICAgICAgICAgIyAgIGVtcHR5XG4gICAgICAgICAgICAgICAgICAgIGlmIGVxSW5kZXggPiAwXG4gICAgICAgICAgICAgICAgICAgICAgICByYXdLZXkgPSBhcmd1bWVudC5zdWJzdHJpbmcoMCwgZXFJbmRleClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlS2V5ID0gL14oXFxzKikoLis/KVxccyokL1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5TWF0Y2hlcyA9IHJlS2V5LmV4ZWMocmF3S2V5KVxuICAgICAgICAgICAgICAgICAgICAgICAga2V5ID0ga2V5TWF0Y2hlc1syXVxuICAgICAgICAgICAgICAgICAgICAgICAga2V5SW5kZXggPSBhcmdJbmRleCArIChpZiBrZXlNYXRjaGVzWzFdIHRoZW4ga2V5TWF0Y2hlc1sxXS5sZW5ndGggZWxzZSAwKVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAjIDEgaXMgdGhlIGxlbmd0aCBvZiBcIj1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBhcmd1bWVudC5zdWJzdHIoZXFJbmRleCArIDEpXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZUluZGV4ID0gYXJnSW5kZXggKyBrZXlNYXRjaGVzWzBdLmxlbmd0aCArIDFcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAga2V5ID0gbnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAga2V5SW5kZXggPSBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGFyZ3VtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZUluZGV4ID0gYXJnSW5kZXhcblxuICAgICAgICAgICAgICAgICAgICBhcmdzLnB1c2goXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6IGtleVxuICAgICAgICAgICAgICAgICAgICAgICAga2V5X2luZGV4OiBrZXlJbmRleFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZV9pbmRleDogdmFsdWVJbmRleFxuICAgICAgICAgICAgICAgICAgICApXG5cbiAgICAgICAgICAgICAgICAgICAgIyAxIGlzIHRoZSBsZW5ndGggb2YgXCJ8XCJcbiAgICAgICAgICAgICAgICAgICAgcmVsSW5kZXggKz0gYXJnTCArIDFcblxuICAgICAgICByZXR1cm4gYXJnc1xuXG4gICAgZmluZFRlbXBsYXRlczogKHNvdXJjZSwgdGVtcGxhdGUpIC0+XG4gICAgICAgIGlmIHRlbXBsYXRlXG4gICAgICAgICAgICBwYXR0ZXJuID0gUmVnRXguZXNjYXBlUGF0dGVybih0ZW1wbGF0ZSlcbiAgICAgICAgICAgIHBhdHRlcm4gPSBwcmVwYXJlUmVnZXhwV2hpdGVzcGFjZShwYXR0ZXJuKVxuICAgICAgICAgICAgcGF0dGVybiA9IHByZXBhcmVUaXRsZUNhc2luZyhwYXR0ZXJuKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICBwYXR0ZXJuID0gXCJbXlxcXFxuXFxcXHtcXFxcfVxcXFxbXFxcXF1cXFxcfHxcXFxcI10rP1wiXG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZmluZFRlbXBsYXRlc1BhdHRlcm4oc291cmNlLCBwYXR0ZXJuKVxuXG4gICAgZmluZFRlbXBsYXRlc1BhdHRlcm46IChzb3VyY2UsIHBhdHRlcm4pIC0+XG4gICAgICAgICMgcGF0dGVybiBtdXN0IGJlIGEgc3RyaW5nIGFuZCBJVCBNVVNUIE5PVCBIQVZFIEFOWSBDQVBUVVJJTkdcbiAgICAgICAgIyAgIEdST1VQU1xuICAgICAgICAjIE1ha2Ugc3VyZSB0byBwcmVwYXJlIHdoaXRlc3BhY2UgaW4gcGF0dGVybiBsaWtlIGluXG4gICAgICAgICMgICBwcmVwYXJlUmVnZXhwV2hpdGVzcGFjZVxuICAgICAgICAjIFRlbXBsYXRlcyBjYW4ndCBiZSB0cmFuc2NsdWRlZCB3aXRoIGEgY29sb24gYmVmb3JlIHRoZSB0aXRsZVxuICAgICAgICAjIFRoZSB0aXRsZSBtdXN0IG5vdCBiZSBicm9rZW4gYnkgbmV3IGxpbmUgY2hhcmFjdGVyczsgYW55IHVuZGVyc2NvcmVzXG4gICAgICAgICMgICBtdXN0IGJlIGluIHRoZSBzYW1lIGxpbmUgYXMgdGhlIHRpdGxlLCBldmVuIHRob3VnaCB0aGVuIHRoZXkgYXJlXG4gICAgICAgICMgICBjb25zaWRlcmVkIGFzIHdoaXRlc3BhY2VcbiAgICAgICAgcmV0dXJuIEBmaW5kVHJhbnNjbHVzaW9uc0VuZ2luZShzb3VyY2UsIHBhdHRlcm4sIHRydWUpXG5cbiAgICBmaW5kVHJhbnNjbHVzaW9uczogKHNvdXJjZSwgbmFtZXNwYWNlLCB0aXRsZSkgLT5cbiAgICAgICAgIyBUaGUgZGlmZmVyZW5jZSBmcm9tIHRlbXBsYXRlcyBpcyB0aGUgcG9zc2liaWxpdHkgb2YgYSBjb2xvbiBiZWZvcmVcbiAgICAgICAgIyAgIHRoZSB0aXRsZSB3aGljaCBmb3JjZXMgdGhlIHRyYW5zY2x1c2lvbiBvZiBhIHBhZ2UgaW5zdGVhZCBvZiBhXG4gICAgICAgICMgICB0ZW1wbGF0ZVxuICAgICAgICAjIFRoZXJlIGNhbid0IGJlIGFuIHVuZGVyc2NvcmUgYmVmb3JlIHRoZSBjb2xvblxuICAgICAgICAjIFRoZSB0aXRsZSBtdXN0IG5vdCBiZSBicm9rZW4gYnkgbmV3IGxpbmUgY2hhcmFjdGVyczsgYW55IHVuZGVyc2NvcmVzXG4gICAgICAgICMgICBtdXN0IGJlIGluIHRoZSBzYW1lIGxpbmUgYXMgdGhlIHRpdGxlLCBldmVuIHRob3VnaCB0aGVuIHRoZXkgYXJlXG4gICAgICAgICMgICBjb25zaWRlcmVkIGFzIHdoaXRlc3BhY2VcbiAgICAgICAgdGl0bGVDaGFycyA9IFwiW15cXFxcblxcXFx7XFxcXH1cXFxcW1xcXFxdXFxcXHx8XFxcXCNdKz9cIlxuXG4gICAgICAgIGlmIG5hbWVzcGFjZVxuICAgICAgICAgICAgbmFtZXNwYWNlUGF0dGVybiA9IFJlZ0V4LmVzY2FwZVBhdHRlcm4obmFtZXNwYWNlKVxuICAgICAgICAgICAgbmFtZXNwYWNlUGF0dGVybiA9IHByZXBhcmVSZWdleHBXaGl0ZXNwYWNlKG5hbWVzcGFjZVBhdHRlcm4pXG4gICAgICAgICAgICBuYW1lc3BhY2VQYXR0ZXJuID0gcHJlcGFyZVRpdGxlQ2FzaW5nKG5hbWVzcGFjZVBhdHRlcm4pXG5cbiAgICAgICAgaWYgdGl0bGVcbiAgICAgICAgICAgIHRpdGxlUGF0dGVybiA9IFJlZ0V4LmVzY2FwZVBhdHRlcm4odGl0bGUpXG4gICAgICAgICAgICB0aXRsZVBhdHRlcm4gPSBwcmVwYXJlUmVnZXhwV2hpdGVzcGFjZSh0aXRsZVBhdHRlcm4pXG4gICAgICAgICAgICB0aXRsZVBhdHRlcm4gPSBwcmVwYXJlVGl0bGVDYXNpbmcodGl0bGVQYXR0ZXJuKVxuXG4gICAgICAgIGlmIG5hbWVzcGFjZVBhdHRlcm4gYW5kIHRpdGxlUGF0dGVyblxuICAgICAgICAgICAgcGF0dGVybiA9IG5hbWVzcGFjZVBhdHRlcm4gKyBcIlsgX10qOlsgX10qXCIgKyB0aXRsZVBhdHRlcm5cbiAgICAgICAgZWxzZSBpZiBub3QgbmFtZXNwYWNlUGF0dGVybiBhbmQgdGl0bGVQYXR0ZXJuXG4gICAgICAgICAgICBwYXR0ZXJuID0gdGl0bGVQYXR0ZXJuXG4gICAgICAgIGVsc2UgaWYgbmFtZXNwYWNlUGF0dGVybiBhbmQgbm90IHRpdGxlUGF0dGVyblxuICAgICAgICAgICAgcGF0dGVybiA9IG5hbWVzcGFjZVBhdHRlcm4gKyBcIlsgX10qOlwiICsgdGl0bGVDaGFyc1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBwYXR0ZXJuID0gdGl0bGVDaGFyc1xuXG4gICAgICAgIHJldHVybiBAZmluZFRyYW5zY2x1c2lvbnNFbmdpbmUoc291cmNlLCBwYXR0ZXJuLCBmYWxzZSlcblxuICAgIGZpbmRTZWN0aW9uSGVhZGluZ3M6IChzb3VyY2UpIC0+XG4gICAgICAgICMgPT09PT09VGl0bGU9PT09PT0gaXMgdGhlIGRlZXBlc3QgbGV2ZWwgc3VwcG9ydGVkXG4gICAgICAgIE1BWExFVkVMID0gNlxuXG4gICAgICAgIHNlY3Rpb25zID0gW11cbiAgICAgICAgbWluTGV2ZWwgPSBNQVhMRVZFTFxuICAgICAgICBtYXhUb2NMZXZlbCA9IDBcbiAgICAgICAgdG9jTGV2ZWwgPSAxXG4gICAgICAgIHJlZ0V4cCA9IC9eKFxcPSsoWyBfXSooLis/KVsgX10qKVxcPSspWyBcXHRdKiQvZ21cblxuICAgICAgICB3aGlsZSB0cnVlXG4gICAgICAgICAgICBtYXRjaCA9IHJlZ0V4cC5leGVjKHNvdXJjZSlcblxuICAgICAgICAgICAgaWYgbWF0Y2hcbiAgICAgICAgICAgICAgICBMMCA9IG1hdGNoWzBdLmxlbmd0aFxuICAgICAgICAgICAgICAgIGxpbmUgPSBtYXRjaFsxXVxuICAgICAgICAgICAgICAgIHJhd2hlYWRpbmcgPSBtYXRjaFsyXVxuICAgICAgICAgICAgICAgIGhlYWRpbmcgPSBtYXRjaFszXVxuICAgICAgICAgICAgICAgIGNsZWFuaGVhZGluZyA9IEBzcXVhc2hDb250aWd1b3VzV2hpdGVzcGFjZShoZWFkaW5nKVxuICAgICAgICAgICAgICAgIEwxID0gbGluZS5sZW5ndGhcbiAgICAgICAgICAgICAgICBsZXZlbCA9IDFcbiAgICAgICAgICAgICAgICBzdGFydCA9IFwiPVwiXG4gICAgICAgICAgICAgICAgZW5kID0gXCI9XCJcblxuICAgICAgICAgICAgICAgICMgPT1UaXRsZT09PSBhbmQgPT09VGl0bGU9PSBhcmUgYm90aCAybmQgbGV2ZWxzIGFuZCBzbyBvblxuICAgICAgICAgICAgICAgICMgKHRoZSBzaG9ydGVzdCBzZXF1ZW5jZSBvZiA9IGJldHdlZW4gdGhlIHR3byBzaWRlcyBpc1xuICAgICAgICAgICAgICAgICMgIGNvbnNpZGVyZWQpXG5cbiAgICAgICAgICAgICAgICAjID0gYW5kID09IGFyZSBub3QgdGl0bGVzXG4gICAgICAgICAgICAgICAgIyA9PT0gaXMgcmVhZCBhcyA9KD0pPSwgPT09PSBpcyByZWFkIGFzID0oPT0pPSAoYm90aCAxc3RcbiAgICAgICAgICAgICAgICAjICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXZlbHMpXG4gICAgICAgICAgICAgICAgIyA9PT09PSBpcyByZWFkIGFzID09KD0pPT0gKDJuZCBsZXZlbCkgYW5kIHNvIG9uXG5cbiAgICAgICAgICAgICAgICB3aGlsZSB0cnVlXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gbGluZS5zdWJzdHIobGV2ZWwsIDEpXG4gICAgICAgICAgICAgICAgICAgIGVuZCA9IGxpbmUuc3Vic3RyKEwxIC0gbGV2ZWwgLSAxLCAxKVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIEwxIC0gbGV2ZWwgKiAyID4gMiBhbmQgc3RhcnQgPT0gXCI9XCIgYW5kIGVuZCA9PSBcIj1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgbGV2ZWwrK1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiBsZXZlbCA+IE1BWExFVkVMXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV2ZWwgPSBNQVhMRVZFTFxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiBsZXZlbCA8IG1pbkxldmVsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluTGV2ZWwgPSBsZXZlbFxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcblxuICAgICAgICAgICAgICAgIGlmIGxldmVsID09IG1pbkxldmVsXG4gICAgICAgICAgICAgICAgICAgIHRvY0xldmVsID0gMVxuICAgICAgICAgICAgICAgICAgICBwcmV2TGV2ZWxzID0ge31cbiAgICAgICAgICAgICAgICAgICAgcHJldkxldmVsc1tsZXZlbF0gPSAxXG4gICAgICAgICAgICAgICAgICAgIHByZXZMZXZlbHMucmVsTWF4ID0gbGV2ZWxcbiAgICAgICAgICAgICAgICAgICAgaWYgbWF4VG9jTGV2ZWwgPT0gMFxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4VG9jTGV2ZWwgPSB0b2NMZXZlbFxuICAgICAgICAgICAgICAgIGVsc2UgaWYgbGV2ZWwgPiBwcmV2TGV2ZWxzLnJlbE1heFxuICAgICAgICAgICAgICAgICAgICB0b2NMZXZlbCsrXG4gICAgICAgICAgICAgICAgICAgIHByZXZMZXZlbHNbbGV2ZWxdID0gdG9jTGV2ZWxcbiAgICAgICAgICAgICAgICAgICAgcHJldkxldmVscy5yZWxNYXggPSBsZXZlbFxuICAgICAgICAgICAgICAgICAgICBpZiB0b2NMZXZlbCA+IG1heFRvY0xldmVsXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhUb2NMZXZlbCA9IHRvY0xldmVsXG4gICAgICAgICAgICAgICAgZWxzZSBpZiBsZXZlbCA8IHByZXZMZXZlbHMucmVsTWF4XG4gICAgICAgICAgICAgICAgICAgIGlmIHByZXZMZXZlbHNbbGV2ZWxdXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2NMZXZlbCA9IHByZXZMZXZlbHNbbGV2ZWxdXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICMgdG9jUGVlciBpcyB0aGUgbGV2ZWwgaW1tZWRpYXRlbHkgZ3JlYXRlciB0aGFuIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgIyBjdXJyZW50IG9uZSwgYW5kIGl0IHNob3VsZCBoYXZlIHRoZSBzYW1lIHRvY0xldmVsXG4gICAgICAgICAgICAgICAgICAgICAgICAjIEkgbXVzdCByZXNldCB0b2NQZWVyIGhlcmUgdG8gdGhlIHJlbGF0aXZlIG1heGltdW1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRvY1BlZXIgPSBwcmV2TGV2ZWxzLnJlbE1heFxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIHBMZXZlbCBpbiBwcmV2TGV2ZWxzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgcExldmVsID4gbGV2ZWwgYW5kIHBMZXZlbCA8IHRvY1BlZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9jUGVlciA9IHBMZXZlbFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9jTGV2ZWwgPSBwcmV2TGV2ZWxzW3RvY1BlZXJdXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2TGV2ZWxzW2xldmVsXSA9IHRvY0xldmVsXG4gICAgICAgICAgICAgICAgICAgIHByZXZMZXZlbHMucmVsTWF4ID0gbGV2ZWxcblxuICAgICAgICAgICAgICAgIHNlY3Rpb25zLnB1c2goXG4gICAgICAgICAgICAgICAgICAgIGxpbmU6IGxpbmVcbiAgICAgICAgICAgICAgICAgICAgcmF3aGVhZGluZzogcmF3aGVhZGluZ1xuICAgICAgICAgICAgICAgICAgICBoZWFkaW5nOiBoZWFkaW5nXG4gICAgICAgICAgICAgICAgICAgIGNsZWFuaGVhZGluZzogY2xlYW5oZWFkaW5nXG4gICAgICAgICAgICAgICAgICAgIGxldmVsOiBsZXZlbFxuICAgICAgICAgICAgICAgICAgICB0b2NMZXZlbDogdG9jTGV2ZWxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IChyZWdFeHAubGFzdEluZGV4IC0gTDApXG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aDA6IEwwXG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aDE6IEwxXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgIyBBcnRpY2xlcyB3aXRob3V0IHNlY3Rpb25zXG4gICAgICAgIGlmIG1heFRvY0xldmVsID09IDBcbiAgICAgICAgICAgIG1pbkxldmVsID0gMFxuXG4gICAgICAgIHJldHVybiB7c2VjdGlvbnM6IHNlY3Rpb25zLCBtaW5MZXZlbDogbWluTGV2ZWwsIG1heFRvY0xldmVsOiBtYXhUb2NMZXZlbH1cbiIsIiMgV2lraSBNb25rZXkgLSBNZWRpYVdpa2kgYm90IGFuZCBlZGl0b3ItYXNzaXN0YW50IHVzZXIgc2NyaXB0XG4jIENvcHlyaWdodCAoQykgMjAxMSBEYXJpbyBHaW92YW5uZXR0aSA8ZGV2QGRhcmlvZ2lvdmFubmV0dGkubmV0PlxuI1xuIyBUaGlzIGZpbGUgaXMgcGFydCBvZiBXaWtpIE1vbmtleS5cbiNcbiMgV2lraSBNb25rZXkgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuIyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuIyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuIyAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuI1xuIyBXaWtpIE1vbmtleSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuIyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuIyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4jIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4jXG4jIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4jIGFsb25nIHdpdGggV2lraSBNb25rZXkuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG5cblxuY2xhc3MgbW9kdWxlLmV4cG9ydHNcbiAgICBjb25zdHJ1Y3RvcjogKEBXTSkgLT5cblxuICAgIHJvdXRlOiAtPlxuICAgICAgICAjIE1XIHNlZW1zIGEgYml0IHVucmVsaWFibGUgd2l0aCBjYXBpdGFsaXphdGlvbiwgZS5nLiBpdCdzXG4gICAgICAgICMgXCJTcGVjaWFsUGFnZXNcIiBidXQgXCJSZWNlbnRjaGFuZ2VzXCJcbiAgICAgICAgc3BlY2lhbFBhZ2UgPSBkbyAtPlxuICAgICAgICAgICAgc3BhZ2UgPSBtdy5jb25maWcuZ2V0KCd3Z0Nhbm9uaWNhbFNwZWNpYWxQYWdlTmFtZScpXG4gICAgICAgICAgICBpZiBzcGFnZVxuICAgICAgICAgICAgICAgIHJldHVybiBzcGFnZS50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgICByZXR1cm4gc3BhZ2VcblxuICAgICAgICBkaXNwbGF5ID0gdHJ1ZVxuICAgICAgICBkaXNwbGF5TG9nID0gdHJ1ZVxuXG4gICAgICAgICMgVE9ETzogUmVjb2duaXplIHRoZSBlZGl0b3Igd2l0aCBtdy5jb25maWcuZ2V0KCd3Z0FjdGlvbicpP1xuICAgICAgICBpZiAkKCcjZWRpdGZvcm0nKS5sZW5ndGhcbiAgICAgICAgICAgIG5leHROb2RlID0gJCgnI3dwU3VtbWFyeUxhYmVsJykucGFyZW50KCkubmV4dCgpWzBdXG4gICAgICAgICAgICBjb25mID0gQFdNLlBsdWdpbnMuZWRpdG9yXG4gICAgICAgICAgICBVSSA9IGlmIGNvbmYubGVuZ3RoIHRoZW4gQFdNLk1lbnUuX21ha2VVSSgnZWRpdG9yJywgY29uZikgZWxzZSBudWxsXG4gICAgICAgICAgICBAV00uTW9kcy5hcHBseUVkaXRvck1vZHMoKVxuXG4gICAgICAgIGVsc2UgaWYgbXcuY29uZmlnLmdldCgnd2dEaWZmTmV3SWQnKVxuICAgICAgICAgICAgbmV4dE5vZGUgPSAkKCcjYm9keUNvbnRlbnQgaDInKS5maXJzdCgpWzBdXG4gICAgICAgICAgICBjb25mID0gQFdNLlBsdWdpbnMuZGlmZlxuICAgICAgICAgICAgVUkgPSBpZiBjb25mLmxlbmd0aCB0aGVuIEBXTS5NZW51Ll9tYWtlVUkoJ2RpZmYnLCBjb25mKSBlbHNlIG51bGxcblxuICAgICAgICBlbHNlIGlmIG13LmNvbmZpZy5nZXQoJ3dnQ2Fub25pY2FsTmFtZXNwYWNlJykgaXMgJ0NhdGVnb3J5J1xuICAgICAgICAgICAgbmV4dE5vZGUgPSAkKCcjY29udGVudFN1YicpWzBdXG4gICAgICAgICAgICBjb25mID0gQFdNLlBsdWdpbnMuYm90XG4gICAgICAgICAgICBVSSA9IGlmIGNvbmYubGVuZ3RoIFxcXG4gICAgICAgICAgICAgICAgdGhlbiBAV00uQm90Ll9tYWtlVUkoY29uZiwgW1xuICAgICAgICAgICAgICAgICAgICBbJCgnI213LXBhZ2VzJylbMF0sIDAsIFwiUGFnZXNcIl1cbiAgICAgICAgICAgICAgICAgICAgWyQoJyNtdy1zdWJjYXRlZ29yaWVzJylbMF0sIDAsIFwiU3ViY2F0ZWdvcmllc1wiXVxuICAgICAgICAgICAgICAgIF0pIGVsc2UgbnVsbFxuICAgICAgICAgICAgZGlzcGxheSA9IGZhbHNlXG5cbiAgICAgICAgZWxzZSBpZiBzcGVjaWFsUGFnZSBpcyBcIndoYXRsaW5rc2hlcmVcIlxuICAgICAgICAgICAgbmV4dE5vZGUgPSAkKCcjYm9keUNvbnRlbnQgZm9ybScpLmZpcnN0KCkubmV4dCgpWzBdXG4gICAgICAgICAgICBjb25mID0gQFdNLlBsdWdpbnMuYm90XG4gICAgICAgICAgICBVSSA9IGlmIGNvbmYubGVuZ3RoIFxcXG4gICAgICAgICAgICAgICAgdGhlbiBAV00uQm90Ll9tYWtlVUkoY29uZiwgW1xuICAgICAgICAgICAgICAgICAgICBbJCgnI213LXdoYXRsaW5rc2hlcmUtbGlzdCcpWzBdLCAwLCBcIlBhZ2VzXCJdXG4gICAgICAgICAgICAgICAgXSkgZWxzZSBudWxsXG4gICAgICAgICAgICBkaXNwbGF5ID0gZmFsc2VcblxuICAgICAgICBlbHNlIGlmIHNwZWNpYWxQYWdlIGlzIFwibGlua3NlYXJjaFwiIGFuZFxuICAgICAgICAgICAgICAgICQoJyNtdy1jb250ZW50LXRleHQgZGl2Lm13LXNwY29udGVudCcpLmxlbmd0aFxuICAgICAgICAgICAgbmV4dE5vZGUgPSAkKCcjbXctY29udGVudC10ZXh0IGRpdi5tdy1zcGNvbnRlbnQnKS5maXJzdCgpWzBdXG4gICAgICAgICAgICBjb25mID0gQFdNLlBsdWdpbnMuYm90XG4gICAgICAgICAgICBVSSA9IGlmIGNvbmYubGVuZ3RoIFxcXG4gICAgICAgICAgICAgICAgdGhlbiBAV00uQm90Ll9tYWtlVUkoY29uZiwgW1xuICAgICAgICAgICAgICAgICAgICBbJChuZXh0Tm9kZSkuZmlyc3QoJ29sLnNwZWNpYWwnKS5maXJzdCgpWzBdLCAxLCBcIlBhZ2VzXCJdXG4gICAgICAgICAgICAgICAgXSkgZWxzZSBudWxsXG4gICAgICAgICAgICBkaXNwbGF5ID0gZmFsc2VcblxuICAgICAgICBlbHNlIGlmIHNwZWNpYWxQYWdlIGlzIFwicHJlZml4aW5kZXhcIlxuICAgICAgICAgICAgbmV4dE5vZGUgPSAkKCcjbXctY29udGVudC10ZXh0IGRpdi5tdy1wcmVmaXhpbmRleC1ib2R5JykuZmlyc3QoKVswXVxuICAgICAgICAgICAgY29uZiA9IEBXTS5QbHVnaW5zLmJvdFxuICAgICAgICAgICAgVUkgPSBpZiBjb25mLmxlbmd0aCBcXFxuICAgICAgICAgICAgICAgIHRoZW4gQFdNLkJvdC5fbWFrZVVJKGNvbmYsIFtcbiAgICAgICAgICAgICAgICAgICAgWyQobmV4dE5vZGUpLmZpbmQoJ3VsLm13LXByZWZpeGluZGV4LWxpc3QnKS5maXJzdCgpWzBdXG4gICAgICAgICAgICAgICAgICAgICAwLCBcIlBhZ2VzXCJdXG4gICAgICAgICAgICAgICAgXSkgZWxzZSBudWxsXG4gICAgICAgICAgICBkaXNwbGF5ID0gZmFsc2VcblxuICAgICAgICBlbHNlIGlmIHNwZWNpYWxQYWdlIGlzIFwic3BlY2lhbHBhZ2VzXCJcbiAgICAgICAgICAgIG5leHROb2RlID0gJCgnI2NvbnRlbnRTdWInKVswXVxuICAgICAgICAgICAgY29uZiA9IEBXTS5QbHVnaW5zLnNwZWNpYWxcbiAgICAgICAgICAgIFVJID0gaWYgY29uZi5sZW5ndGggXFxcbiAgICAgICAgICAgICAgICB0aGVuIEBXTS5NZW51Ll9tYWtlVUkoJ3NwZWNpYWwnLCBjb25mKSBlbHNlIG51bGxcblxuICAgICAgICBlbHNlIGlmIHNwZWNpYWxQYWdlIGlzIFwicmVjZW50Y2hhbmdlc1wiXG4gICAgICAgICAgICBuZXh0Tm9kZSA9ICQoJyNtdy1jb250ZW50LXRleHQgaDQnKS5maXJzdCgpWzBdXG4gICAgICAgICAgICBjb25mID0gQFdNLlBsdWdpbnMucmVjZW50Y2hhbmdlc1xuICAgICAgICAgICAgVUkgPSBpZiBjb25mLmxlbmd0aCBcXFxuICAgICAgICAgICAgICAgIHRoZW4gQFdNLkZpbHRlcnMuX21ha2VVSSgncmVjZW50Y2hhbmdlcycsIGNvbmYpIFxcXG4gICAgICAgICAgICAgICAgZWxzZSBudWxsXG4gICAgICAgICAgICBkaXNwbGF5TG9nID0gZmFsc2VcbiAgICAgICAgICAgIEBXTS5Nb2RzLmFwcGx5UmVjZW50Q2hhbmdlc01vZHMoKVxuXG4gICAgICAgIGVsc2UgaWYgc3BlY2lhbFBhZ2UgaXMgXCJuZXdwYWdlc1wiXG4gICAgICAgICAgICBuZXh0Tm9kZSA9ICQoJyNtdy1jb250ZW50LXRleHQgdWwnKS5maXJzdCgpWzBdXG4gICAgICAgICAgICBjb25mID0gQFdNLlBsdWdpbnMubmV3cGFnZXNcbiAgICAgICAgICAgIFVJID0gaWYgY29uZi5sZW5ndGggXFxcbiAgICAgICAgICAgICAgICB0aGVuIEBXTS5GaWx0ZXJzLl9tYWtlVUkoJ25ld3BhZ2VzJywgY29uZikgZWxzZSBudWxsXG4gICAgICAgICAgICBkaXNwbGF5TG9nID0gZmFsc2VcblxuICAgICAgICBlbHNlIGlmIHNwZWNpYWxQYWdlIGlzIFwicHJvdGVjdGVkcGFnZXNcIlxuICAgICAgICAgICAgbmV4dE5vZGUgPSAkKCcjbXctY29udGVudC10ZXh0IHRhYmxlLm13LXByb3RlY3RlZHBhZ2VzJykuZmlyc3QoKVswXVxuICAgICAgICAgICAgY29uZiA9IEBXTS5QbHVnaW5zLmJvdFxuICAgICAgICAgICAgVUkgPSBpZiBjb25mLmxlbmd0aCBcXFxuICAgICAgICAgICAgICAgIHRoZW4gQFdNLkJvdC5fbWFrZVVJKGNvbmYsIFtcbiAgICAgICAgICAgICAgICAgICAgWyQobmV4dE5vZGUpLmZpbmQoJ3Rib2R5JykuZmlyc3QoKVswXSwgMCwgXCJQYWdlc1wiXVxuICAgICAgICAgICAgICAgIF0pIGVsc2UgbnVsbFxuICAgICAgICAgICAgZGlzcGxheSA9IGZhbHNlXG5cbiAgICAgICAgZWxzZSBpZiBzcGVjaWFsUGFnZSBpcyBcImNvbnRyaWJ1dGlvbnNcIlxuICAgICAgICAgICAgQFdNLk1vZHMuYXBwbHlDb250cmlidXRpb25zTW9kcygpXG5cbiAgICAgICAgZWxzZSBpZiBzcGVjaWFsUGFnZSBpbiBbXG4gICAgICAgICAgICBcImFuY2llbnRwYWdlc1wiXG4gICAgICAgICAgICBcImJyb2tlbnJlZGlyZWN0c1wiXG4gICAgICAgICAgICBcImRlYWRlbmRwYWdlc1wiXG4gICAgICAgICAgICBcImRvdWJsZXJlZGlyZWN0c1wiXG4gICAgICAgICAgICBcImZld2VzdHJldmlzaW9uc1wiXG4gICAgICAgICAgICBcImxvbmVseXBhZ2VzXCJcbiAgICAgICAgICAgIFwidW5jYXRlZ29yaXplZGNhdGVnb3JpZXNcIlxuICAgICAgICAgICAgXCJ1bmNhdGVnb3JpemVkcGFnZXNcIlxuICAgICAgICAgICAgXCJ1bmNhdGVnb3JpemVkdGVtcGxhdGVzXCJcbiAgICAgICAgICAgIFwidW51c2VkY2F0ZWdvcmllc1wiXG4gICAgICAgICAgICBcInVud2F0Y2hlZHBhZ2VzXCJcbiAgICAgICAgXVxuICAgICAgICAgICAgbmV4dE5vZGUgPSAkKCcjbXctY29udGVudC10ZXh0IGRpdi5tdy1zcGNvbnRlbnQnKS5maXJzdCgpWzBdXG4gICAgICAgICAgICBjb25mID0gQFdNLlBsdWdpbnMuYm90XG4gICAgICAgICAgICBVSSA9IGlmIGNvbmYubGVuZ3RoIFxcXG4gICAgICAgICAgICAgICAgdGhlbiBAV00uQm90Ll9tYWtlVUkoY29uZiwgW1xuICAgICAgICAgICAgICAgICAgICBbJChuZXh0Tm9kZSkuZmluZCgnb2wnKS5maXJzdCgpWzBdLCAwLCBcIlBhZ2VzXCJdXG4gICAgICAgICAgICAgICAgXSkgZWxzZSBudWxsXG4gICAgICAgICAgICBkaXNwbGF5ID0gZmFsc2VcblxuICAgICAgICBlbHNlIGlmIHNwZWNpYWxQYWdlIGluIFtcbiAgICAgICAgICAgIFwibG9uZ3BhZ2VzXCJcbiAgICAgICAgICAgIFwic2hvcnRwYWdlc1wiXG4gICAgICAgIF1cbiAgICAgICAgICAgIG5leHROb2RlID0gJCgnI213LWNvbnRlbnQtdGV4dCBkaXYubXctc3Bjb250ZW50JykuZmlyc3QoKVswXVxuICAgICAgICAgICAgY29uZiA9IEBXTS5QbHVnaW5zLmJvdFxuICAgICAgICAgICAgVUkgPSBpZiBjb25mLmxlbmd0aCBcXFxuICAgICAgICAgICAgICAgIHRoZW4gQFdNLkJvdC5fbWFrZVVJKGNvbmYsIFtcbiAgICAgICAgICAgICAgICAgICAgWyQobmV4dE5vZGUpLmZpbmQoJ29sJykuZmlyc3QoKVswXSwgMSwgXCJQYWdlc1wiXVxuICAgICAgICAgICAgICAgIF0pIGVsc2UgbnVsbFxuICAgICAgICAgICAgZGlzcGxheSA9IGZhbHNlXG5cbiAgICAgICAgZWxzZSBpZiBzcGVjaWFsUGFnZSBpcyBcIndpdGhvdXRpbnRlcndpa2lcIlxuICAgICAgICAgICAgbmV4dE5vZGUgPSAkKCcjbXctY29udGVudC10ZXh0IGRpdi5tdy1zcGNvbnRlbnQgPiBwJykuZmlyc3QoKVswXVxuICAgICAgICAgICAgY29uZiA9IEBXTS5QbHVnaW5zLmJvdFxuICAgICAgICAgICAgVUkgPSBpZiBjb25mLmxlbmd0aCBcXFxuICAgICAgICAgICAgICAgIHRoZW4gQFdNLkJvdC5fbWFrZVVJKGNvbmYsIFtcbiAgICAgICAgICAgICAgICAgICAgWyQobmV4dE5vZGUpLm5leHRBbGwoJ29sJykuZmlyc3QoKVswXSwgMCwgXCJQYWdlc1wiXVxuICAgICAgICAgICAgICAgIF0pIGVsc2UgbnVsbFxuICAgICAgICAgICAgZGlzcGxheSA9IGZhbHNlXG5cbiAgICAgICAgZWxzZSBpZiBzcGVjaWFsUGFnZSBpcyBcImFsbHBhZ2VzXCJcbiAgICAgICAgICAgIG5leHROb2RlID0gJCgnI213LWNvbnRlbnQtdGV4dCBkaXYubXctYWxscGFnZXMtbmF2JykuZmlyc3QoKVswXVxuICAgICAgICAgICAgY29uZiA9IEBXTS5QbHVnaW5zLmJvdFxuICAgICAgICAgICAgVUkgPSBpZiBjb25mLmxlbmd0aCBcXFxuICAgICAgICAgICAgICAgIHRoZW4gQFdNLkJvdC5fbWFrZVVJKGNvbmYsIFtcbiAgICAgICAgICAgICAgICAgICAgWyQobmV4dE5vZGUpLm5leHRBbGwoJ2Rpdi5tdy1hbGxwYWdlcy1ib2R5JykuZmlyc3QoKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmZpbmQoJ3VsJykuZmlyc3QoKVswXVxuICAgICAgICAgICAgICAgICAgICAgMCwgXCJQYWdlc1wiXVxuICAgICAgICAgICAgICAgIF0pIGVsc2UgbnVsbFxuICAgICAgICAgICAgZGlzcGxheSA9IGZhbHNlXG5cbiAgICAgICAgaWYgVUlcbiAgICAgICAgICAgIEBXTS5VSS5fbWFrZVVJKHtkaXNwbGF5LCBkaXNwbGF5TG9nLCBuZXh0Tm9kZSwgVUl9KVxuIiwiIyBXaWtpIE1vbmtleSAtIE1lZGlhV2lraSBib3QgYW5kIGVkaXRvci1hc3Npc3RhbnQgdXNlciBzY3JpcHRcbiMgQ29weXJpZ2h0IChDKSAyMDExIERhcmlvIEdpb3Zhbm5ldHRpIDxkZXZAZGFyaW9naW92YW5uZXR0aS5uZXQ+XG4jXG4jIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFdpa2kgTW9ua2V5LlxuI1xuIyBXaWtpIE1vbmtleSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4jIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4jIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4jIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4jXG4jIFdpa2kgTW9ua2V5IGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4jIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4jIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiMgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbiNcbiMgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiMgYWxvbmcgd2l0aCBXaWtpIE1vbmtleS4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cblxuU3RyID0gcmVxdWlyZSgnQGt5bmlrb3MvbWlzYy9kaXN0L1N0cicpXG5cblxuY2xhc3MgbW9kdWxlLmV4cG9ydHNcbiAgICBjb25zdHJ1Y3RvcjogKEBXTSkgLT5cblxuICAgIGFwcGVuZFJvdzogKHNvdXJjZSwgbWFyaywgdmFsdWVzKSAtPlxuICAgICAgICBsYXN0SWQgPSBzb3VyY2UubGFzdEluZGV4T2YoJ3x9JyArIG1hcmspXG4gICAgICAgIGVuZHRhYmxlID0gaWYgbGFzdElkID4gLTEgdGhlbiBsYXN0SWQgZWxzZSBzb3VyY2UubGFzdEluZGV4T2YoJ3x9JylcblxuICAgICAgICByb3cgPSBcInwtXFxufFwiICsgdmFsdWVzLmpvaW4oXCJcXG58XCIpICsgXCJcXG5cIlxuXG4gICAgICAgIG5ld1RleHQgPSBTdHIuaW5zZXJ0KHNvdXJjZSwgcm93LCBlbmR0YWJsZSlcblxuICAgICAgICByZXR1cm4gbmV3VGV4dFxuIiwiIyBXaWtpIE1vbmtleSAtIE1lZGlhV2lraSBib3QgYW5kIGVkaXRvci1hc3Npc3RhbnQgdXNlciBzY3JpcHRcbiMgQ29weXJpZ2h0IChDKSAyMDExIERhcmlvIEdpb3Zhbm5ldHRpIDxkZXZAZGFyaW9naW92YW5uZXR0aS5uZXQ+XG4jXG4jIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFdpa2kgTW9ua2V5LlxuI1xuIyBXaWtpIE1vbmtleSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4jIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4jIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4jIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4jXG4jIFdpa2kgTW9ua2V5IGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4jIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4jIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiMgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbiNcbiMgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiMgYWxvbmcgd2l0aCBXaWtpIE1vbmtleS4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cblxue3ZlcnNpb259ID0gcmVxdWlyZSgnLi4vLi4vcGFja2FnZS5qc29uJylcbkNTUyA9IHJlcXVpcmUoJ0BreW5pa29zL21pc2MvZGlzdC9DU1MnKVxuXG5cbmNsYXNzIG1vZHVsZS5leHBvcnRzXG4gICAgY29uc3RydWN0b3I6IChAV00pIC0+XG5cbiAgICBfbWFrZVVJOiAoe2Rpc3BsYXksIGRpc3BsYXlMb2csIG5leHROb2RlLCBVSX0pIC0+XG4gICAgICAgIENTUy5hZGRTdHlsZUVsZW1lbnQoXCIjV2lraU1vbmtleSB7cG9zaXRpb246cmVsYXRpdmU7fVxuICAgICAgICAgICAgICAgICAgICAjV2lraU1vbmtleSBmaWVsZHNldCB7bWFyZ2luOjAgMCAxZW0gMDt9XCIpXG5cbiAgICAgICAgbWFpbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ZpZWxkc2V0JylcbiAgICAgICAgbWFpbi5pZCA9ICdXaWtpTW9ua2V5J1xuXG4gICAgICAgIGxlZ2VuZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xlZ2VuZCcpXG4gICAgICAgIGxlZ2VuZC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnV2lraSBNb25rZXkgJykpXG5cbiAgICAgICAgaGlkZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKVxuICAgICAgICBoaWRlLmhyZWYgPSAnI1dpa2lNb25rZXknXG4gICAgICAgIGhpZGUuaW5uZXJIVE1MID0gJ1toaWRlXSdcbiAgICAgICAgaGlkZS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKGV2ZW50KSAtPlxuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKVxuICAgICAgICAgICAgd21tYWluID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ1dpa2lNb25rZXlNYWluJylcbiAgICAgICAgICAgIGlmIHdtbWFpbi5zdHlsZS5kaXNwbGF5ID09ICdub25lJ1xuICAgICAgICAgICAgICAgIHdtbWFpbi5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJ1xuICAgICAgICAgICAgICAgIHRoaXMuaW5uZXJIVE1MID0gJ1toaWRlXSdcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB3bW1haW4uc3R5bGUuZGlzcGxheSA9ICdub25lJ1xuICAgICAgICAgICAgICAgIHRoaXMuaW5uZXJIVE1MID0gJ1tzaG93XSdcbiAgICAgICAgLCBmYWxzZSlcbiAgICAgICAgbGVnZW5kLmFwcGVuZENoaWxkKGhpZGUpXG5cbiAgICAgICAgbWFpbi5hcHBlbmRDaGlsZChsZWdlbmQpXG5cbiAgICAgICAgbWFpbjIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgICAgICBtYWluMi5pZCA9ICdXaWtpTW9ua2V5TWFpbidcblxuICAgICAgICBtYWluMi5hcHBlbmRDaGlsZChVSSlcblxuICAgICAgICBsb2dBcmVhID0gQFdNLkxvZy5fbWFrZUxvZ0FyZWEoKVxuICAgICAgICBpZiBub3QgZGlzcGxheUxvZ1xuICAgICAgICAgICAgbG9nQXJlYS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnXG5cbiAgICAgICAgbWFpbjIuYXBwZW5kQ2hpbGQobG9nQXJlYSlcblxuICAgICAgICBpZiBub3QgZGlzcGxheVxuICAgICAgICAgICAgbWFpbjIuc3R5bGUuZGlzcGxheSA9ICdub25lJ1xuICAgICAgICAgICAgaGlkZS5pbm5lckhUTUwgPSAnW3Nob3ddJ1xuXG4gICAgICAgIG1haW4uYXBwZW5kQ2hpbGQobWFpbjIpXG5cbiAgICAgICAgbmV4dE5vZGUucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobWFpbiwgbmV4dE5vZGUpXG5cbiAgICAgICAgQFdNLkxvZy5sb2dIaWRkZW4oXCJXaWtpIE1vbmtleSB2ZXJzaW9uOiAje3ZlcnNpb259XCIpXG4gICAgICAgIGRhdGUgPSBuZXcgRGF0ZSgpXG4gICAgICAgIEBXTS5Mb2cubG9nSGlkZGVuKFwiRGF0ZTogI3tkYXRlLnRvU3RyaW5nKCl9XCIpXG4gICAgICAgIEBXTS5Mb2cubG9nSGlkZGVuKFwiVVJMOiAje2xvY2F0aW9uLmhyZWZ9XCIpXG4iLCIjIFdpa2kgTW9ua2V5IC0gTWVkaWFXaWtpIGJvdCBhbmQgZWRpdG9yLWFzc2lzdGFudCB1c2VyIHNjcmlwdFxuIyBDb3B5cmlnaHQgKEMpIDIwMTEgRGFyaW8gR2lvdmFubmV0dGkgPGRldkBkYXJpb2dpb3Zhbm5ldHRpLm5ldD5cbiNcbiMgVGhpcyBmaWxlIGlzIHBhcnQgb2YgV2lraSBNb25rZXkuXG4jXG4jIFdpa2kgTW9ua2V5IGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiMgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiMgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiMgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbiNcbiMgV2lraSBNb25rZXkgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiMgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiMgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuIyBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuI1xuIyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuIyBhbG9uZyB3aXRoIFdpa2kgTW9ua2V5LiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuXG57bW9tZW50LCBBLCBCciwgRGl2fSA9IHJlcXVpcmUoJy4vbGlicycpXG57dmVyc2lvbn0gPSByZXF1aXJlKCcuLi8uLi9wYWNrYWdlLmpzb24nKVxuXG5cbmNsYXNzIG1vZHVsZS5leHBvcnRzXG4gICAgUkVQT19SQVdfVVJMID0gXCJodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20va3luaWtvcy93aWtpLW1vbmtleVwiXG5cbiAgICBjb25zdHJ1Y3RvcjogKEBXTSkgLT5cblxuICAgIGNoZWNrX2FuZF9ub3RpZnk6IC0+XG4gICAgICAgIGlmIEBzaG91bGRfY2hlY2soKVxuICAgICAgICAgICAgdXBzdHJlYW1fcGFja2FnZSA9IGF3YWl0ICQuZ2V0SlNPTihcbiAgICAgICAgICAgICAgICBcIiN7UkVQT19SQVdfVVJMfS8je0BXTS5jb25mLnVwZGF0ZV9jaGVja19icmFuY2h9L3BhY2thZ2UuanNvblwiKVxuICAgICAgICAgICAgIyBXZWxsLCBvaywgdGhpcyBpcyBhc3N1bWluZyB0aGF0IGlmIHRoZSB2ZXJzaW9ucyBhcmVcbiAgICAgICAgICAgICMgZGlmZmVyZW50LCB1cHN0cmVhbSBoYXMgdGhlIGxhdGVzdFxuICAgICAgICAgICAgaWYgdmVyc2lvbiAhPSB1cHN0cmVhbV9wYWNrYWdlLnZlcnNpb25cbiAgICAgICAgICAgICAgICBAZGlzcGxheV9ub3RpZmljYXRpb24oW1xuICAgICAgICAgICAgICAgICAgICBcIlZlcnNpb24gI3t1cHN0cmVhbV9wYWNrYWdlLnZlcnNpb259IGlzIGF2YWlsYWJsZS5cIlxuICAgICAgICAgICAgICAgICAgICBCcigpXG4gICAgICAgICAgICAgICAgICAgIEEoe2hyZWY6IFwiaHR0cHM6Ly9naXRodWIuY29tL2t5bmlrb3Mvd2lraS1tb25rZXkvd2lraS9DaGFuZ2Vsb2dcIn0gICMgbm9xYVxuICAgICAgICAgICAgICAgICAgICAgIFwiQ2hhbmdlbG9nXCIpXG4gICAgICAgICAgICAgICAgICAgIEJyKClcbiAgICAgICAgICAgICAgICAgICAgQSgnUnVuIHVwZ3JhZGUnLCB7b25jbGljazogPT5cbiAgICAgICAgICAgICAgICAgICAgICBAdXBncmFkZSh1cHN0cmVhbV9wYWNrYWdlLnZlcnNpb24pXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBtdy5zdG9yYWdlLnNldCgnV2lraU1vbmtleS1sYXN0LXVwZGF0ZS1jaGVjaycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9tZW50KCkuZm9ybWF0KCdZWVlZLU1NLUREJykpXG5cbiAgICBzaG91bGRfY2hlY2s6IC0+XG4gICAgICAgIGxhc3R1cGRjaGVjayA9IG13LnN0b3JhZ2UuZ2V0KCdXaWtpTW9ua2V5LWxhc3QtdXBkYXRlLWNoZWNrJylcbiAgICAgICAgaWYgbm90IGxhc3R1cGRjaGVja1xuICAgICAgICAgICAgcmV0dXJuIHRydWVcblxuICAgICAgICBkaWZmID0gbW9tZW50KCkuZGlmZihtb21lbnQobGFzdHVwZGNoZWNrKSwgJ2RheXMnKVxuICAgICAgICAjIFByZWZlcmFibHkgY2hlY2sgb24gdGhlIGNvbmZpZ3VyZWQgZGF5IG9mIHRoZSB3ZWVrLCBidXQgZG9uJ3QgbGV0XG4gICAgICAgICMgbW9yZSB0aGFuIDcgZGF5cyBwYXNzIHdpdGhvdXQgY2hlY2tpbmcgaW4gYW55IGNhc2VcbiAgICAgICAgaWYgKGRpZmYgPj0gMSBhbmQgbW9tZW50KCkuZGF5KCkgaW5cbiAgICAgICAgICAgICAgICBAV00uY29uZi51cGRhdGVfY2hlY2tfd2RheXMpIG9yIGRpZmYgPj0gN1xuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgcmV0dXJuIGZhbHNlXG5cbiAgICBkaXNwbGF5X25vdGlmaWNhdGlvbjogKGNvbnRlbnQsIG9wdGlvbnNvdmVycmlkZSkgLT5cbiAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGF1dG9IaWRlOiBmYWxzZVxuICAgICAgICAgICAgdGFnOiAnV2lraU1vbmtleS11cGdyYWRlJ1xuICAgICAgICAgICAgdGl0bGU6ICdXaWtpIE1vbmtleSdcbiAgICAgICAgICAgIHR5cGU6ICdpbmZvJ1xuICAgICAgICB9XG4gICAgICAgICQuZXh0ZW5kKG9wdGlvbnMsIG9wdGlvbnNvdmVycmlkZSlcbiAgICAgICAgbXcubm90aWZpY2F0aW9uLm5vdGlmeShjb250ZW50LCBvcHRpb25zKVxuXG4gICAgdXBncmFkZTogKHVwc3RyZWFtX3ZlcnNpb24pIC0+XG4gICAgICAgIHBhZ2UgPSBcIlVzZXI6I3ttdy51c2VyLmdldE5hbWUoKX0vY29tbW9uLmpzXCJcbiAgICAgICAgcGFnZWxpbmsgPSBAV00uTVcubGlua0FydGljbGUocGFnZSlcblxuICAgICAgICBAZGlzcGxheV9ub3RpZmljYXRpb24oXCJVcGdyYWRpbmcgdG8gdmVyc2lvbiAje3Vwc3RyZWFtX3ZlcnNpb259Li4uXCIpXG5cbiAgICAgICAgIyBUaGlzIHJlZ3VsYXIgZXhwcmVzc2lvbiBtdXN0IHN1cHBvcnQgYWxsIHZlcnNpb25zLCBpbmNsdWRpbmcgdGhlXG4gICAgICAgICMgLm1pbi5qc1xuICAgICAgICAjIFRPRE86IEFsbG93IHByZXZlbnRpbmcgdXBncmFkZXMgcGVyLWxpbmUgd2l0aCAvL25vdXBncmFkZSBjb21tZW50cz9cbiAgICAgICAgIyAgICAgICBEb24ndCB1cGdyYWRlIGNvbW1lbnRlZCBsaW5lcz9cbiAgICAgICAgcmVnZXggPSAvLy9cbiAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgICBbXCInXWh0dHBzPzovLy4rPy9reW5pa29zL3dpa2ktbW9ua2V5L3ZcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICN7bXcuUmVnRXhwLmVzY2FwZSh2ZXJzaW9uKX1cbiAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgICAvZGlzdC9XaWtpTW9ua2V5LVteL10rXFwuanNbXCInXVxuICAgICAgICAgICAgKVxuICAgICAgICAvLy9nXG5cbiAgICAgICAgQFdNLk1XLmFwaS5lZGl0KHBhZ2UsIChyZXZpc2lvbikgLT5cbiAgICAgICAgICAgIG5ld3RleHQgPSByZXZpc2lvbi5jb250ZW50LnJlcGxhY2UocmVnZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiJDEje3Vwc3RyZWFtX3ZlcnNpb259JDJcIilcblxuICAgICAgICAgICAgaWYgbmV3dGV4dCBpcyByZXZpc2lvbi5jb250ZW50XG4gICAgICAgICAgICAgICAgIyBFeGVjdXRpbmcgdGhlIHF1ZXJ5IHdvdWxkIHJldHVybiBhICdub2NoYW5nZTp0cnVlJyByZXN1bHQsXG4gICAgICAgICAgICAgICAgIyBidXQgd2UgY2FuIHRlc3QgaXQgYmVmb3JlIHNlbmRpbmcgaXRcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoXG4gICAgICAgICAgICAgICAgICAgIG5ldyBFcnJvcihcIkNvdWxkIG5vdCBmaW5kIFdpa2kgTW9ua2V5IGxvYWRlciBsaW5lXCIpKVxuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHRleHQ6IG5ld3RleHQsXG4gICAgICAgICAgICAgICAgc3VtbWFyeTogXCJVcGRhdGUgV2lraSBNb25rZXkgdG8gdmVyc2lvbiAje3Vwc3RyZWFtX3ZlcnNpb259XCIsXG4gICAgICAgICAgICAgICAgYm90OiB0cnVlLFxuICAgICAgICAgICAgfVxuICAgICAgICApLmRvbmUoKHJlc3VsdCkgPT5cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHJlc3VsdClcbiAgICAgICAgICAgIEBkaXNwbGF5X25vdGlmaWNhdGlvbihbXG4gICAgICAgICAgICAgICAgXCJVcGdyYWRlIHN1Y2Nlc3NmdWw6IHlvdSBuZWVkIHRvIHJlZnJlc2ggdGhlIG9wZW4gd2lraSBwYWdlKHMpXG4gICAgICAgICAgICAgICAgaW4gb3JkZXIgdG8gdXNlIHRoZSBuZXcgdmVyc2lvbi5cIlxuICAgICAgICAgICAgICAgIEJyKClcbiAgICAgICAgICAgICAgICBBKHtocmVmOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9reW5pa29zL3dpa2ktbW9ua2V5L3dpa2kvQ2hhbmdlbG9nXCJ9XG4gICAgICAgICAgICAgICAgICBcIkNoYW5nZWxvZ1wiKVxuICAgICAgICAgICAgXSlcbiAgICAgICAgKS5mYWlsKChjb2RlLCBlcnJvcikgPT5cbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoY29kZSwgZXJyb3IpXG4gICAgICAgICAgICBAZGlzcGxheV9ub3RpZmljYXRpb24oW1xuICAgICAgICAgICAgICAgIFwiQ291bGQgbm90IGNvbXBsZXRlIHRoZSB1cGdyYWRlIHRvIHZlcnNpb25cbiAgICAgICAgICAgICAgICAje3Vwc3RyZWFtX3ZlcnNpb259OiBcIixcbiAgICAgICAgICAgICAgICBBKHtvbmNsaWNrOiA9PlxuICAgICAgICAgICAgICAgICAgICBAdXBncmFkZSh1cHN0cmVhbV92ZXJzaW9uKVxuICAgICAgICAgICAgICAgIH0sIFwicmV0cnlcIiksXG4gICAgICAgICAgICAgICAgXCIgaW4gY2FzZSBpdCB3YXMgYSB0ZW1wb3JhcnkgcHJvYmxlbTsgaXQgaXMgYWxzbyBwb3NzaWJsZVxuICAgICAgICAgICAgICAgIHRoYXQgV2lraSBNb25rZXkgaXMgaW5zdGFsbGVkIGluIGEgbm9uLXN0YW5kYXJkIHdheSBpbiBcIixcbiAgICAgICAgICAgICAgICBwYWdlbGluaywgXCIgYW5kIHRoZSB1cGdyYWRlIHNob3VsZCBiZSBleGVjdXRlZCBtYW51YWxseTtcbiAgICAgICAgICAgICAgICBmaW5hbGx5LCBpdCBpcyBwb3NzaWJsZSB0aGF0IHRoZSB1cGdyYWRlIHdhcyBhbHJlYWR5IGxhdW5jaGVkXG4gICAgICAgICAgICAgICAgYW5kIGNvbXBsZXRlZCBmcm9tIGFub3RoZXIgcGFnZTogaW4gdGhpcyBjYXNlIHJlZnJlc2ggdGhlIHBhZ2VcbiAgICAgICAgICAgICAgICB0byB2ZXJpZnkuXCJcbiAgICAgICAgICAgIF0sIHt0eXBlOiAnZXJyb3InfSlcbiAgICAgICAgKVxuXG4gICAgY2hlY2tfb2Jzb2xldGVfY29uZmlnOiAtPlxuICAgICAgICAjIFRPRE86IFJlbW92ZSBpbiBhIGxhdGVyIHZlcnNpb25cbiAgICAgICAgb2xkY29uZiA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwiV2lraU1vbmtleVwiKVxuICAgICAgICBpZiBvbGRjb25mIGlzbnQgbnVsbFxuICAgICAgICAgICAgYmxvYiA9IG5ldyBCbG9iKFtvbGRjb25mXSwge3R5cGU6ICdhcHBsaWNhdGlvbi9qc29uJ30pXG4gICAgICAgICAgICBjb25maHJlZiA9IHdpbmRvdy5VUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpXG4gICAgICAgICAgICBAZGlzcGxheV9ub3RpZmljYXRpb24oW1xuICAgICAgICAgICAgICAgIFwiV2lraSBNb25rZXkgNC4wLjAgdXNlcyBhIGNvbXBsZXRlbHkgcmV3cml0dGVuIGNvbmZpZ3VyYXRpb25cbiAgICAgICAgICAgICAgICBzeXN0ZW0uIEFmdGVyIHVwZGF0aW5nLCB5b3VyIG9sZCBjb25maWd1cmF0aW9uIHdhcyBub3RcbiAgICAgICAgICAgICAgICBhdXRvbWF0aWNhbGx5IGltcG9ydGVkLCBidXQgaXQgaXMgc3RpbGwgc2F2ZWQgaW4geW91ciBicm93c2VyJ3NcbiAgICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2UuIFlvdSBjYW4gZGVjaWRlIHRvIGV4cG9ydCBpdCBhbmQgdGhlbiBtZXJnZSBpdFxuICAgICAgICAgICAgICAgIG1hbnVhbGx5LCBvciBzaW1wbHkgcmVtb3ZlIGl0IGFuZCB1c2UgdGhlIGRlZmF1bHQgY29uZmlndXJhdGlvblxuICAgICAgICAgICAgICAgIG9wdGlvbnMuXCJcbiAgICAgICAgICAgICAgICBCcigpXG4gICAgICAgICAgICAgICAgQSh7aHJlZjogXCJodHRwczovL2dpdGh1Yi5jb20va3luaWtvcy93aWtpLW1vbmtleS93aWtpL0NvbmZpZ3VyYXRpb25cIn0gICMgbm9xYVxuICAgICAgICAgICAgICAgICAgXCJOZXcgY29uZmlndXJhdGlvbiBpbnN0cnVjdGlvbnNcIilcbiAgICAgICAgICAgICAgICBCcigpXG4gICAgICAgICAgICAgICAgQSh7aHJlZjogY29uZmhyZWZ9LCBcIlZpZXcgb2xkIGNvbmZpZ3VyYXRpb25cIilcbiAgICAgICAgICAgICAgICBCcigpXG4gICAgICAgICAgICAgICAgQSh7aHJlZjogY29uZmhyZWYsIGRvd25sb2FkOiBcIndpa2ltb25rZXlfb2xkY29uZi5qc29uXCJ9XG4gICAgICAgICAgICAgICAgICBcIkV4cG9ydCBvbGQgY29uZmlndXJhdGlvblwiKVxuICAgICAgICAgICAgICAgIEJyKClcbiAgICAgICAgICAgICAgICBBKHtvbmNsaWNrOiA9PlxuICAgICAgICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShcIldpa2lNb25rZXlcIilcbiAgICAgICAgICAgICAgICAgICAgQGRpc3BsYXlfbm90aWZpY2F0aW9uKFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJUaGUgb2xkIGNvbmZpZ3VyYXRpb24gd2FzIHN1Y2Nlc3NmdWxseSByZW1vdmVkLlwiXG4gICAgICAgICAgICAgICAgICAgICAgICB7YXV0b0hpZGU6IHRydWV9XG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICB9LCBcIkRlbGV0ZSBvbGQgY29uZmlndXJhdGlvblwiKVxuICAgICAgICAgICAgXSlcbiIsIiMgV2lraSBNb25rZXkgLSBNZWRpYVdpa2kgYm90IGFuZCBlZGl0b3ItYXNzaXN0YW50IHVzZXIgc2NyaXB0XG4jIENvcHlyaWdodCAoQykgMjAxMSBEYXJpbyBHaW92YW5uZXR0aSA8ZGV2QGRhcmlvZ2lvdmFubmV0dGkubmV0PlxuI1xuIyBUaGlzIGZpbGUgaXMgcGFydCBvZiBXaWtpIE1vbmtleS5cbiNcbiMgV2lraSBNb25rZXkgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuIyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuIyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuIyAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuI1xuIyBXaWtpIE1vbmtleSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuIyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuIyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4jIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4jXG4jIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4jIGFsb25nIHdpdGggV2lraSBNb25rZXkuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG5cblxuY2xhc3MgbW9kdWxlLmV4cG9ydHNcbiAgICBjb25zdHJ1Y3RvcjogKEBXTSkgLT5cblxuICAgIGlzV2hhdExpbmtzSGVyZVBhZ2U6IC0+XG4gICAgICAgIHJldHVybiBpZiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbXctd2hhdGxpbmtzaGVyZS1saXN0JykgdGhlbiB0cnVlIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlXG5cbiAgICBnZXRUaXRsZTogLT5cbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjb250ZW50U3ViJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdhJylbMF0udGl0bGVcbiIsIiMgV2lraSBNb25rZXkgLSBNZWRpYVdpa2kgYm90IGFuZCBlZGl0b3ItYXNzaXN0YW50IHVzZXIgc2NyaXB0XG4jIENvcHlyaWdodCAoQykgMjAxMSBEYXJpbyBHaW92YW5uZXR0aSA8ZGV2QGRhcmlvZ2lvdmFubmV0dGkubmV0PlxuI1xuIyBUaGlzIGZpbGUgaXMgcGFydCBvZiBXaWtpIE1vbmtleS5cbiNcbiMgV2lraSBNb25rZXkgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuIyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuIyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuIyAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuI1xuIyBXaWtpIE1vbmtleSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuIyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuIyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4jIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4jXG4jIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4jIGFsb25nIHdpdGggV2lraSBNb25rZXkuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG5cbm13bW9kcHJvbWlzZSA9IG13LmxvYWRlci51c2luZyhbJ21lZGlhd2lraS5hcGkuZWRpdCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ21lZGlhd2lraS5ub3RpZmljYXRpb24nXSlcblxuIyBJbml0aWFsaXplIHRoZSBsaWJyYXJpZXMgaW1tZWRpYXRlbHkgKGVzcGVjaWFsbHkgYmFiZWwtcG9seWZpbGwpXG5yZXF1aXJlKCcuL2xpYnMnKVxuXG4jIFRoZSBBcmNoUGFja2FnZXMgbW9kdWxlIGlzIGN1cnJlbnRseSB1bnVzYWJsZVxuIyBBcmNoUGFja2FnZXMgPSByZXF1aXJlKCcuL0FyY2hQYWNrYWdlcycpXG5BcmNoV2lraSA9IHJlcXVpcmUoJy4vQXJjaFdpa2knKVxuQm90ID0gcmVxdWlyZSgnLi9Cb3QnKVxuQ2F0ID0gcmVxdWlyZSgnLi9DYXQnKVxuRGlmZiA9IHJlcXVpcmUoJy4vRGlmZicpXG5FZGl0b3IgPSByZXF1aXJlKCcuL0VkaXRvcicpXG5GaWx0ZXJzID0gcmVxdWlyZSgnLi9GaWx0ZXJzJylcbkludGVybGFuZ3VhZ2UgPSByZXF1aXJlKCcuL0ludGVybGFuZ3VhZ2UnKVxuTG9nID0gcmVxdWlyZSgnLi9Mb2cnKVxuTWVudSA9IHJlcXVpcmUoJy4vTWVudScpXG5Nb2RzID0gcmVxdWlyZSgnLi9Nb2RzJylcbk1XID0gcmVxdWlyZSgnLi9NVycpXG5QYXJzZXIgPSByZXF1aXJlKCcuL1BhcnNlcicpXG5Sb3V0ZXIgPSByZXF1aXJlKCcuL1JvdXRlcicpXG5UYWJsZXMgPSByZXF1aXJlKCcuL1RhYmxlcycpXG5VSSA9IHJlcXVpcmUoJy4vVUknKVxuVXBncmFkZSA9IHJlcXVpcmUoJy4vVXBncmFkZScpXG5XaGF0TGlua3NIZXJlID0gcmVxdWlyZSgnLi9XaGF0TGlua3NIZXJlJylcblxue1BsdWdpbn0gPSByZXF1aXJlKCcuLi9wbHVnaW5zL19QbHVnaW4nKVxuXG5cbmNsYXNzIG1vZHVsZS5leHBvcnRzLldNXG4gICAgY29uZjpcbiAgICAgICAgZGVmYXVsdF9ib3RfcGx1Z2luOiBcIlNpbXBsZVJlcGxhY2VcIlxuICAgICAgICBkZWZhdWx0X3JlY2VudGNoYW5nZXNfcGx1Z2luOiBudWxsXG4gICAgICAgIGRlZmF1bHRfbmV3cGFnZXNfcGx1Z2luOiBudWxsXG4gICAgICAgIHVwZGF0ZV9jaGVja193ZGF5czogWzZdXG4gICAgICAgIHVwZGF0ZV9jaGVja19icmFuY2g6ICdtYXN0ZXInXG4gICAgICAgIGhpZGVfcm9sbGJhY2tfbGlua3M6IHRydWVcbiAgICAgICAgZGlzYWJsZV9lZGl0X3N1bW1hcnlfc3VibWl0X29uX2VudGVyOiB0cnVlXG4gICAgICAgIHNjcm9sbF90b19maXJzdF9oZWFkaW5nOiBmYWxzZVxuXG4gICAgY29uc3RydWN0b3I6IChAd2lraV9uYW1lLCBAaW5zdGFsbGVkX3BsdWdpbnNfdGVtcC4uLikgLT5cbiAgICAgICAgQHNldHVwKClcbiAgICAgICAgJC53aGVuKG13bW9kcHJvbWlzZSwgJC5yZWFkeSkuZG9uZShAaW5pdClcblxuICAgIHNldHVwOiAtPlxuICAgICAgICAjIG13LmxvYWRlci5sb2FkKCkgZG9lc24ndCByZXR1cm4gYSBwcm9taXNlIG5vciBzdXBwb3J0IGNhbGxiYWNrc1xuICAgICAgICAjIG13LmxvYWRlci51c2luZygpIG9ubHkgc3VwcG9ydHMgTVcgbW9kdWxlc1xuICAgICAgICAjICQuZ2V0U2NyaXB0KCkgaWdub3JlcyB0aGUgY2FjaGUgYnkgZGVmYXVsdFxuICAgICAgICAjIEluIHRoZSBlbmQgdXNpbmcgJC5hamF4KCkgd2l0aCBzZXR1cCBwYXJhbWV0ZXJzIHdvdWxkIGJlIHRoZSBvbmx5XG4gICAgICAgICMgb3B0aW9uIHRvIGNvbmZpZ3VyZSBXTSBpbiBhIGNhbGxiYWNrLCB0aGVyZWZvcmUgdXNlIGEgZ2xvYmFsXG4gICAgICAgICMgY29uZmlndXJhdGlvbiBvYmplY3QgZm9yIHNpbXBsaWNpdHlcbiAgICAgICAgdXNlcl9jb25maWcgPSB3aW5kb3cud2lraU1vbmtleUNvbmZpZyBvciB3aW5kb3cud2lraW1vbmtleV9jb25maWcgb3Ige31cblxuICAgICAgICBmb3Igb3B0aW9uLCB2YWx1ZSBvZiB1c2VyX2NvbmZpZyB3aGVuIG9wdGlvbiBvZiBAY29uZlxuICAgICAgICAgICAgQGNvbmZbb3B0aW9uXSA9IHZhbHVlXG4gICAgICAgICAgICBkZWxldGUgdXNlcl9jb25maWdbb3B0aW9uXVxuXG4gICAgICAgIEBQbHVnaW5zID1cbiAgICAgICAgICAgIGJvdDogW11cbiAgICAgICAgICAgIGRpZmY6IFtdXG4gICAgICAgICAgICBlZGl0b3I6IFtdXG4gICAgICAgICAgICBuZXdwYWdlczogW11cbiAgICAgICAgICAgIHJlY2VudGNoYW5nZXM6IFtdXG4gICAgICAgICAgICBzcGVjaWFsOiBbXVxuXG4gICAgICAgIGZvciBwbW9kIGluIEBpbnN0YWxsZWRfcGx1Z2luc190ZW1wXG4gICAgICAgICAgICBmb3IgcG5hbWUsIFBsdWdpblN1YiBvZiBwbW9kIFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGVuIFBsdWdpblN1Yi5wcm90b3R5cGUgaW5zdGFuY2VvZiBQbHVnaW5cbiAgICAgICAgICAgICAgICB0cnlcbiAgICAgICAgICAgICAgICAgICAgUGx1Z2luU3ViLl9fY29uZmlndXJlKEB3aWtpX25hbWUsIHVzZXJfY29uZmlnKVxuICAgICAgICAgICAgICAgIGNhdGNoIGVycm9yXG4gICAgICAgICAgICAgICAgICAgICMgVE9ETzogUHJvcGVybHkgZXh0ZW5kIEVycm9yLCBidXQgYmV3YXJlIHRoYXQgQmFiZWxvXG4gICAgICAgICAgICAgICAgICAgICMgICAgICAgZG9lc24ndCBsaWtlIGl0IHdpdGhvdXQgc3BlY2lmaWMgcGx1Z2luc1xuICAgICAgICAgICAgICAgICAgICBpZiBlcnJvci5tZXNzYWdlIGlzIFwiUGx1Z2luIGRpc2FibGVkXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yXG5cbiAgICAgICAgICAgICAgICBmb3IgaW50ZXJmYWNlXyBvZiBAUGx1Z2lucyBcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoZW4gUGx1Z2luU3ViOjpbXCJtYWluXyN7aW50ZXJmYWNlX31cIl1cbiAgICAgICAgICAgICAgICAgICAgQFBsdWdpbnNbaW50ZXJmYWNlX10ucHVzaChQbHVnaW5TdWIpXG5cbiAgICAgICAgaWYgbm90ICQuaXNFbXB0eU9iamVjdCh1c2VyX2NvbmZpZylcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlVua293biBjb25maWd1cmF0aW9uIG9wdGlvbnNcIiwgdXNlcl9jb25maWcpXG5cbiAgICAgICAgZGVsZXRlIEBpbnN0YWxsZWRfcGx1Z2luc190ZW1wXG5cbiAgICBpbml0OiA9PlxuICAgICAgICAjIFRoZSBBcmNoUGFja2FnZXMgbW9kdWxlIGlzIGN1cnJlbnRseSB1bnVzYWJsZVxuICAgICAgICAjIEBBcmNoUGFja2FnZXMgPSBuZXcgQXJjaFBhY2thZ2VzKHRoaXMpXG4gICAgICAgIEBBcmNoV2lraSA9IG5ldyBBcmNoV2lraSh0aGlzKVxuICAgICAgICBAQm90ID0gbmV3IEJvdCh0aGlzKVxuICAgICAgICBAQ2F0ID0gbmV3IENhdCh0aGlzKVxuICAgICAgICBARGlmZiA9IG5ldyBEaWZmKHRoaXMpXG4gICAgICAgIEBFZGl0b3IgPSBuZXcgRWRpdG9yKHRoaXMpXG4gICAgICAgIEBGaWx0ZXJzID0gbmV3IEZpbHRlcnModGhpcylcbiAgICAgICAgQEludGVybGFuZ3VhZ2UgPSBuZXcgSW50ZXJsYW5ndWFnZSh0aGlzKVxuICAgICAgICBATG9nID0gbmV3IExvZyh0aGlzKVxuICAgICAgICBATWVudSA9IG5ldyBNZW51KHRoaXMpXG4gICAgICAgIEBNb2RzID0gbmV3IE1vZHModGhpcylcbiAgICAgICAgQE1XID0gbmV3IE1XKHRoaXMpXG4gICAgICAgIEBQYXJzZXIgPSBuZXcgUGFyc2VyKHRoaXMpXG4gICAgICAgIEBSb3V0ZXIgPSBuZXcgUm91dGVyKHRoaXMpXG4gICAgICAgIEBUYWJsZXMgPSBuZXcgVGFibGVzKHRoaXMpXG4gICAgICAgIEBVSSA9IG5ldyBVSSh0aGlzKVxuICAgICAgICBAVXBncmFkZSA9IG5ldyBVcGdyYWRlKHRoaXMpXG4gICAgICAgIEBXaGF0TGlua3NIZXJlID0gbmV3IFdoYXRMaW5rc0hlcmUodGhpcylcblxuICAgICAgICBAVXBncmFkZS5jaGVja19vYnNvbGV0ZV9jb25maWcoKVxuICAgICAgICBpZiBAY29uZi51cGRhdGVfY2hlY2tfd2RheXNcbiAgICAgICAgICAgIEBVcGdyYWRlLmNoZWNrX2FuZF9ub3RpZnkoKVxuXG4gICAgICAgIEBSb3V0ZXIucm91dGUoKVxuIiwiIyBXaWtpIE1vbmtleSAtIE1lZGlhV2lraSBib3QgYW5kIGVkaXRvci1hc3Npc3RhbnQgdXNlciBzY3JpcHRcbiMgQ29weXJpZ2h0IChDKSAyMDExIERhcmlvIEdpb3Zhbm5ldHRpIDxkZXZAZGFyaW9naW92YW5uZXR0aS5uZXQ+XG4jXG4jIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFdpa2kgTW9ua2V5LlxuI1xuIyBXaWtpIE1vbmtleSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4jIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4jIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4jIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4jXG4jIFdpa2kgTW9ua2V5IGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4jIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4jIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiMgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbiNcbiMgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiMgYWxvbmcgd2l0aCBXaWtpIE1vbmtleS4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cblxucmVxdWlyZSgnYmFiZWwtcG9seWZpbGwnKVxuXG4jIGpRdWVyeSBpcyBwcm92aWRlZCBnbG9iYWxseSBieSBNZWRpYVdpa2lcblxuaGggPSByZXF1aXJlKCdoeXBlcnNjcmlwdC1oZWxwZXJzJykocmVxdWlyZSgnaHlwZXJzY3JpcHQnKSlcbmZvciB0YWcsIGhlbHBlciBvZiBoaFxuICAgICMgVE9ETzogVGhpcyBjYW4gYmUgc2ltcGxpZmllZCBhZnRlclxuICAgICMgICAgICAgaHR0cHM6Ly9naXRodWIuY29tL29oYW5oaS9oeXBlcnNjcmlwdC1oZWxwZXJzL3B1bGwvNDYgaXMgcmVsZWFzZWRcbiAgICBtb2R1bGUuZXhwb3J0c1t0YWcuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyB0YWcuc2xpY2UoMSldID0gaGVscGVyXG5cbm1vZHVsZS5leHBvcnRzLm1vbWVudCA9IHJlcXVpcmUoJ21vbWVudCcpXG5cbmpzcyA9IHJlcXVpcmUoJ2pzcycpLmRlZmF1bHRcbmpzcy5zZXR1cChyZXF1aXJlKCdqc3MtcHJlc2V0LWRlZmF1bHQnKS5kZWZhdWx0KCkpXG5tb2R1bGUuZXhwb3J0cy5qc3MgPSBqc3NcbiIsIiMgV2lraSBNb25rZXkgLSBNZWRpYVdpa2kgYm90IGFuZCBlZGl0b3ItYXNzaXN0YW50IHVzZXIgc2NyaXB0XG4jIENvcHlyaWdodCAoQykgMjAxMSBEYXJpbyBHaW92YW5uZXR0aSA8ZGV2QGRhcmlvZ2lvdmFubmV0dGkubmV0PlxuI1xuIyBUaGlzIGZpbGUgaXMgcGFydCBvZiBXaWtpIE1vbmtleS5cbiNcbiMgV2lraSBNb25rZXkgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuIyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuIyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuIyAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuI1xuIyBXaWtpIE1vbmtleSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuIyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuIyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4jIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4jXG4jIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4jIGFsb25nIHdpdGggV2lraSBNb25rZXkuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG5cbntQbHVnaW59ID0gcmVxdWlyZSgnLi9fUGx1Z2luJylcblxuXG5jbGFzcyBtb2R1bGUuZXhwb3J0cy5BcmNoV2lraUZpeEhlYWRlciBleHRlbmRzIFBsdWdpblxuICAgIEBjb25mX2RlZmF1bHQ6XG4gICAgICAgIGVuYWJsZWQ6IHRydWVcbiAgICAgICAgZWRpdG9yX21lbnU6IFtcIlRleHQgcGx1Z2luc1wiLCBcIkZpeCBoZWFkZXJcIl1cblxuICAgIG1haW5fZWRpdG9yOiAoY2FsbE5leHQpIC0+XG4gICAgICAgIHNvdXJjZSA9IEBXTS5FZGl0b3IucmVhZFNvdXJjZSgpXG5cbiAgICAgICAgbGFuZ3VhZ2UgPSBAV00uQXJjaFdpa2kuZGV0ZWN0TGFuZ3VhZ2UoQFdNLkVkaXRvci5nZXRUaXRsZSgpKVsxXVxuXG4gICAgICAgIGhlYWRlciA9IFwiXCJcbiAgICAgICAgY29udGVudCA9IHNvdXJjZVxuXG4gICAgICAgICMgPG5vaW5jbHVkZT5cbiAgICAgICAgY29udGVudCA9IGNvbnRlbnQucmVwbGFjZSgvXlxccyo8bm9pbmNsdWRlPi8sIFwiXCIpXG4gICAgICAgIGlmIGNvbnRlbnQgIT0gc291cmNlXG4gICAgICAgICAgICBoZWFkZXIgKz0gXCI8bm9pbmNsdWRlPlxcblwiXG5cbiAgICAgICAgIyBESVNQTEFZVElUTEUgYW5kIFRlbXBsYXRlOkxvd2VyY2FzZV90aXRsZVxuICAgICAgICBkaXNwbGF5dGl0bGUgPSBAV00uUGFyc2VyLmZpbmRWYXJpYWJsZXMoY29udGVudCwgXCJESVNQTEFZVElUTEVcIilcbiAgICAgICAgbG93ZXJjYXNldGl0bGUgPSBAV00uUGFyc2VyLmZpbmRUZW1wbGF0ZXMoY29udGVudCwgXCJMb3dlcmNhc2UgdGl0bGVcIilcbiAgICAgICAgdGl0bGVtb2RzID0gZGlzcGxheXRpdGxlLmNvbmNhdChsb3dlcmNhc2V0aXRsZSlcbiAgICAgICAgdGl0bGVtb2RzLnNvcnQoIChhLCBiKSAtPlxuICAgICAgICAgICAgcmV0dXJuIGEuaW5kZXggLSBiLmluZGV4XG4gICAgICAgIClcbiAgICAgICAgdGVtcGNvbnRlbnQgPSBcIlwiXG4gICAgICAgIGNvbnRlbnRJZCA9IDBcbiAgICAgICAgZm9yIHRpdGxlbW9kIGluIHRpdGxlbW9kc1xuICAgICAgICAgICAgdGVtcGNvbnRlbnQgKz0gY29udGVudC5zdWJzdHJpbmcoY29udGVudElkLCB0aXRsZW1vZC5pbmRleClcbiAgICAgICAgICAgIGNvbnRlbnRJZCA9IHRpdGxlbW9kLmluZGV4ICsgdGl0bGVtb2QubGVuZ3RoXG5cbiAgICAgICAgdGVtcGNvbnRlbnQgKz0gY29udGVudC5zdWJzdHJpbmcoY29udGVudElkKVxuICAgICAgICBjb250ZW50ID0gdGVtcGNvbnRlbnRcbiAgICAgICAgZHQgPSBkaXNwbGF5dGl0bGUucG9wKClcbiAgICAgICAgbGN0ID0gbG93ZXJjYXNldGl0bGUucG9wKClcbiAgICAgICAgZGxjdCA9IFwiXCJcbiAgICAgICAgaWYgZHQgYW5kIG5vdCBsY3RcbiAgICAgICAgICAgIGRsY3QgPSBcInt7RElTUExBWVRJVExFOlwiICsgZHQudmFsdWUgKyBcIn19XCJcbiAgICAgICAgZWxzZSBpZiBub3QgZHQgYW5kIGxjdFxuICAgICAgICAgICAgZGxjdCA9IFwie3tMb3dlcmNhc2UgdGl0bGV9fVwiXG4gICAgICAgIGVsc2UgaWYgZHQgYW5kIGxjdFxuICAgICAgICAgICAgZGxjdCA9IGlmIGR0LmluZGV4IDwgbGN0LmluZGV4IHRoZW4gXCJ7e0xvd2VyY2FzZSB0aXRsZX19XCIgZWxzZSBcInt7RElTUExBWVRJVExFOiN7ZHQudmFsdWV9fX1cIlxuICAgICAgICBpZiBkaXNwbGF5dGl0bGUubGVuZ3RoIG9yIGxvd2VyY2FzZXRpdGxlLmxlbmd0aFxuICAgICAgICAgICAgQFdNLkxvZy5sb2dXYXJuaW5nKFwiRm91bmQgbXVsdGlwbGUgaW5zdGFuY2VzIG9mXG4gICAgICAgICAgICAgICAge3tESVNQTEFZVElUTEU6Li4ufX0gb3Ige3tMb3dlcmNhc2UgdGl0bGV9fTogb25seSB0aGUgbGFzdFxuICAgICAgICAgICAgICAgIG9uZSBoYXMgYmVlbiB1c2VkLCB0aGUgb3RoZXJzIGhhdmUgYmVlbiBkZWxldGVkXCIpXG5cbiAgICAgICAgIyBCZWhhdmlvciBzd2l0Y2hlc1xuICAgICAgICBiZWhhdmlvcnN3aXRjaGVzID0gQFdNLlBhcnNlci5maW5kQmVoYXZpb3JTd2l0Y2hlcyhjb250ZW50KVxuICAgICAgICBic2xpc3QgPSBbXVxuICAgICAgICB0ZW1wY29udGVudCA9IFwiXCJcbiAgICAgICAgY29udGVudElkID0gMFxuICAgICAgICBmb3IgYnN3aXRjaCwgYiBpbiBiZWhhdmlvcnN3aXRjaGVzXG4gICAgICAgICAgICBpZiBic3dpdGNoLm1hdGNoWzFdIGluIFtcIlRPQ1wiLCBcIlNUQVJUXCIsIFwiRU5EXCJdXG4gICAgICAgICAgICAgICAgYmVoYXZpb3Jzd2l0Y2hlcy5zcGxpY2UoYiwgMSlcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBpZiBic3dpdGNoLm1hdGNoWzBdIG5vdCBpbiBic2xpc3RcbiAgICAgICAgICAgICAgICAgICAgYnNsaXN0LnB1c2goYnN3aXRjaC5tYXRjaFswXSlcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIEBXTS5Mb2cubG9nV2FybmluZyhcIlJlbW92ZWQgZHVwbGljYXRlIG9mXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI3tic3dpdGNoLm1hdGNoWzBdfVwiKVxuICAgICAgICAgICAgICAgIHRlbXBjb250ZW50ICs9IGNvbnRlbnQuc3Vic3RyaW5nKGNvbnRlbnRJZCwgYnN3aXRjaC5pbmRleClcbiAgICAgICAgICAgICAgICBjb250ZW50SWQgPSBic3dpdGNoLmluZGV4ICsgYnN3aXRjaC5sZW5ndGhcblxuICAgICAgICB0ZW1wY29udGVudCArPSBjb250ZW50LnN1YnN0cmluZyhjb250ZW50SWQpXG4gICAgICAgIGNvbnRlbnQgPSB0ZW1wY29udGVudFxuXG4gICAgICAgIGlmIG5vdCBkbGN0IGFuZCBic2xpc3QubGVuZ3RoXG4gICAgICAgICAgICBoZWFkZXIgKz0gYnNsaXN0LmpvaW4oXCIgXCIpICsgXCJcXG5cIlxuICAgICAgICBlbHNlIGlmIGRsY3QgYW5kIG5vdCBic2xpc3QubGVuZ3RoXG4gICAgICAgICAgICBoZWFkZXIgKz0gZGxjdCArIFwiXFxuXCJcbiAgICAgICAgZWxzZSBpZiBkbGN0IGFuZCBic2xpc3QubGVuZ3RoXG4gICAgICAgICAgICBoZWFkZXIgKz0gZGxjdCArIFwiIFwiICsgYnNsaXN0LmpvaW4oXCIgXCIpICsgXCJcXG5cIlxuXG4gICAgICAgICMgQ2F0ZWdvcmllc1xuICAgICAgICBjYXRlZ29yaWVzID0gQFdNLlBhcnNlci5maW5kQ2F0ZWdvcmllcyhjb250ZW50KVxuICAgICAgICBjYXRsaXN0ID0gW11cbiAgICAgICAgY2F0bGlua3MgPSBbXVxuICAgICAgICB0ZW1wY29udGVudCA9IFwiXCJcbiAgICAgICAgY29udGVudElkID0gMFxuICAgICAgICBmb3IgY2F0IGluIGNhdGVnb3JpZXNcbiAgICAgICAgICAgIGlmIGNhdC5mcmFnbWVudFxuICAgICAgICAgICAgICAgIEBXTS5Mb2cubG9nV2FybmluZyhAV00uTG9nLmxpbmtUb1dpa2lQYWdlKGNhdC5saW5rLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0LnJhd0xpbmspICsgXCIgY29udGFpbnMgYSBmcmFnbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlLCBidXQgaXQgZG9lc24ndCBtYWtlIHNlbnNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbiBjYXRlZ29yaWVzIGFuZCB3aWxsIGJlIHJlbW92ZWRcIilcblxuICAgICAgICAgICAgY2xlYW50aXRsZSA9IEBXTS5QYXJzZXIuc3F1YXNoQ29udGlndW91c1doaXRlc3BhY2UoY2F0LnRpdGxlKVxuICAgICAgICAgICAgY2F0dGV4dCA9IFwiQ2F0ZWdvcnk6XCIgKyBjbGVhbnRpdGxlXG4gICAgICAgICAgICAjIERvbid0IGp1c3QgcGFzcyBjbGVhbnRpdGxlIGhlcmUsIG90aGVyd2lzZSB0aGUgbGFuZ3VhZ2Ugb2ZcbiAgICAgICAgICAgICMgICByb290IGxhbmd1YWdlIGNhdGVnb3JpZXMgd29uJ3QgYmUgcHJvcGVybHkgZGV0ZWN0ZWRcbiAgICAgICAgICAgIGNhdGxhbmcgPSBAV00uQXJjaFdpa2kuZGV0ZWN0TGFuZ3VhZ2UoY2F0dGV4dClbMV1cbiAgICAgICAgICAgIGNhdGxpbmsgPSBcIltbXCIgKyBjYXR0ZXh0ICsgKGlmIGNhdC5hbmNob3IgdGhlbiBcInxcIiArIGNhdC5hbmNob3IgZWxzZSBcIlwiKSArIFwiXV1cIlxuICAgICAgICAgICAgaWYgbGFuZ3VhZ2UgIT0gY2F0bGFuZ1xuICAgICAgICAgICAgICAgIEBXTS5Mb2cubG9nV2FybmluZyhAV00uTG9nLmxpbmtUb1dpa2lQYWdlKGNhdC5saW5rLCBjYXR0ZXh0KSArXG4gICAgICAgICAgICAgICAgICAgIFwiIGJlbG9uZ3MgdG8gYSBkaWZmZXJlbnRcbiAgICAgICAgICAgICAgICAgICAgbGFuZ3VhZ2UgdGhhbiB0aGUgb25lIG9mIHRoZSB0aXRsZSAoXCIgKyBsYW5ndWFnZSArIFwiKVwiKVxuXG4gICAgICAgICAgICBpZiBjYXRsaXN0LmluZGV4T2YoY2F0dGV4dCkgPCAwXG4gICAgICAgICAgICAgICAgY2F0bGlzdC5wdXNoKGNhdHRleHQpXG4gICAgICAgICAgICAgICAgY2F0bGlua3MucHVzaChjYXRsaW5rKVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIEBXTS5Mb2cubG9nV2FybmluZyhcIlJlbW92ZWQgZHVwbGljYXRlIG9mIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEBXTS5Mb2cubGlua1RvV2lraVBhZ2UoY2F0LmxpbmssIGNhdHRleHQpKVxuXG4gICAgICAgICAgICB0ZW1wY29udGVudCArPSBjb250ZW50LnN1YnN0cmluZyhjb250ZW50SWQsIGNhdC5pbmRleClcbiAgICAgICAgICAgIGNvbnRlbnRJZCA9IGNhdC5pbmRleCArIGNhdC5sZW5ndGhcblxuICAgICAgICBpZiBjYXRsaXN0Lmxlbmd0aFxuICAgICAgICAgICAgaGVhZGVyICs9IGNhdGxpbmtzLmpvaW4oXCJcXG5cIikgKyBcIlxcblwiXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIEBXTS5Mb2cubG9nV2FybmluZyhcIlRoZSBhcnRpY2xlIGlzIG5vdCBjYXRlZ29yaXplZFwiKVxuICAgICAgICB0ZW1wY29udGVudCArPSBjb250ZW50LnN1YnN0cmluZyhjb250ZW50SWQpXG4gICAgICAgIGNvbnRlbnQgPSB0ZW1wY29udGVudFxuXG4gICAgICAgICMgSW50ZXJsYW5ndWFnZSBsaW5rc1xuICAgICAgICBpbnRlcmxhbmd1YWdlID0gQFdNLkFyY2hXaWtpLmZpbmRBbGxJbnRlcmxhbmd1YWdlTGlua3MoY29udGVudClcbiAgICAgICAgaXdsaXN0ID0gW11cbiAgICAgICAgaXdsaW5rcyA9IFtdXG4gICAgICAgIHRlbXBjb250ZW50ID0gXCJcIlxuICAgICAgICBjb250ZW50SWQgPSAwXG4gICAgICAgIGZvciBsaW5rIGluIGludGVybGFuZ3VhZ2VcbiAgICAgICAgICAgIGlmIGxpbmsuYW5jaG9yXG4gICAgICAgICAgICAgICAgIyBDYW5ub3QgdXNlIEBXTS5Mb2cubGlua1RvV2lraVBhZ2UgYmVjYXVzZSBsb2NhbCBpbnRlcmxhbmd1YWdlXG4gICAgICAgICAgICAgICAgIyAgIGxpbmtzIHdvdWxkIG5vdCByZXNvbHZlZCBjb3JyZWN0bHk7IGxpbmtUb1BhZ2Ugd291bGQgbmVlZFxuICAgICAgICAgICAgICAgICMgICB0byBmaW5kIHRoZSBVUkwgaW5zdGVhZCwgd2hpY2ggc2VlbXMgdG9vIGNvbXBsaWNhdGVkIGZvclxuICAgICAgICAgICAgICAgICMgICB0aGUgcHVycG9zZSBvZiB0aGlzIHBsdWdpblxuICAgICAgICAgICAgICAgIEBXTS5Mb2cubG9nV2FybmluZyhsaW5rLnJhd0xpbmsgKyBcIiBjb250YWlucyBhbiBhbHRlcm5hdGl2ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCwgYnV0IGl0IGRvZXNuJ3QgbWFrZSBzZW5zZSBpblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJsYW5ndWFnZSBsaW5rcyBhbmQgd2lsbCBiZSByZW1vdmVkXCIpXG5cbiAgICAgICAgICAgICMgQXBwbHlpbmcgQFdNLlBhcnNlci5zcXVhc2hDb250aWd1b3VzV2hpdGVzcGFjZSBpcyBkYW5nZXJvdXMgaGVyZVxuICAgICAgICAgICAgIyAgIGJlY2F1c2Ugd2UgZG9uJ3Qga25vdyBob3cgdGhlIHRhcmdldCBzZXJ2ZXIgaGFuZGxlcyB3aGl0ZXNwYWNlXG4gICAgICAgICAgICBsaW5rdGl0bGUgPSBsaW5rLnRpdGxlXG4gICAgICAgICAgICBsaW5rbGFuZyA9IGxpbmsubmFtZXNwYWNlXG4gICAgICAgICAgICBsaW5rdGV4dCA9IGxpbmtsYW5nICsgXCI6XCIgKyBsaW5rdGl0bGVcbiAgICAgICAgICAgIGZ1bGxsaW5rID0gXCJbW1wiICsgbGlua3RleHQgKyAoaWYgbGluay5mcmFnbWVudCB0aGVuIFwiI1wiICsgbGluay5mcmFnbWVudCBlbHNlIFwiXCIpICsgXCJdXVwiXG4gICAgICAgICAgICBpZiBpd2xpc3QuaW5kZXhPZihsaW5rdGV4dCkgPCAwXG4gICAgICAgICAgICAgICAgaXdsaXN0LnB1c2gobGlua3RleHQpXG4gICAgICAgICAgICAgICAgaXdsaW5rcy5wdXNoKGZ1bGxsaW5rKVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICMgQ2Fubm90IHVzZSBAV00uTG9nLmxpbmtUb1dpa2lQYWdlIGJlY2F1c2UgbG9jYWwgaW50ZXJsYW5ndWFnZVxuICAgICAgICAgICAgICAgICMgICBsaW5rcyB3b3VsZCBub3QgcmVzb2x2ZWQgY29ycmVjdGx5OyBsaW5rVG9QYWdlIHdvdWxkIG5lZWRcbiAgICAgICAgICAgICAgICAjICAgdG8gZmluZCB0aGUgVVJMIGluc3RlYWQsIHdoaWNoIHNlZW1zIHRvbyBjb21wbGljYXRlZCBmb3JcbiAgICAgICAgICAgICAgICAjICAgdGhlIHB1cnBvc2Ugb2YgdGhpcyBwbHVnaW5cbiAgICAgICAgICAgICAgICBAV00uTG9nLmxvZ1dhcm5pbmcoXCJSZW1vdmVkIGR1cGxpY2F0ZSBvZiBcIiArIGxpbmt0ZXh0KVxuXG4gICAgICAgICAgICB0ZW1wY29udGVudCArPSBjb250ZW50LnN1YnN0cmluZyhjb250ZW50SWQsIGxpbmsuaW5kZXgpXG4gICAgICAgICAgICBjb250ZW50SWQgPSBsaW5rLmluZGV4ICsgbGluay5sZW5ndGhcblxuICAgICAgICBpZiBpd2xpc3QubGVuZ3RoXG4gICAgICAgICAgICBpd2xpbmtzLnNvcnQoKVxuICAgICAgICAgICAgaGVhZGVyICs9IGl3bGlua3Muam9pbihcIlxcblwiKSArIFwiXFxuXCJcblxuICAgICAgICB0ZW1wY29udGVudCArPSBjb250ZW50LnN1YnN0cmluZyhjb250ZW50SWQpXG4gICAgICAgIGNvbnRlbnQgPSB0ZW1wY29udGVudFxuXG4gICAgICAgIGZpcnN0Q2hhciA9IGNvbnRlbnQuc2VhcmNoKC9bXlxcc10vKVxuICAgICAgICBjb250ZW50ID0gY29udGVudC5zdWJzdHIoZmlyc3RDaGFyKVxuXG4gICAgICAgIG5ld1RleHQgPSBoZWFkZXIgKyBjb250ZW50XG5cbiAgICAgICAgaWYgbmV3VGV4dCAhPSBzb3VyY2VcbiAgICAgICAgICAgIEBXTS5FZGl0b3Iud3JpdGVTb3VyY2UobmV3VGV4dClcbiAgICAgICAgICAgIEBXTS5Mb2cubG9nSW5mbyhcIkZpeGVkIGhlYWRlclwiKVxuXG4gICAgICAgIGlmIGNhbGxOZXh0XG4gICAgICAgICAgICBjYWxsTmV4dCgpXG4iLCIjIFdpa2kgTW9ua2V5IC0gTWVkaWFXaWtpIGJvdCBhbmQgZWRpdG9yLWFzc2lzdGFudCB1c2VyIHNjcmlwdFxuIyBDb3B5cmlnaHQgKEMpIDIwMTEgRGFyaW8gR2lvdmFubmV0dGkgPGRldkBkYXJpb2dpb3Zhbm5ldHRpLm5ldD5cbiNcbiMgVGhpcyBmaWxlIGlzIHBhcnQgb2YgV2lraSBNb25rZXkuXG4jXG4jIFdpa2kgTW9ua2V5IGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiMgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiMgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiMgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbiNcbiMgV2lraSBNb25rZXkgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiMgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiMgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuIyBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuI1xuIyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuIyBhbG9uZyB3aXRoIFdpa2kgTW9ua2V5LiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuXG57UGx1Z2lufSA9IHJlcXVpcmUoJy4vX1BsdWdpbicpXG5cblxuY2xhc3MgbW9kdWxlLmV4cG9ydHMuQXJjaFdpa2lGaXhIZWFkaW5ncyBleHRlbmRzIFBsdWdpblxuICAgIEBjb25mX2RlZmF1bHQ6XG4gICAgICAgIGVuYWJsZWQ6IHRydWVcbiAgICAgICAgZWRpdG9yX21lbnU6IFtcIlRleHQgcGx1Z2luc1wiLCBcIkZpeCBoZWFkaW5nc1wiXVxuXG4gICAgbWFpbl9lZGl0b3I6IChjYWxsTmV4dCkgLT5cbiAgICAgICAgc291cmNlID0gQFdNLkVkaXRvci5yZWFkU291cmNlKClcblxuICAgICAgICBpbmZvID0gQFdNLlBhcnNlci5maW5kU2VjdGlvbkhlYWRpbmdzKHNvdXJjZSlcblxuICAgICAgICBpZiBAV00uRWRpdG9yLmlzU2VjdGlvbigpXG4gICAgICAgICAgICBpbmNyZWFzZUxldmVsID0gaW5mby5taW5MZXZlbCAtIDFcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgaWYgaW5mby5tYXhUb2NMZXZlbCA8IDZcbiAgICAgICAgICAgICAgICBpbmNyZWFzZUxldmVsID0gMVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGluY3JlYXNlTGV2ZWwgPSAwXG4gICAgICAgICAgICAgICAgQFdNLkxvZy5sb2dXYXJuaW5nKFwiVGhlcmUgYXJlIDYgbGV2ZWxzIG9mIGhlYWRpbmdzLCBpdCBoYXNcbiAgICAgICAgICAgICAgICAgICAgYmVlbiBuZWNlc3NhcnkgdG8gc3RhcnQgY3JlYXRpbmcgdGhlbSBmcm9tIGxldmVsIDFcbiAgICAgICAgICAgICAgICAgICAgYWx0aG91Z2ggdXN1YWxseSBpdCBpcyBzdWdnZXN0ZWQgdG8gc3RhcnQgZnJvbSBsZXZlbCAyXCIpXG5cbiAgICAgICAgbmV3dGV4dCA9IFwiXCJcbiAgICAgICAgcHJldklkID0gMFxuXG4gICAgICAgIGZvciBzZWN0aW9uIGluIGluZm8uc2VjdGlvbnNcbiAgICAgICAgICAgIG5ld3RleHQgKz0gc291cmNlLnN1YnN0cmluZyhwcmV2SWQsIHNlY3Rpb24uaW5kZXgpXG4gICAgICAgICAgICBuZXd0ZXh0ICs9IG5ldyBBcnJheShzZWN0aW9uLnRvY0xldmVsICsgaW5jcmVhc2VMZXZlbCArIDEpLmpvaW4oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIj1cIilcbiAgICAgICAgICAgIG5ld3RleHQgKz0gc2VjdGlvbi5yYXdoZWFkaW5nXG4gICAgICAgICAgICBuZXd0ZXh0ICs9IG5ldyBBcnJheShzZWN0aW9uLnRvY0xldmVsICsgaW5jcmVhc2VMZXZlbCArIDEpLmpvaW4oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIj1cIilcbiAgICAgICAgICAgIHByZXZJZCA9IHNlY3Rpb24uaW5kZXggKyBzZWN0aW9uLmxlbmd0aDBcblxuICAgICAgICBuZXd0ZXh0ICs9IHNvdXJjZS5zdWJzdHIocHJldklkKVxuXG4gICAgICAgIGlmIG5ld3RleHQgIT0gc291cmNlXG4gICAgICAgICAgICBAV00uRWRpdG9yLndyaXRlU291cmNlKG5ld3RleHQpXG4gICAgICAgICAgICBAV00uTG9nLmxvZ0luZm8oXCJGaXhlZCBzZWN0aW9uIGhlYWRpbmdzXCIpXG5cbiAgICAgICAgaWYgY2FsbE5leHRcbiAgICAgICAgICAgIGNhbGxOZXh0KClcbiIsIiMgV2lraSBNb25rZXkgLSBNZWRpYVdpa2kgYm90IGFuZCBlZGl0b3ItYXNzaXN0YW50IHVzZXIgc2NyaXB0XG4jIENvcHlyaWdodCAoQykgMjAxMSBEYXJpbyBHaW92YW5uZXR0aSA8ZGV2QGRhcmlvZ2lvdmFubmV0dGkubmV0PlxuI1xuIyBUaGlzIGZpbGUgaXMgcGFydCBvZiBXaWtpIE1vbmtleS5cbiNcbiMgV2lraSBNb25rZXkgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuIyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuIyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuIyAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuI1xuIyBXaWtpIE1vbmtleSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuIyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuIyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4jIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4jXG4jIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4jIGFsb25nIHdpdGggV2lraSBNb25rZXkuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG5cbntQbHVnaW59ID0gcmVxdWlyZSgnLi9fUGx1Z2luJylcblxuXG5jbGFzcyBtb2R1bGUuZXhwb3J0cy5BcmNoV2lraUZpeExpbmtzIGV4dGVuZHMgUGx1Z2luXG4gICAgQGNvbmZfZGVmYXVsdDpcbiAgICAgICAgZW5hYmxlZDogdHJ1ZVxuICAgICAgICBlZGl0b3JfbWVudTogW1wiVGV4dCBwbHVnaW5zXCIsIFwiRml4IGV4dGVybmFsIGxpbmtzXCJdXG5cbiAgICBkb1JlcGxhY2U6ICh0eHQpIC0+XG4gICAgICAgICMgYXJjaGxpbnV4Lm9yZyBIVFRQIC0+IEhUVFBTXG5cbiAgICAgICAgcmUgPSAvaHR0cDpcXC9cXC8oW2Etel0rXFwuKT9hcmNobGludXhcXC5vcmcoPyFcXC5bYS16XSkvaWdcbiAgICAgICAgdHh0ID0gdHh0LnJlcGxhY2UocmUsICdodHRwczovLyQxYXJjaGxpbnV4Lm9yZycpXG5cbiAgICAgICAgIyB3aWtpLmFyY2hsaW51eC5vcmcgLT4gSW50ZXJuYWwgbGlua1xuXG4gICAgICAgIHJlID0gL1xcW2h0dHBzPzpcXC9cXC93aWtpXFwuYXJjaGxpbnV4XFwub3JnXFwvaW5kZXhcXC5waHBcXC9DYXRlZ29yeTooW15cXF1dKz8pICguKz8pXFxdL2lnXG4gICAgICAgIHR4dCA9IHR4dC5yZXBsYWNlKHJlLCAnW1s6Q2F0ZWdvcnk6JDF8JDJdXScpXG5cbiAgICAgICAgcmUgPSAvXFxbaHR0cHM/OlxcL1xcL3dpa2lcXC5hcmNobGludXhcXC5vcmdcXC9pbmRleFxcLnBocFxcL0NhdGVnb3J5OiguKz8pXFxdL2lnXG4gICAgICAgIHR4dCA9IHR4dC5yZXBsYWNlKHJlLCAnW1s6Q2F0ZWdvcnk6JDFdXScpXG5cbiAgICAgICAgcmUgPSAvaHR0cHM/OlxcL1xcL3dpa2lcXC5hcmNobGludXhcXC5vcmdcXC9pbmRleFxcLnBocFxcL0NhdGVnb3J5OihbXlxcc10rKS9pZ1xuICAgICAgICB0eHQgPSB0eHQucmVwbGFjZShyZSwgJ1tbOkNhdGVnb3J5OiQxXV0nKVxuXG4gICAgICAgIHJlID0gL1xcW2h0dHBzPzpcXC9cXC93aWtpXFwuYXJjaGxpbnV4XFwub3JnXFwvaW5kZXhcXC5waHBcXC8oW15cXF1dKz8pICguKz8pXFxdL2lnXG4gICAgICAgIHR4dCA9IHR4dC5yZXBsYWNlKHJlLCAnW1skMXwkMl1dJylcblxuICAgICAgICByZSA9IC9cXFtodHRwcz86XFwvXFwvd2lraVxcLmFyY2hsaW51eFxcLm9yZ1xcL2luZGV4XFwucGhwXFwvKC4rPylcXF0vaWdcbiAgICAgICAgdHh0ID0gdHh0LnJlcGxhY2UocmUsICdbWyQxXV0nKVxuXG4gICAgICAgIHJlID0gL2h0dHBzPzpcXC9cXC93aWtpXFwuYXJjaGxpbnV4XFwub3JnXFwvaW5kZXhcXC5waHBcXC8oW15cXHNdKykvaWdcbiAgICAgICAgdHh0ID0gdHh0LnJlcGxhY2UocmUsICdbWyQxXV0nKVxuXG4gICAgICAgIHJlID0gL2h0dHBzPzpcXC9cXC93aWtpXFwuYXJjaGxpbnV4XFwub3JnKD8hXFwuKS9pZ1xuXG4gICAgICAgIGlmIHJlLnRlc3QodHh0KVxuICAgICAgICAgICAgQFdNLkxvZy5sb2dXYXJuaW5nKFwiSXQgaGFzbid0IGJlZW4gcG9zc2libGUgdG8gY29udmVydCBzb21lIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibGlua3MgdG8gd2lraS5hcmNobGludXgub3JnXCIpXG5cbiAgICAgICAgIyBXaWtpcGVkaWEgLT4gd2lraXBlZGlhOiBpbnRlcmxpbmtcblxuICAgICAgICByZSA9IC9cXFtodHRwcz86XFwvXFwvZW5cXC53aWtpcGVkaWFcXC5vcmdcXC93aWtpXFwvKFteXFxdXSs/KSAoLis/KVxcXS9pZ1xuICAgICAgICB0eHQgPSB0eHQucmVwbGFjZShyZSwgJ1tbd2lraXBlZGlhOiQxfCQyXV0nKVxuXG4gICAgICAgIHJlID0gL1xcW2h0dHBzPzpcXC9cXC9lblxcLndpa2lwZWRpYVxcLm9yZ1xcL3dpa2lcXC8oLis/KVxcXS9pZ1xuICAgICAgICB0eHQgPSB0eHQucmVwbGFjZShyZSwgJ1tbd2lraXBlZGlhOiQxXV0nKVxuXG4gICAgICAgIHJlID0gL2h0dHBzPzpcXC9cXC9lblxcLndpa2lwZWRpYVxcLm9yZ1xcL3dpa2lcXC8oW15cXHNdKykvaWdcbiAgICAgICAgdHh0ID0gdHh0LnJlcGxhY2UocmUsICdbW3dpa2lwZWRpYTokMV1dJylcblxuICAgICAgICByZSA9IC9odHRwcz86XFwvXFwvKFthLXpdKz8pXFwud2lraXBlZGlhXFwub3JnKD8hXFwuKS9pZ1xuXG4gICAgICAgIGlmIHJlLnRlc3QodHh0KVxuICAgICAgICAgICAgQFdNLkxvZy5sb2dXYXJuaW5nKFwiSXQgaGFzbid0IGJlZW4gcG9zc2libGUgdG8gY29udmVydCBzb21lIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJsaW5rcyB0byBXaWtpcGVkaWFcIilcblxuICAgICAgICAjIE9mZmljaWFsIHBhY2thZ2UgbGlua3MgLT4gUGtnIHRlbXBsYXRlXG5cbiAgICAgICAgcmUgPSAvXFxbaHR0cHM/OlxcL1xcLyg/Ond3d1xcLik/YXJjaGxpbnV4XFwub3JnXFwvcGFja2FnZXNcXC8oPzpjb21tdW5pdHl8Y29tbXVuaXR5LXRlc3Rpbmd8Y29yZXxleHRyYXxtdWx0aWxpYnxtdWx0aWxpYi10ZXN0aW5nfHRlc3RpbmcpXFwvKD86YW55fGk2ODZ8eDg2XzY0KVxcLyhbXlxcc10rPylcXC8/ICsoLis/KT9cXF0vaWdcbiAgICAgICAgbmV3VGV4dCA9ICcnXG4gICAgICAgIHByZXZJZCA9IDBcblxuICAgICAgICB3aGlsZSB0cnVlXG4gICAgICAgICAgICBtYXRjaCA9IHJlLmV4ZWModHh0KVxuXG4gICAgICAgICAgICBpZiBtYXRjaFxuICAgICAgICAgICAgICAgICMgRG9uJ3Qgam9pbiB0aGVzZSB0d28gY29uZGl0aW9uc1xuICAgICAgICAgICAgICAgIGlmIG1hdGNoWzFdID09IG1hdGNoWzJdXG4gICAgICAgICAgICAgICAgICAgIEwgPSBtYXRjaFswXS5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgbmV3VGV4dCArPSB0eHQuc3Vic3RyaW5nKHByZXZJZCwgcmUubGFzdEluZGV4IC0gTCkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICd7e1BrZ3wnICsgbWF0Y2hbMV0gKyAnfX0nXG5cbiAgICAgICAgICAgICAgICAgICAgcHJldklkID0gcmUubGFzdEluZGV4XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgYnJlYWtcblxuICAgICAgICBuZXdUZXh0ICs9IHR4dC5zdWJzdHIocHJldklkKVxuICAgICAgICB0eHQgPSBuZXdUZXh0XG5cbiAgICAgICAgcmUgPSAvXFxbaHR0cHM/OlxcL1xcLyg/Ond3d1xcLik/YXJjaGxpbnV4XFwub3JnXFwvcGFja2FnZXNcXC8oPzpjb21tdW5pdHl8Y29tbXVuaXR5LXRlc3Rpbmd8Y29yZXxleHRyYXxtdWx0aWxpYnxtdWx0aWxpYi10ZXN0aW5nfHRlc3RpbmcpXFwvKD86YW55fGk2ODZ8eDg2XzY0KVxcLyhbXlxcc10rPylcXC8/XFxdL2lnXG4gICAgICAgIHR4dCA9IHR4dC5yZXBsYWNlKHJlLCAne3tQa2d8JDF9fScpXG5cbiAgICAgICAgcmUgPSAvKFteXFxbXSlodHRwcz86XFwvXFwvKD86d3d3XFwuKT9hcmNobGludXhcXC5vcmdcXC9wYWNrYWdlc1xcLyg/OmNvbW11bml0eXxjb21tdW5pdHktdGVzdGluZ3xjb3JlfGV4dHJhfG11bHRpbGlifG11bHRpbGliLXRlc3Rpbmd8dGVzdGluZylcXC8oPzphbnl8aTY4Nnx4ODZfNjQpXFwvKFteXFxzXFwvXSspXFwvPy9pZ1xuICAgICAgICB0eHQgPSB0eHQucmVwbGFjZShyZSwgJyQxe3tQa2d8JDJ9fScpXG5cbiAgICAgICAgcmUgPSAvaHR0cHM/OlxcL1xcLyg/Ond3d1xcLik/YXJjaGxpbnV4XFwub3JnXFwvcGFja2FnZXMoPyFcXC8/XFxzKS9pZ1xuXG4gICAgICAgIGlmIHJlLnRlc3QodHh0KVxuICAgICAgICAgICAgQFdNLkxvZy5sb2dXYXJuaW5nKFwiSXQgaGFzbid0IGJlZW4gcG9zc2libGUgdG8gY29udmVydCBzb21lIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJsaW5rcyB0byBhcmNobGludXgub3JnL3BhY2thZ2VzXCIpXG5cbiAgICAgICAgIyBBVVIgcGFja2FnZSBsaW5rcyAtPiBBVVIgdGVtcGxhdGVcblxuICAgICAgICByZSA9IC9cXFtodHRwcz86XFwvXFwvYXVyXFwuYXJjaGxpbnV4XFwub3JnXFwvcGFja2FnZXNcXC8oW15cXHNdKz8pXFwvPyArKC4rPyk/XFxdL2lnXG4gICAgICAgIG5ld1RleHQgPSAnJ1xuICAgICAgICBwcmV2SWQgPSAwXG5cbiAgICAgICAgd2hpbGUgdHJ1ZVxuICAgICAgICAgICAgbWF0Y2ggPSByZS5leGVjKHR4dClcblxuICAgICAgICAgICAgaWYgbWF0Y2hcbiAgICAgICAgICAgICAgICAjIERvbid0IGpvaW4gdGhlc2UgdHdvIGNvbmRpdGlvbnNcbiAgICAgICAgICAgICAgICBpZiBtYXRjaFsxXSA9PSBtYXRjaFsyXVxuICAgICAgICAgICAgICAgICAgICBMID0gbWF0Y2hbMF0ubGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgIG5ld1RleHQgKz0gdHh0LnN1YnN0cmluZyhwcmV2SWQsIHJlLmxhc3RJbmRleCAtIEwpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAne3tBVVJ8JyArIG1hdGNoWzFdICsgJ319J1xuXG4gICAgICAgICAgICAgICAgICAgIHByZXZJZCA9IHJlLmxhc3RJbmRleFxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgbmV3VGV4dCArPSB0eHQuc3Vic3RyKHByZXZJZClcbiAgICAgICAgdHh0ID0gbmV3VGV4dFxuXG4gICAgICAgIHJlID0gL1xcW2h0dHBzPzpcXC9cXC9hdXJcXC5hcmNobGludXhcXC5vcmdcXC9wYWNrYWdlc1xcLyhbXlxcc10rPylcXC8/XFxdL2lnXG4gICAgICAgIHR4dCA9IHR4dC5yZXBsYWNlKHJlLCAne3tBVVJ8JDF9fScpXG5cbiAgICAgICAgcmUgPSAvKFteXFxbXSlodHRwcz86XFwvXFwvYXVyXFwuYXJjaGxpbnV4XFwub3JnXFwvcGFja2FnZXNcXC8oW15cXHNcXC9dKylcXC8/L2lnXG4gICAgICAgIHR4dCA9IHR4dC5yZXBsYWNlKHJlLCAnJDF7e0FVUnwkMn19JylcblxuICAgICAgICByZSA9IC9odHRwcz86XFwvXFwvYXVyXFwuYXJjaGxpbnV4XFwub3JnKD8hKD86XFwufCg/OlxcLz9wYWNrYWdlcyk/XFwvP1xccykpL2lnXG5cbiAgICAgICAgaWYgcmUudGVzdCh0eHQpXG4gICAgICAgICAgICBAV00uTG9nLmxvZ1dhcm5pbmcoXCJJdCBoYXNuJ3QgYmVlbiBwb3NzaWJsZSB0byBjb252ZXJ0IHNvbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rcyB0byBhdXIuYXJjaGxpbnV4Lm9yZyAodHJ5IHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcXCJGaXggb2xkIEFVUiBsaW5rc1xcXCIgZnVuY3Rpb24sIGlmIGluc3RhbGxlZClcIilcblxuICAgICAgICAjIEJ1ZyBsaW5rcyAtPiBCdWcgdGVtcGxhdGVcblxuICAgICAgICByZSA9IC9cXFtodHRwcz86XFwvXFwvYnVnc1xcLmFyY2hsaW51eFxcLm9yZ1xcL3Rhc2tcXC8oW15cXHNdKz8pXFwvPyArKC4rPyk/XFxdL2lnXG4gICAgICAgIG5ld1RleHQgPSAnJ1xuICAgICAgICBwcmV2SWQgPSAwXG5cbiAgICAgICAgd2hpbGUgdHJ1ZVxuICAgICAgICAgICAgbWF0Y2ggPSByZS5leGVjKHR4dClcblxuICAgICAgICAgICAgaWYgbWF0Y2hcbiAgICAgICAgICAgICAgICAjIERvbid0IGpvaW4gdGhlc2UgdHdvIGNvbmRpdGlvbnNcbiAgICAgICAgICAgICAgICBpZiBtYXRjaFsxXSA9PSBtYXRjaFsyXVxuICAgICAgICAgICAgICAgICAgICBMID0gbWF0Y2hbMF0ubGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgIG5ld1RleHQgKz0gdHh0LnN1YnN0cmluZyhwcmV2SWQsIHJlLmxhc3RJbmRleCAtIEwpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAne3tCdWd8JyArIG1hdGNoWzFdICsgJ319J1xuXG4gICAgICAgICAgICAgICAgICAgIHByZXZJZCA9IHJlLmxhc3RJbmRleFxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgbmV3VGV4dCArPSB0eHQuc3Vic3RyKHByZXZJZClcbiAgICAgICAgdHh0ID0gbmV3VGV4dFxuXG4gICAgICAgIHJlID0gL1xcW2h0dHBzPzpcXC9cXC9idWdzXFwuYXJjaGxpbnV4XFwub3JnXFwvdGFza1xcLyhbXlxcc10rPylcXC8/XFxdL2lnXG4gICAgICAgIHR4dCA9IHR4dC5yZXBsYWNlKHJlLCAne3tCdWd8JDF9fScpXG5cbiAgICAgICAgcmUgPSAvKFteXFxbXSlodHRwcz86XFwvXFwvYnVnc1xcLmFyY2hsaW51eFxcLm9yZ1xcL3Rhc2tcXC8oW15cXHNcXC9dKylcXC8/L2lnXG4gICAgICAgIHR4dCA9IHR4dC5yZXBsYWNlKHJlLCAnJDF7e0J1Z3wkMn19JylcblxuICAgICAgICByZSA9IC9odHRwcz86XFwvXFwvYnVnc1xcLmFyY2hsaW51eFxcLm9yZ1xcL3Rhc2svaWdcblxuICAgICAgICBpZiByZS50ZXN0KHR4dClcbiAgICAgICAgICAgIEBXTS5Mb2cubG9nV2FybmluZyhcIkl0IGhhc24ndCBiZWVuIHBvc3NpYmxlIHRvIGNvbnZlcnQgc29tZSBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJsaW5rcyB0byBidWdzLmFyY2hsaW51eC5vcmcvdGFza1wiKVxuXG4gICAgICAgIHJldHVybiB0eHRcblxuICAgIG1haW5fZWRpdG9yOiAoY2FsbE5leHQpIC0+XG4gICAgICAgIHNvdXJjZSA9IEBXTS5FZGl0b3IucmVhZFNvdXJjZSgpXG4gICAgICAgIG5ld3RleHQgPSBAZG9SZXBsYWNlKHNvdXJjZSlcblxuICAgICAgICBpZiBuZXd0ZXh0ICE9IHNvdXJjZVxuICAgICAgICAgICAgQFdNLkVkaXRvci53cml0ZVNvdXJjZShuZXd0ZXh0KVxuICAgICAgICAgICAgQFdNLkxvZy5sb2dJbmZvKFwiRml4ZWQgbGlua3NcIilcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgQFdNLkxvZy5sb2dJbmZvKFwiTm8gZml4YWJsZSBsaW5rcyBmb3VuZFwiKVxuXG4gICAgICAgIGlmIGNhbGxOZXh0XG4gICAgICAgICAgICBjYWxsTmV4dCgpXG5cbiAgICAjIE5vdGUgdGhhdCBpdCdzIHRvbyBkYW5nZXJvdXMgdG8gdXNlIHRoaXMgcGx1Z2luIHdpdGggdGhlIGJvdCwgaW4gZmFjdFxuICAgICMgc29tZSBmdWxsIFVSTHMgYXJlIGNvcnJlY3RseSB1c2VkIGluIGNvZGUgYmxvY2tzIChlLmcuIHdnZXQgbGluZXMpXG4iLCIjIFdpa2kgTW9ua2V5IC0gTWVkaWFXaWtpIGJvdCBhbmQgZWRpdG9yLWFzc2lzdGFudCB1c2VyIHNjcmlwdFxuIyBDb3B5cmlnaHQgKEMpIDIwMTEgRGFyaW8gR2lvdmFubmV0dGkgPGRldkBkYXJpb2dpb3Zhbm5ldHRpLm5ldD5cbiNcbiMgVGhpcyBmaWxlIGlzIHBhcnQgb2YgV2lraSBNb25rZXkuXG4jXG4jIFdpa2kgTW9ua2V5IGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiMgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiMgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiMgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbiNcbiMgV2lraSBNb25rZXkgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiMgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiMgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuIyBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuI1xuIyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuIyBhbG9uZyB3aXRoIFdpa2kgTW9ua2V5LiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuXG57UGx1Z2lufSA9IHJlcXVpcmUoJy4vX1BsdWdpbicpXG5cbkNTUyA9IHJlcXVpcmUoJ0BreW5pa29zL21pc2MvZGlzdC9DU1MnKVxuXG5cbmNsYXNzIG1vZHVsZS5leHBvcnRzLkFyY2hXaWtpTlBGaWx0ZXIgZXh0ZW5kcyBQbHVnaW5cbiAgICBAY29uZl9kZWZhdWx0OlxuICAgICAgICBlbmFibGVkOiB0cnVlXG4gICAgICAgIGZpbHRlcl9sYWJlbDogXCJEZWZhdWx0IGZpbHRlclwiXG4gICAgICAgIGRlZmF1bHRfbGFuZ3VhZ2U6IFwiRW5nbGlzaFwiXG5cbiAgICBtYWluX25ld3BhZ2VzOiAtPlxuICAgICAgICBDU1MuYWRkU3R5bGVFbGVtZW50KFwiI213LWNvbnRlbnQtdGV4dCA+IGg1XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge2JhY2tncm91bmQtY29sb3I6I2FmYTt9XCIpXG5cbiAgICAgICAgY29udGVudERpdiA9ICQoJyNtdy1jb250ZW50LXRleHQnKVxuICAgICAgICB1bCA9IGNvbnRlbnREaXYuZmluZCgndWwnKS5maXJzdCgpXG4gICAgICAgIGxpTGlzdCA9IHVsLmNoaWxkcmVuKCdsaScpXG5cbiAgICAgICAgZm9yIGxpIGluIGxpTGlzdFxuICAgICAgICAgICAgbGluayA9ICQobGkpLmZpbmQoJ2EubXctbmV3cGFnZXMtcGFnZW5hbWUnKS5maXJzdCgpXG4gICAgICAgICAgICBbcHVyZVRpdGxlLCBsYW5ndWFnZV0gPSBAV00uQXJjaFdpa2kuZGV0ZWN0TGFuZ3VhZ2UobGlua1swXS50aXRsZSlcbiAgICAgICAgICAgIGlmIGxhbmd1YWdlICE9IEBjb25mLmRlZmF1bHRfbGFuZ3VhZ2VcbiAgICAgICAgICAgICAgICBAbW92ZUFydGljbGUoY29udGVudERpdiwgbGksIGxhbmd1YWdlKVxuXG4gICAgICAgIEBXTS5Mb2cubG9nSW5mbyhcIkdyb3VwZWQgYXJ0aWNsZXMgYnkgbGFuZ3VhZ2VcIilcblxuICAgIG1vdmVBcnRpY2xlOiAoY29udGVudERpdiwgbGksIGxhbmd1YWdlKSAtPlxuICAgICAgICBsYW5nSHMgPSBjb250ZW50RGl2LmNoaWxkcmVuKCdoNScpXG4gICAgICAgIGxhbmdGb3VuZCA9IGZhbHNlXG4gICAgICAgIGZvciBITGFuZyBpbiBsYW5nSHNcbiAgICAgICAgICAgIGlmIEhMYW5nLmlubmVySFRNTCA9PSBsYW5ndWFnZVxuICAgICAgICAgICAgICAgIHVsID0gJChITGFuZykubmV4dCgpLmFwcGVuZChsaSlcbiAgICAgICAgICAgICAgICBsYW5nRm91bmQgPSB0cnVlXG4gICAgICAgICAgICAgICAgYnJlYWtcblxuICAgICAgICBpZiBub3QgbGFuZ0ZvdW5kXG4gICAgICAgICAgICBjb250ZW50RGl2LmFwcGVuZChcbiAgICAgICAgICAgICAgICAkKCc8aDU+JykudGV4dChsYW5ndWFnZSksXG4gICAgICAgICAgICAgICAgJCgnPHVsPicpLmFwcGVuZChsaSksXG4gICAgICAgICAgICApXG4iLCIjIFdpa2kgTW9ua2V5IC0gTWVkaWFXaWtpIGJvdCBhbmQgZWRpdG9yLWFzc2lzdGFudCB1c2VyIHNjcmlwdFxuIyBDb3B5cmlnaHQgKEMpIDIwMTEgRGFyaW8gR2lvdmFubmV0dGkgPGRldkBkYXJpb2dpb3Zhbm5ldHRpLm5ldD5cbiNcbiMgVGhpcyBmaWxlIGlzIHBhcnQgb2YgV2lraSBNb25rZXkuXG4jXG4jIFdpa2kgTW9ua2V5IGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiMgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiMgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiMgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbiNcbiMgV2lraSBNb25rZXkgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiMgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiMgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuIyBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuI1xuIyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuIyBhbG9uZyB3aXRoIFdpa2kgTW9ua2V5LiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuXG57UGx1Z2lufSA9IHJlcXVpcmUoJy4vX1BsdWdpbicpXG5cblxuY2xhc3MgbW9kdWxlLmV4cG9ydHMuQXJjaFdpa2lOZXdUZW1wbGF0ZXMgZXh0ZW5kcyBQbHVnaW5cbiAgICBAY29uZl9kZWZhdWx0OlxuICAgICAgICBlbmFibGVkOiB0cnVlXG4gICAgICAgIGVkaXRvcl9tZW51OiBbXCJUZXh0IHBsdWdpbnNcIiwgXCJVc2UgY29kZSB0ZW1wbGF0ZXNcIl1cblxuICAgIG1haW5fZWRpdG9yOiAoY2FsbE5leHQpIC0+XG4gICAgICAgIHNvdXJjZSA9IEBXTS5FZGl0b3IucmVhZFNvdXJjZSgpXG4gICAgICAgIG5ld3RleHQgPSBzb3VyY2VcblxuICAgICAgICByZTggPSAvPHByZT4oKCg/ITwocHJlfG5vd2lraSk+KVteXFw9XFx8XSkqPygoPyE8KHByZXxub3dpa2kpPilbXlxcPVxcfFxcfV0pKTxcXC9wcmU+L2lnXG4gICAgICAgIHJlOSA9IC88cHJlPigoKD8hPChwcmV8bm93aWtpKT4pW15cXHxdKSo/KCg/ITwocHJlfG5vd2lraSk+KVteXFx8XFx9XSkpPFxcL3ByZT4vaWdcbiAgICAgICAgcmUxMCA9IC88cHJlPihcXG4qKCg/ITwocHJlfG5vd2lraSk+KS5cXG4qKSs/KTxcXC9wcmU+L2lnXG5cbiAgICAgICAgcmUxMSA9IC88Y29kZT4oKCg/ITwoY29kZXxub3dpa2kpPilbXlxcPVxcfFxcbl0pKj8oKD8hPChjb2RlfG5vd2lraSk+KVteXFw9XFx8XFx9XFxuXSkpPFxcL2NvZGU+L2lnXG4gICAgICAgIHJlMTIgPSAvPGNvZGU+KCgoPyE8KGNvZGV8bm93aWtpKT4pW15cXHxcXG5dKSo/KCg/ITwoY29kZXxub3dpa2kpPilbXlxcfFxcfVxcbl0pKTxcXC9jb2RlPi9pZ1xuICAgICAgICByZTEzID0gLzxjb2RlPigoKD8hPChjb2RlfG5vd2lraSk+KVteXFxuXSkrPyk8XFwvY29kZT4vaWdcblxuICAgICAgICByZTE0ID0gLzx0dD4oKCg/ITwodHR8bm93aWtpKT4pW15cXD1cXHxcXG5dKSo/KCg/ITwodHR8bm93aWtpKT4pW15cXD1cXHxcXH1cXG5dKSk8XFwvdHQ+L2lnXG4gICAgICAgIHJlMTUgPSAvPHR0PigoKD8hPCh0dHxub3dpa2kpPilbXlxcfFxcbl0pKj8oKD8hPCh0dHxub3dpa2kpPilbXlxcfFxcfVxcbl0pKTxcXC90dD4vaWdcbiAgICAgICAgcmUxNiA9IC88dHQ+KCgoPyE8KHR0fG5vd2lraSk+KVteXFxuXSkrPyk8XFwvdHQ+L2lnXG5cbiAgICAgICAgbmV3dGV4dCA9IG5ld3RleHQucmVwbGFjZShyZTgsICd7e2JjfCQxfX0nKVxuICAgICAgICBuZXd0ZXh0ID0gbmV3dGV4dC5yZXBsYWNlKHJlOSwgJ3t7YmN8MT0kMX19JykgICMgTXVzdCBjb21lIGFmdGVyIHJlOFxuICAgICAgICBuZXd0ZXh0ID0gbmV3dGV4dC5yZXBsYWNlKHJlMTAsXG4gICAgICAgICAgICAgICAgICAgICAgICAne3tiY3w8bm93aWtpPiQxPC9ub3dpa2k+fX0nKSAgIyBNdXN0IGNvbWUgYWZ0ZXIgcmU5XG5cbiAgICAgICAgbmV3dGV4dCA9IG5ld3RleHQucmVwbGFjZShyZTExLCAne3tpY3wkMX19JylcbiAgICAgICAgbmV3dGV4dCA9IG5ld3RleHQucmVwbGFjZShyZTEyLCAne3tpY3wxPSQxfX0nKSAgIyBNdXN0IGNvbWUgYWZ0ZXIgcmUxMVxuICAgICAgICBuZXd0ZXh0ID0gbmV3dGV4dC5yZXBsYWNlKHJlMTMsXG4gICAgICAgICAgICAgICAgICAgICAgICAne3tpY3w8bm93aWtpPiQxPC9ub3dpa2k+fX0nKSAgIyBNdXN0IGNvbWUgYWZ0ZXIgcmUxMlxuXG4gICAgICAgIG5ld3RleHQgPSBuZXd0ZXh0LnJlcGxhY2UocmUxNCwgJ3t7aWN8JDF9fScpXG4gICAgICAgIG5ld3RleHQgPSBuZXd0ZXh0LnJlcGxhY2UocmUxNSwgJ3t7aWN8MT0kMX19JykgICMgTXVzdCBjb21lIGFmdGVyIHJlMTRcbiAgICAgICAgbmV3dGV4dCA9IG5ld3RleHQucmVwbGFjZShyZTE2LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3t7aWN8PG5vd2lraT4kMTwvbm93aWtpPn19JykgICMgTXVzdCBjb21lIGFmdGVyIHJlMTVcblxuICAgICAgICBpZiBuZXd0ZXh0ICE9IHNvdXJjZVxuICAgICAgICAgICAgQFdNLkVkaXRvci53cml0ZVNvdXJjZShuZXd0ZXh0KVxuICAgICAgICAgICAgQFdNLkxvZy5sb2dJbmZvKFwiVHVybmVkIEhUTUwgdGFncyBpbnRvIHByb3BlciB0ZW1wbGF0ZXNcIilcblxuICAgICAgICB0ZXN0cyA9IFtcbiAgICAgICAgICAgIFsnJmx0O3ByZT4nLCBuZXd0ZXh0Lm1hdGNoKC88cHJlL2lnKV0sXG4gICAgICAgICAgICBbJyZsdDtjb2RlPicsIG5ld3RleHQubWF0Y2goLzxjb2RlL2lnKV0sXG4gICAgICAgICAgICBbJyZsdDt0dD4nLCBuZXd0ZXh0Lm1hdGNoKC88dHQvaWcpXVxuICAgICAgICBdXG5cbiAgICAgICAgZm9yIHRlc3QgaW4gdGVzdHNcbiAgICAgICAgICAgIGlmIHRlc3RbMV1cbiAgICAgICAgICAgICAgICBAV00uTG9nLmxvZ1dhcm5pbmcodGVzdFsxXS5sZW5ndGggKyAnICcgK1xuICAgICAgICAgICAgICAgICAgICB0ZXN0WzBdICsgJyBpbnN0YW5jZXMgcmVxdWlyZSBtYW51YWwgaW50ZXJ2ZW50aW9uJylcblxuICAgICAgICBpZiBjYWxsTmV4dFxuICAgICAgICAgICAgY2FsbE5leHQoKVxuIiwiIyBXaWtpIE1vbmtleSAtIE1lZGlhV2lraSBib3QgYW5kIGVkaXRvci1hc3Npc3RhbnQgdXNlciBzY3JpcHRcbiMgQ29weXJpZ2h0IChDKSAyMDExIERhcmlvIEdpb3Zhbm5ldHRpIDxkZXZAZGFyaW9naW92YW5uZXR0aS5uZXQ+XG4jXG4jIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFdpa2kgTW9ua2V5LlxuI1xuIyBXaWtpIE1vbmtleSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4jIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4jIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4jIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4jXG4jIFdpa2kgTW9ua2V5IGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4jIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4jIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiMgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbiNcbiMgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiMgYWxvbmcgd2l0aCBXaWtpIE1vbmtleS4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cblxue1BsdWdpbn0gPSByZXF1aXJlKCcuL19QbHVnaW4nKVxuXG5DU1MgPSByZXF1aXJlKCdAa3luaWtvcy9taXNjL2Rpc3QvQ1NTJylcblxuXG5jbGFzcyBtb2R1bGUuZXhwb3J0cy5BcmNoV2lraVJDRmlsdGVyIGV4dGVuZHMgUGx1Z2luXG4gICAgQGNvbmZfZGVmYXVsdDpcbiAgICAgICAgZW5hYmxlZDogdHJ1ZVxuICAgICAgICBmaWx0ZXJfbGFiZWw6IFwiRGVmYXVsdCBmaWx0ZXJcIlxuICAgICAgICBkZWZhdWx0X2xhbmd1YWdlOiBcIkVuZ2xpc2hcIlxuXG4gICAgbWFpbl9yZWNlbnRjaGFuZ2VzOiAtPlxuICAgICAgICBoNHMgPSAkKCcjbXctY29udGVudC10ZXh0IC5tdy1jaGFuZ2VzbGlzdCA+IGg0JylcblxuICAgICAgICBpZiBoNHMuZXEoMCkubmV4dCgpWzBdLmxvY2FsTmFtZS50b0xvd2VyQ2FzZSgpICE9ICdkaXYnXG4gICAgICAgICAgICBAV00uTG9nLmxvZ0Vycm9yKFwiVGhpcyBmaWx0ZXIgaXMgZGVzaWduZWQgdG8gd29yayBvbiB0b3Agb2ZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1lZGlhV2lraSdzIGZpbHRlciwgd2hpY2ggeW91IGNhblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5hYmxlIGluIHlvdXIgdXNlciBwcmVmZXJlbmNlcy5cIilcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgQ1NTLmFkZFN0eWxlRWxlbWVudChcIiNtdy1jb250ZW50LXRleHQgPiBkaXYgPiBoNFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge2JhY2tncm91bmQtY29sb3I6I2FhZjt9XG4gICAgICAgICAgICAgICAgICAgICNtdy1jb250ZW50LXRleHQgPiBkaXYgPiBkaXYgPiBoNSB7YmFja2dyb3VuZC1jb2xvcjojYWZhO31cIilcblxuICAgICAgICAgICAgZm9yIGg0IGluIGg0c1xuICAgICAgICAgICAgICAgIGdyb3VwRGl2ID0gJChoNCkubmV4dCgpXG4gICAgICAgICAgICAgICAgZm9yIGFydGljbGVUYWJsZSBpbiBncm91cERpdi5jaGlsZHJlbigndGFibGUnKVxuICAgICAgICAgICAgICAgICAgICBsaW5rID0gJChhcnRpY2xlVGFibGUpLmZpbmQoJ2EubXctY2hhbmdlc2xpc3QtdGl0bGUnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZmlyc3QoKVxuICAgICAgICAgICAgICAgICAgICBpZiBsaW5rWzBdXG4gICAgICAgICAgICAgICAgICAgICAgICBbcHVyZVRpdGxlLCBsYW5ndWFnZV0gPSBAV00uQXJjaFdpa2kuZGV0ZWN0TGFuZ3VhZ2UoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua1swXS50aXRsZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIGxhbmd1YWdlICE9IEBjb25mLmRlZmF1bHRfbGFuZ3VhZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBAbW92ZUFydGljbGUoZ3JvdXBEaXYsIGFydGljbGVUYWJsZSwgbGFuZ3VhZ2UpXG5cbiAgICAgICAgICAgIEBXTS5Mb2cubG9nSW5mbyhcIkdyb3VwZWQgYXJ0aWNsZXMgYnkgbGFuZ3VhZ2VcIilcblxuICAgIG1vdmVBcnRpY2xlOiAoZ3JvdXBEaXYsIGFydGljbGVUYWJsZSwgbGFuZ3VhZ2UpIC0+XG4gICAgICAgIGxhbmdIcyA9IGdyb3VwRGl2LmNoaWxkcmVuKCdoNScpXG4gICAgICAgIGxhbmdGb3VuZCA9IGZhbHNlXG4gICAgICAgIGZvciBITGFuZywgaSBpbiBsYW5nSHNcbiAgICAgICAgICAgIGlmIEhMYW5nLmlubmVySFRNTCA9PSBsYW5ndWFnZVxuICAgICAgICAgICAgICAgIGlmIGkgKyAxIDwgbGFuZ0hzLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICBsYW5nSHMuZXEoaSArIDEpLmJlZm9yZShhcnRpY2xlVGFibGUpXG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBncm91cERpdi5hcHBlbmQoYXJ0aWNsZVRhYmxlKVxuICAgICAgICAgICAgICAgIGxhbmdGb3VuZCA9IHRydWVcbiAgICAgICAgICAgICAgICBicmVha1xuXG4gICAgICAgIGlmIG5vdCBsYW5nRm91bmRcbiAgICAgICAgICAgIGdyb3VwRGl2LmFwcGVuZChcbiAgICAgICAgICAgICAgICAkKCc8aDU+JykudGV4dChsYW5ndWFnZSksXG4gICAgICAgICAgICAgICAgYXJ0aWNsZVRhYmxlLFxuICAgICAgICAgICAgKVxuIiwiIyBXaWtpIE1vbmtleSAtIE1lZGlhV2lraSBib3QgYW5kIGVkaXRvci1hc3Npc3RhbnQgdXNlciBzY3JpcHRcbiMgQ29weXJpZ2h0IChDKSAyMDExIERhcmlvIEdpb3Zhbm5ldHRpIDxkZXZAZGFyaW9naW92YW5uZXR0aS5uZXQ+XG4jXG4jIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFdpa2kgTW9ua2V5LlxuI1xuIyBXaWtpIE1vbmtleSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4jIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4jIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4jIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4jXG4jIFdpa2kgTW9ua2V5IGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4jIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4jIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiMgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbiNcbiMgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiMgYWxvbmcgd2l0aCBXaWtpIE1vbmtleS4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cblxue1BsdWdpbn0gPSByZXF1aXJlKCcuL19QbHVnaW4nKVxuXG5DU1MgPSByZXF1aXJlKCdAa3luaWtvcy9taXNjL2Rpc3QvQ1NTJylcbkhUVFAgPSByZXF1aXJlKCdAa3luaWtvcy9taXNjL2Rpc3QvSFRUUCcpXG5cblxuY2xhc3MgbW9kdWxlLmV4cG9ydHMuQXJjaFdpa2lTYXZlVGFsayBleHRlbmRzIFBsdWdpblxuICAgIEBjb25mX2RlZmF1bHQ6XG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlXG4gICAgICAgIGRpZmZfbWVudTogW1wiU2F2ZSBkaXNjdXNzaW9uXCJdXG4gICAgICAgIHBhZ2U6IG51bGxcbiAgICAgICAgZWRpdF9zdW1tYXJ5OiBcImFkZCBkaXNjdXNzaW9uXCJcblxuICAgIG1ha2VVSTogLT5cbiAgICAgICAgQ1NTLmFkZFN0eWxlRWxlbWVudChcIiNXaWtpTW9ua2V5LUFyY2hXaWtpU2F2ZVRhbGtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7bWFyZ2luLWxlZnQ6MC4zM2VtO31cIilcblxuICAgICAgICBhcnRpY2xlID0gQGNvbmYucGFnZVxuXG4gICAgICAgIGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJylcbiAgICAgICAgbGluay5pZCA9IFwiV2lraU1vbmtleS1BcmNoV2lraVNhdmVUYWxrXCJcbiAgICAgICAgbGluay5ocmVmID0gXCIvaW5kZXgucGhwL1wiICsgYXJ0aWNsZVxuICAgICAgICBsaW5rLmlubmVySFRNTCA9IGFydGljbGVcblxuICAgICAgICByZXR1cm4gbGlua1xuXG4gICAgbWFpbl9kaWZmOiAoY2FsbE5leHQpIC0+XG4gICAgICAgIGFydGljbGUgPSBAY29uZi5wYWdlXG4gICAgICAgIHN1bW1hcnkgPSBAY29uZi5lZGl0X3N1bW1hcnlcblxuICAgICAgICBAV00uTG9nLmxvZ0luZm8oJ0FwcGVuZGluZyBkaWZmIHRvICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEBXTS5Mb2cubGlua1RvV2lraVBhZ2UoYXJ0aWNsZSwgYXJ0aWNsZSkgKyBcIiAuLi5cIilcblxuICAgICAgICBAV00uRGlmZi5nZXRFbmRUaW1lc3RhbXAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQG1haW5HZXRFbmRUaW1lc3RhbXAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW2FydGljbGUsIHN1bW1hcnksIGNhbGxOZXh0XSlcblxuICAgIG1haW5HZXRFbmRUaW1lc3RhbXA6IChlbmRkYXRlLCBhcmdzKSA9PlxuICAgICAgICBhcnRpY2xlID0gYXJnc1swXVxuICAgICAgICBzdW1tYXJ5ID0gYXJnc1sxXVxuICAgICAgICBjYWxsTmV4dCA9IGFyZ3NbMl1cblxuICAgICAgICBAV00uTVcuY2FsbFF1ZXJ5RWRpdChhcnRpY2xlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEBtYWluV3JpdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW3N1bW1hcnksIGVuZGRhdGUsIGNhbGxOZXh0XSlcblxuICAgIG1haW5Xcml0ZTogKGFydGljbGUsIHNvdXJjZSwgdGltZXN0YW1wLCBlZGl0dG9rZW4sIGFyZ3MpID0+XG4gICAgICAgIHN1bW1hcnkgPSBhcmdzWzBdXG4gICAgICAgIGVuZGRhdGUgPSBhcmdzWzFdXG4gICAgICAgIGNhbGxOZXh0ID0gYXJnc1syXVxuXG4gICAgICAgIHRpdGxlID0gSFRUUC5nZXRVUklQYXJhbWV0ZXIobnVsbCwgJ3RpdGxlJylcbiAgICAgICAgcEVuZGRhdGUgPSBlbmRkYXRlLnN1YnN0cigwLCAxMCkgKyBcIiZuYnNwO1wiICsgZW5kZGF0ZS5zdWJzdHIoMTEsIDgpXG5cbiAgICAgICAgbmV3dGV4dCA9IEBXTS5UYWJsZXMuYXBwZW5kUm93KHNvdXJjZSwgXCI8IS0tIFJFUExZIFRBQkxFIC0tPlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgW1wiW1wiICsgbG9jYXRpb24uaHJlZiArIFwiIFwiICsgdGl0bGUgKyBcIl1cIiwgcEVuZGRhdGVdKVxuXG4gICAgICAgIEBXTS5NVy5jYWxsQVBJUG9zdChcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBhY3Rpb246IFwiZWRpdFwiLFxuICAgICAgICAgICAgICAgIGJvdDogXCIxXCIsXG4gICAgICAgICAgICAgICAgdGl0bGU6IGFydGljbGUsXG4gICAgICAgICAgICAgICAgc3VtbWFyeTogc3VtbWFyeSxcbiAgICAgICAgICAgICAgICB0ZXh0OiBuZXd0ZXh0LFxuICAgICAgICAgICAgICAgIGJhc2V0aW1lc3RhbXA6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICAgICB0b2tlbjogZWRpdHRva2VuXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgQG1haW5FbmQsXG4gICAgICAgICAgICBbYXJ0aWNsZSwgY2FsbE5leHRdLFxuICAgICAgICAgICAgbnVsbFxuICAgICAgICApXG5cbiAgICBtYWluRW5kOiAocmVzLCBhcmdzKSA9PlxuICAgICAgICBhcnRpY2xlID0gYXJnc1swXVxuICAgICAgICBjYWxsTmV4dCA9IGFyZ3NbMV1cblxuICAgICAgICBpZiByZXMuZWRpdCBhbmQgcmVzLmVkaXQucmVzdWx0ID09ICdTdWNjZXNzJ1xuICAgICAgICAgICAgQFdNLkxvZy5sb2dJbmZvKCdEaWZmIGNvcnJlY3RseSBhcHBlbmRlZCB0byAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEBXTS5Mb2cubGlua1RvV2lraVBhZ2UoYXJ0aWNsZSwgYXJ0aWNsZSkpXG4gICAgICAgICAgICBpZiBjYWxsTmV4dFxuICAgICAgICAgICAgICAgIGNhbGxOZXh0KClcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgQFdNLkxvZy5sb2dFcnJvcignVGhlIGRpZmYgaGFzIG5vdCBiZWVuIGFwcGVuZGVkIVxcbicgK1xuICAgICAgICAgICAgICAgICAgICByZXNbJ2Vycm9yJ11bJ2luZm8nXSArIFwiIChcIiArIHJlc1snZXJyb3InXVsnY29kZSddICsgXCIpXCIpXG4iLCIjIFdpa2kgTW9ua2V5IC0gTWVkaWFXaWtpIGJvdCBhbmQgZWRpdG9yLWFzc2lzdGFudCB1c2VyIHNjcmlwdFxuIyBDb3B5cmlnaHQgKEMpIDIwMTEgRGFyaW8gR2lvdmFubmV0dGkgPGRldkBkYXJpb2dpb3Zhbm5ldHRpLm5ldD5cbiNcbiMgVGhpcyBmaWxlIGlzIHBhcnQgb2YgV2lraSBNb25rZXkuXG4jXG4jIFdpa2kgTW9ua2V5IGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiMgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiMgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiMgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbiNcbiMgV2lraSBNb25rZXkgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiMgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiMgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuIyBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuI1xuIyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuIyBhbG9uZyB3aXRoIFdpa2kgTW9ua2V5LiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuXG57UGx1Z2lufSA9IHJlcXVpcmUoJy4vX1BsdWdpbicpXG5cblxuY2xhc3MgbW9kdWxlLmV4cG9ydHMuQXJjaFdpa2lTb3J0Q29udGFjdHMgZXh0ZW5kcyBQbHVnaW5cbiAgICAjIFRoaXMgcGx1Z2luIHdhcyBvcmlnaW5hbGx5IGJhc2VkIG9uIGxpc3Q9YWxsdXNlcnMsIGJ1dCBiZWNhdXNlIG9mIGJ1Z1xuICAgICMgICMyMDggaXQgY2FuJ3QgcmVseSBvbiB0aGF0IGFueW1vcmUsIHNvIGl0IHdhcyByZXdyaXR0ZW4gd2l0aFxuICAgICMgIDYwYmIyYWMyYTJkY2QwYjE1YjdhYWM4MDcyNWM4MzE1MTE3M2VlYjNcbiAgICAjIFNlZSBhbHNvIGh0dHBzOi8vYmJzLmFyY2hsaW51eC5vcmcvdmlld3RvcGljLnBocD9pZD0xOTIzODkgYW5kXG4gICAgIyAgaHR0cHM6Ly9saXN0cy53aWtpbWVkaWEub3JnL3BpcGVybWFpbC9tZWRpYXdpa2ktbC8yMDE1LUphbnVhcnkvMDQzODUwLmh0bWxcblxuICAgIHN0YXJ0TWFyayA9IFwiU1RBUlQgQVVUTyBMSVNUIC0gRE8gTk9UIFJFTU9WRSBPUiBNT0RJRlkgVEhJUyBNQVJLLS0+XCJcbiAgICBlbmRNYXJrID0gXCI8IS0tRU5EIEFVVE8gTElTVCAtIERPIE5PVCBSRU1PVkUgT1IgTU9ESUZZIFRISVMgTUFSS1wiXG4gICAgIyBEb24ndCBkbyBcIig/OiBcXFxcPCEtLSBhc3NvY2lhdGVkIGJvdDogKC4rPykgLS0+KT8uKiRcIlxuICAgIHJlZ0V4cCA9IG5ldyBSZWdFeHAoXCJeXFxcXCouKj9cXFxcW1xcXFxbVXNlcjooLis/KVxcXFx8Lis/XCIgK1xuICAgICAgICAgICAgICAgICAgICBcIig/OiBcXFxcPCEtLSBhc3NvY2lhdGVkIGJvdDogKC4rPykgLS0+LiopPyRcIiwgXCJcIilcblxuICAgIEBjb25mX2RlZmF1bHQ6XG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlXG4gICAgICAgIHNwZWNpYWxfbWVudTogW1wiU29ydCBzdGFmZiBjb250YWN0c1wiXVxuICAgICAgICBlZGl0X3N1bW1hcnk6IFwiYXV0b21hdGljYWxseSBzb3J0IGxpc3QgYWNjb3JkaW5nIHRvIHJlY2VudCBhY3Rpdml0eVwiXG4gICAgICAgIHBhZ2VzOiBbe1xuICAgICAgICAgICAgdGl0bGU6IFwiQXJjaFdpa2k6QWRtaW5pc3RyYXRvcnNcIlxuICAgICAgICAgICAgcmVjZW50X2RheXM6IDMwXG4gICAgICAgICAgICBpbmFjdGl2ZV9saW1pdDogMzBcbiAgICAgICAgICAgIGluYWN0aXZlX21lc3NhZ2U6IFwiVGhlIGZvbGxvd2luZyBBZG1pbmlzdHJhdG9ycyBhcmUgY3VycmVudGx5XG4gICAgICAgICAgICAgICAgaW5hY3RpdmUgKGxlc3MgdGhhbiAzMCBlZGl0cyBpbiB0aGUgbGFzdCAzMCBkYXlzKTpcIlxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICB0aXRsZTogXCJBcmNoV2lraTpNYWludGFpbmVyc1wiXG4gICAgICAgICAgICByZWNlbnRfZGF5czogMzBcbiAgICAgICAgICAgIGluYWN0aXZlX2xpbWl0OiAxMFxuICAgICAgICAgICAgaW5hY3RpdmVfbWVzc2FnZTogXCJUaGUgZm9sbG93aW5nIE1haW50YWluZXJzIGFyZSBjdXJyZW50bHlcbiAgICAgICAgICAgICAgICBpbmFjdGl2ZSAobGVzcyB0aGFuIDEwIGVkaXRzIGluIHRoZSBsYXN0IDMwIGRheXMpOlwiXG4gICAgICAgIH1dXG5cbiAgICBtYWluX3NwZWNpYWw6IChjYWxsTmV4dCkgLT5cbiAgICAgICAgQGl0ZXJhdGVQYWdlcygtMSwgY2FsbE5leHQpXG5cbiAgICBpdGVyYXRlUGFnZXM6IChwYWdlaWQsIGNhbGxOZXh0KSAtPlxuICAgICAgICBwYWdlaWQrK1xuICAgICAgICBwY29uZiA9IEBjb25mLnBhZ2VzW3BhZ2VpZF1cbiAgICAgICAgaWYgcGNvbmZcbiAgICAgICAgICAgIHBhZ2UgPSBwY29uZi50aXRsZVxuICAgICAgICAgICAgcmVjZW50RGF5cyA9IHBjb25mLnJlY2VudF9kYXlzXG4gICAgICAgICAgICBpbmFjdGl2ZUxpbWl0ID0gcGNvbmYuaW5hY3RpdmVfbGltaXRcbiAgICAgICAgICAgIGluYWN0aXZlSW50cm8gPSBwY29uZi5pbmFjdGl2ZV9tZXNzYWdlXG4gICAgICAgICAgICBzdW1tYXJ5ID0gQGNvbmYuZWRpdF9zdW1tYXJ5XG5cbiAgICAgICAgICAgIEBXTS5Mb2cubG9nSW5mbyhcIlNvcnRpbmcgXCIgKyBAV00uTG9nLmxpbmtUb1dpa2lQYWdlKHBhZ2UsIHBhZ2UpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiIC4uLlwiKVxuXG4gICAgICAgICAgICBAV00uTVcuY2FsbFF1ZXJ5RWRpdChwYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBAcGFyc2VMaXN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbcmVjZW50RGF5cywgaW5hY3RpdmVMaW1pdCwgaW5hY3RpdmVJbnRybyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1bW1hcnksIGNhbGxOZXh0LCBwYWdlaWRdKVxuICAgICAgICBlbHNlIGlmIGNhbGxOZXh0XG4gICAgICAgICAgICBjYWxsTmV4dCgpXG5cbiAgICBwYXJzZUxpc3Q6ICh0aXRsZSwgc291cmNlLCB0aW1lc3RhbXAsIGVkaXR0b2tlbiwgYXJncykgPT5cbiAgICAgICAgcmVjZW50RGF5cyA9IGFyZ3NbMF1cbiAgICAgICAgaW5hY3RpdmVMaW1pdCA9IGFyZ3NbMV1cbiAgICAgICAgaW5hY3RpdmVJbnRybyA9IGFyZ3NbMl1cbiAgICAgICAgc3VtbWFyeSA9IGFyZ3NbM11cbiAgICAgICAgY2FsbE5leHQgPSBhcmdzWzRdXG4gICAgICAgIHBhZ2VpZCA9IGFyZ3NbNV1cblxuICAgICAgICBzdGFydExpc3QgPSBzb3VyY2UuaW5kZXhPZihzdGFydE1hcmspXG4gICAgICAgIGVuZExpc3QgPSBzb3VyY2UuaW5kZXhPZihlbmRNYXJrKVxuXG4gICAgICAgIGlmIHN0YXJ0TGlzdCA+IC0xIGFuZCBlbmRMaXN0ID4gLTFcbiAgICAgICAgICAgIHN0YXJ0TGlzdCArPSBzdGFydE1hcmsubGVuZ3RoXG4gICAgICAgICAgICBkYXRlID0gbmV3IERhdGUoKVxuICAgICAgICAgICAgdWNzdGFydCA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApXG4gICAgICAgICAgICB1Y2VuZCA9IHVjc3RhcnQgLSA4NjQwMCAqIHJlY2VudERheXNcbiAgICAgICAgICAgIHVzZXJzID1cbiAgICAgICAgICAgICAgICBhY3RpdmU6IFtdXG4gICAgICAgICAgICAgICAgaW5hY3RpdmU6IFtdXG5cbiAgICAgICAgICAgIHVzZXJzQXJyYXkgPSBzb3VyY2Uuc3Vic3RyaW5nKHN0YXJ0TGlzdCwgZW5kTGlzdCkuc3BsaXQoXCJcXG5cIilcbiAgICAgICAgICAgIEBpdGVyYXRlVXNlcnModXNlcnNBcnJheSwgLTEsIHVjc3RhcnQsIHVjZW5kLCB1c2VycywgdGl0bGUsIHNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydExpc3QsIGVuZExpc3QsIHRpbWVzdGFtcCwgZWRpdHRva2VuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluYWN0aXZlTGltaXQsIGluYWN0aXZlSW50cm8sIHN1bW1hcnksIGNhbGxOZXh0LCBwYWdlaWQpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIEBXTS5Mb2cubG9nRXJyb3IoXCJDYW5ub3QgZmluZCB0aGUgbmVlZGVkIG1hcmtzXCIpXG5cbiAgICBpdGVyYXRlVXNlcnM6ICh1c2Vyc0FycmF5LCBpbmRleCwgdWNzdGFydCwgdWNlbmQsIHVzZXJzLFxuICAgICAgICAgICAgICAgICAgICB0aXRsZSwgc291cmNlLCBzdGFydExpc3QsIGVuZExpc3QsIHRpbWVzdGFtcCwgZWRpdHRva2VuLFxuICAgICAgICAgICAgICAgICAgICBpbmFjdGl2ZUxpbWl0LCBpbmFjdGl2ZUludHJvLCBzdW1tYXJ5LCBjYWxsTmV4dCwgcGFnZWlkKSA9PlxuICAgICAgICBpbmRleCsrXG5cbiAgICAgICAgaWYgaW5kZXggPCB1c2Vyc0FycmF5Lmxlbmd0aFxuICAgICAgICAgICAgdXNlclN0cmluZyA9IHVzZXJzQXJyYXlbaW5kZXhdXG4gICAgICAgICAgICBtYXRjaCA9IHJlZ0V4cC5leGVjKHVzZXJTdHJpbmcpXG5cbiAgICAgICAgICAgIGlmIG1hdGNoXG4gICAgICAgICAgICAgICAgdWN1c2VyID0gbWF0Y2hbMV0uY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBtYXRjaFsxXS5zdWJzdHIoMSlcblxuICAgICAgICAgICAgICAgIGlmIG1hdGNoWzJdXG4gICAgICAgICAgICAgICAgICAgIHVjdXNlciArPSBcInxcIiArIG1hdGNoWzJdLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoWzJdLnN1YnN0cigxKVxuXG4gICAgICAgICAgICAgICAgQFdNLkxvZy5sb2dJbmZvKFwiUXVlcnlpbmcgXCIgKyB1Y3VzZXIgKyBcIiAuLi5cIilcblxuICAgICAgICAgICAgICAgIEBXTS5NVy5nZXRVc2VyQ29udHJpYnModWN1c2VyLCB1Y3N0YXJ0LCB1Y2VuZCxcbiAgICAgICAgICAgICAgICAgICAgQHN0b3JlVXNlckNvbnRyaWJzLFxuICAgICAgICAgICAgICAgICAgICBbdXNlcnNBcnJheSwgaW5kZXgsIHVjc3RhcnQsIHVjZW5kLCB1c2VycywgdGl0bGUsIHNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgIHN0YXJ0TGlzdCwgZW5kTGlzdCwgdGltZXN0YW1wLCBlZGl0dG9rZW4sIGluYWN0aXZlTGltaXQsXG4gICAgICAgICAgICAgICAgICAgICBpbmFjdGl2ZUludHJvLCBzdW1tYXJ5LCBjYWxsTmV4dCwgcGFnZWlkXSlcblxuICAgICAgICAgICAgZWxzZSBpZiB1c2VyU3RyaW5nICE9IFwiXCIgYW5kXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VyU3RyaW5nLmluZGV4T2YoaW5hY3RpdmVJbnRybykgIT0gMFxuICAgICAgICAgICAgICAgIEBXTS5Mb2cubG9nRXJyb3IoXCJBbiBlbnRyeSBpbiB0aGUgbGlzdCBtYXkgbm90IGJlIGNvcnJlY3RseSBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJmb3JtYXR0ZWRcIilcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBAaXRlcmF0ZVVzZXJzKHVzZXJzQXJyYXksIGluZGV4LCB1Y3N0YXJ0LCB1Y2VuZCwgdXNlcnMsIHRpdGxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZSwgc3RhcnRMaXN0LCBlbmRMaXN0LCB0aW1lc3RhbXAsIGVkaXR0b2tlbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmFjdGl2ZUxpbWl0LCBpbmFjdGl2ZUludHJvLCBzdW1tYXJ5LCBjYWxsTmV4dCwgcGFnZWlkKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICBAdXBkYXRlTGlzdCh1c2VycywgdGl0bGUsIHNvdXJjZSwgc3RhcnRMaXN0LCBlbmRMaXN0LCB0aW1lc3RhbXAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVkaXR0b2tlbiwgaW5hY3RpdmVJbnRybywgc3VtbWFyeSwgY2FsbE5leHQsIHBhZ2VpZClcblxuICAgIHN0b3JlVXNlckNvbnRyaWJzOiAocmVzdWx0cywgYXJncykgPT5cbiAgICAgICAgdXNlcnNBcnJheSA9IGFyZ3NbMF1cbiAgICAgICAgaW5kZXggPSBhcmdzWzFdXG4gICAgICAgIHVjc3RhcnQgPSBhcmdzWzJdXG4gICAgICAgIHVjZW5kID0gYXJnc1szXVxuICAgICAgICB1c2VycyA9IGFyZ3NbNF1cbiAgICAgICAgdGl0bGUgPSBhcmdzWzVdXG4gICAgICAgIHNvdXJjZSA9IGFyZ3NbNl1cbiAgICAgICAgc3RhcnRMaXN0ID0gYXJnc1s3XVxuICAgICAgICBlbmRMaXN0ID0gYXJnc1s4XVxuICAgICAgICB0aW1lc3RhbXAgPSBhcmdzWzldXG4gICAgICAgIGVkaXR0b2tlbiA9IGFyZ3NbMTBdXG4gICAgICAgIGluYWN0aXZlTGltaXQgPSBhcmdzWzExXVxuICAgICAgICBpbmFjdGl2ZUludHJvID0gYXJnc1sxMl1cbiAgICAgICAgc3VtbWFyeSA9IGFyZ3NbMTNdXG4gICAgICAgIGNhbGxOZXh0ID0gYXJnc1sxNF1cbiAgICAgICAgcGFnZWlkID0gYXJnc1sxNV1cblxuICAgICAgICBlZGl0cyA9IHJlc3VsdHMubGVuZ3RoXG5cbiAgICAgICAgaWYgZWRpdHMgPCBpbmFjdGl2ZUxpbWl0XG4gICAgICAgICAgICB1c2Vycy5pbmFjdGl2ZS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwidGV4dFwiOiB1c2Vyc0FycmF5W2luZGV4XVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJlZGl0c1wiOiBlZGl0c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICB1c2Vycy5hY3RpdmUucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInRleHRcIjogdXNlcnNBcnJheVtpbmRleF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZWRpdHNcIjogZWRpdHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgQGl0ZXJhdGVVc2Vycyh1c2Vyc0FycmF5LCBpbmRleCwgdWNzdGFydCwgdWNlbmQsIHVzZXJzLCB0aXRsZSwgc291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0TGlzdCwgZW5kTGlzdCwgdGltZXN0YW1wLCBlZGl0dG9rZW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5hY3RpdmVMaW1pdCwgaW5hY3RpdmVJbnRybywgc3VtbWFyeSwgY2FsbE5leHQsIHBhZ2VpZClcblxuICAgIHVwZGF0ZUxpc3Q6ICh1c2VycywgdGl0bGUsIHNvdXJjZSwgc3RhcnRMaXN0LCBlbmRMaXN0LFxuICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXAsIGVkaXR0b2tlbiwgaW5hY3RpdmVJbnRybywgc3VtbWFyeSwgY2FsbE5leHQsIHBhZ2VpZCkgPT5cbiAgICAgICAgc29ydGVyID0gKGEsIGIpIC0+XG4gICAgICAgICAgICAjIFVzZXJzIG11c3QgYmUgc29ydGVkIGluIGRlc2NlbmRpbmcgb3JkZXJcbiAgICAgICAgICAgIGlmIGEuZWRpdHMgPCBiLmVkaXRzXG4gICAgICAgICAgICAgICAgcmV0dXJuIDFcbiAgICAgICAgICAgIGVsc2UgaWYgYS5lZGl0cyA+IGIuZWRpdHNcbiAgICAgICAgICAgICAgICByZXR1cm4gLTFcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXR1cm4gMFxuXG4gICAgICAgIHVzZXJzLmFjdGl2ZS5zb3J0KHNvcnRlcilcbiAgICAgICAgdXNlcnMuaW5hY3RpdmUuc29ydChzb3J0ZXIpXG5cbiAgICAgICAgbmV3TGlzdCA9IFwiXFxuXCJcblxuICAgICAgICBmb3IgdXNlciBpbiB1c2Vycy5hY3RpdmVcbiAgICAgICAgICAgIG5ld0xpc3QgKz0gdXNlci50ZXh0ICsgXCJcXG5cIlxuXG4gICAgICAgIGlmIHVzZXJzLmluYWN0aXZlLmxlbmd0aCA+IDBcbiAgICAgICAgICAgIG5ld0xpc3QgKz0gXCJcXG5cIiArIGluYWN0aXZlSW50cm8gKyBcIlxcblxcblwiXG5cbiAgICAgICAgICAgIGZvciB1c2VyIGluIHVzZXJzLmluYWN0aXZlXG4gICAgICAgICAgICAgICAgbmV3TGlzdCArPSB1c2VyLnRleHQgKyBcIlxcblwiXG5cbiAgICAgICAgbmV3VGV4dCA9IHNvdXJjZS5zdWJzdHJpbmcoMCwgc3RhcnRMaXN0KSArIG5ld0xpc3QgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZS5zdWJzdHJpbmcoZW5kTGlzdClcblxuICAgICAgICBpZiBuZXdUZXh0ICE9IHNvdXJjZVxuICAgICAgICAgICAgQFdNLk1XLmNhbGxBUElQb3N0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXCJlZGl0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvdDogXCIxXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbm9yOiBcIjFcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IHRpdGxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdW1tYXJ5OiBzdW1tYXJ5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBuZXdUZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiMWFzZXRpbWVzdGFtcDogdGltZXN0YW1wXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbjogZWRpdHRva2VuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBAd3JpdGVQYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFt0aXRsZSwgY2FsbE5leHQsIHBhZ2VpZF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVsbClcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgQFdNLkxvZy5sb2dJbmZvKEBXTS5Mb2cubGlua1RvV2lraVBhZ2UodGl0bGUsIHRpdGxlKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiIHdhcyBhbHJlYWR5IHVwIHRvIGRhdGVcIilcbiAgICAgICAgICAgIEBpdGVyYXRlUGFnZXMocGFnZWlkLCBjYWxsTmV4dClcblxuICAgIHdyaXRlUGFnZTogKHJlcywgYXJncykgPT5cbiAgICAgICAgdGl0bGUgPSBhcmdzWzBdXG4gICAgICAgIGNhbGxOZXh0ID0gYXJnc1sxXVxuICAgICAgICBwYWdlaWQgPSBhcmdzWzJdXG5cbiAgICAgICAgaWYgcmVzLmVkaXQgYW5kIHJlcy5lZGl0LnJlc3VsdCA9PSAnU3VjY2VzcydcbiAgICAgICAgICAgIEBXTS5Mb2cubG9nSW5mbyhAV00uTG9nLmxpbmtUb1dpa2lQYWdlKHRpdGxlLCB0aXRsZSkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiIHdhcyBjb3JyZWN0bHkgdXBkYXRlZFwiKVxuICAgICAgICAgICAgQGl0ZXJhdGVQYWdlcyhwYWdlaWQsIGNhbGxOZXh0KVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICBAV00uTG9nLmxvZ0Vycm9yKHJlc1snZXJyb3InXVsnaW5mbyddICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgKFwiICsgcmVzWydlcnJvciddWydjb2RlJ10gKyBcIilcIilcbiIsIiMgV2lraSBNb25rZXkgLSBNZWRpYVdpa2kgYm90IGFuZCBlZGl0b3ItYXNzaXN0YW50IHVzZXIgc2NyaXB0XG4jIENvcHlyaWdodCAoQykgMjAxMSBEYXJpbyBHaW92YW5uZXR0aSA8ZGV2QGRhcmlvZ2lvdmFubmV0dGkubmV0PlxuI1xuIyBUaGlzIGZpbGUgaXMgcGFydCBvZiBXaWtpIE1vbmtleS5cbiNcbiMgV2lraSBNb25rZXkgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuIyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuIyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuIyAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuI1xuIyBXaWtpIE1vbmtleSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuIyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuIyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4jIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4jXG4jIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4jIGFsb25nIHdpdGggV2lraSBNb25rZXkuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG5cbntQbHVnaW59ID0gcmVxdWlyZSgnLi9fUGx1Z2luJylcblxuXG5jbGFzcyBtb2R1bGUuZXhwb3J0cy5BcmNoV2lraVdhbnRlZENhdGVnb3JpZXMgZXh0ZW5kcyBQbHVnaW5cbiAgICBAY29uZl9kZWZhdWx0OlxuICAgICAgICBlbmFibGVkOiBmYWxzZVxuICAgICAgICBib3RfbGFiZWw6IFwiQ3JlYXRlIHdhbnRlZCBjYXRlZ29yaWVzXCJcblxuICAgIG1haW5fYm90OiAodGl0bGUsIGNhbGxCb3QsIGNoYWluQXJncykgLT5cbiAgICAgICAgdGl0bGUgPSB0aXRsZS5yZXBsYWNlKFwiIChwYWdlIGRvZXMgbm90IGV4aXN0KVwiLCBcIlwiKVxuXG4gICAgICAgIEBXTS5NVy5jYWxsUXVlcnkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3A6IFwiaW5mb1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludG9rZW46IFwiZWRpdFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlczogdGl0bGVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBAbWFpbkF1dG9Xcml0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFt0aXRsZSwgY2FsbEJvdF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBudWxsKVxuXG4gICAgbWFpbkF1dG9Xcml0ZTogKHBhZ2UsIGFyZ3MpIC0+XG4gICAgICAgIHRpdGxlID0gYXJnc1swXVxuICAgICAgICBjYWxsQm90ID0gYXJnc1sxXVxuXG4gICAgICAgIGVkaXR0b2tlbiA9IHBhZ2UuZWRpdHRva2VuXG5cbiAgICAgICAgbGFuZ3VhZ2UgPSBAV00uQXJjaFdpa2kuZGV0ZWN0TGFuZ3VhZ2UodGl0bGUpWzFdXG5cbiAgICAgICAgaWYgbGFuZ3VhZ2UgIT0gQFdNLkFyY2hXaWtpLmdldExvY2FsTGFuZ3VhZ2UoKVxuICAgICAgICAgICAgdGV4dCA9IFwiW1tDYXRlZ29yeTpcIiArIGxhbmd1YWdlICsgXCJdXVwiXG4gICAgICAgICAgICBzdW1tYXJ5ID0gXCJ3YW50ZWQgY2F0ZWdvcnlcIlxuXG4gICAgICAgICAgICBAV00uTVcuY2FsbEFQSVBvc3Qoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwiZWRpdFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3Q6IFwiMVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogdGl0bGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1bW1hcnk6IHN1bW1hcnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IHRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNyZWF0ZW9ubHk6IFwiMVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbjogZWRpdHRva2VuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBAbWFpbkF1dG9FbmQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbEJvdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudWxsKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICBjYWxsQm90KDAsIG51bGwpXG5cbiAgICBtYWluQXV0b0VuZDogKHJlcywgY2FsbEJvdCkgLT5cbiAgICAgICAgaWYgcmVzLmVkaXQgYW5kIHJlcy5lZGl0LnJlc3VsdCA9PSAnU3VjY2VzcydcbiAgICAgICAgICAgIGNhbGxCb3QoMSwgbnVsbClcbiAgICAgICAgZWxzZSBpZiByZXMuZXJyb3JcbiAgICAgICAgICAgIEBXTS5Mb2cubG9nRXJyb3IocmVzLmVycm9yLmluZm8gKyBcIiAoXCIgKyByZXMuZXJyb3IuY29kZSArIFwiKVwiKVxuICAgICAgICAgICAgY2FsbEJvdChyZXMuZXJyb3IuY29kZSwgbnVsbClcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgY2FsbEJvdChmYWxzZSwgbnVsbClcbiIsIiMgV2lraSBNb25rZXkgLSBNZWRpYVdpa2kgYm90IGFuZCBlZGl0b3ItYXNzaXN0YW50IHVzZXIgc2NyaXB0XG4jIENvcHlyaWdodCAoQykgMjAxMSBEYXJpbyBHaW92YW5uZXR0aSA8ZGV2QGRhcmlvZ2lvdmFubmV0dGkubmV0PlxuI1xuIyBUaGlzIGZpbGUgaXMgcGFydCBvZiBXaWtpIE1vbmtleS5cbiNcbiMgV2lraSBNb25rZXkgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuIyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuIyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuIyAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuI1xuIyBXaWtpIE1vbmtleSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuIyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuIyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4jIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4jXG4jIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4jIGFsb25nIHdpdGggV2lraSBNb25rZXkuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG5cbntQbHVnaW59ID0gcmVxdWlyZSgnLi9fUGx1Z2luJylcblxuXG5jbGFzcyBtb2R1bGUuZXhwb3J0cy5EZWxldGVQYWdlcyBleHRlbmRzIFBsdWdpblxuICAgIEBjb25mX2RlZmF1bHQ6XG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlXG4gICAgICAgIGJvdF9sYWJlbDogXCJEZWxldGUgcGFnZXNcIlxuICAgICAgICBlZGl0X3N1bW1hcnk6IFwiZGVsZXRlIHBhZ2VcIlxuXG4gICAgbWFpbl9ib3Q6ICh0aXRsZSwgY2FsbEJvdCwgY2hhaW5BcmdzKSAtPlxuICAgICAgICBzdW1tYXJ5ID0gQGNvbmYuZWRpdF9zdW1tYXJ5XG5cbiAgICAgICAgQFdNLk1XLmNhbGxRdWVyeSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcDogJ2luZm8nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50b2tlbjogJ2RlbGV0ZSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZXM6IHRpdGxlXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgQG1haW5BdXRvV3JpdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBbdGl0bGUsIHN1bW1hcnksIGNhbGxCb3RdLFxuICAgICAgICAgICAgICAgICAgICAgICAgbnVsbClcblxuICAgIG1haW5BdXRvV3JpdGU6IChwYWdlLCBhcmdzKSAtPlxuICAgICAgICB0aXRsZSA9IGFyZ3NbMF1cbiAgICAgICAgc3VtbWFyeSA9IGFyZ3NbMV1cbiAgICAgICAgY2FsbEJvdCA9IGFyZ3NbMl1cblxuICAgICAgICBkZWxldGV0b2tlbiA9IHBhZ2UuZGVsZXRldG9rZW5cblxuICAgICAgICBAV00uTVcuY2FsbEFQSVBvc3Qoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogJ2RlbGV0ZSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3Q6ICcxJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiB0aXRsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuOiBkZWxldGV0b2tlblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYXNvbjogc3VtbWFyeVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIEBtYWluQXV0b0VuZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIFt0aXRsZSwgY2FsbEJvdF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBudWxsKVxuXG4gICAgbWFpbkF1dG9FbmQ6IChyZXMsIGFyZ3MpIC0+XG4gICAgICAgIHRpdGxlID0gYXJnc1swXVxuICAgICAgICBjYWxsQm90ID0gYXJnc1sxXVxuXG4gICAgICAgIGlmIG5vdCByZXMuZGVsZXRlXG4gICAgICAgICAgICBpZiByZXMuZXJyb3JcbiAgICAgICAgICAgICAgICBAV00uTG9nLmxvZ0Vycm9yKFwiI3tAV00uTG9nLmxpbmtUb1dpa2lQYWdlKHRpdGxlLCB0aXRsZSl9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhcyBub3QgYmVlbiBkZWxldGVkIVxcbiN7cmVzLmVycm9yLmluZm99XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgje3Jlcy5lcnJvci5jb2RlfSlcIilcbiAgICAgICAgICAgICAgICBjYWxsQm90KHJlcy5lcnJvci5jb2RlLCBudWxsKVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGNhbGxCb3QoZmFsc2UsIG51bGwpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGNhbGxCb3QoMSwgbnVsbClcbiIsIiMgV2lraSBNb25rZXkgLSBNZWRpYVdpa2kgYm90IGFuZCBlZGl0b3ItYXNzaXN0YW50IHVzZXIgc2NyaXB0XG4jIENvcHlyaWdodCAoQykgMjAxMSBEYXJpbyBHaW92YW5uZXR0aSA8ZGV2QGRhcmlvZ2lvdmFubmV0dGkubmV0PlxuI1xuIyBUaGlzIGZpbGUgaXMgcGFydCBvZiBXaWtpIE1vbmtleS5cbiNcbiMgV2lraSBNb25rZXkgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuIyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuIyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuIyAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuI1xuIyBXaWtpIE1vbmtleSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuIyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuIyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4jIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4jXG4jIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4jIGFsb25nIHdpdGggV2lraSBNb25rZXkuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG5cbntQbHVnaW59ID0gcmVxdWlyZSgnLi9fUGx1Z2luJylcblxuXG5jbGFzcyBtb2R1bGUuZXhwb3J0cy5FeHBhbmRDb250cmFjdGlvbnMgZXh0ZW5kcyBQbHVnaW5cbiAgICBAY29uZl9kZWZhdWx0OlxuICAgICAgICBlbmFibGVkOiB0cnVlXG4gICAgICAgIGVkaXRvcl9tZW51OiBbXCJUZXh0IHBsdWdpbnNcIiwgXCJFeHBhbmQgY29udHJhY3Rpb25zXCJdXG5cbiAgICByZXBsYWNlOiAoc291cmNlLCByZWdFeHAsIG5ld1N0cmluZywgY2hlY2tTdHJpbmcsIGNoZWNrU3RyaW5ncykgLT5cbiAgICAgICAgbmV3dGV4dCA9IHNvdXJjZS5yZXBsYWNlKHJlZ0V4cCwgbmV3U3RyaW5nKVxuICAgICAgICBpZiBjaGVja1N0cmluZ3MubGVuZ3RoID4gMSBhbmQgbmV3dGV4dCAhPSBzb3VyY2VcbiAgICAgICAgICAgIEBXTS5Mb2cubG9nV2FybmluZyhcIlJlcGxhY2VkIHNvbWUgXFxcIiN7Y2hlY2tTdHJpbmd9XFxcIiB3aXRoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxcIiN7Y2hlY2tTdHJpbmdzWzBdfVxcXCI6IGNoZWNrIHRoYXQgaXQgZGlkbid0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVhbiBcXFwiI3tjaGVja1N0cmluZ3Muc2xpY2UoMSkuam9pbignXFxcIiBvciBcXFwiJyl9XFxcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc3RlYWRcIilcbiAgICAgICAgcmV0dXJuIG5ld3RleHRcblxuICAgIG1haW5fZWRpdG9yOiAoY2FsbE5leHQpIC0+XG4gICAgICAgIHNvdXJjZSA9IEBXTS5FZGl0b3IucmVhZFNvdXJjZSgpXG4gICAgICAgIG5ld3RleHQgPSBzb3VyY2VcblxuICAgICAgICAjIElnbm9yaW5nIFwiSVwiIHNpbmNlIHdyaXRpbmcgaW4gMXN0IHBlcnNvbiBpc24ndCBmb3JtYWwgYW55d2F5XG4gICAgICAgICMgTm90ZSB0aGF0IEphdmFTY3JpcHQgZG9lc24ndCBzdXBwb3J0IGxvb2sgYmVoaW5kIDooXG4gICAgICAgICMgUGF5IGF0dGVudGlvbiB0byBwcmVzZXJ2ZSB0aGUgb3JpZ2luYWwgY2FwaXRhbGl6YXRpb25cblxuICAgICAgICBuZXd0ZXh0ID0gQHJlcGxhY2UobmV3dGV4dCwgLyhbYS16XSkncmUvaWcsICckMSBhcmUnLCBcIidyZVwiLCBbXCJhcmVcIl0pXG4gICAgICAgIG5ld3RleHQgPSBAcmVwbGFjZShuZXd0ZXh0LCAvKFthLXpdKSd2ZS9pZywgJyQxIGhhdmUnLCBcIid2ZVwiLCBbXCJoYXZlXCJdKVxuICAgICAgICBuZXd0ZXh0ID0gQHJlcGxhY2UobmV3dGV4dCwgLyhbYS16XSknbGwvaWcsICckMSB3aWxsJywgXCInbGxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcIndpbGxcIiwgXCJzaGFsbFwiXSlcbiAgICAgICAgbmV3dGV4dCA9IEByZXBsYWNlKG5ld3RleHQsIC8oW2Etel0pJ2QvaWcsICckMSB3b3VsZCcsIFwiJ2RcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcIndvdWxkXCIsIFwiaGFkXCJdKVxuICAgICAgICBuZXd0ZXh0ID0gQHJlcGxhY2UobmV3dGV4dCwgLyhjKWFuJ3QvaWcsICckMWFubm90JywgXCJjYW4ndFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcImNhbm5vdFwiXSlcbiAgICAgICAgbmV3dGV4dCA9IEByZXBsYWNlKG5ld3RleHQsIC8odylvbid0L2lnLCAnJDFpbGwgbm90JywgXCJ3b24ndFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcIndpbGwgbm90XCJdKVxuICAgICAgICBuZXd0ZXh0ID0gQHJlcGxhY2UobmV3dGV4dCwgLyhbYS16XSluJ3QvaWcsICckMSBub3QnLCBcIm4ndFwiLCBbXCJub3RcIl0pXG4gICAgICAgIG5ld3RleHQgPSBAcmVwbGFjZShuZXd0ZXh0LCAvKGhlcmV8dGhlcmUpJ3MvaWcsICckMSBpcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJoZXJlL3RoZXJlJ3NcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJoZXJlL3RoZXJlIGlzXCIsIFwiaGVyZS90aGVyZSBoYXNcIl0pXG4gICAgICAgIG5ld3RleHQgPSBAcmVwbGFjZShuZXd0ZXh0LCAvKGcpb25uYS9pZywgJyQxb2luZyB0bycsIFwiZ29ubmFcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJnb2luZyB0b1wiXSlcbiAgICAgICAgIyBSZXBsYWNpbmcgaGUncywgc2hlJ3MsIHRoYXQncywgd2hhdCdzLCB3aGVyZSdzLCB3aG8ncyAuLi4gbWF5IGJlIHRvb1xuICAgICAgICAjICAgZGFuZ2Vyb3VzXG4gICAgICAgIG5ld3RleHQgPSBAcmVwbGFjZShuZXd0ZXh0LCAvKFthLXpdKSdzIChiZWVuKS9pZywgJyQxIGhhcyAkMicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIncyBiZWVuXCIsIFtcImhhcyBiZWVuXCJdKVxuICAgICAgICBuZXd0ZXh0ID0gQHJlcGxhY2UobmV3dGV4dCwgLyhsZXQpJ3MvaWcsICckMSB1cycsIFwibGV0J3NcIiwgW1wibGV0IHVzXCJdKVxuICAgICAgICBuZXd0ZXh0ID0gQHJlcGxhY2UobmV3dGV4dCwgLyhpdCknKHMgb3duKS9pZywgJyQxJDInLCBcIml0J3Mgb3duXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wiaXRzIG93blwiXSlcblxuICAgICAgICBzcyA9IG5ld3RleHQubWF0Y2goL1thLXpdJ3MvZ2kpXG4gICAgICAgIGlmIHNzXG4gICAgICAgICAgICBAV00uTG9nLmxvZ1dhcm5pbmcoXCJGb3VuZCBcIiArIHNzLmxlbmd0aCArIFwiIGluc3RhbmNlcyBvZiBcXFwiJ3NcXFwiOiBcIiArXG4gICAgICAgICAgICAgICAgICAgIFwiY2hlY2sgaWYgdGhleSBjYW4gYmUgcmVwbGFjZWQgd2l0aCBcXFwiaXNcXFwiLCBcXFwiaGFzXFxcIiwgLi4uXCIpXG5cbiAgICAgICAgaWYgbmV3dGV4dCAhPSBzb3VyY2VcbiAgICAgICAgICAgIEBXTS5FZGl0b3Iud3JpdGVTb3VyY2UobmV3dGV4dClcbiAgICAgICAgICAgIEBXTS5Mb2cubG9nSW5mbyhcIkV4cGFuZGVkIGNvbnRyYWN0aW9uc1wiKVxuXG4gICAgICAgIGlmIGNhbGxOZXh0XG4gICAgICAgICAgICBjYWxsTmV4dCgpXG4iLCIjIFdpa2kgTW9ua2V5IC0gTWVkaWFXaWtpIGJvdCBhbmQgZWRpdG9yLWFzc2lzdGFudCB1c2VyIHNjcmlwdFxuIyBDb3B5cmlnaHQgKEMpIDIwMTEgRGFyaW8gR2lvdmFubmV0dGkgPGRldkBkYXJpb2dpb3Zhbm5ldHRpLm5ldD5cbiNcbiMgVGhpcyBmaWxlIGlzIHBhcnQgb2YgV2lraSBNb25rZXkuXG4jXG4jIFdpa2kgTW9ua2V5IGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiMgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiMgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiMgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbiNcbiMgV2lraSBNb25rZXkgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiMgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiMgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuIyBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuI1xuIyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuIyBhbG9uZyB3aXRoIFdpa2kgTW9ua2V5LiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuXG57UGx1Z2lufSA9IHJlcXVpcmUoJy4vX1BsdWdpbicpXG5cbkNTUyA9IHJlcXVpcmUoJ0BreW5pa29zL21pc2MvZGlzdC9DU1MnKVxuXG5cbmNsYXNzIG1vZHVsZS5leHBvcnRzLkZpeEJhY2tsaW5rRnJhZ21lbnRzIGV4dGVuZHMgUGx1Z2luXG4gICAgQGNvbmZfZGVmYXVsdDpcbiAgICAgICAgZW5hYmxlZDogdHJ1ZVxuICAgICAgICBib3RfbGFiZWw6IFwiRml4IGxpbmtzIHRvIHNwZWNpZmljIHNlY3Rpb25zIG9mIGEgdGFyZ2V0IHBhZ2VcIlxuICAgICAgICBlZGl0X3N1bW1hcnk6IFwiZml4IGxpbmtzIHRvIHNwZWNpZmljIHNlY3Rpb25zXCJcblxuICAgIG1ha2VCb3RVSTogPT5cbiAgICAgICAgQ1NTLmFkZFN0eWxlRWxlbWVudChcIiNXaWtpTW9ua2V5LUZpeEJhY2tsaW5rRnJhZ21lbnRzIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJpbnB1dFt0eXBlPSd0ZXh0J10ge21hcmdpbi1sZWZ0OjAuMzNlbTt9XCIpXG5cbiAgICAgICAgZGl2TWFpbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgICAgIGRpdk1haW4uaWQgPSBcIldpa2lNb25rZXktRml4QmFja2xpbmtGcmFnbWVudHNcIlxuXG4gICAgICAgIGxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpXG4gICAgICAgIGxhYmVsLmlubmVySFRNTCA9ICdUYXJnZXQgcGFnZTonXG4gICAgICAgIGRpdk1haW4uYXBwZW5kQ2hpbGQobGFiZWwpXG5cbiAgICAgICAgdGFyZ2V0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKVxuICAgICAgICB0YXJnZXQuc2V0QXR0cmlidXRlKCd0eXBlJywgJ3RleHQnKVxuICAgICAgICB0YXJnZXQuaWQgPSBcIldpa2lNb25rZXktRml4QmFja2xpbmtGcmFnbWVudHMtVGFyZ2V0XCJcblxuICAgICAgICBpZiBAV00uV2hhdExpbmtzSGVyZS5pc1doYXRMaW5rc0hlcmVQYWdlKClcbiAgICAgICAgICAgIHRhcmdldC52YWx1ZSA9IEBXTS5XaGF0TGlua3NIZXJlLmdldFRpdGxlKClcblxuICAgICAgICBkaXZNYWluLmFwcGVuZENoaWxkKHRhcmdldClcblxuICAgICAgICByZXR1cm4gZGl2TWFpblxuXG4gICAgcmVhZFRhcmdldCA9IC0+XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIldpa2lNb25rZXktRml4QmFja2xpbmtGcmFnbWVudHMtVGFyZ2V0XCIpLnZhbHVlXG5cbiAgICBmaXhMaW5rczogKHNvdXJjZSwgdGFyZ2V0LCBzZWN0aW9ucykgPT5cbiAgICAgICAgIyBOb3RlIHRoYXQgaXQncyBpbXBvc3NpYmxlIHRvIHJlY29nbml6ZSBhbnkgbmFtZXNwYWNlcyBpbiB0aGUgdGl0bGVcbiAgICAgICAgIyAgIHdpdGhvdXQgcXVlcnlpbmcgdGhlIHNlcnZlclxuICAgICAgICAjIEFsdGVybmF0aXZlbHksIGEgbGlzdCBvZiB0aGUga25vd24gbmFtZXNwYWNlcyBjb3VsZCBiZSBtYWludGFpbmVkXG4gICAgICAgICMgICBmb3IgZWFjaCB3aWtpXG4gICAgICAgICMgUmVjb2duaXppbmcgbmFtZXNwYWNlcyB3b3VsZCBsZXQgcmVjb2duaXplIG1vcmUgbGliZXJhbCBsaW5rXG4gICAgICAgICMgICBzeW50YXhlcyAoZS5nLiBzcGFjZXMgYXJvdW5kIHRoZSBjb2xvbilcbiAgICAgICAgbGlua3MgPSBAV00uUGFyc2VyLmZpbmRJbnRlcm5hbExpbmtzKHNvdXJjZSwgbnVsbCwgdGFyZ2V0KVxuXG4gICAgICAgIG5ld1RleHQgPSBcIlwiXG4gICAgICAgIHByZXZJZCA9IDBcblxuICAgICAgICBmb3IgbGluayBpbiBsaW5rc1xuICAgICAgICAgICAgbmV3VGV4dCArPSBzb3VyY2Uuc3Vic3RyaW5nKHByZXZJZCwgbGluay5pbmRleClcbiAgICAgICAgICAgIG5ld2xpbmsgPSBsaW5rLnJhd0xpbmtcblxuICAgICAgICAgICAgcmF3ZnJhZ21lbnQgPSBsaW5rLmZyYWdtZW50XG5cbiAgICAgICAgICAgIGlmIHJhd2ZyYWdtZW50XG4gICAgICAgICAgICAgICAgZml4ZWRGcmFnbWVudCA9IEBmaXhGcmFnbWVudChyYXdmcmFnbWVudCwgc2VjdGlvbnMpXG5cbiAgICAgICAgICAgICAgICBpZiBmaXhlZEZyYWdtZW50IGlzIHRydWVcbiAgICAgICAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgICAgIGVsc2UgaWYgZml4ZWRGcmFnbWVudFxuICAgICAgICAgICAgICAgICAgICBvbGRsaW5rID0gbmV3bGlua1xuICAgICAgICAgICAgICAgICAgICBuZXdsaW5rID0gXCJbW1wiICsgdGFyZ2V0ICsgXCIjXCIgKyBmaXhlZEZyYWdtZW50ICtcbiAgICAgICAgICAgICAgICAgICAgICAgIChpZiBsaW5rLmFuY2hvciB0aGVuIFwifFwiICsgbGluay5hbmNob3IgZWxzZSBcIlwiKSArIFwiXV1cIlxuICAgICAgICAgICAgICAgICAgICBAV00uTG9nLmxvZ0luZm8oXCJGaXhlZCBicm9rZW4gbGluayBmcmFnbWVudDogXCIgKyBvbGRsaW5rICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiIC0+IFwiICsgQFdNLkxvZy5saW5rVG9XaWtpUGFnZShsaW5rLmxpbmssIG5ld2xpbmspKVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgQFdNLkxvZy5sb2dXYXJuaW5nKFwiQ2Fubm90IGZpeCBicm9rZW4gbGluayBmcmFnbWVudDogXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQFdNLkxvZy5saW5rVG9XaWtpUGFnZShsaW5rLmxpbmssIG5ld2xpbmspKVxuXG4gICAgICAgICAgICBuZXdUZXh0ICs9IG5ld2xpbmtcbiAgICAgICAgICAgIHByZXZJZCA9IGxpbmsuaW5kZXggKyBsaW5rLmxlbmd0aFxuXG4gICAgICAgIG5ld1RleHQgKz0gc291cmNlLnN1YnN0cihwcmV2SWQpXG5cbiAgICAgICAgIyBXaXRob3V0IHRoaXMgY2hlY2sgdGhpcyBwbHVnaW4gd291bGQgYmUgc3BlY2lmaWMgdG8gQXJjaFdpa2lcbiAgICAgICAgaWYgbG9jYXRpb24uaG9zdG5hbWUgPT0gJ3dpa2kuYXJjaGxpbnV4Lm9yZydcbiAgICAgICAgICAgIG5ld1RleHQgPSBAZml4QXJjaFdpa2lMaW5rcyhuZXdUZXh0LCB0YXJnZXQsIHNlY3Rpb25zKVxuXG4gICAgICAgIHJldHVybiBuZXdUZXh0XG5cbiAgICBmaXhBcmNoV2lraUxpbmtzOiAoc291cmNlLCB0YXJnZXQsIHNlY3Rpb25zKSA9PlxuICAgICAgICBsaW5rcyA9IEBXTS5QYXJzZXIuZmluZFRlbXBsYXRlcyhzb3VyY2UsICdSZWxhdGVkJylcblxuICAgICAgICBuZXdUZXh0MSA9IFwiXCJcbiAgICAgICAgcHJldklkID0gMFxuXG4gICAgICAgIGZvciBsaW5rIGluIGxpbmtzXG4gICAgICAgICAgICBuZXdUZXh0MSArPSBzb3VyY2Uuc3Vic3RyaW5nKHByZXZJZCwgbGluay5pbmRleClcbiAgICAgICAgICAgIG5ld1RleHQxICs9IEBmaXhBcmNoV2lraUxpbmsodGFyZ2V0LCBzZWN0aW9ucywgbGluaywgMSlcbiAgICAgICAgICAgIHByZXZJZCA9IGxpbmsuaW5kZXggKyBsaW5rLmxlbmd0aFxuXG4gICAgICAgIG5ld1RleHQxICs9IHNvdXJjZS5zdWJzdHIocHJldklkKVxuXG4gICAgICAgIGxpbmtzMiA9IEBXTS5QYXJzZXIuZmluZFRlbXBsYXRlcyhuZXdUZXh0MSwgJ1JlbGF0ZWQyJylcblxuICAgICAgICBuZXdUZXh0MiA9IFwiXCJcbiAgICAgICAgcHJldklkID0gMFxuXG4gICAgICAgIGZvciBsaW5rMiBpbiBsaW5rczJcbiAgICAgICAgICAgIG5ld1RleHQyICs9IG5ld1RleHQxLnN1YnN0cmluZyhwcmV2SWQsIGxpbmsyLmluZGV4KVxuICAgICAgICAgICAgbmV3VGV4dDIgKz0gQGZpeEFyY2hXaWtpTGluayh0YXJnZXQsIHNlY3Rpb25zLCBsaW5rMiwgMilcbiAgICAgICAgICAgIHByZXZJZCA9IGxpbmsyLmluZGV4ICsgbGluazIubGVuZ3RoXG5cbiAgICAgICAgbmV3VGV4dDIgKz0gbmV3VGV4dDEuc3Vic3RyKHByZXZJZClcblxuICAgICAgICByZXR1cm4gbmV3VGV4dDJcblxuICAgIGZpeEFyY2hXaWtpTGluazogKHRhcmdldCwgc2VjdGlvbnMsIHRlbXBsYXRlLCBleHBlY3RlZEFyZ3MpID0+XG4gICAgICAgIGFyZ3MgPSB0ZW1wbGF0ZS5hcmd1bWVudHNcblxuICAgICAgICAjIERvbid0IGNyYXNoIGluIGNhc2Ugb2YgbWFsZm9ybWVkIHRlbXBsYXRlc1xuICAgICAgICBpZiBhcmdzLmxlbmd0aCA9PSBleHBlY3RlZEFyZ3NcbiAgICAgICAgICAgIGxpbmsgPSBhcmdzWzBdLnZhbHVlXG4gICAgICAgICAgICBmcmFnSWQgPSBsaW5rLmluZGV4T2YoJyMnKVxuXG4gICAgICAgICAgICBpZiBmcmFnSWQgPiAtMVxuICAgICAgICAgICAgICAgIGx0aXRsZSA9IGxpbmsuc3Vic3RyaW5nKDAsIGZyYWdJZClcblxuICAgICAgICAgICAgICAgICMgTm90ZSB0aGF0IGl0J3MgaW1wb3NzaWJsZSB0byByZWNvZ25pemUgYW55IG5hbWVzcGFjZXMgaW4gdGhlXG4gICAgICAgICAgICAgICAgIyAgIHRpdGxlIHdpdGhvdXQgcXVlcnlpbmcgdGhlIHNlcnZlclxuICAgICAgICAgICAgICAgICMgQWx0ZXJuYXRpdmVseSwgYSBsaXN0IG9mIHRoZSBrbm93biBuYW1lc3BhY2VzIGNvdWxkIGJlXG4gICAgICAgICAgICAgICAgIyAgIG1haW50YWluZWQgZm9yIGVhY2ggd2lraVxuICAgICAgICAgICAgICAgICMgUmVjb2duaXppbmcgbmFtZXNwYWNlcyB3b3VsZCBsZXQgcmVjb2duaXplIG1vcmUgbGliZXJhbCBsaW5rXG4gICAgICAgICAgICAgICAgIyAgIHN5bnRheGVzIChlLmcuIHNwYWNlcyBhcm91bmQgdGhlIGNvbG9uKVxuICAgICAgICAgICAgICAgIGlmIEBXTS5QYXJzZXIuY29tcGFyZUFydGljbGVUaXRsZXMobHRpdGxlLCB0YXJnZXQpXG4gICAgICAgICAgICAgICAgICAgIHJhd2ZyYWdtZW50ID0gbGluay5zdWJzdHIoZnJhZ0lkICsgMSlcbiAgICAgICAgICAgICAgICAgICAgZml4ZWRGcmFnbWVudCA9IEBmaXhGcmFnbWVudChyYXdmcmFnbWVudCwgc2VjdGlvbnMpXG5cbiAgICAgICAgICAgICAgICAgICAgaWYgZml4ZWRGcmFnbWVudCBpcyB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgZml4ZWRGcmFnbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgYW5jaG9yID0gaWYgYXJnc1sxXSB0aGVuIChcInxcIiArIGFyZ3NbMV0udmFsdWUpIGVsc2UgXCJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3bGluayA9IFwie3tcIiArIHRlbXBsYXRlLnRpdGxlICsgXCJ8XCIgKyB0YXJnZXQgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiI1wiICsgZml4ZWRGcmFnbWVudCAgKyBhbmNob3IgKyBcIn19XCJcbiAgICAgICAgICAgICAgICAgICAgICAgIEBXTS5Mb2cubG9nSW5mbyhcIkZpeGVkIGJyb2tlbiBsaW5rIGZyYWdtZW50OiBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGUucmF3VHJhbnNjbHVzaW9uICsgXCIgLT4gXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEBXTS5Mb2cubGlua1RvV2lraVBhZ2UobGluaywgbmV3bGluaykpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3bGlua1xuXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIEBXTS5Mb2cubG9nV2FybmluZyhcIkNhbm5vdCBmaXggYnJva2VuIGxpbmsgZnJhZ21lbnQ6IFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBAV00uTG9nLmxpbmtUb1dpa2lQYWdlKGxpbmssXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGUucmF3VHJhbnNjbHVzaW9uKSlcblxuICAgICAgICBlbHNlXG4gICAgICAgICAgICBAV00uTG9nLmxvZ1dhcm5pbmcoXCJUZW1wbGF0ZTpcIiArIHRlbXBsYXRlLnRpdGxlICsgXCIgbXVzdCBoYXZlIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkQXJncyArIFwiIGFuZCBvbmx5IFwiICsgZXhwZWN0ZWRBcmdzICtcbiAgICAgICAgICAgICAgICAgICAgICAgIChpZiBleHBlY3RlZEFyZ3MgPiAxIHRoZW4gXCIgYXJndW1lbnRzOiBcIiBlbHNlIFwiIGFyZ3VtZW50OiBcIikgK1xuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGUucmF3VHJhbnNjbHVzaW9uKVxuXG4gICAgICAgIHJldHVybiB0ZW1wbGF0ZS5yYXdUcmFuc2NsdXNpb25cblxuICAgIGZpeEZyYWdtZW50OiAocmF3ZnJhZ21lbnQsIHNlY3Rpb25zKSA9PlxuICAgICAgICBpZiByYXdmcmFnbWVudFxuICAgICAgICAgICAgZnJhZ21lbnQgPSBAV00uUGFyc2VyLnNxdWFzaENvbnRpZ3VvdXNXaGl0ZXNwYWNlKHJhd2ZyYWdtZW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAudHJpbSgpXG5cbiAgICAgICAgICAgIGlmIHNlY3Rpb25zLmluZGV4T2YoZnJhZ21lbnQpIDwgMFxuICAgICAgICAgICAgICAgIGZvciBzZWN0aW9uIGluIHNlY3Rpb25zXG4gICAgICAgICAgICAgICAgICAgICMgVGhlIEZpeEZyYWdtZW50cyBhbmQgRml4TGlua0ZyYWdtZW50cyBwbHVnaW5zIGFsc28gdHJ5XG4gICAgICAgICAgICAgICAgICAgICMgdG8gZml4IGRvdC1lbmNvZGVkIGZyYWdtZW50cyBob3dldmVyIGl0J3MgdG9vIGRhbmdlcm91c1xuICAgICAgICAgICAgICAgICAgICAjIHRvIGRvIGl0IHdpdGggdGhpcyBib3QgcGx1Z2luLCBoYXZlIHRoZSB1c2VyIGZpeFxuICAgICAgICAgICAgICAgICAgICAjIGZyYWdtZW50cyBtYW51YWxseVxuICAgICAgICAgICAgICAgICAgICBpZiBzZWN0aW9uLnRvTG93ZXJDYXNlKCkgPT0gZnJhZ21lbnQudG9Mb3dlckNhc2UoKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlY3Rpb25cblxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG5cbiAgICBtYWluX2JvdDogKHRpdGxlLCBjYWxsQm90LCBjaGFpbkFyZ3MpIC0+XG4gICAgICAgIHN1bW1hcnkgPSBAY29uZi5lZGl0X3N1bW1hcnlcblxuICAgICAgICB0YXJnZXQgPSByZWFkVGFyZ2V0KClcbiAgICAgICAgQFdNLkxvZy5sb2dIaWRkZW4oXCJUYXJnZXQgcGFnZTogXCIgKyB0YXJnZXQpXG5cbiAgICAgICAgaWYgdGFyZ2V0XG4gICAgICAgICAgICBpZiBjaGFpbkFyZ3MgaXMgbnVsbFxuICAgICAgICAgICAgICAgIHBhcmFtcyA9XG4gICAgICAgICAgICAgICAgICAgICdhY3Rpb24nOiAncGFyc2UnXG4gICAgICAgICAgICAgICAgICAgICdwcm9wJzogJ3NlY3Rpb25zJ1xuICAgICAgICAgICAgICAgICAgICAncGFnZSc6IHRhcmdldFxuICAgICAgICAgICAgICAgICAgICAncmVkaXJlY3RzJzogMVxuXG4gICAgICAgICAgICAgICAgQFdNLkxvZy5sb2dXYXJuaW5nKFwiSWYgc29tZSBhcnRpY2xlcyBpbiB0aGUgbGlzdCBhcmVcbiAgICAgICAgICAgICAgICAgICAgbGlua2luZyB0byB0aGUgdGFyZ2V0IGFydGljbGVcbiAgICAgICAgICAgICAgICAgICAgdGhyb3VnaCBhIHJlZGlyZWN0LCB5b3Ugc2hvdWxkIHByb2Nlc3MgdGhlIGJhY2tsaW5rc1xuICAgICAgICAgICAgICAgICAgICBvZiB0aGF0IHJlZGlyZWN0IHBhZ2Ugc2VwYXJhdGVseSB0aHJvdWdoIGl0c1xuICAgICAgICAgICAgICAgICAgICBTcGVjaWFsOldoYXRMaW5rc0hlcmUgcGFnZSwgYXMgdGhpcyBwbHVnaW4gY2FuIG9ubHlcbiAgICAgICAgICAgICAgICAgICAgZml4IGxpbmtzIHRoYXQgZXhhY3RseSBtYXRjaCB0aGUgdGl0bGUgb2YgdGhlIHRhcmdldFxuICAgICAgICAgICAgICAgICAgICBhcnRpY2xlLlxcbkluIG9yZGVyIHRvIHNhdmUgdGltZSB5b3UgYXJlIGFkdmlzZWQgdG9cbiAgICAgICAgICAgICAgICAgICAgaGlkZSB0aGUgcmVkaXJlY3RzIGluIHRoZSBwYWdlIGxpc3RzIHRoYXQgYWxsb3cgdG8gZG9cbiAgICAgICAgICAgICAgICAgICAgc28uXCIpXG5cbiAgICAgICAgICAgICAgICBAV00uTVcuY2FsbEFQSUdldChwYXJhbXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgQG1haW5BdXRvRmluZFNlY3Rpb25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgIFt0aXRsZSwgdGFyZ2V0LCBzdW1tYXJ5LCBjYWxsQm90XSxcbiAgICAgICAgICAgICAgICAgICAgICAgICBudWxsKVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIEBtYWluQXV0b1JlYWQodGFyZ2V0LCBjaGFpbkFyZ3MsIHRpdGxlLCBzdW1tYXJ5LCBjYWxsQm90KVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICBAV00uTG9nLmxvZ0Vycm9yKCdUaGUgdGFyZ2V0IHBhZ2UgY2Fubm90IGJlIGVtcHR5JylcbiAgICAgICAgICAgIGNhbGxCb3QoZmFsc2UsIG51bGwpXG5cbiAgICBtYWluQXV0b0ZpbmRTZWN0aW9uczogKHJlcywgYXJncykgPT5cbiAgICAgICAgdGl0bGUgPSBhcmdzWzBdXG4gICAgICAgIHRhcmdldCA9IGFyZ3NbMV1cbiAgICAgICAgc3VtbWFyeSA9IGFyZ3NbMl1cbiAgICAgICAgY2FsbEJvdCA9IGFyZ3NbM11cbiAgICAgICAgc2VjdGlvbnMgPSBbXVxuXG4gICAgICAgIGlmIHJlcy5wYXJzZVxuICAgICAgICAgICAgZm9yIHNlY3Rpb24gaW4gcmVzLnBhcnNlLnNlY3Rpb25zXG4gICAgICAgICAgICAgICAgc2VjdGlvbnMucHVzaChAV00uUGFyc2VyLnNxdWFzaENvbnRpZ3VvdXNXaGl0ZXNwYWNlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlY3Rpb24ubGluZSkudHJpbSgpKVxuXG4gICAgICAgICAgICBAbWFpbkF1dG9SZWFkKHRhcmdldCwgc2VjdGlvbnMsIHRpdGxlLCBzdW1tYXJ5LCBjYWxsQm90KVxuXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIEBXTS5Mb2cubG9nRXJyb3IoXCJUaGUgc2V0IHRhcmdldCBwYWdlLCBcIiArIHRhcmdldCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsIHNlZW1zIG5vdCB0byBleGlzdFwiKVxuXG4gICAgICAgICAgICBpZiByZXMuZXJyb3JcbiAgICAgICAgICAgICAgICBjYWxsQm90KHJlcy5lcnJvci5jb2RlLCBzZWN0aW9ucylcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBjYWxsQm90KGZhbHNlLCBzZWN0aW9ucylcblxuICAgIG1haW5BdXRvUmVhZDogKHRhcmdldCwgc2VjdGlvbnMsIHRpdGxlLCBzdW1tYXJ5LCBjYWxsQm90KSA9PlxuICAgICAgICBAV00uTVcuY2FsbFF1ZXJ5RWRpdCh0aXRsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBAbWFpbkF1dG9Xcml0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbdGFyZ2V0LCBzdW1tYXJ5LCBjYWxsQm90LCBzZWN0aW9uc10pXG5cbiAgICBtYWluQXV0b1dyaXRlOiAodGl0bGUsIHNvdXJjZSwgdGltZXN0YW1wLCBlZGl0dG9rZW4sIGFyZ3MpID0+XG4gICAgICAgIHRhcmdldCA9IGFyZ3NbMF1cbiAgICAgICAgc3VtbWFyeSA9IGFyZ3NbMV1cbiAgICAgICAgY2FsbEJvdCA9IGFyZ3NbMl1cbiAgICAgICAgc2VjdGlvbnMgPSBhcmdzWzNdXG5cbiAgICAgICAgbmV3dGV4dCA9IEBmaXhMaW5rcyhzb3VyY2UsIHRhcmdldCwgc2VjdGlvbnMpXG5cbiAgICAgICAgaWYgbmV3dGV4dCAhPSBzb3VyY2VcbiAgICAgICAgICAgIEBXTS5NVy5jYWxsQVBJUG9zdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwiZWRpdFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm90OiBcIjFcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiB0aXRsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1bW1hcnk6IHN1bW1hcnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBuZXd0ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFzZXRpbWVzdGFtcDogdGltZXN0YW1wLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW46IGVkaXR0b2tlblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBAbWFpbkF1dG9FbmQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtjYWxsQm90LCBzZWN0aW9uc10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bGwpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGNhbGxCb3QoMCwgc2VjdGlvbnMpXG5cbiAgICBtYWluQXV0b0VuZDogKHJlcywgYXJncykgPT5cbiAgICAgICAgY2FsbEJvdCA9IGFyZ3NbMF1cbiAgICAgICAgc2VjdGlvbnMgPSBhcmdzWzFdXG5cbiAgICAgICAgaWYgcmVzLmVkaXQgYW5kIHJlcy5lZGl0LnJlc3VsdCA9PSAnU3VjY2VzcydcbiAgICAgICAgICAgIGNhbGxCb3QoMSwgc2VjdGlvbnMpXG4gICAgICAgIGVsc2UgaWYgcmVzLmVycm9yXG4gICAgICAgICAgICBAV00uTG9nLmxvZ0Vycm9yKHJlcy5lcnJvci5pbmZvICsgXCIgKFwiICsgcmVzLmVycm9yLmNvZGUgKyBcIilcIilcbiAgICAgICAgICAgIGNhbGxCb3QocmVzLmVycm9yLmNvZGUsIHNlY3Rpb25zKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICBjYWxsQm90KGZhbHNlLCBzZWN0aW9ucylcbiIsIiMgV2lraSBNb25rZXkgLSBNZWRpYVdpa2kgYm90IGFuZCBlZGl0b3ItYXNzaXN0YW50IHVzZXIgc2NyaXB0XG4jIENvcHlyaWdodCAoQykgMjAxMSBEYXJpbyBHaW92YW5uZXR0aSA8ZGV2QGRhcmlvZ2lvdmFubmV0dGkubmV0PlxuI1xuIyBUaGlzIGZpbGUgaXMgcGFydCBvZiBXaWtpIE1vbmtleS5cbiNcbiMgV2lraSBNb25rZXkgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuIyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuIyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuIyAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuI1xuIyBXaWtpIE1vbmtleSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuIyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuIyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4jIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4jXG4jIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4jIGFsb25nIHdpdGggV2lraSBNb25rZXkuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG5cbntQbHVnaW59ID0gcmVxdWlyZSgnLi9fUGx1Z2luJylcblN0ciA9IHJlcXVpcmUoJ0BreW5pa29zL21pc2MvZGlzdC9TdHInKVxuXG5cbmNsYXNzIG1vZHVsZS5leHBvcnRzLkZpeERvdWJsZVJlZGlyZWN0cyBleHRlbmRzIFBsdWdpblxuICAgIEBjb25mX2RlZmF1bHQ6XG4gICAgICAgIGVuYWJsZWQ6IHRydWVcbiAgICAgICAgc3BlY2lhbF9tZW51OiBbXCJGaXggZG91YmxlIHJlZGlyZWN0c1wiXVxuICAgICAgICBlZGl0X3N1bW1hcnk6IFwiZml4IGRvdWJsZSByZWRpcmVjdFwiXG5cbiAgICBtYWluX3NwZWNpYWw6IChjYWxsTmV4dCkgLT5cbiAgICAgICAgQFdNLkxvZy5sb2dJbmZvKFwiRml4aW5nIGRvdWJsZSByZWRpcmVjdHMgLi4uXCIpXG5cbiAgICAgICAge3Jlc3VsdHMsIHNpdGVpbmZvfSA9XG4gICAgICAgICAgICBhd2FpdCBAV00uTVcuZ2V0U3BlY2lhbExpc3QoXCJEb3VibGVSZWRpcmVjdHNcIiwgXCJuYW1lc3BhY2VzXCIpXG5cbiAgICAgICAge25hbWVzcGFjZXN9ID0gc2l0ZWluZm9cbiAgICAgICAgcmVzdWx0cy5yZXZlcnNlKClcblxuICAgICAgICB0cnlcbiAgICAgICAgICAgIGZvciBkb3VibGVSZWRpcmVjdCBpbiByZXN1bHRzXG4gICAgICAgICAgICAgICAgYXdhaXQgQHByb2Nlc3NfcmVkaXJlY3QoZG91YmxlUmVkaXJlY3QsIG5hbWVzcGFjZXMpXG4gICAgICAgIGNhdGNoIGVycm9yXG4gICAgICAgICAgICBAV00uTG9nLmxvZ0Vycm9yKGVycm9yLm1lc3NhZ2UpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcblxuICAgICAgICBAV00uTG9nLmxvZ0luZm8oXCJGaXhlZCBkb3VibGUgcmVkaXJlY3RzXCIpXG4gICAgICAgIGlmIGNhbGxOZXh0XG4gICAgICAgICAgICBjYWxsTmV4dCgpXG5cbiAgICBwcm9jZXNzX3JlZGlyZWN0OiAoZG91YmxlUmVkaXJlY3QsIG5hbWVzcGFjZXMpID0+XG4gICAgICAgIHtzb3VyY2UsIHRpbWVzdGFtcCwgZWRpdHRva2VufSA9XG4gICAgICAgICAgICBhd2FpdCBAV00uTVcuY2FsbFF1ZXJ5RWRpdChkb3VibGVSZWRpcmVjdC50aXRsZSlcbiAgICAgICAgZG91YmxlUmVkaXJlY3RTb3VyY2UgPSBzb3VyY2VcblxuICAgICAgICBtaWRkbGVSZWRpcmVjdFRpdGxlID1cbiAgICAgICAgICAgIFtuYW1lc3BhY2VzW2RvdWJsZVJlZGlyZWN0LmRhdGFiYXNlUmVzdWx0LmJfbmFtZXNwYWNlXVsnKiddXG4gICAgICAgICAgICAgZG91YmxlUmVkaXJlY3QuZGF0YWJhc2VSZXN1bHQuYl90aXRsZV0uam9pbignOicpXG5cbiAgICAgICAgbWlkZGxlUmVkaXJlY3QgPSBhd2FpdCBAV00uTVcuY2FsbFF1ZXJ5KFxuICAgICAgICAgICAgcHJvcDogXCJyZXZpc2lvbnNcIlxuICAgICAgICAgICAgcnZwcm9wOiBcImNvbnRlbnRcIlxuICAgICAgICAgICAgdGl0bGVzOiBtaWRkbGVSZWRpcmVjdFRpdGxlXG4gICAgICAgIClcblxuICAgICAgICBtaWRkbGVSZWRpcmVjdFNvdXJjZSA9IG1pZGRsZVJlZGlyZWN0LnJldmlzaW9uc1swXVtcIipcIl1cblxuICAgICAgICBAV00uTG9nLmxvZ0luZm8oXCJQcm9jZXNzaW5nICN7QFdNLkxvZy5saW5rVG9XaWtpUGFnZShcbiAgICAgICAgICAgIGRvdWJsZVJlZGlyZWN0LnRpdGxlLCBkb3VibGVSZWRpcmVjdC50aXRsZSl9IC4uLlwiKVxuXG4gICAgICAgIHJhd09sZFRhcmdldCA9IGRvdWJsZVJlZGlyZWN0U291cmNlLm1hdGNoKC9cXHMqI3JlZGlyZWN0XFxzKlteXFxuXSsvaSlcbiAgICAgICAgb2xkVGFyZ2V0ID0gQFdNLlBhcnNlci5maW5kSW50ZXJuYWxMaW5rcyhyYXdPbGRUYXJnZXRbMF0sIG51bGwpWzBdXG5cbiAgICAgICAgcmF3TWlkZGxlVGFyZ2V0ID0gbWlkZGxlUmVkaXJlY3RTb3VyY2UubWF0Y2goL1xccyojcmVkaXJlY3RcXHMqW15cXG5dKy9pKVxuICAgICAgICBtaWRkbGVUYXJnZXQgPVxuICAgICAgICAgICAgQFdNLlBhcnNlci5maW5kSW50ZXJuYWxMaW5rcyhyYXdNaWRkbGVUYXJnZXRbMF0sIG51bGwpWzBdXG5cbiAgICAgICAgbmV3VGFyZ2V0RnJhZ21lbnQgPSBkbyAtPlxuICAgICAgICAgICAgaWYgb2xkVGFyZ2V0LmZyYWdtZW50XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiI1wiICsgb2xkVGFyZ2V0LmZyYWdtZW50XG4gICAgICAgICAgICBlbHNlIGlmIG1pZGRsZVRhcmdldC5mcmFnbWVudFxuICAgICAgICAgICAgICAgIHJldHVybiBcIiNcIiArIG1pZGRsZVRhcmdldC5mcmFnbWVudFxuICAgICAgICAgICAgcmV0dXJuIFwiXCJcblxuICAgICAgICBuZXdUYXJnZXRBbHRBbmNob3IgPSBkbyAtPlxuICAgICAgICAgICAgaWYgb2xkVGFyZ2V0LmFuY2hvclxuICAgICAgICAgICAgICAgIHJldHVybiBcInxcIiArIG9sZFRhcmdldC5hbmNob3JcbiAgICAgICAgICAgIGVsc2UgaWYgbWlkZGxlVGFyZ2V0LmFuY2hvclxuICAgICAgICAgICAgICAgIHJldHVybiBcInxcIiArIG1pZGRsZVRhcmdldC5hbmNob3JcbiAgICAgICAgICAgIHJldHVybiBcIlwiXG5cbiAgICAgICAgbmV3VGFyZ2V0SW50ZXJsYW5ndWFnZSA9IGlmIGRvdWJsZVJlZGlyZWN0LmRhdGFiYXNlUmVzdWx0LmNfaW50ZXJ3aWtpIFxcXG4gICAgICAgICAgICB0aGVuIGRvdWJsZVJlZGlyZWN0LmRhdGFiYXNlUmVzdWx0LmNfaW50ZXJ3aWtpICsgXCI6XCIgZWxzZSBcIlwiXG5cbiAgICAgICAgbmV3VGFyZ2V0TmFtZXNwYWNlID0gZG8gLT5cbiAgICAgICAgICAgIGNucyA9IG5hbWVzcGFjZXNbZG91YmxlUmVkaXJlY3QuZGF0YWJhc2VSZXN1bHQuY19uYW1lc3BhY2VdW1wiKlwiXVxuICAgICAgICAgICAgaWYgY25zXG4gICAgICAgICAgICAgICAgcmV0dXJuIEBXTS5QYXJzZXIuc3F1YXNoQ29udGlndW91c1doaXRlc3BhY2UoY25zKSArIFwiOlwiXG4gICAgICAgICAgICByZXR1cm4gXCJcIlxuXG4gICAgICAgIG5ld1RhcmdldFRpdGxlID0gQFdNLlBhcnNlci5zcXVhc2hDb250aWd1b3VzV2hpdGVzcGFjZShcbiAgICAgICAgICAgIGRvdWJsZVJlZGlyZWN0LmRhdGFiYXNlUmVzdWx0LmNfdGl0bGUpXG5cbiAgICAgICAgbmV3VGFyZ2V0ID0gXCJbWyN7bmV3VGFyZ2V0SW50ZXJsYW5ndWFnZX0je25ld1RhcmdldE5hbWVzcGFjZX1cIiArXG4gICAgICAgICAgICBcIiN7bmV3VGFyZ2V0VGl0bGV9I3tuZXdUYXJnZXRGcmFnbWVudH0je25ld1RhcmdldEFsdEFuY2hvcn1dXVwiXG4gICAgICAgIG5ld1RleHQgPSBTdHIub3ZlcndyaXRlRm9yKGRvdWJsZVJlZGlyZWN0U291cmNlLCBuZXdUYXJnZXQsXG4gICAgICAgICAgICBvbGRUYXJnZXQuaW5kZXgsIG9sZFRhcmdldC5sZW5ndGgpXG5cbiAgICAgICAgaWYgbmV3VGV4dCBpc250IGRvdWJsZVJlZGlyZWN0U291cmNlXG4gICAgICAgICAgICByZXMgPSBhd2FpdCBAV00uTVcuY2FsbEFQSVBvc3QoXG4gICAgICAgICAgICAgICAgYWN0aW9uOiBcImVkaXRcIlxuICAgICAgICAgICAgICAgIGJvdDogXCIxXCJcbiAgICAgICAgICAgICAgICB0aXRsZTogZG91YmxlUmVkaXJlY3QudGl0bGVcbiAgICAgICAgICAgICAgICBzdW1tYXJ5OiBAY29uZi5lZGl0X3N1bW1hcnlcbiAgICAgICAgICAgICAgICB0ZXh0OiBuZXdUZXh0XG4gICAgICAgICAgICAgICAgYjFhc2V0aW1lc3RhbXA6IHRpbWVzdGFtcFxuICAgICAgICAgICAgICAgIHRva2VuOiBlZGl0dG9rZW5cbiAgICAgICAgICAgIClcblxuICAgICAgICAgICAgaWYgbm90IHJlcy5lZGl0IG9yIHJlcy5lZGl0LnJlc3VsdCBpc250ICdTdWNjZXNzJ1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIiN7cmVzLmVycm9yLmluZm99ICgje3Jlcy5lcnJvci5jb2RlfSlcIilcblxuICAgICAgICBlbHNlXG4gICAgICAgICAgICBAV00uTG9nLmxvZ1dhcm5pbmcoXCJDb3VsZCBub3QgZml4ICN7QFdNLkxvZy5saW5rVG9XaWtpUGFnZShcbiAgICAgICAgICAgICAgICBkb3VibGVSZWRpcmVjdC50aXRsZSwgZG91YmxlUmVkaXJlY3QudGl0bGUpfVwiKVxuIiwiIyBXaWtpIE1vbmtleSAtIE1lZGlhV2lraSBib3QgYW5kIGVkaXRvci1hc3Npc3RhbnQgdXNlciBzY3JpcHRcbiMgQ29weXJpZ2h0IChDKSAyMDExIERhcmlvIEdpb3Zhbm5ldHRpIDxkZXZAZGFyaW9naW92YW5uZXR0aS5uZXQ+XG4jXG4jIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFdpa2kgTW9ua2V5LlxuI1xuIyBXaWtpIE1vbmtleSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4jIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4jIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4jIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4jXG4jIFdpa2kgTW9ua2V5IGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4jIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4jIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiMgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbiNcbiMgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiMgYWxvbmcgd2l0aCBXaWtpIE1vbmtleS4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cblxue1BsdWdpbn0gPSByZXF1aXJlKCcuL19QbHVnaW4nKVxuXG5cbmNsYXNzIG1vZHVsZS5leHBvcnRzLkZpeEZyYWdtZW50cyBleHRlbmRzIFBsdWdpblxuICAgIEBjb25mX2RlZmF1bHQ6XG4gICAgICAgIGVuYWJsZWQ6IHRydWVcbiAgICAgICAgZWRpdG9yX21lbnU6IFtcIlRleHQgcGx1Z2luc1wiLCBcIkZpeCBzZWN0aW9uIGxpbmtzXCJdXG5cbiAgICBmaXhMaW5rczogKHNvdXJjZSkgLT5cbiAgICAgICAgdGl0bGUgPSBAV00uRWRpdG9yLmdldFRpdGxlKClcbiAgICAgICAgc2VjdGlvbnMgPSBAV00uUGFyc2VyLmZpbmRTZWN0aW9uSGVhZGluZ3Moc291cmNlKS5zZWN0aW9uc1xuXG4gICAgICAgIHNsaW5rcyA9IEBXTS5QYXJzZXIuZmluZFNlY3Rpb25MaW5rcyhzb3VyY2UpXG4gICAgICAgIG5ld3RleHQxID0gXCJcIlxuICAgICAgICBwcmV2SWQgPSAwXG5cbiAgICAgICAgZm9yIGxpbmsgaW4gc2xpbmtzXG4gICAgICAgICAgICBuZXd0ZXh0MSArPSBzb3VyY2Uuc3Vic3RyaW5nKHByZXZJZCwgbGluay5pbmRleClcbiAgICAgICAgICAgIG5ld3RleHQxICs9IEBmaXhMaW5rKHNvdXJjZSwgc2VjdGlvbnMsIGxpbmsucmF3TGluaywgbGluay5mcmFnbWVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rLmFuY2hvcilcbiAgICAgICAgICAgIHByZXZJZCA9IGxpbmsuaW5kZXggKyBsaW5rLmxlbmd0aFxuXG4gICAgICAgIG5ld3RleHQxICs9IHNvdXJjZS5zdWJzdHIocHJldklkKVxuXG4gICAgICAgICMgTm90ZSB0aGF0IGl0J3MgaW1wb3NzaWJsZSB0byByZWNvZ25pemUgYW55IG5hbWVzcGFjZXMgaW4gdGhlIHRpdGxlXG4gICAgICAgICMgICB3aXRob3V0IHF1ZXJ5aW5nIHRoZSBzZXJ2ZXJcbiAgICAgICAgIyBBbHRlcm5hdGl2ZWx5LCBhIGxpc3Qgb2YgdGhlIGtub3duIG5hbWVzcGFjZXMgY291bGQgYmUgbWFpbnRhaW5lZFxuICAgICAgICAjICAgZm9yIGVhY2ggd2lraVxuICAgICAgICAjIFJlY29nbml6aW5nIG5hbWVzcGFjZXMgd291bGQgbGV0IHJlY29nbml6ZSBtb3JlIGxpYmVyYWwgbGlua1xuICAgICAgICAjICAgc3ludGF4ZXMgKGUuZy4gc3BhY2VzIGFyb3VuZCB0aGUgY29sb24pXG4gICAgICAgIGlsaW5rcyA9IEBXTS5QYXJzZXIuZmluZEludGVybmFsTGlua3MobmV3dGV4dDEsIG51bGwsIHRpdGxlKVxuICAgICAgICBuZXd0ZXh0MiA9IFwiXCJcbiAgICAgICAgcHJldklkID0gMFxuXG4gICAgICAgIGZvciBsaW5rIGluIGlsaW5rc1xuICAgICAgICAgICAgbmV3dGV4dDIgKz0gbmV3dGV4dDEuc3Vic3RyaW5nKHByZXZJZCwgbGluay5pbmRleClcbiAgICAgICAgICAgIHJhd2ZyYWdtZW50ID0gbGluay5mcmFnbWVudFxuXG4gICAgICAgICAgICBpZiByYXdmcmFnbWVudFxuICAgICAgICAgICAgICAgIG5ld3RleHQyICs9IEBmaXhMaW5rKG5ld3RleHQxLCBzZWN0aW9ucywgbGluay5yYXdMaW5rLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhd2ZyYWdtZW50LCBsaW5rLmFuY2hvcilcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBuZXd0ZXh0MiArPSBsaW5rLnJhd0xpbmtcblxuICAgICAgICAgICAgcHJldklkID0gbGluay5pbmRleCArIGxpbmsubGVuZ3RoXG5cbiAgICAgICAgbmV3dGV4dDIgKz0gbmV3dGV4dDEuc3Vic3RyKHByZXZJZClcblxuICAgICAgICByZXR1cm4gbmV3dGV4dDJcblxuICAgIGZpeExpbms6IChzb3VyY2UsIHNlY3Rpb25zLCByYXdsaW5rLCByYXdmcmFnbWVudCwgbGFsdCkgLT5cbiAgICAgICAgZnJhZ21lbnQgPSBAV00uUGFyc2VyLnNxdWFzaENvbnRpZ3VvdXNXaGl0ZXNwYWNlKHJhd2ZyYWdtZW50KS50cmltKClcblxuICAgICAgICBmb3Igc2VjdGlvbiBpbiBzZWN0aW9uc1xuICAgICAgICAgICAgaGVhZGluZyA9IHNlY3Rpb24uY2xlYW5oZWFkaW5nXG4gICAgICAgICAgICBkb3RIZWFkaW5nID0gQFdNLlBhcnNlci5kb3RFbmNvZGUoaGVhZGluZylcbiAgICAgICAgICAgIGRvdEZyYWdtZW50ID0gQFdNLlBhcnNlci5kb3RFbmNvZGUoZnJhZ21lbnQpXG5cbiAgICAgICAgICAgIGlmIGRvdEhlYWRpbmcudG9Mb3dlckNhc2UoKSA9PSBkb3RGcmFnbWVudC50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgICAgICAgaWYgZnJhZ21lbnQgPT0gZG90RnJhZ21lbnRcbiAgICAgICAgICAgICAgICAgICAgIyBJZiB0aGUgZnJhZ21lbnQgd2FzIGVuY29kZWQsIHJlLWVuY29kZSBpdCBiZWNhdXNlIGl0XG4gICAgICAgICAgICAgICAgICAgICMgY291bGQgY29udGFpbiBsaW5rLWJyZWFraW5nIGNoYXJhY3RlcnMgKGUuZy4gW118e30pXG4gICAgICAgICAgICAgICAgICAgICMgVGhlIGNvbmRpdGlvbiB3b3VsZCBhbHNvIGJlIHRydWUgaWYgdGhlIGZyYWdtZW50IGRvZXNuJ3RcbiAgICAgICAgICAgICAgICAgICAgIyBjb250YWluIGFueSBlbmNvZGFibGUgY2hhcmFjdGVycywgYnV0IHNpbmNlIGhlYWRpbmcgYW5kXG4gICAgICAgICAgICAgICAgICAgICMgZnJhZ21lbnQgYXQgbW9zdCBkaWZmZXIgYnkgY2FwaXRhbGl6YXRpb24sIGVuY29kaW5nIHRoZVxuICAgICAgICAgICAgICAgICAgICAjIGhlYWRpbmcgd29uJ3QgaGF2ZSBhbnkgZWZmZWN0XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIltbI1wiICsgZG90SGVhZGluZyArIChpZiBsYWx0IHRoZW4gXCJ8XCIgKyBsYWx0IGVsc2UgXCJcIikgKyBcIl1dXCJcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICMgSWYgdGhlIGZyYWdtZW50IHdhcyBub3QgZW5jb2RlZCwgaWYgdGhlIGZyYWdtZW50XG4gICAgICAgICAgICAgICAgICAgICMgY29udGFpbmVkIGxpbmstYnJlYWtpbmcgY2hhcmFjdGVycyB0aGUgbGluayB3YXMgYWxyZWFkeVxuICAgICAgICAgICAgICAgICAgICAjIGJyb2tlbiwgYW5kIHJlcGxhY2luZyBpdCB3aXRoIGhlYWRpbmcgd291bGRuJ3QgbWFrZVxuICAgICAgICAgICAgICAgICAgICAjIHRoaW5ncyB3b3JzZTsgaWYgdGhlIGZyYWdtZW50IGRpZG4ndCBjb250YWluXG4gICAgICAgICAgICAgICAgICAgICMgbGluay1icmVha2luZyBjaGFyYWN0ZXJzLCB0aGUgaGVhZGluZyBkb2Vzbid0IGVpdGhlcixcbiAgICAgICAgICAgICAgICAgICAgIyBzaW5jZSBoZWFkaW5nIGFuZCBmcmFnbWVudCBhdCBtb3N0IGRpZmZlciBieVxuICAgICAgICAgICAgICAgICAgICAjIGNhcGl0YWxpemF0aW9uLCBzbyBpdCdzIHNhZmUgdG8gcmVwbGFjZSBpdFxuICAgICAgICAgICAgICAgICAgICAjIElmIHRoZSBmcmFnbWVudCB3YXMgKnBhcnRpYWxseSogZW5jb2RlZCBpbnN0ZWFkLCBhXG4gICAgICAgICAgICAgICAgICAgICMgbGluay1icmVha2luZyBjaGFyYWN0ZXIgbWF5IGhhdmUgYmVlbiBlbmNvZGVkLCBzbyBhbGxcbiAgICAgICAgICAgICAgICAgICAgIyBsaW5rLWJyZWFraW5nIGNoYXJhY3RlcnMgbXVzdCBiZSByZS1lbmNvZGVkIGhlcmUhXG4gICAgICAgICAgICAgICAgICAgIGVzY0hlYWRpbmcgPSBAV00uUGFyc2VyLmRvdEVuY29kZUxpbmtCcmVha2luZ0ZyYWdtZW50Q2hhcmFjdGVycyhoZWFkaW5nKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJbWyNcIiArIGVzY0hlYWRpbmcgKyAoaWYgbGFsdCB0aGVuIFwifFwiICsgbGFsdCBlbHNlIFwiXCIpICsgXCJdXVwiXG5cbiAgICAgICAgIyBJdCdzIG5vdCBlYXN5IHRvIHVzZSBAV00uTG9nLmxpbmtUb1dpa2lQYWdlIGJlY2F1c2UgcHVyZSBmcmFnbWVudHNcbiAgICAgICAgIyAgIGFyZSBub3Qgc3VwcG9ydGVkIHlldFxuICAgICAgICBAV00uTG9nLmxvZ1dhcm5pbmcoXCJDYW5ub3QgZml4IGJyb2tlbiBzZWN0aW9uIGxpbms6IFwiICsgcmF3bGluaylcbiAgICAgICAgcmV0dXJuIHJhd2xpbmtcblxuICAgIG1haW5fZWRpdG9yOiAoY2FsbE5leHQpIC0+XG4gICAgICAgIHNvdXJjZSA9IEBXTS5FZGl0b3IucmVhZFNvdXJjZSgpXG4gICAgICAgIG5ld3RleHQgPSBAZml4TGlua3Moc291cmNlKVxuXG4gICAgICAgIGlmIG5ld3RleHQgIT0gc291cmNlXG4gICAgICAgICAgICBAV00uRWRpdG9yLndyaXRlU291cmNlKG5ld3RleHQpXG4gICAgICAgICAgICBAV00uTG9nLmxvZ0luZm8oXCJGaXhlZCBzZWN0aW9uIGxpbmtzXCIpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIEBXTS5Mb2cubG9nSW5mbyhcIk5vIGZpeGFibGUgc2VjdGlvbiBsaW5rcyBmb3VuZFwiKVxuXG4gICAgICAgIGlmIGNhbGxOZXh0XG4gICAgICAgICAgICBjYWxsTmV4dCgpXG4iLCIjIFdpa2kgTW9ua2V5IC0gTWVkaWFXaWtpIGJvdCBhbmQgZWRpdG9yLWFzc2lzdGFudCB1c2VyIHNjcmlwdFxuIyBDb3B5cmlnaHQgKEMpIDIwMTEgRGFyaW8gR2lvdmFubmV0dGkgPGRldkBkYXJpb2dpb3Zhbm5ldHRpLm5ldD5cbiNcbiMgVGhpcyBmaWxlIGlzIHBhcnQgb2YgV2lraSBNb25rZXkuXG4jXG4jIFdpa2kgTW9ua2V5IGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiMgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiMgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiMgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbiNcbiMgV2lraSBNb25rZXkgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiMgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiMgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuIyBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuI1xuIyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuIyBhbG9uZyB3aXRoIFdpa2kgTW9ua2V5LiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuXG57UGx1Z2lufSA9IHJlcXVpcmUoJy4vX1BsdWdpbicpXG5cblxuY2xhc3MgbW9kdWxlLmV4cG9ydHMuRml4TGlua0ZyYWdtZW50cyBleHRlbmRzIFBsdWdpblxuICAgIEBjb25mX2RlZmF1bHQ6XG4gICAgICAgIGVuYWJsZWQ6IHRydWVcbiAgICAgICAgZWRpdG9yX21lbnU6IFtcIlF1ZXJ5IHBsdWdpbnNcIiwgXCJGaXggZXh0ZXJuYWwgc2VjdGlvbiBsaW5rc1wiXVxuXG4gICAgcHJvY2Vzc0xpbms6ICh0aXRsZSwgaXdwcmVmaXhlcywgbGlua3MsIGluZGV4LCBzb3VyY2UsIG5ld1RleHQsIHByZXZJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGwsIGNhbGxBcmdzKSA9PlxuICAgICAgICBpZiBsaW5rc1tpbmRleF1cbiAgICAgICAgICAgIGxpbmsgPSBsaW5rc1tpbmRleF1cbiAgICAgICAgICAgIHJhd2ZyYWdtZW50ID0gbGluay5mcmFnbWVudFxuXG4gICAgICAgICAgICBpZiBub3QgKGxpbmsubmFtZXNwYWNlPyBhbmQgbGluay5uYW1lc3BhY2UudG9Mb3dlckNhc2UoKSBpbiBpd3ByZWZpeGVzKSBhbmQgcmF3ZnJhZ21lbnRcbiAgICAgICAgICAgICAgICBAV00uTG9nLmxvZ0luZm8oXCJQcm9jZXNzaW5nIFwiICtcbiAgICAgICAgICAgICAgICAgICAgQFdNLkxvZy5saW5rVG9XaWtpUGFnZShsaW5rLmxpbmssIGxpbmsucmF3TGluaykgKyBcIiAuLi5cIilcblxuICAgICAgICAgICAgICAgIHRhcmdldCA9IChpZiBsaW5rLm5hbWVzcGFjZSB0aGVuIGxpbmsubmFtZXNwYWNlICsgXCI6XCIgZWxzZSBcIlwiKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmsudGl0bGVcblxuICAgICAgICAgICAgICAgICMgTm90ZSB0aGF0IGl0J3MgaW1wb3NzaWJsZSB0byByZWNvZ25pemUgYW55IG5hbWVzcGFjZXMgaW4gdGhlXG4gICAgICAgICAgICAgICAgIyAgIHRpdGxlIHdpdGhvdXQgcXVlcnlpbmcgdGhlIHNlcnZlclxuICAgICAgICAgICAgICAgICMgQWx0ZXJuYXRpdmVseSwgYSBsaXN0IG9mIHRoZSBrbm93biBuYW1lc3BhY2VzIGNvdWxkIGJlXG4gICAgICAgICAgICAgICAgIyAgIG1haW50YWluZWQgZm9yIGVhY2ggd2lraVxuICAgICAgICAgICAgICAgICMgUmVjb2duaXppbmcgbmFtZXNwYWNlcyB3b3VsZCBsZXQgcmVjb2duaXplIG1vcmUgbGliZXJhbCBsaW5rXG4gICAgICAgICAgICAgICAgIyAgIHN5bnRheGVzIChlLmcuIHNwYWNlcyBhcm91bmQgdGhlIGNvbG9uKVxuICAgICAgICAgICAgICAgIGlmIG5vdCBAV00uUGFyc2VyLmNvbXBhcmVBcnRpY2xlVGl0bGVzKHRhcmdldCwgdGl0bGUpXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcyA9XG4gICAgICAgICAgICAgICAgICAgICAgICAnYWN0aW9uJzogJ3BhcnNlJ1xuICAgICAgICAgICAgICAgICAgICAgICAgJ3Byb3AnOiAnc2VjdGlvbnMnXG4gICAgICAgICAgICAgICAgICAgICAgICAncGFnZSc6IHRhcmdldFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3JlZGlyZWN0cyc6IDFcblxuICAgICAgICAgICAgICAgICAgICBAV00uTVcuY2FsbEFQSUdldChwYXJhbXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIEBwcm9jZXNzTGlua0NvbnRpbnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbbGluaywgdGFyZ2V0LCByYXdmcmFnbWVudCwgaXdwcmVmaXhlcywgbGlua3MsIGluZGV4LCBzb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdUZXh0LCBwcmV2SWQsIHRpdGxlLCBjYWxsLCBjYWxsQXJnc10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bGwpXG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBpbmRleCsrXG4gICAgICAgICAgICAgICAgICAgIEBwcm9jZXNzTGluayh0aXRsZSwgaXdwcmVmaXhlcywgbGlua3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXgsIHNvdXJjZSwgbmV3VGV4dCwgcHJldklkLCBjYWxsLCBjYWxsQXJncylcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBpbmRleCsrXG4gICAgICAgICAgICAgICAgQHByb2Nlc3NMaW5rKHRpdGxlLCBpd3ByZWZpeGVzLCBsaW5rcywgaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2UsIG5ld1RleHQsIHByZXZJZCwgY2FsbCwgY2FsbEFyZ3MpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIG5ld1RleHQgKz0gc291cmNlLnN1YnN0cihwcmV2SWQpXG4gICAgICAgICAgICBjYWxsKG5ld1RleHQsIGl3cHJlZml4ZXMsIGNhbGxBcmdzKVxuXG4gICAgcHJvY2Vzc0xpbmtDb250aW51ZTogKHJlcywgYXJncykgPT5cbiAgICAgICAgbGluayA9IGFyZ3NbMF1cbiAgICAgICAgdGFyZ2V0ID0gYXJnc1sxXVxuICAgICAgICByYXdmcmFnbWVudCA9IGFyZ3NbMl1cbiAgICAgICAgaXdwcmVmaXhlcyA9IGFyZ3NbM11cbiAgICAgICAgbGlua3MgPSBhcmdzWzRdXG4gICAgICAgIGluZGV4ID0gYXJnc1s1XVxuICAgICAgICBzb3VyY2UgPSBhcmdzWzZdXG4gICAgICAgIG5ld1RleHQgPSBhcmdzWzddXG4gICAgICAgIHByZXZJZCA9IGFyZ3NbOF1cbiAgICAgICAgdGl0bGUgPSBhcmdzWzldXG4gICAgICAgIGNhbGwgPSBhcmdzWzEwXVxuICAgICAgICBjYWxsQXJncyA9IGFyZ3NbMTFdXG5cbiAgICAgICAgIyBDaGVjayB0aGF0IHRoZSBwYWdlIGlzIGluIHRoZSB3aWtpIChlLmcuIGl0J3Mgbm90IGFuIGludGVyd2lraSBsaW5rKVxuICAgICAgICBpZiByZXMucGFyc2VcbiAgICAgICAgICAgIHNlY3Rpb25zID0gW11cblxuICAgICAgICAgICAgZm9yIHNlY3Rpb24gaW4gcmVzLnBhcnNlLnNlY3Rpb25zXG4gICAgICAgICAgICAgICAgc2VjdGlvbnMucHVzaChAV00uUGFyc2VyLnNxdWFzaENvbnRpZ3VvdXNXaGl0ZXNwYWNlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlY3Rpb24ubGluZSkudHJpbSgpKVxuXG4gICAgICAgICAgICBmaXhlZEZyYWdtZW50ID0gQGZpeEZyYWdtZW50KHJhd2ZyYWdtZW50LCBzZWN0aW9ucylcblxuICAgICAgICAgICAgbmV3VGV4dCArPSBzb3VyY2Uuc3Vic3RyaW5nKHByZXZJZCwgbGluay5pbmRleClcblxuICAgICAgICAgICAgaWYgZml4ZWRGcmFnbWVudCBpcyB0cnVlXG4gICAgICAgICAgICAgICAgbmV3VGV4dCArPSBsaW5rLnJhd0xpbmtcbiAgICAgICAgICAgIGVsc2UgaWYgZml4ZWRGcmFnbWVudFxuICAgICAgICAgICAgICAgIG5ld1RleHQgKz0gXCJbW1wiICsgdGFyZ2V0ICsgXCIjXCIgKyBmaXhlZEZyYWdtZW50ICArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGlmIGxpbmsuYW5jaG9yIHRoZW4gXCJ8XCIgKyBsaW5rLmFuY2hvciBlbHNlIFwiXCIpICsgXCJdXVwiXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgQFdNLkxvZy5sb2dXYXJuaW5nKFwiQ2Fubm90IGZpeCBicm9rZW4gbGluayBmcmFnbWVudDogXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEBXTS5Mb2cubGlua1RvV2lraVBhZ2UobGluay5saW5rLCBsaW5rLnJhd0xpbmspKVxuICAgICAgICAgICAgICAgIG5ld1RleHQgKz0gbGluay5yYXdMaW5rXG5cbiAgICAgICAgICAgIHByZXZJZCA9IGxpbmsuaW5kZXggKyBsaW5rLmxlbmd0aFxuXG4gICAgICAgIGluZGV4KytcbiAgICAgICAgQHByb2Nlc3NMaW5rKHRpdGxlLCBpd3ByZWZpeGVzLCBsaW5rcywgaW5kZXgsIHNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3VGV4dCwgcHJldklkLCBjYWxsLCBjYWxsQXJncylcblxuICAgIGZpeEZyYWdtZW50OiAocmF3ZnJhZ21lbnQsIHNlY3Rpb25zKSA9PlxuICAgICAgICBmcmFnbWVudCA9IEBXTS5QYXJzZXIuc3F1YXNoQ29udGlndW91c1doaXRlc3BhY2UocmF3ZnJhZ21lbnQpLnRyaW0oKVxuXG4gICAgICAgIGlmIHNlY3Rpb25zLmluZGV4T2YoZnJhZ21lbnQpIDwgMFxuICAgICAgICAgICAgZm9yIHNlY3Rpb24gaW4gc2VjdGlvbnNcbiAgICAgICAgICAgICAgICBkb3RTZWN0aW9uID0gQFdNLlBhcnNlci5kb3RFbmNvZGUoc2VjdGlvbilcbiAgICAgICAgICAgICAgICBkb3RGcmFnbWVudCA9IEBXTS5QYXJzZXIuZG90RW5jb2RlKGZyYWdtZW50KVxuXG4gICAgICAgICAgICAgICAgaWYgZG90U2VjdGlvbi50b0xvd2VyQ2FzZSgpID09IGRvdEZyYWdtZW50LnRvTG93ZXJDYXNlKClcbiAgICAgICAgICAgICAgICAgICAgaWYgZnJhZ21lbnQgPT0gZG90RnJhZ21lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICMgSWYgdGhlIGZyYWdtZW50IHdhcyBlbmNvZGVkLCByZS1lbmNvZGUgaXQgYmVjYXVzZSBpdFxuICAgICAgICAgICAgICAgICAgICAgICAgIyBjb3VsZCBjb250YWluIGxpbmstYnJlYWtpbmcgY2hhcmFjdGVycyAoZS5nLiBbXXx7fSlcbiAgICAgICAgICAgICAgICAgICAgICAgICMgVGhlIGNvbmRpdGlvbiB3b3VsZCBhbHNvIGJlIHRydWUgaWYgdGhlIGZyYWdtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAjIGRvZXNuJ3QgY29udGFpbiBhbnkgZW5jb2RhYmxlIGNoYXJhY3RlcnMsIGJ1dCBzaW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgIyBzZWN0aW9uIGFuZCBmcmFnbWVudCBhdCBtb3N0IGRpZmZlciBieVxuICAgICAgICAgICAgICAgICAgICAgICAgIyBjYXBpdGFsaXphdGlvbiwgZW5jb2RpbmcgdGhlIHNlY3Rpb24gd29uJ3QgaGF2ZSBhbnlcbiAgICAgICAgICAgICAgICAgICAgICAgICMgZWZmZWN0XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZG90U2VjdGlvblxuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAjIElmIHRoZSBmcmFnbWVudCB3YXMgbm90IGVuY29kZWQsIGlmIHRoZSBmcmFnbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgIyBjb250YWluZWQgbGluay1icmVha2luZyBjaGFyYWN0ZXJzIHRoZSBsaW5rIHdhc1xuICAgICAgICAgICAgICAgICAgICAgICAgIyBhbHJlYWR5IGJyb2tlbiwgYW5kIHJlcGxhY2luZyBpdCB3aXRoIHNlY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICMgd291bGRuJ3QgbWFrZSB0aGluZ3Mgd29yc2U7IGlmIHRoZSBmcmFnbWVudCBkaWRuJ3RcbiAgICAgICAgICAgICAgICAgICAgICAgICMgY29udGFpbiBsaW5rLWJyZWFraW5nIGNoYXJhY3RlcnMsIHRoZSBzZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAjIGRvZXNuJ3QgZWl0aGVyLCBzaW5jZSBzZWN0aW9uIGFuZCBmcmFnbWVudCBhdCBtb3N0XG4gICAgICAgICAgICAgICAgICAgICAgICAjIGRpZmZlciBieSBjYXBpdGFsaXphdGlvbiwgc28gaXQncyBzYWZlIHRvIHJlcGxhY2UgaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICMgSWYgdGhlIGZyYWdtZW50IHdhcyAqcGFydGlhbGx5KiBlbmNvZGVkIGluc3RlYWQsIGFcbiAgICAgICAgICAgICAgICAgICAgICAgICMgbGluay1icmVha2luZyBjaGFyYWN0ZXIgbWF5IGhhdmUgYmVlbiBlbmNvZGVkLCBzb1xuICAgICAgICAgICAgICAgICAgICAgICAgIyBhbGwgbGluay1icmVha2luZyBjaGFyYWN0ZXJzIG11c3QgYmUgcmUtZW5jb2RlZFxuICAgICAgICAgICAgICAgICAgICAgICAgIyBoZXJlIVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEBXTS5QYXJzZXIuZG90RW5jb2RlTGlua0JyZWFraW5nRnJhZ21lbnRDaGFyYWN0ZXJzKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWN0aW9uKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG5cbiAgICBmaW5kQXJjaFdpa2lMaW5rczogKG5ld1RleHQsIGl3cHJlZml4ZXMsIGNhbGxBcmdzKSA9PlxuICAgICAgICB0ZW1wbGF0ZXMgPSBAV00uUGFyc2VyLmZpbmRUZW1wbGF0ZXMobmV3VGV4dCwgJ1JlbGF0ZWQnKVxuICAgICAgICB0aXRsZSA9IEBXTS5FZGl0b3IuZ2V0VGl0bGUoKVxuICAgICAgICBAcHJvY2Vzc0FyY2hXaWtpTGluayh0aXRsZSwgaXdwcmVmaXhlcywgdGVtcGxhdGVzLCAxLCAwLFxuICAgICAgICAgICAgICAgICAgICBuZXdUZXh0LCBcIlwiLCAwLFxuICAgICAgICAgICAgICAgICAgICBAZmluZEFyY2hXaWtpTGlua3MyLCBjYWxsQXJncylcblxuICAgIGZpbmRBcmNoV2lraUxpbmtzMjogKG5ld1RleHQsIGl3cHJlZml4ZXMsIGNhbGxBcmdzKSA9PlxuICAgICAgICB0ZW1wbGF0ZXMgPSBAV00uUGFyc2VyLmZpbmRUZW1wbGF0ZXMobmV3VGV4dCwgJ1JlbGF0ZWQyJylcbiAgICAgICAgdGl0bGUgPSBAV00uRWRpdG9yLmdldFRpdGxlKClcbiAgICAgICAgQHByb2Nlc3NBcmNoV2lraUxpbmsodGl0bGUsIGl3cHJlZml4ZXMsIHRlbXBsYXRlcywgMiwgMCxcbiAgICAgICAgICAgICAgICBuZXdUZXh0LCBcIlwiLCAwLCBAbWFpbkVuZCwgY2FsbEFyZ3MpXG5cbiAgICBwcm9jZXNzQXJjaFdpa2lMaW5rOiAodGl0bGUsIGl3cHJlZml4ZXMsIHRlbXBsYXRlcywgZXhwZWN0ZWRBcmdzLCBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZSwgbmV3VGV4dCwgcHJldklkLCBjYWxsLCBjYWxsQXJncykgPT5cbiAgICAgICAgaWYgdGVtcGxhdGVzW2luZGV4XVxuICAgICAgICAgICAgdGVtcGxhdGUgPSB0ZW1wbGF0ZXNbaW5kZXhdXG4gICAgICAgICAgICBhcmdzID0gdGVtcGxhdGUuYXJndW1lbnRzXG5cbiAgICAgICAgICAgICMgRG9uJ3QgY3Jhc2ggaW4gY2FzZSBvZiBtYWxmb3JtZWQgdGVtcGxhdGVzXG4gICAgICAgICAgICBpZiBhcmdzLmxlbmd0aCA9PSBleHBlY3RlZEFyZ3NcbiAgICAgICAgICAgICAgICBsaW5rID0gYXJnc1swXS52YWx1ZVxuICAgICAgICAgICAgICAgIGZyYWdJZCA9IGxpbmsuaW5kZXhPZignIycpXG5cbiAgICAgICAgICAgICAgICBpZiBmcmFnSWQgPiAtMVxuICAgICAgICAgICAgICAgICAgICByYXd0YXJnZXQgPSBsaW5rLnN1YnN0cmluZygwLCBmcmFnSWQpXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldCA9IEBXTS5QYXJzZXIuc3F1YXNoQ29udGlndW91c1doaXRlc3BhY2UocmF3dGFyZ2V0KS50cmltKClcbiAgICAgICAgICAgICAgICAgICAgcmF3ZnJhZ21lbnQgPSBsaW5rLnN1YnN0cihmcmFnSWQgKyAxKVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIHJhd2ZyYWdtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAjIE5vdGUgdGhhdCBpdCdzIGltcG9zc2libGUgdG8gcmVjb2duaXplIGFueVxuICAgICAgICAgICAgICAgICAgICAgICAgIyAgIG5hbWVzcGFjZXMgaW4gdGhlIHRpdGxlIHdpdGhvdXQgcXVlcnlpbmcgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAjICAgc2VydmVyXG4gICAgICAgICAgICAgICAgICAgICAgICAjIEFsdGVybmF0aXZlbHksIGEgbGlzdCBvZiB0aGUga25vd24gbmFtZXNwYWNlcyBjb3VsZFxuICAgICAgICAgICAgICAgICAgICAgICAgIyAgIGJlIG1haW50YWluZWQgZm9yIGVhY2ggd2lraVxuICAgICAgICAgICAgICAgICAgICAgICAgIyBSZWNvZ25pemluZyBuYW1lc3BhY2VzIHdvdWxkIGxldCByZWNvZ25pemUgbW9yZVxuICAgICAgICAgICAgICAgICAgICAgICAgIyAgIGxpYmVyYWwgbGluayBzeW50YXhlcyAoZS5nLiBzcGFjZXMgYXJvdW5kIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgIyAgIGNvbG9uKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgbm90IEBXTS5QYXJzZXIuY29tcGFyZUFydGljbGVUaXRsZXModGFyZ2V0LCB0aXRsZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBAV00uTG9nLmxvZ0luZm8oXCJQcm9jZXNzaW5nIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBAV00uTG9nLmxpbmtUb1dpa2lQYWdlKGxpbmssXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGUucmF3VHJhbnNjbHVzaW9uKSArIFwiIC4uLlwiKVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2FjdGlvbic6ICdwYXJzZSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3Byb3AnOiAnc2VjdGlvbnMnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdwYWdlJzogdGFyZ2V0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdyZWRpcmVjdHMnOiAxXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBAV00uTVcuY2FsbEFQSUdldChwYXJhbXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBAcHJvY2Vzc0FyY2hXaWtpTGlua0NvbnRpbnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3RlbXBsYXRlLCB0YXJnZXQsIHJhd2ZyYWdtZW50LCBpd3ByZWZpeGVzLCB0ZW1wbGF0ZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZEFyZ3MsIGluZGV4LCBzb3VyY2UsIG5ld1RleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2SWQsIHRpdGxlLCBjYWxsLCBjYWxsQXJnc10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4KytcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBAcHJvY2Vzc0FyY2hXaWtpTGluayhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlLCBpd3ByZWZpeGVzLCB0ZW1wbGF0ZXMsIGV4cGVjdGVkQXJncywgaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2UsIG5ld1RleHQsIHByZXZJZCwgY2FsbCwgY2FsbEFyZ3MpXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4KytcbiAgICAgICAgICAgICAgICAgICAgICAgIEBwcm9jZXNzQXJjaFdpa2lMaW5rKHRpdGxlLCBpd3ByZWZpeGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlcywgZXhwZWN0ZWRBcmdzLCBpbmRleCwgc291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1RleHQsIHByZXZJZCwgY2FsbCwgY2FsbEFyZ3MpXG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBpbmRleCsrXG4gICAgICAgICAgICAgICAgICAgIEBwcm9jZXNzQXJjaFdpa2lMaW5rKHRpdGxlLCBpd3ByZWZpeGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlcywgZXhwZWN0ZWRBcmdzLCBpbmRleCwgc291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1RleHQsIHByZXZJZCwgY2FsbCwgY2FsbEFyZ3MpXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgQFdNLkxvZy5sb2dXYXJuaW5nKFwiVGVtcGxhdGU6XCIgKyB0ZW1wbGF0ZS50aXRsZSArXG4gICAgICAgICAgICAgICAgICAgICAgICBcIiBtdXN0IGhhdmUgXCIgKyBleHBlY3RlZEFyZ3MgKyBcIiBhbmQgb25seSBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZEFyZ3MgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKGlmIGV4cGVjdGVkQXJncyA+IDEgdGhlbiBcIiBhcmd1bWVudHM6IFwiIGVsc2UgXCIgYXJndW1lbnQ6IFwiKSArXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZS5yYXdUcmFuc2NsdXNpb24pXG4gICAgICAgICAgICAgICAgaW5kZXgrK1xuICAgICAgICAgICAgICAgIEBwcm9jZXNzQXJjaFdpa2lMaW5rKHRpdGxlLCBpd3ByZWZpeGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlcywgZXhwZWN0ZWRBcmdzLCBpbmRleCwgc291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1RleHQsIHByZXZJZCwgY2FsbCwgY2FsbEFyZ3MpXG5cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgbmV3VGV4dCArPSBzb3VyY2Uuc3Vic3RyKHByZXZJZClcbiAgICAgICAgICAgIGNhbGwobmV3VGV4dCwgaXdwcmVmaXhlcywgY2FsbEFyZ3MpXG5cbiAgICBwcm9jZXNzQXJjaFdpa2lMaW5rQ29udGludWU6IChyZXMsIGFyZ3MpID0+XG4gICAgICAgIHRlbXBsYXRlID0gYXJnc1swXVxuICAgICAgICB0YXJnZXQgPSBhcmdzWzFdXG4gICAgICAgIHJhd2ZyYWdtZW50ID0gYXJnc1syXVxuICAgICAgICBpd3ByZWZpeGVzID0gYXJnc1szXVxuICAgICAgICB0ZW1wbGF0ZXMgPSBhcmdzWzRdXG4gICAgICAgIGV4cGVjdGVkQXJncyA9IGFyZ3NbNV1cbiAgICAgICAgaW5kZXggPSBhcmdzWzZdXG4gICAgICAgIHNvdXJjZSA9IGFyZ3NbN11cbiAgICAgICAgbmV3VGV4dCA9IGFyZ3NbOF1cbiAgICAgICAgcHJldklkID0gYXJnc1s5XVxuICAgICAgICB0aXRsZSA9IGFyZ3NbMTBdXG4gICAgICAgIGNhbGwgPSBhcmdzWzExXVxuICAgICAgICBjYWxsQXJncyA9IGFyZ3NbMTJdXG5cbiAgICAgICAgIyBDaGVjayB0aGF0IHRoZSBwYWdlIGlzIGluIHRoZSB3aWtpIChlLmcuIGl0J3Mgbm90IGFuIGludGVyd2lraSBsaW5rKVxuICAgICAgICBpZiByZXMucGFyc2VcbiAgICAgICAgICAgIHNlY3Rpb25zID0gW11cblxuICAgICAgICAgICAgZm9yIHNlY3Rpb24gaW4gcmVzLnBhcnNlLnNlY3Rpb25zXG4gICAgICAgICAgICAgICAgc2VjdGlvbnMucHVzaChAV00uUGFyc2VyLnNxdWFzaENvbnRpZ3VvdXNXaGl0ZXNwYWNlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlY3Rpb24ubGluZSkudHJpbSgpKVxuXG4gICAgICAgICAgICBmaXhlZEZyYWdtZW50ID0gQGZpeEZyYWdtZW50KHJhd2ZyYWdtZW50LCBzZWN0aW9ucylcblxuICAgICAgICAgICAgbmV3VGV4dCArPSBzb3VyY2Uuc3Vic3RyaW5nKHByZXZJZCwgdGVtcGxhdGUuaW5kZXgpXG5cbiAgICAgICAgICAgIGlmIGZpeGVkRnJhZ21lbnQgaXMgdHJ1ZVxuICAgICAgICAgICAgICAgIG5ld1RleHQgKz0gdGVtcGxhdGUucmF3VHJhbnNjbHVzaW9uXG4gICAgICAgICAgICBlbHNlIGlmIGZpeGVkRnJhZ21lbnRcbiAgICAgICAgICAgICAgICBhbmNob3IgPSBpZiB0ZW1wbGF0ZS5hcmd1bWVudHNbMV0gdGhlbiAoXCJ8XCIgKyB0ZW1wbGF0ZS5hcmd1bWVudHNbMV0udmFsdWUpIGVsc2UgXCJcIlxuICAgICAgICAgICAgICAgIG5ld1RleHQgKz0gXCJ7e1wiICsgdGVtcGxhdGUudGl0bGUgKyBcInxcIiArIHRhcmdldCArIFwiI1wiICsgZml4ZWRGcmFnbWVudCAgKyBhbmNob3IgKyBcIn19XCJcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBAV00uTG9nLmxvZ1dhcm5pbmcoXCJDYW5ub3QgZml4IGJyb2tlbiBsaW5rIGZyYWdtZW50OiBcIiArXG4gICAgICAgICAgICAgICAgICAgIEBXTS5Mb2cubGlua1RvV2lraVBhZ2UodGFyZ2V0LCB0ZW1wbGF0ZS5yYXdUcmFuc2NsdXNpb24pKVxuICAgICAgICAgICAgICAgIG5ld1RleHQgKz0gdGVtcGxhdGUucmF3VHJhbnNjbHVzaW9uXG5cbiAgICAgICAgICAgIHByZXZJZCA9IHRlbXBsYXRlLmluZGV4ICsgdGVtcGxhdGUubGVuZ3RoXG5cbiAgICAgICAgaW5kZXgrK1xuICAgICAgICBAcHJvY2Vzc0FyY2hXaWtpTGluayh0aXRsZSwgaXdwcmVmaXhlcywgdGVtcGxhdGVzLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkQXJncywgaW5kZXgsIHNvdXJjZSwgbmV3VGV4dCwgcHJldklkLCBjYWxsLCBjYWxsQXJncylcblxuICAgIG1haW5fZWRpdG9yOiAoY2FsbE5leHQpIC0+XG4gICAgICAgIHNvdXJjZSA9IEBXTS5FZGl0b3IucmVhZFNvdXJjZSgpXG4gICAgICAgIEBXTS5Mb2cubG9nSW5mbyhcIkZpeGluZyBsaW5rcyB0byBzZWN0aW9ucyBvZiBvdGhlciBhcnRpY2xlcyAuLi5cIilcbiAgICAgICAgdGl0bGUgPSBAV00uRWRpdG9yLmdldFRpdGxlKClcbiAgICAgICAgcmVzID0gYXdhaXQgQFdNLk1XLmdldEludGVyd2lraU1hcCh0aXRsZSlcbiAgICAgICAgaXdwcmVmaXhlcyA9IChpdy5wcmVmaXggZm9yIGl3IGluIHJlcy5xdWVyeS5pbnRlcndpa2ltYXApXG4gICAgICAgIGxpbmtzID0gQFdNLlBhcnNlci5maW5kSW50ZXJuYWxMaW5rcyhzb3VyY2UsIG51bGwsIG51bGwpXG4gICAgICAgIEBwcm9jZXNzTGluayh0aXRsZSwgaXdwcmVmaXhlcywgbGlua3MsIDAsIHNvdXJjZSwgXCJcIiwgMCxcbiAgICAgICAgICAgICAgICAgICAgIEBtYWluQ29udGludWUsIGNhbGxOZXh0KVxuXG4gICAgbWFpbkNvbnRpbnVlOiAobmV3VGV4dCwgaXdwcmVmaXhlcywgY2FsbE5leHQpID0+XG4gICAgICAgICMgV2l0aG91dCB0aGlzIGNoZWNrIHRoaXMgcGx1Z2luIHdvdWxkIGJlIHNwZWNpZmljIHRvIEFyY2hXaWtpXG4gICAgICAgIGlmIGxvY2F0aW9uLmhvc3RuYW1lID09ICd3aWtpLmFyY2hsaW51eC5vcmcnXG4gICAgICAgICAgICB0ZW1wbGF0ZXMgPSBAZmluZEFyY2hXaWtpTGlua3MobmV3VGV4dCwgaXdwcmVmaXhlcywgY2FsbE5leHQpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIEBtYWluRW5kKG5ld1RleHQsIGl3cHJlZml4ZXMsIGNhbGxOZXh0KVxuXG4gICAgbWFpbkVuZDogKG5ld1RleHQsIGl3cHJlZml4ZXMsIGNhbGxOZXh0KSA9PlxuICAgICAgICBzb3VyY2UgPSBAV00uRWRpdG9yLnJlYWRTb3VyY2UoKVxuXG4gICAgICAgIGlmIG5ld1RleHQgIT0gc291cmNlXG4gICAgICAgICAgICBAV00uRWRpdG9yLndyaXRlU291cmNlKG5ld1RleHQpXG4gICAgICAgICAgICBAV00uTG9nLmxvZ0luZm8oXCJSZXBsYWNlZCBsaW5rcyB0byBzZWN0aW9ucyBvZiBvdGhlciBhcnRpY2xlc1wiKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICBAV00uTG9nLmxvZ0luZm8oXCJObyBmaXhhYmxlIGxpbmtzIHRvIHNlY3Rpb25zIG9mIG90aGVyIGFydGljbGVzIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJmb3VuZFwiKVxuXG4gICAgICAgIGlmIGNhbGxOZXh0XG4gICAgICAgICAgICBjYWxsTmV4dCgpXG4iLCIjIFdpa2kgTW9ua2V5IC0gTWVkaWFXaWtpIGJvdCBhbmQgZWRpdG9yLWFzc2lzdGFudCB1c2VyIHNjcmlwdFxuIyBDb3B5cmlnaHQgKEMpIDIwMTEgRGFyaW8gR2lvdmFubmV0dGkgPGRldkBkYXJpb2dpb3Zhbm5ldHRpLm5ldD5cbiNcbiMgVGhpcyBmaWxlIGlzIHBhcnQgb2YgV2lraSBNb25rZXkuXG4jXG4jIFdpa2kgTW9ua2V5IGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiMgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiMgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiMgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbiNcbiMgV2lraSBNb25rZXkgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiMgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiMgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuIyBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuI1xuIyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuIyBhbG9uZyB3aXRoIFdpa2kgTW9ua2V5LiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuXG57UGx1Z2lufSA9IHJlcXVpcmUoJy4vX1BsdWdpbicpXG5cblxuY2xhc3MgbW9kdWxlLmV4cG9ydHMuTXVsdGlwbGVMaW5lQnJlYWtzIGV4dGVuZHMgUGx1Z2luXG4gICAgQGNvbmZfZGVmYXVsdDpcbiAgICAgICAgZW5hYmxlZDogdHJ1ZVxuICAgICAgICBlZGl0b3JfbWVudTogW1wiVGV4dCBwbHVnaW5zXCIsIFwiU3F1YXNoIG11bHRpcGxlIGxpbmUgYnJlYWtzXCJdXG5cbiAgICBtYWluX2VkaXRvcjogKGNhbGxOZXh0KSAtPlxuICAgICAgICBzb3VyY2UgPSBAV00uRWRpdG9yLnJlYWRTb3VyY2UoKVxuICAgICAgICBuZXd0ZXh0ID0gc291cmNlXG5cbiAgICAgICAgbmV3dGV4dCA9IG5ld3RleHQucmVwbGFjZSgvW1xcbl17Myx9L2csICdcXG5cXG4nKVxuXG4gICAgICAgIGlmIG5ld3RleHQgIT0gc291cmNlXG4gICAgICAgICAgICBAV00uRWRpdG9yLndyaXRlU291cmNlKG5ld3RleHQpXG4gICAgICAgICAgICBAV00uTG9nLmxvZ0luZm8oXCJSZW1vdmVkIG11bHRpcGxlIGxpbmUgYnJlYWtzXCIpXG5cbiAgICAgICAgaWYgY2FsbE5leHRcbiAgICAgICAgICAgIGNhbGxOZXh0KClcbiIsIiMgV2lraSBNb25rZXkgLSBNZWRpYVdpa2kgYm90IGFuZCBlZGl0b3ItYXNzaXN0YW50IHVzZXIgc2NyaXB0XG4jIENvcHlyaWdodCAoQykgMjAxMSBEYXJpbyBHaW92YW5uZXR0aSA8ZGV2QGRhcmlvZ2lvdmFubmV0dGkubmV0PlxuI1xuIyBUaGlzIGZpbGUgaXMgcGFydCBvZiBXaWtpIE1vbmtleS5cbiNcbiMgV2lraSBNb25rZXkgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuIyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuIyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuIyAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuI1xuIyBXaWtpIE1vbmtleSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuIyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuIyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4jIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4jXG4jIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4jIGFsb25nIHdpdGggV2lraSBNb25rZXkuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG5cbntQbHVnaW59ID0gcmVxdWlyZSgnLi9fUGx1Z2luJylcblxuQ1NTID0gcmVxdWlyZSgnQGt5bmlrb3MvbWlzYy9kaXN0L0NTUycpXG5cblxuY2xhc3MgbW9kdWxlLmV4cG9ydHMuU2ltcGxlUmVwbGFjZSBleHRlbmRzIFBsdWdpblxuICAgIEBjb25mX2RlZmF1bHQ6XG4gICAgICAgIGVuYWJsZWQ6IHRydWVcbiAgICAgICAgZWRpdG9yX21lbnU6IFtcIlJlZ0V4cCBzdWJzdGl0dXRpb25cIl1cbiAgICAgICAgYm90X2xhYmVsOiBcIlJlZ0V4cCBzdWJzdGl0dXRpb25cIlxuXG4gICAgbWFrZVVJID0gLT5cbiAgICAgICAgQ1NTLmFkZFN0eWxlRWxlbWVudChcIiNXaWtpTW9ua2V5LVNpbXBsZVJlcGxhY2UgZGl2IFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwie21hcmdpbi1ib3R0b206MC4zM2VtO30gXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiI1dpa2lNb25rZXktU2ltcGxlUmVwbGFjZSBpbnB1dFt0eXBlPSd0ZXh0J10gXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwie21hcmdpbi1sZWZ0OjAuMzNlbTsgd2lkdGg6NjAlO31cIilcblxuICAgICAgICBkaXZNYWluID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICAgICAgZGl2TWFpbi5pZCA9IFwiV2lraU1vbmtleS1TaW1wbGVSZXBsYWNlXCJcblxuICAgICAgICBwYXIxID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcblxuICAgICAgICByZWdleHBMYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKVxuICAgICAgICByZWdleHBMYWJlbC5pbm5lckhUTUwgPSAnUmVnRXhwIHBhdHRlcm46J1xuXG4gICAgICAgIHJlZ2V4cCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0JylcbiAgICAgICAgcmVnZXhwLnNldEF0dHJpYnV0ZSgndHlwZScsICd0ZXh0JylcbiAgICAgICAgcmVnZXhwLmlkID0gXCJXaWtpTW9ua2V5LVNpbXBsZVJlcGxhY2UtUmVnRXhwXCJcblxuICAgICAgICBpZ25vcmVDYXNlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKVxuICAgICAgICBpZ25vcmVDYXNlLnNldEF0dHJpYnV0ZSgndHlwZScsICdjaGVja2JveCcpXG4gICAgICAgIGlnbm9yZUNhc2UuaWQgPSBcIldpa2lNb25rZXktU2ltcGxlUmVwbGFjZS1JZ25vcmVDYXNlXCJcblxuICAgICAgICBpZ25vcmVDYXNlTGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJylcbiAgICAgICAgaWdub3JlQ2FzZUxhYmVsLmlubmVySFRNTCA9ICdpJ1xuXG4gICAgICAgIHBhcjEuYXBwZW5kQ2hpbGQocmVnZXhwTGFiZWwpXG4gICAgICAgIHBhcjEuYXBwZW5kQ2hpbGQocmVnZXhwKVxuICAgICAgICBwYXIxLmFwcGVuZENoaWxkKGlnbm9yZUNhc2UpXG4gICAgICAgIHBhcjEuYXBwZW5kQ2hpbGQoaWdub3JlQ2FzZUxhYmVsKVxuXG4gICAgICAgIHBhcjIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuXG4gICAgICAgIG5ld1N0cmluZ0xhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpXG4gICAgICAgIG5ld1N0cmluZ0xhYmVsLmlubmVySFRNTCA9ICdOZXcgc3RyaW5nOidcblxuICAgICAgICBuZXdTdHJpbmcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpXG4gICAgICAgIG5ld1N0cmluZy5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAndGV4dCcpXG4gICAgICAgIG5ld1N0cmluZy5pZCA9IFwiV2lraU1vbmtleS1TaW1wbGVSZXBsYWNlLU5ld1N0cmluZ1wiXG5cbiAgICAgICAgcGFyMi5hcHBlbmRDaGlsZChuZXdTdHJpbmdMYWJlbClcbiAgICAgICAgcGFyMi5hcHBlbmRDaGlsZChuZXdTdHJpbmcpXG5cbiAgICAgICAgZGl2TWFpbi5hcHBlbmRDaGlsZChwYXIxKVxuICAgICAgICBkaXZNYWluLmFwcGVuZENoaWxkKHBhcjIpXG5cbiAgICAgICAgcmV0dXJuIGRpdk1haW5cblxuICAgIG1ha2VVSTogLT5cbiAgICAgICAgcmV0dXJuIG1ha2VVSSgpXG5cbiAgICBtYWtlQm90VUk6IC0+XG4gICAgICAgIGRpdk1haW4gPSBtYWtlVUkoKVxuICAgICAgICBwYXIzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcblxuICAgICAgICBzdW1tYXJ5TGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJylcbiAgICAgICAgc3VtbWFyeUxhYmVsLmlubmVySFRNTCA9ICdFZGl0IHN1bW1hcnk6J1xuXG4gICAgICAgIHN1bW1hcnkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpXG4gICAgICAgIHN1bW1hcnkuc2V0QXR0cmlidXRlKCd0eXBlJywgJ3RleHQnKVxuICAgICAgICBzdW1tYXJ5LmlkID0gXCJXaWtpTW9ua2V5LVNpbXBsZVJlcGxhY2UtU3VtbWFyeVwiXG5cbiAgICAgICAgcGFyMy5hcHBlbmRDaGlsZChzdW1tYXJ5TGFiZWwpXG4gICAgICAgIHBhcjMuYXBwZW5kQ2hpbGQoc3VtbWFyeSlcblxuICAgICAgICBkaXZNYWluLmFwcGVuZENoaWxkKHBhcjMpXG5cbiAgICAgICAgcmV0dXJuIGRpdk1haW5cblxuICAgIGNvbmZpZ3VyYXRpb24gPSBudWxsXG5cbiAgICBzdG9yZUNvbmZpZ3VyYXRpb246ID0+XG4gICAgICAgIGNvbmZpZ3VyYXRpb24gPVxuICAgICAgICAgICAgcGF0dGVybjogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiV2lraU1vbmtleS1TaW1wbGVSZXBsYWNlLVJlZ0V4cFwiKS52YWx1ZVxuICAgICAgICAgICAgaWdub3JlQ2FzZTogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiV2lraU1vbmtleS1TaW1wbGVSZXBsYWNlLUlnbm9yZUNhc2VcIikuY2hlY2tlZFxuICAgICAgICAgICAgbmV3U3RyaW5nOiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJXaWtpTW9ua2V5LVNpbXBsZVJlcGxhY2UtTmV3U3RyaW5nXCIpLnZhbHVlXG5cbiAgICAgICAgQFdNLkxvZy5sb2dIaWRkZW4oXCJQYXR0ZXJuOiBcIiArIGNvbmZpZ3VyYXRpb24ucGF0dGVybilcbiAgICAgICAgQFdNLkxvZy5sb2dIaWRkZW4oXCJJZ25vcmUgY2FzZTogXCIgKyBjb25maWd1cmF0aW9uLmlnbm9yZUNhc2UpXG4gICAgICAgIEBXTS5Mb2cubG9nSGlkZGVuKFwiTmV3IHN0cmluZzogXCIgKyBjb25maWd1cmF0aW9uLm5ld1N0cmluZylcblxuICAgIHN0b3JlUmVnRXhwID0gLT5cbiAgICAgICAgY29uZmlndXJhdGlvbi5yZWdFeHAgPSBuZXcgUmVnRXhwKGNvbmZpZ3VyYXRpb24ucGF0dGVybixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiZ1wiICsgKGlmIGNvbmZpZ3VyYXRpb24uaWdub3JlQ2FzZSB0aGVuIFwiaVwiIGVsc2UgXCJcIikpXG5cbiAgICBtYWluX2VkaXRvcjogKGNhbGxOZXh0KSAtPlxuICAgICAgICBAc3RvcmVDb25maWd1cmF0aW9uKClcblxuICAgICAgICB0cnlcbiAgICAgICAgICAgIHN0b3JlUmVnRXhwKClcbiAgICAgICAgY2F0Y2ggZXhjXG4gICAgICAgICAgICBAV00uTG9nLmxvZ0Vycm9yKFwiSW52YWxpZCBwYXR0ZXJuOiBcIiArIGV4YylcbiAgICAgICAgICAgICMgQmxvY2sgdGhlIGV4ZWN1dGlvbiBvZiB0aGlzIGZ1bmN0aW9uXG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcblxuICAgICAgICBzb3VyY2UgPSBAV00uRWRpdG9yLnJlYWRTb3VyY2UoKVxuICAgICAgICBuZXd0ZXh0ID0gc291cmNlLnJlcGxhY2UoY29uZmlndXJhdGlvbi5yZWdFeHAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhdGlvbi5uZXdTdHJpbmcpXG5cbiAgICAgICAgaWYgbmV3dGV4dCAhPSBzb3VyY2VcbiAgICAgICAgICAgIEBXTS5FZGl0b3Iud3JpdGVTb3VyY2UobmV3dGV4dClcbiAgICAgICAgICAgIEBXTS5Mb2cubG9nSW5mbyhcIlRleHQgc3Vic3RpdHV0ZWRcIilcblxuICAgICAgICBpZiBjYWxsTmV4dFxuICAgICAgICAgICAgY2FsbE5leHQoKVxuXG4gICAgbWFpbl9ib3Q6ICh0aXRsZSwgY2FsbEJvdCwgY2hhaW5BcmdzKSAtPlxuICAgICAgICBAc3RvcmVDb25maWd1cmF0aW9uKClcblxuICAgICAgICB0cnlcbiAgICAgICAgICAgIHN0b3JlUmVnRXhwKClcbiAgICAgICAgY2F0Y2ggZXhjXG4gICAgICAgICAgICBAV00uTG9nLmxvZ0Vycm9yKFwiSW52YWxpZCBwYXR0ZXJuOiBcIiArIGV4YylcbiAgICAgICAgICAgIGNhbGxCb3QoZmFsc2UsIG51bGwpXG4gICAgICAgICAgICAjIEJsb2NrIHRoZSBleGVjdXRpb24gb2YgdGhpcyBmdW5jdGlvblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG5cbiAgICAgICAgc3VtbWFyeSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJXaWtpTW9ua2V5LVNpbXBsZVJlcGxhY2UtU3VtbWFyeVwiKS52YWx1ZVxuXG4gICAgICAgIGlmIHN1bW1hcnkgIT0gXCJcIlxuICAgICAgICAgICAgQFdNLk1XLmNhbGxRdWVyeUVkaXQodGl0bGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEBtYWluQXV0b1dyaXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbc3VtbWFyeSwgY2FsbEJvdF0pXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIEBXTS5Mb2cubG9nRXJyb3IoXCJUaGUgZWRpdCBzdW1tYXJ5IGNhbm5vdCBiZSBlbXB0eVwiKVxuICAgICAgICAgICAgY2FsbEJvdChmYWxzZSwgbnVsbClcblxuICAgIG1haW5BdXRvV3JpdGU6ICh0aXRsZSwgc291cmNlLCB0aW1lc3RhbXAsIGVkaXR0b2tlbiwgYXJncykgPT5cbiAgICAgICAgc3VtbWFyeSA9IGFyZ3NbMF1cbiAgICAgICAgY2FsbEJvdCA9IGFyZ3NbMV1cblxuICAgICAgICBuZXd0ZXh0ID0gc291cmNlLnJlcGxhY2UoY29uZmlndXJhdGlvbi5yZWdFeHAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhdGlvbi5uZXdTdHJpbmcpXG5cbiAgICAgICAgaWYgbmV3dGV4dCAhPSBzb3VyY2VcbiAgICAgICAgICAgIEBXTS5NVy5jYWxsQVBJUG9zdCh7YWN0aW9uOiBcImVkaXRcIiwgYm90OiBcIjFcIiwgdGl0bGU6IHRpdGxlLCBzdW1tYXJ5OiBzdW1tYXJ5LCB0ZXh0OiBuZXd0ZXh0LCBiYXNldGltZXN0YW1wOiB0aW1lc3RhbXAsIHRva2VuOiBlZGl0dG9rZW59LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEBtYWluQXV0b0VuZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsQm90LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bGwpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGNhbGxCb3QoMCwgbnVsbClcblxuICAgIG1haW5BdXRvRW5kOiAocmVzLCBjYWxsQm90KSA9PlxuICAgICAgICBpZiByZXMuZWRpdCBhbmQgcmVzLmVkaXQucmVzdWx0ID09ICdTdWNjZXNzJ1xuICAgICAgICAgICAgY2FsbEJvdCgxLCBudWxsKVxuICAgICAgICBlbHNlIGlmIHJlcy5lcnJvclxuICAgICAgICAgICAgQFdNLkxvZy5sb2dFcnJvcihyZXMuZXJyb3IuaW5mbyArIFwiIChcIiArIHJlcy5lcnJvci5jb2RlICsgXCIpXCIpXG4gICAgICAgICAgICBjYWxsQm90KHJlcy5lcnJvci5jb2RlLCBudWxsKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICBjYWxsQm90KGZhbHNlLCBudWxsKVxuIiwiIyBXaWtpIE1vbmtleSAtIE1lZGlhV2lraSBib3QgYW5kIGVkaXRvci1hc3Npc3RhbnQgdXNlciBzY3JpcHRcbiMgQ29weXJpZ2h0IChDKSAyMDExIERhcmlvIEdpb3Zhbm5ldHRpIDxkZXZAZGFyaW9naW92YW5uZXR0aS5uZXQ+XG4jXG4jIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFdpa2kgTW9ua2V5LlxuI1xuIyBXaWtpIE1vbmtleSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4jIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4jIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4jIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4jXG4jIFdpa2kgTW9ua2V5IGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4jIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4jIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiMgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbiNcbiMgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiMgYWxvbmcgd2l0aCBXaWtpIE1vbmtleS4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cblxue1BsdWdpbn0gPSByZXF1aXJlKCcuL19QbHVnaW4nKVxuXG5cbmNsYXNzIG1vZHVsZS5leHBvcnRzLlN5bmNocm9uaXplSW50ZXJsYW5ndWFnZUxpbmtzIGV4dGVuZHMgUGx1Z2luXG4gICAgQGNvbmZfZGVmYXVsdDpcbiAgICAgICAgZW5hYmxlZDogdHJ1ZVxuICAgICAgICBlZGl0b3JfbWVudTogW1wiUXVlcnkgcGx1Z2luc1wiLCBcIlN5bmMgaW50ZXJsYW5ndWFnZSBsaW5rc1wiXVxuICAgICAgICBib3RfbGFiZWw6IFwiU3luY2hyb25pemUgaW50ZXJsYW5ndWFnZSBsaW5rc1wiXG4gICAgICAgIGxhbmd1YWdlX3RhZzogXCJlblwiXG4gICAgICAgIHRhZ193aGl0ZWxpc3Q6IFtcImVuXCJdXG4gICAgICAgIHN1cHBvcnRlZF90YWdzOiBbXCJlblwiXVxuICAgICAgICBlZGl0X3N1bW1hcnk6IFwic3luY2hyb25pemVkIGludGVybGFuZ3VhZ2UgbGlua3Mgd2l0aCB0aGUgb3RoZXIgd2lraXNcIlxuICAgIEB3aWtpX3RvX2NvbmZfZGVmYXVsdDpcbiAgICAgICAgQXJjaFdpa2k6XG4gICAgICAgICAgICBsYW5ndWFnZV90YWc6IFwiQXJjaFdpa2lcIlxuICAgICAgICAgICAgdGFnX3doaXRlbGlzdDogXCJBcmNoV2lraVwiXG4gICAgICAgICAgICBzdXBwb3J0ZWRfdGFnczogXCJBcmNoV2lraVwiXG4gICAgICAgIFdpa2lwZWRpYTpcbiAgICAgICAgICAgIGVuYWJsZWQ6IGZhbHNlXG5cbiAgICBkZXRlY3RMYW5nOiAodGl0bGUsIHRhZykgPT5cbiAgICAgICAgIyBXaXRob3V0IHRoaXMgY2hlY2sgdGhpcyBwbHVnaW4gd291bGQgYmUgc3BlY2lmaWMgdG8gQXJjaFdpa2lcbiAgICAgICAgaWYgdGFnID09IFwiQXJjaFdpa2lcIlxuICAgICAgICAgICAgZGV0ZWN0ID0gQFdNLkFyY2hXaWtpLmRldGVjdExhbmd1YWdlKHRpdGxlKVxuICAgICAgICAgICAgcHVyZVRpdGxlID0gZGV0ZWN0WzBdXG4gICAgICAgICAgICB0YWcgPSBAV00uQXJjaFdpa2kuZ2V0SW50ZXJsYW5ndWFnZVRhZyhkZXRlY3RbMV0pXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHB1cmVUaXRsZSA9IHRpdGxlXG5cbiAgICAgICAgcmV0dXJuIFtwdXJlVGl0bGUsIHRhZ11cblxuICAgIGNvbXB1dGVXaGl0ZUxpc3Q6ICh3aGl0ZWxpc3QpID0+XG4gICAgICAgICMgV2l0aG91dCB0aGlzIGNoZWNrIHRoaXMgcGx1Z2luIHdvdWxkIGJlIHNwZWNpZmljIHRvIEFyY2hXaWtpXG4gICAgICAgIGlmIHdoaXRlbGlzdCA9PSBcIkFyY2hXaWtpXCJcbiAgICAgICAgICAgIHJldHVybiBAV00uQXJjaFdpa2kuZ2V0SW50ZXJuYWxJbnRlcndpa2lMYW5ndWFnZXMoKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gd2hpdGVsaXN0XG5cbiAgICBjb21wdXRlU3VwcG9ydGVkTGFuZ3M6IChzdXBwb3J0ZWRMYW5ncykgPT5cbiAgICAgICAgIyBXaXRob3V0IHRoaXMgY2hlY2sgdGhpcyBwbHVnaW4gd291bGQgYmUgc3BlY2lmaWMgdG8gQXJjaFdpa2lcbiAgICAgICAgaWYgc3VwcG9ydGVkTGFuZ3MgPT0gXCJBcmNoV2lraVwiXG4gICAgICAgICAgICByZXR1cm4gQFdNLkFyY2hXaWtpLmdldEludGVyd2lraUxhbmd1YWdlcygpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBzdXBwb3J0ZWRMYW5nc1xuXG4gICAgbWFpbl9lZGl0b3I6IChjYWxsTmV4dCkgLT5cbiAgICAgICAgdGl0bGUgPSBAV00uRWRpdG9yLmdldFRpdGxlKClcblxuICAgICAgICBkZXRlY3QgPSBAZGV0ZWN0TGFuZyh0aXRsZSwgQGNvbmYubGFuZ3VhZ2VfdGFnKVxuICAgICAgICBwdXJlVGl0bGUgPSBkZXRlY3RbMF1cbiAgICAgICAgdGFnID0gZGV0ZWN0WzFdXG5cbiAgICAgICAgd2hpdGVsaXN0ID0gQGNvbXB1dGVXaGl0ZUxpc3QoQGNvbmYudGFnX3doaXRlbGlzdClcbiAgICAgICAgc3VwcG9ydGVkTGFuZ3MgPSBAY29tcHV0ZVN1cHBvcnRlZExhbmdzKEBjb25mLnN1cHBvcnRlZF90YWdzKVxuXG4gICAgICAgIEBXTS5Mb2cubG9nSW5mbyhcIlN5bmNocm9uaXppbmcgaW50ZXJsYW5ndWFnZSBsaW5rcyAuLi5cIilcblxuICAgICAgICBAV00uTVcuZ2V0TG9jYWxJbnRlcndpa2lNYXAoXG4gICAgICAgICAgICB0aXRsZSxcbiAgICAgICAgICAgIEBtYWluQ29udGludWUsXG4gICAgICAgICAgICBbdGFnLCBwdXJlVGl0bGUsIHN1cHBvcnRlZExhbmdzLCB3aGl0ZWxpc3QsIHRpdGxlLCBjYWxsTmV4dF1cbiAgICAgICAgKVxuXG4gICAgbWFpbkNvbnRpbnVlOiAoaXdtYXAsIGFyZ3MpID0+XG4gICAgICAgIHRhZyA9IGFyZ3NbMF1cbiAgICAgICAgcHVyZVRpdGxlID0gYXJnc1sxXVxuICAgICAgICBzdXBwb3J0ZWRMYW5ncyA9IGFyZ3NbMl1cbiAgICAgICAgd2hpdGVsaXN0ID0gYXJnc1szXVxuICAgICAgICB0aXRsZSA9IGFyZ3NbNF1cbiAgICAgICAgY2FsbE5leHQgPSBhcmdzWzVdXG5cbiAgICAgICAgc291cmNlID0gQFdNLkVkaXRvci5yZWFkU291cmNlKClcblxuICAgICAgICBsYW5nbGlua3MgPSBAV00uSW50ZXJsYW5ndWFnZS5wYXJzZUxpbmtzKHN1cHBvcnRlZExhbmdzLCBzb3VyY2UsIGl3bWFwKVxuXG4gICAgICAgIHdpa2lVcmxzID0gQFdNLk1XLmdldFdpa2lVcmxzKClcbiAgICAgICAgdXJsID0gd2lraVVybHMuc2hvcnQgKyBlbmNvZGVVUklDb21wb25lbnQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEBXTS5QYXJzZXIuc3F1YXNoQ29udGlndW91c1doaXRlc3BhY2UodGl0bGUpKVxuXG4gICAgICAgIHZpc2l0ZWRsaW5rcyA9IHt9XG4gICAgICAgIHZpc2l0ZWRsaW5rc1t0YWcudG9Mb3dlckNhc2UoKV0gPSBAV00uSW50ZXJsYW5ndWFnZS5jcmVhdGVWaXNpdGVkTGluayhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFnLCBwdXJlVGl0bGUsIHVybCwgaXdtYXAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZSwgbnVsbCwgbnVsbCwgbGFuZ2xpbmtzKVxuXG4gICAgICAgIG5ld2xpbmtzID0ge31cblxuICAgICAgICBAV00uTG9nLmxvZ0luZm8oXCJSZWFkaW5nIFwiICsgQFdNLkxvZy5saW5rVG9QYWdlKHVybCwgXCJlZGl0ZWQgYXJ0aWNsZVwiKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiIC4uLlwiKVxuXG4gICAgICAgIGlmIGxhbmdsaW5rc1xuICAgICAgICAgICAgZm9yIGxpbmsgaW4gbGFuZ2xpbmtzXG4gICAgICAgICAgICAgICAgbmxpbmsgPSBuZXdsaW5rc1tsaW5rLmxhbmcudG9Mb3dlckNhc2UoKV1cbiAgICAgICAgICAgICAgICB2bGluayA9IHZpc2l0ZWRsaW5rc1tsaW5rLmxhbmcudG9Mb3dlckNhc2UoKV1cblxuICAgICAgICAgICAgICAgIGlmIG5vdCB2bGluayBhbmQgbm90IG5saW5rXG4gICAgICAgICAgICAgICAgICAgIG5ld2xpbmtzW2xpbmsubGFuZy50b0xvd2VyQ2FzZSgpXSA9IEBXTS5JbnRlcmxhbmd1YWdlLmNyZWF0ZU5ld0xpbmsoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmsubGFuZywgbGluay50aXRsZSwgbGluay51cmwpXG4gICAgICAgICAgICAgICAgZWxzZSBpZiB2bGluayBhbmQgdmxpbmsudXJsICE9IGxpbmsudXJsXG4gICAgICAgICAgICAgICAgICAgICMgSnVzdCBpZ25vcmUgYW55IGNvbmZsaWN0aW5nIGxpbmtzIGFuZCB3YXJuIHRoZSB1c2VyOlxuICAgICAgICAgICAgICAgICAgICAjIGlmIGl0J3MgYSByZWFsIGNvbmZsaWN0LCB0aGUgdXNlciB3aWxsIGludmVzdGlnYXRlIGl0LFxuICAgICAgICAgICAgICAgICAgICAjIG90aGVyd2lzZSB0aGUgdXNlciB3aWxsIGlnbm9yZSBpdFxuICAgICAgICAgICAgICAgICAgICBAV00uTG9nLmxvZ1dhcm5pbmcoXCJQb3NzaWJseSBjb25mbGljdGluZyBpbnRlcmxhbmd1YWdlIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwibGlua3M6IFwiICsgQFdNLkxvZy5saW5rVG9QYWdlKGxpbmsudXJsLCBcIltbXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgbGluay5sYW5nICsgXCI6XCIgKyBsaW5rLnRpdGxlICsgXCJdXVwiKSArIFwiIGFuZCBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICBAV00uTG9nLmxpbmtUb1BhZ2UodmxpbmsudXJsLCBcIltbXCIgKyBsaW5rLmxhbmcgKyBcIjpcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICB2aXNpdGVkbGlua3NbbGluay5sYW5nLnRvTG93ZXJDYXNlKCldLnRpdGxlICsgXCJdXVwiKSlcbiAgICAgICAgICAgICAgICBlbHNlIGlmIG5saW5rIGFuZCBubGluay51cmwgIT0gbGluay51cmxcbiAgICAgICAgICAgICAgICAgICAgIyBKdXN0IGlnbm9yZSBhbnkgY29uZmxpY3RpbmcgbGlua3MgYW5kIHdhcm4gdGhlIHVzZXI6XG4gICAgICAgICAgICAgICAgICAgICMgaWYgaXQncyBhIHJlYWwgY29uZmxpY3QsIHRoZSB1c2VyIHdpbGwgaW52ZXN0aWdhdGUgaXQsXG4gICAgICAgICAgICAgICAgICAgICMgb3RoZXJ3aXNlIHRoZSB1c2VyIHdpbGwgaWdub3JlIGl0XG4gICAgICAgICAgICAgICAgICAgIEBXTS5Mb2cubG9nV2FybmluZyhcIlBvc3NpYmx5IGNvbmZsaWN0aW5nIGludGVybGFuZ3VhZ2UgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJsaW5rczogXCIgKyBAV00uTG9nLmxpbmtUb1BhZ2UobGluay51cmwsIFwiW1tcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rLmxhbmcgKyBcIjpcIiArIGxpbmsudGl0bGUgKyBcIl1dXCIpICsgXCIgYW5kIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIEBXTS5Mb2cubGlua1RvUGFnZShubGluay51cmwsIFwiW1tcIiArIGxpbmsubGFuZyArIFwiOlwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld2xpbmtzW2xpbmsubGFuZy50b0xvd2VyQ2FzZSgpXS50aXRsZSArIFwiXV1cIikpXG5cbiAgICAgICAgICAgIEBXTS5JbnRlcmxhbmd1YWdlLmNvbGxlY3RMaW5rcyhcbiAgICAgICAgICAgICAgICB2aXNpdGVkbGlua3MsXG4gICAgICAgICAgICAgICAgbmV3bGlua3MsXG4gICAgICAgICAgICAgICAgc3VwcG9ydGVkTGFuZ3MsXG4gICAgICAgICAgICAgICAgd2hpdGVsaXN0LFxuICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgIEBtYWluRW5kLFxuICAgICAgICAgICAgICAgIFt0YWcsIHVybCwgc291cmNlLCBsYW5nbGlua3MsIGl3bWFwLCBjYWxsTmV4dF1cbiAgICAgICAgICAgIClcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgQFdNLkxvZy5sb2dJbmZvKFwiTm8gaW50ZXJsYW5ndWFnZSBsaW5rcyBmb3VuZFwiKVxuXG4gICAgICAgICAgICBpZiBjYWxsTmV4dFxuICAgICAgICAgICAgICAgIGNhbGxOZXh0KClcblxuICAgIG1haW5FbmQ6IChsaW5rcywgYXJncykgPT5cbiAgICAgICAgdGFnID0gYXJnc1swXVxuICAgICAgICB1cmwgPSBhcmdzWzFdXG4gICAgICAgIHNvdXJjZSA9IGFyZ3NbMl1cbiAgICAgICAgbGFuZ2xpbmtzID0gYXJnc1szXVxuICAgICAgICBpd21hcCA9IGFyZ3NbNF1cbiAgICAgICAgY2FsbE5leHQgPSBhcmdzWzVdXG5cbiAgICAgICAgbmV3VGV4dCA9IEBXTS5JbnRlcmxhbmd1YWdlLnVwZGF0ZUxpbmtzKHRhZywgdXJsLCBpd21hcCwgc291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFuZ2xpbmtzLCBsaW5rcylcblxuICAgICAgICBpZiBuZXdUZXh0ICE9IHNvdXJjZVxuICAgICAgICAgICAgQFdNLkVkaXRvci53cml0ZVNvdXJjZShuZXdUZXh0KVxuICAgICAgICAgICAgQFdNLkxvZy5sb2dJbmZvKFwiU3luY2hyb25pemVkIGludGVybGFuZ3VhZ2UgbGlua3NcIilcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgQFdNLkxvZy5sb2dJbmZvKFwiSW50ZXJsYW5ndWFnZSBsaW5rcyB3ZXJlIGFscmVhZHkgc3luY2hyb25pemVkXCIpXG5cbiAgICAgICAgaWYgY2FsbE5leHRcbiAgICAgICAgICAgIGNhbGxOZXh0KClcblxuICAgIG1haW5fYm90OiAodGl0bGUsIGNhbGxCb3QsIGNoYWluQXJncykgLT5cbiAgICAgICAgZGV0ZWN0ID0gQGRldGVjdExhbmcodGl0bGUsIEBjb25mLmxhbmd1YWdlX3RhZylcbiAgICAgICAgcHVyZVRpdGxlID0gZGV0ZWN0WzBdXG4gICAgICAgIHRhZyA9IGRldGVjdFsxXVxuXG4gICAgICAgIHdoaXRlbGlzdCA9IEBjb21wdXRlV2hpdGVMaXN0KEBjb25mLnRhZ193aGl0ZWxpc3QpXG4gICAgICAgIHN1cHBvcnRlZExhbmdzID0gQGNvbXB1dGVTdXBwb3J0ZWRMYW5ncyhAY29uZi5zdXBwb3J0ZWRfdGFncylcblxuICAgICAgICBzdW1tYXJ5ID0gQGNvbmYuZWRpdF9zdW1tYXJ5XG5cbiAgICAgICAgd2lraVVybHMgPSBAV00uTVcuZ2V0V2lraVVybHMoKVxuICAgICAgICB1cmwgPSB3aWtpVXJscy5zaG9ydCArIGVuY29kZVVSSUNvbXBvbmVudChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQFdNLlBhcnNlci5zcXVhc2hDb250aWd1b3VzV2hpdGVzcGFjZSh0aXRsZSkpXG5cbiAgICAgICAgdmlzaXRlZGxpbmtzID0ge31cblxuICAgICAgICBuZXdsaW5rcyA9IHt9XG4gICAgICAgIG5ld2xpbmtzW3RhZy50b0xvd2VyQ2FzZSgpXSA9IEBXTS5JbnRlcmxhbmd1YWdlLmNyZWF0ZU5ld0xpbmsodGFnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHVyZVRpdGxlLCB1cmwpXG5cbiAgICAgICAgQFdNLkludGVybGFuZ3VhZ2UuY29sbGVjdExpbmtzKFxuICAgICAgICAgICAgdmlzaXRlZGxpbmtzLFxuICAgICAgICAgICAgbmV3bGlua3MsXG4gICAgICAgICAgICBzdXBwb3J0ZWRMYW5ncyxcbiAgICAgICAgICAgIHdoaXRlbGlzdCxcbiAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICBAbWFpbkF1dG9Xcml0ZSxcbiAgICAgICAgICAgIFt0aXRsZSwgdXJsLCB0YWcsIHN1bW1hcnksIGNhbGxCb3RdXG4gICAgICAgIClcblxuICAgIG1haW5BdXRvV3JpdGU6IChsaW5rcywgYXJncykgPT5cbiAgICAgICAgdGl0bGUgPSBhcmdzWzBdXG4gICAgICAgIHVybCA9IGFyZ3NbMV1cbiAgICAgICAgdGFnID0gYXJnc1syXVxuICAgICAgICBzdW1tYXJ5ID0gYXJnc1szXVxuICAgICAgICBjYWxsQm90ID0gYXJnc1s0XVxuXG4gICAgICAgIGxjVGFnID0gdGFnLnRvTG93ZXJDYXNlKClcbiAgICAgICAgIyBOZXcgbGlua3MgdGhhdCB3ZXJlIG5vdCBpbiB0aGUgd2hpdGUgbGlzdCB3aWxsIGhhdmUgdGhlIFwiaXdtYXBcIlxuICAgICAgICAjIGF0dHJpYnV0ZSBmYWxzZSwgXCJ0aW1lc3RhbXBcIiBhbmQgXCJlZGl0dG9rZW5cIiBudWxsIGFuZCBcImxpbmtzXCIgYXMgYW5cbiAgICAgICAgIyBlbXB0eSBhcnJheSwgaG93ZXZlciBsaW5rc1tsY1RhZ10gc2hvdWxkIGFsd2F5cyBiZSBzYWZlXG4gICAgICAgIGl3bWFwID0gbGlua3NbbGNUYWddLml3bWFwXG4gICAgICAgIHNvdXJjZSA9IGxpbmtzW2xjVGFnXS5zb3VyY2VcbiAgICAgICAgbGFuZ2xpbmtzID0gbGlua3NbbGNUYWddLmxpbmtzXG4gICAgICAgIHRpbWVzdGFtcCA9IGxpbmtzW2xjVGFnXS50aW1lc3RhbXBcbiAgICAgICAgZWRpdHRva2VuID0gbGlua3NbbGNUYWddLmVkaXR0b2tlblxuXG4gICAgICAgIG5ld1RleHQgPSBAV00uSW50ZXJsYW5ndWFnZS51cGRhdGVMaW5rcyh0YWcsIHVybCwgaXdtYXAsIHNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhbmdsaW5rcywgbGlua3MpXG5cbiAgICAgICAgaWYgbmV3VGV4dCAhPSBzb3VyY2VcbiAgICAgICAgICAgIEBXTS5NVy5jYWxsQVBJUG9zdCh7XG4gICAgICAgICAgICAgICAgIGFjdGlvbjogXCJlZGl0XCJcbiAgICAgICAgICAgICAgICAgYm90OiBcIjFcIlxuICAgICAgICAgICAgICAgICB0aXRsZTogdGl0bGVcbiAgICAgICAgICAgICAgICAgc3VtbWFyeTogc3VtbWFyeVxuICAgICAgICAgICAgICAgICB0ZXh0OiBuZXdUZXh0XG4gICAgICAgICAgICAgICAgIGJhc2V0aW1lc3RhbXA6IHRpbWVzdGFtcFxuICAgICAgICAgICAgICAgICB0b2tlbjogZWRpdHRva2VuXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBAbWFpbkF1dG9FbmQsXG4gICAgICAgICAgICAgICAgY2FsbEJvdCxcbiAgICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICApXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGNhbGxCb3QoMCwgbnVsbClcblxuICAgIG1haW5BdXRvRW5kOiAocmVzLCBjYWxsQm90KSA9PlxuICAgICAgICBpZiByZXMuZWRpdCBhbmQgcmVzLmVkaXQucmVzdWx0ID09ICdTdWNjZXNzJ1xuICAgICAgICAgICAgY2FsbEJvdCgxLCBudWxsKVxuICAgICAgICBlbHNlIGlmIHJlcy5lcnJvclxuICAgICAgICAgICAgQFdNLkxvZy5sb2dFcnJvcihyZXMuZXJyb3IuaW5mbyArIFwiIChcIiArIHJlcy5lcnJvci5jb2RlICsgXCIpXCIpXG4gICAgICAgICAgICBjYWxsQm90KHJlcy5lcnJvci5jb2RlLCBudWxsKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICBjYWxsQm90KGZhbHNlLCBudWxsKVxuIiwiIyBXaWtpIE1vbmtleSAtIE1lZGlhV2lraSBib3QgYW5kIGVkaXRvci1hc3Npc3RhbnQgdXNlciBzY3JpcHRcbiMgQ29weXJpZ2h0IChDKSAyMDExIERhcmlvIEdpb3Zhbm5ldHRpIDxkZXZAZGFyaW9naW92YW5uZXR0aS5uZXQ+XG4jXG4jIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFdpa2kgTW9ua2V5LlxuI1xuIyBXaWtpIE1vbmtleSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4jIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4jIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4jIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4jXG4jIFdpa2kgTW9ua2V5IGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4jIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4jIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiMgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbiNcbiMgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiMgYWxvbmcgd2l0aCBXaWtpIE1vbmtleS4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cblxue1BsdWdpbn0gPSByZXF1aXJlKCcuL19QbHVnaW4nKVxuXG5TdHIgPSByZXF1aXJlKCdAa3luaWtvcy9taXNjL2Rpc3QvU3RyJylcblxuXG5jbGFzcyBtb2R1bGUuZXhwb3J0cy5VcGRhdGVDYXRlZ29yeVRyZWUgZXh0ZW5kcyBQbHVnaW5cbiAgICBAY29uZl9kZWZhdWx0OlxuICAgICAgICBlbmFibGVkOiBmYWxzZVxuICAgICAgICBzcGVjaWFsX21lbnU6IFtcIlVwZGF0ZSBjYXRlZ29yeSB0cmVlc1wiXVxuICAgICAgICBlZGl0X3N1bW1hcnk6IFwiYXV0b21hdGljIHVwZGF0ZVwiXG4gICAgICAgIHNob3dfcm9vdF9hbHNvX2luOiBmYWxzZVxuICAgICAgICBwYWdlczogW11cbiAgICBAd2lraV90b19jb25mX2RlZmF1bHQ6XG4gICAgICAgIEFyY2hXaWtpOlxuICAgICAgICAgICAgcGFnZXM6IFtcImFyXCIsIFwiY3NcIiwgXCJjc1wiLCBcImRhXCIsIFwiZWxcIiwgXCJlblwiLCBcImVzXCIsIFwiaGVcIiwgXCJoclwiLCBcImh1XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiaWRcIiwgXCJpdFwiLCBcImtvXCIsIFwibHRcIiwgXCJubFwiLCBcInBsXCIsIFwicHRcIiwgXCJydVwiLCBcInNrXCIsIFwic3JcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ0aFwiLCBcInRyXCIsIFwidWtcIiwgXCJ6aC1oYW5zXCIsIFwiemgtaGFudFwiXVxuICAgICAgICBXaWtpcGVkaWE6IHt9XG5cbiAgICBtYWluX3NwZWNpYWw6IChjYWxsTmV4dCkgLT5cbiAgICAgICAgQGl0ZXJhdGVQYWdlcygtMSwgY2FsbE5leHQpXG5cbiAgICBpdGVyYXRlUGFnZXM6IChwYWdlaWQsIGNhbGxOZXh0KSAtPlxuICAgICAgICBwYWdlaWQrK1xuICAgICAgICBzdW1tYXJ5ID0gQGNvbmYuZWRpdF9zdW1tYXJ5XG4gICAgICAgIHNob3dSb290QWxzb0luID0gQGNvbmYuc2hvd19yb290X2Fsc29faW5cbiAgICAgICAgcGNvbmYgPSBAY29uZi5wYWdlc1twYWdlaWRdXG4gICAgICAgIGlmIHBjb25mXG4gICAgICAgICAgICBpZiAkLnR5cGUocGNvbmYpIGlzIFwic3RyaW5nXCJcbiAgICAgICAgICAgICAgICBwYXJhbXMgPSBAV00uQXJjaFdpa2kuZ2V0VGFibGVPZkNvbnRlbnRzKHBjb25mKVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICMgVGhpcyBzaG91bGQgYmUgYSBjdXN0b20gY29uZmlndXJhdGlvbiBvYmplY3RcbiAgICAgICAgICAgICAgICBwYXJhbXMgPSBwY29uZlxuXG4gICAgICAgICAgICBAV00uTVcuaXNVc2VyQm90KHRoaXMubWFpbkNvbnRpbnVlLCBbcGFyYW1zLCBzaG93Um9vdEFsc29Jbiwgc3VtbWFyeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsTmV4dCwgcGFnZWlkXSlcblxuICAgICAgICBlbHNlIGlmIGNhbGxOZXh0XG4gICAgICAgICAgICBjYWxsTmV4dCgpXG5cbiAgICBtYWluQ29udGludWU6IChib3RUZXN0LCBhcmdzKSA9PlxuICAgICAgICBAcmVhZFRvQyh7XG4gICAgICAgICAgICBwYXJhbXM6IGFyZ3NbMF1cbiAgICAgICAgICAgIG1pbkludGVydmFsOiBpZiBib3RUZXN0IHRoZW4gNjAwMDAgZWxzZSAyMTYwMDAwMFxuICAgICAgICAgICAgZWRpdHRva2VuOiBcIlwiXG4gICAgICAgICAgICB0aW1lc3RhbXA6IFwiXCJcbiAgICAgICAgICAgIHNvdXJjZTogXCJcIlxuICAgICAgICAgICAgc3RhcnRJZDogMFxuICAgICAgICAgICAgZW5kSWQ6IDBcbiAgICAgICAgICAgIHRyZWVUZXh0OiBcIlwiXG4gICAgICAgICAgICBzdGFydE1hcms6IFwiU1RBUlQgQVVUTyBUT0MgLSBETyBOT1QgUkVNT1ZFIE9SIE1PRElGWSBUSElTIE1BUkstLT5cIlxuICAgICAgICAgICAgZW5kTWFyazogXCI8IS0tRU5EIEFVVE8gVE9DIC0gRE8gTk9UIFJFTU9WRSBPUiBNT0RJRlkgVEhJUyBNQVJLXCJcbiAgICAgICAgICAgIGFsdE5hbWVzOiB7fVxuICAgICAgICAgICAgc2hvd1Jvb3RBbHNvSW46IGFyZ3NbMV1cbiAgICAgICAgICAgIHN1bW1hcnk6IGFyZ3NbMl1cbiAgICAgICAgICAgIGNhbGxOZXh0OiBhcmdzWzNdXG4gICAgICAgICAgICBwYWdlaWQ6IGFyZ3NbNF1cbiAgICAgICAgfSlcblxuICAgIHJlYWRUb0M6IChhcmdzKSA9PlxuICAgICAgICBAV00uTG9nLmxvZ0luZm8oJ1VwZGF0aW5nICcgKyBAV00uTG9nLmxpbmtUb1dpa2lQYWdlKGFyZ3MucGFyYW1zLnBhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzLnBhcmFtcy5wYWdlKSArIFwiIC4uLlwiKVxuICAgICAgICBAV00uTVcuY2FsbFF1ZXJ5RWRpdChhcmdzLnBhcmFtcy5wYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEBwcm9jZXNzVG9DLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MpXG5cbiAgICBwcm9jZXNzVG9DOiAodGl0bGUsIHNvdXJjZSwgdGltZXN0YW1wLCBlZGl0dG9rZW4sIGFyZ3MpID0+XG4gICAgICAgIGFyZ3Muc291cmNlID0gc291cmNlXG4gICAgICAgIGFyZ3MudGltZXN0YW1wID0gdGltZXN0YW1wXG4gICAgICAgIGFyZ3MuZWRpdHRva2VuID0gZWRpdHRva2VuXG5cbiAgICAgICAgbm93ID0gbmV3IERhdGUoKVxuICAgICAgICBtc1RpbWVzdGFtcCA9IERhdGUucGFyc2UoYXJncy50aW1lc3RhbXApXG4gICAgICAgIGlmIG5vdy5nZXRUaW1lKCkgLSBtc1RpbWVzdGFtcCA+PSBhcmdzLm1pbkludGVydmFsXG4gICAgICAgICAgICBzdGFydCA9IGFyZ3Muc291cmNlLmluZGV4T2YoYXJncy5zdGFydE1hcmspXG4gICAgICAgICAgICBlbmQgPSBhcmdzLnNvdXJjZS5sYXN0SW5kZXhPZihhcmdzLmVuZE1hcmspXG5cbiAgICAgICAgICAgIGlmIHN0YXJ0ID4gLTEgYW5kIGVuZCA+IC0xXG4gICAgICAgICAgICAgICAgYXJncy5zdGFydElkID0gc3RhcnQgKyBhcmdzLnN0YXJ0TWFyay5sZW5ndGhcbiAgICAgICAgICAgICAgICBhcmdzLmVuZElkID0gZW5kXG4gICAgICAgICAgICAgICAgYXJncy50cmVlVGV4dCA9IFwiXCJcbiAgICAgICAgICAgICAgICBhcmdzLmFsdE5hbWVzID0gaWYgYXJncy5wYXJhbXMua2VlcEFsdE5hbWUgdGhlbiBAc3RvcmVBbHRlcm5hdGl2ZU5hbWVzKGFyZ3Muc291cmNlKSBlbHNlIHt9XG4gICAgICAgICAgICAgICAgQFdNLkNhdC5yZWN1cnNlVHJlZSh7XG4gICAgICAgICAgICAgICAgICAgIG5vZGU6IGFyZ3MucGFyYW1zLnJvb3QsXG4gICAgICAgICAgICAgICAgICAgIGNhbGxOb2RlOiBAcHJvY2Vzc0NhdGVnb3J5LFxuICAgICAgICAgICAgICAgICAgICBjYWxsRW5kOiBAd3JpdGVUb0MsXG4gICAgICAgICAgICAgICAgICAgIGNhbGxBcmdzOiBhcmdzXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBAV00uTG9nLmxvZ0Vycm9yKFwiQ2Fubm90IGZpbmQgaW5zZXJ0aW9uIG1hcmtzIGluIFwiICtcbiAgICAgICAgICAgICAgICAgICAgQFdNLkxvZy5saW5rVG9XaWtpUGFnZShhcmdzLnBhcmFtcy5wYWdlLCBhcmdzLnBhcmFtcy5wYWdlKSlcbiAgICAgICAgICAgICAgICBAaXRlcmF0ZVBhZ2VzKGFyZ3MucGFnZWlkLCBhcmdzLmNhbGxOZXh0KVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICBAV00uTG9nLmxvZ1dhcm5pbmcoQFdNLkxvZy5saW5rVG9XaWtpUGFnZShhcmdzLnBhcmFtcy5wYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXJncy5wYXJhbXMucGFnZSkgKyAnIGhhcyBiZWVuIHVwZGF0ZWQgdG9vIHJlY2VudGx5JylcbiAgICAgICAgICAgIEBpdGVyYXRlUGFnZXMoYXJncy5wYWdlaWQsIGFyZ3MuY2FsbE5leHQpXG5cbiAgICBzdG9yZUFsdGVybmF0aXZlTmFtZXM6IChzb3VyY2UpID0+XG4gICAgICAgIGRpY3QgPSB7fVxuICAgICAgICByZWdFeHAgPSAvXFxbXFxbXFw6KFtDY11hdGVnb3J5XFw6Lis/KVxcfCguKz8pXFxdXFxdL2dtXG4gICAgICAgIHdoaWxlIHRydWVcbiAgICAgICAgICAgIG1hdGNoID0gcmVnRXhwLmV4ZWMoc291cmNlKVxuICAgICAgICAgICAgaWYgbWF0Y2hcbiAgICAgICAgICAgICAgICBkaWN0W21hdGNoWzFdLnRvTG93ZXJDYXNlKCldID0gbWF0Y2hbMl1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICByZXR1cm4gZGljdFxuXG4gICAgcHJvY2Vzc0NhdGVnb3J5OiAocGFyYW1zKSA9PlxuICAgICAgICBhcmdzID0gcGFyYW1zLmNhbGxBcmdzXG5cbiAgICAgICAgQFdNLkxvZy5sb2dJbmZvKFwiUHJvY2Vzc2luZyBcIiArIEBXTS5Mb2cubGlua1RvV2lraVBhZ2UocGFyYW1zLm5vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy5ub2RlKSArIFwiIC4uLlwiKVxuXG4gICAgICAgIHRleHQgPSBcIlwiXG5cbiAgICAgICAgZm9yIFswLi4ucGFyYW1zLmFuY2VzdG9ycy5sZW5ndGhdXG4gICAgICAgICAgICB0ZXh0ICs9IGFyZ3MucGFyYW1zLmluZGVudFR5cGVcblxuICAgICAgICBpZiBhcmdzLnBhcmFtcy5zaG93SW5kaWNlc1xuICAgICAgICAgICAgaW5kaWNlcyA9IFtdXG4gICAgICAgICAgICBub2RlID0gcGFyYW1zXG4gICAgICAgICAgICB3aGlsZSBub2RlLnBhcmVudEluZGV4ICE9IG51bGxcbiAgICAgICAgICAgICAgICBpbmRpY2VzLnB1c2gobm9kZS5zaWJsaW5nSW5kZXggKyAxKVxuICAgICAgICAgICAgICAgIG5vZGUgPSBwYXJhbXMubm9kZXNMaXN0W25vZGUucGFyZW50SW5kZXhdXG4gICAgICAgICAgICBpZiBpbmRpY2VzLmxlbmd0aFxuICAgICAgICAgICAgICAgIHRleHQgKz0gXCI8c21hbGw+XCIgKyBpbmRpY2VzLnJldmVyc2UoKS5qb2luKFwiLlwiKSArIFwiLjwvc21hbGw+IFwiXG5cbiAgICAgICAgYWx0TmFtZSA9IGlmIGFyZ3MuYWx0TmFtZXNbcGFyYW1zLm5vZGUudG9Mb3dlckNhc2UoKV0gdGhlbiBhcmdzLmFsdE5hbWVzW3BhcmFtcy5ub2RlLnRvTG93ZXJDYXNlKCldIGVsc2UgbnVsbFxuICAgICAgICB0ZXh0ICs9IEBjcmVhdGVDYXRMaW5rKHBhcmFtcy5ub2RlLCBhcmdzLnBhcmFtcy5yZXBsYWNlLCBhbHROYW1lKVxuXG4gICAgICAgIHRleHQgKz0gaWYgYXJncy5wYXJhbXMucmlnaHRUb0xlZnQgdGhlbiBcIiZscm07IFwiIGVsc2UgXCIgXCJcblxuICAgICAgICBpZiBwYXJhbXMuY2hpbGRyZW4gPT0gXCJsb29wXCJcbiAgICAgICAgICAgIHRleHQgKz0gXCInJydbTE9PUF0nJydcXG5cIlxuICAgICAgICAgICAgQFdNLkxvZy5sb2dXYXJuaW5nKFwiTG9vcCBpbiBcIiArIEBXTS5Mb2cubGlua1RvV2lraVBhZ2UocGFyYW1zLm5vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLm5vZGUpKVxuICAgICAgICAgICAgQHByb2Nlc3NDYXRlZ29yeUVuZChwYXJhbXMsIGFyZ3MsIHRleHQpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIEBXTS5DYXQuZ2V0UGFyZW50c0FuZEluZm8oXG4gICAgICAgICAgICAgICAgcGFyYW1zLm5vZGUsXG4gICAgICAgICAgICAgICAgQHByb2Nlc3NDYXRlZ29yeUFkZFN1ZmZpeCxcbiAgICAgICAgICAgICAgICBbcGFyYW1zLCBhcmdzLCB0ZXh0LCBhbHROYW1lXVxuICAgICAgICAgICAgKVxuXG4gICAgcHJvY2Vzc0NhdGVnb3J5QWRkU3VmZml4OiAocGFyZW50cywgaW5mbywgYXJnc18pID0+XG4gICAgICAgIHBhcmFtcyA9IGFyZ3NfWzBdXG4gICAgICAgIGFyZ3MgPSBhcmdzX1sxXVxuICAgICAgICB0ZXh0ID0gYXJnc19bMl1cbiAgICAgICAgYWx0TmFtZSA9IGFyZ3NfWzNdXG5cbiAgICAgICAgY3VyclBhcmVudCA9IHBhcmFtcy5hbmNlc3RvcnNbcGFyYW1zLmFuY2VzdG9ycy5sZW5ndGggLSAxXVxuICAgICAgICBhbHNvUGFyZW50cyA9IFtdXG4gICAgICAgIHRleHQgKz0gXCI8c21hbGw+KFwiICsgKGlmIGluZm8gdGhlbiBpbmZvLnBhZ2VzIGVsc2UgMCkgKyBcIilcIlxuXG4gICAgICAgICMgQWxsb3cgaGlkaW5nIHRoZSBcImFsc28gaW5cIiAod2hvc2UgY3VyclBhcmVudCBpcyB1bmRlZmluZWQpIGxpbmtzIGZvclxuICAgICAgICAjIHRoZSByb290IGl0ZW0sIHNpbmNlIHRoZSByb290J3MgcGFyZW50IGNhdGVnb3J5IHdvdWxkIGJlIGRpc3BsYXllZFxuICAgICAgICAjIHRoZXJlXG4gICAgICAgIGlmIGN1cnJQYXJlbnQgb3IgYXJncy5zaG93Um9vdEFsc29JblxuICAgICAgICAgICAgZm9yIHBhciBpbiBwYXJlbnRzXG4gICAgICAgICAgICAgICAgaWYgY3VyclBhcmVudCAhPSBwYXIudGl0bGUgYW5kIG5vdCAoXCJoaWRkZW5cIiBpbiBwYXIpXG4gICAgICAgICAgICAgICAgICAgIGFsc29QYXJlbnRzLnB1c2gocGFyKVxuXG4gICAgICAgICAgICBpZiBhbHNvUGFyZW50cy5sZW5ndGhcbiAgICAgICAgICAgICAgICBwYXJlbnRUaXRsZXMgPSBbXVxuICAgICAgICAgICAgICAgIGZvciBpIGluIGFsc29QYXJlbnRzXG4gICAgICAgICAgICAgICAgICAgIGFsdE5hbWUgPSBpZiBhcmdzLmFsdE5hbWVzW2Fsc29QYXJlbnRzW2ldLnRpdGxlLnRvTG93ZXJDYXNlKCldIHRoZW4gYXJncy5hbHROYW1lc1thbHNvUGFyZW50c1tpXS50aXRsZS50b0xvd2VyQ2FzZSgpXSBlbHNlIG51bGxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50VGl0bGVzLnB1c2goQGNyZWF0ZUNhdExpbmsoYWxzb1BhcmVudHNbaV0udGl0bGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzLnBhcmFtcy5yZXBsYWNlLCBhbHROYW1lKSlcblxuICAgICAgICAgICAgICAgIHRleHQgKz0gXCIgKFwiICsgYXJncy5wYXJhbXMuYWxzb0luICsgXCIgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50VGl0bGVzLmpvaW4oXCIsIFwiKSArIFwiKVwiXG5cbiAgICAgICAgdGV4dCArPSBcIjwvc21hbGw+XFxuXCJcblxuICAgICAgICBAcHJvY2Vzc0NhdGVnb3J5RW5kKHBhcmFtcywgYXJncywgdGV4dClcblxuICAgIHByb2Nlc3NDYXRlZ29yeUVuZDogKHBhcmFtcywgYXJncywgdGV4dCkgPT5cbiAgICAgICAgYXJncy50cmVlVGV4dCArPSB0ZXh0XG5cbiAgICAgICAgcGFyYW1zLmNhbGxBcmdzID0gYXJnc1xuXG4gICAgICAgIEBXTS5DYXQucmVjdXJzZVRyZWVDb250aW51ZShwYXJhbXMpXG5cbiAgICBjcmVhdGVDYXRMaW5rOiAoY2F0LCByZXBsYWNlLCBhbHROYW1lKSA9PlxuICAgICAgICBpZiBhbHROYW1lXG4gICAgICAgICAgICBjYXROYW1lID0gYWx0TmFtZVxuICAgICAgICBlbHNlIGlmIHJlcGxhY2VcbiAgICAgICAgICAgIHJlZ0V4cCA9IG5ldyBSZWdFeHAocmVwbGFjZVswXSwgcmVwbGFjZVsxXSlcbiAgICAgICAgICAgIGNhdE5hbWUgPSBjYXQuc3Vic3RyKDkpLnJlcGxhY2UocmVnRXhwLCByZXBsYWNlWzJdKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICBjYXROYW1lID0gY2F0LnN1YnN0cig5KVxuICAgICAgICByZXR1cm4gXCJbWzpcIiArIGNhdCArIFwifFwiICsgY2F0TmFtZSArIFwiXV1cIlxuXG4gICAgd3JpdGVUb0M6IChwYXJhbXMpID0+XG4gICAgICAgIGFyZ3MgPSBwYXJhbXMuY2FsbEFyZ3NcblxuICAgICAgICBhcmdzLnRyZWVUZXh0ID0gXCJcXG5cIiArIGFyZ3MudHJlZVRleHRcbiAgICAgICAgbmV3dGV4dCA9IFN0ci5vdmVyd3JpdGVCZXR3ZWVuKGFyZ3Muc291cmNlLCBhcmdzLnRyZWVUZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3Muc3RhcnRJZCwgYXJncy5lbmRJZClcblxuICAgICAgICBpZiBuZXd0ZXh0ICE9IGFyZ3Muc291cmNlXG4gICAgICAgICAgICBAV00uTVcuY2FsbEFQSVBvc3Qoe1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwiZWRpdFwiXG4gICAgICAgICAgICAgICAgICAgIGJvdDogXCIxXCJcbiAgICAgICAgICAgICAgICAgICAgbWlub3I6IFwiMVwiXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiBhcmdzLnBhcmFtcy5wYWdlXG4gICAgICAgICAgICAgICAgICAgIHN1bW1hcnk6IGFyZ3Muc3VtbWFyeVxuICAgICAgICAgICAgICAgICAgICB0ZXh0OiBuZXd0ZXh0XG4gICAgICAgICAgICAgICAgICAgIGJhc2V0aW1lc3RhbXA6IGFyZ3MudGltZXN0YW1wXG4gICAgICAgICAgICAgICAgICAgIHRva2VuOiBhcmdzLmVkaXR0b2tlblxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgQGNoZWNrV3JpdGUsXG4gICAgICAgICAgICAgICAgYXJncyxcbiAgICAgICAgICAgICAgICBudWxsKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICBAV00uTG9nLmxvZ0luZm8oQFdNLkxvZy5saW5rVG9XaWtpUGFnZShhcmdzLnBhcmFtcy5wYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzLnBhcmFtcy5wYWdlKSArICcgaXMgYWxyZWFkeSB1cCB0byBkYXRlJylcblxuICAgICAgICAgICAgQGl0ZXJhdGVQYWdlcyhhcmdzLnBhZ2VpZCwgYXJncy5jYWxsTmV4dClcblxuICAgIGNoZWNrV3JpdGU6IChyZXMsIGFyZ3MpID0+XG4gICAgICAgIGlmIHJlcy5lZGl0IGFuZCByZXMuZWRpdC5yZXN1bHQgPT0gJ1N1Y2Nlc3MnXG4gICAgICAgICAgICBAV00uTG9nLmxvZ0luZm8oQFdNLkxvZy5saW5rVG9XaWtpUGFnZShhcmdzLnBhcmFtcy5wYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJncy5wYXJhbXMucGFnZSkgKyAnIGNvcnJlY3RseSB1cGRhdGVkJylcblxuICAgICAgICAgICAgQGl0ZXJhdGVQYWdlcyhhcmdzLnBhZ2VpZCwgYXJncy5jYWxsTmV4dClcblxuICAgICAgICBlbHNlXG4gICAgICAgICAgICBAV00uTG9nLmxvZ0Vycm9yKEBXTS5Mb2cubGlua1RvV2lraVBhZ2UoYXJncy5wYXJhbXMucGFnZSxcbiAgICAgICAgICAgICAgICAgICAgYXJncy5wYXJhbXMucGFnZSkgKyAnIGhhcyBub3QgYmVlbiB1cGRhdGVkIVxcbicgK1xuICAgICAgICAgICAgICAgICAgICByZXNbJ2Vycm9yJ11bJ2luZm8nXSArIFwiIChcIiArIHJlc1snZXJyb3InXVsnY29kZSddICsgXCIpXCIpXG4iLCIjIFdpa2kgTW9ua2V5IC0gTWVkaWFXaWtpIGJvdCBhbmQgZWRpdG9yLWFzc2lzdGFudCB1c2VyIHNjcmlwdFxuIyBDb3B5cmlnaHQgKEMpIDIwMTEgRGFyaW8gR2lvdmFubmV0dGkgPGRldkBkYXJpb2dpb3Zhbm5ldHRpLm5ldD5cbiNcbiMgVGhpcyBmaWxlIGlzIHBhcnQgb2YgV2lraSBNb25rZXkuXG4jXG4jIFdpa2kgTW9ua2V5IGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiMgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiMgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiMgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbiNcbiMgV2lraSBNb25rZXkgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiMgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiMgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuIyBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuI1xuIyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuIyBhbG9uZyB3aXRoIFdpa2kgTW9ua2V5LiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuXG5cbmNsYXNzIG1vZHVsZS5leHBvcnRzLlBsdWdpblxuICAgICMgRG9uJ3QgY3JlYXRlIGRlZmF1bHQgb2JqZWN0cyBoZXJlLCBvciB0aGV5J2xsIGJlIHNoYXJlZCBhbW9uZyB0aGVcbiAgICAjIHN1YmNsYXNzZXMgdW5sZXNzIG92ZXJyaWRkZW5cbiAgICAjIEBjb25mX2RlZmF1bHQ6IHt9XG4gICAgIyBAd2lraV90b19jb25mX2RlZmF1bHQ6IHt9XG4gICAgIyBjb25mOiB7fVxuXG4gICAgQF9fY29uZmlndXJlOiAod2lraV9uYW1lLCB1c2VyX2NvbmZpZykgLT5cbiAgICAgICAgIyBEbyBnZW5lcmF0ZSBhIG5ldyBvYmplY3QgZm9yIGVhY2ggcGx1Z2luXG4gICAgICAgIEA6OmNvbmYgPSB7fVxuXG4gICAgICAgIGlmIEBjb25mX2RlZmF1bHQ/XG4gICAgICAgICAgICAkLmV4dGVuZChAOjpjb25mLCBAY29uZl9kZWZhdWx0KVxuXG4gICAgICAgIGlmIEB3aWtpX3RvX2NvbmZfZGVmYXVsdD8gYW5kIHdpa2lfbmFtZSBvZiBAd2lraV90b19jb25mX2RlZmF1bHRcbiAgICAgICAgICAgICQuZXh0ZW5kKEA6OmNvbmYsIEB3aWtpX3RvX2NvbmZfZGVmYXVsdFt3aWtpX25hbWVdKVxuXG4gICAgICAgIGlmIEBuYW1lIG9mIHVzZXJfY29uZmlnXG4gICAgICAgICAgICAjIERvbid0IGp1c3QgdXNlICQuZXh0ZW5kKCkgc28gaXQncyBwb3NzaWJsZSB0byBzZWUgaWYgdGhlcmUgYXJlXG4gICAgICAgICAgICAjIHVua25vd24gb3B0aW9ucyBhbmQgcG9zc2libHkgd2FybiB0aGUgdXNlclxuICAgICAgICAgICAgZm9yIG9wdGlvbiwgdmFsdWUgb2YgdXNlcl9jb25maWdbQG5hbWVdIHdoZW4gb3B0aW9uIG9mIEA6OmNvbmZcbiAgICAgICAgICAgICAgICBAOjpjb25mW29wdGlvbl0gPSB2YWx1ZVxuICAgICAgICAgICAgICAgIGRlbGV0ZSB1c2VyX2NvbmZpZ1tAbmFtZV1bb3B0aW9uXVxuXG4gICAgICAgIGlmIG5vdCBAOjpjb25mLmVuYWJsZWRcbiAgICAgICAgICAgIGRlbGV0ZSB1c2VyX2NvbmZpZ1tAbmFtZV1cbiAgICAgICAgICAgICMgVE9ETzogUHJvcGVybHkgZXh0ZW5kIEVycm9yLCBidXQgYmV3YXJlIHRoYXQgQmFiZWwgZG9lc24ndCBsaWtlXG4gICAgICAgICAgICAjICAgICAgIGl0IHdpdGhvdXQgc3BlY2lmaWMgcGx1Z2luc1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGx1Z2luIGRpc2FibGVkXCIpXG5cbiAgICAgICAgaWYgJC5pc0VtcHR5T2JqZWN0KHVzZXJfY29uZmlnW0BuYW1lXSlcbiAgICAgICAgICAgIGRlbGV0ZSB1c2VyX2NvbmZpZ1tAbmFtZV1cblxuICAgIGNvbnN0cnVjdG9yOiAoQFdNKSAtPlxuXG4gICAgbWFpbl9ib3Q6IG51bGxcbiAgICBtYWluX2RpZmY6IG51bGxcbiAgICBtYWluX2VkaXRvcjogbnVsbFxuICAgIG1haW5fbmV3cGFnZXM6IG51bGxcbiAgICBtYWluX3JlY2VudGNoYW5nZXM6IG51bGxcbiAgICBtYWluX3NwZWNpYWw6IG51bGxcbiJdfQ==
