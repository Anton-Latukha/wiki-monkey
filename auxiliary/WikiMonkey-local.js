(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
"use strict";

// Generated by CoffeeScript 2.1.1
// JavaScript auxiliary library
// Copyright (C) 2012 Dario Giovannetti <dev@dariogiovannetti.net>

// This file is part of JavaScript auxiliary library.

// JavaScript auxiliary library is free software: you can redistribute it
// and/or modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation, either version 3
// of the License, or (at your option) any later version.

// JavaScript auxiliary library is distributed in the hope that it will be
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with JavaScript auxiliary library.
// If not, see <http://www.gnu.org/licenses/>.
module.exports.executeAsync = function (functions, id) {
  var _this = this;

  var callContinue, fid;
  id++;
  if (functions[id]) {
    fid = functions[id];
    callContinue = function callContinue() {
      return _this.executeAsync(functions, id);
    };
    return fid[0](fid[1], callContinue);
  }
};

module.exports.recurseTreeAsync = function (params) {
  var parent;
  // params = {
  //   node: ,
  //   parentIndex: ,
  //   siblingIndex: ,
  //   ancestors: ,
  //   children: ,
  //   callChildren: ,
  //   callNode: ,
  //   callEnd: ,
  //   callArgs: ,
  //   stage: ,
  //   nodesList:
  // }

  // nodesList: [
  //   {
  //     node: ,
  //     parentIndex: ,
  //     siblingIndex: ,
  //     ancestors: [...],
  //     children: [...]
  //   },
  //   {...}
  // ]

  // Example:

  // recurseTreeAsync({
  //   node: ,
  //   callChildren: ,
  //   callNode: ,
  //   callEnd: ,
  //   callArgs:
  // });

  // callChildren(params) {
  //   params.children = ;
  //   recurseTreeAsync(params);
  // }

  // callNode(params) {
  //   recurseTreeAsync(params);
  // }

  // callEnd(params) {}
  switch (params.stage) {
    case void 0:
      params.parentIndex = null;
      params.siblingIndex = 0;
      params.ancestors = [];
      params.children = [];
      params.nodesList = [];
      params.stage = 1;
      return this.recurseTreeAsync(params);
    case 1:
      params.stage = 2;
      // Prevent infinite loops
      if (params.ancestors.indexOf(params.node) === -1) {
        return params.callChildren(params);
      } else {
        params.children = "loop";
        return this.recurseTreeAsync(params);
      }
      break;
    case 2:
      params.nodesList.push({
        node: params.node,
        parentIndex: params.parentIndex,
        siblingIndex: params.siblingIndex,
        ancestors: params.ancestors.slice(0),
        children: params.children.slice(0)
      });
      params.stage = 3;
      return params.callNode(params);
    case 3:
      if (params.children.length && params.children !== "loop") {
        // Go to the first child
        params.ancestors.push(params.node);
        params.node = params.children[0];
        params.parentIndex = params.nodesList.length - 1;
        params.siblingIndex = 0;
        params.children = [];
        params.stage = 1;
        return this.recurseTreeAsync(params);
      } else if (params.parentIndex !== null) {
        // Go to the next sibling
        parent = params.nodesList[params.parentIndex];
        params.siblingIndex++;
        params.node = parent.children[params.siblingIndex];
        params.children = [];
        if (params.node) {
          params.stage = 1;
        } else {
          // There are no more siblings
          params.node = parent.node;
          params.parentIndex = parent.parentIndex;
          params.siblingIndex = parent.siblingIndex;
          params.ancestors = parent.ancestors.slice(0);
          params.stage = 3;
        }
        return this.recurseTreeAsync(params);
      } else {
        // End of recursion
        return params.callEnd(params);
      }
  }
};
},{}],2:[function(require,module,exports){
'use strict';

// Generated by CoffeeScript 2.1.1
// JavaScript auxiliary library
// Copyright (C) 2012 Dario Giovannetti <dev@dariogiovannetti.net>

// This file is part of JavaScript auxiliary library.

// JavaScript auxiliary library is free software: you can redistribute it
// and/or modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation, either version 3
// of the License, or (at your option) any later version.

// JavaScript auxiliary library is distributed in the hope that it will be
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with JavaScript auxiliary library.
// If not, see <http://www.gnu.org/licenses/>.
module.exports.addStyleElement = function (css) {
  var style;
  style = document.createElement('style');
  style.setAttribute('type', 'text/css');
  style.innerHTML = css;
  return document.head.appendChild(style);
};
},{}],3:[function(require,module,exports){
'use strict';

// Generated by CoffeeScript 2.1.1
// JavaScript auxiliary library
// Copyright (C) 2012 Dario Giovannetti <dev@dariogiovannetti.net>

// This file is part of JavaScript auxiliary library.

// JavaScript auxiliary library is free software: you can redistribute it
// and/or modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation, either version 3
// of the License, or (at your option) any later version.

// JavaScript auxiliary library is distributed in the hope that it will be
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with JavaScript auxiliary library.
// If not, see <http://www.gnu.org/licenses/>.
module.exports.normalizeCarriageReturns = function (source) {
  // Opera and IE use \r\n instead of \n
  return source.replace(/\r\n/g, '\n');
};
},{}],4:[function(require,module,exports){
'use strict';

// Generated by CoffeeScript 2.1.1
// JavaScript auxiliary library
// Copyright (C) 2012 Dario Giovannetti <dev@dariogiovannetti.net>

// This file is part of JavaScript auxiliary library.

// JavaScript auxiliary library is free software: you can redistribute it
// and/or modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation, either version 3
// of the License, or (at your option) any later version.

// JavaScript auxiliary library is distributed in the hope that it will be
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with JavaScript auxiliary library.
// If not, see <http://www.gnu.org/licenses/>.
module.exports.getUrlLocation = function (url) {
  var link;
  link = document.createElement('a');
  link.href = url;
  return link;
};

module.exports.getURIParameters = function (uri) {
  var i, len, par, qarray, qdict, qstring, s;
  if (uri) {
    qstring = module.exports.getUrlLocation(uri).search;
  } else {
    qstring = location.search;
  }
  qarray = qstring.substr(1).split('&');
  qdict = new Object();
  s = new Array();
  for (i = 0, len = qarray.length; i < len; i++) {
    par = qarray[i];
    s = par.split('=');
    qdict[s[0]] = s[1];
  }
  return qdict;
};

module.exports.getURIParameter = function (uri, name) {
  return module.exports.getURIParameters(uri)[name];
};

module.exports.sendGetAsyncRequest = function (url, call) {
  var req;
  req = new XMLHttpRequest();
  req.onreadystatechange = function () {
    if (req.readyState === 4 && req.status === 200) {
      return call(req);
    }
  };
  req.open("GET", url, true);
  return req.send();
};

module.exports.sendGetSyncRequest = function (url) {
  var req;
  req = new XMLHttpRequest();
  req.open("GET", url, false);
  req.send();
  return req;
};

module.exports.sendPostAsyncRequest = function (url, call, query, header, headervalue) {
  var req;
  req = new XMLHttpRequest();
  req.onreadystatechange = function () {
    if (req.readyState === 4 && req.status === 200) {
      return call(req);
    }
  };
  req.open("POST", url, true);
  if (header && headervalue) {
    req.setRequestHeader(header, headervalue);
  }
  return req.send(query);
};

module.exports.sendPostSyncRequest = function (url, query, header, headervalue) {
  var req;
  req = new XMLHttpRequest();
  req.open("POST", url, false);
  if (header && headervalue) {
    req.setRequestHeader(header, headervalue);
  }
  req.send(query);
  return req;
};
},{}],5:[function(require,module,exports){
"use strict";

// Generated by CoffeeScript 2.1.1
// JavaScript auxiliary library
// Copyright (C) 2012 Dario Giovannetti <dev@dariogiovannetti.net>

// This file is part of JavaScript auxiliary library.

// JavaScript auxiliary library is free software: you can redistribute it
// and/or modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation, either version 3
// of the License, or (at your option) any later version.

// JavaScript auxiliary library is distributed in the hope that it will be
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with JavaScript auxiliary library.
// If not, see <http://www.gnu.org/licenses/>.
module.exports.getKeys = function (object) {
  var i, keys;
  keys = [];
  for (i in object) {
    keys.push(i);
  }
  return keys;
};

module.exports.getValues = function (object) {
  var i, values;
  values = [];
  for (i in object) {
    values.push(object[i]);
  }
  return values;
};

module.exports.getFirstItem = function (object) {
  var i;
  for (i in object) {
    return object[i];
  }
};
},{}],6:[function(require,module,exports){
"use strict";

// Generated by CoffeeScript 2.1.1
// JavaScript auxiliary library
// Copyright (C) 2012 Dario Giovannetti <dev@dariogiovannetti.net>

// This file is part of JavaScript auxiliary library.

// JavaScript auxiliary library is free software: you can redistribute it
// and/or modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation, either version 3
// of the License, or (at your option) any later version.

// JavaScript auxiliary library is distributed in the hope that it will be
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with JavaScript auxiliary library.
// If not, see <http://www.gnu.org/licenses/>.
module.exports.escapePattern = function (string) {
  // Escaping any other characters is not necessary, references:
  // - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions
  // - http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
  // - http://stackoverflow.com/questions/2593637/how-to-escape-regular-expression-in-javascript
  // - http://stackoverflow.com/questions/494035/how-do-you-pass-a-variable-to-a-regular-expression-javascript
  // - http://stackoverflow.com/questions/3446170/escape-string-for-use-in-javascript-regex
  // - http://stackoverflow.com/questions/399078/what-special-characters-must-be-escaped-in-regular-expressions

  // Note for Wiki Monkey: do *not* escape '\s' here so that it will be
  // safe to use prepareRegexpWhitespace in WM.Parser
  return string.replace(/[-[\]{}()^$*+?.|\\]/g, "\\$&");
};

module.exports.matchAll = function (source, regExp) {
  var L, match, result;
  result = [];
  while (true) {
    match = regExp.exec(source);
    if (match) {
      L = match[0].length;
      result.push({
        "match": match,
        "index": regExp.lastIndex - L,
        "length": L
      });
    } else {
      break;
    }
  }
  return result;
};

module.exports.matchAllConditional = function (source, regExp, test) {
  var L, match, result;
  result = [];
  while (true) {
    match = regExp.exec(source);
    if (match && test(match)) {
      L = match[0].length;
      result.push({
        "match": match,
        "index": regExp.lastIndex - L,
        "length": L
      });
    } else {
      break;
    }
  }
  return result;
};
},{}],7:[function(require,module,exports){
"use strict";

// Generated by CoffeeScript 2.1.1
// JavaScript auxiliary library
// Copyright (C) 2012 Dario Giovannetti <dev@dariogiovannetti.net>

// This file is part of JavaScript auxiliary library.

// JavaScript auxiliary library is free software: you can redistribute it
// and/or modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation, either version 3
// of the License, or (at your option) any later version.

// JavaScript auxiliary library is distributed in the hope that it will be
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with JavaScript auxiliary library.
// If not, see <http://www.gnu.org/licenses/>.
module.exports.insert = function (string, newString, id) {
  if (id == null) {
    id = 0;
  }
  return string.substring(0, id) + newString + string.substr(id);
};

module.exports.overwriteFor = function (string, newString, id, length) {
  if (id == null) {
    id = 0;
  }
  if (!length || length < 0) {
    length = 0;
  }
  return string.substring(0, id) + newString + string.substr(id + length);
};

module.exports.overwriteAt = function (string, newString, id) {
  return module.exports.overwriteFor(string, newString, id, newString.length);
};

module.exports.overwriteBetween = function (string, newString, id1, id2) {
  var tempid;
  if (id1 == null) {
    id1 = 0;
  }
  if (id2 == null) {
    id2 = id1;
  }
  if (id1 > id2) {
    tempid = id2;
    id2 = id1;
    id1 = tempid;
  }
  return string.substring(0, id1) + newString + string.substr(id2);
};

module.exports.removeFor = function (string, id, length) {
  return module.exports.overwriteFor(string, "", id, length);
};

module.exports.removeBetween = function (string, id1, id2) {
  return module.exports.overwriteBetween(string, "", id1, id2);
};

module.exports.padLeft = function (string, filler, length) {
  while (string.length < length) {
    string = filler + string;
  }
  return string;
};

module.exports.padRight = function (string, filler, length) {
  while (string.length < length) {
    string += filler;
  }
  return string;
};

module.exports.findSimpleEnclosures = function (string, openTag, openLength, closeTag, closeLength) {
  var cIndex, cIndexRel, oIndex, oIndexRel, results, searchIndex;
  // openTag and closeTag can be strings or regular expressions
  // If the string is "<<>>" and the tags are "<" and ">", the result is
  //   [[0, 2], ]
  // Results are guaranteed to be in order of appearance in the original
  //   text
  results = [];
  searchIndex = 0;
  oIndexRel = string.search(openTag);
  while (true) {
    if (oIndexRel > -1) {
      oIndex = searchIndex + oIndexRel;
      cIndexRel = string.substr(oIndex + openLength).search(closeTag);
      if (cIndexRel > -1) {
        cIndex = oIndex + openLength + cIndexRel;
        results.push([oIndex, cIndex]);
        searchIndex = cIndex + closeLength;
        if (searchIndex < string.length) {
          oIndexRel = string.substr(searchIndex).search(openTag);
          continue;
        } else {
          break;
        }
      } else {
        // A tag is left open (no closing tag is found)
        // Let each implementation decide what to do in this case
        //   (either consider the tag working until the end of text
        //   or not)
        results.push([oIndex, false]);
        break;
      }
    } else {
      break;
    }
  }
  return results;
};

module.exports.findNestedEnclosures = function (string, openTag, closeTag, maskChar) {
  var cIndex, cIndexRel, closeLength, maskLength, maskedString, maskedString1, maskedString2, maskedString3, oIndex, oIndexRel, openLength, results, searchIndex;
  // openTag and closeTag must be strings, *not* regular expressions,
  //   unlike this.findSimpleEnclosures
  // maskChar must be a *1*-character string and must *not* be part of
  //   neither openTag nor closeTag
  // If the string is "<<>>" and the tags are "<" and ">", the result is
  //   [[1, 2], [0, 3]]
  openLength = openTag.length;
  closeLength = closeTag.length;
  results = [];
  searchIndex = 0;
  cIndexRel = string.indexOf(closeTag);
  maskedString = string;
  while (true) {
    if (cIndexRel > -1) {
      cIndex = searchIndex + cIndexRel;
      oIndexRel = maskedString.substring(searchIndex, cIndex).lastIndexOf(openTag);
      if (oIndexRel > -1) {
        oIndex = searchIndex + oIndexRel;
        results.push([oIndex, cIndex]);
        maskedString1 = maskedString.substring(0, oIndex);
        maskLength = cIndex - oIndex + closeLength;
        maskedString2 = module.exports.padRight("", maskChar, maskLength);
        maskedString3 = maskedString.substring(cIndex + closeLength);
        maskedString = maskedString1 + maskedString2 + maskedString3;
      } else {
        // Do *not* increment searchIndex in this case, in fact in
        //   we don't know yet whether there are more openTags
        //   before the one found
        searchIndex = cIndex + closeLength;
      }
      cIndexRel = maskedString.substring(searchIndex).indexOf(closeTag);
      continue;
    } else {
      break;
    }
  }
  return [results, maskedString];
};

module.exports.findInnermostEnclosures = function (string, openTag, closeTag) {
  var cIndex, cIndexRel, closeLength, oIndex, oIndexRel, openLength, results, searchIndex;
  // openTag and closeTag must be strings, *not* regular expressions,
  //   unlike this.findSimpleEnclosures
  // If the string is "<<>>" and the tags are "<" and ">", the result is
  //   [[1, 2], ]
  openLength = openTag.length;
  closeLength = closeTag.length;
  results = [];
  searchIndex = 0;
  while (true) {
    cIndexRel = string.substring(searchIndex).indexOf(closeTag);
    if (cIndexRel > -1) {
      cIndex = searchIndex + cIndexRel;
      oIndexRel = string.substring(searchIndex, cIndex).lastIndexOf(openTag);
      if (oIndexRel > -1) {
        oIndex = searchIndex + oIndexRel;
        results.push([oIndex, cIndex]);
      }
      searchIndex = cIndex + closeLength;
      continue;
    } else {
      break;
    }
  }
  return results;
};
},{}],8:[function(require,module,exports){
(function (global){
"use strict";

require("core-js/shim");

require("regenerator-runtime/runtime");

require("core-js/fn/regexp/escape");

if (global._babelPolyfill) {
  throw new Error("only one instance of babel-polyfill is allowed");
}
global._babelPolyfill = true;

var DEFINE_PROPERTY = "defineProperty";
function define(O, key, value) {
  O[key] || Object[DEFINE_PROPERTY](O, key, {
    writable: true,
    configurable: true,
    value: value
  });
}

define(String.prototype, "padLeft", "".padStart);
define(String.prototype, "padRight", "".padEnd);

"pop,reverse,shift,keys,values,entries,indexOf,every,some,forEach,map,filter,find,findIndex,includes,join,slice,concat,push,splice,unshift,sort,lastIndexOf,reduce,reduceRight,copyWithin,fill".split(",").forEach(function (key) {
  [][key] && define(Array, key, Function.call.bind([][key]));
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"core-js/fn/regexp/escape":13,"core-js/shim":335,"regenerator-runtime/runtime":9}],9:[function(require,module,exports){
(function (global){
/**
 * Copyright (c) 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
 * additional grant of patent rights can be found in the PATENTS file in
 * the same directory.
 */

!(function(global) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  var inModule = typeof module === "object";
  var runtime = global.regeneratorRuntime;
  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    }
    // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.
    return;
  }

  // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.
  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  runtime.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  runtime.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  runtime.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  runtime.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration. If the Promise is rejected, however, the
          // result for this iteration will be rejected with the same
          // reason. Note that rejections of yielded Promises are not
          // thrown back into the generator function, as is the case
          // when an awaited Promise is rejected. This difference in
          // behavior between yield and await is important, because it
          // allows the consumer to decide what to do with the yielded
          // rejection (swallow it and continue, manually .throw it back
          // into the generator, abandon iteration, whatever). With
          // await, by contrast, there is no opportunity to examine the
          // rejection reason outside the generator function, so the
          // only option is to throw it from the await expression, and
          // let the generator function handle the exception.
          result.value = unwrapped;
          resolve(result);
        }, reject);
      }
    }

    if (typeof global.process === "object" && global.process.domain) {
      invoke = global.process.domain.bind(invoke);
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  runtime.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList)
    );

    return runtime.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        if (delegate.iterator.return) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  runtime.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  runtime.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };
})(
  // Among the various tricks for obtaining a reference to the global
  // object, this seems to be the most reliable technique that does not
  // use indirect eval (which violates Content Security Policy).
  typeof global === "object" ? global :
  typeof window === "object" ? window :
  typeof self === "object" ? self : this
);

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],10:[function(require,module,exports){

},{}],11:[function(require,module,exports){
/*!
 * Cross-Browser Split 1.1.1
 * Copyright 2007-2012 Steven Levithan <stevenlevithan.com>
 * Available under the MIT License
 * ECMAScript compliant, uniform cross-browser split method
 */

/**
 * Splits a string into an array of strings using a regex or string separator. Matches of the
 * separator are not included in the result array. However, if `separator` is a regex that contains
 * capturing groups, backreferences are spliced into the result each time `separator` is matched.
 * Fixes browser bugs compared to the native `String.prototype.split` and can be used reliably
 * cross-browser.
 * @param {String} str String to split.
 * @param {RegExp|String} separator Regex or string to use for separating the string.
 * @param {Number} [limit] Maximum number of items to include in the result array.
 * @returns {Array} Array of substrings.
 * @example
 *
 * // Basic use
 * split('a b c d', ' ');
 * // -> ['a', 'b', 'c', 'd']
 *
 * // With limit
 * split('a b c d', ' ', 2);
 * // -> ['a', 'b']
 *
 * // Backreferences in result array
 * split('..word1 word2..', /([a-z]+)(\d+)/i);
 * // -> ['..', 'word', '1', ' ', 'word', '2', '..']
 */
module.exports = (function split(undef) {

  var nativeSplit = String.prototype.split,
    compliantExecNpcg = /()??/.exec("")[1] === undef,
    // NPCG: nonparticipating capturing group
    self;

  self = function(str, separator, limit) {
    // If `separator` is not a regex, use `nativeSplit`
    if (Object.prototype.toString.call(separator) !== "[object RegExp]") {
      return nativeSplit.call(str, separator, limit);
    }
    var output = [],
      flags = (separator.ignoreCase ? "i" : "") + (separator.multiline ? "m" : "") + (separator.extended ? "x" : "") + // Proposed for ES6
      (separator.sticky ? "y" : ""),
      // Firefox 3+
      lastLastIndex = 0,
      // Make `global` and avoid `lastIndex` issues by working with a copy
      separator = new RegExp(separator.source, flags + "g"),
      separator2, match, lastIndex, lastLength;
    str += ""; // Type-convert
    if (!compliantExecNpcg) {
      // Doesn't need flags gy, but they don't hurt
      separator2 = new RegExp("^" + separator.source + "$(?!\\s)", flags);
    }
    /* Values for `limit`, per the spec:
     * If undefined: 4294967295 // Math.pow(2, 32) - 1
     * If 0, Infinity, or NaN: 0
     * If positive number: limit = Math.floor(limit); if (limit > 4294967295) limit -= 4294967296;
     * If negative number: 4294967296 - Math.floor(Math.abs(limit))
     * If other: Type-convert, then use the above rules
     */
    limit = limit === undef ? -1 >>> 0 : // Math.pow(2, 32) - 1
    limit >>> 0; // ToUint32(limit)
    while (match = separator.exec(str)) {
      // `separator.lastIndex` is not reliable cross-browser
      lastIndex = match.index + match[0].length;
      if (lastIndex > lastLastIndex) {
        output.push(str.slice(lastLastIndex, match.index));
        // Fix browsers whose `exec` methods don't consistently return `undefined` for
        // nonparticipating capturing groups
        if (!compliantExecNpcg && match.length > 1) {
          match[0].replace(separator2, function() {
            for (var i = 1; i < arguments.length - 2; i++) {
              if (arguments[i] === undef) {
                match[i] = undef;
              }
            }
          });
        }
        if (match.length > 1 && match.index < str.length) {
          Array.prototype.push.apply(output, match.slice(1));
        }
        lastLength = match[0].length;
        lastLastIndex = lastIndex;
        if (output.length >= limit) {
          break;
        }
      }
      if (separator.lastIndex === match.index) {
        separator.lastIndex++; // Avoid an infinite loop
      }
    }
    if (lastLastIndex === str.length) {
      if (lastLength || !separator.test("")) {
        output.push("");
      }
    } else {
      output.push(str.slice(lastLastIndex));
    }
    return output.length > limit ? output.slice(0, limit) : output;
  };

  return self;
})();

},{}],12:[function(require,module,exports){
// contains, add, remove, toggle
var indexof = require('indexof')

module.exports = ClassList

function ClassList(elem) {
    var cl = elem.classList

    if (cl) {
        return cl
    }

    var classList = {
        add: add
        , remove: remove
        , contains: contains
        , toggle: toggle
        , toString: $toString
        , length: 0
        , item: item
    }

    return classList

    function add(token) {
        var list = getTokens()
        if (indexof(list, token) > -1) {
            return
        }
        list.push(token)
        setTokens(list)
    }

    function remove(token) {
        var list = getTokens()
            , index = indexof(list, token)

        if (index === -1) {
            return
        }

        list.splice(index, 1)
        setTokens(list)
    }

    function contains(token) {
        return indexof(getTokens(), token) > -1
    }

    function toggle(token) {
        if (contains(token)) {
            remove(token)
            return false
        } else {
            add(token)
            return true
        }
    }

    function $toString() {
        return elem.className
    }

    function item(index) {
        var tokens = getTokens()
        return tokens[index] || null
    }

    function getTokens() {
        var className = elem.className

        return filter(className.split(" "), isTruthy)
    }

    function setTokens(list) {
        var length = list.length

        elem.className = list.join(" ")
        classList.length = length

        for (var i = 0; i < list.length; i++) {
            classList[i] = list[i]
        }

        delete list[length]
    }
}

function filter (arr, fn) {
    var ret = []
    for (var i = 0; i < arr.length; i++) {
        if (fn(arr[i])) ret.push(arr[i])
    }
    return ret
}

function isTruthy(value) {
    return !!value
}

},{"indexof":343}],13:[function(require,module,exports){
require('../../modules/core.regexp.escape');
module.exports = require('../../modules/_core').RegExp.escape;

},{"../../modules/_core":34,"../../modules/core.regexp.escape":138}],14:[function(require,module,exports){
module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};

},{}],15:[function(require,module,exports){
var cof = require('./_cof');
module.exports = function (it, msg) {
  if (typeof it != 'number' && cof(it) != 'Number') throw TypeError(msg);
  return +it;
};

},{"./_cof":29}],16:[function(require,module,exports){
// 22.1.3.31 Array.prototype[@@unscopables]
var UNSCOPABLES = require('./_wks')('unscopables');
var ArrayProto = Array.prototype;
if (ArrayProto[UNSCOPABLES] == undefined) require('./_hide')(ArrayProto, UNSCOPABLES, {});
module.exports = function (key) {
  ArrayProto[UNSCOPABLES][key] = true;
};

},{"./_hide":53,"./_wks":136}],17:[function(require,module,exports){
module.exports = function (it, Constructor, name, forbiddenField) {
  if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {
    throw TypeError(name + ': incorrect invocation!');
  } return it;
};

},{}],18:[function(require,module,exports){
var isObject = require('./_is-object');
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};

},{"./_is-object":62}],19:[function(require,module,exports){
// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
'use strict';
var toObject = require('./_to-object');
var toAbsoluteIndex = require('./_to-absolute-index');
var toLength = require('./_to-length');

module.exports = [].copyWithin || function copyWithin(target /* = 0 */, start /* = 0, end = @length */) {
  var O = toObject(this);
  var len = toLength(O.length);
  var to = toAbsoluteIndex(target, len);
  var from = toAbsoluteIndex(start, len);
  var end = arguments.length > 2 ? arguments[2] : undefined;
  var count = Math.min((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to);
  var inc = 1;
  if (from < to && to < from + count) {
    inc = -1;
    from += count - 1;
    to += count - 1;
  }
  while (count-- > 0) {
    if (from in O) O[to] = O[from];
    else delete O[to];
    to += inc;
    from += inc;
  } return O;
};

},{"./_to-absolute-index":122,"./_to-length":126,"./_to-object":127}],20:[function(require,module,exports){
// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
'use strict';
var toObject = require('./_to-object');
var toAbsoluteIndex = require('./_to-absolute-index');
var toLength = require('./_to-length');
module.exports = function fill(value /* , start = 0, end = @length */) {
  var O = toObject(this);
  var length = toLength(O.length);
  var aLen = arguments.length;
  var index = toAbsoluteIndex(aLen > 1 ? arguments[1] : undefined, length);
  var end = aLen > 2 ? arguments[2] : undefined;
  var endPos = end === undefined ? length : toAbsoluteIndex(end, length);
  while (endPos > index) O[index++] = value;
  return O;
};

},{"./_to-absolute-index":122,"./_to-length":126,"./_to-object":127}],21:[function(require,module,exports){
var forOf = require('./_for-of');

module.exports = function (iter, ITERATOR) {
  var result = [];
  forOf(iter, false, result.push, result, ITERATOR);
  return result;
};

},{"./_for-of":50}],22:[function(require,module,exports){
// false -> Array#indexOf
// true  -> Array#includes
var toIObject = require('./_to-iobject');
var toLength = require('./_to-length');
var toAbsoluteIndex = require('./_to-absolute-index');
module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

},{"./_to-absolute-index":122,"./_to-iobject":125,"./_to-length":126}],23:[function(require,module,exports){
// 0 -> Array#forEach
// 1 -> Array#map
// 2 -> Array#filter
// 3 -> Array#some
// 4 -> Array#every
// 5 -> Array#find
// 6 -> Array#findIndex
var ctx = require('./_ctx');
var IObject = require('./_iobject');
var toObject = require('./_to-object');
var toLength = require('./_to-length');
var asc = require('./_array-species-create');
module.exports = function (TYPE, $create) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  var create = $create || asc;
  return function ($this, callbackfn, that) {
    var O = toObject($this);
    var self = IObject(O);
    var f = ctx(callbackfn, that, 3);
    var length = toLength(self.length);
    var index = 0;
    var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
    var val, res;
    for (;length > index; index++) if (NO_HOLES || index in self) {
      val = self[index];
      res = f(val, index, O);
      if (TYPE) {
        if (IS_MAP) result[index] = res;   // map
        else if (res) switch (TYPE) {
          case 3: return true;             // some
          case 5: return val;              // find
          case 6: return index;            // findIndex
          case 2: result.push(val);        // filter
        } else if (IS_EVERY) return false; // every
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
  };
};

},{"./_array-species-create":26,"./_ctx":36,"./_iobject":58,"./_to-length":126,"./_to-object":127}],24:[function(require,module,exports){
var aFunction = require('./_a-function');
var toObject = require('./_to-object');
var IObject = require('./_iobject');
var toLength = require('./_to-length');

module.exports = function (that, callbackfn, aLen, memo, isRight) {
  aFunction(callbackfn);
  var O = toObject(that);
  var self = IObject(O);
  var length = toLength(O.length);
  var index = isRight ? length - 1 : 0;
  var i = isRight ? -1 : 1;
  if (aLen < 2) for (;;) {
    if (index in self) {
      memo = self[index];
      index += i;
      break;
    }
    index += i;
    if (isRight ? index < 0 : length <= index) {
      throw TypeError('Reduce of empty array with no initial value');
    }
  }
  for (;isRight ? index >= 0 : length > index; index += i) if (index in self) {
    memo = callbackfn(memo, self[index], index, O);
  }
  return memo;
};

},{"./_a-function":14,"./_iobject":58,"./_to-length":126,"./_to-object":127}],25:[function(require,module,exports){
var isObject = require('./_is-object');
var isArray = require('./_is-array');
var SPECIES = require('./_wks')('species');

module.exports = function (original) {
  var C;
  if (isArray(original)) {
    C = original.constructor;
    // cross-realm fallback
    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
    if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  } return C === undefined ? Array : C;
};

},{"./_is-array":60,"./_is-object":62,"./_wks":136}],26:[function(require,module,exports){
// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
var speciesConstructor = require('./_array-species-constructor');

module.exports = function (original, length) {
  return new (speciesConstructor(original))(length);
};

},{"./_array-species-constructor":25}],27:[function(require,module,exports){
'use strict';
var aFunction = require('./_a-function');
var isObject = require('./_is-object');
var invoke = require('./_invoke');
var arraySlice = [].slice;
var factories = {};

var construct = function (F, len, args) {
  if (!(len in factories)) {
    for (var n = [], i = 0; i < len; i++) n[i] = 'a[' + i + ']';
    // eslint-disable-next-line no-new-func
    factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');
  } return factories[len](F, args);
};

module.exports = Function.bind || function bind(that /* , ...args */) {
  var fn = aFunction(this);
  var partArgs = arraySlice.call(arguments, 1);
  var bound = function (/* args... */) {
    var args = partArgs.concat(arraySlice.call(arguments));
    return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that);
  };
  if (isObject(fn.prototype)) bound.prototype = fn.prototype;
  return bound;
};

},{"./_a-function":14,"./_invoke":57,"./_is-object":62}],28:[function(require,module,exports){
// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = require('./_cof');
var TAG = require('./_wks')('toStringTag');
// ES3 wrong here
var ARG = cof(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (e) { /* empty */ }
};

module.exports = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};

},{"./_cof":29,"./_wks":136}],29:[function(require,module,exports){
var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};

},{}],30:[function(require,module,exports){
'use strict';
var dP = require('./_object-dp').f;
var create = require('./_object-create');
var redefineAll = require('./_redefine-all');
var ctx = require('./_ctx');
var anInstance = require('./_an-instance');
var forOf = require('./_for-of');
var $iterDefine = require('./_iter-define');
var step = require('./_iter-step');
var setSpecies = require('./_set-species');
var DESCRIPTORS = require('./_descriptors');
var fastKey = require('./_meta').fastKey;
var validate = require('./_validate-collection');
var SIZE = DESCRIPTORS ? '_s' : 'size';

var getEntry = function (that, key) {
  // fast case
  var index = fastKey(key);
  var entry;
  if (index !== 'F') return that._i[index];
  // frozen object case
  for (entry = that._f; entry; entry = entry.n) {
    if (entry.k == key) return entry;
  }
};

module.exports = {
  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME;         // collection type
      that._i = create(null); // index
      that._f = undefined;    // first entry
      that._l = undefined;    // last entry
      that[SIZE] = 0;         // size
      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear() {
        for (var that = validate(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {
          entry.r = true;
          if (entry.p) entry.p = entry.p.n = undefined;
          delete data[entry.i];
        }
        that._f = that._l = undefined;
        that[SIZE] = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function (key) {
        var that = validate(this, NAME);
        var entry = getEntry(that, key);
        if (entry) {
          var next = entry.n;
          var prev = entry.p;
          delete that._i[entry.i];
          entry.r = true;
          if (prev) prev.n = next;
          if (next) next.p = prev;
          if (that._f == entry) that._f = next;
          if (that._l == entry) that._l = prev;
          that[SIZE]--;
        } return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn /* , that = undefined */) {
        validate(this, NAME);
        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
        var entry;
        while (entry = entry ? entry.n : this._f) {
          f(entry.v, entry.k, this);
          // revert to the last existing entry
          while (entry && entry.r) entry = entry.p;
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key) {
        return !!getEntry(validate(this, NAME), key);
      }
    });
    if (DESCRIPTORS) dP(C.prototype, 'size', {
      get: function () {
        return validate(this, NAME)[SIZE];
      }
    });
    return C;
  },
  def: function (that, key, value) {
    var entry = getEntry(that, key);
    var prev, index;
    // change existing entry
    if (entry) {
      entry.v = value;
    // create new entry
    } else {
      that._l = entry = {
        i: index = fastKey(key, true), // <- index
        k: key,                        // <- key
        v: value,                      // <- value
        p: prev = that._l,             // <- previous entry
        n: undefined,                  // <- next entry
        r: false                       // <- removed
      };
      if (!that._f) that._f = entry;
      if (prev) prev.n = entry;
      that[SIZE]++;
      // add to index
      if (index !== 'F') that._i[index] = entry;
    } return that;
  },
  getEntry: getEntry,
  setStrong: function (C, NAME, IS_MAP) {
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    $iterDefine(C, NAME, function (iterated, kind) {
      this._t = validate(iterated, NAME); // target
      this._k = kind;                     // kind
      this._l = undefined;                // previous
    }, function () {
      var that = this;
      var kind = that._k;
      var entry = that._l;
      // revert to the last existing entry
      while (entry && entry.r) entry = entry.p;
      // get next entry
      if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
        // or finish the iteration
        that._t = undefined;
        return step(1);
      }
      // return step by kind
      if (kind == 'keys') return step(0, entry.k);
      if (kind == 'values') return step(0, entry.v);
      return step(0, [entry.k, entry.v]);
    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);

    // add [@@species], 23.1.2.2, 23.2.2.2
    setSpecies(NAME);
  }
};

},{"./_an-instance":17,"./_ctx":36,"./_descriptors":40,"./_for-of":50,"./_iter-define":66,"./_iter-step":68,"./_meta":76,"./_object-create":81,"./_object-dp":82,"./_redefine-all":101,"./_set-species":108,"./_validate-collection":133}],31:[function(require,module,exports){
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var classof = require('./_classof');
var from = require('./_array-from-iterable');
module.exports = function (NAME) {
  return function toJSON() {
    if (classof(this) != NAME) throw TypeError(NAME + "#toJSON isn't generic");
    return from(this);
  };
};

},{"./_array-from-iterable":21,"./_classof":28}],32:[function(require,module,exports){
'use strict';
var redefineAll = require('./_redefine-all');
var getWeak = require('./_meta').getWeak;
var anObject = require('./_an-object');
var isObject = require('./_is-object');
var anInstance = require('./_an-instance');
var forOf = require('./_for-of');
var createArrayMethod = require('./_array-methods');
var $has = require('./_has');
var validate = require('./_validate-collection');
var arrayFind = createArrayMethod(5);
var arrayFindIndex = createArrayMethod(6);
var id = 0;

// fallback for uncaught frozen keys
var uncaughtFrozenStore = function (that) {
  return that._l || (that._l = new UncaughtFrozenStore());
};
var UncaughtFrozenStore = function () {
  this.a = [];
};
var findUncaughtFrozen = function (store, key) {
  return arrayFind(store.a, function (it) {
    return it[0] === key;
  });
};
UncaughtFrozenStore.prototype = {
  get: function (key) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) return entry[1];
  },
  has: function (key) {
    return !!findUncaughtFrozen(this, key);
  },
  set: function (key, value) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) entry[1] = value;
    else this.a.push([key, value]);
  },
  'delete': function (key) {
    var index = arrayFindIndex(this.a, function (it) {
      return it[0] === key;
    });
    if (~index) this.a.splice(index, 1);
    return !!~index;
  }
};

module.exports = {
  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME;      // collection type
      that._i = id++;      // collection id
      that._l = undefined; // leak store for uncaught frozen objects
      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.3.3.2 WeakMap.prototype.delete(key)
      // 23.4.3.3 WeakSet.prototype.delete(value)
      'delete': function (key) {
        if (!isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(validate(this, NAME))['delete'](key);
        return data && $has(data, this._i) && delete data[this._i];
      },
      // 23.3.3.4 WeakMap.prototype.has(key)
      // 23.4.3.4 WeakSet.prototype.has(value)
      has: function has(key) {
        if (!isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(validate(this, NAME)).has(key);
        return data && $has(data, this._i);
      }
    });
    return C;
  },
  def: function (that, key, value) {
    var data = getWeak(anObject(key), true);
    if (data === true) uncaughtFrozenStore(that).set(key, value);
    else data[that._i] = value;
    return that;
  },
  ufstore: uncaughtFrozenStore
};

},{"./_an-instance":17,"./_an-object":18,"./_array-methods":23,"./_for-of":50,"./_has":52,"./_is-object":62,"./_meta":76,"./_redefine-all":101,"./_validate-collection":133}],33:[function(require,module,exports){
'use strict';
var global = require('./_global');
var $export = require('./_export');
var redefine = require('./_redefine');
var redefineAll = require('./_redefine-all');
var meta = require('./_meta');
var forOf = require('./_for-of');
var anInstance = require('./_an-instance');
var isObject = require('./_is-object');
var fails = require('./_fails');
var $iterDetect = require('./_iter-detect');
var setToStringTag = require('./_set-to-string-tag');
var inheritIfRequired = require('./_inherit-if-required');

module.exports = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
  var Base = global[NAME];
  var C = Base;
  var ADDER = IS_MAP ? 'set' : 'add';
  var proto = C && C.prototype;
  var O = {};
  var fixMethod = function (KEY) {
    var fn = proto[KEY];
    redefine(proto, KEY,
      KEY == 'delete' ? function (a) {
        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'has' ? function has(a) {
        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'get' ? function get(a) {
        return IS_WEAK && !isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'add' ? function add(a) { fn.call(this, a === 0 ? 0 : a); return this; }
        : function set(a, b) { fn.call(this, a === 0 ? 0 : a, b); return this; }
    );
  };
  if (typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function () {
    new C().entries().next();
  }))) {
    // create collection constructor
    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
    redefineAll(C.prototype, methods);
    meta.NEED = true;
  } else {
    var instance = new C();
    // early implementations not supports chaining
    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;
    // V8 ~  Chromium 40- weak-collections throws on primitives, but should return false
    var THROWS_ON_PRIMITIVES = fails(function () { instance.has(1); });
    // most early implementations doesn't supports iterables, most modern - not close it correctly
    var ACCEPT_ITERABLES = $iterDetect(function (iter) { new C(iter); }); // eslint-disable-line no-new
    // for early implementations -0 and +0 not the same
    var BUGGY_ZERO = !IS_WEAK && fails(function () {
      // V8 ~ Chromium 42- fails only with 5+ elements
      var $instance = new C();
      var index = 5;
      while (index--) $instance[ADDER](index, index);
      return !$instance.has(-0);
    });
    if (!ACCEPT_ITERABLES) {
      C = wrapper(function (target, iterable) {
        anInstance(target, C, NAME);
        var that = inheritIfRequired(new Base(), target, C);
        if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
        return that;
      });
      C.prototype = proto;
      proto.constructor = C;
    }
    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
      fixMethod('delete');
      fixMethod('has');
      IS_MAP && fixMethod('get');
    }
    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);
    // weak collections should not contains .clear method
    if (IS_WEAK && proto.clear) delete proto.clear;
  }

  setToStringTag(C, NAME);

  O[NAME] = C;
  $export($export.G + $export.W + $export.F * (C != Base), O);

  if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);

  return C;
};

},{"./_an-instance":17,"./_export":44,"./_fails":46,"./_for-of":50,"./_global":51,"./_inherit-if-required":56,"./_is-object":62,"./_iter-detect":67,"./_meta":76,"./_redefine":102,"./_redefine-all":101,"./_set-to-string-tag":109}],34:[function(require,module,exports){
var core = module.exports = { version: '2.5.1' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef

},{}],35:[function(require,module,exports){
'use strict';
var $defineProperty = require('./_object-dp');
var createDesc = require('./_property-desc');

module.exports = function (object, index, value) {
  if (index in object) $defineProperty.f(object, index, createDesc(0, value));
  else object[index] = value;
};

},{"./_object-dp":82,"./_property-desc":100}],36:[function(require,module,exports){
// optional / simple context binding
var aFunction = require('./_a-function');
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};

},{"./_a-function":14}],37:[function(require,module,exports){
'use strict';
// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()
var fails = require('./_fails');
var getTime = Date.prototype.getTime;
var $toISOString = Date.prototype.toISOString;

var lz = function (num) {
  return num > 9 ? num : '0' + num;
};

// PhantomJS / old WebKit has a broken implementations
module.exports = (fails(function () {
  return $toISOString.call(new Date(-5e13 - 1)) != '0385-07-25T07:06:39.999Z';
}) || !fails(function () {
  $toISOString.call(new Date(NaN));
})) ? function toISOString() {
  if (!isFinite(getTime.call(this))) throw RangeError('Invalid time value');
  var d = this;
  var y = d.getUTCFullYear();
  var m = d.getUTCMilliseconds();
  var s = y < 0 ? '-' : y > 9999 ? '+' : '';
  return s + ('00000' + Math.abs(y)).slice(s ? -6 : -4) +
    '-' + lz(d.getUTCMonth() + 1) + '-' + lz(d.getUTCDate()) +
    'T' + lz(d.getUTCHours()) + ':' + lz(d.getUTCMinutes()) +
    ':' + lz(d.getUTCSeconds()) + '.' + (m > 99 ? m : '0' + lz(m)) + 'Z';
} : $toISOString;

},{"./_fails":46}],38:[function(require,module,exports){
'use strict';
var anObject = require('./_an-object');
var toPrimitive = require('./_to-primitive');
var NUMBER = 'number';

module.exports = function (hint) {
  if (hint !== 'string' && hint !== NUMBER && hint !== 'default') throw TypeError('Incorrect hint');
  return toPrimitive(anObject(this), hint != NUMBER);
};

},{"./_an-object":18,"./_to-primitive":128}],39:[function(require,module,exports){
// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};

},{}],40:[function(require,module,exports){
// Thank's IE8 for his funny defineProperty
module.exports = !require('./_fails')(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});

},{"./_fails":46}],41:[function(require,module,exports){
var isObject = require('./_is-object');
var document = require('./_global').document;
// typeof document.createElement is 'object' in old IE
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};

},{"./_global":51,"./_is-object":62}],42:[function(require,module,exports){
// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');

},{}],43:[function(require,module,exports){
// all enumerable object keys, includes symbols
var getKeys = require('./_object-keys');
var gOPS = require('./_object-gops');
var pIE = require('./_object-pie');
module.exports = function (it) {
  var result = getKeys(it);
  var getSymbols = gOPS.f;
  if (getSymbols) {
    var symbols = getSymbols(it);
    var isEnum = pIE.f;
    var i = 0;
    var key;
    while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);
  } return result;
};

},{"./_object-gops":88,"./_object-keys":91,"./_object-pie":92}],44:[function(require,module,exports){
var global = require('./_global');
var core = require('./_core');
var hide = require('./_hide');
var redefine = require('./_redefine');
var ctx = require('./_ctx');
var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE];
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});
  var key, own, out, exp;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    // export native or passed
    out = (own ? target : source)[key];
    // bind timers to global for call from export context
    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // extend global
    if (target) redefine(target, key, out, type & $export.U);
    // export
    if (exports[key] != out) hide(exports, key, exp);
    if (IS_PROTO && expProto[key] != out) expProto[key] = out;
  }
};
global.core = core;
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;

},{"./_core":34,"./_ctx":36,"./_global":51,"./_hide":53,"./_redefine":102}],45:[function(require,module,exports){
var MATCH = require('./_wks')('match');
module.exports = function (KEY) {
  var re = /./;
  try {
    '/./'[KEY](re);
  } catch (e) {
    try {
      re[MATCH] = false;
      return !'/./'[KEY](re);
    } catch (f) { /* empty */ }
  } return true;
};

},{"./_wks":136}],46:[function(require,module,exports){
module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};

},{}],47:[function(require,module,exports){
'use strict';
var hide = require('./_hide');
var redefine = require('./_redefine');
var fails = require('./_fails');
var defined = require('./_defined');
var wks = require('./_wks');

module.exports = function (KEY, length, exec) {
  var SYMBOL = wks(KEY);
  var fns = exec(defined, SYMBOL, ''[KEY]);
  var strfn = fns[0];
  var rxfn = fns[1];
  if (fails(function () {
    var O = {};
    O[SYMBOL] = function () { return 7; };
    return ''[KEY](O) != 7;
  })) {
    redefine(String.prototype, KEY, strfn);
    hide(RegExp.prototype, SYMBOL, length == 2
      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
      // 21.2.5.11 RegExp.prototype[@@split](string, limit)
      ? function (string, arg) { return rxfn.call(string, this, arg); }
      // 21.2.5.6 RegExp.prototype[@@match](string)
      // 21.2.5.9 RegExp.prototype[@@search](string)
      : function (string) { return rxfn.call(string, this); }
    );
  }
};

},{"./_defined":39,"./_fails":46,"./_hide":53,"./_redefine":102,"./_wks":136}],48:[function(require,module,exports){
'use strict';
// 21.2.5.3 get RegExp.prototype.flags
var anObject = require('./_an-object');
module.exports = function () {
  var that = anObject(this);
  var result = '';
  if (that.global) result += 'g';
  if (that.ignoreCase) result += 'i';
  if (that.multiline) result += 'm';
  if (that.unicode) result += 'u';
  if (that.sticky) result += 'y';
  return result;
};

},{"./_an-object":18}],49:[function(require,module,exports){
'use strict';
// https://tc39.github.io/proposal-flatMap/#sec-FlattenIntoArray
var isArray = require('./_is-array');
var isObject = require('./_is-object');
var toLength = require('./_to-length');
var ctx = require('./_ctx');
var IS_CONCAT_SPREADABLE = require('./_wks')('isConcatSpreadable');

function flattenIntoArray(target, original, source, sourceLen, start, depth, mapper, thisArg) {
  var targetIndex = start;
  var sourceIndex = 0;
  var mapFn = mapper ? ctx(mapper, thisArg, 3) : false;
  var element, spreadable;

  while (sourceIndex < sourceLen) {
    if (sourceIndex in source) {
      element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];

      spreadable = false;
      if (isObject(element)) {
        spreadable = element[IS_CONCAT_SPREADABLE];
        spreadable = spreadable !== undefined ? !!spreadable : isArray(element);
      }

      if (spreadable && depth > 0) {
        targetIndex = flattenIntoArray(target, original, element, toLength(element.length), targetIndex, depth - 1) - 1;
      } else {
        if (targetIndex >= 0x1fffffffffffff) throw TypeError();
        target[targetIndex] = element;
      }

      targetIndex++;
    }
    sourceIndex++;
  }
  return targetIndex;
}

module.exports = flattenIntoArray;

},{"./_ctx":36,"./_is-array":60,"./_is-object":62,"./_to-length":126,"./_wks":136}],50:[function(require,module,exports){
var ctx = require('./_ctx');
var call = require('./_iter-call');
var isArrayIter = require('./_is-array-iter');
var anObject = require('./_an-object');
var toLength = require('./_to-length');
var getIterFn = require('./core.get-iterator-method');
var BREAK = {};
var RETURN = {};
var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
  var iterFn = ITERATOR ? function () { return iterable; } : getIterFn(iterable);
  var f = ctx(fn, that, entries ? 2 : 1);
  var index = 0;
  var length, step, iterator, result;
  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
  // fast case for arrays with default iterator
  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
    if (result === BREAK || result === RETURN) return result;
  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
    result = call(iterator, f, step.value, entries);
    if (result === BREAK || result === RETURN) return result;
  }
};
exports.BREAK = BREAK;
exports.RETURN = RETURN;

},{"./_an-object":18,"./_ctx":36,"./_is-array-iter":59,"./_iter-call":64,"./_to-length":126,"./core.get-iterator-method":137}],51:[function(require,module,exports){
// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef

},{}],52:[function(require,module,exports){
var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};

},{}],53:[function(require,module,exports){
var dP = require('./_object-dp');
var createDesc = require('./_property-desc');
module.exports = require('./_descriptors') ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};

},{"./_descriptors":40,"./_object-dp":82,"./_property-desc":100}],54:[function(require,module,exports){
var document = require('./_global').document;
module.exports = document && document.documentElement;

},{"./_global":51}],55:[function(require,module,exports){
module.exports = !require('./_descriptors') && !require('./_fails')(function () {
  return Object.defineProperty(require('./_dom-create')('div'), 'a', { get: function () { return 7; } }).a != 7;
});

},{"./_descriptors":40,"./_dom-create":41,"./_fails":46}],56:[function(require,module,exports){
var isObject = require('./_is-object');
var setPrototypeOf = require('./_set-proto').set;
module.exports = function (that, target, C) {
  var S = target.constructor;
  var P;
  if (S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf) {
    setPrototypeOf(that, P);
  } return that;
};

},{"./_is-object":62,"./_set-proto":107}],57:[function(require,module,exports){
// fast apply, http://jsperf.lnkit.com/fast-apply/5
module.exports = function (fn, args, that) {
  var un = that === undefined;
  switch (args.length) {
    case 0: return un ? fn()
                      : fn.call(that);
    case 1: return un ? fn(args[0])
                      : fn.call(that, args[0]);
    case 2: return un ? fn(args[0], args[1])
                      : fn.call(that, args[0], args[1]);
    case 3: return un ? fn(args[0], args[1], args[2])
                      : fn.call(that, args[0], args[1], args[2]);
    case 4: return un ? fn(args[0], args[1], args[2], args[3])
                      : fn.call(that, args[0], args[1], args[2], args[3]);
  } return fn.apply(that, args);
};

},{}],58:[function(require,module,exports){
// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = require('./_cof');
// eslint-disable-next-line no-prototype-builtins
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};

},{"./_cof":29}],59:[function(require,module,exports){
// check on default Array iterator
var Iterators = require('./_iterators');
var ITERATOR = require('./_wks')('iterator');
var ArrayProto = Array.prototype;

module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};

},{"./_iterators":69,"./_wks":136}],60:[function(require,module,exports){
// 7.2.2 IsArray(argument)
var cof = require('./_cof');
module.exports = Array.isArray || function isArray(arg) {
  return cof(arg) == 'Array';
};

},{"./_cof":29}],61:[function(require,module,exports){
// 20.1.2.3 Number.isInteger(number)
var isObject = require('./_is-object');
var floor = Math.floor;
module.exports = function isInteger(it) {
  return !isObject(it) && isFinite(it) && floor(it) === it;
};

},{"./_is-object":62}],62:[function(require,module,exports){
module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};

},{}],63:[function(require,module,exports){
// 7.2.8 IsRegExp(argument)
var isObject = require('./_is-object');
var cof = require('./_cof');
var MATCH = require('./_wks')('match');
module.exports = function (it) {
  var isRegExp;
  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');
};

},{"./_cof":29,"./_is-object":62,"./_wks":136}],64:[function(require,module,exports){
// call something on iterator step with safe closing on error
var anObject = require('./_an-object');
module.exports = function (iterator, fn, value, entries) {
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch (e) {
    var ret = iterator['return'];
    if (ret !== undefined) anObject(ret.call(iterator));
    throw e;
  }
};

},{"./_an-object":18}],65:[function(require,module,exports){
'use strict';
var create = require('./_object-create');
var descriptor = require('./_property-desc');
var setToStringTag = require('./_set-to-string-tag');
var IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
require('./_hide')(IteratorPrototype, require('./_wks')('iterator'), function () { return this; });

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
  setToStringTag(Constructor, NAME + ' Iterator');
};

},{"./_hide":53,"./_object-create":81,"./_property-desc":100,"./_set-to-string-tag":109,"./_wks":136}],66:[function(require,module,exports){
'use strict';
var LIBRARY = require('./_library');
var $export = require('./_export');
var redefine = require('./_redefine');
var hide = require('./_hide');
var has = require('./_has');
var Iterators = require('./_iterators');
var $iterCreate = require('./_iter-create');
var setToStringTag = require('./_set-to-string-tag');
var getPrototypeOf = require('./_object-gpo');
var ITERATOR = require('./_wks')('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function () { return this; };

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);
  var getMethod = function (kind) {
    if (!BUGGY && kind in proto) return proto[kind];
    switch (kind) {
      case KEYS: return function keys() { return new Constructor(this, kind); };
      case VALUES: return function values() { return new Constructor(this, kind); };
    } return function entries() { return new Constructor(this, kind); };
  };
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  // Fix native
  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if (!LIBRARY && !has(IteratorPrototype, ITERATOR)) hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;
    $default = function values() { return $native.call(this); };
  }
  // Define iterator
  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;
  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};

},{"./_export":44,"./_has":52,"./_hide":53,"./_iter-create":65,"./_iterators":69,"./_library":70,"./_object-gpo":89,"./_redefine":102,"./_set-to-string-tag":109,"./_wks":136}],67:[function(require,module,exports){
var ITERATOR = require('./_wks')('iterator');
var SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();
  riter['return'] = function () { SAFE_CLOSING = true; };
  // eslint-disable-next-line no-throw-literal
  Array.from(riter, function () { throw 2; });
} catch (e) { /* empty */ }

module.exports = function (exec, skipClosing) {
  if (!skipClosing && !SAFE_CLOSING) return false;
  var safe = false;
  try {
    var arr = [7];
    var iter = arr[ITERATOR]();
    iter.next = function () { return { done: safe = true }; };
    arr[ITERATOR] = function () { return iter; };
    exec(arr);
  } catch (e) { /* empty */ }
  return safe;
};

},{"./_wks":136}],68:[function(require,module,exports){
module.exports = function (done, value) {
  return { value: value, done: !!done };
};

},{}],69:[function(require,module,exports){
module.exports = {};

},{}],70:[function(require,module,exports){
module.exports = false;

},{}],71:[function(require,module,exports){
// 20.2.2.14 Math.expm1(x)
var $expm1 = Math.expm1;
module.exports = (!$expm1
  // Old FF bug
  || $expm1(10) > 22025.465794806719 || $expm1(10) < 22025.4657948067165168
  // Tor Browser bug
  || $expm1(-2e-17) != -2e-17
) ? function expm1(x) {
  return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : Math.exp(x) - 1;
} : $expm1;

},{}],72:[function(require,module,exports){
// 20.2.2.16 Math.fround(x)
var sign = require('./_math-sign');
var pow = Math.pow;
var EPSILON = pow(2, -52);
var EPSILON32 = pow(2, -23);
var MAX32 = pow(2, 127) * (2 - EPSILON32);
var MIN32 = pow(2, -126);

var roundTiesToEven = function (n) {
  return n + 1 / EPSILON - 1 / EPSILON;
};

module.exports = Math.fround || function fround(x) {
  var $abs = Math.abs(x);
  var $sign = sign(x);
  var a, result;
  if ($abs < MIN32) return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
  a = (1 + EPSILON32 / EPSILON) * $abs;
  result = a - (a - $abs);
  // eslint-disable-next-line no-self-compare
  if (result > MAX32 || result != result) return $sign * Infinity;
  return $sign * result;
};

},{"./_math-sign":75}],73:[function(require,module,exports){
// 20.2.2.20 Math.log1p(x)
module.exports = Math.log1p || function log1p(x) {
  return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : Math.log(1 + x);
};

},{}],74:[function(require,module,exports){
// https://rwaldron.github.io/proposal-math-extensions/
module.exports = Math.scale || function scale(x, inLow, inHigh, outLow, outHigh) {
  if (
    arguments.length === 0
      // eslint-disable-next-line no-self-compare
      || x != x
      // eslint-disable-next-line no-self-compare
      || inLow != inLow
      // eslint-disable-next-line no-self-compare
      || inHigh != inHigh
      // eslint-disable-next-line no-self-compare
      || outLow != outLow
      // eslint-disable-next-line no-self-compare
      || outHigh != outHigh
  ) return NaN;
  if (x === Infinity || x === -Infinity) return x;
  return (x - inLow) * (outHigh - outLow) / (inHigh - inLow) + outLow;
};

},{}],75:[function(require,module,exports){
// 20.2.2.28 Math.sign(x)
module.exports = Math.sign || function sign(x) {
  // eslint-disable-next-line no-self-compare
  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
};

},{}],76:[function(require,module,exports){
var META = require('./_uid')('meta');
var isObject = require('./_is-object');
var has = require('./_has');
var setDesc = require('./_object-dp').f;
var id = 0;
var isExtensible = Object.isExtensible || function () {
  return true;
};
var FREEZE = !require('./_fails')(function () {
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function (it) {
  setDesc(it, META, { value: {
    i: 'O' + ++id, // object ID
    w: {}          // weak collections IDs
  } });
};
var fastKey = function (it, create) {
  // return primitive with prefix
  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F';
    // not necessary to add metadata
    if (!create) return 'E';
    // add missing metadata
    setMeta(it);
  // return object ID
  } return it[META].i;
};
var getWeak = function (it, create) {
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true;
    // not necessary to add metadata
    if (!create) return false;
    // add missing metadata
    setMeta(it);
  // return hash weak collections IDs
  } return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function (it) {
  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY: META,
  NEED: false,
  fastKey: fastKey,
  getWeak: getWeak,
  onFreeze: onFreeze
};

},{"./_fails":46,"./_has":52,"./_is-object":62,"./_object-dp":82,"./_uid":132}],77:[function(require,module,exports){
var Map = require('./es6.map');
var $export = require('./_export');
var shared = require('./_shared')('metadata');
var store = shared.store || (shared.store = new (require('./es6.weak-map'))());

var getOrCreateMetadataMap = function (target, targetKey, create) {
  var targetMetadata = store.get(target);
  if (!targetMetadata) {
    if (!create) return undefined;
    store.set(target, targetMetadata = new Map());
  }
  var keyMetadata = targetMetadata.get(targetKey);
  if (!keyMetadata) {
    if (!create) return undefined;
    targetMetadata.set(targetKey, keyMetadata = new Map());
  } return keyMetadata;
};
var ordinaryHasOwnMetadata = function (MetadataKey, O, P) {
  var metadataMap = getOrCreateMetadataMap(O, P, false);
  return metadataMap === undefined ? false : metadataMap.has(MetadataKey);
};
var ordinaryGetOwnMetadata = function (MetadataKey, O, P) {
  var metadataMap = getOrCreateMetadataMap(O, P, false);
  return metadataMap === undefined ? undefined : metadataMap.get(MetadataKey);
};
var ordinaryDefineOwnMetadata = function (MetadataKey, MetadataValue, O, P) {
  getOrCreateMetadataMap(O, P, true).set(MetadataKey, MetadataValue);
};
var ordinaryOwnMetadataKeys = function (target, targetKey) {
  var metadataMap = getOrCreateMetadataMap(target, targetKey, false);
  var keys = [];
  if (metadataMap) metadataMap.forEach(function (_, key) { keys.push(key); });
  return keys;
};
var toMetaKey = function (it) {
  return it === undefined || typeof it == 'symbol' ? it : String(it);
};
var exp = function (O) {
  $export($export.S, 'Reflect', O);
};

module.exports = {
  store: store,
  map: getOrCreateMetadataMap,
  has: ordinaryHasOwnMetadata,
  get: ordinaryGetOwnMetadata,
  set: ordinaryDefineOwnMetadata,
  keys: ordinaryOwnMetadataKeys,
  key: toMetaKey,
  exp: exp
};

},{"./_export":44,"./_shared":111,"./es6.map":168,"./es6.weak-map":274}],78:[function(require,module,exports){
var global = require('./_global');
var macrotask = require('./_task').set;
var Observer = global.MutationObserver || global.WebKitMutationObserver;
var process = global.process;
var Promise = global.Promise;
var isNode = require('./_cof')(process) == 'process';

module.exports = function () {
  var head, last, notify;

  var flush = function () {
    var parent, fn;
    if (isNode && (parent = process.domain)) parent.exit();
    while (head) {
      fn = head.fn;
      head = head.next;
      try {
        fn();
      } catch (e) {
        if (head) notify();
        else last = undefined;
        throw e;
      }
    } last = undefined;
    if (parent) parent.enter();
  };

  // Node.js
  if (isNode) {
    notify = function () {
      process.nextTick(flush);
    };
  // browsers with MutationObserver
  } else if (Observer) {
    var toggle = true;
    var node = document.createTextNode('');
    new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new
    notify = function () {
      node.data = toggle = !toggle;
    };
  // environments with maybe non-completely correct, but existent Promise
  } else if (Promise && Promise.resolve) {
    var promise = Promise.resolve();
    notify = function () {
      promise.then(flush);
    };
  // for other environments - macrotask based on:
  // - setImmediate
  // - MessageChannel
  // - window.postMessag
  // - onreadystatechange
  // - setTimeout
  } else {
    notify = function () {
      // strange IE + webpack dev server bug - use .call(global)
      macrotask.call(global, flush);
    };
  }

  return function (fn) {
    var task = { fn: fn, next: undefined };
    if (last) last.next = task;
    if (!head) {
      head = task;
      notify();
    } last = task;
  };
};

},{"./_cof":29,"./_global":51,"./_task":121}],79:[function(require,module,exports){
'use strict';
// 25.4.1.5 NewPromiseCapability(C)
var aFunction = require('./_a-function');

function PromiseCapability(C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject = $$reject;
  });
  this.resolve = aFunction(resolve);
  this.reject = aFunction(reject);
}

module.exports.f = function (C) {
  return new PromiseCapability(C);
};

},{"./_a-function":14}],80:[function(require,module,exports){
'use strict';
// 19.1.2.1 Object.assign(target, source, ...)
var getKeys = require('./_object-keys');
var gOPS = require('./_object-gops');
var pIE = require('./_object-pie');
var toObject = require('./_to-object');
var IObject = require('./_iobject');
var $assign = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = !$assign || require('./_fails')(function () {
  var A = {};
  var B = {};
  // eslint-disable-next-line no-undef
  var S = Symbol();
  var K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function (k) { B[k] = k; });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source) { // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var aLen = arguments.length;
  var index = 1;
  var getSymbols = gOPS.f;
  var isEnum = pIE.f;
  while (aLen > index) {
    var S = IObject(arguments[index++]);
    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) if (isEnum.call(S, key = keys[j++])) T[key] = S[key];
  } return T;
} : $assign;

},{"./_fails":46,"./_iobject":58,"./_object-gops":88,"./_object-keys":91,"./_object-pie":92,"./_to-object":127}],81:[function(require,module,exports){
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = require('./_an-object');
var dPs = require('./_object-dps');
var enumBugKeys = require('./_enum-bug-keys');
var IE_PROTO = require('./_shared-key')('IE_PROTO');
var Empty = function () { /* empty */ };
var PROTOTYPE = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = require('./_dom-create')('iframe');
  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';
  require('./_html').appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};

},{"./_an-object":18,"./_dom-create":41,"./_enum-bug-keys":42,"./_html":54,"./_object-dps":83,"./_shared-key":110}],82:[function(require,module,exports){
var anObject = require('./_an-object');
var IE8_DOM_DEFINE = require('./_ie8-dom-define');
var toPrimitive = require('./_to-primitive');
var dP = Object.defineProperty;

exports.f = require('./_descriptors') ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};

},{"./_an-object":18,"./_descriptors":40,"./_ie8-dom-define":55,"./_to-primitive":128}],83:[function(require,module,exports){
var dP = require('./_object-dp');
var anObject = require('./_an-object');
var getKeys = require('./_object-keys');

module.exports = require('./_descriptors') ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;
  while (length > i) dP.f(O, P = keys[i++], Properties[P]);
  return O;
};

},{"./_an-object":18,"./_descriptors":40,"./_object-dp":82,"./_object-keys":91}],84:[function(require,module,exports){
'use strict';
// Forced replacement prototype accessors methods
module.exports = require('./_library') || !require('./_fails')(function () {
  var K = Math.random();
  // In FF throws only define methods
  // eslint-disable-next-line no-undef, no-useless-call
  __defineSetter__.call(null, K, function () { /* empty */ });
  delete require('./_global')[K];
});

},{"./_fails":46,"./_global":51,"./_library":70}],85:[function(require,module,exports){
var pIE = require('./_object-pie');
var createDesc = require('./_property-desc');
var toIObject = require('./_to-iobject');
var toPrimitive = require('./_to-primitive');
var has = require('./_has');
var IE8_DOM_DEFINE = require('./_ie8-dom-define');
var gOPD = Object.getOwnPropertyDescriptor;

exports.f = require('./_descriptors') ? gOPD : function getOwnPropertyDescriptor(O, P) {
  O = toIObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return gOPD(O, P);
  } catch (e) { /* empty */ }
  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
};

},{"./_descriptors":40,"./_has":52,"./_ie8-dom-define":55,"./_object-pie":92,"./_property-desc":100,"./_to-iobject":125,"./_to-primitive":128}],86:[function(require,module,exports){
// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = require('./_to-iobject');
var gOPN = require('./_object-gopn').f;
var toString = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return gOPN(it);
  } catch (e) {
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};

},{"./_object-gopn":87,"./_to-iobject":125}],87:[function(require,module,exports){
// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys = require('./_object-keys-internal');
var hiddenKeys = require('./_enum-bug-keys').concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return $keys(O, hiddenKeys);
};

},{"./_enum-bug-keys":42,"./_object-keys-internal":90}],88:[function(require,module,exports){
exports.f = Object.getOwnPropertySymbols;

},{}],89:[function(require,module,exports){
// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = require('./_has');
var toObject = require('./_to-object');
var IE_PROTO = require('./_shared-key')('IE_PROTO');
var ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};

},{"./_has":52,"./_shared-key":110,"./_to-object":127}],90:[function(require,module,exports){
var has = require('./_has');
var toIObject = require('./_to-iobject');
var arrayIndexOf = require('./_array-includes')(false);
var IE_PROTO = require('./_shared-key')('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};

},{"./_array-includes":22,"./_has":52,"./_shared-key":110,"./_to-iobject":125}],91:[function(require,module,exports){
// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = require('./_object-keys-internal');
var enumBugKeys = require('./_enum-bug-keys');

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};

},{"./_enum-bug-keys":42,"./_object-keys-internal":90}],92:[function(require,module,exports){
exports.f = {}.propertyIsEnumerable;

},{}],93:[function(require,module,exports){
// most Object methods by ES6 should accept primitives
var $export = require('./_export');
var core = require('./_core');
var fails = require('./_fails');
module.exports = function (KEY, exec) {
  var fn = (core.Object || {})[KEY] || Object[KEY];
  var exp = {};
  exp[KEY] = exec(fn);
  $export($export.S + $export.F * fails(function () { fn(1); }), 'Object', exp);
};

},{"./_core":34,"./_export":44,"./_fails":46}],94:[function(require,module,exports){
var getKeys = require('./_object-keys');
var toIObject = require('./_to-iobject');
var isEnum = require('./_object-pie').f;
module.exports = function (isEntries) {
  return function (it) {
    var O = toIObject(it);
    var keys = getKeys(O);
    var length = keys.length;
    var i = 0;
    var result = [];
    var key;
    while (length > i) if (isEnum.call(O, key = keys[i++])) {
      result.push(isEntries ? [key, O[key]] : O[key]);
    } return result;
  };
};

},{"./_object-keys":91,"./_object-pie":92,"./_to-iobject":125}],95:[function(require,module,exports){
// all object keys, includes non-enumerable and symbols
var gOPN = require('./_object-gopn');
var gOPS = require('./_object-gops');
var anObject = require('./_an-object');
var Reflect = require('./_global').Reflect;
module.exports = Reflect && Reflect.ownKeys || function ownKeys(it) {
  var keys = gOPN.f(anObject(it));
  var getSymbols = gOPS.f;
  return getSymbols ? keys.concat(getSymbols(it)) : keys;
};

},{"./_an-object":18,"./_global":51,"./_object-gopn":87,"./_object-gops":88}],96:[function(require,module,exports){
var $parseFloat = require('./_global').parseFloat;
var $trim = require('./_string-trim').trim;

module.exports = 1 / $parseFloat(require('./_string-ws') + '-0') !== -Infinity ? function parseFloat(str) {
  var string = $trim(String(str), 3);
  var result = $parseFloat(string);
  return result === 0 && string.charAt(0) == '-' ? -0 : result;
} : $parseFloat;

},{"./_global":51,"./_string-trim":119,"./_string-ws":120}],97:[function(require,module,exports){
var $parseInt = require('./_global').parseInt;
var $trim = require('./_string-trim').trim;
var ws = require('./_string-ws');
var hex = /^[-+]?0[xX]/;

module.exports = $parseInt(ws + '08') !== 8 || $parseInt(ws + '0x16') !== 22 ? function parseInt(str, radix) {
  var string = $trim(String(str), 3);
  return $parseInt(string, (radix >>> 0) || (hex.test(string) ? 16 : 10));
} : $parseInt;

},{"./_global":51,"./_string-trim":119,"./_string-ws":120}],98:[function(require,module,exports){
module.exports = function (exec) {
  try {
    return { e: false, v: exec() };
  } catch (e) {
    return { e: true, v: e };
  }
};

},{}],99:[function(require,module,exports){
var anObject = require('./_an-object');
var isObject = require('./_is-object');
var newPromiseCapability = require('./_new-promise-capability');

module.exports = function (C, x) {
  anObject(C);
  if (isObject(x) && x.constructor === C) return x;
  var promiseCapability = newPromiseCapability.f(C);
  var resolve = promiseCapability.resolve;
  resolve(x);
  return promiseCapability.promise;
};

},{"./_an-object":18,"./_is-object":62,"./_new-promise-capability":79}],100:[function(require,module,exports){
module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};

},{}],101:[function(require,module,exports){
var redefine = require('./_redefine');
module.exports = function (target, src, safe) {
  for (var key in src) redefine(target, key, src[key], safe);
  return target;
};

},{"./_redefine":102}],102:[function(require,module,exports){
var global = require('./_global');
var hide = require('./_hide');
var has = require('./_has');
var SRC = require('./_uid')('src');
var TO_STRING = 'toString';
var $toString = Function[TO_STRING];
var TPL = ('' + $toString).split(TO_STRING);

require('./_core').inspectSource = function (it) {
  return $toString.call(it);
};

(module.exports = function (O, key, val, safe) {
  var isFunction = typeof val == 'function';
  if (isFunction) has(val, 'name') || hide(val, 'name', key);
  if (O[key] === val) return;
  if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
  if (O === global) {
    O[key] = val;
  } else if (!safe) {
    delete O[key];
    hide(O, key, val);
  } else if (O[key]) {
    O[key] = val;
  } else {
    hide(O, key, val);
  }
// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, TO_STRING, function toString() {
  return typeof this == 'function' && this[SRC] || $toString.call(this);
});

},{"./_core":34,"./_global":51,"./_has":52,"./_hide":53,"./_uid":132}],103:[function(require,module,exports){
module.exports = function (regExp, replace) {
  var replacer = replace === Object(replace) ? function (part) {
    return replace[part];
  } : replace;
  return function (it) {
    return String(it).replace(regExp, replacer);
  };
};

},{}],104:[function(require,module,exports){
// 7.2.9 SameValue(x, y)
module.exports = Object.is || function is(x, y) {
  // eslint-disable-next-line no-self-compare
  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
};

},{}],105:[function(require,module,exports){
'use strict';
// https://tc39.github.io/proposal-setmap-offrom/
var $export = require('./_export');
var aFunction = require('./_a-function');
var ctx = require('./_ctx');
var forOf = require('./_for-of');

module.exports = function (COLLECTION) {
  $export($export.S, COLLECTION, { from: function from(source /* , mapFn, thisArg */) {
    var mapFn = arguments[1];
    var mapping, A, n, cb;
    aFunction(this);
    mapping = mapFn !== undefined;
    if (mapping) aFunction(mapFn);
    if (source == undefined) return new this();
    A = [];
    if (mapping) {
      n = 0;
      cb = ctx(mapFn, arguments[2], 2);
      forOf(source, false, function (nextItem) {
        A.push(cb(nextItem, n++));
      });
    } else {
      forOf(source, false, A.push, A);
    }
    return new this(A);
  } });
};

},{"./_a-function":14,"./_ctx":36,"./_export":44,"./_for-of":50}],106:[function(require,module,exports){
'use strict';
// https://tc39.github.io/proposal-setmap-offrom/
var $export = require('./_export');

module.exports = function (COLLECTION) {
  $export($export.S, COLLECTION, { of: function of() {
    var length = arguments.length;
    var A = Array(length);
    while (length--) A[length] = arguments[length];
    return new this(A);
  } });
};

},{"./_export":44}],107:[function(require,module,exports){
// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var isObject = require('./_is-object');
var anObject = require('./_an-object');
var check = function (O, proto) {
  anObject(O);
  if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
};
module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
    function (test, buggy, set) {
      try {
        set = require('./_ctx')(Function.call, require('./_object-gopd').f(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch (e) { buggy = true; }
      return function setPrototypeOf(O, proto) {
        check(O, proto);
        if (buggy) O.__proto__ = proto;
        else set(O, proto);
        return O;
      };
    }({}, false) : undefined),
  check: check
};

},{"./_an-object":18,"./_ctx":36,"./_is-object":62,"./_object-gopd":85}],108:[function(require,module,exports){
'use strict';
var global = require('./_global');
var dP = require('./_object-dp');
var DESCRIPTORS = require('./_descriptors');
var SPECIES = require('./_wks')('species');

module.exports = function (KEY) {
  var C = global[KEY];
  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
    configurable: true,
    get: function () { return this; }
  });
};

},{"./_descriptors":40,"./_global":51,"./_object-dp":82,"./_wks":136}],109:[function(require,module,exports){
var def = require('./_object-dp').f;
var has = require('./_has');
var TAG = require('./_wks')('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
};

},{"./_has":52,"./_object-dp":82,"./_wks":136}],110:[function(require,module,exports){
var shared = require('./_shared')('keys');
var uid = require('./_uid');
module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};

},{"./_shared":111,"./_uid":132}],111:[function(require,module,exports){
var global = require('./_global');
var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});
module.exports = function (key) {
  return store[key] || (store[key] = {});
};

},{"./_global":51}],112:[function(require,module,exports){
// 7.3.20 SpeciesConstructor(O, defaultConstructor)
var anObject = require('./_an-object');
var aFunction = require('./_a-function');
var SPECIES = require('./_wks')('species');
module.exports = function (O, D) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
};

},{"./_a-function":14,"./_an-object":18,"./_wks":136}],113:[function(require,module,exports){
'use strict';
var fails = require('./_fails');

module.exports = function (method, arg) {
  return !!method && fails(function () {
    // eslint-disable-next-line no-useless-call
    arg ? method.call(null, function () { /* empty */ }, 1) : method.call(null);
  });
};

},{"./_fails":46}],114:[function(require,module,exports){
var toInteger = require('./_to-integer');
var defined = require('./_defined');
// true  -> String#at
// false -> String#codePointAt
module.exports = function (TO_STRING) {
  return function (that, pos) {
    var s = String(defined(that));
    var i = toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};

},{"./_defined":39,"./_to-integer":124}],115:[function(require,module,exports){
// helper for String#{startsWith, endsWith, includes}
var isRegExp = require('./_is-regexp');
var defined = require('./_defined');

module.exports = function (that, searchString, NAME) {
  if (isRegExp(searchString)) throw TypeError('String#' + NAME + " doesn't accept regex!");
  return String(defined(that));
};

},{"./_defined":39,"./_is-regexp":63}],116:[function(require,module,exports){
var $export = require('./_export');
var fails = require('./_fails');
var defined = require('./_defined');
var quot = /"/g;
// B.2.3.2.1 CreateHTML(string, tag, attribute, value)
var createHTML = function (string, tag, attribute, value) {
  var S = String(defined(string));
  var p1 = '<' + tag;
  if (attribute !== '') p1 += ' ' + attribute + '="' + String(value).replace(quot, '&quot;') + '"';
  return p1 + '>' + S + '</' + tag + '>';
};
module.exports = function (NAME, exec) {
  var O = {};
  O[NAME] = exec(createHTML);
  $export($export.P + $export.F * fails(function () {
    var test = ''[NAME]('"');
    return test !== test.toLowerCase() || test.split('"').length > 3;
  }), 'String', O);
};

},{"./_defined":39,"./_export":44,"./_fails":46}],117:[function(require,module,exports){
// https://github.com/tc39/proposal-string-pad-start-end
var toLength = require('./_to-length');
var repeat = require('./_string-repeat');
var defined = require('./_defined');

module.exports = function (that, maxLength, fillString, left) {
  var S = String(defined(that));
  var stringLength = S.length;
  var fillStr = fillString === undefined ? ' ' : String(fillString);
  var intMaxLength = toLength(maxLength);
  if (intMaxLength <= stringLength || fillStr == '') return S;
  var fillLen = intMaxLength - stringLength;
  var stringFiller = repeat.call(fillStr, Math.ceil(fillLen / fillStr.length));
  if (stringFiller.length > fillLen) stringFiller = stringFiller.slice(0, fillLen);
  return left ? stringFiller + S : S + stringFiller;
};

},{"./_defined":39,"./_string-repeat":118,"./_to-length":126}],118:[function(require,module,exports){
'use strict';
var toInteger = require('./_to-integer');
var defined = require('./_defined');

module.exports = function repeat(count) {
  var str = String(defined(this));
  var res = '';
  var n = toInteger(count);
  if (n < 0 || n == Infinity) throw RangeError("Count can't be negative");
  for (;n > 0; (n >>>= 1) && (str += str)) if (n & 1) res += str;
  return res;
};

},{"./_defined":39,"./_to-integer":124}],119:[function(require,module,exports){
var $export = require('./_export');
var defined = require('./_defined');
var fails = require('./_fails');
var spaces = require('./_string-ws');
var space = '[' + spaces + ']';
var non = '\u200b\u0085';
var ltrim = RegExp('^' + space + space + '*');
var rtrim = RegExp(space + space + '*$');

var exporter = function (KEY, exec, ALIAS) {
  var exp = {};
  var FORCE = fails(function () {
    return !!spaces[KEY]() || non[KEY]() != non;
  });
  var fn = exp[KEY] = FORCE ? exec(trim) : spaces[KEY];
  if (ALIAS) exp[ALIAS] = fn;
  $export($export.P + $export.F * FORCE, 'String', exp);
};

// 1 -> String#trimLeft
// 2 -> String#trimRight
// 3 -> String#trim
var trim = exporter.trim = function (string, TYPE) {
  string = String(defined(string));
  if (TYPE & 1) string = string.replace(ltrim, '');
  if (TYPE & 2) string = string.replace(rtrim, '');
  return string;
};

module.exports = exporter;

},{"./_defined":39,"./_export":44,"./_fails":46,"./_string-ws":120}],120:[function(require,module,exports){
module.exports = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' +
  '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';

},{}],121:[function(require,module,exports){
var ctx = require('./_ctx');
var invoke = require('./_invoke');
var html = require('./_html');
var cel = require('./_dom-create');
var global = require('./_global');
var process = global.process;
var setTask = global.setImmediate;
var clearTask = global.clearImmediate;
var MessageChannel = global.MessageChannel;
var Dispatch = global.Dispatch;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var defer, channel, port;
var run = function () {
  var id = +this;
  // eslint-disable-next-line no-prototype-builtins
  if (queue.hasOwnProperty(id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};
var listener = function (event) {
  run.call(event.data);
};
// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if (!setTask || !clearTask) {
  setTask = function setImmediate(fn) {
    var args = [];
    var i = 1;
    while (arguments.length > i) args.push(arguments[i++]);
    queue[++counter] = function () {
      // eslint-disable-next-line no-new-func
      invoke(typeof fn == 'function' ? fn : Function(fn), args);
    };
    defer(counter);
    return counter;
  };
  clearTask = function clearImmediate(id) {
    delete queue[id];
  };
  // Node.js 0.8-
  if (require('./_cof')(process) == 'process') {
    defer = function (id) {
      process.nextTick(ctx(run, id, 1));
    };
  // Sphere (JS game engine) Dispatch API
  } else if (Dispatch && Dispatch.now) {
    defer = function (id) {
      Dispatch.now(ctx(run, id, 1));
    };
  // Browsers with MessageChannel, includes WebWorkers
  } else if (MessageChannel) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = ctx(port.postMessage, port, 1);
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
    defer = function (id) {
      global.postMessage(id + '', '*');
    };
    global.addEventListener('message', listener, false);
  // IE8-
  } else if (ONREADYSTATECHANGE in cel('script')) {
    defer = function (id) {
      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {
        html.removeChild(this);
        run.call(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function (id) {
      setTimeout(ctx(run, id, 1), 0);
    };
  }
}
module.exports = {
  set: setTask,
  clear: clearTask
};

},{"./_cof":29,"./_ctx":36,"./_dom-create":41,"./_global":51,"./_html":54,"./_invoke":57}],122:[function(require,module,exports){
var toInteger = require('./_to-integer');
var max = Math.max;
var min = Math.min;
module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};

},{"./_to-integer":124}],123:[function(require,module,exports){
// https://tc39.github.io/ecma262/#sec-toindex
var toInteger = require('./_to-integer');
var toLength = require('./_to-length');
module.exports = function (it) {
  if (it === undefined) return 0;
  var number = toInteger(it);
  var length = toLength(number);
  if (number !== length) throw RangeError('Wrong length!');
  return length;
};

},{"./_to-integer":124,"./_to-length":126}],124:[function(require,module,exports){
// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};

},{}],125:[function(require,module,exports){
// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = require('./_iobject');
var defined = require('./_defined');
module.exports = function (it) {
  return IObject(defined(it));
};

},{"./_defined":39,"./_iobject":58}],126:[function(require,module,exports){
// 7.1.15 ToLength
var toInteger = require('./_to-integer');
var min = Math.min;
module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};

},{"./_to-integer":124}],127:[function(require,module,exports){
// 7.1.13 ToObject(argument)
var defined = require('./_defined');
module.exports = function (it) {
  return Object(defined(it));
};

},{"./_defined":39}],128:[function(require,module,exports){
// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = require('./_is-object');
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};

},{"./_is-object":62}],129:[function(require,module,exports){
'use strict';
if (require('./_descriptors')) {
  var LIBRARY = require('./_library');
  var global = require('./_global');
  var fails = require('./_fails');
  var $export = require('./_export');
  var $typed = require('./_typed');
  var $buffer = require('./_typed-buffer');
  var ctx = require('./_ctx');
  var anInstance = require('./_an-instance');
  var propertyDesc = require('./_property-desc');
  var hide = require('./_hide');
  var redefineAll = require('./_redefine-all');
  var toInteger = require('./_to-integer');
  var toLength = require('./_to-length');
  var toIndex = require('./_to-index');
  var toAbsoluteIndex = require('./_to-absolute-index');
  var toPrimitive = require('./_to-primitive');
  var has = require('./_has');
  var classof = require('./_classof');
  var isObject = require('./_is-object');
  var toObject = require('./_to-object');
  var isArrayIter = require('./_is-array-iter');
  var create = require('./_object-create');
  var getPrototypeOf = require('./_object-gpo');
  var gOPN = require('./_object-gopn').f;
  var getIterFn = require('./core.get-iterator-method');
  var uid = require('./_uid');
  var wks = require('./_wks');
  var createArrayMethod = require('./_array-methods');
  var createArrayIncludes = require('./_array-includes');
  var speciesConstructor = require('./_species-constructor');
  var ArrayIterators = require('./es6.array.iterator');
  var Iterators = require('./_iterators');
  var $iterDetect = require('./_iter-detect');
  var setSpecies = require('./_set-species');
  var arrayFill = require('./_array-fill');
  var arrayCopyWithin = require('./_array-copy-within');
  var $DP = require('./_object-dp');
  var $GOPD = require('./_object-gopd');
  var dP = $DP.f;
  var gOPD = $GOPD.f;
  var RangeError = global.RangeError;
  var TypeError = global.TypeError;
  var Uint8Array = global.Uint8Array;
  var ARRAY_BUFFER = 'ArrayBuffer';
  var SHARED_BUFFER = 'Shared' + ARRAY_BUFFER;
  var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
  var PROTOTYPE = 'prototype';
  var ArrayProto = Array[PROTOTYPE];
  var $ArrayBuffer = $buffer.ArrayBuffer;
  var $DataView = $buffer.DataView;
  var arrayForEach = createArrayMethod(0);
  var arrayFilter = createArrayMethod(2);
  var arraySome = createArrayMethod(3);
  var arrayEvery = createArrayMethod(4);
  var arrayFind = createArrayMethod(5);
  var arrayFindIndex = createArrayMethod(6);
  var arrayIncludes = createArrayIncludes(true);
  var arrayIndexOf = createArrayIncludes(false);
  var arrayValues = ArrayIterators.values;
  var arrayKeys = ArrayIterators.keys;
  var arrayEntries = ArrayIterators.entries;
  var arrayLastIndexOf = ArrayProto.lastIndexOf;
  var arrayReduce = ArrayProto.reduce;
  var arrayReduceRight = ArrayProto.reduceRight;
  var arrayJoin = ArrayProto.join;
  var arraySort = ArrayProto.sort;
  var arraySlice = ArrayProto.slice;
  var arrayToString = ArrayProto.toString;
  var arrayToLocaleString = ArrayProto.toLocaleString;
  var ITERATOR = wks('iterator');
  var TAG = wks('toStringTag');
  var TYPED_CONSTRUCTOR = uid('typed_constructor');
  var DEF_CONSTRUCTOR = uid('def_constructor');
  var ALL_CONSTRUCTORS = $typed.CONSTR;
  var TYPED_ARRAY = $typed.TYPED;
  var VIEW = $typed.VIEW;
  var WRONG_LENGTH = 'Wrong length!';

  var $map = createArrayMethod(1, function (O, length) {
    return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length);
  });

  var LITTLE_ENDIAN = fails(function () {
    // eslint-disable-next-line no-undef
    return new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;
  });

  var FORCED_SET = !!Uint8Array && !!Uint8Array[PROTOTYPE].set && fails(function () {
    new Uint8Array(1).set({});
  });

  var toOffset = function (it, BYTES) {
    var offset = toInteger(it);
    if (offset < 0 || offset % BYTES) throw RangeError('Wrong offset!');
    return offset;
  };

  var validate = function (it) {
    if (isObject(it) && TYPED_ARRAY in it) return it;
    throw TypeError(it + ' is not a typed array!');
  };

  var allocate = function (C, length) {
    if (!(isObject(C) && TYPED_CONSTRUCTOR in C)) {
      throw TypeError('It is not a typed array constructor!');
    } return new C(length);
  };

  var speciesFromList = function (O, list) {
    return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list);
  };

  var fromList = function (C, list) {
    var index = 0;
    var length = list.length;
    var result = allocate(C, length);
    while (length > index) result[index] = list[index++];
    return result;
  };

  var addGetter = function (it, key, internal) {
    dP(it, key, { get: function () { return this._d[internal]; } });
  };

  var $from = function from(source /* , mapfn, thisArg */) {
    var O = toObject(source);
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var iterFn = getIterFn(O);
    var i, length, values, result, step, iterator;
    if (iterFn != undefined && !isArrayIter(iterFn)) {
      for (iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++) {
        values.push(step.value);
      } O = values;
    }
    if (mapping && aLen > 2) mapfn = ctx(mapfn, arguments[2], 2);
    for (i = 0, length = toLength(O.length), result = allocate(this, length); length > i; i++) {
      result[i] = mapping ? mapfn(O[i], i) : O[i];
    }
    return result;
  };

  var $of = function of(/* ...items */) {
    var index = 0;
    var length = arguments.length;
    var result = allocate(this, length);
    while (length > index) result[index] = arguments[index++];
    return result;
  };

  // iOS Safari 6.x fails here
  var TO_LOCALE_BUG = !!Uint8Array && fails(function () { arrayToLocaleString.call(new Uint8Array(1)); });

  var $toLocaleString = function toLocaleString() {
    return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments);
  };

  var proto = {
    copyWithin: function copyWithin(target, start /* , end */) {
      return arrayCopyWithin.call(validate(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
    },
    every: function every(callbackfn /* , thisArg */) {
      return arrayEvery(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    fill: function fill(value /* , start, end */) { // eslint-disable-line no-unused-vars
      return arrayFill.apply(validate(this), arguments);
    },
    filter: function filter(callbackfn /* , thisArg */) {
      return speciesFromList(this, arrayFilter(validate(this), callbackfn,
        arguments.length > 1 ? arguments[1] : undefined));
    },
    find: function find(predicate /* , thisArg */) {
      return arrayFind(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    findIndex: function findIndex(predicate /* , thisArg */) {
      return arrayFindIndex(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    forEach: function forEach(callbackfn /* , thisArg */) {
      arrayForEach(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    indexOf: function indexOf(searchElement /* , fromIndex */) {
      return arrayIndexOf(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    includes: function includes(searchElement /* , fromIndex */) {
      return arrayIncludes(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    join: function join(separator) { // eslint-disable-line no-unused-vars
      return arrayJoin.apply(validate(this), arguments);
    },
    lastIndexOf: function lastIndexOf(searchElement /* , fromIndex */) { // eslint-disable-line no-unused-vars
      return arrayLastIndexOf.apply(validate(this), arguments);
    },
    map: function map(mapfn /* , thisArg */) {
      return $map(validate(this), mapfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    reduce: function reduce(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars
      return arrayReduce.apply(validate(this), arguments);
    },
    reduceRight: function reduceRight(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars
      return arrayReduceRight.apply(validate(this), arguments);
    },
    reverse: function reverse() {
      var that = this;
      var length = validate(that).length;
      var middle = Math.floor(length / 2);
      var index = 0;
      var value;
      while (index < middle) {
        value = that[index];
        that[index++] = that[--length];
        that[length] = value;
      } return that;
    },
    some: function some(callbackfn /* , thisArg */) {
      return arraySome(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    sort: function sort(comparefn) {
      return arraySort.call(validate(this), comparefn);
    },
    subarray: function subarray(begin, end) {
      var O = validate(this);
      var length = O.length;
      var $begin = toAbsoluteIndex(begin, length);
      return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))(
        O.buffer,
        O.byteOffset + $begin * O.BYTES_PER_ELEMENT,
        toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - $begin)
      );
    }
  };

  var $slice = function slice(start, end) {
    return speciesFromList(this, arraySlice.call(validate(this), start, end));
  };

  var $set = function set(arrayLike /* , offset */) {
    validate(this);
    var offset = toOffset(arguments[1], 1);
    var length = this.length;
    var src = toObject(arrayLike);
    var len = toLength(src.length);
    var index = 0;
    if (len + offset > length) throw RangeError(WRONG_LENGTH);
    while (index < len) this[offset + index] = src[index++];
  };

  var $iterators = {
    entries: function entries() {
      return arrayEntries.call(validate(this));
    },
    keys: function keys() {
      return arrayKeys.call(validate(this));
    },
    values: function values() {
      return arrayValues.call(validate(this));
    }
  };

  var isTAIndex = function (target, key) {
    return isObject(target)
      && target[TYPED_ARRAY]
      && typeof key != 'symbol'
      && key in target
      && String(+key) == String(key);
  };
  var $getDesc = function getOwnPropertyDescriptor(target, key) {
    return isTAIndex(target, key = toPrimitive(key, true))
      ? propertyDesc(2, target[key])
      : gOPD(target, key);
  };
  var $setDesc = function defineProperty(target, key, desc) {
    if (isTAIndex(target, key = toPrimitive(key, true))
      && isObject(desc)
      && has(desc, 'value')
      && !has(desc, 'get')
      && !has(desc, 'set')
      // TODO: add validation descriptor w/o calling accessors
      && !desc.configurable
      && (!has(desc, 'writable') || desc.writable)
      && (!has(desc, 'enumerable') || desc.enumerable)
    ) {
      target[key] = desc.value;
      return target;
    } return dP(target, key, desc);
  };

  if (!ALL_CONSTRUCTORS) {
    $GOPD.f = $getDesc;
    $DP.f = $setDesc;
  }

  $export($export.S + $export.F * !ALL_CONSTRUCTORS, 'Object', {
    getOwnPropertyDescriptor: $getDesc,
    defineProperty: $setDesc
  });

  if (fails(function () { arrayToString.call({}); })) {
    arrayToString = arrayToLocaleString = function toString() {
      return arrayJoin.call(this);
    };
  }

  var $TypedArrayPrototype$ = redefineAll({}, proto);
  redefineAll($TypedArrayPrototype$, $iterators);
  hide($TypedArrayPrototype$, ITERATOR, $iterators.values);
  redefineAll($TypedArrayPrototype$, {
    slice: $slice,
    set: $set,
    constructor: function () { /* noop */ },
    toString: arrayToString,
    toLocaleString: $toLocaleString
  });
  addGetter($TypedArrayPrototype$, 'buffer', 'b');
  addGetter($TypedArrayPrototype$, 'byteOffset', 'o');
  addGetter($TypedArrayPrototype$, 'byteLength', 'l');
  addGetter($TypedArrayPrototype$, 'length', 'e');
  dP($TypedArrayPrototype$, TAG, {
    get: function () { return this[TYPED_ARRAY]; }
  });

  // eslint-disable-next-line max-statements
  module.exports = function (KEY, BYTES, wrapper, CLAMPED) {
    CLAMPED = !!CLAMPED;
    var NAME = KEY + (CLAMPED ? 'Clamped' : '') + 'Array';
    var GETTER = 'get' + KEY;
    var SETTER = 'set' + KEY;
    var TypedArray = global[NAME];
    var Base = TypedArray || {};
    var TAC = TypedArray && getPrototypeOf(TypedArray);
    var FORCED = !TypedArray || !$typed.ABV;
    var O = {};
    var TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE];
    var getter = function (that, index) {
      var data = that._d;
      return data.v[GETTER](index * BYTES + data.o, LITTLE_ENDIAN);
    };
    var setter = function (that, index, value) {
      var data = that._d;
      if (CLAMPED) value = (value = Math.round(value)) < 0 ? 0 : value > 0xff ? 0xff : value & 0xff;
      data.v[SETTER](index * BYTES + data.o, value, LITTLE_ENDIAN);
    };
    var addElement = function (that, index) {
      dP(that, index, {
        get: function () {
          return getter(this, index);
        },
        set: function (value) {
          return setter(this, index, value);
        },
        enumerable: true
      });
    };
    if (FORCED) {
      TypedArray = wrapper(function (that, data, $offset, $length) {
        anInstance(that, TypedArray, NAME, '_d');
        var index = 0;
        var offset = 0;
        var buffer, byteLength, length, klass;
        if (!isObject(data)) {
          length = toIndex(data);
          byteLength = length * BYTES;
          buffer = new $ArrayBuffer(byteLength);
        } else if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
          buffer = data;
          offset = toOffset($offset, BYTES);
          var $len = data.byteLength;
          if ($length === undefined) {
            if ($len % BYTES) throw RangeError(WRONG_LENGTH);
            byteLength = $len - offset;
            if (byteLength < 0) throw RangeError(WRONG_LENGTH);
          } else {
            byteLength = toLength($length) * BYTES;
            if (byteLength + offset > $len) throw RangeError(WRONG_LENGTH);
          }
          length = byteLength / BYTES;
        } else if (TYPED_ARRAY in data) {
          return fromList(TypedArray, data);
        } else {
          return $from.call(TypedArray, data);
        }
        hide(that, '_d', {
          b: buffer,
          o: offset,
          l: byteLength,
          e: length,
          v: new $DataView(buffer)
        });
        while (index < length) addElement(that, index++);
      });
      TypedArrayPrototype = TypedArray[PROTOTYPE] = create($TypedArrayPrototype$);
      hide(TypedArrayPrototype, 'constructor', TypedArray);
    } else if (!fails(function () {
      TypedArray(1);
    }) || !fails(function () {
      new TypedArray(-1); // eslint-disable-line no-new
    }) || !$iterDetect(function (iter) {
      new TypedArray(); // eslint-disable-line no-new
      new TypedArray(null); // eslint-disable-line no-new
      new TypedArray(1.5); // eslint-disable-line no-new
      new TypedArray(iter); // eslint-disable-line no-new
    }, true)) {
      TypedArray = wrapper(function (that, data, $offset, $length) {
        anInstance(that, TypedArray, NAME);
        var klass;
        // `ws` module bug, temporarily remove validation length for Uint8Array
        // https://github.com/websockets/ws/pull/645
        if (!isObject(data)) return new Base(toIndex(data));
        if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
          return $length !== undefined
            ? new Base(data, toOffset($offset, BYTES), $length)
            : $offset !== undefined
              ? new Base(data, toOffset($offset, BYTES))
              : new Base(data);
        }
        if (TYPED_ARRAY in data) return fromList(TypedArray, data);
        return $from.call(TypedArray, data);
      });
      arrayForEach(TAC !== Function.prototype ? gOPN(Base).concat(gOPN(TAC)) : gOPN(Base), function (key) {
        if (!(key in TypedArray)) hide(TypedArray, key, Base[key]);
      });
      TypedArray[PROTOTYPE] = TypedArrayPrototype;
      if (!LIBRARY) TypedArrayPrototype.constructor = TypedArray;
    }
    var $nativeIterator = TypedArrayPrototype[ITERATOR];
    var CORRECT_ITER_NAME = !!$nativeIterator
      && ($nativeIterator.name == 'values' || $nativeIterator.name == undefined);
    var $iterator = $iterators.values;
    hide(TypedArray, TYPED_CONSTRUCTOR, true);
    hide(TypedArrayPrototype, TYPED_ARRAY, NAME);
    hide(TypedArrayPrototype, VIEW, true);
    hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray);

    if (CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)) {
      dP(TypedArrayPrototype, TAG, {
        get: function () { return NAME; }
      });
    }

    O[NAME] = TypedArray;

    $export($export.G + $export.W + $export.F * (TypedArray != Base), O);

    $export($export.S, NAME, {
      BYTES_PER_ELEMENT: BYTES
    });

    $export($export.S + $export.F * fails(function () { Base.of.call(TypedArray, 1); }), NAME, {
      from: $from,
      of: $of
    });

    if (!(BYTES_PER_ELEMENT in TypedArrayPrototype)) hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES);

    $export($export.P, NAME, proto);

    setSpecies(NAME);

    $export($export.P + $export.F * FORCED_SET, NAME, { set: $set });

    $export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators);

    if (!LIBRARY && TypedArrayPrototype.toString != arrayToString) TypedArrayPrototype.toString = arrayToString;

    $export($export.P + $export.F * fails(function () {
      new TypedArray(1).slice();
    }), NAME, { slice: $slice });

    $export($export.P + $export.F * (fails(function () {
      return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString();
    }) || !fails(function () {
      TypedArrayPrototype.toLocaleString.call([1, 2]);
    })), NAME, { toLocaleString: $toLocaleString });

    Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator;
    if (!LIBRARY && !CORRECT_ITER_NAME) hide(TypedArrayPrototype, ITERATOR, $iterator);
  };
} else module.exports = function () { /* empty */ };

},{"./_an-instance":17,"./_array-copy-within":19,"./_array-fill":20,"./_array-includes":22,"./_array-methods":23,"./_classof":28,"./_ctx":36,"./_descriptors":40,"./_export":44,"./_fails":46,"./_global":51,"./_has":52,"./_hide":53,"./_is-array-iter":59,"./_is-object":62,"./_iter-detect":67,"./_iterators":69,"./_library":70,"./_object-create":81,"./_object-dp":82,"./_object-gopd":85,"./_object-gopn":87,"./_object-gpo":89,"./_property-desc":100,"./_redefine-all":101,"./_set-species":108,"./_species-constructor":112,"./_to-absolute-index":122,"./_to-index":123,"./_to-integer":124,"./_to-length":126,"./_to-object":127,"./_to-primitive":128,"./_typed":131,"./_typed-buffer":130,"./_uid":132,"./_wks":136,"./core.get-iterator-method":137,"./es6.array.iterator":149}],130:[function(require,module,exports){
'use strict';
var global = require('./_global');
var DESCRIPTORS = require('./_descriptors');
var LIBRARY = require('./_library');
var $typed = require('./_typed');
var hide = require('./_hide');
var redefineAll = require('./_redefine-all');
var fails = require('./_fails');
var anInstance = require('./_an-instance');
var toInteger = require('./_to-integer');
var toLength = require('./_to-length');
var toIndex = require('./_to-index');
var gOPN = require('./_object-gopn').f;
var dP = require('./_object-dp').f;
var arrayFill = require('./_array-fill');
var setToStringTag = require('./_set-to-string-tag');
var ARRAY_BUFFER = 'ArrayBuffer';
var DATA_VIEW = 'DataView';
var PROTOTYPE = 'prototype';
var WRONG_LENGTH = 'Wrong length!';
var WRONG_INDEX = 'Wrong index!';
var $ArrayBuffer = global[ARRAY_BUFFER];
var $DataView = global[DATA_VIEW];
var Math = global.Math;
var RangeError = global.RangeError;
// eslint-disable-next-line no-shadow-restricted-names
var Infinity = global.Infinity;
var BaseBuffer = $ArrayBuffer;
var abs = Math.abs;
var pow = Math.pow;
var floor = Math.floor;
var log = Math.log;
var LN2 = Math.LN2;
var BUFFER = 'buffer';
var BYTE_LENGTH = 'byteLength';
var BYTE_OFFSET = 'byteOffset';
var $BUFFER = DESCRIPTORS ? '_b' : BUFFER;
var $LENGTH = DESCRIPTORS ? '_l' : BYTE_LENGTH;
var $OFFSET = DESCRIPTORS ? '_o' : BYTE_OFFSET;

// IEEE754 conversions based on https://github.com/feross/ieee754
function packIEEE754(value, mLen, nBytes) {
  var buffer = Array(nBytes);
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0;
  var i = 0;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  var e, m, c;
  value = abs(value);
  // eslint-disable-next-line no-self-compare
  if (value != value || value === Infinity) {
    // eslint-disable-next-line no-self-compare
    m = value != value ? 1 : 0;
    e = eMax;
  } else {
    e = floor(log(value) / LN2);
    if (value * (c = pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }
    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * pow(2, eBias - 1) * pow(2, mLen);
      e = 0;
    }
  }
  for (; mLen >= 8; buffer[i++] = m & 255, m /= 256, mLen -= 8);
  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer[i++] = e & 255, e /= 256, eLen -= 8);
  buffer[--i] |= s * 128;
  return buffer;
}
function unpackIEEE754(buffer, mLen, nBytes) {
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = eLen - 7;
  var i = nBytes - 1;
  var s = buffer[i--];
  var e = s & 127;
  var m;
  s >>= 7;
  for (; nBits > 0; e = e * 256 + buffer[i], i--, nBits -= 8);
  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[i], i--, nBits -= 8);
  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : s ? -Infinity : Infinity;
  } else {
    m = m + pow(2, mLen);
    e = e - eBias;
  } return (s ? -1 : 1) * m * pow(2, e - mLen);
}

function unpackI32(bytes) {
  return bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0];
}
function packI8(it) {
  return [it & 0xff];
}
function packI16(it) {
  return [it & 0xff, it >> 8 & 0xff];
}
function packI32(it) {
  return [it & 0xff, it >> 8 & 0xff, it >> 16 & 0xff, it >> 24 & 0xff];
}
function packF64(it) {
  return packIEEE754(it, 52, 8);
}
function packF32(it) {
  return packIEEE754(it, 23, 4);
}

function addGetter(C, key, internal) {
  dP(C[PROTOTYPE], key, { get: function () { return this[internal]; } });
}

function get(view, bytes, index, isLittleEndian) {
  var numIndex = +index;
  var intIndex = toIndex(numIndex);
  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b;
  var start = intIndex + view[$OFFSET];
  var pack = store.slice(start, start + bytes);
  return isLittleEndian ? pack : pack.reverse();
}
function set(view, bytes, index, conversion, value, isLittleEndian) {
  var numIndex = +index;
  var intIndex = toIndex(numIndex);
  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b;
  var start = intIndex + view[$OFFSET];
  var pack = conversion(+value);
  for (var i = 0; i < bytes; i++) store[start + i] = pack[isLittleEndian ? i : bytes - i - 1];
}

if (!$typed.ABV) {
  $ArrayBuffer = function ArrayBuffer(length) {
    anInstance(this, $ArrayBuffer, ARRAY_BUFFER);
    var byteLength = toIndex(length);
    this._b = arrayFill.call(Array(byteLength), 0);
    this[$LENGTH] = byteLength;
  };

  $DataView = function DataView(buffer, byteOffset, byteLength) {
    anInstance(this, $DataView, DATA_VIEW);
    anInstance(buffer, $ArrayBuffer, DATA_VIEW);
    var bufferLength = buffer[$LENGTH];
    var offset = toInteger(byteOffset);
    if (offset < 0 || offset > bufferLength) throw RangeError('Wrong offset!');
    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
    if (offset + byteLength > bufferLength) throw RangeError(WRONG_LENGTH);
    this[$BUFFER] = buffer;
    this[$OFFSET] = offset;
    this[$LENGTH] = byteLength;
  };

  if (DESCRIPTORS) {
    addGetter($ArrayBuffer, BYTE_LENGTH, '_l');
    addGetter($DataView, BUFFER, '_b');
    addGetter($DataView, BYTE_LENGTH, '_l');
    addGetter($DataView, BYTE_OFFSET, '_o');
  }

  redefineAll($DataView[PROTOTYPE], {
    getInt8: function getInt8(byteOffset) {
      return get(this, 1, byteOffset)[0] << 24 >> 24;
    },
    getUint8: function getUint8(byteOffset) {
      return get(this, 1, byteOffset)[0];
    },
    getInt16: function getInt16(byteOffset /* , littleEndian */) {
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
    },
    getUint16: function getUint16(byteOffset /* , littleEndian */) {
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return bytes[1] << 8 | bytes[0];
    },
    getInt32: function getInt32(byteOffset /* , littleEndian */) {
      return unpackI32(get(this, 4, byteOffset, arguments[1]));
    },
    getUint32: function getUint32(byteOffset /* , littleEndian */) {
      return unpackI32(get(this, 4, byteOffset, arguments[1])) >>> 0;
    },
    getFloat32: function getFloat32(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4);
    },
    getFloat64: function getFloat64(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8);
    },
    setInt8: function setInt8(byteOffset, value) {
      set(this, 1, byteOffset, packI8, value);
    },
    setUint8: function setUint8(byteOffset, value) {
      set(this, 1, byteOffset, packI8, value);
    },
    setInt16: function setInt16(byteOffset, value /* , littleEndian */) {
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setUint16: function setUint16(byteOffset, value /* , littleEndian */) {
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setInt32: function setInt32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setUint32: function setUint32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setFloat32: function setFloat32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packF32, value, arguments[2]);
    },
    setFloat64: function setFloat64(byteOffset, value /* , littleEndian */) {
      set(this, 8, byteOffset, packF64, value, arguments[2]);
    }
  });
} else {
  if (!fails(function () {
    $ArrayBuffer(1);
  }) || !fails(function () {
    new $ArrayBuffer(-1); // eslint-disable-line no-new
  }) || fails(function () {
    new $ArrayBuffer(); // eslint-disable-line no-new
    new $ArrayBuffer(1.5); // eslint-disable-line no-new
    new $ArrayBuffer(NaN); // eslint-disable-line no-new
    return $ArrayBuffer.name != ARRAY_BUFFER;
  })) {
    $ArrayBuffer = function ArrayBuffer(length) {
      anInstance(this, $ArrayBuffer);
      return new BaseBuffer(toIndex(length));
    };
    var ArrayBufferProto = $ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE];
    for (var keys = gOPN(BaseBuffer), j = 0, key; keys.length > j;) {
      if (!((key = keys[j++]) in $ArrayBuffer)) hide($ArrayBuffer, key, BaseBuffer[key]);
    }
    if (!LIBRARY) ArrayBufferProto.constructor = $ArrayBuffer;
  }
  // iOS Safari 7.x bug
  var view = new $DataView(new $ArrayBuffer(2));
  var $setInt8 = $DataView[PROTOTYPE].setInt8;
  view.setInt8(0, 2147483648);
  view.setInt8(1, 2147483649);
  if (view.getInt8(0) || !view.getInt8(1)) redefineAll($DataView[PROTOTYPE], {
    setInt8: function setInt8(byteOffset, value) {
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    },
    setUint8: function setUint8(byteOffset, value) {
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    }
  }, true);
}
setToStringTag($ArrayBuffer, ARRAY_BUFFER);
setToStringTag($DataView, DATA_VIEW);
hide($DataView[PROTOTYPE], $typed.VIEW, true);
exports[ARRAY_BUFFER] = $ArrayBuffer;
exports[DATA_VIEW] = $DataView;

},{"./_an-instance":17,"./_array-fill":20,"./_descriptors":40,"./_fails":46,"./_global":51,"./_hide":53,"./_library":70,"./_object-dp":82,"./_object-gopn":87,"./_redefine-all":101,"./_set-to-string-tag":109,"./_to-index":123,"./_to-integer":124,"./_to-length":126,"./_typed":131}],131:[function(require,module,exports){
var global = require('./_global');
var hide = require('./_hide');
var uid = require('./_uid');
var TYPED = uid('typed_array');
var VIEW = uid('view');
var ABV = !!(global.ArrayBuffer && global.DataView);
var CONSTR = ABV;
var i = 0;
var l = 9;
var Typed;

var TypedArrayConstructors = (
  'Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array'
).split(',');

while (i < l) {
  if (Typed = global[TypedArrayConstructors[i++]]) {
    hide(Typed.prototype, TYPED, true);
    hide(Typed.prototype, VIEW, true);
  } else CONSTR = false;
}

module.exports = {
  ABV: ABV,
  CONSTR: CONSTR,
  TYPED: TYPED,
  VIEW: VIEW
};

},{"./_global":51,"./_hide":53,"./_uid":132}],132:[function(require,module,exports){
var id = 0;
var px = Math.random();
module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};

},{}],133:[function(require,module,exports){
var isObject = require('./_is-object');
module.exports = function (it, TYPE) {
  if (!isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');
  return it;
};

},{"./_is-object":62}],134:[function(require,module,exports){
var global = require('./_global');
var core = require('./_core');
var LIBRARY = require('./_library');
var wksExt = require('./_wks-ext');
var defineProperty = require('./_object-dp').f;
module.exports = function (name) {
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });
};

},{"./_core":34,"./_global":51,"./_library":70,"./_object-dp":82,"./_wks-ext":135}],135:[function(require,module,exports){
exports.f = require('./_wks');

},{"./_wks":136}],136:[function(require,module,exports){
var store = require('./_shared')('wks');
var uid = require('./_uid');
var Symbol = require('./_global').Symbol;
var USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;

},{"./_global":51,"./_shared":111,"./_uid":132}],137:[function(require,module,exports){
var classof = require('./_classof');
var ITERATOR = require('./_wks')('iterator');
var Iterators = require('./_iterators');
module.exports = require('./_core').getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};

},{"./_classof":28,"./_core":34,"./_iterators":69,"./_wks":136}],138:[function(require,module,exports){
// https://github.com/benjamingr/RexExp.escape
var $export = require('./_export');
var $re = require('./_replacer')(/[\\^$*+?.()|[\]{}]/g, '\\$&');

$export($export.S, 'RegExp', { escape: function escape(it) { return $re(it); } });

},{"./_export":44,"./_replacer":103}],139:[function(require,module,exports){
// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
var $export = require('./_export');

$export($export.P, 'Array', { copyWithin: require('./_array-copy-within') });

require('./_add-to-unscopables')('copyWithin');

},{"./_add-to-unscopables":16,"./_array-copy-within":19,"./_export":44}],140:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var $every = require('./_array-methods')(4);

$export($export.P + $export.F * !require('./_strict-method')([].every, true), 'Array', {
  // 22.1.3.5 / 15.4.4.16 Array.prototype.every(callbackfn [, thisArg])
  every: function every(callbackfn /* , thisArg */) {
    return $every(this, callbackfn, arguments[1]);
  }
});

},{"./_array-methods":23,"./_export":44,"./_strict-method":113}],141:[function(require,module,exports){
// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
var $export = require('./_export');

$export($export.P, 'Array', { fill: require('./_array-fill') });

require('./_add-to-unscopables')('fill');

},{"./_add-to-unscopables":16,"./_array-fill":20,"./_export":44}],142:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var $filter = require('./_array-methods')(2);

$export($export.P + $export.F * !require('./_strict-method')([].filter, true), 'Array', {
  // 22.1.3.7 / 15.4.4.20 Array.prototype.filter(callbackfn [, thisArg])
  filter: function filter(callbackfn /* , thisArg */) {
    return $filter(this, callbackfn, arguments[1]);
  }
});

},{"./_array-methods":23,"./_export":44,"./_strict-method":113}],143:[function(require,module,exports){
'use strict';
// 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)
var $export = require('./_export');
var $find = require('./_array-methods')(6);
var KEY = 'findIndex';
var forced = true;
// Shouldn't skip holes
if (KEY in []) Array(1)[KEY](function () { forced = false; });
$export($export.P + $export.F * forced, 'Array', {
  findIndex: function findIndex(callbackfn /* , that = undefined */) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});
require('./_add-to-unscopables')(KEY);

},{"./_add-to-unscopables":16,"./_array-methods":23,"./_export":44}],144:[function(require,module,exports){
'use strict';
// 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)
var $export = require('./_export');
var $find = require('./_array-methods')(5);
var KEY = 'find';
var forced = true;
// Shouldn't skip holes
if (KEY in []) Array(1)[KEY](function () { forced = false; });
$export($export.P + $export.F * forced, 'Array', {
  find: function find(callbackfn /* , that = undefined */) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});
require('./_add-to-unscopables')(KEY);

},{"./_add-to-unscopables":16,"./_array-methods":23,"./_export":44}],145:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var $forEach = require('./_array-methods')(0);
var STRICT = require('./_strict-method')([].forEach, true);

$export($export.P + $export.F * !STRICT, 'Array', {
  // 22.1.3.10 / 15.4.4.18 Array.prototype.forEach(callbackfn [, thisArg])
  forEach: function forEach(callbackfn /* , thisArg */) {
    return $forEach(this, callbackfn, arguments[1]);
  }
});

},{"./_array-methods":23,"./_export":44,"./_strict-method":113}],146:[function(require,module,exports){
'use strict';
var ctx = require('./_ctx');
var $export = require('./_export');
var toObject = require('./_to-object');
var call = require('./_iter-call');
var isArrayIter = require('./_is-array-iter');
var toLength = require('./_to-length');
var createProperty = require('./_create-property');
var getIterFn = require('./core.get-iterator-method');

$export($export.S + $export.F * !require('./_iter-detect')(function (iter) { Array.from(iter); }), 'Array', {
  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
  from: function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
    var O = toObject(arrayLike);
    var C = typeof this == 'function' ? this : Array;
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var index = 0;
    var iterFn = getIterFn(O);
    var length, result, step, iterator;
    if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
    // if object isn't iterable or it's array with default iterator - use simple case
    if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {
      for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
      }
    } else {
      length = toLength(O.length);
      for (result = new C(length); length > index; index++) {
        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
      }
    }
    result.length = index;
    return result;
  }
});

},{"./_create-property":35,"./_ctx":36,"./_export":44,"./_is-array-iter":59,"./_iter-call":64,"./_iter-detect":67,"./_to-length":126,"./_to-object":127,"./core.get-iterator-method":137}],147:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var $indexOf = require('./_array-includes')(false);
var $native = [].indexOf;
var NEGATIVE_ZERO = !!$native && 1 / [1].indexOf(1, -0) < 0;

$export($export.P + $export.F * (NEGATIVE_ZERO || !require('./_strict-method')($native)), 'Array', {
  // 22.1.3.11 / 15.4.4.14 Array.prototype.indexOf(searchElement [, fromIndex])
  indexOf: function indexOf(searchElement /* , fromIndex = 0 */) {
    return NEGATIVE_ZERO
      // convert -0 to +0
      ? $native.apply(this, arguments) || 0
      : $indexOf(this, searchElement, arguments[1]);
  }
});

},{"./_array-includes":22,"./_export":44,"./_strict-method":113}],148:[function(require,module,exports){
// 22.1.2.2 / 15.4.3.2 Array.isArray(arg)
var $export = require('./_export');

$export($export.S, 'Array', { isArray: require('./_is-array') });

},{"./_export":44,"./_is-array":60}],149:[function(require,module,exports){
'use strict';
var addToUnscopables = require('./_add-to-unscopables');
var step = require('./_iter-step');
var Iterators = require('./_iterators');
var toIObject = require('./_to-iobject');

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = require('./_iter-define')(Array, 'Array', function (iterated, kind) {
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;
  if (!O || index >= O.length) {
    this._t = undefined;
    return step(1);
  }
  if (kind == 'keys') return step(0, index);
  if (kind == 'values') return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');

},{"./_add-to-unscopables":16,"./_iter-define":66,"./_iter-step":68,"./_iterators":69,"./_to-iobject":125}],150:[function(require,module,exports){
'use strict';
// 22.1.3.13 Array.prototype.join(separator)
var $export = require('./_export');
var toIObject = require('./_to-iobject');
var arrayJoin = [].join;

// fallback for not array-like strings
$export($export.P + $export.F * (require('./_iobject') != Object || !require('./_strict-method')(arrayJoin)), 'Array', {
  join: function join(separator) {
    return arrayJoin.call(toIObject(this), separator === undefined ? ',' : separator);
  }
});

},{"./_export":44,"./_iobject":58,"./_strict-method":113,"./_to-iobject":125}],151:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var toIObject = require('./_to-iobject');
var toInteger = require('./_to-integer');
var toLength = require('./_to-length');
var $native = [].lastIndexOf;
var NEGATIVE_ZERO = !!$native && 1 / [1].lastIndexOf(1, -0) < 0;

$export($export.P + $export.F * (NEGATIVE_ZERO || !require('./_strict-method')($native)), 'Array', {
  // 22.1.3.14 / 15.4.4.15 Array.prototype.lastIndexOf(searchElement [, fromIndex])
  lastIndexOf: function lastIndexOf(searchElement /* , fromIndex = @[*-1] */) {
    // convert -0 to +0
    if (NEGATIVE_ZERO) return $native.apply(this, arguments) || 0;
    var O = toIObject(this);
    var length = toLength(O.length);
    var index = length - 1;
    if (arguments.length > 1) index = Math.min(index, toInteger(arguments[1]));
    if (index < 0) index = length + index;
    for (;index >= 0; index--) if (index in O) if (O[index] === searchElement) return index || 0;
    return -1;
  }
});

},{"./_export":44,"./_strict-method":113,"./_to-integer":124,"./_to-iobject":125,"./_to-length":126}],152:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var $map = require('./_array-methods')(1);

$export($export.P + $export.F * !require('./_strict-method')([].map, true), 'Array', {
  // 22.1.3.15 / 15.4.4.19 Array.prototype.map(callbackfn [, thisArg])
  map: function map(callbackfn /* , thisArg */) {
    return $map(this, callbackfn, arguments[1]);
  }
});

},{"./_array-methods":23,"./_export":44,"./_strict-method":113}],153:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var createProperty = require('./_create-property');

// WebKit Array.of isn't generic
$export($export.S + $export.F * require('./_fails')(function () {
  function F() { /* empty */ }
  return !(Array.of.call(F) instanceof F);
}), 'Array', {
  // 22.1.2.3 Array.of( ...items)
  of: function of(/* ...args */) {
    var index = 0;
    var aLen = arguments.length;
    var result = new (typeof this == 'function' ? this : Array)(aLen);
    while (aLen > index) createProperty(result, index, arguments[index++]);
    result.length = aLen;
    return result;
  }
});

},{"./_create-property":35,"./_export":44,"./_fails":46}],154:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var $reduce = require('./_array-reduce');

$export($export.P + $export.F * !require('./_strict-method')([].reduceRight, true), 'Array', {
  // 22.1.3.19 / 15.4.4.22 Array.prototype.reduceRight(callbackfn [, initialValue])
  reduceRight: function reduceRight(callbackfn /* , initialValue */) {
    return $reduce(this, callbackfn, arguments.length, arguments[1], true);
  }
});

},{"./_array-reduce":24,"./_export":44,"./_strict-method":113}],155:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var $reduce = require('./_array-reduce');

$export($export.P + $export.F * !require('./_strict-method')([].reduce, true), 'Array', {
  // 22.1.3.18 / 15.4.4.21 Array.prototype.reduce(callbackfn [, initialValue])
  reduce: function reduce(callbackfn /* , initialValue */) {
    return $reduce(this, callbackfn, arguments.length, arguments[1], false);
  }
});

},{"./_array-reduce":24,"./_export":44,"./_strict-method":113}],156:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var html = require('./_html');
var cof = require('./_cof');
var toAbsoluteIndex = require('./_to-absolute-index');
var toLength = require('./_to-length');
var arraySlice = [].slice;

// fallback for not array-like ES3 strings and DOM objects
$export($export.P + $export.F * require('./_fails')(function () {
  if (html) arraySlice.call(html);
}), 'Array', {
  slice: function slice(begin, end) {
    var len = toLength(this.length);
    var klass = cof(this);
    end = end === undefined ? len : end;
    if (klass == 'Array') return arraySlice.call(this, begin, end);
    var start = toAbsoluteIndex(begin, len);
    var upTo = toAbsoluteIndex(end, len);
    var size = toLength(upTo - start);
    var cloned = Array(size);
    var i = 0;
    for (; i < size; i++) cloned[i] = klass == 'String'
      ? this.charAt(start + i)
      : this[start + i];
    return cloned;
  }
});

},{"./_cof":29,"./_export":44,"./_fails":46,"./_html":54,"./_to-absolute-index":122,"./_to-length":126}],157:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var $some = require('./_array-methods')(3);

$export($export.P + $export.F * !require('./_strict-method')([].some, true), 'Array', {
  // 22.1.3.23 / 15.4.4.17 Array.prototype.some(callbackfn [, thisArg])
  some: function some(callbackfn /* , thisArg */) {
    return $some(this, callbackfn, arguments[1]);
  }
});

},{"./_array-methods":23,"./_export":44,"./_strict-method":113}],158:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var aFunction = require('./_a-function');
var toObject = require('./_to-object');
var fails = require('./_fails');
var $sort = [].sort;
var test = [1, 2, 3];

$export($export.P + $export.F * (fails(function () {
  // IE8-
  test.sort(undefined);
}) || !fails(function () {
  // V8 bug
  test.sort(null);
  // Old WebKit
}) || !require('./_strict-method')($sort)), 'Array', {
  // 22.1.3.25 Array.prototype.sort(comparefn)
  sort: function sort(comparefn) {
    return comparefn === undefined
      ? $sort.call(toObject(this))
      : $sort.call(toObject(this), aFunction(comparefn));
  }
});

},{"./_a-function":14,"./_export":44,"./_fails":46,"./_strict-method":113,"./_to-object":127}],159:[function(require,module,exports){
require('./_set-species')('Array');

},{"./_set-species":108}],160:[function(require,module,exports){
// 20.3.3.1 / 15.9.4.4 Date.now()
var $export = require('./_export');

$export($export.S, 'Date', { now: function () { return new Date().getTime(); } });

},{"./_export":44}],161:[function(require,module,exports){
// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()
var $export = require('./_export');
var toISOString = require('./_date-to-iso-string');

// PhantomJS / old WebKit has a broken implementations
$export($export.P + $export.F * (Date.prototype.toISOString !== toISOString), 'Date', {
  toISOString: toISOString
});

},{"./_date-to-iso-string":37,"./_export":44}],162:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var toObject = require('./_to-object');
var toPrimitive = require('./_to-primitive');

$export($export.P + $export.F * require('./_fails')(function () {
  return new Date(NaN).toJSON() !== null
    || Date.prototype.toJSON.call({ toISOString: function () { return 1; } }) !== 1;
}), 'Date', {
  // eslint-disable-next-line no-unused-vars
  toJSON: function toJSON(key) {
    var O = toObject(this);
    var pv = toPrimitive(O);
    return typeof pv == 'number' && !isFinite(pv) ? null : O.toISOString();
  }
});

},{"./_export":44,"./_fails":46,"./_to-object":127,"./_to-primitive":128}],163:[function(require,module,exports){
var TO_PRIMITIVE = require('./_wks')('toPrimitive');
var proto = Date.prototype;

if (!(TO_PRIMITIVE in proto)) require('./_hide')(proto, TO_PRIMITIVE, require('./_date-to-primitive'));

},{"./_date-to-primitive":38,"./_hide":53,"./_wks":136}],164:[function(require,module,exports){
var DateProto = Date.prototype;
var INVALID_DATE = 'Invalid Date';
var TO_STRING = 'toString';
var $toString = DateProto[TO_STRING];
var getTime = DateProto.getTime;
if (new Date(NaN) + '' != INVALID_DATE) {
  require('./_redefine')(DateProto, TO_STRING, function toString() {
    var value = getTime.call(this);
    // eslint-disable-next-line no-self-compare
    return value === value ? $toString.call(this) : INVALID_DATE;
  });
}

},{"./_redefine":102}],165:[function(require,module,exports){
// 19.2.3.2 / 15.3.4.5 Function.prototype.bind(thisArg, args...)
var $export = require('./_export');

$export($export.P, 'Function', { bind: require('./_bind') });

},{"./_bind":27,"./_export":44}],166:[function(require,module,exports){
'use strict';
var isObject = require('./_is-object');
var getPrototypeOf = require('./_object-gpo');
var HAS_INSTANCE = require('./_wks')('hasInstance');
var FunctionProto = Function.prototype;
// 19.2.3.6 Function.prototype[@@hasInstance](V)
if (!(HAS_INSTANCE in FunctionProto)) require('./_object-dp').f(FunctionProto, HAS_INSTANCE, { value: function (O) {
  if (typeof this != 'function' || !isObject(O)) return false;
  if (!isObject(this.prototype)) return O instanceof this;
  // for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this:
  while (O = getPrototypeOf(O)) if (this.prototype === O) return true;
  return false;
} });

},{"./_is-object":62,"./_object-dp":82,"./_object-gpo":89,"./_wks":136}],167:[function(require,module,exports){
var dP = require('./_object-dp').f;
var FProto = Function.prototype;
var nameRE = /^\s*function ([^ (]*)/;
var NAME = 'name';

// 19.2.4.2 name
NAME in FProto || require('./_descriptors') && dP(FProto, NAME, {
  configurable: true,
  get: function () {
    try {
      return ('' + this).match(nameRE)[1];
    } catch (e) {
      return '';
    }
  }
});

},{"./_descriptors":40,"./_object-dp":82}],168:[function(require,module,exports){
'use strict';
var strong = require('./_collection-strong');
var validate = require('./_validate-collection');
var MAP = 'Map';

// 23.1 Map Objects
module.exports = require('./_collection')(MAP, function (get) {
  return function Map() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.1.3.6 Map.prototype.get(key)
  get: function get(key) {
    var entry = strong.getEntry(validate(this, MAP), key);
    return entry && entry.v;
  },
  // 23.1.3.9 Map.prototype.set(key, value)
  set: function set(key, value) {
    return strong.def(validate(this, MAP), key === 0 ? 0 : key, value);
  }
}, strong, true);

},{"./_collection":33,"./_collection-strong":30,"./_validate-collection":133}],169:[function(require,module,exports){
// 20.2.2.3 Math.acosh(x)
var $export = require('./_export');
var log1p = require('./_math-log1p');
var sqrt = Math.sqrt;
var $acosh = Math.acosh;

$export($export.S + $export.F * !($acosh
  // V8 bug: https://code.google.com/p/v8/issues/detail?id=3509
  && Math.floor($acosh(Number.MAX_VALUE)) == 710
  // Tor Browser bug: Math.acosh(Infinity) -> NaN
  && $acosh(Infinity) == Infinity
), 'Math', {
  acosh: function acosh(x) {
    return (x = +x) < 1 ? NaN : x > 94906265.62425156
      ? Math.log(x) + Math.LN2
      : log1p(x - 1 + sqrt(x - 1) * sqrt(x + 1));
  }
});

},{"./_export":44,"./_math-log1p":73}],170:[function(require,module,exports){
// 20.2.2.5 Math.asinh(x)
var $export = require('./_export');
var $asinh = Math.asinh;

function asinh(x) {
  return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : Math.log(x + Math.sqrt(x * x + 1));
}

// Tor Browser bug: Math.asinh(0) -> -0
$export($export.S + $export.F * !($asinh && 1 / $asinh(0) > 0), 'Math', { asinh: asinh });

},{"./_export":44}],171:[function(require,module,exports){
// 20.2.2.7 Math.atanh(x)
var $export = require('./_export');
var $atanh = Math.atanh;

// Tor Browser bug: Math.atanh(-0) -> 0
$export($export.S + $export.F * !($atanh && 1 / $atanh(-0) < 0), 'Math', {
  atanh: function atanh(x) {
    return (x = +x) == 0 ? x : Math.log((1 + x) / (1 - x)) / 2;
  }
});

},{"./_export":44}],172:[function(require,module,exports){
// 20.2.2.9 Math.cbrt(x)
var $export = require('./_export');
var sign = require('./_math-sign');

$export($export.S, 'Math', {
  cbrt: function cbrt(x) {
    return sign(x = +x) * Math.pow(Math.abs(x), 1 / 3);
  }
});

},{"./_export":44,"./_math-sign":75}],173:[function(require,module,exports){
// 20.2.2.11 Math.clz32(x)
var $export = require('./_export');

$export($export.S, 'Math', {
  clz32: function clz32(x) {
    return (x >>>= 0) ? 31 - Math.floor(Math.log(x + 0.5) * Math.LOG2E) : 32;
  }
});

},{"./_export":44}],174:[function(require,module,exports){
// 20.2.2.12 Math.cosh(x)
var $export = require('./_export');
var exp = Math.exp;

$export($export.S, 'Math', {
  cosh: function cosh(x) {
    return (exp(x = +x) + exp(-x)) / 2;
  }
});

},{"./_export":44}],175:[function(require,module,exports){
// 20.2.2.14 Math.expm1(x)
var $export = require('./_export');
var $expm1 = require('./_math-expm1');

$export($export.S + $export.F * ($expm1 != Math.expm1), 'Math', { expm1: $expm1 });

},{"./_export":44,"./_math-expm1":71}],176:[function(require,module,exports){
// 20.2.2.16 Math.fround(x)
var $export = require('./_export');

$export($export.S, 'Math', { fround: require('./_math-fround') });

},{"./_export":44,"./_math-fround":72}],177:[function(require,module,exports){
// 20.2.2.17 Math.hypot([value1[, value2[, … ]]])
var $export = require('./_export');
var abs = Math.abs;

$export($export.S, 'Math', {
  hypot: function hypot(value1, value2) { // eslint-disable-line no-unused-vars
    var sum = 0;
    var i = 0;
    var aLen = arguments.length;
    var larg = 0;
    var arg, div;
    while (i < aLen) {
      arg = abs(arguments[i++]);
      if (larg < arg) {
        div = larg / arg;
        sum = sum * div * div + 1;
        larg = arg;
      } else if (arg > 0) {
        div = arg / larg;
        sum += div * div;
      } else sum += arg;
    }
    return larg === Infinity ? Infinity : larg * Math.sqrt(sum);
  }
});

},{"./_export":44}],178:[function(require,module,exports){
// 20.2.2.18 Math.imul(x, y)
var $export = require('./_export');
var $imul = Math.imul;

// some WebKit versions fails with big numbers, some has wrong arity
$export($export.S + $export.F * require('./_fails')(function () {
  return $imul(0xffffffff, 5) != -5 || $imul.length != 2;
}), 'Math', {
  imul: function imul(x, y) {
    var UINT16 = 0xffff;
    var xn = +x;
    var yn = +y;
    var xl = UINT16 & xn;
    var yl = UINT16 & yn;
    return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);
  }
});

},{"./_export":44,"./_fails":46}],179:[function(require,module,exports){
// 20.2.2.21 Math.log10(x)
var $export = require('./_export');

$export($export.S, 'Math', {
  log10: function log10(x) {
    return Math.log(x) * Math.LOG10E;
  }
});

},{"./_export":44}],180:[function(require,module,exports){
// 20.2.2.20 Math.log1p(x)
var $export = require('./_export');

$export($export.S, 'Math', { log1p: require('./_math-log1p') });

},{"./_export":44,"./_math-log1p":73}],181:[function(require,module,exports){
// 20.2.2.22 Math.log2(x)
var $export = require('./_export');

$export($export.S, 'Math', {
  log2: function log2(x) {
    return Math.log(x) / Math.LN2;
  }
});

},{"./_export":44}],182:[function(require,module,exports){
// 20.2.2.28 Math.sign(x)
var $export = require('./_export');

$export($export.S, 'Math', { sign: require('./_math-sign') });

},{"./_export":44,"./_math-sign":75}],183:[function(require,module,exports){
// 20.2.2.30 Math.sinh(x)
var $export = require('./_export');
var expm1 = require('./_math-expm1');
var exp = Math.exp;

// V8 near Chromium 38 has a problem with very small numbers
$export($export.S + $export.F * require('./_fails')(function () {
  return !Math.sinh(-2e-17) != -2e-17;
}), 'Math', {
  sinh: function sinh(x) {
    return Math.abs(x = +x) < 1
      ? (expm1(x) - expm1(-x)) / 2
      : (exp(x - 1) - exp(-x - 1)) * (Math.E / 2);
  }
});

},{"./_export":44,"./_fails":46,"./_math-expm1":71}],184:[function(require,module,exports){
// 20.2.2.33 Math.tanh(x)
var $export = require('./_export');
var expm1 = require('./_math-expm1');
var exp = Math.exp;

$export($export.S, 'Math', {
  tanh: function tanh(x) {
    var a = expm1(x = +x);
    var b = expm1(-x);
    return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));
  }
});

},{"./_export":44,"./_math-expm1":71}],185:[function(require,module,exports){
// 20.2.2.34 Math.trunc(x)
var $export = require('./_export');

$export($export.S, 'Math', {
  trunc: function trunc(it) {
    return (it > 0 ? Math.floor : Math.ceil)(it);
  }
});

},{"./_export":44}],186:[function(require,module,exports){
'use strict';
var global = require('./_global');
var has = require('./_has');
var cof = require('./_cof');
var inheritIfRequired = require('./_inherit-if-required');
var toPrimitive = require('./_to-primitive');
var fails = require('./_fails');
var gOPN = require('./_object-gopn').f;
var gOPD = require('./_object-gopd').f;
var dP = require('./_object-dp').f;
var $trim = require('./_string-trim').trim;
var NUMBER = 'Number';
var $Number = global[NUMBER];
var Base = $Number;
var proto = $Number.prototype;
// Opera ~12 has broken Object#toString
var BROKEN_COF = cof(require('./_object-create')(proto)) == NUMBER;
var TRIM = 'trim' in String.prototype;

// 7.1.3 ToNumber(argument)
var toNumber = function (argument) {
  var it = toPrimitive(argument, false);
  if (typeof it == 'string' && it.length > 2) {
    it = TRIM ? it.trim() : $trim(it, 3);
    var first = it.charCodeAt(0);
    var third, radix, maxCode;
    if (first === 43 || first === 45) {
      third = it.charCodeAt(2);
      if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
    } else if (first === 48) {
      switch (it.charCodeAt(1)) {
        case 66: case 98: radix = 2; maxCode = 49; break; // fast equal /^0b[01]+$/i
        case 79: case 111: radix = 8; maxCode = 55; break; // fast equal /^0o[0-7]+$/i
        default: return +it;
      }
      for (var digits = it.slice(2), i = 0, l = digits.length, code; i < l; i++) {
        code = digits.charCodeAt(i);
        // parseInt parses a string to a first unavailable symbol
        // but ToNumber should return NaN if a string contains unavailable symbols
        if (code < 48 || code > maxCode) return NaN;
      } return parseInt(digits, radix);
    }
  } return +it;
};

if (!$Number(' 0o1') || !$Number('0b1') || $Number('+0x1')) {
  $Number = function Number(value) {
    var it = arguments.length < 1 ? 0 : value;
    var that = this;
    return that instanceof $Number
      // check on 1..constructor(foo) case
      && (BROKEN_COF ? fails(function () { proto.valueOf.call(that); }) : cof(that) != NUMBER)
        ? inheritIfRequired(new Base(toNumber(it)), that, $Number) : toNumber(it);
  };
  for (var keys = require('./_descriptors') ? gOPN(Base) : (
    // ES3:
    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
    // ES6 (in case, if modules with ES6 Number statics required before):
    'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' +
    'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger'
  ).split(','), j = 0, key; keys.length > j; j++) {
    if (has(Base, key = keys[j]) && !has($Number, key)) {
      dP($Number, key, gOPD(Base, key));
    }
  }
  $Number.prototype = proto;
  proto.constructor = $Number;
  require('./_redefine')(global, NUMBER, $Number);
}

},{"./_cof":29,"./_descriptors":40,"./_fails":46,"./_global":51,"./_has":52,"./_inherit-if-required":56,"./_object-create":81,"./_object-dp":82,"./_object-gopd":85,"./_object-gopn":87,"./_redefine":102,"./_string-trim":119,"./_to-primitive":128}],187:[function(require,module,exports){
// 20.1.2.1 Number.EPSILON
var $export = require('./_export');

$export($export.S, 'Number', { EPSILON: Math.pow(2, -52) });

},{"./_export":44}],188:[function(require,module,exports){
// 20.1.2.2 Number.isFinite(number)
var $export = require('./_export');
var _isFinite = require('./_global').isFinite;

$export($export.S, 'Number', {
  isFinite: function isFinite(it) {
    return typeof it == 'number' && _isFinite(it);
  }
});

},{"./_export":44,"./_global":51}],189:[function(require,module,exports){
// 20.1.2.3 Number.isInteger(number)
var $export = require('./_export');

$export($export.S, 'Number', { isInteger: require('./_is-integer') });

},{"./_export":44,"./_is-integer":61}],190:[function(require,module,exports){
// 20.1.2.4 Number.isNaN(number)
var $export = require('./_export');

$export($export.S, 'Number', {
  isNaN: function isNaN(number) {
    // eslint-disable-next-line no-self-compare
    return number != number;
  }
});

},{"./_export":44}],191:[function(require,module,exports){
// 20.1.2.5 Number.isSafeInteger(number)
var $export = require('./_export');
var isInteger = require('./_is-integer');
var abs = Math.abs;

$export($export.S, 'Number', {
  isSafeInteger: function isSafeInteger(number) {
    return isInteger(number) && abs(number) <= 0x1fffffffffffff;
  }
});

},{"./_export":44,"./_is-integer":61}],192:[function(require,module,exports){
// 20.1.2.6 Number.MAX_SAFE_INTEGER
var $export = require('./_export');

$export($export.S, 'Number', { MAX_SAFE_INTEGER: 0x1fffffffffffff });

},{"./_export":44}],193:[function(require,module,exports){
// 20.1.2.10 Number.MIN_SAFE_INTEGER
var $export = require('./_export');

$export($export.S, 'Number', { MIN_SAFE_INTEGER: -0x1fffffffffffff });

},{"./_export":44}],194:[function(require,module,exports){
var $export = require('./_export');
var $parseFloat = require('./_parse-float');
// 20.1.2.12 Number.parseFloat(string)
$export($export.S + $export.F * (Number.parseFloat != $parseFloat), 'Number', { parseFloat: $parseFloat });

},{"./_export":44,"./_parse-float":96}],195:[function(require,module,exports){
var $export = require('./_export');
var $parseInt = require('./_parse-int');
// 20.1.2.13 Number.parseInt(string, radix)
$export($export.S + $export.F * (Number.parseInt != $parseInt), 'Number', { parseInt: $parseInt });

},{"./_export":44,"./_parse-int":97}],196:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var toInteger = require('./_to-integer');
var aNumberValue = require('./_a-number-value');
var repeat = require('./_string-repeat');
var $toFixed = 1.0.toFixed;
var floor = Math.floor;
var data = [0, 0, 0, 0, 0, 0];
var ERROR = 'Number.toFixed: incorrect invocation!';
var ZERO = '0';

var multiply = function (n, c) {
  var i = -1;
  var c2 = c;
  while (++i < 6) {
    c2 += n * data[i];
    data[i] = c2 % 1e7;
    c2 = floor(c2 / 1e7);
  }
};
var divide = function (n) {
  var i = 6;
  var c = 0;
  while (--i >= 0) {
    c += data[i];
    data[i] = floor(c / n);
    c = (c % n) * 1e7;
  }
};
var numToString = function () {
  var i = 6;
  var s = '';
  while (--i >= 0) {
    if (s !== '' || i === 0 || data[i] !== 0) {
      var t = String(data[i]);
      s = s === '' ? t : s + repeat.call(ZERO, 7 - t.length) + t;
    }
  } return s;
};
var pow = function (x, n, acc) {
  return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);
};
var log = function (x) {
  var n = 0;
  var x2 = x;
  while (x2 >= 4096) {
    n += 12;
    x2 /= 4096;
  }
  while (x2 >= 2) {
    n += 1;
    x2 /= 2;
  } return n;
};

$export($export.P + $export.F * (!!$toFixed && (
  0.00008.toFixed(3) !== '0.000' ||
  0.9.toFixed(0) !== '1' ||
  1.255.toFixed(2) !== '1.25' ||
  1000000000000000128.0.toFixed(0) !== '1000000000000000128'
) || !require('./_fails')(function () {
  // V8 ~ Android 4.3-
  $toFixed.call({});
})), 'Number', {
  toFixed: function toFixed(fractionDigits) {
    var x = aNumberValue(this, ERROR);
    var f = toInteger(fractionDigits);
    var s = '';
    var m = ZERO;
    var e, z, j, k;
    if (f < 0 || f > 20) throw RangeError(ERROR);
    // eslint-disable-next-line no-self-compare
    if (x != x) return 'NaN';
    if (x <= -1e21 || x >= 1e21) return String(x);
    if (x < 0) {
      s = '-';
      x = -x;
    }
    if (x > 1e-21) {
      e = log(x * pow(2, 69, 1)) - 69;
      z = e < 0 ? x * pow(2, -e, 1) : x / pow(2, e, 1);
      z *= 0x10000000000000;
      e = 52 - e;
      if (e > 0) {
        multiply(0, z);
        j = f;
        while (j >= 7) {
          multiply(1e7, 0);
          j -= 7;
        }
        multiply(pow(10, j, 1), 0);
        j = e - 1;
        while (j >= 23) {
          divide(1 << 23);
          j -= 23;
        }
        divide(1 << j);
        multiply(1, 1);
        divide(2);
        m = numToString();
      } else {
        multiply(0, z);
        multiply(1 << -e, 0);
        m = numToString() + repeat.call(ZERO, f);
      }
    }
    if (f > 0) {
      k = m.length;
      m = s + (k <= f ? '0.' + repeat.call(ZERO, f - k) + m : m.slice(0, k - f) + '.' + m.slice(k - f));
    } else {
      m = s + m;
    } return m;
  }
});

},{"./_a-number-value":15,"./_export":44,"./_fails":46,"./_string-repeat":118,"./_to-integer":124}],197:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var $fails = require('./_fails');
var aNumberValue = require('./_a-number-value');
var $toPrecision = 1.0.toPrecision;

$export($export.P + $export.F * ($fails(function () {
  // IE7-
  return $toPrecision.call(1, undefined) !== '1';
}) || !$fails(function () {
  // V8 ~ Android 4.3-
  $toPrecision.call({});
})), 'Number', {
  toPrecision: function toPrecision(precision) {
    var that = aNumberValue(this, 'Number#toPrecision: incorrect invocation!');
    return precision === undefined ? $toPrecision.call(that) : $toPrecision.call(that, precision);
  }
});

},{"./_a-number-value":15,"./_export":44,"./_fails":46}],198:[function(require,module,exports){
// 19.1.3.1 Object.assign(target, source)
var $export = require('./_export');

$export($export.S + $export.F, 'Object', { assign: require('./_object-assign') });

},{"./_export":44,"./_object-assign":80}],199:[function(require,module,exports){
var $export = require('./_export');
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
$export($export.S, 'Object', { create: require('./_object-create') });

},{"./_export":44,"./_object-create":81}],200:[function(require,module,exports){
var $export = require('./_export');
// 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)
$export($export.S + $export.F * !require('./_descriptors'), 'Object', { defineProperties: require('./_object-dps') });

},{"./_descriptors":40,"./_export":44,"./_object-dps":83}],201:[function(require,module,exports){
var $export = require('./_export');
// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
$export($export.S + $export.F * !require('./_descriptors'), 'Object', { defineProperty: require('./_object-dp').f });

},{"./_descriptors":40,"./_export":44,"./_object-dp":82}],202:[function(require,module,exports){
// 19.1.2.5 Object.freeze(O)
var isObject = require('./_is-object');
var meta = require('./_meta').onFreeze;

require('./_object-sap')('freeze', function ($freeze) {
  return function freeze(it) {
    return $freeze && isObject(it) ? $freeze(meta(it)) : it;
  };
});

},{"./_is-object":62,"./_meta":76,"./_object-sap":93}],203:[function(require,module,exports){
// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
var toIObject = require('./_to-iobject');
var $getOwnPropertyDescriptor = require('./_object-gopd').f;

require('./_object-sap')('getOwnPropertyDescriptor', function () {
  return function getOwnPropertyDescriptor(it, key) {
    return $getOwnPropertyDescriptor(toIObject(it), key);
  };
});

},{"./_object-gopd":85,"./_object-sap":93,"./_to-iobject":125}],204:[function(require,module,exports){
// 19.1.2.7 Object.getOwnPropertyNames(O)
require('./_object-sap')('getOwnPropertyNames', function () {
  return require('./_object-gopn-ext').f;
});

},{"./_object-gopn-ext":86,"./_object-sap":93}],205:[function(require,module,exports){
// 19.1.2.9 Object.getPrototypeOf(O)
var toObject = require('./_to-object');
var $getPrototypeOf = require('./_object-gpo');

require('./_object-sap')('getPrototypeOf', function () {
  return function getPrototypeOf(it) {
    return $getPrototypeOf(toObject(it));
  };
});

},{"./_object-gpo":89,"./_object-sap":93,"./_to-object":127}],206:[function(require,module,exports){
// 19.1.2.11 Object.isExtensible(O)
var isObject = require('./_is-object');

require('./_object-sap')('isExtensible', function ($isExtensible) {
  return function isExtensible(it) {
    return isObject(it) ? $isExtensible ? $isExtensible(it) : true : false;
  };
});

},{"./_is-object":62,"./_object-sap":93}],207:[function(require,module,exports){
// 19.1.2.12 Object.isFrozen(O)
var isObject = require('./_is-object');

require('./_object-sap')('isFrozen', function ($isFrozen) {
  return function isFrozen(it) {
    return isObject(it) ? $isFrozen ? $isFrozen(it) : false : true;
  };
});

},{"./_is-object":62,"./_object-sap":93}],208:[function(require,module,exports){
// 19.1.2.13 Object.isSealed(O)
var isObject = require('./_is-object');

require('./_object-sap')('isSealed', function ($isSealed) {
  return function isSealed(it) {
    return isObject(it) ? $isSealed ? $isSealed(it) : false : true;
  };
});

},{"./_is-object":62,"./_object-sap":93}],209:[function(require,module,exports){
// 19.1.3.10 Object.is(value1, value2)
var $export = require('./_export');
$export($export.S, 'Object', { is: require('./_same-value') });

},{"./_export":44,"./_same-value":104}],210:[function(require,module,exports){
// 19.1.2.14 Object.keys(O)
var toObject = require('./_to-object');
var $keys = require('./_object-keys');

require('./_object-sap')('keys', function () {
  return function keys(it) {
    return $keys(toObject(it));
  };
});

},{"./_object-keys":91,"./_object-sap":93,"./_to-object":127}],211:[function(require,module,exports){
// 19.1.2.15 Object.preventExtensions(O)
var isObject = require('./_is-object');
var meta = require('./_meta').onFreeze;

require('./_object-sap')('preventExtensions', function ($preventExtensions) {
  return function preventExtensions(it) {
    return $preventExtensions && isObject(it) ? $preventExtensions(meta(it)) : it;
  };
});

},{"./_is-object":62,"./_meta":76,"./_object-sap":93}],212:[function(require,module,exports){
// 19.1.2.17 Object.seal(O)
var isObject = require('./_is-object');
var meta = require('./_meta').onFreeze;

require('./_object-sap')('seal', function ($seal) {
  return function seal(it) {
    return $seal && isObject(it) ? $seal(meta(it)) : it;
  };
});

},{"./_is-object":62,"./_meta":76,"./_object-sap":93}],213:[function(require,module,exports){
// 19.1.3.19 Object.setPrototypeOf(O, proto)
var $export = require('./_export');
$export($export.S, 'Object', { setPrototypeOf: require('./_set-proto').set });

},{"./_export":44,"./_set-proto":107}],214:[function(require,module,exports){
'use strict';
// 19.1.3.6 Object.prototype.toString()
var classof = require('./_classof');
var test = {};
test[require('./_wks')('toStringTag')] = 'z';
if (test + '' != '[object z]') {
  require('./_redefine')(Object.prototype, 'toString', function toString() {
    return '[object ' + classof(this) + ']';
  }, true);
}

},{"./_classof":28,"./_redefine":102,"./_wks":136}],215:[function(require,module,exports){
var $export = require('./_export');
var $parseFloat = require('./_parse-float');
// 18.2.4 parseFloat(string)
$export($export.G + $export.F * (parseFloat != $parseFloat), { parseFloat: $parseFloat });

},{"./_export":44,"./_parse-float":96}],216:[function(require,module,exports){
var $export = require('./_export');
var $parseInt = require('./_parse-int');
// 18.2.5 parseInt(string, radix)
$export($export.G + $export.F * (parseInt != $parseInt), { parseInt: $parseInt });

},{"./_export":44,"./_parse-int":97}],217:[function(require,module,exports){
'use strict';
var LIBRARY = require('./_library');
var global = require('./_global');
var ctx = require('./_ctx');
var classof = require('./_classof');
var $export = require('./_export');
var isObject = require('./_is-object');
var aFunction = require('./_a-function');
var anInstance = require('./_an-instance');
var forOf = require('./_for-of');
var speciesConstructor = require('./_species-constructor');
var task = require('./_task').set;
var microtask = require('./_microtask')();
var newPromiseCapabilityModule = require('./_new-promise-capability');
var perform = require('./_perform');
var promiseResolve = require('./_promise-resolve');
var PROMISE = 'Promise';
var TypeError = global.TypeError;
var process = global.process;
var $Promise = global[PROMISE];
var isNode = classof(process) == 'process';
var empty = function () { /* empty */ };
var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
var newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;

var USE_NATIVE = !!function () {
  try {
    // correct subclassing with @@species support
    var promise = $Promise.resolve(1);
    var FakePromise = (promise.constructor = {})[require('./_wks')('species')] = function (exec) {
      exec(empty, empty);
    };
    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
    return (isNode || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise;
  } catch (e) { /* empty */ }
}();

// helpers
var isThenable = function (it) {
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};
var notify = function (promise, isReject) {
  if (promise._n) return;
  promise._n = true;
  var chain = promise._c;
  microtask(function () {
    var value = promise._v;
    var ok = promise._s == 1;
    var i = 0;
    var run = function (reaction) {
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve = reaction.resolve;
      var reject = reaction.reject;
      var domain = reaction.domain;
      var result, then;
      try {
        if (handler) {
          if (!ok) {
            if (promise._h == 2) onHandleUnhandled(promise);
            promise._h = 1;
          }
          if (handler === true) result = value;
          else {
            if (domain) domain.enter();
            result = handler(value);
            if (domain) domain.exit();
          }
          if (result === reaction.promise) {
            reject(TypeError('Promise-chain cycle'));
          } else if (then = isThenable(result)) {
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch (e) {
        reject(e);
      }
    };
    while (chain.length > i) run(chain[i++]); // variable length - can't use forEach
    promise._c = [];
    promise._n = false;
    if (isReject && !promise._h) onUnhandled(promise);
  });
};
var onUnhandled = function (promise) {
  task.call(global, function () {
    var value = promise._v;
    var unhandled = isUnhandled(promise);
    var result, handler, console;
    if (unhandled) {
      result = perform(function () {
        if (isNode) {
          process.emit('unhandledRejection', value, promise);
        } else if (handler = global.onunhandledrejection) {
          handler({ promise: promise, reason: value });
        } else if ((console = global.console) && console.error) {
          console.error('Unhandled promise rejection', value);
        }
      });
      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
    } promise._a = undefined;
    if (unhandled && result.e) throw result.v;
  });
};
var isUnhandled = function (promise) {
  if (promise._h == 1) return false;
  var chain = promise._a || promise._c;
  var i = 0;
  var reaction;
  while (chain.length > i) {
    reaction = chain[i++];
    if (reaction.fail || !isUnhandled(reaction.promise)) return false;
  } return true;
};
var onHandleUnhandled = function (promise) {
  task.call(global, function () {
    var handler;
    if (isNode) {
      process.emit('rejectionHandled', promise);
    } else if (handler = global.onrejectionhandled) {
      handler({ promise: promise, reason: promise._v });
    }
  });
};
var $reject = function (value) {
  var promise = this;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  promise._v = value;
  promise._s = 2;
  if (!promise._a) promise._a = promise._c.slice();
  notify(promise, true);
};
var $resolve = function (value) {
  var promise = this;
  var then;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  try {
    if (promise === value) throw TypeError("Promise can't be resolved itself");
    if (then = isThenable(value)) {
      microtask(function () {
        var wrapper = { _w: promise, _d: false }; // wrap
        try {
          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
        } catch (e) {
          $reject.call(wrapper, e);
        }
      });
    } else {
      promise._v = value;
      promise._s = 1;
      notify(promise, false);
    }
  } catch (e) {
    $reject.call({ _w: promise, _d: false }, e); // wrap
  }
};

// constructor polyfill
if (!USE_NATIVE) {
  // 25.4.3.1 Promise(executor)
  $Promise = function Promise(executor) {
    anInstance(this, $Promise, PROMISE, '_h');
    aFunction(executor);
    Internal.call(this);
    try {
      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
    } catch (err) {
      $reject.call(this, err);
    }
  };
  // eslint-disable-next-line no-unused-vars
  Internal = function Promise(executor) {
    this._c = [];             // <- awaiting reactions
    this._a = undefined;      // <- checked in isUnhandled reactions
    this._s = 0;              // <- state
    this._d = false;          // <- done
    this._v = undefined;      // <- value
    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
    this._n = false;          // <- notify
  };
  Internal.prototype = require('./_redefine-all')($Promise.prototype, {
    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
    then: function then(onFulfilled, onRejected) {
      var reaction = newPromiseCapability(speciesConstructor(this, $Promise));
      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail = typeof onRejected == 'function' && onRejected;
      reaction.domain = isNode ? process.domain : undefined;
      this._c.push(reaction);
      if (this._a) this._a.push(reaction);
      if (this._s) notify(this, false);
      return reaction.promise;
    },
    // 25.4.5.1 Promise.prototype.catch(onRejected)
    'catch': function (onRejected) {
      return this.then(undefined, onRejected);
    }
  });
  OwnPromiseCapability = function () {
    var promise = new Internal();
    this.promise = promise;
    this.resolve = ctx($resolve, promise, 1);
    this.reject = ctx($reject, promise, 1);
  };
  newPromiseCapabilityModule.f = newPromiseCapability = function (C) {
    return C === $Promise || C === Wrapper
      ? new OwnPromiseCapability(C)
      : newGenericPromiseCapability(C);
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Promise: $Promise });
require('./_set-to-string-tag')($Promise, PROMISE);
require('./_set-species')(PROMISE);
Wrapper = require('./_core')[PROMISE];

// statics
$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
  // 25.4.4.5 Promise.reject(r)
  reject: function reject(r) {
    var capability = newPromiseCapability(this);
    var $$reject = capability.reject;
    $$reject(r);
    return capability.promise;
  }
});
$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
  // 25.4.4.6 Promise.resolve(x)
  resolve: function resolve(x) {
    return promiseResolve(LIBRARY && this === Wrapper ? $Promise : this, x);
  }
});
$export($export.S + $export.F * !(USE_NATIVE && require('./_iter-detect')(function (iter) {
  $Promise.all(iter)['catch'](empty);
})), PROMISE, {
  // 25.4.4.1 Promise.all(iterable)
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var values = [];
      var index = 0;
      var remaining = 1;
      forOf(iterable, false, function (promise) {
        var $index = index++;
        var alreadyCalled = false;
        values.push(undefined);
        remaining++;
        C.resolve(promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[$index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if (result.e) reject(result.v);
    return capability.promise;
  },
  // 25.4.4.4 Promise.race(iterable)
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var reject = capability.reject;
    var result = perform(function () {
      forOf(iterable, false, function (promise) {
        C.resolve(promise).then(capability.resolve, reject);
      });
    });
    if (result.e) reject(result.v);
    return capability.promise;
  }
});

},{"./_a-function":14,"./_an-instance":17,"./_classof":28,"./_core":34,"./_ctx":36,"./_export":44,"./_for-of":50,"./_global":51,"./_is-object":62,"./_iter-detect":67,"./_library":70,"./_microtask":78,"./_new-promise-capability":79,"./_perform":98,"./_promise-resolve":99,"./_redefine-all":101,"./_set-species":108,"./_set-to-string-tag":109,"./_species-constructor":112,"./_task":121,"./_wks":136}],218:[function(require,module,exports){
// 26.1.1 Reflect.apply(target, thisArgument, argumentsList)
var $export = require('./_export');
var aFunction = require('./_a-function');
var anObject = require('./_an-object');
var rApply = (require('./_global').Reflect || {}).apply;
var fApply = Function.apply;
// MS Edge argumentsList argument is optional
$export($export.S + $export.F * !require('./_fails')(function () {
  rApply(function () { /* empty */ });
}), 'Reflect', {
  apply: function apply(target, thisArgument, argumentsList) {
    var T = aFunction(target);
    var L = anObject(argumentsList);
    return rApply ? rApply(T, thisArgument, L) : fApply.call(T, thisArgument, L);
  }
});

},{"./_a-function":14,"./_an-object":18,"./_export":44,"./_fails":46,"./_global":51}],219:[function(require,module,exports){
// 26.1.2 Reflect.construct(target, argumentsList [, newTarget])
var $export = require('./_export');
var create = require('./_object-create');
var aFunction = require('./_a-function');
var anObject = require('./_an-object');
var isObject = require('./_is-object');
var fails = require('./_fails');
var bind = require('./_bind');
var rConstruct = (require('./_global').Reflect || {}).construct;

// MS Edge supports only 2 arguments and argumentsList argument is optional
// FF Nightly sets third argument as `new.target`, but does not create `this` from it
var NEW_TARGET_BUG = fails(function () {
  function F() { /* empty */ }
  return !(rConstruct(function () { /* empty */ }, [], F) instanceof F);
});
var ARGS_BUG = !fails(function () {
  rConstruct(function () { /* empty */ });
});

$export($export.S + $export.F * (NEW_TARGET_BUG || ARGS_BUG), 'Reflect', {
  construct: function construct(Target, args /* , newTarget */) {
    aFunction(Target);
    anObject(args);
    var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);
    if (ARGS_BUG && !NEW_TARGET_BUG) return rConstruct(Target, args, newTarget);
    if (Target == newTarget) {
      // w/o altered newTarget, optimization for 0-4 arguments
      switch (args.length) {
        case 0: return new Target();
        case 1: return new Target(args[0]);
        case 2: return new Target(args[0], args[1]);
        case 3: return new Target(args[0], args[1], args[2]);
        case 4: return new Target(args[0], args[1], args[2], args[3]);
      }
      // w/o altered newTarget, lot of arguments case
      var $args = [null];
      $args.push.apply($args, args);
      return new (bind.apply(Target, $args))();
    }
    // with altered newTarget, not support built-in constructors
    var proto = newTarget.prototype;
    var instance = create(isObject(proto) ? proto : Object.prototype);
    var result = Function.apply.call(Target, instance, args);
    return isObject(result) ? result : instance;
  }
});

},{"./_a-function":14,"./_an-object":18,"./_bind":27,"./_export":44,"./_fails":46,"./_global":51,"./_is-object":62,"./_object-create":81}],220:[function(require,module,exports){
// 26.1.3 Reflect.defineProperty(target, propertyKey, attributes)
var dP = require('./_object-dp');
var $export = require('./_export');
var anObject = require('./_an-object');
var toPrimitive = require('./_to-primitive');

// MS Edge has broken Reflect.defineProperty - throwing instead of returning false
$export($export.S + $export.F * require('./_fails')(function () {
  // eslint-disable-next-line no-undef
  Reflect.defineProperty(dP.f({}, 1, { value: 1 }), 1, { value: 2 });
}), 'Reflect', {
  defineProperty: function defineProperty(target, propertyKey, attributes) {
    anObject(target);
    propertyKey = toPrimitive(propertyKey, true);
    anObject(attributes);
    try {
      dP.f(target, propertyKey, attributes);
      return true;
    } catch (e) {
      return false;
    }
  }
});

},{"./_an-object":18,"./_export":44,"./_fails":46,"./_object-dp":82,"./_to-primitive":128}],221:[function(require,module,exports){
// 26.1.4 Reflect.deleteProperty(target, propertyKey)
var $export = require('./_export');
var gOPD = require('./_object-gopd').f;
var anObject = require('./_an-object');

$export($export.S, 'Reflect', {
  deleteProperty: function deleteProperty(target, propertyKey) {
    var desc = gOPD(anObject(target), propertyKey);
    return desc && !desc.configurable ? false : delete target[propertyKey];
  }
});

},{"./_an-object":18,"./_export":44,"./_object-gopd":85}],222:[function(require,module,exports){
'use strict';
// 26.1.5 Reflect.enumerate(target)
var $export = require('./_export');
var anObject = require('./_an-object');
var Enumerate = function (iterated) {
  this._t = anObject(iterated); // target
  this._i = 0;                  // next index
  var keys = this._k = [];      // keys
  var key;
  for (key in iterated) keys.push(key);
};
require('./_iter-create')(Enumerate, 'Object', function () {
  var that = this;
  var keys = that._k;
  var key;
  do {
    if (that._i >= keys.length) return { value: undefined, done: true };
  } while (!((key = keys[that._i++]) in that._t));
  return { value: key, done: false };
});

$export($export.S, 'Reflect', {
  enumerate: function enumerate(target) {
    return new Enumerate(target);
  }
});

},{"./_an-object":18,"./_export":44,"./_iter-create":65}],223:[function(require,module,exports){
// 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey)
var gOPD = require('./_object-gopd');
var $export = require('./_export');
var anObject = require('./_an-object');

$export($export.S, 'Reflect', {
  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) {
    return gOPD.f(anObject(target), propertyKey);
  }
});

},{"./_an-object":18,"./_export":44,"./_object-gopd":85}],224:[function(require,module,exports){
// 26.1.8 Reflect.getPrototypeOf(target)
var $export = require('./_export');
var getProto = require('./_object-gpo');
var anObject = require('./_an-object');

$export($export.S, 'Reflect', {
  getPrototypeOf: function getPrototypeOf(target) {
    return getProto(anObject(target));
  }
});

},{"./_an-object":18,"./_export":44,"./_object-gpo":89}],225:[function(require,module,exports){
// 26.1.6 Reflect.get(target, propertyKey [, receiver])
var gOPD = require('./_object-gopd');
var getPrototypeOf = require('./_object-gpo');
var has = require('./_has');
var $export = require('./_export');
var isObject = require('./_is-object');
var anObject = require('./_an-object');

function get(target, propertyKey /* , receiver */) {
  var receiver = arguments.length < 3 ? target : arguments[2];
  var desc, proto;
  if (anObject(target) === receiver) return target[propertyKey];
  if (desc = gOPD.f(target, propertyKey)) return has(desc, 'value')
    ? desc.value
    : desc.get !== undefined
      ? desc.get.call(receiver)
      : undefined;
  if (isObject(proto = getPrototypeOf(target))) return get(proto, propertyKey, receiver);
}

$export($export.S, 'Reflect', { get: get });

},{"./_an-object":18,"./_export":44,"./_has":52,"./_is-object":62,"./_object-gopd":85,"./_object-gpo":89}],226:[function(require,module,exports){
// 26.1.9 Reflect.has(target, propertyKey)
var $export = require('./_export');

$export($export.S, 'Reflect', {
  has: function has(target, propertyKey) {
    return propertyKey in target;
  }
});

},{"./_export":44}],227:[function(require,module,exports){
// 26.1.10 Reflect.isExtensible(target)
var $export = require('./_export');
var anObject = require('./_an-object');
var $isExtensible = Object.isExtensible;

$export($export.S, 'Reflect', {
  isExtensible: function isExtensible(target) {
    anObject(target);
    return $isExtensible ? $isExtensible(target) : true;
  }
});

},{"./_an-object":18,"./_export":44}],228:[function(require,module,exports){
// 26.1.11 Reflect.ownKeys(target)
var $export = require('./_export');

$export($export.S, 'Reflect', { ownKeys: require('./_own-keys') });

},{"./_export":44,"./_own-keys":95}],229:[function(require,module,exports){
// 26.1.12 Reflect.preventExtensions(target)
var $export = require('./_export');
var anObject = require('./_an-object');
var $preventExtensions = Object.preventExtensions;

$export($export.S, 'Reflect', {
  preventExtensions: function preventExtensions(target) {
    anObject(target);
    try {
      if ($preventExtensions) $preventExtensions(target);
      return true;
    } catch (e) {
      return false;
    }
  }
});

},{"./_an-object":18,"./_export":44}],230:[function(require,module,exports){
// 26.1.14 Reflect.setPrototypeOf(target, proto)
var $export = require('./_export');
var setProto = require('./_set-proto');

if (setProto) $export($export.S, 'Reflect', {
  setPrototypeOf: function setPrototypeOf(target, proto) {
    setProto.check(target, proto);
    try {
      setProto.set(target, proto);
      return true;
    } catch (e) {
      return false;
    }
  }
});

},{"./_export":44,"./_set-proto":107}],231:[function(require,module,exports){
// 26.1.13 Reflect.set(target, propertyKey, V [, receiver])
var dP = require('./_object-dp');
var gOPD = require('./_object-gopd');
var getPrototypeOf = require('./_object-gpo');
var has = require('./_has');
var $export = require('./_export');
var createDesc = require('./_property-desc');
var anObject = require('./_an-object');
var isObject = require('./_is-object');

function set(target, propertyKey, V /* , receiver */) {
  var receiver = arguments.length < 4 ? target : arguments[3];
  var ownDesc = gOPD.f(anObject(target), propertyKey);
  var existingDescriptor, proto;
  if (!ownDesc) {
    if (isObject(proto = getPrototypeOf(target))) {
      return set(proto, propertyKey, V, receiver);
    }
    ownDesc = createDesc(0);
  }
  if (has(ownDesc, 'value')) {
    if (ownDesc.writable === false || !isObject(receiver)) return false;
    existingDescriptor = gOPD.f(receiver, propertyKey) || createDesc(0);
    existingDescriptor.value = V;
    dP.f(receiver, propertyKey, existingDescriptor);
    return true;
  }
  return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true);
}

$export($export.S, 'Reflect', { set: set });

},{"./_an-object":18,"./_export":44,"./_has":52,"./_is-object":62,"./_object-dp":82,"./_object-gopd":85,"./_object-gpo":89,"./_property-desc":100}],232:[function(require,module,exports){
var global = require('./_global');
var inheritIfRequired = require('./_inherit-if-required');
var dP = require('./_object-dp').f;
var gOPN = require('./_object-gopn').f;
var isRegExp = require('./_is-regexp');
var $flags = require('./_flags');
var $RegExp = global.RegExp;
var Base = $RegExp;
var proto = $RegExp.prototype;
var re1 = /a/g;
var re2 = /a/g;
// "new" creates a new object, old webkit buggy here
var CORRECT_NEW = new $RegExp(re1) !== re1;

if (require('./_descriptors') && (!CORRECT_NEW || require('./_fails')(function () {
  re2[require('./_wks')('match')] = false;
  // RegExp constructor can alter flags and IsRegExp works correct with @@match
  return $RegExp(re1) != re1 || $RegExp(re2) == re2 || $RegExp(re1, 'i') != '/a/i';
}))) {
  $RegExp = function RegExp(p, f) {
    var tiRE = this instanceof $RegExp;
    var piRE = isRegExp(p);
    var fiU = f === undefined;
    return !tiRE && piRE && p.constructor === $RegExp && fiU ? p
      : inheritIfRequired(CORRECT_NEW
        ? new Base(piRE && !fiU ? p.source : p, f)
        : Base((piRE = p instanceof $RegExp) ? p.source : p, piRE && fiU ? $flags.call(p) : f)
      , tiRE ? this : proto, $RegExp);
  };
  var proxy = function (key) {
    key in $RegExp || dP($RegExp, key, {
      configurable: true,
      get: function () { return Base[key]; },
      set: function (it) { Base[key] = it; }
    });
  };
  for (var keys = gOPN(Base), i = 0; keys.length > i;) proxy(keys[i++]);
  proto.constructor = $RegExp;
  $RegExp.prototype = proto;
  require('./_redefine')(global, 'RegExp', $RegExp);
}

require('./_set-species')('RegExp');

},{"./_descriptors":40,"./_fails":46,"./_flags":48,"./_global":51,"./_inherit-if-required":56,"./_is-regexp":63,"./_object-dp":82,"./_object-gopn":87,"./_redefine":102,"./_set-species":108,"./_wks":136}],233:[function(require,module,exports){
// 21.2.5.3 get RegExp.prototype.flags()
if (require('./_descriptors') && /./g.flags != 'g') require('./_object-dp').f(RegExp.prototype, 'flags', {
  configurable: true,
  get: require('./_flags')
});

},{"./_descriptors":40,"./_flags":48,"./_object-dp":82}],234:[function(require,module,exports){
// @@match logic
require('./_fix-re-wks')('match', 1, function (defined, MATCH, $match) {
  // 21.1.3.11 String.prototype.match(regexp)
  return [function match(regexp) {
    'use strict';
    var O = defined(this);
    var fn = regexp == undefined ? undefined : regexp[MATCH];
    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
  }, $match];
});

},{"./_fix-re-wks":47}],235:[function(require,module,exports){
// @@replace logic
require('./_fix-re-wks')('replace', 2, function (defined, REPLACE, $replace) {
  // 21.1.3.14 String.prototype.replace(searchValue, replaceValue)
  return [function replace(searchValue, replaceValue) {
    'use strict';
    var O = defined(this);
    var fn = searchValue == undefined ? undefined : searchValue[REPLACE];
    return fn !== undefined
      ? fn.call(searchValue, O, replaceValue)
      : $replace.call(String(O), searchValue, replaceValue);
  }, $replace];
});

},{"./_fix-re-wks":47}],236:[function(require,module,exports){
// @@search logic
require('./_fix-re-wks')('search', 1, function (defined, SEARCH, $search) {
  // 21.1.3.15 String.prototype.search(regexp)
  return [function search(regexp) {
    'use strict';
    var O = defined(this);
    var fn = regexp == undefined ? undefined : regexp[SEARCH];
    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
  }, $search];
});

},{"./_fix-re-wks":47}],237:[function(require,module,exports){
// @@split logic
require('./_fix-re-wks')('split', 2, function (defined, SPLIT, $split) {
  'use strict';
  var isRegExp = require('./_is-regexp');
  var _split = $split;
  var $push = [].push;
  var $SPLIT = 'split';
  var LENGTH = 'length';
  var LAST_INDEX = 'lastIndex';
  if (
    'abbc'[$SPLIT](/(b)*/)[1] == 'c' ||
    'test'[$SPLIT](/(?:)/, -1)[LENGTH] != 4 ||
    'ab'[$SPLIT](/(?:ab)*/)[LENGTH] != 2 ||
    '.'[$SPLIT](/(.?)(.?)/)[LENGTH] != 4 ||
    '.'[$SPLIT](/()()/)[LENGTH] > 1 ||
    ''[$SPLIT](/.?/)[LENGTH]
  ) {
    var NPCG = /()??/.exec('')[1] === undefined; // nonparticipating capturing group
    // based on es5-shim implementation, need to rework it
    $split = function (separator, limit) {
      var string = String(this);
      if (separator === undefined && limit === 0) return [];
      // If `separator` is not a regex, use native split
      if (!isRegExp(separator)) return _split.call(string, separator, limit);
      var output = [];
      var flags = (separator.ignoreCase ? 'i' : '') +
                  (separator.multiline ? 'm' : '') +
                  (separator.unicode ? 'u' : '') +
                  (separator.sticky ? 'y' : '');
      var lastLastIndex = 0;
      var splitLimit = limit === undefined ? 4294967295 : limit >>> 0;
      // Make `global` and avoid `lastIndex` issues by working with a copy
      var separatorCopy = new RegExp(separator.source, flags + 'g');
      var separator2, match, lastIndex, lastLength, i;
      // Doesn't need flags gy, but they don't hurt
      if (!NPCG) separator2 = new RegExp('^' + separatorCopy.source + '$(?!\\s)', flags);
      while (match = separatorCopy.exec(string)) {
        // `separatorCopy.lastIndex` is not reliable cross-browser
        lastIndex = match.index + match[0][LENGTH];
        if (lastIndex > lastLastIndex) {
          output.push(string.slice(lastLastIndex, match.index));
          // Fix browsers whose `exec` methods don't consistently return `undefined` for NPCG
          // eslint-disable-next-line no-loop-func
          if (!NPCG && match[LENGTH] > 1) match[0].replace(separator2, function () {
            for (i = 1; i < arguments[LENGTH] - 2; i++) if (arguments[i] === undefined) match[i] = undefined;
          });
          if (match[LENGTH] > 1 && match.index < string[LENGTH]) $push.apply(output, match.slice(1));
          lastLength = match[0][LENGTH];
          lastLastIndex = lastIndex;
          if (output[LENGTH] >= splitLimit) break;
        }
        if (separatorCopy[LAST_INDEX] === match.index) separatorCopy[LAST_INDEX]++; // Avoid an infinite loop
      }
      if (lastLastIndex === string[LENGTH]) {
        if (lastLength || !separatorCopy.test('')) output.push('');
      } else output.push(string.slice(lastLastIndex));
      return output[LENGTH] > splitLimit ? output.slice(0, splitLimit) : output;
    };
  // Chakra, V8
  } else if ('0'[$SPLIT](undefined, 0)[LENGTH]) {
    $split = function (separator, limit) {
      return separator === undefined && limit === 0 ? [] : _split.call(this, separator, limit);
    };
  }
  // 21.1.3.17 String.prototype.split(separator, limit)
  return [function split(separator, limit) {
    var O = defined(this);
    var fn = separator == undefined ? undefined : separator[SPLIT];
    return fn !== undefined ? fn.call(separator, O, limit) : $split.call(String(O), separator, limit);
  }, $split];
});

},{"./_fix-re-wks":47,"./_is-regexp":63}],238:[function(require,module,exports){
'use strict';
require('./es6.regexp.flags');
var anObject = require('./_an-object');
var $flags = require('./_flags');
var DESCRIPTORS = require('./_descriptors');
var TO_STRING = 'toString';
var $toString = /./[TO_STRING];

var define = function (fn) {
  require('./_redefine')(RegExp.prototype, TO_STRING, fn, true);
};

// 21.2.5.14 RegExp.prototype.toString()
if (require('./_fails')(function () { return $toString.call({ source: 'a', flags: 'b' }) != '/a/b'; })) {
  define(function toString() {
    var R = anObject(this);
    return '/'.concat(R.source, '/',
      'flags' in R ? R.flags : !DESCRIPTORS && R instanceof RegExp ? $flags.call(R) : undefined);
  });
// FF44- RegExp#toString has a wrong name
} else if ($toString.name != TO_STRING) {
  define(function toString() {
    return $toString.call(this);
  });
}

},{"./_an-object":18,"./_descriptors":40,"./_fails":46,"./_flags":48,"./_redefine":102,"./es6.regexp.flags":233}],239:[function(require,module,exports){
'use strict';
var strong = require('./_collection-strong');
var validate = require('./_validate-collection');
var SET = 'Set';

// 23.2 Set Objects
module.exports = require('./_collection')(SET, function (get) {
  return function Set() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.2.3.1 Set.prototype.add(value)
  add: function add(value) {
    return strong.def(validate(this, SET), value = value === 0 ? 0 : value, value);
  }
}, strong);

},{"./_collection":33,"./_collection-strong":30,"./_validate-collection":133}],240:[function(require,module,exports){
'use strict';
// B.2.3.2 String.prototype.anchor(name)
require('./_string-html')('anchor', function (createHTML) {
  return function anchor(name) {
    return createHTML(this, 'a', 'name', name);
  };
});

},{"./_string-html":116}],241:[function(require,module,exports){
'use strict';
// B.2.3.3 String.prototype.big()
require('./_string-html')('big', function (createHTML) {
  return function big() {
    return createHTML(this, 'big', '', '');
  };
});

},{"./_string-html":116}],242:[function(require,module,exports){
'use strict';
// B.2.3.4 String.prototype.blink()
require('./_string-html')('blink', function (createHTML) {
  return function blink() {
    return createHTML(this, 'blink', '', '');
  };
});

},{"./_string-html":116}],243:[function(require,module,exports){
'use strict';
// B.2.3.5 String.prototype.bold()
require('./_string-html')('bold', function (createHTML) {
  return function bold() {
    return createHTML(this, 'b', '', '');
  };
});

},{"./_string-html":116}],244:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var $at = require('./_string-at')(false);
$export($export.P, 'String', {
  // 21.1.3.3 String.prototype.codePointAt(pos)
  codePointAt: function codePointAt(pos) {
    return $at(this, pos);
  }
});

},{"./_export":44,"./_string-at":114}],245:[function(require,module,exports){
// 21.1.3.6 String.prototype.endsWith(searchString [, endPosition])
'use strict';
var $export = require('./_export');
var toLength = require('./_to-length');
var context = require('./_string-context');
var ENDS_WITH = 'endsWith';
var $endsWith = ''[ENDS_WITH];

$export($export.P + $export.F * require('./_fails-is-regexp')(ENDS_WITH), 'String', {
  endsWith: function endsWith(searchString /* , endPosition = @length */) {
    var that = context(this, searchString, ENDS_WITH);
    var endPosition = arguments.length > 1 ? arguments[1] : undefined;
    var len = toLength(that.length);
    var end = endPosition === undefined ? len : Math.min(toLength(endPosition), len);
    var search = String(searchString);
    return $endsWith
      ? $endsWith.call(that, search, end)
      : that.slice(end - search.length, end) === search;
  }
});

},{"./_export":44,"./_fails-is-regexp":45,"./_string-context":115,"./_to-length":126}],246:[function(require,module,exports){
'use strict';
// B.2.3.6 String.prototype.fixed()
require('./_string-html')('fixed', function (createHTML) {
  return function fixed() {
    return createHTML(this, 'tt', '', '');
  };
});

},{"./_string-html":116}],247:[function(require,module,exports){
'use strict';
// B.2.3.7 String.prototype.fontcolor(color)
require('./_string-html')('fontcolor', function (createHTML) {
  return function fontcolor(color) {
    return createHTML(this, 'font', 'color', color);
  };
});

},{"./_string-html":116}],248:[function(require,module,exports){
'use strict';
// B.2.3.8 String.prototype.fontsize(size)
require('./_string-html')('fontsize', function (createHTML) {
  return function fontsize(size) {
    return createHTML(this, 'font', 'size', size);
  };
});

},{"./_string-html":116}],249:[function(require,module,exports){
var $export = require('./_export');
var toAbsoluteIndex = require('./_to-absolute-index');
var fromCharCode = String.fromCharCode;
var $fromCodePoint = String.fromCodePoint;

// length should be 1, old FF problem
$export($export.S + $export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {
  // 21.1.2.2 String.fromCodePoint(...codePoints)
  fromCodePoint: function fromCodePoint(x) { // eslint-disable-line no-unused-vars
    var res = [];
    var aLen = arguments.length;
    var i = 0;
    var code;
    while (aLen > i) {
      code = +arguments[i++];
      if (toAbsoluteIndex(code, 0x10ffff) !== code) throw RangeError(code + ' is not a valid code point');
      res.push(code < 0x10000
        ? fromCharCode(code)
        : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00)
      );
    } return res.join('');
  }
});

},{"./_export":44,"./_to-absolute-index":122}],250:[function(require,module,exports){
// 21.1.3.7 String.prototype.includes(searchString, position = 0)
'use strict';
var $export = require('./_export');
var context = require('./_string-context');
var INCLUDES = 'includes';

$export($export.P + $export.F * require('./_fails-is-regexp')(INCLUDES), 'String', {
  includes: function includes(searchString /* , position = 0 */) {
    return !!~context(this, searchString, INCLUDES)
      .indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);
  }
});

},{"./_export":44,"./_fails-is-regexp":45,"./_string-context":115}],251:[function(require,module,exports){
'use strict';
// B.2.3.9 String.prototype.italics()
require('./_string-html')('italics', function (createHTML) {
  return function italics() {
    return createHTML(this, 'i', '', '');
  };
});

},{"./_string-html":116}],252:[function(require,module,exports){
'use strict';
var $at = require('./_string-at')(true);

// 21.1.3.27 String.prototype[@@iterator]()
require('./_iter-define')(String, 'String', function (iterated) {
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var index = this._i;
  var point;
  if (index >= O.length) return { value: undefined, done: true };
  point = $at(O, index);
  this._i += point.length;
  return { value: point, done: false };
});

},{"./_iter-define":66,"./_string-at":114}],253:[function(require,module,exports){
'use strict';
// B.2.3.10 String.prototype.link(url)
require('./_string-html')('link', function (createHTML) {
  return function link(url) {
    return createHTML(this, 'a', 'href', url);
  };
});

},{"./_string-html":116}],254:[function(require,module,exports){
var $export = require('./_export');
var toIObject = require('./_to-iobject');
var toLength = require('./_to-length');

$export($export.S, 'String', {
  // 21.1.2.4 String.raw(callSite, ...substitutions)
  raw: function raw(callSite) {
    var tpl = toIObject(callSite.raw);
    var len = toLength(tpl.length);
    var aLen = arguments.length;
    var res = [];
    var i = 0;
    while (len > i) {
      res.push(String(tpl[i++]));
      if (i < aLen) res.push(String(arguments[i]));
    } return res.join('');
  }
});

},{"./_export":44,"./_to-iobject":125,"./_to-length":126}],255:[function(require,module,exports){
var $export = require('./_export');

$export($export.P, 'String', {
  // 21.1.3.13 String.prototype.repeat(count)
  repeat: require('./_string-repeat')
});

},{"./_export":44,"./_string-repeat":118}],256:[function(require,module,exports){
'use strict';
// B.2.3.11 String.prototype.small()
require('./_string-html')('small', function (createHTML) {
  return function small() {
    return createHTML(this, 'small', '', '');
  };
});

},{"./_string-html":116}],257:[function(require,module,exports){
// 21.1.3.18 String.prototype.startsWith(searchString [, position ])
'use strict';
var $export = require('./_export');
var toLength = require('./_to-length');
var context = require('./_string-context');
var STARTS_WITH = 'startsWith';
var $startsWith = ''[STARTS_WITH];

$export($export.P + $export.F * require('./_fails-is-regexp')(STARTS_WITH), 'String', {
  startsWith: function startsWith(searchString /* , position = 0 */) {
    var that = context(this, searchString, STARTS_WITH);
    var index = toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length));
    var search = String(searchString);
    return $startsWith
      ? $startsWith.call(that, search, index)
      : that.slice(index, index + search.length) === search;
  }
});

},{"./_export":44,"./_fails-is-regexp":45,"./_string-context":115,"./_to-length":126}],258:[function(require,module,exports){
'use strict';
// B.2.3.12 String.prototype.strike()
require('./_string-html')('strike', function (createHTML) {
  return function strike() {
    return createHTML(this, 'strike', '', '');
  };
});

},{"./_string-html":116}],259:[function(require,module,exports){
'use strict';
// B.2.3.13 String.prototype.sub()
require('./_string-html')('sub', function (createHTML) {
  return function sub() {
    return createHTML(this, 'sub', '', '');
  };
});

},{"./_string-html":116}],260:[function(require,module,exports){
'use strict';
// B.2.3.14 String.prototype.sup()
require('./_string-html')('sup', function (createHTML) {
  return function sup() {
    return createHTML(this, 'sup', '', '');
  };
});

},{"./_string-html":116}],261:[function(require,module,exports){
'use strict';
// 21.1.3.25 String.prototype.trim()
require('./_string-trim')('trim', function ($trim) {
  return function trim() {
    return $trim(this, 3);
  };
});

},{"./_string-trim":119}],262:[function(require,module,exports){
'use strict';
// ECMAScript 6 symbols shim
var global = require('./_global');
var has = require('./_has');
var DESCRIPTORS = require('./_descriptors');
var $export = require('./_export');
var redefine = require('./_redefine');
var META = require('./_meta').KEY;
var $fails = require('./_fails');
var shared = require('./_shared');
var setToStringTag = require('./_set-to-string-tag');
var uid = require('./_uid');
var wks = require('./_wks');
var wksExt = require('./_wks-ext');
var wksDefine = require('./_wks-define');
var enumKeys = require('./_enum-keys');
var isArray = require('./_is-array');
var anObject = require('./_an-object');
var toIObject = require('./_to-iobject');
var toPrimitive = require('./_to-primitive');
var createDesc = require('./_property-desc');
var _create = require('./_object-create');
var gOPNExt = require('./_object-gopn-ext');
var $GOPD = require('./_object-gopd');
var $DP = require('./_object-dp');
var $keys = require('./_object-keys');
var gOPD = $GOPD.f;
var dP = $DP.f;
var gOPN = gOPNExt.f;
var $Symbol = global.Symbol;
var $JSON = global.JSON;
var _stringify = $JSON && $JSON.stringify;
var PROTOTYPE = 'prototype';
var HIDDEN = wks('_hidden');
var TO_PRIMITIVE = wks('toPrimitive');
var isEnum = {}.propertyIsEnumerable;
var SymbolRegistry = shared('symbol-registry');
var AllSymbols = shared('symbols');
var OPSymbols = shared('op-symbols');
var ObjectProto = Object[PROTOTYPE];
var USE_NATIVE = typeof $Symbol == 'function';
var QObject = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = DESCRIPTORS && $fails(function () {
  return _create(dP({}, 'a', {
    get: function () { return dP(this, 'a', { value: 7 }).a; }
  })).a != 7;
}) ? function (it, key, D) {
  var protoDesc = gOPD(ObjectProto, key);
  if (protoDesc) delete ObjectProto[key];
  dP(it, key, D);
  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function (tag) {
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D) {
  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);
  if (has(AllSymbols, key)) {
    if (!D.enumerable) {
      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
      D = _create(D, { enumerable: createDesc(0, false) });
    } return setSymbolDesc(it, key, D);
  } return dP(it, key, D);
};
var $defineProperties = function defineProperties(it, P) {
  anObject(it);
  var keys = enumKeys(P = toIObject(P));
  var i = 0;
  var l = keys.length;
  var key;
  while (l > i) $defineProperty(it, key = keys[i++], P[key]);
  return it;
};
var $create = function create(it, P) {
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key) {
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
  it = toIObject(it);
  key = toPrimitive(key, true);
  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
  var D = gOPD(it, key);
  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it) {
  var names = gOPN(toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
  } return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
  var IS_OP = it === ObjectProto;
  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
  } return result;
};

// 19.4.1.1 Symbol([description])
if (!USE_NATIVE) {
  $Symbol = function Symbol() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
    var $set = function (value) {
      if (this === ObjectProto) $set.call(OPSymbols, value);
      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };
    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
    return wrap(tag);
  };
  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
    return this._k;
  });

  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f = $defineProperty;
  require('./_object-gopn').f = gOPNExt.f = $getOwnPropertyNames;
  require('./_object-pie').f = $propertyIsEnumerable;
  require('./_object-gops').f = $getOwnPropertySymbols;

  if (DESCRIPTORS && !require('./_library')) {
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function (name) {
    return wrap(wks(name));
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });

for (var es6Symbols = (
  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
).split(','), j = 0; es6Symbols.length > j;)wks(es6Symbols[j++]);

for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);

$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function (key) {
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');
    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
  },
  useSetter: function () { setter = true; },
  useSimple: function () { setter = false; }
});

$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it) {
    if (it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
    var args = [it];
    var i = 1;
    var replacer, $replacer;
    while (arguments.length > i) args.push(arguments[i++]);
    replacer = args[1];
    if (typeof replacer == 'function') $replacer = replacer;
    if ($replacer || !isArray(replacer)) replacer = function (key, value) {
      if ($replacer) value = $replacer.call(this, key, value);
      if (!isSymbol(value)) return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
});

// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
$Symbol[PROTOTYPE][TO_PRIMITIVE] || require('./_hide')($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setToStringTag(global.JSON, 'JSON', true);

},{"./_an-object":18,"./_descriptors":40,"./_enum-keys":43,"./_export":44,"./_fails":46,"./_global":51,"./_has":52,"./_hide":53,"./_is-array":60,"./_library":70,"./_meta":76,"./_object-create":81,"./_object-dp":82,"./_object-gopd":85,"./_object-gopn":87,"./_object-gopn-ext":86,"./_object-gops":88,"./_object-keys":91,"./_object-pie":92,"./_property-desc":100,"./_redefine":102,"./_set-to-string-tag":109,"./_shared":111,"./_to-iobject":125,"./_to-primitive":128,"./_uid":132,"./_wks":136,"./_wks-define":134,"./_wks-ext":135}],263:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var $typed = require('./_typed');
var buffer = require('./_typed-buffer');
var anObject = require('./_an-object');
var toAbsoluteIndex = require('./_to-absolute-index');
var toLength = require('./_to-length');
var isObject = require('./_is-object');
var ArrayBuffer = require('./_global').ArrayBuffer;
var speciesConstructor = require('./_species-constructor');
var $ArrayBuffer = buffer.ArrayBuffer;
var $DataView = buffer.DataView;
var $isView = $typed.ABV && ArrayBuffer.isView;
var $slice = $ArrayBuffer.prototype.slice;
var VIEW = $typed.VIEW;
var ARRAY_BUFFER = 'ArrayBuffer';

$export($export.G + $export.W + $export.F * (ArrayBuffer !== $ArrayBuffer), { ArrayBuffer: $ArrayBuffer });

$export($export.S + $export.F * !$typed.CONSTR, ARRAY_BUFFER, {
  // 24.1.3.1 ArrayBuffer.isView(arg)
  isView: function isView(it) {
    return $isView && $isView(it) || isObject(it) && VIEW in it;
  }
});

$export($export.P + $export.U + $export.F * require('./_fails')(function () {
  return !new $ArrayBuffer(2).slice(1, undefined).byteLength;
}), ARRAY_BUFFER, {
  // 24.1.4.3 ArrayBuffer.prototype.slice(start, end)
  slice: function slice(start, end) {
    if ($slice !== undefined && end === undefined) return $slice.call(anObject(this), start); // FF fix
    var len = anObject(this).byteLength;
    var first = toAbsoluteIndex(start, len);
    var final = toAbsoluteIndex(end === undefined ? len : end, len);
    var result = new (speciesConstructor(this, $ArrayBuffer))(toLength(final - first));
    var viewS = new $DataView(this);
    var viewT = new $DataView(result);
    var index = 0;
    while (first < final) {
      viewT.setUint8(index++, viewS.getUint8(first++));
    } return result;
  }
});

require('./_set-species')(ARRAY_BUFFER);

},{"./_an-object":18,"./_export":44,"./_fails":46,"./_global":51,"./_is-object":62,"./_set-species":108,"./_species-constructor":112,"./_to-absolute-index":122,"./_to-length":126,"./_typed":131,"./_typed-buffer":130}],264:[function(require,module,exports){
var $export = require('./_export');
$export($export.G + $export.W + $export.F * !require('./_typed').ABV, {
  DataView: require('./_typed-buffer').DataView
});

},{"./_export":44,"./_typed":131,"./_typed-buffer":130}],265:[function(require,module,exports){
require('./_typed-array')('Float32', 4, function (init) {
  return function Float32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":129}],266:[function(require,module,exports){
require('./_typed-array')('Float64', 8, function (init) {
  return function Float64Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":129}],267:[function(require,module,exports){
require('./_typed-array')('Int16', 2, function (init) {
  return function Int16Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":129}],268:[function(require,module,exports){
require('./_typed-array')('Int32', 4, function (init) {
  return function Int32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":129}],269:[function(require,module,exports){
require('./_typed-array')('Int8', 1, function (init) {
  return function Int8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":129}],270:[function(require,module,exports){
require('./_typed-array')('Uint16', 2, function (init) {
  return function Uint16Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":129}],271:[function(require,module,exports){
require('./_typed-array')('Uint32', 4, function (init) {
  return function Uint32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":129}],272:[function(require,module,exports){
require('./_typed-array')('Uint8', 1, function (init) {
  return function Uint8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":129}],273:[function(require,module,exports){
require('./_typed-array')('Uint8', 1, function (init) {
  return function Uint8ClampedArray(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
}, true);

},{"./_typed-array":129}],274:[function(require,module,exports){
'use strict';
var each = require('./_array-methods')(0);
var redefine = require('./_redefine');
var meta = require('./_meta');
var assign = require('./_object-assign');
var weak = require('./_collection-weak');
var isObject = require('./_is-object');
var fails = require('./_fails');
var validate = require('./_validate-collection');
var WEAK_MAP = 'WeakMap';
var getWeak = meta.getWeak;
var isExtensible = Object.isExtensible;
var uncaughtFrozenStore = weak.ufstore;
var tmp = {};
var InternalMap;

var wrapper = function (get) {
  return function WeakMap() {
    return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
};

var methods = {
  // 23.3.3.3 WeakMap.prototype.get(key)
  get: function get(key) {
    if (isObject(key)) {
      var data = getWeak(key);
      if (data === true) return uncaughtFrozenStore(validate(this, WEAK_MAP)).get(key);
      return data ? data[this._i] : undefined;
    }
  },
  // 23.3.3.5 WeakMap.prototype.set(key, value)
  set: function set(key, value) {
    return weak.def(validate(this, WEAK_MAP), key, value);
  }
};

// 23.3 WeakMap Objects
var $WeakMap = module.exports = require('./_collection')(WEAK_MAP, wrapper, methods, weak, true, true);

// IE11 WeakMap frozen keys fix
if (fails(function () { return new $WeakMap().set((Object.freeze || Object)(tmp), 7).get(tmp) != 7; })) {
  InternalMap = weak.getConstructor(wrapper, WEAK_MAP);
  assign(InternalMap.prototype, methods);
  meta.NEED = true;
  each(['delete', 'has', 'get', 'set'], function (key) {
    var proto = $WeakMap.prototype;
    var method = proto[key];
    redefine(proto, key, function (a, b) {
      // store frozen objects on internal weakmap shim
      if (isObject(a) && !isExtensible(a)) {
        if (!this._f) this._f = new InternalMap();
        var result = this._f[key](a, b);
        return key == 'set' ? this : result;
      // store all the rest on native weakmap
      } return method.call(this, a, b);
    });
  });
}

},{"./_array-methods":23,"./_collection":33,"./_collection-weak":32,"./_fails":46,"./_is-object":62,"./_meta":76,"./_object-assign":80,"./_redefine":102,"./_validate-collection":133}],275:[function(require,module,exports){
'use strict';
var weak = require('./_collection-weak');
var validate = require('./_validate-collection');
var WEAK_SET = 'WeakSet';

// 23.4 WeakSet Objects
require('./_collection')(WEAK_SET, function (get) {
  return function WeakSet() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.4.3.1 WeakSet.prototype.add(value)
  add: function add(value) {
    return weak.def(validate(this, WEAK_SET), value, true);
  }
}, weak, false, true);

},{"./_collection":33,"./_collection-weak":32,"./_validate-collection":133}],276:[function(require,module,exports){
'use strict';
// https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatMap
var $export = require('./_export');
var flattenIntoArray = require('./_flatten-into-array');
var toObject = require('./_to-object');
var toLength = require('./_to-length');
var aFunction = require('./_a-function');
var arraySpeciesCreate = require('./_array-species-create');

$export($export.P, 'Array', {
  flatMap: function flatMap(callbackfn /* , thisArg */) {
    var O = toObject(this);
    var sourceLen, A;
    aFunction(callbackfn);
    sourceLen = toLength(O.length);
    A = arraySpeciesCreate(O, 0);
    flattenIntoArray(A, O, O, sourceLen, 0, 1, callbackfn, arguments[1]);
    return A;
  }
});

require('./_add-to-unscopables')('flatMap');

},{"./_a-function":14,"./_add-to-unscopables":16,"./_array-species-create":26,"./_export":44,"./_flatten-into-array":49,"./_to-length":126,"./_to-object":127}],277:[function(require,module,exports){
'use strict';
// https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatten
var $export = require('./_export');
var flattenIntoArray = require('./_flatten-into-array');
var toObject = require('./_to-object');
var toLength = require('./_to-length');
var toInteger = require('./_to-integer');
var arraySpeciesCreate = require('./_array-species-create');

$export($export.P, 'Array', {
  flatten: function flatten(/* depthArg = 1 */) {
    var depthArg = arguments[0];
    var O = toObject(this);
    var sourceLen = toLength(O.length);
    var A = arraySpeciesCreate(O, 0);
    flattenIntoArray(A, O, O, sourceLen, 0, depthArg === undefined ? 1 : toInteger(depthArg));
    return A;
  }
});

require('./_add-to-unscopables')('flatten');

},{"./_add-to-unscopables":16,"./_array-species-create":26,"./_export":44,"./_flatten-into-array":49,"./_to-integer":124,"./_to-length":126,"./_to-object":127}],278:[function(require,module,exports){
'use strict';
// https://github.com/tc39/Array.prototype.includes
var $export = require('./_export');
var $includes = require('./_array-includes')(true);

$export($export.P, 'Array', {
  includes: function includes(el /* , fromIndex = 0 */) {
    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
  }
});

require('./_add-to-unscopables')('includes');

},{"./_add-to-unscopables":16,"./_array-includes":22,"./_export":44}],279:[function(require,module,exports){
// https://github.com/rwaldron/tc39-notes/blob/master/es6/2014-09/sept-25.md#510-globalasap-for-enqueuing-a-microtask
var $export = require('./_export');
var microtask = require('./_microtask')();
var process = require('./_global').process;
var isNode = require('./_cof')(process) == 'process';

$export($export.G, {
  asap: function asap(fn) {
    var domain = isNode && process.domain;
    microtask(domain ? domain.bind(fn) : fn);
  }
});

},{"./_cof":29,"./_export":44,"./_global":51,"./_microtask":78}],280:[function(require,module,exports){
// https://github.com/ljharb/proposal-is-error
var $export = require('./_export');
var cof = require('./_cof');

$export($export.S, 'Error', {
  isError: function isError(it) {
    return cof(it) === 'Error';
  }
});

},{"./_cof":29,"./_export":44}],281:[function(require,module,exports){
// https://github.com/tc39/proposal-global
var $export = require('./_export');

$export($export.G, { global: require('./_global') });

},{"./_export":44,"./_global":51}],282:[function(require,module,exports){
// https://tc39.github.io/proposal-setmap-offrom/#sec-map.from
require('./_set-collection-from')('Map');

},{"./_set-collection-from":105}],283:[function(require,module,exports){
// https://tc39.github.io/proposal-setmap-offrom/#sec-map.of
require('./_set-collection-of')('Map');

},{"./_set-collection-of":106}],284:[function(require,module,exports){
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export = require('./_export');

$export($export.P + $export.R, 'Map', { toJSON: require('./_collection-to-json')('Map') });

},{"./_collection-to-json":31,"./_export":44}],285:[function(require,module,exports){
// https://rwaldron.github.io/proposal-math-extensions/
var $export = require('./_export');

$export($export.S, 'Math', {
  clamp: function clamp(x, lower, upper) {
    return Math.min(upper, Math.max(lower, x));
  }
});

},{"./_export":44}],286:[function(require,module,exports){
// https://rwaldron.github.io/proposal-math-extensions/
var $export = require('./_export');

$export($export.S, 'Math', { DEG_PER_RAD: Math.PI / 180 });

},{"./_export":44}],287:[function(require,module,exports){
// https://rwaldron.github.io/proposal-math-extensions/
var $export = require('./_export');
var RAD_PER_DEG = 180 / Math.PI;

$export($export.S, 'Math', {
  degrees: function degrees(radians) {
    return radians * RAD_PER_DEG;
  }
});

},{"./_export":44}],288:[function(require,module,exports){
// https://rwaldron.github.io/proposal-math-extensions/
var $export = require('./_export');
var scale = require('./_math-scale');
var fround = require('./_math-fround');

$export($export.S, 'Math', {
  fscale: function fscale(x, inLow, inHigh, outLow, outHigh) {
    return fround(scale(x, inLow, inHigh, outLow, outHigh));
  }
});

},{"./_export":44,"./_math-fround":72,"./_math-scale":74}],289:[function(require,module,exports){
// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = require('./_export');

$export($export.S, 'Math', {
  iaddh: function iaddh(x0, x1, y0, y1) {
    var $x0 = x0 >>> 0;
    var $x1 = x1 >>> 0;
    var $y0 = y0 >>> 0;
    return $x1 + (y1 >>> 0) + (($x0 & $y0 | ($x0 | $y0) & ~($x0 + $y0 >>> 0)) >>> 31) | 0;
  }
});

},{"./_export":44}],290:[function(require,module,exports){
// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = require('./_export');

$export($export.S, 'Math', {
  imulh: function imulh(u, v) {
    var UINT16 = 0xffff;
    var $u = +u;
    var $v = +v;
    var u0 = $u & UINT16;
    var v0 = $v & UINT16;
    var u1 = $u >> 16;
    var v1 = $v >> 16;
    var t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
    return u1 * v1 + (t >> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >> 16);
  }
});

},{"./_export":44}],291:[function(require,module,exports){
// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = require('./_export');

$export($export.S, 'Math', {
  isubh: function isubh(x0, x1, y0, y1) {
    var $x0 = x0 >>> 0;
    var $x1 = x1 >>> 0;
    var $y0 = y0 >>> 0;
    return $x1 - (y1 >>> 0) - ((~$x0 & $y0 | ~($x0 ^ $y0) & $x0 - $y0 >>> 0) >>> 31) | 0;
  }
});

},{"./_export":44}],292:[function(require,module,exports){
// https://rwaldron.github.io/proposal-math-extensions/
var $export = require('./_export');

$export($export.S, 'Math', { RAD_PER_DEG: 180 / Math.PI });

},{"./_export":44}],293:[function(require,module,exports){
// https://rwaldron.github.io/proposal-math-extensions/
var $export = require('./_export');
var DEG_PER_RAD = Math.PI / 180;

$export($export.S, 'Math', {
  radians: function radians(degrees) {
    return degrees * DEG_PER_RAD;
  }
});

},{"./_export":44}],294:[function(require,module,exports){
// https://rwaldron.github.io/proposal-math-extensions/
var $export = require('./_export');

$export($export.S, 'Math', { scale: require('./_math-scale') });

},{"./_export":44,"./_math-scale":74}],295:[function(require,module,exports){
// http://jfbastien.github.io/papers/Math.signbit.html
var $export = require('./_export');

$export($export.S, 'Math', { signbit: function signbit(x) {
  // eslint-disable-next-line no-self-compare
  return (x = +x) != x ? x : x == 0 ? 1 / x == Infinity : x > 0;
} });

},{"./_export":44}],296:[function(require,module,exports){
// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = require('./_export');

$export($export.S, 'Math', {
  umulh: function umulh(u, v) {
    var UINT16 = 0xffff;
    var $u = +u;
    var $v = +v;
    var u0 = $u & UINT16;
    var v0 = $v & UINT16;
    var u1 = $u >>> 16;
    var v1 = $v >>> 16;
    var t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
    return u1 * v1 + (t >>> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >>> 16);
  }
});

},{"./_export":44}],297:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var toObject = require('./_to-object');
var aFunction = require('./_a-function');
var $defineProperty = require('./_object-dp');

// B.2.2.2 Object.prototype.__defineGetter__(P, getter)
require('./_descriptors') && $export($export.P + require('./_object-forced-pam'), 'Object', {
  __defineGetter__: function __defineGetter__(P, getter) {
    $defineProperty.f(toObject(this), P, { get: aFunction(getter), enumerable: true, configurable: true });
  }
});

},{"./_a-function":14,"./_descriptors":40,"./_export":44,"./_object-dp":82,"./_object-forced-pam":84,"./_to-object":127}],298:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var toObject = require('./_to-object');
var aFunction = require('./_a-function');
var $defineProperty = require('./_object-dp');

// B.2.2.3 Object.prototype.__defineSetter__(P, setter)
require('./_descriptors') && $export($export.P + require('./_object-forced-pam'), 'Object', {
  __defineSetter__: function __defineSetter__(P, setter) {
    $defineProperty.f(toObject(this), P, { set: aFunction(setter), enumerable: true, configurable: true });
  }
});

},{"./_a-function":14,"./_descriptors":40,"./_export":44,"./_object-dp":82,"./_object-forced-pam":84,"./_to-object":127}],299:[function(require,module,exports){
// https://github.com/tc39/proposal-object-values-entries
var $export = require('./_export');
var $entries = require('./_object-to-array')(true);

$export($export.S, 'Object', {
  entries: function entries(it) {
    return $entries(it);
  }
});

},{"./_export":44,"./_object-to-array":94}],300:[function(require,module,exports){
// https://github.com/tc39/proposal-object-getownpropertydescriptors
var $export = require('./_export');
var ownKeys = require('./_own-keys');
var toIObject = require('./_to-iobject');
var gOPD = require('./_object-gopd');
var createProperty = require('./_create-property');

$export($export.S, 'Object', {
  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
    var O = toIObject(object);
    var getDesc = gOPD.f;
    var keys = ownKeys(O);
    var result = {};
    var i = 0;
    var key, desc;
    while (keys.length > i) {
      desc = getDesc(O, key = keys[i++]);
      if (desc !== undefined) createProperty(result, key, desc);
    }
    return result;
  }
});

},{"./_create-property":35,"./_export":44,"./_object-gopd":85,"./_own-keys":95,"./_to-iobject":125}],301:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var toObject = require('./_to-object');
var toPrimitive = require('./_to-primitive');
var getPrototypeOf = require('./_object-gpo');
var getOwnPropertyDescriptor = require('./_object-gopd').f;

// B.2.2.4 Object.prototype.__lookupGetter__(P)
require('./_descriptors') && $export($export.P + require('./_object-forced-pam'), 'Object', {
  __lookupGetter__: function __lookupGetter__(P) {
    var O = toObject(this);
    var K = toPrimitive(P, true);
    var D;
    do {
      if (D = getOwnPropertyDescriptor(O, K)) return D.get;
    } while (O = getPrototypeOf(O));
  }
});

},{"./_descriptors":40,"./_export":44,"./_object-forced-pam":84,"./_object-gopd":85,"./_object-gpo":89,"./_to-object":127,"./_to-primitive":128}],302:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var toObject = require('./_to-object');
var toPrimitive = require('./_to-primitive');
var getPrototypeOf = require('./_object-gpo');
var getOwnPropertyDescriptor = require('./_object-gopd').f;

// B.2.2.5 Object.prototype.__lookupSetter__(P)
require('./_descriptors') && $export($export.P + require('./_object-forced-pam'), 'Object', {
  __lookupSetter__: function __lookupSetter__(P) {
    var O = toObject(this);
    var K = toPrimitive(P, true);
    var D;
    do {
      if (D = getOwnPropertyDescriptor(O, K)) return D.set;
    } while (O = getPrototypeOf(O));
  }
});

},{"./_descriptors":40,"./_export":44,"./_object-forced-pam":84,"./_object-gopd":85,"./_object-gpo":89,"./_to-object":127,"./_to-primitive":128}],303:[function(require,module,exports){
// https://github.com/tc39/proposal-object-values-entries
var $export = require('./_export');
var $values = require('./_object-to-array')(false);

$export($export.S, 'Object', {
  values: function values(it) {
    return $values(it);
  }
});

},{"./_export":44,"./_object-to-array":94}],304:[function(require,module,exports){
'use strict';
// https://github.com/zenparsing/es-observable
var $export = require('./_export');
var global = require('./_global');
var core = require('./_core');
var microtask = require('./_microtask')();
var OBSERVABLE = require('./_wks')('observable');
var aFunction = require('./_a-function');
var anObject = require('./_an-object');
var anInstance = require('./_an-instance');
var redefineAll = require('./_redefine-all');
var hide = require('./_hide');
var forOf = require('./_for-of');
var RETURN = forOf.RETURN;

var getMethod = function (fn) {
  return fn == null ? undefined : aFunction(fn);
};

var cleanupSubscription = function (subscription) {
  var cleanup = subscription._c;
  if (cleanup) {
    subscription._c = undefined;
    cleanup();
  }
};

var subscriptionClosed = function (subscription) {
  return subscription._o === undefined;
};

var closeSubscription = function (subscription) {
  if (!subscriptionClosed(subscription)) {
    subscription._o = undefined;
    cleanupSubscription(subscription);
  }
};

var Subscription = function (observer, subscriber) {
  anObject(observer);
  this._c = undefined;
  this._o = observer;
  observer = new SubscriptionObserver(this);
  try {
    var cleanup = subscriber(observer);
    var subscription = cleanup;
    if (cleanup != null) {
      if (typeof cleanup.unsubscribe === 'function') cleanup = function () { subscription.unsubscribe(); };
      else aFunction(cleanup);
      this._c = cleanup;
    }
  } catch (e) {
    observer.error(e);
    return;
  } if (subscriptionClosed(this)) cleanupSubscription(this);
};

Subscription.prototype = redefineAll({}, {
  unsubscribe: function unsubscribe() { closeSubscription(this); }
});

var SubscriptionObserver = function (subscription) {
  this._s = subscription;
};

SubscriptionObserver.prototype = redefineAll({}, {
  next: function next(value) {
    var subscription = this._s;
    if (!subscriptionClosed(subscription)) {
      var observer = subscription._o;
      try {
        var m = getMethod(observer.next);
        if (m) return m.call(observer, value);
      } catch (e) {
        try {
          closeSubscription(subscription);
        } finally {
          throw e;
        }
      }
    }
  },
  error: function error(value) {
    var subscription = this._s;
    if (subscriptionClosed(subscription)) throw value;
    var observer = subscription._o;
    subscription._o = undefined;
    try {
      var m = getMethod(observer.error);
      if (!m) throw value;
      value = m.call(observer, value);
    } catch (e) {
      try {
        cleanupSubscription(subscription);
      } finally {
        throw e;
      }
    } cleanupSubscription(subscription);
    return value;
  },
  complete: function complete(value) {
    var subscription = this._s;
    if (!subscriptionClosed(subscription)) {
      var observer = subscription._o;
      subscription._o = undefined;
      try {
        var m = getMethod(observer.complete);
        value = m ? m.call(observer, value) : undefined;
      } catch (e) {
        try {
          cleanupSubscription(subscription);
        } finally {
          throw e;
        }
      } cleanupSubscription(subscription);
      return value;
    }
  }
});

var $Observable = function Observable(subscriber) {
  anInstance(this, $Observable, 'Observable', '_f')._f = aFunction(subscriber);
};

redefineAll($Observable.prototype, {
  subscribe: function subscribe(observer) {
    return new Subscription(observer, this._f);
  },
  forEach: function forEach(fn) {
    var that = this;
    return new (core.Promise || global.Promise)(function (resolve, reject) {
      aFunction(fn);
      var subscription = that.subscribe({
        next: function (value) {
          try {
            return fn(value);
          } catch (e) {
            reject(e);
            subscription.unsubscribe();
          }
        },
        error: reject,
        complete: resolve
      });
    });
  }
});

redefineAll($Observable, {
  from: function from(x) {
    var C = typeof this === 'function' ? this : $Observable;
    var method = getMethod(anObject(x)[OBSERVABLE]);
    if (method) {
      var observable = anObject(method.call(x));
      return observable.constructor === C ? observable : new C(function (observer) {
        return observable.subscribe(observer);
      });
    }
    return new C(function (observer) {
      var done = false;
      microtask(function () {
        if (!done) {
          try {
            if (forOf(x, false, function (it) {
              observer.next(it);
              if (done) return RETURN;
            }) === RETURN) return;
          } catch (e) {
            if (done) throw e;
            observer.error(e);
            return;
          } observer.complete();
        }
      });
      return function () { done = true; };
    });
  },
  of: function of() {
    for (var i = 0, l = arguments.length, items = Array(l); i < l;) items[i] = arguments[i++];
    return new (typeof this === 'function' ? this : $Observable)(function (observer) {
      var done = false;
      microtask(function () {
        if (!done) {
          for (var j = 0; j < items.length; ++j) {
            observer.next(items[j]);
            if (done) return;
          } observer.complete();
        }
      });
      return function () { done = true; };
    });
  }
});

hide($Observable.prototype, OBSERVABLE, function () { return this; });

$export($export.G, { Observable: $Observable });

require('./_set-species')('Observable');

},{"./_a-function":14,"./_an-instance":17,"./_an-object":18,"./_core":34,"./_export":44,"./_for-of":50,"./_global":51,"./_hide":53,"./_microtask":78,"./_redefine-all":101,"./_set-species":108,"./_wks":136}],305:[function(require,module,exports){
// https://github.com/tc39/proposal-promise-finally
'use strict';
var $export = require('./_export');
var core = require('./_core');
var global = require('./_global');
var speciesConstructor = require('./_species-constructor');
var promiseResolve = require('./_promise-resolve');

$export($export.P + $export.R, 'Promise', { 'finally': function (onFinally) {
  var C = speciesConstructor(this, core.Promise || global.Promise);
  var isFunction = typeof onFinally == 'function';
  return this.then(
    isFunction ? function (x) {
      return promiseResolve(C, onFinally()).then(function () { return x; });
    } : onFinally,
    isFunction ? function (e) {
      return promiseResolve(C, onFinally()).then(function () { throw e; });
    } : onFinally
  );
} });

},{"./_core":34,"./_export":44,"./_global":51,"./_promise-resolve":99,"./_species-constructor":112}],306:[function(require,module,exports){
'use strict';
// https://github.com/tc39/proposal-promise-try
var $export = require('./_export');
var newPromiseCapability = require('./_new-promise-capability');
var perform = require('./_perform');

$export($export.S, 'Promise', { 'try': function (callbackfn) {
  var promiseCapability = newPromiseCapability.f(this);
  var result = perform(callbackfn);
  (result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v);
  return promiseCapability.promise;
} });

},{"./_export":44,"./_new-promise-capability":79,"./_perform":98}],307:[function(require,module,exports){
var metadata = require('./_metadata');
var anObject = require('./_an-object');
var toMetaKey = metadata.key;
var ordinaryDefineOwnMetadata = metadata.set;

metadata.exp({ defineMetadata: function defineMetadata(metadataKey, metadataValue, target, targetKey) {
  ordinaryDefineOwnMetadata(metadataKey, metadataValue, anObject(target), toMetaKey(targetKey));
} });

},{"./_an-object":18,"./_metadata":77}],308:[function(require,module,exports){
var metadata = require('./_metadata');
var anObject = require('./_an-object');
var toMetaKey = metadata.key;
var getOrCreateMetadataMap = metadata.map;
var store = metadata.store;

metadata.exp({ deleteMetadata: function deleteMetadata(metadataKey, target /* , targetKey */) {
  var targetKey = arguments.length < 3 ? undefined : toMetaKey(arguments[2]);
  var metadataMap = getOrCreateMetadataMap(anObject(target), targetKey, false);
  if (metadataMap === undefined || !metadataMap['delete'](metadataKey)) return false;
  if (metadataMap.size) return true;
  var targetMetadata = store.get(target);
  targetMetadata['delete'](targetKey);
  return !!targetMetadata.size || store['delete'](target);
} });

},{"./_an-object":18,"./_metadata":77}],309:[function(require,module,exports){
var Set = require('./es6.set');
var from = require('./_array-from-iterable');
var metadata = require('./_metadata');
var anObject = require('./_an-object');
var getPrototypeOf = require('./_object-gpo');
var ordinaryOwnMetadataKeys = metadata.keys;
var toMetaKey = metadata.key;

var ordinaryMetadataKeys = function (O, P) {
  var oKeys = ordinaryOwnMetadataKeys(O, P);
  var parent = getPrototypeOf(O);
  if (parent === null) return oKeys;
  var pKeys = ordinaryMetadataKeys(parent, P);
  return pKeys.length ? oKeys.length ? from(new Set(oKeys.concat(pKeys))) : pKeys : oKeys;
};

metadata.exp({ getMetadataKeys: function getMetadataKeys(target /* , targetKey */) {
  return ordinaryMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));
} });

},{"./_an-object":18,"./_array-from-iterable":21,"./_metadata":77,"./_object-gpo":89,"./es6.set":239}],310:[function(require,module,exports){
var metadata = require('./_metadata');
var anObject = require('./_an-object');
var getPrototypeOf = require('./_object-gpo');
var ordinaryHasOwnMetadata = metadata.has;
var ordinaryGetOwnMetadata = metadata.get;
var toMetaKey = metadata.key;

var ordinaryGetMetadata = function (MetadataKey, O, P) {
  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
  if (hasOwn) return ordinaryGetOwnMetadata(MetadataKey, O, P);
  var parent = getPrototypeOf(O);
  return parent !== null ? ordinaryGetMetadata(MetadataKey, parent, P) : undefined;
};

metadata.exp({ getMetadata: function getMetadata(metadataKey, target /* , targetKey */) {
  return ordinaryGetMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
} });

},{"./_an-object":18,"./_metadata":77,"./_object-gpo":89}],311:[function(require,module,exports){
var metadata = require('./_metadata');
var anObject = require('./_an-object');
var ordinaryOwnMetadataKeys = metadata.keys;
var toMetaKey = metadata.key;

metadata.exp({ getOwnMetadataKeys: function getOwnMetadataKeys(target /* , targetKey */) {
  return ordinaryOwnMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));
} });

},{"./_an-object":18,"./_metadata":77}],312:[function(require,module,exports){
var metadata = require('./_metadata');
var anObject = require('./_an-object');
var ordinaryGetOwnMetadata = metadata.get;
var toMetaKey = metadata.key;

metadata.exp({ getOwnMetadata: function getOwnMetadata(metadataKey, target /* , targetKey */) {
  return ordinaryGetOwnMetadata(metadataKey, anObject(target)
    , arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
} });

},{"./_an-object":18,"./_metadata":77}],313:[function(require,module,exports){
var metadata = require('./_metadata');
var anObject = require('./_an-object');
var getPrototypeOf = require('./_object-gpo');
var ordinaryHasOwnMetadata = metadata.has;
var toMetaKey = metadata.key;

var ordinaryHasMetadata = function (MetadataKey, O, P) {
  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
  if (hasOwn) return true;
  var parent = getPrototypeOf(O);
  return parent !== null ? ordinaryHasMetadata(MetadataKey, parent, P) : false;
};

metadata.exp({ hasMetadata: function hasMetadata(metadataKey, target /* , targetKey */) {
  return ordinaryHasMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
} });

},{"./_an-object":18,"./_metadata":77,"./_object-gpo":89}],314:[function(require,module,exports){
var metadata = require('./_metadata');
var anObject = require('./_an-object');
var ordinaryHasOwnMetadata = metadata.has;
var toMetaKey = metadata.key;

metadata.exp({ hasOwnMetadata: function hasOwnMetadata(metadataKey, target /* , targetKey */) {
  return ordinaryHasOwnMetadata(metadataKey, anObject(target)
    , arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
} });

},{"./_an-object":18,"./_metadata":77}],315:[function(require,module,exports){
var $metadata = require('./_metadata');
var anObject = require('./_an-object');
var aFunction = require('./_a-function');
var toMetaKey = $metadata.key;
var ordinaryDefineOwnMetadata = $metadata.set;

$metadata.exp({ metadata: function metadata(metadataKey, metadataValue) {
  return function decorator(target, targetKey) {
    ordinaryDefineOwnMetadata(
      metadataKey, metadataValue,
      (targetKey !== undefined ? anObject : aFunction)(target),
      toMetaKey(targetKey)
    );
  };
} });

},{"./_a-function":14,"./_an-object":18,"./_metadata":77}],316:[function(require,module,exports){
// https://tc39.github.io/proposal-setmap-offrom/#sec-set.from
require('./_set-collection-from')('Set');

},{"./_set-collection-from":105}],317:[function(require,module,exports){
// https://tc39.github.io/proposal-setmap-offrom/#sec-set.of
require('./_set-collection-of')('Set');

},{"./_set-collection-of":106}],318:[function(require,module,exports){
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export = require('./_export');

$export($export.P + $export.R, 'Set', { toJSON: require('./_collection-to-json')('Set') });

},{"./_collection-to-json":31,"./_export":44}],319:[function(require,module,exports){
'use strict';
// https://github.com/mathiasbynens/String.prototype.at
var $export = require('./_export');
var $at = require('./_string-at')(true);

$export($export.P, 'String', {
  at: function at(pos) {
    return $at(this, pos);
  }
});

},{"./_export":44,"./_string-at":114}],320:[function(require,module,exports){
'use strict';
// https://tc39.github.io/String.prototype.matchAll/
var $export = require('./_export');
var defined = require('./_defined');
var toLength = require('./_to-length');
var isRegExp = require('./_is-regexp');
var getFlags = require('./_flags');
var RegExpProto = RegExp.prototype;

var $RegExpStringIterator = function (regexp, string) {
  this._r = regexp;
  this._s = string;
};

require('./_iter-create')($RegExpStringIterator, 'RegExp String', function next() {
  var match = this._r.exec(this._s);
  return { value: match, done: match === null };
});

$export($export.P, 'String', {
  matchAll: function matchAll(regexp) {
    defined(this);
    if (!isRegExp(regexp)) throw TypeError(regexp + ' is not a regexp!');
    var S = String(this);
    var flags = 'flags' in RegExpProto ? String(regexp.flags) : getFlags.call(regexp);
    var rx = new RegExp(regexp.source, ~flags.indexOf('g') ? flags : 'g' + flags);
    rx.lastIndex = toLength(regexp.lastIndex);
    return new $RegExpStringIterator(rx, S);
  }
});

},{"./_defined":39,"./_export":44,"./_flags":48,"./_is-regexp":63,"./_iter-create":65,"./_to-length":126}],321:[function(require,module,exports){
'use strict';
// https://github.com/tc39/proposal-string-pad-start-end
var $export = require('./_export');
var $pad = require('./_string-pad');

$export($export.P, 'String', {
  padEnd: function padEnd(maxLength /* , fillString = ' ' */) {
    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, false);
  }
});

},{"./_export":44,"./_string-pad":117}],322:[function(require,module,exports){
'use strict';
// https://github.com/tc39/proposal-string-pad-start-end
var $export = require('./_export');
var $pad = require('./_string-pad');

$export($export.P, 'String', {
  padStart: function padStart(maxLength /* , fillString = ' ' */) {
    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, true);
  }
});

},{"./_export":44,"./_string-pad":117}],323:[function(require,module,exports){
'use strict';
// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
require('./_string-trim')('trimLeft', function ($trim) {
  return function trimLeft() {
    return $trim(this, 1);
  };
}, 'trimStart');

},{"./_string-trim":119}],324:[function(require,module,exports){
'use strict';
// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
require('./_string-trim')('trimRight', function ($trim) {
  return function trimRight() {
    return $trim(this, 2);
  };
}, 'trimEnd');

},{"./_string-trim":119}],325:[function(require,module,exports){
require('./_wks-define')('asyncIterator');

},{"./_wks-define":134}],326:[function(require,module,exports){
require('./_wks-define')('observable');

},{"./_wks-define":134}],327:[function(require,module,exports){
// https://github.com/tc39/proposal-global
var $export = require('./_export');

$export($export.S, 'System', { global: require('./_global') });

},{"./_export":44,"./_global":51}],328:[function(require,module,exports){
// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.from
require('./_set-collection-from')('WeakMap');

},{"./_set-collection-from":105}],329:[function(require,module,exports){
// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.of
require('./_set-collection-of')('WeakMap');

},{"./_set-collection-of":106}],330:[function(require,module,exports){
// https://tc39.github.io/proposal-setmap-offrom/#sec-weakset.from
require('./_set-collection-from')('WeakSet');

},{"./_set-collection-from":105}],331:[function(require,module,exports){
// https://tc39.github.io/proposal-setmap-offrom/#sec-weakset.of
require('./_set-collection-of')('WeakSet');

},{"./_set-collection-of":106}],332:[function(require,module,exports){
var $iterators = require('./es6.array.iterator');
var getKeys = require('./_object-keys');
var redefine = require('./_redefine');
var global = require('./_global');
var hide = require('./_hide');
var Iterators = require('./_iterators');
var wks = require('./_wks');
var ITERATOR = wks('iterator');
var TO_STRING_TAG = wks('toStringTag');
var ArrayValues = Iterators.Array;

var DOMIterables = {
  CSSRuleList: true, // TODO: Not spec compliant, should be false.
  CSSStyleDeclaration: false,
  CSSValueList: false,
  ClientRectList: false,
  DOMRectList: false,
  DOMStringList: false,
  DOMTokenList: true,
  DataTransferItemList: false,
  FileList: false,
  HTMLAllCollection: false,
  HTMLCollection: false,
  HTMLFormElement: false,
  HTMLSelectElement: false,
  MediaList: true, // TODO: Not spec compliant, should be false.
  MimeTypeArray: false,
  NamedNodeMap: false,
  NodeList: true,
  PaintRequestList: false,
  Plugin: false,
  PluginArray: false,
  SVGLengthList: false,
  SVGNumberList: false,
  SVGPathSegList: false,
  SVGPointList: false,
  SVGStringList: false,
  SVGTransformList: false,
  SourceBufferList: false,
  StyleSheetList: true, // TODO: Not spec compliant, should be false.
  TextTrackCueList: false,
  TextTrackList: false,
  TouchList: false
};

for (var collections = getKeys(DOMIterables), i = 0; i < collections.length; i++) {
  var NAME = collections[i];
  var explicit = DOMIterables[NAME];
  var Collection = global[NAME];
  var proto = Collection && Collection.prototype;
  var key;
  if (proto) {
    if (!proto[ITERATOR]) hide(proto, ITERATOR, ArrayValues);
    if (!proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
    Iterators[NAME] = ArrayValues;
    if (explicit) for (key in $iterators) if (!proto[key]) redefine(proto, key, $iterators[key], true);
  }
}

},{"./_global":51,"./_hide":53,"./_iterators":69,"./_object-keys":91,"./_redefine":102,"./_wks":136,"./es6.array.iterator":149}],333:[function(require,module,exports){
var $export = require('./_export');
var $task = require('./_task');
$export($export.G + $export.B, {
  setImmediate: $task.set,
  clearImmediate: $task.clear
});

},{"./_export":44,"./_task":121}],334:[function(require,module,exports){
// ie9- setTimeout & setInterval additional parameters fix
var global = require('./_global');
var $export = require('./_export');
var navigator = global.navigator;
var slice = [].slice;
var MSIE = !!navigator && /MSIE .\./.test(navigator.userAgent); // <- dirty ie9- check
var wrap = function (set) {
  return function (fn, time /* , ...args */) {
    var boundArgs = arguments.length > 2;
    var args = boundArgs ? slice.call(arguments, 2) : false;
    return set(boundArgs ? function () {
      // eslint-disable-next-line no-new-func
      (typeof fn == 'function' ? fn : Function(fn)).apply(this, args);
    } : fn, time);
  };
};
$export($export.G + $export.B + $export.F * MSIE, {
  setTimeout: wrap(global.setTimeout),
  setInterval: wrap(global.setInterval)
});

},{"./_export":44,"./_global":51}],335:[function(require,module,exports){
require('./modules/es6.symbol');
require('./modules/es6.object.create');
require('./modules/es6.object.define-property');
require('./modules/es6.object.define-properties');
require('./modules/es6.object.get-own-property-descriptor');
require('./modules/es6.object.get-prototype-of');
require('./modules/es6.object.keys');
require('./modules/es6.object.get-own-property-names');
require('./modules/es6.object.freeze');
require('./modules/es6.object.seal');
require('./modules/es6.object.prevent-extensions');
require('./modules/es6.object.is-frozen');
require('./modules/es6.object.is-sealed');
require('./modules/es6.object.is-extensible');
require('./modules/es6.object.assign');
require('./modules/es6.object.is');
require('./modules/es6.object.set-prototype-of');
require('./modules/es6.object.to-string');
require('./modules/es6.function.bind');
require('./modules/es6.function.name');
require('./modules/es6.function.has-instance');
require('./modules/es6.parse-int');
require('./modules/es6.parse-float');
require('./modules/es6.number.constructor');
require('./modules/es6.number.to-fixed');
require('./modules/es6.number.to-precision');
require('./modules/es6.number.epsilon');
require('./modules/es6.number.is-finite');
require('./modules/es6.number.is-integer');
require('./modules/es6.number.is-nan');
require('./modules/es6.number.is-safe-integer');
require('./modules/es6.number.max-safe-integer');
require('./modules/es6.number.min-safe-integer');
require('./modules/es6.number.parse-float');
require('./modules/es6.number.parse-int');
require('./modules/es6.math.acosh');
require('./modules/es6.math.asinh');
require('./modules/es6.math.atanh');
require('./modules/es6.math.cbrt');
require('./modules/es6.math.clz32');
require('./modules/es6.math.cosh');
require('./modules/es6.math.expm1');
require('./modules/es6.math.fround');
require('./modules/es6.math.hypot');
require('./modules/es6.math.imul');
require('./modules/es6.math.log10');
require('./modules/es6.math.log1p');
require('./modules/es6.math.log2');
require('./modules/es6.math.sign');
require('./modules/es6.math.sinh');
require('./modules/es6.math.tanh');
require('./modules/es6.math.trunc');
require('./modules/es6.string.from-code-point');
require('./modules/es6.string.raw');
require('./modules/es6.string.trim');
require('./modules/es6.string.iterator');
require('./modules/es6.string.code-point-at');
require('./modules/es6.string.ends-with');
require('./modules/es6.string.includes');
require('./modules/es6.string.repeat');
require('./modules/es6.string.starts-with');
require('./modules/es6.string.anchor');
require('./modules/es6.string.big');
require('./modules/es6.string.blink');
require('./modules/es6.string.bold');
require('./modules/es6.string.fixed');
require('./modules/es6.string.fontcolor');
require('./modules/es6.string.fontsize');
require('./modules/es6.string.italics');
require('./modules/es6.string.link');
require('./modules/es6.string.small');
require('./modules/es6.string.strike');
require('./modules/es6.string.sub');
require('./modules/es6.string.sup');
require('./modules/es6.date.now');
require('./modules/es6.date.to-json');
require('./modules/es6.date.to-iso-string');
require('./modules/es6.date.to-string');
require('./modules/es6.date.to-primitive');
require('./modules/es6.array.is-array');
require('./modules/es6.array.from');
require('./modules/es6.array.of');
require('./modules/es6.array.join');
require('./modules/es6.array.slice');
require('./modules/es6.array.sort');
require('./modules/es6.array.for-each');
require('./modules/es6.array.map');
require('./modules/es6.array.filter');
require('./modules/es6.array.some');
require('./modules/es6.array.every');
require('./modules/es6.array.reduce');
require('./modules/es6.array.reduce-right');
require('./modules/es6.array.index-of');
require('./modules/es6.array.last-index-of');
require('./modules/es6.array.copy-within');
require('./modules/es6.array.fill');
require('./modules/es6.array.find');
require('./modules/es6.array.find-index');
require('./modules/es6.array.species');
require('./modules/es6.array.iterator');
require('./modules/es6.regexp.constructor');
require('./modules/es6.regexp.to-string');
require('./modules/es6.regexp.flags');
require('./modules/es6.regexp.match');
require('./modules/es6.regexp.replace');
require('./modules/es6.regexp.search');
require('./modules/es6.regexp.split');
require('./modules/es6.promise');
require('./modules/es6.map');
require('./modules/es6.set');
require('./modules/es6.weak-map');
require('./modules/es6.weak-set');
require('./modules/es6.typed.array-buffer');
require('./modules/es6.typed.data-view');
require('./modules/es6.typed.int8-array');
require('./modules/es6.typed.uint8-array');
require('./modules/es6.typed.uint8-clamped-array');
require('./modules/es6.typed.int16-array');
require('./modules/es6.typed.uint16-array');
require('./modules/es6.typed.int32-array');
require('./modules/es6.typed.uint32-array');
require('./modules/es6.typed.float32-array');
require('./modules/es6.typed.float64-array');
require('./modules/es6.reflect.apply');
require('./modules/es6.reflect.construct');
require('./modules/es6.reflect.define-property');
require('./modules/es6.reflect.delete-property');
require('./modules/es6.reflect.enumerate');
require('./modules/es6.reflect.get');
require('./modules/es6.reflect.get-own-property-descriptor');
require('./modules/es6.reflect.get-prototype-of');
require('./modules/es6.reflect.has');
require('./modules/es6.reflect.is-extensible');
require('./modules/es6.reflect.own-keys');
require('./modules/es6.reflect.prevent-extensions');
require('./modules/es6.reflect.set');
require('./modules/es6.reflect.set-prototype-of');
require('./modules/es7.array.includes');
require('./modules/es7.array.flat-map');
require('./modules/es7.array.flatten');
require('./modules/es7.string.at');
require('./modules/es7.string.pad-start');
require('./modules/es7.string.pad-end');
require('./modules/es7.string.trim-left');
require('./modules/es7.string.trim-right');
require('./modules/es7.string.match-all');
require('./modules/es7.symbol.async-iterator');
require('./modules/es7.symbol.observable');
require('./modules/es7.object.get-own-property-descriptors');
require('./modules/es7.object.values');
require('./modules/es7.object.entries');
require('./modules/es7.object.define-getter');
require('./modules/es7.object.define-setter');
require('./modules/es7.object.lookup-getter');
require('./modules/es7.object.lookup-setter');
require('./modules/es7.map.to-json');
require('./modules/es7.set.to-json');
require('./modules/es7.map.of');
require('./modules/es7.set.of');
require('./modules/es7.weak-map.of');
require('./modules/es7.weak-set.of');
require('./modules/es7.map.from');
require('./modules/es7.set.from');
require('./modules/es7.weak-map.from');
require('./modules/es7.weak-set.from');
require('./modules/es7.global');
require('./modules/es7.system.global');
require('./modules/es7.error.is-error');
require('./modules/es7.math.clamp');
require('./modules/es7.math.deg-per-rad');
require('./modules/es7.math.degrees');
require('./modules/es7.math.fscale');
require('./modules/es7.math.iaddh');
require('./modules/es7.math.isubh');
require('./modules/es7.math.imulh');
require('./modules/es7.math.rad-per-deg');
require('./modules/es7.math.radians');
require('./modules/es7.math.scale');
require('./modules/es7.math.umulh');
require('./modules/es7.math.signbit');
require('./modules/es7.promise.finally');
require('./modules/es7.promise.try');
require('./modules/es7.reflect.define-metadata');
require('./modules/es7.reflect.delete-metadata');
require('./modules/es7.reflect.get-metadata');
require('./modules/es7.reflect.get-metadata-keys');
require('./modules/es7.reflect.get-own-metadata');
require('./modules/es7.reflect.get-own-metadata-keys');
require('./modules/es7.reflect.has-metadata');
require('./modules/es7.reflect.has-own-metadata');
require('./modules/es7.reflect.metadata');
require('./modules/es7.asap');
require('./modules/es7.observable');
require('./modules/web.timers');
require('./modules/web.immediate');
require('./modules/web.dom.iterable');
module.exports = require('./modules/_core');

},{"./modules/_core":34,"./modules/es6.array.copy-within":139,"./modules/es6.array.every":140,"./modules/es6.array.fill":141,"./modules/es6.array.filter":142,"./modules/es6.array.find":144,"./modules/es6.array.find-index":143,"./modules/es6.array.for-each":145,"./modules/es6.array.from":146,"./modules/es6.array.index-of":147,"./modules/es6.array.is-array":148,"./modules/es6.array.iterator":149,"./modules/es6.array.join":150,"./modules/es6.array.last-index-of":151,"./modules/es6.array.map":152,"./modules/es6.array.of":153,"./modules/es6.array.reduce":155,"./modules/es6.array.reduce-right":154,"./modules/es6.array.slice":156,"./modules/es6.array.some":157,"./modules/es6.array.sort":158,"./modules/es6.array.species":159,"./modules/es6.date.now":160,"./modules/es6.date.to-iso-string":161,"./modules/es6.date.to-json":162,"./modules/es6.date.to-primitive":163,"./modules/es6.date.to-string":164,"./modules/es6.function.bind":165,"./modules/es6.function.has-instance":166,"./modules/es6.function.name":167,"./modules/es6.map":168,"./modules/es6.math.acosh":169,"./modules/es6.math.asinh":170,"./modules/es6.math.atanh":171,"./modules/es6.math.cbrt":172,"./modules/es6.math.clz32":173,"./modules/es6.math.cosh":174,"./modules/es6.math.expm1":175,"./modules/es6.math.fround":176,"./modules/es6.math.hypot":177,"./modules/es6.math.imul":178,"./modules/es6.math.log10":179,"./modules/es6.math.log1p":180,"./modules/es6.math.log2":181,"./modules/es6.math.sign":182,"./modules/es6.math.sinh":183,"./modules/es6.math.tanh":184,"./modules/es6.math.trunc":185,"./modules/es6.number.constructor":186,"./modules/es6.number.epsilon":187,"./modules/es6.number.is-finite":188,"./modules/es6.number.is-integer":189,"./modules/es6.number.is-nan":190,"./modules/es6.number.is-safe-integer":191,"./modules/es6.number.max-safe-integer":192,"./modules/es6.number.min-safe-integer":193,"./modules/es6.number.parse-float":194,"./modules/es6.number.parse-int":195,"./modules/es6.number.to-fixed":196,"./modules/es6.number.to-precision":197,"./modules/es6.object.assign":198,"./modules/es6.object.create":199,"./modules/es6.object.define-properties":200,"./modules/es6.object.define-property":201,"./modules/es6.object.freeze":202,"./modules/es6.object.get-own-property-descriptor":203,"./modules/es6.object.get-own-property-names":204,"./modules/es6.object.get-prototype-of":205,"./modules/es6.object.is":209,"./modules/es6.object.is-extensible":206,"./modules/es6.object.is-frozen":207,"./modules/es6.object.is-sealed":208,"./modules/es6.object.keys":210,"./modules/es6.object.prevent-extensions":211,"./modules/es6.object.seal":212,"./modules/es6.object.set-prototype-of":213,"./modules/es6.object.to-string":214,"./modules/es6.parse-float":215,"./modules/es6.parse-int":216,"./modules/es6.promise":217,"./modules/es6.reflect.apply":218,"./modules/es6.reflect.construct":219,"./modules/es6.reflect.define-property":220,"./modules/es6.reflect.delete-property":221,"./modules/es6.reflect.enumerate":222,"./modules/es6.reflect.get":225,"./modules/es6.reflect.get-own-property-descriptor":223,"./modules/es6.reflect.get-prototype-of":224,"./modules/es6.reflect.has":226,"./modules/es6.reflect.is-extensible":227,"./modules/es6.reflect.own-keys":228,"./modules/es6.reflect.prevent-extensions":229,"./modules/es6.reflect.set":231,"./modules/es6.reflect.set-prototype-of":230,"./modules/es6.regexp.constructor":232,"./modules/es6.regexp.flags":233,"./modules/es6.regexp.match":234,"./modules/es6.regexp.replace":235,"./modules/es6.regexp.search":236,"./modules/es6.regexp.split":237,"./modules/es6.regexp.to-string":238,"./modules/es6.set":239,"./modules/es6.string.anchor":240,"./modules/es6.string.big":241,"./modules/es6.string.blink":242,"./modules/es6.string.bold":243,"./modules/es6.string.code-point-at":244,"./modules/es6.string.ends-with":245,"./modules/es6.string.fixed":246,"./modules/es6.string.fontcolor":247,"./modules/es6.string.fontsize":248,"./modules/es6.string.from-code-point":249,"./modules/es6.string.includes":250,"./modules/es6.string.italics":251,"./modules/es6.string.iterator":252,"./modules/es6.string.link":253,"./modules/es6.string.raw":254,"./modules/es6.string.repeat":255,"./modules/es6.string.small":256,"./modules/es6.string.starts-with":257,"./modules/es6.string.strike":258,"./modules/es6.string.sub":259,"./modules/es6.string.sup":260,"./modules/es6.string.trim":261,"./modules/es6.symbol":262,"./modules/es6.typed.array-buffer":263,"./modules/es6.typed.data-view":264,"./modules/es6.typed.float32-array":265,"./modules/es6.typed.float64-array":266,"./modules/es6.typed.int16-array":267,"./modules/es6.typed.int32-array":268,"./modules/es6.typed.int8-array":269,"./modules/es6.typed.uint16-array":270,"./modules/es6.typed.uint32-array":271,"./modules/es6.typed.uint8-array":272,"./modules/es6.typed.uint8-clamped-array":273,"./modules/es6.weak-map":274,"./modules/es6.weak-set":275,"./modules/es7.array.flat-map":276,"./modules/es7.array.flatten":277,"./modules/es7.array.includes":278,"./modules/es7.asap":279,"./modules/es7.error.is-error":280,"./modules/es7.global":281,"./modules/es7.map.from":282,"./modules/es7.map.of":283,"./modules/es7.map.to-json":284,"./modules/es7.math.clamp":285,"./modules/es7.math.deg-per-rad":286,"./modules/es7.math.degrees":287,"./modules/es7.math.fscale":288,"./modules/es7.math.iaddh":289,"./modules/es7.math.imulh":290,"./modules/es7.math.isubh":291,"./modules/es7.math.rad-per-deg":292,"./modules/es7.math.radians":293,"./modules/es7.math.scale":294,"./modules/es7.math.signbit":295,"./modules/es7.math.umulh":296,"./modules/es7.object.define-getter":297,"./modules/es7.object.define-setter":298,"./modules/es7.object.entries":299,"./modules/es7.object.get-own-property-descriptors":300,"./modules/es7.object.lookup-getter":301,"./modules/es7.object.lookup-setter":302,"./modules/es7.object.values":303,"./modules/es7.observable":304,"./modules/es7.promise.finally":305,"./modules/es7.promise.try":306,"./modules/es7.reflect.define-metadata":307,"./modules/es7.reflect.delete-metadata":308,"./modules/es7.reflect.get-metadata":310,"./modules/es7.reflect.get-metadata-keys":309,"./modules/es7.reflect.get-own-metadata":312,"./modules/es7.reflect.get-own-metadata-keys":311,"./modules/es7.reflect.has-metadata":313,"./modules/es7.reflect.has-own-metadata":314,"./modules/es7.reflect.metadata":315,"./modules/es7.set.from":316,"./modules/es7.set.of":317,"./modules/es7.set.to-json":318,"./modules/es7.string.at":319,"./modules/es7.string.match-all":320,"./modules/es7.string.pad-end":321,"./modules/es7.string.pad-start":322,"./modules/es7.string.trim-left":323,"./modules/es7.string.trim-right":324,"./modules/es7.symbol.async-iterator":325,"./modules/es7.symbol.observable":326,"./modules/es7.system.global":327,"./modules/es7.weak-map.from":328,"./modules/es7.weak-map.of":329,"./modules/es7.weak-set.from":330,"./modules/es7.weak-set.of":331,"./modules/web.dom.iterable":332,"./modules/web.immediate":333,"./modules/web.timers":334}],336:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports['default'] = camelize;
var regExp = /[-\s]+(.)?/g;

/**
 * Convert dash separated strings to camel cased.
 *
 * @param {String} str
 * @return {String}
 */
function camelize(str) {
  return str.replace(regExp, toUpper);
}

function toUpper(match, c) {
  return c ? c.toUpperCase() : '';
}
},{}],337:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.supportedValue = exports.supportedProperty = exports.prefix = undefined;

var _prefix = require('./prefix');

var _prefix2 = _interopRequireDefault(_prefix);

var _supportedProperty = require('./supported-property');

var _supportedProperty2 = _interopRequireDefault(_supportedProperty);

var _supportedValue = require('./supported-value');

var _supportedValue2 = _interopRequireDefault(_supportedValue);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

exports['default'] = {
  prefix: _prefix2['default'],
  supportedProperty: _supportedProperty2['default'],
  supportedValue: _supportedValue2['default']
}; /**
    * CSS Vendor prefix detection and property feature testing.
    *
    * @copyright Oleg Slobodskoi 2015
    * @website https://github.com/jsstyles/css-vendor
    * @license MIT
    */

exports.prefix = _prefix2['default'];
exports.supportedProperty = _supportedProperty2['default'];
exports.supportedValue = _supportedValue2['default'];
},{"./prefix":338,"./supported-property":339,"./supported-value":340}],338:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _isInBrowser = require('is-in-browser');

var _isInBrowser2 = _interopRequireDefault(_isInBrowser);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var js = ''; /**
              * Export javascript style and css style vendor prefixes.
              * Based on "transform" support test.
              */

var css = '';

// We should not do anything if required serverside.
if (_isInBrowser2['default']) {
  // Order matters. We need to check Webkit the last one because
  // other vendors use to add Webkit prefixes to some properties
  var jsCssMap = {
    Moz: '-moz-',
    // IE did it wrong again ...
    ms: '-ms-',
    O: '-o-',
    Webkit: '-webkit-'
  };
  var style = document.createElement('p').style;
  var testProp = 'Transform';

  for (var key in jsCssMap) {
    if (key + testProp in style) {
      js = key;
      css = jsCssMap[key];
      break;
    }
  }
}

/**
 * Vendor prefix string for the current browser.
 *
 * @type {{js: String, css: String}}
 * @api public
 */
exports['default'] = { js: js, css: css };
},{"is-in-browser":344}],339:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports['default'] = supportedProperty;

var _isInBrowser = require('is-in-browser');

var _isInBrowser2 = _interopRequireDefault(_isInBrowser);

var _prefix = require('./prefix');

var _prefix2 = _interopRequireDefault(_prefix);

var _camelize = require('./camelize');

var _camelize2 = _interopRequireDefault(_camelize);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var el = void 0;
var cache = {};

if (_isInBrowser2['default']) {
  el = document.createElement('p');

  /**
   * We test every property on vendor prefix requirement.
   * Once tested, result is cached. It gives us up to 70% perf boost.
   * http://jsperf.com/element-style-object-access-vs-plain-object
   *
   * Prefill cache with known css properties to reduce amount of
   * properties we need to feature test at runtime.
   * http://davidwalsh.name/vendor-prefix
   */
  var computed = window.getComputedStyle(document.documentElement, '');
  for (var key in computed) {
    if (!isNaN(key)) cache[computed[key]] = computed[key];
  }
}

/**
 * Test if a property is supported, returns supported property with vendor
 * prefix if required. Returns `false` if not supported.
 *
 * @param {String} prop dash separated
 * @return {String|Boolean}
 * @api public
 */
function supportedProperty(prop) {
  // For server-side rendering.
  if (!el) return prop;

  // We have not tested this prop yet, lets do the test.
  if (cache[prop] != null) return cache[prop];

  // Camelization is required because we can't test using
  // css syntax for e.g. in FF.
  // Test if property is supported as it is.
  if ((0, _camelize2['default'])(prop) in el.style) {
    cache[prop] = prop;
  }
  // Test if property is supported with vendor prefix.
  else if (_prefix2['default'].js + (0, _camelize2['default'])('-' + prop) in el.style) {
      cache[prop] = _prefix2['default'].css + prop;
    } else {
      cache[prop] = false;
    }

  return cache[prop];
}
},{"./camelize":336,"./prefix":338,"is-in-browser":344}],340:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports['default'] = supportedValue;

var _isInBrowser = require('is-in-browser');

var _isInBrowser2 = _interopRequireDefault(_isInBrowser);

var _prefix = require('./prefix');

var _prefix2 = _interopRequireDefault(_prefix);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var cache = {};
var el = void 0;

if (_isInBrowser2['default']) el = document.createElement('p');

/**
 * Returns prefixed value if needed. Returns `false` if value is not supported.
 *
 * @param {String} property
 * @param {String} value
 * @return {String|Boolean}
 * @api public
 */
function supportedValue(property, value) {
  // For server-side rendering.
  if (!el) return value;

  // It is a string or a number as a string like '1'.
  // We want only prefixable values here.
  if (typeof value !== 'string' || !isNaN(parseInt(value, 10))) return value;

  var cacheKey = property + value;

  if (cache[cacheKey] != null) return cache[cacheKey];

  // IE can even throw an error in some cases, for e.g. style.content = 'bar'
  try {
    // Test value as it is.
    el.style[property] = value;
  } catch (err) {
    cache[cacheKey] = false;
    return false;
  }

  // Value is supported as it is.
  if (el.style[property] !== '') {
    cache[cacheKey] = value;
  } else {
    // Test value with vendor prefix.
    value = _prefix2['default'].css + value;

    // Hardcode test to convert "flex" to "-ms-flexbox" for IE10.
    if (value === '-ms-flex') value = '-ms-flexbox';

    el.style[property] = value;

    // Value is supported with vendor prefix.
    if (el.style[property] !== '') cache[cacheKey] = value;
  }

  if (!cache[cacheKey]) cache[cacheKey] = false;

  // Reset style value.
  el.style[property] = '';

  return cache[cacheKey];
}
},{"./prefix":338,"is-in-browser":344}],341:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
var isValidString = function isValidString(param) {
  return typeof param === 'string' && param.length > 0;
};

var startsWith = function startsWith(string, start) {
  return string[0] === start;
};

var isSelector = function isSelector(param) {
  return isValidString(param) && (startsWith(param, '.') || startsWith(param, '#'));
};

var node = function node(h) {
  return function (tagName) {
    return function (first) {
      for (var _len = arguments.length, rest = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        rest[_key - 1] = arguments[_key];
      }

      if (isSelector(first)) {
        return h.apply(undefined, [tagName + first].concat(rest));
      } else if (typeof first === 'undefined') {
        return h(tagName);
      } else {
        return h.apply(undefined, [tagName, first].concat(rest));
      }
    };
  };
};

var TAG_NAMES = ['a', 'abbr', 'acronym', 'address', 'applet', 'area', 'article', 'aside', 'audio', 'b', 'base', 'basefont', 'bdi', 'bdo', 'bgsound', 'big', 'blink', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'center', 'cite', 'code', 'col', 'colgroup', 'command', 'content', 'data', 'datalist', 'dd', 'del', 'details', 'dfn', 'dialog', 'dir', 'div', 'dl', 'dt', 'element', 'em', 'embed', 'fieldset', 'figcaption', 'figure', 'font', 'footer', 'form', 'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'iframe', 'image', 'img', 'input', 'ins', 'isindex', 'kbd', 'keygen', 'label', 'legend', 'li', 'link', 'listing', 'main', 'map', 'mark', 'marquee', 'math', 'menu', 'menuitem', 'meta', 'meter', 'multicol', 'nav', 'nextid', 'nobr', 'noembed', 'noframes', 'noscript', 'object', 'ol', 'optgroup', 'option', 'output', 'p', 'param', 'picture', 'plaintext', 'pre', 'progress', 'q', 'rb', 'rbc', 'rp', 'rt', 'rtc', 'ruby', 's', 'samp', 'script', 'section', 'select', 'shadow', 'slot', 'small', 'source', 'spacer', 'span', 'strike', 'strong', 'style', 'sub', 'summary', 'sup', 'svg', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'time', 'title', 'tr', 'track', 'tt', 'u', 'ul', 'var', 'video', 'wbr', 'xmp'];

exports['default'] = function (h) {
  var createTag = node(h);
  var exported = { TAG_NAMES: TAG_NAMES, isSelector: isSelector, createTag: createTag };
  TAG_NAMES.forEach(function (n) {
    exported[n] = createTag(n);
  });
  return exported;
};

module.exports = exports['default'];
},{}],342:[function(require,module,exports){
var split = require('browser-split')
var ClassList = require('class-list')

var w = typeof window === 'undefined' ? require('html-element') : window
var document = w.document
var Text = w.Text

function context () {

  var cleanupFuncs = []

  function h() {
    var args = [].slice.call(arguments), e = null
    function item (l) {
      var r
      function parseClass (string) {
        // Our minimal parser doesn’t understand escaping CSS special
        // characters like `#`. Don’t use them. More reading:
        // https://mathiasbynens.be/notes/css-escapes .

        var m = split(string, /([\.#]?[^\s#.]+)/)
        if(/^\.|#/.test(m[1]))
          e = document.createElement('div')
        forEach(m, function (v) {
          var s = v.substring(1,v.length)
          if(!v) return
          if(!e)
            e = document.createElement(v)
          else if (v[0] === '.')
            ClassList(e).add(s)
          else if (v[0] === '#')
            e.setAttribute('id', s)
        })
      }

      if(l == null)
        ;
      else if('string' === typeof l) {
        if(!e)
          parseClass(l)
        else
          e.appendChild(r = document.createTextNode(l))
      }
      else if('number' === typeof l
        || 'boolean' === typeof l
        || l instanceof Date
        || l instanceof RegExp ) {
          e.appendChild(r = document.createTextNode(l.toString()))
      }
      //there might be a better way to handle this...
      else if (isArray(l))
        forEach(l, item)
      else if(isNode(l))
        e.appendChild(r = l)
      else if(l instanceof Text)
        e.appendChild(r = l)
      else if ('object' === typeof l) {
        for (var k in l) {
          if('function' === typeof l[k]) {
            if(/^on\w+/.test(k)) {
              (function (k, l) { // capture k, l in the closure
                if (e.addEventListener){
                  e.addEventListener(k.substring(2), l[k], false)
                  cleanupFuncs.push(function(){
                    e.removeEventListener(k.substring(2), l[k], false)
                  })
                }else{
                  e.attachEvent(k, l[k])
                  cleanupFuncs.push(function(){
                    e.detachEvent(k, l[k])
                  })
                }
              })(k, l)
            } else {
              // observable
              e[k] = l[k]()
              cleanupFuncs.push(l[k](function (v) {
                e[k] = v
              }))
            }
          }
          else if(k === 'style') {
            if('string' === typeof l[k]) {
              e.style.cssText = l[k]
            }else{
              for (var s in l[k]) (function(s, v) {
                if('function' === typeof v) {
                  // observable
                  e.style.setProperty(s, v())
                  cleanupFuncs.push(v(function (val) {
                    e.style.setProperty(s, val)
                  }))
                } else
                  var match = l[k][s].match(/(.*)\W+!important\W*$/);
                  if (match) {
                    e.style.setProperty(s, match[1], 'important')
                  } else {
                    e.style.setProperty(s, l[k][s])
                  }
              })(s, l[k][s])
            }
          } else if(k === 'attrs') {
            for (var v in l[k]) {
              e.setAttribute(v, l[k][v])
            }
          }
          else if (k.substr(0, 5) === "data-") {
            e.setAttribute(k, l[k])
          } else {
            e[k] = l[k]
          }
        }
      } else if ('function' === typeof l) {
        //assume it's an observable!
        var v = l()
        e.appendChild(r = isNode(v) ? v : document.createTextNode(v))

        cleanupFuncs.push(l(function (v) {
          if(isNode(v) && r.parentElement)
            r.parentElement.replaceChild(v, r), r = v
          else
            r.textContent = v
        }))
      }

      return r
    }
    while(args.length)
      item(args.shift())

    return e
  }

  h.cleanup = function () {
    for (var i = 0; i < cleanupFuncs.length; i++){
      cleanupFuncs[i]()
    }
    cleanupFuncs.length = 0
  }

  return h
}

var h = module.exports = context()
h.context = context

function isNode (el) {
  return el && el.nodeName && el.nodeType
}

function forEach (arr, fn) {
  if (arr.forEach) return arr.forEach(fn)
  for (var i = 0; i < arr.length; i++) fn(arr[i], i)
}

function isArray (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]'
}



},{"browser-split":11,"class-list":12,"html-element":10}],343:[function(require,module,exports){

var indexOf = [].indexOf;

module.exports = function(arr, obj){
  if (indexOf) return arr.indexOf(obj);
  for (var i = 0; i < arr.length; ++i) {
    if (arr[i] === obj) return i;
  }
  return -1;
};
},{}],344:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var isBrowser = exports.isBrowser = (typeof window === "undefined" ? "undefined" : _typeof(window)) === "object" && (typeof document === "undefined" ? "undefined" : _typeof(document)) === 'object' && document.nodeType === 9;

exports.default = isBrowser;
},{}],345:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = camelCase;
var regExp = /([A-Z])/g;

/**
 * Replace a string passed from String#replace.
 * @param {String} str
 * @return {String}
 */
function replace(str) {
  return "-" + str.toLowerCase();
}

/**
 * Convert camel cased property names to dash separated.
 *
 * @param {Object} style
 * @return {Object}
 */
function convertCase(style) {
  var converted = {};

  for (var prop in style) {
    converted[prop.replace(regExp, replace)] = style[prop];
  }

  if (style.fallbacks) {
    if (Array.isArray(style.fallbacks)) converted.fallbacks = style.fallbacks.map(convertCase);else converted.fallbacks = convertCase(style.fallbacks);
  }

  return converted;
}

/**
 * Allow camel cased property names by converting them back to dasherized.
 *
 * @param {Rule} rule
 */
function camelCase() {
  function onProcessStyle(style) {
    if (Array.isArray(style)) {
      // Handle rules like @font-face, which can have multiple styles in an array
      for (var index = 0; index < style.length; index++) {
        style[index] = convertCase(style[index]);
      }
      return style;
    }

    return convertCase(style);
  }

  return { onProcessStyle: onProcessStyle };
}
},{}],346:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = jssCompose;

var _warning = require('warning');

var _warning2 = _interopRequireDefault(_warning);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Set selector.
 *
 * @param {Object} original rule
 * @param {String} className class string
 * @return {Boolean} flag, indicating function was successfull or not
 */
function registerClass(rule, className) {
  // Skip falsy values
  if (!className) return true;

  // Support array of class names `{composes: ['foo', 'bar']}`
  if (Array.isArray(className)) {
    for (var index = 0; index < className.length; index++) {
      var isSetted = registerClass(rule, className[index]);
      if (!isSetted) return false;
    }

    return true;
  }

  // Support space separated class names `{composes: 'foo bar'}`
  if (className.indexOf(' ') > -1) {
    return registerClass(rule, className.split(' '));
  }

  var parent = rule.options.parent;

  // It is a ref to a local rule.

  if (className[0] === '$') {
    var refRule = parent.getRule(className.substr(1));

    if (!refRule) {
      (0, _warning2.default)(false, '[JSS] Referenced rule is not defined. \r\n%s', rule);
      return false;
    }

    if (refRule === rule) {
      (0, _warning2.default)(false, '[JSS] Cyclic composition detected. \r\n%s', rule);
      return false;
    }

    parent.classes[rule.key] += ' ' + parent.classes[refRule.key];

    return true;
  }

  rule.options.parent.classes[rule.key] += ' ' + className;

  return true;
}

/**
 * Convert compose property to additional class, remove property from original styles.
 *
 * @param {Rule} rule
 * @api public
 */
function jssCompose() {
  function onProcessStyle(style, rule) {
    if (!style.composes) return style;
    registerClass(rule, style.composes);
    // Remove composes property to prevent infinite loop.
    delete style.composes;
    return style;
  }
  return { onProcessStyle: onProcessStyle };
}
},{"warning":394}],347:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Generated jss-default-unit CSS property units
 *
 * @type object
 */
exports['default'] = {
  'animation-delay': 'ms',
  'animation-duration': 'ms',
  'background-position': 'px',
  'background-position-x': 'px',
  'background-position-y': 'px',
  'background-size': 'px',
  border: 'px',
  'border-bottom': 'px',
  'border-bottom-left-radius': 'px',
  'border-bottom-right-radius': 'px',
  'border-bottom-width': 'px',
  'border-left': 'px',
  'border-left-width': 'px',
  'border-radius': 'px',
  'border-right': 'px',
  'border-right-width': 'px',
  'border-spacing': 'px',
  'border-top': 'px',
  'border-top-left-radius': 'px',
  'border-top-right-radius': 'px',
  'border-top-width': 'px',
  'border-width': 'px',
  'border-after-width': 'px',
  'border-before-width': 'px',
  'border-end-width': 'px',
  'border-horizontal-spacing': 'px',
  'border-start-width': 'px',
  'border-vertical-spacing': 'px',
  bottom: 'px',
  'box-shadow': 'px',
  'column-gap': 'px',
  'column-rule': 'px',
  'column-rule-width': 'px',
  'column-width': 'px',
  'flex-basis': 'px',
  'font-size': 'px',
  'font-size-delta': 'px',
  height: 'px',
  left: 'px',
  'letter-spacing': 'px',
  'logical-height': 'px',
  'logical-width': 'px',
  margin: 'px',
  'margin-after': 'px',
  'margin-before': 'px',
  'margin-bottom': 'px',
  'margin-left': 'px',
  'margin-right': 'px',
  'margin-top': 'px',
  'max-height': 'px',
  'max-width': 'px',
  'margin-end': 'px',
  'margin-start': 'px',
  'mask-position-x': 'px',
  'mask-position-y': 'px',
  'mask-size': 'px',
  'max-logical-height': 'px',
  'max-logical-width': 'px',
  'min-height': 'px',
  'min-width': 'px',
  'min-logical-height': 'px',
  'min-logical-width': 'px',
  motion: 'px',
  'motion-offset': 'px',
  outline: 'px',
  'outline-offset': 'px',
  'outline-width': 'px',
  padding: 'px',
  'padding-bottom': 'px',
  'padding-left': 'px',
  'padding-right': 'px',
  'padding-top': 'px',
  'padding-after': 'px',
  'padding-before': 'px',
  'padding-end': 'px',
  'padding-start': 'px',
  'perspective-origin-x': '%',
  'perspective-origin-y': '%',
  perspective: 'px',
  right: 'px',
  'shape-margin': 'px',
  size: 'px',
  'text-indent': 'px',
  'text-stroke': 'px',
  'text-stroke-width': 'px',
  top: 'px',
  'transform-origin': '%',
  'transform-origin-x': '%',
  'transform-origin-y': '%',
  'transform-origin-z': '%',
  'transition-delay': 'ms',
  'transition-duration': 'ms',
  'vertical-align': 'px',
  width: 'px',
  'word-spacing': 'px',
  // Not existing properties.
  // Used to avoid issues with jss-expand intergration.
  'box-shadow-x': 'px',
  'box-shadow-y': 'px',
  'box-shadow-blur': 'px',
  'box-shadow-spread': 'px',
  'font-line-height': 'px',
  'text-shadow-x': 'px',
  'text-shadow-y': 'px',
  'text-shadow-blur': 'px'
};
},{}],348:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports['default'] = defaultUnit;

var _defaultUnits = require('./defaultUnits');

var _defaultUnits2 = _interopRequireDefault(_defaultUnits);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/**
 * Clones the object and adds a camel cased property version.
 */
function addCamelCasedVersion(obj) {
  var regExp = /(-[a-z])/g;
  var replace = function replace(str) {
    return str[1].toUpperCase();
  };
  var newObj = {};
  for (var key in obj) {
    newObj[key] = obj[key];
    newObj[key.replace(regExp, replace)] = obj[key];
  }
  return newObj;
}

var units = addCamelCasedVersion(_defaultUnits2['default']);

/**
 * Recursive deep style passing function
 *
 * @param {String} current property
 * @param {(Object|Array|Number|String)} property value
 * @param {Object} options
 * @return {(Object|Array|Number|String)} resulting value
 */
function iterate(prop, value, options) {
  if (!value) return value;

  var convertedValue = value;

  var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);
  if (type === 'object' && Array.isArray(value)) type = 'array';

  switch (type) {
    case 'object':
      if (prop === 'fallbacks') {
        for (var innerProp in value) {
          value[innerProp] = iterate(innerProp, value[innerProp], options);
        }
        break;
      }
      for (var _innerProp in value) {
        value[_innerProp] = iterate(prop + '-' + _innerProp, value[_innerProp], options);
      }
      break;
    case 'array':
      for (var i = 0; i < value.length; i++) {
        value[i] = iterate(prop, value[i], options);
      }
      break;
    case 'number':
      if (value !== 0) {
        convertedValue = value + (options[prop] || units[prop] || '');
      }
      break;
    default:
      break;
  }

  return convertedValue;
}

/**
 * Add unit to numeric values.
 */
function defaultUnit() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var camelCasedOptions = addCamelCasedVersion(options);

  function onProcessStyle(style, rule) {
    if (rule.type !== 'style') return style;

    for (var prop in style) {
      style[prop] = iterate(prop, style[prop], camelCasedOptions);
    }

    return style;
  }

  function onChangeValue(value, prop) {
    return iterate(prop, value, camelCasedOptions);
  }

  return { onProcessStyle: onProcessStyle, onChangeValue: onChangeValue };
}
},{"./defaultUnits":347}],349:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.default = jssExpand;

var _props = require('./props');

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Map values by given prop.
 *
 * @param {Array} array of values
 * @param {String} original property
 * @param {String} original rule
 * @return {String} mapped values
 */
function mapValuesByProp(value, prop, rule) {
  return value.map(function (item) {
    return objectToString(item, prop, rule);
  });
}

/**
 * Convert array to string.
 *
 * @param {Array} array of values
 * @param {String} original property
 * @param {Object} sheme, for converting arrays in strings
 * @param {Object} original rule
 * @return {String} converted string
 */
function arrayToString(value, prop, scheme, rule) {
  if (scheme[prop] == null) return value.join(',');
  if (value.length === 0) return '';
  if (Array.isArray(value[0])) return arrayToString(value[0], prop, scheme);
  if (_typeof(value[0]) === 'object') {
    return mapValuesByProp(value, prop, rule);
  }
  return value.join(' ');
}

/**
 * Convert object to string.
 *
 * @param {Object} object of values
 * @param {String} original property
 * @param {Object} original rule
 * @param {Boolean} is fallback prop
 * @return {String} converted string
 */
function objectToString(value, prop, rule, isFallback) {
  if (!(_props.propObj[prop] || _props.customPropObj[prop])) return '';

  var result = [];

  // Check if exists any non-standart property
  if (_props.customPropObj[prop]) {
    value = customPropsToStyle(value, rule, _props.customPropObj[prop], isFallback);
  }

  // Pass throught all standart props
  if (Object.keys(value).length) {
    for (var baseProp in _props.propObj[prop]) {
      if (value[baseProp]) {
        if (Array.isArray(value[baseProp])) {
          result.push(arrayToString(value[baseProp], baseProp, _props.propArrayInObj));
        } else result.push(value[baseProp]);
        continue;
      }

      // Add default value from props config.
      if (_props.propObj[prop][baseProp] != null) {
        result.push(_props.propObj[prop][baseProp]);
      }
    }
  }

  return result.join(' ');
}

/**
 * Convert custom properties values to styles adding them to rule directly
 *
 * @param {Object} object of values
 * @param {Object} original rule
 * @param {String} property, that contain partial custom properties
 * @param {Boolean} is fallback prop
 * @return {Object} value without custom properties, that was already added to rule
 */
function customPropsToStyle(value, rule, customProps, isFallback) {
  for (var prop in customProps) {
    var propName = customProps[prop];

    // If current property doesn't exist already in rule - add new one
    if (typeof value[prop] !== 'undefined' && (isFallback || !rule.prop(propName))) {
      var appendedValue = styleDetector(_defineProperty({}, propName, value[prop]), rule)[propName];

      // Add style directly in rule
      if (isFallback) rule.style.fallbacks[propName] = appendedValue;else rule.style[propName] = appendedValue;
    }
    // Delete converted property to avoid double converting
    delete value[prop];
  }

  return value;
}

/**
 * Detect if a style needs to be converted.
 *
 * @param {Object} style
 * @param {Object} rule
 * @param {Boolean} is fallback prop
 * @return {Object} convertedStyle
 */
function styleDetector(style, rule, isFallback) {
  for (var prop in style) {
    var value = style[prop];

    if (Array.isArray(value)) {
      // Check double arrays to avoid recursion.
      if (!Array.isArray(value[0])) {
        if (prop === 'fallbacks') {
          for (var index = 0; index < style.fallbacks.length; index++) {
            style.fallbacks[index] = styleDetector(style.fallbacks[index], rule, true);
          }
          continue;
        }

        style[prop] = arrayToString(value, prop, _props.propArray);
        // Avoid creating properties with empty values
        if (!style[prop]) delete style[prop];
      }
    } else if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {
      if (prop === 'fallbacks') {
        style.fallbacks = styleDetector(style.fallbacks, rule, true);
        continue;
      }

      style[prop] = objectToString(value, prop, rule, isFallback);
      // Avoid creating properties with empty values
      if (!style[prop]) delete style[prop];
    }

    // Maybe a computed value resulting in an empty string
    else if (style[prop] === '') delete style[prop];
  }

  return style;
}

/**
 * Adds possibility to write expanded styles.
 *
 * @param {Rule} rule
 * @api public
 */
function jssExpand() {
  function onProcessStyle(style, rule) {
    if (!style || rule.type !== 'style') return style;

    if (Array.isArray(style)) {
      // Pass rules one by one and reformat them
      for (var index = 0; index < style.length; index++) {
        style[index] = styleDetector(style[index], rule);
      }
      return style;
    }

    return styleDetector(style, rule);
  }

  return { onProcessStyle: onProcessStyle };
}
},{"./props":350}],350:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * A scheme for converting properties from array to regular style.
 * All properties listed below will be transformed to a string separated by space.
 */
var propArray = exports.propArray = {
  'background-size': true,
  'background-position': true,
  border: true,
  'border-bottom': true,
  'border-left': true,
  'border-top': true,
  'border-right': true,
  'border-radius': true,
  'border-image': true,
  'box-shadow': true,
  flex: true,
  margin: true,
  padding: true,
  outline: true,
  'transform-origin': true,
  transform: true,
  transition: true

  /**
   * A scheme for converting arrays to regular styles inside of objects.
   * For e.g.: "{position: [0, 0]}" => "background-position: 0 0;".
   */
};var propArrayInObj = exports.propArrayInObj = {
  position: true, // background-position
  size: true // background-size


  /**
   * A scheme for parsing and building correct styles from passed objects.
   */
};var propObj = exports.propObj = {
  padding: {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  },
  margin: {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  },
  background: {
    attachment: null,
    color: null,
    image: null,
    position: null,
    repeat: null
  },
  border: {
    width: null,
    style: null,
    color: null
  },
  'border-top': {
    width: null,
    style: null,
    color: null
  },
  'border-right': {
    width: null,
    style: null,
    color: null
  },
  'border-bottom': {
    width: null,
    style: null,
    color: null
  },
  'border-left': {
    width: null,
    style: null,
    color: null
  },
  outline: {
    width: null,
    style: null,
    color: null
  },
  'list-style': {
    type: null,
    position: null,
    image: null
  },
  transition: {
    property: null,
    duration: null,
    'timing-function': null,
    timingFunction: null, // Needed for avoiding comilation issues with jss-camel-case
    delay: null
  },
  animation: {
    name: null,
    duration: null,
    'timing-function': null,
    timingFunction: null, // Needed to avoid compilation issues with jss-camel-case
    delay: null,
    'iteration-count': null,
    iterationCount: null, // Needed to avoid compilation issues with jss-camel-case
    direction: null,
    'fill-mode': null,
    fillMode: null, // Needed to avoid compilation issues with jss-camel-case
    'play-state': null,
    playState: null // Needed to avoid compilation issues with jss-camel-case
  },
  'box-shadow': {
    x: 0,
    y: 0,
    blur: 0,
    spread: 0,
    color: null,
    inset: null
  },
  'text-shadow': {
    x: 0,
    y: 0,
    blur: null,
    color: null
  }

  /**
   * A scheme for converting non-standart properties inside object.
   * For e.g.: include 'border-radius' property inside 'border' object.
   */
};var customPropObj = exports.customPropObj = {
  border: {
    radius: 'border-radius',
    image: 'border-image'
  },
  background: {
    size: 'background-size',
    image: 'background-image'
  },
  font: {
    style: 'font-style',
    variant: 'font-variant',
    weight: 'font-weight',
    stretch: 'font-stretch',
    size: 'font-size',
    family: 'font-family',
    lineHeight: 'line-height', // Needed to avoid compilation issues with jss-camel-case
    'line-height': 'line-height'
  },
  flex: {
    grow: 'flex-grow',
    basis: 'flex-basis',
    direction: 'flex-direction',
    wrap: 'flex-wrap',
    flow: 'flex-flow',
    shrink: 'flex-shrink'
  },
  align: {
    self: 'align-self',
    items: 'align-items',
    content: 'align-content'
  }
};
},{}],351:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports['default'] = jssExtend;

var _warning = require('warning');

var _warning2 = _interopRequireDefault(_warning);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var isObject = function isObject(obj) {
  return obj && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' && !Array.isArray(obj);
};

/**
 * Recursively extend styles.
 */
function extend(style, rule, sheet) {
  var newStyle = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

  if (typeof style.extend === 'string') {
    if (sheet) {
      var refRule = sheet.getRule(style.extend);
      if (refRule) {
        if (refRule === rule) (0, _warning2['default'])(false, '[JSS] A rule tries to extend itself \r\n%s', rule);else if (refRule.options.parent) {
          var originalStyle = refRule.options.parent.rules.raw[style.extend];
          extend(originalStyle, rule, sheet, newStyle);
        }
      }
    }
  } else if (Array.isArray(style.extend)) {
    for (var index = 0; index < style.extend.length; index++) {
      extend(style.extend[index], rule, sheet, newStyle);
    }
  } else {
    for (var prop in style.extend) {
      if (prop === 'extend') {
        extend(style.extend.extend, rule, sheet, newStyle);
      } else if (isObject(style.extend[prop])) {
        if (!newStyle[prop]) newStyle[prop] = {};
        extend(style.extend[prop], rule, sheet, newStyle[prop]);
      } else {
        newStyle[prop] = style.extend[prop];
      }
    }
  }
  // Copy base style.
  for (var _prop in style) {
    if (_prop === 'extend') continue;
    if (isObject(newStyle[_prop]) && isObject(style[_prop])) {
      extend(style[_prop], rule, sheet, newStyle[_prop]);
    } else if (isObject(style[_prop])) {
      newStyle[_prop] = extend(style[_prop], rule, sheet);
    } else {
      newStyle[_prop] = style[_prop];
    }
  }

  return newStyle;
}

/**
 * Handle `extend` property.
 *
 * @param {Rule} rule
 * @api public
 */
function jssExtend() {
  function onProcessStyle(style, rule, sheet) {
    return style.extend ? extend(style, rule, sheet) : style;
  }

  return { onProcessStyle: onProcessStyle };
}
},{"warning":394}],352:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports['default'] = jssGlobal;

var _jss = require('jss');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var propKey = '@global';
var prefixKey = '@global ';

var GlobalContainerRule = function () {
  function GlobalContainerRule(key, styles, options) {
    _classCallCheck(this, GlobalContainerRule);

    this.type = 'global';

    this.key = key;
    this.options = options;
    this.rules = new _jss.RuleList(_extends({}, options, {
      parent: this
    }));

    for (var selector in styles) {
      this.rules.add(selector, styles[selector], { selector: selector });
    }

    this.rules.process();
  }

  /**
   * Get a rule.
   */


  _createClass(GlobalContainerRule, [{
    key: 'getRule',
    value: function getRule(name) {
      return this.rules.get(name);
    }

    /**
     * Create and register rule, run plugins.
     */

  }, {
    key: 'addRule',
    value: function addRule(name, style, options) {
      var rule = this.rules.add(name, style, options);
      this.options.jss.plugins.onProcessRule(rule);
      return rule;
    }

    /**
     * Get index of a rule.
     */

  }, {
    key: 'indexOf',
    value: function indexOf(rule) {
      return this.rules.indexOf(rule);
    }

    /**
     * Generates a CSS string.
     */

  }, {
    key: 'toString',
    value: function toString() {
      return this.rules.toString();
    }
  }]);

  return GlobalContainerRule;
}();

var GlobalPrefixedRule = function () {
  function GlobalPrefixedRule(name, style, options) {
    _classCallCheck(this, GlobalPrefixedRule);

    this.name = name;
    this.options = options;
    var selector = name.substr(prefixKey.length);
    this.rule = options.jss.createRule(selector, style, _extends({}, options, {
      parent: this,
      selector: selector
    }));
  }

  _createClass(GlobalPrefixedRule, [{
    key: 'toString',
    value: function toString(options) {
      return this.rule.toString(options);
    }
  }]);

  return GlobalPrefixedRule;
}();

var separatorRegExp = /\s*,\s*/g;

function addScope(selector, scope) {
  var parts = selector.split(separatorRegExp);
  var scoped = '';
  for (var i = 0; i < parts.length; i++) {
    scoped += scope + ' ' + parts[i].trim();
    if (parts[i + 1]) scoped += ', ';
  }
  return scoped;
}

function handleNestedGlobalContainerRule(rule) {
  var options = rule.options,
      style = rule.style;

  var rules = style[propKey];

  if (!rules) return;

  for (var name in rules) {
    options.sheet.addRule(name, rules[name], _extends({}, options, {
      selector: addScope(name, rule.selector)
    }));
  }

  delete style[propKey];
}

function handlePrefixedGlobalRule(rule) {
  var options = rule.options,
      style = rule.style;

  for (var prop in style) {
    if (prop.substr(0, propKey.length) !== propKey) continue;

    var selector = addScope(prop.substr(propKey.length), rule.selector);
    options.sheet.addRule(selector, style[prop], _extends({}, options, {
      selector: selector
    }));
    delete style[prop];
  }
}

/**
 * Convert nested rules to separate, remove them from original styles.
 *
 * @param {Rule} rule
 * @api public
 */
function jssGlobal() {
  function onCreateRule(name, styles, options) {
    if (name === propKey) {
      return new GlobalContainerRule(name, styles, options);
    }

    if (name[0] === '@' && name.substr(0, prefixKey.length) === prefixKey) {
      return new GlobalPrefixedRule(name, styles, options);
    }

    var parent = options.parent;


    if (parent) {
      if (parent.type === 'global' || parent.options.parent.type === 'global') {
        options.global = true;
      }
    }

    if (options.global) options.selector = name;

    return null;
  }

  function onProcessRule(rule) {
    if (rule.type !== 'style') return;

    handleNestedGlobalContainerRule(rule);
    handlePrefixedGlobalRule(rule);
  }

  return { onCreateRule: onCreateRule, onProcessRule: onProcessRule };
}
},{"jss":365}],353:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = jssNested;

var _warning = require('warning');

var _warning2 = _interopRequireDefault(_warning);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var separatorRegExp = /\s*,\s*/g;
var parentRegExp = /&/g;
var refRegExp = /\$([\w-]+)/g;

/**
 * Convert nested rules to separate, remove them from original styles.
 *
 * @param {Rule} rule
 * @api public
 */
function jssNested() {
  // Get a function to be used for $ref replacement.
  function getReplaceRef(container) {
    return function (match, key) {
      var rule = container.getRule(key);
      if (rule) return rule.selector;
      (0, _warning2.default)(false, '[JSS] Could not find the referenced rule %s in %s.', key, container.options.meta || container);
      return key;
    };
  }

  var hasAnd = function hasAnd(str) {
    return str.indexOf('&') !== -1;
  };

  function replaceParentRefs(nestedProp, parentProp) {
    var parentSelectors = parentProp.split(separatorRegExp);
    var nestedSelectors = nestedProp.split(separatorRegExp);

    var result = '';

    for (var i = 0; i < parentSelectors.length; i++) {
      var parent = parentSelectors[i];

      for (var j = 0; j < nestedSelectors.length; j++) {
        var nested = nestedSelectors[j];
        if (result) result += ', ';
        // Replace all & by the parent or prefix & with the parent.
        result += hasAnd(nested) ? nested.replace(parentRegExp, parent) : parent + ' ' + nested;
      }
    }

    return result;
  }

  function getOptions(rule, container, options) {
    // Options has been already created, now we only increase index.
    if (options) return _extends({}, options, { index: options.index + 1 });

    var nestingLevel = rule.options.nestingLevel;

    nestingLevel = nestingLevel === undefined ? 1 : nestingLevel + 1;

    return _extends({}, rule.options, {
      nestingLevel: nestingLevel,
      index: container.indexOf(rule) + 1
    });
  }

  function onProcessStyle(style, rule) {
    if (rule.type !== 'style') return style;
    var container = rule.options.parent;
    var options = void 0;
    var replaceRef = void 0;
    for (var prop in style) {
      var isNested = hasAnd(prop);
      var isNestedConditional = prop[0] === '@';

      if (!isNested && !isNestedConditional) continue;

      options = getOptions(rule, container, options);

      if (isNested) {
        var selector = replaceParentRefs(prop, rule.selector
        // Lazily create the ref replacer function just once for
        // all nested rules within the sheet.
        );if (!replaceRef) replaceRef = getReplaceRef(container
        // Replace all $refs.
        );selector = selector.replace(refRegExp, replaceRef);

        container.addRule(selector, style[prop], _extends({}, options, { selector: selector }));
      } else if (isNestedConditional) {
        container
        // Place conditional right after the parent rule to ensure right ordering.
        .addRule(prop, null, options).addRule(rule.key, style[prop], { selector: rule.selector });
      }

      delete style[prop];
    }

    return style;
  }

  return { onProcessStyle: onProcessStyle };
}
},{"warning":394}],354:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _jssTemplate = require('jss-template');

var _jssTemplate2 = _interopRequireDefault(_jssTemplate);

var _jssGlobal = require('jss-global');

var _jssGlobal2 = _interopRequireDefault(_jssGlobal);

var _jssExtend = require('jss-extend');

var _jssExtend2 = _interopRequireDefault(_jssExtend);

var _jssNested = require('jss-nested');

var _jssNested2 = _interopRequireDefault(_jssNested);

var _jssCompose = require('jss-compose');

var _jssCompose2 = _interopRequireDefault(_jssCompose);

var _jssCamelCase = require('jss-camel-case');

var _jssCamelCase2 = _interopRequireDefault(_jssCamelCase);

var _jssDefaultUnit = require('jss-default-unit');

var _jssDefaultUnit2 = _interopRequireDefault(_jssDefaultUnit);

var _jssExpand = require('jss-expand');

var _jssExpand2 = _interopRequireDefault(_jssExpand);

var _jssVendorPrefixer = require('jss-vendor-prefixer');

var _jssVendorPrefixer2 = _interopRequireDefault(_jssVendorPrefixer);

var _jssPropsSort = require('jss-props-sort');

var _jssPropsSort2 = _interopRequireDefault(_jssPropsSort);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function () {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return {
    plugins: [(0, _jssTemplate2.default)(options.template), (0, _jssGlobal2.default)(options.global), (0, _jssExtend2.default)(options.extend), (0, _jssNested2.default)(options.nested), (0, _jssCompose2.default)(options.compose), (0, _jssCamelCase2.default)(options.camelCase), (0, _jssDefaultUnit2.default)(options.defaultUnit), (0, _jssExpand2.default)(options.expand), (0, _jssVendorPrefixer2.default)(options.vendorPrefixer), (0, _jssPropsSort2.default)(options.propsSort)]
  };
};
},{"jss-camel-case":345,"jss-compose":346,"jss-default-unit":348,"jss-expand":349,"jss-extend":351,"jss-global":352,"jss-nested":353,"jss-props-sort":355,"jss-template":356,"jss-vendor-prefixer":358}],355:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports['default'] = jssPropsSort;
/**
 * Sort props by length.
 */
function jssPropsSort() {
  function sort(prop0, prop1) {
    return prop0.length - prop1.length;
  }

  function onProcessStyle(style, rule) {
    if (rule.type !== 'style') return style;

    var newStyle = {};
    var props = Object.keys(style).sort(sort);
    for (var prop in props) {
      newStyle[props[prop]] = style[props[prop]];
    }
    return newStyle;
  }

  return { onProcessStyle: onProcessStyle };
}
},{}],356:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _parse = require('./parse');

var _parse2 = _interopRequireDefault(_parse);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var onProcessRule = function onProcessRule(rule) {
  if (typeof rule.style === 'string') {
    rule.style = (0, _parse2['default'])(rule.style);
  }
};

exports['default'] = function () {
  return { onProcessRule: onProcessRule };
};
},{"./parse":357}],357:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _warning = require('warning');

var _warning2 = _interopRequireDefault(_warning);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var semiWithNl = /;\n/;

/**
 * Naive CSS parser.
 * - Supports only rule body (no selectors)
 * - Requires semicolon and new line after the value (except of last line)
 * - No nested rules support
 */

exports['default'] = function (cssText) {
  var style = {};
  var split = cssText.split(semiWithNl);
  for (var i = 0; i < split.length; i++) {
    var decl = (split[i] || '').trim();

    if (!decl) continue;
    var colonIndex = decl.indexOf(':');
    if (colonIndex === -1) {
      (0, _warning2['default'])(false, 'Malformed CSS string "%s"', decl);
      continue;
    }
    var prop = decl.substr(0, colonIndex).trim();
    var value = decl.substr(colonIndex + 1).trim();
    style[prop] = value;
  }
  return style;
};
},{"warning":394}],358:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports['default'] = jssVendorPrefixer;

var _cssVendor = require('css-vendor');

var vendor = _interopRequireWildcard(_cssVendor);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

/**
 * Add vendor prefix to a property name when needed.
 *
 * @param {Rule} rule
 * @api public
 */
function jssVendorPrefixer() {
  function onProcessRule(rule) {
    if (rule.type === 'keyframes') {
      rule.key = '@' + vendor.prefix.css + rule.key.substr(1);
    }
  }

  function onProcessStyle(style, rule) {
    if (rule.type !== 'style') return style;

    for (var prop in style) {
      var value = style[prop];

      var changeProp = false;
      var supportedProp = vendor.supportedProperty(prop);
      if (supportedProp && supportedProp !== prop) changeProp = true;

      var changeValue = false;
      var supportedValue = vendor.supportedValue(supportedProp, value);
      if (supportedValue && supportedValue !== value) changeValue = true;

      if (changeProp || changeValue) {
        if (changeProp) delete style[prop];
        style[supportedProp || prop] = supportedValue || value;
      }
    }

    return style;
  }

  function onChangeValue(value, prop) {
    return vendor.supportedValue(prop, value);
  }

  return { onProcessRule: onProcessRule, onProcessStyle: onProcessStyle, onChangeValue: onChangeValue };
}
},{"css-vendor":337}],359:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _isInBrowser = require('is-in-browser');

var _isInBrowser2 = _interopRequireDefault(_isInBrowser);

var _StyleSheet = require('./StyleSheet');

var _StyleSheet2 = _interopRequireDefault(_StyleSheet);

var _PluginsRegistry = require('./PluginsRegistry');

var _PluginsRegistry2 = _interopRequireDefault(_PluginsRegistry);

var _rules = require('./plugins/rules');

var _rules2 = _interopRequireDefault(_rules);

var _observables = require('./plugins/observables');

var _observables2 = _interopRequireDefault(_observables);

var _functions = require('./plugins/functions');

var _functions2 = _interopRequireDefault(_functions);

var _sheets = require('./sheets');

var _sheets2 = _interopRequireDefault(_sheets);

var _StyleRule = require('./rules/StyleRule');

var _StyleRule2 = _interopRequireDefault(_StyleRule);

var _createGenerateClassName = require('./utils/createGenerateClassName');

var _createGenerateClassName2 = _interopRequireDefault(_createGenerateClassName);

var _createRule2 = require('./utils/createRule');

var _createRule3 = _interopRequireDefault(_createRule2);

var _DomRenderer = require('./renderers/DomRenderer');

var _DomRenderer2 = _interopRequireDefault(_DomRenderer);

var _VirtualRenderer = require('./renderers/VirtualRenderer');

var _VirtualRenderer2 = _interopRequireDefault(_VirtualRenderer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var defaultPlugins = _rules2['default'].concat([_observables2['default'], _functions2['default']]);

var instanceCounter = 0;

var Jss = function () {
  function Jss(options) {
    _classCallCheck(this, Jss);

    this.id = instanceCounter++;
    this.version = "9.5.1";
    this.plugins = new _PluginsRegistry2['default']();
    this.options = {
      createGenerateClassName: _createGenerateClassName2['default'],
      Renderer: _isInBrowser2['default'] ? _DomRenderer2['default'] : _VirtualRenderer2['default'],
      plugins: []
    };
    this.generateClassName = (0, _createGenerateClassName2['default'])();

    // eslint-disable-next-line prefer-spread
    this.use.apply(this, defaultPlugins);
    this.setup(options);
  }

  _createClass(Jss, [{
    key: 'setup',
    value: function setup() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (options.createGenerateClassName) {
        this.options.createGenerateClassName = options.createGenerateClassName;
        // $FlowFixMe
        this.generateClassName = options.createGenerateClassName();
      }

      if (options.insertionPoint != null) this.options.insertionPoint = options.insertionPoint;
      if (options.virtual || options.Renderer) {
        this.options.Renderer = options.Renderer || (options.virtual ? _VirtualRenderer2['default'] : _DomRenderer2['default']);
      }

      // eslint-disable-next-line prefer-spread
      if (options.plugins) this.use.apply(this, options.plugins);

      return this;
    }

    /**
     * Create a Style Sheet.
     */

  }, {
    key: 'createStyleSheet',
    value: function createStyleSheet(styles) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var index = options.index;
      if (typeof index !== 'number') {
        index = _sheets2['default'].index === 0 ? 0 : _sheets2['default'].index + 1;
      }
      var sheet = new _StyleSheet2['default'](styles, _extends({}, options, {
        jss: this,
        generateClassName: options.generateClassName || this.generateClassName,
        insertionPoint: this.options.insertionPoint,
        Renderer: this.options.Renderer,
        index: index
      }));
      this.plugins.onProcessSheet(sheet);

      return sheet;
    }

    /**
     * Detach the Style Sheet and remove it from the registry.
     */

  }, {
    key: 'removeStyleSheet',
    value: function removeStyleSheet(sheet) {
      sheet.detach();
      _sheets2['default'].remove(sheet);
      return this;
    }

    /**
     * Create a rule without a Style Sheet.
     */

  }, {
    key: 'createRule',
    value: function createRule(name) {
      var style = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      // Enable rule without name for inline styles.
      if ((typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {
        options = style;
        style = name;
        name = undefined;
      }

      // Cast from RuleFactoryOptions to RuleOptions
      // https://stackoverflow.com/questions/41328728/force-casting-in-flow
      var ruleOptions = options;

      ruleOptions.jss = this;
      ruleOptions.Renderer = this.options.Renderer;
      if (!ruleOptions.generateClassName) ruleOptions.generateClassName = this.generateClassName;
      if (!ruleOptions.classes) ruleOptions.classes = {};
      var rule = (0, _createRule3['default'])(name, style, ruleOptions);

      if (!ruleOptions.selector && rule instanceof _StyleRule2['default']) {
        rule.selector = '.' + ruleOptions.generateClassName(rule);
      }

      this.plugins.onProcessRule(rule);

      return rule;
    }

    /**
     * Register plugin. Passed function will be invoked with a rule instance.
     */

  }, {
    key: 'use',
    value: function use() {
      var _this = this;

      for (var _len = arguments.length, plugins = Array(_len), _key = 0; _key < _len; _key++) {
        plugins[_key] = arguments[_key];
      }

      plugins.forEach(function (plugin) {
        // Avoids applying same plugin twice, at least based on ref.
        if (_this.options.plugins.indexOf(plugin) === -1) {
          _this.options.plugins.push(plugin);
          _this.plugins.use(plugin);
        }
      });

      return this;
    }
  }]);

  return Jss;
}();

exports['default'] = Jss;
},{"./PluginsRegistry":360,"./StyleSheet":364,"./plugins/functions":366,"./plugins/observables":367,"./plugins/rules":368,"./renderers/DomRenderer":369,"./renderers/VirtualRenderer":370,"./rules/StyleRule":375,"./sheets":377,"./utils/createGenerateClassName":379,"./utils/createRule":380,"is-in-browser":344}],360:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _warning = require('warning');

var _warning2 = _interopRequireDefault(_warning);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var PluginsRegistry = function () {
  function PluginsRegistry() {
    _classCallCheck(this, PluginsRegistry);

    this.hooks = {
      onCreateRule: [],
      onProcessRule: [],
      onProcessStyle: [],
      onProcessSheet: [],
      onChangeValue: [],
      onUpdate: []

      /**
       * Call `onCreateRule` hooks and return an object if returned by a hook.
       */
    };
  }

  _createClass(PluginsRegistry, [{
    key: 'onCreateRule',
    value: function onCreateRule(name, decl, options) {
      for (var i = 0; i < this.hooks.onCreateRule.length; i++) {
        var rule = this.hooks.onCreateRule[i](name, decl, options);
        if (rule) return rule;
      }
      return null;
    }

    /**
     * Call `onProcessRule` hooks.
     */

  }, {
    key: 'onProcessRule',
    value: function onProcessRule(rule) {
      if (rule.isProcessed) return;
      var sheet = rule.options.sheet;

      for (var i = 0; i < this.hooks.onProcessRule.length; i++) {
        this.hooks.onProcessRule[i](rule, sheet);
      }

      // $FlowFixMe
      if (rule.style) this.onProcessStyle(rule.style, rule, sheet);

      rule.isProcessed = true;
    }

    /**
     * Call `onProcessStyle` hooks.
     */

  }, {
    key: 'onProcessStyle',
    value: function onProcessStyle(style, rule, sheet) {
      var nextStyle = style;

      for (var i = 0; i < this.hooks.onProcessStyle.length; i++) {
        nextStyle = this.hooks.onProcessStyle[i](nextStyle, rule, sheet);
        // $FlowFixMe
        rule.style = nextStyle;
      }
    }

    /**
     * Call `onProcessSheet` hooks.
     */

  }, {
    key: 'onProcessSheet',
    value: function onProcessSheet(sheet) {
      for (var i = 0; i < this.hooks.onProcessSheet.length; i++) {
        this.hooks.onProcessSheet[i](sheet);
      }
    }

    /**
     * Call `onUpdate` hooks.
     */

  }, {
    key: 'onUpdate',
    value: function onUpdate(data, rule, sheet) {
      for (var i = 0; i < this.hooks.onUpdate.length; i++) {
        this.hooks.onUpdate[i](data, rule, sheet);
      }
    }

    /**
     * Call `onChangeValue` hooks.
     */

  }, {
    key: 'onChangeValue',
    value: function onChangeValue(value, prop, rule) {
      var processedValue = value;
      for (var i = 0; i < this.hooks.onChangeValue.length; i++) {
        processedValue = this.hooks.onChangeValue[i](processedValue, prop, rule);
      }
      return processedValue;
    }

    /**
     * Register a plugin.
     * If function is passed, it is a shortcut for `{onProcessRule}`.
     */

  }, {
    key: 'use',
    value: function use(plugin) {
      for (var name in plugin) {
        if (this.hooks[name]) this.hooks[name].push(plugin[name]);else (0, _warning2['default'])(false, '[JSS] Unknown hook "%s".', name);
      }
    }
  }]);

  return PluginsRegistry;
}();

exports['default'] = PluginsRegistry;
},{"warning":394}],361:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _createRule = require('./utils/createRule');

var _createRule2 = _interopRequireDefault(_createRule);

var _linkRule = require('./utils/linkRule');

var _linkRule2 = _interopRequireDefault(_linkRule);

var _StyleRule = require('./rules/StyleRule');

var _StyleRule2 = _interopRequireDefault(_StyleRule);

var _escape = require('./utils/escape');

var _escape2 = _interopRequireDefault(_escape);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Contains rules objects and allows adding/removing etc.
 * Is used for e.g. by `StyleSheet` or `ConditionalRule`.
 */
var RuleList = function () {

  // Original styles object.
  function RuleList(options) {
    _classCallCheck(this, RuleList);

    this.map = {};
    this.raw = {};
    this.index = [];

    this.options = options;
    this.classes = options.classes;
  }

  /**
   * Create and register rule.
   *
   * Will not render after Style Sheet was rendered the first time.
   */


  // Used to ensure correct rules order.

  // Rules registry for access by .get() method.
  // It contains the same rule registered by name and by selector.


  _createClass(RuleList, [{
    key: 'add',
    value: function add(name, decl, options) {
      var _options = this.options,
          parent = _options.parent,
          sheet = _options.sheet,
          jss = _options.jss,
          Renderer = _options.Renderer,
          generateClassName = _options.generateClassName;


      options = _extends({
        classes: this.classes,
        parent: parent,
        sheet: sheet,
        jss: jss,
        Renderer: Renderer,
        generateClassName: generateClassName
      }, options);

      if (!options.selector && this.classes[name]) {
        options.selector = '.' + (0, _escape2['default'])(this.classes[name]);
      }

      this.raw[name] = decl;

      var rule = (0, _createRule2['default'])(name, decl, options);

      var className = void 0;

      if (!options.selector && rule instanceof _StyleRule2['default']) {
        className = generateClassName(rule, sheet);
        rule.selector = '.' + (0, _escape2['default'])(className);
      }

      this.register(rule, className);

      var index = options.index === undefined ? this.index.length : options.index;
      this.index.splice(index, 0, rule);

      return rule;
    }

    /**
     * Get a rule.
     */

  }, {
    key: 'get',
    value: function get(name) {
      return this.map[name];
    }

    /**
     * Delete a rule.
     */

  }, {
    key: 'remove',
    value: function remove(rule) {
      this.unregister(rule);
      this.index.splice(this.indexOf(rule), 1);
    }

    /**
     * Get index of a rule.
     */

  }, {
    key: 'indexOf',
    value: function indexOf(rule) {
      return this.index.indexOf(rule);
    }

    /**
     * Run `onProcessRule()` plugins on every rule.
     */

  }, {
    key: 'process',
    value: function process() {
      var plugins = this.options.jss.plugins;
      // We need to clone array because if we modify the index somewhere else during a loop
      // we end up with very hard-to-track-down side effects.

      this.index.slice(0).forEach(plugins.onProcessRule, plugins);
    }

    /**
     * Register a rule in `.map` and `.classes` maps.
     */

  }, {
    key: 'register',
    value: function register(rule, className) {
      this.map[rule.key] = rule;
      if (rule instanceof _StyleRule2['default']) {
        this.map[rule.selector] = rule;
        if (className) this.classes[rule.key] = className;
      }
    }

    /**
     * Unregister a rule.
     */

  }, {
    key: 'unregister',
    value: function unregister(rule) {
      delete this.map[rule.key];
      if (rule instanceof _StyleRule2['default']) {
        delete this.map[rule.selector];
        delete this.classes[rule.key];
      }
    }

    /**
     * Update the function values with a new data.
     */

  }, {
    key: 'update',
    value: function update(name, data) {
      var _options2 = this.options,
          plugins = _options2.jss.plugins,
          sheet = _options2.sheet;

      if (typeof name === 'string') {
        plugins.onUpdate(data, this.get(name), sheet);
        return;
      }

      for (var index = 0; index < this.index.length; index++) {
        plugins.onUpdate(name, this.index[index], sheet);
      }
    }

    /**
     * Link renderable rules with CSSRuleList.
     */

  }, {
    key: 'link',
    value: function link(cssRules) {
      var map = this.options.sheet.renderer.getUnescapedKeysMap(this.index);

      for (var i = 0; i < cssRules.length; i++) {
        var cssRule = cssRules[i];
        var _key = this.options.sheet.renderer.getKey(cssRule);
        if (map[_key]) _key = map[_key];
        var rule = this.map[_key];
        if (rule) (0, _linkRule2['default'])(rule, cssRule);
      }
    }

    /**
     * Convert rules to a CSS string.
     */

  }, {
    key: 'toString',
    value: function toString(options) {
      var str = '';
      var sheet = this.options.sheet;

      var link = sheet ? sheet.options.link : false;

      for (var index = 0; index < this.index.length; index++) {
        var rule = this.index[index];
        var css = rule.toString(options);

        // No need to render an empty rule.
        if (!css && !link) continue;

        if (str) str += '\n';
        str += css;
      }

      return str;
    }
  }]);

  return RuleList;
}();

exports['default'] = RuleList;
},{"./rules/StyleRule":375,"./utils/createRule":380,"./utils/escape":381,"./utils/linkRule":385}],362:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _warning = require('warning');

var _warning2 = _interopRequireDefault(_warning);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * SheetsManager is like a WeakMap which is designed to count StyleSheet
 * instances and attach/detach automatically.
 */
var SheetsManager = function () {
  function SheetsManager() {
    _classCallCheck(this, SheetsManager);

    this.sheets = [];
    this.refs = [];
    this.keys = [];
  }

  _createClass(SheetsManager, [{
    key: 'get',
    value: function get(key) {
      var index = this.keys.indexOf(key);
      return this.sheets[index];
    }
  }, {
    key: 'add',
    value: function add(key, sheet) {
      var sheets = this.sheets,
          refs = this.refs,
          keys = this.keys;

      var index = sheets.indexOf(sheet);

      if (index !== -1) return index;

      sheets.push(sheet);
      refs.push(0);
      keys.push(key);

      return sheets.length - 1;
    }
  }, {
    key: 'manage',
    value: function manage(key) {
      var index = this.keys.indexOf(key);
      var sheet = this.sheets[index];
      if (this.refs[index] === 0) sheet.attach();
      this.refs[index]++;
      if (!this.keys[index]) this.keys.splice(index, 0, key);
      return sheet;
    }
  }, {
    key: 'unmanage',
    value: function unmanage(key) {
      var index = this.keys.indexOf(key);
      if (index === -1) {
        // eslint-ignore-next-line no-console
        (0, _warning2['default'])(false, 'SheetsManager: can\'t find sheet to unmanage');
        return;
      }
      if (this.refs[index] > 0) {
        this.refs[index]--;
        if (this.refs[index] === 0) this.sheets[index].detach();
      }
    }
  }, {
    key: 'size',
    get: function get() {
      return this.keys.length;
    }
  }]);

  return SheetsManager;
}();

exports['default'] = SheetsManager;
},{"warning":394}],363:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Sheets registry to access them all at one place.
 */
var SheetsRegistry = function () {
  function SheetsRegistry() {
    _classCallCheck(this, SheetsRegistry);

    this.registry = [];
  }

  _createClass(SheetsRegistry, [{
    key: 'add',


    /**
     * Register a Style Sheet.
     */
    value: function add(sheet) {
      var registry = this.registry;
      var index = sheet.options.index;


      if (registry.indexOf(sheet) !== -1) return;

      if (registry.length === 0 || index >= this.index) {
        registry.push(sheet);
        return;
      }

      // Find a position.
      for (var i = 0; i < registry.length; i++) {
        if (registry[i].options.index > index) {
          registry.splice(i, 0, sheet);
          return;
        }
      }
    }

    /**
     * Reset the registry.
     */

  }, {
    key: 'reset',
    value: function reset() {
      this.registry = [];
    }

    /**
     * Remove a Style Sheet.
     */

  }, {
    key: 'remove',
    value: function remove(sheet) {
      var index = this.registry.indexOf(sheet);
      this.registry.splice(index, 1);
    }

    /**
     * Convert all attached sheets to a CSS string.
     */

  }, {
    key: 'toString',
    value: function toString(options) {
      return this.registry.filter(function (sheet) {
        return sheet.attached;
      }).map(function (sheet) {
        return sheet.toString(options);
      }).join('\n');
    }
  }, {
    key: 'index',


    /**
     * Current highest index number.
     */
    get: function get() {
      return this.registry.length === 0 ? 0 : this.registry[this.registry.length - 1].options.index;
    }
  }]);

  return SheetsRegistry;
}();

exports['default'] = SheetsRegistry;
},{}],364:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _linkRule = require('./utils/linkRule');

var _linkRule2 = _interopRequireDefault(_linkRule);

var _RuleList = require('./RuleList');

var _RuleList2 = _interopRequireDefault(_RuleList);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var StyleSheet = function () {
  function StyleSheet(styles, options) {
    _classCallCheck(this, StyleSheet);

    this.attached = false;
    this.deployed = false;
    this.linked = false;
    this.classes = {};
    this.options = _extends({}, options, {
      sheet: this,
      parent: this,
      classes: this.classes
    });
    this.renderer = new options.Renderer(this);
    this.rules = new _RuleList2['default'](this.options);

    for (var name in styles) {
      this.rules.add(name, styles[name]);
    }

    this.rules.process();
  }

  /**
   * Attach renderable to the render tree.
   */


  _createClass(StyleSheet, [{
    key: 'attach',
    value: function attach() {
      if (this.attached) return this;
      if (!this.deployed) this.deploy();
      this.renderer.attach();
      if (!this.linked && this.options.link) this.link();
      this.attached = true;
      return this;
    }

    /**
     * Remove renderable from render tree.
     */

  }, {
    key: 'detach',
    value: function detach() {
      if (!this.attached) return this;
      this.renderer.detach();
      this.attached = false;
      return this;
    }

    /**
     * Add a rule to the current stylesheet.
     * Will insert a rule also after the stylesheet has been rendered first time.
     */

  }, {
    key: 'addRule',
    value: function addRule(name, decl, options) {
      var queue = this.queue;

      // Plugins can create rules.
      // In order to preserve the right order, we need to queue all `.addRule` calls,
      // which happen after the first `rules.add()` call.

      if (this.attached && !queue) this.queue = [];

      var rule = this.rules.add(name, decl, options);
      this.options.jss.plugins.onProcessRule(rule);

      if (this.attached) {
        if (!this.deployed) return rule;
        // Don't insert rule directly if there is no stringified version yet.
        // It will be inserted all together when .attach is called.
        if (queue) queue.push(rule);else {
          this.insertRule(rule);
          if (this.queue) {
            this.queue.forEach(this.insertRule, this);
            this.queue = undefined;
          }
        }
        return rule;
      }

      // We can't add rules to a detached style node.
      // We will redeploy the sheet once user will attach it.
      this.deployed = false;

      return rule;
    }

    /**
     * Insert rule into the StyleSheet
     */

  }, {
    key: 'insertRule',
    value: function insertRule(rule) {
      var renderable = this.renderer.insertRule(rule);
      if (renderable && this.options.link) (0, _linkRule2['default'])(rule, renderable);
    }

    /**
     * Create and add rules.
     * Will render also after Style Sheet was rendered the first time.
     */

  }, {
    key: 'addRules',
    value: function addRules(styles, options) {
      var added = [];
      for (var name in styles) {
        added.push(this.addRule(name, styles[name], options));
      }
      return added;
    }

    /**
     * Get a rule by name.
     */

  }, {
    key: 'getRule',
    value: function getRule(name) {
      return this.rules.get(name);
    }

    /**
     * Delete a rule by name.
     * Returns `true`: if rule has been deleted from the DOM.
     */

  }, {
    key: 'deleteRule',
    value: function deleteRule(name) {
      var rule = this.rules.get(name);

      if (!rule) return false;

      this.rules.remove(rule);

      if (this.attached && rule.renderable) {
        return this.renderer.deleteRule(rule.renderable);
      }

      return true;
    }

    /**
     * Get index of a rule.
     */

  }, {
    key: 'indexOf',
    value: function indexOf(rule) {
      return this.rules.indexOf(rule);
    }

    /**
     * Deploy pure CSS string to a renderable.
     */

  }, {
    key: 'deploy',
    value: function deploy() {
      this.renderer.deploy();
      this.deployed = true;
      return this;
    }

    /**
     * Link renderable CSS rules from sheet with their corresponding models.
     */

  }, {
    key: 'link',
    value: function link() {
      var cssRules = this.renderer.getRules();

      // Is undefined when VirtualRenderer is used.
      if (cssRules) this.rules.link(cssRules);
      this.linked = true;
      return this;
    }

    /**
     * Update the function values with a new data.
     */

  }, {
    key: 'update',
    value: function update(name, data) {
      this.rules.update(name, data);
      return this;
    }

    /**
     * Convert rules to a CSS string.
     */

  }, {
    key: 'toString',
    value: function toString(options) {
      return this.rules.toString(options);
    }
  }]);

  return StyleSheet;
}();

exports['default'] = StyleSheet;
},{"./RuleList":361,"./utils/linkRule":385}],365:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.create = exports.createGenerateClassName = exports.sheets = exports.RuleList = exports.SheetsManager = exports.SheetsRegistry = exports.toCssValue = exports.getDynamicStyles = undefined;

var _getDynamicStyles = require('./utils/getDynamicStyles');

Object.defineProperty(exports, 'getDynamicStyles', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_getDynamicStyles)['default'];
  }
});

var _toCssValue = require('./utils/toCssValue');

Object.defineProperty(exports, 'toCssValue', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_toCssValue)['default'];
  }
});

var _SheetsRegistry = require('./SheetsRegistry');

Object.defineProperty(exports, 'SheetsRegistry', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_SheetsRegistry)['default'];
  }
});

var _SheetsManager = require('./SheetsManager');

Object.defineProperty(exports, 'SheetsManager', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_SheetsManager)['default'];
  }
});

var _RuleList = require('./RuleList');

Object.defineProperty(exports, 'RuleList', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_RuleList)['default'];
  }
});

var _sheets = require('./sheets');

Object.defineProperty(exports, 'sheets', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_sheets)['default'];
  }
});

var _createGenerateClassName = require('./utils/createGenerateClassName');

Object.defineProperty(exports, 'createGenerateClassName', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_createGenerateClassName)['default'];
  }
});

var _Jss = require('./Jss');

var _Jss2 = _interopRequireDefault(_Jss);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/**
 * Creates a new instance of Jss.
 */
var create = exports.create = function create(options) {
  return new _Jss2['default'](options);
};

/**
 * A global Jss instance.
 */
exports['default'] = create();
},{"./Jss":359,"./RuleList":361,"./SheetsManager":362,"./SheetsRegistry":363,"./sheets":377,"./utils/createGenerateClassName":379,"./utils/getDynamicStyles":382,"./utils/toCssValue":388}],366:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _RuleList = require('../RuleList');

var _RuleList2 = _interopRequireDefault(_RuleList);

var _StyleRule = require('../rules/StyleRule');

var _StyleRule2 = _interopRequireDefault(_StyleRule);

var _kebabCase = require('../utils/kebabCase');

var _kebabCase2 = _interopRequireDefault(_kebabCase);

var _createRule = require('../utils/createRule');

var _createRule2 = _interopRequireDefault(_createRule);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

// A symbol replacement.
var now = Date.now();
var fnValuesNs = 'fnValues' + now;
var fnStyleNs = 'fnStyle' + ++now;

exports['default'] = {
  onCreateRule: function onCreateRule(name, decl, options) {
    if (typeof decl !== 'function') return null;
    var rule = (0, _createRule2['default'])(name, {}, options);
    rule[fnStyleNs] = decl;
    return rule;
  },
  onProcessStyle: function onProcessStyle(style, rule) {
    var fn = {};
    for (var prop in style) {
      var value = style[prop];
      if (typeof value !== 'function') continue;
      delete style[prop];
      fn[(0, _kebabCase2['default'])(prop)] = value;
    }
    rule = rule;
    rule[fnValuesNs] = fn;
    return style;
  },
  onUpdate: function onUpdate(data, rule) {
    // It is a rules container like for e.g. ConditionalRule.
    if (rule.rules instanceof _RuleList2['default']) {
      rule.rules.update(data);
      return;
    }
    if (!(rule instanceof _StyleRule2['default'])) return;

    rule = rule;

    // If we have a fn values map, it is a rule with function values.
    if (rule[fnValuesNs]) {
      for (var prop in rule[fnValuesNs]) {
        rule.prop(prop, rule[fnValuesNs][prop](data));
      }
    }

    rule = rule;

    var fnStyle = rule[fnStyleNs];

    // If we have a style function, the entire rule is dynamic and style object
    // will be returned from that function.
    if (fnStyle) {
      var style = fnStyle(data);
      for (var _prop in style) {
        rule.prop(_prop, style[_prop]);
      }
    }
  }
};
},{"../RuleList":361,"../rules/StyleRule":375,"../utils/createRule":380,"../utils/kebabCase":384}],367:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _StyleRule = require('../rules/StyleRule');

var _StyleRule2 = _interopRequireDefault(_StyleRule);

var _createRule = require('../utils/createRule');

var _createRule2 = _interopRequireDefault(_createRule);

var _isObservable = require('../utils/isObservable');

var _isObservable2 = _interopRequireDefault(_isObservable);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

exports['default'] = {
  onCreateRule: function onCreateRule(name, decl, options) {
    if (!(0, _isObservable2['default'])(decl)) return null;

    // Cast `decl` to `Observable`, since it passed the type guard.
    var style$ = decl;

    var rule = (0, _createRule2['default'])(name, {}, options);

    // TODO
    // Call `stream.subscribe()` returns a subscription, which should be explicitly
    // unsubscribed from when we know this sheet is no longer needed.
    style$.subscribe(function (style) {
      for (var prop in style) {
        rule.prop(prop, style[prop]);
      }
    });

    return rule;
  },
  onProcessRule: function onProcessRule(rule) {
    if (!(rule instanceof _StyleRule2['default'])) return;
    var styleRule = rule;
    var style = styleRule.style;

    var _loop = function _loop(prop) {
      var value = style[prop];
      if (!(0, _isObservable2['default'])(value)) return 'continue';
      delete style[prop];
      value.subscribe({
        next: function next(nextValue) {
          styleRule.prop(prop, nextValue);
        }
      });
    };

    for (var prop in style) {
      var _ret = _loop(prop);

      if (_ret === 'continue') continue;
    }
  }
};
},{"../rules/StyleRule":375,"../utils/createRule":380,"../utils/isObservable":383}],368:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _SimpleRule = require('../rules/SimpleRule');

var _SimpleRule2 = _interopRequireDefault(_SimpleRule);

var _KeyframesRule = require('../rules/KeyframesRule');

var _KeyframesRule2 = _interopRequireDefault(_KeyframesRule);

var _ConditionalRule = require('../rules/ConditionalRule');

var _ConditionalRule2 = _interopRequireDefault(_ConditionalRule);

var _FontFaceRule = require('../rules/FontFaceRule');

var _FontFaceRule2 = _interopRequireDefault(_FontFaceRule);

var _ViewportRule = require('../rules/ViewportRule');

var _ViewportRule2 = _interopRequireDefault(_ViewportRule);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var classes = {
  '@charset': _SimpleRule2['default'],
  '@import': _SimpleRule2['default'],
  '@namespace': _SimpleRule2['default'],
  '@keyframes': _KeyframesRule2['default'],
  '@media': _ConditionalRule2['default'],
  '@supports': _ConditionalRule2['default'],
  '@font-face': _FontFaceRule2['default'],
  '@viewport': _ViewportRule2['default'],
  '@-ms-viewport': _ViewportRule2['default']

  /**
   * Generate plugins which will register all rules.
   */
};
exports['default'] = Object.keys(classes).map(function (key) {
  // https://jsperf.com/indexof-vs-substr-vs-regex-at-the-beginning-3
  var re = new RegExp('^' + key);
  var onCreateRule = function onCreateRule(name, decl, options) {
    return re.test(name) ? new classes[key](name, decl, options) : null;
  };
  return { onCreateRule: onCreateRule };
});
},{"../rules/ConditionalRule":371,"../rules/FontFaceRule":372,"../rules/KeyframesRule":373,"../rules/SimpleRule":374,"../rules/ViewportRule":376}],369:[function(require,module,exports){
(function (global){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _warning = require('warning');

var _warning2 = _interopRequireDefault(_warning);

var _sheets = require('../sheets');

var _sheets2 = _interopRequireDefault(_sheets);

var _StyleRule = require('../rules/StyleRule');

var _StyleRule2 = _interopRequireDefault(_StyleRule);

var _toCssValue = require('../utils/toCssValue');

var _toCssValue2 = _interopRequireDefault(_toCssValue);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Get a style property.
 */
function getStyle(cssRule, prop) {
  try {
    return cssRule.style.getPropertyValue(prop);
  } catch (err) {
    // IE may throw if property is unknown.
    return '';
  }
}

/**
 * Set a style property.
 */
function setStyle(cssRule, prop, value) {
  try {
    var cssValue = value;

    if (Array.isArray(value)) {
      cssValue = (0, _toCssValue2['default'])(value, true);

      if (value[value.length - 1] === '!important') {
        cssRule.style.setProperty(prop, cssValue, 'important');
        return true;
      }
    }

    cssRule.style.setProperty(prop, cssValue);
  } catch (err) {
    // IE may throw if property is unknown.
    return false;
  }
  return true;
}

var CSSRuleTypes = {
  STYLE_RULE: 1,
  KEYFRAMES_RULE: 7

  /**
   * Get the CSS Rule key.
   */

};var getKey = function () {
  var extractKey = function extractKey(cssText) {
    var from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    return cssText.substr(from, cssText.indexOf('{') - 1);
  };

  return function (cssRule) {
    if (cssRule.type === CSSRuleTypes.STYLE_RULE) return cssRule.selectorText;
    if (cssRule.type === CSSRuleTypes.KEYFRAMES_RULE) {
      var name = cssRule.name;

      if (name) return '@keyframes ' + name;

      // There is no rule.name in the following browsers:
      // - IE 9
      // - Safari 7.1.8
      // - Mobile Safari 9.0.0
      var cssText = cssRule.cssText;

      return '@' + extractKey(cssText, cssText.indexOf('keyframes'));
    }

    // Conditionals.
    return extractKey(cssRule.cssText);
  };
}();

/**
 * Set the selector.
 */
function setSelector(cssRule, selectorText) {
  cssRule.selectorText = selectorText;

  // Return false if setter was not successful.
  // Currently works in chrome only.
  return cssRule.selectorText === selectorText;
}

/**
 * Gets the `head` element upon the first call and caches it.
 */
var getHead = function () {
  var head = void 0;
  return function () {
    if (!head) head = document.head || document.getElementsByTagName('head')[0];
    return head;
  };
}();

/**
 * Gets a map of rule keys, where the property is an unescaped key and value
 * is a potentially escaped one.
 * It is used to identify CSS rules and the corresponding JSS rules. As an identifier
 * for CSSStyleRule we normally use `selectorText`. Though if original selector text
 * contains escaped code points e.g. `:not(#\\20)`, CSSOM will compile it to `:not(# )`
 * and so CSS rule's `selectorText` won't match JSS rule selector.
 *
 * https://www.w3.org/International/questions/qa-escapes#cssescapes
 */
var getUnescapedKeysMap = function () {
  var style = void 0;
  var isAttached = false;

  return function (rules) {
    var map = {};
    // https://github.com/facebook/flow/issues/2696
    if (!style) style = document.createElement('style');
    for (var i = 0; i < rules.length; i++) {
      var rule = rules[i];
      if (!(rule instanceof _StyleRule2['default'])) continue;
      var selector = rule.selector;
      // Only unescape selector over CSSOM if it contains a back slash.

      if (selector && selector.indexOf('\\') !== -1) {
        // Lazilly attach when needed.
        if (!isAttached) {
          getHead().appendChild(style);
          isAttached = true;
        }
        style.textContent = selector + ' {}';
        var _style = style,
            sheet = _style.sheet;

        if (sheet) {
          var cssRules = sheet.cssRules;

          if (cssRules) map[cssRules[0].selectorText] = rule.key;
        }
      }
    }
    if (isAttached) {
      getHead().removeChild(style);
      isAttached = false;
    }
    return map;
  };
}();

/**
 * Find attached sheet with an index higher than the passed one.
 */
function findHigherSheet(registry, options) {
  for (var i = 0; i < registry.length; i++) {
    var sheet = registry[i];
    if (sheet.attached && sheet.options.index > options.index && sheet.options.insertionPoint === options.insertionPoint) {
      return sheet;
    }
  }
  return null;
}

/**
 * Find attached sheet with the highest index.
 */
function findHighestSheet(registry, options) {
  for (var i = registry.length - 1; i >= 0; i--) {
    var sheet = registry[i];
    if (sheet.attached && sheet.options.insertionPoint === options.insertionPoint) {
      return sheet;
    }
  }
  return null;
}

/**
 * Find a comment with "jss" inside.
 */
function findCommentNode(text) {
  var head = getHead();
  for (var i = 0; i < head.childNodes.length; i++) {
    var node = head.childNodes[i];
    if (node.nodeType === 8 && node.nodeValue.trim() === text) {
      return node;
    }
  }
  return null;
}

/**
 * Find a node before which we can insert the sheet.
 */
function findPrevNode(options) {
  var registry = _sheets2['default'].registry;


  if (registry.length > 0) {
    // Try to insert before the next higher sheet.
    var sheet = findHigherSheet(registry, options);
    if (sheet) return sheet.renderer.element;

    // Otherwise insert after the last attached.
    sheet = findHighestSheet(registry, options);
    if (sheet) return sheet.renderer.element.nextElementSibling;
  }

  // Try to find a comment placeholder if registry is empty.
  var insertionPoint = options.insertionPoint;

  if (insertionPoint && typeof insertionPoint === 'string') {
    var comment = findCommentNode(insertionPoint);
    if (comment) return comment.nextSibling;
    // If user specifies an insertion point and it can't be found in the document -
    // bad specificity issues may appear.
    (0, _warning2['default'])(insertionPoint === 'jss', '[JSS] Insertion point "%s" not found.', insertionPoint);
  }

  return null;
}

/**
 * Insert style element into the DOM.
 */
function insertStyle(style, options) {
  var insertionPoint = options.insertionPoint;

  var prevNode = findPrevNode(options);

  if (prevNode) {
    var parentNode = prevNode.parentNode;

    if (parentNode) parentNode.insertBefore(style, prevNode);
    return;
  }

  // Works with iframes and any node types.
  if (insertionPoint && typeof insertionPoint.nodeType === 'number') {
    // https://stackoverflow.com/questions/41328728/force-casting-in-flow
    var insertionPointElement = insertionPoint;
    var _parentNode = insertionPointElement.parentNode;

    if (_parentNode) _parentNode.insertBefore(style, insertionPointElement.nextSibling);else (0, _warning2['default'])(false, '[JSS] Insertion point is not in the DOM.');
    return;
  }

  getHead().insertBefore(style, prevNode);
}

var DomRenderer = function () {
  function DomRenderer(sheet) {
    _classCallCheck(this, DomRenderer);

    this.getStyle = getStyle;
    this.setStyle = setStyle;
    this.setSelector = setSelector;
    this.getKey = getKey;
    this.getUnescapedKeysMap = getUnescapedKeysMap;
    this.hasInsertedRules = false;

    // There is no sheet when the renderer is used from a standalone StyleRule.
    if (sheet) _sheets2['default'].add(sheet);

    this.sheet = sheet;

    var _ref = this.sheet ? this.sheet.options : {},
        media = _ref.media,
        meta = _ref.meta,
        element = _ref.element;

    this.element = element || document.createElement('style');
    this.element.type = 'text/css';
    this.element.setAttribute('data-jss', '');
    if (media) this.element.setAttribute('media', media);
    if (meta) this.element.setAttribute('data-meta', meta);
    // eslint-disable-next-line no-underscore-dangle
    var nonce = global.__webpack_nonce__;
    if (nonce) this.element.setAttribute('nonce', nonce);
  }

  /**
   * Insert style element into render tree.
   */


  // HTMLStyleElement needs fixing https://github.com/facebook/flow/issues/2696


  _createClass(DomRenderer, [{
    key: 'attach',
    value: function attach() {
      // In the case the element node is external and it is already in the DOM.
      if (this.element.parentNode || !this.sheet) return;

      // When rules are inserted using `insertRule` API, after `sheet.detach().attach()`
      // browsers remove those rules.
      // TODO figure out if its a bug and if it is known.
      // Workaround is to redeploy the sheet before attaching as a string.
      if (this.hasInsertedRules) {
        this.deploy();
        this.hasInsertedRules = false;
      }

      insertStyle(this.element, this.sheet.options);
    }

    /**
     * Remove style element from render tree.
     */

  }, {
    key: 'detach',
    value: function detach() {
      this.element.parentNode.removeChild(this.element);
    }

    /**
     * Inject CSS string into element.
     */

  }, {
    key: 'deploy',
    value: function deploy() {
      if (!this.sheet) return;
      this.element.textContent = '\n' + this.sheet.toString() + '\n';
    }

    /**
     * Insert a rule into element.
     */

  }, {
    key: 'insertRule',
    value: function insertRule(rule, index) {
      var sheet = this.element.sheet;
      var cssRules = sheet.cssRules;

      var str = rule.toString();
      if (!index) index = cssRules.length;

      if (!str) return false;

      try {
        sheet.insertRule(str, index);
      } catch (err) {
        (0, _warning2['default'])(false, '[JSS] Can not insert an unsupported rule \n\r%s', rule);
        return false;
      }
      this.hasInsertedRules = true;

      return cssRules[index];
    }

    /**
     * Delete a rule.
     */

  }, {
    key: 'deleteRule',
    value: function deleteRule(cssRule) {
      var sheet = this.element.sheet;

      var index = this.indexOf(cssRule);
      if (index === -1) return false;
      sheet.deleteRule(index);
      return true;
    }

    /**
     * Get index of a CSS Rule.
     */

  }, {
    key: 'indexOf',
    value: function indexOf(cssRule) {
      var cssRules = this.element.sheet.cssRules;

      for (var _index = 0; _index < cssRules.length; _index++) {
        if (cssRule === cssRules[_index]) return _index;
      }
      return -1;
    }

    /**
     * Generate a new CSS rule and replace the existing one.
     */

  }, {
    key: 'replaceRule',
    value: function replaceRule(cssRule, rule) {
      var index = this.indexOf(cssRule);
      var newCssRule = this.insertRule(rule, index);
      this.element.sheet.deleteRule(index);
      return newCssRule;
    }

    /**
     * Get all rules elements.
     */

  }, {
    key: 'getRules',
    value: function getRules() {
      return this.element.sheet.cssRules;
    }
  }]);

  return DomRenderer;
}();

exports['default'] = DomRenderer;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../rules/StyleRule":375,"../sheets":377,"../utils/toCssValue":388,"warning":394}],370:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/* eslint-disable class-methods-use-this */

/**
 * Rendering backend to do nothing in nodejs.
 */
var VirtualRenderer = function () {
  function VirtualRenderer() {
    _classCallCheck(this, VirtualRenderer);
  }

  _createClass(VirtualRenderer, [{
    key: 'setStyle',
    value: function setStyle() {
      return true;
    }
  }, {
    key: 'getStyle',
    value: function getStyle() {
      return '';
    }
  }, {
    key: 'setSelector',
    value: function setSelector() {
      return true;
    }
  }, {
    key: 'getKey',
    value: function getKey() {
      return '';
    }
  }, {
    key: 'attach',
    value: function attach() {}
  }, {
    key: 'detach',
    value: function detach() {}
  }, {
    key: 'deploy',
    value: function deploy() {}
  }, {
    key: 'insertRule',
    value: function insertRule() {
      return false;
    }
  }, {
    key: 'deleteRule',
    value: function deleteRule() {
      return true;
    }
  }, {
    key: 'replaceRule',
    value: function replaceRule() {
      return false;
    }
  }, {
    key: 'getRules',
    value: function getRules() {}
  }, {
    key: 'indexOf',
    value: function indexOf() {
      return -1;
    }
  }]);

  return VirtualRenderer;
}();

exports['default'] = VirtualRenderer;
},{}],371:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _RuleList = require('../RuleList');

var _RuleList2 = _interopRequireDefault(_RuleList);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Conditional rule for @media, @supports
 */
var ConditionalRule = function () {
  function ConditionalRule(key, styles, options) {
    _classCallCheck(this, ConditionalRule);

    this.type = 'conditional';
    this.isProcessed = false;

    this.key = key;
    this.options = options;
    this.rules = new _RuleList2['default'](_extends({}, options, { parent: this }));

    for (var name in styles) {
      this.rules.add(name, styles[name]);
    }

    this.rules.process();
  }

  /**
   * Get a rule.
   */


  _createClass(ConditionalRule, [{
    key: 'getRule',
    value: function getRule(name) {
      return this.rules.get(name);
    }

    /**
     * Get index of a rule.
     */

  }, {
    key: 'indexOf',
    value: function indexOf(rule) {
      return this.rules.indexOf(rule);
    }

    /**
     * Create and register rule, run plugins.
     */

  }, {
    key: 'addRule',
    value: function addRule(name, style, options) {
      var rule = this.rules.add(name, style, options);
      this.options.jss.plugins.onProcessRule(rule);
      return rule;
    }

    /**
     * Generates a CSS string.
     */

  }, {
    key: 'toString',
    value: function toString() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { indent: 1 };

      var inner = this.rules.toString(options);
      return inner ? this.key + ' {\n' + inner + '\n}' : '';
    }
  }]);

  return ConditionalRule;
}();

exports['default'] = ConditionalRule;
},{"../RuleList":361}],372:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _toCss = require('../utils/toCss');

var _toCss2 = _interopRequireDefault(_toCss);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var FontFaceRule = function () {
  function FontFaceRule(key, style, options) {
    _classCallCheck(this, FontFaceRule);

    this.type = 'font-face';
    this.isProcessed = false;

    this.key = key;
    this.style = style;
    this.options = options;
  }

  /**
   * Generates a CSS string.
   */


  _createClass(FontFaceRule, [{
    key: 'toString',
    value: function toString(options) {
      if (Array.isArray(this.style)) {
        var str = '';
        for (var index = 0; index < this.style.length; index++) {
          str += (0, _toCss2['default'])(this.key, this.style[index]);
          if (this.style[index + 1]) str += '\n';
        }
        return str;
      }

      return (0, _toCss2['default'])(this.key, this.style, options);
    }
  }]);

  return FontFaceRule;
}();

exports['default'] = FontFaceRule;
},{"../utils/toCss":387}],373:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _RuleList = require('../RuleList');

var _RuleList2 = _interopRequireDefault(_RuleList);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Rule for @keyframes
 */
var KeyframesRule = function () {
  function KeyframesRule(key, frames, options) {
    _classCallCheck(this, KeyframesRule);

    this.type = 'keyframes';
    this.isProcessed = false;

    this.key = key;
    this.options = options;
    this.rules = new _RuleList2['default'](_extends({}, options, { parent: this }));

    for (var name in frames) {
      this.rules.add(name, frames[name], _extends({}, this.options, {
        parent: this,
        selector: name
      }));
    }

    this.rules.process();
  }

  /**
   * Generates a CSS string.
   */


  _createClass(KeyframesRule, [{
    key: 'toString',
    value: function toString() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { indent: 1 };

      var inner = this.rules.toString(options);
      if (inner) inner += '\n';
      return this.key + ' {\n' + inner + '}';
    }
  }]);

  return KeyframesRule;
}();

exports['default'] = KeyframesRule;
},{"../RuleList":361}],374:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var SimpleRule = function () {
  function SimpleRule(key, value, options) {
    _classCallCheck(this, SimpleRule);

    this.type = 'simple';
    this.isProcessed = false;

    this.key = key;
    this.value = value;
    this.options = options;
  }

  /**
   * Generates a CSS string.
   */
  // eslint-disable-next-line no-unused-vars


  _createClass(SimpleRule, [{
    key: 'toString',
    value: function toString(options) {
      if (Array.isArray(this.value)) {
        var str = '';
        for (var index = 0; index < this.value.length; index++) {
          str += this.key + ' ' + this.value[index] + ';';
          if (this.value[index + 1]) str += '\n';
        }
        return str;
      }

      return this.key + ' ' + this.value + ';';
    }
  }]);

  return SimpleRule;
}();

exports['default'] = SimpleRule;
},{}],375:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _warning = require('warning');

var _warning2 = _interopRequireDefault(_warning);

var _toCss = require('../utils/toCss');

var _toCss2 = _interopRequireDefault(_toCss);

var _toCssValue = require('../utils/toCssValue');

var _toCssValue2 = _interopRequireDefault(_toCssValue);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var StyleRule = function () {
  function StyleRule(key, style, options) {
    _classCallCheck(this, StyleRule);

    this.type = 'style';
    this.isProcessed = false;
    var sheet = options.sheet,
        Renderer = options.Renderer,
        selector = options.selector;

    this.key = key;
    this.options = options;
    this.style = style;
    if (selector) this.selectorText = selector;
    this.renderer = sheet ? sheet.renderer : new Renderer();
  }

  /**
   * Set selector string.
   * Attention: use this with caution. Most browsers didn't implement
   * selectorText setter, so this may result in rerendering of entire Style Sheet.
   */


  _createClass(StyleRule, [{
    key: 'prop',


    /**
     * Get or set a style property.
     */
    value: function prop(name, nextValue) {
      // It's a setter.
      if (nextValue != null) {
        // Don't do anything if the value has not changed.
        if (this.style[name] !== nextValue) {
          nextValue = this.options.jss.plugins.onChangeValue(nextValue, name, this);
          this.style[name] = nextValue;

          // Renderable is defined if StyleSheet option `link` is true.
          if (this.renderable) this.renderer.setStyle(this.renderable, name, nextValue);else {
            var sheet = this.options.sheet;

            if (sheet && sheet.attached) {
              (0, _warning2['default'])(false, 'Rule is not linked. Missing sheet option "link: true".');
            }
          }
        }
        return this;
      }

      return this.style[name];
    }

    /**
     * Apply rule to an element inline.
     */

  }, {
    key: 'applyTo',
    value: function applyTo(renderable) {
      var json = this.toJSON();
      for (var prop in json) {
        this.renderer.setStyle(renderable, prop, json[prop]);
      }return this;
    }

    /**
     * Returns JSON representation of the rule.
     * Fallbacks are not supported.
     * Useful for inline styles.
     */

  }, {
    key: 'toJSON',
    value: function toJSON() {
      var json = {};
      for (var prop in this.style) {
        var value = this.style[prop];
        if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) !== 'object') json[prop] = value;else if (Array.isArray(value)) json[prop] = (0, _toCssValue2['default'])(value);
      }
      return json;
    }

    /**
     * Generates a CSS string.
     */

  }, {
    key: 'toString',
    value: function toString(options) {
      var sheet = this.options.sheet;

      var link = sheet ? sheet.options.link : false;
      var opts = link ? _extends({}, options, { allowEmpty: true }) : options;
      return (0, _toCss2['default'])(this.selector, this.style, opts);
    }
  }, {
    key: 'selector',
    set: function set(selector) {
      if (selector === this.selectorText) return;

      this.selectorText = selector;

      if (this.renderable) {
        var hasChanged = this.renderer.setSelector(this.renderable, selector);

        // If selector setter is not implemented, rerender the rule.
        if (!hasChanged && this.renderable) {
          var renderable = this.renderer.replaceRule(this.renderable, this);
          if (renderable) this.renderable = renderable;
        }
      }
    }

    /**
     * Get selector string.
     */
    ,
    get: function get() {
      return this.selectorText;
    }
  }]);

  return StyleRule;
}();

exports['default'] = StyleRule;
},{"../utils/toCss":387,"../utils/toCssValue":388,"warning":394}],376:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _toCss = require('../utils/toCss');

var _toCss2 = _interopRequireDefault(_toCss);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ViewportRule = function () {
  function ViewportRule(key, style, options) {
    _classCallCheck(this, ViewportRule);

    this.type = 'viewport';
    this.isProcessed = false;

    this.key = key;
    this.style = style;
    this.options = options;
  }

  /**
   * Generates a CSS string.
   */


  _createClass(ViewportRule, [{
    key: 'toString',
    value: function toString(options) {
      return (0, _toCss2['default'])(this.key, this.style, options);
    }
  }]);

  return ViewportRule;
}();

exports['default'] = ViewportRule;
},{"../utils/toCss":387}],377:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _SheetsRegistry = require('./SheetsRegistry');

var _SheetsRegistry2 = _interopRequireDefault(_SheetsRegistry);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/**
 * This is a global sheets registry. Only DomRenderer will add sheets to it.
 * On the server one should use an own SheetsRegistry instance and add the
 * sheets to it, because you need to make sure to create a new registry for
 * each request in order to not leak sheets across requests.
 */
exports['default'] = new _SheetsRegistry2['default']();
},{"./SheetsRegistry":363}],378:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports['default'] = cloneStyle;

var _isObservable = require('./isObservable');

var _isObservable2 = _interopRequireDefault(_isObservable);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var isArray = Array.isArray;
function cloneStyle(style) {
  // Support empty values in case user ends up with them by accident.
  if (style == null) return style;

  // Support string value for SimpleRule.
  var typeOfStyle = typeof style === 'undefined' ? 'undefined' : _typeof(style);

  if (typeOfStyle === 'string' || typeOfStyle === 'number' || typeOfStyle === 'function') {
    return style;
  }

  // Support array for FontFaceRule.
  if (isArray(style)) return style.map(cloneStyle);

  // Support Observable styles.  Observables are immutable, so we don't need to
  // copy them.
  if ((0, _isObservable2['default'])(style)) return style;

  var newStyle = {};
  for (var name in style) {
    var value = style[name];
    if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {
      newStyle[name] = cloneStyle(value);
      continue;
    }
    newStyle[name] = value;
  }

  return newStyle;
}
},{"./isObservable":383}],379:[function(require,module,exports){
(function (process){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _warning = require('warning');

var _warning2 = _interopRequireDefault(_warning);

var _StyleSheet = require('../StyleSheet');

var _StyleSheet2 = _interopRequireDefault(_StyleSheet);

var _moduleId = require('./moduleId');

var _moduleId2 = _interopRequireDefault(_moduleId);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var maxRules = 1e10;


var env = process.env.NODE_ENV;

/**
 * Returns a function which generates unique class names based on counters.
 * When new generator function is created, rule counter is reseted.
 * We need to reset the rule counter for SSR for each request.
 */

exports['default'] = function () {
  var ruleCounter = 0;
  var defaultPrefix = env === 'production' ? 'c' : '';

  return function (rule, sheet) {
    ruleCounter += 1;

    if (ruleCounter > maxRules) {
      (0, _warning2['default'])(false, '[JSS] You might have a memory leak. Rule counter is at %s.', ruleCounter);
    }

    var prefix = defaultPrefix;
    var jssId = '';

    if (sheet) {
      prefix = sheet.options.classNamePrefix || defaultPrefix;
      if (sheet.options.jss.id != null) jssId += sheet.options.jss.id;
    }

    if (env === 'production') {
      return '' + prefix + _moduleId2['default'] + jssId + ruleCounter;
    }

    return prefix + rule.key + '-' + _moduleId2['default'] + (jssId && '-' + jssId) + '-' + ruleCounter;
  };
};
}).call(this,require('_process'))

},{"../StyleSheet":364,"./moduleId":386,"_process":390,"warning":394}],380:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports['default'] = createRule;

var _warning = require('warning');

var _warning2 = _interopRequireDefault(_warning);

var _StyleRule = require('../rules/StyleRule');

var _StyleRule2 = _interopRequireDefault(_StyleRule);

var _cloneStyle = require('../utils/cloneStyle');

var _cloneStyle2 = _interopRequireDefault(_cloneStyle);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/**
 * Create a rule instance.
 */
function createRule() {
  var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'unnamed';
  var decl = arguments[1];
  var options = arguments[2];
  var jss = options.jss;

  var declCopy = (0, _cloneStyle2['default'])(decl);

  var rule = jss.plugins.onCreateRule(name, declCopy, options);
  if (rule) return rule;

  // It is an at-rule and it has no instance.
  if (name[0] === '@') {
    (0, _warning2['default'])(false, '[JSS] Unknown at-rule %s', name);
  }

  return new _StyleRule2['default'](name, declCopy, options);
}
},{"../rules/StyleRule":375,"../utils/cloneStyle":378,"warning":394}],381:[function(require,module,exports){
(function (process,global){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var CSS = global.CSS;

var env = process.env.NODE_ENV;

var escapeRegex = /([[\].#*$><+~=|^:(),"'`])/g;

exports['default'] = function (str) {
  // We don't need to escape it in production, because we are not using user's
  // input for selectors, we are generating a valid selector.
  if (env === 'production') return str;

  if (!CSS || !CSS.escape) {
    return str.replace(escapeRegex, '\\$1');
  }

  return CSS.escape(str);
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"_process":390}],382:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
 * Extracts a styles object with only props that contain function values.
 */
exports['default'] = function (styles) {
  // eslint-disable-next-line no-shadow
  function extract(styles) {
    var to = null;

    for (var key in styles) {
      var value = styles[key];
      var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);

      if (type === 'function') {
        if (!to) to = {};
        to[key] = value;
      } else if (type === 'object' && value !== null && !Array.isArray(value)) {
        var extracted = extract(value);
        if (extracted) {
          if (!to) to = {};
          to[key] = extracted;
        }
      }
    }

    return to;
  }

  return extract(styles);
};
},{}],383:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _symbolObservable = require('symbol-observable');

var _symbolObservable2 = _interopRequireDefault(_symbolObservable);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

exports['default'] = function (value) {
  return value && value[_symbolObservable2['default']] && value === value[_symbolObservable2['default']]();
};
},{"symbol-observable":391}],384:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var regExp = /([A-Z])/g;
var replace = function replace(str) {
  return "-" + str.toLowerCase();
};

exports["default"] = function (str) {
  return str.replace(regExp, replace);
};
},{}],385:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = linkRule;
/**
 * Link rule with CSSStyleRule and nested rules with corresponding nested cssRules if both exists.
 */
function linkRule(rule, cssRule) {
  rule.renderable = cssRule;
  if (rule.rules && cssRule.cssRules) rule.rules.link(cssRule.cssRules);
}
},{}],386:[function(require,module,exports){
(function (global){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var ns = '2f1acc6c3a606b082e5eef5e54414ffb';
if (global[ns] == null) global[ns] = 0;

// Bundle may contain multiple JSS versions at the same time. In order to identify
// the current version with just one short number and use it for classes generation
// we use a counter. Also it is more accurate, because user can manually reevaluate
// the module.
exports['default'] = global[ns]++;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],387:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports['default'] = toCss;

var _toCssValue = require('./toCssValue');

var _toCssValue2 = _interopRequireDefault(_toCssValue);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/**
 * Indent a string.
 * http://jsperf.com/array-join-vs-for
 */
function indentStr(str, indent) {
  var result = '';
  for (var index = 0; index < indent; index++) {
    result += '  ';
  }return result + str;
}

/**
 * Converts a Rule to CSS string.
 */

function toCss(selector, style) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  var result = '';

  if (!style) return result;

  var _options$indent = options.indent,
      indent = _options$indent === undefined ? 0 : _options$indent;
  var fallbacks = style.fallbacks;


  indent++;

  // Apply fallbacks first.
  if (fallbacks) {
    // Array syntax {fallbacks: [{prop: value}]}
    if (Array.isArray(fallbacks)) {
      for (var index = 0; index < fallbacks.length; index++) {
        var fallback = fallbacks[index];
        for (var prop in fallback) {
          var value = fallback[prop];
          if (value != null) {
            result += '\n' + indentStr(prop + ': ' + (0, _toCssValue2['default'])(value) + ';', indent);
          }
        }
      }
    }
    // Object syntax {fallbacks: {prop: value}}
    else {
        for (var _prop in fallbacks) {
          var _value = fallbacks[_prop];
          if (_value != null) {
            result += '\n' + indentStr(_prop + ': ' + (0, _toCssValue2['default'])(_value) + ';', indent);
          }
        }
      }
  }

  for (var _prop2 in style) {
    var _value2 = style[_prop2];
    if (_value2 != null && _prop2 !== 'fallbacks') {
      result += '\n' + indentStr(_prop2 + ': ' + (0, _toCssValue2['default'])(_value2) + ';', indent);
    }
  }

  // Allow empty style in this case, because properties will be added dynamically.
  if (!result && !options.allowEmpty) return result;

  indent--;
  result = indentStr(selector + ' {' + result + '\n', indent) + indentStr('}', indent);

  return result;
}
},{"./toCssValue":388}],388:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports['default'] = toCssValue;
var join = function join(value, by) {
  var result = '';
  for (var i = 0; i < value.length; i++) {
    // Remove !important from the value, it will be readded later.
    if (value[i] === '!important') break;
    if (result) result += by;
    result += value[i];
  }
  return result;
};

/**
 * Converts array values to string.
 *
 * `margin: [['5px', '10px']]` > `margin: 5px 10px;`
 * `border: ['1px', '2px']` > `border: 1px, 2px;`
 * `margin: [['5px', '10px'], '!important']` > `margin: 5px 10px !important;`
 * `color: ['red', !important]` > `color: red !important;`
 */
function toCssValue(value) {
  var ignoreImportant = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  if (!Array.isArray(value)) return value;

  var cssValue = '';

  // Support space separated values via `[['5px', '10px']]`.
  if (Array.isArray(value[0])) {
    for (var i = 0; i < value.length; i++) {
      if (value[i] === '!important') break;
      if (cssValue) cssValue += ', ';
      cssValue += join(value[i], ' ');
    }
  } else cssValue = join(value, ', ');

  // Add !important, because it was ignored.
  if (!ignoreImportant && value[value.length - 1] === '!important') {
    cssValue += ' !important';
  }

  return cssValue;
}
},{}],389:[function(require,module,exports){
//! moment.js
//! version : 2.20.1
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com

;(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    global.moment = factory()
}(this, (function () { 'use strict';

var hookCallback;

function hooks () {
    return hookCallback.apply(null, arguments);
}

// This is done to register the method called with moment()
// without creating circular dependencies.
function setHookCallback (callback) {
    hookCallback = callback;
}

function isArray(input) {
    return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
}

function isObject(input) {
    // IE8 will treat undefined and null as object if it wasn't for
    // input != null
    return input != null && Object.prototype.toString.call(input) === '[object Object]';
}

function isObjectEmpty(obj) {
    if (Object.getOwnPropertyNames) {
        return (Object.getOwnPropertyNames(obj).length === 0);
    } else {
        var k;
        for (k in obj) {
            if (obj.hasOwnProperty(k)) {
                return false;
            }
        }
        return true;
    }
}

function isUndefined(input) {
    return input === void 0;
}

function isNumber(input) {
    return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';
}

function isDate(input) {
    return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
}

function map(arr, fn) {
    var res = [], i;
    for (i = 0; i < arr.length; ++i) {
        res.push(fn(arr[i], i));
    }
    return res;
}

function hasOwnProp(a, b) {
    return Object.prototype.hasOwnProperty.call(a, b);
}

function extend(a, b) {
    for (var i in b) {
        if (hasOwnProp(b, i)) {
            a[i] = b[i];
        }
    }

    if (hasOwnProp(b, 'toString')) {
        a.toString = b.toString;
    }

    if (hasOwnProp(b, 'valueOf')) {
        a.valueOf = b.valueOf;
    }

    return a;
}

function createUTC (input, format, locale, strict) {
    return createLocalOrUTC(input, format, locale, strict, true).utc();
}

function defaultParsingFlags() {
    // We need to deep clone this object.
    return {
        empty           : false,
        unusedTokens    : [],
        unusedInput     : [],
        overflow        : -2,
        charsLeftOver   : 0,
        nullInput       : false,
        invalidMonth    : null,
        invalidFormat   : false,
        userInvalidated : false,
        iso             : false,
        parsedDateParts : [],
        meridiem        : null,
        rfc2822         : false,
        weekdayMismatch : false
    };
}

function getParsingFlags(m) {
    if (m._pf == null) {
        m._pf = defaultParsingFlags();
    }
    return m._pf;
}

var some;
if (Array.prototype.some) {
    some = Array.prototype.some;
} else {
    some = function (fun) {
        var t = Object(this);
        var len = t.length >>> 0;

        for (var i = 0; i < len; i++) {
            if (i in t && fun.call(this, t[i], i, t)) {
                return true;
            }
        }

        return false;
    };
}

function isValid(m) {
    if (m._isValid == null) {
        var flags = getParsingFlags(m);
        var parsedParts = some.call(flags.parsedDateParts, function (i) {
            return i != null;
        });
        var isNowValid = !isNaN(m._d.getTime()) &&
            flags.overflow < 0 &&
            !flags.empty &&
            !flags.invalidMonth &&
            !flags.invalidWeekday &&
            !flags.weekdayMismatch &&
            !flags.nullInput &&
            !flags.invalidFormat &&
            !flags.userInvalidated &&
            (!flags.meridiem || (flags.meridiem && parsedParts));

        if (m._strict) {
            isNowValid = isNowValid &&
                flags.charsLeftOver === 0 &&
                flags.unusedTokens.length === 0 &&
                flags.bigHour === undefined;
        }

        if (Object.isFrozen == null || !Object.isFrozen(m)) {
            m._isValid = isNowValid;
        }
        else {
            return isNowValid;
        }
    }
    return m._isValid;
}

function createInvalid (flags) {
    var m = createUTC(NaN);
    if (flags != null) {
        extend(getParsingFlags(m), flags);
    }
    else {
        getParsingFlags(m).userInvalidated = true;
    }

    return m;
}

// Plugins that add properties should also add the key here (null value),
// so we can properly clone ourselves.
var momentProperties = hooks.momentProperties = [];

function copyConfig(to, from) {
    var i, prop, val;

    if (!isUndefined(from._isAMomentObject)) {
        to._isAMomentObject = from._isAMomentObject;
    }
    if (!isUndefined(from._i)) {
        to._i = from._i;
    }
    if (!isUndefined(from._f)) {
        to._f = from._f;
    }
    if (!isUndefined(from._l)) {
        to._l = from._l;
    }
    if (!isUndefined(from._strict)) {
        to._strict = from._strict;
    }
    if (!isUndefined(from._tzm)) {
        to._tzm = from._tzm;
    }
    if (!isUndefined(from._isUTC)) {
        to._isUTC = from._isUTC;
    }
    if (!isUndefined(from._offset)) {
        to._offset = from._offset;
    }
    if (!isUndefined(from._pf)) {
        to._pf = getParsingFlags(from);
    }
    if (!isUndefined(from._locale)) {
        to._locale = from._locale;
    }

    if (momentProperties.length > 0) {
        for (i = 0; i < momentProperties.length; i++) {
            prop = momentProperties[i];
            val = from[prop];
            if (!isUndefined(val)) {
                to[prop] = val;
            }
        }
    }

    return to;
}

var updateInProgress = false;

// Moment prototype object
function Moment(config) {
    copyConfig(this, config);
    this._d = new Date(config._d != null ? config._d.getTime() : NaN);
    if (!this.isValid()) {
        this._d = new Date(NaN);
    }
    // Prevent infinite loop in case updateOffset creates new moment
    // objects.
    if (updateInProgress === false) {
        updateInProgress = true;
        hooks.updateOffset(this);
        updateInProgress = false;
    }
}

function isMoment (obj) {
    return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
}

function absFloor (number) {
    if (number < 0) {
        // -0 -> 0
        return Math.ceil(number) || 0;
    } else {
        return Math.floor(number);
    }
}

function toInt(argumentForCoercion) {
    var coercedNumber = +argumentForCoercion,
        value = 0;

    if (coercedNumber !== 0 && isFinite(coercedNumber)) {
        value = absFloor(coercedNumber);
    }

    return value;
}

// compare two arrays, return the number of differences
function compareArrays(array1, array2, dontConvert) {
    var len = Math.min(array1.length, array2.length),
        lengthDiff = Math.abs(array1.length - array2.length),
        diffs = 0,
        i;
    for (i = 0; i < len; i++) {
        if ((dontConvert && array1[i] !== array2[i]) ||
            (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
            diffs++;
        }
    }
    return diffs + lengthDiff;
}

function warn(msg) {
    if (hooks.suppressDeprecationWarnings === false &&
            (typeof console !==  'undefined') && console.warn) {
        console.warn('Deprecation warning: ' + msg);
    }
}

function deprecate(msg, fn) {
    var firstTime = true;

    return extend(function () {
        if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(null, msg);
        }
        if (firstTime) {
            var args = [];
            var arg;
            for (var i = 0; i < arguments.length; i++) {
                arg = '';
                if (typeof arguments[i] === 'object') {
                    arg += '\n[' + i + '] ';
                    for (var key in arguments[0]) {
                        arg += key + ': ' + arguments[0][key] + ', ';
                    }
                    arg = arg.slice(0, -2); // Remove trailing comma and space
                } else {
                    arg = arguments[i];
                }
                args.push(arg);
            }
            warn(msg + '\nArguments: ' + Array.prototype.slice.call(args).join('') + '\n' + (new Error()).stack);
            firstTime = false;
        }
        return fn.apply(this, arguments);
    }, fn);
}

var deprecations = {};

function deprecateSimple(name, msg) {
    if (hooks.deprecationHandler != null) {
        hooks.deprecationHandler(name, msg);
    }
    if (!deprecations[name]) {
        warn(msg);
        deprecations[name] = true;
    }
}

hooks.suppressDeprecationWarnings = false;
hooks.deprecationHandler = null;

function isFunction(input) {
    return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
}

function set (config) {
    var prop, i;
    for (i in config) {
        prop = config[i];
        if (isFunction(prop)) {
            this[i] = prop;
        } else {
            this['_' + i] = prop;
        }
    }
    this._config = config;
    // Lenient ordinal parsing accepts just a number in addition to
    // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
    // TODO: Remove "ordinalParse" fallback in next major release.
    this._dayOfMonthOrdinalParseLenient = new RegExp(
        (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +
            '|' + (/\d{1,2}/).source);
}

function mergeConfigs(parentConfig, childConfig) {
    var res = extend({}, parentConfig), prop;
    for (prop in childConfig) {
        if (hasOwnProp(childConfig, prop)) {
            if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
                res[prop] = {};
                extend(res[prop], parentConfig[prop]);
                extend(res[prop], childConfig[prop]);
            } else if (childConfig[prop] != null) {
                res[prop] = childConfig[prop];
            } else {
                delete res[prop];
            }
        }
    }
    for (prop in parentConfig) {
        if (hasOwnProp(parentConfig, prop) &&
                !hasOwnProp(childConfig, prop) &&
                isObject(parentConfig[prop])) {
            // make sure changes to properties don't modify parent config
            res[prop] = extend({}, res[prop]);
        }
    }
    return res;
}

function Locale(config) {
    if (config != null) {
        this.set(config);
    }
}

var keys;

if (Object.keys) {
    keys = Object.keys;
} else {
    keys = function (obj) {
        var i, res = [];
        for (i in obj) {
            if (hasOwnProp(obj, i)) {
                res.push(i);
            }
        }
        return res;
    };
}

var defaultCalendar = {
    sameDay : '[Today at] LT',
    nextDay : '[Tomorrow at] LT',
    nextWeek : 'dddd [at] LT',
    lastDay : '[Yesterday at] LT',
    lastWeek : '[Last] dddd [at] LT',
    sameElse : 'L'
};

function calendar (key, mom, now) {
    var output = this._calendar[key] || this._calendar['sameElse'];
    return isFunction(output) ? output.call(mom, now) : output;
}

var defaultLongDateFormat = {
    LTS  : 'h:mm:ss A',
    LT   : 'h:mm A',
    L    : 'MM/DD/YYYY',
    LL   : 'MMMM D, YYYY',
    LLL  : 'MMMM D, YYYY h:mm A',
    LLLL : 'dddd, MMMM D, YYYY h:mm A'
};

function longDateFormat (key) {
    var format = this._longDateFormat[key],
        formatUpper = this._longDateFormat[key.toUpperCase()];

    if (format || !formatUpper) {
        return format;
    }

    this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
        return val.slice(1);
    });

    return this._longDateFormat[key];
}

var defaultInvalidDate = 'Invalid date';

function invalidDate () {
    return this._invalidDate;
}

var defaultOrdinal = '%d';
var defaultDayOfMonthOrdinalParse = /\d{1,2}/;

function ordinal (number) {
    return this._ordinal.replace('%d', number);
}

var defaultRelativeTime = {
    future : 'in %s',
    past   : '%s ago',
    s  : 'a few seconds',
    ss : '%d seconds',
    m  : 'a minute',
    mm : '%d minutes',
    h  : 'an hour',
    hh : '%d hours',
    d  : 'a day',
    dd : '%d days',
    M  : 'a month',
    MM : '%d months',
    y  : 'a year',
    yy : '%d years'
};

function relativeTime (number, withoutSuffix, string, isFuture) {
    var output = this._relativeTime[string];
    return (isFunction(output)) ?
        output(number, withoutSuffix, string, isFuture) :
        output.replace(/%d/i, number);
}

function pastFuture (diff, output) {
    var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
    return isFunction(format) ? format(output) : format.replace(/%s/i, output);
}

var aliases = {};

function addUnitAlias (unit, shorthand) {
    var lowerCase = unit.toLowerCase();
    aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
}

function normalizeUnits(units) {
    return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
}

function normalizeObjectUnits(inputObject) {
    var normalizedInput = {},
        normalizedProp,
        prop;

    for (prop in inputObject) {
        if (hasOwnProp(inputObject, prop)) {
            normalizedProp = normalizeUnits(prop);
            if (normalizedProp) {
                normalizedInput[normalizedProp] = inputObject[prop];
            }
        }
    }

    return normalizedInput;
}

var priorities = {};

function addUnitPriority(unit, priority) {
    priorities[unit] = priority;
}

function getPrioritizedUnits(unitsObj) {
    var units = [];
    for (var u in unitsObj) {
        units.push({unit: u, priority: priorities[u]});
    }
    units.sort(function (a, b) {
        return a.priority - b.priority;
    });
    return units;
}

function zeroFill(number, targetLength, forceSign) {
    var absNumber = '' + Math.abs(number),
        zerosToFill = targetLength - absNumber.length,
        sign = number >= 0;
    return (sign ? (forceSign ? '+' : '') : '-') +
        Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
}

var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;

var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;

var formatFunctions = {};

var formatTokenFunctions = {};

// token:    'M'
// padded:   ['MM', 2]
// ordinal:  'Mo'
// callback: function () { this.month() + 1 }
function addFormatToken (token, padded, ordinal, callback) {
    var func = callback;
    if (typeof callback === 'string') {
        func = function () {
            return this[callback]();
        };
    }
    if (token) {
        formatTokenFunctions[token] = func;
    }
    if (padded) {
        formatTokenFunctions[padded[0]] = function () {
            return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
        };
    }
    if (ordinal) {
        formatTokenFunctions[ordinal] = function () {
            return this.localeData().ordinal(func.apply(this, arguments), token);
        };
    }
}

function removeFormattingTokens(input) {
    if (input.match(/\[[\s\S]/)) {
        return input.replace(/^\[|\]$/g, '');
    }
    return input.replace(/\\/g, '');
}

function makeFormatFunction(format) {
    var array = format.match(formattingTokens), i, length;

    for (i = 0, length = array.length; i < length; i++) {
        if (formatTokenFunctions[array[i]]) {
            array[i] = formatTokenFunctions[array[i]];
        } else {
            array[i] = removeFormattingTokens(array[i]);
        }
    }

    return function (mom) {
        var output = '', i;
        for (i = 0; i < length; i++) {
            output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];
        }
        return output;
    };
}

// format date using native date object
function formatMoment(m, format) {
    if (!m.isValid()) {
        return m.localeData().invalidDate();
    }

    format = expandFormat(format, m.localeData());
    formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);

    return formatFunctions[format](m);
}

function expandFormat(format, locale) {
    var i = 5;

    function replaceLongDateFormatTokens(input) {
        return locale.longDateFormat(input) || input;
    }

    localFormattingTokens.lastIndex = 0;
    while (i >= 0 && localFormattingTokens.test(format)) {
        format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
        localFormattingTokens.lastIndex = 0;
        i -= 1;
    }

    return format;
}

var match1         = /\d/;            //       0 - 9
var match2         = /\d\d/;          //      00 - 99
var match3         = /\d{3}/;         //     000 - 999
var match4         = /\d{4}/;         //    0000 - 9999
var match6         = /[+-]?\d{6}/;    // -999999 - 999999
var match1to2      = /\d\d?/;         //       0 - 99
var match3to4      = /\d\d\d\d?/;     //     999 - 9999
var match5to6      = /\d\d\d\d\d\d?/; //   99999 - 999999
var match1to3      = /\d{1,3}/;       //       0 - 999
var match1to4      = /\d{1,4}/;       //       0 - 9999
var match1to6      = /[+-]?\d{1,6}/;  // -999999 - 999999

var matchUnsigned  = /\d+/;           //       0 - inf
var matchSigned    = /[+-]?\d+/;      //    -inf - inf

var matchOffset    = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z
var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z

var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123

// any word (or two) characters or numbers including two/three word month in arabic.
// includes scottish gaelic two word and hyphenated months
var matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i;


var regexes = {};

function addRegexToken (token, regex, strictRegex) {
    regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
        return (isStrict && strictRegex) ? strictRegex : regex;
    };
}

function getParseRegexForToken (token, config) {
    if (!hasOwnProp(regexes, token)) {
        return new RegExp(unescapeFormat(token));
    }

    return regexes[token](config._strict, config._locale);
}

// Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
function unescapeFormat(s) {
    return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
        return p1 || p2 || p3 || p4;
    }));
}

function regexEscape(s) {
    return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
}

var tokens = {};

function addParseToken (token, callback) {
    var i, func = callback;
    if (typeof token === 'string') {
        token = [token];
    }
    if (isNumber(callback)) {
        func = function (input, array) {
            array[callback] = toInt(input);
        };
    }
    for (i = 0; i < token.length; i++) {
        tokens[token[i]] = func;
    }
}

function addWeekParseToken (token, callback) {
    addParseToken(token, function (input, array, config, token) {
        config._w = config._w || {};
        callback(input, config._w, config, token);
    });
}

function addTimeToArrayFromToken(token, input, config) {
    if (input != null && hasOwnProp(tokens, token)) {
        tokens[token](input, config._a, config, token);
    }
}

var YEAR = 0;
var MONTH = 1;
var DATE = 2;
var HOUR = 3;
var MINUTE = 4;
var SECOND = 5;
var MILLISECOND = 6;
var WEEK = 7;
var WEEKDAY = 8;

// FORMATTING

addFormatToken('Y', 0, 0, function () {
    var y = this.year();
    return y <= 9999 ? '' + y : '+' + y;
});

addFormatToken(0, ['YY', 2], 0, function () {
    return this.year() % 100;
});

addFormatToken(0, ['YYYY',   4],       0, 'year');
addFormatToken(0, ['YYYYY',  5],       0, 'year');
addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

// ALIASES

addUnitAlias('year', 'y');

// PRIORITIES

addUnitPriority('year', 1);

// PARSING

addRegexToken('Y',      matchSigned);
addRegexToken('YY',     match1to2, match2);
addRegexToken('YYYY',   match1to4, match4);
addRegexToken('YYYYY',  match1to6, match6);
addRegexToken('YYYYYY', match1to6, match6);

addParseToken(['YYYYY', 'YYYYYY'], YEAR);
addParseToken('YYYY', function (input, array) {
    array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
});
addParseToken('YY', function (input, array) {
    array[YEAR] = hooks.parseTwoDigitYear(input);
});
addParseToken('Y', function (input, array) {
    array[YEAR] = parseInt(input, 10);
});

// HELPERS

function daysInYear(year) {
    return isLeapYear(year) ? 366 : 365;
}

function isLeapYear(year) {
    return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
}

// HOOKS

hooks.parseTwoDigitYear = function (input) {
    return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
};

// MOMENTS

var getSetYear = makeGetSet('FullYear', true);

function getIsLeapYear () {
    return isLeapYear(this.year());
}

function makeGetSet (unit, keepTime) {
    return function (value) {
        if (value != null) {
            set$1(this, unit, value);
            hooks.updateOffset(this, keepTime);
            return this;
        } else {
            return get(this, unit);
        }
    };
}

function get (mom, unit) {
    return mom.isValid() ?
        mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
}

function set$1 (mom, unit, value) {
    if (mom.isValid() && !isNaN(value)) {
        if (unit === 'FullYear' && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
            mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value, mom.month(), daysInMonth(value, mom.month()));
        }
        else {
            mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
        }
    }
}

// MOMENTS

function stringGet (units) {
    units = normalizeUnits(units);
    if (isFunction(this[units])) {
        return this[units]();
    }
    return this;
}


function stringSet (units, value) {
    if (typeof units === 'object') {
        units = normalizeObjectUnits(units);
        var prioritized = getPrioritizedUnits(units);
        for (var i = 0; i < prioritized.length; i++) {
            this[prioritized[i].unit](units[prioritized[i].unit]);
        }
    } else {
        units = normalizeUnits(units);
        if (isFunction(this[units])) {
            return this[units](value);
        }
    }
    return this;
}

function mod(n, x) {
    return ((n % x) + x) % x;
}

var indexOf;

if (Array.prototype.indexOf) {
    indexOf = Array.prototype.indexOf;
} else {
    indexOf = function (o) {
        // I know
        var i;
        for (i = 0; i < this.length; ++i) {
            if (this[i] === o) {
                return i;
            }
        }
        return -1;
    };
}

function daysInMonth(year, month) {
    if (isNaN(year) || isNaN(month)) {
        return NaN;
    }
    var modMonth = mod(month, 12);
    year += (month - modMonth) / 12;
    return modMonth === 1 ? (isLeapYear(year) ? 29 : 28) : (31 - modMonth % 7 % 2);
}

// FORMATTING

addFormatToken('M', ['MM', 2], 'Mo', function () {
    return this.month() + 1;
});

addFormatToken('MMM', 0, 0, function (format) {
    return this.localeData().monthsShort(this, format);
});

addFormatToken('MMMM', 0, 0, function (format) {
    return this.localeData().months(this, format);
});

// ALIASES

addUnitAlias('month', 'M');

// PRIORITY

addUnitPriority('month', 8);

// PARSING

addRegexToken('M',    match1to2);
addRegexToken('MM',   match1to2, match2);
addRegexToken('MMM',  function (isStrict, locale) {
    return locale.monthsShortRegex(isStrict);
});
addRegexToken('MMMM', function (isStrict, locale) {
    return locale.monthsRegex(isStrict);
});

addParseToken(['M', 'MM'], function (input, array) {
    array[MONTH] = toInt(input) - 1;
});

addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
    var month = config._locale.monthsParse(input, token, config._strict);
    // if we didn't find a month name, mark the date as invalid.
    if (month != null) {
        array[MONTH] = month;
    } else {
        getParsingFlags(config).invalidMonth = input;
    }
});

// LOCALES

var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
function localeMonths (m, format) {
    if (!m) {
        return isArray(this._months) ? this._months :
            this._months['standalone'];
    }
    return isArray(this._months) ? this._months[m.month()] :
        this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
}

var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
function localeMonthsShort (m, format) {
    if (!m) {
        return isArray(this._monthsShort) ? this._monthsShort :
            this._monthsShort['standalone'];
    }
    return isArray(this._monthsShort) ? this._monthsShort[m.month()] :
        this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
}

function handleStrictParse(monthName, format, strict) {
    var i, ii, mom, llc = monthName.toLocaleLowerCase();
    if (!this._monthsParse) {
        // this is not used
        this._monthsParse = [];
        this._longMonthsParse = [];
        this._shortMonthsParse = [];
        for (i = 0; i < 12; ++i) {
            mom = createUTC([2000, i]);
            this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
            this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
        }
    }

    if (strict) {
        if (format === 'MMM') {
            ii = indexOf.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
        } else {
            ii = indexOf.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
        }
    } else {
        if (format === 'MMM') {
            ii = indexOf.call(this._shortMonthsParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
        } else {
            ii = indexOf.call(this._longMonthsParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
        }
    }
}

function localeMonthsParse (monthName, format, strict) {
    var i, mom, regex;

    if (this._monthsParseExact) {
        return handleStrictParse.call(this, monthName, format, strict);
    }

    if (!this._monthsParse) {
        this._monthsParse = [];
        this._longMonthsParse = [];
        this._shortMonthsParse = [];
    }

    // TODO: add sorting
    // Sorting makes sure if one month (or abbr) is a prefix of another
    // see sorting in computeMonthsParse
    for (i = 0; i < 12; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, i]);
        if (strict && !this._longMonthsParse[i]) {
            this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
            this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
        }
        if (!strict && !this._monthsParse[i]) {
            regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
            this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
        }
        // test the regex
        if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
            return i;
        } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
            return i;
        } else if (!strict && this._monthsParse[i].test(monthName)) {
            return i;
        }
    }
}

// MOMENTS

function setMonth (mom, value) {
    var dayOfMonth;

    if (!mom.isValid()) {
        // No op
        return mom;
    }

    if (typeof value === 'string') {
        if (/^\d+$/.test(value)) {
            value = toInt(value);
        } else {
            value = mom.localeData().monthsParse(value);
            // TODO: Another silent failure?
            if (!isNumber(value)) {
                return mom;
            }
        }
    }

    dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
    mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
    return mom;
}

function getSetMonth (value) {
    if (value != null) {
        setMonth(this, value);
        hooks.updateOffset(this, true);
        return this;
    } else {
        return get(this, 'Month');
    }
}

function getDaysInMonth () {
    return daysInMonth(this.year(), this.month());
}

var defaultMonthsShortRegex = matchWord;
function monthsShortRegex (isStrict) {
    if (this._monthsParseExact) {
        if (!hasOwnProp(this, '_monthsRegex')) {
            computeMonthsParse.call(this);
        }
        if (isStrict) {
            return this._monthsShortStrictRegex;
        } else {
            return this._monthsShortRegex;
        }
    } else {
        if (!hasOwnProp(this, '_monthsShortRegex')) {
            this._monthsShortRegex = defaultMonthsShortRegex;
        }
        return this._monthsShortStrictRegex && isStrict ?
            this._monthsShortStrictRegex : this._monthsShortRegex;
    }
}

var defaultMonthsRegex = matchWord;
function monthsRegex (isStrict) {
    if (this._monthsParseExact) {
        if (!hasOwnProp(this, '_monthsRegex')) {
            computeMonthsParse.call(this);
        }
        if (isStrict) {
            return this._monthsStrictRegex;
        } else {
            return this._monthsRegex;
        }
    } else {
        if (!hasOwnProp(this, '_monthsRegex')) {
            this._monthsRegex = defaultMonthsRegex;
        }
        return this._monthsStrictRegex && isStrict ?
            this._monthsStrictRegex : this._monthsRegex;
    }
}

function computeMonthsParse () {
    function cmpLenRev(a, b) {
        return b.length - a.length;
    }

    var shortPieces = [], longPieces = [], mixedPieces = [],
        i, mom;
    for (i = 0; i < 12; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, i]);
        shortPieces.push(this.monthsShort(mom, ''));
        longPieces.push(this.months(mom, ''));
        mixedPieces.push(this.months(mom, ''));
        mixedPieces.push(this.monthsShort(mom, ''));
    }
    // Sorting makes sure if one month (or abbr) is a prefix of another it
    // will match the longer piece.
    shortPieces.sort(cmpLenRev);
    longPieces.sort(cmpLenRev);
    mixedPieces.sort(cmpLenRev);
    for (i = 0; i < 12; i++) {
        shortPieces[i] = regexEscape(shortPieces[i]);
        longPieces[i] = regexEscape(longPieces[i]);
    }
    for (i = 0; i < 24; i++) {
        mixedPieces[i] = regexEscape(mixedPieces[i]);
    }

    this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
    this._monthsShortRegex = this._monthsRegex;
    this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
    this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
}

function createDate (y, m, d, h, M, s, ms) {
    // can't just apply() to create a date:
    // https://stackoverflow.com/q/181348
    var date = new Date(y, m, d, h, M, s, ms);

    // the date constructor remaps years 0-99 to 1900-1999
    if (y < 100 && y >= 0 && isFinite(date.getFullYear())) {
        date.setFullYear(y);
    }
    return date;
}

function createUTCDate (y) {
    var date = new Date(Date.UTC.apply(null, arguments));

    // the Date.UTC function remaps years 0-99 to 1900-1999
    if (y < 100 && y >= 0 && isFinite(date.getUTCFullYear())) {
        date.setUTCFullYear(y);
    }
    return date;
}

// start-of-first-week - start-of-year
function firstWeekOffset(year, dow, doy) {
    var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
        fwd = 7 + dow - doy,
        // first-week day local weekday -- which local weekday is fwd
        fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

    return -fwdlw + fwd - 1;
}

// https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
    var localWeekday = (7 + weekday - dow) % 7,
        weekOffset = firstWeekOffset(year, dow, doy),
        dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
        resYear, resDayOfYear;

    if (dayOfYear <= 0) {
        resYear = year - 1;
        resDayOfYear = daysInYear(resYear) + dayOfYear;
    } else if (dayOfYear > daysInYear(year)) {
        resYear = year + 1;
        resDayOfYear = dayOfYear - daysInYear(year);
    } else {
        resYear = year;
        resDayOfYear = dayOfYear;
    }

    return {
        year: resYear,
        dayOfYear: resDayOfYear
    };
}

function weekOfYear(mom, dow, doy) {
    var weekOffset = firstWeekOffset(mom.year(), dow, doy),
        week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
        resWeek, resYear;

    if (week < 1) {
        resYear = mom.year() - 1;
        resWeek = week + weeksInYear(resYear, dow, doy);
    } else if (week > weeksInYear(mom.year(), dow, doy)) {
        resWeek = week - weeksInYear(mom.year(), dow, doy);
        resYear = mom.year() + 1;
    } else {
        resYear = mom.year();
        resWeek = week;
    }

    return {
        week: resWeek,
        year: resYear
    };
}

function weeksInYear(year, dow, doy) {
    var weekOffset = firstWeekOffset(year, dow, doy),
        weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
    return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
}

// FORMATTING

addFormatToken('w', ['ww', 2], 'wo', 'week');
addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

// ALIASES

addUnitAlias('week', 'w');
addUnitAlias('isoWeek', 'W');

// PRIORITIES

addUnitPriority('week', 5);
addUnitPriority('isoWeek', 5);

// PARSING

addRegexToken('w',  match1to2);
addRegexToken('ww', match1to2, match2);
addRegexToken('W',  match1to2);
addRegexToken('WW', match1to2, match2);

addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
    week[token.substr(0, 1)] = toInt(input);
});

// HELPERS

// LOCALES

function localeWeek (mom) {
    return weekOfYear(mom, this._week.dow, this._week.doy).week;
}

var defaultLocaleWeek = {
    dow : 0, // Sunday is the first day of the week.
    doy : 6  // The week that contains Jan 1st is the first week of the year.
};

function localeFirstDayOfWeek () {
    return this._week.dow;
}

function localeFirstDayOfYear () {
    return this._week.doy;
}

// MOMENTS

function getSetWeek (input) {
    var week = this.localeData().week(this);
    return input == null ? week : this.add((input - week) * 7, 'd');
}

function getSetISOWeek (input) {
    var week = weekOfYear(this, 1, 4).week;
    return input == null ? week : this.add((input - week) * 7, 'd');
}

// FORMATTING

addFormatToken('d', 0, 'do', 'day');

addFormatToken('dd', 0, 0, function (format) {
    return this.localeData().weekdaysMin(this, format);
});

addFormatToken('ddd', 0, 0, function (format) {
    return this.localeData().weekdaysShort(this, format);
});

addFormatToken('dddd', 0, 0, function (format) {
    return this.localeData().weekdays(this, format);
});

addFormatToken('e', 0, 0, 'weekday');
addFormatToken('E', 0, 0, 'isoWeekday');

// ALIASES

addUnitAlias('day', 'd');
addUnitAlias('weekday', 'e');
addUnitAlias('isoWeekday', 'E');

// PRIORITY
addUnitPriority('day', 11);
addUnitPriority('weekday', 11);
addUnitPriority('isoWeekday', 11);

// PARSING

addRegexToken('d',    match1to2);
addRegexToken('e',    match1to2);
addRegexToken('E',    match1to2);
addRegexToken('dd',   function (isStrict, locale) {
    return locale.weekdaysMinRegex(isStrict);
});
addRegexToken('ddd',   function (isStrict, locale) {
    return locale.weekdaysShortRegex(isStrict);
});
addRegexToken('dddd',   function (isStrict, locale) {
    return locale.weekdaysRegex(isStrict);
});

addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
    var weekday = config._locale.weekdaysParse(input, token, config._strict);
    // if we didn't get a weekday name, mark the date as invalid
    if (weekday != null) {
        week.d = weekday;
    } else {
        getParsingFlags(config).invalidWeekday = input;
    }
});

addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
    week[token] = toInt(input);
});

// HELPERS

function parseWeekday(input, locale) {
    if (typeof input !== 'string') {
        return input;
    }

    if (!isNaN(input)) {
        return parseInt(input, 10);
    }

    input = locale.weekdaysParse(input);
    if (typeof input === 'number') {
        return input;
    }

    return null;
}

function parseIsoWeekday(input, locale) {
    if (typeof input === 'string') {
        return locale.weekdaysParse(input) % 7 || 7;
    }
    return isNaN(input) ? null : input;
}

// LOCALES

var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
function localeWeekdays (m, format) {
    if (!m) {
        return isArray(this._weekdays) ? this._weekdays :
            this._weekdays['standalone'];
    }
    return isArray(this._weekdays) ? this._weekdays[m.day()] :
        this._weekdays[this._weekdays.isFormat.test(format) ? 'format' : 'standalone'][m.day()];
}

var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
function localeWeekdaysShort (m) {
    return (m) ? this._weekdaysShort[m.day()] : this._weekdaysShort;
}

var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
function localeWeekdaysMin (m) {
    return (m) ? this._weekdaysMin[m.day()] : this._weekdaysMin;
}

function handleStrictParse$1(weekdayName, format, strict) {
    var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
    if (!this._weekdaysParse) {
        this._weekdaysParse = [];
        this._shortWeekdaysParse = [];
        this._minWeekdaysParse = [];

        for (i = 0; i < 7; ++i) {
            mom = createUTC([2000, 1]).day(i);
            this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
            this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
            this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
        }
    }

    if (strict) {
        if (format === 'dddd') {
            ii = indexOf.call(this._weekdaysParse, llc);
            return ii !== -1 ? ii : null;
        } else if (format === 'ddd') {
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        } else {
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        }
    } else {
        if (format === 'dddd') {
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        } else if (format === 'ddd') {
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        } else {
            ii = indexOf.call(this._minWeekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        }
    }
}

function localeWeekdaysParse (weekdayName, format, strict) {
    var i, mom, regex;

    if (this._weekdaysParseExact) {
        return handleStrictParse$1.call(this, weekdayName, format, strict);
    }

    if (!this._weekdaysParse) {
        this._weekdaysParse = [];
        this._minWeekdaysParse = [];
        this._shortWeekdaysParse = [];
        this._fullWeekdaysParse = [];
    }

    for (i = 0; i < 7; i++) {
        // make the regex if we don't have it already

        mom = createUTC([2000, 1]).day(i);
        if (strict && !this._fullWeekdaysParse[i]) {
            this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\.?') + '$', 'i');
            this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\.?') + '$', 'i');
            this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\.?') + '$', 'i');
        }
        if (!this._weekdaysParse[i]) {
            regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
            this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
        }
        // test the regex
        if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
            return i;
        } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
            return i;
        } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
            return i;
        } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
            return i;
        }
    }
}

// MOMENTS

function getSetDayOfWeek (input) {
    if (!this.isValid()) {
        return input != null ? this : NaN;
    }
    var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
    if (input != null) {
        input = parseWeekday(input, this.localeData());
        return this.add(input - day, 'd');
    } else {
        return day;
    }
}

function getSetLocaleDayOfWeek (input) {
    if (!this.isValid()) {
        return input != null ? this : NaN;
    }
    var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
    return input == null ? weekday : this.add(input - weekday, 'd');
}

function getSetISODayOfWeek (input) {
    if (!this.isValid()) {
        return input != null ? this : NaN;
    }

    // behaves the same as moment#day except
    // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
    // as a setter, sunday should belong to the previous week.

    if (input != null) {
        var weekday = parseIsoWeekday(input, this.localeData());
        return this.day(this.day() % 7 ? weekday : weekday - 7);
    } else {
        return this.day() || 7;
    }
}

var defaultWeekdaysRegex = matchWord;
function weekdaysRegex (isStrict) {
    if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
            computeWeekdaysParse.call(this);
        }
        if (isStrict) {
            return this._weekdaysStrictRegex;
        } else {
            return this._weekdaysRegex;
        }
    } else {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
            this._weekdaysRegex = defaultWeekdaysRegex;
        }
        return this._weekdaysStrictRegex && isStrict ?
            this._weekdaysStrictRegex : this._weekdaysRegex;
    }
}

var defaultWeekdaysShortRegex = matchWord;
function weekdaysShortRegex (isStrict) {
    if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
            computeWeekdaysParse.call(this);
        }
        if (isStrict) {
            return this._weekdaysShortStrictRegex;
        } else {
            return this._weekdaysShortRegex;
        }
    } else {
        if (!hasOwnProp(this, '_weekdaysShortRegex')) {
            this._weekdaysShortRegex = defaultWeekdaysShortRegex;
        }
        return this._weekdaysShortStrictRegex && isStrict ?
            this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
    }
}

var defaultWeekdaysMinRegex = matchWord;
function weekdaysMinRegex (isStrict) {
    if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
            computeWeekdaysParse.call(this);
        }
        if (isStrict) {
            return this._weekdaysMinStrictRegex;
        } else {
            return this._weekdaysMinRegex;
        }
    } else {
        if (!hasOwnProp(this, '_weekdaysMinRegex')) {
            this._weekdaysMinRegex = defaultWeekdaysMinRegex;
        }
        return this._weekdaysMinStrictRegex && isStrict ?
            this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
    }
}


function computeWeekdaysParse () {
    function cmpLenRev(a, b) {
        return b.length - a.length;
    }

    var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [],
        i, mom, minp, shortp, longp;
    for (i = 0; i < 7; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, 1]).day(i);
        minp = this.weekdaysMin(mom, '');
        shortp = this.weekdaysShort(mom, '');
        longp = this.weekdays(mom, '');
        minPieces.push(minp);
        shortPieces.push(shortp);
        longPieces.push(longp);
        mixedPieces.push(minp);
        mixedPieces.push(shortp);
        mixedPieces.push(longp);
    }
    // Sorting makes sure if one weekday (or abbr) is a prefix of another it
    // will match the longer piece.
    minPieces.sort(cmpLenRev);
    shortPieces.sort(cmpLenRev);
    longPieces.sort(cmpLenRev);
    mixedPieces.sort(cmpLenRev);
    for (i = 0; i < 7; i++) {
        shortPieces[i] = regexEscape(shortPieces[i]);
        longPieces[i] = regexEscape(longPieces[i]);
        mixedPieces[i] = regexEscape(mixedPieces[i]);
    }

    this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
    this._weekdaysShortRegex = this._weekdaysRegex;
    this._weekdaysMinRegex = this._weekdaysRegex;

    this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
    this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
    this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
}

// FORMATTING

function hFormat() {
    return this.hours() % 12 || 12;
}

function kFormat() {
    return this.hours() || 24;
}

addFormatToken('H', ['HH', 2], 0, 'hour');
addFormatToken('h', ['hh', 2], 0, hFormat);
addFormatToken('k', ['kk', 2], 0, kFormat);

addFormatToken('hmm', 0, 0, function () {
    return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
});

addFormatToken('hmmss', 0, 0, function () {
    return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) +
        zeroFill(this.seconds(), 2);
});

addFormatToken('Hmm', 0, 0, function () {
    return '' + this.hours() + zeroFill(this.minutes(), 2);
});

addFormatToken('Hmmss', 0, 0, function () {
    return '' + this.hours() + zeroFill(this.minutes(), 2) +
        zeroFill(this.seconds(), 2);
});

function meridiem (token, lowercase) {
    addFormatToken(token, 0, 0, function () {
        return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
    });
}

meridiem('a', true);
meridiem('A', false);

// ALIASES

addUnitAlias('hour', 'h');

// PRIORITY
addUnitPriority('hour', 13);

// PARSING

function matchMeridiem (isStrict, locale) {
    return locale._meridiemParse;
}

addRegexToken('a',  matchMeridiem);
addRegexToken('A',  matchMeridiem);
addRegexToken('H',  match1to2);
addRegexToken('h',  match1to2);
addRegexToken('k',  match1to2);
addRegexToken('HH', match1to2, match2);
addRegexToken('hh', match1to2, match2);
addRegexToken('kk', match1to2, match2);

addRegexToken('hmm', match3to4);
addRegexToken('hmmss', match5to6);
addRegexToken('Hmm', match3to4);
addRegexToken('Hmmss', match5to6);

addParseToken(['H', 'HH'], HOUR);
addParseToken(['k', 'kk'], function (input, array, config) {
    var kInput = toInt(input);
    array[HOUR] = kInput === 24 ? 0 : kInput;
});
addParseToken(['a', 'A'], function (input, array, config) {
    config._isPm = config._locale.isPM(input);
    config._meridiem = input;
});
addParseToken(['h', 'hh'], function (input, array, config) {
    array[HOUR] = toInt(input);
    getParsingFlags(config).bigHour = true;
});
addParseToken('hmm', function (input, array, config) {
    var pos = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos));
    array[MINUTE] = toInt(input.substr(pos));
    getParsingFlags(config).bigHour = true;
});
addParseToken('hmmss', function (input, array, config) {
    var pos1 = input.length - 4;
    var pos2 = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos1));
    array[MINUTE] = toInt(input.substr(pos1, 2));
    array[SECOND] = toInt(input.substr(pos2));
    getParsingFlags(config).bigHour = true;
});
addParseToken('Hmm', function (input, array, config) {
    var pos = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos));
    array[MINUTE] = toInt(input.substr(pos));
});
addParseToken('Hmmss', function (input, array, config) {
    var pos1 = input.length - 4;
    var pos2 = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos1));
    array[MINUTE] = toInt(input.substr(pos1, 2));
    array[SECOND] = toInt(input.substr(pos2));
});

// LOCALES

function localeIsPM (input) {
    // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
    // Using charAt should be more compatible.
    return ((input + '').toLowerCase().charAt(0) === 'p');
}

var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
function localeMeridiem (hours, minutes, isLower) {
    if (hours > 11) {
        return isLower ? 'pm' : 'PM';
    } else {
        return isLower ? 'am' : 'AM';
    }
}


// MOMENTS

// Setting the hour should keep the time, because the user explicitly
// specified which hour he wants. So trying to maintain the same hour (in
// a new timezone) makes sense. Adding/subtracting hours does not follow
// this rule.
var getSetHour = makeGetSet('Hours', true);

// months
// week
// weekdays
// meridiem
var baseConfig = {
    calendar: defaultCalendar,
    longDateFormat: defaultLongDateFormat,
    invalidDate: defaultInvalidDate,
    ordinal: defaultOrdinal,
    dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
    relativeTime: defaultRelativeTime,

    months: defaultLocaleMonths,
    monthsShort: defaultLocaleMonthsShort,

    week: defaultLocaleWeek,

    weekdays: defaultLocaleWeekdays,
    weekdaysMin: defaultLocaleWeekdaysMin,
    weekdaysShort: defaultLocaleWeekdaysShort,

    meridiemParse: defaultLocaleMeridiemParse
};

// internal storage for locale config files
var locales = {};
var localeFamilies = {};
var globalLocale;

function normalizeLocale(key) {
    return key ? key.toLowerCase().replace('_', '-') : key;
}

// pick the locale from the array
// try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
// substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
function chooseLocale(names) {
    var i = 0, j, next, locale, split;

    while (i < names.length) {
        split = normalizeLocale(names[i]).split('-');
        j = split.length;
        next = normalizeLocale(names[i + 1]);
        next = next ? next.split('-') : null;
        while (j > 0) {
            locale = loadLocale(split.slice(0, j).join('-'));
            if (locale) {
                return locale;
            }
            if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                //the next array item is better than a shallower substring of this one
                break;
            }
            j--;
        }
        i++;
    }
    return null;
}

function loadLocale(name) {
    var oldLocale = null;
    // TODO: Find a better way to register and load all the locales in Node
    if (!locales[name] && (typeof module !== 'undefined') &&
            module && module.exports) {
        try {
            oldLocale = globalLocale._abbr;
            var aliasedRequire = require;
            aliasedRequire('./locale/' + name);
            getSetGlobalLocale(oldLocale);
        } catch (e) {}
    }
    return locales[name];
}

// This function will load locale and then set the global locale.  If
// no arguments are passed in, it will simply return the current global
// locale key.
function getSetGlobalLocale (key, values) {
    var data;
    if (key) {
        if (isUndefined(values)) {
            data = getLocale(key);
        }
        else {
            data = defineLocale(key, values);
        }

        if (data) {
            // moment.duration._locale = moment._locale = data;
            globalLocale = data;
        }
    }

    return globalLocale._abbr;
}

function defineLocale (name, config) {
    if (config !== null) {
        var parentConfig = baseConfig;
        config.abbr = name;
        if (locales[name] != null) {
            deprecateSimple('defineLocaleOverride',
                    'use moment.updateLocale(localeName, config) to change ' +
                    'an existing locale. moment.defineLocale(localeName, ' +
                    'config) should only be used for creating a new locale ' +
                    'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');
            parentConfig = locales[name]._config;
        } else if (config.parentLocale != null) {
            if (locales[config.parentLocale] != null) {
                parentConfig = locales[config.parentLocale]._config;
            } else {
                if (!localeFamilies[config.parentLocale]) {
                    localeFamilies[config.parentLocale] = [];
                }
                localeFamilies[config.parentLocale].push({
                    name: name,
                    config: config
                });
                return null;
            }
        }
        locales[name] = new Locale(mergeConfigs(parentConfig, config));

        if (localeFamilies[name]) {
            localeFamilies[name].forEach(function (x) {
                defineLocale(x.name, x.config);
            });
        }

        // backwards compat for now: also set the locale
        // make sure we set the locale AFTER all child locales have been
        // created, so we won't end up with the child locale set.
        getSetGlobalLocale(name);


        return locales[name];
    } else {
        // useful for testing
        delete locales[name];
        return null;
    }
}

function updateLocale(name, config) {
    if (config != null) {
        var locale, tmpLocale, parentConfig = baseConfig;
        // MERGE
        tmpLocale = loadLocale(name);
        if (tmpLocale != null) {
            parentConfig = tmpLocale._config;
        }
        config = mergeConfigs(parentConfig, config);
        locale = new Locale(config);
        locale.parentLocale = locales[name];
        locales[name] = locale;

        // backwards compat for now: also set the locale
        getSetGlobalLocale(name);
    } else {
        // pass null for config to unupdate, useful for tests
        if (locales[name] != null) {
            if (locales[name].parentLocale != null) {
                locales[name] = locales[name].parentLocale;
            } else if (locales[name] != null) {
                delete locales[name];
            }
        }
    }
    return locales[name];
}

// returns locale data
function getLocale (key) {
    var locale;

    if (key && key._locale && key._locale._abbr) {
        key = key._locale._abbr;
    }

    if (!key) {
        return globalLocale;
    }

    if (!isArray(key)) {
        //short-circuit everything else
        locale = loadLocale(key);
        if (locale) {
            return locale;
        }
        key = [key];
    }

    return chooseLocale(key);
}

function listLocales() {
    return keys(locales);
}

function checkOverflow (m) {
    var overflow;
    var a = m._a;

    if (a && getParsingFlags(m).overflow === -2) {
        overflow =
            a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :
            a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :
            a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :
            a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :
            a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :
            a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :
            -1;

        if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
            overflow = DATE;
        }
        if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
            overflow = WEEK;
        }
        if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
            overflow = WEEKDAY;
        }

        getParsingFlags(m).overflow = overflow;
    }

    return m;
}

// Pick the first defined of two or three arguments.
function defaults(a, b, c) {
    if (a != null) {
        return a;
    }
    if (b != null) {
        return b;
    }
    return c;
}

function currentDateArray(config) {
    // hooks is actually the exported moment object
    var nowValue = new Date(hooks.now());
    if (config._useUTC) {
        return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
    }
    return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
}

// convert an array to a date.
// the array should mirror the parameters below
// note: all values past the year are optional and will default to the lowest possible value.
// [year, month, day , hour, minute, second, millisecond]
function configFromArray (config) {
    var i, date, input = [], currentDate, expectedWeekday, yearToUse;

    if (config._d) {
        return;
    }

    currentDate = currentDateArray(config);

    //compute day of the year from weeks and weekdays
    if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
        dayOfYearFromWeekInfo(config);
    }

    //if the day of the year is set, figure out what it is
    if (config._dayOfYear != null) {
        yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

        if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
            getParsingFlags(config)._overflowDayOfYear = true;
        }

        date = createUTCDate(yearToUse, 0, config._dayOfYear);
        config._a[MONTH] = date.getUTCMonth();
        config._a[DATE] = date.getUTCDate();
    }

    // Default to current date.
    // * if no year, month, day of month are given, default to today
    // * if day of month is given, default month and year
    // * if month is given, default only year
    // * if year is given, don't default anything
    for (i = 0; i < 3 && config._a[i] == null; ++i) {
        config._a[i] = input[i] = currentDate[i];
    }

    // Zero out whatever was not defaulted, including time
    for (; i < 7; i++) {
        config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
    }

    // Check for 24:00:00.000
    if (config._a[HOUR] === 24 &&
            config._a[MINUTE] === 0 &&
            config._a[SECOND] === 0 &&
            config._a[MILLISECOND] === 0) {
        config._nextDay = true;
        config._a[HOUR] = 0;
    }

    config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
    expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();

    // Apply timezone offset from input. The actual utcOffset can be changed
    // with parseZone.
    if (config._tzm != null) {
        config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
    }

    if (config._nextDay) {
        config._a[HOUR] = 24;
    }

    // check for mismatching day of week
    if (config._w && typeof config._w.d !== 'undefined' && config._w.d !== expectedWeekday) {
        getParsingFlags(config).weekdayMismatch = true;
    }
}

function dayOfYearFromWeekInfo(config) {
    var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;

    w = config._w;
    if (w.GG != null || w.W != null || w.E != null) {
        dow = 1;
        doy = 4;

        // TODO: We need to take the current isoWeekYear, but that depends on
        // how we interpret now (local, utc, fixed offset). So create
        // a now version of current config (take local/utc/offset flags, and
        // create now).
        weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
        week = defaults(w.W, 1);
        weekday = defaults(w.E, 1);
        if (weekday < 1 || weekday > 7) {
            weekdayOverflow = true;
        }
    } else {
        dow = config._locale._week.dow;
        doy = config._locale._week.doy;

        var curWeek = weekOfYear(createLocal(), dow, doy);

        weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);

        // Default to current week.
        week = defaults(w.w, curWeek.week);

        if (w.d != null) {
            // weekday -- low day numbers are considered next week
            weekday = w.d;
            if (weekday < 0 || weekday > 6) {
                weekdayOverflow = true;
            }
        } else if (w.e != null) {
            // local weekday -- counting starts from begining of week
            weekday = w.e + dow;
            if (w.e < 0 || w.e > 6) {
                weekdayOverflow = true;
            }
        } else {
            // default to begining of week
            weekday = dow;
        }
    }
    if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
        getParsingFlags(config)._overflowWeeks = true;
    } else if (weekdayOverflow != null) {
        getParsingFlags(config)._overflowWeekday = true;
    } else {
        temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
        config._a[YEAR] = temp.year;
        config._dayOfYear = temp.dayOfYear;
    }
}

// iso 8601 regex
// 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;

var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;

var isoDates = [
    ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
    ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
    ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
    ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
    ['YYYY-DDD', /\d{4}-\d{3}/],
    ['YYYY-MM', /\d{4}-\d\d/, false],
    ['YYYYYYMMDD', /[+-]\d{10}/],
    ['YYYYMMDD', /\d{8}/],
    // YYYYMM is NOT allowed by the standard
    ['GGGG[W]WWE', /\d{4}W\d{3}/],
    ['GGGG[W]WW', /\d{4}W\d{2}/, false],
    ['YYYYDDD', /\d{7}/]
];

// iso time formats and regexes
var isoTimes = [
    ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
    ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
    ['HH:mm:ss', /\d\d:\d\d:\d\d/],
    ['HH:mm', /\d\d:\d\d/],
    ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
    ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
    ['HHmmss', /\d\d\d\d\d\d/],
    ['HHmm', /\d\d\d\d/],
    ['HH', /\d\d/]
];

var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;

// date from iso format
function configFromISO(config) {
    var i, l,
        string = config._i,
        match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
        allowTime, dateFormat, timeFormat, tzFormat;

    if (match) {
        getParsingFlags(config).iso = true;

        for (i = 0, l = isoDates.length; i < l; i++) {
            if (isoDates[i][1].exec(match[1])) {
                dateFormat = isoDates[i][0];
                allowTime = isoDates[i][2] !== false;
                break;
            }
        }
        if (dateFormat == null) {
            config._isValid = false;
            return;
        }
        if (match[3]) {
            for (i = 0, l = isoTimes.length; i < l; i++) {
                if (isoTimes[i][1].exec(match[3])) {
                    // match[2] should be 'T' or space
                    timeFormat = (match[2] || ' ') + isoTimes[i][0];
                    break;
                }
            }
            if (timeFormat == null) {
                config._isValid = false;
                return;
            }
        }
        if (!allowTime && timeFormat != null) {
            config._isValid = false;
            return;
        }
        if (match[4]) {
            if (tzRegex.exec(match[4])) {
                tzFormat = 'Z';
            } else {
                config._isValid = false;
                return;
            }
        }
        config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
        configFromStringAndFormat(config);
    } else {
        config._isValid = false;
    }
}

// RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3
var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/;

function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
    var result = [
        untruncateYear(yearStr),
        defaultLocaleMonthsShort.indexOf(monthStr),
        parseInt(dayStr, 10),
        parseInt(hourStr, 10),
        parseInt(minuteStr, 10)
    ];

    if (secondStr) {
        result.push(parseInt(secondStr, 10));
    }

    return result;
}

function untruncateYear(yearStr) {
    var year = parseInt(yearStr, 10);
    if (year <= 49) {
        return 2000 + year;
    } else if (year <= 999) {
        return 1900 + year;
    }
    return year;
}

function preprocessRFC2822(s) {
    // Remove comments and folding whitespace and replace multiple-spaces with a single space
    return s.replace(/\([^)]*\)|[\n\t]/g, ' ').replace(/(\s\s+)/g, ' ').trim();
}

function checkWeekday(weekdayStr, parsedInput, config) {
    if (weekdayStr) {
        // TODO: Replace the vanilla JS Date object with an indepentent day-of-week check.
        var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),
            weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();
        if (weekdayProvided !== weekdayActual) {
            getParsingFlags(config).weekdayMismatch = true;
            config._isValid = false;
            return false;
        }
    }
    return true;
}

var obsOffsets = {
    UT: 0,
    GMT: 0,
    EDT: -4 * 60,
    EST: -5 * 60,
    CDT: -5 * 60,
    CST: -6 * 60,
    MDT: -6 * 60,
    MST: -7 * 60,
    PDT: -7 * 60,
    PST: -8 * 60
};

function calculateOffset(obsOffset, militaryOffset, numOffset) {
    if (obsOffset) {
        return obsOffsets[obsOffset];
    } else if (militaryOffset) {
        // the only allowed military tz is Z
        return 0;
    } else {
        var hm = parseInt(numOffset, 10);
        var m = hm % 100, h = (hm - m) / 100;
        return h * 60 + m;
    }
}

// date and time from ref 2822 format
function configFromRFC2822(config) {
    var match = rfc2822.exec(preprocessRFC2822(config._i));
    if (match) {
        var parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);
        if (!checkWeekday(match[1], parsedArray, config)) {
            return;
        }

        config._a = parsedArray;
        config._tzm = calculateOffset(match[8], match[9], match[10]);

        config._d = createUTCDate.apply(null, config._a);
        config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);

        getParsingFlags(config).rfc2822 = true;
    } else {
        config._isValid = false;
    }
}

// date from iso format or fallback
function configFromString(config) {
    var matched = aspNetJsonRegex.exec(config._i);

    if (matched !== null) {
        config._d = new Date(+matched[1]);
        return;
    }

    configFromISO(config);
    if (config._isValid === false) {
        delete config._isValid;
    } else {
        return;
    }

    configFromRFC2822(config);
    if (config._isValid === false) {
        delete config._isValid;
    } else {
        return;
    }

    // Final attempt, use Input Fallback
    hooks.createFromInputFallback(config);
}

hooks.createFromInputFallback = deprecate(
    'value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' +
    'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' +
    'discouraged and will be removed in an upcoming major release. Please refer to ' +
    'http://momentjs.com/guides/#/warnings/js-date/ for more info.',
    function (config) {
        config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
    }
);

// constant that refers to the ISO standard
hooks.ISO_8601 = function () {};

// constant that refers to the RFC 2822 form
hooks.RFC_2822 = function () {};

// date from string and format string
function configFromStringAndFormat(config) {
    // TODO: Move this to another part of the creation flow to prevent circular deps
    if (config._f === hooks.ISO_8601) {
        configFromISO(config);
        return;
    }
    if (config._f === hooks.RFC_2822) {
        configFromRFC2822(config);
        return;
    }
    config._a = [];
    getParsingFlags(config).empty = true;

    // This array is used to make a Date, either with `new Date` or `Date.UTC`
    var string = '' + config._i,
        i, parsedInput, tokens, token, skipped,
        stringLength = string.length,
        totalParsedInputLength = 0;

    tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

    for (i = 0; i < tokens.length; i++) {
        token = tokens[i];
        parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
        // console.log('token', token, 'parsedInput', parsedInput,
        //         'regex', getParseRegexForToken(token, config));
        if (parsedInput) {
            skipped = string.substr(0, string.indexOf(parsedInput));
            if (skipped.length > 0) {
                getParsingFlags(config).unusedInput.push(skipped);
            }
            string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
            totalParsedInputLength += parsedInput.length;
        }
        // don't parse if it's not a known token
        if (formatTokenFunctions[token]) {
            if (parsedInput) {
                getParsingFlags(config).empty = false;
            }
            else {
                getParsingFlags(config).unusedTokens.push(token);
            }
            addTimeToArrayFromToken(token, parsedInput, config);
        }
        else if (config._strict && !parsedInput) {
            getParsingFlags(config).unusedTokens.push(token);
        }
    }

    // add remaining unparsed input length to the string
    getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
    if (string.length > 0) {
        getParsingFlags(config).unusedInput.push(string);
    }

    // clear _12h flag if hour is <= 12
    if (config._a[HOUR] <= 12 &&
        getParsingFlags(config).bigHour === true &&
        config._a[HOUR] > 0) {
        getParsingFlags(config).bigHour = undefined;
    }

    getParsingFlags(config).parsedDateParts = config._a.slice(0);
    getParsingFlags(config).meridiem = config._meridiem;
    // handle meridiem
    config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);

    configFromArray(config);
    checkOverflow(config);
}


function meridiemFixWrap (locale, hour, meridiem) {
    var isPm;

    if (meridiem == null) {
        // nothing to do
        return hour;
    }
    if (locale.meridiemHour != null) {
        return locale.meridiemHour(hour, meridiem);
    } else if (locale.isPM != null) {
        // Fallback
        isPm = locale.isPM(meridiem);
        if (isPm && hour < 12) {
            hour += 12;
        }
        if (!isPm && hour === 12) {
            hour = 0;
        }
        return hour;
    } else {
        // this is not supposed to happen
        return hour;
    }
}

// date from string and array of format strings
function configFromStringAndArray(config) {
    var tempConfig,
        bestMoment,

        scoreToBeat,
        i,
        currentScore;

    if (config._f.length === 0) {
        getParsingFlags(config).invalidFormat = true;
        config._d = new Date(NaN);
        return;
    }

    for (i = 0; i < config._f.length; i++) {
        currentScore = 0;
        tempConfig = copyConfig({}, config);
        if (config._useUTC != null) {
            tempConfig._useUTC = config._useUTC;
        }
        tempConfig._f = config._f[i];
        configFromStringAndFormat(tempConfig);

        if (!isValid(tempConfig)) {
            continue;
        }

        // if there is any input that was not parsed add a penalty for that format
        currentScore += getParsingFlags(tempConfig).charsLeftOver;

        //or tokens
        currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

        getParsingFlags(tempConfig).score = currentScore;

        if (scoreToBeat == null || currentScore < scoreToBeat) {
            scoreToBeat = currentScore;
            bestMoment = tempConfig;
        }
    }

    extend(config, bestMoment || tempConfig);
}

function configFromObject(config) {
    if (config._d) {
        return;
    }

    var i = normalizeObjectUnits(config._i);
    config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {
        return obj && parseInt(obj, 10);
    });

    configFromArray(config);
}

function createFromConfig (config) {
    var res = new Moment(checkOverflow(prepareConfig(config)));
    if (res._nextDay) {
        // Adding is smart enough around DST
        res.add(1, 'd');
        res._nextDay = undefined;
    }

    return res;
}

function prepareConfig (config) {
    var input = config._i,
        format = config._f;

    config._locale = config._locale || getLocale(config._l);

    if (input === null || (format === undefined && input === '')) {
        return createInvalid({nullInput: true});
    }

    if (typeof input === 'string') {
        config._i = input = config._locale.preparse(input);
    }

    if (isMoment(input)) {
        return new Moment(checkOverflow(input));
    } else if (isDate(input)) {
        config._d = input;
    } else if (isArray(format)) {
        configFromStringAndArray(config);
    } else if (format) {
        configFromStringAndFormat(config);
    }  else {
        configFromInput(config);
    }

    if (!isValid(config)) {
        config._d = null;
    }

    return config;
}

function configFromInput(config) {
    var input = config._i;
    if (isUndefined(input)) {
        config._d = new Date(hooks.now());
    } else if (isDate(input)) {
        config._d = new Date(input.valueOf());
    } else if (typeof input === 'string') {
        configFromString(config);
    } else if (isArray(input)) {
        config._a = map(input.slice(0), function (obj) {
            return parseInt(obj, 10);
        });
        configFromArray(config);
    } else if (isObject(input)) {
        configFromObject(config);
    } else if (isNumber(input)) {
        // from milliseconds
        config._d = new Date(input);
    } else {
        hooks.createFromInputFallback(config);
    }
}

function createLocalOrUTC (input, format, locale, strict, isUTC) {
    var c = {};

    if (locale === true || locale === false) {
        strict = locale;
        locale = undefined;
    }

    if ((isObject(input) && isObjectEmpty(input)) ||
            (isArray(input) && input.length === 0)) {
        input = undefined;
    }
    // object construction must be done this way.
    // https://github.com/moment/moment/issues/1423
    c._isAMomentObject = true;
    c._useUTC = c._isUTC = isUTC;
    c._l = locale;
    c._i = input;
    c._f = format;
    c._strict = strict;

    return createFromConfig(c);
}

function createLocal (input, format, locale, strict) {
    return createLocalOrUTC(input, format, locale, strict, false);
}

var prototypeMin = deprecate(
    'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',
    function () {
        var other = createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
            return other < this ? this : other;
        } else {
            return createInvalid();
        }
    }
);

var prototypeMax = deprecate(
    'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',
    function () {
        var other = createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
            return other > this ? this : other;
        } else {
            return createInvalid();
        }
    }
);

// Pick a moment m from moments so that m[fn](other) is true for all
// other. This relies on the function fn to be transitive.
//
// moments should either be an array of moment objects or an array, whose
// first element is an array of moment objects.
function pickBy(fn, moments) {
    var res, i;
    if (moments.length === 1 && isArray(moments[0])) {
        moments = moments[0];
    }
    if (!moments.length) {
        return createLocal();
    }
    res = moments[0];
    for (i = 1; i < moments.length; ++i) {
        if (!moments[i].isValid() || moments[i][fn](res)) {
            res = moments[i];
        }
    }
    return res;
}

// TODO: Use [].sort instead?
function min () {
    var args = [].slice.call(arguments, 0);

    return pickBy('isBefore', args);
}

function max () {
    var args = [].slice.call(arguments, 0);

    return pickBy('isAfter', args);
}

var now = function () {
    return Date.now ? Date.now() : +(new Date());
};

var ordering = ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'];

function isDurationValid(m) {
    for (var key in m) {
        if (!(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
            return false;
        }
    }

    var unitHasDecimal = false;
    for (var i = 0; i < ordering.length; ++i) {
        if (m[ordering[i]]) {
            if (unitHasDecimal) {
                return false; // only allow non-integers for smallest unit
            }
            if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
                unitHasDecimal = true;
            }
        }
    }

    return true;
}

function isValid$1() {
    return this._isValid;
}

function createInvalid$1() {
    return createDuration(NaN);
}

function Duration (duration) {
    var normalizedInput = normalizeObjectUnits(duration),
        years = normalizedInput.year || 0,
        quarters = normalizedInput.quarter || 0,
        months = normalizedInput.month || 0,
        weeks = normalizedInput.week || 0,
        days = normalizedInput.day || 0,
        hours = normalizedInput.hour || 0,
        minutes = normalizedInput.minute || 0,
        seconds = normalizedInput.second || 0,
        milliseconds = normalizedInput.millisecond || 0;

    this._isValid = isDurationValid(normalizedInput);

    // representation for dateAddRemove
    this._milliseconds = +milliseconds +
        seconds * 1e3 + // 1000
        minutes * 6e4 + // 1000 * 60
        hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
    // Because of dateAddRemove treats 24 hours as different from a
    // day when working around DST, we need to store them separately
    this._days = +days +
        weeks * 7;
    // It is impossible to translate months into days without knowing
    // which months you are are talking about, so we have to store
    // it separately.
    this._months = +months +
        quarters * 3 +
        years * 12;

    this._data = {};

    this._locale = getLocale();

    this._bubble();
}

function isDuration (obj) {
    return obj instanceof Duration;
}

function absRound (number) {
    if (number < 0) {
        return Math.round(-1 * number) * -1;
    } else {
        return Math.round(number);
    }
}

// FORMATTING

function offset (token, separator) {
    addFormatToken(token, 0, 0, function () {
        var offset = this.utcOffset();
        var sign = '+';
        if (offset < 0) {
            offset = -offset;
            sign = '-';
        }
        return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
    });
}

offset('Z', ':');
offset('ZZ', '');

// PARSING

addRegexToken('Z',  matchShortOffset);
addRegexToken('ZZ', matchShortOffset);
addParseToken(['Z', 'ZZ'], function (input, array, config) {
    config._useUTC = true;
    config._tzm = offsetFromString(matchShortOffset, input);
});

// HELPERS

// timezone chunker
// '+10:00' > ['10',  '00']
// '-1530'  > ['-15', '30']
var chunkOffset = /([\+\-]|\d\d)/gi;

function offsetFromString(matcher, string) {
    var matches = (string || '').match(matcher);

    if (matches === null) {
        return null;
    }

    var chunk   = matches[matches.length - 1] || [];
    var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];
    var minutes = +(parts[1] * 60) + toInt(parts[2]);

    return minutes === 0 ?
      0 :
      parts[0] === '+' ? minutes : -minutes;
}

// Return a moment from input, that is local/utc/zone equivalent to model.
function cloneWithOffset(input, model) {
    var res, diff;
    if (model._isUTC) {
        res = model.clone();
        diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
        // Use low-level api, because this fn is low-level api.
        res._d.setTime(res._d.valueOf() + diff);
        hooks.updateOffset(res, false);
        return res;
    } else {
        return createLocal(input).local();
    }
}

function getDateOffset (m) {
    // On Firefox.24 Date#getTimezoneOffset returns a floating point.
    // https://github.com/moment/moment/pull/1871
    return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
}

// HOOKS

// This function will be called whenever a moment is mutated.
// It is intended to keep the offset in sync with the timezone.
hooks.updateOffset = function () {};

// MOMENTS

// keepLocalTime = true means only change the timezone, without
// affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
// 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
// +0200, so we adjust the time as needed, to be valid.
//
// Keeping the time actually adds/subtracts (one hour)
// from the actual represented time. That is why we call updateOffset
// a second time. In case it wants us to change the offset again
// _changeInProgress == true case, then we have to adjust, because
// there is no such time in the given timezone.
function getSetOffset (input, keepLocalTime, keepMinutes) {
    var offset = this._offset || 0,
        localAdjust;
    if (!this.isValid()) {
        return input != null ? this : NaN;
    }
    if (input != null) {
        if (typeof input === 'string') {
            input = offsetFromString(matchShortOffset, input);
            if (input === null) {
                return this;
            }
        } else if (Math.abs(input) < 16 && !keepMinutes) {
            input = input * 60;
        }
        if (!this._isUTC && keepLocalTime) {
            localAdjust = getDateOffset(this);
        }
        this._offset = input;
        this._isUTC = true;
        if (localAdjust != null) {
            this.add(localAdjust, 'm');
        }
        if (offset !== input) {
            if (!keepLocalTime || this._changeInProgress) {
                addSubtract(this, createDuration(input - offset, 'm'), 1, false);
            } else if (!this._changeInProgress) {
                this._changeInProgress = true;
                hooks.updateOffset(this, true);
                this._changeInProgress = null;
            }
        }
        return this;
    } else {
        return this._isUTC ? offset : getDateOffset(this);
    }
}

function getSetZone (input, keepLocalTime) {
    if (input != null) {
        if (typeof input !== 'string') {
            input = -input;
        }

        this.utcOffset(input, keepLocalTime);

        return this;
    } else {
        return -this.utcOffset();
    }
}

function setOffsetToUTC (keepLocalTime) {
    return this.utcOffset(0, keepLocalTime);
}

function setOffsetToLocal (keepLocalTime) {
    if (this._isUTC) {
        this.utcOffset(0, keepLocalTime);
        this._isUTC = false;

        if (keepLocalTime) {
            this.subtract(getDateOffset(this), 'm');
        }
    }
    return this;
}

function setOffsetToParsedOffset () {
    if (this._tzm != null) {
        this.utcOffset(this._tzm, false, true);
    } else if (typeof this._i === 'string') {
        var tZone = offsetFromString(matchOffset, this._i);
        if (tZone != null) {
            this.utcOffset(tZone);
        }
        else {
            this.utcOffset(0, true);
        }
    }
    return this;
}

function hasAlignedHourOffset (input) {
    if (!this.isValid()) {
        return false;
    }
    input = input ? createLocal(input).utcOffset() : 0;

    return (this.utcOffset() - input) % 60 === 0;
}

function isDaylightSavingTime () {
    return (
        this.utcOffset() > this.clone().month(0).utcOffset() ||
        this.utcOffset() > this.clone().month(5).utcOffset()
    );
}

function isDaylightSavingTimeShifted () {
    if (!isUndefined(this._isDSTShifted)) {
        return this._isDSTShifted;
    }

    var c = {};

    copyConfig(c, this);
    c = prepareConfig(c);

    if (c._a) {
        var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
        this._isDSTShifted = this.isValid() &&
            compareArrays(c._a, other.toArray()) > 0;
    } else {
        this._isDSTShifted = false;
    }

    return this._isDSTShifted;
}

function isLocal () {
    return this.isValid() ? !this._isUTC : false;
}

function isUtcOffset () {
    return this.isValid() ? this._isUTC : false;
}

function isUtc () {
    return this.isValid() ? this._isUTC && this._offset === 0 : false;
}

// ASP.NET json date format regex
var aspNetRegex = /^(\-|\+)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/;

// from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
// somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
// and further modified to allow for strings containing both week and day
var isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;

function createDuration (input, key) {
    var duration = input,
        // matching against regexp is expensive, do it on demand
        match = null,
        sign,
        ret,
        diffRes;

    if (isDuration(input)) {
        duration = {
            ms : input._milliseconds,
            d  : input._days,
            M  : input._months
        };
    } else if (isNumber(input)) {
        duration = {};
        if (key) {
            duration[key] = input;
        } else {
            duration.milliseconds = input;
        }
    } else if (!!(match = aspNetRegex.exec(input))) {
        sign = (match[1] === '-') ? -1 : 1;
        duration = {
            y  : 0,
            d  : toInt(match[DATE])                         * sign,
            h  : toInt(match[HOUR])                         * sign,
            m  : toInt(match[MINUTE])                       * sign,
            s  : toInt(match[SECOND])                       * sign,
            ms : toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match
        };
    } else if (!!(match = isoRegex.exec(input))) {
        sign = (match[1] === '-') ? -1 : (match[1] === '+') ? 1 : 1;
        duration = {
            y : parseIso(match[2], sign),
            M : parseIso(match[3], sign),
            w : parseIso(match[4], sign),
            d : parseIso(match[5], sign),
            h : parseIso(match[6], sign),
            m : parseIso(match[7], sign),
            s : parseIso(match[8], sign)
        };
    } else if (duration == null) {// checks for null or undefined
        duration = {};
    } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
        diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));

        duration = {};
        duration.ms = diffRes.milliseconds;
        duration.M = diffRes.months;
    }

    ret = new Duration(duration);

    if (isDuration(input) && hasOwnProp(input, '_locale')) {
        ret._locale = input._locale;
    }

    return ret;
}

createDuration.fn = Duration.prototype;
createDuration.invalid = createInvalid$1;

function parseIso (inp, sign) {
    // We'd normally use ~~inp for this, but unfortunately it also
    // converts floats to ints.
    // inp may be undefined, so careful calling replace on it.
    var res = inp && parseFloat(inp.replace(',', '.'));
    // apply sign while we're at it
    return (isNaN(res) ? 0 : res) * sign;
}

function positiveMomentsDifference(base, other) {
    var res = {milliseconds: 0, months: 0};

    res.months = other.month() - base.month() +
        (other.year() - base.year()) * 12;
    if (base.clone().add(res.months, 'M').isAfter(other)) {
        --res.months;
    }

    res.milliseconds = +other - +(base.clone().add(res.months, 'M'));

    return res;
}

function momentsDifference(base, other) {
    var res;
    if (!(base.isValid() && other.isValid())) {
        return {milliseconds: 0, months: 0};
    }

    other = cloneWithOffset(other, base);
    if (base.isBefore(other)) {
        res = positiveMomentsDifference(base, other);
    } else {
        res = positiveMomentsDifference(other, base);
        res.milliseconds = -res.milliseconds;
        res.months = -res.months;
    }

    return res;
}

// TODO: remove 'name' arg after deprecation is removed
function createAdder(direction, name) {
    return function (val, period) {
        var dur, tmp;
        //invert the arguments, but complain about it
        if (period !== null && !isNaN(+period)) {
            deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' +
            'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');
            tmp = val; val = period; period = tmp;
        }

        val = typeof val === 'string' ? +val : val;
        dur = createDuration(val, period);
        addSubtract(this, dur, direction);
        return this;
    };
}

function addSubtract (mom, duration, isAdding, updateOffset) {
    var milliseconds = duration._milliseconds,
        days = absRound(duration._days),
        months = absRound(duration._months);

    if (!mom.isValid()) {
        // No op
        return;
    }

    updateOffset = updateOffset == null ? true : updateOffset;

    if (months) {
        setMonth(mom, get(mom, 'Month') + months * isAdding);
    }
    if (days) {
        set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
    }
    if (milliseconds) {
        mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
    }
    if (updateOffset) {
        hooks.updateOffset(mom, days || months);
    }
}

var add      = createAdder(1, 'add');
var subtract = createAdder(-1, 'subtract');

function getCalendarFormat(myMoment, now) {
    var diff = myMoment.diff(now, 'days', true);
    return diff < -6 ? 'sameElse' :
            diff < -1 ? 'lastWeek' :
            diff < 0 ? 'lastDay' :
            diff < 1 ? 'sameDay' :
            diff < 2 ? 'nextDay' :
            diff < 7 ? 'nextWeek' : 'sameElse';
}

function calendar$1 (time, formats) {
    // We want to compare the start of today, vs this.
    // Getting start-of-today depends on whether we're local/utc/offset or not.
    var now = time || createLocal(),
        sod = cloneWithOffset(now, this).startOf('day'),
        format = hooks.calendarFormat(this, sod) || 'sameElse';

    var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);

    return this.format(output || this.localeData().calendar(format, this, createLocal(now)));
}

function clone () {
    return new Moment(this);
}

function isAfter (input, units) {
    var localInput = isMoment(input) ? input : createLocal(input);
    if (!(this.isValid() && localInput.isValid())) {
        return false;
    }
    units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
    if (units === 'millisecond') {
        return this.valueOf() > localInput.valueOf();
    } else {
        return localInput.valueOf() < this.clone().startOf(units).valueOf();
    }
}

function isBefore (input, units) {
    var localInput = isMoment(input) ? input : createLocal(input);
    if (!(this.isValid() && localInput.isValid())) {
        return false;
    }
    units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
    if (units === 'millisecond') {
        return this.valueOf() < localInput.valueOf();
    } else {
        return this.clone().endOf(units).valueOf() < localInput.valueOf();
    }
}

function isBetween (from, to, units, inclusivity) {
    inclusivity = inclusivity || '()';
    return (inclusivity[0] === '(' ? this.isAfter(from, units) : !this.isBefore(from, units)) &&
        (inclusivity[1] === ')' ? this.isBefore(to, units) : !this.isAfter(to, units));
}

function isSame (input, units) {
    var localInput = isMoment(input) ? input : createLocal(input),
        inputMs;
    if (!(this.isValid() && localInput.isValid())) {
        return false;
    }
    units = normalizeUnits(units || 'millisecond');
    if (units === 'millisecond') {
        return this.valueOf() === localInput.valueOf();
    } else {
        inputMs = localInput.valueOf();
        return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
    }
}

function isSameOrAfter (input, units) {
    return this.isSame(input, units) || this.isAfter(input,units);
}

function isSameOrBefore (input, units) {
    return this.isSame(input, units) || this.isBefore(input,units);
}

function diff (input, units, asFloat) {
    var that,
        zoneDelta,
        delta, output;

    if (!this.isValid()) {
        return NaN;
    }

    that = cloneWithOffset(input, this);

    if (!that.isValid()) {
        return NaN;
    }

    zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

    units = normalizeUnits(units);

    switch (units) {
        case 'year': output = monthDiff(this, that) / 12; break;
        case 'month': output = monthDiff(this, that); break;
        case 'quarter': output = monthDiff(this, that) / 3; break;
        case 'second': output = (this - that) / 1e3; break; // 1000
        case 'minute': output = (this - that) / 6e4; break; // 1000 * 60
        case 'hour': output = (this - that) / 36e5; break; // 1000 * 60 * 60
        case 'day': output = (this - that - zoneDelta) / 864e5; break; // 1000 * 60 * 60 * 24, negate dst
        case 'week': output = (this - that - zoneDelta) / 6048e5; break; // 1000 * 60 * 60 * 24 * 7, negate dst
        default: output = this - that;
    }

    return asFloat ? output : absFloor(output);
}

function monthDiff (a, b) {
    // difference in months
    var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
        // b is in (anchor - 1 month, anchor + 1 month)
        anchor = a.clone().add(wholeMonthDiff, 'months'),
        anchor2, adjust;

    if (b - anchor < 0) {
        anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
        // linear across the month
        adjust = (b - anchor) / (anchor - anchor2);
    } else {
        anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
        // linear across the month
        adjust = (b - anchor) / (anchor2 - anchor);
    }

    //check for negative zero, return zero if negative zero
    return -(wholeMonthDiff + adjust) || 0;
}

hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

function toString () {
    return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
}

function toISOString(keepOffset) {
    if (!this.isValid()) {
        return null;
    }
    var utc = keepOffset !== true;
    var m = utc ? this.clone().utc() : this;
    if (m.year() < 0 || m.year() > 9999) {
        return formatMoment(m, utc ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ');
    }
    if (isFunction(Date.prototype.toISOString)) {
        // native implementation is ~50x faster, use it when we can
        if (utc) {
            return this.toDate().toISOString();
        } else {
            return new Date(this._d.valueOf()).toISOString().replace('Z', formatMoment(m, 'Z'));
        }
    }
    return formatMoment(m, utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ');
}

/**
 * Return a human readable representation of a moment that can
 * also be evaluated to get a new moment which is the same
 *
 * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
 */
function inspect () {
    if (!this.isValid()) {
        return 'moment.invalid(/* ' + this._i + ' */)';
    }
    var func = 'moment';
    var zone = '';
    if (!this.isLocal()) {
        func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
        zone = 'Z';
    }
    var prefix = '[' + func + '("]';
    var year = (0 <= this.year() && this.year() <= 9999) ? 'YYYY' : 'YYYYYY';
    var datetime = '-MM-DD[T]HH:mm:ss.SSS';
    var suffix = zone + '[")]';

    return this.format(prefix + year + datetime + suffix);
}

function format (inputString) {
    if (!inputString) {
        inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
    }
    var output = formatMoment(this, inputString);
    return this.localeData().postformat(output);
}

function from (time, withoutSuffix) {
    if (this.isValid() &&
            ((isMoment(time) && time.isValid()) ||
             createLocal(time).isValid())) {
        return createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
    } else {
        return this.localeData().invalidDate();
    }
}

function fromNow (withoutSuffix) {
    return this.from(createLocal(), withoutSuffix);
}

function to (time, withoutSuffix) {
    if (this.isValid() &&
            ((isMoment(time) && time.isValid()) ||
             createLocal(time).isValid())) {
        return createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);
    } else {
        return this.localeData().invalidDate();
    }
}

function toNow (withoutSuffix) {
    return this.to(createLocal(), withoutSuffix);
}

// If passed a locale key, it will set the locale for this
// instance.  Otherwise, it will return the locale configuration
// variables for this instance.
function locale (key) {
    var newLocaleData;

    if (key === undefined) {
        return this._locale._abbr;
    } else {
        newLocaleData = getLocale(key);
        if (newLocaleData != null) {
            this._locale = newLocaleData;
        }
        return this;
    }
}

var lang = deprecate(
    'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
    function (key) {
        if (key === undefined) {
            return this.localeData();
        } else {
            return this.locale(key);
        }
    }
);

function localeData () {
    return this._locale;
}

function startOf (units) {
    units = normalizeUnits(units);
    // the following switch intentionally omits break keywords
    // to utilize falling through the cases.
    switch (units) {
        case 'year':
            this.month(0);
            /* falls through */
        case 'quarter':
        case 'month':
            this.date(1);
            /* falls through */
        case 'week':
        case 'isoWeek':
        case 'day':
        case 'date':
            this.hours(0);
            /* falls through */
        case 'hour':
            this.minutes(0);
            /* falls through */
        case 'minute':
            this.seconds(0);
            /* falls through */
        case 'second':
            this.milliseconds(0);
    }

    // weeks are a special case
    if (units === 'week') {
        this.weekday(0);
    }
    if (units === 'isoWeek') {
        this.isoWeekday(1);
    }

    // quarters are also special
    if (units === 'quarter') {
        this.month(Math.floor(this.month() / 3) * 3);
    }

    return this;
}

function endOf (units) {
    units = normalizeUnits(units);
    if (units === undefined || units === 'millisecond') {
        return this;
    }

    // 'date' is an alias for 'day', so it should be considered as such.
    if (units === 'date') {
        units = 'day';
    }

    return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
}

function valueOf () {
    return this._d.valueOf() - ((this._offset || 0) * 60000);
}

function unix () {
    return Math.floor(this.valueOf() / 1000);
}

function toDate () {
    return new Date(this.valueOf());
}

function toArray () {
    var m = this;
    return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
}

function toObject () {
    var m = this;
    return {
        years: m.year(),
        months: m.month(),
        date: m.date(),
        hours: m.hours(),
        minutes: m.minutes(),
        seconds: m.seconds(),
        milliseconds: m.milliseconds()
    };
}

function toJSON () {
    // new Date(NaN).toJSON() === null
    return this.isValid() ? this.toISOString() : null;
}

function isValid$2 () {
    return isValid(this);
}

function parsingFlags () {
    return extend({}, getParsingFlags(this));
}

function invalidAt () {
    return getParsingFlags(this).overflow;
}

function creationData() {
    return {
        input: this._i,
        format: this._f,
        locale: this._locale,
        isUTC: this._isUTC,
        strict: this._strict
    };
}

// FORMATTING

addFormatToken(0, ['gg', 2], 0, function () {
    return this.weekYear() % 100;
});

addFormatToken(0, ['GG', 2], 0, function () {
    return this.isoWeekYear() % 100;
});

function addWeekYearFormatToken (token, getter) {
    addFormatToken(0, [token, token.length], 0, getter);
}

addWeekYearFormatToken('gggg',     'weekYear');
addWeekYearFormatToken('ggggg',    'weekYear');
addWeekYearFormatToken('GGGG',  'isoWeekYear');
addWeekYearFormatToken('GGGGG', 'isoWeekYear');

// ALIASES

addUnitAlias('weekYear', 'gg');
addUnitAlias('isoWeekYear', 'GG');

// PRIORITY

addUnitPriority('weekYear', 1);
addUnitPriority('isoWeekYear', 1);


// PARSING

addRegexToken('G',      matchSigned);
addRegexToken('g',      matchSigned);
addRegexToken('GG',     match1to2, match2);
addRegexToken('gg',     match1to2, match2);
addRegexToken('GGGG',   match1to4, match4);
addRegexToken('gggg',   match1to4, match4);
addRegexToken('GGGGG',  match1to6, match6);
addRegexToken('ggggg',  match1to6, match6);

addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
    week[token.substr(0, 2)] = toInt(input);
});

addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
    week[token] = hooks.parseTwoDigitYear(input);
});

// MOMENTS

function getSetWeekYear (input) {
    return getSetWeekYearHelper.call(this,
            input,
            this.week(),
            this.weekday(),
            this.localeData()._week.dow,
            this.localeData()._week.doy);
}

function getSetISOWeekYear (input) {
    return getSetWeekYearHelper.call(this,
            input, this.isoWeek(), this.isoWeekday(), 1, 4);
}

function getISOWeeksInYear () {
    return weeksInYear(this.year(), 1, 4);
}

function getWeeksInYear () {
    var weekInfo = this.localeData()._week;
    return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
}

function getSetWeekYearHelper(input, week, weekday, dow, doy) {
    var weeksTarget;
    if (input == null) {
        return weekOfYear(this, dow, doy).year;
    } else {
        weeksTarget = weeksInYear(input, dow, doy);
        if (week > weeksTarget) {
            week = weeksTarget;
        }
        return setWeekAll.call(this, input, week, weekday, dow, doy);
    }
}

function setWeekAll(weekYear, week, weekday, dow, doy) {
    var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
        date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

    this.year(date.getUTCFullYear());
    this.month(date.getUTCMonth());
    this.date(date.getUTCDate());
    return this;
}

// FORMATTING

addFormatToken('Q', 0, 'Qo', 'quarter');

// ALIASES

addUnitAlias('quarter', 'Q');

// PRIORITY

addUnitPriority('quarter', 7);

// PARSING

addRegexToken('Q', match1);
addParseToken('Q', function (input, array) {
    array[MONTH] = (toInt(input) - 1) * 3;
});

// MOMENTS

function getSetQuarter (input) {
    return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
}

// FORMATTING

addFormatToken('D', ['DD', 2], 'Do', 'date');

// ALIASES

addUnitAlias('date', 'D');

// PRIOROITY
addUnitPriority('date', 9);

// PARSING

addRegexToken('D',  match1to2);
addRegexToken('DD', match1to2, match2);
addRegexToken('Do', function (isStrict, locale) {
    // TODO: Remove "ordinalParse" fallback in next major release.
    return isStrict ?
      (locale._dayOfMonthOrdinalParse || locale._ordinalParse) :
      locale._dayOfMonthOrdinalParseLenient;
});

addParseToken(['D', 'DD'], DATE);
addParseToken('Do', function (input, array) {
    array[DATE] = toInt(input.match(match1to2)[0]);
});

// MOMENTS

var getSetDayOfMonth = makeGetSet('Date', true);

// FORMATTING

addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

// ALIASES

addUnitAlias('dayOfYear', 'DDD');

// PRIORITY
addUnitPriority('dayOfYear', 4);

// PARSING

addRegexToken('DDD',  match1to3);
addRegexToken('DDDD', match3);
addParseToken(['DDD', 'DDDD'], function (input, array, config) {
    config._dayOfYear = toInt(input);
});

// HELPERS

// MOMENTS

function getSetDayOfYear (input) {
    var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
    return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
}

// FORMATTING

addFormatToken('m', ['mm', 2], 0, 'minute');

// ALIASES

addUnitAlias('minute', 'm');

// PRIORITY

addUnitPriority('minute', 14);

// PARSING

addRegexToken('m',  match1to2);
addRegexToken('mm', match1to2, match2);
addParseToken(['m', 'mm'], MINUTE);

// MOMENTS

var getSetMinute = makeGetSet('Minutes', false);

// FORMATTING

addFormatToken('s', ['ss', 2], 0, 'second');

// ALIASES

addUnitAlias('second', 's');

// PRIORITY

addUnitPriority('second', 15);

// PARSING

addRegexToken('s',  match1to2);
addRegexToken('ss', match1to2, match2);
addParseToken(['s', 'ss'], SECOND);

// MOMENTS

var getSetSecond = makeGetSet('Seconds', false);

// FORMATTING

addFormatToken('S', 0, 0, function () {
    return ~~(this.millisecond() / 100);
});

addFormatToken(0, ['SS', 2], 0, function () {
    return ~~(this.millisecond() / 10);
});

addFormatToken(0, ['SSS', 3], 0, 'millisecond');
addFormatToken(0, ['SSSS', 4], 0, function () {
    return this.millisecond() * 10;
});
addFormatToken(0, ['SSSSS', 5], 0, function () {
    return this.millisecond() * 100;
});
addFormatToken(0, ['SSSSSS', 6], 0, function () {
    return this.millisecond() * 1000;
});
addFormatToken(0, ['SSSSSSS', 7], 0, function () {
    return this.millisecond() * 10000;
});
addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
    return this.millisecond() * 100000;
});
addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
    return this.millisecond() * 1000000;
});


// ALIASES

addUnitAlias('millisecond', 'ms');

// PRIORITY

addUnitPriority('millisecond', 16);

// PARSING

addRegexToken('S',    match1to3, match1);
addRegexToken('SS',   match1to3, match2);
addRegexToken('SSS',  match1to3, match3);

var token;
for (token = 'SSSS'; token.length <= 9; token += 'S') {
    addRegexToken(token, matchUnsigned);
}

function parseMs(input, array) {
    array[MILLISECOND] = toInt(('0.' + input) * 1000);
}

for (token = 'S'; token.length <= 9; token += 'S') {
    addParseToken(token, parseMs);
}
// MOMENTS

var getSetMillisecond = makeGetSet('Milliseconds', false);

// FORMATTING

addFormatToken('z',  0, 0, 'zoneAbbr');
addFormatToken('zz', 0, 0, 'zoneName');

// MOMENTS

function getZoneAbbr () {
    return this._isUTC ? 'UTC' : '';
}

function getZoneName () {
    return this._isUTC ? 'Coordinated Universal Time' : '';
}

var proto = Moment.prototype;

proto.add               = add;
proto.calendar          = calendar$1;
proto.clone             = clone;
proto.diff              = diff;
proto.endOf             = endOf;
proto.format            = format;
proto.from              = from;
proto.fromNow           = fromNow;
proto.to                = to;
proto.toNow             = toNow;
proto.get               = stringGet;
proto.invalidAt         = invalidAt;
proto.isAfter           = isAfter;
proto.isBefore          = isBefore;
proto.isBetween         = isBetween;
proto.isSame            = isSame;
proto.isSameOrAfter     = isSameOrAfter;
proto.isSameOrBefore    = isSameOrBefore;
proto.isValid           = isValid$2;
proto.lang              = lang;
proto.locale            = locale;
proto.localeData        = localeData;
proto.max               = prototypeMax;
proto.min               = prototypeMin;
proto.parsingFlags      = parsingFlags;
proto.set               = stringSet;
proto.startOf           = startOf;
proto.subtract          = subtract;
proto.toArray           = toArray;
proto.toObject          = toObject;
proto.toDate            = toDate;
proto.toISOString       = toISOString;
proto.inspect           = inspect;
proto.toJSON            = toJSON;
proto.toString          = toString;
proto.unix              = unix;
proto.valueOf           = valueOf;
proto.creationData      = creationData;

// Year
proto.year       = getSetYear;
proto.isLeapYear = getIsLeapYear;

// Week Year
proto.weekYear    = getSetWeekYear;
proto.isoWeekYear = getSetISOWeekYear;

// Quarter
proto.quarter = proto.quarters = getSetQuarter;

// Month
proto.month       = getSetMonth;
proto.daysInMonth = getDaysInMonth;

// Week
proto.week           = proto.weeks        = getSetWeek;
proto.isoWeek        = proto.isoWeeks     = getSetISOWeek;
proto.weeksInYear    = getWeeksInYear;
proto.isoWeeksInYear = getISOWeeksInYear;

// Day
proto.date       = getSetDayOfMonth;
proto.day        = proto.days             = getSetDayOfWeek;
proto.weekday    = getSetLocaleDayOfWeek;
proto.isoWeekday = getSetISODayOfWeek;
proto.dayOfYear  = getSetDayOfYear;

// Hour
proto.hour = proto.hours = getSetHour;

// Minute
proto.minute = proto.minutes = getSetMinute;

// Second
proto.second = proto.seconds = getSetSecond;

// Millisecond
proto.millisecond = proto.milliseconds = getSetMillisecond;

// Offset
proto.utcOffset            = getSetOffset;
proto.utc                  = setOffsetToUTC;
proto.local                = setOffsetToLocal;
proto.parseZone            = setOffsetToParsedOffset;
proto.hasAlignedHourOffset = hasAlignedHourOffset;
proto.isDST                = isDaylightSavingTime;
proto.isLocal              = isLocal;
proto.isUtcOffset          = isUtcOffset;
proto.isUtc                = isUtc;
proto.isUTC                = isUtc;

// Timezone
proto.zoneAbbr = getZoneAbbr;
proto.zoneName = getZoneName;

// Deprecations
proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);
proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);

function createUnix (input) {
    return createLocal(input * 1000);
}

function createInZone () {
    return createLocal.apply(null, arguments).parseZone();
}

function preParsePostFormat (string) {
    return string;
}

var proto$1 = Locale.prototype;

proto$1.calendar        = calendar;
proto$1.longDateFormat  = longDateFormat;
proto$1.invalidDate     = invalidDate;
proto$1.ordinal         = ordinal;
proto$1.preparse        = preParsePostFormat;
proto$1.postformat      = preParsePostFormat;
proto$1.relativeTime    = relativeTime;
proto$1.pastFuture      = pastFuture;
proto$1.set             = set;

// Month
proto$1.months            =        localeMonths;
proto$1.monthsShort       =        localeMonthsShort;
proto$1.monthsParse       =        localeMonthsParse;
proto$1.monthsRegex       = monthsRegex;
proto$1.monthsShortRegex  = monthsShortRegex;

// Week
proto$1.week = localeWeek;
proto$1.firstDayOfYear = localeFirstDayOfYear;
proto$1.firstDayOfWeek = localeFirstDayOfWeek;

// Day of Week
proto$1.weekdays       =        localeWeekdays;
proto$1.weekdaysMin    =        localeWeekdaysMin;
proto$1.weekdaysShort  =        localeWeekdaysShort;
proto$1.weekdaysParse  =        localeWeekdaysParse;

proto$1.weekdaysRegex       =        weekdaysRegex;
proto$1.weekdaysShortRegex  =        weekdaysShortRegex;
proto$1.weekdaysMinRegex    =        weekdaysMinRegex;

// Hours
proto$1.isPM = localeIsPM;
proto$1.meridiem = localeMeridiem;

function get$1 (format, index, field, setter) {
    var locale = getLocale();
    var utc = createUTC().set(setter, index);
    return locale[field](utc, format);
}

function listMonthsImpl (format, index, field) {
    if (isNumber(format)) {
        index = format;
        format = undefined;
    }

    format = format || '';

    if (index != null) {
        return get$1(format, index, field, 'month');
    }

    var i;
    var out = [];
    for (i = 0; i < 12; i++) {
        out[i] = get$1(format, i, field, 'month');
    }
    return out;
}

// ()
// (5)
// (fmt, 5)
// (fmt)
// (true)
// (true, 5)
// (true, fmt, 5)
// (true, fmt)
function listWeekdaysImpl (localeSorted, format, index, field) {
    if (typeof localeSorted === 'boolean') {
        if (isNumber(format)) {
            index = format;
            format = undefined;
        }

        format = format || '';
    } else {
        format = localeSorted;
        index = format;
        localeSorted = false;

        if (isNumber(format)) {
            index = format;
            format = undefined;
        }

        format = format || '';
    }

    var locale = getLocale(),
        shift = localeSorted ? locale._week.dow : 0;

    if (index != null) {
        return get$1(format, (index + shift) % 7, field, 'day');
    }

    var i;
    var out = [];
    for (i = 0; i < 7; i++) {
        out[i] = get$1(format, (i + shift) % 7, field, 'day');
    }
    return out;
}

function listMonths (format, index) {
    return listMonthsImpl(format, index, 'months');
}

function listMonthsShort (format, index) {
    return listMonthsImpl(format, index, 'monthsShort');
}

function listWeekdays (localeSorted, format, index) {
    return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
}

function listWeekdaysShort (localeSorted, format, index) {
    return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
}

function listWeekdaysMin (localeSorted, format, index) {
    return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
}

getSetGlobalLocale('en', {
    dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
    ordinal : function (number) {
        var b = number % 10,
            output = (toInt(number % 100 / 10) === 1) ? 'th' :
            (b === 1) ? 'st' :
            (b === 2) ? 'nd' :
            (b === 3) ? 'rd' : 'th';
        return number + output;
    }
});

// Side effect imports
hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);
hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);

var mathAbs = Math.abs;

function abs () {
    var data           = this._data;

    this._milliseconds = mathAbs(this._milliseconds);
    this._days         = mathAbs(this._days);
    this._months       = mathAbs(this._months);

    data.milliseconds  = mathAbs(data.milliseconds);
    data.seconds       = mathAbs(data.seconds);
    data.minutes       = mathAbs(data.minutes);
    data.hours         = mathAbs(data.hours);
    data.months        = mathAbs(data.months);
    data.years         = mathAbs(data.years);

    return this;
}

function addSubtract$1 (duration, input, value, direction) {
    var other = createDuration(input, value);

    duration._milliseconds += direction * other._milliseconds;
    duration._days         += direction * other._days;
    duration._months       += direction * other._months;

    return duration._bubble();
}

// supports only 2.0-style add(1, 's') or add(duration)
function add$1 (input, value) {
    return addSubtract$1(this, input, value, 1);
}

// supports only 2.0-style subtract(1, 's') or subtract(duration)
function subtract$1 (input, value) {
    return addSubtract$1(this, input, value, -1);
}

function absCeil (number) {
    if (number < 0) {
        return Math.floor(number);
    } else {
        return Math.ceil(number);
    }
}

function bubble () {
    var milliseconds = this._milliseconds;
    var days         = this._days;
    var months       = this._months;
    var data         = this._data;
    var seconds, minutes, hours, years, monthsFromDays;

    // if we have a mix of positive and negative values, bubble down first
    // check: https://github.com/moment/moment/issues/2166
    if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||
            (milliseconds <= 0 && days <= 0 && months <= 0))) {
        milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
        days = 0;
        months = 0;
    }

    // The following code bubbles up values, see the tests for
    // examples of what that means.
    data.milliseconds = milliseconds % 1000;

    seconds           = absFloor(milliseconds / 1000);
    data.seconds      = seconds % 60;

    minutes           = absFloor(seconds / 60);
    data.minutes      = minutes % 60;

    hours             = absFloor(minutes / 60);
    data.hours        = hours % 24;

    days += absFloor(hours / 24);

    // convert days to months
    monthsFromDays = absFloor(daysToMonths(days));
    months += monthsFromDays;
    days -= absCeil(monthsToDays(monthsFromDays));

    // 12 months -> 1 year
    years = absFloor(months / 12);
    months %= 12;

    data.days   = days;
    data.months = months;
    data.years  = years;

    return this;
}

function daysToMonths (days) {
    // 400 years have 146097 days (taking into account leap year rules)
    // 400 years have 12 months === 4800
    return days * 4800 / 146097;
}

function monthsToDays (months) {
    // the reverse of daysToMonths
    return months * 146097 / 4800;
}

function as (units) {
    if (!this.isValid()) {
        return NaN;
    }
    var days;
    var months;
    var milliseconds = this._milliseconds;

    units = normalizeUnits(units);

    if (units === 'month' || units === 'year') {
        days   = this._days   + milliseconds / 864e5;
        months = this._months + daysToMonths(days);
        return units === 'month' ? months : months / 12;
    } else {
        // handle milliseconds separately because of floating point math errors (issue #1867)
        days = this._days + Math.round(monthsToDays(this._months));
        switch (units) {
            case 'week'   : return days / 7     + milliseconds / 6048e5;
            case 'day'    : return days         + milliseconds / 864e5;
            case 'hour'   : return days * 24    + milliseconds / 36e5;
            case 'minute' : return days * 1440  + milliseconds / 6e4;
            case 'second' : return days * 86400 + milliseconds / 1000;
            // Math.floor prevents floating point math errors here
            case 'millisecond': return Math.floor(days * 864e5) + milliseconds;
            default: throw new Error('Unknown unit ' + units);
        }
    }
}

// TODO: Use this.as('ms')?
function valueOf$1 () {
    if (!this.isValid()) {
        return NaN;
    }
    return (
        this._milliseconds +
        this._days * 864e5 +
        (this._months % 12) * 2592e6 +
        toInt(this._months / 12) * 31536e6
    );
}

function makeAs (alias) {
    return function () {
        return this.as(alias);
    };
}

var asMilliseconds = makeAs('ms');
var asSeconds      = makeAs('s');
var asMinutes      = makeAs('m');
var asHours        = makeAs('h');
var asDays         = makeAs('d');
var asWeeks        = makeAs('w');
var asMonths       = makeAs('M');
var asYears        = makeAs('y');

function clone$1 () {
    return createDuration(this);
}

function get$2 (units) {
    units = normalizeUnits(units);
    return this.isValid() ? this[units + 's']() : NaN;
}

function makeGetter(name) {
    return function () {
        return this.isValid() ? this._data[name] : NaN;
    };
}

var milliseconds = makeGetter('milliseconds');
var seconds      = makeGetter('seconds');
var minutes      = makeGetter('minutes');
var hours        = makeGetter('hours');
var days         = makeGetter('days');
var months       = makeGetter('months');
var years        = makeGetter('years');

function weeks () {
    return absFloor(this.days() / 7);
}

var round = Math.round;
var thresholds = {
    ss: 44,         // a few seconds to seconds
    s : 45,         // seconds to minute
    m : 45,         // minutes to hour
    h : 22,         // hours to day
    d : 26,         // days to month
    M : 11          // months to year
};

// helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
    return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
}

function relativeTime$1 (posNegDuration, withoutSuffix, locale) {
    var duration = createDuration(posNegDuration).abs();
    var seconds  = round(duration.as('s'));
    var minutes  = round(duration.as('m'));
    var hours    = round(duration.as('h'));
    var days     = round(duration.as('d'));
    var months   = round(duration.as('M'));
    var years    = round(duration.as('y'));

    var a = seconds <= thresholds.ss && ['s', seconds]  ||
            seconds < thresholds.s   && ['ss', seconds] ||
            minutes <= 1             && ['m']           ||
            minutes < thresholds.m   && ['mm', minutes] ||
            hours   <= 1             && ['h']           ||
            hours   < thresholds.h   && ['hh', hours]   ||
            days    <= 1             && ['d']           ||
            days    < thresholds.d   && ['dd', days]    ||
            months  <= 1             && ['M']           ||
            months  < thresholds.M   && ['MM', months]  ||
            years   <= 1             && ['y']           || ['yy', years];

    a[2] = withoutSuffix;
    a[3] = +posNegDuration > 0;
    a[4] = locale;
    return substituteTimeAgo.apply(null, a);
}

// This function allows you to set the rounding function for relative time strings
function getSetRelativeTimeRounding (roundingFunction) {
    if (roundingFunction === undefined) {
        return round;
    }
    if (typeof(roundingFunction) === 'function') {
        round = roundingFunction;
        return true;
    }
    return false;
}

// This function allows you to set a threshold for relative time strings
function getSetRelativeTimeThreshold (threshold, limit) {
    if (thresholds[threshold] === undefined) {
        return false;
    }
    if (limit === undefined) {
        return thresholds[threshold];
    }
    thresholds[threshold] = limit;
    if (threshold === 's') {
        thresholds.ss = limit - 1;
    }
    return true;
}

function humanize (withSuffix) {
    if (!this.isValid()) {
        return this.localeData().invalidDate();
    }

    var locale = this.localeData();
    var output = relativeTime$1(this, !withSuffix, locale);

    if (withSuffix) {
        output = locale.pastFuture(+this, output);
    }

    return locale.postformat(output);
}

var abs$1 = Math.abs;

function sign(x) {
    return ((x > 0) - (x < 0)) || +x;
}

function toISOString$1() {
    // for ISO strings we do not use the normal bubbling rules:
    //  * milliseconds bubble up until they become hours
    //  * days do not bubble at all
    //  * months bubble up until they become years
    // This is because there is no context-free conversion between hours and days
    // (think of clock changes)
    // and also not between days and months (28-31 days per month)
    if (!this.isValid()) {
        return this.localeData().invalidDate();
    }

    var seconds = abs$1(this._milliseconds) / 1000;
    var days         = abs$1(this._days);
    var months       = abs$1(this._months);
    var minutes, hours, years;

    // 3600 seconds -> 60 minutes -> 1 hour
    minutes           = absFloor(seconds / 60);
    hours             = absFloor(minutes / 60);
    seconds %= 60;
    minutes %= 60;

    // 12 months -> 1 year
    years  = absFloor(months / 12);
    months %= 12;


    // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
    var Y = years;
    var M = months;
    var D = days;
    var h = hours;
    var m = minutes;
    var s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, '') : '';
    var total = this.asSeconds();

    if (!total) {
        // this is the same as C#'s (Noda) and python (isodate)...
        // but not other JS (goog.date)
        return 'P0D';
    }

    var totalSign = total < 0 ? '-' : '';
    var ymSign = sign(this._months) !== sign(total) ? '-' : '';
    var daysSign = sign(this._days) !== sign(total) ? '-' : '';
    var hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';

    return totalSign + 'P' +
        (Y ? ymSign + Y + 'Y' : '') +
        (M ? ymSign + M + 'M' : '') +
        (D ? daysSign + D + 'D' : '') +
        ((h || m || s) ? 'T' : '') +
        (h ? hmsSign + h + 'H' : '') +
        (m ? hmsSign + m + 'M' : '') +
        (s ? hmsSign + s + 'S' : '');
}

var proto$2 = Duration.prototype;

proto$2.isValid        = isValid$1;
proto$2.abs            = abs;
proto$2.add            = add$1;
proto$2.subtract       = subtract$1;
proto$2.as             = as;
proto$2.asMilliseconds = asMilliseconds;
proto$2.asSeconds      = asSeconds;
proto$2.asMinutes      = asMinutes;
proto$2.asHours        = asHours;
proto$2.asDays         = asDays;
proto$2.asWeeks        = asWeeks;
proto$2.asMonths       = asMonths;
proto$2.asYears        = asYears;
proto$2.valueOf        = valueOf$1;
proto$2._bubble        = bubble;
proto$2.clone          = clone$1;
proto$2.get            = get$2;
proto$2.milliseconds   = milliseconds;
proto$2.seconds        = seconds;
proto$2.minutes        = minutes;
proto$2.hours          = hours;
proto$2.days           = days;
proto$2.weeks          = weeks;
proto$2.months         = months;
proto$2.years          = years;
proto$2.humanize       = humanize;
proto$2.toISOString    = toISOString$1;
proto$2.toString       = toISOString$1;
proto$2.toJSON         = toISOString$1;
proto$2.locale         = locale;
proto$2.localeData     = localeData;

// Deprecations
proto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);
proto$2.lang = lang;

// Side effect imports

// FORMATTING

addFormatToken('X', 0, 0, 'unix');
addFormatToken('x', 0, 0, 'valueOf');

// PARSING

addRegexToken('x', matchSigned);
addRegexToken('X', matchTimestamp);
addParseToken('X', function (input, array, config) {
    config._d = new Date(parseFloat(input, 10) * 1000);
});
addParseToken('x', function (input, array, config) {
    config._d = new Date(toInt(input));
});

// Side effect imports


hooks.version = '2.20.1';

setHookCallback(createLocal);

hooks.fn                    = proto;
hooks.min                   = min;
hooks.max                   = max;
hooks.now                   = now;
hooks.utc                   = createUTC;
hooks.unix                  = createUnix;
hooks.months                = listMonths;
hooks.isDate                = isDate;
hooks.locale                = getSetGlobalLocale;
hooks.invalid               = createInvalid;
hooks.duration              = createDuration;
hooks.isMoment              = isMoment;
hooks.weekdays              = listWeekdays;
hooks.parseZone             = createInZone;
hooks.localeData            = getLocale;
hooks.isDuration            = isDuration;
hooks.monthsShort           = listMonthsShort;
hooks.weekdaysMin           = listWeekdaysMin;
hooks.defineLocale          = defineLocale;
hooks.updateLocale          = updateLocale;
hooks.locales               = listLocales;
hooks.weekdaysShort         = listWeekdaysShort;
hooks.normalizeUnits        = normalizeUnits;
hooks.relativeTimeRounding  = getSetRelativeTimeRounding;
hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
hooks.calendarFormat        = getCalendarFormat;
hooks.prototype             = proto;

// currently HTML5 input type only supports 24-hour formats
hooks.HTML5_FMT = {
    DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm',             // <input type="datetime-local" />
    DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss',  // <input type="datetime-local" step="1" />
    DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS',   // <input type="datetime-local" step="0.001" />
    DATE: 'YYYY-MM-DD',                             // <input type="date" />
    TIME: 'HH:mm',                                  // <input type="time" />
    TIME_SECONDS: 'HH:mm:ss',                       // <input type="time" step="1" />
    TIME_MS: 'HH:mm:ss.SSS',                        // <input type="time" step="0.001" />
    WEEK: 'YYYY-[W]WW',                             // <input type="week" />
    MONTH: 'YYYY-MM'                                // <input type="month" />
};

return hooks;

})));

},{}],390:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],391:[function(require,module,exports){
module.exports = require('./lib/index');

},{"./lib/index":392}],392:[function(require,module,exports){
(function (global){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _ponyfill = require('./ponyfill.js');

var _ponyfill2 = _interopRequireDefault(_ponyfill);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var root; /* global window */


if (typeof self !== 'undefined') {
  root = self;
} else if (typeof window !== 'undefined') {
  root = window;
} else if (typeof global !== 'undefined') {
  root = global;
} else if (typeof module !== 'undefined') {
  root = module;
} else {
  root = Function('return this')();
}

var result = (0, _ponyfill2['default'])(root);
exports['default'] = result;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./ponyfill.js":393}],393:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports['default'] = symbolObservablePonyfill;
function symbolObservablePonyfill(root) {
	var result;
	var _Symbol = root.Symbol;

	if (typeof _Symbol === 'function') {
		if (_Symbol.observable) {
			result = _Symbol.observable;
		} else {
			result = _Symbol('observable');
			_Symbol.observable = result;
		}
	} else {
		result = '@@observable';
	}

	return result;
};
},{}],394:[function(require,module,exports){
(function (process){
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

'use strict';

/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var warning = function() {};

if (process.env.NODE_ENV !== 'production') {
  warning = function(condition, format, args) {
    var len = arguments.length;
    args = new Array(len > 2 ? len - 2 : 0);
    for (var key = 2; key < len; key++) {
      args[key - 2] = arguments[key];
    }
    if (format === undefined) {
      throw new Error(
        '`warning(condition, format, ...args)` requires a warning ' +
        'message argument'
      );
    }

    if (format.length < 10 || (/^[s\W]*$/).test(format)) {
      throw new Error(
        'The warning format should be able to uniquely identify this ' +
        'warning. Please, use a more descriptive format than: ' + format
      );
    }

    if (!condition) {
      var argIndex = 0;
      var message = 'Warning: ' +
        format.replace(/%s/g, function() {
          return args[argIndex++];
        });
      if (typeof console !== 'undefined') {
        console.error(message);
      }
      try {
        // This error was thrown as a convenience so that you can use this stack
        // to find the callsite that caused this warning to fire.
        throw new Error(message);
      } catch(x) {}
    }
  };
}

module.exports = warning;

}).call(this,require('_process'))

},{"_process":390}],395:[function(require,module,exports){
module.exports={
  "name": "@kynikos/wiki-monkey",
  "version": "4.0.0",
  "author": "Dario Giovannetti",
  "description": "MediaWiki bot and editor-assistant user script.",
  "license": "GPL-3.0",
  "repository": {
    "type": "git",
    "url": "https://github.com/kynikos/wiki-monkey.git"
  },
  "keywords": [
    "wiki mediawiki bot"
  ],
  "dependencies": {
    "@kynikos/misc": "^0.1.3",
    "babel-polyfill": "^6.26.0",
    "hyperscript": "^2.0.2",
    "hyperscript-helpers": "^3.0.3",
    "jss": "^9.5.1",
    "jss-preset-default": "^4.1.0",
    "moment": "^2.20.1"
  },
  "devDependencies": {
    "@kynikos/browserify-helpers": "^1.0.7",
    "babel-core": "^6.26.0",
    "babel-preset-env": "^1.6.1",
    "coffeelint": "^2.0.7",
    "coffeescript": "^2.1.1",
    "http-server": "^0.11.1"
  }
}

},{}],396:[function(require,module,exports){
"use strict";

var WM;

var _require = require('./modules/_Init');

WM = _require.WM;

new WM("ArchWiki", require("./plugins/ArchWikiFixHeader"), require("./plugins/ArchWikiFixHeadings"), require("./plugins/ArchWikiFixLinks"), require("./plugins/ArchWikiNewTemplates"), require("./plugins/ArchWikiNPFilter"), require("./plugins/ArchWikiRCFilter"), require("./plugins/ArchWikiSaveTalk"), require("./plugins/ArchWikiSortContacts"), require("./plugins/ArchWikiWantedCategories"), require("./plugins/DeletePages"), require("./plugins/ExpandContractions"), require("./plugins/FixBacklinkFragments"), require("./plugins/FixDoubleRedirects"), require("./plugins/FixFragments"), require("./plugins/FixLinkFragments"), require("./plugins/MultipleLineBreaks"), require("./plugins/SimpleReplace"), require("./plugins/SynchronizeInterlanguageLinks"), require("./plugins/UpdateCategoryTree"));

},{"./modules/_Init":413,"./plugins/ArchWikiFixHeader":415,"./plugins/ArchWikiFixHeadings":416,"./plugins/ArchWikiFixLinks":417,"./plugins/ArchWikiNPFilter":418,"./plugins/ArchWikiNewTemplates":419,"./plugins/ArchWikiRCFilter":420,"./plugins/ArchWikiSaveTalk":421,"./plugins/ArchWikiSortContacts":422,"./plugins/ArchWikiWantedCategories":423,"./plugins/DeletePages":424,"./plugins/ExpandContractions":425,"./plugins/FixBacklinkFragments":426,"./plugins/FixDoubleRedirects":427,"./plugins/FixFragments":428,"./plugins/FixLinkFragments":429,"./plugins/MultipleLineBreaks":430,"./plugins/SimpleReplace":431,"./plugins/SynchronizeInterlanguageLinks":432,"./plugins/UpdateCategoryTree":433}],397:[function(require,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

module.exports = function () {
  var languages, tablesOfContents;

  var exports = function () {
    function exports(WM) {
      _classCallCheck(this, exports);

      this.WM = WM;
    }

    _createClass(exports, [{
      key: "getLocalLanguage",
      value: function getLocalLanguage() {
        return languages.local;
      }
    }, {
      key: "getCategoryLanguages",
      value: function getCategoryLanguages() {
        return languages.categories;
      }
    }, {
      key: "isCategoryLanguage",
      value: function isCategoryLanguage(lang) {
        return languages.categories.indexOf(lang) > -1;
      }
    }, {
      key: "getInterwikiLanguages",
      value: function getInterwikiLanguages() {
        return languages.interlanguage.external.concat(languages.interlanguage.internal);
      }
    }, {
      key: "isInterwikiLanguage",
      value: function isInterwikiLanguage(lang) {
        return this.getInterwikiLanguages().indexOf(lang) > -1;
      }
    }, {
      key: "getInternalInterwikiLanguages",
      value: function getInternalInterwikiLanguages() {
        return languages.interlanguage.internal;
      }
    }, {
      key: "isInternalInterwikiLanguage",
      value: function isInternalInterwikiLanguage(lang) {
        return languages.interlanguage.internal.indexOf(lang) > -1;
      }
    }, {
      key: "getInterlanguageTag",
      value: function getInterlanguageTag(language) {
        return languages.names[language].subtag;
      }
    }, {
      key: "detectLanguage",
      value: function detectLanguage(title) {
        var detectedLanguage, matches, pureTitle, testLangCat;
        matches = title.match(/^(.+?)(?:[ _]\(([^\(]+)\))?$/);
        pureTitle = matches[1];
        detectedLanguage = matches[2];
        if (!detectedLanguage || !this.isCategoryLanguage(detectedLanguage)) {
          testLangCat = matches[1].match(/^[ _]*[Cc]ategory[ _]*:[ _]*(.+?)[ _]*$/);
          if (testLangCat && this.isCategoryLanguage(testLangCat[1])) {
            detectedLanguage = testLangCat[1];
            pureTitle = matches[1];
          } else {
            detectedLanguage = this.getLocalLanguage();
            pureTitle = matches[0];
          }
        }
        return [pureTitle, detectedLanguage];
      }
    }, {
      key: "findAllInterlanguageLinks",
      value: function findAllInterlanguageLinks(source) {
        return this.WM.Parser.findSpecialLinks(source, this.getInterwikiLanguages().join("|"));
      }
    }, {
      key: "findInternalInterlanguageLinks",
      value: function findInternalInterlanguageLinks(source) {
        return this.WM.Parser.findSpecialLinks(source, this.getInternalInterwikiLanguages().join("|"));
      }
    }, {
      key: "getTableOfContents",
      value: function getTableOfContents(tag) {
        return tablesOfContents[tag];
      }
    }]);

    return exports;
  }();

  ;

  languages = {
    local: "English",
    names: {
      "العربية": {
        subtag: "ar",
        english: "Arabic"
      },
      "Български": {
        subtag: "bg",
        english: "Bulgarian"
      },
      "Català": {
        subtag: "ca",
        english: "Catalan"
      },
      "Česky": {
        subtag: "cs",
        english: "Czech"
      },
      "Dansk": {
        subtag: "da",
        english: "Danish"
      },
      "Deutsch": {
        subtag: "de",
        english: "German"
      },
      "Ελληνικά": {
        subtag: "el",
        english: "Greek"
      },
      "English": {
        subtag: "en",
        english: "English"
      },
      "Esperanto": {
        subtag: "eo",
        english: "Esperanto"
      },
      "Español": {
        subtag: "es",
        english: "Spanish"
      },
      "فارسی": {
        subtag: "fa",
        english: "Persian"
      },
      "Suomi": {
        subtag: "fi",
        english: "Finnish"
      },
      "Français": {
        subtag: "fr",
        english: "French"
      },
      "עברית": {
        subtag: "he",
        english: "Hebrew"
      },
      "Hrvatski": {
        subtag: "hr",
        english: "Croatian"
      },
      "Magyar": {
        subtag: "hu",
        english: "Hungarian"
      },
      "Indonesia": {
        subtag: "id",
        english: "Indonesian"
      },
      "Italiano": {
        subtag: "it",
        english: "Italian"
      },
      "日本語": {
        subtag: "ja",
        english: "Japanese"
      },
      "한국어": {
        subtag: "ko",
        english: "Korean"
      },
      "Lietuviškai": {
        subtag: "lt",
        english: "Lithuanian"
      },
      "Norsk Bokmål": {
        subtag: "nb",
        english: "Norwegian (Bokmål)"
      },
      "Nederlands": {
        subtag: "nl",
        english: "Dutch"
      },
      "Polski": {
        subtag: "pl",
        english: "Polish"
      },
      "Português": {
        subtag: "pt",
        english: "Portuguese"
      },
      "Română": {
        subtag: "ro",
        english: "Romanian"
      },
      "Русский": {
        subtag: "ru",
        english: "Russian"
      },
      "Slovenský": {
        subtag: "sk",
        english: "Slovak"
      },
      "Српски": {
        subtag: "sr",
        english: "Serbian"
      },
      "Svenska": {
        subtag: "sv",
        english: "Swedish"
      },
      "ไทย": {
        subtag: "th",
        english: "Thai"
      },
      "Türkçe": {
        subtag: "tr",
        english: "Turkish"
      },
      "Українська": {
        subtag: "uk",
        english: "Ukrainian"
      },
      "Tiếng Việt": {
        subtag: "vi",
        english: "Vietnamese"
      },
      "简体中文": {
        subtag: "zh-hans",
        english: "Chinese (Simplified)"
      },
      "正體中文": {
        subtag: "zh-hant",
        english: "Chinese (Traditional)"
      }
    },
    categories: ["العربية", "Български", "Català", "Česky", "Dansk", "Ελληνικά", "English", "Esperanto", "Español", "Suomi", "עברית", "Hrvatski", "Magyar", "Indonesia", "Italiano", "日本語", "한국어", "Lietuviškai", "Norsk Bokmål", "Nederlands", "Polski", "Português", "Русский", "Slovenský", "Српски", "ไทย", "Türkçe", "Українська", "简体中文", "正體中文"],
    interlanguage: {
      external: ["de", "fa", "fr", "ja", "ro"],
      internal: ["ar", "bg", "cs", "da", "el", "en", "es", "fi", "he", "hr", "hu", "id", "it", "ko", "lt", "nl", "pl", "pt", "ru", "sk", "sr", "sv", "th", "tr", "uk", "zh-hans", "zh-hant"]
    }
  };

  tablesOfContents = {
    "ar": {
      "page": "Table of contents (العربية)",
      "root": "Category:العربية",
      "alsoIn": "also in",
      "indentType": ":",
      "replace": ["[ _]\\(العربية\\)", "", ""],
      "keepAltName": true,
      "showIndices": true,
      "rightToLeft": true
    },
    "bg": {
      "page": "Table of contents (Български)",
      "root": "Category:Български",
      "alsoIn": "също в",
      "indentType": ":",
      "replace": ["[ _]\\(Български\\)", "", ""],
      "keepAltName": true,
      "showIndices": true,
      "rightToLeft": false
    },
    "cs": {
      "page": "Table of contents (Česky)",
      "root": "Category:Česky",
      "alsoIn": "také v",
      "indentType": ":",
      "replace": ["[ _]\\(Česky\\)", "", ""],
      "keepAltName": true,
      "showIndices": true,
      "rightToLeft": false
    },
    "da": {
      "page": "Table of contents (Dansk)",
      "root": "Category:Dansk",
      "alsoIn": "også i",
      "indentType": ":",
      "replace": ["[ _]\\(Dansk\\)", "", ""],
      "keepAltName": true,
      "showIndices": true,
      "rightToLeft": false
    },
    "el": {
      "page": "Table of contents (Ελληνικά)",
      "root": "Category:Ελληνικά",
      "alsoIn": "επίσης σε",
      "indentType": ":",
      "replace": ["[ _]\\(Ελληνικά\\)", "", ""],
      "keepAltName": true,
      "showIndices": true,
      "rightToLeft": false
    },
    "en": {
      "page": "Table of contents",
      "root": "Category:English",
      "alsoIn": "also in",
      "indentType": ":",
      "replace": null,
      "keepAltName": false,
      "showIndices": true,
      "rightToLeft": false
    },
    "es": {
      "page": "Table of contents (Español)",
      "root": "Category:Español",
      "alsoIn": "también en",
      "indentType": ":",
      "replace": ["[ _]\\(Español\\)", "", ""],
      "keepAltName": true,
      "showIndices": true,
      "rightToLeft": false
    },
    "he": {
      "page": "Table of contents (עברית)",
      "root": "Category:עברית",
      "alsoIn": "also in",
      "indentType": ":",
      "replace": ["[ _]\\(עברית\\)", "", ""],
      "keepAltName": true,
      "showIndices": true,
      "rightToLeft": true
    },
    "hr": {
      "page": "Table of contents (Hrvatski)",
      "root": "Category:Hrvatski",
      "alsoIn": "također u",
      "indentType": ":",
      "replace": ["[ _]\\(Hrvatski\\)", "", ""],
      "keepAltName": true,
      "showIndices": true,
      "rightToLeft": false
    },
    "hu": {
      "page": "Table of contents (Magyar)",
      "root": "Category:Magyar",
      "alsoIn": "is",
      "indentType": ":",
      "replace": ["[ _]\\(Magyar\\)", "", ""],
      "keepAltName": true,
      "showIndices": true,
      "rightToLeft": false
    },
    "id": {
      "page": "Table of contents (Indonesia)",
      "root": "Category:Indonesia",
      "alsoIn": "juga di",
      "indentType": ":",
      "replace": ["[ _]\\(Indonesia\\)", "", ""],
      "keepAltName": true,
      "showIndices": true,
      "rightToLeft": false
    },
    "it": {
      "page": "Table of contents (Italiano)",
      "root": "Category:Italiano",
      "alsoIn": "anche in",
      "indentType": ":",
      "replace": ["[ _]\\(Italiano\\)", "", ""],
      "keepAltName": true,
      "showIndices": true,
      "rightToLeft": false
    },
    "ko": {
      "page": "Table of contents (한국어)",
      "root": "Category:한국어",
      "alsoIn": "또한 에",
      "indentType": ":",
      "replace": ["[ _]\\(한국어\\)", "", ""],
      "keepAltName": true,
      "showIndices": true,
      "rightToLeft": false
    },
    "lt": {
      "page": "Table of contents (Lietuviškai)",
      "root": "Category:Lietuviškai",
      "alsoIn": "taip pat ir",
      "indentType": ":",
      "replace": ["[ _]\\(Lietuviškai\\)", "", ""],
      "keepAltName": true,
      "showIndices": true,
      "rightToLeft": false
    },
    "nl": {
      "page": "Table of contents (Nederlands)",
      "root": "Category:Nederlands",
      "alsoIn": "ook in",
      "indentType": ":",
      "replace": ["[ _]\\(Nederlands\\)", "", ""],
      "keepAltName": true,
      "showIndices": true,
      "rightToLeft": false
    },
    "pl": {
      "page": "Table of contents (Polski)",
      "root": "Category:Polski",
      "alsoIn": "również w",
      "indentType": ":",
      "replace": ["[ _]\\(Polski\\)", "", ""],
      "keepAltName": true,
      "showIndices": true,
      "rightToLeft": false
    },
    "pt": {
      "page": "Table of contents (Português)",
      "root": "Category:Português",
      "alsoIn": "também em",
      "indentType": ":",
      "replace": ["[ _]\\(Português\\)", "", ""],
      "keepAltName": true,
      "showIndices": true,
      "rightToLeft": false
    },
    "ru": {
      "page": "Table of contents (Русский)",
      "root": "Category:Русский",
      "alsoIn": "Также в",
      "indentType": ":",
      "replace": ["[ _]\\(Русский\\)", "", ""],
      "keepAltName": true,
      "showIndices": true,
      "rightToLeft": false
    },
    "sk": {
      "page": "Table of contents (Slovenský)",
      "root": "Category:Slovenský",
      "alsoIn": "tiež v",
      "indentType": ":",
      "replace": ["[ _]\\(Slovenský\\)", "", ""],
      "keepAltName": true,
      "showIndices": true,
      "rightToLeft": false
    },
    "sr": {
      "page": "Table of contents (Српски)",
      "root": "Category:Српски",
      "alsoIn": "такође у",
      "indentType": ":",
      "replace": ["[ _]\\(Српски\\)", "", ""],
      "keepAltName": true,
      "showIndices": true,
      "rightToLeft": false
    },
    "th": {
      "page": "Table of contents (ไทย)",
      "root": "Category:ไทย",
      "alsoIn": "ยังอยู่ใน",
      "indentType": ":",
      "replace": ["[ _]\\(ไทย\\)", "", ""],
      "keepAltName": true,
      "showIndices": true,
      "rightToLeft": false
    },
    "tr": {
      "page": "Table of contents (Türkçe)",
      "root": "Category:Türkçe",
      "alsoIn": "ayrıca",
      "indentType": ":",
      "replace": ["[ _]\\(Türkçe\\)", "", ""],
      "keepAltName": true,
      "showIndices": true,
      "rightToLeft": false
    },
    "uk": {
      "page": "Table of contents (Українська)",
      "root": "Category:Українська",
      "alsoIn": "також в",
      "indentType": ":",
      "replace": ["[ _]\\(Українська\\)", "", ""],
      "keepAltName": true,
      "showIndices": true,
      "rightToLeft": false
    },
    "zh-hans": {
      "page": "Table of contents (简体中文)",
      "root": "Category:简体中文",
      "alsoIn": "同时还属于",
      "indentType": ":",
      "replace": ["[ _]\\(简体中文\\)", "", ""],
      "keepAltName": true,
      "showIndices": true,
      "rightToLeft": false
    },
    "zh-hant": {
      "page": "Table of contents (正體中文)",
      "root": "Category:正體中文",
      "alsoIn": "還在",
      "indentType": ":",
      "replace": ["[ _]\\(正體中文\\)", "", ""],
      "keepAltName": true,
      "showIndices": true,
      "rightToLeft": false
    }
  };

  return exports;
}.call(undefined);

},{}],398:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var CSS;

CSS = require('@kynikos/misc/dist/CSS');

module.exports = function () {
  function exports(WM) {
    _classCallCheck(this, exports);

    this._previewFilter = this._previewFilter.bind(this);
    this._startAutomatic = this._startAutomatic.bind(this);
    this._startAutomaticContinue = this._startAutomaticContinue.bind(this);
    this.WM = WM;
    this.configuration = {
      plugin_name: null,
      function_: function function_() {},
      filters: [],
      list: {
        current: null,
        previous: null
      },
      visited: []
    };

    this.botToken = "0";
  }

  _createClass(exports, [{
    key: '_makeUI',
    value: function _makeUI(functions, lists) {
      var divContainer, fdiv;
      divContainer = document.createElement('div');
      divContainer.id = 'WikiMonkeyBot';
      CSS.addStyleElement("#WikiMonkeyBot-PluginSelect {width:100%; margin-bottom:1em;} #WikiMonkeyBot-ListSelect {margin-bottom:1em;} #WikiMonkeyBotFilter {height:6em; margin-bottom:1em; resize:vertical;} #WikiMonkeyBotStart, #WikiMonkeyBotStop {margin-right:0.33em; margin-bottom:1em; font-weight:bold;} a.WikiMonkeyBotSelected {background-color:#faa; padding:0.2em 0.4em;} a.WikiMonkeyBotProcessing {background-color:#ff8; padding:0.2em 0.4em;} a.WikiMonkeyBotChanged {background-color:#afa; padding:0.2em 0.4em;} a.WikiMonkeyBotUnchanged {background-color:#aaf; padding:0.2em 0.4em;} a.WikiMonkeyBotBypassed {background-color:orangered; padding:0.2em 0.4em;} a.WikiMonkeyBotFailed {background-color:red; padding:0.2em 0.4em;}");
      fdiv = this.makeFunctionUI(functions);
      if (fdiv) {
        divContainer.appendChild(fdiv);
        divContainer.appendChild(this.makeConfUI(lists));
        return divContainer;
      } else {
        return false;
      }
    }
  }, {
    key: 'makeFunctionUI',
    value: function makeFunctionUI(functions) {
      var Plugin, divFunction, ffunctions, fieldset, i, legend, len, makeUI, option, plugin, pluginInst, selectFunctions, self;
      self = this;
      fieldset = document.createElement('fieldset');
      legend = document.createElement('legend');
      legend.innerHTML = 'Plugin';
      selectFunctions = document.createElement('select');
      selectFunctions.id = 'WikiMonkeyBot-PluginSelect';
      ffunctions = [];
      for (i = 0, len = functions.length; i < len; i++) {
        Plugin = functions[i];
        plugin = new Plugin(this.WM);
        pluginInst = plugin.conf.bot_label;

        if (!pluginInst || !pluginInst.length) {
          continue;
        }
        ffunctions.push(plugin);
        option = document.createElement('option');
        option.innerHTML = pluginInst;
        if (plugin.constructor.name === this.WM.conf.default_bot_plugin) {
          option.selected = true;
        }
        selectFunctions.appendChild(option);
      }
      if (ffunctions.length) {
        selectFunctions.addEventListener("change", function (ffunctions) {
          return function () {
            var UI, id, makeUI, select;
            select = document.getElementById('WikiMonkeyBot-PluginSelect');
            id = select.selectedIndex;
            UI = document.getElementById('WikiMonkeyBotFunction');
            plugin = ffunctions[id];

            makeUI = plugin.makeBotUI;
            if (makeUI instanceof Function) {
              UI.replaceChild(makeUI(), UI.firstChild);
            } else {
              UI.replaceChild(document.createElement('div'), UI.firstChild);
            }
            self.configuration.plugin_name = plugin.constructor.name;
            return self.configuration.function_ = function (title, callContinue, chainArgs) {
              return plugin.main_bot(title, callContinue, chainArgs);
            };
          };
        }(ffunctions), false);
        divFunction = document.createElement('div');
        divFunction.id = "WikiMonkeyBotFunction";
        plugin = ffunctions[selectFunctions.selectedIndex];

        makeUI = plugin.makeBotUI;
        if (makeUI instanceof Function) {
          divFunction.appendChild(makeUI());
        } else {
          divFunction.appendChild(document.createElement('div'));
        }
        this.configuration.plugin_name = plugin.constructor.name;
        this.configuration.function_ = function (title, callContinue, chainArgs) {
          return plugin.main_bot(title, callContinue, chainArgs);
        };
        fieldset.appendChild(legend);
        fieldset.appendChild(selectFunctions);
        fieldset.appendChild(divFunction);
        return fieldset;
      } else {
        return false;
      }
    }
  }, {
    key: 'makeListSelector',
    value: function makeListSelector(lists) {
      var i, len, list, option, selectLists, self;
      self = this;
      selectLists = document.createElement('select');
      selectLists.id = 'WikiMonkeyBot-ListSelect';
      for (i = 0, len = lists.length; i < len; i++) {
        list = lists[i];
        if (list[0]) {
          option = document.createElement('option');
          option.innerHTML = list[2];
          selectLists.appendChild(option);
          if (!this.configuration.list.current) {
            this.configuration.list.current = list;
          }
        }
      }
      selectLists.addEventListener("change", function (lss) {
        return function () {
          var id, select;
          select = document.getElementById('WikiMonkeyBot-ListSelect');
          id = select.selectedIndex;
          self.configuration.list.previous = self.configuration.list.current;

          return self.configuration.list.current = lss[id];
        };
      }(lists), false);
      return selectLists;
    }
  }, {
    key: 'makeConfUI',
    value: function makeConfUI(lists) {
      var bot, duplicates, duplicatestag, elem, elems, fieldset, filter, forceStart, forceStartCB, forceStartLabel, i, inverse, inversetag, legend, len, listSelect, preview, self, start, startMsg;
      self = this;
      bot = document.createElement('div');
      fieldset = document.createElement('fieldset');
      legend = document.createElement('legend');
      legend.innerHTML = 'Filter';
      listSelect = this.makeListSelector(lists);
      filter = document.createElement('textarea');
      filter.id = 'WikiMonkeyBotFilter';
      preview = document.createElement('input');
      preview.id = 'WikiMonkeyBotPreview';
      preview.type = 'button';
      preview.value = 'Preview';
      duplicates = document.createElement('input');
      duplicates.type = 'checkbox';
      duplicates.id = 'WikiMonkeyBotDuplicates';
      inverse = document.createElement('input');
      inverse.type = 'checkbox';
      inverse.id = 'WikiMonkeyBotInverse';
      elems = [filter, duplicates, inverse];
      for (i = 0, len = elems.length; i < len; i++) {
        elem = elems[i];
        elem.addEventListener("change", function () {
          return self._disableStartBot('Filters have changed, preview the selection');
        }, false);
      }
      duplicatestag = document.createElement('span');
      duplicatestag.innerHTML = 'Duplicates';
      inversetag = document.createElement('span');
      inversetag.innerHTML = 'Inverse';
      preview.addEventListener("click", this._previewFilter, false);
      fieldset.appendChild(legend);
      if (listSelect.length > 1) {
        fieldset.appendChild(listSelect);
      }
      fieldset.appendChild(filter);
      fieldset.appendChild(preview);
      fieldset.appendChild(duplicates);
      fieldset.appendChild(duplicatestag);
      fieldset.appendChild(inverse);
      fieldset.appendChild(inversetag);
      start = document.createElement('input');
      start.type = 'button';
      start.value = 'Start bot';
      start.id = 'WikiMonkeyBotStart';
      start.addEventListener("click", this._startAutomatic, false);
      start.disabled = true;
      startMsg = document.createElement('span');
      startMsg.innerHTML = 'Set and preview the filter first';
      startMsg.id = 'WikiMonkeyBotStartMsg';
      forceStart = document.createElement('span');
      forceStart.id = 'WikiMonkeyBotForceStart';
      forceStartCB = document.createElement('input');
      forceStartCB.type = 'checkbox';
      forceStartCB.disabled = true;
      forceStartLabel = document.createElement('span');
      forceStartLabel.innerHTML = 'Force start, stopping any other currently running bots';
      forceStart.style.display = "none";
      forceStart.appendChild(forceStartCB);
      forceStart.appendChild(forceStartLabel);
      bot.appendChild(fieldset);
      bot.appendChild(start);
      bot.appendChild(startMsg);
      bot.appendChild(forceStart);
      return bot;
    }
  }, {
    key: '_enableStartBot',
    value: function _enableStartBot() {
      document.getElementById('WikiMonkeyBotStartMsg').innerHTML = '';
      return document.getElementById('WikiMonkeyBotStart').disabled = false;
    }
  }, {
    key: '_disableStartBot',
    value: function _disableStartBot(message) {
      document.getElementById('WikiMonkeyBotStartMsg').innerHTML = message;
      return document.getElementById('WikiMonkeyBotStart').disabled = true;
    }
  }, {
    key: '_enableStopBot',
    value: function _enableStopBot(stopId) {
      var self, start, stop;
      self = this;
      stop = document.createElement('input');
      stop.type = 'button';
      stop.value = 'Stop bot';
      stop.id = 'WikiMonkeyBotStop';
      stop.addEventListener("click", function (id) {
        return function () {
          clearTimeout(id);

          self._disableStopBot();
          self._endAutomatic(true);
          return self.WM.Log.logInfo('Bot stopped manually');
        };
      }(stopId), false);
      start = document.getElementById('WikiMonkeyBotStart');
      start.parentNode.insertBefore(stop, start);
      return start.style.display = 'none';
    }
  }, {
    key: '_disableStopBot',
    value: function _disableStopBot() {
      var stop;
      stop = document.getElementById('WikiMonkeyBotStop');
      stop.parentNode.removeChild(stop);
      return document.getElementById('WikiMonkeyBotStart').style.display = 'inline';
    }
  }, {
    key: '_disableControls',
    value: function _disableControls() {
      return this._setEnableControls(true);
    }
  }, {
    key: '_reEnableControls',
    value: function _reEnableControls() {
      return this._setEnableControls(false);
    }
  }, {
    key: '_setEnableControls',
    value: function _setEnableControls(flag) {
      var fset, fsets, i, len, results;
      fsets = document.getElementById('WikiMonkeyBot').getElementsByTagName('fieldset');
      results = [];
      for (i = 0, len = fsets.length; i < len; i++) {
        fset = fsets[i];

        results.push(fset.disabled = flag);
      }
      return results;
    }
  }, {
    key: '_enableForceStart',
    value: function _enableForceStart() {
      var force;
      force = document.getElementById('WikiMonkeyBotForceStart');
      force.getElementsByTagName('input')[0].disabled = false;
      return force.style.display = 'inline';
    }
  }, {
    key: '_disableForceStart',
    value: function _disableForceStart() {
      var force;
      force = document.getElementById('WikiMonkeyBotForceStart');
      force.getElementsByTagName('input')[0].checked = false;
      force.getElementsByTagName('input')[0].disabled = true;
      return force.style.display = 'none';
    }
  }, {
    key: '_canForceStart',
    value: function _canForceStart() {
      return document.getElementById('WikiMonkeyBotForceStart').getElementsByTagName('input')[0].checked;
    }
  }, {
    key: 'makeFilters',
    value: function makeFilters() {
      var exc, filter, filters, firstSlash, i, lastSlash, len, modifiers, negative, pattern, regexp;
      this.configuration.filters = [];
      filters = document.getElementById('WikiMonkeyBotFilter').value.split('\n');
      for (i = 0, len = filters.length; i < len; i++) {
        filter = filters[i];

        if (filter) {
          firstSlash = filter.indexOf('/');
          lastSlash = filter.lastIndexOf('/');
          pattern = filter.substring(firstSlash + 1, lastSlash);
          modifiers = filter.substring(lastSlash + 1);
          negative = filter.charAt(0) === '!';
          try {
            regexp = new RegExp(pattern, modifiers);
          } catch (error) {
            exc = error;
            this.WM.Log.logError('Invalid regexp: ' + exc);
            return false;
          }
          this.configuration.filters.push([regexp, negative]);
        }
      }

      return true;
    }
  }, {
    key: 'canProcessPage',
    value: function canProcessPage(link) {
      var duplicates, filter, filters, i, inverse, len, negative, regexp, test, title;

      if (link.className.split(" ").indexOf("new") < 0) {
        title = link.innerHTML;
        duplicates = document.getElementById('WikiMonkeyBotDuplicates').checked;
        if (duplicates || this.configuration.visited.indexOf(title) < 0) {
          this.configuration.visited.push(title);
          filters = this.configuration.filters;
          inverse = document.getElementById('WikiMonkeyBotInverse').checked;
          if (filters.length > 0) {
            for (i = 0, len = filters.length; i < len; i++) {
              filter = filters[i];
              regexp = filter[0];
              negative = filter[1];
              test = regexp.test(title);
              if (test !== negative) {
                if (inverse) {
                  return false;
                } else {
                  return true;
                }
              }
            }

            if (inverse) {
              return true;
            } else {
              return false;
            }
          } else {
            if (inverse) {
              return false;
            } else {
              return true;
            }
          }
        } else {
          return false;
        }
      } else {
        return false;
      }
    }
  }, {
    key: 'changeWikiMonkeyLinkClassName',
    value: function changeWikiMonkeyLinkClassName(className, newClass) {
      var classes, cls, i, len, newClasses;
      classes = className.split(" ");
      newClasses = [];
      for (i = 0, len = classes.length; i < len; i++) {
        cls = classes[i];
        if (cls.indexOf("WikiMonkey") < 0) {
          newClasses.push(cls);
        }
      }

      newClasses.push(newClass);
      return newClasses.join(" ");
    }
  }, {
    key: 'restoreOriginalLinkClassName',
    value: function restoreOriginalLinkClassName(className) {
      var classes, cls, i, len, origClasses;
      classes = className.split(" ");
      origClasses = [];
      for (i = 0, len = classes.length; i < len; i++) {
        cls = classes[i];
        if (cls.indexOf("WikiMonkey") < 0) {
          origClasses.push(cls);
        }
      }
      return origClasses.join(" ");
    }
  }, {
    key: '_previewFilter',
    value: function _previewFilter() {
      var N, enable, i, item, items, j, len, len1, link, linkId;
      this.WM.Log.logInfo('Updating filter preview, please wait ...');
      this._disableStartBot('Updating filter preview ...');
      if (this.configuration.list.previous) {
        if (this.configuration.list.current[0].nodeName === 'TBODY') {
          items = this.configuration.list.previous[0].getElementsByTagName('td');
        } else {
          items = this.configuration.list.previous[0].getElementsByTagName('li');
        }
        linkId = this.configuration.list.previous[1];
        for (i = 0, len = items.length; i < len; i++) {
          item = items[i];
          link = item.getElementsByTagName('a')[linkId];

          if (link) {
            link.className = this.restoreOriginalLinkClassName(link.className);
          }
        }
      }
      this.configuration.visited = [];
      linkId = this.configuration.list.current[1];
      enable = false;
      N = 0;
      if (this.makeFilters()) {
        if (this.configuration.list.current[0].nodeName === 'TBODY') {
          items = this.configuration.list.current[0].getElementsByTagName('td');
        } else {
          items = this.configuration.list.current[0].getElementsByTagName('li');
        }
        for (j = 0, len1 = items.length; j < len1; j++) {
          item = items[j];
          link = item.getElementsByTagName('a')[linkId];

          if (link) {
            if (this.canProcessPage(link)) {
              link.className = this.changeWikiMonkeyLinkClassName(link.className, 'WikiMonkeyBotSelected');
              enable = true;
              N++;
            } else {
              link.className = this.restoreOriginalLinkClassName(link.className);
            }
          }
        }
      }
      this.WM.Log.logInfo('Preview updated (' + N + ' pages selected)');
      if (enable) {
        return this._enableStartBot();
      } else {
        return this._disableStartBot('No pages selected, reset and preview the filter');
      }
    }
  }, {
    key: '_setBotToken',
    value: function _setBotToken() {
      var date, token;
      date = new Date();
      token = date.getTime() + "";
      this.botToken = token;
      return localStorage.setItem('WikiMonkeyBotToken', token);
    }
  }, {
    key: '_resetBotToken',
    value: function _resetBotToken(reset) {
      this.botToken = "0";
      if (reset) {
        return localStorage.setItem('WikiMonkeyBotToken', "0");
      }
    }
  }, {
    key: '_getBotToken',
    value: function _getBotToken() {
      return this.botToken;
    }
  }, {
    key: '_checkOtherBotsRunning',
    value: function _checkOtherBotsRunning() {
      var value;
      value = localStorage.getItem('WikiMonkeyBotToken');

      return value && value !== "0" && value !== this._getBotToken();
    }
  }, {
    key: '_startAutomatic',
    value: function _startAutomatic() {
      var i, item, items, itemsDOM, len, linkId;
      if (this._checkOtherBotsRunning() && !this._canForceStart()) {
        this.WM.Log.logError("It's not possible to start the bot (without forcing it) for one of the following reasons:<br> * another bot instance is currently running<br> * a previously running bot has stopped due to a page processing error<br> * a previously running bot has stopped due to a Javascript error<br> * a previously running bot has been interrupted by a browser page refresh");
        return this._enableForceStart();
      } else if (this.makeFilters()) {
        if (this.configuration.list.current[0].nodeName === 'TBODY') {
          itemsDOM = this.configuration.list.current[0].getElementsByTagName('td');
        } else {
          itemsDOM = this.configuration.list.current[0].getElementsByTagName('li');
        }

        items = [];
        for (i = 0, len = itemsDOM.length; i < len; i++) {
          item = itemsDOM[i];
          items.push(item);
        }
        linkId = this.configuration.list.current[1];
        this._disableForceStart();
        this._setBotToken();
        this.WM.Log.logInfo('Starting bot ...');
        this.WM.Log.logHidden("Plugin: " + this.configuration.plugin_name);
        this.WM.Log.logHidden("Filter: " + document.getElementById('WikiMonkeyBotFilter').value);
        this._disableStartBot('Bot is running ...');
        this._disableControls();
        this.configuration.visited = [];
        return this.WM.MW.isUserBot(this._startAutomaticContinue, [items, linkId]);
      }
    }
  }, {
    key: '_startAutomaticContinue',
    value: function _startAutomaticContinue(botTest, args) {
      var items, linkId;
      items = args[0];
      linkId = args[1];
      this.configuration.interval = botTest ? 3000 : 30000;
      return this._processItem(0, items, 0, linkId, null);
    }
  }, {
    key: 'makeCallContinue',
    value: function makeCallContinue(lis, id, linkId, ln, article) {
      var self;
      self = this;
      return function (status, resArgs) {
        switch (status) {
          case 0:
            ln.className = self.changeWikiMonkeyLinkClassName(ln.className, 'WikiMonkeyBotUnchanged');
            self.WM.Log.logInfo(self.WM.Log.linkToWikiPage(article, article) + " processed (unchanged)");
            id++;
            self._processItem(status, lis, id, linkId, resArgs);
            break;

          case 1:
            ln.className = self.changeWikiMonkeyLinkClassName(ln.className, 'WikiMonkeyBotChanged');
            self.WM.Log.logInfo(self.WM.Log.linkToWikiPage(article, article) + " processed (changed)");
            id++;
            self._processItem(status, lis, id, linkId, resArgs);
            break;

          case 'protectedpage':
            ln.className = self.changeWikiMonkeyLinkClassName(ln.className, 'WikiMonkeyBotBypassed');
            self.WM.Log.logWarning("This user doesn't have the rights to " + "edit " + self.WM.Log.linkToWikiPage(article, article) + ", bypassing it ...");
            id++;

            self._processItem(0, lis, id, linkId, resArgs);
            break;
          default:
            ln.className = self.changeWikiMonkeyLinkClassName(ln.className, 'WikiMonkeyBotFailed');
            self.WM.Log.logError("Error processing " + self.WM.Log.linkToWikiPage(article, article) + ", stopping the bot");
            return self._endAutomatic(true);
        }
      };
    }
  }, {
    key: '_processItem',
    value: function _processItem(status, items, index, linkId, chainArgs) {
      var interval, link, self, stopId, title;
      self = this;
      if (items[index]) {
        link = items[index].getElementsByTagName('a')[linkId];

        if (link && this.canProcessPage(link)) {
          title = link.title;
          if (status === 0) {
            interval = 1000;
          } else {
            interval = this.configuration.interval;
          }
          this.WM.Log.logInfo('Waiting ' + interval / 1000 + ' seconds ...');
          stopId = setTimeout(function (lis, id, ln, article, chainArgs) {
            return function () {
              self._disableStopBot();

              if (!self._checkOtherBotsRunning()) {
                ln.className = self.changeWikiMonkeyLinkClassName(ln.className, 'WikiMonkeyBotProcessing');
                self.WM.Log.logInfo("Processing " + self.WM.Log.linkToWikiPage(article, article) + " ...");
                return self.configuration.function_(article, self.makeCallContinue(lis, id, linkId, ln, article), chainArgs);
              } else {
                self.WM.Log.logError('Another bot has been ' + 'force-started, stopping ...');
                return self._endAutomatic(false);
              }
            };
          }(items, index, link, title, chainArgs), interval);
          return this._enableStopBot(stopId);
        } else {
          index++;
          return this._processItem(status, items, index, linkId, chainArgs);
        }
      } else {
        return this._endAutomatic(true);
      }
    }
  }, {
    key: '_endAutomatic',
    value: function _endAutomatic(reset) {
      this._resetBotToken(reset);
      this.WM.Log.logInfo('Bot operations completed (check the log for ' + 'warnings or errors)');
      this._disableStartBot('Bot operations completed, reset and preview ' + 'the filter');
      return this._reEnableControls();
    }
  }]);

  return exports;
}();

},{"@kynikos/misc/dist/CSS":2}],399:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Async, Obj;

Async = require('@kynikos/misc/dist/Async');

Obj = require('@kynikos/misc/dist/Obj');

module.exports = function () {
  function exports(WM) {
    _classCallCheck(this, exports);

    this.WM = WM;
  }

  _createClass(exports, [{
    key: 'recurseTree',
    value: function recurseTree(params) {
      params.callChildren = this.WM.Cat._recurseTreeCallChildren;
      return Async.recurseTreeAsync(params);
    }
  }, {
    key: 'recurseTreeContinue',
    value: function recurseTreeContinue(params) {
      return Async.recurseTreeAsync(params);
    }
  }, {
    key: '_recurseTreeCallChildren',
    value: function _recurseTreeCallChildren(params) {
      return this.WM.Cat.getSubCategories(params.node, this.WM.Cat._recurseTreeCallChildrenContinue, params);
    }
  }, {
    key: '_recurseTreeCallChildrenContinue',
    value: function _recurseTreeCallChildrenContinue(subCats, params) {
      var i, len, subCat;
      for (i = 0, len = subCats.length; i < len; i++) {
        subCat = subCats[i];
        params.children.push(subCat.title);
      }
      return Async.recurseTreeAsync(params);
    }
  }, {
    key: 'getSubCategories',
    value: function getSubCategories(parent, call, callArgs) {
      return this.WM.Cat._getMembers(parent, "subcat", call, callArgs);
    }
  }, {
    key: 'getAllMembers',
    value: function getAllMembers(parent, call, callArgs) {
      return this.WM.Cat._getMembers(parent, null, call, callArgs);
    }
  }, {
    key: '_getMembers',
    value: function _getMembers(name, cmtype, call, callArgs) {
      var query;
      query = {
        action: "query",
        list: "categorymembers",
        cmtitle: name,
        cmlimit: 500
      };
      if (cmtype) {
        query.cmtype = cmtype;
      }
      return this._getMembersContinue(query, call, callArgs, []);
    }
  }, {
    key: '_getMembersContinue',
    value: function _getMembersContinue(query, call, callArgs, members) {
      return this.WM.MW.callAPIGet(query, function (res, args) {
        members = members.concat(res.query.categorymembers);
        if (res["query-continue"]) {
          query.cmcontinue = res["query-continue"].categorymembers.cmcontinue;
          return this._getMembersContinue(query, call, args, members);
        } else {
          return call(members, args);
        }
      }, callArgs, null);
    }
  }, {
    key: 'getParentsAndInfo',
    value: function getParentsAndInfo(name, call, callArgs) {
      var query;
      query = {
        action: "query",
        prop: "categories|categoryinfo",
        titles: name,
        clprop: "hidden",
        cllimit: 500
      };
      return this._getParentsAndInfoContinue(query, call, callArgs, [], null);
    }
  }, {
    key: '_getParentsAndInfoContinue',
    value: function _getParentsAndInfoContinue(query, call, callArgs, parents, info) {
      return this.WM.MW.callAPIGet(query, function (res, args) {
        var page;
        page = Obj.getFirstItem(res.query.pages);
        if (page.categories) {
          parents = parents.concat(page.categories);
        }
        if (page.categoryinfo) {
          info = page.categoryinfo;
        }
        if (res["query-continue"]) {
          query.prop = "categories";
          query.clcontinue = res["query-continue"].categories.clcontinue;
          return this._getParentsAndInfoContinue(query, call, args, parents, info);
        } else {
          return call(parents, info, args);
        }
      }, callArgs, null);
    }
  }]);

  return exports;
}();

},{"@kynikos/misc/dist/Async":1,"@kynikos/misc/dist/Obj":5}],400:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var HTTP;

HTTP = require('@kynikos/misc/dist/HTTP');

module.exports = function () {
  function exports(WM) {
    _classCallCheck(this, exports);

    this.WM = WM;
  }

  _createClass(exports, [{
    key: 'getEndTimestamp',
    value: function getEndTimestamp(call, callArgs) {
      var diff, giveEndTimestamp, oldid, pars, title;
      title = decodeURIComponent(HTTP.getURIParameter(null, 'title'));
      diff = HTTP.getURIParameter(null, 'diff');
      oldid = HTTP.getURIParameter(null, 'oldid');
      giveEndTimestamp = function giveEndTimestamp(page, id) {
        return call(page.revisions[id].timestamp, callArgs);
      };
      switch (diff) {
        case 'next':
          pars = {
            prop: "revisions",
            titles: title,
            rvlimit: "2",
            rvprop: "timestamp",
            rvdir: "newer",
            rvstartid: oldid
          };
          return this.WM.MW.callQuery(pars, giveEndTimestamp, 1, null);
        case 'prev':
          pars = {
            prop: "revisions",
            revids: oldid,
            rvprop: "timestamp"
          };
          return this.WM.MW.callQuery(pars, giveEndTimestamp, 0, null);
        default:
          pars = {
            prop: "revisions",
            revids: diff,
            rvprop: "timestamp"
          };
          return this.WM.MW.callQuery(pars, giveEndTimestamp, 0, null);
      }
    }
  }]);

  return exports;
}();

},{"@kynikos/misc/dist/HTTP":4}],401:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Compatibility, HTTP;

Compatibility = require('@kynikos/misc/dist/Compatibility');

HTTP = require('@kynikos/misc/dist/HTTP');

module.exports = function () {
  function exports(WM) {
    _classCallCheck(this, exports);

    this.WM = WM;
  }

  _createClass(exports, [{
    key: 'getTitle',
    value: function getTitle() {
      return this.WM.Parser.squashContiguousWhitespace(decodeURIComponent(HTTP.getURIParameter(null, 'title')));
    }
  }, {
    key: 'isSection',
    value: function isSection() {
      if (document.getElementsByName('wpSection')[0].value) {
        return true;
      } else {
        return false;
      }
    }
  }, {
    key: 'readSource',
    value: function readSource() {
      var value;
      value = document.getElementById('wpTextbox1').value;

      return Compatibility.normalizeCarriageReturns(value);
    }
  }, {
    key: 'writeSource',
    value: function writeSource(text) {
      return document.getElementById('wpTextbox1').value = text;
    }
  }, {
    key: 'readSummary',
    value: function readSummary() {
      return document.getElementById('wpSummary').getAttribute("value");
    }
  }, {
    key: 'writeSummary',
    value: function writeSummary(text) {
      return document.getElementById('wpSummary').setAttribute("value", text);
    }
  }, {
    key: 'appendToSummary',
    value: function appendToSummary(text) {
      return document.getElementById('wpSummary').setAttribute("value", this.readSummary() + text);
    }
  }]);

  return exports;
}();

},{"@kynikos/misc/dist/Compatibility":3,"@kynikos/misc/dist/HTTP":4}],402:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var CSS;

CSS = require('@kynikos/misc/dist/CSS');

module.exports = function () {
  function exports(WM) {
    _classCallCheck(this, exports);

    this.updateFilterUI = this.updateFilterUI.bind(this);
    this.executePlugin = this.executePlugin.bind(this);
    this.WM = WM;
  }

  _createClass(exports, [{
    key: '_makeUI',
    value: function _makeUI(page_type, plugins) {
      var Plugin, commandsFilterDiv, div, divFilter, filters, i, len, option, plugin, pluginInst, selectFilter;
      this.page_type = page_type;
      CSS.addStyleElement("#WikiMonkeyFilters-Commands {display:flex; align-items:center; justify-content:space-between;} #WikiMonkeyFilters-Commands > select {flex:auto;} #WikiMonkeyFilters-Commands > select, #WikiMonkeyFilters-Commands > input[type='button'] {margin-right:1em;} #WikiMonkeyFilters-Commands > input[type='checkbox'] {margin-right:0.4em;}");
      filters = [];
      selectFilter = $('<select/>').change(this.updateFilterUI(filters));
      for (i = 0, len = plugins.length; i < len; i++) {
        Plugin = plugins[i];
        plugin = new Plugin(this.WM);
        pluginInst = plugin.conf.filter_label;

        if (!pluginInst) {
          continue;
        }
        filters.push(plugin);
        option = $('<option/>').text(pluginInst);
        if (plugin.constructor.name === this.WM.conf['default_' + this.page_type + '_plugin']) {
          option[0].selected = true;
        }
        option.appendTo(selectFilter);
      }
      if (filters.length) {
        commandsFilterDiv = $('<div/>').attr('id', 'WikiMonkeyFilters-Commands');
        commandsFilterDiv.append(selectFilter);
        $('<input/>').attr('type', 'button').val('Apply filter').click(this.executePlugin(filters)).appendTo(commandsFilterDiv);
        $('<input/>').attr('type', 'checkbox').change(this.toggleLog).appendTo(commandsFilterDiv);
        $('<span/>').text('Show Log').appendTo(commandsFilterDiv);
        divFilter = $('<div/>').attr('id', "WikiMonkeyFilters-Options");

        $('<div/>').appendTo(divFilter);
        this.doUpdateFilterUI(divFilter, filters, selectFilter[0].selectedIndex);
        div = $('<div/>').attr('id', 'WikiMonkeyFilters').append(commandsFilterDiv).append(divFilter);
        return div[0];
      } else {
        return false;
      }
    }
  }, {
    key: 'updateFilterUI',
    value: function updateFilterUI(filters) {
      var _this = this;

      return function (event) {
        var UI, id, select;
        UI = $('#WikiMonkeyFilters-Options');
        select = $('#WikiMonkeyFilters-Commands').find('select').first();
        id = select[0].selectedIndex;
        return _this.doUpdateFilterUI(UI, filters, id);
      };
    }
  }, {
    key: 'doUpdateFilterUI',
    value: function doUpdateFilterUI(UI, filters, id) {
      var makeUI;
      makeUI = filters[id].makeUI;
      if (makeUI instanceof Function) {
        return UI.children().first().replaceWith(makeUI());
      } else {
        return UI.children().first().replaceWith($('<div/>'));
      }
    }
  }, {
    key: 'executePlugin',
    value: function executePlugin(filters) {
      var _this2 = this;

      return function (event) {
        var id, select;
        select = $('#WikiMonkeyFilters-Commands').find('select').first();
        id = select[0].selectedIndex;
        filters[id]['main_' + _this2.page_type]();
        return event.target.disabled = true;
      };
    }
  }, {
    key: 'toggleLog',
    value: function toggleLog(event) {
      if (this.checked) {
        return $('#WikiMonkeyLog').show();
      } else {
        return $('#WikiMonkeyLog').hide();
      }
    }
  }]);

  return exports;
}();

},{"@kynikos/misc/dist/CSS":2}],403:[function(require,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Obj;

Obj = require('@kynikos/misc/dist/Obj');

module.exports = function () {
  function exports(WM) {
    _classCallCheck(this, exports);

    this.parseLinks = this.parseLinks.bind(this);
    this.queryLinks = this.queryLinks.bind(this);
    this.createNewLink = this.createNewLink.bind(this);
    this.createVisitedLink = this.createVisitedLink.bind(this);
    this.collectLinks = this.collectLinks.bind(this);
    this._collectLinksContinue = this._collectLinksContinue.bind(this);
    this.updateLinks = this.updateLinks.bind(this);
    this.WM = WM;
  }

  _createClass(exports, [{
    key: "parseLinks",
    value: function parseLinks(supportedLangs, source, iwmap) {
      var i, iw, j, langlinks, len, len1, link, ltag, ltitle, lurl, parsedLinks;
      parsedLinks = this.WM.Parser.findSpecialLinks(source, supportedLangs.join("|"));
      langlinks = [];
      for (i = 0, len = parsedLinks.length; i < len; i++) {
        link = parsedLinks[i];

        ltag = link.namespace;
        ltitle = link.title + (link.fragment ? "#" + link.fragment : "");
        for (j = 0, len1 = iwmap.length; j < len1; j++) {
          iw = iwmap[j];
          if (iw.prefix.toLowerCase() === ltag.toLowerCase()) {
            lurl = this.WM.MW.fixInterwikiUrl(iw.url);
            lurl = lurl.replace("$1", encodeURIComponent(this.WM.Parser.squashContiguousWhitespace(ltitle)));
            break;
          }
        }
        langlinks.push({
          lang: ltag,
          title: ltitle,
          url: lurl,
          index: link.index,
          length: link.length
        });
      }
      return langlinks;
    }
  }, {
    key: "queryLinks",
    value: function queryLinks(queryTitle, title, supportedLangs, whitelist, firstPage, callEnd, callArgs) {
      var _this = this;

      var query;
      query = {
        action: "query",
        prop: "info|revisions",
        rvprop: "content|timestamp",
        intoken: "edit",
        titles: queryTitle,
        meta: "siteinfo",
        siprop: "interwikimap",
        sifilteriw: "local"
      };

      if (!firstPage) {
        query.redirects = "1";
      }
      return this.WM.MW.callAPIGet(query, function (res, args) {
        var edittoken, error, iwmap, langlinks, page, source, timestamp;
        if (res.query.pages) {
          page = Obj.getFirstItem(res.query.pages);
          if (page.revisions) {
            error = null;
            source = page.revisions[0]["*"];
            timestamp = page.revisions[0].timestamp;
            edittoken = page.edittoken;
            iwmap = res.query.interwikimap;
            langlinks = _this.WM.Interlanguage.parseLinks(supportedLangs, source, iwmap);
          } else {
            error = 'nonexisting';
            source = false;
            timestamp = false;
            edittoken = false;
            iwmap = res.query.interwikimap;
            langlinks = false;
          }
        } else if (res.query.redirects) {
          error = 'unsolvedredirect';
          source = false;
          timestamp = false;
          edittoken = false;
          iwmap = res.query.interwikimap;
          langlinks = false;
        } else {
          error = 'unknown';
          source = false;
          timestamp = false;
          edittoken = false;
          iwmap = res.query.interwikimap;
          langlinks = false;
        }
        return callEnd(title, supportedLangs, whitelist, false, error, langlinks, iwmap, source, timestamp, edittoken, args);
      }, callArgs, function (args) {
        return callEnd(title, supportedLangs, whitelist, false, 'unknown', false, false, false, false, false, args);
      });
    }
  }, {
    key: "createNewLink",
    value: function createNewLink(origTag, title, url) {
      return {
        origTag: origTag,
        title: title,
        url: url
      };
    }
  }, {
    key: "createVisitedLink",
    value: function createVisitedLink(origTag, title, url, iwmap, source, timestamp, edittoken, links) {
      var entry, i, len, link;
      entry = {
        origTag: origTag,
        title: title,
        url: url,
        iwmap: iwmap,
        source: source,
        timestamp: timestamp,
        edittoken: edittoken,
        links: []
      };
      for (i = 0, len = links.length; i < len; i++) {
        link = links[i];
        entry.links.push(link);
      }
      return entry;
    }
  }, {
    key: "collectLinks",
    value: function collectLinks(visitedlinks, newlinks, supportedLangs, whitelist, firstPage, callEnd, callArgs) {
      var link, origTag, queryTitle, tag, title, url;
      for (tag in newlinks) {
        link = newlinks[tag];
        break;
      }
      if (link) {
        delete newlinks[tag];
        url = link.url;

        queryTitle = decodeURIComponent(this.WM.MW.getTitleFromWikiUrl(url));
        if (queryTitle) {
          origTag = link.origTag;
          title = link.title;

          if (firstPage || whitelist.indexOf(tag) > -1) {
            this.WM.Log.logInfo("Reading " + this.WM.Log.linkToPage(url, "[[" + origTag + ":" + title + "]]") + " ...");
            return this.queryLinks(queryTitle, title, supportedLangs, whitelist, firstPage, this.WM.Interlanguage._collectLinksContinue, [url, tag, origTag, visitedlinks, newlinks, callEnd, callArgs]);
          } else {
            return this.WM.Interlanguage._collectLinksContinue(title, supportedLangs, whitelist, firstPage, 'notinwhitelist', [], false, null, null, null, [url, tag, origTag, visitedlinks, newlinks, callEnd, callArgs]);
          }
        } else {
          this.WM.Log.logWarning("Cannot extract the page title from " + this.WM.Log.linkToPage(url, decodeURI(url)) + ", removing it if it was linked from the processed article");
          return this.WM.Interlanguage.collectLinks(visitedlinks, newlinks, supportedLangs, whitelist, firstPage, callEnd, callArgs);
        }
      } else {
        return callEnd(visitedlinks, callArgs);
      }
    }
  }, {
    key: "_collectLinksContinue",
    value: function _collectLinksContinue(title, supportedLangs, whitelist, firstPage, error, langlinks, iwmap, source, timestamp, edittoken, args) {
      var callArgs, callEnd, i, len, link, newlinks, nlink, origTag, tag, url, visitedlinks, vlink;
      url = args[0];
      tag = args[1];
      origTag = args[2];
      visitedlinks = args[3];
      newlinks = args[4];
      callEnd = args[5];
      callArgs = args[6];
      if (error === 'nonexisting') {
        this.WM.Log.logWarning(this.WM.Log.linkToPage(url, "[[" + origTag + ":" + title + "]]") + " seems to point to a non-existing article: removing it if it was linked from the processed article");
      } else {
        if (error === 'unsolvedredirect') {
          this.WM.Log.logWarning(this.WM.Log.linkToPage(url, "[[" + origTag + ":" + title + "]]") + " will not be checked because it points to an external redirect");
        } else if (error === 'unknown') {
          this.WM.Log.logWarning(this.WM.Log.linkToPage(url, "[[" + origTag + ":" + title + "]]") + " will not be checked because of an unspecified problem");
        } else if (error === 'notinwhitelist') {
          this.WM.Log.logWarning(this.WM.Log.linkToPage(url, "[[" + origTag + ":" + title + "]]") + " will not be checked because " + tag + " is not included in the whitelist defined in the configuration");
        }
        visitedlinks[tag] = this.WM.Interlanguage.createVisitedLink(origTag, title, url, iwmap, source, timestamp, edittoken, langlinks);
        for (i = 0, len = langlinks.length; i < len; i++) {
          link = langlinks[i];
          nlink = newlinks[link.lang.toLowerCase()];
          vlink = visitedlinks[link.lang.toLowerCase()];
          if (!vlink && !nlink) {
            newlinks[link.lang.toLowerCase()] = this.WM.Interlanguage.createNewLink(link.lang, link.title, link.url);
          } else if (vlink && vlink.url !== link.url) {
            this.WM.Log.logWarning("Possibly conflicting interlanguage links: " + this.WM.Log.linkToPage(link.url, "[[" + link.lang + ":" + link.title + "]]") + " and " + this.WM.Log.linkToPage(vlink.url, "[[" + link.lang + ":" + visitedlinks[link.lang.toLowerCase()].title + "]]"));
          } else if (nlink && nlink.url !== link.url) {
            this.WM.Log.logWarning("Possibly conflicting interlanguage links: " + this.WM.Log.linkToPage(link.url, "[[" + link.lang + ":" + link.title + "]]") + " and " + this.WM.Log.linkToPage(nlink.url, "[[" + link.lang + ":" + newlinks[link.lang.toLowerCase()].title + "]]"));
          }
        }
      }
      return this.WM.Interlanguage.collectLinks(visitedlinks, newlinks, supportedLangs, whitelist, firstPage, callEnd, callArgs);
    }
  }, {
    key: "updateLinks",
    value: function updateLinks(lang, url, iwmap, source, oldlinks, newlinks) {
      var body, cleanText, firstLink, head, i, iw, j, len, len1, link, linkList, links, parts, tag, tagFound, textId, trailws;
      lang = lang.toLowerCase();
      linkList = [];
      for (tag in newlinks) {
        if (tag !== lang) {
          link = newlinks[tag];
          tagFound = false;

          for (i = 0, len = iwmap.length; i < len; i++) {
            iw = iwmap[i];
            if (iw.prefix.toLowerCase() === tag.toLowerCase()) {
              linkList.push("[[" + link.origTag + ":" + link.title + "]]");
              tagFound = true;
              break;
            }
          }
          if (!tagFound) {
            this.WM.Log.logWarning(tag + " interlanguage links are not supported in " + this.WM.Log.linkToPage(url, "[[" + link.origTag + ":" + link.title + "]]") + " , ignoring them");
          }
        }
      }
      linkList.sort(function (a, b) {
        if (a.toLowerCase() > b.toLowerCase()) {
          return 1;
        }
        if (b.toLowerCase() > a.toLowerCase()) {
          return -1;
        } else {
          return 0;
        }
      });
      cleanText = "";
      textId = 0;
      for (j = 0, len1 = oldlinks.length; j < len1; j++) {
        link = oldlinks[j];
        cleanText += source.substring(textId, link.index);
        textId = link.index + link.length;
      }
      cleanText += source.substring(textId);
      if (oldlinks.length) {
        firstLink = oldlinks[0].index;
      } else {
        firstLink = 0;
      }
      parts = [];

      head = cleanText.substring(0, firstLink).trim();
      if (head) {
        parts.push(head);
      }
      links = linkList.join("\n");
      if (links) {
        parts.push(links);
      }
      body = cleanText.substr(firstLink).trim();
      if (body) {
        parts.push(body);
      }

      trailws = /\s*$/;
      return parts.join("\n") + trailws.exec(source);
    }
  }]);

  return exports;
}();

},{"@kynikos/misc/dist/Obj":5}],404:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Str, jss;

var _require = require('./libs');

jss = _require.jss;


Str = require('@kynikos/misc/dist/Str');

module.exports = function () {
  var classesToLevels;

  var exports = function () {
    function exports(WM) {
      _classCallCheck(this, exports);

      var classes, styles;
      this.WM = WM;
      this._currentInfoDisplayState = true;

      styles = {
        log: {
          height: '10em',
          border: '2px solid #07b',
          padding: '0.5em',
          overflow: 'auto',
          resize: 'vertical',
          'background-color': '#111',
          '& p.timestamp, & p.message': {
            border: 'none',
            padding: 0,
            'font-family': 'monospace',
            color: '#eee'
          },
          '& p.timestamp': {
            margin: '0 1em 0 0',
            'white-space': 'nowrap'
          },
          '& p.message': {
            margin: 0
          },
          '& div.mdebug, & div.minfo, & div.mwarning, & div.merror': {
            display: 'flex'
          },
          '& div.mhidden': {
            display: 'none'
          },
          '& div.mjson': {
            display: 'none'
          },
          '& div.mdebug p.message': {
            color: 'cyan'
          },
          '& div.mwarning p.message': {
            color: 'gold'
          },
          '& div.merror p.message': {
            color: 'red'
          },
          '& a': {
            color: 'inherit',
            'text-decoration': 'underline'
          }
        }
      };

      var _jss$createStyleSheet = jss.createStyleSheet(styles, {
        classNamePrefix: "WikiMonkey-"
      }).attach();

      classes = _jss$createStyleSheet.classes;

      this.classes = classes;
    }

    _createClass(exports, [{
      key: '_makeLogArea',
      value: function _makeLogArea() {
        var log, par;
        log = document.createElement('div');
        log.id = 'WikiMonkeyLog';
        par = document.createElement('p');
        par.appendChild(this.makeFilterLink());
        par.appendChild(document.createTextNode(' '));
        par.appendChild(this.makeSaveLink());
        log.appendChild(par);
        this.logarea = document.createElement('div');
        this.logarea.className = this.classes.log;
        log.appendChild(this.logarea);
        return log;
      }
    }, {
      key: 'makeFilterLink',
      value: function makeFilterLink() {
        var _this = this;

        var link;
        link = document.createElement('a');
        link.href = '#WikiMonkey';
        link.innerHTML = this.computeFilterLinkAnchor();
        link.addEventListener("click", function (event) {
          var i, len, msg, msgs;
          event.preventDefault();

          _this._currentInfoDisplayState = !_this._currentInfoDisplayState;
          link.innerHTML = _this.computeFilterLinkAnchor();
          msgs = _this.logarea.getElementsByClassName('minfo');
          for (i = 0, len = msgs.length; i < len; i++) {
            msg = msgs[i];
            msg.style.display = _this.computeInfoDisplayStyle();
          }
          return _this.scrollToBottom();
        }, false);
        return link;
      }
    }, {
      key: 'makeSaveLink',
      value: function makeSaveLink() {
        var _this2 = this;

        var link;
        link = document.createElement('a');
        link.href = '#';
        link.download = 'WikiMonkey.log';
        link.innerHTML = '[save log]';
        link.id = 'WikiMonkeyLog-Save';
        link.addEventListener("click", function () {
          link.href = 'data:text/plain;charset=utf-8,' + encodeURIComponent(_this2.composeSaveLogText());
          return link.download = _this2.composeSaveLogFilename();
        }, false);
        return link;
      }
    }, {
      key: 'composeSaveLogText',
      value: function composeSaveLogText() {
        var div, divs, i, len, level, message, ps, text, tstamp;
        divs = this.logarea.getElementsByTagName('div');
        text = '';
        for (i = 0, len = divs.length; i < len; i++) {
          div = divs[i];
          ps = div.getElementsByTagName('p');
          tstamp = ps[0].innerHTML;
          level = classesToLevels[div.className];
          message = ps[1].innerHTML;
          text += tstamp + '\t' + level + '\t' + message + '\n';
        }
        return text;
      }
    }, {
      key: 'composeSaveLogFilename',
      value: function composeSaveLogFilename() {
        var date;
        date = new Date();
        return 'WikiMonkey-' + date.getFullYear() + Str.padLeft(String(date.getMonth() + 1), '0', 2) + Str.padLeft(String(date.getDate()), '0', 2) + Str.padLeft(String(date.getHours()), '0', 2) + Str.padLeft(String(date.getMinutes()), '0', 2) + '.log';
      }
    }, {
      key: 'computeInfoDisplayStyle',
      value: function computeInfoDisplayStyle() {
        if (this._currentInfoDisplayState) {
          return 'flex';
        } else {
          return 'none';
        }
      }
    }, {
      key: 'computeFilterLinkAnchor',
      value: function computeFilterLinkAnchor() {
        if (this._currentInfoDisplayState) {
          return '[hide info messages]';
        } else {
          return '[show info messages]';
        }
      }
    }, {
      key: 'scrollToBottom',
      value: function scrollToBottom() {
        return this.logarea.scrollTop = this.logarea.scrollHeight - this.logarea.clientHeight;
      }
    }, {
      key: 'appendMessage',
      value: function appendMessage(text, type) {
        var line, msg, now, test, tstamp;
        tstamp = document.createElement('p');
        tstamp.className = 'timestamp';
        now = new Date();
        tstamp.innerHTML = now.toLocaleTimeString();
        msg = document.createElement('p');
        msg.className = 'message';

        msg.innerHTML = text ? text : " ";
        line = document.createElement('div');
        line.appendChild(tstamp);
        line.appendChild(msg);
        line.className = type;
        if (type === 'minfo') {
          line.style.display = this.computeInfoDisplayStyle();
        }

        test = this.logarea.scrollTop + this.logarea.clientHeight === this.logarea.scrollHeight;
        this.logarea.appendChild(line);
        if (test) {
          return this.scrollToBottom();
        }
      }
    }, {
      key: 'logHidden',
      value: function logHidden(text) {
        return this.appendMessage(text, 'mhidden');
      }
    }, {
      key: 'logJson',
      value: function logJson(component, data) {
        var text;
        text = JSON.stringify({
          "component": component,
          "data": data
        });
        return this.appendMessage(text, 'mjson');
      }
    }, {
      key: 'logDebug',
      value: function logDebug(text) {
        return this.appendMessage(text, 'mdebug');
      }
    }, {
      key: 'logInfo',
      value: function logInfo(text) {
        return this.appendMessage(text, 'minfo');
      }
    }, {
      key: 'logWarning',
      value: function logWarning(text) {
        return this.appendMessage(text, 'mwarning');
      }
    }, {
      key: 'logError',
      value: function logError(text) {
        return this.appendMessage(text, 'merror');
      }
    }, {
      key: 'linkToPage',
      value: function linkToPage(url, anchor) {
        return "<a href=\"" + url + "\">" + anchor + "</a>";
      }
    }, {
      key: 'linkToWikiPage',
      value: function linkToWikiPage(title, anchor) {
        var wikiUrls;

        wikiUrls = this.WM.MW.getWikiUrls();
        return "<a href=\"" + wikiUrls.short + title + "\">" + anchor + "</a>";
      }
    }]);

    return exports;
  }();

  ;

  classesToLevels = {
    'mhidden': 'HDN',
    'mjson': 'JSN',
    'mdebug': 'DBG',
    'minfo': 'INF',
    'mwarning': 'WRN',
    'merror': 'ERR'
  };

  return exports;
}.call(undefined);

},{"./libs":414,"@kynikos/misc/dist/Str":7}],405:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var A, HTTP, Obj;

HTTP = require('@kynikos/misc/dist/HTTP');

Obj = require('@kynikos/misc/dist/Obj');

var _require = require('./libs');

A = _require.A;


module.exports = function () {
  var interwikiFixes, localWikiPaths, localWikiUrls, wikiPaths;

  var exports = function () {
    function exports(WM) {
      _classCallCheck(this, exports);

      var hostname, key, wpaths;
      this.WM = WM;
      this.api = new mw.Api();
      wpaths = this._getWikiPaths(location.href);
      hostname = wpaths[0];
      this.userInfo = null;
      localWikiPaths = wpaths[1];
      localWikiUrls = {};
      for (key in localWikiPaths) {
        localWikiUrls[key] = hostname + localWikiPaths[key];
      }
    }

    _createClass(exports, [{
      key: '_getWikiPaths',
      value: function _getWikiPaths(href) {
        var hostname, match, p, paths, r, re;

        for (r in wikiPaths.known) {
          re = new RegExp(r, "i");
          match = re.exec(href);
          if (match) {
            hostname = match[0];
            paths = {};
            for (p in wikiPaths.known[r]) {
              paths[p] = wikiPaths.known[r][p];
            }
            break;
          }
        }
        if (!paths) {
          hostname = HTTP.getUrlLocation(href).hostname;
          paths = {};
          for (p in wikiPaths.default_) {
            paths[p] = wikiPaths.default_[p];
          }
        }
        return [hostname, paths];
      }
    }, {
      key: 'getWikiPaths',
      value: function getWikiPaths(href) {
        if (href) {
          return this._getWikiPaths(href)[1];
        } else {
          return localWikiPaths;
        }
      }
    }, {
      key: 'linkArticle',
      value: function linkArticle(page, label) {
        return A({
          href: mw.util.getUrl(page)
        }, label || page);
      }
    }, {
      key: 'getWikiUrls',
      value: function getWikiUrls(href) {
        var hostname, key, paths, urls, wpaths;
        if (href) {
          wpaths = this._getWikiPaths(href);
          hostname = wpaths[0];
          paths = wpaths[1];
          urls = {};
          for (key in paths) {
            urls[key] = hostname + paths[key];
          }
          return urls;
        } else {
          return localWikiUrls;
        }
      }
    }, {
      key: 'getTitleFromWikiUrl',
      value: function getTitleFromWikiUrl(url) {
        var match, pathname, r, re, title;
        title = HTTP.getURIParameters(url).title;

        if (!title) {
          pathname = HTTP.getUrlLocation(url).pathname;
          for (r in wikiPaths.known) {
            re = new RegExp(r, "i");
            match = re.exec(url);
            if (match) {
              if (pathname.indexOf(wikiPaths.known[r].short) === 0) {
                title = pathname.substr(wikiPaths.known[r].short.length);
              } else {
                title = false;
              }
              break;
            }
          }
          if (!title) {
            if (pathname.indexOf(wikiPaths.default_.short) === 0) {
              title = pathname.substr(wikiPaths.default_.short.length);
            } else {
              title = false;
            }
          }
        }
        return title;
      }
    }, {
      key: 'failedQueryError',
      value: function failedQueryError(url) {
        if (url) {
          return 'Failed query: ' + this.WM.Log.linkToPage(url, url);
        }
        return "Failed query";
      }
    }, {
      key: 'callAPIGet',
      value: function callAPIGet(params, call, callArgs, callError) {
        var _this = this;

        params.format = "json";
        return this.api.get(params).done(function (data, textStatus, jqXHR) {
          if (call) {
            return call(data, callArgs);
          }
        }).fail(function (jqXHR, textStatus, errorThrown) {
          console.error(jqXHR, textStatus, errorThrown);
          _this.WM.Log.logError(_this.failedQueryError());
          if (confirm("Wiki Monkey error: Failed query\n\nDo you want " + "to retry?")) {
            _this.WM.Log.logInfo("Retrying ...");
            return _this.callAPIGet(params, call, callArgs, callError);
          } else if (callError) {
            return callError(callArgs);
          }
        });
      }
    }, {
      key: 'callAPIPost',
      value: function callAPIPost(params, call, callArgs, callError) {
        var _this2 = this;

        params.format = "json";
        return this.api.post(params).done(function (data, textStatus, jqXHR) {
          if (call) {
            return call(data, callArgs);
          }
        }).fail(function (jqXHR, textStatus, errorThrown) {
          console.error(jqXHR, textStatus, errorThrown);
          _this2.WM.Log.logError(_this2.failedQueryError());
          if (confirm("Wiki Monkey error: Failed query\n\nDo you want " + "to retry?")) {
            _this2.WM.Log.logInfo("Retrying ...");
            return _this2.callAPIPost(params, call, callArgs, callError);
          } else if (callError) {
            return callError(callArgs);
          }
        });
      }
    }, {
      key: 'callQuery',
      value: function () {
        var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(params, call, callArgs, callError) {
          var error, page, res;
          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  params.action = "query";
                  _context.prev = 1;
                  _context.next = 4;
                  return this.callAPIGet(params);

                case 4:
                  res = _context.sent;
                  _context.next = 13;
                  break;

                case 7:
                  _context.prev = 7;
                  _context.t0 = _context['catch'](1);

                  error = _context.t0;

                  if (!callError) {
                    _context.next = 12;
                    break;
                  }

                  return _context.abrupt('return', callError(callArgs));

                case 12:
                  throw error;

                case 13:
                  page = Obj.getFirstItem(res.query.pages);

                  if (!call) {
                    _context.next = 16;
                    break;
                  }

                  return _context.abrupt('return', call(page, callArgs));

                case 16:
                  return _context.abrupt('return', page);

                case 17:
                case 'end':
                  return _context.stop();
              }
            }
          }, _callee, this, [[1, 7]]);
        }));

        function callQuery(_x, _x2, _x3, _x4) {
          return _ref.apply(this, arguments);
        }

        return callQuery;
      }()
    }, {
      key: 'callQueryEdit',
      value: function () {
        var _ref2 = _asyncToGenerator(regeneratorRuntime.mark(function _callee2(title, call, callArgs) {
          var edittoken, page, source, timestamp;
          return regeneratorRuntime.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  _context2.next = 2;
                  return this.callQuery({
                    prop: "info|revisions",
                    rvprop: "content|timestamp",
                    intoken: "edit",
                    titles: title
                  });

                case 2:
                  page = _context2.sent;

                  source = page.revisions[0]["*"];
                  timestamp = page.revisions[0].timestamp;
                  edittoken = page.edittoken;

                  if (!call) {
                    _context2.next = 8;
                    break;
                  }

                  return _context2.abrupt('return', call(title, source, timestamp, edittoken, callArgs));

                case 8:
                  return _context2.abrupt('return', { source: source, timestamp: timestamp, edittoken: edittoken });

                case 9:
                case 'end':
                  return _context2.stop();
              }
            }
          }, _callee2, this);
        }));

        function callQueryEdit(_x5, _x6, _x7) {
          return _ref2.apply(this, arguments);
        }

        return callQueryEdit;
      }()
    }, {
      key: 'getUserInfo',
      value: function getUserInfo(call) {
        var _this3 = this;

        var pars, storeInfo;
        storeInfo = function storeInfo(res, call) {
          _this3.userInfo = res;
          return call();
        };
        if (!this.userInfo) {
          pars = {
            action: "query",
            meta: "userinfo",
            uiprop: "groups"
          };
          return this.callAPIGet(pars, storeInfo, call, null);
        } else {
          return call();
        }
      }
    }, {
      key: 'isLoggedIn',
      value: function isLoggedIn(call, args) {
        var _this4 = this;

        return this.getUserInfo(function () {
          var test;
          test = _this4.userInfo.query.userinfo.id !== 0;
          return call(test, args);
        });
      }
    }, {
      key: 'getUserName',
      value: function getUserName(call, args) {
        var _this5 = this;

        return this.getUserInfo(function () {
          return call(_this5.userInfo.query.userinfo.name, args);
        });
      }
    }, {
      key: 'isUserBot',
      value: function isUserBot(call, args) {
        var _this6 = this;

        return this.getUserInfo(function () {
          var groups, res;
          groups = _this6.userInfo.query.userinfo.groups;
          res = groups.indexOf("bot") > -1;
          return call(res, args);
        });
      }
    }, {
      key: 'getBacklinks',
      value: function getBacklinks(bltitle, blnamespace, call, callArgs) {
        var query;
        query = {
          action: "query",
          list: "backlinks",
          bltitle: bltitle,
          bllimit: 500
        };
        if (blnamespace) {
          query.blnamespace = blnamespace;
        }
        return this._getBacklinksContinue(query, call, callArgs, []);
      }
    }, {
      key: '_getBacklinksContinue',
      value: function _getBacklinksContinue(query, call, callArgs, backlinks) {
        var _this7 = this;

        return this.callAPIGet(query, function (res, args) {
          backlinks = backlinks.concat(res.query.backlinks);
          if (res["query-continue"]) {
            query.blcontinue = res["query-continue"].backlinks.blcontinue;
            return _this7._getBacklinksContinue(query, call, args, backlinks);
          } else {
            return call(backlinks, args);
          }
        }, callArgs, null);
      }
    }, {
      key: 'getLanglinks',
      value: function getLanglinks(title, iwmap, call, callArgs) {
        var query;
        query = {
          action: "query",
          prop: "langlinks",
          titles: title,
          lllimit: 500,
          llurl: "1",
          redirects: "1"
        };
        if (iwmap) {
          query.meta = "siteinfo";
          query.siprop = "interwikimap";
          query.sifilteriw = "local";
        }
        return this._getLanglinksContinue(query, call, callArgs, [], null);
      }
    }, {
      key: '_getLanglinksContinue',
      value: function _getLanglinksContinue(query, call, callArgs, langlinks, iwmap) {
        var _this8 = this;

        return this.callAPIGet(query, function (res, args) {
          var page;
          page = Obj.getFirstItem(res.query.pages);
          langlinks = langlinks.concat(page.langlinks);
          if (res.query.interwikimap) {
            iwmap = res.query.interwikimap;
          }
          if (query.meta) {
            delete query.meta;
            delete query.siprop;
            delete query.sifilteriw;
          }
          if (res["query-continue"]) {
            query.llcontinue = res["query-continue"].langlinks.llcontinue;
            return _this8._getLanglinksContinue(query, call, args, langlinks, iwmap);
          } else {
            return call(langlinks, iwmap, args);
          }
        }, callArgs, null);
      }
    }, {
      key: 'getInterwikiMap',
      value: function getInterwikiMap(title) {
        return this.callAPIGet({
          action: "query",
          meta: "siteinfo",
          siprop: "interwikimap"
        });
      }
    }, {
      key: 'getLocalInterwikiMap',
      value: function getLocalInterwikiMap(title, call, callArgs) {
        return this.callAPIGet({
          action: "query",
          meta: "siteinfo",
          siprop: "interwikimap",
          sifilteriw: "local"
        }, function (res, args) {
          return call(res.query.interwikimap, args);
        }, callArgs, null);
      }
    }, {
      key: 'fixInterwikiUrl',
      value: function fixInterwikiUrl(url) {
        var f, furl, i, ref;
        for (f = i = 0, ref = interwikiFixes.length; 0 <= ref ? i < ref : i > ref; f = 0 <= ref ? ++i : --i) {
          furl = url.replace(interwikiFixes[f][0], interwikiFixes[f][1]);
          if (furl !== url) {
            return furl;
          }
        }

        return url;
      }
    }, {
      key: 'getSpecialList',
      value: function () {
        var _ref3 = _asyncToGenerator(regeneratorRuntime.mark(function _callee3(qppage, siprop) {
          var info, key, query, ref, res, results, siteinfo;
          return regeneratorRuntime.wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  query = {
                    action: "query",
                    list: "querypage",
                    qppage: qppage,
                    qplimit: 500
                  };
                  if (siprop) {
                    query.meta = "siteinfo";
                    query.siprop = siprop;
                  }
                  results = [];
                  siteinfo = {};

                case 4:
                  if (!true) {
                    _context3.next = 19;
                    break;
                  }

                  _context3.next = 7;
                  return this.callAPIGet(query);

                case 7:
                  res = _context3.sent;

                  results = results.concat(res.query.querypage.results);
                  ref = res.query;
                  for (key in ref) {
                    info = ref[key];
                    if (key !== "querypage") {
                      siteinfo[key] = info;
                    }
                  }
                  delete query.meta;
                  delete query.siprop;

                  if (!res["query-continue"]) {
                    _context3.next = 16;
                    break;
                  }

                  query.qpoffset = res["query-continue"].querypage.qpoffset;
                  return _context3.abrupt('continue', 4);

                case 16:
                  return _context3.abrupt('return', { results: results, siteinfo: siteinfo });

                case 19:
                case 'end':
                  return _context3.stop();
              }
            }
          }, _callee3, this);
        }));

        function getSpecialList(_x8, _x9) {
          return _ref3.apply(this, arguments);
        }

        return getSpecialList;
      }()
    }, {
      key: 'getUserContribs',
      value: function getUserContribs(ucuser, ucstart, ucend, call, callArgs) {
        var query;
        query = {
          action: "query",
          list: "usercontribs",
          ucuser: ucuser,
          ucprop: "",
          ucstart: ucstart,
          ucend: ucend,
          uclimit: 500
        };
        return this._getUserContribsContinue(query, call, callArgs, []);
      }
    }, {
      key: '_getUserContribsContinue',
      value: function _getUserContribsContinue(query, call, callArgs, results) {
        var _this9 = this;

        return this.callAPIGet(query, function (res, args) {
          results = results.concat(res.query.usercontribs);
          if (res["query-continue"]) {
            query.uccontinue = res["query-continue"].usercontribs.uccontinue;
            return _this9._getUserContribsContinue(query, call, args, results);
          } else {
            return call(results, args);
          }
        }, callArgs, null);
      }
    }]);

    return exports;
  }();

  ;

  localWikiPaths = null;

  localWikiUrls = null;

  wikiPaths = {
    known: {
      "^https?://[^\.]+\.wikipedia\.org": {
        short: "/wiki/",
        full: "/w/index.php",
        api: "/w/api.php"
      },
      "^https?://wiki\.archlinux\.org": {
        short: "/index.php/",
        full: "/index.php",
        api: "/api.php"
      },
      "^https?://wiki\.archlinux\.de": {
        short: "/title/",
        full: "/index.php",
        api: "/api.php"
      },
      "^http://wiki\.archlinux\.fr": {
        short: "/",
        full: "/index.php",
        api: "/api.php"
      },
      "^https?://wiki\.archlinux\.jp": {
        short: "/index.php/",
        full: "/index.php",
        api: "/api.php"
      },
      "^http://wiki\.archlinux\.ro": {
        short: "/index.php/",
        full: "/index.php",
        api: "/api.php"
      },
      "^http://wiki\.archlinux\.ir": {
        short: "/index.php/",
        full: "/index.php",
        api: "/api.php"
      }
    },
    default_: {
      short: "/index.php?title=",
      full: "/index.php",
      api: "/api.php"
    }
  };

  interwikiFixes = [["https://wiki.archlinux.org/index.php/$1_(", "https://wiki.archlinux.org/index.php/$1%20("]];

  return exports;
}.call(undefined);

},{"./libs":414,"@kynikos/misc/dist/HTTP":4,"@kynikos/misc/dist/Obj":5}],406:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var CSS;

CSS = require('@kynikos/misc/dist/CSS');

module.exports = function () {
  var _executeGroupAction, makeChangeMenu, makeGroupAction;

  var exports = function () {
    function exports(WM) {
      _classCallCheck(this, exports);

      this.executeEntryAction = this.executeEntryAction.bind(this);
      this.warnInputNeeded = this.warnInputNeeded.bind(this);
      this.WM = WM;
    }

    _createClass(exports, [{
      key: '_makeUI',
      value: function _makeUI(page_type, plugins) {
        var Plugin, currId, currMenu, entry, execAll, groupAction, groupActions, i, j, len, m, mainDiv, menuSel, menus, parentId, parentMenu, plugin, pluginInst, ref;
        this.page_type = page_type;
        CSS.addStyleElement("#WikiMonkeyMenu input.margin {margin:0 0.33em 0.33em 0;}");
        mainDiv = $('<div/>').attr('id', 'WikiMonkeyMenu');
        groupActions = {};
        for (i = 0, len = plugins.length; i < len; i++) {
          Plugin = plugins[i];
          plugin = new Plugin(this.WM);
          pluginInst = plugin.conf[this.page_type + '_menu'];

          if (!pluginInst || !pluginInst.length) {
            continue;
          }
          if (plugin.makeUI) {
            groupAction = [this.warnInputNeeded, plugin];
          } else {
            groupAction = [this.executeEntryAction, plugin];
          }
          pluginInst.unshift("WikiMonkeyMenuRoot");
          currId = false;
          for (m = j = 0, ref = pluginInst.length - 1; 0 <= ref ? j < ref : j > ref; m = 0 <= ref ? ++j : --j) {
            parentId = currId;
            currId = pluginInst.slice(0, m + 1).join("-").replace(/ /g, "_");

            menuSel = mainDiv.children('div[id=\'' + currId + '\']');
            if (!menuSel.length) {
              currMenu = $("<div/>").attr("id", currId).hide().appendTo(mainDiv);
              groupActions[currId] = [];
              if (m > 0) {
                parentMenu = mainDiv.children('div[id=\'' + parentId + '\']');
                $('<input/>').attr('type', 'button').val('<').addClass('margin').click(makeChangeMenu(currMenu, parentMenu)).appendTo(currMenu);
                $('<input/>').attr('type', 'button').val(pluginInst[m]).click(makeGroupAction(groupActions[currId])).appendTo(parentMenu);
                $('<input/>').attr('type', 'button').val('>').addClass('margin').click(makeChangeMenu(parentMenu, currMenu)).appendTo(parentMenu);
              }
            } else {
              currMenu = menuSel.first();
            }
            groupActions[currId].push(groupAction);
          }
          entry = $("<input/>").attr('type', 'button').val(pluginInst[pluginInst.length - 1]).addClass('margin').appendTo(currMenu);
          if (plugin.makeUI) {
            entry.click(this.makeEntryUI(currMenu, plugin));
          } else {
            entry.click(this.makeEntryAction(plugin));
          }
        }
        menus = mainDiv.children();
        if (menus.length) {
          execAll = $('<input/>').attr('type', 'button').val("*").addClass('margin').click(makeGroupAction(groupActions["WikiMonkeyMenuRoot"]));

          mainDiv.children("div[id='WikiMonkeyMenuRoot']").first().prepend(execAll);
          menus.first().show();
          return mainDiv[0];
        } else {
          return false;
        }
      }
    }, {
      key: 'makeEntryUI',
      value: function makeEntryUI(currMenu, plugin) {
        var _this = this;

        return function (event) {
          var UI, UIdiv;
          currMenu.hide();
          UIdiv = $('<div/>');
          $('<input/>').attr('type', 'button').val('<').addClass('margin').click(function (event) {
            UIdiv.remove();
            return currMenu.show();
          }).appendTo(UIdiv);
          $('<input/>').attr('type', 'button').val('Execute').click(_this.makeEntryAction(plugin)).appendTo(UIdiv);
          UI = plugin.makeUI();
          return UIdiv.append(UI).insertAfter(currMenu);
        };
      }
    }, {
      key: 'makeEntryAction',
      value: function makeEntryAction(plugin) {
        var _this2 = this;

        return function (event) {
          return _this2.executeEntryAction(plugin, null);
        };
      }
    }, {
      key: 'executeEntryAction',
      value: function executeEntryAction(plugin, callNext) {
        this.WM.Log.logHidden("Plugin: " + plugin.constructor.name);
        return plugin['main_' + this.page_type](callNext);
      }
    }, {
      key: 'warnInputNeeded',
      value: function warnInputNeeded(plugin, callNext) {
        this.WM.Log.logWarning("Plugin " + plugin.constructor.name + " was not executed because it requires input from its interface.");
        if (callNext) {
          return callNext();
        }
      }
    }]);

    return exports;
  }();

  ;

  makeChangeMenu = function makeChangeMenu(currentMenu, changeMenu) {
    return function (event) {
      currentMenu.hide();
      return changeMenu.show();
    };
  };

  makeGroupAction = function makeGroupAction(subGroupActions) {
    return function (event) {
      return _executeGroupAction(subGroupActions, -1);
    };
  };

  _executeGroupAction = function executeGroupAction(subGroupActions, id) {
    var callContinue, fid;
    id++;
    if (subGroupActions[id]) {
      fid = subGroupActions[id];
      callContinue = function callContinue() {
        return _executeGroupAction(subGroupActions, id);
      };
      return fid[0](fid[1], callContinue);
    }
  };

  return exports;
}.call(undefined);

},{"@kynikos/misc/dist/CSS":2}],407:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var CSS;

CSS = require('@kynikos/misc/dist/CSS');

module.exports = function () {
  var disableEditSummarySubmitOnEnter, hideRollbackLinks, scrollToFirstHeading;

  var exports = function () {
    function exports(WM) {
      _classCallCheck(this, exports);

      this.WM = WM;
    }

    _createClass(exports, [{
      key: 'applyEditorMods',
      value: function applyEditorMods() {
        if (this.WM.conf.disable_edit_summary_submit_on_enter) {
          disableEditSummarySubmitOnEnter();
        }
        if (this.WM.conf.scroll_to_first_heading) {
          return scrollToFirstHeading();
        }
      }
    }, {
      key: 'applyRecentChangesMods',
      value: function applyRecentChangesMods() {
        if (this.WM.conf.hide_rollback_links) {
          return hideRollbackLinks();
        }
      }
    }, {
      key: 'applyContributionsMods',
      value: function applyContributionsMods() {
        if (this.WM.conf.hide_rollback_links) {
          return hideRollbackLinks();
        }
      }
    }]);

    return exports;
  }();

  ;

  disableEditSummarySubmitOnEnter = function disableEditSummarySubmitOnEnter() {
    return $('#wpSummary').keydown(function (event) {
      if (event.key === 'Enter' || typeof event.key === 'undefined' && event.keyCode === 13) {
        event.preventDefault();
        return false;
      }
    });
  };

  hideRollbackLinks = function hideRollbackLinks() {
    return CSS.addStyleElement("span.mw-rollback-link {display:none;}");
  };

  scrollToFirstHeading = function scrollToFirstHeading() {
    return window.scrollTo(0, $('#firstHeading').offset().top);
  };

  return exports;
}.call(undefined);

},{"@kynikos/misc/dist/CSS":2}],408:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var RegEx, Str;

RegEx = require('@kynikos/misc/dist/RegEx');

Str = require('@kynikos/misc/dist/Str');

module.exports = function () {
  var prepareRegexpWhitespace, prepareTitleCasing;

  var exports = function () {
    function exports(WM) {
      _classCallCheck(this, exports);

      this.WM = WM;
    }

    _createClass(exports, [{
      key: 'squashContiguousWhitespace',
      value: function squashContiguousWhitespace(title) {
        return title.replace(/[_ ]+/g, " ");
      }
    }, {
      key: 'neutralizeNowikiTags',
      value: function neutralizeNowikiTags(source) {
        var CLOSELENGTH, OPENLENGTH, i, len, maskLength, maskString, maskedText, prevId, tag, tags;

        OPENLENGTH = 8;
        CLOSELENGTH = 9;
        tags = Str.findSimpleEnclosures(source, /<nowiki>/i, OPENLENGTH, /<\/nowiki>/i, CLOSELENGTH);
        maskedText = "";
        prevId = 0;
        for (i = 0, len = tags.length; i < len; i++) {
          tag = tags[i];
          if (tag[1]) {
            maskLength = tag[1] - tag[0] + CLOSELENGTH;
            maskString = Str.padRight("", "x", maskLength);
            maskedText += source.substring(prevId, tag[0]) + maskString;
            prevId = tag[1] + CLOSELENGTH;
            continue;
          } else {
            maskLength = source.substr(tag[0]).length;
            maskString = Str.padRight("", "x", maskLength);
            maskedText += source.substring(prevId, tag[0]) + maskString;
            prevId = source.length;
            break;
          }
        }
        maskedText += source.substring(prevId);
        return maskedText;
      }
    }, {
      key: 'dotEncode',
      value: function dotEncode(text) {
        return encodeURIComponent(text).replace(/%/g, ".");
      }
    }, {
      key: 'dotEncodeLinkBreakingFragmentCharacters',
      value: function dotEncodeLinkBreakingFragmentCharacters(fragment) {
        fragment = fragment.replace(/\[/g, ".5B");
        fragment = fragment.replace(/\]/g, ".5D");
        fragment = fragment.replace(/\{/g, ".7B");
        fragment = fragment.replace(/\}/g, ".7D");
        fragment = fragment.replace(/\|/g, ".7C");
        return fragment;
      }
    }, {
      key: 'compareArticleTitles',
      value: function compareArticleTitles(title1, title2) {
        var t1, t2;

        t1 = prepareTitleCasing(this.squashContiguousWhitespace(title1).trim());
        t2 = prepareTitleCasing(this.squashContiguousWhitespace(title2).trim());
        return t1 === t2;
      }
    }, {
      key: 'findBehaviorSwitches',
      value: function findBehaviorSwitches(source, word) {
        var regExp;
        source = this.neutralizeNowikiTags(source);
        regExp;
        if (word) {
          regExp = new RegExp("__" + RegEx.escapePattern(word) + "__", "gi");
        } else {
          regExp = new RegExp("__(TOC|NOTOC|FORCETOC|NOEDITSECTION|" + "NEWSECTIONLINK|NONEWSECTIONLINK|NOGALLERY|HIDDENCAT|" + "NOCONTENTCONVERT|NOCC|NOTITLECONVERT|NOTC|INDEX|" + "NOINDEX|STATICREDIRECT|START|END)__", "gi");
        }
        return RegEx.matchAll(source, regExp);
      }
    }, {
      key: 'findLinksEngine',
      value: function findLinksEngine(source, titlePattern, specialOnly, caseSensitive) {
        var dbrace, dbraces, flags, i, inText, len, links, maskedText, match, nSource, nText, push, regExp, special;

        flags = caseSensitive ? "" : "i";

        special = specialOnly ? "(?:[ _]+:)?[ _]*" : "(?:\\:?[ _]*){0,2}";
        regExp = new RegExp("^" + special + "(" + titlePattern + ")" + "[ _]*(?:\\|[_\\s]*([\\s\\S]+?)[_\\s]*)?[_\\s]*$", flags);
        nSource = this.neutralizeNowikiTags(source);
        links = [];
        dbraces = Str.findInnermostEnclosures(nSource, "[[", "]]");
        for (i = 0, len = dbraces.length; i < len; i++) {
          dbrace = dbraces[i];
          inText = source.substring(dbrace[0] + 2, dbrace[1]);
          match = regExp.exec(inText);
          if (match) {
            push = true;
            if (match[6]) {
              nText = this.neutralizeNowikiTags(match[6]);
              maskedText = Str.findNestedEnclosures(nText, "{{", "}}", "x")[1];
              if (maskedText.search(/(\{\{|\}\})/) > -1) {
                this.WM.Log.logWarning("[[" + match[0] + "]] seems to contain part of a template, and the resulting behaviour cannot be predicted by this function, so the link will be ignored altogether");
                push = false;
              }
            }
            if (push) {
              links.push({
                "rawLink": "[[" + match[0] + "]]",
                "link": match[1],
                "rawTitle": match[2],
                "namespace": match[3],
                "title": match[4],
                "fragment": match[5],
                "anchor": match[6],
                "index": dbrace[0],
                "length": dbrace[1] + 2 - dbrace[0]
              });
            }
          }
        }
        return links;
      }
    }, {
      key: 'findSectionLinks',
      value: function findSectionLinks(source) {
        var fragmentChars, titlePattern;

        fragmentChars = "[^\\n\\{\\}\\[\\]\\|]*?";
        titlePattern = "(()())#(" + fragmentChars + ")";
        return this.findLinksEngine(source, titlePattern, false, true);
      }
    }, {
      key: 'findInternalLinks',
      value: function findInternalLinks(source, namespace, title) {
        var caseSensitive, fragmentChars, namespaceChars, rens, retitle, titleChars, titlePattern;

        namespaceChars = "[^\\n\\{\\}\\[\\]\\|\\:\\#]+?";
        titleChars = "[^\\n\\{\\}\\[\\]\\|\\#]+?";
        fragmentChars = "[^\\n\\{\\}\\[\\]\\|]*?";
        if (namespace) {
          rens = prepareRegexpWhitespace(RegEx.escapePattern(namespace));
          if (title) {
            retitle = prepareRegexpWhitespace(RegEx.escapePattern(title));
            titlePattern = "((" + rens + ")[ _]*:[ _]*" + "(" + retitle + "))" + "(?:[ _]*#(" + fragmentChars + "))?";

            caseSensitive = true;
          } else {
            titlePattern = "((" + rens + ")[ _]*:[ _]*" + "(" + titleChars + "))" + "(?:[ _]*#(" + fragmentChars + "))?";

            caseSensitive = false;
          }
        } else if (title) {
          retitle = prepareRegexpWhitespace(RegEx.escapePattern(title));

          titlePattern = "(()(" + retitle + "))" + "(?:[ _]*#(" + fragmentChars + "))?";

          caseSensitive = true;
        } else {
          titlePattern = "((?:(" + namespaceChars + ")[ _]*:[ _]*)?" + "(" + titleChars + "))" + "(?:[ _]*#(" + fragmentChars + "))?";
          caseSensitive = true;
        }
        return this.findLinksEngine(source, titlePattern, false, caseSensitive);
      }
    }, {
      key: 'findInterwikiLinks',
      value: function findInterwikiLinks(source, wiki) {
        return this.findInternalLinks(source, wiki);
      }
    }, {
      key: 'findSpecialLinks',
      value: function findSpecialLinks(source, pattern) {
        var fragmentChars, titleChars, titlePattern;

        titleChars = "[^\\n\\{\\}\\[\\]\\|\\#]+?";
        fragmentChars = "[^\\n\\{\\}\\[\\]\\|]*?";
        titlePattern = "((" + pattern + ")[ _]*:[ _]*" + "(" + titleChars + "))" + "(?:[ _]*#(" + fragmentChars + "))?";

        return this.findLinksEngine(source, titlePattern, true, false);
      }
    }, {
      key: 'findCategories',
      value: function findCategories(source) {
        return this.findSpecialLinks(source, "Category");
      }
    }, {
      key: 'findInterlanguageLinks',
      value: function findInterlanguageLinks(source, language) {
        return this.findSpecialLinks(source, RegEx.escapePattern(language));
      }
    }, {
      key: 'findVariables',
      value: function findVariables(source, variable) {
        var pattern;

        pattern = RegEx.escapePattern(variable);
        return this.findVariablesPattern(source, pattern);
      }
    }, {
      key: 'findVariablesPattern',
      value: function findVariablesPattern(source, pattern) {
        var dbracket, dbrackets, i, inText, len, match, nSource, regExp, results;

        nSource = this.neutralizeNowikiTags(source);
        results = [];
        dbrackets = Str.findNestedEnclosures(nSource, "{{", "}}", "x")[0];
        for (i = 0, len = dbrackets.length; i < len; i++) {
          dbracket = dbrackets[i];
          inText = source.substring(dbracket[0] + 2, dbracket[1]);

          regExp = new RegExp("^\\s*(" + pattern + ")" + "(?:\\:\\s*([\\s\\S]*?))?\\s*$", "");
          match = regExp.exec(inText);
          if (match) {
            results.push({
              "rawVariable": "{{" + match[0] + "}}",
              "name": match[1],
              "value": match[2],
              "index": dbracket[0],
              "length": dbracket[1] + 2 - dbracket[0]
            });
          }
        }
        return results;
      }
    }, {
      key: 'findTransclusionsEngine',
      value: function findTransclusionsEngine(source, pattern, templatesOnly) {
        var argIndex, dbracket, dbrackets, i, inText, len, match, nSource, regExp, transclusions;

        regExp = new RegExp("^(\\s*" + (templatesOnly ? "" : ":?") + "[_ ]*(" + pattern + ")[_ ]*\\s*)" + "(?:\\|([\\s\\S]*))?$", "");
        nSource = this.neutralizeNowikiTags(source);
        transclusions = [];
        dbrackets = Str.findNestedEnclosures(nSource, "{{", "}}", "x")[0];
        for (i = 0, len = dbrackets.length; i < len; i++) {
          dbracket = dbrackets[i];
          inText = source.substring(dbracket[0] + 2, dbracket[1]);
          match = regExp.exec(inText);
          if (match) {
            argIndex = dbracket[0] + match[1].length + 3;
            transclusions.push({
              "rawTransclusion": "{{" + match[0] + "}}",
              "title": match[2],
              "index": dbracket[0],
              "length": dbracket[1] - dbracket[0] + 2,
              "arguments": this.findTransclusionArguments(match, argIndex)
            });
          }
        }
        return transclusions;
      }
    }, {
      key: 'findTransclusionArguments',
      value: function findTransclusionArguments(match, argIndex) {
        var argL, args, argument, eqIndex, i, key, keyIndex, keyMatches, len, mArgs, mArgument, maskedArgs, nArgs, rawArguments, rawKey, reKey, relIndex, value, valueIndex;
        rawArguments = match[3];
        args = [];
        if (rawArguments) {
          nArgs = this.neutralizeNowikiTags(rawArguments);

          maskedArgs = Str.findNestedEnclosures(nArgs, "[[", "]]", "x")[1];

          maskedArgs = Str.findNestedEnclosures(maskedArgs, "{{", "}}", "x")[1];

          if (maskedArgs.search(/(\{\{|\}\}|\[\[|\]\])/) > -1) {
            this.WM.Log.logWarning("{{" + match[0] + "}} seems to contain part of a link or template, and the resulting behaviour cannot be predicted by this function, so the whole template will be ignored altogether");
          } else {
            mArgs = maskedArgs.split("|");
            relIndex = 0;
            for (i = 0, len = mArgs.length; i < len; i++) {
              mArgument = mArgs[i];
              argL = mArgument.length;
              argument = rawArguments.substr(relIndex, argL);
              eqIndex = mArgument.indexOf("=");

              if (eqIndex > 0) {
                rawKey = argument.substring(0, eqIndex);
                reKey = /^(\s*)(.+?)\s*$/;
                keyMatches = reKey.exec(rawKey);
                key = keyMatches[2];
                keyIndex = argIndex + (keyMatches[1] ? keyMatches[1].length : 0);

                value = argument.substr(eqIndex + 1);
                valueIndex = argIndex + keyMatches[0].length + 1;
              } else {
                key = null;
                keyIndex = null;
                value = argument;
                valueIndex = argIndex;
              }
              args.push({
                key: key,
                key_index: keyIndex,
                value: value,
                value_index: valueIndex
              });

              relIndex += argL + 1;
            }
          }
        }
        return args;
      }
    }, {
      key: 'findTemplates',
      value: function findTemplates(source, template) {
        var pattern;
        if (template) {
          pattern = RegEx.escapePattern(template);
          pattern = prepareRegexpWhitespace(pattern);
          pattern = prepareTitleCasing(pattern);
        } else {
          pattern = "[^\\n\\{\\}\\[\\]\\||\\#]+?";
        }
        return this.findTemplatesPattern(source, pattern);
      }
    }, {
      key: 'findTemplatesPattern',
      value: function findTemplatesPattern(source, pattern) {
        return this.findTransclusionsEngine(source, pattern, true);
      }
    }, {
      key: 'findTransclusions',
      value: function findTransclusions(source, namespace, title) {
        var namespacePattern, pattern, titleChars, titlePattern;

        titleChars = "[^\\n\\{\\}\\[\\]\\||\\#]+?";
        if (namespace) {
          namespacePattern = RegEx.escapePattern(namespace);
          namespacePattern = prepareRegexpWhitespace(namespacePattern);
          namespacePattern = prepareTitleCasing(namespacePattern);
        }
        if (title) {
          titlePattern = RegEx.escapePattern(title);
          titlePattern = prepareRegexpWhitespace(titlePattern);
          titlePattern = prepareTitleCasing(titlePattern);
        }
        if (namespacePattern && titlePattern) {
          pattern = namespacePattern + "[ _]*:[ _]*" + titlePattern;
        } else if (!namespacePattern && titlePattern) {
          pattern = titlePattern;
        } else if (namespacePattern && !titlePattern) {
          pattern = namespacePattern + "[ _]*:" + titleChars;
        } else {
          pattern = titleChars;
        }
        return this.findTransclusionsEngine(source, pattern, false);
      }
    }, {
      key: 'findSectionHeadings',
      value: function findSectionHeadings(source) {
        var L0, L1, MAXLEVEL, cleanheading, end, heading, i, len, level, line, match, maxTocLevel, minLevel, pLevel, prevLevels, rawheading, regExp, sections, start, tocLevel, tocPeer;

        MAXLEVEL = 6;
        sections = [];
        minLevel = MAXLEVEL;
        maxTocLevel = 0;
        tocLevel = 1;
        regExp = /^(\=+([ _]*(.+?)[ _]*)\=+)[ \t]*$/gm;
        while (true) {
          match = regExp.exec(source);
          if (match) {
            L0 = match[0].length;
            line = match[1];
            rawheading = match[2];
            heading = match[3];
            cleanheading = this.squashContiguousWhitespace(heading);
            L1 = line.length;
            level = 1;
            start = "=";
            end = "=";

            while (true) {
              start = line.substr(level, 1);
              end = line.substr(L1 - level - 1, 1);
              if (L1 - level * 2 > 2 && start === "=" && end === "=") {
                level++;
              } else {
                if (level > MAXLEVEL) {
                  level = MAXLEVEL;
                } else if (level < minLevel) {
                  minLevel = level;
                }
                break;
              }
            }
            if (level === minLevel) {
              tocLevel = 1;
              prevLevels = {};
              prevLevels[level] = 1;
              prevLevels.relMax = level;
              if (maxTocLevel === 0) {
                maxTocLevel = tocLevel;
              }
            } else if (level > prevLevels.relMax) {
              tocLevel++;
              prevLevels[level] = tocLevel;
              prevLevels.relMax = level;
              if (tocLevel > maxTocLevel) {
                maxTocLevel = tocLevel;
              }
            } else if (level < prevLevels.relMax) {
              if (prevLevels[level]) {
                tocLevel = prevLevels[level];
              } else {
                tocPeer = prevLevels.relMax;
                for (i = 0, len = prevLevels.length; i < len; i++) {
                  pLevel = prevLevels[i];
                  if (pLevel > level && pLevel < tocPeer) {
                    tocPeer = pLevel;
                  }
                }
                tocLevel = prevLevels[tocPeer];
                prevLevels[level] = tocLevel;
              }
              prevLevels.relMax = level;
            }
            sections.push({
              line: line,
              rawheading: rawheading,
              heading: heading,
              cleanheading: cleanheading,
              level: level,
              tocLevel: tocLevel,
              index: regExp.lastIndex - L0,
              length0: L0,
              length1: L1
            });
          } else {
            break;
          }
        }

        if (maxTocLevel === 0) {
          minLevel = 0;
        }
        return {
          sections: sections,
          minLevel: minLevel,
          maxTocLevel: maxTocLevel
        };
      }
    }]);

    return exports;
  }();

  ;

  prepareRegexpWhitespace = function prepareRegexpWhitespace(title) {
    return title.replace(/[_ ]+/g, "[_ ]+");
  };

  prepareTitleCasing = function prepareTitleCasing(pattern) {
    var fcLower, fcUpper, firstChar;
    firstChar = pattern.charAt(0);
    fcUpper = firstChar.toUpperCase();
    fcLower = firstChar.toLowerCase();
    if (fcUpper !== fcLower) {
      pattern = "[" + fcUpper + fcLower + "]" + pattern.substr(1);
    }
    return pattern;
  };

  return exports;
}.call(undefined);

},{"@kynikos/misc/dist/RegEx":6,"@kynikos/misc/dist/Str":7}],409:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Str;

Str = require('@kynikos/misc/dist/Str');

module.exports = function () {
  function exports(WM) {
    _classCallCheck(this, exports);

    this.WM = WM;
  }

  _createClass(exports, [{
    key: 'appendRow',
    value: function appendRow(source, mark, values) {
      var endtable, lastId, newText, row;
      lastId = source.lastIndexOf('|}' + mark);
      endtable = lastId > -1 ? lastId : source.lastIndexOf('|}');
      row = "|-\n|" + values.join("\n|") + "\n";
      newText = Str.insert(source, row, endtable);
      return newText;
    }
  }]);

  return exports;
}();

},{"@kynikos/misc/dist/Str":7}],410:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var CSS, RegEx, version;

var _require = require('../../package.json');

version = _require.version;


CSS = require('@kynikos/misc/dist/CSS');

RegEx = require('@kynikos/misc/dist/RegEx');

module.exports = function () {
  function exports(WM) {
    _classCallCheck(this, exports);

    this.WM = WM;
  }

  _createClass(exports, [{
    key: '_makeUI',
    value: function _makeUI() {
      var UI, conf, date, display, displayLog, hide, legend, logArea, main, main2, nextNode, patt1A, patt1B, patt2A, patt2B, patt3A, patt3B, patt4A, patt4B, patt5A, patt5B, wikiUrls;
      display = true;
      displayLog = true;
      if (document.getElementById('editform')) {
        nextNode = document.getElementById('wpSummaryLabel').parentNode.nextSibling;
        conf = this.WM.Plugins.editor;
        UI = conf.length ? this.WM.Menu._makeUI('editor', conf) : null;
        this.WM.Mods.applyEditorMods();
      } else if (document.getElementById('mw-diff-otitle1')) {
        nextNode = document.getElementById('bodyContent').getElementsByTagName('h2')[0];
        conf = this.WM.Plugins.diff;
        UI = conf.length ? this.WM.Menu._makeUI('diff', conf) : null;
      } else if (document.getElementById('mw-subcategories') || document.getElementById('mw-pages')) {
        nextNode = document.getElementById('bodyContent');
        conf = this.WM.Plugins.bot;
        UI = conf.length ? this.WM.Bot._makeUI(conf, [[document.getElementById('mw-pages'), 0, "Pages"], [document.getElementById('mw-subcategories'), 0, "Subcategories"]]) : null;
        display = false;
      } else if (document.getElementById('mw-whatlinkshere-list')) {
        nextNode = document.getElementById('bodyContent').getElementsByTagName('form')[0].nextSibling;
        conf = this.WM.Plugins.bot;
        UI = conf.length ? this.WM.Bot._makeUI(conf, [[document.getElementById('mw-whatlinkshere-list'), 0, "Pages"]]) : null;
        display = false;
      } else if (document.body.classList.contains('mw-special-LinkSearch') && document.getElementById('bodyContent').getElementsByTagName('ol')[0]) {
        nextNode = document.getElementsByClassName('mw-spcontent')[0];
        conf = this.WM.Plugins.bot;
        UI = conf.length ? this.WM.Bot._makeUI(conf, [[document.getElementById('bodyContent').getElementsByTagName('ol')[0], 1, "Pages"]]) : null;
        display = false;
      } else if (document.getElementById('mw-prefixindex-list-table')) {
        nextNode = document.getElementById('mw-prefixindex-list-table');
        conf = this.WM.Plugins.bot;
        UI = conf.length ? this.WM.Bot._makeUI(conf, [[nextNode.getElementsByTagName('tbody')[0], 0, "Pages"]]) : null;
        display = false;
      } else {
        wikiUrls = this.WM.MW.getWikiUrls();
        patt1A = new RegExp(RegEx.escapePattern(wikiUrls.full) + "\?.*?" + "title\\=Special(\\:|%3[Aa])SpecialPages", '');
        patt1B = new RegExp(RegEx.escapePattern(wikiUrls.short) + "Special(\\:|%3[Aa])SpecialPages", '');
        patt2A = new RegExp(RegEx.escapePattern(wikiUrls.full) + "\?.*?" + "title\\=Special(\\:|%3[Aa])RecentChanges", '');
        patt2B = new RegExp(RegEx.escapePattern(wikiUrls.short) + "Special(\\:|%3[Aa])RecentChanges", '');
        patt3A = new RegExp(RegEx.escapePattern(wikiUrls.full) + "\?.*?" + "title\\=Special(\\:|%3[Aa])NewPages", '');
        patt3B = new RegExp(RegEx.escapePattern(wikiUrls.short) + "Special(\\:|%3[Aa])NewPages", '');
        patt4A = new RegExp(RegEx.escapePattern(wikiUrls.full) + "\?.*?" + "title\\=Special(\\:|%3[Aa])ProtectedPages", '');
        patt4B = new RegExp(RegEx.escapePattern(wikiUrls.short) + "Special(\\:|%3[Aa])ProtectedPages", '');
        patt5A = new RegExp(RegEx.escapePattern(wikiUrls.full) + "\?.*?" + "title\\=Special(\\:|%3[Aa])Contributions", '');
        patt5B = new RegExp(RegEx.escapePattern(wikiUrls.short) + "Special(\\:|%3[Aa])Contributions", '');
        if (location.href.search(patt1A) > -1 || location.href.search(patt1B) > -1) {
          nextNode = document.getElementById('bodyContent');
          conf = this.WM.Plugins.special;
          UI = conf.length ? this.WM.Menu._makeUI('special', conf) : null;
        } else if (location.href.search(patt2A) > -1 || location.href.search(patt2B) > -1) {
          nextNode = document.getElementById('mw-content-text').getElementsByTagName('h4')[0];
          conf = this.WM.Plugins.recentchanges;
          UI = conf.length ? this.WM.Filters._makeUI('recentchanges', conf) : null;
          displayLog = false;
          this.WM.Mods.applyRecentChangesMods();
        } else if (location.href.search(patt3A) > -1 || location.href.search(patt3B) > -1) {
          nextNode = document.getElementById('mw-content-text').getElementsByTagName('ul')[0];
          conf = this.WM.Plugins.newpages;
          UI = conf.length ? this.WM.Filters._makeUI('newpages', conf) : null;
          displayLog = false;
        } else if (location.href.search(patt4A) > -1 || location.href.search(patt4B) > -1) {
          nextNode = document.getElementById('mw-content-text').getElementsByTagName('ul')[0];
          conf = this.WM.Plugins.bot;
          UI = conf.length ? this.WM.Bot._makeUI(conf, [[document.getElementById('mw-content-text').getElementsByTagName('ul')[0], 0, "Pages"]]) : null;
          display = false;
        } else if (location.href.search(patt5A) > -1 || location.href.search(patt5B) > -1) {
          this.WM.Mods.applyContributionsMods();
        } else if (document.getElementsByClassName('mw-spcontent').length > 0) {
          nextNode = document.getElementsByClassName('mw-spcontent')[0];
          conf = this.WM.Plugins.bot;
          UI = conf.length ? this.WM.Bot._makeUI(conf, [[nextNode.getElementsByTagName('ol')[0], 0, "Pages"]]) : null;
          display = false;
        } else if (document.getElementsByClassName('mw-allpages-table-chunk').length > 0) {
          nextNode = document.getElementsByClassName('mw-allpages-table-chunk')[0];
          conf = this.WM.Plugins.bot;
          UI = conf.length ? this.WM.Bot._makeUI(conf, [[nextNode.getElementsByTagName('tbody')[0], 0, "Pages"]]) : null;
          display = false;
        }
      }
      if (UI) {
        CSS.addStyleElement("#WikiMonkey {position:relative;} #WikiMonkey fieldset {margin:0 0 1em 0;}");
        main = document.createElement('fieldset');
        main.id = 'WikiMonkey';
        legend = document.createElement('legend');
        legend.appendChild(document.createTextNode('Wiki Monkey '));
        hide = document.createElement('a');
        hide.href = '#WikiMonkey';
        hide.innerHTML = '[hide]';
        hide.addEventListener("click", function (event) {
          var wmmain;
          event.preventDefault();
          wmmain = document.getElementById('WikiMonkeyMain');
          if (wmmain.style.display === 'none') {
            wmmain.style.display = 'block';
            return this.innerHTML = '[hide]';
          } else {
            wmmain.style.display = 'none';
            return this.innerHTML = '[show]';
          }
        }, false);
        legend.appendChild(hide);
        main.appendChild(legend);
        main2 = document.createElement('div');
        main2.id = 'WikiMonkeyMain';
        main2.appendChild(UI);
        logArea = this.WM.Log._makeLogArea();
        if (!displayLog) {
          logArea.style.display = 'none';
        }
        main2.appendChild(logArea);
        if (!display) {
          main2.style.display = 'none';
          hide.innerHTML = '[show]';
        }
        main.appendChild(main2);
        nextNode.parentNode.insertBefore(main, nextNode);
        this.WM.Log.logHidden('Wiki Monkey version: ' + version);
        date = new Date();
        this.WM.Log.logHidden('Date: ' + date.toString());
        return this.WM.Log.logHidden('URL: ' + location.href);
      }
    }
  }]);

  return exports;
}();

},{"../../package.json":395,"@kynikos/misc/dist/CSS":2,"@kynikos/misc/dist/RegEx":6}],411:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var A,
    Br,
    Div,
    moment,
    version,
    indexOf = [].indexOf;

var _require = require('./libs');

moment = _require.moment;
A = _require.A;
Br = _require.Br;
Div = _require.Div;

var _require2 = require('../../package.json');

version = _require2.version;


module.exports = function () {
  var PACKAGE_URL;

  var exports = function () {
    function exports(WM) {
      _classCallCheck(this, exports);

      this.WM = WM;
    }

    _createClass(exports, [{
      key: 'check_and_notify',
      value: function () {
        var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
          var _this = this;

          var upstream_package;
          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  if (!this.should_check()) {
                    _context.next = 9;
                    break;
                  }

                  _context.next = 3;
                  return $.getJSON(PACKAGE_URL);

                case 3:
                  upstream_package = _context.sent;

                  if (!(version !== upstream_package.version)) {
                    _context.next = 8;
                    break;
                  }

                  return _context.abrupt('return', this.display_notification(['Version ' + upstream_package.version + ' is available.', Br(), A({
                    href: "https://github.com/kynikos/wiki-monkey/wiki/Changelog" }, "Changelog"), Br(), A('Run upgrade', {
                    onclick: function onclick() {
                      return _this.upgrade(upstream_package.version);
                    }
                  })]));

                case 8:
                  return _context.abrupt('return', mw.storage.set('WikiMonkey-last-update-check', moment().format('YYYY-MM-DD')));

                case 9:
                case 'end':
                  return _context.stop();
              }
            }
          }, _callee, this);
        }));

        function check_and_notify() {
          return _ref.apply(this, arguments);
        }

        return check_and_notify;
      }()
    }, {
      key: 'should_check',
      value: function should_check() {
        var diff, lastupdcheck, ref;
        lastupdcheck = mw.storage.get('WikiMonkey-last-update-check');
        if (!lastupdcheck) {
          return true;
        }
        diff = moment().diff(moment(lastupdcheck), 'days');

        if (diff >= 1 && (ref = moment().day(), indexOf.call(this.WM.conf.update_check_wdays, ref) >= 0) || diff >= 7) {
          return true;
        }
        return false;
      }
    }, {
      key: 'display_notification',
      value: function display_notification(content, optionsoverride) {
        var options;
        options = {
          autoHide: false,
          tag: 'WikiMonkey-upgrade',
          title: 'Wiki Monkey',
          type: 'info'
        };
        $.extend(options, optionsoverride);
        return mw.notification.notify(content, options);
      }
    }, {
      key: 'upgrade',
      value: function upgrade(upstream_version) {
        var _this2 = this;

        var page, pagelink, regex;
        page = 'User:' + mw.user.getName() + '/common.js';
        pagelink = this.WM.MW.linkArticle(page);
        this.display_notification('Upgrading to version ' + upstream_version + '...');

        regex = new RegExp("([\"']https?://[^/]+/kynikos/wiki-monkey/" + ('v)' + mw.RegExp.escape(version) + '(/dist/') + "WikiMonkey-[^/]+\\.js[\"'])", 'g');
        return this.WM.MW.api.edit(page, function (revision) {
          var newtext;
          newtext = revision.content.replace(regex, '$1' + upstream_version + '$2');
          if (newtext === revision.content) {
            return Promise.reject(new Error("Could not find Wiki Monkey loader line"));
          }
          return {
            text: newtext,
            summary: 'Update Wiki Monkey to version ' + upstream_version,
            bot: true
          };
        }).done(function (result) {
          console.log(result);
          return _this2.display_notification(["Upgrade successful: you need to refresh the open wiki page(s) in order to use the new version.", Br(), A({
            href: "https://github.com/kynikos/wiki-monkey/wiki/Changelog"
          }, "Changelog")]);
        }).fail(function (code, error) {
          console.error(code, error);
          return _this2.display_notification(['Could not complete the upgrade to version ' + upstream_version + ': ', A({
            onclick: function onclick() {
              return _this2.upgrade(upstream_version);
            }
          }, "retry"), " in case it was a temporary problem; it is also possible that Wiki Monkey is installed in a non-standard way in ", pagelink, " and the upgrade should be executed manually; finally, it is possible that the upgrade was already launched and completed from another page: in this case refresh the page to verify."], {
            type: 'error'
          });
        });
      }
    }, {
      key: 'check_obsolete_config',
      value: function check_obsolete_config() {
        var _this3 = this;

        var blob, confhref, oldconf;

        oldconf = localStorage.getItem("WikiMonkey");
        if (oldconf !== null) {
          blob = new Blob([oldconf], {
            type: 'application/json'
          });
          confhref = window.URL.createObjectURL(blob);
          return this.display_notification(["Wiki Monkey 4.0.0 uses a completely rewritten configuration system. After updating, your old configuration was not automatically imported, but it is still saved in your browser's localStorage. You can decide to export it and then merge it manually, or simply remove it and use the default configuration options.", Br(), A({
            href: "https://github.com/kynikos/wiki-monkey/wiki/Configuration" }, "New configuration instructions"), Br(), A({
            href: confhref
          }, "View old configuration"), Br(), A({
            href: confhref,
            download: "wikimonkey_oldconf.json"
          }, "Export old configuration"), Br(), A({
            onclick: function onclick() {
              localStorage.removeItem("WikiMonkey");
              return _this3.display_notification("The old configuration was successfully removed.", {
                autoHide: true
              });
            }
          }, "Delete old configuration")]);
        }
      }
    }]);

    return exports;
  }();

  ;

  PACKAGE_URL = 'https://raw.githubusercontent.com/kynikos/wiki-monkey/master/package.json';

  return exports;
}.call(undefined);

},{"../../package.json":395,"./libs":414}],412:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

module.exports = function () {
  function exports(WM) {
    _classCallCheck(this, exports);

    this.WM = WM;
  }

  _createClass(exports, [{
    key: 'isWhatLinksHerePage',
    value: function isWhatLinksHerePage() {
      if (document.getElementById('mw-whatlinkshere-list')) {
        return true;
      } else {
        return false;
      }
    }
  }, {
    key: 'getTitle',
    value: function getTitle() {
      return document.getElementById('contentSub').getElementsByTagName('a')[0].title;
    }
  }]);

  return exports;
}();

},{}],413:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ArchWiki, Bot, Cat, Diff, Editor, Filters, Interlanguage, Log, MW, Menu, Mods, Parser, Plugin, Tables, UI, Upgrade, WhatLinksHere, mwmodpromise;

mwmodpromise = mw.loader.using(['mediawiki.api.edit', 'mediawiki.notification']);

require('./libs');

ArchWiki = require('./ArchWiki');

Bot = require('./Bot');

Cat = require('./Cat');

Diff = require('./Diff');

Editor = require('./Editor');

Filters = require('./Filters');

Interlanguage = require('./Interlanguage');

Log = require('./Log');

Menu = require('./Menu');

Mods = require('./Mods');

MW = require('./MW');

Parser = require('./Parser');

Tables = require('./Tables');

UI = require('./UI');

Upgrade = require('./Upgrade');

WhatLinksHere = require('./WhatLinksHere');

var _require = require('../plugins/_Plugin');

Plugin = _require.Plugin;


module.exports.WM = function () {
  var WM = function () {
    function WM(wiki_name) {
      _classCallCheck(this, WM);

      this.init = this.init.bind(this);
      this.wiki_name = wiki_name;

      for (var _len = arguments.length, installed_plugins_temp = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        installed_plugins_temp[_key - 1] = arguments[_key];
      }

      this.installed_plugins_temp = installed_plugins_temp;
      this.setup();
      $.when(mwmodpromise, $.ready).done(this.init);
    }

    _createClass(WM, [{
      key: 'setup',
      value: function setup() {
        var PluginSub, error, i, interface_, len, option, pmod, pname, ref, user_config, value;

        user_config = window.wikiMonkeyConfig || window.wikimonkey_config || {};
        for (option in user_config) {
          value = user_config[option];
          if (!(option in this.conf)) {
            continue;
          }
          this.conf[option] = value;
          delete user_config[option];
        }
        this.Plugins = {
          bot: [],
          diff: [],
          editor: [],
          newpages: [],
          recentchanges: [],
          special: []
        };
        ref = this.installed_plugins_temp;
        for (i = 0, len = ref.length; i < len; i++) {
          pmod = ref[i];
          for (pname in pmod) {
            PluginSub = pmod[pname];
            if (!(PluginSub.prototype instanceof Plugin)) {
              continue;
            }
            try {
              PluginSub.__configure(this.wiki_name, user_config);
            } catch (error1) {
              error = error1;

              if (error.message === "Plugin disabled") {
                continue;
              }
              throw error;
            }
            for (interface_ in this.Plugins) {
              if (PluginSub.prototype['main_' + interface_]) {
                this.Plugins[interface_].push(PluginSub);
              }
            }
          }
        }
        if (!$.isEmptyObject(user_config)) {
          console.warn("Unkown configuration options", user_config);
        }
        return delete this.installed_plugins_temp;
      }
    }, {
      key: 'init',
      value: function init() {
        this.ArchWiki = new ArchWiki(this);
        this.Bot = new Bot(this);
        this.Cat = new Cat(this);
        this.Diff = new Diff(this);
        this.Editor = new Editor(this);
        this.Filters = new Filters(this);
        this.Interlanguage = new Interlanguage(this);
        this.Log = new Log(this);
        this.Menu = new Menu(this);
        this.Mods = new Mods(this);
        this.MW = new MW(this);
        this.Parser = new Parser(this);
        this.Tables = new Tables(this);
        this.UI = new UI(this);
        this.Upgrade = new Upgrade(this);
        this.WhatLinksHere = new WhatLinksHere(this);
        this.Upgrade.check_obsolete_config();
        if (this.conf.update_check_wdays) {
          this.Upgrade.check_and_notify();
        }
        return this.UI._makeUI();
      }
    }]);

    return WM;
  }();

  ;

  WM.prototype.conf = {
    default_bot_plugin: "SimpleReplace",
    default_recentchanges_plugin: null,
    default_newpages_plugin: null,
    update_check_wdays: [6],
    hide_rollback_links: true,
    disable_edit_summary_submit_on_enter: true,
    scroll_to_first_heading: false
  };

  return WM;
}.call(undefined);

},{"../plugins/_Plugin":434,"./ArchWiki":397,"./Bot":398,"./Cat":399,"./Diff":400,"./Editor":401,"./Filters":402,"./Interlanguage":403,"./Log":404,"./MW":405,"./Menu":406,"./Mods":407,"./Parser":408,"./Tables":409,"./UI":410,"./Upgrade":411,"./WhatLinksHere":412,"./libs":414}],414:[function(require,module,exports){
'use strict';

var helper, hh, jss, tag;

require('babel-polyfill');

hh = require('hyperscript-helpers')(require('hyperscript'));

for (tag in hh) {
  helper = hh[tag];

  module.exports[tag.charAt(0).toUpperCase() + tag.slice(1)] = helper;
}

module.exports.moment = require('moment');

jss = require('jss').default;

jss.setup(require('jss-preset-default').default());

module.exports.jss = jss;

},{"babel-polyfill":8,"hyperscript":342,"hyperscript-helpers":341,"jss":365,"jss-preset-default":354,"moment":389}],415:[function(require,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Plugin,
    indexOf = [].indexOf;

var _require = require('./_Plugin');

Plugin = _require.Plugin;


module.exports.ArchWikiFixHeader = function () {
  var ArchWikiFixHeader = function (_Plugin) {
    _inherits(ArchWikiFixHeader, _Plugin);

    function ArchWikiFixHeader() {
      _classCallCheck(this, ArchWikiFixHeader);

      return _possibleConstructorReturn(this, (ArchWikiFixHeader.__proto__ || Object.getPrototypeOf(ArchWikiFixHeader)).apply(this, arguments));
    }

    _createClass(ArchWikiFixHeader, [{
      key: "main_editor",
      value: function main_editor(callNext) {
        var b, behaviorswitches, bslist, bswitch, cat, categories, catlang, catlink, catlinks, catlist, cattext, cleantitle, content, contentId, displaytitle, dlct, dt, firstChar, fulllink, header, i, interlanguage, iwlinks, iwlist, j, k, l, language, lct, len, len1, len2, len3, link, linklang, linktext, linktitle, lowercasetitle, newText, ref, ref1, source, tempcontent, titlemod, titlemods;
        source = this.WM.Editor.readSource();
        language = this.WM.ArchWiki.detectLanguage(this.WM.Editor.getTitle())[1];
        header = "";
        content = source;

        content = content.replace(/^\s*<noinclude>/, "");
        if (content !== source) {
          header += "<noinclude>\n";
        }

        displaytitle = this.WM.Parser.findVariables(content, "DISPLAYTITLE");
        lowercasetitle = this.WM.Parser.findTemplates(content, "Lowercase title");
        titlemods = displaytitle.concat(lowercasetitle);
        titlemods.sort(function (a, b) {
          return a.index - b.index;
        });
        tempcontent = "";
        contentId = 0;
        for (i = 0, len = titlemods.length; i < len; i++) {
          titlemod = titlemods[i];
          tempcontent += content.substring(contentId, titlemod.index);
          contentId = titlemod.index + titlemod.length;
        }
        tempcontent += content.substring(contentId);
        content = tempcontent;
        dt = displaytitle.pop();
        lct = lowercasetitle.pop();
        dlct = "";
        if (dt && !lct) {
          dlct = "{{DISPLAYTITLE:" + dt.value + "}}";
        } else if (!dt && lct) {
          dlct = "{{Lowercase title}}";
        } else if (dt && lct) {
          dlct = dt.index < lct.index ? "{{Lowercase title}}" : "{{DISPLAYTITLE:" + dt.value + "}}";
        }
        if (displaytitle.length || lowercasetitle.length) {
          this.WM.Log.logWarning("Found multiple instances of {{DISPLAYTITLE:...}} or {{Lowercase title}}: only the last one has been used, the others have been deleted");
        }

        behaviorswitches = this.WM.Parser.findBehaviorSwitches(content);
        bslist = [];
        tempcontent = "";
        contentId = 0;
        for (b = j = 0, len1 = behaviorswitches.length; j < len1; b = ++j) {
          bswitch = behaviorswitches[b];
          if ((ref = bswitch.match[1]) === "TOC" || ref === "START" || ref === "END") {
            behaviorswitches.splice(b, 1);
          } else {
            if (ref1 = bswitch.match[0], indexOf.call(bslist, ref1) < 0) {
              bslist.push(bswitch.match[0]);
            } else {
              this.WM.Log.logWarning("Removed duplicate of " + bswitch.match[0]);
            }
            tempcontent += content.substring(contentId, bswitch.index);
            contentId = bswitch.index + bswitch.length;
          }
        }
        tempcontent += content.substring(contentId);
        content = tempcontent;
        if (!dlct && bslist.length) {
          header += bslist.join(" ") + "\n";
        } else if (dlct && !bslist.length) {
          header += dlct + "\n";
        } else if (dlct && bslist.length) {
          header += dlct + " " + bslist.join(" ") + "\n";
        }

        categories = this.WM.Parser.findCategories(content);
        catlist = [];
        catlinks = [];
        tempcontent = "";
        contentId = 0;
        for (k = 0, len2 = categories.length; k < len2; k++) {
          cat = categories[k];
          if (cat.fragment) {
            this.WM.Log.logWarning(this.WM.Log.linkToWikiPage(cat.link, cat.rawLink) + " contains a fragment reference, but it doesn't make sense in categories and will be removed");
          }
          cleantitle = this.WM.Parser.squashContiguousWhitespace(cat.title);
          cattext = "Category:" + cleantitle;

          catlang = this.WM.ArchWiki.detectLanguage(cattext)[1];
          catlink = "[[" + cattext + (cat.anchor ? "|" + cat.anchor : "") + "]]";
          if (language !== catlang) {
            this.WM.Log.logWarning(this.WM.Log.linkToWikiPage(cat.link, cattext) + " belongs to a different language than the one of the title (" + language + ")");
          }
          if (catlist.indexOf(cattext) < 0) {
            catlist.push(cattext);
            catlinks.push(catlink);
          } else {
            this.WM.Log.logWarning("Removed duplicate of " + this.WM.Log.linkToWikiPage(cat.link, cattext));
          }
          tempcontent += content.substring(contentId, cat.index);
          contentId = cat.index + cat.length;
        }
        if (catlist.length) {
          header += catlinks.join("\n") + "\n";
        } else {
          this.WM.Log.logWarning("The article is not categorized");
        }
        tempcontent += content.substring(contentId);
        content = tempcontent;

        interlanguage = this.WM.ArchWiki.findAllInterlanguageLinks(content);
        iwlist = [];
        iwlinks = [];
        tempcontent = "";
        contentId = 0;
        for (l = 0, len3 = interlanguage.length; l < len3; l++) {
          link = interlanguage[l];
          if (link.anchor) {
            this.WM.Log.logWarning(link.rawLink + " contains an alternative text, but it doesn't make sense in interlanguage links and will be removed");
          }

          linktitle = link.title;
          linklang = link.namespace;
          linktext = linklang + ":" + linktitle;
          fulllink = "[[" + linktext + (link.fragment ? "#" + link.fragment : "") + "]]";
          if (iwlist.indexOf(linktext) < 0) {
            iwlist.push(linktext);
            iwlinks.push(fulllink);
          } else {
            this.WM.Log.logWarning("Removed duplicate of " + linktext);
          }
          tempcontent += content.substring(contentId, link.index);
          contentId = link.index + link.length;
        }
        if (iwlist.length) {
          iwlinks.sort();
          header += iwlinks.join("\n") + "\n";
        }
        tempcontent += content.substring(contentId);
        content = tempcontent;
        firstChar = content.search(/[^\s]/);
        content = content.substr(firstChar);
        newText = header + content;
        if (newText !== source) {
          this.WM.Editor.writeSource(newText);
          this.WM.Log.logInfo("Fixed header");
        }
        if (callNext) {
          return callNext();
        }
      }
    }]);

    return ArchWikiFixHeader;
  }(Plugin);

  ;

  ArchWikiFixHeader.conf_default = {
    enabled: true,
    editor_menu: ["Text plugins", "Fix header"]
  };

  return ArchWikiFixHeader;
}.call(undefined);

},{"./_Plugin":434}],416:[function(require,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Plugin;

var _require = require('./_Plugin');

Plugin = _require.Plugin;


module.exports.ArchWikiFixHeadings = function () {
  var ArchWikiFixHeadings = function (_Plugin) {
    _inherits(ArchWikiFixHeadings, _Plugin);

    function ArchWikiFixHeadings() {
      _classCallCheck(this, ArchWikiFixHeadings);

      return _possibleConstructorReturn(this, (ArchWikiFixHeadings.__proto__ || Object.getPrototypeOf(ArchWikiFixHeadings)).apply(this, arguments));
    }

    _createClass(ArchWikiFixHeadings, [{
      key: "main_editor",
      value: function main_editor(callNext) {
        var i, increaseLevel, info, len, newtext, prevId, ref, section, source;
        source = this.WM.Editor.readSource();
        info = this.WM.Parser.findSectionHeadings(source);
        if (this.WM.Editor.isSection()) {
          increaseLevel = info.minLevel - 1;
        } else {
          if (info.maxTocLevel < 6) {
            increaseLevel = 1;
          } else {
            increaseLevel = 0;
            this.WM.Log.logWarning("There are 6 levels of headings, it has been necessary to start creating them from level 1 although usually it is suggested to start from level 2");
          }
        }
        newtext = "";
        prevId = 0;
        ref = info.sections;
        for (i = 0, len = ref.length; i < len; i++) {
          section = ref[i];
          newtext += source.substring(prevId, section.index);
          newtext += new Array(section.tocLevel + increaseLevel + 1).join("=");
          newtext += section.rawheading;
          newtext += new Array(section.tocLevel + increaseLevel + 1).join("=");
          prevId = section.index + section.length0;
        }
        newtext += source.substr(prevId);
        if (newtext !== source) {
          this.WM.Editor.writeSource(newtext);
          this.WM.Log.logInfo("Fixed section headings");
        }
        if (callNext) {
          return callNext();
        }
      }
    }]);

    return ArchWikiFixHeadings;
  }(Plugin);

  ;

  ArchWikiFixHeadings.conf_default = {
    enabled: true,
    editor_menu: ["Text plugins", "Fix headings"]
  };

  return ArchWikiFixHeadings;
}.call(undefined);

},{"./_Plugin":434}],417:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Plugin;

var _require = require('./_Plugin');

Plugin = _require.Plugin;


module.exports.ArchWikiFixLinks = function () {
  var ArchWikiFixLinks = function (_Plugin) {
    _inherits(ArchWikiFixLinks, _Plugin);

    function ArchWikiFixLinks() {
      _classCallCheck(this, ArchWikiFixLinks);

      return _possibleConstructorReturn(this, (ArchWikiFixLinks.__proto__ || Object.getPrototypeOf(ArchWikiFixLinks)).apply(this, arguments));
    }

    _createClass(ArchWikiFixLinks, [{
      key: 'doReplace',
      value: function doReplace(txt) {
        var L, match, newText, prevId, re;

        re = /http:\/\/([a-z]+\.)?archlinux\.org(?!\.[a-z])/ig;
        txt = txt.replace(re, 'https://$1archlinux.org');

        re = /\[https?:\/\/wiki\.archlinux\.org\/index\.php\/Category:([^\]]+?) (.+?)\]/ig;
        txt = txt.replace(re, '[[:Category:$1|$2]]');
        re = /\[https?:\/\/wiki\.archlinux\.org\/index\.php\/Category:(.+?)\]/ig;
        txt = txt.replace(re, '[[:Category:$1]]');
        re = /https?:\/\/wiki\.archlinux\.org\/index\.php\/Category:([^\s]+)/ig;
        txt = txt.replace(re, '[[:Category:$1]]');
        re = /\[https?:\/\/wiki\.archlinux\.org\/index\.php\/([^\]]+?) (.+?)\]/ig;
        txt = txt.replace(re, '[[$1|$2]]');
        re = /\[https?:\/\/wiki\.archlinux\.org\/index\.php\/(.+?)\]/ig;
        txt = txt.replace(re, '[[$1]]');
        re = /https?:\/\/wiki\.archlinux\.org\/index\.php\/([^\s]+)/ig;
        txt = txt.replace(re, '[[$1]]');
        re = /https?:\/\/wiki\.archlinux\.org(?!\.)/ig;
        if (re.test(txt)) {
          this.WM.Log.logWarning("It hasn't been possible to convert some " + "links to wiki.archlinux.org");
        }

        re = /\[https?:\/\/en\.wikipedia\.org\/wiki\/([^\]]+?) (.+?)\]/ig;
        txt = txt.replace(re, '[[wikipedia:$1|$2]]');
        re = /\[https?:\/\/en\.wikipedia\.org\/wiki\/(.+?)\]/ig;
        txt = txt.replace(re, '[[wikipedia:$1]]');
        re = /https?:\/\/en\.wikipedia\.org\/wiki\/([^\s]+)/ig;
        txt = txt.replace(re, '[[wikipedia:$1]]');
        re = /https?:\/\/([a-z]+?)\.wikipedia\.org(?!\.)/ig;
        if (re.test(txt)) {
          this.WM.Log.logWarning("It hasn't been possible to convert some " + "links to Wikipedia");
        }

        re = /\[https?:\/\/(?:www\.)?archlinux\.org\/packages\/(?:community|community-testing|core|extra|multilib|multilib-testing|testing)\/(?:any|i686|x86_64)\/([^\s]+?)\/? +(.+?)?\]/ig;
        newText = '';
        prevId = 0;
        while (true) {
          match = re.exec(txt);
          if (match) {
            if (match[1] === match[2]) {
              L = match[0].length;
              newText += txt.substring(prevId, re.lastIndex - L) + '{{Pkg|' + match[1] + '}}';
              prevId = re.lastIndex;
            }
          } else {
            break;
          }
        }
        newText += txt.substr(prevId);
        txt = newText;
        re = /\[https?:\/\/(?:www\.)?archlinux\.org\/packages\/(?:community|community-testing|core|extra|multilib|multilib-testing|testing)\/(?:any|i686|x86_64)\/([^\s]+?)\/?\]/ig;
        txt = txt.replace(re, '{{Pkg|$1}}');
        re = /([^\[])https?:\/\/(?:www\.)?archlinux\.org\/packages\/(?:community|community-testing|core|extra|multilib|multilib-testing|testing)\/(?:any|i686|x86_64)\/([^\s\/]+)\/?/ig;
        txt = txt.replace(re, '$1{{Pkg|$2}}');
        re = /https?:\/\/(?:www\.)?archlinux\.org\/packages(?!\/?\s)/ig;
        if (re.test(txt)) {
          this.WM.Log.logWarning("It hasn't been possible to convert some " + "links to archlinux.org/packages");
        }

        re = /\[https?:\/\/aur\.archlinux\.org\/packages\/([^\s]+?)\/? +(.+?)?\]/ig;
        newText = '';
        prevId = 0;
        while (true) {
          match = re.exec(txt);
          if (match) {
            if (match[1] === match[2]) {
              L = match[0].length;
              newText += txt.substring(prevId, re.lastIndex - L) + '{{AUR|' + match[1] + '}}';
              prevId = re.lastIndex;
            }
          } else {
            break;
          }
        }
        newText += txt.substr(prevId);
        txt = newText;
        re = /\[https?:\/\/aur\.archlinux\.org\/packages\/([^\s]+?)\/?\]/ig;
        txt = txt.replace(re, '{{AUR|$1}}');
        re = /([^\[])https?:\/\/aur\.archlinux\.org\/packages\/([^\s\/]+)\/?/ig;
        txt = txt.replace(re, '$1{{AUR|$2}}');
        re = /https?:\/\/aur\.archlinux\.org(?!(?:\.|(?:\/?packages)?\/?\s))/ig;
        if (re.test(txt)) {
          this.WM.Log.logWarning("It hasn't been possible to convert some links to aur.archlinux.org (try the \"Fix old AUR links\" function, if installed)");
        }

        re = /\[https?:\/\/bugs\.archlinux\.org\/task\/([^\s]+?)\/? +(.+?)?\]/ig;
        newText = '';
        prevId = 0;
        while (true) {
          match = re.exec(txt);
          if (match) {
            if (match[1] === match[2]) {
              L = match[0].length;
              newText += txt.substring(prevId, re.lastIndex - L) + '{{Bug|' + match[1] + '}}';
              prevId = re.lastIndex;
            }
          } else {
            break;
          }
        }
        newText += txt.substr(prevId);
        txt = newText;
        re = /\[https?:\/\/bugs\.archlinux\.org\/task\/([^\s]+?)\/?\]/ig;
        txt = txt.replace(re, '{{Bug|$1}}');
        re = /([^\[])https?:\/\/bugs\.archlinux\.org\/task\/([^\s\/]+)\/?/ig;
        txt = txt.replace(re, '$1{{Bug|$2}}');
        re = /https?:\/\/bugs\.archlinux\.org\/task/ig;
        if (re.test(txt)) {
          this.WM.Log.logWarning("It hasn't been possible to convert some " + "links to bugs.archlinux.org/task");
        }
        return txt;
      }
    }, {
      key: 'main_editor',
      value: function main_editor(callNext) {
        var newtext, source;
        source = this.WM.Editor.readSource();
        newtext = this.doReplace(source);
        if (newtext !== source) {
          this.WM.Editor.writeSource(newtext);
          this.WM.Log.logInfo("Fixed links");
        } else {
          this.WM.Log.logInfo("No fixable links found");
        }
        if (callNext) {
          return callNext();
        }
      }
    }]);

    return ArchWikiFixLinks;
  }(Plugin);

  ;

  ArchWikiFixLinks.conf_default = {
    enabled: true,
    editor_menu: ["Text plugins", "Fix external links"]
  };

  return ArchWikiFixLinks;
}.call(undefined);

},{"./_Plugin":434}],418:[function(require,module,exports){
'use strict';

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var CSS, Plugin;

var _require = require('./_Plugin');

Plugin = _require.Plugin;


CSS = require('@kynikos/misc/dist/CSS');

module.exports.ArchWikiNPFilter = function () {
  var ArchWikiNPFilter = function (_Plugin) {
    _inherits(ArchWikiNPFilter, _Plugin);

    function ArchWikiNPFilter() {
      _classCallCheck(this, ArchWikiNPFilter);

      return _possibleConstructorReturn(this, (ArchWikiNPFilter.__proto__ || Object.getPrototypeOf(ArchWikiNPFilter)).apply(this, arguments));
    }

    _createClass(ArchWikiNPFilter, [{
      key: 'main_newpages',
      value: function main_newpages() {
        var contentDiv, i, language, len, li, liList, link, pureTitle, ul;
        CSS.addStyleElement("#mw-content-text > h5 {background-color:#afa;}");
        contentDiv = $('#mw-content-text');
        ul = contentDiv.find('ul').first();
        liList = ul.children('li');
        for (i = 0, len = liList.length; i < len; i++) {
          li = liList[i];
          link = $(li).find('a.mw-newpages-pagename').first();

          var _WM$ArchWiki$detectLa = this.WM.ArchWiki.detectLanguage(link[0].title);

          var _WM$ArchWiki$detectLa2 = _slicedToArray(_WM$ArchWiki$detectLa, 2);

          pureTitle = _WM$ArchWiki$detectLa2[0];
          language = _WM$ArchWiki$detectLa2[1];

          if (language !== this.conf.default_language) {
            this.moveArticle(contentDiv, li, language);
          }
        }
        return this.WM.Log.logInfo("Grouped articles by language");
      }
    }, {
      key: 'moveArticle',
      value: function moveArticle(contentDiv, li, language) {
        var HLang, i, langFound, langHs, len, ul;
        langHs = contentDiv.children('h5');
        langFound = false;
        for (i = 0, len = langHs.length; i < len; i++) {
          HLang = langHs[i];
          if (HLang.innerHTML === language) {
            ul = $(HLang).next().append(li);
            langFound = true;
            break;
          }
        }
        if (!langFound) {
          return contentDiv.append($('<h5>').text(language), $('<ul>').append(li));
        }
      }
    }]);

    return ArchWikiNPFilter;
  }(Plugin);

  ;

  ArchWikiNPFilter.conf_default = {
    enabled: true,
    filter_label: "Default filter",
    default_language: "English"
  };

  return ArchWikiNPFilter;
}.call(undefined);

},{"./_Plugin":434,"@kynikos/misc/dist/CSS":2}],419:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Plugin;

var _require = require('./_Plugin');

Plugin = _require.Plugin;


module.exports.ArchWikiNewTemplates = function () {
  var ArchWikiNewTemplates = function (_Plugin) {
    _inherits(ArchWikiNewTemplates, _Plugin);

    function ArchWikiNewTemplates() {
      _classCallCheck(this, ArchWikiNewTemplates);

      return _possibleConstructorReturn(this, (ArchWikiNewTemplates.__proto__ || Object.getPrototypeOf(ArchWikiNewTemplates)).apply(this, arguments));
    }

    _createClass(ArchWikiNewTemplates, [{
      key: 'main_editor',
      value: function main_editor(callNext) {
        var i, len, newtext, re10, re11, re12, re13, re14, re15, re16, re8, re9, source, test, tests;
        source = this.WM.Editor.readSource();
        newtext = source;
        re8 = /<pre>(((?!<(pre|nowiki)>)[^\=\|])*?((?!<(pre|nowiki)>)[^\=\|\}]))<\/pre>/ig;
        re9 = /<pre>(((?!<(pre|nowiki)>)[^\|])*?((?!<(pre|nowiki)>)[^\|\}]))<\/pre>/ig;
        re10 = /<pre>(\n*((?!<(pre|nowiki)>).\n*)+?)<\/pre>/ig;
        re11 = /<code>(((?!<(code|nowiki)>)[^\=\|\n])*?((?!<(code|nowiki)>)[^\=\|\}\n]))<\/code>/ig;
        re12 = /<code>(((?!<(code|nowiki)>)[^\|\n])*?((?!<(code|nowiki)>)[^\|\}\n]))<\/code>/ig;
        re13 = /<code>(((?!<(code|nowiki)>)[^\n])+?)<\/code>/ig;
        re14 = /<tt>(((?!<(tt|nowiki)>)[^\=\|\n])*?((?!<(tt|nowiki)>)[^\=\|\}\n]))<\/tt>/ig;
        re15 = /<tt>(((?!<(tt|nowiki)>)[^\|\n])*?((?!<(tt|nowiki)>)[^\|\}\n]))<\/tt>/ig;
        re16 = /<tt>(((?!<(tt|nowiki)>)[^\n])+?)<\/tt>/ig;
        newtext = newtext.replace(re8, '{{bc|$1}}');
        newtext = newtext.replace(re9, '{{bc|1=$1}}');
        newtext = newtext.replace(re10, '{{bc|<nowiki>$1</nowiki>}}');
        newtext = newtext.replace(re11, '{{ic|$1}}');
        newtext = newtext.replace(re12, '{{ic|1=$1}}');
        newtext = newtext.replace(re13, '{{ic|<nowiki>$1</nowiki>}}');
        newtext = newtext.replace(re14, '{{ic|$1}}');
        newtext = newtext.replace(re15, '{{ic|1=$1}}');
        newtext = newtext.replace(re16, '{{ic|<nowiki>$1</nowiki>}}');
        if (newtext !== source) {
          this.WM.Editor.writeSource(newtext);
          this.WM.Log.logInfo("Turned HTML tags into proper templates");
        }
        tests = [['&lt;pre>', newtext.match(/<pre/ig)], ['&lt;code>', newtext.match(/<code/ig)], ['&lt;tt>', newtext.match(/<tt/ig)]];
        for (i = 0, len = tests.length; i < len; i++) {
          test = tests[i];
          if (test[1]) {
            this.WM.Log.logWarning(test[1].length + ' ' + test[0] + ' instances require manual intervention');
          }
        }
        if (callNext) {
          return callNext();
        }
      }
    }]);

    return ArchWikiNewTemplates;
  }(Plugin);

  ;

  ArchWikiNewTemplates.conf_default = {
    enabled: true,
    editor_menu: ["Text plugins", "Use code templates"]
  };

  return ArchWikiNewTemplates;
}.call(undefined);

},{"./_Plugin":434}],420:[function(require,module,exports){
'use strict';

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var CSS, Plugin;

var _require = require('./_Plugin');

Plugin = _require.Plugin;


CSS = require('@kynikos/misc/dist/CSS');

module.exports.ArchWikiRCFilter = function () {
  var ArchWikiRCFilter = function (_Plugin) {
    _inherits(ArchWikiRCFilter, _Plugin);

    function ArchWikiRCFilter() {
      _classCallCheck(this, ArchWikiRCFilter);

      return _possibleConstructorReturn(this, (ArchWikiRCFilter.__proto__ || Object.getPrototypeOf(ArchWikiRCFilter)).apply(this, arguments));
    }

    _createClass(ArchWikiRCFilter, [{
      key: 'main_recentchanges',
      value: function main_recentchanges() {
        var articleTable, groupDiv, h4, h4s, j, k, language, len, len1, link, pureTitle, ref;
        h4s = $('#mw-content-text .mw-changeslist > h4');
        if (h4s.eq(0).next()[0].localName.toLowerCase() !== 'div') {
          return this.WM.Log.logError("This filter is designed to work on top of MediaWiki's filter, which you can enable in your user preferences.");
        } else {
          CSS.addStyleElement("#mw-content-text > div > h4 {background-color:#aaf;} #mw-content-text > div > div > h5 {background-color:#afa;}");
          for (j = 0, len = h4s.length; j < len; j++) {
            h4 = h4s[j];
            groupDiv = $(h4).next();
            ref = groupDiv.children('table');
            for (k = 0, len1 = ref.length; k < len1; k++) {
              articleTable = ref[k];
              link = $(articleTable).find('a.mw-changeslist-title').first();
              if (link[0]) {
                var _WM$ArchWiki$detectLa = this.WM.ArchWiki.detectLanguage(link[0].title);

                var _WM$ArchWiki$detectLa2 = _slicedToArray(_WM$ArchWiki$detectLa, 2);

                pureTitle = _WM$ArchWiki$detectLa2[0];
                language = _WM$ArchWiki$detectLa2[1];

                if (language !== this.conf.default_language) {
                  this.moveArticle(groupDiv, articleTable, language);
                }
              }
            }
          }
          return this.WM.Log.logInfo("Grouped articles by language");
        }
      }
    }, {
      key: 'moveArticle',
      value: function moveArticle(groupDiv, articleTable, language) {
        var HLang, i, j, langFound, langHs, len;
        langHs = groupDiv.children('h5');
        langFound = false;
        for (i = j = 0, len = langHs.length; j < len; i = ++j) {
          HLang = langHs[i];
          if (HLang.innerHTML === language) {
            if (i + 1 < langHs.length) {
              langHs.eq(i + 1).before(articleTable);
            } else {
              groupDiv.append(articleTable);
            }
            langFound = true;
            break;
          }
        }
        if (!langFound) {
          return groupDiv.append($('<h5>').text(language), articleTable);
        }
      }
    }]);

    return ArchWikiRCFilter;
  }(Plugin);

  ;

  ArchWikiRCFilter.conf_default = {
    enabled: true,
    filter_label: "Default filter",
    default_language: "English"
  };

  return ArchWikiRCFilter;
}.call(undefined);

},{"./_Plugin":434,"@kynikos/misc/dist/CSS":2}],421:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var CSS,
    HTTP,
    Plugin,
    ref,
    boundMethodCheck = function boundMethodCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new Error('Bound instance method accessed before binding');
  }
};

var _require = require('./_Plugin');

Plugin = _require.Plugin;


CSS = require('@kynikos/misc/dist/CSS');

HTTP = require('@kynikos/misc/dist/HTTP');

ref = module.exports.ArchWikiSaveTalk = function () {
  var ArchWikiSaveTalk = function (_Plugin) {
    _inherits(ArchWikiSaveTalk, _Plugin);

    function ArchWikiSaveTalk() {
      _classCallCheck(this, ArchWikiSaveTalk);

      var _this = _possibleConstructorReturn(this, (ArchWikiSaveTalk.__proto__ || Object.getPrototypeOf(ArchWikiSaveTalk)).apply(this, arguments));

      _this.mainGetEndTimestamp = _this.mainGetEndTimestamp.bind(_this);
      _this.mainWrite = _this.mainWrite.bind(_this);
      _this.mainEnd = _this.mainEnd.bind(_this);
      return _this;
    }

    _createClass(ArchWikiSaveTalk, [{
      key: 'makeUI',
      value: function makeUI() {
        var article, link;
        CSS.addStyleElement("#WikiMonkey-ArchWikiSaveTalk {margin-left:0.33em;}");
        article = this.conf.page;
        link = document.createElement('a');
        link.id = "WikiMonkey-ArchWikiSaveTalk";
        link.href = "/index.php/" + article;
        link.innerHTML = article;
        return link;
      }
    }, {
      key: 'main_diff',
      value: function main_diff(callNext) {
        var article, summary;
        article = this.conf.page;
        summary = this.conf.edit_summary;
        this.WM.Log.logInfo('Appending diff to ' + this.WM.Log.linkToWikiPage(article, article) + " ...");
        return this.WM.Diff.getEndTimestamp(this.mainGetEndTimestamp, [article, summary, callNext]);
      }
    }, {
      key: 'mainGetEndTimestamp',
      value: function mainGetEndTimestamp(enddate, args) {
        var article, callNext, summary;
        boundMethodCheck(this, ref);
        article = args[0];
        summary = args[1];
        callNext = args[2];
        return this.WM.MW.callQueryEdit(article, this.mainWrite, [summary, enddate, callNext]);
      }
    }, {
      key: 'mainWrite',
      value: function mainWrite(article, source, timestamp, edittoken, args) {
        var callNext, enddate, newtext, pEnddate, summary, title;
        boundMethodCheck(this, ref);
        summary = args[0];
        enddate = args[1];
        callNext = args[2];
        title = HTTP.getURIParameter(null, 'title');
        pEnddate = enddate.substr(0, 10) + "&nbsp;" + enddate.substr(11, 8);
        newtext = this.WM.Tables.appendRow(source, "<!-- REPLY TABLE -->", ["[" + location.href + " " + title + "]", pEnddate]);
        return this.WM.MW.callAPIPost({
          action: "edit",
          bot: "1",
          title: article,
          summary: summary,
          text: newtext,
          basetimestamp: timestamp,
          token: edittoken
        }, this.mainEnd, [article, callNext], null);
      }
    }, {
      key: 'mainEnd',
      value: function mainEnd(res, args) {
        var article, callNext;
        boundMethodCheck(this, ref);
        article = args[0];
        callNext = args[1];
        if (res.edit && res.edit.result === 'Success') {
          this.WM.Log.logInfo('Diff correctly appended to ' + this.WM.Log.linkToWikiPage(article, article));
          if (callNext) {
            return callNext();
          }
        } else {
          return this.WM.Log.logError('The diff has not been appended!\n' + res['error']['info'] + " (" + res['error']['code'] + ")");
        }
      }
    }]);

    return ArchWikiSaveTalk;
  }(Plugin);

  ;

  ArchWikiSaveTalk.conf_default = {
    enabled: false,
    diff_menu: ["Save discussion"],
    page: null,
    edit_summary: "add discussion"
  };

  return ArchWikiSaveTalk;
}.call(undefined);

},{"./_Plugin":434,"@kynikos/misc/dist/CSS":2,"@kynikos/misc/dist/HTTP":4}],422:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Plugin,
    ref,
    boundMethodCheck = function boundMethodCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new Error('Bound instance method accessed before binding');
  }
};

var _require = require('./_Plugin');

Plugin = _require.Plugin;


ref = module.exports.ArchWikiSortContacts = function () {
  var endMark, regExp, startMark;

  var ArchWikiSortContacts = function (_Plugin) {
    _inherits(ArchWikiSortContacts, _Plugin);

    function ArchWikiSortContacts() {
      _classCallCheck(this, ArchWikiSortContacts);

      var _this = _possibleConstructorReturn(this, (ArchWikiSortContacts.__proto__ || Object.getPrototypeOf(ArchWikiSortContacts)).apply(this, arguments));

      _this.parseList = _this.parseList.bind(_this);
      _this.iterateUsers = _this.iterateUsers.bind(_this);
      _this.storeUserContribs = _this.storeUserContribs.bind(_this);
      _this.updateList = _this.updateList.bind(_this);
      _this.writePage = _this.writePage.bind(_this);
      return _this;
    }

    _createClass(ArchWikiSortContacts, [{
      key: 'main_special',
      value: function main_special(callNext) {
        return this.iteratePages(-1, callNext);
      }
    }, {
      key: 'iteratePages',
      value: function iteratePages(pageid, callNext) {
        var inactiveIntro, inactiveLimit, page, pconf, recentDays, summary;
        pageid++;
        pconf = this.conf.pages[pageid];
        if (pconf) {
          page = pconf.title;
          recentDays = pconf.recent_days;
          inactiveLimit = pconf.inactive_limit;
          inactiveIntro = pconf.inactive_message;
          summary = this.conf.edit_summary;
          this.WM.Log.logInfo("Sorting " + this.WM.Log.linkToWikiPage(page, page) + " ...");
          return this.WM.MW.callQueryEdit(page, this.parseList, [recentDays, inactiveLimit, inactiveIntro, summary, callNext, pageid]);
        } else if (callNext) {
          return callNext();
        }
      }
    }, {
      key: 'parseList',
      value: function parseList(title, source, timestamp, edittoken, args) {
        var callNext, date, endList, inactiveIntro, inactiveLimit, pageid, recentDays, startList, summary, ucend, ucstart, users, usersArray;
        boundMethodCheck(this, ref);
        recentDays = args[0];
        inactiveLimit = args[1];
        inactiveIntro = args[2];
        summary = args[3];
        callNext = args[4];
        pageid = args[5];
        startList = source.indexOf(startMark);
        endList = source.indexOf(endMark);
        if (startList > -1 && endList > -1) {
          startList += startMark.length;
          date = new Date();
          ucstart = Math.floor(Date.now() / 1000);
          ucend = ucstart - 86400 * recentDays;
          users = {
            active: [],
            inactive: []
          };
          usersArray = source.substring(startList, endList).split("\n");
          return this.iterateUsers(usersArray, -1, ucstart, ucend, users, title, source, startList, endList, timestamp, edittoken, inactiveLimit, inactiveIntro, summary, callNext, pageid);
        } else {
          return this.WM.Log.logError("Cannot find the needed marks");
        }
      }
    }, {
      key: 'iterateUsers',
      value: function iterateUsers(usersArray, index, ucstart, ucend, users, title, source, startList, endList, timestamp, edittoken, inactiveLimit, inactiveIntro, summary, callNext, pageid) {
        var match, ucuser, userString;
        boundMethodCheck(this, ref);
        index++;
        if (index < usersArray.length) {
          userString = usersArray[index];
          match = regExp.exec(userString);
          if (match) {
            ucuser = match[1].charAt(0).toUpperCase() + match[1].substr(1);
            if (match[2]) {
              ucuser += "|" + match[2].charAt(0).toUpperCase() + match[2].substr(1);
            }
            this.WM.Log.logInfo("Querying " + ucuser + " ...");
            return this.WM.MW.getUserContribs(ucuser, ucstart, ucend, this.storeUserContribs, [usersArray, index, ucstart, ucend, users, title, source, startList, endList, timestamp, edittoken, inactiveLimit, inactiveIntro, summary, callNext, pageid]);
          } else if (userString !== "" && userString.indexOf(inactiveIntro) !== 0) {
            return this.WM.Log.logError("An entry in the list may not be correctly " + "formatted");
          } else {
            return this.iterateUsers(usersArray, index, ucstart, ucend, users, title, source, startList, endList, timestamp, edittoken, inactiveLimit, inactiveIntro, summary, callNext, pageid);
          }
        } else {
          return this.updateList(users, title, source, startList, endList, timestamp, edittoken, inactiveIntro, summary, callNext, pageid);
        }
      }
    }, {
      key: 'storeUserContribs',
      value: function storeUserContribs(results, args) {
        var callNext, edits, edittoken, endList, inactiveIntro, inactiveLimit, index, pageid, source, startList, summary, timestamp, title, ucend, ucstart, users, usersArray;
        boundMethodCheck(this, ref);
        usersArray = args[0];
        index = args[1];
        ucstart = args[2];
        ucend = args[3];
        users = args[4];
        title = args[5];
        source = args[6];
        startList = args[7];
        endList = args[8];
        timestamp = args[9];
        edittoken = args[10];
        inactiveLimit = args[11];
        inactiveIntro = args[12];
        summary = args[13];
        callNext = args[14];
        pageid = args[15];
        edits = results.length;
        if (edits < inactiveLimit) {
          users.inactive.push({
            "text": usersArray[index],
            "edits": edits
          });
        } else {
          users.active.push({
            "text": usersArray[index],
            "edits": edits
          });
        }
        return this.iterateUsers(usersArray, index, ucstart, ucend, users, title, source, startList, endList, timestamp, edittoken, inactiveLimit, inactiveIntro, summary, callNext, pageid);
      }
    }, {
      key: 'updateList',
      value: function updateList(users, title, source, startList, endList, timestamp, edittoken, inactiveIntro, summary, callNext, pageid) {
        var i, j, len, len1, newList, newText, ref1, ref2, sorter, user;
        boundMethodCheck(this, ref);
        sorter = function sorter(a, b) {
          if (a.edits < b.edits) {
            return 1;
          } else if (a.edits > b.edits) {
            return -1;
          } else {
            return 0;
          }
        };
        users.active.sort(sorter);
        users.inactive.sort(sorter);
        newList = "\n";
        ref1 = users.active;
        for (i = 0, len = ref1.length; i < len; i++) {
          user = ref1[i];
          newList += user.text + "\n";
        }
        if (users.inactive.length > 0) {
          newList += "\n" + inactiveIntro + "\n\n";
          ref2 = users.inactive;
          for (j = 0, len1 = ref2.length; j < len1; j++) {
            user = ref2[j];
            newList += user.text + "\n";
          }
        }
        newText = source.substring(0, startList) + newList + source.substring(endList);
        if (newText !== source) {
          return this.WM.MW.callAPIPost({
            action: "edit",
            bot: "1",
            minor: "1",
            title: title,
            summary: summary,
            text: newText,
            b1asetimestamp: timestamp,
            token: edittoken
          }, this.writePage, [title, callNext, pageid], null);
        } else {
          this.WM.Log.logInfo(this.WM.Log.linkToWikiPage(title, title) + " was already up to date");
          return this.iteratePages(pageid, callNext);
        }
      }
    }, {
      key: 'writePage',
      value: function writePage(res, args) {
        var callNext, pageid, title;
        boundMethodCheck(this, ref);
        title = args[0];
        callNext = args[1];
        pageid = args[2];
        if (res.edit && res.edit.result === 'Success') {
          this.WM.Log.logInfo(this.WM.Log.linkToWikiPage(title, title) + " was correctly updated");
          return this.iteratePages(pageid, callNext);
        } else {
          return this.WM.Log.logError(res['error']['info'] + " (" + res['error']['code'] + ")");
        }
      }
    }]);

    return ArchWikiSortContacts;
  }(Plugin);

  ;

  startMark = "START AUTO LIST - DO NOT REMOVE OR MODIFY THIS MARK-->";

  endMark = "<!--END AUTO LIST - DO NOT REMOVE OR MODIFY THIS MARK";

  regExp = new RegExp("^\\*.*?\\[\\[User:(.+?)\\|.+?" + "(?: \\<!-- associated bot: (.+?) -->.*)?$", "");

  ArchWikiSortContacts.conf_default = {
    enabled: false,
    special_menu: ["Sort staff contacts"],
    edit_summary: "automatically sort list according to recent activity",
    pages: [{
      title: "ArchWiki:Administrators",
      recent_days: 30,
      inactive_limit: 30,
      inactive_message: "The following Administrators are currently inactive (less than 30 edits in the last 30 days):"
    }, {
      title: "ArchWiki:Maintainers",
      recent_days: 30,
      inactive_limit: 10,
      inactive_message: "The following Maintainers are currently inactive (less than 10 edits in the last 30 days):"
    }]
  };

  return ArchWikiSortContacts;
}.call(undefined);

},{"./_Plugin":434}],423:[function(require,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Plugin;

var _require = require('./_Plugin');

Plugin = _require.Plugin;


module.exports.ArchWikiWantedCategories = function () {
  var ArchWikiWantedCategories = function (_Plugin) {
    _inherits(ArchWikiWantedCategories, _Plugin);

    function ArchWikiWantedCategories() {
      _classCallCheck(this, ArchWikiWantedCategories);

      return _possibleConstructorReturn(this, (ArchWikiWantedCategories.__proto__ || Object.getPrototypeOf(ArchWikiWantedCategories)).apply(this, arguments));
    }

    _createClass(ArchWikiWantedCategories, [{
      key: "main_bot",
      value: function main_bot(title, callBot, chainArgs) {
        title = title.replace(" (page does not exist)", "");
        return this.WM.MW.callQuery({
          prop: "info",
          intoken: "edit",
          titles: title
        }, this.mainAutoWrite, [title, callBot], null);
      }
    }, {
      key: "mainAutoWrite",
      value: function mainAutoWrite(page, args) {
        var callBot, edittoken, language, summary, text, title;
        title = args[0];
        callBot = args[1];
        edittoken = page.edittoken;
        language = this.WM.ArchWiki.detectLanguage(title)[1];
        if (language !== this.WM.ArchWiki.getLocalLanguage()) {
          text = "[[Category:" + language + "]]";
          summary = "wanted category";
          return this.WM.MW.callAPIPost({
            action: "edit",
            bot: "1",
            title: title,
            summary: summary,
            text: text,
            createonly: "1",
            token: edittoken
          }, this.mainAutoEnd, callBot, null);
        } else {
          return callBot(0, null);
        }
      }
    }, {
      key: "mainAutoEnd",
      value: function mainAutoEnd(res, callBot) {
        if (res.edit && res.edit.result === 'Success') {
          return callBot(1, null);
        } else if (res.error) {
          this.WM.Log.logError(res.error.info + " (" + res.error.code + ")");
          return callBot(res.error.code, null);
        } else {
          return callBot(false, null);
        }
      }
    }]);

    return ArchWikiWantedCategories;
  }(Plugin);

  ;

  ArchWikiWantedCategories.conf_default = {
    enabled: false,
    bot_label: "Create wanted categories"
  };

  return ArchWikiWantedCategories;
}.call(undefined);

},{"./_Plugin":434}],424:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Plugin;

var _require = require('./_Plugin');

Plugin = _require.Plugin;


module.exports.DeletePages = function () {
  var DeletePages = function (_Plugin) {
    _inherits(DeletePages, _Plugin);

    function DeletePages() {
      _classCallCheck(this, DeletePages);

      return _possibleConstructorReturn(this, (DeletePages.__proto__ || Object.getPrototypeOf(DeletePages)).apply(this, arguments));
    }

    _createClass(DeletePages, [{
      key: 'main_bot',
      value: function main_bot(title, callBot, chainArgs) {
        var summary;
        summary = this.conf.edit_summary;
        return this.WM.MW.callQuery({
          prop: 'info',
          intoken: 'delete',
          titles: title
        }, this.mainAutoWrite, [title, summary, callBot], null);
      }
    }, {
      key: 'mainAutoWrite',
      value: function mainAutoWrite(page, args) {
        var callBot, deletetoken, summary, title;
        title = args[0];
        summary = args[1];
        callBot = args[2];
        deletetoken = page.deletetoken;
        return this.WM.MW.callAPIPost({
          action: 'delete',
          bot: '1',
          title: title,
          token: deletetoken,
          reason: summary
        }, this.mainAutoEnd, [title, callBot], null);
      }
    }, {
      key: 'mainAutoEnd',
      value: function mainAutoEnd(res, args) {
        var callBot, title;
        title = args[0];
        callBot = args[1];
        if (!res.delete) {
          if (res.error) {
            this.WM.Log.logError(this.WM.Log.linkToWikiPage(title, title) + ' has not been deleted!\n' + res.error.info + ' (' + res.error.code + ')');
            return callBot(res.error.code, null);
          } else {
            return callBot(false, null);
          }
        } else {
          return callBot(1, null);
        }
      }
    }]);

    return DeletePages;
  }(Plugin);

  ;

  DeletePages.conf_default = {
    enabled: false,
    bot_label: "Delete pages",
    edit_summary: "delete page"
  };

  return DeletePages;
}.call(undefined);

},{"./_Plugin":434}],425:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Plugin;

var _require = require('./_Plugin');

Plugin = _require.Plugin;


module.exports.ExpandContractions = function () {
  var ExpandContractions = function (_Plugin) {
    _inherits(ExpandContractions, _Plugin);

    function ExpandContractions() {
      _classCallCheck(this, ExpandContractions);

      return _possibleConstructorReturn(this, (ExpandContractions.__proto__ || Object.getPrototypeOf(ExpandContractions)).apply(this, arguments));
    }

    _createClass(ExpandContractions, [{
      key: 'replace',
      value: function replace(source, regExp, newString, checkString, checkStrings) {
        var newtext;
        newtext = source.replace(regExp, newString);
        if (checkStrings.length > 1 && newtext !== source) {
          this.WM.Log.logWarning('Replaced some "' + checkString + '" with "' + checkStrings[0] + '": check that it didn\'t mean "' + checkStrings.slice(1).join('\" or \"') + '" instead');
        }
        return newtext;
      }
    }, {
      key: 'main_editor',
      value: function main_editor(callNext) {
        var newtext, source, ss;
        source = this.WM.Editor.readSource();
        newtext = source;

        newtext = this.replace(newtext, /([a-z])'re/ig, '$1 are', "'re", ["are"]);
        newtext = this.replace(newtext, /([a-z])'ve/ig, '$1 have', "'ve", ["have"]);
        newtext = this.replace(newtext, /([a-z])'ll/ig, '$1 will', "'ll", ["will", "shall"]);
        newtext = this.replace(newtext, /([a-z])'d/ig, '$1 would', "'d", ["would", "had"]);
        newtext = this.replace(newtext, /(c)an't/ig, '$1annot', "can't", ["cannot"]);
        newtext = this.replace(newtext, /(w)on't/ig, '$1ill not', "won't", ["will not"]);
        newtext = this.replace(newtext, /([a-z])n't/ig, '$1 not', "n't", ["not"]);
        newtext = this.replace(newtext, /(here|there)'s/ig, '$1 is', "here/there's", ["here/there is", "here/there has"]);
        newtext = this.replace(newtext, /(g)onna/ig, '$1oing to', "gonna", ["going to"]);

        newtext = this.replace(newtext, /([a-z])'s (been)/ig, '$1 has $2', "'s been", ["has been"]);
        newtext = this.replace(newtext, /(let)'s/ig, '$1 us', "let's", ["let us"]);
        newtext = this.replace(newtext, /(it)'(s own)/ig, '$1$2', "it's own", ["its own"]);
        ss = newtext.match(/[a-z]'s/gi);
        if (ss) {
          this.WM.Log.logWarning("Found " + ss.length + " instances of \"'s\": " + "check if they can be replaced with \"is\", \"has\", ...");
        }
        if (newtext !== source) {
          this.WM.Editor.writeSource(newtext);
          this.WM.Log.logInfo("Expanded contractions");
        }
        if (callNext) {
          return callNext();
        }
      }
    }]);

    return ExpandContractions;
  }(Plugin);

  ;

  ExpandContractions.conf_default = {
    enabled: true,
    editor_menu: ["Text plugins", "Expand contractions"]
  };

  return ExpandContractions;
}.call(undefined);

},{"./_Plugin":434}],426:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var CSS,
    Plugin,
    ref,
    boundMethodCheck = function boundMethodCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new Error('Bound instance method accessed before binding');
  }
};

var _require = require('./_Plugin');

Plugin = _require.Plugin;


CSS = require('@kynikos/misc/dist/CSS');

ref = module.exports.FixBacklinkFragments = function () {
  var readTarget;

  var FixBacklinkFragments = function (_Plugin) {
    _inherits(FixBacklinkFragments, _Plugin);

    function FixBacklinkFragments() {
      _classCallCheck(this, FixBacklinkFragments);

      var _this = _possibleConstructorReturn(this, (FixBacklinkFragments.__proto__ || Object.getPrototypeOf(FixBacklinkFragments)).apply(this, arguments));

      _this.makeBotUI = _this.makeBotUI.bind(_this);
      _this.fixLinks = _this.fixLinks.bind(_this);
      _this.fixArchWikiLinks = _this.fixArchWikiLinks.bind(_this);
      _this.fixArchWikiLink = _this.fixArchWikiLink.bind(_this);
      _this.fixFragment = _this.fixFragment.bind(_this);
      _this.mainAutoFindSections = _this.mainAutoFindSections.bind(_this);
      _this.mainAutoRead = _this.mainAutoRead.bind(_this);
      _this.mainAutoWrite = _this.mainAutoWrite.bind(_this);
      _this.mainAutoEnd = _this.mainAutoEnd.bind(_this);
      return _this;
    }

    _createClass(FixBacklinkFragments, [{
      key: 'makeBotUI',
      value: function makeBotUI() {
        var divMain, label, target;
        boundMethodCheck(this, ref);
        CSS.addStyleElement("#WikiMonkey-FixBacklinkFragments " + "input[type='text'] {margin-left:0.33em;}");
        divMain = document.createElement('div');
        divMain.id = "WikiMonkey-FixBacklinkFragments";
        label = document.createElement('span');
        label.innerHTML = 'Target page:';
        divMain.appendChild(label);
        target = document.createElement('input');
        target.setAttribute('type', 'text');
        target.id = "WikiMonkey-FixBacklinkFragments-Target";
        if (this.WM.WhatLinksHere.isWhatLinksHerePage()) {
          target.value = this.WM.WhatLinksHere.getTitle();
        }
        divMain.appendChild(target);
        return divMain;
      }
    }, {
      key: 'fixLinks',
      value: function fixLinks(source, target, sections) {
        var fixedFragment, i, len, link, links, newText, newlink, oldlink, prevId, rawfragment;
        boundMethodCheck(this, ref);

        links = this.WM.Parser.findInternalLinks(source, null, target);
        newText = "";
        prevId = 0;
        for (i = 0, len = links.length; i < len; i++) {
          link = links[i];
          newText += source.substring(prevId, link.index);
          newlink = link.rawLink;
          rawfragment = link.fragment;
          if (rawfragment) {
            fixedFragment = this.fixFragment(rawfragment, sections);
            if (fixedFragment === true) {
              null;
            } else if (fixedFragment) {
              oldlink = newlink;
              newlink = "[[" + target + "#" + fixedFragment + (link.anchor ? "|" + link.anchor : "") + "]]";
              this.WM.Log.logInfo("Fixed broken link fragment: " + oldlink + " -> " + this.WM.Log.linkToWikiPage(link.link, newlink));
            } else {
              this.WM.Log.logWarning("Cannot fix broken link fragment: " + this.WM.Log.linkToWikiPage(link.link, newlink));
            }
          }
          newText += newlink;
          prevId = link.index + link.length;
        }
        newText += source.substr(prevId);

        if (location.hostname === 'wiki.archlinux.org') {
          newText = this.fixArchWikiLinks(newText, target, sections);
        }
        return newText;
      }
    }, {
      key: 'fixArchWikiLinks',
      value: function fixArchWikiLinks(source, target, sections) {
        var i, j, len, len1, link, link2, links, links2, newText1, newText2, prevId;
        boundMethodCheck(this, ref);
        links = this.WM.Parser.findTemplates(source, 'Related');
        newText1 = "";
        prevId = 0;
        for (i = 0, len = links.length; i < len; i++) {
          link = links[i];
          newText1 += source.substring(prevId, link.index);
          newText1 += this.fixArchWikiLink(target, sections, link, 1);
          prevId = link.index + link.length;
        }
        newText1 += source.substr(prevId);
        links2 = this.WM.Parser.findTemplates(newText1, 'Related2');
        newText2 = "";
        prevId = 0;
        for (j = 0, len1 = links2.length; j < len1; j++) {
          link2 = links2[j];
          newText2 += newText1.substring(prevId, link2.index);
          newText2 += this.fixArchWikiLink(target, sections, link2, 2);
          prevId = link2.index + link2.length;
        }
        newText2 += newText1.substr(prevId);
        return newText2;
      }
    }, {
      key: 'fixArchWikiLink',
      value: function fixArchWikiLink(target, sections, template, expectedArgs) {
        var anchor, args, fixedFragment, fragId, link, ltitle, newlink, rawfragment;
        boundMethodCheck(this, ref);
        args = template.arguments;

        if (args.length === expectedArgs) {
          link = args[0].value;
          fragId = link.indexOf('#');
          if (fragId > -1) {
            ltitle = link.substring(0, fragId);

            if (this.WM.Parser.compareArticleTitles(ltitle, target)) {
              rawfragment = link.substr(fragId + 1);
              fixedFragment = this.fixFragment(rawfragment, sections);
              if (fixedFragment === true) {
                null;
              } else if (fixedFragment) {
                anchor = args[1] ? "|" + args[1].value : "";
                newlink = "{{" + template.title + "|" + target + "#" + fixedFragment + anchor + "}}";
                this.WM.Log.logInfo("Fixed broken link fragment: " + template.rawTransclusion + " -> " + this.WM.Log.linkToWikiPage(link, newlink));
                return newlink;
              } else {
                this.WM.Log.logWarning("Cannot fix broken link fragment: " + this.WM.Log.linkToWikiPage(link, template.rawTransclusion));
              }
            }
          }
        } else {
          this.WM.Log.logWarning("Template:" + template.title + " must have " + expectedArgs + " and only " + expectedArgs + (expectedArgs > 1 ? " arguments: " : " argument: ") + template.rawTransclusion);
        }
        return template.rawTransclusion;
      }
    }, {
      key: 'fixFragment',
      value: function fixFragment(rawfragment, sections) {
        var fragment, i, len, section;
        boundMethodCheck(this, ref);
        if (rawfragment) {
          fragment = this.WM.Parser.squashContiguousWhitespace(rawfragment).trim();
          if (sections.indexOf(fragment) < 0) {
            for (i = 0, len = sections.length; i < len; i++) {
              section = sections[i];

              if (section.toLowerCase() === fragment.toLowerCase()) {
                return section;
              }
            }
            return false;
          } else {
            return true;
          }
        } else {
          return true;
        }
      }
    }, {
      key: 'main_bot',
      value: function main_bot(title, callBot, chainArgs) {
        var params, summary, target;
        summary = this.conf.edit_summary;
        target = readTarget();
        this.WM.Log.logHidden("Target page: " + target);
        if (target) {
          if (chainArgs === null) {
            params = {
              'action': 'parse',
              'prop': 'sections',
              'page': target,
              'redirects': 1
            };
            this.WM.Log.logWarning("If some articles in the list are linking to the target article through a redirect, you should process the backlinks of that redirect page separately through its Special:WhatLinksHere page, as this plugin can only fix links that exactly match the title of the target article.\nIn order to save time you are advised to hide the redirects in the page lists that allow to do so.");
            return this.WM.MW.callAPIGet(params, this.mainAutoFindSections, [title, target, summary, callBot], null);
          } else {
            return this.mainAutoRead(target, chainArgs, title, summary, callBot);
          }
        } else {
          this.WM.Log.logError('The target page cannot be empty');
          return callBot(false, null);
        }
      }
    }, {
      key: 'mainAutoFindSections',
      value: function mainAutoFindSections(res, args) {
        var callBot, i, len, ref1, section, sections, summary, target, title;
        boundMethodCheck(this, ref);
        title = args[0];
        target = args[1];
        summary = args[2];
        callBot = args[3];
        sections = [];
        if (res.parse) {
          ref1 = res.parse.sections;
          for (i = 0, len = ref1.length; i < len; i++) {
            section = ref1[i];
            sections.push(this.WM.Parser.squashContiguousWhitespace(section.line).trim());
          }
          return this.mainAutoRead(target, sections, title, summary, callBot);
        } else {
          this.WM.Log.logError("The set target page, " + target + ", seems not to exist");
          if (res.error) {
            return callBot(res.error.code, sections);
          } else {
            return callBot(false, sections);
          }
        }
      }
    }, {
      key: 'mainAutoRead',
      value: function mainAutoRead(target, sections, title, summary, callBot) {
        boundMethodCheck(this, ref);
        return this.WM.MW.callQueryEdit(title, this.mainAutoWrite, [target, summary, callBot, sections]);
      }
    }, {
      key: 'mainAutoWrite',
      value: function mainAutoWrite(title, source, timestamp, edittoken, args) {
        var callBot, newtext, sections, summary, target;
        boundMethodCheck(this, ref);
        target = args[0];
        summary = args[1];
        callBot = args[2];
        sections = args[3];
        newtext = this.fixLinks(source, target, sections);
        if (newtext !== source) {
          return this.WM.MW.callAPIPost({
            action: "edit",
            bot: "1",
            title: title,
            summary: summary,
            text: newtext,
            basetimestamp: timestamp,
            token: edittoken
          }, this.mainAutoEnd, [callBot, sections], null);
        } else {
          return callBot(0, sections);
        }
      }
    }, {
      key: 'mainAutoEnd',
      value: function mainAutoEnd(res, args) {
        var callBot, sections;
        boundMethodCheck(this, ref);
        callBot = args[0];
        sections = args[1];
        if (res.edit && res.edit.result === 'Success') {
          return callBot(1, sections);
        } else if (res.error) {
          this.WM.Log.logError(res.error.info + " (" + res.error.code + ")");
          return callBot(res.error.code, sections);
        } else {
          return callBot(false, sections);
        }
      }
    }]);

    return FixBacklinkFragments;
  }(Plugin);

  ;

  FixBacklinkFragments.conf_default = {
    enabled: true,
    bot_label: "Fix links to specific sections of a target page",
    edit_summary: "fix links to specific sections"
  };

  readTarget = function readTarget() {
    return document.getElementById("WikiMonkey-FixBacklinkFragments-Target").value;
  };

  return FixBacklinkFragments;
}.call(undefined);

},{"./_Plugin":434,"@kynikos/misc/dist/CSS":2}],427:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Plugin,
    Str,
    ref,
    boundMethodCheck = function boundMethodCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new Error('Bound instance method accessed before binding');
  }
};

var _require = require('./_Plugin');

Plugin = _require.Plugin;


Str = require('@kynikos/misc/dist/Str');

ref = module.exports.FixDoubleRedirects = function () {
  var FixDoubleRedirects = function (_Plugin) {
    _inherits(FixDoubleRedirects, _Plugin);

    function FixDoubleRedirects() {
      _classCallCheck(this, FixDoubleRedirects);

      var _this = _possibleConstructorReturn(this, (FixDoubleRedirects.__proto__ || Object.getPrototypeOf(FixDoubleRedirects)).apply(this, arguments));

      _this.reverseResults = _this.reverseResults.bind(_this);
      _this.iterateList = _this.iterateList.bind(_this);
      _this.readMiddleRedirect = _this.readMiddleRedirect.bind(_this);
      _this.processDoubleRedirect = _this.processDoubleRedirect.bind(_this);
      _this.processDoubleRedirectEnd = _this.processDoubleRedirectEnd.bind(_this);
      return _this;
    }

    _createClass(FixDoubleRedirects, [{
      key: 'main_special',
      value: function main_special(callNext) {
        this.WM.Log.logInfo("Fixing double redirects ...");
        return this.WM.MW.getSpecialList("DoubleRedirects", "namespaces", this.reverseResults, callNext);
      }
    }, {
      key: 'reverseResults',
      value: function reverseResults(results, siteinfo, callNext) {
        var namespaces;
        boundMethodCheck(this, ref);
        namespaces = siteinfo.namespaces;
        results.reverse();
        return this.iterateList(results, namespaces, callNext);
      }
    }, {
      key: 'iterateList',
      value: function iterateList(doubleRedirects, namespaces, callNext) {
        var doubleRedirect;
        boundMethodCheck(this, ref);
        doubleRedirect = doubleRedirects.pop();
        if (doubleRedirect) {
          return this.WM.MW.callQueryEdit(doubleRedirect.title, this.readMiddleRedirect, [doubleRedirect, doubleRedirects, namespaces, callNext]);
        } else {
          this.WM.Log.logInfo("Fixed double redirects");
          if (callNext) {
            return callNext();
          }
        }
      }
    }, {
      key: 'readMiddleRedirect',
      value: function readMiddleRedirect(doubleRedirectTitle, doubleRedirectSource, timestamp, edittoken, args) {
        var callNext, doubleRedirect, doubleRedirects, middleRedirectTitle, namespaces;
        boundMethodCheck(this, ref);
        doubleRedirect = args[0];
        doubleRedirects = args[1];
        namespaces = args[2];
        callNext = args[3];
        middleRedirectTitle = namespaces[doubleRedirect.databaseResult.nsb]['*'] + ':' + doubleRedirect.databaseResult.tb;
        return this.WM.MW.callQuery({
          prop: "revisions",
          rvprop: "content",
          titles: middleRedirectTitle
        }, this.processDoubleRedirect, [doubleRedirect, doubleRedirectTitle, doubleRedirectSource, timestamp, edittoken, doubleRedirects, namespaces, callNext], null);
      }
    }, {
      key: 'processDoubleRedirect',
      value: function processDoubleRedirect(middleRedirect, args) {
        var callNext, doubleRedirect, doubleRedirectSource, doubleRedirectTitle, doubleRedirects, edittoken, middleRedirectSource, middleTarget, namespaces, newTarget, newTargetAltAnchor, newTargetFragment, newTargetInterlanguage, newTargetNamespace, newTargetTitle, newText, oldTarget, rawMiddleTarget, rawOldTarget, timestamp;
        boundMethodCheck(this, ref);
        middleRedirectSource = middleRedirect.revisions[0]["*"];
        doubleRedirect = args[0];
        doubleRedirectTitle = args[1];
        doubleRedirectSource = args[2];
        timestamp = args[3];
        edittoken = args[4];
        doubleRedirects = args[5];
        namespaces = args[6];
        callNext = args[7];
        this.WM.Log.logInfo("Processing " + this.WM.Log.linkToWikiPage(doubleRedirectTitle, doubleRedirectTitle) + " ...");
        rawOldTarget = doubleRedirectSource.match(/\s*#redirect\s*[^\n]+/i);
        oldTarget = this.WM.Parser.findInternalLinks(rawOldTarget[0], null)[0];
        rawMiddleTarget = middleRedirectSource.match(/\s*#redirect\s*[^\n]+/i);
        middleTarget = this.WM.Parser.findInternalLinks(rawMiddleTarget[0], null)[0];
        if (oldTarget.fragment) {
          newTargetFragment = "#" + oldTarget.fragment;
        } else if (middleTarget.fragment) {
          newTargetFragment = "#" + middleTarget.fragment;
        } else {
          newTargetFragment = "";
        }
        if (oldTarget.anchor) {
          newTargetAltAnchor = "|" + oldTarget.anchor;
        } else if (middleTarget.anchor) {
          newTargetAltAnchor = "|" + middleTarget.anchor;
        } else {
          newTargetAltAnchor = "";
        }
        if (doubleRedirect.databaseResult.iwc) {
          newTargetInterlanguage = doubleRedirect.databaseResult.iwc + ":";
        } else {
          newTargetInterlanguage = "";
        }
        if (namespaces[doubleRedirect.databaseResult.nsc]["*"]) {
          newTargetNamespace = this.WM.Parser.squashContiguousWhitespace(namespaces[doubleRedirect.databaseResult.nsc]["*"]) + ":";
        } else {
          newTargetNamespace = "";
        }
        newTargetTitle = this.WM.Parser.squashContiguousWhitespace(doubleRedirect.databaseResult.tc);
        newTarget = "[[" + newTargetInterlanguage + newTargetNamespace + newTargetTitle + newTargetFragment + newTargetAltAnchor + "]]";
        newText = Str.overwriteFor(doubleRedirectSource, newTarget, oldTarget.index, oldTarget.length);
        if (newText !== doubleRedirectSource) {
          return this.WM.MW.callAPIPost({
            action: "edit",
            bot: "1",
            title: doubleRedirectTitle,
            summary: this.conf.edit_summary,
            text: newText,
            b1asetimestamp: timestamp,
            token: edittoken
          }, this.processDoubleRedirectEnd, [doubleRedirects, namespaces, callNext], null);
        } else {
          this.WM.Log.logWarning("Could not fix " + this.WM.Log.linkToWikiPage(doubleRedirectTitle, doubleRedirectTitle));
          return this.iterateList(doubleRedirects, namespaces, callNext);
        }
      }
    }, {
      key: 'processDoubleRedirectEnd',
      value: function processDoubleRedirectEnd(res, args) {
        var callNext, doubleRedirects, namespaces;
        boundMethodCheck(this, ref);
        doubleRedirects = args[0];
        namespaces = args[1];
        callNext = args[2];
        if (res.edit && res.edit.result === 'Success') {
          return this.iterateList(doubleRedirects, namespaces, callNext);
        } else {
          return this.WM.Log.logError(res['error']['info'] + " (" + res['error']['code'] + ")");
        }
      }
    }]);

    return FixDoubleRedirects;
  }(Plugin);

  ;

  FixDoubleRedirects.conf_default = {
    enabled: true,
    special_menu: ["Fix double redirects"],
    edit_summary: "fix double redirect"
  };

  return FixDoubleRedirects;
}.call(undefined);

},{"./_Plugin":434,"@kynikos/misc/dist/Str":7}],428:[function(require,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Plugin;

var _require = require('./_Plugin');

Plugin = _require.Plugin;


module.exports.FixFragments = function () {
  var FixFragments = function (_Plugin) {
    _inherits(FixFragments, _Plugin);

    function FixFragments() {
      _classCallCheck(this, FixFragments);

      return _possibleConstructorReturn(this, (FixFragments.__proto__ || Object.getPrototypeOf(FixFragments)).apply(this, arguments));
    }

    _createClass(FixFragments, [{
      key: "fixLinks",
      value: function fixLinks(source) {
        var i, ilinks, j, len, len1, link, newtext1, newtext2, prevId, rawfragment, sections, slinks, title;
        title = this.WM.Editor.getTitle();
        sections = this.WM.Parser.findSectionHeadings(source).sections;
        slinks = this.WM.Parser.findSectionLinks(source);
        newtext1 = "";
        prevId = 0;
        for (i = 0, len = slinks.length; i < len; i++) {
          link = slinks[i];
          newtext1 += source.substring(prevId, link.index);
          newtext1 += this.fixLink(source, sections, link.rawLink, link.fragment, link.anchor);
          prevId = link.index + link.length;
        }
        newtext1 += source.substr(prevId);

        ilinks = this.WM.Parser.findInternalLinks(newtext1, null, title);
        newtext2 = "";
        prevId = 0;
        for (j = 0, len1 = ilinks.length; j < len1; j++) {
          link = ilinks[j];
          newtext2 += newtext1.substring(prevId, link.index);
          rawfragment = link.fragment;
          if (rawfragment) {
            newtext2 += this.fixLink(newtext1, sections, link.rawLink, rawfragment, link.anchor);
          } else {
            newtext2 += link.rawLink;
          }
          prevId = link.index + link.length;
        }
        newtext2 += newtext1.substr(prevId);
        return newtext2;
      }
    }, {
      key: "fixLink",
      value: function fixLink(source, sections, rawlink, rawfragment, lalt) {
        var dotFragment, dotHeading, escHeading, fragment, heading, i, len, section;
        fragment = this.WM.Parser.squashContiguousWhitespace(rawfragment).trim();
        for (i = 0, len = sections.length; i < len; i++) {
          section = sections[i];
          heading = section.cleanheading;
          dotHeading = this.WM.Parser.dotEncode(heading);
          dotFragment = this.WM.Parser.dotEncode(fragment);
          if (dotHeading.toLowerCase() === dotFragment.toLowerCase()) {
            if (fragment === dotFragment) {
              return "[[#" + dotHeading + (lalt ? "|" + lalt : "") + "]]";
            } else {
              escHeading = this.WM.Parser.dotEncodeLinkBreakingFragmentCharacters(heading);
              return "[[#" + escHeading + (lalt ? "|" + lalt : "") + "]]";
            }
          }
        }

        this.WM.Log.logWarning("Cannot fix broken section link: " + rawlink);
        return rawlink;
      }
    }, {
      key: "main_editor",
      value: function main_editor(callNext) {
        var newtext, source;
        source = this.WM.Editor.readSource();
        newtext = this.fixLinks(source);
        if (newtext !== source) {
          this.WM.Editor.writeSource(newtext);
          this.WM.Log.logInfo("Fixed section links");
        } else {
          this.WM.Log.logInfo("No fixable section links found");
        }
        if (callNext) {
          return callNext();
        }
      }
    }]);

    return FixFragments;
  }(Plugin);

  ;

  FixFragments.conf_default = {
    enabled: true,
    editor_menu: ["Text plugins", "Fix section links"]
  };

  return FixFragments;
}.call(undefined);

},{"./_Plugin":434}],429:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Plugin,
    ref,
    boundMethodCheck = function boundMethodCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new Error('Bound instance method accessed before binding');
  }
},
    indexOf = [].indexOf;

var _require = require('./_Plugin');

Plugin = _require.Plugin;


ref = module.exports.FixLinkFragments = function () {
  var FixLinkFragments = function (_Plugin) {
    _inherits(FixLinkFragments, _Plugin);

    function FixLinkFragments() {
      _classCallCheck(this, FixLinkFragments);

      var _this = _possibleConstructorReturn(this, (FixLinkFragments.__proto__ || Object.getPrototypeOf(FixLinkFragments)).apply(this, arguments));

      _this.processLink = _this.processLink.bind(_this);
      _this.processLinkContinue = _this.processLinkContinue.bind(_this);
      _this.fixFragment = _this.fixFragment.bind(_this);
      _this.findArchWikiLinks = _this.findArchWikiLinks.bind(_this);
      _this.findArchWikiLinks2 = _this.findArchWikiLinks2.bind(_this);
      _this.processArchWikiLink = _this.processArchWikiLink.bind(_this);
      _this.processArchWikiLinkContinue = _this.processArchWikiLinkContinue.bind(_this);
      _this.mainContinue = _this.mainContinue.bind(_this);
      _this.mainEnd = _this.mainEnd.bind(_this);
      return _this;
    }

    _createClass(FixLinkFragments, [{
      key: 'processLink',
      value: function processLink(title, iwprefixes, links, index, source, newText, prevId, call, callArgs) {
        var link, params, rawfragment, ref1, target;
        boundMethodCheck(this, ref);
        if (links[index]) {
          link = links[index];
          rawfragment = link.fragment;
          if (!(link.namespace != null && (ref1 = link.namespace.toLowerCase(), indexOf.call(iwprefixes, ref1) >= 0)) && rawfragment) {
            this.WM.Log.logInfo("Processing " + this.WM.Log.linkToWikiPage(link.link, link.rawLink) + " ...");
            target = (link.namespace ? link.namespace + ":" : "") + link.title;

            if (!this.WM.Parser.compareArticleTitles(target, title)) {
              params = {
                'action': 'parse',
                'prop': 'sections',
                'page': target,
                'redirects': 1
              };
              return this.WM.MW.callAPIGet(params, this.processLinkContinue, [link, target, rawfragment, iwprefixes, links, index, source, newText, prevId, title, call, callArgs], null);
            } else {
              index++;
              return this.processLink(title, iwprefixes, links, index, source, newText, prevId, call, callArgs);
            }
          } else {
            index++;
            return this.processLink(title, iwprefixes, links, index, source, newText, prevId, call, callArgs);
          }
        } else {
          newText += source.substr(prevId);
          return call(newText, iwprefixes, callArgs);
        }
      }
    }, {
      key: 'processLinkContinue',
      value: function processLinkContinue(res, args) {
        var call, callArgs, fixedFragment, i, index, iwprefixes, len, link, links, newText, prevId, rawfragment, ref1, section, sections, source, target, title;
        boundMethodCheck(this, ref);
        link = args[0];
        target = args[1];
        rawfragment = args[2];
        iwprefixes = args[3];
        links = args[4];
        index = args[5];
        source = args[6];
        newText = args[7];
        prevId = args[8];
        title = args[9];
        call = args[10];
        callArgs = args[11];

        if (res.parse) {
          sections = [];
          ref1 = res.parse.sections;
          for (i = 0, len = ref1.length; i < len; i++) {
            section = ref1[i];
            sections.push(this.WM.Parser.squashContiguousWhitespace(section.line).trim());
          }
          fixedFragment = this.fixFragment(rawfragment, sections);
          newText += source.substring(prevId, link.index);
          if (fixedFragment === true) {
            newText += link.rawLink;
          } else if (fixedFragment) {
            newText += "[[" + target + "#" + fixedFragment + (link.anchor ? "|" + link.anchor : "") + "]]";
          } else {
            this.WM.Log.logWarning("Cannot fix broken link fragment: " + this.WM.Log.linkToWikiPage(link.link, link.rawLink));
            newText += link.rawLink;
          }
          prevId = link.index + link.length;
        }
        index++;
        return this.processLink(title, iwprefixes, links, index, source, newText, prevId, call, callArgs);
      }
    }, {
      key: 'fixFragment',
      value: function fixFragment(rawfragment, sections) {
        var dotFragment, dotSection, fragment, i, len, section;
        boundMethodCheck(this, ref);
        fragment = this.WM.Parser.squashContiguousWhitespace(rawfragment).trim();
        if (sections.indexOf(fragment) < 0) {
          for (i = 0, len = sections.length; i < len; i++) {
            section = sections[i];
            dotSection = this.WM.Parser.dotEncode(section);
            dotFragment = this.WM.Parser.dotEncode(fragment);
            if (dotSection.toLowerCase() === dotFragment.toLowerCase()) {
              if (fragment === dotFragment) {
                return dotSection;
              } else {
                return this.WM.Parser.dotEncodeLinkBreakingFragmentCharacters(section);
              }
            }
          }
          return false;
        } else {
          return true;
        }
      }
    }, {
      key: 'findArchWikiLinks',
      value: function findArchWikiLinks(newText, iwprefixes, callArgs) {
        var templates, title;
        boundMethodCheck(this, ref);
        templates = this.WM.Parser.findTemplates(newText, 'Related');
        title = this.WM.Editor.getTitle();
        return this.processArchWikiLink(title, iwprefixes, templates, 1, 0, newText, "", 0, this.findArchWikiLinks2, callArgs);
      }
    }, {
      key: 'findArchWikiLinks2',
      value: function findArchWikiLinks2(newText, iwprefixes, callArgs) {
        var templates, title;
        boundMethodCheck(this, ref);
        templates = this.WM.Parser.findTemplates(newText, 'Related2');
        title = this.WM.Editor.getTitle();
        return this.processArchWikiLink(title, iwprefixes, templates, 2, 0, newText, "", 0, this.mainEnd, callArgs);
      }
    }, {
      key: 'processArchWikiLink',
      value: function processArchWikiLink(title, iwprefixes, templates, expectedArgs, index, source, newText, prevId, call, callArgs) {
        var args, fragId, link, params, rawfragment, rawtarget, target, template;
        boundMethodCheck(this, ref);
        if (templates[index]) {
          template = templates[index];
          args = template.arguments;

          if (args.length === expectedArgs) {
            link = args[0].value;
            fragId = link.indexOf('#');
            if (fragId > -1) {
              rawtarget = link.substring(0, fragId);
              target = this.WM.Parser.squashContiguousWhitespace(rawtarget).trim();
              rawfragment = link.substr(fragId + 1);
              if (rawfragment) {
                if (!this.WM.Parser.compareArticleTitles(target, title)) {
                  this.WM.Log.logInfo("Processing " + this.WM.Log.linkToWikiPage(link, template.rawTransclusion) + " ...");
                  params = {
                    'action': 'parse',
                    'prop': 'sections',
                    'page': target,
                    'redirects': 1
                  };
                  return this.WM.MW.callAPIGet(params, this.processArchWikiLinkContinue, [template, target, rawfragment, iwprefixes, templates, expectedArgs, index, source, newText, prevId, title, call, callArgs], null);
                } else {
                  index++;
                  return this.processArchWikiLink(title, iwprefixes, templates, expectedArgs, index, source, newText, prevId, call, callArgs);
                }
              } else {
                index++;
                return this.processArchWikiLink(title, iwprefixes, templates, expectedArgs, index, source, newText, prevId, call, callArgs);
              }
            } else {
              index++;
              return this.processArchWikiLink(title, iwprefixes, templates, expectedArgs, index, source, newText, prevId, call, callArgs);
            }
          } else {
            this.WM.Log.logWarning("Template:" + template.title + " must have " + expectedArgs + " and only " + expectedArgs + (expectedArgs > 1 ? " arguments: " : " argument: ") + template.rawTransclusion);
            index++;
            return this.processArchWikiLink(title, iwprefixes, templates, expectedArgs, index, source, newText, prevId, call, callArgs);
          }
        } else {
          newText += source.substr(prevId);
          return call(newText, iwprefixes, callArgs);
        }
      }
    }, {
      key: 'processArchWikiLinkContinue',
      value: function processArchWikiLinkContinue(res, args) {
        var anchor, call, callArgs, expectedArgs, fixedFragment, i, index, iwprefixes, len, newText, prevId, rawfragment, ref1, section, sections, source, target, template, templates, title;
        boundMethodCheck(this, ref);
        template = args[0];
        target = args[1];
        rawfragment = args[2];
        iwprefixes = args[3];
        templates = args[4];
        expectedArgs = args[5];
        index = args[6];
        source = args[7];
        newText = args[8];
        prevId = args[9];
        title = args[10];
        call = args[11];
        callArgs = args[12];

        if (res.parse) {
          sections = [];
          ref1 = res.parse.sections;
          for (i = 0, len = ref1.length; i < len; i++) {
            section = ref1[i];
            sections.push(this.WM.Parser.squashContiguousWhitespace(section.line).trim());
          }
          fixedFragment = this.fixFragment(rawfragment, sections);
          newText += source.substring(prevId, template.index);
          if (fixedFragment === true) {
            newText += template.rawTransclusion;
          } else if (fixedFragment) {
            anchor = template.arguments[1] ? "|" + template.arguments[1].value : "";
            newText += "{{" + template.title + "|" + target + "#" + fixedFragment + anchor + "}}";
          } else {
            this.WM.Log.logWarning("Cannot fix broken link fragment: " + this.WM.Log.linkToWikiPage(target, template.rawTransclusion));
            newText += template.rawTransclusion;
          }
          prevId = template.index + template.length;
        }
        index++;
        return this.processArchWikiLink(title, iwprefixes, templates, expectedArgs, index, source, newText, prevId, call, callArgs);
      }
    }, {
      key: 'main_editor',
      value: function () {
        var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(callNext) {
          var iw, iwprefixes, links, res, source, title;
          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  source = this.WM.Editor.readSource();
                  this.WM.Log.logInfo("Fixing links to sections of other articles ...");
                  title = this.WM.Editor.getTitle();
                  _context.next = 5;
                  return this.WM.MW.getInterwikiMap(title);

                case 5:
                  res = _context.sent;

                  iwprefixes = function () {
                    var i, len, ref1, results;
                    ref1 = res.query.interwikimap;
                    results = [];
                    for (i = 0, len = ref1.length; i < len; i++) {
                      iw = ref1[i];
                      results.push(iw.prefix);
                    }
                    return results;
                  }();
                  links = this.WM.Parser.findInternalLinks(source, null, null);
                  return _context.abrupt('return', this.processLink(title, iwprefixes, links, 0, source, "", 0, this.mainContinue, callNext));

                case 9:
                case 'end':
                  return _context.stop();
              }
            }
          }, _callee, this);
        }));

        function main_editor(_x) {
          return _ref.apply(this, arguments);
        }

        return main_editor;
      }()
    }, {
      key: 'mainContinue',
      value: function mainContinue(newText, iwprefixes, callNext) {
        var templates;
        boundMethodCheck(this, ref);

        if (location.hostname === 'wiki.archlinux.org') {
          return templates = this.findArchWikiLinks(newText, iwprefixes, callNext);
        } else {
          return this.mainEnd(newText, iwprefixes, callNext);
        }
      }
    }, {
      key: 'mainEnd',
      value: function mainEnd(newText, iwprefixes, callNext) {
        var source;
        boundMethodCheck(this, ref);
        source = this.WM.Editor.readSource();
        if (newText !== source) {
          this.WM.Editor.writeSource(newText);
          this.WM.Log.logInfo("Replaced links to sections of other articles");
        } else {
          this.WM.Log.logInfo("No fixable links to sections of other articles " + "found");
        }
        if (callNext) {
          return callNext();
        }
      }
    }]);

    return FixLinkFragments;
  }(Plugin);

  ;

  FixLinkFragments.conf_default = {
    enabled: true,
    editor_menu: ["Query plugins", "Fix external section links"]
  };

  return FixLinkFragments;
}.call(undefined);

},{"./_Plugin":434}],430:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Plugin;

var _require = require('./_Plugin');

Plugin = _require.Plugin;


module.exports.MultipleLineBreaks = function () {
  var MultipleLineBreaks = function (_Plugin) {
    _inherits(MultipleLineBreaks, _Plugin);

    function MultipleLineBreaks() {
      _classCallCheck(this, MultipleLineBreaks);

      return _possibleConstructorReturn(this, (MultipleLineBreaks.__proto__ || Object.getPrototypeOf(MultipleLineBreaks)).apply(this, arguments));
    }

    _createClass(MultipleLineBreaks, [{
      key: 'main_editor',
      value: function main_editor(callNext) {
        var newtext, source;
        source = this.WM.Editor.readSource();
        newtext = source;
        newtext = newtext.replace(/[\n]{3,}/g, '\n\n');
        if (newtext !== source) {
          this.WM.Editor.writeSource(newtext);
          this.WM.Log.logInfo("Removed multiple line breaks");
        }
        if (callNext) {
          return callNext();
        }
      }
    }]);

    return MultipleLineBreaks;
  }(Plugin);

  ;

  MultipleLineBreaks.conf_default = {
    enabled: true,
    editor_menu: ["Text plugins", "Squash multiple line breaks"]
  };

  return MultipleLineBreaks;
}.call(undefined);

},{"./_Plugin":434}],431:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var CSS,
    Plugin,
    ref,
    boundMethodCheck = function boundMethodCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new Error('Bound instance method accessed before binding');
  }
};

var _require = require('./_Plugin');

Plugin = _require.Plugin;


CSS = require('@kynikos/misc/dist/CSS');

ref = module.exports.SimpleReplace = function () {
  var configuration, _makeUI, storeRegExp;

  var SimpleReplace = function (_Plugin) {
    _inherits(SimpleReplace, _Plugin);

    function SimpleReplace() {
      _classCallCheck(this, SimpleReplace);

      var _this = _possibleConstructorReturn(this, (SimpleReplace.__proto__ || Object.getPrototypeOf(SimpleReplace)).apply(this, arguments));

      _this.storeConfiguration = _this.storeConfiguration.bind(_this);
      _this.mainAutoWrite = _this.mainAutoWrite.bind(_this);
      _this.mainAutoEnd = _this.mainAutoEnd.bind(_this);
      return _this;
    }

    _createClass(SimpleReplace, [{
      key: 'makeUI',
      value: function makeUI() {
        return _makeUI();
      }
    }, {
      key: 'makeBotUI',
      value: function makeBotUI() {
        var divMain, par3, summary, summaryLabel;
        divMain = _makeUI();
        par3 = document.createElement('div');
        summaryLabel = document.createElement('span');
        summaryLabel.innerHTML = 'Edit summary:';
        summary = document.createElement('input');
        summary.setAttribute('type', 'text');
        summary.id = "WikiMonkey-SimpleReplace-Summary";
        par3.appendChild(summaryLabel);
        par3.appendChild(summary);
        divMain.appendChild(par3);
        return divMain;
      }
    }, {
      key: 'storeConfiguration',
      value: function storeConfiguration() {
        boundMethodCheck(this, ref);
        configuration = {
          pattern: document.getElementById("WikiMonkey-SimpleReplace-RegExp").value,
          ignoreCase: document.getElementById("WikiMonkey-SimpleReplace-IgnoreCase").checked,
          newString: document.getElementById("WikiMonkey-SimpleReplace-NewString").value
        };
        this.WM.Log.logHidden("Pattern: " + configuration.pattern);
        this.WM.Log.logHidden("Ignore case: " + configuration.ignoreCase);
        return this.WM.Log.logHidden("New string: " + configuration.newString);
      }
    }, {
      key: 'main_editor',
      value: function main_editor(callNext) {
        var exc, newtext, source;
        this.storeConfiguration();
        try {
          storeRegExp();
        } catch (error) {
          exc = error;
          this.WM.Log.logError("Invalid pattern: " + exc);

          return false;
        }
        source = this.WM.Editor.readSource();
        newtext = source.replace(configuration.regExp, configuration.newString);
        if (newtext !== source) {
          this.WM.Editor.writeSource(newtext);
          this.WM.Log.logInfo("Text substituted");
        }
        if (callNext) {
          return callNext();
        }
      }
    }, {
      key: 'main_bot',
      value: function main_bot(title, callBot, chainArgs) {
        var exc, summary;
        this.storeConfiguration();
        try {
          storeRegExp();
        } catch (error) {
          exc = error;
          this.WM.Log.logError("Invalid pattern: " + exc);
          callBot(false, null);

          return false;
        }
        summary = document.getElementById("WikiMonkey-SimpleReplace-Summary").value;
        if (summary !== "") {
          return this.WM.MW.callQueryEdit(title, this.mainAutoWrite, [summary, callBot]);
        } else {
          this.WM.Log.logError("The edit summary cannot be empty");
          return callBot(false, null);
        }
      }
    }, {
      key: 'mainAutoWrite',
      value: function mainAutoWrite(title, source, timestamp, edittoken, args) {
        var callBot, newtext, summary;
        boundMethodCheck(this, ref);
        summary = args[0];
        callBot = args[1];
        newtext = source.replace(configuration.regExp, configuration.newString);
        if (newtext !== source) {
          return this.WM.MW.callAPIPost({
            action: "edit",
            bot: "1",
            title: title,
            summary: summary,
            text: newtext,
            basetimestamp: timestamp,
            token: edittoken
          }, this.mainAutoEnd, callBot, null);
        } else {
          return callBot(0, null);
        }
      }
    }, {
      key: 'mainAutoEnd',
      value: function mainAutoEnd(res, callBot) {
        boundMethodCheck(this, ref);
        if (res.edit && res.edit.result === 'Success') {
          return callBot(1, null);
        } else if (res.error) {
          this.WM.Log.logError(res.error.info + " (" + res.error.code + ")");
          return callBot(res.error.code, null);
        } else {
          return callBot(false, null);
        }
      }
    }]);

    return SimpleReplace;
  }(Plugin);

  ;

  SimpleReplace.conf_default = {
    enabled: true,
    editor_menu: ["RegExp substitution"],
    bot_label: "RegExp substitution"
  };

  _makeUI = function _makeUI() {
    var divMain, ignoreCase, ignoreCaseLabel, newString, newStringLabel, par1, par2, regexp, regexpLabel;
    CSS.addStyleElement("#WikiMonkey-SimpleReplace div " + "{margin-bottom:0.33em;} " + "#WikiMonkey-SimpleReplace input[type='text'] " + "{margin-left:0.33em; width:60%;}");
    divMain = document.createElement('div');
    divMain.id = "WikiMonkey-SimpleReplace";
    par1 = document.createElement('div');
    regexpLabel = document.createElement('span');
    regexpLabel.innerHTML = 'RegExp pattern:';
    regexp = document.createElement('input');
    regexp.setAttribute('type', 'text');
    regexp.id = "WikiMonkey-SimpleReplace-RegExp";
    ignoreCase = document.createElement('input');
    ignoreCase.setAttribute('type', 'checkbox');
    ignoreCase.id = "WikiMonkey-SimpleReplace-IgnoreCase";
    ignoreCaseLabel = document.createElement('span');
    ignoreCaseLabel.innerHTML = 'i';
    par1.appendChild(regexpLabel);
    par1.appendChild(regexp);
    par1.appendChild(ignoreCase);
    par1.appendChild(ignoreCaseLabel);
    par2 = document.createElement('div');
    newStringLabel = document.createElement('span');
    newStringLabel.innerHTML = 'New string:';
    newString = document.createElement('input');
    newString.setAttribute('type', 'text');
    newString.id = "WikiMonkey-SimpleReplace-NewString";
    par2.appendChild(newStringLabel);
    par2.appendChild(newString);
    divMain.appendChild(par1);
    divMain.appendChild(par2);
    return divMain;
  };

  configuration = null;

  storeRegExp = function storeRegExp() {
    return configuration.regExp = new RegExp(configuration.pattern, "g" + (configuration.ignoreCase ? "i" : ""));
  };

  return SimpleReplace;
}.call(undefined);

},{"./_Plugin":434,"@kynikos/misc/dist/CSS":2}],432:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Plugin,
    ref,
    boundMethodCheck = function boundMethodCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new Error('Bound instance method accessed before binding');
  }
};

var _require = require('./_Plugin');

Plugin = _require.Plugin;


ref = module.exports.SynchronizeInterlanguageLinks = function () {
  var SynchronizeInterlanguageLinks = function (_Plugin) {
    _inherits(SynchronizeInterlanguageLinks, _Plugin);

    function SynchronizeInterlanguageLinks() {
      _classCallCheck(this, SynchronizeInterlanguageLinks);

      var _this = _possibleConstructorReturn(this, (SynchronizeInterlanguageLinks.__proto__ || Object.getPrototypeOf(SynchronizeInterlanguageLinks)).apply(this, arguments));

      _this.detectLang = _this.detectLang.bind(_this);
      _this.computeWhiteList = _this.computeWhiteList.bind(_this);
      _this.computeSupportedLangs = _this.computeSupportedLangs.bind(_this);
      _this.mainContinue = _this.mainContinue.bind(_this);
      _this.mainEnd = _this.mainEnd.bind(_this);
      _this.mainAutoWrite = _this.mainAutoWrite.bind(_this);
      _this.mainAutoEnd = _this.mainAutoEnd.bind(_this);
      return _this;
    }

    _createClass(SynchronizeInterlanguageLinks, [{
      key: 'detectLang',
      value: function detectLang(title, tag) {
        var detect, pureTitle;
        boundMethodCheck(this, ref);

        if (tag === "ArchWiki") {
          detect = this.WM.ArchWiki.detectLanguage(title);
          pureTitle = detect[0];
          tag = this.WM.ArchWiki.getInterlanguageTag(detect[1]);
        } else {
          pureTitle = title;
        }
        return [pureTitle, tag];
      }
    }, {
      key: 'computeWhiteList',
      value: function computeWhiteList(whitelist) {
        boundMethodCheck(this, ref);

        if (whitelist === "ArchWiki") {
          return this.WM.ArchWiki.getInternalInterwikiLanguages();
        } else {
          return whitelist;
        }
      }
    }, {
      key: 'computeSupportedLangs',
      value: function computeSupportedLangs(supportedLangs) {
        boundMethodCheck(this, ref);

        if (supportedLangs === "ArchWiki") {
          return this.WM.ArchWiki.getInterwikiLanguages();
        } else {
          return supportedLangs;
        }
      }
    }, {
      key: 'main_editor',
      value: function main_editor(callNext) {
        var detect, pureTitle, supportedLangs, tag, title, whitelist;
        title = this.WM.Editor.getTitle();
        detect = this.detectLang(title, this.conf.language_tag);
        pureTitle = detect[0];
        tag = detect[1];
        whitelist = this.computeWhiteList(this.conf.tag_whitelist);
        supportedLangs = this.computeSupportedLangs(this.conf.supported_tags);
        this.WM.Log.logInfo("Synchronizing interlanguage links ...");
        return this.WM.MW.getLocalInterwikiMap(title, this.mainContinue, [tag, pureTitle, supportedLangs, whitelist, title, callNext]);
      }
    }, {
      key: 'mainContinue',
      value: function mainContinue(iwmap, args) {
        var callNext, i, langlinks, len, link, newlinks, nlink, pureTitle, source, supportedLangs, tag, title, url, visitedlinks, vlink, whitelist, wikiUrls;
        boundMethodCheck(this, ref);
        tag = args[0];
        pureTitle = args[1];
        supportedLangs = args[2];
        whitelist = args[3];
        title = args[4];
        callNext = args[5];
        source = this.WM.Editor.readSource();
        langlinks = this.WM.Interlanguage.parseLinks(supportedLangs, source, iwmap);
        wikiUrls = this.WM.MW.getWikiUrls();
        url = wikiUrls.short + encodeURIComponent(this.WM.Parser.squashContiguousWhitespace(title));
        visitedlinks = {};
        visitedlinks[tag.toLowerCase()] = this.WM.Interlanguage.createVisitedLink(tag, pureTitle, url, iwmap, source, null, null, langlinks);
        newlinks = {};
        this.WM.Log.logInfo("Reading " + this.WM.Log.linkToPage(url, "edited article") + " ...");
        if (langlinks) {
          for (i = 0, len = langlinks.length; i < len; i++) {
            link = langlinks[i];
            nlink = newlinks[link.lang.toLowerCase()];
            vlink = visitedlinks[link.lang.toLowerCase()];
            if (!vlink && !nlink) {
              newlinks[link.lang.toLowerCase()] = this.WM.Interlanguage.createNewLink(link.lang, link.title, link.url);
            } else if (vlink && vlink.url !== link.url) {
              this.WM.Log.logWarning("Possibly conflicting interlanguage " + "links: " + this.WM.Log.linkToPage(link.url, "[[" + link.lang + ":" + link.title + "]]") + " and " + this.WM.Log.linkToPage(vlink.url, "[[" + link.lang + ":" + visitedlinks[link.lang.toLowerCase()].title + "]]"));
            } else if (nlink && nlink.url !== link.url) {
              this.WM.Log.logWarning("Possibly conflicting interlanguage " + "links: " + this.WM.Log.linkToPage(link.url, "[[" + link.lang + ":" + link.title + "]]") + " and " + this.WM.Log.linkToPage(nlink.url, "[[" + link.lang + ":" + newlinks[link.lang.toLowerCase()].title + "]]"));
            }
          }
          return this.WM.Interlanguage.collectLinks(visitedlinks, newlinks, supportedLangs, whitelist, false, this.mainEnd, [tag, url, source, langlinks, iwmap, callNext]);
        } else {
          this.WM.Log.logInfo("No interlanguage links found");
          if (callNext) {
            return callNext();
          }
        }
      }
    }, {
      key: 'mainEnd',
      value: function mainEnd(links, args) {
        var callNext, iwmap, langlinks, newText, source, tag, url;
        boundMethodCheck(this, ref);
        tag = args[0];
        url = args[1];
        source = args[2];
        langlinks = args[3];
        iwmap = args[4];
        callNext = args[5];
        newText = this.WM.Interlanguage.updateLinks(tag, url, iwmap, source, langlinks, links);
        if (newText !== source) {
          this.WM.Editor.writeSource(newText);
          this.WM.Log.logInfo("Synchronized interlanguage links");
        } else {
          this.WM.Log.logInfo("Interlanguage links were already synchronized");
        }
        if (callNext) {
          return callNext();
        }
      }
    }, {
      key: 'main_bot',
      value: function main_bot(title, callBot, chainArgs) {
        var detect, newlinks, pureTitle, summary, supportedLangs, tag, url, visitedlinks, whitelist, wikiUrls;
        detect = this.detectLang(title, this.conf.language_tag);
        pureTitle = detect[0];
        tag = detect[1];
        whitelist = this.computeWhiteList(this.conf.tag_whitelist);
        supportedLangs = this.computeSupportedLangs(this.conf.supported_tags);
        summary = this.conf.edit_summary;
        wikiUrls = this.WM.MW.getWikiUrls();
        url = wikiUrls.short + encodeURIComponent(this.WM.Parser.squashContiguousWhitespace(title));
        visitedlinks = {};
        newlinks = {};
        newlinks[tag.toLowerCase()] = this.WM.Interlanguage.createNewLink(tag, pureTitle, url);
        return this.WM.Interlanguage.collectLinks(visitedlinks, newlinks, supportedLangs, whitelist, true, this.mainAutoWrite, [title, url, tag, summary, callBot]);
      }
    }, {
      key: 'mainAutoWrite',
      value: function mainAutoWrite(links, args) {
        var callBot, edittoken, iwmap, langlinks, lcTag, newText, source, summary, tag, timestamp, title, url;
        boundMethodCheck(this, ref);
        title = args[0];
        url = args[1];
        tag = args[2];
        summary = args[3];
        callBot = args[4];
        lcTag = tag.toLowerCase();

        iwmap = links[lcTag].iwmap;
        source = links[lcTag].source;
        langlinks = links[lcTag].links;
        timestamp = links[lcTag].timestamp;
        edittoken = links[lcTag].edittoken;
        newText = this.WM.Interlanguage.updateLinks(tag, url, iwmap, source, langlinks, links);
        if (newText !== source) {
          return this.WM.MW.callAPIPost({
            action: "edit",
            bot: "1",
            title: title,
            summary: summary,
            text: newText,
            basetimestamp: timestamp,
            token: edittoken
          }, this.mainAutoEnd, callBot, null);
        } else {
          return callBot(0, null);
        }
      }
    }, {
      key: 'mainAutoEnd',
      value: function mainAutoEnd(res, callBot) {
        boundMethodCheck(this, ref);
        if (res.edit && res.edit.result === 'Success') {
          return callBot(1, null);
        } else if (res.error) {
          this.WM.Log.logError(res.error.info + " (" + res.error.code + ")");
          return callBot(res.error.code, null);
        } else {
          return callBot(false, null);
        }
      }
    }]);

    return SynchronizeInterlanguageLinks;
  }(Plugin);

  ;

  SynchronizeInterlanguageLinks.conf_default = {
    enabled: true,
    editor_menu: ["Query plugins", "Sync interlanguage links"],
    bot_label: "Synchronize interlanguage links",
    language_tag: "en",
    tag_whitelist: ["en"],
    supported_tags: ["en"],
    edit_summary: "synchronized interlanguage links with the other wikis"
  };

  SynchronizeInterlanguageLinks.wiki_to_conf_default = {
    ArchWiki: {
      language_tag: "ArchWiki",
      tag_whitelist: "ArchWiki",
      supported_tags: "ArchWiki"
    },
    Wikipedia: {
      enabled: false
    }
  };

  return SynchronizeInterlanguageLinks;
}.call(undefined);

},{"./_Plugin":434}],433:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Plugin,
    Str,
    ref,
    boundMethodCheck = function boundMethodCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new Error('Bound instance method accessed before binding');
  }
},
    indexOf = [].indexOf;

var _require = require('./_Plugin');

Plugin = _require.Plugin;


Str = require('@kynikos/misc/dist/Str');

ref = module.exports.UpdateCategoryTree = function () {
  var UpdateCategoryTree = function (_Plugin) {
    _inherits(UpdateCategoryTree, _Plugin);

    function UpdateCategoryTree() {
      _classCallCheck(this, UpdateCategoryTree);

      var _this = _possibleConstructorReturn(this, (UpdateCategoryTree.__proto__ || Object.getPrototypeOf(UpdateCategoryTree)).apply(this, arguments));

      _this.mainContinue = _this.mainContinue.bind(_this);
      _this.readToC = _this.readToC.bind(_this);
      _this.processToC = _this.processToC.bind(_this);
      _this.storeAlternativeNames = _this.storeAlternativeNames.bind(_this);
      _this.processCategory = _this.processCategory.bind(_this);
      _this.processCategoryAddSuffix = _this.processCategoryAddSuffix.bind(_this);
      _this.processCategoryEnd = _this.processCategoryEnd.bind(_this);
      _this.createCatLink = _this.createCatLink.bind(_this);
      _this.writeToC = _this.writeToC.bind(_this);
      _this.checkWrite = _this.checkWrite.bind(_this);
      return _this;
    }

    _createClass(UpdateCategoryTree, [{
      key: 'main_special',
      value: function main_special(callNext) {
        return this.iteratePages(-1, callNext);
      }
    }, {
      key: 'iteratePages',
      value: function iteratePages(pageid, callNext) {
        var params, pconf, showRootAlsoIn, summary;
        pageid++;
        summary = this.conf.edit_summary;
        showRootAlsoIn = this.conf.show_root_also_in;
        pconf = this.conf.pages[pageid];
        if (pconf) {
          if ($.type(pconf) === "string") {
            params = this.WM.ArchWiki.getTableOfContents(pconf);
          } else {
            params = pconf;
          }
          return this.WM.MW.isUserBot(this.mainContinue, [params, showRootAlsoIn, summary, callNext, pageid]);
        } else if (callNext) {
          return callNext();
        }
      }
    }, {
      key: 'mainContinue',
      value: function mainContinue(botTest, args) {
        boundMethodCheck(this, ref);
        return this.readToC({
          params: args[0],
          minInterval: botTest ? 60000 : 21600000,
          edittoken: "",
          timestamp: "",
          source: "",
          startId: 0,
          endId: 0,
          treeText: "",
          startMark: "START AUTO TOC - DO NOT REMOVE OR MODIFY THIS MARK-->",
          endMark: "<!--END AUTO TOC - DO NOT REMOVE OR MODIFY THIS MARK",
          altNames: {},
          showRootAlsoIn: args[1],
          summary: args[2],
          callNext: args[3],
          pageid: args[4]
        });
      }
    }, {
      key: 'readToC',
      value: function readToC(args) {
        boundMethodCheck(this, ref);
        this.WM.Log.logInfo('Updating ' + this.WM.Log.linkToWikiPage(args.params.page, args.params.page) + " ...");
        return this.WM.MW.callQueryEdit(args.params.page, this.processToC, args);
      }
    }, {
      key: 'processToC',
      value: function processToC(title, source, timestamp, edittoken, args) {
        var end, msTimestamp, now, start;
        boundMethodCheck(this, ref);
        args.source = source;
        args.timestamp = timestamp;
        args.edittoken = edittoken;
        now = new Date();
        msTimestamp = Date.parse(args.timestamp);
        if (now.getTime() - msTimestamp >= args.minInterval) {
          start = args.source.indexOf(args.startMark);
          end = args.source.lastIndexOf(args.endMark);
          if (start > -1 && end > -1) {
            args.startId = start + args.startMark.length;
            args.endId = end;
            args.treeText = "";
            args.altNames = args.params.keepAltName ? this.storeAlternativeNames(args.source) : {};
            return this.WM.Cat.recurseTree({
              node: args.params.root,
              callNode: this.processCategory,
              callEnd: this.writeToC,
              callArgs: args
            });
          } else {
            this.WM.Log.logError("Cannot find insertion marks in " + this.WM.Log.linkToWikiPage(args.params.page, args.params.page));
            return this.iteratePages(args.pageid, args.callNext);
          }
        } else {
          this.WM.Log.logWarning(this.WM.Log.linkToWikiPage(args.params.page, args.params.page) + ' has been updated too recently');
          return this.iteratePages(args.pageid, args.callNext);
        }
      }
    }, {
      key: 'storeAlternativeNames',
      value: function storeAlternativeNames(source) {
        var dict, match, regExp;
        boundMethodCheck(this, ref);
        dict = {};
        regExp = /\[\[\:([Cc]ategory\:.+?)\|(.+?)\]\]/gm;
        while (true) {
          match = regExp.exec(source);
          if (match) {
            dict[match[1].toLowerCase()] = match[2];
          } else {
            break;
          }
        }
        return dict;
      }
    }, {
      key: 'processCategory',
      value: function processCategory(params) {
        var altName, args, indices, j, node, ref1, text;
        boundMethodCheck(this, ref);
        args = params.callArgs;
        this.WM.Log.logInfo("Processing " + this.WM.Log.linkToWikiPage(params.node, params.node) + " ...");
        text = "";
        for (j = 0, ref1 = params.ancestors.length; 0 <= ref1 ? j < ref1 : j > ref1; 0 <= ref1 ? j++ : j--) {
          text += args.params.indentType;
        }
        if (args.params.showIndices) {
          indices = [];
          node = params;
          while (node.parentIndex !== null) {
            indices.push(node.siblingIndex + 1);
            node = params.nodesList[node.parentIndex];
          }
          if (indices.length) {
            text += "<small>" + indices.reverse().join(".") + ".</small> ";
          }
        }
        altName = args.altNames[params.node.toLowerCase()] ? args.altNames[params.node.toLowerCase()] : null;
        text += this.createCatLink(params.node, args.params.replace, altName);
        text += args.params.rightToLeft ? "&lrm; " : " ";
        if (params.children === "loop") {
          text += "'''[LOOP]'''\n";
          this.WM.Log.logWarning("Loop in " + this.WM.Log.linkToWikiPage(params.node, params.node));
          return this.processCategoryEnd(params, args, text);
        } else {
          return this.WM.Cat.getParentsAndInfo(params.node, this.processCategoryAddSuffix, [params, args, text, altName]);
        }
      }
    }, {
      key: 'processCategoryAddSuffix',
      value: function processCategoryAddSuffix(parents, info, args_) {
        var alsoParents, altName, args, currParent, i, j, k, len, len1, par, params, parentTitles, text;
        boundMethodCheck(this, ref);
        params = args_[0];
        args = args_[1];
        text = args_[2];
        altName = args_[3];
        currParent = params.ancestors[params.ancestors.length - 1];
        alsoParents = [];
        text += "<small>(" + (info ? info.pages : 0) + ")";

        if (currParent || args.showRootAlsoIn) {
          for (j = 0, len = parents.length; j < len; j++) {
            par = parents[j];
            if (currParent !== par.title && !(indexOf.call(par, "hidden") >= 0)) {
              alsoParents.push(par);
            }
          }
          if (alsoParents.length) {
            parentTitles = [];
            for (k = 0, len1 = alsoParents.length; k < len1; k++) {
              i = alsoParents[k];
              altName = args.altNames[alsoParents[i].title.toLowerCase()] ? args.altNames[alsoParents[i].title.toLowerCase()] : null;
              parentTitles.push(this.createCatLink(alsoParents[i].title, args.params.replace, altName));
            }
            text += " (" + args.params.alsoIn + " " + parentTitles.join(", ") + ")";
          }
        }
        text += "</small>\n";
        return this.processCategoryEnd(params, args, text);
      }
    }, {
      key: 'processCategoryEnd',
      value: function processCategoryEnd(params, args, text) {
        boundMethodCheck(this, ref);
        args.treeText += text;
        params.callArgs = args;
        return this.WM.Cat.recurseTreeContinue(params);
      }
    }, {
      key: 'createCatLink',
      value: function createCatLink(cat, replace, altName) {
        var catName, regExp;
        boundMethodCheck(this, ref);
        if (altName) {
          catName = altName;
        } else if (replace) {
          regExp = new RegExp(replace[0], replace[1]);
          catName = cat.substr(9).replace(regExp, replace[2]);
        } else {
          catName = cat.substr(9);
        }
        return "[[:" + cat + "|" + catName + "]]";
      }
    }, {
      key: 'writeToC',
      value: function writeToC(params) {
        var args, newtext;
        boundMethodCheck(this, ref);
        args = params.callArgs;
        args.treeText = "\n" + args.treeText;
        newtext = Str.overwriteBetween(args.source, args.treeText, args.startId, args.endId);
        if (newtext !== args.source) {
          return this.WM.MW.callAPIPost({
            action: "edit",
            bot: "1",
            minor: "1",
            title: args.params.page,
            summary: args.summary,
            text: newtext,
            basetimestamp: args.timestamp,
            token: args.edittoken
          }, this.checkWrite, args, null);
        } else {
          this.WM.Log.logInfo(this.WM.Log.linkToWikiPage(args.params.page, args.params.page) + ' is already up to date');
          return this.iteratePages(args.pageid, args.callNext);
        }
      }
    }, {
      key: 'checkWrite',
      value: function checkWrite(res, args) {
        boundMethodCheck(this, ref);
        if (res.edit && res.edit.result === 'Success') {
          this.WM.Log.logInfo(this.WM.Log.linkToWikiPage(args.params.page, args.params.page) + ' correctly updated');
          return this.iteratePages(args.pageid, args.callNext);
        } else {
          return this.WM.Log.logError(this.WM.Log.linkToWikiPage(args.params.page, args.params.page) + ' has not been updated!\n' + res['error']['info'] + " (" + res['error']['code'] + ")");
        }
      }
    }]);

    return UpdateCategoryTree;
  }(Plugin);

  ;

  UpdateCategoryTree.conf_default = {
    enabled: false,
    special_menu: ["Update category trees"],
    edit_summary: "automatic update",
    show_root_also_in: false,
    pages: []
  };

  UpdateCategoryTree.wiki_to_conf_default = {
    ArchWiki: {
      pages: ["ar", "cs", "cs", "da", "el", "en", "es", "he", "hr", "hu", "id", "it", "ko", "lt", "nl", "pl", "pt", "ru", "sk", "sr", "th", "tr", "uk", "zh-hans", "zh-hant"]
    },
    Wikipedia: {}
  };

  return UpdateCategoryTree;
}.call(undefined);

},{"./_Plugin":434,"@kynikos/misc/dist/Str":7}],434:[function(require,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

module.exports.Plugin = function () {
  var Plugin = function () {
    _createClass(Plugin, null, [{
      key: "__configure",
      value: function __configure(wiki_name, user_config) {
        var option, ref, value;

        this.prototype.conf = {};
        if (this.conf_default != null) {
          $.extend(this.prototype.conf, this.conf_default);
        }
        if (this.wiki_to_conf_default != null && wiki_name in this.wiki_to_conf_default) {
          $.extend(this.prototype.conf, this.wiki_to_conf_default[wiki_name]);
        }
        if (this.name in user_config) {
          ref = user_config[this.name];

          for (option in ref) {
            value = ref[option];
            if (!(option in this.prototype.conf)) {
              continue;
            }
            this.prototype.conf[option] = value;
            delete user_config[this.name][option];
          }
        }
        if (!this.prototype.conf.enabled) {
          delete user_config[this.name];

          throw new Error("Plugin disabled");
        }
        if ($.isEmptyObject(user_config[this.name])) {
          return delete user_config[this.name];
        }
      }
    }]);

    function Plugin(WM) {
      _classCallCheck(this, Plugin);

      this.WM = WM;
    }

    return Plugin;
  }();

  ;

  Plugin.prototype.main_bot = null;

  Plugin.prototype.main_diff = null;

  Plugin.prototype.main_editor = null;

  Plugin.prototype.main_newpages = null;

  Plugin.prototype.main_recentchanges = null;

  Plugin.prototype.main_special = null;

  return Plugin;
}.call(undefined);

},{}]},{},[396])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvQGt5bmlrb3MvbWlzYy9kaXN0L0FzeW5jLmpzIiwibm9kZV9tb2R1bGVzL0BreW5pa29zL21pc2MvZGlzdC9DU1MuanMiLCJub2RlX21vZHVsZXMvQGt5bmlrb3MvbWlzYy9kaXN0L0NvbXBhdGliaWxpdHkuanMiLCJub2RlX21vZHVsZXMvQGt5bmlrb3MvbWlzYy9kaXN0L0hUVFAuanMiLCJub2RlX21vZHVsZXMvQGt5bmlrb3MvbWlzYy9kaXN0L09iai5qcyIsIm5vZGVfbW9kdWxlcy9Aa3luaWtvcy9taXNjL2Rpc3QvUmVnRXguanMiLCJub2RlX21vZHVsZXMvQGt5bmlrb3MvbWlzYy9kaXN0L1N0ci5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1wb2x5ZmlsbC9saWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcG9seWZpbGwvbm9kZV9tb2R1bGVzL3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyLXJlc29sdmUvZW1wdHkuanMiLCJub2RlX21vZHVsZXMvYnJvd3Nlci1zcGxpdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jbGFzcy1saXN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvZm4vcmVnZXhwL2VzY2FwZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2EtZnVuY3Rpb24uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hLW51bWJlci12YWx1ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FkZC10by11bnNjb3BhYmxlcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FuLWluc3RhbmNlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYW4tb2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYXJyYXktY29weS13aXRoaW4uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hcnJheS1maWxsLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYXJyYXktZnJvbS1pdGVyYWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FycmF5LWluY2x1ZGVzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYXJyYXktbWV0aG9kcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FycmF5LXJlZHVjZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FycmF5LXNwZWNpZXMtY29uc3RydWN0b3IuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hcnJheS1zcGVjaWVzLWNyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2JpbmQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jbGFzc29mLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY29mLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY29sbGVjdGlvbi1zdHJvbmcuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jb2xsZWN0aW9uLXRvLWpzb24uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jb2xsZWN0aW9uLXdlYWsuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jb2xsZWN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY29yZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NyZWF0ZS1wcm9wZXJ0eS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2N0eC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2RhdGUtdG8taXNvLXN0cmluZy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2RhdGUtdG8tcHJpbWl0aXZlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZGVmaW5lZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2Rlc2NyaXB0b3JzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZG9tLWNyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2VudW0tYnVnLWtleXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19lbnVtLWtleXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19leHBvcnQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19mYWlscy1pcy1yZWdleHAuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19mYWlscy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2ZpeC1yZS13a3MuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19mbGFncy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2ZsYXR0ZW4taW50by1hcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2Zvci1vZi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2dsb2JhbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2hhcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2hpZGUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19odG1sLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faWU4LWRvbS1kZWZpbmUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pbmhlcml0LWlmLXJlcXVpcmVkLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faW52b2tlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faW9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2lzLWFycmF5LWl0ZXIuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pcy1hcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2lzLWludGVnZXIuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pcy1vYmplY3QuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pcy1yZWdleHAuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pdGVyLWNhbGwuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pdGVyLWNyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2l0ZXItZGVmaW5lLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXRlci1kZXRlY3QuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pdGVyLXN0ZXAuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pdGVyYXRvcnMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19saWJyYXJ5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fbWF0aC1leHBtMS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX21hdGgtZnJvdW5kLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fbWF0aC1sb2cxcC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX21hdGgtc2NhbGUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19tYXRoLXNpZ24uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19tZXRhLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fbWV0YWRhdGEuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19taWNyb3Rhc2suanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19uZXctcHJvbWlzZS1jYXBhYmlsaXR5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWFzc2lnbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1jcmVhdGUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZHAuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZHBzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWZvcmNlZC1wYW0uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ29wZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1nb3BuLWV4dC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1nb3BuLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdvcHMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ3BvLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWtleXMtaW50ZXJuYWwuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3Qta2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1waWUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3Qtc2FwLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LXRvLWFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb3duLWtleXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19wYXJzZS1mbG9hdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3BhcnNlLWludC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3BlcmZvcm0uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19wcm9taXNlLXJlc29sdmUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19wcm9wZXJ0eS1kZXNjLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fcmVkZWZpbmUtYWxsLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fcmVkZWZpbmUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19yZXBsYWNlci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NhbWUtdmFsdWUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zZXQtY29sbGVjdGlvbi1mcm9tLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc2V0LWNvbGxlY3Rpb24tb2YuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zZXQtcHJvdG8uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zZXQtc3BlY2llcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NldC10by1zdHJpbmctdGFnLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc2hhcmVkLWtleS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NoYXJlZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NwZWNpZXMtY29uc3RydWN0b3IuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zdHJpY3QtbWV0aG9kLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLWF0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLWNvbnRleHQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zdHJpbmctaHRtbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy1wYWQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zdHJpbmctcmVwZWF0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLXRyaW0uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zdHJpbmctd3MuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190YXNrLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8tYWJzb2x1dGUtaW5kZXguanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLWludGVnZXIuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1pb2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8tbGVuZ3RoLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8tb2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8tcHJpbWl0aXZlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdHlwZWQtYXJyYXkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190eXBlZC1idWZmZXIuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190eXBlZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3VpZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3ZhbGlkYXRlLWNvbGxlY3Rpb24uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL193a3MtZGVmaW5lLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fd2tzLWV4dC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3drcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9jb3JlLnJlZ2V4cC5lc2NhcGUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5jb3B5LXdpdGhpbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmV2ZXJ5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZmlsbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmZpbHRlci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmZpbmQtaW5kZXguanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5maW5kLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZm9yLWVhY2guanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5mcm9tLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuaW5kZXgtb2YuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5pcy1hcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5Lml0ZXJhdG9yLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuam9pbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5Lmxhc3QtaW5kZXgtb2YuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5tYXAuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5vZi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LnJlZHVjZS1yaWdodC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LnJlZHVjZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LnNsaWNlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuc29tZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LnNvcnQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5zcGVjaWVzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuZGF0ZS5ub3cuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5kYXRlLnRvLWlzby1zdHJpbmcuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5kYXRlLnRvLWpzb24uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5kYXRlLnRvLXByaW1pdGl2ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmRhdGUudG8tc3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuZnVuY3Rpb24uYmluZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmZ1bmN0aW9uLmhhcy1pbnN0YW5jZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmZ1bmN0aW9uLm5hbWUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXAuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmFjb3NoLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5hc2luaC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguYXRhbmguanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmNicnQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmNsejMyLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5jb3NoLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5leHBtMS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguZnJvdW5kLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5oeXBvdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguaW11bC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGgubG9nMTAuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmxvZzFwLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5sb2cyLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5zaWduLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5zaW5oLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC50YW5oLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC50cnVuYy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5jb25zdHJ1Y3Rvci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5lcHNpbG9uLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLmlzLWZpbml0ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5pcy1pbnRlZ2VyLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLmlzLW5hbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5pcy1zYWZlLWludGVnZXIuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIubWF4LXNhZmUtaW50ZWdlci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5taW4tc2FmZS1pbnRlZ2VyLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLnBhcnNlLWZsb2F0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLnBhcnNlLWludC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci50by1maXhlZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci50by1wcmVjaXNpb24uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuYXNzaWduLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmNyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydGllcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydHkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuZnJlZXplLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtb3duLXByb3BlcnR5LW5hbWVzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmdldC1wcm90b3R5cGUtb2YuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuaXMtZXh0ZW5zaWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5pcy1mcm96ZW4uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuaXMtc2VhbGVkLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmlzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmtleXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QucHJldmVudC1leHRlbnNpb25zLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LnNlYWwuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3Quc2V0LXByb3RvdHlwZS1vZi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC50by1zdHJpbmcuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5wYXJzZS1mbG9hdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnBhcnNlLWludC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnByb21pc2UuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmFwcGx5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5jb25zdHJ1Y3QuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmRlZmluZS1wcm9wZXJ0eS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZGVsZXRlLXByb3BlcnR5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5lbnVtZXJhdGUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZ2V0LXByb3RvdHlwZS1vZi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZ2V0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5oYXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmlzLWV4dGVuc2libGUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0Lm93bi1rZXlzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5wcmV2ZW50LWV4dGVuc2lvbnMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LnNldC1wcm90b3R5cGUtb2YuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LnNldC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5jb25zdHJ1Y3Rvci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5mbGFncy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5tYXRjaC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5yZXBsYWNlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLnNlYXJjaC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5zcGxpdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC50by1zdHJpbmcuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zZXQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuYW5jaG9yLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmJpZy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5ibGluay5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5ib2xkLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmNvZGUtcG9pbnQtYXQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuZW5kcy13aXRoLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmZpeGVkLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmZvbnRjb2xvci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5mb250c2l6ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5mcm9tLWNvZGUtcG9pbnQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuaW5jbHVkZXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuaXRhbGljcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5saW5rLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnJhdy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5yZXBlYXQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuc21hbGwuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuc3RhcnRzLXdpdGguanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuc3RyaWtlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnN1Yi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5zdXAuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcudHJpbS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN5bWJvbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLmFycmF5LWJ1ZmZlci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLmRhdGEtdmlldy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLmZsb2F0MzItYXJyYXkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC5mbG9hdDY0LWFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQuaW50MTYtYXJyYXkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC5pbnQzMi1hcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLmludDgtYXJyYXkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC51aW50MTYtYXJyYXkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC51aW50MzItYXJyYXkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC51aW50OC1hcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLnVpbnQ4LWNsYW1wZWQtYXJyYXkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi53ZWFrLW1hcC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LndlYWstc2V0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuYXJyYXkuZmxhdC1tYXAuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5hcnJheS5mbGF0dGVuLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuYXJyYXkuaW5jbHVkZXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5hc2FwLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuZXJyb3IuaXMtZXJyb3IuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5nbG9iYWwuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5tYXAuZnJvbS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hcC5vZi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hcC50by1qc29uLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcubWF0aC5jbGFtcC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hdGguZGVnLXBlci1yYWQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5tYXRoLmRlZ3JlZXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5tYXRoLmZzY2FsZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hdGguaWFkZGguanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5tYXRoLmltdWxoLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcubWF0aC5pc3ViaC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hdGgucmFkLXBlci1kZWcuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5tYXRoLnJhZGlhbnMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5tYXRoLnNjYWxlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcubWF0aC5zaWduYml0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcubWF0aC51bXVsaC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm9iamVjdC5kZWZpbmUtZ2V0dGVyLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcub2JqZWN0LmRlZmluZS1zZXR0ZXIuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5vYmplY3QuZW50cmllcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3JzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcub2JqZWN0Lmxvb2t1cC1nZXR0ZXIuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5vYmplY3QubG9va3VwLXNldHRlci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm9iamVjdC52YWx1ZXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5vYnNlcnZhYmxlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcucHJvbWlzZS5maW5hbGx5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcucHJvbWlzZS50cnkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0LmRlZmluZS1tZXRhZGF0YS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QuZGVsZXRlLW1ldGFkYXRhLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcucmVmbGVjdC5nZXQtbWV0YWRhdGEta2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QuZ2V0LW1ldGFkYXRhLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcucmVmbGVjdC5nZXQtb3duLW1ldGFkYXRhLWtleXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0LmdldC1vd24tbWV0YWRhdGEuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0Lmhhcy1tZXRhZGF0YS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QuaGFzLW93bi1tZXRhZGF0YS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QubWV0YWRhdGEuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5zZXQuZnJvbS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnNldC5vZi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnNldC50by1qc29uLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuc3RyaW5nLmF0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuc3RyaW5nLm1hdGNoLWFsbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnN0cmluZy5wYWQtZW5kLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuc3RyaW5nLnBhZC1zdGFydC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnN0cmluZy50cmltLWxlZnQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5zdHJpbmcudHJpbS1yaWdodC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnN5bWJvbC5hc3luYy1pdGVyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnN5bWJvbC5vYnNlcnZhYmxlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuc3lzdGVtLmdsb2JhbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LndlYWstbWFwLmZyb20uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy53ZWFrLW1hcC5vZi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LndlYWstc2V0LmZyb20uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy53ZWFrLXNldC5vZi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvd2ViLmltbWVkaWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvd2ViLnRpbWVycy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL3NoaW0uanMiLCJub2RlX21vZHVsZXMvY3NzLXZlbmRvci9saWIvY2FtZWxpemUuanMiLCJub2RlX21vZHVsZXMvY3NzLXZlbmRvci9saWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY3NzLXZlbmRvci9saWIvcHJlZml4LmpzIiwibm9kZV9tb2R1bGVzL2Nzcy12ZW5kb3IvbGliL3N1cHBvcnRlZC1wcm9wZXJ0eS5qcyIsIm5vZGVfbW9kdWxlcy9jc3MtdmVuZG9yL2xpYi9zdXBwb3J0ZWQtdmFsdWUuanMiLCJub2RlX21vZHVsZXMvaHlwZXJzY3JpcHQtaGVscGVycy9kaXN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2h5cGVyc2NyaXB0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2luZGV4b2YvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXMtaW4tYnJvd3Nlci9kaXN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2pzcy1jYW1lbC1jYXNlL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9qc3MtY29tcG9zZS9saWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvanNzLWRlZmF1bHQtdW5pdC9saWIvZGVmYXVsdFVuaXRzLmpzIiwibm9kZV9tb2R1bGVzL2pzcy1kZWZhdWx0LXVuaXQvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2pzcy1leHBhbmQvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2pzcy1leHBhbmQvbGliL3Byb3BzLmpzIiwibm9kZV9tb2R1bGVzL2pzcy1leHRlbmQvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2pzcy1nbG9iYWwvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2pzcy1uZXN0ZWQvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2pzcy1wcmVzZXQtZGVmYXVsdC9saWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvanNzLXByb3BzLXNvcnQvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2pzcy10ZW1wbGF0ZS9saWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvanNzLXRlbXBsYXRlL2xpYi9wYXJzZS5qcyIsIm5vZGVfbW9kdWxlcy9qc3MtdmVuZG9yLXByZWZpeGVyL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9qc3MvbGliL0pzcy5qcyIsIm5vZGVfbW9kdWxlcy9qc3MvbGliL1BsdWdpbnNSZWdpc3RyeS5qcyIsIm5vZGVfbW9kdWxlcy9qc3MvbGliL1J1bGVMaXN0LmpzIiwibm9kZV9tb2R1bGVzL2pzcy9saWIvU2hlZXRzTWFuYWdlci5qcyIsIm5vZGVfbW9kdWxlcy9qc3MvbGliL1NoZWV0c1JlZ2lzdHJ5LmpzIiwibm9kZV9tb2R1bGVzL2pzcy9saWIvU3R5bGVTaGVldC5qcyIsIm5vZGVfbW9kdWxlcy9qc3MvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2pzcy9saWIvcGx1Z2lucy9mdW5jdGlvbnMuanMiLCJub2RlX21vZHVsZXMvanNzL2xpYi9wbHVnaW5zL29ic2VydmFibGVzLmpzIiwibm9kZV9tb2R1bGVzL2pzcy9saWIvcGx1Z2lucy9ydWxlcy5qcyIsIm5vZGVfbW9kdWxlcy9qc3MvbGliL3JlbmRlcmVycy9Eb21SZW5kZXJlci5qcyIsIm5vZGVfbW9kdWxlcy9qc3MvbGliL3JlbmRlcmVycy9WaXJ0dWFsUmVuZGVyZXIuanMiLCJub2RlX21vZHVsZXMvanNzL2xpYi9ydWxlcy9Db25kaXRpb25hbFJ1bGUuanMiLCJub2RlX21vZHVsZXMvanNzL2xpYi9ydWxlcy9Gb250RmFjZVJ1bGUuanMiLCJub2RlX21vZHVsZXMvanNzL2xpYi9ydWxlcy9LZXlmcmFtZXNSdWxlLmpzIiwibm9kZV9tb2R1bGVzL2pzcy9saWIvcnVsZXMvU2ltcGxlUnVsZS5qcyIsIm5vZGVfbW9kdWxlcy9qc3MvbGliL3J1bGVzL1N0eWxlUnVsZS5qcyIsIm5vZGVfbW9kdWxlcy9qc3MvbGliL3J1bGVzL1ZpZXdwb3J0UnVsZS5qcyIsIm5vZGVfbW9kdWxlcy9qc3MvbGliL3NoZWV0cy5qcyIsIm5vZGVfbW9kdWxlcy9qc3MvbGliL3V0aWxzL2Nsb25lU3R5bGUuanMiLCJub2RlX21vZHVsZXMvanNzL2xpYi91dGlscy9jcmVhdGVHZW5lcmF0ZUNsYXNzTmFtZS5qcyIsIm5vZGVfbW9kdWxlcy9qc3MvbGliL3V0aWxzL2NyZWF0ZVJ1bGUuanMiLCJub2RlX21vZHVsZXMvanNzL2xpYi91dGlscy9lc2NhcGUuanMiLCJub2RlX21vZHVsZXMvanNzL2xpYi91dGlscy9nZXREeW5hbWljU3R5bGVzLmpzIiwibm9kZV9tb2R1bGVzL2pzcy9saWIvdXRpbHMvaXNPYnNlcnZhYmxlLmpzIiwibm9kZV9tb2R1bGVzL2pzcy9saWIvdXRpbHMva2ViYWJDYXNlLmpzIiwibm9kZV9tb2R1bGVzL2pzcy9saWIvdXRpbHMvbGlua1J1bGUuanMiLCJub2RlX21vZHVsZXMvanNzL2xpYi91dGlscy9tb2R1bGVJZC5qcyIsIm5vZGVfbW9kdWxlcy9qc3MvbGliL3V0aWxzL3RvQ3NzLmpzIiwibm9kZV9tb2R1bGVzL2pzcy9saWIvdXRpbHMvdG9Dc3NWYWx1ZS5qcyIsIm5vZGVfbW9kdWxlcy9tb21lbnQvbW9tZW50LmpzIiwibm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9zeW1ib2wtb2JzZXJ2YWJsZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zeW1ib2wtb2JzZXJ2YWJsZS9saWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc3ltYm9sLW9ic2VydmFibGUvbGliL3BvbnlmaWxsLmpzIiwibm9kZV9tb2R1bGVzL3dhcm5pbmcvYnJvd3Nlci5qcyIsInBhY2thZ2UuanNvbiIsInNyYy9fbG9jYWwuY29mZmVlIiwic3JjL21vZHVsZXMvQXJjaFdpa2kuY29mZmVlIiwic3JjL21vZHVsZXMvQm90LmNvZmZlZSIsInNyYy9tb2R1bGVzL0NhdC5jb2ZmZWUiLCJzcmMvbW9kdWxlcy9EaWZmLmNvZmZlZSIsInNyYy9tb2R1bGVzL0VkaXRvci5jb2ZmZWUiLCJzcmMvbW9kdWxlcy9GaWx0ZXJzLmNvZmZlZSIsInNyYy9tb2R1bGVzL0ludGVybGFuZ3VhZ2UuY29mZmVlIiwic3JjL21vZHVsZXMvTG9nLmNvZmZlZSIsInNyYy9tb2R1bGVzL01XLmNvZmZlZSIsInNyYy9tb2R1bGVzL01lbnUuY29mZmVlIiwic3JjL21vZHVsZXMvTW9kcy5jb2ZmZWUiLCJzcmMvbW9kdWxlcy9QYXJzZXIuY29mZmVlIiwic3JjL21vZHVsZXMvVGFibGVzLmNvZmZlZSIsInNyYy9tb2R1bGVzL1VJLmNvZmZlZSIsInNyYy9tb2R1bGVzL1VwZ3JhZGUuY29mZmVlIiwic3JjL21vZHVsZXMvV2hhdExpbmtzSGVyZS5jb2ZmZWUiLCJzcmMvbW9kdWxlcy9fSW5pdC5jb2ZmZWUiLCJzcmMvbW9kdWxlcy9saWJzLmNvZmZlZSIsInNyYy9wbHVnaW5zL0FyY2hXaWtpRml4SGVhZGVyLmNvZmZlZSIsInNyYy9wbHVnaW5zL0FyY2hXaWtpRml4SGVhZGluZ3MuY29mZmVlIiwic3JjL3BsdWdpbnMvQXJjaFdpa2lGaXhMaW5rcy5jb2ZmZWUiLCJzcmMvcGx1Z2lucy9BcmNoV2lraU5QRmlsdGVyLmNvZmZlZSIsInNyYy9wbHVnaW5zL0FyY2hXaWtpTmV3VGVtcGxhdGVzLmNvZmZlZSIsInNyYy9wbHVnaW5zL0FyY2hXaWtpUkNGaWx0ZXIuY29mZmVlIiwic3JjL3BsdWdpbnMvQXJjaFdpa2lTYXZlVGFsay5jb2ZmZWUiLCJzcmMvcGx1Z2lucy9BcmNoV2lraVNvcnRDb250YWN0cy5jb2ZmZWUiLCJzcmMvcGx1Z2lucy9BcmNoV2lraVdhbnRlZENhdGVnb3JpZXMuY29mZmVlIiwic3JjL3BsdWdpbnMvRGVsZXRlUGFnZXMuY29mZmVlIiwic3JjL3BsdWdpbnMvRXhwYW5kQ29udHJhY3Rpb25zLmNvZmZlZSIsInNyYy9wbHVnaW5zL0ZpeEJhY2tsaW5rRnJhZ21lbnRzLmNvZmZlZSIsInNyYy9wbHVnaW5zL0ZpeERvdWJsZVJlZGlyZWN0cy5jb2ZmZWUiLCJzcmMvcGx1Z2lucy9GaXhGcmFnbWVudHMuY29mZmVlIiwic3JjL3BsdWdpbnMvRml4TGlua0ZyYWdtZW50cy5jb2ZmZWUiLCJzcmMvcGx1Z2lucy9NdWx0aXBsZUxpbmVCcmVha3MuY29mZmVlIiwic3JjL3BsdWdpbnMvU2ltcGxlUmVwbGFjZS5jb2ZmZWUiLCJzcmMvcGx1Z2lucy9TeW5jaHJvbml6ZUludGVybGFuZ3VhZ2VMaW5rcy5jb2ZmZWUiLCJzcmMvcGx1Z2lucy9VcGRhdGVDYXRlZ29yeVRyZWUuY29mZmVlIiwic3JjL3BsdWdpbnMvX1BsdWdpbi5jb2ZmZWUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMxTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNodUJBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25HQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckZBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7O0FDREE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcFJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTs7QUNEQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3REQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDOWFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN4REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdjdJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hMQTtBQUNBOzs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDL0JBLElBQUEsQUFrQkE7O2VBQU8sUUFsQlAsQUFrQkEsQUFBTyxBQUFROztBQUFmLEFBQUM7O0FBRUQsSUFBQSxBQUFJLEdBQUosQUFDSSxZQUlBLFFBTEosQUFLSSxBQUFRLGdDQUNSLFFBTkosQUFNSSxBQUFRLGtDQUNSLFFBUEosQUFPSSxBQUFRLCtCQUNSLFFBUkosQUFRSSxBQUFRLG1DQUNSLFFBVEosQUFTSSxBQUFRLCtCQUNSLFFBVkosQUFVSSxBQUFRLCtCQUNSLFFBWEosQUFXSSxBQUFRLCtCQUNSLFFBWkosQUFZSSxBQUFRLG1DQUdSLFFBZkosQUFlSSxBQUFRLHVDQUNSLFFBaEJKLEFBZ0JJLEFBQVEsMEJBQ1IsUUFqQkosQUFpQkksQUFBUSxpQ0FDUixRQWxCSixBQWtCSSxBQUFRLG1DQUNSLFFBbkJKLEFBbUJJLEFBQVEsaUNBQ1IsUUFwQkosQUFvQkksQUFBUSwyQkFDUixRQXJCSixBQXFCSSxBQUFRLCtCQUNSLFFBdEJKLEFBc0JJLEFBQVEsaUNBQ1IsUUF2QkosQUF1QkksQUFBUSw0QkFDUixRQXhCSixBQXdCSSxBQUFRLDRDQUNSLFFBekJKLEFBeUJJLEFBQVE7Ozs7Ozs7OztBQzFCTixBQUFNLE9BQUM7aUJBQWI7O01BQUE7QUFDSSxBQUFhLHFCQUFBOzs7QUFBQyxBQUFDLFdBQUEsS0FBRjtBQWdWYixBQUFrQjs7Ozt5Q0FDZDtlQUFPLEFBQVMsVUFERixBQUNHO0FBRXJCLEFBQXNCOzs7NkNBQ2xCO2VBQU8sQUFBUyxVQURFLEFBQ0Q7QUFFckIsQUFBb0I7Ozt5Q0FBQSxBQUFDLE1BQ2pCO2VBQU8sQUFBUyxVQUFDLEFBQVUsV0FBcEIsQUFBcUIsUUFBckIsQUFBNkIsUUFBUSxDQUQ1QixBQUM2QjtBQUVqRCxBQUF1Qjs7OzhDQUNuQjtlQUFPLEFBQVMsVUFBQyxBQUFhLGNBQUMsQUFBUSxTQUFoQyxBQUFpQyxPQUNKLEFBQVMsVUFBQyxBQUFhLGNBRnhDLEFBQ1osQUFDcUQ7QUFFaEUsQUFBcUI7OzswQ0FBQSxBQUFDLE1BQ2xCO2VBQU8sQUFBSSxLQUFKLEFBQUssQUFBdUIsd0JBQTVCLEFBQTZCLFFBQTdCLEFBQXFDLFFBQVEsQ0FEbkMsQUFDb0M7QUFFekQsQUFBK0I7OztzREFDM0I7ZUFBTyxBQUFTLFVBQUMsQUFBYSxjQURILEFBQ0k7QUFFbkMsQUFBNkI7OztrREFBQSxBQUFDLE1BQzFCO2VBQU8sQUFBUyxVQUFDLEFBQWEsY0FBQyxBQUFRLFNBQWhDLEFBQWlDLFFBQWpDLEFBQXlDLFFBQVEsQ0FEL0IsQUFDZ0M7QUFFN0QsQUFBcUI7OzswQ0FBQSxBQUFDLFVBQ2xCO2VBQU8sQUFBUyxVQUFDLEFBQU0sTUFBQSxBQUFTLFVBRGYsQUFDZ0I7QUFFckMsQUFBZ0I7OztxQ0FBQSxBQUFDLE9BQ2I7WUFBQSxrQkFBQSxTQUFBLFdBQUE7QUFBQSxrQkFBVSxBQUFLLE1BQUwsQUFBTSxNQUFOLEFBQVk7QUFDdEIsb0JBQVksQUFBUSxRQUFBO0FBQ3BCLDJCQUFtQixBQUFRLFFBQUE7QUFFM0IsWUFBRyxDQUFBLEFBQUksb0JBQW9CLENBQUksQUFBQyxLQUFELEFBQUMsbUJBQWhDLEFBQStCLEFBQ2lCO0FBSzVDLHdCQUFjLEFBQVEsUUFBQSxBQUFFLEdBQVYsQUFBVyxNQUFYLEFBQ1U7QUFDeEIsY0FBRyxlQUFnQixBQUFDLEtBQUQsQUFBQyxtQkFBbUIsQUFBWSxZQUFuRCxBQUFtQixBQUFnQztBQUMvQywrQkFBbUIsQUFBWSxZQUFBO0FBQy9CLHdCQUFZLEFBQVEsUUFGeEIsQUFFd0I7QUFGeEIsaUJBQUE7QUFJSSwrQkFBbUIsQUFBSSxLQUFKLEFBQUs7QUFDeEIsd0JBQVksQUFBUSxRQUx4QixBQUt3QjtBQWI1QjtBQWVBO2VBQU8sQ0FBQSxBQUFDLFdBcEJJLEFBb0JMLEFBQVk7QUFFdkIsQUFBMkI7OztnREFBQSxBQUFDLFFBQUQsQUFFdkI7ZUFBTyxBQUFDLEtBQUEsQUFBRSxHQUFDLEFBQU0sT0FBVixBQUFXLGlCQUFYLEFBQTRCLFFBQ1AsQUFBSSxLQUFKLEFBQUssQUFBdUIsd0JBQTVCLEFBQTZCLEtBSGxDLEFBRWhCLEFBQ3FCLEFBQWtDO0FBRWxFLEFBQWdDOzs7cURBQUEsQUFBQyxRQUFELEFBRTVCO2VBQU8sQUFBQyxLQUFBLEFBQUUsR0FBQyxBQUFNLE9BQVYsQUFBVyxpQkFBWCxBQUE0QixRQUNmLEFBQUksS0FBSixBQUFLLEFBQStCLGdDQUFwQyxBQUFxQyxLQUg3QixBQUVyQixBQUNhLEFBQTBDO0FBRWxFLEFBQW9COzs7eUNBQUEsQUFBQyxLQUNqQjtlQUFPLEFBQWlCLGlCQURSLEFBQ1E7QUEzWWhDOzs7Ozs7OztBQUdJO0FBQ0ksV0FEUSxBQUNEO0FBQ1A7QUFDSTtBQUFZLGdCQUFELEFBQVM7QUFBTSxpQkFEdkIsQUFDUSxBQUF3QjtBQUF4QjtBQUNYO0FBQWMsZ0JBQUQsQUFBUztBQUFNLGlCQUZ6QixBQUVVLEFBQXdCO0FBQXhCO0FBQ2I7QUFBVyxnQkFBRCxBQUFTO0FBQU0saUJBSHRCLEFBR08sQUFBd0I7QUFBeEI7QUFDVjtBQUFVLGdCQUFELEFBQVM7QUFBTSxpQkFKckIsQUFJTSxBQUF3QjtBQUF4QjtBQUNUO0FBQVUsZ0JBQUQsQUFBUztBQUFNLGlCQUxyQixBQUtNLEFBQXdCO0FBQXhCO0FBQ1Q7QUFBWSxnQkFBRCxBQUFTO0FBQU0saUJBTnZCLEFBTVEsQUFBd0I7QUFBeEI7QUFDWDtBQUFhLGdCQUFELEFBQVM7QUFBTSxpQkFQeEIsQUFPUyxBQUF3QjtBQUF4QjtBQUNaO0FBQVksZ0JBQUQsQUFBUztBQUFNLGlCQVJ2QixBQVFRLEFBQXdCO0FBQXhCO0FBQ1g7QUFBYyxnQkFBRCxBQUFTO0FBQU0saUJBVHpCLEFBU1UsQUFBd0I7QUFBeEI7QUFDYjtBQUFZLGdCQUFELEFBQVM7QUFBTSxpQkFWdkIsQUFVUSxBQUF3QjtBQUF4QjtBQUNYO0FBQVUsZ0JBQUQsQUFBUztBQUFNLGlCQVhyQixBQVdNLEFBQXdCO0FBQXhCO0FBQ1Q7QUFBVSxnQkFBRCxBQUFTO0FBQU0saUJBWnJCLEFBWU0sQUFBd0I7QUFBeEI7QUFDVDtBQUFhLGdCQUFELEFBQVM7QUFBTSxpQkFieEIsQUFhUyxBQUF3QjtBQUF4QjtBQUNaO0FBQVUsZ0JBQUQsQUFBUztBQUFNLGlCQWRyQixBQWNNLEFBQXdCO0FBQXhCO0FBQ1Q7QUFBYSxnQkFBRCxBQUFTO0FBQU0saUJBZnhCLEFBZVMsQUFBd0I7QUFBeEI7QUFDWjtBQUFXLGdCQUFELEFBQVM7QUFBTSxpQkFoQnRCLEFBZ0JPLEFBQXdCO0FBQXhCO0FBQ1Y7QUFBYyxnQkFBRCxBQUFTO0FBQU0saUJBakJ6QixBQWlCVSxBQUF3QjtBQUF4QjtBQUNiO0FBQWEsZ0JBQUQsQUFBUztBQUFNLGlCQWxCeEIsQUFrQlMsQUFBd0I7QUFBeEI7QUFDWjtBQUFRLGdCQUFELEFBQVM7QUFBTSxpQkFuQm5CLEFBbUJJLEFBQXdCO0FBQXhCO0FBQ1A7QUFBUSxnQkFBRCxBQUFTO0FBQU0saUJBcEJuQixBQW9CSSxBQUF3QjtBQUF4QjtBQUNQO0FBQWdCLGdCQUFELEFBQVM7QUFBTSxpQkFyQjNCLEFBcUJZLEFBQXdCO0FBQXhCO0FBQ2Y7QUFBaUIsZ0JBQUQsQUFBUztBQUFNLGlCQXRCNUIsQUFzQmEsQUFBd0I7QUFBeEI7QUFDaEI7QUFBZSxnQkFBRCxBQUFTO0FBQU0saUJBdkIxQixBQXVCVyxBQUF3QjtBQUF4QjtBQUNkO0FBQVcsZ0JBQUQsQUFBUztBQUFNLGlCQXhCdEIsQUF3Qk8sQUFBd0I7QUFBeEI7QUFDVjtBQUFjLGdCQUFELEFBQVM7QUFBTSxpQkF6QnpCLEFBeUJVLEFBQXdCO0FBQXhCO0FBQ2I7QUFBVyxnQkFBRCxBQUFTO0FBQU0saUJBMUJ0QixBQTBCTyxBQUF3QjtBQUF4QjtBQUNWO0FBQVksZ0JBQUQsQUFBUztBQUFNLGlCQTNCdkIsQUEyQlEsQUFBd0I7QUFBeEI7QUFDWDtBQUFjLGdCQUFELEFBQVM7QUFBTSxpQkE1QnpCLEFBNEJVLEFBQXdCO0FBQXhCO0FBQ2I7QUFBVyxnQkFBRCxBQUFTO0FBQU0saUJBN0J0QixBQTZCTyxBQUF3QjtBQUF4QjtBQUNWO0FBQVksZ0JBQUQsQUFBUztBQUFNLGlCQTlCdkIsQUE4QlEsQUFBd0I7QUFBeEI7QUFDWDtBQUFRLGdCQUFELEFBQVM7QUFBTSxpQkEvQm5CLEFBK0JJLEFBQXdCO0FBQXhCO0FBQ1A7QUFBVyxnQkFBRCxBQUFTO0FBQU0saUJBaEN0QixBQWdDTyxBQUF3QjtBQUF4QjtBQUNWO0FBQWUsZ0JBQUQsQUFBUztBQUFNLGlCQWpDMUIsQUFpQ1csQUFBd0I7QUFBeEI7QUFDZDtBQUFlLGdCQUFELEFBQVM7QUFBTSxpQkFsQzFCLEFBa0NXLEFBQXdCO0FBQXhCO0FBQ2Q7QUFBUyxnQkFBRCxBQUFTO0FBQVcsaUJBbkN6QixBQW1DSyxBQUE2QjtBQUE3QjtBQUNSO0FBQVMsZ0JBQUQsQUFBUztBQUFXLGlCQXRDeEIsQUFFRCxBQW9DSyxBQUE2QjtBQUE3QjtBQXBDTDtBQXNDUCxnQkFBWSxDQUFBLEFBQ1IsV0FEUSxBQUVSLGFBRlEsQUFHUixVQUhRLEFBSVIsU0FKUSxBQUtSLFNBTFEsQUFNUixZQU5RLEFBT1IsV0FQUSxBQVFSLGFBUlEsQUFTUixXQVRRLEFBVVIsU0FWUSxBQVdSLFNBWFEsQUFZUixZQVpRLEFBYVIsVUFiUSxBQWNSLGFBZFEsQUFlUixZQWZRLEFBZ0JSLE9BaEJRLEFBaUJSLE9BakJRLEFBa0JSLGVBbEJRLEFBbUJSLGdCQW5CUSxBQW9CUixjQXBCUSxBQXFCUixVQXJCUSxBQXNCUixhQXRCUSxBQXVCUixXQXZCUSxBQXdCUixhQXhCUSxBQXlCUixVQXpCUSxBQTBCUixPQTFCUSxBQTJCUixVQTNCUSxBQTRCUixjQTVCUSxBQTZCUixRQXJFSSxBQXdDSSxBQThCUjtBQUVKO0FBQ0ksZ0JBQVUsQ0FBQSxBQUFDLE1BQUQsQUFBTyxNQUFQLEFBQWEsTUFBYixBQUFtQixNQURsQixBQUNELEFBQXlCO0FBQ25DLGdCQUFVLENBQUEsQUFBQyxNQUFELEFBQU8sTUFBUCxBQUFhLE1BQWIsQUFBbUIsTUFBbkIsQUFBeUIsTUFBekIsQUFBK0IsTUFBL0IsQUFBcUMsTUFBckMsQUFBMkMsTUFBM0MsQUFBaUQsTUFBakQsQUFDQyxNQURELEFBQ08sTUFEUCxBQUNhLE1BRGIsQUFDbUIsTUFEbkIsQUFDeUIsTUFEekIsQUFDK0IsTUFEL0IsQUFDcUMsTUFEckMsQUFDMkMsTUFEM0MsQUFDaUQsTUFEakQsQUFFQyxNQUZELEFBRU8sTUFGUCxBQUVhLE1BRmIsQUFFbUIsTUFGbkIsQUFFeUIsTUFGekIsQUFFK0IsTUFGL0IsQUFFcUMsTUFGckMsQUFFMkMsV0E1RWpELEFBd0VPLEFBRUQsQUFHQztBQUxBO0FBeEVQOztBQWlGWjtBQUNJO0FBQ0ksY0FERSxBQUNNO0FBQ1IsY0FGRSxBQUVNO0FBQ1IsZ0JBSEUsQUFHUTtBQUNWLG9CQUpFLEFBSVk7QUFDZCxpQkFBVyxDQUFBLEFBQUMscUJBQUQsQUFBc0IsSUFML0IsQUFLUyxBQUEwQjtBQUNyQyxxQkFORSxBQU1hO0FBQ2YscUJBUEUsQUFPYTtBQUNmLHFCQVRXLEFBQ1QsQUFRYTtBQVJiO0FBVU47QUFDSSxjQURFLEFBQ007QUFDUixjQUZFLEFBRU07QUFDUixnQkFIRSxBQUdRO0FBQ1Ysb0JBSkUsQUFJWTtBQUNkLGlCQUFXLENBQUEsQUFBQyx1QkFBRCxBQUF3QixJQUxqQyxBQUtTLEFBQTRCO0FBQ3ZDLHFCQU5FLEFBTWE7QUFDZixxQkFQRSxBQU9hO0FBQ2YscUJBbkJXLEFBV1QsQUFRYTtBQVJiO0FBVU47QUFDSSxjQURFLEFBQ007QUFDUixjQUZFLEFBRU07QUFDUixnQkFIRSxBQUdRO0FBQ1Ysb0JBSkUsQUFJWTtBQUNkLGlCQUFXLENBQUEsQUFBQyxtQkFBRCxBQUFvQixJQUw3QixBQUtTLEFBQXdCO0FBQ25DLHFCQU5FLEFBTWE7QUFDZixxQkFQRSxBQU9hO0FBQ2YscUJBN0JXLEFBcUJULEFBUWE7QUFSYjtBQVVOO0FBQ0ksY0FERSxBQUNNO0FBQ1IsY0FGRSxBQUVNO0FBQ1IsZ0JBSEUsQUFHUTtBQUNWLG9CQUpFLEFBSVk7QUFDZCxpQkFBVyxDQUFBLEFBQUMsbUJBQUQsQUFBb0IsSUFMN0IsQUFLUyxBQUF3QjtBQUNuQyxxQkFORSxBQU1hO0FBQ2YscUJBUEUsQUFPYTtBQUNmLHFCQXZDVyxBQStCVCxBQVFhO0FBUmI7QUFVTjtBQUNJLGNBREUsQUFDTTtBQUNSLGNBRkUsQUFFTTtBQUNSLGdCQUhFLEFBR1E7QUFDVixvQkFKRSxBQUlZO0FBQ2QsaUJBQVcsQ0FBQSxBQUFDLHNCQUFELEFBQXVCLElBTGhDLEFBS1MsQUFBMkI7QUFDdEMscUJBTkUsQUFNYTtBQUNmLHFCQVBFLEFBT2E7QUFDZixxQkFqRFcsQUF5Q1QsQUFRYTtBQVJiO0FBVU47QUFDSSxjQURFLEFBQ007QUFDUixjQUZFLEFBRU07QUFDUixnQkFIRSxBQUdRO0FBQ1Ysb0JBSkUsQUFJWTtBQUNkLGlCQUxFLEFBS1M7QUFDWCxxQkFORSxBQU1hO0FBQ2YscUJBUEUsQUFPYTtBQUNmLHFCQTNEVyxBQW1EVCxBQVFhO0FBUmI7QUFVTjtBQUNJLGNBREUsQUFDTTtBQUNSLGNBRkUsQUFFTTtBQUNSLGdCQUhFLEFBR1E7QUFDVixvQkFKRSxBQUlZO0FBQ2QsaUJBQVcsQ0FBQSxBQUFDLHFCQUFELEFBQXNCLElBTC9CLEFBS1MsQUFBMEI7QUFDckMscUJBTkUsQUFNYTtBQUNmLHFCQVBFLEFBT2E7QUFDZixxQkFyRVcsQUE2RFQsQUFRYTtBQVJiO0FBVU47QUFDSSxjQURFLEFBQ007QUFDUixjQUZFLEFBRU07QUFDUixnQkFIRSxBQUdRO0FBQ1Ysb0JBSkUsQUFJWTtBQUNkLGlCQUFXLENBQUEsQUFBQyxtQkFBRCxBQUFvQixJQUw3QixBQUtTLEFBQXdCO0FBQ25DLHFCQU5FLEFBTWE7QUFDZixxQkFQRSxBQU9hO0FBQ2YscUJBL0VXLEFBdUVULEFBUWE7QUFSYjtBQVVOO0FBQ0ksY0FERSxBQUNNO0FBQ1IsY0FGRSxBQUVNO0FBQ1IsZ0JBSEUsQUFHUTtBQUNWLG9CQUpFLEFBSVk7QUFDZCxpQkFBVyxDQUFBLEFBQUMsc0JBQUQsQUFBdUIsSUFMaEMsQUFLUyxBQUEyQjtBQUN0QyxxQkFORSxBQU1hO0FBQ2YscUJBUEUsQUFPYTtBQUNmLHFCQXpGVyxBQWlGVCxBQVFhO0FBUmI7QUFVTjtBQUNJLGNBREUsQUFDTTtBQUNSLGNBRkUsQUFFTTtBQUNSLGdCQUhFLEFBR1E7QUFDVixvQkFKRSxBQUlZO0FBQ2QsaUJBQVcsQ0FBQSxBQUFDLG9CQUFELEFBQXFCLElBTDlCLEFBS1MsQUFBeUI7QUFDcEMscUJBTkUsQUFNYTtBQUNmLHFCQVBFLEFBT2E7QUFDZixxQkFuR1csQUEyRlQsQUFRYTtBQVJiO0FBVU47QUFDSSxjQURFLEFBQ007QUFDUixjQUZFLEFBRU07QUFDUixnQkFIRSxBQUdRO0FBQ1Ysb0JBSkUsQUFJWTtBQUNkLGlCQUFXLENBQUEsQUFBQyx1QkFBRCxBQUF3QixJQUxqQyxBQUtTLEFBQTRCO0FBQ3ZDLHFCQU5FLEFBTWE7QUFDZixxQkFQRSxBQU9hO0FBQ2YscUJBN0dXLEFBcUdULEFBUWE7QUFSYjtBQVVOO0FBQ0ksY0FERSxBQUNNO0FBQ1IsY0FGRSxBQUVNO0FBQ1IsZ0JBSEUsQUFHUTtBQUNWLG9CQUpFLEFBSVk7QUFDZCxpQkFBVyxDQUFBLEFBQUMsc0JBQUQsQUFBdUIsSUFMaEMsQUFLUyxBQUEyQjtBQUN0QyxxQkFORSxBQU1hO0FBQ2YscUJBUEUsQUFPYTtBQUNmLHFCQXZIVyxBQStHVCxBQVFhO0FBUmI7QUFVTjtBQUNJLGNBREUsQUFDTTtBQUNSLGNBRkUsQUFFTTtBQUNSLGdCQUhFLEFBR1E7QUFDVixvQkFKRSxBQUlZO0FBQ2QsaUJBQVcsQ0FBQSxBQUFDLGlCQUFELEFBQWtCLElBTDNCLEFBS1MsQUFBc0I7QUFDakMscUJBTkUsQUFNYTtBQUNmLHFCQVBFLEFBT2E7QUFDZixxQkFqSVcsQUF5SFQsQUFRYTtBQVJiO0FBVU47QUFDSSxjQURFLEFBQ007QUFDUixjQUZFLEFBRU07QUFDUixnQkFIRSxBQUdRO0FBQ1Ysb0JBSkUsQUFJWTtBQUNkLGlCQUFXLENBQUEsQUFBQyx5QkFBRCxBQUEwQixJQUxuQyxBQUtTLEFBQThCO0FBQ3pDLHFCQU5FLEFBTWE7QUFDZixxQkFQRSxBQU9hO0FBQ2YscUJBM0lXLEFBbUlULEFBUWE7QUFSYjtBQVVOO0FBQ0ksY0FERSxBQUNNO0FBQ1IsY0FGRSxBQUVNO0FBQ1IsZ0JBSEUsQUFHUTtBQUNWLG9CQUpFLEFBSVk7QUFDZCxpQkFBVyxDQUFBLEFBQUMsd0JBQUQsQUFBeUIsSUFMbEMsQUFLUyxBQUE2QjtBQUN4QyxxQkFORSxBQU1hO0FBQ2YscUJBUEUsQUFPYTtBQUNmLHFCQXJKVyxBQTZJVCxBQVFhO0FBUmI7QUFVTjtBQUNJLGNBREUsQUFDTTtBQUNSLGNBRkUsQUFFTTtBQUNSLGdCQUhFLEFBR1E7QUFDVixvQkFKRSxBQUlZO0FBQ2QsaUJBQVcsQ0FBQSxBQUFDLG9CQUFELEFBQXFCLElBTDlCLEFBS1MsQUFBeUI7QUFDcEMscUJBTkUsQUFNYTtBQUNmLHFCQVBFLEFBT2E7QUFDZixxQkEvSlcsQUF1SlQsQUFRYTtBQVJiO0FBVU47QUFDSSxjQURFLEFBQ007QUFDUixjQUZFLEFBRU07QUFDUixnQkFIRSxBQUdRO0FBQ1Ysb0JBSkUsQUFJWTtBQUNkLGlCQUFXLENBQUEsQUFBQyx1QkFBRCxBQUF3QixJQUxqQyxBQUtTLEFBQTRCO0FBQ3ZDLHFCQU5FLEFBTWE7QUFDZixxQkFQRSxBQU9hO0FBQ2YscUJBektXLEFBaUtULEFBUWE7QUFSYjtBQVVOO0FBQ0ksY0FERSxBQUNNO0FBQ1IsY0FGRSxBQUVNO0FBQ1IsZ0JBSEUsQUFHUTtBQUNWLG9CQUpFLEFBSVk7QUFDZCxpQkFBVyxDQUFBLEFBQUMscUJBQUQsQUFBc0IsSUFML0IsQUFLUyxBQUEwQjtBQUNyQyxxQkFORSxBQU1hO0FBQ2YscUJBUEUsQUFPYTtBQUNmLHFCQW5MVyxBQTJLVCxBQVFhO0FBUmI7QUFVTjtBQUNJLGNBREUsQUFDTTtBQUNSLGNBRkUsQUFFTTtBQUNSLGdCQUhFLEFBR1E7QUFDVixvQkFKRSxBQUlZO0FBQ2QsaUJBQVcsQ0FBQSxBQUFDLHVCQUFELEFBQXdCLElBTGpDLEFBS1MsQUFBNEI7QUFDdkMscUJBTkUsQUFNYTtBQUNmLHFCQVBFLEFBT2E7QUFDZixxQkE3TFcsQUFxTFQsQUFRYTtBQVJiO0FBVU47QUFDSSxjQURFLEFBQ007QUFDUixjQUZFLEFBRU07QUFDUixnQkFIRSxBQUdRO0FBQ1Ysb0JBSkUsQUFJWTtBQUNkLGlCQUFXLENBQUEsQUFBQyxvQkFBRCxBQUFxQixJQUw5QixBQUtTLEFBQXlCO0FBQ3BDLHFCQU5FLEFBTWE7QUFDZixxQkFQRSxBQU9hO0FBQ2YscUJBdk1XLEFBK0xULEFBUWE7QUFSYjtBQVVOO0FBQ0ksY0FERSxBQUNNO0FBQ1IsY0FGRSxBQUVNO0FBQ1IsZ0JBSEUsQUFHUTtBQUNWLG9CQUpFLEFBSVk7QUFDZCxpQkFBVyxDQUFBLEFBQUMsaUJBQUQsQUFBa0IsSUFMM0IsQUFLUyxBQUFzQjtBQUNqQyxxQkFORSxBQU1hO0FBQ2YscUJBUEUsQUFPYTtBQUNmLHFCQWpOVyxBQXlNVCxBQVFhO0FBUmI7QUFVTjtBQUNJLGNBREUsQUFDTTtBQUNSLGNBRkUsQUFFTTtBQUNSLGdCQUhFLEFBR1E7QUFDVixvQkFKRSxBQUlZO0FBQ2QsaUJBQVcsQ0FBQSxBQUFDLG9CQUFELEFBQXFCLElBTDlCLEFBS1MsQUFBeUI7QUFDcEMscUJBTkUsQUFNYTtBQUNmLHFCQVBFLEFBT2E7QUFDZixxQkEzTlcsQUFtTlQsQUFRYTtBQVJiO0FBVU47QUFDSSxjQURFLEFBQ007QUFDUixjQUZFLEFBRU07QUFDUixnQkFIRSxBQUdRO0FBQ1Ysb0JBSkUsQUFJWTtBQUNkLGlCQUFXLENBQUEsQUFBQyx3QkFBRCxBQUF5QixJQUxsQyxBQUtTLEFBQTZCO0FBQ3hDLHFCQU5FLEFBTWE7QUFDZixxQkFQRSxBQU9hO0FBQ2YscUJBck9XLEFBNk5ULEFBUWE7QUFSYjtBQVVOO0FBQ0ksY0FETyxBQUNDO0FBQ1IsY0FGTyxBQUVDO0FBQ1IsZ0JBSE8sQUFHRztBQUNWLG9CQUpPLEFBSU87QUFDZCxpQkFBVyxDQUFBLEFBQUMsa0JBQUQsQUFBbUIsSUFMdkIsQUFLSSxBQUF1QjtBQUNsQyxxQkFOTyxBQU1RO0FBQ2YscUJBUE8sQUFPUTtBQUNmLHFCQS9PVyxBQXVPSixBQVFRO0FBUlI7QUFVWDtBQUNJLGNBRE8sQUFDQztBQUNSLGNBRk8sQUFFQztBQUNSLGdCQUhPLEFBR0c7QUFDVixvQkFKTyxBQUlPO0FBQ2QsaUJBQVcsQ0FBQSxBQUFDLGtCQUFELEFBQW1CLElBTHZCLEFBS0ksQUFBdUI7QUFDbEMscUJBTk8sQUFNUTtBQUNmLHFCQVBPLEFBT1E7QUFDZixxQkF6UFcsQUFpUEosQUFRUTtBQVJSO0FBalBJOzs7Ozs7Ozs7Ozs7QUN2R3ZCLElBQUE7O0FBa0JBLE1BQU0sUUFBQSxBQUFROztBQUdSLEFBQU0sT0FBWixBQUFhO0FBQ1QsQUFBYSxtQkFBQTs7O0FBbVliLFNBQUEsaUJBQUEsS0FBQTtBQW9GQSxTQUFBLGtCQUFBLEtBQUE7QUF5Q0EsU0FBQSwwQkFBQSxLQUFBO0FBaGdCYyxBQUFDLFNBQUE7QUFDWCxBQUFDLFNBQUQsQUFBQztBQUNHLG1CQUFBLEFBQWE7QUFDYixpQkFBVyxxQkFBQSxDQURYO0FBRUEsZUFGQSxBQUVTO0FBQ1Q7QUFDSSxpQkFBQSxBQUFTO0FBQ1Qsa0JBTEosQUFJSSxBQUNVO0FBRFY7QUFFSixlQVBKLEFBQ0ksQUFNUztBQU5UOztBQVNKLEFBQUMsU0FBRCxBQUFDLFdBWFEsQUFXRztBQUVoQixBQUFTOzs7OzRCQUFBLEFBQUMsV0FBRCxBQUFZLE9BQ2pCO1VBQUEsY0FBQTtBQUFBLHFCQUFlLEFBQVEsU0FBUixBQUFTLGNBQVQsQUFBdUI7QUFDdEMsQUFBWSxtQkFBWixBQUFhLEtBQUs7QUFFbEIsQUFBRyxVQUFILEFBQUksZ0JBQUosQUFBb0I7QUFxQnBCLGFBQU8sQUFBQyxLQUFELEFBQUMsZUFBRCxBQUFnQjtBQUV2QixVQUFBLEFBQUc7QUFDQyxBQUFZLHFCQUFaLEFBQWEsWUFBYixBQUF5QjtBQUN6QixBQUFZLHFCQUFaLEFBQWEsWUFBWSxBQUFDLEtBQUQsQUFBQyxXQUExQixBQUF5QixBQUFZLEFBQ3JDO2VBSEosQUFHVztBQUhYLGFBQUEsQUFLSTtlQUxKLEFBS1c7QUFoQ047QUFrQ1QsQUFBZ0I7OzttQ0FBQSxBQUFDLFdBQ2I7VUFBQSxRQUFBLGFBQUEsWUFBQSxVQUFBLEdBQUEsUUFBQSxLQUFBLFFBQUEsUUFBQSxRQUFBLFlBQUEsaUJBQUE7QUFBQSxhQUFPO0FBQ1AsaUJBQVcsQUFBUSxTQUFSLEFBQVMsY0FBVCxBQUF1QjtBQUVsQyxlQUFTLEFBQVEsU0FBUixBQUFTLGNBQVQsQUFBdUI7QUFDaEMsQUFBTSxhQUFOLEFBQU8sWUFBWTtBQUVuQix3QkFBa0IsQUFBUSxTQUFSLEFBQVMsY0FBVCxBQUF1QjtBQUN6QyxBQUFlLHNCQUFmLEFBQWdCLEtBQUs7QUFFckIsbUJBQWE7QUFFYixXQUFBLHdDQUFBOztBQUNJLGlCQUFTLElBQUEsQUFBSSxPQUFPLEFBQUMsS0FBWixBQUFZO0FBQ3JCLHFCQUFhLEFBQU0sT0FBQyxBQUFJLEtBRHhCLEFBQ3lCOztBQUl6QixZQUFHLENBQUEsQUFBSSxjQUFjLENBQUksQUFBVSxXQUFuQyxBQUFvQyxRQUNoQztBQURKOztBQUdBLEFBQVUsbUJBQVYsQUFBVyxLQUFYLEFBQWdCO0FBQ2hCLGlCQUFTLEFBQVEsU0FBUixBQUFTLGNBQVQsQUFBdUI7QUFDaEMsQUFBTSxlQUFOLEFBQU8sWUFBWTtBQUVuQixZQUFHLEFBQU0sT0FBQyxBQUFXLFlBQWxCLEFBQW1CLFNBQVEsQUFBQyxLQUFBLEFBQUUsR0FBQyxBQUFJLEtBQXRDLEFBQXVDO0FBQ25DLEFBQU0saUJBQU4sQUFBTyxXQURYLEFBQ3NCOztBQUV0QixBQUFlLHdCQUFmLEFBQWdCLFlBaEJwQixBQWdCSSxBQUE0Qjs7QUFFaEMsVUFBRyxBQUFVLFdBQWIsQUFBYztBQUNWLEFBQWUsd0JBQWYsQUFBZ0IsaUJBQWhCLEFBQWlDLFVBQVksVUFBQSxBQUFDLFlBQzFDO2lCQUFPLFlBQ0g7Z0JBQUEsSUFBQSxJQUFBLFFBQUE7QUFBQSxxQkFBUyxBQUFRLFNBQVIsQUFBUyxlQUFULEFBQ21CO0FBQzVCLGlCQUFLLEFBQU0sT0FBQztBQUNaLGlCQUFLLEFBQVEsU0FBUixBQUFTLGVBQVQsQUFBd0I7QUFDN0IscUJBQVMsQUFBVyxXQUpwQixBQUlvQjs7QUFHcEIscUJBQVMsQUFBTSxPQUFDO0FBQ2hCLGdCQUFHLGtCQUFILEFBQXFCO0FBQ2pCLEFBQUUsaUJBQUYsQUFBRyxhQUFILEFBQWdCLFVBQVUsQUFBRSxHQURoQyxBQUNJLEFBQTZCO0FBRGpDLG1CQUFBO0FBS0ksQUFBRSxpQkFBRixBQUFHLGFBQWEsQUFBUSxTQUFSLEFBQVMsY0FBekIsQUFBZ0IsQUFBdUIsUUFDQyxBQUFFLEdBTjlDLEFBS0ksQUFDMkM7O0FBQy9DLEFBQUksaUJBQUMsQUFBYSxjQUFsQixBQUFtQixjQUFjLEFBQU0sT0FBQyxBQUFXLFlBQUM7bUJBQ3BELEFBQUksS0FBQyxBQUFhLGNBQWxCLEFBQW1CLFlBQVksVUFBQSxBQUFDLE9BQUQsQUFDQyxjQURELEFBQ2U7cUJBQzFDLEFBQU0sT0FBTixBQUFPLFNBQVAsQUFBZ0IsT0FBaEIsQUFBdUIsY0FGSSxBQUUzQixBQUFxQztBQW5CdEM7QUFEa0M7QUFBRixTQUFBLENBQTNDLEFBQTJDLEFBcUJ6QyxhQXJCRixBQXFCZTtBQUVmLHNCQUFjLEFBQVEsU0FBUixBQUFTLGNBQVQsQUFBdUI7QUFDckMsQUFBVyxvQkFBWCxBQUFZLEtBQUs7QUFFakIsaUJBQVMsQUFBVyxXQUFBLEFBQWUsZ0JBMUJuQyxBQTBCb0IsQUFBZ0I7O0FBR3BDLGlCQUFTLEFBQU0sT0FBQztBQUNoQixZQUFHLGtCQUFILEFBQXFCO0FBQ2pCLEFBQVcsc0JBQVgsQUFBWSxZQURoQixBQUNJLEFBQXdCO0FBRDVCLGVBQUE7QUFHSSxBQUFXLHNCQUFYLEFBQVksWUFBWSxBQUFRLFNBQVIsQUFBUyxjQUhyQyxBQUdJLEFBQXdCLEFBQXVCOztBQUNuRCxBQUFDLGFBQUEsQUFBYSxjQUFkLEFBQWUsY0FBYyxBQUFNLE9BQUMsQUFBVyxZQUFDO0FBQ2hELEFBQUMsYUFBQSxBQUFhLGNBQWQsQUFBZSxZQUFZLFVBQUEsQUFBQyxPQUFELEFBQVEsY0FBUixBQUFzQjtpQkFDN0MsQUFBTSxPQUFOLEFBQU8sU0FBUCxBQUFnQixPQUFoQixBQUF1QixjQURBLEFBQ3ZCLEFBQXFDOztBQUV6QyxBQUFRLGlCQUFSLEFBQVMsWUFBVCxBQUFxQjtBQUNyQixBQUFRLGlCQUFSLEFBQVMsWUFBVCxBQUFxQjtBQUNyQixBQUFRLGlCQUFSLEFBQVMsWUFBVCxBQUFxQixBQUVyQjtlQTNDSixBQTJDVztBQTNDWCxhQUFBLEFBNkNJO2VBN0NKLEFBNkNXO0FBM0VDO0FBNkVoQixBQUFrQjs7O3FDQUFBLEFBQUMsT0FDZjtVQUFBLEdBQUEsS0FBQSxNQUFBLFFBQUEsYUFBQTtBQUFBLGFBQU87QUFDUCxvQkFBYyxBQUFRLFNBQVIsQUFBUyxjQUFULEFBQXVCO0FBQ3JDLEFBQVcsa0JBQVgsQUFBWSxLQUFLO0FBRWpCLFdBQUEsb0NBQUE7O0FBQ0ksWUFBRyxBQUFLLEtBQVIsQUFBUTtBQUNKLG1CQUFTLEFBQVEsU0FBUixBQUFTLGNBQVQsQUFBdUI7QUFDaEMsQUFBTSxpQkFBTixBQUFPLFlBQVksQUFBSyxLQUFBO0FBQ3hCLEFBQVcsc0JBQVgsQUFBWSxZQUFaLEFBQXdCO0FBRXhCLGNBQUcsQ0FBSSxBQUFDLEtBQUEsQUFBYSxjQUFDLEFBQUksS0FBMUIsQUFBMkI7QUFFdkIsQUFBQyxpQkFBQSxBQUFhLGNBQUMsQUFBSSxLQUFuQixBQUFvQixVQUZ4QixBQUVrQztBQVB0QztBQURKOztBQVVBLEFBQVcsa0JBQVgsQUFBWSxpQkFBWixBQUE2QixVQUFZLFVBQUEsQUFBQyxLQUN0QztlQUFPLFlBQ0g7Y0FBQSxJQUFBO0FBQUEsbUJBQVMsQUFBUSxTQUFSLEFBQVMsZUFBVCxBQUN1QjtBQUNoQyxlQUFLLEFBQU0sT0FBQztBQUNaLEFBQUksZUFBQyxBQUFhLGNBQUMsQUFBSSxLQUF2QixBQUF3QixXQUNJLEFBQUksS0FBQyxBQUFhLGNBQUMsQUFBSSxLQUpuRCxBQUlvRDs7aUJBR3BELEFBQUksS0FBQyxBQUFhLGNBQUMsQUFBSSxLQUF2QixBQUF3QixVQUFVLEFBQUksSUFSbkMsQUFRbUM7QUFUTDtBQUFGLE9BQUEsQ0FBdkMsQUFBdUMsQUFVckMsUUFWRixBQVVVLEFBRVY7YUEzQmMsQUEyQlA7QUFFWCxBQUFZOzs7K0JBQUEsQUFBQyxPQUNUO1VBQUEsS0FBQSxZQUFBLGVBQUEsTUFBQSxPQUFBLFVBQUEsUUFBQSxZQUFBLGNBQUEsaUJBQUEsR0FBQSxTQUFBLFlBQUEsUUFBQSxLQUFBLFlBQUEsU0FBQSxNQUFBLE9BQUE7QUFBQSxhQUFPO0FBQ1AsWUFBTSxBQUFRLFNBQVIsQUFBUyxjQUFULEFBQXVCO0FBRTdCLGlCQUFXLEFBQVEsU0FBUixBQUFTLGNBQVQsQUFBdUI7QUFFbEMsZUFBUyxBQUFRLFNBQVIsQUFBUyxjQUFULEFBQXVCO0FBQ2hDLEFBQU0sYUFBTixBQUFPLFlBQVk7QUFFbkIsbUJBQWEsQUFBQyxLQUFELEFBQUMsaUJBQUQsQUFBa0I7QUFFL0IsZUFBUyxBQUFRLFNBQVIsQUFBUyxjQUFULEFBQXVCO0FBQ2hDLEFBQU0sYUFBTixBQUFPLEtBQUs7QUFFWixnQkFBVSxBQUFRLFNBQVIsQUFBUyxjQUFULEFBQXVCO0FBQ2pDLEFBQU8sY0FBUCxBQUFRLEtBQUs7QUFDYixBQUFPLGNBQVAsQUFBUSxPQUFPO0FBQ2YsQUFBTyxjQUFQLEFBQVEsUUFBUTtBQUVoQixtQkFBYSxBQUFRLFNBQVIsQUFBUyxjQUFULEFBQXVCO0FBQ3BDLEFBQVUsaUJBQVYsQUFBVyxPQUFPO0FBQ2xCLEFBQVUsaUJBQVYsQUFBVyxLQUFLO0FBRWhCLGdCQUFVLEFBQVEsU0FBUixBQUFTLGNBQVQsQUFBdUI7QUFDakMsQUFBTyxjQUFQLEFBQVEsT0FBTztBQUNmLEFBQU8sY0FBUCxBQUFRLEtBQUs7QUFFYixjQUFRLENBQUEsQUFBQyxRQUFELEFBQVMsWUFBVCxBQUFxQjtBQUU3QixXQUFBLG9DQUFBOztBQUNJLEFBQUksYUFBSixBQUFLLGlCQUFMLEFBQXNCLFVBQVU7aUJBQzVCLEFBQUksS0FBSixBQUFLLGlCQUR1QixBQUM1QixBQUNnQjtBQUZwQixXQURKLEFBQ0ksQUFHRTs7QUFFTixzQkFBZ0IsQUFBUSxTQUFSLEFBQVMsY0FBVCxBQUF1QjtBQUN2QyxBQUFhLG9CQUFiLEFBQWMsWUFBWTtBQUUxQixtQkFBYSxBQUFRLFNBQVIsQUFBUyxjQUFULEFBQXVCO0FBQ3BDLEFBQVUsaUJBQVYsQUFBVyxZQUFZO0FBRXZCLEFBQU8sY0FBUCxBQUFRLGlCQUFSLEFBQXlCLFNBQVMsQUFBQyxLQUFuQyxBQUFtQyxnQkFBbkMsQUFBbUQ7QUFFbkQsQUFBUSxlQUFSLEFBQVMsWUFBVCxBQUFxQjtBQUNyQixVQUFHLEFBQVUsV0FBVixBQUFXLFNBQWQsQUFBdUI7QUFDbkIsQUFBUSxpQkFBUixBQUFTLFlBRGIsQUFDSSxBQUFxQjs7QUFDekIsQUFBUSxlQUFSLEFBQVMsWUFBVCxBQUFxQjtBQUNyQixBQUFRLGVBQVIsQUFBUyxZQUFULEFBQXFCO0FBQ3JCLEFBQVEsZUFBUixBQUFTLFlBQVQsQUFBcUI7QUFDckIsQUFBUSxlQUFSLEFBQVMsWUFBVCxBQUFxQjtBQUNyQixBQUFRLGVBQVIsQUFBUyxZQUFULEFBQXFCO0FBQ3JCLEFBQVEsZUFBUixBQUFTLFlBQVQsQUFBcUI7QUFFckIsY0FBUSxBQUFRLFNBQVIsQUFBUyxjQUFULEFBQXVCO0FBQy9CLEFBQUssWUFBTCxBQUFNLE9BQU87QUFDYixBQUFLLFlBQUwsQUFBTSxRQUFRO0FBQ2QsQUFBSyxZQUFMLEFBQU0sS0FBSztBQUVYLEFBQUssWUFBTCxBQUFNLGlCQUFOLEFBQXVCLFNBQVMsQUFBQyxLQUFqQyxBQUFpQyxpQkFBakMsQUFBa0Q7QUFFbEQsQUFBSyxZQUFMLEFBQU0sV0FBVztBQUVqQixpQkFBVyxBQUFRLFNBQVIsQUFBUyxjQUFULEFBQXVCO0FBQ2xDLEFBQVEsZUFBUixBQUFTLFlBQVk7QUFDckIsQUFBUSxlQUFSLEFBQVMsS0FBSztBQUVkLG1CQUFhLEFBQVEsU0FBUixBQUFTLGNBQVQsQUFBdUI7QUFDcEMsQUFBVSxpQkFBVixBQUFXLEtBQUs7QUFFaEIscUJBQWUsQUFBUSxTQUFSLEFBQVMsY0FBVCxBQUF1QjtBQUN0QyxBQUFZLG1CQUFaLEFBQWEsT0FBTztBQUNwQixBQUFZLG1CQUFaLEFBQWEsV0FBVztBQUV4Qix3QkFBa0IsQUFBUSxTQUFSLEFBQVMsY0FBVCxBQUF1QjtBQUN6QyxBQUFlLHNCQUFmLEFBQWdCLFlBQVk7QUFHNUIsQUFBVSxpQkFBQyxBQUFLLE1BQWhCLEFBQWlCLFVBQVU7QUFDM0IsQUFBVSxpQkFBVixBQUFXLFlBQVgsQUFBdUI7QUFDdkIsQUFBVSxpQkFBVixBQUFXLFlBQVgsQUFBdUI7QUFFdkIsQUFBRyxVQUFILEFBQUksWUFBSixBQUFnQjtBQUNoQixBQUFHLFVBQUgsQUFBSSxZQUFKLEFBQWdCO0FBQ2hCLEFBQUcsVUFBSCxBQUFJLFlBQUosQUFBZ0I7QUFDaEIsQUFBRyxVQUFILEFBQUksWUFBSixBQUFnQixBQUVoQjthQXRGUSxBQXNGRDtBQUVYLEFBQWlCOzs7O0FBQ2IsQUFBUSxlQUFSLEFBQVMsZUFBVCxBQUF3QixBQUF3Qix5QkFBaEQsQUFBaUQsWUFBWTthQUM3RCxBQUFRLFNBQVIsQUFBUyxlQUFULEFBQXdCLEFBQXFCLHNCQUE3QyxBQUE4QyxXQUZqQyxBQUU0QztBQUU3RCxBQUFrQjs7O3FDQUFBLEFBQUM7QUFDZixBQUFRLGVBQVIsQUFBUyxlQUFULEFBQXdCLEFBQXdCLHlCQUFoRCxBQUFpRCxZQUFZO2FBQzdELEFBQVEsU0FBUixBQUFTLGVBQVQsQUFBd0IsQUFBcUIsc0JBQTdDLEFBQThDLFdBRmhDLEFBRTJDO0FBRTdELEFBQWdCOzs7bUNBQUEsQUFBQyxRQUNiO1VBQUEsTUFBQSxPQUFBO0FBQUEsYUFBTztBQUNQLGFBQU8sQUFBUSxTQUFSLEFBQVMsY0FBVCxBQUF1QjtBQUM5QixBQUFJLFdBQUosQUFBSyxPQUFPO0FBQ1osQUFBSSxXQUFKLEFBQUssUUFBUTtBQUNiLEFBQUksV0FBSixBQUFLLEtBQUs7QUFFVixBQUFJLFdBQUosQUFBSyxpQkFBTCxBQUFzQixTQUFXLFVBQUEsQUFBQyxJQUM5QjtlQUFPO0FBQ0gsdUJBQUEsQUFBYTs7QUFFYixBQUFJLGVBQUosQUFBSztBQUNMLEFBQUksZUFBSixBQUFLLGNBQUwsQUFBbUI7aUJBQ25CLEFBQUksS0FBQyxBQUFFLEdBQUMsQUFBRyxJQUFYLEFBQVksUUFMVCxBQUtILEFBQW9CO0FBTks7QUFBRixPQUFBLENBQS9CLEFBQStCLEFBTzdCLFNBUEYsQUFPVztBQUVYLGNBQVEsQUFBUSxTQUFSLEFBQVMsZUFBVCxBQUF3QjtBQUNoQyxBQUFLLFlBQUMsQUFBVSxXQUFoQixBQUFpQixhQUFqQixBQUE4QixNQUE5QixBQUFvQzthQUNwQyxBQUFLLE1BQUMsQUFBSyxNQUFYLEFBQVksVUFsQkEsQUFrQlU7QUFFMUIsQUFBaUI7OztzQ0FDYjtVQUFBO0FBQUEsYUFBTyxBQUFRLFNBQVIsQUFBUyxlQUFULEFBQXdCO0FBQy9CLEFBQUksV0FBQyxBQUFVLFdBQWYsQUFBZ0IsWUFBaEIsQUFBNEI7YUFDNUIsQUFBUSxTQUFSLEFBQVMsZUFBVCxBQUF3QixBQUFxQixzQkFBQyxBQUFLLE1BQW5ELEFBQW9ELFVBSHZDLEFBR2lEO0FBRWxFLEFBQWtCOzs7O2FBQ2QsQUFBQyxLQUFELEFBQUMsbUJBRGEsQUFDZCxBQUFvQjtBQUV4QixBQUFtQjs7OzthQUNmLEFBQUMsS0FBRCxBQUFDLG1CQURjLEFBQ2YsQUFBb0I7QUFFeEIsQUFBb0I7Ozt1Q0FBQSxBQUFDLE1BQ2pCO1VBQUEsTUFBQSxPQUFBLEdBQUEsS0FBQTtBQUFBLGNBQVEsQUFBUSxTQUFSLEFBQVMsZUFBVCxBQUF3QixBQUNJLGlCQUQ1QixBQUM2QixxQkFEN0IsQUFDa0QsQUFDMUQ7O0FBQUEsV0FBQSxvQ0FBQTtxQkFBQTs7cUJBRUksQUFBSSxLQUFKLEFBQUssV0FGVCxBQUVvQjtBQUZwQjthQUhnQjtBQU9wQixBQUFtQjs7O3dDQUNmO1VBQUE7QUFBQSxjQUFRLEFBQVEsU0FBUixBQUFTLGVBQVQsQUFBd0I7QUFDaEMsQUFBSyxZQUFMLEFBQU0scUJBQU4sQUFBMkIsQUFBUyxTQUFBLEFBQUUsR0FBdEMsQUFBdUMsV0FBVzthQUNsRCxBQUFLLE1BQUMsQUFBSyxNQUFYLEFBQVksVUFIRyxBQUdPO0FBRTFCLEFBQW9COzs7eUNBQ2hCO1VBQUE7QUFBQSxjQUFRLEFBQVEsU0FBUixBQUFTLGVBQVQsQUFBd0I7QUFDaEMsQUFBSyxZQUFMLEFBQU0scUJBQU4sQUFBMkIsQUFBUyxTQUFBLEFBQUUsR0FBdEMsQUFBdUMsVUFBVTtBQUNqRCxBQUFLLFlBQUwsQUFBTSxxQkFBTixBQUEyQixBQUFTLFNBQUEsQUFBRSxHQUF0QyxBQUF1QyxXQUFXO2FBQ2xELEFBQUssTUFBQyxBQUFLLE1BQVgsQUFBWSxVQUpJLEFBSU07QUFFMUIsQUFBZ0I7OztxQ0FDWjthQUFPLEFBQVEsU0FBUixBQUFTLGVBQVQsQUFBd0IsQUFDSCwyQkFEckIsQUFDc0IscUJBRHRCLEFBQzJDLEFBQVMsU0FBQSxBQUFFLEdBRmpELEFBRWtEO0FBRWxFLEFBQWE7OztrQ0FDVDtVQUFBLEtBQUEsUUFBQSxTQUFBLFlBQUEsR0FBQSxXQUFBLEtBQUEsV0FBQSxVQUFBLFNBQUE7QUFBQSxBQUFDLFdBQUEsQUFBYSxjQUFkLEFBQWUsVUFBVTtBQUN6QixnQkFBVSxBQUFRLFNBQVIsQUFBUyxlQUFULEFBQXdCLEFBQ2MsdUJBQUMsQUFBSyxNQUQ1QyxBQUM2QyxNQUQ3QyxBQUNtRDtBQUU3RCxXQUFBLHNDQUFBO3lCQUFBOztBQUVJLFlBQUEsQUFBRztBQUNDLHVCQUFhLEFBQU0sT0FBTixBQUFPLFFBQVAsQUFBZTtBQUM1QixzQkFBWSxBQUFNLE9BQU4sQUFBTyxZQUFQLEFBQW1CO0FBQy9CLG9CQUFVLEFBQU0sT0FBTixBQUFPLFVBQVUsYUFBakIsQUFBOEIsR0FBOUIsQUFBaUM7QUFDM0Msc0JBQVksQUFBTSxPQUFOLEFBQU8sVUFBVSxZQUFqQixBQUE2QjtBQUN6QyxxQkFBVyxBQUFNLE9BQU4sQUFBTyxPQUFQLEFBQWMsT0FBTSxBQUUvQjs7QUFDSSxxQkFBUyxJQUFBLEFBQUksT0FBSixBQUFXLFNBRHhCLEFBQ2EsQUFBb0I7QUFEakMsbUJBQUE7QUFFTTtBQUNGLEFBQUMsaUJBQUEsQUFBRSxHQUFDLEFBQUcsSUFBUCxBQUFRLFNBQVMscUJBQWpCLEFBQXNDLEFBQ3RDO21CQUpKLEFBSVc7O0FBRVgsQUFBQyxlQUFBLEFBQWEsY0FBQyxBQUFPLFFBQXRCLEFBQXVCLEtBQUssQ0FBQSxBQUFDLFFBYmpDLEFBYUksQUFBNEIsQUFBUztBQWY3QztBQUpBLEFBdUJBOzthQXhCUyxBQXdCRjtBQUVYLEFBQWdCOzs7bUNBQUEsQUFBQyxNQUViO1VBQUEsWUFBQSxRQUFBLFNBQUEsR0FBQSxTQUFBLEtBQUEsVUFBQSxRQUFBLE1BQUE7O0FBQUEsVUFBRyxBQUFJLEtBQUMsQUFBUyxVQUFkLEFBQWUsTUFBZixBQUFxQixBQUFJLEtBQXpCLEFBQTBCLFFBQTFCLEFBQWtDLFNBQXJDLEFBQThDO0FBSTFDLGdCQUFRLEFBQUksS0FBQztBQUNiLHFCQUFhLEFBQVEsU0FBUixBQUFTLGVBQVQsQUFBd0IsQUFDbUIsMkJBQUM7QUFFekQsWUFBRyxjQUFjLEFBQUMsS0FBQSxBQUFhLGNBQUMsQUFBTyxRQUF0QixBQUF1QixRQUF2QixBQUNtQyxTQURwRCxBQUM2RDtBQUN6RCxBQUFDLGVBQUEsQUFBYSxjQUFDLEFBQU8sUUFBdEIsQUFBdUIsS0FBdkIsQUFBNEI7QUFDNUIsb0JBQVUsQUFBQyxLQUFBLEFBQWEsY0FBQztBQUN6QixvQkFBVSxBQUFRLFNBQVIsQUFBUyxlQUFULEFBQXdCLEFBQ2tCLHdCQUFDO0FBRXJELGNBQUcsQUFBTyxRQUFQLEFBQVEsU0FBWCxBQUFvQjtBQUNoQixpQkFBQSxzQ0FBQTs7QUFDSSx1QkFBUyxBQUFPLE9BQUE7QUFDaEIseUJBQVcsQUFBTyxPQUFBO0FBQ2xCLHFCQUFPLEFBQU0sT0FBTixBQUFPLEtBQVAsQUFBWTtBQUVuQixrQkFBRyxTQUFILEFBQVc7QUFDQSxvQkFBQSxBQUFHO3lCQUFILEFBQWdCO0FBQWhCLHVCQUFBO3lCQUFBLEFBQTJCO0FBRHRDO0FBTEo7QUFBQTs7QUFTTyxnQkFBQSxBQUFHO3FCQUFILEFBQWdCO0FBQWhCLG1CQUFBO3FCQUFBLEFBQTBCO0FBVnJDO0FBQUEsaUJBQUE7QUFZVyxnQkFBQSxBQUFHO3FCQUFILEFBQWdCO0FBQWhCLG1CQUFBO3FCQUFBLEFBQTJCO0FBWnRDO0FBUEo7QUFBQSxlQUFBLEFBcUJJO2lCQXJCSixBQXFCVztBQTdCZjtBQUFBLGFBQUEsQUErQkk7ZUEvQkosQUErQlc7QUFqQ0M7QUFtQ2hCLEFBQStCOzs7a0RBQUEsQUFBQyxXQUFELEFBQVksVUFDdkM7VUFBQSxTQUFBLEtBQUEsR0FBQSxLQUFBO0FBQUEsZ0JBQVUsQUFBUyxVQUFULEFBQVUsTUFBVixBQUFnQjtBQUMxQixtQkFBYTtBQUViLFdBQUEsc0NBQUE7O0FBQ0ksWUFBRyxBQUFHLElBQUgsQUFBSSxRQUFKLEFBQVksZ0JBQWYsQUFBK0I7QUFDM0IsQUFBVSxxQkFBVixBQUFXLEtBRGYsQUFDSSxBQUFnQjtBQUZ4QjtBQUhBOztBQVNBLEFBQVUsaUJBQVYsQUFBVyxLQUFYLEFBQWdCLEFBRWhCO2FBQU8sQUFBVSxXQUFWLEFBQVcsS0FaUyxBQVlwQixBQUFnQjtBQUUzQixBQUE4Qjs7O2lEQUFBLEFBQUMsV0FDM0I7VUFBQSxTQUFBLEtBQUEsR0FBQSxLQUFBO0FBQUEsZ0JBQVUsQUFBUyxVQUFULEFBQVUsTUFBVixBQUFnQjtBQUMxQixvQkFBYztBQUVkLFdBQUEsc0NBQUE7O0FBQ0ksWUFBRyxBQUFHLElBQUgsQUFBSSxRQUFKLEFBQVksZ0JBQWYsQUFBK0I7QUFDM0IsQUFBVyxzQkFBWCxBQUFZLEtBRGhCLEFBQ0ksQUFBaUI7QUFGekI7QUFJQTthQUFPLEFBQVcsWUFBWCxBQUFZLEtBUk8sQUFRbkIsQUFBaUI7QUFFNUIsQUFBZ0I7OztxQ0FDWjtVQUFBLEdBQUEsUUFBQSxHQUFBLE1BQUEsT0FBQSxHQUFBLEtBQUEsTUFBQSxNQUFBO0FBQUEsQUFBQyxXQUFBLEFBQUUsR0FBQyxBQUFHLElBQVAsQUFBUSxRQUFSLEFBQWdCO0FBQ2hCLEFBQUMsV0FBRCxBQUFDLGlCQUFELEFBQWtCO0FBRWxCLFVBQUcsQUFBQyxLQUFBLEFBQWEsY0FBQyxBQUFJLEtBQXRCLEFBQXVCO0FBQ25CLFlBQUcsQUFBQyxLQUFBLEFBQWEsY0FBQyxBQUFJLEtBQUMsQUFBUSxRQUFBLEFBQUUsR0FBOUIsQUFBK0IsYUFBbEMsQUFBOEM7QUFDMUMsa0JBQVEsQUFBQyxLQUFBLEFBQWEsY0FBQyxBQUFJLEtBQUMsQUFBUyxTQUFBLEFBQ0wsR0FEeEIsQUFDeUIscUJBRnJDLEFBQ1ksQUFDOEM7QUFGMUQsZUFBQTtBQUlJLGtCQUFRLEFBQUMsS0FBQSxBQUFhLGNBQUMsQUFBSSxLQUFDLEFBQVMsU0FBQSxBQUNMLEdBRHhCLEFBQ3lCLHFCQUxyQyxBQUlZLEFBQzhDOztBQUMxRCxpQkFBUyxBQUFDLEtBQUEsQUFBYSxjQUFDLEFBQUksS0FBQyxBQUFTLFNBQUE7QUFFdEMsYUFBQSxvQ0FBQTs7QUFDSSxpQkFBTyxBQUFJLEtBQUosQUFBSyxxQkFBTCxBQUEwQixBQUFLLEtBQXRDLEFBQXNDOztBQUt0QyxjQUFBLEFBQUc7QUFDQyxBQUFJLGlCQUFKLEFBQUssWUFBWSxBQUFDLEtBQUQsQUFBQyw2QkFDc0IsQUFBSSxLQUZoRCxBQUNxQixBQUM0QjtBQVJyRDtBQVRKOztBQW1CQSxBQUFDLFdBQUEsQUFBYSxjQUFkLEFBQWUsVUFBVTtBQUV6QixlQUFTLEFBQUMsS0FBQSxBQUFhLGNBQUMsQUFBSSxLQUFDLEFBQVEsUUFBQTtBQUNyQyxlQUFTO0FBQ1QsVUFBSTtBQUVKLFVBQUcsQUFBQyxLQUFKLEFBQUcsQUFBQztBQUNBLFlBQUcsQUFBQyxLQUFBLEFBQWEsY0FBQyxBQUFJLEtBQUMsQUFBUSxRQUFBLEFBQUUsR0FBOUIsQUFBK0IsYUFBbEMsQUFBOEM7QUFDMUMsa0JBQ0ksQUFBQyxLQUFBLEFBQWEsY0FBQyxBQUFJLEtBQUMsQUFBUSxRQUFBLEFBQUUsR0FBOUIsQUFBK0IscUJBRnZDLEFBRVEsQUFDb0Q7QUFINUQsZUFBQTtBQUtJLGtCQUNJLEFBQUMsS0FBQSxBQUFhLGNBQUMsQUFBSSxLQUFDLEFBQVEsUUFBQSxBQUFFLEdBQTlCLEFBQStCLHFCQU52QyxBQU1RLEFBQ29EOztBQUU1RCxhQUFBLHNDQUFBOztBQUNJLGlCQUFPLEFBQUksS0FBSixBQUFLLHFCQUFMLEFBQTBCLEFBQUssS0FBdEMsQUFBc0M7O0FBTXRDLGNBQUEsQUFBRztBQUNDLGdCQUFHLEFBQUMsS0FBRCxBQUFDLGVBQUosQUFBRyxBQUFnQjtBQUNmLEFBQUksbUJBQUosQUFBSyxZQUFZLEFBQUMsS0FBRCxBQUFDLDhCQUNOLEFBQUksS0FEQyxBQUNBLFdBREEsQUFDVztBQUM1Qix1QkFBUztBQUhiLEFBSUk7QUFKSixtQkFBQTtBQU1JLEFBQUksbUJBQUosQUFBSyxZQUFZLEFBQUMsS0FBRCxBQUFDLDZCQUNrQixBQUFJLEtBUDVDLEFBTXFCLEFBQ3dCO0FBUmpEO0FBUEo7QUFWSjs7QUEyQkEsQUFBQyxXQUFBLEFBQUUsR0FBQyxBQUFHLElBQVAsQUFBUSxRQUFRLHNCQUFBLEFBQXNCLElBQXRDLEFBQTBDO0FBRTFDLFVBQUEsQUFBRztlQUNDLEFBQUMsS0FETCxBQUNJLEFBQUM7QUFETCxhQUFBO2VBR0ksQUFBQyxLQUFELEFBQUMsaUJBSEwsQUFHSSxBQUNnQjtBQTlEUjtBQWdFaEIsQUFBYzs7O21DQUNWO1VBQUEsTUFBQTtBQUFBLGFBQU8sSUFBQSxBQUFJO0FBQ1gsY0FBUSxBQUFJLEtBQUosQUFBSyxZQUFZO0FBQ3pCLEFBQUMsV0FBRCxBQUFDLFdBQVc7YUFDWixBQUFZLGFBQVosQUFBYSxRQUFiLEFBQXFCLHNCQUpYLEFBSVYsQUFBMkM7QUFFL0MsQUFBZ0I7OzttQ0FBQSxBQUFDO0FBQ2IsQUFBQyxXQUFELEFBQUMsV0FBVztBQUNaLFVBQUEsQUFBRztlQUNDLEFBQVksYUFBWixBQUFhLFFBQWIsQUFBcUIsc0JBRHpCLEFBQ0ksQUFBMkM7QUFIbkM7QUFLaEIsQUFBYzs7O21DQUNWO2FBQU8sQUFBQyxLQURFLEFBQ0Y7QUFFWixBQUF3Qjs7OzZDQUNwQjtVQUFBO0FBQUEsY0FBUSxBQUFZLGFBQVosQUFBYSxRQUFyQixBQUFRLEFBQXFCLEFBRzdCOzthQUFPLFNBQVUsVUFBVixBQUFtQixPQUFRLFVBQVMsQUFBQyxLQUp4QixBQUl1QixBQUFDO0FBRWhELEFBQWlCOzs7c0NBQ2I7VUFBQSxHQUFBLE1BQUEsT0FBQSxVQUFBLEtBQUE7QUFBQSxVQUFHLEFBQUMsS0FBRCxBQUFDLDRCQUE2QixDQUFJLEFBQUMsS0FBdEMsQUFBcUMsQUFBQztBQUNsQyxBQUFDLGFBQUEsQUFBRSxHQUFDLEFBQUcsSUFBUCxBQUFRLFNBQVIsQUFBaUI7ZUFTakIsQUFBQyxLQVZMLEFBVUksQUFBQztBQVZMLGFBV0ssSUFBRyxBQUFDLEtBQUosQUFBRyxBQUFDO0FBQ0wsWUFBRyxBQUFDLEtBQUEsQUFBYSxjQUFDLEFBQUksS0FBQyxBQUFRLFFBQUEsQUFBRSxHQUE5QixBQUErQixhQUFsQyxBQUE4QztBQUMxQyxxQkFBVyxBQUFDLEtBQUEsQUFBYSxjQUFDLEFBQUksS0FBQyxBQUFRLFFBQUEsQUFDUCxHQURyQixBQUNzQixxQkFGckMsQUFDZSxBQUMyQztBQUYxRCxlQUFBO0FBSUkscUJBQVcsQUFBQyxLQUFBLEFBQWEsY0FBQyxBQUFJLEtBQUMsQUFBUSxRQUFBLEFBQ1AsR0FEckIsQUFDc0IscUJBTHJDLEFBSWUsQUFDMkM7QUFMMUQ7O0FBU0EsZ0JBQVE7QUFFUixhQUFBLHVDQUFBOztBQUNJLEFBQUssZ0JBQUwsQUFBTSxLQURWLEFBQ0ksQUFBVzs7QUFFZixpQkFBUyxBQUFDLEtBQUEsQUFBYSxjQUFDLEFBQUksS0FBQyxBQUFRLFFBQUE7QUFFckMsQUFBQyxhQUFELEFBQUM7QUFDRCxBQUFDLGFBQUQsQUFBQztBQUNELEFBQUMsYUFBQSxBQUFFLEdBQUMsQUFBRyxJQUFQLEFBQVEsUUFBUixBQUFnQjtBQUNoQixBQUFDLGFBQUEsQUFBRSxHQUFDLEFBQUcsSUFBUCxBQUFRLFVBQVUsYUFBYSxBQUFDLEtBQUEsQUFBYSxjQUE3QyxBQUE4QztBQUM5QyxBQUFDLGFBQUEsQUFBRSxHQUFDLEFBQUcsSUFBUCxBQUFRLFVBQVUsYUFBYSxBQUFRLFNBQVIsQUFBUyxlQUFULEFBQ0ssQUFBc0IsdUJBRDFELEFBQzJEO0FBQzNELEFBQUMsYUFBRCxBQUFDLGlCQUFELEFBQWtCO0FBQ2xCLEFBQUMsYUFBRCxBQUFDO0FBQ0QsQUFBQyxhQUFBLEFBQWEsY0FBZCxBQUFlLFVBQVU7ZUFFekIsQUFBQyxLQUFBLEFBQUUsR0FBQyxBQUFFLEdBQU4sQUFBTyxVQUFVLEFBQUMsS0FBbEIsQUFBa0IseUJBQXlCLENBQUEsQUFBQyxPQTNCM0MsQUEyQkQsQUFBMkMsQUFBUTtBQXZDMUM7QUF5Q2pCLEFBQXlCOzs7NENBQUEsQUFBQyxTQUFELEFBQVUsTUFDL0I7VUFBQSxPQUFBO0FBQUEsY0FBUSxBQUFLLEtBQUE7QUFDYixlQUFTLEFBQUssS0FBQTtBQUVkLEFBQUMsV0FBQSxBQUFhLGNBQWQsQUFBZSxXQUFXLEFBQUcsVUFBSCxBQUFnQixPQUFVO2FBQ3BELEFBQUMsS0FBRCxBQUFDLGFBQUQsQUFBYyxHQUFkLEFBQWlCLE9BQWpCLEFBQXdCLEdBQXhCLEFBQTJCLFFBTE4sQUFLckIsQUFBbUM7QUFFdkMsQUFBa0I7OztxQ0FBQSxBQUFDLEtBQUQsQUFBTSxJQUFOLEFBQVUsUUFBVixBQUFrQixJQUFsQixBQUFzQixTQUNwQztVQUFBO0FBQUEsYUFBTyxBQUNQO2FBQU8sVUFBQSxBQUFDLFFBQUQsQUFBUyxTQUNaO2dCQUFBLEFBQU87ZUFBUCxBQUVTO0FBQ0QsQUFBRSxlQUFGLEFBQUcsWUFBWSxBQUFJLEtBQUosQUFBSyw4QkFBOEIsQUFBRSxHQUFyQyxBQUFzQyxXQUF0QyxBQUNpQjtBQUNoQyxBQUFJLGlCQUFDLEFBQUUsR0FBQyxBQUFHLElBQVgsQUFBWSxRQUFRLEFBQUksS0FBQyxBQUFFLEdBQUMsQUFBRyxJQUFYLEFBQVksZUFBWixBQUEyQixTQUEzQixBQUFvQyxXQUF4RCxBQUNnQztBQUNoQztBQUNBLEFBQUksaUJBQUosQUFBSyxhQUFMLEFBQWtCLFFBQWxCLEFBQTBCLEtBQTFCLEFBQStCLElBQS9CLEFBQW1DLFFBQW5DLEFBQTJDLEFBQzNDO0FBVFI7O2VBQUEsQUFXUztBQUNELEFBQUUsZUFBRixBQUFHLFlBQVksQUFBSSxLQUFKLEFBQUssOEJBQThCLEFBQUUsR0FBckMsQUFBc0MsV0FBdEMsQUFDaUI7QUFDaEMsQUFBSSxpQkFBQyxBQUFFLEdBQUMsQUFBRyxJQUFYLEFBQVksUUFBUSxBQUFJLEtBQUMsQUFBRSxHQUFDLEFBQUcsSUFBWCxBQUFZLGVBQVosQUFBMkIsU0FBM0IsQUFBb0MsV0FBeEQsQUFDZ0M7QUFDaEM7QUFDQSxBQUFJLGlCQUFKLEFBQUssYUFBTCxBQUFrQixRQUFsQixBQUEwQixLQUExQixBQUErQixJQUEvQixBQUFtQyxRQUFuQyxBQUEyQyxBQUMzQztBQWxCUjs7ZUFBQSxBQW9CUztBQUNELEFBQUUsZUFBRixBQUFHLFlBQVksQUFBSSxLQUFKLEFBQUssOEJBQThCLEFBQUUsR0FBckMsQUFBc0MsV0FBdEMsQUFDaUI7QUFDaEMsQUFBSSxpQkFBQyxBQUFFLEdBQUMsQUFBRyxJQUFYLEFBQVksV0FBVywwQ0FBQSxBQUNQLFVBQVUsQUFBSSxLQUFDLEFBQUUsR0FBQyxBQUFHLElBQVgsQUFBWSxlQUFaLEFBQTJCLFNBRDlCLEFBQ0csQUFDVixXQUZoQixBQUUyQjtBQUozQixBQUtBOztBQUVBLEFBQUksaUJBQUosQUFBSyxhQUFMLEFBQWtCLEdBQWxCLEFBQXFCLEtBQXJCLEFBQTBCLElBQTFCLEFBQThCLFFBQTlCLEFBQXNDLEFBQ3RDO0FBN0JSOztBQWdDUSxBQUFFLGVBQUYsQUFBRyxZQUFZLEFBQUksS0FBSixBQUFLLDhCQUE4QixBQUFFLEdBQXJDLEFBQXNDLFdBQXRDLEFBQ3FCO0FBQ3BDLEFBQUksaUJBQUMsQUFBRSxHQUFDLEFBQUcsSUFBWCxBQUFZLFNBQVMsc0JBQ0wsQUFBSSxLQUFDLEFBQUUsR0FBQyxBQUFHLElBQVgsQUFBWSxlQUFaLEFBQTJCLFNBRHRCLEFBQ0wsQUFBb0MsV0FEcEQsQUFFZ0I7bUJBQ2hCLEFBQUksS0FBSixBQUFLLGNBdENWLEFBQ0gsQUFxQ1EsQUFBbUI7O0FBeENqQjtBQTBDbEIsQUFBYzs7O2lDQUFBLEFBQUMsUUFBRCxBQUFTLE9BQVQsQUFBZ0IsT0FBaEIsQUFBdUIsUUFBdkIsQUFBK0IsV0FDekM7VUFBQSxVQUFBLE1BQUEsTUFBQSxRQUFBO0FBQUEsYUFBTztBQUNQLFVBQUcsQUFBTSxNQUFULEFBQVM7QUFDTCxlQUFPLEFBQU0sTUFBQSxBQUFNLE9BQVosQUFBYSxxQkFBYixBQUFrQyxBQUFLLEtBQTlDLEFBQThDOztBQU05QyxZQUFHLFFBQVMsQUFBQyxLQUFELEFBQUMsZUFBYixBQUFZLEFBQWdCO0FBQ3hCLGtCQUFRLEFBQUksS0FBQztBQUViLGNBQUcsV0FBSCxBQUFhO0FBQ1QsdUJBREosQUFDZTtBQURmLGlCQUFBO0FBR0ksdUJBQVcsQUFBQyxLQUFBLEFBQWEsY0FIN0IsQUFHOEI7O0FBRTlCLEFBQUMsZUFBQSxBQUFFLEdBQUMsQUFBRyxJQUFQLEFBQVEsUUFBUSxBQUFhLGFBQUMsV0FBZCxBQUFhLEFBQVksT0FBekMsQUFDNEM7QUFFNUMsbUJBQVMsV0FBYSxVQUFBLEFBQUMsS0FBRCxBQUFNLElBQU4sQUFBVSxJQUFWLEFBQWMsU0FBZCxBQUF1QixXQUN6QzttQkFBTyxZQUFBO0FBRUgsQUFBSSxtQkFBSixBQUFLOztBQUlMLGtCQUFHLENBQUksQUFBSSxLQUFYLEFBQU8sQUFBSztBQUNSLEFBQUUsbUJBQUYsQUFBRyxZQUFZLEFBQUksS0FBSixBQUFLLDhCQUNaLEFBQUUsR0FESyxBQUNKLFdBREksQUFDTztBQUN0QixBQUFJLHFCQUFDLEFBQUUsR0FBQyxBQUFHLElBQVgsQUFBWSxRQUFRLGdCQUNaLEFBQUksS0FBQyxBQUFFLEdBQUMsQUFBRyxJQUFYLEFBQVksZUFBWixBQUEyQixTQURmLEFBQ1osQUFBb0MsV0FENUMsQUFFUTt1QkFFUixBQUFJLEtBQUMsQUFBYSxjQUFsQixBQUFtQixVQUFuQixBQUE2QixTQUN6QixBQUFJLEtBQUosQUFBSyxpQkFBTCxBQUFzQixLQUF0QixBQUEyQixJQUEzQixBQUErQixRQUEvQixBQUF1QyxJQUQzQyxBQUNJLEFBQTJDLFVBUm5ELEFBT0ksQUFFSTtBQVRSLHFCQUFBO0FBV0ksQUFBSSxxQkFBQyxBQUFFLEdBQUMsQUFBRyxJQUFYLEFBQVksU0FBUywwQkFBckIsQUFDb0I7dUJBQ3BCLEFBQUksS0FBSixBQUFLLGNBYlQsQUFhSSxBQUFtQjtBQW5CcEI7QUFEVztBQUFGLFdBQUEsQ0FBQSxBQXFCbEIsT0FyQmtCLEFBcUJYLE9BckJXLEFBcUJKLE1BckJJLEFBcUJFLE9BckJiLEFBQVcsQUFxQlMsWUFyQnBCLEFBcUJnQztpQkFFekMsQUFBQyxLQUFELEFBQUMsZUFsQ0wsQUFrQ0ksQUFBZ0I7QUFsQ3BCLGVBQUE7QUFvQ0k7aUJBQ0EsQUFBQyxLQUFELEFBQUMsYUFBRCxBQUFjLFFBQWQsQUFBc0IsT0FBdEIsQUFBNkIsT0FBN0IsQUFBb0MsUUFyQ3hDLEFBcUNJLEFBQTRDO0FBNUNwRDtBQUFBLGFBQUE7ZUE4Q0ksQUFBQyxLQUFELEFBQUMsY0E5Q0wsQUE4Q0ksQUFBZTtBQWhEVDtBQWtEZCxBQUFlOzs7a0NBQUEsQUFBQztBQUNaLEFBQUMsV0FBRCxBQUFDLGVBQUQsQUFBZ0I7QUFDaEIsQUFBQyxXQUFBLEFBQUUsR0FBQyxBQUFHLElBQVAsQUFBUSxRQUFRLGlEQUFoQixBQUNnRDtBQUNoRCxBQUFDLFdBQUQsQUFBQyxpQkFBaUIsaURBQWxCLEFBQ3dEO2FBQ3hELEFBQUMsS0FOVSxBQU1YLEFBQUM7QUExbUJUOzs7Ozs7Ozs7Ozs7O0FDckJBLElBQUEsT0FBQTs7QUFrQkEsUUFBUSxRQUFBLEFBQVE7O0FBQ2hCLE1BQU0sUUFBQSxBQUFROztBQUdSLEFBQU0sT0FBWixBQUFhO0FBQ1QsQUFBYSxtQkFBQTs7O0FBQUMsQUFBQyxTQUFBLEtBQUY7QUFFYixBQUFhOzs7O2dDQUFBLEFBQUM7QUFDVixBQUFNLGFBQU4sQUFBTyxlQUFlLEFBQUMsS0FBQSxBQUFFLEdBQUMsQUFBRyxJQUFDO2FBQzlCLEFBQUssTUFBTCxBQUFNLGlCQUZHLEFBRVQsQUFBdUI7QUFFM0IsQUFBcUI7Ozt3Q0FBQSxBQUFDO2FBQ2xCLEFBQUssTUFBTCxBQUFNLGlCQURXLEFBQ2pCLEFBQXVCO0FBRTNCLEFBQTBCOzs7NkNBQUEsQUFBQzthQUN2QixBQUFDLEtBQUEsQUFBRSxHQUFDLEFBQUcsSUFBUCxBQUFRLGlCQUFpQixBQUFNLE9BQS9CLEFBQWdDLE1BQ1osQUFBQyxLQUFBLEFBQUUsR0FBQyxBQUFHLElBRDNCLEFBQzRCLGtDQUZOLEFBQ3RCLEFBQzhEO0FBRWxFLEFBQWtDOzs7cURBQUEsQUFBQyxTQUFELEFBQVUsUUFDeEM7VUFBQSxHQUFBLEtBQUE7QUFBQSxXQUFBLHNDQUFBOztBQUNJLEFBQU0sZUFBQyxBQUFRLFNBQWYsQUFBZ0IsS0FBSyxBQUFNLE9BRC9CLEFBQ0ksQUFBNEI7O2FBQ2hDLEFBQUssTUFBTCxBQUFNLGlCQUh3QixBQUc5QixBQUF1QjtBQUUzQixBQUFrQjs7O3FDQUFBLEFBQUMsUUFBRCxBQUFTLE1BQVQsQUFBZTthQUM3QixBQUFDLEtBQUEsQUFBRSxHQUFDLEFBQUcsSUFBUCxBQUFRLFlBQVIsQUFBb0IsUUFBcEIsQUFBNEIsVUFBNUIsQUFBc0MsTUFEeEIsQUFDZCxBQUE0QztBQUVoRCxBQUFlOzs7a0NBQUEsQUFBQyxRQUFELEFBQVMsTUFBVCxBQUFlO2FBQzFCLEFBQUMsS0FBQSxBQUFFLEdBQUMsQUFBRyxJQUFQLEFBQVEsWUFBUixBQUFvQixRQUFwQixBQUE0QixNQUE1QixBQUFrQyxNQUR2QixBQUNYLEFBQXdDO0FBRTVDLEFBQWE7OztnQ0FBQSxBQUFDLE1BQUQsQUFBTyxRQUFQLEFBQWUsTUFBZixBQUFxQixVQUM5QjtVQUFBO0FBQUE7QUFDSSxnQkFBQSxBQUFRO0FBQ1IsY0FEQSxBQUNNO0FBQ04saUJBRkEsQUFFUztBQUNULGlCQUhBLEFBR1M7QUFIVDtBQUtKLFVBQUEsQUFBRztBQUNDLEFBQUssY0FBTCxBQUFNLFNBRFYsQUFDbUI7O2FBRW5CLEFBQUMsS0FBRCxBQUFDLG9CQUFELEFBQXFCLE9BQXJCLEFBQTRCLE1BQTVCLEFBQWtDLFVBVnpCLEFBVVQsQUFBNEM7QUFFaEQsQUFBcUI7Ozt3Q0FBQSxBQUFDLE9BQUQsQUFBUSxNQUFSLEFBQWMsVUFBZCxBQUF3QjtrQkFDeEMsQUFBRSxHQUFDLEFBQUUsR0FBTixBQUFPLFdBQVAsQUFBa0IsT0FBTyxVQUFBLEFBQUMsS0FBRCxBQUFNO0FBQzNCLGtCQUFVLEFBQU8sUUFBUCxBQUFRLE9BQU8sQUFBRyxJQUFDLEFBQUssTUFBeEIsQUFBeUI7QUFDbkMsWUFBRyxBQUFJLElBQVAsQUFBTztBQUNILEFBQUssZ0JBQUwsQUFBTSxhQUFhLEFBQUksSUFBQSxBQUNTLGtCQUFDLEFBQWUsZ0JBQUM7aUJBQ2pELEFBQUMsS0FBRCxBQUFDLG9CQUFELEFBQXFCLE9BQXJCLEFBQTRCLE1BQTVCLEFBQWtDLE1BSHRDLEFBR0ksQUFBd0M7QUFINUMsZUFBQTtpQkFLSSxLQUFBLEFBQUssU0FMVCxBQUtJLEFBQWM7QUFQRztBQUF6QixPQUFBLEFBQUMsRUFBRCxBQVNBLFVBVmlCLEFBQ2pCLEFBU1U7QUFFZCxBQUFtQjs7O3NDQUFBLEFBQUMsTUFBRCxBQUFPLE1BQVAsQUFBYSxVQUM1QjtVQUFBO0FBQUE7QUFDSSxnQkFBQSxBQUFRO0FBQ1IsY0FEQSxBQUNNO0FBQ04sZ0JBRkEsQUFFUTtBQUNSLGdCQUhBLEFBR1E7QUFDUixpQkFKQSxBQUlTO0FBSlQ7YUFNSixBQUFDLEtBQUQsQUFBQywyQkFBRCxBQUE0QixPQUE1QixBQUFtQyxNQUFuQyxBQUF5QyxVQUF6QyxBQUFtRCxJQVJwQyxBQVFmLEFBQXVEO0FBRTNELEFBQTRCOzs7K0NBQUEsQUFBQyxPQUFELEFBQVEsTUFBUixBQUFjLFVBQWQsQUFBd0IsU0FBeEIsQUFBaUM7a0JBQ3hELEFBQUUsR0FBQyxBQUFFLEdBQU4sQUFBTyxXQUFQLEFBQWtCLE9BQU8sVUFBQSxBQUFDLEtBQUQsQUFBTSxNQUMzQjtZQUFBO0FBQUEsZUFBTyxBQUFHLElBQUgsQUFBSSxhQUFhLEFBQUcsSUFBQyxBQUFLLE1BQTFCLEFBQTJCO0FBRWxDLFlBQUcsQUFBSSxLQUFQLEFBQVE7QUFDSixvQkFBVSxBQUFPLFFBQVAsQUFBUSxPQUFPLEFBQUksS0FEakMsQUFDYyxBQUFvQjs7QUFFbEMsWUFBRyxBQUFJLEtBQVAsQUFBUTtBQUNKLGlCQUFPLEFBQUksS0FEZixBQUNnQjs7QUFFaEIsWUFBRyxBQUFJLElBQVAsQUFBTztBQUVILEFBQUssZ0JBQUwsQUFBTSxPQUFPO0FBQ2IsQUFBSyxnQkFBTCxBQUFNLGFBQWEsQUFBSSxJQUFBLEFBQWlCLGtCQUFDLEFBQVUsV0FBQztpQkFDcEQsQUFBQyxLQUFELEFBQUMsMkJBQUQsQUFBNEIsT0FBNUIsQUFBbUMsTUFBbkMsQUFBeUMsTUFBekMsQUFBK0MsU0FKbkQsQUFJSSxBQUN3RDtBQUw1RCxlQUFBO2lCQU9JLEtBQUEsQUFBSyxTQUFMLEFBQWMsTUFQbEIsQUFPSSxBQUFvQjtBQWhCSDtBQUF6QixPQUFBLEFBQUMsRUFBRCxBQWtCQSxVQW5Cd0IsQUFDeEIsQUFrQlU7QUE5RWxCOzs7Ozs7Ozs7Ozs7O0FDdEJBLElBQUE7O0FBa0JBLE9BQU8sUUFBQSxBQUFROztBQUdULEFBQU0sT0FBWixBQUFhO0FBQ1QsQUFBYSxtQkFBQTs7O0FBQUMsQUFBQyxTQUFBLEtBQUY7QUFFYixBQUFpQjs7OztvQ0FBQSxBQUFDLE1BQUQsQUFBTyxVQUNwQjtVQUFBLE1BQUEsa0JBQUEsT0FBQSxNQUFBO0FBQUEsY0FBUSxtQkFBbUIsQUFBSSxLQUFKLEFBQUssZ0JBQUwsQUFBcUIsTUFBeEMsQUFBbUIsQUFBMkI7QUFDdEQsYUFBTyxBQUFJLEtBQUosQUFBSyxnQkFBTCxBQUFxQixNQUFyQixBQUEyQjtBQUNsQyxjQUFRLEFBQUksS0FBSixBQUFLLGdCQUFMLEFBQXFCLE1BQXJCLEFBQTJCO0FBRW5DLHlCQUFtQiwwQkFBQSxBQUFDLE1BQUQsQUFBTztlQUN0QixLQUFLLEFBQUksS0FBQyxBQUFVLFVBQUEsQUFBRyxJQUF2QixBQUF3QixXQURULEFBQ2YsQUFBbUM7QUFFdkM7Y0FBQSxBQUFPO2FBQVAsQUFDUztBQUNEO0FBQ0ksa0JBQUEsQUFBTTtBQUNOLG9CQURBLEFBQ1E7QUFDUixxQkFGQSxBQUVTO0FBQ1Qsb0JBSEEsQUFHUTtBQUNSLG1CQUpBLEFBSU87QUFDUCx1QkFMQSxBQUtXO0FBTFg7aUJBTUosQUFBQyxLQUFBLEFBQUUsR0FBQyxBQUFFLEdBQU4sQUFBTyxVQUFQLEFBQWlCLE1BQWpCLEFBQ2lCLGtCQURqQixBQUVpQixHQVh6QixBQVNRLEFBR2lCO2FBWnpCLEFBYVM7QUFDRDtBQUNJLGtCQUFBLEFBQU07QUFDTixvQkFEQSxBQUNRO0FBQ1Isb0JBRkEsQUFFUTtBQUZSO2lCQUdKLEFBQUMsS0FBQSxBQUFFLEdBQUMsQUFBRSxHQUFOLEFBQU8sVUFBUCxBQUFpQixNQUFqQixBQUNpQixrQkFEakIsQUFFaUIsR0FwQnpCLEFBa0JRLEFBR2lCOztBQUVqQjtBQUNJLGtCQUFBLEFBQU07QUFDTixvQkFEQSxBQUNRO0FBQ1Isb0JBRkEsQUFFUTtBQUZSO2lCQUdKLEFBQUMsS0FBQSxBQUFFLEdBQUMsQUFBRSxHQUFOLEFBQU8sVUFBUCxBQUFpQixNQUFqQixBQUNpQixrQkFEakIsQUFFaUIsR0FyQ1osQUFRYixBQTJCUSxBQUdpQjs7QUF6Q2pDOzs7Ozs7Ozs7Ozs7O0FDckJBLElBQUEsZUFBQTs7QUFrQkEsZ0JBQWdCLFFBQUEsQUFBUTs7QUFDeEIsT0FBTyxRQUFBLEFBQVE7O0FBR1QsQUFBTSxPQUFaLEFBQWE7QUFDVCxBQUFhLG1CQUFBOzs7QUFBQyxBQUFDLFNBQUEsS0FBRjtBQUViLEFBQVU7Ozs7K0JBQ047YUFBTyxBQUFDLEtBQUEsQUFBRSxHQUFDLEFBQU0sT0FBVixBQUFXLDJCQUEyQixtQkFDakIsQUFBSSxLQUFKLEFBQUssZ0JBQUwsQUFBcUIsTUFGM0MsQUFDQyxBQUFzQyxBQUNqQixBQUEyQjtBQUUzRCxBQUFXOzs7O0FBQ0EsVUFBRyxBQUFRLFNBQVIsQUFBUyxrQkFBVCxBQUEyQixBQUFhLGFBQUEsQUFBRSxHQUE3QyxBQUE4QztlQUE5QyxBQUF5RDtBQUF6RCxhQUFBO2VBQUEsQUFDeUQ7QUFGekQ7QUFJWCxBQUFZOzs7aUNBQ1I7VUFBQTtBQUFBLGNBQVEsQUFBUSxTQUFSLEFBQVMsZUFBVCxBQUF3QixBQUFhLGNBQTdDLEFBQThDLEFBRTlDOzthQUFPLEFBQWEsY0FBYixBQUFjLHlCQUhiLEFBR0QsQUFBdUM7QUFFbEQsQUFBYTs7O2dDQUFBLEFBQUM7YUFDVixBQUFRLFNBQVIsQUFBUyxlQUFULEFBQXdCLEFBQWEsY0FBckMsQUFBc0MsUUFEN0IsQUFDcUM7QUFFbEQsQUFBYTs7O2tDQUNUO2FBQU8sQUFBUSxTQUFSLEFBQVMsZUFBVCxBQUF3QixBQUFZLGFBQXBDLEFBQXFDLGFBRG5DLEFBQ0YsQUFBa0Q7QUFFN0QsQUFBYzs7O2lDQUFBLEFBQUM7YUFDWCxBQUFRLFNBQVIsQUFBUyxlQUFULEFBQXdCLEFBQVksYUFBcEMsQUFBcUMsYUFBckMsQUFBa0QsU0FEeEMsQUFDVixBQUEyRDtBQUUvRCxBQUFpQjs7O29DQUFBLEFBQUM7YUFDZCxBQUFRLFNBQVIsQUFBUyxlQUFULEFBQXdCLEFBQVksYUFBcEMsQUFBcUMsYUFBckMsQUFBa0QsU0FDTixBQUFJLEtBQUosQUFBSyxnQkFGcEMsQUFDYixBQUNpRTtBQTNCekU7Ozs7Ozs7Ozs7Ozs7QUN0QkEsSUFBQTs7QUFrQkEsTUFBTSxRQUFBLEFBQVE7O0FBR1IsQUFBTSxPQUFaLEFBQWE7QUFDVCxBQUFhLG1CQUFBOzs7QUFvRWIsU0FBQSxpQkFBQSxLQUFBO0FBb0JBLFNBQUEsZ0JBQUEsS0FBQTtBQXhGYyxBQUFDLFNBQUEsS0FBRjtBQUViLEFBQVM7Ozs7NEJBQUEsV0FBQSxBQUFhLFNBQ2xCO1VBQUEsUUFBQSxtQkFBQSxLQUFBLFdBQUEsU0FBQSxHQUFBLEtBQUEsUUFBQSxRQUFBLFlBQUE7QUFETSxBQUFDLFdBQUE7QUFDUCxBQUFHLFVBQUgsQUFBSSxnQkFBSixBQUFvQjtBQVNwQixnQkFBVTtBQUNWLHFCQUFlLEVBQUEsQUFBRSxBQUFZLGFBQWQsQUFBZSxPQUFPLEFBQUMsS0FBRCxBQUFDLGVBQXZCLEFBQXNCLEFBQWdCO0FBRXJELFdBQUEsc0NBQUE7O0FBQ0ksaUJBQVMsSUFBQSxBQUFJLE9BQU8sQUFBQyxLQUFaLEFBQVk7QUFDckIscUJBQWEsQUFBTSxPQUFDLEFBQUksS0FEeEIsQUFDeUI7O0FBSXpCLFlBQUcsQ0FBSCxBQUFPLFlBQ0g7QUFESjs7QUFHQSxBQUFPLGdCQUFQLEFBQVEsS0FBUixBQUFhO0FBQ2IsaUJBQVMsRUFBQSxBQUFFLEFBQVksYUFBZCxBQUFlLEtBQWYsQUFBb0I7QUFFN0IsWUFBRyxBQUFNLE9BQUMsQUFBVyxZQUFsQixBQUFtQixTQUFRLEFBQUMsS0FBQSxBQUFFLEdBQUMsQUFBSyxrQkFBVyxBQUFDLEtBQW5ELEFBQXVDLEFBQVksQUFBVTtBQUN6RCxBQUFPLGlCQUFBLEFBQUUsR0FBVCxBQUFVLFdBRGQsQUFDeUI7O0FBRXpCLEFBQU0sZUFBTixBQUFPLFNBZlgsQUFlSSxBQUFnQjs7QUFFcEIsVUFBRyxBQUFPLFFBQVYsQUFBVztBQUNQLDRCQUFvQixFQUFBLEFBQUUsQUFDbEIsVUFEZ0IsQUFDZixLQURlLEFBQ1YsTUFEVSxBQUNKO0FBRWhCLEFBQWlCLDBCQUFqQixBQUFrQixPQUFsQixBQUF5QjtBQUV6QixVQUFBLEFBQUUsQUFDRSxZQURKLEFBQ0ssS0FETCxBQUNVLFFBRFYsQUFDa0IsQUFDZCxVQUZKLEFBRUssSUFGTCxBQUVTLEFBQ0wsZ0JBSEosQUFHSyxNQUFNLEFBQUMsS0FBRCxBQUFDLGNBSFosQUFHVyxBQUFlLEFBQ3RCLFVBSkosQUFJSyxTQUpMLEFBSWM7QUFFZCxVQUFBLEFBQUUsQUFDRSxZQURKLEFBQ0ssS0FETCxBQUNVLFFBRFYsQUFDa0IsQUFDZCxZQUZKLEFBRUssT0FBTyxBQUFDLEtBRmIsQUFFYSxBQUNULFdBSEosQUFHSyxTQUhMLEFBR2M7QUFFZCxVQUFBLEFBQUUsQUFDRSxXQURKLEFBQ0ssS0FETCxBQUNVLEFBQ04sWUFGSixBQUVLLFNBRkwsQUFFYztBQUVkLG9CQUFZLEVBQUEsQUFBRSxBQUNWLFVBRFEsQUFDUCxLQURPLEFBQ0YsTUFyQlYsQUFvQlksQUFDSTs7QUFHaEIsVUFBQSxBQUFFLEFBQVMsVUFBWCxBQUFZLFNBQVosQUFBcUI7QUFDckIsQUFBQyxhQUFELEFBQUMsaUJBQUQsQUFBa0IsV0FBbEIsQUFBNkIsU0FBUyxBQUFhLGFBQUEsQUFBRSxHQUFyRCxBQUFzRDtBQUV0RCxjQUFNLEVBQUEsQUFBRSxBQUNKLFVBREUsQUFDRCxLQURDLEFBQ0ksTUFESixBQUNVLEFBQ1oscUJBRkUsQUFFRCxPQUZDLEFBRU0sQUFDUixtQkFIRSxBQUdELE9BSEMsQUFHTSxBQUNaO2VBQU8sQUFBSSxJQWhDZixBQWdDZTtBQWhDZixhQUFBLEFBa0NJO2VBbENKLEFBa0NXO0FBaEVOO0FBa0VULEFBQWdCOzs7bUNBQUEsQUFBQztBQUNiOzthQUFPLFVBQUEsQUFBQyxPQUNKO1lBQUEsSUFBQSxJQUFBO0FBQUEsYUFBSyxFQUFBLEFBQUU7QUFDUCxpQkFBUyxFQUFBLEFBQUUsQUFDUCwrQkFESyxBQUNKLEtBREksQUFDQyxBQUNOLFVBRkssQUFFSjtBQUNMLGFBQUssQUFBTyxPQUFBLEFBQUUsR0FBQztlQUVmLEFBQUMsTUFBRCxBQUFDLGlCQUFELEFBQWtCLElBQWxCLEFBQXNCLFNBUG5CLEFBT0gsQUFBK0I7QUFSdkI7QUFVaEIsQUFBa0I7OztxQ0FBQSxBQUFDLElBQUQsQUFBSyxTQUFMLEFBQWMsSUFDNUI7VUFBQTtBQUFBLGVBQVMsQUFBUSxRQUFBLEFBQUcsSUFBQztBQUVyQixVQUFHLGtCQUFILEFBQXFCO2VBQ2pCLEFBQUUsR0FBRixBQUFHLEFBQVUsV0FBYixBQUFjLEFBQU8sUUFBckIsQUFBc0IsWUFEMUIsQUFDSSxBQUFrQztBQUR0QyxhQUFBO2VBS0ksQUFBRSxHQUFGLEFBQUcsQUFBVSxXQUFiLEFBQWMsQUFBTyxRQUFyQixBQUFzQixZQUFZLEVBTHRDLEFBS0ksQUFBa0MsQUFBRTtBQVIxQjtBQVVsQixBQUFlOzs7a0NBQUEsQUFBQztBQUNaOzthQUFPLFVBQUEsQUFBQyxPQUNKO1lBQUEsSUFBQTtBQUFBLGlCQUFTLEVBQUEsQUFBRSxBQUNQLCtCQURLLEFBQ0osS0FESSxBQUNDLEFBQ04sVUFGSyxBQUVKO0FBQ0wsYUFBSyxBQUFPLE9BQUEsQUFBRSxHQUFDO0FBRWYsQUFBUSxnQkFBQSxBQUFJLGNBQVEsQUFBQyxPQUFyQixBQUFZLEFBQVM7ZUFFckIsQUFBSyxNQUFDLEFBQU0sT0FBWixBQUFhLFdBUlYsQUFRcUI7QUFUakI7QUFXZixBQUFXOzs7OEJBQUEsQUFBQztBQUNSLFVBQUcsQUFBQyxLQUFKLEFBQUk7ZUFDQSxFQUFBLEFBQUUsQUFBaUIsa0JBRHZCLEFBQ0ksQUFBb0I7QUFEeEIsYUFBQTtlQUdJLEVBQUEsQUFBRSxBQUFpQixrQkFIdkIsQUFHSSxBQUFvQjtBQUpqQjtBQXBHZjs7Ozs7Ozs7Ozs7OztBQ3JCQSxJQUFBOztBQWtCQSxNQUFNLFFBQUEsQUFBUTs7QUFHUixBQUFNLE9BQVosQUFBYTtBQUNULEFBQWEsbUJBQUE7OztBQUViLFNBQUEsYUFBQSxLQUFBO0FBd0JBLFNBQUEsYUFBQSxLQUFBO0FBeUZBLFNBQUEsZ0JBQUEsS0FBQTtBQUdBLFNBQUEsb0JBQUEsS0FBQTtBQWlCQSxTQUFBLGVBQUEsS0FBQTtBQXlFQSxTQUFBLHdCQUFBLEtBQUE7QUE2RUEsU0FBQSxjQUFBLEtBQUE7QUE3UmMsQUFBQyxTQUFBLEtBQUY7QUFFYixBQUFZOzs7OytCQUFBLEFBQUMsZ0JBQUQsQUFBaUIsUUFBakIsQUFBeUIsT0FDakM7VUFBQSxHQUFBLElBQUEsR0FBQSxXQUFBLEtBQUEsTUFBQSxNQUFBLE1BQUEsUUFBQSxNQUFBO0FBQUEsb0JBQWMsQUFBQyxLQUFBLEFBQUUsR0FBQyxBQUFNLE9BQVYsQUFBVyxpQkFBWCxBQUNWLFFBQ0EsQUFBYyxlQUFkLEFBQWUsS0FGTCxBQUVWLEFBQW9CO0FBR3hCLGtCQUFZO0FBQ1osV0FBQSwwQ0FBQTsyQkFBQTs7QUFHSSxlQUFPLEFBQUksS0FBQztBQUNaLGlCQUFTLEFBQUksS0FBSixBQUFLLEFBQVEsU0FBSSxBQUFJLEtBQVAsQUFBUSxXQUFlLE1BQU0sQUFBSSxLQUFqQyxBQUFrQyxXQUFuQyxBQUFrRDtBQUN4RSxhQUFBLHNDQUFBOztBQUNJLGNBQUcsQUFBRSxHQUFDLEFBQU0sT0FBVCxBQUFVLGtCQUFpQixBQUFJLEtBQWxDLEFBQThCLEFBQUs7QUFFL0IsbUJBQU8sQUFBQyxLQUFBLEFBQUUsR0FBQyxBQUFFLEdBQU4sQUFBTyxnQkFBZ0IsQUFBRSxHQUF6QixBQUEwQjtBQUNqQyxtQkFBTyxBQUFJLEtBQUosQUFBSyxRQUFMLEFBQWEsTUFBTSxtQkFDZCxBQUFDLEtBQUEsQUFBRSxHQUFDLEFBQU0sT0FBVixBQUFXLDJCQURoQixBQUFtQixBQUNkLEFBQXNDLEFBQ2xEO0FBTEo7QUFESjs7QUFRQSxBQUFTLGtCQUFULEFBQVU7QUFBTSxnQkFBRCxBQUFPO0FBQU0saUJBQWIsQUFBb0I7QUFBUSxlQUE1QixBQUFpQztBQUFNLGlCQUFPLEFBQUksS0FBbEQsQUFBbUQ7QUFBTyxrQkFBUSxBQUFJLEtBYnpGLEFBYUksQUFBZSxBQUF1RTtBQUF2RTtBQUVuQjthQXRCUSxBQXNCRDtBQUVYLEFBQVk7OzsrQkFBQSxBQUFDLFlBQUQsQUFBYSxPQUFiLEFBQW9CLGdCQUFwQixBQUNvQixXQURwQixBQUMrQixXQUQvQixBQUMwQyxTQUQxQyxBQUNtRDtBQUMzRDs7VUFBQTtBQUFBO0FBQ0ksZ0JBQUEsQUFBUTtBQUNSLGNBREEsQUFDTTtBQUNOLGdCQUZBLEFBRVE7QUFDUixpQkFIQSxBQUdTO0FBQ1QsZ0JBSkEsQUFJUTtBQUNSLGNBTEEsQUFLTTtBQUNOLGdCQU5BLEFBTVE7QUFDUixvQkFSSixBQUNJLEFBT1k7QUFQWjs7QUFXSixVQUFHLENBQUgsQUFBTztBQUNILEFBQUssY0FBTCxBQUFNLFlBRFYsQUFDc0I7O2tCQUVyQixBQUFFLEdBQUMsQUFBRSxHQUFOLEFBQU8sV0FBUCxBQUNJLE9BQ0EsVUFBQSxBQUFDLEtBQUQsQUFBTSxNQUNGO1lBQUEsV0FBQSxPQUFBLE9BQUEsV0FBQSxNQUFBLFFBQUE7QUFBQSxZQUFHLEFBQUcsSUFBQyxBQUFLLE1BQVosQUFBYTtBQUNULGlCQUFPLEFBQUcsSUFBSCxBQUFJLGFBQWEsQUFBRyxJQUFDLEFBQUssTUFBMUIsQUFBMkI7QUFDbEMsY0FBRyxBQUFJLEtBQVAsQUFBUTtBQUNKLG9CQUFRO0FBQ1IscUJBQVMsQUFBSSxLQUFDLEFBQVUsVUFBQSxBQUFHLEdBQUE7QUFDM0Isd0JBQVksQUFBSSxLQUFDLEFBQVUsVUFBQSxBQUFFLEdBQUM7QUFDOUIsd0JBQVksQUFBSSxLQUFDO0FBQ2pCLG9CQUFRLEFBQUcsSUFBQyxBQUFLLE1BQUM7QUFDbEIsd0JBQVksQUFBQyxNQUFBLEFBQUUsR0FBQyxBQUFhLGNBQWpCLEFBQWtCLFdBQWxCLEFBQ1ksZ0JBRFosQUFDNEIsUUFQNUMsQUFNZ0IsQUFDb0M7QUFQcEQsaUJBQUE7QUFVSSxvQkFBUTtBQUNSLHFCQUFTO0FBQ1Qsd0JBQVk7QUFDWix3QkFBWTtBQUNaLG9CQUFRLEFBQUcsSUFBQyxBQUFLLE1BQUM7QUFDbEIsd0JBZkosQUFlZ0I7QUFqQnBCO0FBQUEsbUJBbUJRLEFBQUcsSUFBQyxBQUFLLE1BQVosQUFBYTtBQUdkLGtCQUFRO0FBQ1IsbUJBQVM7QUFDVCxzQkFBWTtBQUNaLHNCQUFZO0FBQ1osa0JBQVEsQUFBRyxJQUFDLEFBQUssTUFBQztBQUNsQixzQkFSQyxBQVFXO0FBUlgsU0FBQSxNQUFBO0FBWUQsa0JBQVE7QUFDUixtQkFBUztBQUNULHNCQUFZO0FBQ1osc0JBQVk7QUFDWixrQkFBUSxBQUFHLElBQUMsQUFBSyxNQUFDO0FBQ2xCLHNCQWpCQyxBQWlCVzs7ZUFFaEIsUUFBQSxBQUNJLE9BREosQUFFSSxnQkFGSixBQUdJLFdBSEosQUFJSSxPQUpKLEFBS0ksT0FMSixBQU1JLFdBTkosQUFPSSxPQVBKLEFBUUksUUFSSixBQVNJLFdBVEosQUFVSSxXQWpEUixBQXVDSSxBQVdJO0FBcERaLE9BQUEsQUFBQyxFQUFELEFBdURJLFVBQ0EsVUFBQSxBQUFDO2VBQ0csUUFBQSxBQUNJLE9BREosQUFFSSxnQkFGSixBQUdJLFdBSEosQUFJSSxPQUpKLEFBS0ksV0FMSixBQU1JLE9BTkosQUFPSSxPQVBKLEFBUUksT0FSSixBQVNJLE9BVEosQUFVSSxPQVhSLEFBQ0ksQUFXSTtBQXJGSixBQWlCUjtBQXdFSixBQUFlOzs7a0NBQUEsQUFBQyxTQUFELEFBQVUsT0FBVixBQUFpQixLQUM1Qjs7QUFBUSxpQkFBRCxBQUFVO0FBQVMsZUFBbkIsQUFBMEI7QUFBTyxhQUQ3QixBQUNKLEFBQXNDO0FBQXRDO0FBRVgsQUFBbUI7OztzQ0FBQSxBQUFDLFNBQUQsQUFBVSxPQUFWLEFBQWlCLEtBQWpCLEFBQXNCLE9BQXRCLEFBQTZCLFFBQTdCLEFBQ3lCLFdBRHpCLEFBQ29DLFdBRHBDLEFBQytDLE9BQzlEO1VBQUEsT0FBQSxHQUFBLEtBQUE7QUFBQTtBQUNJLGlCQUFBLEFBQVM7QUFDVCxlQURBLEFBQ087QUFDUCxhQUZBLEFBRUs7QUFDTCxlQUhBLEFBR087QUFDUCxnQkFKQSxBQUlRO0FBQ1IsbUJBTEEsQUFLVztBQUNYLG1CQU5BLEFBTVc7QUFDWCxlQVBBLEFBT087QUFQUDtBQVNKLFdBQUEsb0NBQUE7O0FBQ0ksQUFBSyxjQUFDLEFBQUssTUFBWCxBQUFZLEtBRGhCLEFBQ0ksQUFBaUI7QUFFckI7YUFmZSxBQWVSO0FBRVgsQUFBYzs7O2lDQUFBLEFBQUMsY0FBRCxBQUFlLFVBQWYsQUFBeUIsZ0JBQXpCLEFBQ2tCLFdBRGxCLEFBQzZCLFdBRDdCLEFBQ3dDLFNBRHhDLEFBQ2lELFVBQzNEO1VBQUEsTUFBQSxTQUFBLFlBQUEsS0FBQSxPQUFBO0FBQUEsV0FBQSxPQUFBO0FBQ0ksZUFBTyxBQUFTLFNBQUEsQUFDaEI7QUFGSjs7QUFJQSxVQUFBLEFBQUc7QUFDQyxlQUFPLEFBQVMsU0FBQTtBQUVoQixjQUFNLEFBQUksS0FGVixBQUVXOztBQUtYLHFCQUFhLG1CQUFtQixBQUFDLEtBQUEsQUFBRSxHQUFDLEFBQUUsR0FBTixBQUFPLG9CQUExQixBQUFtQixBQUEyQjtBQUUzRCxZQUFBLEFBQUc7QUFDQyxvQkFBVSxBQUFJLEtBQUM7QUFDZixrQkFBUSxBQUFJLEtBRFosQUFDYTs7QUFPYixjQUFHLGFBQWEsQUFBUyxVQUFULEFBQVUsUUFBVixBQUFrQixPQUFPLENBQXpDLEFBQTBDO0FBQ3RDLEFBQUMsaUJBQUEsQUFBRSxHQUFDLEFBQUcsSUFBUCxBQUFRLFFBQVEsYUFDSixBQUFDLEtBQUEsQUFBRSxHQUFDLEFBQUcsSUFBUCxBQUFRLFdBQVIsQUFBbUIsS0FBSyxPQUFBLEFBQU8sVUFBUCxBQUFpQixNQUFqQixBQUN4QixRQUZJLEFBQ0osQUFDUSxRQUZwQixBQUU0QjttQkFFNUIsQUFBSSxLQUFKLEFBQUssV0FBTCxBQUNJLFlBREosQUFFSSxPQUZKLEFBR0ksZ0JBSEosQUFJSSxXQUpKLEFBS0ksV0FDQSxBQUFDLEtBQUEsQUFBRSxHQUFDLEFBQWEsY0FOckIsQUFNc0IsdUJBQ2xCLENBQUEsQUFBQyxLQUFELEFBQU0sS0FBTixBQUFXLFNBQVgsQUFBb0IsY0FBcEIsQUFBa0MsVUFBbEMsQUFBNEMsU0FacEQsQUFLSSxBQU9JLEFBQzRDO0FBYnBELGlCQUFBO21CQWdCSSxBQUFDLEtBQUEsQUFBRSxHQUFDLEFBQWEsY0FBakIsQUFBa0Isc0JBQWxCLEFBQ0ksT0FESixBQUVJLGdCQUZKLEFBR0ksV0FISixBQUlJLFdBSkosQUFLSSxrQkFMSixBQU1JLElBTkosQUFPSSxPQVBKLEFBUUksTUFSSixBQVNJLE1BVEosQUFVSSxNQUNBLENBQUEsQUFBQyxLQUFELEFBQU0sS0FBTixBQUFXLFNBQVgsQUFBb0IsY0FBcEIsQUFBa0MsVUFBbEMsQUFBNEMsU0EzQnBELEFBZ0JJLEFBV0ksQUFDNEM7QUFyQ3hEO0FBQUEsZUFBQTtBQXlDSSxBQUFDLGVBQUEsQUFBRSxHQUFDLEFBQUcsSUFBUCxBQUFRLFdBQVcsd0NBQ1AsQUFBQyxLQUFBLEFBQUUsR0FBQyxBQUFHLElBQVAsQUFBUSxXQUFSLEFBQW1CLEtBQUssVUFEakIsQUFDUCxBQUF3QixBQUFVLFFBRDlDLEFBRVk7aUJBRVosQUFBQyxLQUFBLEFBQUUsR0FBQyxBQUFhLGNBQWpCLEFBQWtCLGFBQWxCLEFBQ0ksY0FESixBQUVJLFVBRkosQUFHSSxnQkFISixBQUlJLFdBSkosQUFLSSxXQUxKLEFBTUksU0FuRFIsQUE2Q0ksQUFPSTtBQTlEWjtBQUFBLGFBQUE7ZUFpRUksUUFBQSxBQUFRLGNBakVaLEFBaUVJLEFBQXNCO0FBdkVoQjtBQXlFZCxBQUF1Qjs7OzBDQUFBLEFBQUMsT0FBRCxBQUFRLGdCQUFSLEFBQ0ssV0FETCxBQUNnQixXQURoQixBQUMyQixPQUQzQixBQUNrQyxXQURsQyxBQUVLLE9BRkwsQUFFWSxRQUZaLEFBRW9CLFdBRnBCLEFBRStCLFdBRi9CLEFBRTBDLE1BQzdEO1VBQUEsVUFBQSxTQUFBLEdBQUEsS0FBQSxNQUFBLFVBQUEsT0FBQSxTQUFBLEtBQUEsS0FBQSxjQUFBO0FBQUEsWUFBTSxBQUFLLEtBQUE7QUFDWCxZQUFNLEFBQUssS0FBQTtBQUNYLGdCQUFVLEFBQUssS0FBQTtBQUNmLHFCQUFlLEFBQUssS0FBQTtBQUNwQixpQkFBVyxBQUFLLEtBQUE7QUFDaEIsZ0JBQVUsQUFBSyxLQUFBO0FBQ2YsaUJBQVcsQUFBSyxLQUFBO0FBRWhCLFVBQUcsVUFBSCxBQUFZO0FBQ1IsQUFBQyxhQUFBLEFBQUUsR0FBQyxBQUFHLElBQVAsQUFBUSxXQUFXLEFBQUMsS0FBQSxBQUFFLEdBQUMsQUFBRyxJQUFQLEFBQVEsV0FBUixBQUFtQixLQUNsQixPQUFBLEFBQU8sVUFBUCxBQUFpQixNQUFqQixBQUF1QixRQUR4QixBQUNnQyxRQUZ2RCxBQUNJLEFBRW9CO0FBSHhCLGFBQUE7QUFPSSxZQUFHLFVBQUgsQUFBWTtBQUNSLEFBQUMsZUFBQSxBQUFFLEdBQUMsQUFBRyxJQUFQLEFBQVEsV0FBVyxBQUFDLEtBQUEsQUFBRSxHQUFDLEFBQUcsSUFBUCxBQUFRLFdBQVIsQUFBbUIsS0FDdEIsT0FBQSxBQUFPLFVBQVAsQUFBaUIsTUFBakIsQUFBdUIsUUFEcEIsQUFDNEIsUUFGbkQsQUFDSSxBQUVnQjtBQUhwQixtQkFLUSxVQUFILEFBQVk7QUFDYixBQUFDLGVBQUEsQUFBRSxHQUFDLEFBQUcsSUFBUCxBQUFRLFdBQVcsQUFBQyxLQUFBLEFBQUUsR0FBQyxBQUFHLElBQVAsQUFBUSxXQUFSLEFBQW1CLEtBQ3RCLE9BQUEsQUFBTyxVQUFQLEFBQWlCLE1BQWpCLEFBQXVCLFFBRHBCLEFBQzRCLFFBRjlDLEFBQ0QsQUFFZ0I7QUFIZixTQUFBLE1BS0EsSUFBRyxVQUFILEFBQVk7QUFDYixBQUFDLGVBQUEsQUFBRSxHQUFDLEFBQUcsSUFBUCxBQUFRLFdBQVcsQUFBQyxLQUFBLEFBQUUsR0FBQyxBQUFHLElBQVAsQUFBUSxXQUFSLEFBQW1CLEtBQ3RCLE9BQUEsQUFBTyxVQUFQLEFBQWlCLE1BQWpCLEFBQXVCLFFBRHBCLEFBQzRCLFFBRDVCLEFBRUgsa0NBRkcsQUFFK0IsTUFIakQsQUFDRCxBQUdnQjs7QUFHcEIsQUFBYSxxQkFBYixBQUFhLE9BQU8sQUFBQyxLQUFBLEFBQUUsR0FBQyxBQUFhLGNBQWpCLEFBQWtCLGtCQUFsQixBQUFvQyxTQUFwQyxBQUNZLE9BRFosQUFDbUIsS0FEbkIsQUFDd0IsT0FEeEIsQUFDK0IsUUFEL0IsQUFFWSxXQUZaLEFBRXVCLFdBRnZCLEFBRWtDO0FBRXRELGFBQUEsd0NBQUE7O0FBQ0ksa0JBQVEsQUFBUyxTQUFBLEFBQUksS0FBQyxBQUFJLEtBQVQsQUFBVTtBQUMzQixrQkFBUSxBQUFhLGFBQUEsQUFBSSxLQUFDLEFBQUksS0FBVCxBQUFVO0FBRS9CLGNBQUcsQ0FBQSxBQUFJLFNBQVUsQ0FBakIsQUFBcUI7QUFDakIsQUFBUyxxQkFBQSxBQUFJLEtBQUMsQUFBSSxLQUFsQixBQUFTLEFBQVUsaUJBQ0gsQUFBQyxLQUFBLEFBQUUsR0FBQyxBQUFhLGNBQWpCLEFBQWtCLGNBQWMsQUFBSSxLQUFwQyxBQUFxQyxNQUNqQixBQUFJLEtBRHhCLEFBQ3lCLE9BQU8sQUFBSSxLQUh4RCxBQUVvQixBQUNxQztBQUh6RCxxQkFJUSxTQUFVLEFBQUssTUFBTCxBQUFNLFFBQU8sQUFBSSxLQUE5QixBQUErQjtBQUloQyxBQUFDLGlCQUFBLEFBQUUsR0FBQyxBQUFHLElBQVAsQUFBUSxXQUFXLCtDQUNKLEFBQUMsS0FBQSxBQUFFLEdBQUMsQUFBRyxJQUFQLEFBQVEsV0FBVyxBQUFJLEtBQXZCLEFBQXdCLEtBQUssT0FDeEMsQUFBSSxLQURvQyxBQUNuQyxPQURtQyxBQUM1QixNQUFNLEFBQUksS0FEa0IsQUFDakIsUUFGUixBQUNKLEFBQ29CLFFBRmhCLEFBRXdCLFVBQ3ZDLEFBQUMsS0FBQSxBQUFFLEdBQUMsQUFBRyxJQUFQLEFBQVEsV0FBVyxBQUFLLE1BQXhCLEFBQXlCLEtBQUssT0FBTyxBQUFJLEtBQVgsQUFBWSxPQUFaLEFBQW1CLE1BQ2pELEFBQWEsYUFBQSxBQUFJLEtBQUMsQUFBSSxLQUFULEFBQVUsQUFBYyxlQURQLEFBQ1EsUUFSekMsQUFJRCxBQUdJLEFBQzhDO0FBUmpELFdBQUEsTUFVQSxJQUFHLFNBQVUsQUFBSyxNQUFMLEFBQU0sUUFBTyxBQUFJLEtBQTlCLEFBQStCO0FBSWhDLEFBQUMsaUJBQUEsQUFBRSxHQUFDLEFBQUcsSUFBUCxBQUFRLFdBQVcsK0NBQ0osQUFBQyxLQUFBLEFBQUUsR0FBQyxBQUFHLElBQVAsQUFBUSxXQUFXLEFBQUksS0FBdkIsQUFBd0IsS0FBSyxPQUN4QyxBQUFJLEtBRG9DLEFBQ25DLE9BRG1DLEFBQzVCLE1BQU0sQUFBSSxLQURrQixBQUNqQixRQUZSLEFBQ0osQUFDb0IsUUFGaEIsQUFFd0IsVUFDdkMsQUFBQyxLQUFBLEFBQUUsR0FBQyxBQUFHLElBQVAsQUFBUSxXQUFXLEFBQUssTUFBeEIsQUFBeUIsS0FBSyxPQUFPLEFBQUksS0FBWCxBQUFZLE9BQVosQUFBbUIsTUFDakQsQUFBUyxTQUFBLEFBQUksS0FBQyxBQUFJLEtBQVQsQUFBVSxBQUFjLGVBREgsQUFDSSxRQVJyQyxBQUlELEFBR0ksQUFDMEM7QUExQnREO0FBNUJKOzthQXdEQSxBQUFDLEtBQUEsQUFBRSxHQUFDLEFBQWEsY0FBakIsQUFBa0IsYUFBbEIsQUFDSSxjQURKLEFBRUksVUFGSixBQUdJLGdCQUhKLEFBSUksV0FKSixBQUtJLFdBTEosQUFNSSxTQXpFZSxBQW1FbkIsQUFPSTtBQUdSLEFBQWE7OztnQ0FBQSxBQUFDLE1BQUQsQUFBTyxLQUFQLEFBQVksT0FBWixBQUFtQixRQUFuQixBQUEyQixVQUEzQixBQUFxQyxVQUM5QztVQUFBLE1BQUEsV0FBQSxXQUFBLE1BQUEsR0FBQSxJQUFBLEdBQUEsS0FBQSxNQUFBLE1BQUEsVUFBQSxPQUFBLE9BQUEsS0FBQSxVQUFBLFFBQUE7QUFBQSxhQUFPLEFBQUksS0FBSixBQUFLO0FBQ1osaUJBQVc7QUFFWCxXQUFBLE9BQUE7QUFDSSxZQUFHLFFBQUgsQUFBVTtBQUNOLGlCQUFPLEFBQVMsU0FBQTtBQUNoQixxQkFEQSxBQUNXOztBQU1YLGVBQUEsb0NBQUE7O0FBQ0ksZ0JBQUcsQUFBRSxHQUFDLEFBQU0sT0FBVCxBQUFVLGtCQUFpQixBQUFHLElBQWpDLEFBQThCLEFBQUk7QUFDOUIsQUFBUSx1QkFBUixBQUFTLEtBQUssT0FBTyxBQUFJLEtBQVgsQUFBWSxVQUFaLEFBQXNCLE1BQ0osQUFBSSxLQUR0QixBQUN1QixRQURyQyxBQUM2QztBQUM3Qyx5QkFBVyxBQUNYO0FBSko7QUFESjs7QUFPQSxjQUFHLENBQUgsQUFBTztBQUNILEFBQUMsaUJBQUEsQUFBRSxHQUFDLEFBQUcsSUFBUCxBQUFRLFdBQVcsTUFBQSxBQUFNLCtDQUNKLEFBQUMsS0FBQSxBQUFFLEdBQUMsQUFBRyxJQUFQLEFBQVEsV0FBUixBQUFtQixLQUFLLE9BQ3pDLEFBQUksS0FEcUMsQUFDcEMsVUFEb0MsQUFDMUIsTUFBTSxBQUFJLEtBRGdCLEFBQ2YsUUFGWCxBQUNFLEFBQ2lCLFFBSDFDLEFBQ0ksQUFHSTtBQW5CWjtBQURKOztBQXNCQSxBQUFRLGVBQVIsQUFBUyxLQUNMLFVBQUEsQUFBQyxHQUFELEFBQUksR0FBSjtBQUVJLFlBQUcsQUFBQyxFQUFELEFBQUUsZ0JBQWdCLEFBQUMsRUFBdEIsQUFBcUIsQUFBRSxlQUNuQjtpQkFESixBQUNXOztBQUNYLFlBQUcsQUFBQyxFQUFELEFBQUUsZ0JBQWdCLEFBQUMsRUFBdEIsQUFBcUIsQUFBRSxlQUNuQjtpQkFBTyxDQURYLEFBQ1k7QUFEWixlQUFBLEFBR0k7aUJBSEosQUFHVztBQVBmO0FBREo7QUFXQSxrQkFBWTtBQUNaLGVBQVM7QUFFVCxXQUFBLHlDQUFBOztBQUNJLHFCQUFhLEFBQU0sT0FBTixBQUFPLFVBQVAsQUFBaUIsUUFBUSxBQUFJLEtBQTdCLEFBQThCO0FBQzNDLGlCQUFTLEFBQUksS0FBSixBQUFLLFFBQVEsQUFBSSxLQUY5QixBQUUrQjs7QUFFL0IsbUJBQWEsQUFBTSxPQUFOLEFBQU8sVUFBUCxBQUFpQjtBQUU5QixVQUFHLEFBQVEsU0FBWCxBQUFZO0FBRVIsb0JBQVksQUFBUyxTQUFBLEFBQUUsR0FGM0IsQUFFNEI7QUFGNUIsYUFBQTtBQUlJLG9CQUpKLEFBSWdCOztBQUVoQixjQW5EQSxBQW1EUTs7QUFJUixhQUFPLEFBQVMsVUFBVCxBQUFVLFVBQVYsQUFBb0IsR0FBcEIsQUFBdUIsQUFBVSxXQUFqQyxBQUFrQztBQUV6QyxVQUFBLEFBQUc7QUFDQyxBQUFLLGNBQUwsQUFBTSxLQURWLEFBQ0ksQUFBVzs7QUFFZixjQUFRLEFBQVEsU0FBUixBQUFTLEtBQVQsQUFBYztBQUV0QixVQUFBLEFBQUc7QUFDQyxBQUFLLGNBQUwsQUFBTSxLQURWLEFBQ0ksQUFBVzs7QUFFZixhQUFPLEFBQVMsVUFBVCxBQUFVLE9BQVYsQUFBaUIsQUFBVSxXQUEzQixBQUE0QjtBQUVuQyxVQUFBLEFBQUc7QUFDQyxBQUFLLGNBQUwsQUFBTSxLQURWLEFBQ0ksQUFBVztBQXBFZjs7QUE0RUEsZ0JBQVUsQUFFVjthQUFPLEFBQUssTUFBTCxBQUFNLEtBQU4sQUFBVyxRQUFRLEFBQU8sUUFBUCxBQUFRLEtBL0V6QixBQStFaUIsQUFBYTtBQTdXL0M7Ozs7Ozs7Ozs7Ozs7QUNyQkEsSUFBQSxLQUFBLEFBa0JBOztlQUFRLFFBQVIsQUFBUSxBQUFROztBQUFoQixBQUFDOzs7QUFDRCxNQUFNLFFBQUEsQUFBUTs7QUFHUixBQUFNLE9BQUM7TUFBYjs7TUFBQTtBQUNJLEFBQWEscUJBQUE7QUFDVDs7VUFBQSxTQUFBO0FBRFUsQUFBQyxXQUFBO0FBQ1gsQUFBQyxXQUFELEFBQUMsMkJBQUQsQUFBNEI7O0FBSTVCO0FBQ0k7QUFDSSxrQkFBQSxBQUFRO0FBQ1Isa0JBREEsQUFDUTtBQUNSLG1CQUZBLEFBRVM7QUFDVCxvQkFIQSxBQUdVO0FBQ1Ysa0JBSkEsQUFJUTtBQUNSLDhCQUxBLEFBS29CO0FBRXBCO0FBQ0ksb0JBQUEsQUFBUTtBQUNSLHFCQURBLEFBQ1M7QUFDVCwyQkFGQSxBQUVlO0FBQ2YsbUJBWEosQUFRSSxBQUdPO0FBSFA7QUFLSjtBQUNJLG9CQUFBLEFBQVE7QUFDUiwyQkFmSixBQWNJLEFBQ2U7QUFEZjtBQUdKO0FBQ0ksb0JBbEJKLEFBa0JJLEFBQVE7QUFBUjtBQUVKO0FBQ0kscUJBckJKLEFBcUJJLEFBQVM7QUFBVDtBQUVKO0FBQ0kscUJBeEJKLEFBd0JJLEFBQVM7QUFBVDtBQUVKO0FBQ0kscUJBM0JKLEFBMkJJLEFBQVM7QUFBVDtBQUVKO0FBQ0ksbUJBOUJKLEFBOEJJLEFBQU87QUFBUDtBQUVKO0FBQ0ksbUJBakNKLEFBaUNJLEFBQU87QUFBUDtBQUVKO0FBQ0ssbUJBcENMLEFBb0NLLEFBQU87QUFBUDtBQUVMO0FBQ0ksbUJBQUEsQUFBTztBQUNQLCtCQXpDUixBQUNJLEFBdUNJLEFBQ21CLEFBRS9CO0FBSFk7QUF2Q0o7QUFESjs7c0NBMkNRLEFBQUksaUJBQUosQUFDUjtBQUFTLHlCQURELEFBQ0EsQUFBa0IsQUFBZTtBQUFqQyxPQURBLEFBQUcsRUFBZixBQUFZLEFBQ2tDOztBQUQ5QyxBQUFDOztBQUVELEFBQUMsV0FBRCxBQUFDLFVBbkRRLEFBbURFO0FBRWYsQUFBYzs7OztxQ0FDVjtZQUFBLEtBQUE7QUFBQSxjQUFNLEFBQVEsU0FBUixBQUFTLGNBQVQsQUFBdUI7QUFDN0IsQUFBRyxZQUFILEFBQUksS0FBSztBQUVULGNBQU0sQUFBUSxTQUFSLEFBQVMsY0FBVCxBQUF1QjtBQUM3QixBQUFHLFlBQUgsQUFBSSxZQUFZLEFBQUMsS0FBakIsQUFBZ0IsQUFBQztBQUNqQixBQUFHLFlBQUgsQUFBSSxZQUFZLEFBQVEsU0FBUixBQUFTLGVBQXpCLEFBQWdCLEFBQXdCO0FBQ3hDLEFBQUcsWUFBSCxBQUFJLFlBQVksQUFBQyxLQUFqQixBQUFnQixBQUFDO0FBQ2pCLEFBQUcsWUFBSCxBQUFJLFlBQUosQUFBZ0I7QUFFaEIsQUFBQyxhQUFELEFBQUMsVUFBVSxBQUFRLFNBQVIsQUFBUyxjQUFULEFBQXVCO0FBQ2xDLEFBQUMsYUFBQSxBQUFPLFFBQVIsQUFBUyxZQUFZLEFBQUMsS0FBQSxBQUFPLFFBQUM7QUFDOUIsQUFBRyxZQUFILEFBQUksWUFBWSxBQUFDLEtBQWpCLEFBQWlCLEFBRWpCO2VBZFUsQUFjSDtBQUVYLEFBQWdCOzs7O0FBQ1o7O1lBQUE7QUFBQSxlQUFPLEFBQVEsU0FBUixBQUFTLGNBQVQsQUFBdUI7QUFDOUIsQUFBSSxhQUFKLEFBQUssT0FBTztBQUNaLEFBQUksYUFBSixBQUFLLFlBQVksQUFBQyxLQUFELEFBQUM7QUFFbEIsQUFBSSxhQUFKLEFBQUssaUJBQUwsQUFBc0IsU0FBUyxVQUFBLEFBQUMsT0FDNUI7Y0FBQSxHQUFBLEtBQUEsS0FBQTtBQUFBLEFBQUssZ0JBQUwsQUFBTTs7QUFHTixBQUFDLGdCQUFELEFBQUMsMkJBQTJCLENBQUksQUFBQyxNQUFBO0FBQ2pDLEFBQUksZUFBSixBQUFLLFlBQVksQUFBQyxNQUFELEFBQUM7QUFFbEIsaUJBQU8sQUFBQyxNQUFBLEFBQU8sUUFBUixBQUFTLHVCQUFULEFBQWdDO0FBRXZDLGVBQUEsbUNBQUE7O0FBQ0ksQUFBRyxnQkFBQyxBQUFLLE1BQVQsQUFBVSxVQUFVLEFBQUMsTUFEekIsQUFDd0IsQUFBQzs7aUJBRXpCLEFBQUMsTUFaMEIsQUFZM0IsQUFBQztBQVpMLFdBQUEsQUFhRSxBQUVGO2VBcEJZLEFBb0JMO0FBRVgsQUFBYzs7OztBQUNWOztZQUFBO0FBQUEsZUFBTyxBQUFRLFNBQVIsQUFBUyxjQUFULEFBQXVCO0FBQzlCLEFBQUksYUFBSixBQUFLLE9BQU87QUFDWixBQUFJLGFBQUosQUFBSyxXQUFXO0FBQ2hCLEFBQUksYUFBSixBQUFLLFlBQVk7QUFDakIsQUFBSSxhQUFKLEFBQUssS0FBSztBQUVWLEFBQUksYUFBSixBQUFLLGlCQUFMLEFBQXNCLFNBQVM7QUFDM0IsQUFBSSxlQUFKLEFBQUssT0FBTyxtQ0FDWSxtQkFBbUIsQUFBQyxPQUFwQixBQUFtQixBQUFDO2lCQUM1QyxBQUFJLEtBQUosQUFBSyxXQUFXLEFBQUMsT0FIVSxBQUdYLEFBQUM7QUFIckIsV0FBQSxBQUlFLEFBRUY7ZUFiVSxBQWFIO0FBVVgsQUFBb0I7OzsyQ0FDaEI7WUFBQSxLQUFBLE1BQUEsR0FBQSxLQUFBLE9BQUEsU0FBQSxJQUFBLE1BQUE7QUFBQSxlQUFPLEFBQUMsS0FBQSxBQUFPLFFBQVIsQUFBUyxxQkFBVCxBQUE4QjtBQUNyQyxlQUFPO0FBRVAsYUFBQSxtQ0FBQTs7QUFDSSxlQUFLLEFBQUcsSUFBSCxBQUFJLHFCQUFKLEFBQXlCO0FBQzlCLG1CQUFTLEFBQUcsR0FBQSxBQUFFLEdBQUM7QUFDZixrQkFBUSxBQUFnQixnQkFBQSxBQUFHLElBQUgsQUFBSTtBQUM1QixvQkFBVSxBQUFHLEdBQUEsQUFBRSxHQUFDO0FBRWhCLGtCQUFRLFNBQUEsQUFBUyxPQUFULEFBQWdCLFFBQWhCLEFBQXdCLE9BQXhCLEFBQStCLFVBTjNDLEFBTXFEO0FBRXJEO2VBWmdCLEFBWVQ7QUFFWCxBQUF3Qjs7OytDQUNwQjtZQUFBO0FBQUEsZUFBTyxJQUFBLEFBQUksQUFDWDtlQUFPLGdCQUFnQixBQUFJLEtBQXBCLEFBQWdCLEFBQUssZ0JBQ1osQUFBRyxJQUFILEFBQUksUUFBUSxPQUFPLEFBQUksS0FBSixBQUFLLGFBQXhCLEFBQVksQUFBeUIsSUFBckMsQUFBeUMsS0FEbEQsQUFDUyxBQUE4QyxLQUM5QyxBQUFHLElBQUgsQUFBSSxRQUFRLE9BQU8sQUFBSSxLQUF2QixBQUFZLEFBQU8sQUFBSyxZQUF4QixBQUFvQyxLQUY3QyxBQUVTLEFBQXlDLEtBQ3pDLEFBQUcsSUFBSCxBQUFJLFFBQVEsT0FBTyxBQUFJLEtBQXZCLEFBQVksQUFBTyxBQUFLLGFBQXhCLEFBQXFDLEtBSDlDLEFBR1MsQUFBMEMsS0FDMUMsQUFBRyxJQUFILEFBQUksUUFBUSxPQUFPLEFBQUksS0FBdkIsQUFBWSxBQUFPLEFBQUssZUFBeEIsQUFBdUMsS0FKaEQsQUFJUyxBQUE0QyxLQU54QyxBQU9KO0FBRXBCLEFBQXlCOzs7O0FBQ2QsWUFBRyxBQUFDLEtBQUosQUFBSTtpQkFBSixBQUFrQztBQUFsQyxlQUFBO2lCQUFBLEFBQThDO0FBRGhDO0FBR3pCLEFBQXlCOzs7O0FBQ2QsWUFBRyxBQUFDLEtBQUosQUFBSTtpQkFBSixBQUFrQztBQUFsQyxlQUFBO2lCQUFBLEFBQ3lDO0FBRjNCO0FBSXpCLEFBQWdCOzs7O2VBQ1osQUFBQyxLQUFBLEFBQU8sUUFBUixBQUFTLFlBQVksQUFBQyxLQUFBLEFBQU8sUUFBUixBQUFTLGVBQWUsQUFBQyxLQUFBLEFBQU8sUUFEekMsQUFDMEM7QUFFMUQsQUFBZTs7O29DQUFBLEFBQUMsTUFBRCxBQUFPLE1BQ2xCO1lBQUEsTUFBQSxLQUFBLEtBQUEsTUFBQTtBQUFBLGlCQUFTLEFBQVEsU0FBUixBQUFTLGNBQVQsQUFBdUI7QUFDaEMsQUFBTSxlQUFOLEFBQU8sWUFBWTtBQUNuQixjQUFNLElBQUEsQUFBSTtBQUNWLEFBQU0sZUFBTixBQUFPLFlBQVksQUFBRyxJQUFILEFBQUk7QUFFdkIsY0FBTSxBQUFRLFNBQVIsQUFBUyxjQUFULEFBQXVCO0FBQzdCLEFBQUcsWUFBSCxBQUFJLFlBTkosQUFNZ0I7O0FBR2hCLEFBQUcsWUFBSCxBQUFJLFlBQVksQUFBRyxPQUFILEFBQWEsT0FBVTtBQUV2QyxlQUFPLEFBQVEsU0FBUixBQUFTLGNBQVQsQUFBdUI7QUFDOUIsQUFBSSxhQUFKLEFBQUssWUFBTCxBQUFpQjtBQUNqQixBQUFJLGFBQUosQUFBSyxZQUFMLEFBQWlCO0FBQ2pCLEFBQUksYUFBSixBQUFLLFlBQVk7QUFFakIsWUFBRyxTQUFILEFBQVc7QUFDUCxBQUFJLGVBQUMsQUFBSyxNQUFWLEFBQVcsVUFBVSxBQUFDLEtBRDFCLEFBQ3lCLEFBQUM7QUFqQjFCOztBQW9CQSxlQUFPLEFBQUMsS0FBQSxBQUFPLFFBQVIsQUFBUyxZQUFZLEFBQUMsS0FBQSxBQUFPLFFBQTdCLEFBQThCLGlCQUNXLEFBQUMsS0FBQSxBQUFPLFFBQUM7QUFFekQsQUFBQyxhQUFBLEFBQU8sUUFBUixBQUFTLFlBQVQsQUFBcUI7QUFFckIsWUFBQSxBQUFHO2lCQUNDLEFBQUMsS0FETCxBQUNJLEFBQUM7QUEzQk07QUE2QmYsQUFBVzs7O2dDQUFBLEFBQUM7ZUFDUixBQUFDLEtBQUQsQUFBQyxjQUFELEFBQWUsTUFEUixBQUNQLEFBQXFCO0FBRXpCLEFBQVM7Ozs4QkFBQSxBQUFDLFdBQUQsQUFBWSxNQUNqQjtZQUFBO0FBQUEsb0JBQU8sQUFBSztBQUFXLHVCQUFELEFBQWM7QUFBVyxrQkFBeEMsQUFBZSxBQUFpQztBQUFqQyxTQUFmLEFBQUk7ZUFDWCxBQUFDLEtBQUQsQUFBQyxjQUFELEFBQWUsTUFGVixBQUVMLEFBQXFCO0FBRXpCLEFBQVU7OzsrQkFBQSxBQUFDO2VBQ1AsQUFBQyxLQUFELEFBQUMsY0FBRCxBQUFlLE1BRFQsQUFDTixBQUFxQjtBQUV6QixBQUFTOzs7OEJBQUEsQUFBQztlQUNOLEFBQUMsS0FBRCxBQUFDLGNBQUQsQUFBZSxNQURWLEFBQ0wsQUFBcUI7QUFFekIsQUFBWTs7O2lDQUFBLEFBQUM7ZUFDVCxBQUFDLEtBQUQsQUFBQyxjQUFELEFBQWUsTUFEUCxBQUNSLEFBQXFCO0FBRXpCLEFBQVU7OzsrQkFBQSxBQUFDO2VBQ1AsQUFBQyxLQUFELEFBQUMsY0FBRCxBQUFlLE1BRFQsQUFDTixBQUFxQjtBQUV6QixBQUFZOzs7aUNBQUEsQUFBQyxLQUFELEFBQU0sUUFBTixBQUVSO2VBQU8sZUFBQSxBQUFlLE1BQWYsQUFBcUIsUUFBckIsQUFBNkIsU0FGNUIsQUFFcUM7QUFFakQsQUFBZ0I7OztxQ0FBQSxBQUFDLE9BQUQsQUFBUSxRQU9wQjtZQUFBOztBQUFBLG1CQUFXLEFBQUMsS0FBQSxBQUFFLEdBQUMsQUFBRSxHQUFOLEFBQU8sQUFDbEI7ZUFBTyxlQUFlLEFBQVEsU0FBdkIsQUFBd0IsUUFBeEIsQUFBZ0MsUUFBaEMsQUFBd0MsUUFBeEMsQUFBZ0QsU0FSM0MsQUFRb0Q7QUFoTnhFOzs7Ozs7OztBQTJHSTtBQUNJLGVBQUEsQUFBVztBQUNYLGFBREEsQUFDUztBQUNULGNBRkEsQUFFVTtBQUNWLGFBSEEsQUFHUztBQUNULGdCQUpBLEFBSVk7QUFDWixjQUxBLEFBS1U7QUFMVjs7Ozs7Ozs7Ozs7Ozs7QUNsSVIsSUFBQSxHQUFBLE1BQUE7O0FBa0JBLE9BQU8sUUFBQSxBQUFROztBQUNmLE1BQU0sUUFBQSxBQUFRLEFBQ2Q7O2VBQU0sUUFBTixBQUFNLEFBQVE7O0FBQWQsQUFBQzs7O0FBR0ssQUFBTSxPQUFDO3FEQUFiOztNQUFBO0FBSUksQUFBYSxxQkFBQTtBQUNUOztVQUFBLFVBQUEsS0FBQTtBQURVLEFBQUMsV0FBQTtBQUNYLEFBQUMsV0FBRCxBQUFDLE1BQU0sSUFBSSxBQUFFLEdBQU4sQUFBTztBQUVkLGVBQVMsQUFBQyxLQUFELEFBQUMsY0FBYyxBQUFRLFNBQXZCLEFBQXdCO0FBQ2pDLGlCQUFXLEFBQU8sT0FBQTtBQUVsQixBQUFDLFdBQUQsQUFBQyxXQUFXO0FBRVosdUJBQWlCLEFBQU8sT0FBQTtBQUN4QixzQkFBZ0I7QUFFaEIsV0FBQSxPQUFBO0FBQ0ksQUFBYyxzQkFBZCxBQUFjLE9BQU8sV0FBVyxBQUFlLGVBRG5ELEFBQ21EO0FBWjFDO0FBc0RiLEFBQWU7Ozs7b0NBQUEsQUFBQyxNQUdaO1lBQUEsVUFBQSxPQUFBLEdBQUEsT0FBQSxHQUFBOztBQUFBLGFBQUEsZUFBQTtBQUNJLGVBQUssSUFBQSxBQUFJLE9BQUosQUFBVyxHQUFYLEFBQWM7QUFDbkIsa0JBQVEsQUFBRSxHQUFGLEFBQUcsS0FBSCxBQUFRO0FBRWhCLGNBQUEsQUFBRztBQUNDLHVCQUFXLEFBQU0sTUFBQTtBQUNqQixvQkFBUTtBQUVSLGlCQUFBLHFCQUFBO0FBQ0ksQUFBTSxvQkFBTixBQUFNLEtBQUssQUFBUyxVQUFDLEFBQU0sTUFBQSxBQUFHLEdBRGxDLEFBQ2tDO0FBRWxDO0FBUEo7QUFKSjs7QUFhQSxZQUFHLENBQUgsQUFBTztBQUNILHFCQUFXLEFBQUksS0FBSixBQUFLLGVBQUwsQUFBb0IsQUFBSyxNQUFDO0FBQ3JDLGtCQUFRO0FBRVIsZUFBQSxlQUFBO0FBQ0ksQUFBTSxrQkFBTixBQUFNLEtBQUssQUFBUyxVQUFDLEFBQVMsU0FEbEMsQUFDa0M7QUFMdEM7QUFPQTtlQUFPLENBQUEsQUFBQyxVQXZCRyxBQXVCSixBQUFXO0FBRXRCLEFBQWM7OzttQ0FBQSxBQUFDO0FBQ1gsWUFBQSxBQUFHLE1BQ0M7aUJBQU8sQUFBQyxLQUFELEFBQUMsY0FBRCxBQUFlLEFBQU0sTUFEaEMsQUFDZ0M7QUFEaEMsZUFBQSxBQUdJO2lCQUhKLEFBR1c7QUFKRDtBQU1kLEFBQWE7OztrQ0FBQSxBQUFDLE1BQUQsQUFBTyxPQUNoQjs7QUFBVSxnQkFBTSxBQUFFLEdBQUMsQUFBSSxLQUFQLEFBQVEsT0FBakIsQUFBRSxBQUFPLEFBQWU7QUFBdEIsU0FBRixFQUFnQyxTQUQ5QixBQUNGLEFBQXlDO0FBRXBELEFBQWE7OztrQ0FBQSxBQUFDLE1BQ1Y7WUFBQSxVQUFBLEtBQUEsT0FBQSxNQUFBO0FBQUEsWUFBQSxBQUFHO0FBQ0MsbUJBQVMsQUFBQyxLQUFELEFBQUMsY0FBRCxBQUFlO0FBQ3hCLHFCQUFXLEFBQU8sT0FBQTtBQUNsQixrQkFBUSxBQUFPLE9BQUE7QUFFZixpQkFBTztBQUVQLGVBQUEsT0FBQTtBQUNJLEFBQUssaUJBQUwsQUFBSyxPQUFPLFdBQVcsQUFBTSxNQURqQyxBQUNpQztBQUVqQztpQkFWSixBQVVXO0FBVlgsZUFBQSxBQWFJO2lCQWJKLEFBYVc7QUFkRjtBQWdCYixBQUFxQjs7OzBDQUFBLEFBQUMsS0FDbEI7WUFBQSxPQUFBLFVBQUEsR0FBQSxJQUFBO0FBQUEsZ0JBQVEsQUFBSSxLQUFKLEFBQUssaUJBQUwsQUFBc0IsQUFBSSxLQUFsQyxBQUFtQzs7QUFJbkMsWUFBRyxDQUFILEFBQU87QUFDSCxxQkFBVyxBQUFJLEtBQUosQUFBSyxlQUFMLEFBQW9CLEFBQUksS0FBQztBQUVwQyxlQUFBLGVBQUE7QUFDSSxpQkFBSyxJQUFBLEFBQUksT0FBSixBQUFXLEdBQVgsQUFBYztBQUNuQixvQkFBUSxBQUFFLEdBQUYsQUFBRyxLQUFILEFBQVE7QUFFaEIsZ0JBQUEsQUFBRztBQUNDLGtCQUFHLEFBQVEsU0FBUixBQUFTLFFBQVEsQUFBUyxVQUFDLEFBQU0sTUFBQSxBQUFFLEdBQW5DLEFBQW9DLFdBQXZDLEFBQWlEO0FBQzdDLHdCQUFRLEFBQVEsU0FBUixBQUFTLE9BQU8sQUFBUyxVQUFDLEFBQU0sTUFBQSxBQUNKLEdBQUMsQUFBSyxNQUY5QyxBQUNZLEFBQ21DO0FBRi9DLHFCQUFBO0FBSUksd0JBSkosQUFJWTtBQUVaO0FBUEo7QUFKSjs7QUFhQSxjQUFHLENBQUgsQUFBTztBQUNILGdCQUFHLEFBQVEsU0FBUixBQUFTLFFBQVEsQUFBUyxVQUFDLEFBQVEsU0FBbkMsQUFBb0MsV0FBdkMsQUFBaUQ7QUFDN0Msc0JBQVEsQUFBUSxTQUFSLEFBQVMsT0FBTyxBQUFTLFVBQUMsQUFBUSxTQUFDLEFBQUssTUFEcEQsQUFDWSxBQUF5QztBQURyRCxtQkFBQTtBQUdJLHNCQUhKLEFBR1k7QUFKaEI7QUFoQko7QUFzQkE7ZUEzQmlCLEFBMkJWO0FBRVgsQUFBa0I7Ozt1Q0FBQSxBQUFDO0FBQ2YsWUFBQSxBQUFHLEtBQ0M7QUFBTyxvQ0FBaUIsQUFBQyxLQUFBLEFBQUUsR0FBQyxBQUFHLElBQVAsQUFBUSxXQUFSLEFBQW1CLEtBRC9DLEFBQ1csQUFBaUIsQUFBd0I7QUFDcEQ7ZUFIYyxBQUdQO0FBRVgsQUFBWTs7O2lDQUFBLEFBQUMsUUFBRCxBQUFTLE1BQVQsQUFBZSxVQUFmLEFBQXlCOzs7QUFDakMsQUFBTSxlQUFOLEFBQU8sU0FBUyxBQUVoQjtvQkFBUSxBQUFHLElBQUosQUFBSyxJQUFMLEFBQVMsQUFDaEIsUUFETyxBQUNOLEtBQUssVUFBQSxBQUFDLE1BQUQsQUFBTyxZQUFQLEFBQW1CO0FBQ3JCLGNBQUEsQUFBRzttQkFDQyxLQUFBLEFBQUssTUFEVCxBQUNJLEFBQVc7QUFGYjtBQURDLEFBSU4sU0FKTSxBQUFDLEVBQUQsQUFJTCxLQUFLLFVBQUEsQUFBQyxPQUFELEFBQVEsWUFBUixBQUFvQjtBQUN2QixBQUFPLGtCQUFQLEFBQVEsTUFBUixBQUFjLE9BQWQsQUFBcUIsWUFBckIsQUFBaUM7QUFDakMsQUFBQyxnQkFBQSxBQUFFLEdBQUMsQUFBRyxJQUFQLEFBQVEsU0FBUyxBQUFDLE1BQWxCLEFBQWlCLEFBQUM7QUFDbEIsY0FBRyxRQUFRLG9EQUFYLEFBQUcsQUFDNkM7QUFDNUMsQUFBQyxrQkFBQSxBQUFFLEdBQUMsQUFBRyxJQUFQLEFBQVEsUUFBUixBQUFnQjttQkFDaEIsQUFBQyxNQUFELEFBQUMsV0FBRCxBQUFZLFFBQVosQUFBb0IsTUFBcEIsQUFBMEIsVUFIOUIsQUFHSSxBQUFvQztBQUh4QyxpQkFJSyxJQUFBLEFBQUc7bUJBQ0osVUFEQyxBQUNELEFBQVU7QUFSWDtBQVBDLEFBR0Q7QUFlWCxBQUFhOzs7a0NBQUEsQUFBQyxRQUFELEFBQVMsTUFBVCxBQUFlLFVBQWYsQUFBeUI7OztBQUNsQyxBQUFNLGVBQU4sQUFBTyxTQUFTLEFBRWhCO29CQUFRLEFBQUcsSUFBSixBQUFLLEtBQUwsQUFBVSxBQUNqQixRQURPLEFBQ04sS0FBSyxVQUFBLEFBQUMsTUFBRCxBQUFPLFlBQVAsQUFBbUI7QUFDckIsY0FBQSxBQUFHO21CQUNDLEtBQUEsQUFBSyxNQURULEFBQ0ksQUFBVztBQUZiO0FBREMsQUFJTixTQUpNLEFBQUMsRUFBRCxBQUlMLEtBQUssVUFBQSxBQUFDLE9BQUQsQUFBUSxZQUFSLEFBQW9CO0FBQ3ZCLEFBQU8sa0JBQVAsQUFBUSxNQUFSLEFBQWMsT0FBZCxBQUFxQixZQUFyQixBQUFpQztBQUNqQyxBQUFDLGlCQUFBLEFBQUUsR0FBQyxBQUFHLElBQVAsQUFBUSxTQUFTLEFBQUMsT0FBbEIsQUFBaUIsQUFBQztBQUNsQixjQUFHLFFBQVEsb0RBQVgsQUFBRyxBQUM2QztBQUM1QyxBQUFDLG1CQUFBLEFBQUUsR0FBQyxBQUFHLElBQVAsQUFBUSxRQUFSLEFBQWdCO21CQUNoQixBQUFDLE9BQUQsQUFBQyxZQUFELEFBQWEsUUFBYixBQUFxQixNQUFyQixBQUEyQixVQUgvQixBQUdJLEFBQXFDO0FBSHpDLGlCQUtLLElBQUEsQUFBRzttQkFDSixVQURDLEFBQ0QsQUFBVTtBQVRYO0FBUEUsQUFHRjtBQWdCWCxBQUFXOzs7OzhFQUFBLEFBQUMsUUFBRCxBQUFTLE1BQVQsQUFBZSxVQUFmLEFBQXlCLEFBQ2hDOzs7Ozs7QUFBQSxBQUFNLHlCQUFOLEFBQU8sU0FBUyxBQUVoQjs7O3lCQUNnQixBQUFDLEtBQUQsQUFBQyxXQURqQixBQUNVLEFBQU0sQUFBWTs7O0FBQXhCLEFBQU07Ozs7Ozs7O0FBQ0osQUFDRjs7dUJBQUEsQUFBRyxBQUNDOzs7OzttREFBTyxVQURYLEFBQ1csQUFBVSxBQUNyQjs7O3dCQUxKLEFBS1U7OztBQUVWLHlCQUFPLEFBQUcsSUFBSCxBQUFJLGFBQWEsQUFBRyxJQUFDLEFBQUssTUFBMUIsQUFBMkIsQUFFbEM7O3VCQUFBLEFBQUcsQUFDQzs7Ozs7bURBQU8sS0FBQSxBQUFLLE1BRGhCLEFBQ1csQUFBVyxBQUN0Qjs7O21EQWRPLEFBY0EsQUFFWCxBQUFlOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O2dGQUFBLEFBQUMsT0FBRCxBQUFRLE1BQVIsQUFBYyxBQUN6Qjs7Ozs7Ozs4QkFBYSxBQUFDO0FBQ1YsMEJBQUEsQUFBTTtBQUNOLDRCQURBLEFBQ1E7QUFDUiw2QkFGQSxBQUVTO0FBQ1QsNEJBSkcsQUFBTSxBQUNULEFBR1E7QUFIUixtQkFEUyxBQUFDOzs7QUFBZCxBQUFPOztBQU9QLDJCQUFTLEFBQUksS0FBQyxBQUFVLFVBQUEsQUFBRyxHQUFBO0FBQzNCLDhCQUFZLEFBQUksS0FBQyxBQUFVLFVBQUEsQUFBRSxHQUFDO0FBQzlCLDhCQUFZLEFBQUksS0FBQyxBQUVqQjs7dUJBQUEsQUFBRyxBQUNDOzs7OztvREFBTyxLQUFBLEFBQUssT0FBTCxBQUFZLFFBQVosQUFBb0IsV0FBcEIsQUFBK0IsV0FEMUMsQUFDVyxBQUEwQyxBQUNyRDs7O29EQUFPLEVBQUEsQUFBQyxnQkFBRCxBQUFTLHNCQWRMLEFBY0osQUFBb0IsQUFFL0IsQUFBYTs7Ozs7Ozs7Ozs7Ozs7Ozs7O2tDQUFBLEFBQUM7QUFDVjs7WUFBQSxNQUFBO0FBQUEsb0JBQVksbUJBQUEsQUFBQyxLQUFELEFBQU07QUFDZCxBQUFDLGlCQUFELEFBQUMsV0FBVztpQkFESixBQUVSOztBQUVKLFlBQUcsQ0FBSSxBQUFDLEtBQVIsQUFBUTtBQUNKO0FBQ0ksb0JBQUEsQUFBUTtBQUNSLGtCQURBLEFBQ007QUFDTixvQkFGQSxBQUVRO0FBRlI7aUJBR0osQUFBQyxLQUFELEFBQUMsV0FBRCxBQUFZLE1BQVosQUFBa0IsV0FBbEIsQUFBNkIsTUFMakMsQUFLSSxBQUFtQztBQUx2QyxlQUFBO2lCQUFBLEFBT0k7QUFaSztBQWNiLEFBQVk7OztpQ0FBQSxBQUFDLE1BQUQsQUFBTzs7O29CQUNmLEFBQUMsWUFBYSxZQUNWO2NBQUE7QUFBQSxpQkFBTyxBQUFDLE9BQUEsQUFBUSxTQUFDLEFBQUssTUFBQyxBQUFRLFNBQXhCLEFBQXlCLE9BQU07aUJBQ3RDLEtBQUEsQUFBSyxNQUZLLEFBRVYsQUFBVztBQUhQLEFBQ1IsU0FBQSxBQUFDO0FBS0wsQUFBYTs7O2tDQUFBLEFBQUMsTUFBRCxBQUFPOzs7b0JBQ2hCLEFBQUMsWUFBYTtpQkFDVixLQUFLLEFBQUMsT0FBQSxBQUFRLFNBQUMsQUFBSyxNQUFDLEFBQVEsU0FBN0IsQUFBOEIsTUFEcEIsQUFDVixBQUFvQztBQUYvQixBQUNULFNBQUEsQUFBQztBQUlMLEFBQVc7OztnQ0FBQSxBQUFDLE1BQUQsQUFBTzs7O29CQUNkLEFBQUMsWUFBYSxZQUNWO2NBQUEsUUFBQTtBQUFBLG1CQUFTLEFBQUMsT0FBQSxBQUFRLFNBQUMsQUFBSyxNQUFDLEFBQVEsU0FBQztBQUNsQyxnQkFBTSxBQUFNLE9BQU4sQUFBTyxRQUFQLEFBQWUsU0FBUyxDQUFDO2lCQUMvQixLQUFBLEFBQUssS0FISyxBQUdWLEFBQVU7QUFKUCxBQUNQLFNBQUEsQUFBQztBQU1MLEFBQWM7OzttQ0FBQSxBQUFDLFNBQUQsQUFBVSxhQUFWLEFBQXVCLE1BQXZCLEFBQTZCLFVBQ3ZDO1lBQUE7QUFBQTtBQUNJLGtCQUFBLEFBQVE7QUFDUixnQkFEQSxBQUNNO0FBQ04sbUJBRkEsQUFFUztBQUNULG1CQUhBLEFBR1M7QUFIVDtBQUtKLFlBQUEsQUFBRztBQUNDLEFBQUssZ0JBQUwsQUFBTSxjQURWLEFBQ3dCOztlQUV4QixBQUFDLEtBQUQsQUFBQyxzQkFBRCxBQUF1QixPQUF2QixBQUE4QixNQUE5QixBQUFvQyxVQVYxQixBQVVWLEFBQThDO0FBRWxELEFBQXVCOzs7NENBQUEsQUFBQyxPQUFELEFBQVEsTUFBUixBQUFjLFVBQWQsQUFBd0I7OztvQkFDM0MsQUFBQyxXQUFELEFBQVksT0FBTyxVQUFBLEFBQUMsS0FBRCxBQUFNO0FBQ3JCLHNCQUFZLEFBQVMsVUFBVCxBQUFVLE9BQU8sQUFBRyxJQUFDLEFBQUssTUFBMUIsQUFBMkI7QUFDdkMsY0FBRyxBQUFJLElBQVAsQUFBTztBQUNILEFBQUssa0JBQUwsQUFBTSxhQUFhLEFBQUksSUFBQSxBQUFpQixrQkFBQyxBQUFTLFVBQUM7bUJBQ25ELEFBQUMsT0FBRCxBQUFDLHNCQUFELEFBQXVCLE9BQXZCLEFBQThCLE1BQTlCLEFBQW9DLE1BRnhDLEFBRUksQUFBMEM7QUFGOUMsaUJBQUE7bUJBSUksS0FBQSxBQUFLLFdBSlQsQUFJSSxBQUFnQjtBQU5MO0FBQW5CLFNBQUEsQUFBQyxFQUFELEFBUUEsVUFUbUIsQUFDbkIsQUFRVTtBQUVkLEFBQWM7OzttQ0FBQSxBQUFDLE9BQUQsQUFBUSxPQUFSLEFBQWUsTUFBZixBQUFxQixVQUMvQjtZQUFBO0FBQUE7QUFDSSxrQkFBQSxBQUFRO0FBQ1IsZ0JBREEsQUFDTTtBQUNOLGtCQUZBLEFBRVE7QUFDUixtQkFIQSxBQUdTO0FBQ1QsaUJBSkEsQUFJTztBQUNQLHFCQUxBLEFBS1c7QUFMWDtBQU9KLFlBQUEsQUFBRztBQUNDLEFBQUssZ0JBQUwsQUFBTSxPQUFPO0FBQ2IsQUFBSyxnQkFBTCxBQUFNLFNBQVM7QUFDZixBQUFLLGdCQUFMLEFBQU0sYUFIVixBQUd1Qjs7ZUFFdkIsQUFBQyxLQUFELEFBQUMsc0JBQUQsQUFBdUIsT0FBdkIsQUFBOEIsTUFBOUIsQUFBb0MsVUFBcEMsQUFBOEMsSUFkcEMsQUFjVixBQUFrRDtBQUV0RCxBQUF1Qjs7OzRDQUFBLEFBQUMsT0FBRCxBQUFRLE1BQVIsQUFBYyxVQUFkLEFBQXdCLFdBQXhCLEFBQW1DOzs7b0JBQ3RELEFBQUMsV0FBRCxBQUFZLE9BQU8sVUFBQSxBQUFDLEtBQUQsQUFBTSxNQUNyQjtjQUFBO0FBQUEsaUJBQU8sQUFBRyxJQUFILEFBQUksYUFBYSxBQUFHLElBQUMsQUFBSyxNQUExQixBQUEyQjtBQUNsQyxzQkFBWSxBQUFTLFVBQVQsQUFBVSxPQUFPLEFBQUksS0FBckIsQUFBc0I7QUFFbEMsY0FBRyxBQUFHLElBQUMsQUFBSyxNQUFaLEFBQWE7QUFDVCxvQkFBUSxBQUFHLElBQUMsQUFBSyxNQURyQixBQUNzQjs7QUFFdEIsY0FBRyxBQUFLLE1BQVIsQUFBUztBQUNMLG1CQUFPLEFBQUssTUFBQztBQUNiLG1CQUFPLEFBQUssTUFBQztBQUNiLG1CQUFPLEFBQUssTUFIaEIsQUFHaUI7O0FBRWpCLGNBQUcsQUFBSSxJQUFQLEFBQU87QUFDSCxBQUFLLGtCQUFMLEFBQU0sYUFBYSxBQUFJLElBQUEsQUFBaUIsa0JBQUMsQUFBUyxVQUFDO21CQUNuRCxBQUFDLE9BQUQsQUFBQyxzQkFBRCxBQUF1QixPQUF2QixBQUE4QixNQUE5QixBQUFvQyxNQUFwQyxBQUEwQyxXQUY5QyxBQUVJLEFBQ3dEO0FBSDVELGlCQUFBO21CQUtJLEtBQUEsQUFBSyxXQUFMLEFBQWdCLE9BTHBCLEFBS0ksQUFBdUI7QUFqQlo7QUFBbkIsU0FBQSxBQUFDLEVBQUQsQUFtQkEsVUFwQm1CLEFBQ25CLEFBbUJVO0FBRWQsQUFBaUI7OztzQ0FBQSxBQUFDLE9BQ2Q7b0JBQU8sQUFBQztBQUNKLGtCQURlLEFBQ1A7QUFDUixnQkFGZSxBQUVUO0FBQ04sa0JBSlMsQUFDTixBQUFZLEFBR1A7QUFITyxTQUFaLEFBQUM7QUFNWixBQUFzQjs7OzJDQUFBLEFBQUMsT0FBRCxBQUFRLE1BQVIsQUFBYztvQkFDaEMsQUFBQztBQUVPLGtCQURKLEFBQ1k7QUFDUixnQkFGSixBQUVVO0FBQ04sa0JBSEosQUFHWTtBQUNSLHNCQUxSLEFBQ0ksQUFJZ0I7QUFKaEIsU0FESixBQUFDLEVBT0csVUFBQSxBQUFDLEtBQUQsQUFBTTtpQkFDRixLQUFLLEFBQUcsSUFBQyxBQUFLLE1BQWQsQUFBZSxjQURuQixBQUNJLEFBQTZCO0FBUnJDLFdBQUEsQUFTSSxVQVZjLEFBQ2xCLEFBVUk7QUFHUixBQUFpQjs7O3NDQUFBLEFBQUMsS0FDZDtZQUFBLEdBQUEsTUFBQSxHQUFBO0FBQUEsYUFBUyw2RkFBVDtBQUNJLGlCQUFPLEFBQUcsSUFBSCxBQUFJLFFBQVEsQUFBZSxlQUFBLEFBQUcsR0FBOUIsQUFBOEIsSUFBSSxBQUFlLGVBQUEsQUFBRyxHQUFwRCxBQUFvRDtBQUUzRCxjQUFHLFNBQUgsQUFBVyxLQUNQO21CQURKLEFBQ1c7QUFKZjtBQUFBLEFBT0E7O2VBUmEsQUFRTjtBQUVYLEFBQWdCOzs7O2dGQUFBLEFBQUMsUUFBRCxBQUFTLEFBQ3JCOzs7Ozs7QUFBQTtBQUNJLDRCQUFBLEFBQVE7QUFDUiwwQkFEQSxBQUNNO0FBQ04sNEJBRkEsQUFFUTtBQUNSLDZCQUhBLEFBR1M7QUFIVDtBQUtKLHNCQUFBLEFBQUc7QUFDQyxBQUFLLDBCQUFMLEFBQU0sT0FBTztBQUNiLEFBQUssMEJBQUwsQUFBTSxTQUZWLEFBRW1COztBQUVuQiw0QkFBVTtBQUNWLDZCQUFXLEFBRVg7Ozt1QkFBQTs7Ozs7O3lCQUNnQixBQUFDLEtBQUQsQUFBQyxXQUFQLEFBQU0sQUFBWTs7O0FBQXhCLEFBQU07O0FBQ04sNEJBQVUsQUFBTyxRQUFQLEFBQVEsT0FBTyxBQUFHLElBQUMsQUFBSyxNQUFDLEFBQVMsVUFBbEMsQUFBbUMsQUFFN0M7O0FBQUEsdUJBQUEsT0FBQTs7d0JBQWdDLFFBQU87QUFDbkMsQUFBUywrQkFBVCxBQUFTLE9BQU87QUFEcEI7O0FBR0EseUJBQU8sQUFBSyxNQUFDO0FBQ2IseUJBQU8sQUFBSyxNQUFDLEFBRWI7O3VCQUFHLEFBQUksSUFBUCxBQUFPOzs7OztBQUNILEFBQUssd0JBQUwsQUFBTSxXQUFXLEFBQUksSUFBQSxBQUFpQixrQkFBQyxBQUFTLFVBRHBELEFBQ3FELEFBQ2pELEFBRUo7Ozs7b0RBQU8sRUFBQSxBQUFDLGtCQTVCQSxBQWNaLEFBY1csQUFBVSxBQUV6QixBQUFpQjs7Ozs7Ozs7Ozs7Ozs7Ozs7O3NDQUFBLEFBQUMsUUFBRCxBQUFTLFNBQVQsQUFBa0IsT0FBbEIsQUFBeUIsTUFBekIsQUFBK0IsVUFDNUM7WUFBQTtBQUFBO0FBQ0ksa0JBQUEsQUFBUTtBQUNSLGdCQURBLEFBQ007QUFDTixrQkFGQSxBQUVRO0FBQ1Isa0JBSEEsQUFHUTtBQUNSLG1CQUpBLEFBSVM7QUFDVCxpQkFMQSxBQUtPO0FBQ1AsbUJBTkEsQUFNUztBQU5UO2VBUUosQUFBQyxLQUFELEFBQUMseUJBQUQsQUFBMEIsT0FBMUIsQUFBaUMsTUFBakMsQUFBdUMsVUFWMUIsQUFVYixBQUFpRDtBQUVyRCxBQUEwQjs7OytDQUFBLEFBQUMsT0FBRCxBQUFRLE1BQVIsQUFBYyxVQUFkLEFBQXdCOzs7b0JBQzlDLEFBQUMsV0FBRCxBQUFZLE9BQU8sVUFBQSxBQUFDLEtBQUQsQUFBTTtBQUNyQixvQkFBVSxBQUFPLFFBQVAsQUFBUSxPQUFPLEFBQUcsSUFBQyxBQUFLLE1BQXhCLEFBQXlCO0FBRW5DLGNBQUcsQUFBSSxJQUFQLEFBQU87QUFDSCxBQUFLLGtCQUFMLEFBQU0sYUFBYSxBQUFJLElBQUEsQUFBaUIsa0JBQUMsQUFDTyxhQUFDO21CQUNqRCxBQUFDLE9BQUQsQUFBQyx5QkFBRCxBQUEwQixPQUExQixBQUFpQyxNQUFqQyxBQUF1QyxNQUgzQyxBQUdJLEFBQTZDO0FBSGpELGlCQUFBO21CQUtJLEtBQUEsQUFBSyxTQUxULEFBS0ksQUFBYztBQVJIO0FBQW5CLFNBQUEsQUFBQyxFQUFELEFBVUEsVUFYc0IsQUFDdEIsQUFVVTtBQXBZbEI7Ozs7Ozs7O0FBQ0ksbUJBQWlCOztBQUNqQixrQkFBZ0I7O0FBZ0JoQjtBQUNJO0FBQ0k7QUFDSSxlQUFBLEFBQU87QUFDUCxjQURBLEFBQ007QUFDTixhQUhKLEFBQ0ksQUFFSztBQUZMO0FBR0o7QUFDSSxlQUFBLEFBQU87QUFDUCxjQURBLEFBQ007QUFDTixhQVBKLEFBS0ksQUFFSztBQUZMO0FBR0o7QUFDSSxlQUFBLEFBQU87QUFDUCxjQURBLEFBQ007QUFDTixhQVhKLEFBU0ksQUFFSztBQUZMO0FBR0o7QUFDSSxlQUFBLEFBQU87QUFDUCxjQURBLEFBQ007QUFDTixhQWZKLEFBYUksQUFFSztBQUZMO0FBR0o7QUFDSSxlQUFBLEFBQU87QUFDUCxjQURBLEFBQ007QUFDTixhQW5CSixBQWlCSSxBQUVLO0FBRkw7QUFHSjtBQUNJLGVBQUEsQUFBTztBQUNQLGNBREEsQUFDTTtBQUNOLGFBdkJKLEFBcUJJLEFBRUs7QUFGTDtBQUdKO0FBQ0ksZUFBQSxBQUFPO0FBQ1AsY0FEQSxBQUNNO0FBQ04sYUE1QlIsQUFDSSxBQXlCSSxBQUVLO0FBRkw7QUF6Qko7QUE0Qko7QUFDSSxhQUFBLEFBQU87QUFDUCxZQURBLEFBQ007QUFDTixXQWhDSixBQThCSSxBQUVLO0FBRkw7QUE5Qko7O0FBa0NKLG1CQUFpQixDQUNiLENBQUEsQUFBQyw2Q0FEWSxBQUNiLEFBQ3dCOzs7Ozs7Ozs7Ozs7QUM5RWhDLElBQUE7O0FBa0JBLE1BQU0sUUFBQSxBQUFROztBQUdSLEFBQU0sT0FBQzsyQ0FBYjs7TUFBQTtBQUNJLEFBQWEscUJBQUE7OztBQXlJYixXQUFBLHFCQUFBLEtBQUE7QUFJQSxXQUFBLGtCQUFBLEtBQUE7QUE3SWMsQUFBQyxXQUFBLEtBQUY7QUFFYixBQUFTOzs7OzhCQUFBLFdBQUEsQUFBYSxTQUNsQjtZQUFBLFFBQUEsUUFBQSxVQUFBLE9BQUEsU0FBQSxhQUFBLGNBQUEsR0FBQSxHQUFBLEtBQUEsR0FBQSxTQUFBLFNBQUEsT0FBQSxVQUFBLFlBQUEsUUFBQSxZQUFBO0FBRE0sQUFBQyxhQUFBO0FBQ1AsQUFBRyxZQUFILEFBQUksZ0JBQUosQUFDUTtBQUVSLGtCQUFVLEVBQUEsQUFBRSxBQUFTLFVBQVgsQUFBWSxLQUFaLEFBQWlCLE1BQWpCLEFBQXVCO0FBQ2pDLHVCQUFlO0FBRWYsYUFBQSxzQ0FBQTs7QUFDSSxtQkFBUyxJQUFBLEFBQUksT0FBTyxBQUFDLEtBQVosQUFBWTtBQUNyQix1QkFBYSxBQUFNLE9BQUMsQUFBSyxLQUFHLEFBQUMsS0FEN0IsQUFDeUIsQUFBSSxBQUFVOztBQUl2QyxjQUFHLENBQUEsQUFBSSxjQUFjLENBQUksQUFBVSxXQUFuQyxBQUFvQyxRQUNoQztBQURKOztBQUdBLGNBQUcsQUFBTSxPQUFULEFBQVU7QUFDTiwwQkFBYyxDQUFDLEFBQUMsS0FBRixBQUFFLGlCQURwQixBQUNrQixBQUFtQjtBQURyQyxpQkFBQTtBQUdJLDBCQUFjLENBQUMsQUFBQyxLQUFGLEFBQUUsb0JBSHBCLEFBR2tCLEFBQXNCOztBQUV4QyxBQUFVLHFCQUFWLEFBQVcsUUFBWCxBQUFtQjtBQUNuQixtQkFBUztBQUVULGVBQVMsNkZBQVQ7QUFDSSx1QkFBVztBQUNYLHFCQUFTLEFBQVUsV0FBVixBQUFXLE1BQVgsQUFBaUIsR0FBRyxJQUFwQixBQUF3QixBQUFFLEdBQTFCLEFBQTJCLEtBQTNCLEFBQWdDLEFBQ0wsS0FEM0IsQUFDNEIsUUFENUIsQUFDb0MsTUFGN0MsQUFDUyxBQUMwQzs7QUFJbkQsc0JBQVUsQUFBTyxRQUFQLEFBQVEsQUFBUyx1QkFBakIsQUFBaUIsQUFBVyxBQUFPO0FBRTdDLGdCQUFHLENBQUksQUFBTyxRQUFkLEFBQWU7QUFDWCx5QkFBVyxFQUFBLEFBQUUsQUFDVCxVQURPLEFBQ04sS0FETSxBQUNELE1BREMsQUFDSyxBQUNaLFFBRk8sQUFFTixBQUNELE9BSE8sQUFHTixTQUhNLEFBR0c7QUFFZCxBQUFhLDJCQUFiLEFBQWEsVUFBVTtBQUV2QixrQkFBRyxJQUFILEFBQU87QUFHSCw2QkFBYSxBQUFPLFFBQVAsQUFBUSxBQUFTLHVCQUFqQixBQUFpQixBQUFXLEFBQVM7QUFFbEQsa0JBQUEsQUFBRSxBQUNFLFlBREosQUFDSyxLQURMLEFBQ1UsUUFEVixBQUNrQixBQUNkLFVBRkosQUFFSyxJQUZMLEFBRVMsQUFDTCxLQUhKLEFBR0ssU0FITCxBQUdjLEFBQ1YsVUFKSixBQUlLLE1BQU0sZUFBQSxBQUFlLFVBSjFCLEFBSVcsQUFBeUIsQUFDaEMsYUFMSixBQUtLLFNBTEwsQUFLYztBQUVkLGtCQUFBLEFBQUUsQUFDRSxZQURKLEFBQ0ssS0FETCxBQUNVLFFBRFYsQUFDa0IsQUFDZCxVQUZKLEFBRUssSUFBSSxBQUFXLFdBRnBCLEFBRW9CLEFBQ2hCLElBSEosQUFHSyxNQUFNLGdCQUFnQixBQUFhLGFBSHhDLEFBR1csQUFBNkIsQUFDcEMsVUFKSixBQUlLLFNBSkwsQUFJYztBQUVkLGtCQUFBLEFBQUUsQUFDRSxZQURKLEFBQ0ssS0FETCxBQUNVLFFBRFYsQUFDa0IsQUFDZCxVQUZKLEFBRUssSUFGTCxBQUVTLEFBQ0wsS0FISixBQUdLLFNBSEwsQUFHYyxBQUNWLFVBSkosQUFJSyxNQUFNLGVBQUEsQUFBZSxZQUoxQixBQUlXLEFBQTJCLEFBQ2xDLFdBTEosQUFLSyxTQXZCVCxBQWtCSSxBQUtjO0FBL0J0QjtBQUFBLG1CQUFBO0FBaUNJLHlCQUFXLEFBQU8sUUFqQ3RCLEFBaUNlLEFBQVE7O0FBRXZCLEFBQWEseUJBQUEsQUFBTyxRQUFwQixBQUFxQixLQTVDekIsQUE0Q0ksQUFBMEI7O0FBRTlCLGtCQUFRLEVBQUEsQUFBRSxBQUNOLFlBREksQUFDSCxLQURHLEFBQ0UsUUFERixBQUNVLEFBQ2QsVUFGSSxBQUVILElBQUksQUFBVyxXQUFBLEFBQVUsV0FBVixBQUFXLFNBRnZCLEFBRVksQUFBb0IsQUFDcEMsSUFISSxBQUdILFNBSEcsQUFHTSxBQUNWLFVBSkksQUFJSCxTQUpHLEFBSU07QUFFZCxjQUFHLEFBQU0sT0FBVCxBQUFVO0FBQ04sQUFBSyxrQkFBTCxBQUFNLE1BQU0sQUFBQyxLQUFELEFBQUMsWUFBRCxBQUFhLFVBRDdCLEFBQ0ksQUFBWSxBQUF1QjtBQUR2QyxpQkFBQTtBQUdJLEFBQUssa0JBQUwsQUFBTSxNQUFNLEFBQUMsS0FBRCxBQUFDLGdCQUhqQixBQUdJLEFBQVksQUFBaUI7QUF4RXJDOztBQTBFQSxnQkFBUSxBQUFPLFFBQVAsQUFBUTtBQUVoQixZQUFHLEFBQUssTUFBUixBQUFTO0FBQ0wsb0JBQVUsRUFBQSxBQUFFLEFBQ1IsWUFETSxBQUNMLEtBREssQUFDQSxRQURBLEFBQ1EsQUFDZCxVQUZNLEFBRUwsSUFGSyxBQUVELEFBQ0wsS0FITSxBQUdMLFNBSEssQUFHSSxBQUNWLFVBSk0sQUFJTCxNQUFNLGdCQUFnQixBQUFhLGFBSnhDLEFBQVUsQUFJQyxBQUE2Qjs7QUFJeEMsQUFDSSxrQkFESixBQUNLLFNBREwsQUFDYyxBQUNWLGdDQUZKLEFBRUssQUFDRCxRQUhKLEFBR0ssUUFITCxBQUdhO0FBRWIsQUFBSyxnQkFBTCxBQUFNLEFBQU8sUUFBYixBQUFjLEFBQ2Q7aUJBQU8sQUFBUSxRQWZuQixBQWVtQjtBQWZuQixlQUFBLEFBaUJJO2lCQWpCSixBQWlCVztBQXBHTjtBQTJHVCxBQUFhOzs7a0NBQUEsQUFBQyxVQUFELEFBQVc7QUFDcEI7O2VBQU8sVUFBQSxBQUFDLE9BQ0o7Y0FBQSxJQUFBO0FBQUEsQUFBUSxtQkFBUixBQUFTO0FBQ1Qsa0JBQVEsRUFBQSxBQUFFO0FBRVYsWUFBQSxBQUFFLEFBQ0UsWUFESixBQUNLLEtBREwsQUFDVSxRQURWLEFBQ2tCLEFBQ2QsVUFGSixBQUVLLElBRkwsQUFFUyxBQUNMLEtBSEosQUFHSyxTQUhMLEFBR2MsQUFDVixVQUpKLEFBSUssTUFBTyxVQUFBLEFBQUM7QUFDTCxBQUFLLGtCQUFMLEFBQU07bUJBQ04sQUFBUSxTQUZKLEFBRUosQUFBUztBQU5qQixBQVFJLGFBUkosQUFRSyxTQVJMLEFBUWM7QUFFZCxZQUFBLEFBQUUsQUFDRSxZQURKLEFBQ0ssS0FETCxBQUNVLFFBRFYsQUFDa0IsQUFDZCxVQUZKLEFBRUssSUFGTCxBQUVTLEFBQ0wsV0FISixBQUdLLE1BQU0sQUFBQyxNQUFELEFBQUMsZ0JBSFosQUFHVyxBQUFpQixBQUN4QixTQUpKLEFBSUssU0FKTCxBQUljO0FBRWQsZUFBSyxBQUFNLE9BQU4sQUFBTztpQkFDWixBQUFLLE1BQUwsQUFBTSxPQUFOLEFBQWEsQUFBRyxJQUFoQixBQUFpQixZQXJCZCxBQXFCSCxBQUE2QjtBQXRCeEI7QUF3QmIsQUFBaUI7OztzQ0FBQSxBQUFDO0FBQ2Q7O2VBQU8sVUFBQSxBQUFDO2lCQUNKLEFBQUMsT0FBRCxBQUFDLG1CQUFELEFBQW9CLFFBRGpCLEFBQ0gsQUFBNEI7QUFGbkI7QUFJakIsQUFBb0I7Ozt5Q0FBQSxBQUFDLFFBQUQsQUFBUztBQUN6QixBQUFDLGFBQUEsQUFBRSxHQUFDLEFBQUcsSUFBUCxBQUFRLFVBQVUsYUFBYSxBQUFNLE9BQUMsQUFBVyxZQUFqRCxBQUFrRDtlQUNsRCxBQUFPLGlCQUFRLEFBQUMsS0FBaEIsQUFBTyxBQUFTLFdBRkEsQUFFaEIsQUFBNkI7QUFFakMsQUFBaUI7OztzQ0FBQSxBQUFDLFFBQUQsQUFBUztBQUN0QixBQUFDLGFBQUEsQUFBRSxHQUFDLEFBQUcsSUFBUCxBQUFRLFdBQVcsWUFBWSxBQUFNLE9BQUMsQUFBVyxZQUE5QixBQUErQixPQUFsRCxBQUNJO0FBRUosWUFBQSxBQUFHO2lCQUFILEFBQ0k7QUFMUztBQTlJckI7Ozs7Ozs7O0FBeUdJLG1CQUFpQix3QkFBQSxBQUFDLGFBQUQsQUFBYyxZQUMzQjtXQUFPLFVBQUEsQUFBQztBQUNKLEFBQVcsa0JBQVgsQUFBWTthQUNaLEFBQVUsV0FGUCxBQUVILEFBQVc7QUFIRjs7O0FBNENqQixvQkFBa0IseUJBQUEsQUFBQyxpQkFDZjtXQUFPLFVBQUEsQUFBQzthQUNKLG9CQUFBLEFBQW1CLGlCQUFpQixDQURqQyxBQUNILEFBQXFDO0FBRjNCOzs7QUFJbEIsd0JBQXFCLDRCQUFBLEFBQUMsaUJBQUQsQUFBa0IsSUFDbkM7UUFBQSxjQUFBO0FBQUE7QUFDQSxRQUFHLEFBQWdCLGdCQUFuQixBQUFtQjtBQUNmLFlBQU0sQUFBZ0IsZ0JBQUE7QUFDdEIscUJBQWU7ZUFDWCxvQkFBQSxBQUFtQixpQkFEUixBQUNYLEFBQW9DOzthQUN4QyxBQUFJLElBQUosQUFBSSxHQUFHLEFBQUksSUFBWCxBQUFXLElBSmYsQUFJSSxBQUFlO0FBTkY7Ozs7Ozs7Ozs7Ozs7QUM5S3pCLElBQUE7O0FBa0JBLE1BQU0sUUFBQSxBQUFROztBQUdSLEFBQU0sT0FBQzswREFBYjs7TUFBQTtBQUNJLEFBQWEscUJBQUE7OztBQUFDLEFBQUMsV0FBQSxLQUFGO0FBaUJiLEFBQWlCOzs7OztBQUNiLFlBQUcsQUFBQyxLQUFBLEFBQUUsR0FBQyxBQUFJLEtBQVgsQUFBWTtBQUFaLEFBQ0k7O0FBQ0osWUFBRyxBQUFDLEtBQUEsQUFBRSxHQUFDLEFBQUksS0FBWCxBQUFZO2lCQUFaLEFBQ0k7QUFKUztBQU1qQixBQUF3Qjs7OztBQUNwQixZQUFHLEFBQUMsS0FBQSxBQUFFLEdBQUMsQUFBSSxLQUFYLEFBQVk7aUJBQVosQUFDSTtBQUZnQjtBQUl4QixBQUF3Qjs7OztBQUNwQixZQUFHLEFBQUMsS0FBQSxBQUFFLEdBQUMsQUFBSSxLQUFYLEFBQVk7aUJBQVosQUFDSTtBQUZnQjtBQTVCNUI7Ozs7Ozs7O0FBR0ksb0NBQWtDO2FBQzlCLEFBQUUsQUFBYSxjQUFmLEFBQWdCLFFBQVMsVUFBQSxBQUFDLE9BQUQ7QUFFckIsVUFBRyxBQUFLLE1BQUwsQUFBTSxRQUFOLEFBQWEsQUFBVyxXQUFDLE9BQU8sQUFBSyxNQUFaLEFBQWEsUUFBYixBQUFvQixlQUNKLEFBQUssTUFBTCxBQUFNLFlBRGxELEFBQTJCLEFBQ2tDO0FBQ3pELEFBQUssY0FBTCxBQUFNLEFBQ047ZUFISixBQUdXO0FBTFU7QUFESyxBQUM5QixLQUFBOzs7QUFRSixzQkFBb0I7V0FDaEIsQUFBRyxJQUFILEFBQUksZ0JBRFksQUFDaEIsQUFBb0I7OztBQUV4Qix5QkFBdUI7V0FDbkIsQUFBTSxPQUFOLEFBQU8sU0FBUCxBQUFnQixHQUFHLEVBQUEsQUFBRSxBQUFnQixpQkFBbEIsQUFBbUIsQUFBUSxTQUQzQixBQUNuQixBQUErQzs7Ozs7Ozs7Ozs7OztBQ3JDdkQsSUFBQSxPQUFBOztBQWtCQSxRQUFRLFFBQUEsQUFBUTs7QUFDaEIsTUFBTSxRQUFBLEFBQVE7O0FBR1IsQUFBTSxPQUFDOytCQUFiOztNQUFBO0FBQ0ksQUFBYSxxQkFBQTs7O0FBQUMsQUFBQyxXQUFBLEtBQUY7QUFFYixBQUE0Qjs7OztpREFBQSxBQUFDLE9BQUQsQUFNeEI7ZUFBTyxBQUFLLE1BQUwsQUFBTSxRQUFOLEFBQWMsVUFORyxBQU1qQixBQUF3QjtBQUVuQyxBQUFzQjs7OzJDQUFBLEFBQUMsUUFNbkI7WUFBQSxhQUFBLFlBQUEsR0FBQSxLQUFBLFlBQUEsWUFBQSxZQUFBLFFBQUEsS0FBQTs7QUFBQSxxQkFBYTtBQUNiLHNCQUFjO0FBQ2QsZUFBTyxBQUFHLElBQUgsQUFBSSxxQkFBSixBQUF5QixRQUF6QixBQUFpQyxhQUFqQyxBQUNxQixZQURyQixBQUNpQyxlQURqQyxBQUNnRDtBQUN2RCxxQkFBYTtBQUNiLGlCQUFTO0FBRVQsYUFBQSxtQ0FBQTs7QUFDSSxjQUFHLEFBQUksSUFBUCxBQUFPO0FBQ0gseUJBQWEsQUFBSSxJQUFKLEFBQUksS0FBSyxBQUFJLElBQWIsQUFBYSxLQUFLO0FBQy9CLHlCQUFhLEFBQUcsSUFBSCxBQUFJLFNBQUosQUFBYSxJQUFiLEFBQWlCLEtBQWpCLEFBQXNCO0FBQ25DLDBCQUFjLEFBQU0sT0FBTixBQUFPLFVBQVAsQUFBaUIsUUFBUSxBQUFJLElBQTdCLEFBQTZCLE1BQU07QUFDakQscUJBQVMsQUFBSSxJQUFKLEFBQUksS0FBSyxBQUNsQjtBQUxKO0FBQUEsaUJBQUE7QUFVSSx5QkFBYSxBQUFNLE9BQU4sQUFBTyxPQUFPLEFBQUksSUFBbEIsQUFBa0IsQUFBRyxJQUFDO0FBQ25DLHlCQUFhLEFBQUcsSUFBSCxBQUFJLFNBQUosQUFBYSxJQUFiLEFBQWlCLEtBQWpCLEFBQXNCO0FBQ25DLDBCQUFjLEFBQU0sT0FBTixBQUFPLFVBQVAsQUFBaUIsUUFBUSxBQUFJLElBQTdCLEFBQTZCLE1BQU07QUFDakQscUJBQVMsQUFBTSxPQUFDLEFBQ2hCO0FBZEo7QUFESjs7QUFpQkEsc0JBQWMsQUFBTSxPQUFOLEFBQU8sVUFBUCxBQUFpQixBQUUvQjtlQWhDa0IsQUFnQ1g7QUFFWCxBQUFXOzs7Z0NBQUEsQUFBQyxNQUNSO2VBQU8sbUJBQUEsQUFBbUIsQUFBSyxNQUF4QixBQUF5QixRQUF6QixBQUFpQyxNQURqQyxBQUNBLEFBQXVDO0FBRWxELEFBQXlDOzs7OERBQUEsQUFBQyxVQUFEO0FBSXJDLG1CQUFXLEFBQVEsU0FBUixBQUFTLFFBQVQsQUFBaUIsT0FBakIsQUFBd0I7QUFDbkMsbUJBQVcsQUFBUSxTQUFSLEFBQVMsUUFBVCxBQUFpQixPQUFqQixBQUF3QjtBQUNuQyxtQkFBVyxBQUFRLFNBQVIsQUFBUyxRQUFULEFBQWlCLE9BQWpCLEFBQXdCO0FBQ25DLG1CQUFXLEFBQVEsU0FBUixBQUFTLFFBQVQsQUFBaUIsT0FBakIsQUFBd0I7QUFDbkMsbUJBQVcsQUFBUSxTQUFSLEFBQVMsUUFBVCxBQUFpQixPQUFqQixBQUF3QixBQUNuQztlQVRxQyxBQVM5QjtBQWtCWCxBQUFzQjs7OzJDQUFBLEFBQUMsUUFBRCxBQUFTLFFBRzNCO1lBQUEsSUFBQTs7QUFBQSxhQUFLLG1CQUFtQixBQUFJLEtBQUosQUFBSywyQkFBTCxBQUFnQyxBQUNJLFFBRHZELEFBQW1CLEFBQ3FDO0FBQzdELGFBQUssbUJBQW1CLEFBQUksS0FBSixBQUFLLDJCQUFMLEFBQWdDLEFBQ0ksUUFEdkQsQUFBbUIsQUFDcUMsQUFDN0Q7ZUFBTyxPQVBXLEFBT0w7QUFFakIsQUFBc0I7OzsyQ0FBQSxBQUFDLFFBQUQsQUFBUyxNQUMzQjtZQUFBO0FBQUEsaUJBQVMsQUFBSSxLQUFKLEFBQUsscUJBQUwsQUFBMEI7QUFDbkM7QUFDQSxZQUFBLEFBQUc7QUFFQyxtQkFBUyxJQUFBLEFBQUksT0FBTyxPQUFPLEFBQUssTUFBTCxBQUFNLGNBQWIsQUFBTyxBQUFvQixRQUF0QyxBQUE4QyxNQUYzRCxBQUVhLEFBQ21EO0FBSGhFLGVBQUE7QUFNSSxtQkFBUyxJQUFBLEFBQUksT0FBTyx5Q0FBQSxBQUNaLHlEQURZLEFBRVoscURBRkMsQUFHRCx1Q0FUWixBQU1hLEFBR3NDO0FBQ25EO2VBQU8sQUFBSyxNQUFMLEFBQU0sU0FBTixBQUFlLFFBYkosQUFhWCxBQUF1QjtBQUVsQyxBQUFpQjs7O3NDQUFBLEFBQUMsUUFBRCxBQUFTLGNBQVQsQUFBdUIsYUFBdkIsQUFBb0MsZUFPakQ7WUFBQSxRQUFBLFNBQUEsT0FBQSxHQUFBLFFBQUEsS0FBQSxPQUFBLFlBQUEsT0FBQSxTQUFBLE9BQUEsTUFBQSxRQUFBOztBQUFBLGdCQUFRLEFBQUcsZ0JBQUgsQUFBc0IsS0FBOUIsQUFBc0M7O0FBY3RDLGtCQUFVLEFBQUcsY0FBSCxBQUFvQixxQkFBd0I7QUFDdEQsaUJBQVMsSUFBQSxBQUFJLE9BQU8sTUFBQSxBQUFNLFVBQU4sQUFBZ0IsTUFBaEIsQUFBc0IsZUFBdEIsQUFBcUMsTUFBaEQsQUFDRyxtREFESCxBQUNzRDtBQUMvRCxrQkFBVSxBQUFDLEtBQUQsQUFBQyxxQkFBRCxBQUFzQjtBQUNoQyxnQkFBUTtBQUNSLGtCQUFVLEFBQUcsSUFBSCxBQUFJLHdCQUFKLEFBQTRCLFNBQTVCLEFBQXFDLE1BQXJDLEFBQTJDO0FBRXJELGFBQUEsc0NBQUE7O0FBQ0ksbUJBQVMsQUFBTSxPQUFOLEFBQU8sVUFBVSxBQUFPLE9BQVAsQUFBTyxLQUF4QixBQUE2QixHQUFHLEFBQU8sT0FBdkMsQUFBdUM7QUFDaEQsa0JBQVEsQUFBTSxPQUFOLEFBQU8sS0FBUCxBQUFZO0FBRXBCLGNBQUEsQUFBRztBQUNDLG1CQUFPO0FBRVAsZ0JBQUcsQUFBTSxNQUFULEFBQVM7QUFNTCxzQkFBUSxBQUFDLEtBQUQsQUFBQyxxQkFBcUIsQUFBTSxNQUE1QixBQUE0QjtBQUNwQywyQkFBYSxBQUFHLElBQUgsQUFBSSxxQkFBSixBQUF5QixPQUF6QixBQUFnQyxNQUFoQyxBQUMrQixNQUQvQixBQUNxQyxBQUFLLEtBQUE7QUFFdkQsa0JBQUcsQUFBVSxXQUFWLEFBQVcsT0FBWCxBQUFrQixpQkFBaUIsQ0FBdEMsQUFBdUM7QUFDbkMsQUFBQyxxQkFBQSxBQUFFLEdBQUMsQUFBRyxJQUFQLEFBQVEsV0FBVyxPQUFPLEFBQU0sTUFBYixBQUFhLEtBQWhDLEFBQXFDO0FBS3JDLHVCQU5KLEFBTVc7QUFoQmY7O0FBa0JBLGdCQUFBLEFBQUc7QUFDQyxBQUFLLG9CQUFMLEFBQU07QUFDRiwyQkFBVyxPQUFPLEFBQU0sTUFBYixBQUFhLEtBQXhCLEFBQTZCO0FBQzdCLHdCQUFRLEFBQU0sTUFEZCxBQUNjO0FBQ2QsNEJBQVksQUFBTSxNQUZsQixBQUVrQjtBQUNsQiw2QkFBYSxBQUFNLE1BSG5CLEFBR21CO0FBQ25CLHlCQUFTLEFBQU0sTUFKZixBQUllO0FBQ2YsNEJBQVksQUFBTSxNQUxsQixBQUtrQjtBQUNsQiwwQkFBVSxBQUFNLE1BTmhCLEFBTWdCO0FBQ2hCLHlCQUFTLEFBQU8sT0FQaEIsQUFPZ0I7QUFDaEIsMEJBQVUsQUFBTyxPQUFQLEFBQU8sS0FBUCxBQUFZLElBQUksQUFBTyxPQVZ6QyxBQUNJLEFBQ0ksQUFRaUM7QUFSakM7QUF2Qlo7QUFKSjtBQXFDQTtlQWpFYSxBQWlFTjtBQUVYLEFBQWtCOzs7dUNBQUEsQUFBQyxRQUVmO1lBQUEsZUFBQTs7QUFBQSx3QkFBZ0I7QUFDaEIsdUJBQWUsYUFBQSxBQUFhLGdCQUFnQixBQUM1QztlQUFPLEFBQUMsS0FBRCxBQUFDLGdCQUFELEFBQWlCLFFBQWpCLEFBQXlCLGNBQXpCLEFBQXVDLE9BSmhDLEFBSVAsQUFBOEM7QUFFekQsQUFBbUI7Ozt3Q0FBQSxBQUFDLFFBQUQsQUFBUyxXQUFULEFBQW9CLE9BRW5DO1lBQUEsZUFBQSxlQUFBLGdCQUFBLE1BQUEsU0FBQSxZQUFBOztBQUFBLHlCQUFpQjtBQUNqQixxQkFBYTtBQUNiLHdCQUFnQjtBQUVoQixZQUFBLEFBQUc7QUFDQyxpQkFBTyx3QkFBd0IsQUFBSyxNQUFMLEFBQU0sY0FBOUIsQUFBd0IsQUFDcUI7QUFFcEQsY0FBQSxBQUFHO0FBQ0Msc0JBQVUsd0JBQXdCLEFBQUssTUFBTCxBQUFNLGNBQTlCLEFBQXdCLEFBQ2tCO0FBQ3BELDJCQUFlLE9BQUEsQUFBTyxPQUFQLEFBQWMsaUJBQWQsQUFDUyxNQURULEFBQ2UsVUFEZixBQUN5QixPQUR6QixBQUVTLGVBRlQsQUFFd0IsZ0JBSnZDLEFBSXVEOztBQUl2RCw0QkFUSixBQVNvQjtBQVRwQixpQkFBQTtBQVdJLDJCQUFlLE9BQUEsQUFBTyxPQUFQLEFBQWMsaUJBQWQsQUFDUyxNQURULEFBQ2UsYUFEZixBQUM0QixPQUQ1QixBQUVTLGVBRlQsQUFFd0IsZ0JBRnZDLEFBRXVEOztBQUd2RCw0QkFoQkosQUFnQm9CO0FBcEJ4QjtBQUFBLG1CQXFCSyxBQUFHO0FBQ0osb0JBQVUsd0JBQXdCLEFBQUssTUFBTCxBQUFNLGNBQXhDLEFBQVUsQUFBd0IsQUFDc0I7O0FBR3hELHlCQUFlLFNBQUEsQUFBUyxVQUFULEFBQW1CLE9BQW5CLEFBQ2EsZUFEYixBQUM0QixnQkFMM0MsQUFLMkQ7O0FBRzNELDBCQVRDLEFBU2U7QUFUZixTQUFBLE1BQUE7QUFXRCx5QkFBZSxVQUFBLEFBQVUsaUJBQVYsQUFBMkIsbUJBQTNCLEFBQ2EsTUFEYixBQUNtQixhQURuQixBQUNnQyxPQURoQyxBQUVhLGVBRmIsQUFFNEIsZ0JBQWdCO0FBQzNELDBCQWRDLEFBY2U7QUFFcEI7ZUFBTyxBQUFDLEtBQUQsQUFBQyxnQkFBRCxBQUFpQixRQUFqQixBQUF5QixjQUF6QixBQUF1QyxPQTNDL0IsQUEyQ1IsQUFBOEM7QUFFekQsQUFBb0I7Ozt5Q0FBQSxBQUFDLFFBQUQsQUFBUyxNQUN6QjtlQUFPLEFBQUksS0FBSixBQUFLLGtCQUFMLEFBQXVCLFFBRGQsQUFDVCxBQUErQjtBQUUxQyxBQUFrQjs7O3VDQUFBLEFBQUMsUUFBRCxBQUFTLFNBS3ZCO1lBQUEsZUFBQSxZQUFBOztBQUFBLHFCQUFhO0FBQ2Isd0JBQWdCO0FBQ2hCLHVCQUFlLE9BQUEsQUFBTyxVQUFQLEFBQWlCLGlCQUFqQixBQUNpQixNQURqQixBQUN1QixhQUR2QixBQUNvQyxPQURwQyxBQUVpQixlQUZqQixBQUVnQyxnQkFKL0MsQUFJK0QsQUFFL0Q7O2VBQU8sQUFBQyxLQUFELEFBQUMsZ0JBQUQsQUFBaUIsUUFBakIsQUFBeUIsY0FBekIsQUFBdUMsTUFYaEMsQUFXUCxBQUE2QztBQUV4RCxBQUFnQjs7O3FDQUFBLEFBQUMsUUFDYjtlQUFPLEFBQUksS0FBSixBQUFLLGlCQUFMLEFBQXNCLFFBRGpCLEFBQ0wsQUFBOEI7QUFFekMsQUFBd0I7Ozs2Q0FBQSxBQUFDLFFBQUQsQUFBUyxVQUFULEFBRXBCO2VBQU8sQUFBSSxLQUFKLEFBQUssaUJBQUwsQUFBc0IsUUFBUSxBQUFLLE1BQUwsQUFBTSxjQUZ2QixBQUViLEFBQThCLEFBQW9CO0FBRTdELEFBQWU7OztvQ0FBQSxBQUFDLFFBQUQsQUFBUyxVQUdwQjtZQUFBOztBQUFBLGtCQUFVLEFBQUssTUFBTCxBQUFNLGNBQU4sQUFBb0IsQUFDOUI7ZUFBTyxBQUFJLEtBQUosQUFBSyxxQkFBTCxBQUEwQixRQUp0QixBQUlKLEFBQWtDO0FBRTdDLEFBQXNCOzs7MkNBQUEsQUFBQyxRQUFELEFBQVMsU0FLM0I7WUFBQSxVQUFBLFdBQUEsR0FBQSxRQUFBLEtBQUEsT0FBQSxTQUFBLFFBQUE7O0FBQUEsa0JBQVUsQUFBSSxLQUFKLEFBQUsscUJBQUwsQUFBMEI7QUFDcEMsa0JBQVU7QUFDVixvQkFBWSxBQUFHLElBQUgsQUFBSSxxQkFBSixBQUF5QixTQUF6QixBQUFrQyxNQUFsQyxBQUF3QyxNQUF4QyxBQUE4QyxBQUFLLEtBQUE7QUFFL0QsYUFBQSx3Q0FBQTs7QUFDSSxtQkFBUyxBQUFNLE9BQU4sQUFBTyxVQUFVLEFBQVMsU0FBVCxBQUFTLEtBQTFCLEFBQStCLEdBQUcsQUFBUyxTQUFwRCxBQUFTLEFBQTJDOztBQUtwRCxtQkFBUyxJQUFBLEFBQUksT0FBTyxXQUFBLEFBQVcsVUFBWCxBQUFxQixNQUFoQyxBQUNtQixpQ0FEbkIsQUFDb0Q7QUFDN0Qsa0JBQVEsQUFBTSxPQUFOLEFBQU8sS0FBUCxBQUFZO0FBRXBCLGNBQUEsQUFBRztBQUNDLEFBQU8sb0JBQVAsQUFBUTtBQUNKLDZCQUFlLE9BQU8sQUFBTSxNQUFiLEFBQWEsS0FBNUIsQUFBaUM7QUFDakMsc0JBQVEsQUFBTSxNQURkLEFBQ2M7QUFDZCx1QkFBUyxBQUFNLE1BRmYsQUFFZTtBQUNmLHVCQUFTLEFBQVMsU0FIbEIsQUFHa0I7QUFDbEIsd0JBQVUsQUFBUyxTQUFULEFBQVMsS0FBVCxBQUFjLElBQUksQUFBUyxTQU43QyxBQUNJLEFBQ0ksQUFJcUM7QUFKckM7QUFaWjtBQWtCQTtlQTNCa0IsQUEyQlg7QUFFWCxBQUF5Qjs7OzhDQUFBLEFBQUMsUUFBRCxBQUFTLFNBQVQsQUFBa0IsZUFnQnZDO1lBQUEsVUFBQSxVQUFBLFdBQUEsR0FBQSxRQUFBLEtBQUEsT0FBQSxTQUFBLFFBQUE7O0FBQUEsaUJBQVMsSUFBQSxBQUFJLE9BQU8sQUFBVyxZQUFDLEFBQUcsZ0JBQUgsQUFBc0IsS0FBbEMsQUFBVyxBQUErQixRQUExQyxBQUNZLFdBRFosQUFDdUIsVUFEdkIsQUFDaUMsZ0JBRDVDLEFBRXVCLHdCQUZ2QixBQUUrQztBQUV4RCxrQkFBVSxBQUFDLEtBQUQsQUFBQyxxQkFBRCxBQUFzQjtBQUNoQyx3QkFBZ0I7QUFDaEIsb0JBQVksQUFBRyxJQUFILEFBQUkscUJBQUosQUFBeUIsU0FBekIsQUFBa0MsTUFBbEMsQUFBd0MsTUFBeEMsQUFBOEMsQUFBSyxLQUFBO0FBRS9ELGFBQUEsd0NBQUE7O0FBQ0ksbUJBQVMsQUFBTSxPQUFOLEFBQU8sVUFBVSxBQUFTLFNBQVQsQUFBUyxLQUExQixBQUErQixHQUFHLEFBQVMsU0FBM0MsQUFBMkM7QUFDcEQsa0JBQVEsQUFBTSxPQUFOLEFBQU8sS0FBUCxBQUFZO0FBRXBCLGNBQUEsQUFBRztBQUVDLHVCQUFXLEFBQVMsU0FBVCxBQUFTLEtBQUssQUFBTSxNQUFBLEFBQUUsR0FBdEIsQUFBdUIsU0FBUztBQUUzQyxBQUFhLDBCQUFiLEFBQWM7QUFDVixpQ0FBbUIsT0FBTyxBQUFNLE1BQWIsQUFBYSxLQUFoQyxBQUFxQztBQUNyQyx1QkFBUyxBQUFNLE1BRGYsQUFDZTtBQUNmLHVCQUFTLEFBQVMsU0FGbEIsQUFFa0I7QUFDbEIsd0JBQVUsQUFBUyxTQUFULEFBQVMsS0FBSyxBQUFTLFNBQXZCLEFBQXVCLEtBSGpDLEFBR3NDO0FBQ3RDLDJCQUFhLEFBQUMsS0FBRCxBQUFDLDBCQUFELEFBQTJCLE9BVGhELEFBSUksQUFDSSxBQUlhLEFBQWtDO0FBSi9DO0FBVFo7QUFnQkE7ZUF4Q3FCLEFBd0NkO0FBRVgsQUFBMkI7OztnREFBQSxBQUFDLE9BQUQsQUFBUSxVQUMvQjtZQUFBLE1BQUEsTUFBQSxVQUFBLFNBQUEsR0FBQSxLQUFBLFVBQUEsWUFBQSxLQUFBLE9BQUEsV0FBQSxZQUFBLE9BQUEsY0FBQSxRQUFBLE9BQUEsVUFBQSxPQUFBO0FBQUEsdUJBQWUsQUFBTSxNQUFBO0FBQ3JCLGVBQU87QUFFUCxZQUFBLEFBQUc7QUFDQyxrQkFBUSxBQUFDLEtBQUQsQUFBQyxxQkFBVCxBQUFRLEFBQXNCOztBQU85Qix1QkFBYSxBQUFHLElBQUgsQUFBSSxxQkFBSixBQUF5QixPQUF6QixBQUFnQyxNQUFoQyxBQUFzQyxNQUF0QyxBQUE0QyxBQUFLLEtBUDlELEFBTzhEOztBQUk5RCx1QkFBYSxBQUFHLElBQUgsQUFBSSxxQkFBSixBQUF5QixZQUF6QixBQUFxQyxNQUFyQyxBQUEyQyxNQUEzQyxBQUMyQyxBQUFLLEtBWjdELEFBWTZEOztBQTBCN0QsY0FBRyxBQUFVLFdBQVYsQUFBVyxPQUFYLEFBQWtCLDJCQUEyQixDQUFoRCxBQUFpRDtBQUM3QyxBQUFDLGlCQUFBLEFBQUUsR0FBQyxBQUFHLElBQVAsQUFBUSxXQUFXLE9BQU8sQUFBTSxNQUFiLEFBQWEsS0FEcEMsQUFDSSxBQUFxQztBQUR6QyxpQkFBQTtBQU1JLG9CQUFRLEFBQVUsV0FBVixBQUFXLE1BQVgsQUFBaUI7QUFDekIsdUJBQVc7QUFFWCxpQkFBQSxvQ0FBQTs7QUFDSSxxQkFBTyxBQUFTLFVBQUM7QUFDakIseUJBQVcsQUFBWSxhQUFaLEFBQWEsT0FBYixBQUFvQixVQUFwQixBQUE4QjtBQUN6Qyx3QkFBVSxBQUFTLFVBQVQsQUFBVSxRQUZwQixBQUVVLEFBQWtCOztBQUk1QixrQkFBRyxVQUFILEFBQWE7QUFDVCx5QkFBUyxBQUFRLFNBQVIsQUFBUyxVQUFULEFBQW1CLEdBQW5CLEFBQXNCO0FBQy9CLHdCQUFRO0FBQ1IsNkJBQWEsQUFBSyxNQUFMLEFBQU0sS0FBTixBQUFXO0FBQ3hCLHNCQUFNLEFBQVcsV0FBQTtBQUNqQiwyQkFBVyxBQUFXLFlBQUksQUFBVyxXQUFkLEFBQWMsS0FBUSxBQUFXLFdBQUEsQUFBRSxHQUFuQyxBQUFvQyxTQUozRCxBQUlzQixBQUFpRDs7QUFHdkUsd0JBQVEsQUFBUSxTQUFSLEFBQVMsT0FBTyxVQUFoQixBQUEwQjtBQUNsQyw2QkFBYSxXQUFXLEFBQVcsV0FBQSxBQUFFLEdBQXhCLEFBQXlCLFNBVDFDLEFBU21EO0FBVG5ELHFCQUFBO0FBV0ksc0JBQU07QUFDTiwyQkFBVztBQUNYLHdCQUFRO0FBQ1IsNkJBZEosQUFjaUI7O0FBRWpCLEFBQUksbUJBQUosQUFBSztBQUNELHFCQUFBLEFBQUs7QUFDTCwyQkFEQSxBQUNXO0FBQ1gsdUJBRkEsQUFFTztBQUNQLDZCQTFCSixBQXNCQSxBQUNJLEFBR2E7QUFIYjs7QUFPSiwwQkFBWSxPQS9CaEIsQUErQnVCO0FBeEMzQjtBQXZDSjtBQWlGQTtlQXJGdUIsQUFxRmhCO0FBRVgsQUFBZTs7O29DQUFBLEFBQUMsUUFBRCxBQUFTLFVBQ3BCO1lBQUE7QUFBQSxZQUFBLEFBQUc7QUFDQyxvQkFBVSxBQUFLLE1BQUwsQUFBTSxjQUFOLEFBQW9CO0FBQzlCLG9CQUFVLHdCQUFBLEFBQXdCO0FBQ2xDLG9CQUFVLG1CQUhkLEFBR2MsQUFBbUI7QUFIakMsZUFBQTtBQUtJLG9CQUxKLEFBS2M7QUFFZDtlQUFPLEFBQUksS0FBSixBQUFLLHFCQUFMLEFBQTBCLFFBUnRCLEFBUUosQUFBa0M7QUFFN0MsQUFBc0I7OzsyQ0FBQSxBQUFDLFFBQUQsQUFBUyxTQUFULEFBU2xCO2VBQU8sQUFBQyxLQUFELEFBQUMsd0JBQUQsQUFBeUIsUUFBekIsQUFBaUMsU0FUdEIsQUFTWCxBQUEwQztBQUVyRCxBQUFtQjs7O3dDQUFBLEFBQUMsUUFBRCxBQUFTLFdBQVQsQUFBb0IsT0FRbkM7WUFBQSxrQkFBQSxTQUFBLFlBQUE7O0FBQUEscUJBQWE7QUFFYixZQUFBLEFBQUc7QUFDQyw2QkFBbUIsQUFBSyxNQUFMLEFBQU0sY0FBTixBQUFvQjtBQUN2Qyw2QkFBbUIsd0JBQUEsQUFBd0I7QUFDM0MsNkJBQW1CLG1CQUh2QixBQUd1QixBQUFtQjs7QUFFMUMsWUFBQSxBQUFHO0FBQ0MseUJBQWUsQUFBSyxNQUFMLEFBQU0sY0FBTixBQUFvQjtBQUNuQyx5QkFBZSx3QkFBQSxBQUF3QjtBQUN2Qyx5QkFBZSxtQkFIbkIsQUFHbUIsQUFBbUI7O0FBRXRDLFlBQUcsb0JBQUgsQUFBd0I7QUFDcEIsb0JBQVUsbUJBQUEsQUFBbUIsZ0JBRGpDLEFBQ2lEO0FBRGpELG1CQUVRLENBQUEsQUFBSSxvQkFBUCxBQUE0QjtBQUM3QixvQkFEQyxBQUNTO0FBRFQsU0FBQSxVQUVHLG9CQUFxQixDQUF4QixBQUE0QjtBQUM3QixvQkFBVSxtQkFBQSxBQUFtQixXQUQ1QixBQUN1QztBQUR2QyxTQUFBLE1BQUE7QUFHRCxvQkFIQyxBQUdTO0FBRWQ7ZUFBTyxBQUFDLEtBQUQsQUFBQyx3QkFBRCxBQUF5QixRQUF6QixBQUFpQyxTQTdCekIsQUE2QlIsQUFBMEM7QUFFckQsQUFBcUI7OzswQ0FBQSxBQUFDLFFBRWxCO1lBQUEsSUFBQSxJQUFBLFVBQUEsY0FBQSxLQUFBLFNBQUEsR0FBQSxLQUFBLE9BQUEsTUFBQSxPQUFBLGFBQUEsVUFBQSxRQUFBLFlBQUEsWUFBQSxRQUFBLFVBQUEsT0FBQSxVQUFBOztBQUFBLG1CQUFXO0FBRVgsbUJBQVc7QUFDWCxtQkFBVztBQUNYLHNCQUFjO0FBQ2QsbUJBQVc7QUFDWCxpQkFBUyxBQUVUO2VBQUEsQUFBTTtBQUNGLGtCQUFRLEFBQU0sT0FBTixBQUFPLEtBQVAsQUFBWTtBQUVwQixjQUFBLEFBQUc7QUFDQyxpQkFBSyxBQUFNLE1BQUEsQUFBRSxHQUFDO0FBQ2QsbUJBQU8sQUFBTSxNQUFBO0FBQ2IseUJBQWEsQUFBTSxNQUFBO0FBQ25CLHNCQUFVLEFBQU0sTUFBQTtBQUNoQiwyQkFBZSxBQUFDLEtBQUQsQUFBQywyQkFBRCxBQUE0QjtBQUMzQyxpQkFBSyxBQUFJLEtBQUM7QUFDVixvQkFBUTtBQUNSLG9CQUFRO0FBQ1Isa0JBUkEsQUFRTSxBQVdOOzttQkFBQSxBQUFNO0FBQ0Ysc0JBQVEsQUFBSSxLQUFKLEFBQUssT0FBTCxBQUFZLE9BQVosQUFBbUI7QUFDM0Isb0JBQU0sQUFBSSxLQUFKLEFBQUssT0FBTyxLQUFBLEFBQUssUUFBakIsQUFBeUIsR0FBekIsQUFBNEI7QUFFbEMsa0JBQUcsS0FBSyxRQUFMLEFBQWEsSUFBYixBQUFpQixLQUFNLFVBQXZCLEFBQWdDLE9BQVEsUUFBM0MsQUFBa0Q7QUFBbEQsQUFDSTtBQURKLHFCQUFBO0FBR0ksb0JBQUcsUUFBSCxBQUFXO0FBQ1AsMEJBREosQUFDWTtBQURaLHVCQUVLLElBQUcsUUFBSCxBQUFXO0FBQ1osNkJBREMsQUFDVTtBQUNmO0FBUEo7QUFKSjs7QUFhQSxnQkFBRyxVQUFILEFBQVk7QUFDUix5QkFBVztBQUNYLDJCQUFhO0FBQ2IsQUFBVyx5QkFBWCxBQUFXLFNBQVM7QUFDcEIsQUFBVSx5QkFBVixBQUFXLFNBQVM7QUFDcEIsa0JBQUcsZ0JBQUgsQUFBa0I7QUFDZCw4QkFESixBQUNrQjtBQU50QjtBQUFBLHVCQU9RLFFBQVEsQUFBVSxXQUFyQixBQUFzQjtBQUN2QjtBQUNBLEFBQVcseUJBQVgsQUFBVyxTQUFTO0FBQ3BCLEFBQVUseUJBQVYsQUFBVyxTQUFTO0FBQ3BCLGtCQUFHLFdBQUgsQUFBYztBQUNWLDhCQURKLEFBQ2tCO0FBTGpCO0FBQUEsYUFBQSxNQU1BLElBQUcsUUFBUSxBQUFVLFdBQXJCLEFBQXNCO0FBQ3ZCLGtCQUFHLEFBQVcsV0FBZCxBQUFjO0FBQ1YsMkJBQVcsQUFBVyxXQUQxQixBQUMwQjtBQUQxQixxQkFBQTtBQU1JLDBCQUFVLEFBQVUsV0FBQztBQUNyQixxQkFBQSx5Q0FBQTs7QUFDSSxzQkFBRyxTQUFBLEFBQVMsU0FBVSxTQUF0QixBQUErQjtBQUMzQiw4QkFESixBQUNjO0FBRmxCOztBQUdBLDJCQUFXLEFBQVcsV0FBQTtBQUN0QixBQUFXLDJCQUFYLEFBQVcsU0FYZixBQVd3Qjs7QUFDeEIsQUFBVSx5QkFBVixBQUFXLFNBYlYsQUFhbUI7O0FBRXhCLEFBQVEscUJBQVIsQUFBUztBQUNMLG9CQUFBLEFBQU07QUFDTiwwQkFEQSxBQUNZO0FBQ1osdUJBRkEsQUFFUztBQUNULDRCQUhBLEFBR2M7QUFDZCxxQkFKQSxBQUlPO0FBQ1Asd0JBTEEsQUFLVTtBQUNWLHFCQUFRLEFBQU0sT0FBTixBQUFPLFlBTmYsQUFNMkI7QUFDM0IsdUJBUEEsQUFPUztBQUNULHVCQXRFUixBQTZESSxBQUNJLEFBUVM7QUFSVDtBQTlEUixpQkFBQSxBQXlFSTtBQXpFSjtBQUhKO0FBUkE7O0FBdUZBLFlBQUcsZ0JBQUgsQUFBa0I7QUFDZCxxQkFESixBQUNlO0FBRWY7O0FBQVEsb0JBQUQsQUFBVztBQUFVLG9CQUFyQixBQUErQjtBQUFVLHVCQTVGL0IsQUE0RlYsQUFBc0Q7QUFBdEQ7QUFwaUJmOzs7Ozs7OztBQTJESSw0QkFBMEIsaUNBQUEsQUFBQyxPQUFELEFBTXRCO1dBQU8sQUFBSyxNQUFMLEFBQU0sUUFBTixBQUFjLFVBTkMsQUFNZixBQUF3Qjs7O0FBRW5DLHVCQUFxQiw0QkFBQSxBQUFDLFNBQ2xCO1FBQUEsU0FBQSxTQUFBO0FBQUEsZ0JBQVksQUFBTyxRQUFQLEFBQVEsT0FBUixBQUFlO0FBQzNCLGNBQVUsQUFBUyxVQUFULEFBQVU7QUFDcEIsY0FBVSxBQUFTLFVBQVQsQUFBVTtBQUNwQixRQUFHLFlBQUgsQUFBYztBQUNWLGdCQUFVLE1BQUEsQUFBTSxVQUFOLEFBQWdCLFVBQWhCLEFBQTBCLE1BQU0sQUFBTyxRQUFQLEFBQVEsT0FEdEQsQUFDOEMsQUFBZTtBQUM3RDtXQU5pQixBQU1WOzs7Ozs7Ozs7Ozs7O0FDL0ZmLElBQUE7O0FBa0JBLE1BQU0sUUFBQSxBQUFROztBQUdSLEFBQU0sT0FBWixBQUFhO0FBQ1QsQUFBYSxtQkFBQTs7O0FBQUMsQUFBQyxTQUFBLEtBQUY7QUFFYixBQUFXOzs7OzhCQUFBLEFBQUMsUUFBRCxBQUFTLE1BQVQsQUFBZSxRQUN0QjtVQUFBLFVBQUEsUUFBQSxTQUFBO0FBQUEsZUFBUyxBQUFNLE9BQU4sQUFBTyxZQUFZLE9BQW5CLEFBQTBCO0FBQ25DLGlCQUFjLFNBQVMsQ0FBWixBQUFhLElBQWIsQUFBb0IsU0FBWSxBQUFNLE9BQU4sQUFBTyxZQUFQLEFBQW1CO0FBRTlELFlBQU0sVUFBVSxBQUFNLE9BQU4sQUFBTyxLQUFqQixBQUFVLEFBQVksU0FBUztBQUVyQyxnQkFBVSxBQUFHLElBQUgsQUFBSSxPQUFKLEFBQVcsUUFBWCxBQUFtQixLQUFuQixBQUF3QixBQUVsQzthQVJPLEFBUUE7QUFYZjs7Ozs7Ozs7Ozs7OztBQ3JCQSxJQUFBLEtBQUEsT0FBQSxBQWtCQTs7ZUFBWSxRQUFaLEFBQVksQUFBUTs7QUFBcEIsQUFBQzs7O0FBQ0QsTUFBTSxRQUFBLEFBQVE7O0FBQ2QsUUFBUSxRQUFBLEFBQVE7O0FBR1YsQUFBTSxPQUFaLEFBQWE7QUFDVCxBQUFhLG1CQUFBOzs7QUFBQyxBQUFDLFNBQUEsS0FBRjtBQUViLEFBQVM7Ozs7OEJBQ0w7VUFBQSxJQUFBLE1BQUEsTUFBQSxTQUFBLFlBQUEsTUFBQSxRQUFBLFNBQUEsTUFBQSxPQUFBLFVBQUEsUUFBQSxRQUFBLFFBQUEsUUFBQSxRQUFBLFFBQUEsUUFBQSxRQUFBLFFBQUEsUUFBQTtBQUFBLGdCQUFVO0FBQ1YsbUJBQWE7QUFFYixVQUFHLEFBQVEsU0FBUixBQUFTLGVBQVosQUFBRyxBQUF3QjtBQUN2QixtQkFBVyxBQUFRLFNBQVIsQUFBUyxlQUFULEFBQXdCLEFBQ1Msa0JBQUMsQUFBVSxXQUFDO0FBQ3hELGVBQU8sQUFBQyxLQUFBLEFBQUUsR0FBQyxBQUFPLFFBQUM7QUFDbkIsYUFBUSxBQUFJLEtBQVAsQUFBUSxTQUFZLEFBQUMsS0FBQSxBQUFFLEdBQUMsQUFBSSxLQUFSLEFBQVMsUUFBVCxBQUFpQixVQUFyQyxBQUFvQixBQUEyQixRQUFXO0FBQy9ELEFBQUMsYUFBQSxBQUFFLEdBQUMsQUFBSSxLQUxaLEFBS0ksQUFBUztBQUxiLGlCQU9RLEFBQVEsU0FBUixBQUFTLGVBQVosQUFBRyxBQUF3QjtBQUM1QixtQkFBVyxBQUFRLFNBQVIsQUFBUyxlQUFULEFBQXdCLEFBQ0MsZUFEekIsQUFDMEIscUJBRDFCLEFBQytDLEFBQU0sTUFBQTtBQUNoRSxlQUFPLEFBQUMsS0FBQSxBQUFFLEdBQUMsQUFBTyxRQUFDO0FBQ25CLGFBQVEsQUFBSSxLQUFQLEFBQVEsU0FBWSxBQUFDLEtBQUEsQUFBRSxHQUFDLEFBQUksS0FBUixBQUFTLFFBQVQsQUFBaUIsUUFBckMsQUFBb0IsQUFBeUIsUUFKakQsQUFJNEQ7QUFKNUQsT0FBQSxVQU1HLEFBQVEsU0FBUixBQUFTLGVBQVQsQUFBd0IsdUJBQ0EsQUFBUSxTQUFSLEFBQVMsZUFEcEMsQUFDMkIsQUFBd0I7QUFDcEQsbUJBQVcsQUFBUSxTQUFSLEFBQVMsZUFBVCxBQUF3QjtBQUNuQyxlQUFPLEFBQUMsS0FBQSxBQUFFLEdBQUMsQUFBTyxRQUFDO0FBQ25CLGFBQVEsQUFBSSxLQUFQLEFBQVEsU0FBWSxBQUFDLEtBQUEsQUFBRSxHQUFDLEFBQUcsSUFBUCxBQUFRLFFBQVIsQUFBZ0IsTUFDekIsQ0FBQyxDQUFDLEFBQVEsU0FBUixBQUFTLGVBQVYsQUFBQyxBQUF3QixhQUF6QixBQUFzQyxHQUF2QyxBQUFDLEFBQXlDLFVBQzFDLENBQUMsQUFBUSxTQUFSLEFBQVMsZUFBVixBQUFDLEFBQXdCLHFCQUF6QixBQUE4QyxHQUZ6RCxBQUFvQixBQUNULEFBQ0EsQUFDQSxxQkFBd0I7QUFDeEMsa0JBUkMsQUFRUztBQVJULE9BQUEsVUFVRyxBQUFRLFNBQVIsQUFBUyxlQUFaLEFBQUcsQUFBd0I7QUFDNUIsbUJBQVcsQUFBUSxTQUFSLEFBQVMsZUFBVCxBQUF3QixBQUNmLGVBRFQsQUFDVSxxQkFEVixBQUMrQixBQUFRLFFBQUEsQUFBRSxHQUFDO0FBQ3JELGVBQU8sQUFBQyxLQUFBLEFBQUUsR0FBQyxBQUFPLFFBQUM7QUFDbkIsYUFBUSxBQUFJLEtBQVAsQUFBUSxTQUFZLEFBQUMsS0FBQSxBQUFFLEdBQUMsQUFBRyxJQUFQLEFBQVEsUUFBUixBQUFnQixNQUN6QixDQUFDLENBQUMsQUFBUSxTQUFSLEFBQVMsZUFBVixBQUFDLEFBQXdCLDBCQUF6QixBQUNELEdBRlgsQUFBb0IsQUFDVCxBQUFDLEFBQ0UsYUFBZ0I7QUFDbkMsa0JBUEMsQUFPUztBQVBULE9BQUEsVUFTRyxBQUFRLFNBQUMsQUFBSSxLQUFDLEFBQVMsVUFBdkIsQUFBd0IsU0FBeEIsQUFBaUMsNEJBQ1QsQUFBUSxTQUFSLEFBQVMsZUFBVCxBQUF3QixBQUN2QixlQURELEFBQ0UscUJBREYsQUFDdUIsQUFBTSxNQUZ4RCxBQUV3RDtBQUN6RCxtQkFBVyxBQUFRLFNBQVIsQUFBUyx1QkFBVCxBQUFnQyxBQUFnQixnQkFBQTtBQUMzRCxlQUFPLEFBQUMsS0FBQSxBQUFFLEdBQUMsQUFBTyxRQUFDO0FBQ25CLGFBQVEsQUFBSSxLQUFQLEFBQVEsU0FBWSxBQUFDLEtBQUEsQUFBRSxHQUFDLEFBQUcsSUFBUCxBQUFRLFFBQVIsQUFBZ0IsTUFDN0IsQ0FBQyxDQUFDLEFBQVEsU0FBUixBQUFTLGVBQVQsQUFBd0IsQUFDekIsZUFEQyxBQUNBLHFCQURBLEFBQ3FCLEFBQU0sTUFENUIsQUFDNEIsSUFENUIsQUFDZ0MsR0FGeEMsQUFBb0IsQUFDYixBQUFDLEFBQ21DLGFBQWdCO0FBQ2hFLGtCQVJDLEFBUVM7QUFSVCxPQUFBLFVBVUcsQUFBUSxTQUFSLEFBQVMsZUFBWixBQUFHLEFBQXdCO0FBQzVCLG1CQUFXLEFBQVEsU0FBUixBQUFTLGVBQVQsQUFBd0I7QUFDbkMsZUFBTyxBQUFDLEtBQUEsQUFBRSxHQUFDLEFBQU8sUUFBQztBQUNuQixhQUFRLEFBQUksS0FBUCxBQUFRLFNBQVksQUFBQyxLQUFBLEFBQUUsR0FBQyxBQUFHLElBQVAsQUFBUSxRQUFSLEFBQWdCLE1BQ3JCLENBQUMsQ0FBQyxBQUFRLFNBQVIsQUFBUyxxQkFBVCxBQUE4QixBQUFTLFNBQXhDLEFBQXdDLElBQXhDLEFBQ0QsR0FGZixBQUFvQixBQUNMLEFBQUMsQUFDRSxhQUFnQjtBQUN2QyxrQkFOQyxBQU1TO0FBTlQsT0FBQSxNQUFBO0FBU0QsbUJBQVcsQUFBQyxLQUFBLEFBQUUsR0FBQyxBQUFFLEdBQU4sQUFBTztBQUNsQixpQkFBUyxJQUFBLEFBQUksT0FBTyxBQUFLLE1BQUwsQUFBTSxjQUFjLEFBQVEsU0FBNUIsQUFBNkIsUUFBN0IsQUFDWixVQURDLEFBQ1MsMkNBRFQsQUFDb0Q7QUFDN0QsaUJBQVMsSUFBQSxBQUFJLE9BQU8sQUFBSyxNQUFMLEFBQU0sY0FBYyxBQUFRLFNBQTVCLEFBQTZCLFNBQXhDLEFBQ0QsbUNBREMsQUFDa0M7QUFDM0MsaUJBQVMsSUFBQSxBQUFJLE9BQU8sQUFBSyxNQUFMLEFBQU0sY0FBYyxBQUFRLFNBQTVCLEFBQTZCLFFBQTdCLEFBQ1osVUFEQyxBQUNTLDRDQURULEFBQ3FEO0FBQzlELGlCQUFTLElBQUEsQUFBSSxPQUFPLEFBQUssTUFBTCxBQUFNLGNBQWMsQUFBUSxTQUE1QixBQUE2QixTQUF4QyxBQUNELG9DQURDLEFBQ21DO0FBQzVDLGlCQUFTLElBQUEsQUFBSSxPQUFPLEFBQUssTUFBTCxBQUFNLGNBQWMsQUFBUSxTQUE1QixBQUE2QixRQUE3QixBQUNaLFVBREMsQUFDUyx1Q0FEVCxBQUNnRDtBQUN6RCxpQkFBUyxJQUFBLEFBQUksT0FBTyxBQUFLLE1BQUwsQUFBTSxjQUFjLEFBQVEsU0FBNUIsQUFBNkIsU0FBeEMsQUFDRCwrQkFEQyxBQUM4QjtBQUN2QyxpQkFBUyxJQUFBLEFBQUksT0FBTyxBQUFLLE1BQUwsQUFBTSxjQUFjLEFBQVEsU0FBNUIsQUFBNkIsUUFBN0IsQUFDWixVQURDLEFBQ1MsNkNBRFQsQUFDc0Q7QUFDL0QsaUJBQVMsSUFBQSxBQUFJLE9BQU8sQUFBSyxNQUFMLEFBQU0sY0FBYyxBQUFRLFNBQTVCLEFBQTZCLFNBQXhDLEFBQ0QscUNBREMsQUFDb0M7QUFDN0MsaUJBQVMsSUFBQSxBQUFJLE9BQU8sQUFBSyxNQUFMLEFBQU0sY0FBYyxBQUFRLFNBQTVCLEFBQTZCLFFBQTdCLEFBQ1osVUFEQyxBQUNTLDRDQURULEFBQ3FEO0FBQzlELGlCQUFTLElBQUEsQUFBSSxPQUFPLEFBQUssTUFBTCxBQUFNLGNBQWMsQUFBUSxTQUE1QixBQUE2QixTQUF4QyxBQUNELG9DQURDLEFBQ21DO0FBRTVDLFlBQUcsQUFBUSxTQUFDLEFBQUksS0FBYixBQUFjLE9BQWQsQUFBcUIsVUFBVSxDQUEvQixBQUFnQyxLQUNQLEFBQVEsU0FBQyxBQUFJLEtBQWIsQUFBYyxPQUFkLEFBQXFCLFVBQVUsQ0FEM0QsQUFDNEQ7QUFDeEQscUJBQVcsQUFBUSxTQUFSLEFBQVMsZUFBVCxBQUF3QjtBQUNuQyxpQkFBTyxBQUFDLEtBQUEsQUFBRSxHQUFDLEFBQU8sUUFBQztBQUNuQixlQUFRLEFBQUksS0FBUCxBQUFRLFNBQVksQUFBQyxLQUFBLEFBQUUsR0FBQyxBQUFJLEtBQVIsQUFBUyxRQUFULEFBQWlCLFdBQXJDLEFBQW9CLEFBQTRCLFFBSnpELEFBS2E7QUFMYixtQkFPUSxBQUFRLFNBQUMsQUFBSSxLQUFiLEFBQWMsT0FBZCxBQUFxQixVQUFVLENBQS9CLEFBQWdDLEtBQ1osQUFBUSxTQUFDLEFBQUksS0FBYixBQUFjLE9BQWQsQUFBcUIsVUFBVSxDQUR0RCxBQUN1RDtBQUN4RCxxQkFBVyxBQUFRLFNBQVIsQUFBUyxlQUFULEFBQXdCLEFBQ1AsbUJBRGpCLEFBQ2tCLHFCQURsQixBQUN1QyxBQUFNLE1BQUE7QUFDeEQsaUJBQU8sQUFBQyxLQUFBLEFBQUUsR0FBQyxBQUFPLFFBQUM7QUFDbkIsZUFBUSxBQUFJLEtBQVAsQUFBUSxTQUFZLEFBQUMsS0FBQSxBQUFFLEdBQUMsQUFBTyxRQUFYLEFBQVksUUFBWixBQUFvQixpQkFBeEMsQUFBb0IsQUFBcUMsUUFBVztBQUN6RSx1QkFBYTtBQUNiLEFBQUMsZUFBQSxBQUFFLEdBQUMsQUFBSSxLQVBQLEFBT0QsQUFBUztBQVBSLFNBQUEsVUFTRyxBQUFRLFNBQUMsQUFBSSxLQUFiLEFBQWMsT0FBZCxBQUFxQixVQUFVLENBQS9CLEFBQWdDLEtBQ1osQUFBUSxTQUFDLEFBQUksS0FBYixBQUFjLE9BQWQsQUFBcUIsVUFBVSxDQUR0RCxBQUN1RDtBQUN4RCxxQkFBVyxBQUFRLFNBQVIsQUFBUyxlQUFULEFBQXdCLEFBQ1AsbUJBRGpCLEFBQ2tCLHFCQURsQixBQUN1QyxBQUFNLE1BQUE7QUFDeEQsaUJBQU8sQUFBQyxLQUFBLEFBQUUsR0FBQyxBQUFPLFFBQUM7QUFDbkIsZUFBUSxBQUFJLEtBQVAsQUFBUSxTQUFZLEFBQUMsS0FBQSxBQUFFLEdBQUMsQUFBTyxRQUFYLEFBQVksUUFBWixBQUFvQixZQUF4QyxBQUFvQixBQUFnQyxRQUFXO0FBQ3BFLHVCQU5DLEFBTVk7QUFOWixTQUFBLFVBUUcsQUFBUSxTQUFDLEFBQUksS0FBYixBQUFjLE9BQWQsQUFBcUIsVUFBVSxDQUEvQixBQUFnQyxLQUNaLEFBQVEsU0FBQyxBQUFJLEtBQWIsQUFBYyxPQUFkLEFBQXFCLFVBQVUsQ0FEdEQsQUFDdUQ7QUFDeEQscUJBQVcsQUFBUSxTQUFSLEFBQVMsZUFBVCxBQUF3QixBQUNQLG1CQURqQixBQUNrQixxQkFEbEIsQUFDdUMsQUFBTSxNQUFBO0FBQ3hELGlCQUFPLEFBQUMsS0FBQSxBQUFFLEdBQUMsQUFBTyxRQUFDO0FBQ25CLGVBQVEsQUFBSSxLQUFQLEFBQVEsU0FBWSxBQUFDLEtBQUEsQUFBRSxHQUFDLEFBQUcsSUFBUCxBQUFRLFFBQVIsQUFBZ0IsTUFDekIsQ0FBQyxDQUFDLEFBQVEsU0FBUixBQUFTLGVBQVQsQUFBd0IsQUFDbEIsbUJBRE4sQUFDTyxxQkFEUCxBQUM0QixBQUFNLE1BRG5DLEFBQ21DLElBRG5DLEFBRUQsR0FIWCxBQUFvQixBQUNULEFBQUMsQUFFRSxhQUFnQjtBQUNuQyxvQkFUQyxBQVNTO0FBVFQsU0FBQSxVQVdHLEFBQVEsU0FBQyxBQUFJLEtBQWIsQUFBYyxPQUFkLEFBQXFCLFVBQVUsQ0FBL0IsQUFBZ0MsS0FDWixBQUFRLFNBQUMsQUFBSSxLQUFiLEFBQWMsT0FBZCxBQUFxQixVQUFVLENBRHRELEFBQ3VEO0FBQ3hELEFBQUMsZUFBQSxBQUFFLEdBQUMsQUFBSSxLQUZQLEFBRUQsQUFBUztBQUZSLFNBQUEsVUFJRyxBQUFRLFNBQVIsQUFBUyx1QkFBVCxBQUFnQyxBQUNZLGdCQUQ1QyxBQUM2QyxTQURoRCxBQUN5RDtBQUMxRCxxQkFBVyxBQUFRLFNBQVIsQUFBUyx1QkFBVCxBQUFnQyxBQUFnQixnQkFBQTtBQUMzRCxpQkFBTyxBQUFDLEtBQUEsQUFBRSxHQUFDLEFBQU8sUUFBQztBQUNuQixlQUFRLEFBQUksS0FBUCxBQUFRLFNBQVksQUFBQyxLQUFBLEFBQUUsR0FBQyxBQUFHLElBQVAsQUFBUSxRQUFSLEFBQWdCLE1BQ3JCLENBQUMsQ0FBQyxBQUFRLFNBQVIsQUFBUyxxQkFBVCxBQUE4QixBQUFNLE1BQXJDLEFBQXFDLElBQXJDLEFBQ0QsR0FGZixBQUFvQixBQUNMLEFBQUMsQUFDRSxhQUFnQjtBQUN2QyxvQkFQQyxBQU9TO0FBUFQsU0FBQSxNQVNBLElBQUcsQUFBUSxTQUFSLEFBQVMsdUJBQVQsQUFBZ0MsQUFDWSwyQkFENUMsQUFDNkMsU0FEaEQsQUFDeUQ7QUFDMUQscUJBQVcsQUFBUSxTQUFSLEFBQVMsdUJBQVQsQUFDcUIsQUFBMkIsMkJBQUE7QUFDM0QsaUJBQU8sQUFBQyxLQUFBLEFBQUUsR0FBQyxBQUFPLFFBQUM7QUFDbkIsZUFBUSxBQUFJLEtBQVAsQUFBUSxTQUFZLEFBQUMsS0FBQSxBQUFFLEdBQUMsQUFBRyxJQUFQLEFBQVEsUUFBUixBQUFnQixNQUN6QixDQUFDLENBQUMsQUFBUSxTQUFSLEFBQVMscUJBQVQsQUFBOEIsQUFBUyxTQUF4QyxBQUF3QyxJQUF4QyxBQUNELEdBRlgsQUFBb0IsQUFDVCxBQUFDLEFBQ0UsYUFBZ0I7QUFDbkMsb0JBUkMsQUFRUztBQXZGYjs7QUF5RkwsVUFBQSxBQUFHO0FBQ0MsQUFBRyxZQUFILEFBQUksZ0JBQUosQUFBb0I7QUFHcEIsZUFBTyxBQUFRLFNBQVIsQUFBUyxjQUFULEFBQXVCO0FBQzlCLEFBQUksYUFBSixBQUFLLEtBQUs7QUFFVixpQkFBUyxBQUFRLFNBQVIsQUFBUyxjQUFULEFBQXVCO0FBQ2hDLEFBQU0sZUFBTixBQUFPLFlBQVksQUFBUSxTQUFSLEFBQVMsZUFBNUIsQUFBbUIsQUFBd0I7QUFFM0MsZUFBTyxBQUFRLFNBQVIsQUFBUyxjQUFULEFBQXVCO0FBQzlCLEFBQUksYUFBSixBQUFLLE9BQU87QUFDWixBQUFJLGFBQUosQUFBSyxZQUFZO0FBQ2pCLEFBQUksYUFBSixBQUFLLGlCQUFMLEFBQXNCLFNBQVMsVUFBQSxBQUFDLE9BQzVCO2NBQUE7QUFBQSxBQUFLLGdCQUFMLEFBQU07QUFDTixtQkFBUyxBQUFRLFNBQVIsQUFBUyxlQUFULEFBQXdCO0FBQ2pDLGNBQUcsQUFBTSxPQUFDLEFBQUssTUFBWixBQUFhLFlBQWhCLEFBQTJCO0FBQ3ZCLEFBQU0sbUJBQUMsQUFBSyxNQUFaLEFBQWEsVUFBVTttQkFDdkIsQUFBSSxLQUFKLEFBQUssWUFGVCxBQUVxQjtBQUZyQixpQkFBQTtBQUlJLEFBQU0sbUJBQUMsQUFBSyxNQUFaLEFBQWEsVUFBVTttQkFDdkIsQUFBSSxLQUFKLEFBQUssWUFMVCxBQUtxQjtBQVJNO0FBQS9CLFdBQUEsQUFTRTtBQUNGLEFBQU0sZUFBTixBQUFPLFlBQVAsQUFBbUI7QUFFbkIsQUFBSSxhQUFKLEFBQUssWUFBTCxBQUFpQjtBQUVqQixnQkFBUSxBQUFRLFNBQVIsQUFBUyxjQUFULEFBQXVCO0FBQy9CLEFBQUssY0FBTCxBQUFNLEtBQUs7QUFFWCxBQUFLLGNBQUwsQUFBTSxZQUFOLEFBQWtCO0FBRWxCLGtCQUFVLEFBQUMsS0FBQSxBQUFFLEdBQUMsQUFBRyxJQUFQLEFBQVE7QUFDbEIsWUFBRyxDQUFILEFBQU87QUFDSCxBQUFPLGtCQUFDLEFBQUssTUFBYixBQUFjLFVBRGxCLEFBQzRCOztBQUU1QixBQUFLLGNBQUwsQUFBTSxZQUFOLEFBQWtCO0FBRWxCLFlBQUcsQ0FBSCxBQUFPO0FBQ0gsQUFBSyxnQkFBQyxBQUFLLE1BQVgsQUFBWSxVQUFVO0FBQ3RCLEFBQUksZUFBSixBQUFLLFlBRlQsQUFFcUI7O0FBRXJCLEFBQUksYUFBSixBQUFLLFlBQUwsQUFBaUI7QUFFakIsQUFBUSxpQkFBQyxBQUFVLFdBQW5CLEFBQW9CLGFBQXBCLEFBQWlDLE1BQWpDLEFBQXVDO0FBRXZDLEFBQUMsYUFBQSxBQUFFLEdBQUMsQUFBRyxJQUFQLEFBQVEsQUFBVSxvQ0FBbEIsQUFBa0IsQUFBd0I7QUFDMUMsZUFBTyxJQUFBLEFBQUk7QUFDWCxBQUFDLGFBQUEsQUFBRSxHQUFDLEFBQUcsSUFBUCxBQUFRLEFBQVUscUJBQVMsQUFBSSxLQUEvQixBQUFrQixBQUFTLEFBQUs7ZUFDaEMsQUFBQyxLQUFBLEFBQUUsR0FBQyxBQUFHLElBQVAsQUFBUSxBQUFVLG9CQUFRLEFBQVEsU0FqRHRDLEFBaURJLEFBQWtCLEFBQWlCO0FBeExsQztBQUhiOzs7Ozs7Ozs7Ozs7Ozs7QUN2QkEsSUFBQTtJQUFBO0lBQUE7SUFBQTtJQUFBO0lBQUEsYUFrQkE7O2VBQXVCLFFBQXZCLEFBQXVCLEFBQVEsQUFDL0I7O0FBREEsQUFBQztBQUFELEFBQVM7QUFBVCxBQUFZO0FBQVosQUFBZ0I7O2dCQUNKLFFBQVosQUFBWSxBQUFROztBQUFwQixBQUFDOzs7QUFHSyxBQUFNLE9BQUM7TUFBYjs7TUFBQTtBQUdJLEFBQWEscUJBQUE7OztBQUFDLEFBQUMsV0FBQSxLQUFGO0FBRWIsQUFBa0IsQUFDZDs7Ozs7Ozs7Ozs7Ozt1QkFBRyxBQUFDLEtBQUosQUFBRyxBQUFDOzs7Ozs7eUJBQ3lCLEFBQUMsRUFBRCxBQUFFLFFBQTNCLEFBQW1CLEFBQU0sQUFBVSxBQUduQzs7O0FBSEEsQUFBbUI7O3dCQUdoQixZQUFXLEFBQWdCLGlCQUE5QixBQUErQjs7Ozs7d0RBQzNCLEFBQUMsbUNBQ2MsQUFBZ0IsaUJBRFQsQUFDbEIsQUFBNEIsQUFBUSw0QkFEbEIsQUFFbEI7QUFDRywwQkFBSCxBQUFFLEFBQU8sdURBQVAsRUFBRixFQUhrQixBQUdsQixBQUNFLGNBSmdCLEFBS2xCLFFBQ0EsQUFBRTtBQUFnQiw2QkFBUzs2QkFDekIsQUFBQyxNQUFELEFBQUMsUUFBUSxBQUFnQixpQkFEQSxBQUN6QixBQUEwQjtBQVJwQyxBQUNJLEFBQXNCLEFBTWxCLEFBQWlCO0FBQUEsbUJBQWpCLENBTmtCLEFBQ2xCLENBREosQUFBQzs7O21EQVdELEFBQUUsR0FBQyxBQUFPLFFBQVYsQUFBVyxJQUFYLEFBQWUsZ0NBQ0EsQUFBUSxTQUFSLEFBQVMsT0FsQmxCLEFBQ2QsQUFJSSxBQVlJLEFBQ2UsQUFBZ0IsQUFFM0MsQUFBYzs7Ozs7Ozs7Ozs7Ozs7Ozs7O3FDQUNWO1lBQUEsTUFBQSxjQUFBO0FBQUEsdUJBQWUsQUFBRSxHQUFDLEFBQU8sUUFBVixBQUFXLElBQVgsQUFBZTtBQUM5QixZQUFHLENBQUgsQUFBTyxjQUNIO2lCQURKLEFBQ1c7O0FBRVgsZUFBTyxBQUFRLFNBQVIsQUFBUyxLQUFLLE9BQWQsQUFBYyxBQUFPLGVBSjVCLEFBSU8sQUFBb0M7O0FBRzNDLFlBQUksUUFBQSxBQUFRLEFBQU0sWUFBQSxBQUFRLFNBQVIsQUFBUyxPQUFULGFBQ1YsQUFBQyxLQUFBLEFBQUUsR0FBQyxBQUFJLEtBREUsQUFDRCxvQkFEQyxRQUFmLEFBQWUsRUFBZixJQUNxQyxRQUR4QyxBQUNnRCxHQUM1QztpQkFGSixBQUVXO0FBQ1g7ZUFYVSxBQVdIO0FBRVgsQUFBc0I7OzsyQ0FBQSxBQUFDLFNBQUQsQUFBVSxpQkFDNUI7WUFBQTtBQUFBO0FBQ0ksb0JBRE0sQUFDSTtBQUNWLGVBRk0sQUFFRDtBQUNMLGlCQUhNLEFBR0M7QUFDUCxnQkFKTSxBQUlBO0FBSkE7QUFNVixBQUFDLFVBQUQsQUFBRSxPQUFGLEFBQVMsU0FBVCxBQUFrQjtlQUNsQixBQUFFLEdBQUMsQUFBWSxhQUFmLEFBQWdCLE9BQWhCLEFBQXVCLFNBUkwsQUFRbEIsQUFBZ0M7QUFFcEMsQUFBUzs7OzhCQUFBLEFBQUM7QUFDTjs7WUFBQSxNQUFBLFVBQUE7QUFBQSxBQUFPLHlCQUFRLEFBQUUsR0FBQyxBQUFJLEtBQWYsQUFBUSxBQUFRLEFBQVU7QUFDakMsbUJBQVcsQUFBQyxLQUFBLEFBQUUsR0FBQyxBQUFFLEdBQU4sQUFBTyxZQUFQLEFBQW1CO0FBRTlCLEFBQUMsYUFBRCxBQUFDLEFBQXFCLCtDQUh0QixBQUdBLEFBQXNCLEFBQXdCLEFBQWlCOztBQUkvRCxnQkFBUSxJQUFBLEFBQUksT0FBTyxBQUNmLHNEQUFLLEFBQUUsR0FBQyxBQUFNLE9BQVQsQUFBVSxPQURBLEFBQ2YsQUFBSyxBQUFpQixBQUFTLHdCQUQzQixBQUVKLCtCQUZJLEFBRTJCO29CQUVsQyxBQUFFLEdBQUMsQUFBRSxHQUFDLEFBQUcsSUFBVixBQUFXLEtBQVgsQUFBZ0IsTUFBTSxVQUFBLEFBQUMsVUFDbkI7Y0FBQTtBQUFBLG9CQUFVLEFBQVEsU0FBQyxBQUFPLFFBQWhCLEFBQWlCLFFBQWpCLEFBQXlCLEFBQ0EsY0FEekIsQUFDeUIsQUFBSyxBQUFpQjtBQUV6RCxjQUFHLFlBQVcsQUFBUSxTQUF0QixBQUF1QixTQUduQjttQkFBTyxBQUFPLFFBQVAsQUFBUSxPQUNYLElBQUEsQUFBSSxNQUpaLEFBR1csQUFDSCxBQUFVO0FBRWxCOztBQUNJLGtCQURHLEFBQ0c7QUFDTixBQUFTLHdEQUZOLEFBRU0sQUFBaUM7QUFDMUMsaUJBYmMsQUFVWCxBQUdFO0FBSEY7QUFWWCxBQWVDLFNBZkQsQUFBQyxFQUFELEFBZUUsS0FBSyxVQUFBLEFBQUM7QUFDSixBQUFPLGtCQUFQLEFBQVEsSUFBUixBQUFZO2lCQUNaLEFBQUMsT0FBRCxBQUFDLHNCQUFxQixBQUNsQixrR0FEa0IsQUFHbEI7QUFDRyxrQkFBSCxBQUFFLEFBQU87QUFBUCxXQUFGLEVBTkQsQUFFSCxBQUFzQixBQUlsQixBQUNFLFlBTGdCO0FBakIxQixBQXdCQyxXQXhCRCxBQXdCRSxLQUFLLFVBQUEsQUFBQyxNQUFELEFBQU87QUFDVixBQUFPLGtCQUFQLEFBQVEsTUFBUixBQUFjLE1BQWQsQUFBb0I7d0JBQ3BCLEFBQUMscUVBQXFCLEFBQ2xCLEFBQ0UsQUFBaUI7QUFDaEIscUJBQVM7cUJBQ1IsQUFBQyxPQUFELEFBQUMsUUFETyxBQUNSLEFBQVM7QUFEYixBQUFFO0FBQUEsV0FBRixFQUhrQixBQUdsQixBQUVHLFFBTGUsQUFDbEIsRUFEa0IsQUFNbEIsb0hBTmtCLEFBUWxCLFVBUkosQUFBc0IsQUFRUjtBQUlWLGtCQWRELEFBRUgsQUFZRyxBQUFPO0FBQVAsV0FaSCxBQUFDO0FBdENBLEFBWUw7QUF5Q0osQUFBdUI7Ozs7QUFFbkI7O1lBQUEsTUFBQSxVQUFBOztBQUFBLGtCQUFVLEFBQVksYUFBWixBQUFhLFFBQWIsQUFBcUI7QUFDL0IsWUFBRyxZQUFILEFBQWdCO0FBQ1oscUJBQU8sQUFBSSxLQUFLLENBQVQsQUFBUyxBQUFDO0FBQVcsa0JBQXJCLEFBQW9CLEFBQU87QUFBUCxXQUFwQjtBQUNQLHFCQUFXLEFBQU0sT0FBQyxBQUFHLElBQVYsQUFBVyxnQkFBWCxBQUEyQjtpQkFDdEMsQUFBQyxLQUFELEFBQUMsc0JBQXFCLEFBQ2xCLDJUQURrQixBQU9sQjtBQUNHLGtCQUFILEFBQUUsQUFBTywyREFBUCxFQUFGLEVBUmtCLEFBUWxCLEFBQ0UsbUNBVGdCLEFBVWxCO0FBQ0csa0JBQUgsQUFBRSxBQUFPO0FBQVAsV0FBRixFQVhrQixBQVdsQixBQUFvQix5QkFYRixFQUFBLEFBWWxCO0FBQ0csa0JBQUQsQUFBTztBQUFVLHNCQUFuQixBQUFFLEFBQTJCO0FBQTNCLFdBQUYsRUFia0IsQUFhbEIsQUFDRSw2QkFkZ0IsQUFlbEI7QUFDRyxxQkFBUztBQUNSLEFBQVksMkJBQVosQUFBYSxXQUFiLEFBQXdCOzRCQUN4QixBQUFDLHFCQUFELEFBQ0k7QUFDQywwQkFKRyxBQUVSLEFBRUksQUFBVztBQUFYLGVBRkosQUFBQztBQUZMLEFBQUU7QUFBQSxXQUFGLEVBbkJSLEFBR0ksQUFBc0IsQUFnQmxCLEFBTUc7QUE1QlE7QUFyRzNCOzs7Ozs7OztBQUNJLGdCQUFjOzs7Ozs7Ozs7Ozs7QUNKWixBQUFNLE9BQVosQUFBYTtBQUNULEFBQWEsbUJBQUE7OztBQUFDLEFBQUMsU0FBQSxLQUFGO0FBRWIsQUFBcUI7Ozs7O0FBQ1YsVUFBRyxBQUFRLFNBQVIsQUFBUyxlQUFaLEFBQUcsQUFBd0I7ZUFBM0IsQUFBeUQ7QUFBekQsYUFBQTtlQUFBLEFBQ3lEO0FBRi9DO0FBSXJCLEFBQVU7OzsrQkFDTjthQUFPLEFBQVEsU0FBUixBQUFTLGVBQVQsQUFBd0IsQUFDSyxjQUQ3QixBQUM4QixxQkFEOUIsQUFDbUQsQUFBSyxLQUFBLEFBQUUsR0FGM0QsQUFFNEQ7QUFUMUU7Ozs7Ozs7Ozs7Ozs7QUNuQkEsSUFBQSxVQUFBLEtBQUEsS0FBQSxNQUFBLFFBQUEsU0FBQSxlQUFBLEtBQUEsSUFBQSxNQUFBLE1BQUEsUUFBQSxRQUFBLFFBQUEsSUFBQSxTQUFBLGVBQUE7O0FBa0JBLGVBQWUsQUFBRSxHQUFDLEFBQU0sT0FBVCxBQUFVLE1BQU0sQ0FBQSxBQUFDLHNCQWxCaEMsQUFrQmUsQUFBZ0IsQUFDQzs7QUFHaEMsUUF0QkEsQUFzQkEsQUFBUTs7QUFJUixXQUFXLFFBQUEsQUFBUTs7QUFDbkIsTUFBTSxRQUFBLEFBQVE7O0FBQ2QsTUFBTSxRQUFBLEFBQVE7O0FBQ2QsT0FBTyxRQUFBLEFBQVE7O0FBQ2YsU0FBUyxRQUFBLEFBQVE7O0FBQ2pCLFVBQVUsUUFBQSxBQUFROztBQUNsQixnQkFBZ0IsUUFBQSxBQUFROztBQUN4QixNQUFNLFFBQUEsQUFBUTs7QUFDZCxPQUFPLFFBQUEsQUFBUTs7QUFDZixPQUFPLFFBQUEsQUFBUTs7QUFDZixLQUFLLFFBQUEsQUFBUTs7QUFDYixTQUFTLFFBQUEsQUFBUTs7QUFDakIsU0FBUyxRQUFBLEFBQVE7O0FBQ2pCLEtBQUssUUFBQSxBQUFROztBQUNiLFVBQVUsUUFBQSxBQUFROztBQUNsQixnQkFBZ0IsUUFBQSxBQUFRLEFBRXhCOztlQUFXLFFBQVgsQUFBVyxBQUFROztBQUFuQixBQUFDOzs7QUFHSyxBQUFNLE9BQUMsQUFBTyxRQUFDO0FBQXJCLE1BQUE7QUFVSSxBQUFhLGdCQUFBOzs7QUE4Q2IsV0FBQSxPQUFBLEtBQUE7QUE5Q2MsQUFBQyxXQUFBOzs7QUFBRixBQUFhOzs7QUFBQSxBQUFDLFdBQUEseUJBQUQ7QUFDdEIsQUFBQyxXQUFELEFBQUM7QUFDRCxBQUFDLFFBQUQsQUFBRSxLQUFGLEFBQU8sY0FBYyxBQUFDLEVBQXRCLEFBQXVCLEFBQU0sT0FBN0IsQUFBOEIsS0FBSyxBQUFDLEtBRjNCLEFBRVQsQUFBb0M7QUFFeEMsQUFBTzs7Ozs4QkFPSDtZQUFBLFdBQUEsT0FBQSxHQUFBLFlBQUEsS0FBQSxRQUFBLE1BQUEsT0FBQSxLQUFBLGFBQUE7O0FBQUEsc0JBQWMsQUFBTSxPQUFOLEFBQU8sb0JBQW9CLEFBQU0sT0FBakMsQUFBa0MscUJBQXFCO0FBRXJFLGFBQUEsVUFBQTs7Z0JBQXNDLFVBQVUsQUFBQyxLQUFBOzs7QUFDN0MsQUFBQyxlQUFBLEFBQUssS0FBTixBQUFNLFVBQVU7QUFDaEIsaUJBQU8sQUFBWSxZQUZ2QixBQUV1Qjs7QUFFdkIsQUFBQyxhQUFELEFBQUM7QUFDRyxlQUFBLEFBQUs7QUFDTCxnQkFEQSxBQUNNO0FBQ04sa0JBRkEsQUFFUTtBQUNSLG9CQUhBLEFBR1U7QUFDVix5QkFKQSxBQUllO0FBQ2YsbUJBTEEsQUFLUyxBQUViO0FBUEk7O0FBT0osYUFBQSxrQ0FBQTs7QUFDSSxlQUFBLFNBQUE7O2tCQUM2QixBQUFTLFVBQVQsQUFBVSxxQkFBcUI7O0FBQ3hEOztBQUNJLEFBQVMsd0JBQVQsQUFBVSxZQUFZLEFBQUMsS0FBdkIsQUFBdUIsV0FEM0IsQUFDSSxBQUFrQztBQUR0QyxxQkFBQTtBQUVNLHNCQUdGOztBQUFBLGtCQUFHLEFBQUssTUFBTCxBQUFNLFlBQVQsQUFBb0IsbUJBQ2hCO0FBREo7O0FBRUEsb0JBUEosQUFPVTs7QUFFVixpQkFBQSxtQkFBQTtrQkFDNkIsQUFBUyxVQUFBLEFBQUcsb0JBQUEsQUFBUTtBQUM3QyxBQUFDLHFCQUFBLEFBQVEsUUFBQSxBQUFXLFlBQXBCLEFBQXFCLEtBQXJCLEFBQTBCO0FBRjlCO0FBWEo7QUFESjs7QUFnQkEsWUFBRyxDQUFJLEFBQUMsRUFBRCxBQUFFLGNBQVQsQUFBTyxBQUFnQjtBQUNuQixBQUFPLGtCQUFQLEFBQVEsS0FBUixBQUFhLGdDQURqQixBQUNJLEFBQTZDOztlQUVqRCxPQUFPLEFBQUMsS0F4Q0wsQUF3Q0s7QUFFWixBQUFNOzs7NkJBQUE7QUFHRixBQUFDLGFBQUQsQUFBQyxXQUFXLElBQUEsQUFBSSxTQUFKLEFBQWE7QUFDekIsQUFBQyxhQUFELEFBQUMsTUFBTSxJQUFBLEFBQUksSUFBSixBQUFRO0FBQ2YsQUFBQyxhQUFELEFBQUMsTUFBTSxJQUFBLEFBQUksSUFBSixBQUFRO0FBQ2YsQUFBQyxhQUFELEFBQUMsT0FBTyxJQUFBLEFBQUksS0FBSixBQUFTO0FBQ2pCLEFBQUMsYUFBRCxBQUFDLFNBQVMsSUFBQSxBQUFJLE9BQUosQUFBVztBQUNyQixBQUFDLGFBQUQsQUFBQyxVQUFVLElBQUEsQUFBSSxRQUFKLEFBQVk7QUFDdkIsQUFBQyxhQUFELEFBQUMsZ0JBQWdCLElBQUEsQUFBSSxjQUFKLEFBQWtCO0FBQ25DLEFBQUMsYUFBRCxBQUFDLE1BQU0sSUFBQSxBQUFJLElBQUosQUFBUTtBQUNmLEFBQUMsYUFBRCxBQUFDLE9BQU8sSUFBQSxBQUFJLEtBQUosQUFBUztBQUNqQixBQUFDLGFBQUQsQUFBQyxPQUFPLElBQUEsQUFBSSxLQUFKLEFBQVM7QUFDakIsQUFBQyxhQUFELEFBQUMsS0FBSyxJQUFBLEFBQUksR0FBSixBQUFPO0FBQ2IsQUFBQyxhQUFELEFBQUMsU0FBUyxJQUFBLEFBQUksT0FBSixBQUFXO0FBQ3JCLEFBQUMsYUFBRCxBQUFDLFNBQVMsSUFBQSxBQUFJLE9BQUosQUFBVztBQUNyQixBQUFDLGFBQUQsQUFBQyxLQUFLLElBQUEsQUFBSSxHQUFKLEFBQU87QUFDYixBQUFDLGFBQUQsQUFBQyxVQUFVLElBQUEsQUFBSSxRQUFKLEFBQVk7QUFDdkIsQUFBQyxhQUFELEFBQUMsZ0JBQWdCLElBQUEsQUFBSSxjQUFKLEFBQWtCO0FBRW5DLEFBQUMsYUFBQSxBQUFPLFFBQVIsQUFBUztBQUNULFlBQUcsQUFBQyxLQUFBLEFBQUksS0FBUixBQUFTO0FBQ0wsQUFBQyxlQUFBLEFBQU8sUUFEWixBQUNJLEFBQVM7O2VBRWIsQUFBQyxLQUFBLEFBQUUsR0F4QkQsQUF3QkYsQUFBSTtBQWhGWjs7Ozs7Ozs7ZUFDSTtBQUNJLHdCQUFBLEFBQW9CO0FBQ3BCLGtDQURBLEFBQzhCO0FBQzlCLDZCQUZBLEFBRXlCO0FBQ3pCLHdCQUFvQixDQUhwQixBQUdvQixBQUFDO0FBQ3JCLHlCQUpBLEFBSXFCO0FBQ3JCLDBDQUxBLEFBS3NDO0FBQ3RDLDZCQU5BLEFBTXlCO0FBTnpCOzs7Ozs7OztBQ2hEUixJQUFBLFFBQUEsSUFBQSxLQUFBOztBQWtCQSxRQWxCQSxBQWtCQSxBQUFROztBQUlSLEtBQUssUUFBQSxBQUFRLHVCQUF1QixRQUEvQixBQUErQixBQUFROztBQUM1QyxLQUFBLE9BQUE7Y0FBQTs7QUFHSSxBQUFNLFNBQUMsQUFBUSxRQUFBLEFBQUcsSUFBSCxBQUFJLE9BQUosQUFBVyxBQUFFLEdBQWIsQUFBYyxnQkFBZ0IsQUFBRyxJQUFILEFBQUksTUFBakQsQUFBZSxBQUE4QixBQUFVLE1BSDNELEFBR2lFOzs7QUFFakUsQUFBTSxPQUFDLEFBQU8sUUFBZCxBQUFlLFNBQVMsUUFBQSxBQUFROztBQUVoQyxNQUFNLFFBQUEsQUFBUSxBQUFNLE9BQUM7O0FBQ3JCLEFBQUcsSUFBSCxBQUFJLE1BQU0sUUFBQSxBQUFRLEFBQXFCLHNCQUF2QyxBQUFVLEFBQThCOztBQUN4QyxBQUFNLE9BQUMsQUFBTyxRQUFkLEFBQWUsTUFBTTs7Ozs7Ozs7Ozs7OztBQ2hDckIsSUFBQTtJQUFBLGFBa0JBOztlQUFXLFFBQVgsQUFBVyxBQUFROztBQUFuQixBQUFDOzs7QUFHSyxBQUFNLE9BQUMsQUFBTyxRQUFDO0FBQXJCLE1BQUE7Ozs7Ozs7Ozs7O2tDQUtpQixBQUFDLFVBQ1Y7WUFBQSxHQUFBLGtCQUFBLFFBQUEsU0FBQSxLQUFBLFlBQUEsU0FBQSxTQUFBLFVBQUEsU0FBQSxTQUFBLFlBQUEsU0FBQSxXQUFBLGNBQUEsTUFBQSxJQUFBLFdBQUEsVUFBQSxRQUFBLEdBQUEsZUFBQSxTQUFBLFFBQUEsR0FBQSxHQUFBLEdBQUEsVUFBQSxLQUFBLEtBQUEsTUFBQSxNQUFBLE1BQUEsTUFBQSxVQUFBLFVBQUEsV0FBQSxnQkFBQSxTQUFBLEtBQUEsTUFBQSxRQUFBLGFBQUEsVUFBQTtBQUFBLGlCQUFTLEFBQUMsS0FBQSxBQUFFLEdBQUMsQUFBTSxPQUFWLEFBQVc7QUFFcEIsbUJBQVcsQUFBQyxLQUFBLEFBQUUsR0FBQyxBQUFRLFNBQVosQUFBYSxlQUFlLEFBQUMsS0FBQSxBQUFFLEdBQUMsQUFBTSxPQUF0QyxBQUE0QixBQUFXLEFBQVksWUFBQTtBQUU5RCxpQkFBUztBQUNULGtCQUxBLEFBS1U7O0FBR1Ysa0JBQVUsQUFBTyxRQUFQLEFBQVEsUUFBUixBQUFnQixtQkFBaEIsQUFBbUM7QUFDN0MsWUFBRyxZQUFILEFBQWM7QUFDVixvQkFESixBQUNjO0FBVmQ7O0FBYUEsdUJBQWUsQUFBQyxLQUFBLEFBQUUsR0FBQyxBQUFNLE9BQVYsQUFBVyxjQUFYLEFBQXlCLFNBQXpCLEFBQWtDO0FBQ2pELHlCQUFpQixBQUFDLEtBQUEsQUFBRSxHQUFDLEFBQU0sT0FBVixBQUFXLGNBQVgsQUFBeUIsU0FBekIsQUFBa0M7QUFDbkQsb0JBQVksQUFBWSxhQUFaLEFBQWEsT0FBYixBQUFvQjtBQUNoQyxBQUFTLGtCQUFULEFBQVUsS0FBTSxVQUFBLEFBQUMsR0FBRCxBQUFJLEdBQ2hCO2lCQUFPLEFBQUMsRUFBRCxBQUFFLFFBQVEsQUFBQyxFQUROLEFBQ087QUFEdkI7QUFHQSxzQkFBYztBQUNkLG9CQUFZO0FBQ1osYUFBQSx3Q0FBQTs7QUFDSSx5QkFBZSxBQUFPLFFBQVAsQUFBUSxVQUFSLEFBQWtCLFdBQVcsQUFBUSxTQUFyQyxBQUFzQztBQUNyRCxzQkFBWSxBQUFRLFNBQVIsQUFBUyxRQUFRLEFBQVEsU0FGekMsQUFFMEM7O0FBRTFDLHVCQUFlLEFBQU8sUUFBUCxBQUFRLFVBQVIsQUFBa0I7QUFDakMsa0JBQVU7QUFDVixhQUFLLEFBQVksYUFBWixBQUFhO0FBQ2xCLGNBQU0sQUFBYyxlQUFkLEFBQWU7QUFDckIsZUFBTztBQUNQLFlBQUcsTUFBTyxDQUFWLEFBQWM7QUFDVixpQkFBTyxvQkFBb0IsQUFBRSxHQUF0QixBQUF1QixRQURsQyxBQUMwQztBQUQxQyxtQkFFUSxDQUFBLEFBQUksTUFBUCxBQUFjO0FBQ2YsaUJBREMsQUFDTTtBQUROLFNBQUEsTUFFQSxJQUFHLE1BQUgsQUFBVTtBQUNYLGlCQUFVLEFBQUUsR0FBRixBQUFHLFFBQVEsQUFBRyxJQUFqQixBQUFrQixRQUFsQixBQUE2QixBQUEyQiw0Q0FBa0IsQUFBRSxHQURsRixBQUM4RCxBQUFxQixBQUFNOztBQUM5RixZQUFHLEFBQVksYUFBWixBQUFhLFVBQVUsQUFBYyxlQUF4QyxBQUF5QztBQUNyQyxBQUFDLGVBQUEsQUFBRSxHQUFDLEFBQUcsSUFBUCxBQUFRLFdBRFosQUFDSSxBQUFtQjtBQXJDdkI7O0FBMENBLDJCQUFtQixBQUFDLEtBQUEsQUFBRSxHQUFDLEFBQU0sT0FBVixBQUFXLHFCQUFYLEFBQWdDO0FBQ25ELGlCQUFTO0FBQ1Qsc0JBQWM7QUFDZCxvQkFBWTtBQUNaLGFBQUEsMkRBQUE7O0FBQ0kscUJBQUcsQUFBTyxRQUFDLEFBQU0sTUFBZCxBQUFjLFFBQWQsQUFBcUIsU0FBckIsUUFBQSxBQUE0QixXQUE1QixRQUFILEFBQXdDO0FBQ3BDLEFBQWdCLDZCQUFoQixBQUFpQixPQUFqQixBQUF3QixHQUQ1QixBQUNJLEFBQTJCO0FBRC9CLGlCQUFBO0FBR0ksdUJBQUcsQUFBTyxRQUFDLEFBQU0sTUFBZCxBQUFjLElBQWQsYUFBQSxBQUF3QixRQUF4QixRQUFIO0FBQ0ksQUFBTSxxQkFBTixBQUFPLEtBQUssQUFBTyxRQUFDLEFBQU0sTUFEOUIsQUFDSSxBQUEwQjtBQUQ5QixtQkFBQTtBQUdJLEFBQUMsbUJBQUEsQUFBRSxHQUFDLEFBQUcsSUFBUCxBQUFRLEFBQVcscUNBQ0csQUFBTyxRQUFDLEFBQU0sTUFKeEMsQUFHSSxBQUFtQixBQUNpQjs7QUFDeEMsMkJBQWUsQUFBTyxRQUFQLEFBQVEsVUFBUixBQUFrQixXQUFXLEFBQU8sUUFBcEMsQUFBcUM7QUFDcEQsd0JBQVksQUFBTyxRQUFQLEFBQVEsUUFBUSxBQUFPLFFBVHZDLEFBU3dDO0FBVjVDOztBQVlBLHVCQUFlLEFBQU8sUUFBUCxBQUFRLFVBQVIsQUFBa0I7QUFDakMsa0JBQVU7QUFFVixZQUFHLENBQUEsQUFBSSxRQUFTLEFBQU0sT0FBdEIsQUFBdUI7QUFDbkIsb0JBQVUsQUFBTSxPQUFOLEFBQU8sS0FBUCxBQUFZLE9BRDFCLEFBQ2lDO0FBRGpDLG1CQUVRLFFBQVMsQ0FBSSxBQUFNLE9BQXRCLEFBQXVCO0FBQ3hCLG9CQUFVLE9BRFQsQUFDZ0I7QUFEaEIsU0FBQSxNQUVBLElBQUcsUUFBUyxBQUFNLE9BQWxCLEFBQW1CO0FBQ3BCLG9CQUFVLE9BQUEsQUFBTyxNQUFNLEFBQU0sT0FBTixBQUFPLEtBQXBCLEFBQWEsQUFBWSxPQURsQyxBQUN5QztBQWxFOUM7O0FBcUVBLHFCQUFhLEFBQUMsS0FBQSxBQUFFLEdBQUMsQUFBTSxPQUFWLEFBQVcsZUFBWCxBQUEwQjtBQUN2QyxrQkFBVTtBQUNWLG1CQUFXO0FBQ1gsc0JBQWM7QUFDZCxvQkFBWTtBQUNaLGFBQUEsMkNBQUE7O0FBQ0ksY0FBRyxBQUFHLElBQU4sQUFBTztBQUNILEFBQUMsaUJBQUEsQUFBRSxHQUFDLEFBQUcsSUFBUCxBQUFRLFdBQVcsQUFBQyxLQUFBLEFBQUUsR0FBQyxBQUFHLElBQVAsQUFBUSxlQUFlLEFBQUcsSUFBMUIsQUFBMkIsTUFDMUIsQUFBRyxJQURKLEFBQ0ssV0FGNUIsQUFDSSxBQUNtQzs7QUFJdkMsdUJBQWEsQUFBQyxLQUFBLEFBQUUsR0FBQyxBQUFNLE9BQVYsQUFBVywyQkFBMkIsQUFBRyxJQUF6QyxBQUEwQztBQUN2RCxvQkFBVSxjQVBWLEFBT3dCOztBQUd4QixvQkFBVSxBQUFDLEtBQUEsQUFBRSxHQUFDLEFBQVEsU0FBWixBQUFhLGVBQWIsQUFBNEIsQUFBUyxTQUFBO0FBQy9DLG9CQUFVLE9BQUEsQUFBTyxBQUFVLFdBQUksQUFBRyxJQUFOLEFBQU8sU0FBWSxNQUFNLEFBQUcsSUFBNUIsQUFBNkIsU0FBL0MsQUFBaUIsQUFBMEMsTUFBTTtBQUMzRSxjQUFHLGFBQUgsQUFBZTtBQUNYLEFBQUMsaUJBQUEsQUFBRSxHQUFDLEFBQUcsSUFBUCxBQUFRLFdBQVcsQUFBQyxLQUFBLEFBQUUsR0FBQyxBQUFHLElBQVAsQUFBUSxlQUFlLEFBQUcsSUFBMUIsQUFBMkIsTUFBM0IsQUFBaUMsV0FBakMsQUFDZixpRUFEZSxBQUV5QixXQUhoRCxBQUNJLEFBRXVEOztBQUUzRCxjQUFHLEFBQU8sUUFBUCxBQUFRLFFBQVIsQUFBZ0IsV0FBbkIsQUFBOEI7QUFDMUIsQUFBTyxvQkFBUCxBQUFRLEtBQVIsQUFBYTtBQUNiLEFBQVEscUJBQVIsQUFBUyxLQUZiLEFBRUksQUFBYztBQUZsQixpQkFBQTtBQUlJLEFBQUMsaUJBQUEsQUFBRSxHQUFDLEFBQUcsSUFBUCxBQUFRLFdBQVcsMEJBQ0MsQUFBQyxLQUFBLEFBQUUsR0FBQyxBQUFHLElBQVAsQUFBUSxlQUFlLEFBQUcsSUFBMUIsQUFBMkIsTUFMbkQsQUFJSSxBQUNvQixBQUFpQzs7QUFFekQseUJBQWUsQUFBTyxRQUFQLEFBQVEsVUFBUixBQUFrQixXQUFXLEFBQUcsSUFBaEMsQUFBaUM7QUFDaEQsc0JBQVksQUFBRyxJQUFILEFBQUksUUFBUSxBQUFHLElBMUIvQixBQTBCZ0M7O0FBRWhDLFlBQUcsQUFBTyxRQUFWLEFBQVc7QUFDUCxvQkFBVSxBQUFRLFNBQVIsQUFBUyxLQUFULEFBQWMsUUFENUIsQUFDb0M7QUFEcEMsZUFBQTtBQUdJLEFBQUMsZUFBQSxBQUFFLEdBQUMsQUFBRyxJQUFQLEFBQVEsV0FIWixBQUdJLEFBQW1COztBQUN2Qix1QkFBZSxBQUFPLFFBQVAsQUFBUSxVQUFSLEFBQWtCO0FBQ2pDLGtCQTNHQSxBQTJHVTs7QUFHVix3QkFBZ0IsQUFBQyxLQUFBLEFBQUUsR0FBQyxBQUFRLFNBQVosQUFBYSwwQkFBYixBQUF1QztBQUN2RCxpQkFBUztBQUNULGtCQUFVO0FBQ1Ysc0JBQWM7QUFDZCxvQkFBWTtBQUNaLGFBQUEsOENBQUE7O0FBQ0ksY0FBRyxBQUFJLEtBQVAsQUFBUTtBQUtKLEFBQUMsaUJBQUEsQUFBRSxHQUFDLEFBQUcsSUFBUCxBQUFRLFdBQVcsQUFBSSxLQUFKLEFBQUssVUFMNUIsQUFLSSxBQUFrQztBQUx0Qzs7QUFXQSxzQkFBWSxBQUFJLEtBQUM7QUFDakIscUJBQVcsQUFBSSxLQUFDO0FBQ2hCLHFCQUFXLFdBQUEsQUFBVyxNQUFNO0FBQzVCLHFCQUFXLE9BQUEsQUFBTyxBQUFXLFlBQUksQUFBSSxLQUFQLEFBQVEsV0FBYyxNQUFNLEFBQUksS0FBaEMsQUFBaUMsV0FBcEQsQUFBa0IsQUFBZ0QsTUFBTTtBQUNuRixjQUFHLEFBQU0sT0FBTixBQUFPLFFBQVAsQUFBZSxZQUFsQixBQUE4QjtBQUMxQixBQUFNLG1CQUFOLEFBQU8sS0FBUCxBQUFZO0FBQ1osQUFBTyxvQkFBUCxBQUFRLEtBRlosQUFFSSxBQUFhO0FBRmpCLGlCQUFBO0FBUUksQUFBQyxpQkFBQSxBQUFFLEdBQUMsQUFBRyxJQUFQLEFBQVEsV0FBVywwQkFSdkIsQUFRSSxBQUE2Qzs7QUFFakQseUJBQWUsQUFBTyxRQUFQLEFBQVEsVUFBUixBQUFrQixXQUFXLEFBQUksS0FBakMsQUFBa0M7QUFDakQsc0JBQVksQUFBSSxLQUFKLEFBQUssUUFBUSxBQUFJLEtBM0JqQyxBQTJCa0M7O0FBRWxDLFlBQUcsQUFBTSxPQUFULEFBQVU7QUFDTixBQUFPLGtCQUFQLEFBQVE7QUFDUixvQkFBVSxBQUFPLFFBQVAsQUFBUSxLQUFSLEFBQWEsUUFGM0IsQUFFbUM7O0FBRW5DLHVCQUFlLEFBQU8sUUFBUCxBQUFRLFVBQVIsQUFBa0I7QUFDakMsa0JBQVU7QUFFVixvQkFBWSxBQUFPLFFBQVAsQUFBUSxPQUFSLEFBQWU7QUFDM0Isa0JBQVUsQUFBTyxRQUFQLEFBQVEsT0FBUixBQUFlO0FBRXpCLGtCQUFVLFNBQVM7QUFFbkIsWUFBRyxZQUFILEFBQWM7QUFDVixBQUFDLGVBQUEsQUFBRSxHQUFDLEFBQU0sT0FBVixBQUFXLFlBQVgsQUFBdUI7QUFDdkIsQUFBQyxlQUFBLEFBQUUsR0FBQyxBQUFHLElBQVAsQUFBUSxRQUZaLEFBRUksQUFBZ0I7O0FBRXBCLFlBQUEsQUFBRztpQkFBSCxBQUNJO0FBbEtLO0FBTGpCOzs7O0lBQUEsQUFBK0MsQUFLM0MsQUFBYTs7OztBQUpiLEFBQUMsb0JBQUQsQUFBQztBQUNHLGFBQUEsQUFBUztBQUNULGlCQUFhLENBQUEsQUFBQyxnQkFEZCxBQUNhLEFBQWlCO0FBRDlCOzs7Ozs7Ozs7Ozs7Ozs7O0FDdkJSLElBQUEsQUFrQkE7O2VBQVcsUUFBWCxBQUFXLEFBQVE7O0FBQW5CLEFBQUM7OztBQUdLLEFBQU0sT0FBQyxBQUFPLFFBQUM7QUFBckIsTUFBQTs7Ozs7Ozs7Ozs7a0NBS2lCLEFBQUMsVUFDVjtZQUFBLEdBQUEsZUFBQSxNQUFBLEtBQUEsU0FBQSxRQUFBLEtBQUEsU0FBQTtBQUFBLGlCQUFTLEFBQUMsS0FBQSxBQUFFLEdBQUMsQUFBTSxPQUFWLEFBQVc7QUFFcEIsZUFBTyxBQUFDLEtBQUEsQUFBRSxHQUFDLEFBQU0sT0FBVixBQUFXLG9CQUFYLEFBQStCO0FBRXRDLFlBQUcsQUFBQyxLQUFBLEFBQUUsR0FBQyxBQUFNLE9BQWIsQUFBRyxBQUFXO0FBQ1YsMEJBQWdCLEFBQUksS0FBSixBQUFLLFdBRHpCLEFBQ29DO0FBRHBDLGVBQUE7QUFHSSxjQUFHLEFBQUksS0FBSixBQUFLLGNBQVIsQUFBc0I7QUFDbEIsNEJBREosQUFDb0I7QUFEcEIsaUJBQUE7QUFHSSw0QkFBZ0I7QUFDaEIsQUFBQyxpQkFBQSxBQUFFLEdBQUMsQUFBRyxJQUFQLEFBQVEsV0FKWixBQUlJLEFBQW1CO0FBUDNCOztBQVdBLGtCQUFVO0FBQ1YsaUJBQVMsQUFFVDs7QUFBQSxhQUFBLGtDQUFBOztBQUNJLHFCQUFXLEFBQU0sT0FBTixBQUFPLFVBQVAsQUFBaUIsUUFBUSxBQUFPLFFBQWhDLEFBQWlDO0FBQzVDLHFCQUFXLElBQUEsQUFBSSxNQUFNLEFBQU8sUUFBUCxBQUFRLFdBQVIsQUFBbUIsZ0JBQTdCLEFBQTZDLEFBQUUsR0FBL0MsQUFBZ0QsS0FBaEQsQUFDaUQ7QUFDNUQscUJBQVcsQUFBTyxRQUFDO0FBQ25CLHFCQUFXLElBQUEsQUFBSSxNQUFNLEFBQU8sUUFBUCxBQUFRLFdBQVIsQUFBbUIsZ0JBQTdCLEFBQTZDLEFBQUUsR0FBL0MsQUFBZ0QsS0FBaEQsQUFDaUQ7QUFDNUQsbUJBQVMsQUFBTyxRQUFQLEFBQVEsUUFBUSxBQUFPLFFBUHBDLEFBT3FDOztBQUVyQyxtQkFBVyxBQUFNLE9BQU4sQUFBTyxPQUFQLEFBQWM7QUFFekIsWUFBRyxZQUFILEFBQWM7QUFDVixBQUFDLGVBQUEsQUFBRSxHQUFDLEFBQU0sT0FBVixBQUFXLFlBQVgsQUFBdUI7QUFDdkIsQUFBQyxlQUFBLEFBQUUsR0FBQyxBQUFHLElBQVAsQUFBUSxRQUZaLEFBRUksQUFBZ0I7O0FBRXBCLFlBQUEsQUFBRztpQkFBSCxBQUNJO0FBbkNLO0FBTGpCOzs7O0lBQUEsQUFBaUQsQUFLN0MsQUFBYTs7OztBQUpiLEFBQUMsc0JBQUQsQUFBQztBQUNHLGFBQUEsQUFBUztBQUNULGlCQUFhLENBQUEsQUFBQyxnQkFEZCxBQUNhLEFBQWlCO0FBRDlCOzs7Ozs7Ozs7Ozs7Ozs7O0FDdkJSLElBQUEsQUFrQkE7O2VBQVcsUUFBWCxBQUFXLEFBQVE7O0FBQW5CLEFBQUM7OztBQUdLLEFBQU0sT0FBQyxBQUFPLFFBQUM7QUFBckIsTUFBQTs7Ozs7Ozs7Ozs7Z0NBS2UsQUFBQyxLQUdSO1lBQUEsR0FBQSxPQUFBLFNBQUEsUUFBQTs7QUFBQSxhQUFLO0FBQ0wsY0FBTSxBQUFHLElBQUgsQUFBSSxRQUFKLEFBQVksSUFEbEIsQUFDTSxBQUFnQjs7QUFJdEIsYUFBSztBQUNMLGNBQU0sQUFBRyxJQUFILEFBQUksUUFBSixBQUFZLElBQVosQUFBZ0I7QUFFdEIsYUFBSztBQUNMLGNBQU0sQUFBRyxJQUFILEFBQUksUUFBSixBQUFZLElBQVosQUFBZ0I7QUFFdEIsYUFBSztBQUNMLGNBQU0sQUFBRyxJQUFILEFBQUksUUFBSixBQUFZLElBQVosQUFBZ0I7QUFFdEIsYUFBSztBQUNMLGNBQU0sQUFBRyxJQUFILEFBQUksUUFBSixBQUFZLElBQVosQUFBZ0I7QUFFdEIsYUFBSztBQUNMLGNBQU0sQUFBRyxJQUFILEFBQUksUUFBSixBQUFZLElBQVosQUFBZ0I7QUFFdEIsYUFBSztBQUNMLGNBQU0sQUFBRyxJQUFILEFBQUksUUFBSixBQUFZLElBQVosQUFBZ0I7QUFFdEIsYUFBSztBQUVMLFlBQUcsQUFBRSxHQUFGLEFBQUcsS0FBTixBQUFHLEFBQVE7QUFDUCxBQUFDLGVBQUEsQUFBRSxHQUFDLEFBQUcsSUFBUCxBQUFRLFdBQVcsNkNBRHZCLEFBQ0ksQUFDb0M7QUEzQnhDOztBQStCQSxhQUFLO0FBQ0wsY0FBTSxBQUFHLElBQUgsQUFBSSxRQUFKLEFBQVksSUFBWixBQUFnQjtBQUV0QixhQUFLO0FBQ0wsY0FBTSxBQUFHLElBQUgsQUFBSSxRQUFKLEFBQVksSUFBWixBQUFnQjtBQUV0QixhQUFLO0FBQ0wsY0FBTSxBQUFHLElBQUgsQUFBSSxRQUFKLEFBQVksSUFBWixBQUFnQjtBQUV0QixhQUFLO0FBRUwsWUFBRyxBQUFFLEdBQUYsQUFBRyxLQUFOLEFBQUcsQUFBUTtBQUNQLEFBQUMsZUFBQSxBQUFFLEdBQUMsQUFBRyxJQUFQLEFBQVEsV0FBVyw2Q0FEdkIsQUFDSSxBQUM0QztBQTVDaEQ7O0FBZ0RBLGFBQUs7QUFDTCxrQkFBVTtBQUNWLGlCQUFTLEFBRVQ7ZUFBQSxBQUFNO0FBQ0Ysa0JBQVEsQUFBRSxHQUFGLEFBQUcsS0FBSCxBQUFRO0FBRWhCLGNBQUEsQUFBRztBQUVDLGdCQUFHLEFBQU0sTUFBTixBQUFNLE9BQU0sQUFBTSxNQUFyQixBQUFxQjtBQUNqQixrQkFBSSxBQUFNLE1BQUEsQUFBRSxHQUFDO0FBQ2IseUJBQVcsQUFBRyxJQUFILEFBQUksVUFBSixBQUFjLFFBQVEsQUFBRSxHQUFGLEFBQUcsWUFBekIsQUFBcUMsS0FBckMsQUFDcUIsV0FBVyxBQUFNLE1BRHRDLEFBQ3NDLEtBQUs7QUFFdEQsdUJBQVMsQUFBRSxHQUxmLEFBS2dCO0FBUHBCO0FBQUEsaUJBQUEsQUFTSTtBQVRKO0FBSEo7O0FBY0EsbUJBQVcsQUFBRyxJQUFILEFBQUksT0FBSixBQUFXO0FBQ3RCLGNBQU07QUFFTixhQUFLO0FBQ0wsY0FBTSxBQUFHLElBQUgsQUFBSSxRQUFKLEFBQVksSUFBWixBQUFnQjtBQUV0QixhQUFLO0FBQ0wsY0FBTSxBQUFHLElBQUgsQUFBSSxRQUFKLEFBQVksSUFBWixBQUFnQjtBQUV0QixhQUFLO0FBRUwsWUFBRyxBQUFFLEdBQUYsQUFBRyxLQUFOLEFBQUcsQUFBUTtBQUNQLEFBQUMsZUFBQSxBQUFFLEdBQUMsQUFBRyxJQUFQLEFBQVEsV0FBVyw2Q0FEdkIsQUFDSSxBQUNnQztBQS9FcEM7O0FBbUZBLGFBQUs7QUFDTCxrQkFBVTtBQUNWLGlCQUFTLEFBRVQ7ZUFBQSxBQUFNO0FBQ0Ysa0JBQVEsQUFBRSxHQUFGLEFBQUcsS0FBSCxBQUFRO0FBRWhCLGNBQUEsQUFBRztBQUVDLGdCQUFHLEFBQU0sTUFBTixBQUFNLE9BQU0sQUFBTSxNQUFyQixBQUFxQjtBQUNqQixrQkFBSSxBQUFNLE1BQUEsQUFBRSxHQUFDO0FBQ2IseUJBQVcsQUFBRyxJQUFILEFBQUksVUFBSixBQUFjLFFBQVEsQUFBRSxHQUFGLEFBQUcsWUFBekIsQUFBcUMsS0FBckMsQUFDcUIsV0FBVyxBQUFNLE1BRHRDLEFBQ3NDLEtBQUs7QUFFdEQsdUJBQVMsQUFBRSxHQUxmLEFBS2dCO0FBUHBCO0FBQUEsaUJBQUEsQUFTSTtBQVRKO0FBSEo7O0FBY0EsbUJBQVcsQUFBRyxJQUFILEFBQUksT0FBSixBQUFXO0FBQ3RCLGNBQU07QUFFTixhQUFLO0FBQ0wsY0FBTSxBQUFHLElBQUgsQUFBSSxRQUFKLEFBQVksSUFBWixBQUFnQjtBQUV0QixhQUFLO0FBQ0wsY0FBTSxBQUFHLElBQUgsQUFBSSxRQUFKLEFBQVksSUFBWixBQUFnQjtBQUV0QixhQUFLO0FBRUwsWUFBRyxBQUFFLEdBQUYsQUFBRyxLQUFOLEFBQUcsQUFBUTtBQUNQLEFBQUMsZUFBQSxBQUFFLEdBQUMsQUFBRyxJQUFQLEFBQVEsV0FEWixBQUNJLEFBQW1CO0FBakh2Qjs7QUF1SEEsYUFBSztBQUNMLGtCQUFVO0FBQ1YsaUJBQVMsQUFFVDtlQUFBLEFBQU07QUFDRixrQkFBUSxBQUFFLEdBQUYsQUFBRyxLQUFILEFBQVE7QUFFaEIsY0FBQSxBQUFHO0FBRUMsZ0JBQUcsQUFBTSxNQUFOLEFBQU0sT0FBTSxBQUFNLE1BQXJCLEFBQXFCO0FBQ2pCLGtCQUFJLEFBQU0sTUFBQSxBQUFFLEdBQUM7QUFDYix5QkFBVyxBQUFHLElBQUgsQUFBSSxVQUFKLEFBQWMsUUFBUSxBQUFFLEdBQUYsQUFBRyxZQUF6QixBQUFxQyxLQUFyQyxBQUNxQixXQUFXLEFBQU0sTUFEdEMsQUFDc0MsS0FBSztBQUV0RCx1QkFBUyxBQUFFLEdBTGYsQUFLZ0I7QUFQcEI7QUFBQSxpQkFBQSxBQVNJO0FBVEo7QUFISjs7QUFjQSxtQkFBVyxBQUFHLElBQUgsQUFBSSxPQUFKLEFBQVc7QUFDdEIsY0FBTTtBQUVOLGFBQUs7QUFDTCxjQUFNLEFBQUcsSUFBSCxBQUFJLFFBQUosQUFBWSxJQUFaLEFBQWdCO0FBRXRCLGFBQUs7QUFDTCxjQUFNLEFBQUcsSUFBSCxBQUFJLFFBQUosQUFBWSxJQUFaLEFBQWdCO0FBRXRCLGFBQUs7QUFFTCxZQUFHLEFBQUUsR0FBRixBQUFHLEtBQU4sQUFBRyxBQUFRO0FBQ1AsQUFBQyxlQUFBLEFBQUUsR0FBQyxBQUFHLElBQVAsQUFBUSxXQUFXLDZDQUR2QixBQUNJLEFBQzRCO0FBRWhDO2VBM0pPLEFBMkpBO0FBRVgsQUFBYTs7O2tDQUFBLEFBQUMsVUFDVjtZQUFBLFNBQUE7QUFBQSxpQkFBUyxBQUFDLEtBQUEsQUFBRSxHQUFDLEFBQU0sT0FBVixBQUFXO0FBQ3BCLGtCQUFVLEFBQUMsS0FBRCxBQUFDLFVBQUQsQUFBVztBQUVyQixZQUFHLFlBQUgsQUFBYztBQUNWLEFBQUMsZUFBQSxBQUFFLEdBQUMsQUFBTSxPQUFWLEFBQVcsWUFBWCxBQUF1QjtBQUN2QixBQUFDLGVBQUEsQUFBRSxHQUFDLEFBQUcsSUFBUCxBQUFRLFFBRlosQUFFSSxBQUFnQjtBQUZwQixlQUFBO0FBSUksQUFBQyxlQUFBLEFBQUUsR0FBQyxBQUFHLElBQVAsQUFBUSxRQUpaLEFBSUksQUFBZ0I7O0FBRXBCLFlBQUEsQUFBRztpQkFBSCxBQUNJO0FBWEs7QUFsS2pCOzs7O0lBQUEsQUFBOEMsQUFLMUMsQUFBVzs7OztBQUpYLEFBQUMsbUJBQUQsQUFBQztBQUNHLGFBQUEsQUFBUztBQUNULGlCQUFhLENBQUEsQUFBQyxnQkFEZCxBQUNhLEFBQWlCO0FBRDlCOzs7RUF2QlI7Ozs7Ozs7Ozs7Ozs7OztBQ0FBLElBQUEsS0FBQSxBQWtCQTs7ZUFBVyxRQUFYLEFBQVcsQUFBUTs7QUFBbkIsQUFBQzs7O0FBRUQsTUFBTSxRQUFBLEFBQVE7O0FBR1IsQUFBTSxPQUFDLEFBQU8sUUFBQztBQUFyQixNQUFBOzs7Ozs7Ozs7OztzQ0FPUTtZQUFBLFlBQUEsR0FBQSxVQUFBLEtBQUEsSUFBQSxRQUFBLE1BQUEsV0FBQTtBQUFBLEFBQUcsWUFBSCxBQUFJLGdCQUFKLEFBQW9CO0FBR3BCLHFCQUFhLEVBQUEsQUFBRTtBQUNmLGFBQUssQUFBVSxXQUFWLEFBQVcsS0FBWCxBQUFnQixBQUFLLE1BQXJCLEFBQXNCO0FBQzNCLGlCQUFTLEFBQUUsR0FBRixBQUFHLFNBQUgsQUFBWTtBQUVyQixhQUFBLHFDQUFBOztBQUNJLGlCQUFPLEVBQUEsQUFBRSxBQUFHLElBQUwsQUFBTSxLQUFOLEFBQVcsQUFBeUIsMEJBQXBDLEFBQXFDLEFBQzVDOztzQ0FBd0IsQUFBQyxLQUFBLEFBQUUsR0FBQyxBQUFRLFNBQVosQUFBYSxlQUFlLEFBQUssS0FBQSxBQUFFLEdBQW5DLEFBQW9DOzs7O0FBQTVELEFBQUM7QUFBRCxBQUFZOztBQUNaLGNBQUcsYUFBWSxBQUFDLEtBQUEsQUFBSSxLQUFwQixBQUFxQjtBQUNqQixBQUFDLGlCQUFELEFBQUMsWUFBRCxBQUFhLFlBQWIsQUFBeUIsSUFEN0IsQUFDSSxBQUE2QjtBQUpyQzs7ZUFNQSxBQUFDLEtBQUEsQUFBRSxHQUFDLEFBQUcsSUFBUCxBQUFRLFFBZEcsQUFjWCxBQUFnQjtBQUVwQixBQUFhOzs7a0NBQUEsQUFBQyxZQUFELEFBQWEsSUFBYixBQUFpQixVQUMxQjtZQUFBLE9BQUEsR0FBQSxXQUFBLFFBQUEsS0FBQTtBQUFBLGlCQUFTLEFBQVUsV0FBVixBQUFXLFNBQVgsQUFBb0I7QUFDN0Isb0JBQVk7QUFDWixhQUFBLHFDQUFBOztBQUNJLGNBQUcsQUFBSyxNQUFMLEFBQU0sY0FBVCxBQUFzQjtBQUNsQixpQkFBSyxFQUFBLEFBQUUsQUFBTSxPQUFSLEFBQVMsQUFBTSxPQUFmLEFBQWdCLE9BQWhCLEFBQXVCO0FBQzVCLHdCQUFZLEFBQ1o7QUFISjtBQURKOztBQU1BLFlBQUcsQ0FBSCxBQUFPO2lCQUNILEFBQVUsV0FBVixBQUFXLE9BQ1AsRUFBQSxBQUFFLEFBQU8sUUFBVCxBQUFVLEtBRGQsQUFDSSxBQUFlLFdBQ2YsRUFBQSxBQUFFLEFBQU8sUUFBVCxBQUFVLE9BSGxCLEFBQ0ksQUFFSSxBQUFpQjtBQVpoQjtBQXRCakI7Ozs7SUFBQSxBQUE4QyxBQU0xQyxBQUFlOzs7O0FBTGYsQUFBQyxtQkFBRCxBQUFDO0FBQ0csYUFBQSxBQUFTO0FBQ1Qsa0JBREEsQUFDYztBQUNkLHNCQUZBLEFBRWtCO0FBRmxCOzs7Ozs7Ozs7Ozs7Ozs7O0FDekJSLElBQUEsQUFrQkE7O2VBQVcsUUFBWCxBQUFXLEFBQVE7O0FBQW5CLEFBQUM7OztBQUdLLEFBQU0sT0FBQyxBQUFPLFFBQUM7QUFBckIsTUFBQTs7Ozs7Ozs7Ozs7a0NBS2lCLEFBQUMsVUFDVjtZQUFBLEdBQUEsS0FBQSxTQUFBLE1BQUEsTUFBQSxNQUFBLE1BQUEsTUFBQSxNQUFBLE1BQUEsS0FBQSxLQUFBLFFBQUEsTUFBQTtBQUFBLGlCQUFTLEFBQUMsS0FBQSxBQUFFLEdBQUMsQUFBTSxPQUFWLEFBQVc7QUFDcEIsa0JBQVU7QUFFVixjQUFNO0FBQ04sY0FBTTtBQUNOLGVBQU87QUFFUCxlQUFPO0FBQ1AsZUFBTztBQUNQLGVBQU87QUFFUCxlQUFPO0FBQ1AsZUFBTztBQUNQLGVBQU87QUFFUCxrQkFBVSxBQUFPLFFBQVAsQUFBUSxRQUFSLEFBQWdCLEtBQWhCLEFBQXFCO0FBQy9CLGtCQUFVLEFBQU8sUUFBUCxBQUFRLFFBQVIsQUFBZ0IsS0FoQjFCLEFBZ0JVLEFBQXFCO0FBQy9CLGtCQUFVLEFBQU8sUUFBUCxBQUFRLFFBQVIsQUFBZ0IsTUFqQjFCLEFBaUJVLEFBQ007QUFFaEIsa0JBQVUsQUFBTyxRQUFQLEFBQVEsUUFBUixBQUFnQixNQUFoQixBQUFzQjtBQUNoQyxrQkFBVSxBQUFPLFFBQVAsQUFBUSxRQUFSLEFBQWdCLE1BckIxQixBQXFCVSxBQUFzQjtBQUNoQyxrQkFBVSxBQUFPLFFBQVAsQUFBUSxRQUFSLEFBQWdCLE1BdEIxQixBQXNCVSxBQUNNO0FBRWhCLGtCQUFVLEFBQU8sUUFBUCxBQUFRLFFBQVIsQUFBZ0IsTUFBaEIsQUFBc0I7QUFDaEMsa0JBQVUsQUFBTyxRQUFQLEFBQVEsUUFBUixBQUFnQixNQTFCMUIsQUEwQlUsQUFBc0I7QUFDaEMsa0JBQVUsQUFBTyxRQUFQLEFBQVEsUUFBUixBQUFnQixNQTNCMUIsQUEyQlUsQUFDTTtBQUVoQixZQUFHLFlBQUgsQUFBYztBQUNWLEFBQUMsZUFBQSxBQUFFLEdBQUMsQUFBTSxPQUFWLEFBQVcsWUFBWCxBQUF1QjtBQUN2QixBQUFDLGVBQUEsQUFBRSxHQUFDLEFBQUcsSUFBUCxBQUFRLFFBRlosQUFFSSxBQUFnQjs7QUFFcEIsZ0JBQVEsQ0FDSixDQUFBLEFBQUMsWUFBWSxBQUFPLFFBQVAsQUFBUSxNQURqQixBQUNKLEFBQWEsQUFBYyxZQUMzQixDQUFBLEFBQUMsYUFBYSxBQUFPLFFBQVAsQUFBUSxNQUZsQixBQUVKLEFBQWMsQUFBYyxhQUM1QixDQUFBLEFBQUMsV0FBVyxBQUFPLFFBQVAsQUFBUSxNQUhoQixBQUdKLEFBQVksQUFBYztBQUc5QixhQUFBLG9DQUFBOztBQUNJLGNBQUcsQUFBSyxLQUFSLEFBQVE7QUFDSixBQUFDLGlCQUFBLEFBQUUsR0FBQyxBQUFHLElBQVAsQUFBUSxXQUFXLEFBQUssS0FBQSxBQUFFLEdBQVAsQUFBUSxTQUFSLEFBQWlCLE1BQ2hDLEFBQUssS0FEVSxBQUNWLEtBRmIsQUFDSSxBQUNjO0FBSHRCOztBQUtBLFlBQUEsQUFBRztpQkFBSCxBQUNJO0FBL0NLO0FBTGpCOzs7O0lBQUEsQUFBa0QsQUFLOUMsQUFBYTs7OztBQUpiLEFBQUMsdUJBQUQsQUFBQztBQUNHLGFBQUEsQUFBUztBQUNULGlCQUFhLENBQUEsQUFBQyxnQkFEZCxBQUNhLEFBQWlCO0FBRDlCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN2QlIsSUFBQSxLQUFBLEFBa0JBOztlQUFXLFFBQVgsQUFBVyxBQUFROztBQUFuQixBQUFDOzs7QUFFRCxNQUFNLFFBQUEsQUFBUTs7QUFHUixBQUFNLE9BQUMsQUFBTyxRQUFDO0FBQXJCLE1BQUE7Ozs7Ozs7Ozs7OzJDQU9RO1lBQUEsY0FBQSxVQUFBLElBQUEsS0FBQSxHQUFBLEdBQUEsVUFBQSxLQUFBLE1BQUEsTUFBQSxXQUFBO0FBQUEsY0FBTSxFQUFBLEFBQUU7QUFFUixZQUFHLEFBQUcsSUFBSCxBQUFJLEdBQUosQUFBTyxBQUFFLEdBQVQsQUFBVSxBQUFPLE9BQUEsQUFBRSxHQUFDLEFBQVMsVUFBN0IsQUFBOEIsa0JBQWpDLEFBQWtEO2lCQUM5QyxBQUFDLEtBQUEsQUFBRSxHQUFDLEFBQUcsSUFBUCxBQUFRLFNBRFosQUFDSSxBQUFpQjtBQURyQixlQUFBO0FBS0ksQUFBRyxjQUFILEFBQUksZ0JBQUosQUFBb0I7QUFJcEIsZUFBQSxrQ0FBQTs7QUFDSSx1QkFBVyxFQUFBLEFBQUUsQUFBRyxJQUFMLEFBQU0sQUFDakI7O0FBQUEsaUJBQUEsb0NBQUE7O0FBQ0kscUJBQU8sRUFBQSxBQUFFLEFBQWEsY0FBZixBQUFnQixLQUFoQixBQUFxQixBQUNvQiwwQkFEekMsQUFDMEM7QUFDakQsa0JBQUcsQUFBSyxLQUFSLEFBQVE7QUFDSiw0Q0FBd0IsQUFBQyxLQUFBLEFBQUUsR0FBQyxBQUFRLFNBQVosQUFBYSxlQUNHLEFBQUssS0FBQSxBQUFFLEdBRHZCLEFBQ3dCOzs7O0FBRGhELEFBQUM7QUFBRCxBQUFZOztBQUVaLG9CQUFHLGFBQVksQUFBQyxLQUFBLEFBQUksS0FBcEIsQUFBcUI7QUFDakIsQUFBQyx1QkFBRCxBQUFDLFlBQUQsQUFBYSxVQUFiLEFBQXVCLGNBRDNCLEFBQ0ksQUFBcUM7QUFKN0M7QUFISjtBQUZKOztpQkFXQSxBQUFDLEtBQUEsQUFBRSxHQUFDLEFBQUcsSUFBUCxBQUFRLFFBcEJaLEFBb0JJLEFBQWdCO0FBdkJKO0FBeUJwQixBQUFhOzs7a0NBQUEsQUFBQyxVQUFELEFBQVcsY0FBWCxBQUF5QixVQUNsQztZQUFBLE9BQUEsR0FBQSxHQUFBLFdBQUEsUUFBQTtBQUFBLGlCQUFTLEFBQVEsU0FBUixBQUFTLFNBQVQsQUFBa0I7QUFDM0Isb0JBQVk7QUFDWixhQUFBLCtDQUFBOztBQUNJLGNBQUcsQUFBSyxNQUFMLEFBQU0sY0FBVCxBQUFzQjtBQUNsQixnQkFBRyxJQUFBLEFBQUksSUFBSSxBQUFNLE9BQWpCLEFBQWtCO0FBQ2QsQUFBTSxxQkFBTixBQUFPLEdBQUcsSUFBVixBQUFjLEFBQUUsR0FBaEIsQUFBaUIsT0FEckIsQUFDSSxBQUF3QjtBQUQ1QixtQkFBQTtBQUdJLEFBQVEsdUJBQVIsQUFBUyxPQUhiLEFBR0ksQUFBZ0I7O0FBQ3BCLHdCQUFZLEFBQ1o7QUFOSjtBQURKOztBQVNBLFlBQUcsQ0FBSCxBQUFPO2lCQUNILEFBQVEsU0FBUixBQUFTLE9BQ0wsRUFBQSxBQUFFLEFBQU8sUUFBVCxBQUFVLEtBRGQsQUFDSSxBQUFlLFdBRnZCLEFBQ0ksQUFFSTtBQWZDO0FBL0JqQjs7OztJQUFBLEFBQThDLEFBTTFDLEFBQW9COzs7O0FBTHBCLEFBQUMsbUJBQUQsQUFBQztBQUNHLGFBQUEsQUFBUztBQUNULGtCQURBLEFBQ2M7QUFDZCxzQkFGQSxBQUVrQjtBQUZsQjs7Ozs7Ozs7Ozs7Ozs7OztBQ3pCUixJQUFBO0lBQUE7SUFBQTtJQUFBO0lBQUE7Ozs7QUFrQkE7O2VBQVcsUUFBWCxBQUFXLEFBQVE7O0FBQW5CLEFBQUM7OztBQUVELE1BQU0sUUFBQSxBQUFROztBQUNkLE9BQU8sUUFBQSxBQUFROztNQUdULEFBQU0sT0FBQyxBQUFPLFFBQUM7QUFBckIsTUFBQTs7Ozs7Ozs7QUErQkksWUFBQSxzQkFBQSxNQUFBO0FBU0EsWUFBQSxZQUFBLE1BQUE7QUEwQkEsWUFBQSxVQUFBLE1BQUE7O0FBM0RBLEFBQVE7Ozs7K0JBQ0o7WUFBQSxTQUFBO0FBQUEsQUFBRyxZQUFILEFBQUksZ0JBQUosQUFBb0I7QUFHcEIsa0JBQVUsQUFBQyxLQUFBLEFBQUksS0FBQztBQUVoQixlQUFPLEFBQVEsU0FBUixBQUFTLGNBQVQsQUFBdUI7QUFDOUIsQUFBSSxhQUFKLEFBQUssS0FBSztBQUNWLEFBQUksYUFBSixBQUFLLE9BQU8sZ0JBQWdCO0FBQzVCLEFBQUksYUFBSixBQUFLLFlBQVksQUFFakI7ZUFYSSxBQVdHO0FBRVgsQUFBVzs7O2dDQUFBLEFBQUMsVUFDUjtZQUFBLFNBQUE7QUFBQSxrQkFBVSxBQUFDLEtBQUEsQUFBSSxLQUFDO0FBQ2hCLGtCQUFVLEFBQUMsS0FBQSxBQUFJLEtBQUM7QUFFaEIsQUFBQyxhQUFBLEFBQUUsR0FBQyxBQUFHLElBQVAsQUFBUSxRQUFRLHVCQUNJLEFBQUMsS0FBQSxBQUFFLEdBQUMsQUFBRyxJQUFQLEFBQVEsZUFBUixBQUF1QixTQUQzQixBQUNJLEFBQWdDLFdBRHBELEFBQytEO2VBRS9ELEFBQUMsS0FBQSxBQUFFLEdBQUMsQUFBSSxLQUFSLEFBQVMsZ0JBQ1csQUFBQyxLQURyQixBQUNxQixxQkFDRCxDQUFBLEFBQUMsU0FBRCxBQUFVLFNBVHZCLEFBT1AsQUFFb0IsQUFBbUI7QUFFM0MsQUFBcUI7OzswQ0FBQSxBQUFDLFNBQUQsQUFBVSxNQUMzQjtZQUFBLFNBQUEsVUFBQTs7QUFBQSxrQkFBVSxBQUFLLEtBQUE7QUFDZixrQkFBVSxBQUFLLEtBQUE7QUFDZixtQkFBVyxBQUFLLEtBQUE7ZUFFaEIsQUFBQyxLQUFBLEFBQUUsR0FBQyxBQUFFLEdBQU4sQUFBTyxjQUFQLEFBQXFCLFNBQ0QsQUFBQyxLQURyQixBQUNxQixXQUNELENBQUEsQUFBQyxTQUFELEFBQVUsU0FQYixBQUtqQixBQUVvQixBQUFtQjtBQUUzQyxBQUFXOzs7Z0NBQUEsQUFBQyxTQUFELEFBQVUsUUFBVixBQUFrQixXQUFsQixBQUE2QixXQUE3QixBQUF3QyxNQUMvQztZQUFBLFVBQUEsU0FBQSxTQUFBLFVBQUEsU0FBQTs7QUFBQSxrQkFBVSxBQUFLLEtBQUE7QUFDZixrQkFBVSxBQUFLLEtBQUE7QUFDZixtQkFBVyxBQUFLLEtBQUE7QUFFaEIsZ0JBQVEsQUFBSSxLQUFKLEFBQUssZ0JBQUwsQUFBcUIsTUFBckIsQUFBMkI7QUFDbkMsbUJBQVcsQUFBTyxRQUFQLEFBQVEsT0FBUixBQUFlLEdBQWYsQUFBa0IsTUFBbEIsQUFBd0IsV0FBVyxBQUFPLFFBQVAsQUFBUSxPQUFSLEFBQWUsSUFBZixBQUFtQjtBQUVqRSxrQkFBVSxBQUFDLEtBQUEsQUFBRSxHQUFDLEFBQU0sT0FBVixBQUFXLFVBQVgsQUFBcUIsUUFBckIsQUFBNkIsd0JBQ3ZCLENBQUMsTUFBTSxBQUFRLFNBQWQsQUFBZSxPQUFmLEFBQXNCLE1BQXRCLEFBQTRCLFFBQTdCLEFBQXFDLEtBRDNDLEFBQ00sQUFBMEM7b0JBRXpELEFBQUUsR0FBQyxBQUFFLEdBQU4sQUFBTztBQUVDLGtCQURKLEFBQ1k7QUFDUixlQUZKLEFBRVM7QUFDTCxpQkFISixBQUdXO0FBQ1AsbUJBSkosQUFJYTtBQUNULGdCQUxKLEFBS1U7QUFDTix5QkFOSixBQU1tQjtBQUNmLGlCQVJSLEFBQ0ksQUFPVztBQVBYLFNBREosQUFBQyxFQVVHLEFBQUMsS0FWTCxBQVVLLFNBQ0QsQ0FBQSxBQUFDLFNBWEwsQUFXSSxBQUFVLFdBdEJQLEFBV1AsQUFZSTtBQUdSLEFBQVM7Ozs4QkFBQSxBQUFDLEtBQUQsQUFBTSxNQUNYO1lBQUEsU0FBQTs7QUFBQSxrQkFBVSxBQUFLLEtBQUE7QUFDZixtQkFBVyxBQUFLLEtBQUE7QUFFaEIsWUFBRyxBQUFHLElBQUgsQUFBSSxRQUFTLEFBQUcsSUFBQyxBQUFJLEtBQVIsQUFBUyxXQUF6QixBQUFtQztBQUMvQixBQUFDLGVBQUEsQUFBRSxHQUFDLEFBQUcsSUFBUCxBQUFRLFFBQVEsZ0NBQ1EsQUFBQyxLQUFBLEFBQUUsR0FBQyxBQUFHLElBQVAsQUFBUSxlQUFSLEFBQXVCLFNBRC9DLEFBQ3dCLEFBQWdDO0FBQ3hELGNBQUEsQUFBRzttQkFBSCxBQUNJO0FBSlI7QUFBQSxlQUFBO2lCQU1JLEFBQUMsS0FBQSxBQUFFLEdBQUMsQUFBRyxJQUFQLEFBQVEsU0FBUyxzQ0FDVCxBQUFJLElBQUEsQUFBUyxTQURKLEFBQ0ksVUFESixBQUNjLE9BQU8sQUFBSSxJQUFBLEFBQVMsU0FEbEMsQUFDa0MsVUFQdkQsQUFNSSxBQUM2RDtBQVg1RDtBQWxFYjs7OztJQUFBLEFBQThDOzs7O0FBQzFDLEFBQUMsbUJBQUQsQUFBQztBQUNHLGFBQUEsQUFBUztBQUNULGVBQVcsQ0FEWCxBQUNXLEFBQUM7QUFDWixVQUZBLEFBRU07QUFDTixrQkFIQSxBQUdjO0FBSGQ7Ozs7Ozs7Ozs7Ozs7Ozs7QUMxQlIsSUFBQTtJQUFBO0lBQUE7Ozs7QUFrQkE7O2VBQVcsUUFBWCxBQUFXLEFBQVE7O0FBQW5CLEFBQUM7OztNQUdLLEFBQU0sT0FBQyxBQUFPLFFBQUM7dUJBQXJCOztNQUFBOzs7Ozs7OztBQXVESSxZQUFBLFlBQUEsTUFBQTtBQTJCQSxZQUFBLGVBQUEsTUFBQTtBQW9DQSxZQUFBLG9CQUFBLE1BQUE7QUFtQ0EsWUFBQSxhQUFBLE1BQUE7QUErQ0EsWUFBQSxZQUFBLE1BQUE7O0FBeEtBLEFBQWM7Ozs7bUNBQUEsQUFBQztlQUNYLEFBQUMsS0FBRCxBQUFDLGFBQWEsQ0FBZCxBQUFlLEdBREwsQUFDVixBQUFrQjtBQUV0QixBQUFjOzs7bUNBQUEsQUFBQyxRQUFELEFBQVMsVUFDbkI7WUFBQSxlQUFBLGVBQUEsTUFBQSxPQUFBLFlBQUE7QUFBQTtBQUNBLGdCQUFRLEFBQUMsS0FBQSxBQUFJLEtBQUMsQUFBTSxNQUFBO0FBQ3BCLFlBQUEsQUFBRztBQUNDLGlCQUFPLEFBQUssTUFBQztBQUNiLHVCQUFhLEFBQUssTUFBQztBQUNuQiwwQkFBZ0IsQUFBSyxNQUFDO0FBQ3RCLDBCQUFnQixBQUFLLE1BQUM7QUFDdEIsb0JBQVUsQUFBQyxLQUFBLEFBQUksS0FBQztBQUVoQixBQUFDLGVBQUEsQUFBRSxHQUFDLEFBQUcsSUFBUCxBQUFRLFFBQVEsYUFBYSxBQUFDLEtBQUEsQUFBRSxHQUFDLEFBQUcsSUFBUCxBQUFRLGVBQVIsQUFBdUIsTUFBcEMsQUFBYSxBQUE2QixRQUExRCxBQUM0RDtpQkFFNUQsQUFBQyxLQUFBLEFBQUUsR0FBQyxBQUFFLEdBQU4sQUFBTyxjQUFQLEFBQXFCLE1BQ0QsQUFBQyxLQURyQixBQUNxQixXQUNELENBQUEsQUFBQyxZQUFELEFBQWEsZUFBYixBQUE0QixlQUE1QixBQUNDLFNBREQsQUFDVSxVQWJsQyxBQVVJLEFBRW9CLEFBQ29CO0FBYjVDLGVBY0ssSUFBQSxBQUFHO2lCQUFILEFBQ0Q7QUFsQk07QUFvQmQsQUFBVzs7O2dDQUFBLEFBQUMsT0FBRCxBQUFRLFFBQVIsQUFBZ0IsV0FBaEIsQUFBMkIsV0FBM0IsQUFBc0MsTUFDN0M7WUFBQSxVQUFBLE1BQUEsU0FBQSxlQUFBLGVBQUEsUUFBQSxZQUFBLFdBQUEsU0FBQSxPQUFBLFNBQUEsT0FBQTs7QUFBQSxxQkFBYSxBQUFLLEtBQUE7QUFDbEIsd0JBQWdCLEFBQUssS0FBQTtBQUNyQix3QkFBZ0IsQUFBSyxLQUFBO0FBQ3JCLGtCQUFVLEFBQUssS0FBQTtBQUNmLG1CQUFXLEFBQUssS0FBQTtBQUNoQixpQkFBUyxBQUFLLEtBQUE7QUFFZCxvQkFBWSxBQUFNLE9BQU4sQUFBTyxRQUFQLEFBQWU7QUFDM0Isa0JBQVUsQUFBTSxPQUFOLEFBQU8sUUFBUCxBQUFlO0FBRXpCLFlBQUcsWUFBWSxDQUFaLEFBQWEsS0FBTSxVQUFVLENBQWhDLEFBQWlDO0FBQzdCLHVCQUFhLEFBQVMsVUFBQztBQUN2QixpQkFBTyxJQUFBLEFBQUk7QUFDWCxvQkFBVSxBQUFJLEtBQUosQUFBSyxNQUFNLEFBQUksS0FBSixBQUFLLFFBQWhCLEFBQXdCO0FBQ2xDLGtCQUFRLFVBQVUsUUFBUTtBQUMxQjtBQUNJLG9CQUFBLEFBQVE7QUFDUixzQkFEQSxBQUNVO0FBRFY7QUFHSix1QkFBYSxBQUFNLE9BQU4sQUFBTyxVQUFQLEFBQWlCLFdBQWpCLEFBQTRCLEFBQVEsU0FBcEMsQUFBcUMsTUFBckMsQUFBMkM7aUJBQ3hELEFBQUMsS0FBRCxBQUFDLGFBQUQsQUFBYyxZQUFZLENBQTFCLEFBQTJCLEdBQTNCLEFBQThCLFNBQTlCLEFBQXVDLE9BQXZDLEFBQThDLE9BQTlDLEFBQXFELE9BQXJELEFBQTRELFFBQTVELEFBQ2dCLFdBRGhCLEFBQzJCLFNBRDNCLEFBQ29DLFdBRHBDLEFBQytDLFdBRC9DLEFBRWdCLGVBRmhCLEFBRStCLGVBRi9CLEFBRThDLFNBRjlDLEFBRXVELFVBWjNELEFBVUksQUFFaUU7QUFackUsZUFBQTtpQkFjSSxBQUFDLEtBQUEsQUFBRSxHQUFDLEFBQUcsSUFBUCxBQUFRLFNBZFosQUFjSSxBQUFpQjtBQXpCZDtBQTJCWCxBQUFjOzs7bUNBQUEsQUFBQyxZQUFELEFBQWEsT0FBYixBQUFvQixTQUFwQixBQUE2QixPQUE3QixBQUFvQyxPQUFwQyxBQUNFLE9BREYsQUFDUyxRQURULEFBQ2lCLFdBRGpCLEFBQzRCLFNBRDVCLEFBQ3FDLFdBRHJDLEFBQ2dELFdBRGhELEFBRUUsZUFGRixBQUVpQixlQUZqQixBQUVnQyxTQUZoQyxBQUV5QyxVQUZ6QyxBQUVtRCxRQUM3RDtZQUFBLE9BQUEsUUFBQTs7QUFBQTtBQUVBLFlBQUcsUUFBUSxBQUFVLFdBQXJCLEFBQXNCO0FBQ2xCLHVCQUFhLEFBQVcsV0FBQTtBQUN4QixrQkFBUSxBQUFNLE9BQU4sQUFBTyxLQUFQLEFBQVk7QUFFcEIsY0FBQSxBQUFHO0FBQ0MscUJBQVMsQUFBTSxNQUFBLEFBQUUsR0FBUixBQUFTLE9BQVQsQUFBZ0IsQUFBRSxHQUFsQixBQUFtQixnQkFBZ0IsQUFBTSxNQUFBLEFBQUUsR0FBUixBQUFTLE9BQVQsQUFBZ0I7QUFFNUQsZ0JBQUcsQUFBTSxNQUFULEFBQVM7QUFDTCx3QkFBVSxNQUFNLEFBQU0sTUFBQSxBQUFFLEdBQVIsQUFBUyxPQUFULEFBQWdCLEFBQUUsR0FBeEIsQUFBTSxBQUFtQixnQkFDSyxBQUFNLE1BQUEsQUFBRSxHQUFSLEFBQVMsT0FGckQsQUFFNEMsQUFBZ0I7O0FBRTVELEFBQUMsaUJBQUEsQUFBRSxHQUFDLEFBQUcsSUFBUCxBQUFRLFFBQVEsY0FBQSxBQUFjLFNBQTlCLEFBQXVDO21CQUV2QyxBQUFDLEtBQUEsQUFBRSxHQUFDLEFBQUUsR0FBTixBQUFPLGdCQUFQLEFBQXVCLFFBQXZCLEFBQStCLFNBQS9CLEFBQXdDLE9BQ3BDLEFBQUMsS0FETCxBQUNLLG1CQUNELENBQUEsQUFBQyxZQUFELEFBQWEsT0FBYixBQUFvQixTQUFwQixBQUE2QixPQUE3QixBQUFvQyxPQUFwQyxBQUEyQyxPQUEzQyxBQUFrRCxRQUFsRCxBQUNDLFdBREQsQUFDWSxTQURaLEFBQ3FCLFdBRHJCLEFBQ2dDLFdBRGhDLEFBQzJDLGVBRDNDLEFBRUMsZUFGRCxBQUVnQixTQUZoQixBQUV5QixVQWJqQyxBQVNJLEFBRUksQUFFbUM7QUFiM0MscUJBZVEsZUFBQSxBQUFjLE1BQ0UsQUFBVSxXQUFWLEFBQVcsUUFBWCxBQUFtQixtQkFEdEMsQUFDd0Q7bUJBQ3pELEFBQUMsS0FBQSxBQUFFLEdBQUMsQUFBRyxJQUFQLEFBQVEsU0FBUywrQ0FGaEIsQUFFRCxBQUNnRDtBQUgvQyxXQUFBLE1BQUE7bUJBS0QsQUFBQyxLQUFELEFBQUMsYUFBRCxBQUFjLFlBQWQsQUFBMEIsT0FBMUIsQUFBaUMsU0FBakMsQUFBMEMsT0FBMUMsQUFBaUQsT0FBakQsQUFBd0QsT0FBeEQsQUFDWSxRQURaLEFBQ29CLFdBRHBCLEFBQytCLFNBRC9CLEFBQ3dDLFdBRHhDLEFBQ21ELFdBRG5ELEFBRVksZUFGWixBQUUyQixlQUYzQixBQUUwQyxTQUYxQyxBQUVtRCxVQVBsRCxBQUtELEFBRTZEO0FBMUJyRTtBQUFBLGVBQUE7aUJBNEJJLEFBQUMsS0FBRCxBQUFDLFdBQUQsQUFBWSxPQUFaLEFBQW1CLE9BQW5CLEFBQTBCLFFBQTFCLEFBQWtDLFdBQWxDLEFBQTZDLFNBQTdDLEFBQXNELFdBQXRELEFBQ29CLFdBRHBCLEFBQytCLGVBRC9CLEFBQzhDLFNBRDlDLEFBQ3VELFVBN0IzRCxBQTRCSSxBQUNpRTtBQWxDM0Q7QUFvQ2QsQUFBbUI7Ozt3Q0FBQSxBQUFDLFNBQUQsQUFBVSxNQUN6QjtZQUFBLFVBQUEsT0FBQSxXQUFBLFNBQUEsZUFBQSxlQUFBLE9BQUEsUUFBQSxRQUFBLFdBQUEsU0FBQSxXQUFBLE9BQUEsT0FBQSxTQUFBLE9BQUE7O0FBQUEscUJBQWEsQUFBSyxLQUFBO0FBQ2xCLGdCQUFRLEFBQUssS0FBQTtBQUNiLGtCQUFVLEFBQUssS0FBQTtBQUNmLGdCQUFRLEFBQUssS0FBQTtBQUNiLGdCQUFRLEFBQUssS0FBQTtBQUNiLGdCQUFRLEFBQUssS0FBQTtBQUNiLGlCQUFTLEFBQUssS0FBQTtBQUNkLG9CQUFZLEFBQUssS0FBQTtBQUNqQixrQkFBVSxBQUFLLEtBQUE7QUFDZixvQkFBWSxBQUFLLEtBQUE7QUFDakIsb0JBQVksQUFBSyxLQUFBO0FBQ2pCLHdCQUFnQixBQUFLLEtBQUE7QUFDckIsd0JBQWdCLEFBQUssS0FBQTtBQUNyQixrQkFBVSxBQUFLLEtBQUE7QUFDZixtQkFBVyxBQUFLLEtBQUE7QUFDaEIsaUJBQVMsQUFBSyxLQUFBO0FBRWQsZ0JBQVEsQUFBTyxRQUFDO0FBRWhCLFlBQUcsUUFBSCxBQUFXO0FBQ1AsQUFBSyxnQkFBQyxBQUFRLFNBQWQsQUFBZTtBQUNTLG9CQUFRLEFBQVcsV0FEdkIsQUFDdUI7QUFDbkIscUJBSDVCLEFBQ0ksQUFBb0IsQUFFYTtBQUZiO0FBRHhCLGVBQUE7QUFNSSxBQUFLLGdCQUFDLEFBQU0sT0FBWixBQUFhO0FBQ1csb0JBQVEsQUFBVyxXQUR6QixBQUN5QjtBQUNuQixxQkFSNUIsQUFNSSxBQUFrQixBQUVlO0FBRmY7O2VBS3RCLEFBQUMsS0FBRCxBQUFDLGFBQUQsQUFBYyxZQUFkLEFBQTBCLE9BQTFCLEFBQWlDLFNBQWpDLEFBQTBDLE9BQTFDLEFBQWlELE9BQWpELEFBQXdELE9BQXhELEFBQStELFFBQS9ELEFBQ29CLFdBRHBCLEFBQytCLFNBRC9CLEFBQ3dDLFdBRHhDLEFBQ21ELFdBRG5ELEFBRW9CLGVBRnBCLEFBRW1DLGVBRm5DLEFBRWtELFNBRmxELEFBRTJELFVBakM1QyxBQStCZixBQUVxRTtBQUV6RSxBQUFZOzs7aUNBQUEsQUFBQyxPQUFELEFBQVEsT0FBUixBQUFlLFFBQWYsQUFBdUIsV0FBdkIsQUFBa0MsU0FBbEMsQUFDSSxXQURKLEFBQ2UsV0FEZixBQUMwQixlQUQxQixBQUN5QyxTQUR6QyxBQUNrRCxVQURsRCxBQUM0RCxRQUNwRTtZQUFBLEdBQUEsR0FBQSxLQUFBLE1BQUEsU0FBQSxTQUFBLE1BQUEsTUFBQSxRQUFBOztBQUFBLGlCQUFTLGdCQUFBLEFBQUMsR0FBRCxBQUFJLEdBQUo7QUFFTCxjQUFHLEFBQUMsRUFBRCxBQUFFLFFBQVEsQUFBQyxFQUFkLEFBQWUsT0FDWDttQkFESixBQUNXO0FBRFgscUJBRVEsQUFBQyxFQUFELEFBQUUsUUFBUSxBQUFDLEVBQWQsQUFBZSxPQUNoQjttQkFBTyxDQUROLEFBQ087QUFEUCxXQUFBLE1BQUEsQUFHRDttQkFIQyxBQUdNO0FBUE47O0FBU1QsQUFBSyxjQUFDLEFBQU0sT0FBWixBQUFhLEtBQWIsQUFBa0I7QUFDbEIsQUFBSyxjQUFDLEFBQVEsU0FBZCxBQUFlLEtBQWYsQUFBb0I7QUFFcEIsa0JBQVUsQUFFVjs7QUFBQSxhQUFBLG1DQUFBOztBQUNJLHFCQUFXLEFBQUksS0FBSixBQUFLLE9BRHBCLEFBQzJCOztBQUUzQixZQUFHLEFBQUssTUFBQyxBQUFRLFNBQWQsQUFBZSxTQUFsQixBQUEyQjtBQUN2QixxQkFBVyxPQUFBLEFBQU8sZ0JBQWdCLEFBRWxDOztBQUFBLGVBQUEscUNBQUE7O0FBQ0ksdUJBQVcsQUFBSSxLQUFKLEFBQUssT0FEcEIsQUFDMkI7QUFKL0I7O0FBTUEsa0JBQVUsQUFBTSxPQUFOLEFBQU8sVUFBUCxBQUFpQixHQUFqQixBQUFvQixhQUFwQixBQUFpQyxVQUNDLEFBQU0sT0FBTixBQUFPLFVBQVAsQUFBaUI7QUFFN0QsWUFBRyxZQUFILEFBQWM7c0JBQ1QsQUFBRSxHQUFDLEFBQUUsR0FBTixBQUFPO0FBQ2lCLG9CQURMLEFBQ2E7QUFDUixpQkFGTCxBQUVVO0FBQ0wsbUJBSEwsQUFHWTtBQUNQLG1CQUpMLEFBSVk7QUFDUCxxQkFMTCxBQUtjO0FBQ1Qsa0JBTkwsQUFNVztBQUNOLDRCQVBMLEFBT3FCO0FBQ2hCLG1CQVJ4QixBQUFtQixBQVFZO0FBUlosV0FBbkIsQUFBQyxFQVVlLEFBQUMsS0FWakIsQUFVaUIsV0FDRCxDQUFBLEFBQUMsT0FBRCxBQUFRLFVBWHhCLEFBV2dCLEFBQWtCLFNBWnRDLEFBQ0ksQUFZZ0I7QUFicEIsZUFBQTtBQWVJLEFBQUMsZUFBQSxBQUFFLEdBQUMsQUFBRyxJQUFQLEFBQVEsUUFBUSxBQUFDLEtBQUEsQUFBRSxHQUFDLEFBQUcsSUFBUCxBQUFRLGVBQVIsQUFBdUIsT0FBdkIsQUFBOEIsU0FBOUMsQUFDZ0M7aUJBQ2hDLEFBQUMsS0FBRCxBQUFDLGFBQUQsQUFBYyxRQWpCbEIsQUFpQkksQUFBc0I7QUE3Q2xCO0FBK0NaLEFBQVc7OztnQ0FBQSxBQUFDLEtBQUQsQUFBTSxNQUNiO1lBQUEsVUFBQSxRQUFBOztBQUFBLGdCQUFRLEFBQUssS0FBQTtBQUNiLG1CQUFXLEFBQUssS0FBQTtBQUNoQixpQkFBUyxBQUFLLEtBQUE7QUFFZCxZQUFHLEFBQUcsSUFBSCxBQUFJLFFBQVMsQUFBRyxJQUFDLEFBQUksS0FBUixBQUFTLFdBQXpCLEFBQW1DO0FBQy9CLEFBQUMsZUFBQSxBQUFFLEdBQUMsQUFBRyxJQUFQLEFBQVEsUUFBUSxBQUFDLEtBQUEsQUFBRSxHQUFDLEFBQUcsSUFBUCxBQUFRLGVBQVIsQUFBdUIsT0FBdkIsQUFBOEIsU0FBOUMsQUFDd0M7aUJBQ3hDLEFBQUMsS0FBRCxBQUFDLGFBQUQsQUFBYyxRQUhsQixBQUdJLEFBQXNCO0FBSDFCLGVBQUE7aUJBS0ksQUFBQyxLQUFBLEFBQUUsR0FBQyxBQUFHLElBQVAsQUFBUSxTQUFTLEFBQUksSUFBQSxBQUFTLFNBQWIsQUFBYSxVQUFiLEFBQ2UsT0FBTyxBQUFJLElBQUEsQUFBUyxTQURuQyxBQUNtQyxVQU54RCxBQUtJLEFBQzhEO0FBWDNEO0FBeE1mOzs7O0lBQUEsQUFBa0Q7Ozs7QUFPOUMsY0FBWTs7QUFDWixZQUFVOztBQUVWLFdBQVMsSUFBQSxBQUFJLE9BQU8sa0NBQVgsQUFDTyw2Q0FEUCxBQUNvRDs7QUFFN0QsQUFBQyx1QkFBRCxBQUFDO0FBQ0csYUFBQSxBQUFTO0FBQ1Qsa0JBQWMsQ0FEZCxBQUNjLEFBQUM7QUFDZixrQkFGQSxBQUVjO0FBQ2Q7QUFDSSxhQURJLEFBQ0c7QUFDUCxtQkFGSSxBQUVTO0FBQ2Isc0JBSEksQUFHWTtBQUNoQix3QkFKRyxBQUFDLEFBSWM7QUFKZCxLQUFEO0FBUUgsYUFESixBQUNXO0FBQ1AsbUJBRkosQUFFaUI7QUFDYixzQkFISixBQUdvQjtBQUNoQix3QkFkSixBQUdPLEFBT1AsQUFJc0I7QUFKdEI7QUFWQTs7Ozs7Ozs7Ozs7Ozs7OztBQ25DUixJQUFBLEFBa0JBOztlQUFXLFFBQVgsQUFBVyxBQUFROztBQUFuQixBQUFDOzs7QUFHSyxBQUFNLE9BQUMsQUFBTyxRQUFDO0FBQXJCLE1BQUE7Ozs7Ozs7Ozs7OytCQUtjLEFBQUMsT0FBRCxBQUFRLFNBQVIsQUFBaUI7QUFDdkIsZ0JBQVEsQUFBSyxNQUFMLEFBQU0sUUFBTixBQUFjLDBCQUFkLEFBQXdDO29CQUUvQyxBQUFFLEdBQUMsQUFBRSxHQUFOLEFBQU87QUFDYSxnQkFESCxBQUNTO0FBQ04sbUJBRkgsQUFFWTtBQUNULGtCQUhwQixBQUFpQixBQUdXO0FBSFgsU0FBakIsQUFBQyxFQUtlLEFBQUMsS0FMakIsQUFLaUIsZUFDRCxDQUFBLEFBQUMsT0FOakIsQUFNZ0IsQUFBUSxVQVRsQixBQUdOLEFBT2dCO0FBRXBCLEFBQWU7OztvQ0FBQSxBQUFDLE1BQUQsQUFBTyxNQUNsQjtZQUFBLFNBQUEsV0FBQSxVQUFBLFNBQUEsTUFBQTtBQUFBLGdCQUFRLEFBQUssS0FBQTtBQUNiLGtCQUFVLEFBQUssS0FBQTtBQUVmLG9CQUFZLEFBQUksS0FBQztBQUVqQixtQkFBVyxBQUFDLEtBQUEsQUFBRSxHQUFDLEFBQVEsU0FBWixBQUFhLGVBQWIsQUFBNEIsQUFBTyxPQUFBO0FBRTlDLFlBQUcsYUFBWSxBQUFDLEtBQUEsQUFBRSxHQUFDLEFBQVEsU0FBM0IsQUFBZSxBQUFhO0FBQ3hCLGlCQUFPLGdCQUFBLEFBQWdCLFdBQVc7QUFDbEMsb0JBQVU7c0JBRVQsQUFBRSxHQUFDLEFBQUUsR0FBTixBQUFPO0FBQ2Esb0JBREQsQUFDUztBQUNSLGlCQUZELEFBRU07QUFDTCxtQkFIRCxBQUdRO0FBQ1AscUJBSkQsQUFJVTtBQUNULGtCQUxELEFBS087QUFDTix3QkFORCxBQU1hO0FBQ1osbUJBUHBCLEFBQW1CLEFBT1E7QUFQUixXQUFuQixBQUFDLEVBU2tCLEFBQUMsS0FUcEIsQUFTb0IsYUFUcEIsQUFVbUIsU0FkdkIsQUFJSSxBQVdtQjtBQWZ2QixlQUFBO2lCQWlCSSxRQUFBLEFBQVEsR0FqQlosQUFpQkksQUFBVztBQXpCSjtBQTJCZixBQUFhOzs7a0NBQUEsQUFBQyxLQUFELEFBQU07QUFDZixZQUFHLEFBQUcsSUFBSCxBQUFJLFFBQVMsQUFBRyxJQUFDLEFBQUksS0FBUixBQUFTLFdBQXpCLEFBQW1DO2lCQUMvQixRQUFBLEFBQVEsR0FEWixBQUNJLEFBQVc7QUFEZixtQkFFUSxBQUFHLElBQU4sQUFBTztBQUNSLEFBQUMsZUFBQSxBQUFFLEdBQUMsQUFBRyxJQUFQLEFBQVEsU0FBUyxBQUFHLElBQUMsQUFBSyxNQUFULEFBQVUsT0FBVixBQUFpQixPQUFPLEFBQUcsSUFBQyxBQUFLLE1BQWpDLEFBQWtDLE9BQW5ELEFBQTBEO2lCQUMxRCxRQUFRLEFBQUcsSUFBQyxBQUFLLE1BQWpCLEFBQWtCLE1BRmpCLEFBRUQsQUFBd0I7QUFGdkIsU0FBQSxNQUFBO2lCQUlELFFBQUEsQUFBUSxPQUpQLEFBSUQsQUFBZTtBQVBWO0FBNUNqQjs7OztJQUFBLEFBQXNELEFBS2xELEFBQVU7Ozs7QUFKVixBQUFDLDJCQUFELEFBQUM7QUFDRyxhQUFBLEFBQVM7QUFDVCxlQURBLEFBQ1c7QUFEWDs7Ozs7Ozs7Ozs7Ozs7OztBQ3ZCUixJQUFBLEFBa0JBOztlQUFXLFFBQVgsQUFBVyxBQUFROztBQUFuQixBQUFDOzs7QUFHSyxBQUFNLE9BQUMsQUFBTyxRQUFDO0FBQXJCLE1BQUE7Ozs7Ozs7Ozs7OytCQU1jLEFBQUMsT0FBRCxBQUFRLFNBQVIsQUFBaUIsV0FDdkI7WUFBQTtBQUFBLGtCQUFVLEFBQUMsS0FBQSxBQUFJLEtBQUM7b0JBRWYsQUFBRSxHQUFDLEFBQUUsR0FBTixBQUFPO0FBQ2EsZ0JBREgsQUFDUztBQUNOLG1CQUZILEFBRVk7QUFDVCxrQkFIcEIsQUFBaUIsQUFHVztBQUhYLFNBQWpCLEFBQUMsRUFLZSxBQUFDLEtBTGpCLEFBS2lCLGVBQ0QsQ0FBQSxBQUFDLE9BQUQsQUFBUSxTQU54QixBQU1nQixBQUFpQixVQVQzQixBQUdOLEFBT2dCO0FBRXBCLEFBQWU7OztvQ0FBQSxBQUFDLE1BQUQsQUFBTyxNQUNsQjtZQUFBLFNBQUEsYUFBQSxTQUFBO0FBQUEsZ0JBQVEsQUFBSyxLQUFBO0FBQ2Isa0JBQVUsQUFBSyxLQUFBO0FBQ2Ysa0JBQVUsQUFBSyxLQUFBO0FBRWYsc0JBQWMsQUFBSSxLQUFDO29CQUVsQixBQUFFLEdBQUMsQUFBRSxHQUFOLEFBQU87QUFDYSxrQkFERCxBQUNTO0FBQ1IsZUFGRCxBQUVNO0FBQ0wsaUJBSEQsQUFHUTtBQUNQLGlCQUpELEFBSVE7QUFDUCxrQkFMcEIsQUFBbUIsQUFLUztBQUxULFNBQW5CLEFBQUMsRUFPZSxBQUFDLEtBUGpCLEFBT2lCLGFBQ0QsQ0FBQSxBQUFDLE9BUmpCLEFBUWdCLEFBQVEsVUFmYixBQU9YLEFBU2dCO0FBRXBCLEFBQWE7OztrQ0FBQSxBQUFDLEtBQUQsQUFBTSxNQUNmO1lBQUEsU0FBQTtBQUFBLGdCQUFRLEFBQUssS0FBQTtBQUNiLGtCQUFVLEFBQUssS0FBQTtBQUVmLFlBQUcsQ0FBSSxBQUFHLElBQVYsQUFBVztBQUNQLGNBQUcsQUFBRyxJQUFOLEFBQU87QUFDSCxBQUFDLGlCQUFBLEFBQUUsR0FBQyxBQUFHLElBQVAsQUFBUSxBQUFTLFNBQUcsQUFBQyxLQUFBLEFBQUUsR0FBQyxBQUFHLElBQVAsQUFBUSxlQUFSLEFBQXVCLE9BQTFCLEFBQUcsQUFBOEIsQUFBTyxzQ0FDaEIsQUFBRyxJQUFDLEFBQUssTUFEakMsQUFDa0MsQUFBSyxjQUNyQyxBQUFHLElBQUMsQUFBSyxNQUY1QixBQUFpQixBQUVZLEFBQUs7bUJBQ2xDLFFBQVEsQUFBRyxJQUFDLEFBQUssTUFBakIsQUFBa0IsTUFKdEIsQUFJSSxBQUF3QjtBQUo1QixpQkFBQTttQkFNSSxRQUFBLEFBQVEsT0FOWixBQU1JLEFBQWU7QUFQdkI7QUFBQSxlQUFBO2lCQVNJLFFBQUEsQUFBUSxHQVRaLEFBU0ksQUFBVztBQWJOO0FBcENqQjs7OztJQUFBLEFBQXlDLEFBTXJDLEFBQVU7Ozs7QUFMVixBQUFDLGNBQUQsQUFBQztBQUNHLGFBQUEsQUFBUztBQUNULGVBREEsQUFDVztBQUNYLGtCQUZBLEFBRWM7QUFGZDs7Ozs7Ozs7Ozs7Ozs7OztBQ3ZCUixJQUFBLEFBa0JBOztlQUFXLFFBQVgsQUFBVyxBQUFROztBQUFuQixBQUFDOzs7QUFHSyxBQUFNLE9BQUMsQUFBTyxRQUFDO0FBQXJCLE1BQUE7Ozs7Ozs7Ozs7OzhCQUthLEFBQUMsUUFBRCxBQUFTLFFBQVQsQUFBaUIsV0FBakIsQUFBNEIsYUFBNUIsQUFBeUMsY0FDOUM7WUFBQTtBQUFBLGtCQUFVLEFBQU0sT0FBTixBQUFPLFFBQVAsQUFBZSxRQUFmLEFBQXVCO0FBQ2pDLFlBQUcsQUFBWSxhQUFaLEFBQWEsU0FBYixBQUFzQixLQUFNLFlBQS9CLEFBQTBDO0FBQ3RDLEFBQUMsZUFBQSxBQUFFLEdBQUMsQUFBRyxJQUFQLEFBQVEsQUFBVywrQkFBQSxBQUFtQixBQUFZLDJCQUMzQixBQUFhLGFBRGpCLEFBQ2lCLEFBQUcseUNBQ1gsQUFBWSxhQUFaLEFBQWEsTUFBYixBQUFtQixBQUFFLEdBQXJCLEFBQXNCLEtBSHRELEFBQ0ksQUFBbUIsQUFFUyxBQUEyQixBQUFZO0FBRXZFO2VBUEssQUFPRTtBQUVYLEFBQWE7OztrQ0FBQSxBQUFDLFVBQ1Y7WUFBQSxTQUFBLFFBQUE7QUFBQSxpQkFBUyxBQUFDLEtBQUEsQUFBRSxHQUFDLEFBQU0sT0FBVixBQUFXO0FBQ3BCLGtCQURBLEFBQ1U7O0FBTVYsa0JBQVUsQUFBQyxLQUFELEFBQUMsUUFBRCxBQUFTLFNBQVQsQUFBa0IsZ0JBQWxCLEFBQWtDLFVBQWxDLEFBQTRDLE9BQU8sQ0FBbkQsQUFBbUQsQUFBQztBQUM5RCxrQkFBVSxBQUFDLEtBQUQsQUFBQyxRQUFELEFBQVMsU0FBVCxBQUFrQixnQkFBbEIsQUFBa0MsV0FBbEMsQUFBNkMsT0FBTyxDQUFwRCxBQUFvRCxBQUFDO0FBQy9ELGtCQUFVLEFBQUMsS0FBRCxBQUFDLFFBQUQsQUFBUyxTQUFULEFBQWtCLGdCQUFsQixBQUFrQyxXQUFsQyxBQUE2QyxPQUNILENBQUEsQUFBQyxRQUQzQyxBQUMwQyxBQUFTO0FBQzdELGtCQUFVLEFBQUMsS0FBRCxBQUFDLFFBQUQsQUFBUyxTQUFULEFBQWtCLGVBQWxCLEFBQWlDLFlBQWpDLEFBQTZDLE1BQ0gsQ0FBQSxBQUFDLFNBRDNDLEFBQzBDLEFBQVU7QUFDOUQsa0JBQVUsQUFBQyxLQUFELEFBQUMsUUFBRCxBQUFTLFNBQVQsQUFBa0IsYUFBbEIsQUFBK0IsV0FBL0IsQUFBMEMsU0FDSSxDQUQ5QyxBQUM4QyxBQUFDO0FBQ3pELGtCQUFVLEFBQUMsS0FBRCxBQUFDLFFBQUQsQUFBUyxTQUFULEFBQWtCLGFBQWxCLEFBQStCLGFBQS9CLEFBQTRDLFNBQ0UsQ0FEOUMsQUFDOEMsQUFBQztBQUN6RCxrQkFBVSxBQUFDLEtBQUQsQUFBQyxRQUFELEFBQVMsU0FBVCxBQUFrQixnQkFBbEIsQUFBa0MsVUFBbEMsQUFBNEMsT0FBTyxDQUFuRCxBQUFtRCxBQUFDO0FBQzlELGtCQUFVLEFBQUMsS0FBRCxBQUFDLFFBQUQsQUFBUyxTQUFULEFBQWtCLG9CQUFsQixBQUFzQyxTQUF0QyxBQUNzQixnQkFDQSxDQUFBLEFBQUMsaUJBRnZCLEFBRXNCLEFBQWtCO0FBQ2xELGtCQUFVLEFBQUMsS0FBRCxBQUFDLFFBQUQsQUFBUyxTQUFULEFBQWtCLGFBQWxCLEFBQStCLGFBQS9CLEFBQTRDLFNBQ0UsQ0F0QnhELEFBcUJVLEFBQzhDLEFBQUM7O0FBR3pELGtCQUFVLEFBQUMsS0FBRCxBQUFDLFFBQUQsQUFBUyxTQUFULEFBQWtCLHNCQUFsQixBQUF3QyxhQUF4QyxBQUNrQyxXQUFXLENBRDdDLEFBQzZDLEFBQUM7QUFDeEQsa0JBQVUsQUFBQyxLQUFELEFBQUMsUUFBRCxBQUFTLFNBQVQsQUFBa0IsYUFBbEIsQUFBK0IsU0FBL0IsQUFBd0MsU0FBUyxDQUFqRCxBQUFpRCxBQUFDO0FBQzVELGtCQUFVLEFBQUMsS0FBRCxBQUFDLFFBQUQsQUFBUyxTQUFULEFBQWtCLGtCQUFsQixBQUFvQyxRQUFwQyxBQUE0QyxZQUNFLENBRDlDLEFBQzhDLEFBQUM7QUFFekQsYUFBSyxBQUFPLFFBQVAsQUFBUSxNQUFSLEFBQWM7QUFDbkIsWUFBQSxBQUFHO0FBQ0MsQUFBQyxlQUFBLEFBQUUsR0FBQyxBQUFHLElBQVAsQUFBUSxXQUFXLFdBQVcsQUFBRSxHQUFiLEFBQWMsU0FBZCxBQUF1QiwyQkFEOUMsQUFDSSxBQUNROztBQUVaLFlBQUcsWUFBSCxBQUFjO0FBQ1YsQUFBQyxlQUFBLEFBQUUsR0FBQyxBQUFNLE9BQVYsQUFBVyxZQUFYLEFBQXVCO0FBQ3ZCLEFBQUMsZUFBQSxBQUFFLEdBQUMsQUFBRyxJQUFQLEFBQVEsUUFGWixBQUVJLEFBQWdCOztBQUVwQixZQUFBLEFBQUc7aUJBQUgsQUFDSTtBQTFDSztBQWRqQjs7OztJQUFBLEFBQWdELEFBSzVDLEFBQVM7Ozs7QUFKVCxBQUFDLHFCQUFELEFBQUM7QUFDRyxhQUFBLEFBQVM7QUFDVCxpQkFBYSxDQUFBLEFBQUMsZ0JBRGQsQUFDYSxBQUFpQjtBQUQ5Qjs7Ozs7Ozs7Ozs7Ozs7OztBQ3ZCUixJQUFBO0lBQUE7SUFBQTtJQUFBOzs7O0FBa0JBOztlQUFXLFFBQVgsQUFBVyxBQUFROztBQUFuQixBQUFDOzs7QUFFRCxNQUFNLFFBQUEsQUFBUTs7TUFHUixBQUFNLE9BQUMsQUFBTyxRQUFDO01BQXJCOztNQUFBOzs7Ozs7OztBQU1JLFlBQUEsWUFBQSxNQUFBO0FBMEJBLFlBQUEsV0FBQSxNQUFBO0FBNENBLFlBQUEsbUJBQUEsTUFBQTtBQTJCQSxZQUFBLGtCQUFBLE1BQUE7QUE2Q0EsWUFBQSxjQUFBLE1BQUE7QUFzREEsWUFBQSx1QkFBQSxNQUFBO0FBdUJBLFlBQUEsZUFBQSxNQUFBO0FBS0EsWUFBQSxnQkFBQSxNQUFBO0FBd0JBLFlBQUEsY0FBQSxNQUFBOztBQXhQQSxBQUFXOzs7O2tDQUNQO1lBQUEsU0FBQSxPQUFBOztBQUFBLEFBQUcsWUFBSCxBQUFJLGdCQUFnQixzQ0FBcEIsQUFDd0I7QUFFeEIsa0JBQVUsQUFBUSxTQUFSLEFBQVMsY0FBVCxBQUF1QjtBQUNqQyxBQUFPLGdCQUFQLEFBQVEsS0FBSztBQUViLGdCQUFRLEFBQVEsU0FBUixBQUFTLGNBQVQsQUFBdUI7QUFDL0IsQUFBSyxjQUFMLEFBQU0sWUFBWTtBQUNsQixBQUFPLGdCQUFQLEFBQVEsWUFBUixBQUFvQjtBQUVwQixpQkFBUyxBQUFRLFNBQVIsQUFBUyxjQUFULEFBQXVCO0FBQ2hDLEFBQU0sZUFBTixBQUFPLGFBQVAsQUFBb0IsUUFBcEIsQUFBNEI7QUFDNUIsQUFBTSxlQUFOLEFBQU8sS0FBSztBQUVaLFlBQUcsQUFBQyxLQUFBLEFBQUUsR0FBQyxBQUFhLGNBQXBCLEFBQUcsQUFBa0I7QUFDakIsQUFBTSxpQkFBTixBQUFPLFFBQVEsQUFBQyxLQUFBLEFBQUUsR0FBQyxBQUFhLGNBRHBDLEFBQ21CLEFBQWtCOztBQUVyQyxBQUFPLGdCQUFQLEFBQVEsWUFBUixBQUFvQixBQUVwQjtlQXBCTyxBQW9CQTtBQU1YLEFBQVU7OzsrQkFBQSxBQUFDLFFBQUQsQUFBUyxRQUFULEFBQWlCLFVBT3ZCO1lBQUEsZUFBQSxHQUFBLEtBQUEsTUFBQSxPQUFBLFNBQUEsU0FBQSxTQUFBLFFBQUE7K0JBQUE7O0FBQUEsZ0JBQVEsQUFBQyxLQUFBLEFBQUUsR0FBQyxBQUFNLE9BQVYsQUFBVyxrQkFBWCxBQUE2QixRQUE3QixBQUFxQyxNQUFyQyxBQUEyQztBQUVuRCxrQkFBVTtBQUNWLGlCQUFTO0FBRVQsYUFBQSxvQ0FBQTs7QUFDSSxxQkFBVyxBQUFNLE9BQU4sQUFBTyxVQUFQLEFBQWlCLFFBQVEsQUFBSSxLQUE3QixBQUE4QjtBQUN6QyxvQkFBVSxBQUFJLEtBQUM7QUFFZix3QkFBYyxBQUFJLEtBQUM7QUFFbkIsY0FBQSxBQUFHO0FBQ0MsNEJBQWdCLEFBQUMsS0FBRCxBQUFDLFlBQUQsQUFBYSxhQUFiLEFBQTBCO0FBRTFDLGdCQUFHLGtCQUFILEFBQW9CO0FBQXBCLEFBQ0k7QUFESix1QkFFSyxBQUFHO0FBQ0osd0JBQVU7QUFDVix3QkFBVSxPQUFBLEFBQU8sU0FBUCxBQUFnQixNQUFoQixBQUFzQixBQUM1QixpQkFBSSxBQUFJLEtBQVAsQUFBUSxTQUFZLE1BQU0sQUFBSSxLQUE5QixBQUErQixTQUQxQixBQUNOLEFBQTRDLE1BQU07QUFDdEQsQUFBQyxtQkFBQSxBQUFFLEdBQUMsQUFBRyxJQUFQLEFBQVEsUUFBUSxpQ0FBQSxBQUFpQyxVQUFqQyxBQUNaLFNBQVMsQUFBQyxLQUFBLEFBQUUsR0FBQyxBQUFHLElBQVAsQUFBUSxlQUFlLEFBQUksS0FBM0IsQUFBNEIsTUFMeEMsQUFJRCxBQUNhLEFBQWtDO0FBTDlDLGFBQUEsTUFBQTtBQU9ELEFBQUMsbUJBQUEsQUFBRSxHQUFDLEFBQUcsSUFBUCxBQUFRLFdBQVcsc0NBQ0gsQUFBQyxLQUFBLEFBQUUsR0FBQyxBQUFHLElBQVAsQUFBUSxlQUFlLEFBQUksS0FBM0IsQUFBNEIsTUFSM0MsQUFPRCxBQUNnQixBQUFrQztBQWIxRDs7QUFlQSxxQkFBVztBQUNYLG1CQUFTLEFBQUksS0FBSixBQUFLLFFBQVEsQUFBSSxLQXRCOUIsQUFzQitCOztBQUUvQixtQkFBVyxBQUFNLE9BQU4sQUFBTyxPQTdCbEIsQUE2QlcsQUFBYzs7QUFHekIsWUFBRyxBQUFRLFNBQVIsQUFBUyxhQUFaLEFBQXdCO0FBQ3BCLG9CQUFVLEFBQUMsS0FBRCxBQUFDLGlCQUFELEFBQWtCLFNBQWxCLEFBQTJCLFFBRHpDLEFBQ2MsQUFBbUM7QUFFakQ7ZUExQ00sQUEwQ0M7QUFFWCxBQUFrQjs7O3VDQUFBLEFBQUMsUUFBRCxBQUFTLFFBQVQsQUFBaUIsVUFDL0I7WUFBQSxHQUFBLEdBQUEsS0FBQSxNQUFBLE1BQUEsT0FBQSxPQUFBLFFBQUEsVUFBQSxVQUFBOztBQUFBLGdCQUFRLEFBQUMsS0FBQSxBQUFFLEdBQUMsQUFBTSxPQUFWLEFBQVcsY0FBWCxBQUF5QixRQUF6QixBQUFpQztBQUV6QyxtQkFBVztBQUNYLGlCQUFTO0FBRVQsYUFBQSxvQ0FBQTs7QUFDSSxzQkFBWSxBQUFNLE9BQU4sQUFBTyxVQUFQLEFBQWlCLFFBQVEsQUFBSSxLQUE3QixBQUE4QjtBQUMxQyxzQkFBWSxBQUFDLEtBQUQsQUFBQyxnQkFBRCxBQUFpQixRQUFqQixBQUF5QixVQUF6QixBQUFtQyxNQUFuQyxBQUF5QztBQUNyRCxtQkFBUyxBQUFJLEtBQUosQUFBSyxRQUFRLEFBQUksS0FIOUIsQUFHK0I7O0FBRS9CLG9CQUFZLEFBQU0sT0FBTixBQUFPLE9BQVAsQUFBYztBQUUxQixpQkFBUyxBQUFDLEtBQUEsQUFBRSxHQUFDLEFBQU0sT0FBVixBQUFXLGNBQVgsQUFBeUIsVUFBekIsQUFBbUM7QUFFNUMsbUJBQVc7QUFDWCxpQkFBUztBQUVULGFBQUEsdUNBQUE7O0FBQ0ksc0JBQVksQUFBUSxTQUFSLEFBQVMsVUFBVCxBQUFtQixRQUFRLEFBQUssTUFBaEMsQUFBaUM7QUFDN0Msc0JBQVksQUFBQyxLQUFELEFBQUMsZ0JBQUQsQUFBaUIsUUFBakIsQUFBeUIsVUFBekIsQUFBbUMsT0FBbkMsQUFBMEM7QUFDdEQsbUJBQVMsQUFBSyxNQUFMLEFBQU0sUUFBUSxBQUFLLE1BSGhDLEFBR2lDOztBQUVqQyxvQkFBWSxBQUFRLFNBQVIsQUFBUyxPQUFULEFBQWdCLEFBRTVCO2VBekJjLEFBeUJQO0FBRVgsQUFBaUI7OztzQ0FBQSxBQUFDLFFBQUQsQUFBUyxVQUFULEFBQW1CLFVBQW5CLEFBQTZCLGNBQzFDO1lBQUEsUUFBQSxNQUFBLGVBQUEsUUFBQSxNQUFBLFFBQUEsU0FBQTs7QUFBQSxlQUFPLEFBQVEsU0FBZixBQUFnQjs7QUFHaEIsWUFBRyxBQUFJLEtBQUosQUFBSyxXQUFSLEFBQWtCO0FBQ2QsaUJBQU8sQUFBSyxLQUFBLEFBQUUsR0FBQztBQUNmLG1CQUFTLEFBQUksS0FBSixBQUFLLFFBQUwsQUFBYTtBQUV0QixjQUFHLFNBQVMsQ0FBWixBQUFhO0FBQ1QscUJBQVMsQUFBSSxLQUFKLEFBQUssVUFBTCxBQUFlLEdBQXhCLEFBQVMsQUFBa0I7O0FBUTNCLGdCQUFHLEFBQUMsS0FBQSxBQUFFLEdBQUMsQUFBTSxPQUFWLEFBQVcscUJBQVgsQUFBZ0MsUUFBbkMsQUFBRyxBQUF3QztBQUN2Qyw0QkFBYyxBQUFJLEtBQUosQUFBSyxPQUFPLFNBQVosQUFBcUI7QUFDbkMsOEJBQWdCLEFBQUMsS0FBRCxBQUFDLFlBQUQsQUFBYSxhQUFiLEFBQTBCO0FBRTFDLGtCQUFHLGtCQUFILEFBQW9CO0FBQXBCLEFBQ0k7QUFESix5QkFFSyxBQUFHO0FBQ0oseUJBQVksQUFBSyxLQUFSLEFBQVEsS0FBUyxNQUFNLEFBQUssS0FBQSxBQUFFLEdBQTlCLEFBQStCLFFBQVk7QUFDcEQsMEJBQVUsT0FBTyxBQUFRLFNBQWYsQUFBZ0IsUUFBaEIsQUFBd0IsTUFBeEIsQUFBOEIsU0FBOUIsQUFDTSxNQUROLEFBQ1ksZ0JBRFosQUFDNkIsU0FBUztBQUNoRCxBQUFDLHFCQUFBLEFBQUUsR0FBQyxBQUFHLElBQVAsQUFBUSxRQUFRLGlDQUNBLEFBQVEsU0FEUixBQUNTLGtCQURULEFBQzJCLFNBQzNCLEFBQUMsS0FBQSxBQUFFLEdBQUMsQUFBRyxJQUFQLEFBQVEsZUFBUixBQUF1QixNQUZ2QyxBQUVnQixBQUE2QixBQUM3Qzt1QkFQQyxBQU9NO0FBUE4sZUFBQSxNQUFBO0FBVUQsQUFBQyxxQkFBQSxBQUFFLEdBQUMsQUFBRyxJQUFQLEFBQVEsV0FBVyxzQ0FDUyxBQUFDLEtBQUEsQUFBRSxHQUFDLEFBQUcsSUFBUCxBQUFRLGVBQVIsQUFBdUIsTUFDdkIsQUFBUSxTQVpuQyxBQVVELEFBQzRCLEFBQ1M7QUFsQjdDO0FBVEo7QUFKSjtBQUFBLGVBQUE7QUFrQ0ksQUFBQyxlQUFBLEFBQUUsR0FBQyxBQUFHLElBQVAsQUFBUSxXQUFXLGNBQWMsQUFBUSxTQUF0QixBQUF1QixRQUF2QixBQUErQixnQkFBL0IsQUFDUCxlQURPLEFBQ1EsZUFEUixBQUN1QixBQUM5QixnQkFBSSxlQUFILEFBQWtCLElBQWxCLEFBQXlCLGlCQUZuQixBQUVQLEFBQThDLGlCQUM5QyxBQUFRLFNBckN4QixBQWtDSSxBQUdxQjtBQUV6QjtlQUFPLEFBQVEsU0EzQ0YsQUEyQ0c7QUFFcEIsQUFBYTs7O2tDQUFBLEFBQUMsYUFBRCxBQUFjLFVBQ3ZCO1lBQUEsVUFBQSxHQUFBLEtBQUE7O0FBQUEsWUFBQSxBQUFHO0FBQ0MscUJBQVcsQUFBQyxLQUFBLEFBQUUsR0FBQyxBQUFNLE9BQVYsQUFBVywyQkFBWCxBQUFzQyxBQUNPLGFBRDdDLEFBQzhDO0FBRXpELGNBQUcsQUFBUSxTQUFSLEFBQVMsUUFBVCxBQUFpQixZQUFwQixBQUFnQztBQUM1QixpQkFBQSx1Q0FBQTtpQ0FBQTs7QUFLSSxrQkFBRyxBQUFPLFFBQVAsQUFBUSxrQkFBaUIsQUFBUSxTQUFwQyxBQUE0QixBQUFTLGVBQ2pDO3VCQURKLEFBQ1c7QUFOZjtBQVFBO21CQVRKLEFBU1c7QUFUWCxpQkFBQSxBQVdJO21CQVhKLEFBV1c7QUFmZjtBQUFBLGVBQUEsQUFpQkk7aUJBakJKLEFBaUJXO0FBbEJGO0FBb0JiLEFBQVU7OzsrQkFBQSxBQUFDLE9BQUQsQUFBUSxTQUFSLEFBQWlCLFdBQ3ZCO1lBQUEsUUFBQSxTQUFBO0FBQUEsa0JBQVUsQUFBQyxLQUFBLEFBQUksS0FBQztBQUVoQixpQkFBUztBQUNULEFBQUMsYUFBQSxBQUFFLEdBQUMsQUFBRyxJQUFQLEFBQVEsVUFBVSxrQkFBbEIsQUFBb0M7QUFFcEMsWUFBQSxBQUFHO0FBQ0MsY0FBRyxjQUFILEFBQWdCO0FBQ1o7QUFDSSx3QkFBQSxBQUFVO0FBQ1Ysc0JBREEsQUFDUTtBQUNSLHNCQUZBLEFBRVE7QUFDUiwyQkFIQSxBQUdhO0FBSGI7QUFLSixBQUFDLGlCQUFBLEFBQUUsR0FBQyxBQUFHLElBQVAsQUFBUSxXQUFSLEFBQW1CO21CQVVuQixBQUFDLEtBQUEsQUFBRSxHQUFDLEFBQUUsR0FBTixBQUFPLFdBQVAsQUFBa0IsUUFDVCxBQUFDLEtBRFYsQUFDVSxzQkFDRCxDQUFBLEFBQUMsT0FBRCxBQUFRLFFBQVIsQUFBZ0IsU0FGekIsQUFFUyxBQUF5QixVQW5CdEMsQUFpQkksQUFHUztBQXBCYixpQkFBQTttQkFzQkksQUFBQyxLQUFELEFBQUMsYUFBRCxBQUFjLFFBQWQsQUFBc0IsV0FBdEIsQUFBaUMsT0FBakMsQUFBd0MsU0F0QjVDLEFBc0JJLEFBQWlEO0FBdkJ6RDtBQUFBLGVBQUE7QUF5QkksQUFBQyxlQUFBLEFBQUUsR0FBQyxBQUFHLElBQVAsQUFBUSxTQUFSLEFBQWlCO2lCQUNqQixRQUFBLEFBQVEsT0ExQlosQUEwQkksQUFBZTtBQWhDYjtBQWtDVixBQUFzQjs7OzJDQUFBLEFBQUMsS0FBRCxBQUFNLE1BQ3hCO1lBQUEsU0FBQSxHQUFBLEtBQUEsTUFBQSxTQUFBLFVBQUEsU0FBQSxRQUFBOztBQUFBLGdCQUFRLEFBQUssS0FBQTtBQUNiLGlCQUFTLEFBQUssS0FBQTtBQUNkLGtCQUFVLEFBQUssS0FBQTtBQUNmLGtCQUFVLEFBQUssS0FBQTtBQUNmLG1CQUFXO0FBRVgsWUFBRyxBQUFHLElBQU4sQUFBTyxPQUNIOztBQUFBLGVBQUEsbUNBQUE7O0FBQ0ksQUFBUSxxQkFBUixBQUFTLEtBQUssQUFBQyxLQUFBLEFBQUUsR0FBQyxBQUFNLE9BQVYsQUFBVywyQkFDRCxBQUFPLFFBRGpCLEFBQ2tCLEFBQUssTUFGekMsQUFDSSxBQUFjLEFBQ3dCOztpQkFFMUMsQUFBQyxLQUFELEFBQUMsYUFBRCxBQUFjLFFBQWQsQUFBc0IsVUFBdEIsQUFBZ0MsT0FBaEMsQUFBdUMsU0FMM0MsQUFLSSxBQUFnRDtBQUxwRCxlQUFBO0FBUUksQUFBQyxlQUFBLEFBQUUsR0FBQyxBQUFHLElBQVAsQUFBUSxTQUFTLDBCQUFBLEFBQTBCLFNBQTNDLEFBQ3dDO0FBRXhDLGNBQUcsQUFBRyxJQUFOLEFBQU87bUJBQ0gsUUFBUSxBQUFHLElBQUMsQUFBSyxNQUFqQixBQUFrQixNQUR0QixBQUNJLEFBQXdCO0FBRDVCLGlCQUFBO21CQUdJLFFBQUEsQUFBUSxPQUhaLEFBR0ksQUFBZTtBQWR2QjtBQVBrQjtBQXVCdEIsQUFBYzs7O21DQUFBLEFBQUMsUUFBRCxBQUFTLFVBQVQsQUFBbUIsT0FBbkIsQUFBMEIsU0FBMUIsQUFBbUM7O2VBQzdDLEFBQUMsS0FBQSxBQUFFLEdBQUMsQUFBRSxHQUFOLEFBQU8sY0FBUCxBQUFxQixPQUNELEFBQUMsS0FEckIsQUFDcUIsZUFDRCxDQUFBLEFBQUMsUUFBRCxBQUFTLFNBQVQsQUFBa0IsU0FINUIsQUFDVixBQUVvQixBQUEyQjtBQUVuRCxBQUFlOzs7b0NBQUEsQUFBQyxPQUFELEFBQVEsUUFBUixBQUFnQixXQUFoQixBQUEyQixXQUEzQixBQUFzQyxNQUNqRDtZQUFBLFNBQUEsU0FBQSxVQUFBLFNBQUE7O0FBQUEsaUJBQVMsQUFBSyxLQUFBO0FBQ2Qsa0JBQVUsQUFBSyxLQUFBO0FBQ2Ysa0JBQVUsQUFBSyxLQUFBO0FBQ2YsbUJBQVcsQUFBSyxLQUFBO0FBRWhCLGtCQUFVLEFBQUMsS0FBRCxBQUFDLFNBQUQsQUFBVSxRQUFWLEFBQWtCLFFBQWxCLEFBQTBCO0FBRXBDLFlBQUcsWUFBSCxBQUFjO3NCQUNULEFBQUUsR0FBQyxBQUFFLEdBQU4sQUFBTztBQUNpQixvQkFETCxBQUNhO0FBQ1IsaUJBRkwsQUFFVTtBQUNMLG1CQUhMLEFBR1k7QUFDUCxxQkFKTCxBQUljO0FBQ1Qsa0JBTEwsQUFLVztBQUNOLDJCQU5MLEFBTW9CO0FBQ2YsbUJBUHhCLEFBQW1CLEFBT1k7QUFQWixXQUFuQixBQUFDLEVBU21CLEFBQUMsS0FUckIsQUFTcUIsYUFDRCxDQUFBLEFBQUMsU0FWckIsQUFVb0IsQUFBVSxXQVhsQyxBQUNJLEFBV29CO0FBWnhCLGVBQUE7aUJBY0ksUUFBQSxBQUFRLEdBZFosQUFjSSxBQUFXO0FBdEJKO0FBd0JmLEFBQWE7OztrQ0FBQSxBQUFDLEtBQUQsQUFBTSxNQUNmO1lBQUEsU0FBQTs7QUFBQSxrQkFBVSxBQUFLLEtBQUE7QUFDZixtQkFBVyxBQUFLLEtBQUE7QUFFaEIsWUFBRyxBQUFHLElBQUgsQUFBSSxRQUFTLEFBQUcsSUFBQyxBQUFJLEtBQVIsQUFBUyxXQUF6QixBQUFtQztpQkFDL0IsUUFBQSxBQUFRLEdBRFosQUFDSSxBQUFXO0FBRGYsbUJBRVEsQUFBRyxJQUFOLEFBQU87QUFDUixBQUFDLGVBQUEsQUFBRSxHQUFDLEFBQUcsSUFBUCxBQUFRLFNBQVMsQUFBRyxJQUFDLEFBQUssTUFBVCxBQUFVLE9BQVYsQUFBaUIsT0FBTyxBQUFHLElBQUMsQUFBSyxNQUFqQyxBQUFrQyxPQUFuRCxBQUEwRDtpQkFDMUQsUUFBUSxBQUFHLElBQUMsQUFBSyxNQUFqQixBQUFrQixNQUZqQixBQUVELEFBQXdCO0FBRnZCLFNBQUEsTUFBQTtpQkFJRCxRQUFBLEFBQVEsT0FKUCxBQUlELEFBQWU7QUFWVjtBQTlQakI7Ozs7SUFBQSxBQUFrRDs7OztBQUM5QyxBQUFDLHVCQUFELEFBQUM7QUFDRyxhQUFBLEFBQVM7QUFDVCxlQURBLEFBQ1c7QUFDWCxrQkFGQSxBQUVjO0FBRmQ7O0FBMEJKLGVBQWEsc0JBQ1Q7V0FBTyxBQUFRLFNBQVIsQUFBUyxlQUFULEFBQ2EsQUFBeUMsMENBRnBELEFBRXFEOzs7Ozs7Ozs7Ozs7Ozs7OztBQ3JEdEUsSUFBQTtJQUFBO0lBQUE7SUFBQTs7OztBQWtCQTs7ZUFBVyxRQUFYLEFBQVcsQUFBUTs7QUFBbkIsQUFBQzs7O0FBRUQsTUFBTSxRQUFBLEFBQVE7O01BR1IsQUFBTSxPQUFDLEFBQU8sUUFBQztBQUFyQixNQUFBOzs7Ozs7OztBQWNJLFlBQUEsaUJBQUEsTUFBQTtBQU9BLFlBQUEsY0FBQSxNQUFBO0FBYUEsWUFBQSxxQkFBQSxNQUFBO0FBZ0JBLFlBQUEsd0JBQUEsTUFBQTtBQTRFQSxZQUFBLDJCQUFBLE1BQUE7O0FBeEhBLEFBQWM7Ozs7bUNBQUEsQUFBQztBQUNYLEFBQUMsYUFBQSxBQUFFLEdBQUMsQUFBRyxJQUFQLEFBQVEsUUFBUixBQUFnQjtlQUVoQixBQUFDLEtBQUEsQUFBRSxHQUFDLEFBQUUsR0FBTixBQUFPLGVBQVAsQUFBc0IsbUJBQXRCLEFBQ3FCLGNBQ0EsQUFBQyxLQUZ0QixBQUVzQixnQkFMWixBQUdWLEFBR3FCO0FBRXpCLEFBQWdCOzs7cUNBQUEsQUFBQyxTQUFELEFBQVUsVUFBVixBQUFvQixVQUNoQztZQUFBOztBQUFBLHFCQUFhLEFBQVEsU0FBQztBQUV0QixBQUFPLGdCQUFQLEFBQVE7ZUFFUixBQUFDLEtBQUQsQUFBQyxZQUFELEFBQWEsU0FBYixBQUFzQixZQUxWLEFBS1osQUFBa0M7QUFFdEMsQUFBYTs7O2tDQUFBLEFBQUMsaUJBQUQsQUFBa0IsWUFBbEIsQUFBOEIsVUFDdkM7WUFBQTs7QUFBQSx5QkFBaUIsQUFBZSxnQkFBZixBQUFnQjtBQUVqQyxZQUFBLEFBQUc7aUJBQ0MsQUFBQyxLQUFBLEFBQUUsR0FBQyxBQUFFLEdBQU4sQUFBTyxjQUFjLEFBQWMsZUFBbkMsQUFBb0MsT0FDcEIsQUFBQyxLQURqQixBQUNpQixvQkFDRCxDQUFBLEFBQUMsZ0JBQUQsQUFBaUIsaUJBQWpCLEFBQWtDLFlBSHRELEFBQ0ksQUFFZ0IsQUFDQztBQUpyQixlQUFBO0FBTUksQUFBQyxlQUFBLEFBQUUsR0FBQyxBQUFHLElBQVAsQUFBUSxRQUFSLEFBQWdCO0FBQ2hCLGNBQUEsQUFBRzttQkFBSCxBQUNJO0FBUlI7QUFIUztBQWFiLEFBQW9COzs7eUNBQUEsQUFBQyxxQkFBRCxBQUNDLHNCQURELEFBQ3VCLFdBRHZCLEFBQ2tDLFdBRGxDLEFBQzZDLE1BQzdEO1lBQUEsVUFBQSxnQkFBQSxpQkFBQSxxQkFBQTs7QUFBQSx5QkFBaUIsQUFBSyxLQUFBO0FBQ3RCLDBCQUFrQixBQUFLLEtBQUE7QUFDdkIscUJBQWEsQUFBSyxLQUFBO0FBQ2xCLG1CQUFXLEFBQUssS0FBQTtBQUNoQiw4QkFBc0IsQUFBVyxXQUFBLEFBQWMsZUFBQyxBQUFjLGVBQTdCLEFBQThCLEFBQUssS0FBOUMsQUFBOEMsT0FBOUMsQUFBcUQsTUFDbkQsQUFBYyxlQUFDLEFBQWMsZUFBQztvQkFFckQsQUFBRSxHQUFDLEFBQUUsR0FBTixBQUFPO0FBQVcsZ0JBQUQsQUFBTztBQUFhLGtCQUFwQixBQUE0QjtBQUFXLGtCQUF4RCxBQUFpQixBQUErQztBQUEvQyxTQUFqQixBQUFDLEVBQ2dCLEFBQUMsS0FEbEIsQUFDa0IsdUJBQ0QsQ0FBQSxBQUFDLGdCQUFELEFBQWlCLHFCQUFqQixBQUNDLHNCQURELEFBQ3VCLFdBRHZCLEFBQ2tDLFdBRGxDLEFBRUMsaUJBRkQsQUFFa0IsWUFKbkMsQUFFaUIsQUFFOEIsV0FiL0IsQUFTaEIsQUFLaUI7QUFFckIsQUFBdUI7Ozs0Q0FBQSxBQUFDLGdCQUFELEFBQWlCLE1BQ3BDO1lBQUEsVUFBQSxnQkFBQSxzQkFBQSxxQkFBQSxpQkFBQSxXQUFBLHNCQUFBLGNBQUEsWUFBQSxXQUFBLG9CQUFBLG1CQUFBLHdCQUFBLG9CQUFBLGdCQUFBLFNBQUEsV0FBQSxpQkFBQSxjQUFBOztBQUFBLCtCQUF1QixBQUFjLGVBQUMsQUFBVSxVQUFBLEFBQUcsR0FBQTtBQUNuRCx5QkFBaUIsQUFBSyxLQUFBO0FBQ3RCLDhCQUFzQixBQUFLLEtBQUE7QUFDM0IsK0JBQXVCLEFBQUssS0FBQTtBQUM1QixvQkFBWSxBQUFLLEtBQUE7QUFDakIsb0JBQVksQUFBSyxLQUFBO0FBQ2pCLDBCQUFrQixBQUFLLEtBQUE7QUFDdkIscUJBQWEsQUFBSyxLQUFBO0FBQ2xCLG1CQUFXLEFBQUssS0FBQTtBQUVoQixBQUFDLGFBQUEsQUFBRSxHQUFDLEFBQUcsSUFBUCxBQUFRLFFBQVEsZ0JBQWdCLEFBQUMsS0FBQSxBQUFFLEdBQUMsQUFBRyxJQUFQLEFBQVEsZUFBUixBQUNoQixxQkFEQSxBQUFnQixBQUNLLHVCQURyQyxBQUM0RDtBQUU1RCx1QkFBZSxBQUFvQixxQkFBcEIsQUFBcUIsTUFBckIsQUFBMkI7QUFDMUMsb0JBQVksQUFBQyxLQUFBLEFBQUUsR0FBQyxBQUFNLE9BQVYsQUFBVyxrQkFBa0IsQUFBYSxhQUExQyxBQUEwQyxJQUExQyxBQUE4QyxBQUFNLE1BQUE7QUFFaEUsMEJBQWtCLEFBQW9CLHFCQUFwQixBQUFxQixNQUFyQixBQUMwQjtBQUM1Qyx1QkFBZSxBQUFDLEtBQUEsQUFBRSxHQUFDLEFBQU0sT0FBVixBQUFXLGtCQUFrQixBQUFnQixnQkFBN0MsQUFBNkMsSUFBN0MsQUFDNkMsQUFBTSxNQUFBO0FBRWxFLFlBQUcsQUFBUyxVQUFaLEFBQWE7QUFDVCw4QkFBb0IsTUFBTSxBQUFTLFVBRHZDLEFBQ3dDO0FBRHhDLG1CQUVRLEFBQVksYUFBZixBQUFnQjtBQUNqQiw4QkFBb0IsTUFBTSxBQUFZLGFBRHJDLEFBQ3NDO0FBRHRDLFNBQUEsTUFBQTtBQUdELDhCQUhDLEFBR21COztBQUV4QixZQUFHLEFBQVMsVUFBWixBQUFhO0FBQ1QsK0JBQXFCLE1BQU0sQUFBUyxVQUR4QyxBQUN5QztBQUR6QyxtQkFFUSxBQUFZLGFBQWYsQUFBZ0I7QUFDakIsK0JBQXFCLE1BQU0sQUFBWSxhQUR0QyxBQUN1QztBQUR2QyxTQUFBLE1BQUE7QUFHRCwrQkFIQyxBQUdvQjs7QUFFekIsWUFBRyxBQUFjLGVBQUMsQUFBYyxlQUFoQyxBQUFpQztBQUM3QixtQ0FBeUIsQUFBYyxlQUFDLEFBQWMsZUFBN0IsQUFBOEIsTUFEM0QsQUFDaUU7QUFEakUsZUFBQTtBQUdJLG1DQUhKLEFBRzZCOztBQUU3QixZQUFHLEFBQVcsV0FBQSxBQUFjLGVBQUMsQUFBYyxlQUE3QixBQUE4QixBQUFLLEtBQWpELEFBQWlEO0FBQzdDLCtCQUFxQixBQUFDLEtBQUEsQUFBRSxHQUFDLEFBQU0sT0FBVixBQUFXLDJCQUNaLEFBQVcsV0FBQSxBQUFjLGVBQUMsQUFBYyxlQUE3QixBQUE4QixBQUFLLEtBRDdDLEFBQzZDLFFBRnRFLEFBRThFO0FBRjlFLGVBQUE7QUFJSSwrQkFKSixBQUl5Qjs7QUFFekIseUJBQWlCLEFBQUMsS0FBQSxBQUFFLEdBQUMsQUFBTSxPQUFWLEFBQVcsMkJBQ1EsQUFBYyxlQUFDLEFBQWMsZUFEaEQsQUFDaUQ7QUFFbEUsb0JBQVksT0FBQSxBQUFPLHlCQUFQLEFBQ0kscUJBREosQUFDeUIsaUJBRHpCLEFBRUksb0JBRkosQUFFd0IscUJBQXFCO0FBQ3pELGtCQUFVLEFBQUcsSUFBSCxBQUFJLGFBQUosQUFBaUIsc0JBQWpCLEFBQXVDLFdBQ2IsQUFBUyxVQURuQyxBQUNvQyxPQUFPLEFBQVMsVUFEcEQsQUFDcUQ7QUFFL0QsWUFBRyxZQUFILEFBQWM7c0JBQ1QsQUFBRSxHQUFDLEFBQUUsR0FBTixBQUFPO0FBRUssb0JBREosQUFDWTtBQUNSLGlCQUZKLEFBRVM7QUFDTCxtQkFISixBQUdXO0FBQ1AscUJBQVMsQUFBQyxLQUFBLEFBQUksS0FKbEIsQUFJbUI7QUFDZixrQkFMSixBQUtVO0FBQ04sNEJBTkosQUFNb0I7QUFDaEIsbUJBUlosQUFDUSxBQU9XO0FBUFgsV0FEUixBQUFDLEVBVU8sQUFBQyxLQVZULEFBVVMsMEJBQ0QsQ0FBQSxBQUFDLGlCQUFELEFBQWtCLFlBWDFCLEFBV1EsQUFBOEIsV0FaMUMsQUFDSSxBQVlRO0FBYlosZUFBQTtBQWVJLEFBQUMsZUFBQSxBQUFFLEdBQUMsQUFBRyxJQUFQLEFBQVEsV0FBVyxtQkFDQyxBQUFDLEtBQUEsQUFBRSxHQUFDLEFBQUcsSUFBUCxBQUFRLGVBQVIsQUFBdUIscUJBRDNDLEFBQ29CLEFBQ0E7aUJBQ3BCLEFBQUMsS0FBRCxBQUFDLFlBQUQsQUFBYSxpQkFBYixBQUE4QixZQWxCbEMsQUFrQkksQUFBMEM7QUExRTNCO0FBNEV2QixBQUEwQjs7OytDQUFBLEFBQUMsS0FBRCxBQUFNLE1BQzVCO1lBQUEsVUFBQSxpQkFBQTs7QUFBQSwwQkFBa0IsQUFBSyxLQUFBO0FBQ3ZCLHFCQUFhLEFBQUssS0FBQTtBQUNsQixtQkFBVyxBQUFLLEtBQUE7QUFFaEIsWUFBRyxBQUFHLElBQUgsQUFBSSxRQUFTLEFBQUcsSUFBQyxBQUFJLEtBQVIsQUFBUyxXQUF6QixBQUFtQztpQkFDL0IsQUFBQyxLQUFELEFBQUMsWUFBRCxBQUFhLGlCQUFiLEFBQThCLFlBRGxDLEFBQ0ksQUFBMEM7QUFEOUMsZUFBQTtpQkFHSSxBQUFDLEtBQUEsQUFBRSxHQUFDLEFBQUcsSUFBUCxBQUFRLFNBQVMsQUFBSSxJQUFBLEFBQVMsU0FBYixBQUFhLFVBQWIsQUFDZSxPQUFPLEFBQUksSUFBQSxBQUFTLFNBRG5DLEFBQ21DLFVBSnhELEFBR0ksQUFDOEQ7QUFUNUM7QUE5SDlCOzs7O0lBQUEsQUFBZ0Q7Ozs7QUFDNUMsQUFBQyxxQkFBRCxBQUFDO0FBQ0csYUFBQSxBQUFTO0FBQ1Qsa0JBQWMsQ0FEZCxBQUNjLEFBQUM7QUFDZixrQkFGQSxBQUVjO0FBRmQ7Ozs7Ozs7Ozs7Ozs7Ozs7QUN6QlIsSUFBQSxBQWtCQTs7ZUFBVyxRQUFYLEFBQVcsQUFBUTs7QUFBbkIsQUFBQzs7O0FBR0ssQUFBTSxPQUFDLEFBQU8sUUFBQztBQUFyQixNQUFBOzs7Ozs7Ozs7OzsrQkFLYyxBQUFDLFFBQ1A7WUFBQSxHQUFBLFFBQUEsR0FBQSxLQUFBLE1BQUEsTUFBQSxVQUFBLFVBQUEsUUFBQSxhQUFBLFVBQUEsUUFBQTtBQUFBLGdCQUFRLEFBQUMsS0FBQSxBQUFFLEdBQUMsQUFBTSxPQUFWLEFBQVc7QUFDbkIsbUJBQVcsQUFBQyxLQUFBLEFBQUUsR0FBQyxBQUFNLE9BQVYsQUFBVyxvQkFBWCxBQUErQixBQUFPLFFBQUM7QUFFbEQsaUJBQVMsQUFBQyxLQUFBLEFBQUUsR0FBQyxBQUFNLE9BQVYsQUFBVyxpQkFBWCxBQUE0QjtBQUNyQyxtQkFBVztBQUNYLGlCQUFTO0FBRVQsYUFBQSxxQ0FBQTs7QUFDSSxzQkFBWSxBQUFNLE9BQU4sQUFBTyxVQUFQLEFBQWlCLFFBQVEsQUFBSSxLQUE3QixBQUE4QjtBQUMxQyxzQkFBWSxBQUFDLEtBQUQsQUFBQyxRQUFELEFBQVMsUUFBVCxBQUFpQixVQUFVLEFBQUksS0FBL0IsQUFBZ0MsU0FBUyxBQUFJLEtBQTdDLEFBQThDLFVBQ04sQUFBSSxLQUQ1QyxBQUM2QztBQUN6RCxtQkFBUyxBQUFJLEtBQUosQUFBSyxRQUFRLEFBQUksS0FKOUIsQUFJK0I7O0FBRS9CLG9CQUFZLEFBQU0sT0FBTixBQUFPLE9BYm5CLEFBYVksQUFBYzs7QUFRMUIsaUJBQVMsQUFBQyxLQUFBLEFBQUUsR0FBQyxBQUFNLE9BQVYsQUFBVyxrQkFBWCxBQUE2QixVQUE3QixBQUF1QyxNQUF2QyxBQUE2QztBQUN0RCxtQkFBVztBQUNYLGlCQUFTO0FBRVQsYUFBQSx1Q0FBQTs7QUFDSSxzQkFBWSxBQUFRLFNBQVIsQUFBUyxVQUFULEFBQW1CLFFBQVEsQUFBSSxLQUEvQixBQUFnQztBQUM1Qyx3QkFBYyxBQUFJLEtBQUM7QUFFbkIsY0FBQSxBQUFHO0FBQ0Msd0JBQVksQUFBQyxLQUFELEFBQUMsUUFBRCxBQUFTLFVBQVQsQUFBbUIsVUFBVSxBQUFJLEtBQWpDLEFBQWtDLFNBQWxDLEFBQ3dCLGFBQWEsQUFBSSxLQUZ6RCxBQUNnQixBQUMwQztBQUYxRCxpQkFBQTtBQUlJLHdCQUFZLEFBQUksS0FKcEIsQUFJcUI7O0FBRXJCLG1CQUFTLEFBQUksS0FBSixBQUFLLFFBQVEsQUFBSSxLQVY5QixBQVUrQjs7QUFFL0Isb0JBQVksQUFBUSxTQUFSLEFBQVMsT0FBVCxBQUFnQixBQUU1QjtlQXhDTSxBQXdDQztBQUVYLEFBQVM7Ozs4QkFBQSxBQUFDLFFBQUQsQUFBUyxVQUFULEFBQW1CLFNBQW5CLEFBQTRCLGFBQTVCLEFBQXlDLE1BQzlDO1lBQUEsYUFBQSxZQUFBLFlBQUEsVUFBQSxTQUFBLEdBQUEsS0FBQTtBQUFBLG1CQUFXLEFBQUMsS0FBQSxBQUFFLEdBQUMsQUFBTSxPQUFWLEFBQVcsMkJBQVgsQUFBc0MsQUFBWSxhQUFsRCxBQUFtRDtBQUU5RCxhQUFBLHVDQUFBOztBQUNJLG9CQUFVLEFBQU8sUUFBQztBQUNsQix1QkFBYSxBQUFDLEtBQUEsQUFBRSxHQUFDLEFBQU0sT0FBVixBQUFXLFVBQVgsQUFBcUI7QUFDbEMsd0JBQWMsQUFBQyxLQUFBLEFBQUUsR0FBQyxBQUFNLE9BQVYsQUFBVyxVQUFYLEFBQXFCO0FBRW5DLGNBQUcsQUFBVSxXQUFWLEFBQVcsa0JBQWlCLEFBQVcsWUFBMUMsQUFBK0IsQUFBWTtBQUN2QyxnQkFBRyxhQUFILEFBQWUsYUFPWDtxQkFBTyxRQUFBLEFBQVEsQUFBYSxjQUFDLEFBQUcsT0FBVSxNQUFiLEFBQW1CLE9BQXpDLEFBQXFCLEFBQThCLE1BUDlELEFBT29FO0FBUHBFLG1CQUFBO0FBbUJJLDJCQUFhLEFBQUMsS0FBQSxBQUFFLEdBQUMsQUFBTSxPQUFWLEFBQVcsd0NBQVgsQUFBbUQsQUFDaEU7cUJBQU8sUUFBQSxBQUFRLEFBQWEsY0FBQyxBQUFHLE9BQVUsTUFBYixBQUFtQixPQUF6QyxBQUFxQixBQUE4QixNQXBCOUQsQUFvQm9FO0FBckJ4RTtBQUxKO0FBRkE7O0FBZ0NBLEFBQUMsYUFBQSxBQUFFLEdBQUMsQUFBRyxJQUFQLEFBQVEsV0FBVyxxQ0FBbkIsQUFBd0QsQUFDeEQ7ZUFsQ0ssQUFrQ0U7QUFFWCxBQUFhOzs7a0NBQUEsQUFBQyxVQUNWO1lBQUEsU0FBQTtBQUFBLGlCQUFTLEFBQUMsS0FBQSxBQUFFLEdBQUMsQUFBTSxPQUFWLEFBQVc7QUFDcEIsa0JBQVUsQUFBQyxLQUFELEFBQUMsU0FBRCxBQUFVO0FBRXBCLFlBQUcsWUFBSCxBQUFjO0FBQ1YsQUFBQyxlQUFBLEFBQUUsR0FBQyxBQUFNLE9BQVYsQUFBVyxZQUFYLEFBQXVCO0FBQ3ZCLEFBQUMsZUFBQSxBQUFFLEdBQUMsQUFBRyxJQUFQLEFBQVEsUUFGWixBQUVJLEFBQWdCO0FBRnBCLGVBQUE7QUFJSSxBQUFDLGVBQUEsQUFBRSxHQUFDLEFBQUcsSUFBUCxBQUFRLFFBSlosQUFJSSxBQUFnQjs7QUFFcEIsWUFBQSxBQUFHO2lCQUFILEFBQ0k7QUFYSztBQW5GakI7Ozs7SUFBQSxBQUEwQyxBQUt0QyxBQUFVOzs7O0FBSlYsQUFBQyxlQUFELEFBQUM7QUFDRyxhQUFBLEFBQVM7QUFDVCxpQkFBYSxDQUFBLEFBQUMsZ0JBRGQsQUFDYSxBQUFpQjtBQUQ5Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDdkJSLElBQUE7SUFBQTtJQUFBOzs7OztpQkFrQkE7O2VBQVcsUUFBWCxBQUFXLEFBQVE7O0FBQW5CLEFBQUM7OztNQUdLLEFBQU0sT0FBQyxBQUFPLFFBQUM7QUFBckIsTUFBQTs7Ozs7Ozs7QUFLSSxZQUFBLGNBQUEsTUFBQTtBQTJDQSxZQUFBLHNCQUFBLE1BQUE7QUEwQ0EsWUFBQSxjQUFBLE1BQUE7QUFvQ0EsWUFBQSxvQkFBQSxNQUFBO0FBT0EsWUFBQSxxQkFBQSxNQUFBO0FBTUEsWUFBQSxzQkFBQSxNQUFBO0FBd0VBLFlBQUEsOEJBQUEsTUFBQTtBQXFEQSxZQUFBLGVBQUEsTUFBQTtBQU9BLFlBQUEsVUFBQSxNQUFBOztBQTFRQSxBQUFhOzs7O2tDQUFBLEFBQUMsT0FBRCxBQUFRLFlBQVIsQUFBb0IsT0FBcEIsQUFBMkIsT0FBM0IsQUFBa0MsUUFBbEMsQUFBMEMsU0FBMUMsQUFBbUQsUUFBbkQsQUFDMkMsTUFEM0MsQUFDaUQsVUFDMUQ7WUFBQSxNQUFBLFFBQUEsYUFBQSxNQUFBOztBQUFBLFlBQUcsQUFBTSxNQUFULEFBQVM7QUFDTCxpQkFBTyxBQUFNLE1BQUE7QUFDYix3QkFBYyxBQUFJLEtBQUM7QUFFbkIsY0FBRyxBQUFJLG9CQUFDLEFBQW9CLElBQXBCLFlBQW9CLEFBQUksS0FBQyxBQUFTLFVBQWQsQUFBZSxlQUFmLGFBQUEsQUFBZ0MsWUFBaEMsU0FBekIsQUFBSSxBQUFxQixPQUE1QixBQUE0RTtBQUN4RSxBQUFDLGlCQUFBLEFBQUUsR0FBQyxBQUFHLElBQVAsQUFBUSxRQUFRLGdCQUNaLEFBQUMsS0FBQSxBQUFFLEdBQUMsQUFBRyxJQUFQLEFBQVEsZUFBZSxBQUFJLEtBQTNCLEFBQTRCLE1BQU0sQUFBSSxLQUQxQixBQUNaLEFBQXVDLFdBRDNDLEFBQ3NEO0FBRXRELHFCQUFTLENBQUksQUFBSSxLQUFQLEFBQVEsWUFBZSxBQUFJLEtBQUosQUFBSyxZQUE1QixBQUF3QyxNQUF6QyxBQUFrRCxNQUNQLEFBQUksS0FKeEQsQUFJeUQ7O0FBUXpELGdCQUFHLENBQUksQUFBQyxLQUFBLEFBQUUsR0FBQyxBQUFNLE9BQVYsQUFBVyxxQkFBWCxBQUFnQyxRQUF2QyxBQUFPLEFBQXdDO0FBQzNDO0FBQ0ksMEJBQUEsQUFBVTtBQUNWLHdCQURBLEFBQ1E7QUFDUix3QkFGQSxBQUVRO0FBQ1IsNkJBSEEsQUFHYTtBQUhiO3FCQUtKLEFBQUMsS0FBQSxBQUFFLEdBQUMsQUFBRSxHQUFOLEFBQU8sV0FBUCxBQUFrQixRQUNULEFBQUMsS0FEVixBQUNVLHFCQUNELENBQUEsQUFBQyxNQUFELEFBQU8sUUFBUCxBQUFlLGFBQWYsQUFBNEIsWUFBNUIsQUFBd0MsT0FBeEMsQUFBK0MsT0FBL0MsQUFBc0QsUUFBdEQsQUFDTyxTQURQLEFBQ2dCLFFBRGhCLEFBQ3dCLE9BRHhCLEFBQytCLE1BSHhDLEFBRVMsQUFDcUMsV0FWbEQsQUFPSSxBQUlTO0FBWGIsbUJBQUE7QUFhSTtxQkFDQSxBQUFDLEtBQUQsQUFBQyxZQUFELEFBQWEsT0FBYixBQUFvQixZQUFwQixBQUFnQyxPQUFoQyxBQUNRLE9BRFIsQUFDZSxRQURmLEFBQ3VCLFNBRHZCLEFBQ2dDLFFBRGhDLEFBQ3dDLE1BZjVDLEFBY0ksQUFDOEM7QUE1QnREO0FBQUEsaUJBQUE7QUE4Qkk7bUJBQ0EsQUFBQyxLQUFELEFBQUMsWUFBRCxBQUFhLE9BQWIsQUFBb0IsWUFBcEIsQUFBZ0MsT0FBaEMsQUFBdUMsT0FBdkMsQUFDb0IsUUFEcEIsQUFDNEIsU0FENUIsQUFDcUMsUUFEckMsQUFDNkMsTUFoQ2pELEFBK0JJLEFBQ21EO0FBcEMzRDtBQUFBLGVBQUE7QUFzQ0kscUJBQVcsQUFBTSxPQUFOLEFBQU8sT0FBUCxBQUFjO2lCQUN6QixLQUFBLEFBQUssU0FBTCxBQUFjLFlBdkNsQixBQXVDSSxBQUEwQjtBQXpDckI7QUEyQ2IsQUFBcUI7OzswQ0FBQSxBQUFDLEtBQUQsQUFBTSxNQUN2QjtZQUFBLE1BQUEsVUFBQSxlQUFBLEdBQUEsT0FBQSxZQUFBLEtBQUEsTUFBQSxPQUFBLFNBQUEsUUFBQSxhQUFBLE1BQUEsU0FBQSxVQUFBLFFBQUEsUUFBQTs7QUFBQSxlQUFPLEFBQUssS0FBQTtBQUNaLGlCQUFTLEFBQUssS0FBQTtBQUNkLHNCQUFjLEFBQUssS0FBQTtBQUNuQixxQkFBYSxBQUFLLEtBQUE7QUFDbEIsZ0JBQVEsQUFBSyxLQUFBO0FBQ2IsZ0JBQVEsQUFBSyxLQUFBO0FBQ2IsaUJBQVMsQUFBSyxLQUFBO0FBQ2Qsa0JBQVUsQUFBSyxLQUFBO0FBQ2YsaUJBQVMsQUFBSyxLQUFBO0FBQ2QsZ0JBQVEsQUFBSyxLQUFBO0FBQ2IsZUFBTyxBQUFLLEtBQUE7QUFDWixtQkFBVyxBQUFLLEtBWGhCLEFBV2dCOztBQUdoQixZQUFHLEFBQUcsSUFBTixBQUFPO0FBQ0gscUJBQVcsQUFFWDs7QUFBQSxlQUFBLG1DQUFBOztBQUNJLEFBQVEscUJBQVIsQUFBUyxLQUFLLEFBQUMsS0FBQSxBQUFFLEdBQUMsQUFBTSxPQUFWLEFBQVcsMkJBQ0QsQUFBTyxRQURqQixBQUNrQixBQUFLLE1BRnpDLEFBQ0ksQUFBYyxBQUN3Qjs7QUFFMUMsMEJBQWdCLEFBQUMsS0FBRCxBQUFDLFlBQUQsQUFBYSxhQUFiLEFBQTBCO0FBRTFDLHFCQUFXLEFBQU0sT0FBTixBQUFPLFVBQVAsQUFBaUIsUUFBUSxBQUFJLEtBQTdCLEFBQThCO0FBRXpDLGNBQUcsa0JBQUgsQUFBb0I7QUFDaEIsdUJBQVcsQUFBSSxLQURuQixBQUNvQjtBQURwQixxQkFFSyxBQUFHO0FBQ0osdUJBQVcsT0FBQSxBQUFPLFNBQVAsQUFBZ0IsTUFBaEIsQUFBc0IsQUFDckIsaUJBQUksQUFBSSxLQUFQLEFBQVEsU0FBWSxNQUFNLEFBQUksS0FBOUIsQUFBK0IsU0FEakMsQUFDQyxBQUE0QyxNQUZ2RCxBQUU2RDtBQUY3RCxXQUFBLE1BQUE7QUFJRCxBQUFDLGlCQUFBLEFBQUUsR0FBQyxBQUFHLElBQVAsQUFBUSxXQUFXLHNDQUNQLEFBQUMsS0FBQSxBQUFFLEdBQUMsQUFBRyxJQUFQLEFBQVEsZUFBZSxBQUFJLEtBQTNCLEFBQTRCLE1BQU0sQUFBSSxLQURsRCxBQUNZLEFBQXVDO0FBQ25ELHVCQUFXLEFBQUksS0FOZCxBQU1lOztBQUVwQixtQkFBUyxBQUFJLEtBQUosQUFBSyxRQUFRLEFBQUksS0FyQjlCLEFBcUIrQjs7QUFFL0I7ZUFDQSxBQUFDLEtBQUQsQUFBQyxZQUFELEFBQWEsT0FBYixBQUFvQixZQUFwQixBQUFnQyxPQUFoQyxBQUF1QyxPQUF2QyxBQUE4QyxRQUE5QyxBQUNvQyxTQURwQyxBQUM2QyxRQUQ3QyxBQUNxRCxNQXhDcEMsQUF1Q2pCLEFBQzJEO0FBRS9ELEFBQWE7OztrQ0FBQSxBQUFDLGFBQUQsQUFBYyxVQUN2QjtZQUFBLGFBQUEsWUFBQSxVQUFBLEdBQUEsS0FBQTs7QUFBQSxtQkFBVyxBQUFDLEtBQUEsQUFBRSxHQUFDLEFBQU0sT0FBVixBQUFXLDJCQUFYLEFBQXNDLEFBQVksYUFBbEQsQUFBbUQ7QUFFOUQsWUFBRyxBQUFRLFNBQVIsQUFBUyxRQUFULEFBQWlCLFlBQXBCLEFBQWdDO0FBQzVCLGVBQUEsdUNBQUE7O0FBQ0kseUJBQWEsQUFBQyxLQUFBLEFBQUUsR0FBQyxBQUFNLE9BQVYsQUFBVyxVQUFYLEFBQXFCO0FBQ2xDLDBCQUFjLEFBQUMsS0FBQSxBQUFFLEdBQUMsQUFBTSxPQUFWLEFBQVcsVUFBWCxBQUFxQjtBQUVuQyxnQkFBRyxBQUFVLFdBQVYsQUFBVyxrQkFBaUIsQUFBVyxZQUExQyxBQUErQixBQUFZO0FBQ3ZDLGtCQUFHLGFBQUgsQUFBZSxhQVFYO3VCQVJKLEFBUVc7QUFSWCxxQkFBQSxBQXFCSTt1QkFBTyxBQUFDLEtBQUEsQUFBRSxHQUFDLEFBQU0sT0FBVixBQUFXLHdDQXJCdEIsQUFxQlcsQUFDcUM7QUF2QnBEO0FBSko7QUE0QkE7aUJBN0JKLEFBNkJXO0FBN0JYLGVBQUEsQUErQkk7aUJBL0JKLEFBK0JXO0FBbENGO0FBb0NiLEFBQW1COzs7d0NBQUEsQUFBQyxTQUFELEFBQVUsWUFBVixBQUFzQixVQUNyQztZQUFBLFdBQUE7O0FBQUEsb0JBQVksQUFBQyxLQUFBLEFBQUUsR0FBQyxBQUFNLE9BQVYsQUFBVyxjQUFYLEFBQXlCLFNBQXpCLEFBQWtDO0FBQzlDLGdCQUFRLEFBQUMsS0FBQSxBQUFFLEdBQUMsQUFBTSxPQUFWLEFBQVc7ZUFDbkIsQUFBQyxLQUFELEFBQUMsb0JBQUQsQUFBcUIsT0FBckIsQUFBNEIsWUFBNUIsQUFBd0MsV0FBeEMsQUFBbUQsR0FBbkQsQUFBc0QsR0FBdEQsQUFDWSxTQURaLEFBQ3FCLElBRHJCLEFBQ3lCLEdBQ2IsQUFBQyxLQUZiLEFBRWEsb0JBTEUsQUFHZixBQUVpQztBQUVyQyxBQUFvQjs7O3lDQUFBLEFBQUMsU0FBRCxBQUFVLFlBQVYsQUFBc0IsVUFDdEM7WUFBQSxXQUFBOztBQUFBLG9CQUFZLEFBQUMsS0FBQSxBQUFFLEdBQUMsQUFBTSxPQUFWLEFBQVcsY0FBWCxBQUF5QixTQUF6QixBQUFrQztBQUM5QyxnQkFBUSxBQUFDLEtBQUEsQUFBRSxHQUFDLEFBQU0sT0FBVixBQUFXO2VBQ25CLEFBQUMsS0FBRCxBQUFDLG9CQUFELEFBQXFCLE9BQXJCLEFBQTRCLFlBQTVCLEFBQXdDLFdBQXhDLEFBQW1ELEdBQW5ELEFBQXNELEdBQXRELEFBQ1EsU0FEUixBQUNpQixJQURqQixBQUNxQixHQUFHLEFBQUMsS0FEekIsQUFDeUIsU0FKVCxBQUdoQixBQUNrQztBQUV0QyxBQUFxQjs7OzBDQUFBLEFBQUMsT0FBRCxBQUFRLFlBQVIsQUFBb0IsV0FBcEIsQUFBK0IsY0FBL0IsQUFBNkMsT0FBN0MsQUFDVyxRQURYLEFBQ21CLFNBRG5CLEFBQzRCLFFBRDVCLEFBQ29DLE1BRHBDLEFBQzBDLFVBQzNEO1lBQUEsTUFBQSxRQUFBLE1BQUEsUUFBQSxhQUFBLFdBQUEsUUFBQTs7QUFBQSxZQUFHLEFBQVUsVUFBYixBQUFhO0FBQ1QscUJBQVcsQUFBVSxVQUFBO0FBQ3JCLGlCQUFPLEFBQVEsU0FEZixBQUNnQjs7QUFHaEIsY0FBRyxBQUFJLEtBQUosQUFBSyxXQUFSLEFBQWtCO0FBQ2QsbUJBQU8sQUFBSyxLQUFBLEFBQUUsR0FBQztBQUNmLHFCQUFTLEFBQUksS0FBSixBQUFLLFFBQUwsQUFBYTtBQUV0QixnQkFBRyxTQUFTLENBQVosQUFBYTtBQUNULDBCQUFZLEFBQUksS0FBSixBQUFLLFVBQUwsQUFBZSxHQUFmLEFBQWtCO0FBQzlCLHVCQUFTLEFBQUMsS0FBQSxBQUFFLEdBQUMsQUFBTSxPQUFWLEFBQVcsMkJBQVgsQUFBc0MsQUFBVSxXQUFoRCxBQUFpRDtBQUMxRCw0QkFBYyxBQUFJLEtBQUosQUFBSyxPQUFPLFNBQVosQUFBcUI7QUFFbkMsa0JBQUEsQUFBRztBQVNDLG9CQUFHLENBQUksQUFBQyxLQUFBLEFBQUUsR0FBQyxBQUFNLE9BQVYsQUFBVyxxQkFBWCxBQUFnQyxRQUF2QyxBQUFPLEFBQXdDO0FBQzNDLEFBQUMsdUJBQUEsQUFBRSxHQUFDLEFBQUcsSUFBUCxBQUFRLFFBQVEsZ0JBQ0osQUFBQyxLQUFBLEFBQUUsR0FBQyxBQUFHLElBQVAsQUFBUSxlQUFSLEFBQXVCLE1BQ3ZCLEFBQVEsU0FGSixBQUNKLEFBQ1MsbUJBRnJCLEFBRXdDO0FBRXhDO0FBQ0ksOEJBQUEsQUFBVTtBQUNWLDRCQURBLEFBQ1E7QUFDUiw0QkFGQSxBQUVRO0FBQ1IsaUNBSEEsQUFHYTtBQUhiO3lCQUtKLEFBQUMsS0FBQSxBQUFFLEdBQUMsQUFBRSxHQUFOLEFBQU8sV0FBUCxBQUFrQixRQUNiLEFBQUMsS0FETixBQUNNLDZCQUNELENBQUEsQUFBQyxVQUFELEFBQVcsUUFBWCxBQUFtQixhQUFuQixBQUFnQyxZQUFoQyxBQUE0QyxXQUE1QyxBQUNBLGNBREEsQUFDYyxPQURkLEFBQ3FCLFFBRHJCLEFBQzZCLFNBRDdCLEFBRUEsUUFGQSxBQUVRLE9BRlIsQUFFZSxNQUpwQixBQUVLLEFBRXFCLFdBZjlCLEFBV0ksQUFLSztBQWhCVCx1QkFBQTtBQWtCSTt5QkFDQSxBQUFDLEtBQUQsQUFBQyxvQkFBRCxBQUNRLE9BRFIsQUFDZSxZQURmLEFBQzJCLFdBRDNCLEFBQ3NDLGNBRHRDLEFBQ29ELE9BRHBELEFBRVEsUUFGUixBQUVnQixTQUZoQixBQUV5QixRQUZ6QixBQUVpQyxNQXJCckMsQUFtQkksQUFFdUM7QUE5Qi9DO0FBQUEscUJBQUE7QUFnQ0k7dUJBQ0EsQUFBQyxLQUFELEFBQUMsb0JBQUQsQUFBcUIsT0FBckIsQUFBNEIsWUFBNUIsQUFDZ0IsV0FEaEIsQUFDMkIsY0FEM0IsQUFDeUMsT0FEekMsQUFDZ0QsUUFEaEQsQUFFZ0IsU0FGaEIsQUFFeUIsUUFGekIsQUFFaUMsTUFuQ3JDLEFBaUNJLEFBRXVDO0FBeEMvQztBQUFBLG1CQUFBO0FBMENJO3FCQUNBLEFBQUMsS0FBRCxBQUFDLG9CQUFELEFBQXFCLE9BQXJCLEFBQTRCLFlBQTVCLEFBQ29CLFdBRHBCLEFBQytCLGNBRC9CLEFBQzZDLE9BRDdDLEFBQ29ELFFBRHBELEFBRW9CLFNBRnBCLEFBRTZCLFFBRjdCLEFBRXFDLE1BN0N6QyxBQTJDSSxBQUUyQztBQWpEbkQ7QUFBQSxpQkFBQTtBQW1ESSxBQUFDLGlCQUFBLEFBQUUsR0FBQyxBQUFHLElBQVAsQUFBUSxXQUFXLGNBQWMsQUFBUSxTQUF0QixBQUF1QixRQUF2QixBQUNYLGdCQURXLEFBQ0ssZUFETCxBQUNvQixlQURwQixBQUVYLEFBQ0EsZ0JBQUksZUFBSCxBQUFrQixJQUFsQixBQUF5QixpQkFIZixBQUdYLEFBQThDLGlCQUM5QyxBQUFRLFNBSmhCLEFBSWlCO0FBQ2pCO21CQUNBLEFBQUMsS0FBRCxBQUFDLG9CQUFELEFBQXFCLE9BQXJCLEFBQTRCLFlBQTVCLEFBQ3dCLFdBRHhCLEFBQ21DLGNBRG5DLEFBQ2lELE9BRGpELEFBQ3dELFFBRHhELEFBRXdCLFNBRnhCLEFBRWlDLFFBRmpDLEFBRXlDLE1BM0Q3QyxBQXlESSxBQUUrQztBQWhFdkQ7QUFBQSxlQUFBO0FBbUVJLHFCQUFXLEFBQU0sT0FBTixBQUFPLE9BQVAsQUFBYztpQkFDekIsS0FBQSxBQUFLLFNBQUwsQUFBYyxZQXBFbEIsQUFvRUksQUFBMEI7QUF0RWI7QUF3RXJCLEFBQTZCOzs7a0RBQUEsQUFBQyxLQUFELEFBQU0sTUFDL0I7WUFBQSxRQUFBLE1BQUEsVUFBQSxjQUFBLGVBQUEsR0FBQSxPQUFBLFlBQUEsS0FBQSxTQUFBLFFBQUEsYUFBQSxNQUFBLFNBQUEsVUFBQSxRQUFBLFFBQUEsVUFBQSxXQUFBOztBQUFBLG1CQUFXLEFBQUssS0FBQTtBQUNoQixpQkFBUyxBQUFLLEtBQUE7QUFDZCxzQkFBYyxBQUFLLEtBQUE7QUFDbkIscUJBQWEsQUFBSyxLQUFBO0FBQ2xCLG9CQUFZLEFBQUssS0FBQTtBQUNqQix1QkFBZSxBQUFLLEtBQUE7QUFDcEIsZ0JBQVEsQUFBSyxLQUFBO0FBQ2IsaUJBQVMsQUFBSyxLQUFBO0FBQ2Qsa0JBQVUsQUFBSyxLQUFBO0FBQ2YsaUJBQVMsQUFBSyxLQUFBO0FBQ2QsZ0JBQVEsQUFBSyxLQUFBO0FBQ2IsZUFBTyxBQUFLLEtBQUE7QUFDWixtQkFBVyxBQUFLLEtBWmhCLEFBWWdCOztBQUdoQixZQUFHLEFBQUcsSUFBTixBQUFPO0FBQ0gscUJBQVcsQUFFWDs7QUFBQSxlQUFBLG1DQUFBOztBQUNJLEFBQVEscUJBQVIsQUFBUyxLQUFLLEFBQUMsS0FBQSxBQUFFLEdBQUMsQUFBTSxPQUFWLEFBQVcsMkJBQ0QsQUFBTyxRQURqQixBQUNrQixBQUFLLE1BRnpDLEFBQ0ksQUFBYyxBQUN3Qjs7QUFFMUMsMEJBQWdCLEFBQUMsS0FBRCxBQUFDLFlBQUQsQUFBYSxhQUFiLEFBQTBCO0FBRTFDLHFCQUFXLEFBQU0sT0FBTixBQUFPLFVBQVAsQUFBaUIsUUFBUSxBQUFRLFNBQWpDLEFBQWtDO0FBRTdDLGNBQUcsa0JBQUgsQUFBb0I7QUFDaEIsdUJBQVcsQUFBUSxTQUR2QixBQUN3QjtBQUR4QixxQkFFSyxBQUFHO0FBQ0oscUJBQVksQUFBUSxTQUFDLEFBQVUsVUFBdEIsQUFBc0IsS0FBUyxNQUFNLEFBQVEsU0FBQyxBQUFVLFVBQUEsQUFBRSxHQUExRCxBQUEyRCxRQUFZO0FBQ2hGLHVCQUFXLE9BQU8sQUFBUSxTQUFmLEFBQWdCLFFBQWhCLEFBQXdCLE1BQXhCLEFBQThCLFNBQTlCLEFBQXVDLE1BQXZDLEFBQTZDLGdCQUE3QyxBQUE4RCxTQUZ4RSxBQUVpRjtBQUZqRixXQUFBLE1BQUE7QUFJRCxBQUFDLGlCQUFBLEFBQUUsR0FBQyxBQUFHLElBQVAsQUFBUSxXQUFXLHNDQUNmLEFBQUMsS0FBQSxBQUFFLEdBQUMsQUFBRyxJQUFQLEFBQVEsZUFBUixBQUF1QixRQUFRLEFBQVEsU0FEM0MsQUFDSSxBQUF3QztBQUM1Qyx1QkFBVyxBQUFRLFNBTmxCLEFBTW1COztBQUV4QixtQkFBUyxBQUFRLFNBQVIsQUFBUyxRQUFRLEFBQVEsU0FyQnRDLEFBcUJ1Qzs7QUFFdkM7ZUFDQSxBQUFDLEtBQUQsQUFBQyxvQkFBRCxBQUFxQixPQUFyQixBQUE0QixZQUE1QixBQUF3QyxXQUF4QyxBQUNRLGNBRFIsQUFDc0IsT0FEdEIsQUFDNkIsUUFEN0IsQUFDcUMsU0FEckMsQUFDOEMsUUFEOUMsQUFDc0QsTUF6QzdCLEFBd0N6QixBQUM0RDtBQUVoRSxBQUFhOzs7OzhFQUFBLEFBQUMsQUFDVjs7Ozs7O0FBQUEsMkJBQVMsQUFBQyxLQUFBLEFBQUUsR0FBQyxBQUFNLE9BQVYsQUFBVztBQUNwQixBQUFDLHVCQUFBLEFBQUUsR0FBQyxBQUFHLElBQVAsQUFBUSxRQUFSLEFBQWdCO0FBQ2hCLDBCQUFRLEFBQUMsS0FBQSxBQUFFLEdBQUMsQUFBTSxPQUFWLEFBQVc7O3lCQUNQLEFBQUMsS0FBQSxBQUFFLEdBQUMsQUFBRSxHQUFOLEFBQU8sZ0JBQWIsQUFBTSxBQUF1Qjs7O0FBQW5DLEFBQU07O0FBQ047c0NBQWM7cUNBQUE7O0FBQUEseUJBQUEsbUNBQUE7O21DQUFBLEFBQUUsR0FBRixBQUFHO0FBQUg7OztBQUNkLDBCQUFRLEFBQUMsS0FBQSxBQUFFLEdBQUMsQUFBTSxPQUFWLEFBQVcsa0JBQVgsQUFBNkIsUUFBN0IsQUFBcUMsTUFBckMsQUFBMkM7bURBQ25ELEFBQUMsS0FBRCxBQUFDLFlBQUQsQUFBYSxPQUFiLEFBQW9CLFlBQXBCLEFBQWdDLE9BQWhDLEFBQXVDLEdBQXZDLEFBQTBDLFFBQTFDLEFBQWtELElBQWxELEFBQXNELEdBQ3pDLEFBQUMsS0FEZCxBQUNjLGNBUkwsQUFPVCxBQUM0QixBQUVoQyxBQUFjOzs7Ozs7Ozs7Ozs7Ozs7Ozs7bUNBQUEsQUFBQyxTQUFELEFBQVUsWUFBVixBQUFzQixVQUVoQztZQUFBOytCQUFBOztBQUFBLFlBQUcsQUFBUSxTQUFSLEFBQVMsYUFBWixBQUF3QjtpQkFDcEIsWUFBWSxBQUFDLEtBQUQsQUFBQyxrQkFBRCxBQUFtQixTQUFuQixBQUE0QixZQUQ1QyxBQUNnQixBQUF3QztBQUR4RCxlQUFBO2lCQUdJLEFBQUMsS0FBRCxBQUFDLFFBQUQsQUFBUyxTQUFULEFBQWtCLFlBSHRCLEFBR0ksQUFBOEI7QUFMeEI7QUFPZCxBQUFTOzs7OEJBQUEsQUFBQyxTQUFELEFBQVUsWUFBVixBQUFzQixVQUMzQjtZQUFBOztBQUFBLGlCQUFTLEFBQUMsS0FBQSxBQUFFLEdBQUMsQUFBTSxPQUFWLEFBQVc7QUFFcEIsWUFBRyxZQUFILEFBQWM7QUFDVixBQUFDLGVBQUEsQUFBRSxHQUFDLEFBQU0sT0FBVixBQUFXLFlBQVgsQUFBdUI7QUFDdkIsQUFBQyxlQUFBLEFBQUUsR0FBQyxBQUFHLElBQVAsQUFBUSxRQUZaLEFBRUksQUFBZ0I7QUFGcEIsZUFBQTtBQUlJLEFBQUMsZUFBQSxBQUFFLEdBQUMsQUFBRyxJQUFQLEFBQVEsUUFBUSxvREFKcEIsQUFJSSxBQUN3RDs7QUFFNUQsWUFBQSxBQUFHO2lCQUFILEFBQ0k7QUFYQztBQS9RYjs7OztJQUFBLEFBQThDOzs7O0FBQzFDLEFBQUMsbUJBQUQsQUFBQztBQUNHLGFBQUEsQUFBUztBQUNULGlCQUFhLENBQUEsQUFBQyxpQkFEZCxBQUNhLEFBQWtCO0FBRC9COzs7Ozs7Ozs7Ozs7Ozs7O0FDdkJSLElBQUEsQUFrQkE7O2VBQVcsUUFBWCxBQUFXLEFBQVE7O0FBQW5CLEFBQUM7OztBQUdLLEFBQU0sT0FBQyxBQUFPLFFBQUM7QUFBckIsTUFBQTs7Ozs7Ozs7Ozs7a0NBS2lCLEFBQUMsVUFDVjtZQUFBLFNBQUE7QUFBQSxpQkFBUyxBQUFDLEtBQUEsQUFBRSxHQUFDLEFBQU0sT0FBVixBQUFXO0FBQ3BCLGtCQUFVO0FBRVYsa0JBQVUsQUFBTyxRQUFQLEFBQVEsUUFBUixBQUFnQixhQUFoQixBQUE2QjtBQUV2QyxZQUFHLFlBQUgsQUFBYztBQUNWLEFBQUMsZUFBQSxBQUFFLEdBQUMsQUFBTSxPQUFWLEFBQVcsWUFBWCxBQUF1QjtBQUN2QixBQUFDLGVBQUEsQUFBRSxHQUFDLEFBQUcsSUFBUCxBQUFRLFFBRlosQUFFSSxBQUFnQjs7QUFFcEIsWUFBQSxBQUFHO2lCQUFILEFBQ0k7QUFYSztBQUxqQjs7OztJQUFBLEFBQWdELEFBSzVDLEFBQWE7Ozs7QUFKYixBQUFDLHFCQUFELEFBQUM7QUFDRyxhQUFBLEFBQVM7QUFDVCxpQkFBYSxDQUFBLEFBQUMsZ0JBRGQsQUFDYSxBQUFpQjtBQUQ5Qjs7Ozs7Ozs7Ozs7Ozs7OztBQ3ZCUixJQUFBO0lBQUE7SUFBQTtJQUFBOzs7O0FBa0JBOztlQUFXLFFBQVgsQUFBVyxBQUFROztBQUFuQixBQUFDOzs7QUFFRCxNQUFNLFFBQUEsQUFBUTs7TUFHUixBQUFNLE9BQUMsQUFBTyxRQUFDOzhCQUFyQjs7TUFBQTs7Ozs7Ozs7QUE0RUksWUFBQSxxQkFBQSxNQUFBO0FBNERBLFlBQUEsZ0JBQUEsTUFBQTtBQWVBLFlBQUEsY0FBQSxNQUFBOztBQWxHQSxBQUFROzs7OytCQUNKO2VBREksQUFDRztBQUVYLEFBQVc7OztrQ0FDUDtZQUFBLFNBQUEsTUFBQSxTQUFBO0FBQUEsa0JBQVU7QUFDVixlQUFPLEFBQVEsU0FBUixBQUFTLGNBQVQsQUFBdUI7QUFFOUIsdUJBQWUsQUFBUSxTQUFSLEFBQVMsY0FBVCxBQUF1QjtBQUN0QyxBQUFZLHFCQUFaLEFBQWEsWUFBWTtBQUV6QixrQkFBVSxBQUFRLFNBQVIsQUFBUyxjQUFULEFBQXVCO0FBQ2pDLEFBQU8sZ0JBQVAsQUFBUSxhQUFSLEFBQXFCLFFBQXJCLEFBQTZCO0FBQzdCLEFBQU8sZ0JBQVAsQUFBUSxLQUFLO0FBRWIsQUFBSSxhQUFKLEFBQUssWUFBTCxBQUFpQjtBQUNqQixBQUFJLGFBQUosQUFBSyxZQUFMLEFBQWlCO0FBRWpCLEFBQU8sZ0JBQVAsQUFBUSxZQUFSLEFBQW9CLEFBRXBCO2VBaEJPLEFBZ0JBO0FBSVgsQUFBb0I7Ozs7O0FBQ2hCO0FBQ0ksbUJBQVMsQUFBUSxTQUFSLEFBQVMsZUFBVCxBQUNXLEFBQWtDLG1DQUR0RCxBQUN1RDtBQUN2RCxzQkFBWSxBQUFRLFNBQVIsQUFBUyxlQUFULEFBQ1EsQUFBc0MsdUNBSDFELEFBRzJEO0FBQzNELHFCQUFXLEFBQVEsU0FBUixBQUFTLGVBQVQsQUFDUyxBQUFxQyxzQ0FMekQsQUFLMEQ7QUFMMUQ7QUFPSixBQUFDLGFBQUEsQUFBRSxHQUFDLEFBQUcsSUFBUCxBQUFRLFVBQVUsY0FBYyxBQUFhLGNBQTdDLEFBQThDO0FBQzlDLEFBQUMsYUFBQSxBQUFFLEdBQUMsQUFBRyxJQUFQLEFBQVEsVUFBVSxrQkFBa0IsQUFBYSxjQUFqRCxBQUFrRDtlQUNsRCxBQUFDLEtBQUEsQUFBRSxHQUFDLEFBQUcsSUFBUCxBQUFRLFVBQVUsaUJBQWlCLEFBQWEsY0FYaEMsQUFXaEIsQUFBaUQ7QUFNckQsQUFBYTs7O2tDQUFBLEFBQUMsVUFDVjtZQUFBLEtBQUEsU0FBQTtBQUFBLEFBQUMsYUFBRCxBQUFDLEFBRUQ7O0FBQUEsQUFDSTtBQURKLGlCQUFBO0FBRU07QUFDRixBQUFDLGVBQUEsQUFBRSxHQUFDLEFBQUcsSUFBUCxBQUFRLFNBQVMsc0JBQWpCLEFBQXVDLEFBRXZDOztpQkFMSixBQUtXOztBQUVYLGlCQUFTLEFBQUMsS0FBQSxBQUFFLEdBQUMsQUFBTSxPQUFWLEFBQVc7QUFDcEIsa0JBQVUsQUFBTSxPQUFOLEFBQU8sUUFBUSxBQUFhLGNBQTVCLEFBQTZCLFFBQ0ssQUFBYSxjQUQvQyxBQUNnRDtBQUUxRCxZQUFHLFlBQUgsQUFBYztBQUNWLEFBQUMsZUFBQSxBQUFFLEdBQUMsQUFBTSxPQUFWLEFBQVcsWUFBWCxBQUF1QjtBQUN2QixBQUFDLGVBQUEsQUFBRSxHQUFDLEFBQUcsSUFBUCxBQUFRLFFBRlosQUFFSSxBQUFnQjs7QUFFcEIsWUFBQSxBQUFHO2lCQUFILEFBQ0k7QUFuQks7QUFxQmIsQUFBVTs7OytCQUFBLEFBQUMsT0FBRCxBQUFRLFNBQVIsQUFBaUIsV0FDdkI7WUFBQSxLQUFBO0FBQUEsQUFBQyxhQUFELEFBQUMsQUFFRDs7QUFBQSxBQUNJO0FBREosaUJBQUE7QUFFTTtBQUNGLEFBQUMsZUFBQSxBQUFFLEdBQUMsQUFBRyxJQUFQLEFBQVEsU0FBUyxzQkFBakIsQUFBdUM7QUFDdkMsa0JBQUEsQUFBUSxPQURSLEFBQ0EsQUFBZSxBQUVmOztpQkFOSixBQU1XOztBQUVYLGtCQUFVLEFBQVEsU0FBUixBQUFTLGVBQVQsQUFDa0IsQUFBbUMsb0NBQUM7QUFFaEUsWUFBRyxZQUFILEFBQWM7aUJBQ1YsQUFBQyxLQUFBLEFBQUUsR0FBQyxBQUFFLEdBQU4sQUFBTyxjQUFQLEFBQXFCLE9BQ0QsQUFBQyxLQURyQixBQUNxQixlQUNELENBQUEsQUFBQyxTQUh6QixBQUNJLEFBRW9CLEFBQVU7QUFIbEMsZUFBQTtBQUtJLEFBQUMsZUFBQSxBQUFFLEdBQUMsQUFBRyxJQUFQLEFBQVEsU0FBUixBQUFpQjtpQkFDakIsUUFBQSxBQUFRLE9BTlosQUFNSSxBQUFlO0FBcEJiO0FBc0JWLEFBQWU7OztvQ0FBQSxBQUFDLE9BQUQsQUFBUSxRQUFSLEFBQWdCLFdBQWhCLEFBQTJCLFdBQTNCLEFBQXNDLE1BQ2pEO1lBQUEsU0FBQSxTQUFBOztBQUFBLGtCQUFVLEFBQUssS0FBQTtBQUNmLGtCQUFVLEFBQUssS0FBQTtBQUVmLGtCQUFVLEFBQU0sT0FBTixBQUFPLFFBQVEsQUFBYSxjQUE1QixBQUE2QixRQUNLLEFBQWEsY0FEL0MsQUFDZ0Q7QUFFMUQsWUFBRyxZQUFILEFBQWM7c0JBQ1QsQUFBRSxHQUFDLEFBQUUsR0FBTixBQUFPO0FBQWEsb0JBQUQsQUFBUztBQUFRLGlCQUFqQixBQUFzQjtBQUFLLG1CQUEzQixBQUFrQztBQUFPLHFCQUF6QyxBQUFrRDtBQUFTLGtCQUEzRCxBQUFpRTtBQUFTLDJCQUExRSxBQUF5RjtBQUFXLG1CQUF2SCxBQUFtQixBQUEyRztBQUEzRyxXQUFuQixBQUFDLEVBQ2tCLEFBQUMsS0FEcEIsQUFDb0IsYUFEcEIsQUFFbUIsU0FIdkIsQUFDSSxBQUdtQjtBQUp2QixlQUFBO2lCQU1JLFFBQUEsQUFBUSxHQU5aLEFBTUksQUFBVztBQWJKO0FBZWYsQUFBYTs7O2tDQUFBLEFBQUMsS0FBRCxBQUFNOztBQUNmLFlBQUcsQUFBRyxJQUFILEFBQUksUUFBUyxBQUFHLElBQUMsQUFBSSxLQUFSLEFBQVMsV0FBekIsQUFBbUM7aUJBQy9CLFFBQUEsQUFBUSxHQURaLEFBQ0ksQUFBVztBQURmLG1CQUVRLEFBQUcsSUFBTixBQUFPO0FBQ1IsQUFBQyxlQUFBLEFBQUUsR0FBQyxBQUFHLElBQVAsQUFBUSxTQUFTLEFBQUcsSUFBQyxBQUFLLE1BQVQsQUFBVSxPQUFWLEFBQWlCLE9BQU8sQUFBRyxJQUFDLEFBQUssTUFBakMsQUFBa0MsT0FBbkQsQUFBMEQ7aUJBQzFELFFBQVEsQUFBRyxJQUFDLEFBQUssTUFBakIsQUFBa0IsTUFGakIsQUFFRCxBQUF3QjtBQUZ2QixTQUFBLE1BQUE7aUJBSUQsUUFBQSxBQUFRLE9BSlAsQUFJRCxBQUFlO0FBUFY7QUF2SmpCOzs7O0lBQUEsQUFBMkM7Ozs7QUFDdkMsQUFBQyxnQkFBRCxBQUFDO0FBQ0csYUFBQSxBQUFTO0FBQ1QsaUJBQWEsQ0FEYixBQUNhLEFBQUM7QUFDZCxlQUZBLEFBRVc7QUFGWDs7QUFJSixZQUFTLG1CQUNMO1FBQUEsU0FBQSxZQUFBLGlCQUFBLFdBQUEsZ0JBQUEsTUFBQSxNQUFBLFFBQUE7QUFBQSxBQUFHLFFBQUgsQUFBSSxnQkFBZ0IsbUNBQUEsQUFDb0IsNkJBRHBCLEFBRUEsa0RBRnBCLEFBR2dDO0FBRWhDLGNBQVUsQUFBUSxTQUFSLEFBQVMsY0FBVCxBQUF1QjtBQUNqQyxBQUFPLFlBQVAsQUFBUSxLQUFLO0FBRWIsV0FBTyxBQUFRLFNBQVIsQUFBUyxjQUFULEFBQXVCO0FBRTlCLGtCQUFjLEFBQVEsU0FBUixBQUFTLGNBQVQsQUFBdUI7QUFDckMsQUFBVyxnQkFBWCxBQUFZLFlBQVk7QUFFeEIsYUFBUyxBQUFRLFNBQVIsQUFBUyxjQUFULEFBQXVCO0FBQ2hDLEFBQU0sV0FBTixBQUFPLGFBQVAsQUFBb0IsUUFBcEIsQUFBNEI7QUFDNUIsQUFBTSxXQUFOLEFBQU8sS0FBSztBQUVaLGlCQUFhLEFBQVEsU0FBUixBQUFTLGNBQVQsQUFBdUI7QUFDcEMsQUFBVSxlQUFWLEFBQVcsYUFBWCxBQUF3QixRQUF4QixBQUFnQztBQUNoQyxBQUFVLGVBQVYsQUFBVyxLQUFLO0FBRWhCLHNCQUFrQixBQUFRLFNBQVIsQUFBUyxjQUFULEFBQXVCO0FBQ3pDLEFBQWUsb0JBQWYsQUFBZ0IsWUFBWTtBQUU1QixBQUFJLFNBQUosQUFBSyxZQUFMLEFBQWlCO0FBQ2pCLEFBQUksU0FBSixBQUFLLFlBQUwsQUFBaUI7QUFDakIsQUFBSSxTQUFKLEFBQUssWUFBTCxBQUFpQjtBQUNqQixBQUFJLFNBQUosQUFBSyxZQUFMLEFBQWlCO0FBRWpCLFdBQU8sQUFBUSxTQUFSLEFBQVMsY0FBVCxBQUF1QjtBQUU5QixxQkFBaUIsQUFBUSxTQUFSLEFBQVMsY0FBVCxBQUF1QjtBQUN4QyxBQUFjLG1CQUFkLEFBQWUsWUFBWTtBQUUzQixnQkFBWSxBQUFRLFNBQVIsQUFBUyxjQUFULEFBQXVCO0FBQ25DLEFBQVMsY0FBVCxBQUFVLGFBQVYsQUFBdUIsUUFBdkIsQUFBK0I7QUFDL0IsQUFBUyxjQUFULEFBQVUsS0FBSztBQUVmLEFBQUksU0FBSixBQUFLLFlBQUwsQUFBaUI7QUFDakIsQUFBSSxTQUFKLEFBQUssWUFBTCxBQUFpQjtBQUVqQixBQUFPLFlBQVAsQUFBUSxZQUFSLEFBQW9CO0FBQ3BCLEFBQU8sWUFBUCxBQUFRLFlBQVIsQUFBb0IsQUFFcEI7V0E3Q0ssQUE2Q0U7OztBQXVCWCxrQkFBZ0I7O0FBZWhCLGdCQUFjO1dBQ1YsQUFBYSxjQUFiLEFBQWMsU0FBUyxJQUFBLEFBQUksT0FBTyxBQUFhLGNBQXhCLEFBQXlCLFNBQ2hDLEFBQU0sT0FBSSxBQUFhLGNBQWhCLEFBQWlCLGFBQWpCLEFBQWlDLE1BRjlDLEFBQ2EsQUFDRCxBQUEyQzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNsSHpFLElBQUE7SUFBQTtJQUFBOzs7O0FBa0JBOztlQUFXLFFBQVgsQUFBVyxBQUFROztBQUFuQixBQUFDOzs7TUFHSyxBQUFNLE9BQUMsQUFBTyxRQUFDO0FBQXJCLE1BQUE7Ozs7Ozs7O0FBaUJJLFlBQUEsYUFBQSxNQUFBO0FBV0EsWUFBQSxtQkFBQSxNQUFBO0FBT0EsWUFBQSx3QkFBQSxNQUFBO0FBeUJBLFlBQUEsZUFBQSxNQUFBO0FBb0VBLFlBQUEsVUFBQSxNQUFBO0FBa0RBLFlBQUEsZ0JBQUEsTUFBQTtBQXFDQSxZQUFBLGNBQUEsTUFBQTs7QUF0TUEsQUFBWTs7OztpQ0FBQSxBQUFDLE9BQUQsQUFBUSxLQUVoQjtZQUFBLFFBQUE7K0JBQUE7O0FBQUEsWUFBRyxRQUFILEFBQVU7QUFDTixtQkFBUyxBQUFDLEtBQUEsQUFBRSxHQUFDLEFBQVEsU0FBWixBQUFhLGVBQWIsQUFBNEI7QUFDckMsc0JBQVksQUFBTyxPQUFBO0FBQ25CLGdCQUFNLEFBQUMsS0FBQSxBQUFFLEdBQUMsQUFBUSxTQUFaLEFBQWEsb0JBQW9CLEFBQU8sT0FIbEQsQUFHVSxBQUF3QztBQUhsRCxlQUFBO0FBS0ksc0JBTEosQUFLZ0I7QUFFaEI7ZUFBTyxDQUFBLEFBQUMsV0FUQSxBQVNELEFBQVk7QUFFdkIsQUFBa0I7Ozt1Q0FBQSxBQUFDOytCQUVmOztBQUFBLFlBQUcsY0FBSCxBQUFnQixZQUNaO2lCQUFPLEFBQUMsS0FBQSxBQUFFLEdBQUMsQUFBUSxTQUR2QixBQUNXLEFBQWE7QUFEeEIsZUFBQSxBQUdJO2lCQUhKLEFBR1c7QUFMRztBQU9sQixBQUF1Qjs7OzRDQUFBLEFBQUM7K0JBRXBCOztBQUFBLFlBQUcsbUJBQUgsQUFBcUIsWUFDakI7aUJBQU8sQUFBQyxLQUFBLEFBQUUsR0FBQyxBQUFRLFNBRHZCLEFBQ1csQUFBYTtBQUR4QixlQUFBLEFBR0k7aUJBSEosQUFHVztBQUxRO0FBT3ZCLEFBQWE7OztrQ0FBQSxBQUFDLFVBQ1Y7WUFBQSxRQUFBLFdBQUEsZ0JBQUEsS0FBQSxPQUFBO0FBQUEsZ0JBQVEsQUFBQyxLQUFBLEFBQUUsR0FBQyxBQUFNLE9BQVYsQUFBVztBQUVuQixpQkFBUyxBQUFDLEtBQUQsQUFBQyxXQUFELEFBQVksT0FBTyxBQUFDLEtBQUEsQUFBSSxLQUF4QixBQUF5QjtBQUNsQyxvQkFBWSxBQUFPLE9BQUE7QUFDbkIsY0FBTSxBQUFPLE9BQUE7QUFFYixvQkFBWSxBQUFDLEtBQUQsQUFBQyxpQkFBaUIsQUFBQyxLQUFBLEFBQUksS0FBdkIsQUFBd0I7QUFDcEMseUJBQWlCLEFBQUMsS0FBRCxBQUFDLHNCQUFzQixBQUFDLEtBQUEsQUFBSSxLQUE1QixBQUE2QjtBQUU5QyxBQUFDLGFBQUEsQUFBRSxHQUFDLEFBQUcsSUFBUCxBQUFRLFFBQVIsQUFBZ0I7ZUFFaEIsQUFBQyxLQUFBLEFBQUUsR0FBQyxBQUFFLEdBQU4sQUFBTyxxQkFBUCxBQUNJLE9BQ0EsQUFBQyxLQUZMLEFBRUssY0FDRCxDQUFBLEFBQUMsS0FBRCxBQUFNLFdBQU4sQUFBaUIsZ0JBQWpCLEFBQWlDLFdBQWpDLEFBQTRDLE9BZnZDLEFBWVQsQUFHSSxBQUFtRDtBQUczRCxBQUFjOzs7bUNBQUEsQUFBQyxPQUFELEFBQVEsTUFDbEI7WUFBQSxVQUFBLEdBQUEsV0FBQSxLQUFBLE1BQUEsVUFBQSxPQUFBLFdBQUEsUUFBQSxnQkFBQSxLQUFBLE9BQUEsS0FBQSxjQUFBLE9BQUEsV0FBQTs7QUFBQSxjQUFNLEFBQUssS0FBQTtBQUNYLG9CQUFZLEFBQUssS0FBQTtBQUNqQix5QkFBaUIsQUFBSyxLQUFBO0FBQ3RCLG9CQUFZLEFBQUssS0FBQTtBQUNqQixnQkFBUSxBQUFLLEtBQUE7QUFDYixtQkFBVyxBQUFLLEtBQUE7QUFFaEIsaUJBQVMsQUFBQyxLQUFBLEFBQUUsR0FBQyxBQUFNLE9BQVYsQUFBVztBQUVwQixvQkFBWSxBQUFDLEtBQUEsQUFBRSxHQUFDLEFBQWEsY0FBakIsQUFBa0IsV0FBbEIsQUFBNkIsZ0JBQTdCLEFBQTZDLFFBQTdDLEFBQXFEO0FBRWpFLG1CQUFXLEFBQUMsS0FBQSxBQUFFLEdBQUMsQUFBRSxHQUFOLEFBQU87QUFDbEIsY0FBTSxBQUFRLFNBQVIsQUFBUyxRQUFRLG1CQUNDLEFBQUMsS0FBQSxBQUFFLEdBQUMsQUFBTSxPQUFWLEFBQVcsMkJBRFosQUFDQyxBQUFzQztBQUU5RCx1QkFBZTtBQUNmLEFBQWEscUJBQUEsQUFBRyxJQUFoQixBQUFhLEFBQUksaUJBQWlCLEFBQUMsS0FBQSxBQUFFLEdBQUMsQUFBYSxjQUFqQixBQUFrQixrQkFBbEIsQUFDRSxLQURGLEFBQ08sV0FEUCxBQUNrQixLQURsQixBQUN1QixPQUR2QixBQUVFLFFBRkYsQUFFVSxNQUZWLEFBRWdCLE1BRmhCLEFBRXNCO0FBRXhELG1CQUFXO0FBRVgsQUFBQyxhQUFBLEFBQUUsR0FBQyxBQUFHLElBQVAsQUFBUSxRQUFRLGFBQWEsQUFBQyxLQUFBLEFBQUUsR0FBQyxBQUFHLElBQVAsQUFBUSxXQUFSLEFBQW1CLEtBQWhDLEFBQWEsQUFBd0Isb0JBQXJELEFBQzREO0FBRTVELFlBQUEsQUFBRztBQUNDLGVBQUEsd0NBQUE7O0FBQ0ksb0JBQVEsQUFBUyxTQUFBLEFBQUksS0FBQyxBQUFJLEtBQVQsQUFBVTtBQUMzQixvQkFBUSxBQUFhLGFBQUEsQUFBSSxLQUFDLEFBQUksS0FBVCxBQUFVO0FBRS9CLGdCQUFHLENBQUEsQUFBSSxTQUFVLENBQWpCLEFBQXFCO0FBQ2pCLEFBQVMsdUJBQUEsQUFBSSxLQUFDLEFBQUksS0FBbEIsQUFBUyxBQUFVLGlCQUFpQixBQUFDLEtBQUEsQUFBRSxHQUFDLEFBQWEsY0FBakIsQUFBa0IsY0FDOUIsQUFBSSxLQURRLEFBQ1AsTUFBTSxBQUFJLEtBREgsQUFDSSxPQUFPLEFBQUksS0FGdkQsQUFDd0MsQUFDZ0I7QUFGeEQsdUJBR1EsU0FBVSxBQUFLLE1BQUwsQUFBTSxRQUFPLEFBQUksS0FBOUIsQUFBK0I7QUFJaEMsQUFBQyxtQkFBQSxBQUFFLEdBQUMsQUFBRyxJQUFQLEFBQVEsV0FBVyx3Q0FBQSxBQUNmLFlBQVksQUFBQyxLQUFBLEFBQUUsR0FBQyxBQUFHLElBQVAsQUFBUSxXQUFXLEFBQUksS0FBdkIsQUFBd0IsS0FBSyxPQUN6QyxBQUFJLEtBRHFDLEFBQ3BDLE9BRG9DLEFBQzdCLE1BQU0sQUFBSSxLQURtQixBQUNsQixRQUZSLEFBQ0gsQUFDbUIsUUFGaEIsQUFFd0IsVUFDdkMsQUFBQyxLQUFBLEFBQUUsR0FBQyxBQUFHLElBQVAsQUFBUSxXQUFXLEFBQUssTUFBeEIsQUFBeUIsS0FBSyxPQUFPLEFBQUksS0FBWCxBQUFZLE9BQVosQUFBbUIsTUFDakQsQUFBYSxhQUFBLEFBQUksS0FBQyxBQUFJLEtBQVQsQUFBVSxBQUFjLGVBRFAsQUFDUSxRQVJ6QyxBQUlELEFBR0ksQUFDOEM7QUFSakQsYUFBQSxNQVNBLElBQUcsU0FBVSxBQUFLLE1BQUwsQUFBTSxRQUFPLEFBQUksS0FBOUIsQUFBK0I7QUFJaEMsQUFBQyxtQkFBQSxBQUFFLEdBQUMsQUFBRyxJQUFQLEFBQVEsV0FBVyx3Q0FBQSxBQUNmLFlBQVksQUFBQyxLQUFBLEFBQUUsR0FBQyxBQUFHLElBQVAsQUFBUSxXQUFXLEFBQUksS0FBdkIsQUFBd0IsS0FBSyxPQUN6QyxBQUFJLEtBRHFDLEFBQ3BDLE9BRG9DLEFBQzdCLE1BQU0sQUFBSSxLQURtQixBQUNsQixRQUZSLEFBQ0gsQUFDbUIsUUFGaEIsQUFFd0IsVUFDdkMsQUFBQyxLQUFBLEFBQUUsR0FBQyxBQUFHLElBQVAsQUFBUSxXQUFXLEFBQUssTUFBeEIsQUFBeUIsS0FBSyxPQUFPLEFBQUksS0FBWCxBQUFZLE9BQVosQUFBbUIsTUFDakQsQUFBUyxTQUFBLEFBQUksS0FBQyxBQUFJLEtBQVQsQUFBVSxBQUFjLGVBREgsQUFDSSxRQVJyQyxBQUlELEFBR0ksQUFDMEM7QUF4QnREOztpQkEwQkEsQUFBQyxLQUFBLEFBQUUsR0FBQyxBQUFhLGNBQWpCLEFBQWtCLGFBQWxCLEFBQ0ksY0FESixBQUVJLFVBRkosQUFHSSxnQkFISixBQUlJLFdBSkosQUFLSSxPQUNBLEFBQUMsS0FOTCxBQU1LLFNBQ0QsQ0FBQSxBQUFDLEtBQUQsQUFBTSxLQUFOLEFBQVcsUUFBWCxBQUFtQixXQUFuQixBQUE4QixPQWxDdEMsQUEyQkksQUFPSSxBQUFxQztBQWxDN0MsZUFBQTtBQXFDSSxBQUFDLGVBQUEsQUFBRSxHQUFDLEFBQUcsSUFBUCxBQUFRLFFBQVIsQUFBZ0I7QUFFaEIsY0FBQSxBQUFHO21CQUFILEFBQ0k7QUF4Q1I7QUExQlU7QUFvRWQsQUFBUzs7OzhCQUFBLEFBQUMsT0FBRCxBQUFRLE1BQ2I7WUFBQSxVQUFBLE9BQUEsV0FBQSxTQUFBLFFBQUEsS0FBQTs7QUFBQSxjQUFNLEFBQUssS0FBQTtBQUNYLGNBQU0sQUFBSyxLQUFBO0FBQ1gsaUJBQVMsQUFBSyxLQUFBO0FBQ2Qsb0JBQVksQUFBSyxLQUFBO0FBQ2pCLGdCQUFRLEFBQUssS0FBQTtBQUNiLG1CQUFXLEFBQUssS0FBQTtBQUVoQixrQkFBVSxBQUFDLEtBQUEsQUFBRSxHQUFDLEFBQWEsY0FBakIsQUFBa0IsWUFBbEIsQUFBOEIsS0FBOUIsQUFBbUMsS0FBbkMsQUFBd0MsT0FBeEMsQUFBK0MsUUFBL0MsQUFDMEMsV0FEMUMsQUFDcUQ7QUFFL0QsWUFBRyxZQUFILEFBQWM7QUFDVixBQUFDLGVBQUEsQUFBRSxHQUFDLEFBQU0sT0FBVixBQUFXLFlBQVgsQUFBdUI7QUFDdkIsQUFBQyxlQUFBLEFBQUUsR0FBQyxBQUFHLElBQVAsQUFBUSxRQUZaLEFBRUksQUFBZ0I7QUFGcEIsZUFBQTtBQUlJLEFBQUMsZUFBQSxBQUFFLEdBQUMsQUFBRyxJQUFQLEFBQVEsUUFKWixBQUlJLEFBQWdCOztBQUVwQixZQUFBLEFBQUc7aUJBQUgsQUFDSTtBQWxCQztBQW9CVCxBQUFVOzs7K0JBQUEsQUFBQyxPQUFELEFBQVEsU0FBUixBQUFpQixXQUN2QjtZQUFBLFFBQUEsVUFBQSxXQUFBLFNBQUEsZ0JBQUEsS0FBQSxLQUFBLGNBQUEsV0FBQTtBQUFBLGlCQUFTLEFBQUMsS0FBRCxBQUFDLFdBQUQsQUFBWSxPQUFPLEFBQUMsS0FBQSxBQUFJLEtBQXhCLEFBQXlCO0FBQ2xDLG9CQUFZLEFBQU8sT0FBQTtBQUNuQixjQUFNLEFBQU8sT0FBQTtBQUViLG9CQUFZLEFBQUMsS0FBRCxBQUFDLGlCQUFpQixBQUFDLEtBQUEsQUFBSSxLQUF2QixBQUF3QjtBQUNwQyx5QkFBaUIsQUFBQyxLQUFELEFBQUMsc0JBQXNCLEFBQUMsS0FBQSxBQUFJLEtBQTVCLEFBQTZCO0FBRTlDLGtCQUFVLEFBQUMsS0FBQSxBQUFJLEtBQUM7QUFFaEIsbUJBQVcsQUFBQyxLQUFBLEFBQUUsR0FBQyxBQUFFLEdBQU4sQUFBTztBQUNsQixjQUFNLEFBQVEsU0FBUixBQUFTLFFBQVEsbUJBQ0MsQUFBQyxLQUFBLEFBQUUsR0FBQyxBQUFNLE9BQVYsQUFBVywyQkFEWixBQUNDLEFBQXNDO0FBRTlELHVCQUFlO0FBRWYsbUJBQVc7QUFDWCxBQUFTLGlCQUFBLEFBQUcsSUFBWixBQUFTLEFBQUksaUJBQWlCLEFBQUMsS0FBQSxBQUFFLEdBQUMsQUFBYSxjQUFqQixBQUFrQixjQUFsQixBQUFnQyxLQUFoQyxBQUNzQixXQUR0QixBQUNpQztlQUUvRCxBQUFDLEtBQUEsQUFBRSxHQUFDLEFBQWEsY0FBakIsQUFBa0IsYUFBbEIsQUFDSSxjQURKLEFBRUksVUFGSixBQUdJLGdCQUhKLEFBSUksV0FKSixBQUtJLE1BQ0EsQUFBQyxLQU5MLEFBTUssZUFDRCxDQUFBLEFBQUMsT0FBRCxBQUFRLEtBQVIsQUFBYSxLQUFiLEFBQWtCLFNBM0JoQixBQW9CTixBQU9JLEFBQTJCO0FBR25DLEFBQWU7OztvQ0FBQSxBQUFDLE9BQUQsQUFBUSxNQUNuQjtZQUFBLFNBQUEsV0FBQSxPQUFBLFdBQUEsT0FBQSxTQUFBLFFBQUEsU0FBQSxLQUFBLFdBQUEsT0FBQTs7QUFBQSxnQkFBUSxBQUFLLEtBQUE7QUFDYixjQUFNLEFBQUssS0FBQTtBQUNYLGNBQU0sQUFBSyxLQUFBO0FBQ1gsa0JBQVUsQUFBSyxLQUFBO0FBQ2Ysa0JBQVUsQUFBSyxLQUFBO0FBRWYsZ0JBQVEsQUFBRyxJQU5YLEFBTVEsQUFBSTs7QUFJWixnQkFBUSxBQUFNLE1BQUEsQUFBTSxPQUFDO0FBQ3JCLGlCQUFTLEFBQU0sTUFBQSxBQUFNLE9BQUM7QUFDdEIsb0JBQVksQUFBTSxNQUFBLEFBQU0sT0FBQztBQUN6QixvQkFBWSxBQUFNLE1BQUEsQUFBTSxPQUFDO0FBQ3pCLG9CQUFZLEFBQU0sTUFBQSxBQUFNLE9BQUM7QUFFekIsa0JBQVUsQUFBQyxLQUFBLEFBQUUsR0FBQyxBQUFhLGNBQWpCLEFBQWtCLFlBQWxCLEFBQThCLEtBQTlCLEFBQW1DLEtBQW5DLEFBQXdDLE9BQXhDLEFBQStDLFFBQS9DLEFBQzBDLFdBRDFDLEFBQ3FEO0FBRS9ELFlBQUcsWUFBSCxBQUFjO3NCQUNULEFBQUUsR0FBQyxBQUFFLEdBQU4sQUFBTztBQUNGLG9CQURjLEFBQ047QUFDUixpQkFGYyxBQUVUO0FBQ0wsbUJBSGMsQUFHUDtBQUNQLHFCQUpjLEFBSUw7QUFDVCxrQkFMYyxBQUtSO0FBQ04sMkJBTmMsQUFNQztBQUNmLG1CQVBMLEFBQW1CLEFBT1A7QUFQTyxXQUFuQixBQUFDLEVBU0csQUFBQyxLQVRMLEFBU0ssYUFUTCxBQVVJLFNBWFIsQUFDSSxBQVdJO0FBWlIsZUFBQTtpQkFlSSxRQUFBLEFBQVEsR0FmWixBQWVJLEFBQVc7QUFuQ0o7QUFxQ2YsQUFBYTs7O2tDQUFBLEFBQUMsS0FBRCxBQUFNOztBQUNmLFlBQUcsQUFBRyxJQUFILEFBQUksUUFBUyxBQUFHLElBQUMsQUFBSSxLQUFSLEFBQVMsV0FBekIsQUFBbUM7aUJBQy9CLFFBQUEsQUFBUSxHQURaLEFBQ0ksQUFBVztBQURmLG1CQUVRLEFBQUcsSUFBTixBQUFPO0FBQ1IsQUFBQyxlQUFBLEFBQUUsR0FBQyxBQUFHLElBQVAsQUFBUSxTQUFTLEFBQUcsSUFBQyxBQUFLLE1BQVQsQUFBVSxPQUFWLEFBQWlCLE9BQU8sQUFBRyxJQUFDLEFBQUssTUFBakMsQUFBa0MsT0FBbkQsQUFBMEQ7aUJBQzFELFFBQVEsQUFBRyxJQUFDLEFBQUssTUFBakIsQUFBa0IsTUFGakIsQUFFRCxBQUF3QjtBQUZ2QixTQUFBLE1BQUE7aUJBSUQsUUFBQSxBQUFRLE9BSlAsQUFJRCxBQUFlO0FBUFY7QUF2TmpCOzs7O0lBQUEsQUFBMkQ7Ozs7QUFDdkQsQUFBQyxnQ0FBRCxBQUFDO0FBQ0csYUFBQSxBQUFTO0FBQ1QsaUJBQWEsQ0FBQSxBQUFDLGlCQURkLEFBQ2EsQUFBa0I7QUFDL0IsZUFGQSxBQUVXO0FBQ1gsa0JBSEEsQUFHYztBQUNkLG1CQUFlLENBSmYsQUFJZSxBQUFDO0FBQ2hCLG9CQUFnQixDQUxoQixBQUtnQixBQUFDO0FBQ2pCLGtCQU5BLEFBTWM7QUFOZDs7QUFPSixBQUFDLGdDQUFELEFBQUM7QUFDRztBQUNJLG9CQUFBLEFBQWM7QUFDZCxxQkFEQSxBQUNlO0FBQ2Ysc0JBSEosQUFDSSxBQUVnQjtBQUZoQjtBQUdKO0FBQ0ksZUFMSixBQUtJLEFBQVM7QUFBVDtBQUxKOzs7Ozs7Ozs7Ozs7Ozs7O0FDL0JSLElBQUE7SUFBQTtJQUFBO0lBQUE7Ozs7O2lCQWtCQTs7ZUFBVyxRQUFYLEFBQVcsQUFBUTs7QUFBbkIsQUFBQzs7O0FBRUQsTUFBTSxRQUFBLEFBQVE7O01BR1IsQUFBTSxPQUFDLEFBQU8sUUFBQztBQUFyQixNQUFBOzs7Ozs7OztBQW1DSSxZQUFBLGVBQUEsTUFBQTtBQW1CQSxZQUFBLFVBQUEsTUFBQTtBQU9BLFlBQUEsYUFBQSxNQUFBO0FBK0JBLFlBQUEsd0JBQUEsTUFBQTtBQVdBLFlBQUEsa0JBQUEsTUFBQTtBQXFDQSxZQUFBLDJCQUFBLE1BQUE7QUFnQ0EsWUFBQSxxQkFBQSxNQUFBO0FBT0EsWUFBQSxnQkFBQSxNQUFBO0FBVUEsWUFBQSxXQUFBLE1BQUE7QUEyQkEsWUFBQSxhQUFBLE1BQUE7O0FBMU1BLEFBQWM7Ozs7bUNBQUEsQUFBQztlQUNYLEFBQUMsS0FBRCxBQUFDLGFBQWEsQ0FBZCxBQUFlLEdBREwsQUFDVixBQUFrQjtBQUV0QixBQUFjOzs7bUNBQUEsQUFBQyxRQUFELEFBQVMsVUFDbkI7WUFBQSxRQUFBLE9BQUEsZ0JBQUE7QUFBQTtBQUNBLGtCQUFVLEFBQUMsS0FBQSxBQUFJLEtBQUM7QUFDaEIseUJBQWlCLEFBQUMsS0FBQSxBQUFJLEtBQUM7QUFDdkIsZ0JBQVEsQUFBQyxLQUFBLEFBQUksS0FBQyxBQUFNLE1BQUE7QUFDcEIsWUFBQSxBQUFHO0FBQ0MsY0FBRyxBQUFDLEVBQUQsQUFBRSxLQUFGLEFBQU8sV0FBVixBQUFvQjtBQUNoQixxQkFBUyxBQUFDLEtBQUEsQUFBRSxHQUFDLEFBQVEsU0FBWixBQUFhLG1CQUQxQixBQUNhLEFBQWdDO0FBRDdDLGlCQUFBO0FBSUkscUJBSkosQUFJYTs7aUJBRWIsQUFBQyxLQUFBLEFBQUUsR0FBQyxBQUFFLEdBQU4sQUFBTyxVQUFVLEFBQUksS0FBckIsQUFBc0IsY0FBYyxDQUFBLEFBQUMsUUFBRCxBQUFTLGdCQUFULEFBQXlCLFNBQXpCLEFBQ0MsVUFSekMsQUFPSSxBQUFvQyxBQUNXO0FBUm5ELGVBVUssSUFBQSxBQUFHO2lCQUFILEFBQ0Q7QUFoQk07QUFrQmQsQUFBYzs7O21DQUFBLEFBQUMsU0FBRCxBQUFVOztvQkFDcEIsQUFBQztBQUNHLGtCQUFRLEFBQUssS0FEUixBQUNRO0FBQ2IsdUJBQWEsQUFBRyxVQUFILEFBQWdCLFFBRnhCLEFBRW1DO0FBQ3hDLHFCQUhLLEFBR007QUFDWCxxQkFKSyxBQUlNO0FBQ1gsa0JBTEssQUFLRztBQUNSLG1CQU5LLEFBTUk7QUFDVCxpQkFQSyxBQU9FO0FBQ1Asb0JBUkssQUFRSztBQUNWLHFCQVRLLEFBU007QUFDWCxtQkFWSyxBQVVJO0FBQ1Qsb0JBWEssQUFXSztBQUNWLDBCQUFnQixBQUFLLEtBWmhCLEFBWWdCO0FBQ3JCLG1CQUFTLEFBQUssS0FiVCxBQWFTO0FBQ2Qsb0JBQVUsQUFBSyxLQWRWLEFBY1U7QUFDZixrQkFBUSxBQUFLLEtBaEJQLEFBQ1YsQUFBUyxBQWVRO0FBZlIsU0FBVCxBQUFDO0FBa0JMLEFBQVM7Ozs4QkFBQSxBQUFDOztBQUNOLEFBQUMsYUFBQSxBQUFFLEdBQUMsQUFBRyxJQUFQLEFBQVEsUUFBUSxjQUFjLEFBQUMsS0FBQSxBQUFFLEdBQUMsQUFBRyxJQUFQLEFBQVEsZUFBZSxBQUFJLEtBQUMsQUFBTSxPQUFsQyxBQUFtQyxNQUN6QixBQUFJLEtBQUMsQUFBTSxPQURuQyxBQUFjLEFBQ3NCLFFBRHBELEFBQzREO2VBQzVELEFBQUMsS0FBQSxBQUFFLEdBQUMsQUFBRSxHQUFOLEFBQU8sY0FBYyxBQUFJLEtBQUMsQUFBTSxPQUFoQyxBQUFpQyxNQUNiLEFBQUMsS0FEckIsQUFDcUIsWUFKaEIsQUFHTCxBQUVvQjtBQUV4QixBQUFZOzs7aUNBQUEsQUFBQyxPQUFELEFBQVEsUUFBUixBQUFnQixXQUFoQixBQUEyQixXQUEzQixBQUFzQyxNQUM5QztZQUFBLEtBQUEsYUFBQSxLQUFBOztBQUFBLEFBQUksYUFBSixBQUFLLFNBQVM7QUFDZCxBQUFJLGFBQUosQUFBSyxZQUFZO0FBQ2pCLEFBQUksYUFBSixBQUFLLFlBQVk7QUFFakIsY0FBTSxJQUFBLEFBQUk7QUFDVixzQkFBYyxBQUFJLEtBQUosQUFBSyxNQUFNLEFBQUksS0FBZixBQUFnQjtBQUM5QixZQUFHLEFBQUcsSUFBSCxBQUFJLFlBQUosQUFBZ0IsZUFBZSxBQUFJLEtBQXRDLEFBQXVDO0FBQ25DLGtCQUFRLEFBQUksS0FBQyxBQUFNLE9BQVgsQUFBWSxRQUFRLEFBQUksS0FBeEIsQUFBeUI7QUFDakMsZ0JBQU0sQUFBSSxLQUFDLEFBQU0sT0FBWCxBQUFZLFlBQVksQUFBSSxLQUE1QixBQUE2QjtBQUVuQyxjQUFHLFFBQVEsQ0FBUixBQUFTLEtBQU0sTUFBTSxDQUF4QixBQUF5QjtBQUNyQixBQUFJLGlCQUFKLEFBQUssVUFBVSxRQUFRLEFBQUksS0FBQyxBQUFTLFVBQUM7QUFDdEMsQUFBSSxpQkFBSixBQUFLLFFBQVE7QUFDYixBQUFJLGlCQUFKLEFBQUssV0FBVztBQUNoQixBQUFJLGlCQUFKLEFBQUssV0FBYyxBQUFJLEtBQUMsQUFBTSxPQUFkLEFBQWUsY0FBaUIsQUFBQyxLQUFELEFBQUMsc0JBQXNCLEFBQUksS0FBM0QsQUFBZ0MsQUFBNEIsVUFBYTt3QkFDeEYsQUFBRSxHQUFDLEFBQUcsSUFBUCxBQUFRO0FBQ0osb0JBQU0sQUFBSSxLQUFDLEFBQU0sT0FERCxBQUNFO0FBQ2xCLHdCQUFVLEFBQUMsS0FGSyxBQUVMO0FBQ1gsdUJBQVMsQUFBQyxLQUhNLEFBR047QUFDVix3QkFUUixBQUtJLEFBQW9CLEFBSU47QUFKTSxhQUFwQixBQUFDO0FBTEwsaUJBQUE7QUFZSSxBQUFDLGlCQUFBLEFBQUUsR0FBQyxBQUFHLElBQVAsQUFBUSxTQUFTLG9DQUNiLEFBQUMsS0FBQSxBQUFFLEdBQUMsQUFBRyxJQUFQLEFBQVEsZUFBZSxBQUFJLEtBQUMsQUFBTSxPQUFsQyxBQUFtQyxNQUFNLEFBQUksS0FBQyxBQUFNLE9BRHhELEFBQ0ksQUFBcUQ7bUJBQ3pELEFBQUMsS0FBRCxBQUFDLGFBQWEsQUFBSSxLQUFsQixBQUFtQixRQUFRLEFBQUksS0FkbkMsQUFjSSxBQUFnQztBQWxCeEM7QUFBQSxlQUFBO0FBb0JJLEFBQUMsZUFBQSxBQUFFLEdBQUMsQUFBRyxJQUFQLEFBQVEsV0FBVyxBQUFDLEtBQUEsQUFBRSxHQUFDLEFBQUcsSUFBUCxBQUFRLGVBQWUsQUFBSSxLQUFDLEFBQU0sT0FBbEMsQUFBbUMsTUFDMUMsQUFBSSxLQUFDLEFBQU0sT0FESixBQUNLLFFBRHhCLEFBQ2dDO2lCQUNoQyxBQUFDLEtBQUQsQUFBQyxhQUFhLEFBQUksS0FBbEIsQUFBbUIsUUFBUSxBQUFJLEtBdEJuQyxBQXNCSSxBQUFnQztBQTdCNUI7QUErQlosQUFBdUI7Ozs0Q0FBQSxBQUFDLFFBQ3BCO1lBQUEsTUFBQSxPQUFBOztBQUFBLGVBQU87QUFDUCxpQkFBUyxBQUNUO2VBQUEsQUFBTTtBQUNGLGtCQUFRLEFBQU0sT0FBTixBQUFPLEtBQVAsQUFBWTtBQUNwQixjQUFBLEFBQUc7QUFDQyxBQUFLLGlCQUFBLEFBQU0sTUFBQSxBQUFFLEdBQWIsQUFBSyxBQUFTLGlCQUFpQixBQUFNLE1BRHpDLEFBQ3lDO0FBRHpDLGlCQUFBLEFBR0k7QUFISjtBQUZKO0FBTUE7ZUFUbUIsQUFTWjtBQUVYLEFBQWlCOzs7c0NBQUEsQUFBQyxRQUNkO1lBQUEsU0FBQSxNQUFBLFNBQUEsR0FBQSxNQUFBLE1BQUE7O0FBQUEsZUFBTyxBQUFNLE9BQUM7QUFFZCxBQUFDLGFBQUEsQUFBRSxHQUFDLEFBQUcsSUFBUCxBQUFRLFFBQVEsZ0JBQWdCLEFBQUMsS0FBQSxBQUFFLEdBQUMsQUFBRyxJQUFQLEFBQVEsZUFBZSxBQUFNLE9BQTdCLEFBQThCLE1BQ2QsQUFBTSxPQUR0QyxBQUFnQixBQUN1QixRQUR2RCxBQUMrRDtBQUUvRCxlQUFPO0FBRVAsYUFBSSwwRkFBSjtBQUNJLGtCQUFRLEFBQUksS0FBQyxBQUFNLE9BRHZCLEFBQ3dCOztBQUV4QixZQUFHLEFBQUksS0FBQyxBQUFNLE9BQWQsQUFBZTtBQUNYLG9CQUFVO0FBQ1YsaUJBQU8sQUFDUDtpQkFBTSxBQUFJLEtBQUosQUFBSyxnQkFBWCxBQUEwQjtBQUN0QixBQUFPLG9CQUFQLEFBQVEsS0FBSyxBQUFJLEtBQUosQUFBSyxlQUFsQixBQUFpQztBQUNqQyxtQkFBTyxBQUFNLE9BQUMsQUFBVSxVQUFBLEFBQUksS0FGaEMsQUFFNEIsQUFBSzs7QUFDakMsY0FBRyxBQUFPLFFBQVYsQUFBVztBQUNQLG9CQUFRLFlBQVksQUFBTyxRQUFQLEFBQVEsQUFBUyxVQUFqQixBQUFrQixLQUE5QixBQUFZLEFBQXVCLE9BRC9DLEFBQ3NEO0FBUDFEOztBQVNBLGtCQUFhLEFBQUksS0FBQyxBQUFTLFNBQUEsQUFBTSxPQUFDLEFBQUksS0FBNUIsQUFBaUIsQUFBWSxpQkFBb0IsQUFBSSxLQUFDLEFBQVMsU0FBQSxBQUFNLE9BQUMsQUFBSSxLQUExRSxBQUErRCxBQUFZLGlCQUFvQjtBQUN6RyxnQkFBUSxBQUFDLEtBQUQsQUFBQyxjQUFjLEFBQU0sT0FBckIsQUFBc0IsTUFBTSxBQUFJLEtBQUMsQUFBTSxPQUF2QyxBQUF3QyxTQUF4QyxBQUFpRDtBQUV6RCxnQkFBVyxBQUFJLEtBQUMsQUFBTSxPQUFkLEFBQWUsY0FBZixBQUFnQyxXQUFjO0FBRXRELFlBQUcsQUFBTSxPQUFOLEFBQU8sYUFBVixBQUFzQjtBQUNsQixrQkFBUTtBQUNSLEFBQUMsZUFBQSxBQUFFLEdBQUMsQUFBRyxJQUFQLEFBQVEsV0FBVyxhQUFhLEFBQUMsS0FBQSxBQUFFLEdBQUMsQUFBRyxJQUFQLEFBQVEsZUFBZSxBQUFNLE9BQTdCLEFBQThCLE1BQ1YsQUFBTSxPQUQxRCxBQUFnQyxBQUMyQjtpQkFDM0QsQUFBQyxLQUFELEFBQUMsbUJBQUQsQUFBb0IsUUFBcEIsQUFBNEIsTUFKaEMsQUFJSSxBQUFrQztBQUp0QyxlQUFBO2lCQU1JLEFBQUMsS0FBQSxBQUFFLEdBQUMsQUFBRyxJQUFQLEFBQVEsa0JBQ0osQUFBTSxPQURWLEFBQ1csTUFDUCxBQUFDLEtBRkwsQUFFSywwQkFDRCxDQUFBLEFBQUMsUUFBRCxBQUFTLE1BQVQsQUFBZSxNQVR2QixBQU1JLEFBR0ksQUFBcUI7QUFsQ2hCO0FBcUNqQixBQUEwQjs7OytDQUFBLEFBQUMsU0FBRCxBQUFVLE1BQVYsQUFBZ0IsT0FDdEM7WUFBQSxhQUFBLFNBQUEsTUFBQSxZQUFBLEdBQUEsR0FBQSxHQUFBLEtBQUEsTUFBQSxLQUFBLFFBQUEsY0FBQTs7QUFBQSxpQkFBUyxBQUFNLE1BQUE7QUFDZixlQUFPLEFBQU0sTUFBQTtBQUNiLGVBQU8sQUFBTSxNQUFBO0FBQ2Isa0JBQVUsQUFBTSxNQUFBO0FBRWhCLHFCQUFhLEFBQU0sT0FBQyxBQUFVLFVBQUEsQUFBTSxPQUFDLEFBQVMsVUFBaEIsQUFBaUIsU0FBakIsQUFBMEI7QUFDeEQsc0JBQWM7QUFDZCxnQkFBUSxBQUFhLGNBQUMsQUFBRyxPQUFVLEFBQUksS0FBakIsQUFBa0IsUUFBaEMsQUFBYSxBQUE4QixLQVBuRCxBQU93RDs7QUFLeEQsWUFBRyxjQUFjLEFBQUksS0FBckIsQUFBc0I7QUFDbEIsZUFBQSxzQ0FBQTs7QUFDSSxnQkFBRyxlQUFjLEFBQUcsSUFBakIsQUFBa0IsU0FBVSxBQUFJLEVBQUMsYUFBQSxBQUFZLEtBQVosYUFBcEMsQUFBbUM7QUFDL0IsQUFBVywwQkFBWCxBQUFZLEtBRGhCLEFBQ0ksQUFBaUI7QUFGekI7O0FBSUEsY0FBRyxBQUFXLFlBQWQsQUFBZTtBQUNYLDJCQUFlO0FBQ2YsaUJBQUEsNENBQUE7O0FBQ0ksd0JBQWEsQUFBSSxLQUFDLEFBQVMsU0FBQSxBQUFZLFlBQUEsQUFBRSxHQUFDLEFBQUssTUFBckMsQUFBaUIsQUFBcUIsaUJBQW9CLEFBQUksS0FBQyxBQUFTLFNBQUEsQUFBWSxZQUFBLEFBQUUsR0FBQyxBQUFLLE1BQTVGLEFBQXdFLEFBQXFCLGlCQUFvQjtBQUMzSCxBQUFZLDJCQUFaLEFBQWEsS0FBSyxBQUFDLEtBQUQsQUFBQyxjQUFjLEFBQVksWUFBQSxBQUFFLEdBQTdCLEFBQThCLE9BQ3BCLEFBQUksS0FBQyxBQUFNLE9BRHJCLEFBQ3NCLFNBSDVDLEFBRUksQUFBa0IsQUFDK0I7O0FBRXJELG9CQUFRLE9BQU8sQUFBSSxLQUFDLEFBQU0sT0FBbEIsQUFBbUIsU0FBbkIsQUFBNEIsTUFDSixBQUFZLGFBQVosQUFBYSxLQURyQyxBQUN3QixBQUFrQixRQVJ0RCxBQVE4RDtBQWJsRTs7QUFlQSxnQkFBUTtlQUVSLEFBQUMsS0FBRCxBQUFDLG1CQUFELEFBQW9CLFFBQXBCLEFBQTRCLE1BOUJOLEFBOEJ0QixBQUFrQztBQUV0QyxBQUFvQjs7O3lDQUFBLEFBQUMsUUFBRCxBQUFTLE1BQVQsQUFBZTs7QUFDL0IsQUFBSSxhQUFKLEFBQUssWUFBWTtBQUVqQixBQUFNLGVBQU4sQUFBTyxXQUFXO2VBRWxCLEFBQUMsS0FBQSxBQUFFLEdBQUMsQUFBRyxJQUFQLEFBQVEsb0JBTFEsQUFLaEIsQUFBNEI7QUFFaEMsQUFBZTs7O29DQUFBLEFBQUMsS0FBRCxBQUFNLFNBQU4sQUFBZSxTQUMxQjtZQUFBLFNBQUE7O0FBQUEsWUFBQSxBQUFHO0FBQ0Msb0JBREosQUFDYztBQURkLG1CQUVLLEFBQUc7QUFDSixtQkFBUyxJQUFBLEFBQUksT0FBTyxBQUFRLFFBQW5CLEFBQW1CLElBQUksQUFBUSxRQUEvQixBQUErQjtBQUN4QyxvQkFBVSxBQUFHLElBQUgsQUFBSSxPQUFKLEFBQVcsQUFBRSxHQUFiLEFBQWMsUUFBZCxBQUFzQixRQUFRLEFBQVEsUUFGL0MsQUFFUyxBQUFzQztBQUYvQyxTQUFBLE1BQUE7QUFJRCxvQkFBVSxBQUFHLElBQUgsQUFBSSxPQUpiLEFBSVMsQUFBVztBQUN6QjtlQUFPLFFBQUEsQUFBUSxNQUFSLEFBQWMsTUFBZCxBQUFvQixVQVJoQixBQVEwQjtBQUV6QyxBQUFVOzs7K0JBQUEsQUFBQyxRQUNQO1lBQUEsTUFBQTs7QUFBQSxlQUFPLEFBQU0sT0FBQztBQUVkLEFBQUksYUFBSixBQUFLLFdBQVcsT0FBTyxBQUFJLEtBQUM7QUFDNUIsa0JBQVUsQUFBRyxJQUFILEFBQUksaUJBQWlCLEFBQUksS0FBekIsQUFBMEIsUUFBUSxBQUFJLEtBQXRDLEFBQXVDLFVBQ0wsQUFBSSxLQUR0QyxBQUN1QyxTQUFTLEFBQUksS0FEcEQsQUFDcUQ7QUFFL0QsWUFBRyxZQUFXLEFBQUksS0FBbEIsQUFBbUI7c0JBQ2QsQUFBRSxHQUFDLEFBQUUsR0FBTixBQUFPO0FBQ0Msb0JBRFcsQUFDSDtBQUNSLGlCQUZXLEFBRU47QUFDTCxtQkFIVyxBQUdKO0FBQ1AsbUJBQU8sQUFBSSxLQUFDLEFBQU0sT0FKUCxBQUlRO0FBQ25CLHFCQUFTLEFBQUksS0FMRixBQUtHO0FBQ2Qsa0JBTlcsQUFNTDtBQUNOLDJCQUFlLEFBQUksS0FQUixBQU9TO0FBQ3BCLG1CQUFPLEFBQUksS0FSbkIsQUFBbUIsQUFRQztBQVJELFdBQW5CLEFBQUMsRUFVRyxBQUFDLEtBVkwsQUFVSyxZQVZMLEFBV0ksTUFaUixBQUNJLEFBWUk7QUFiUixlQUFBO0FBZUksQUFBQyxlQUFBLEFBQUUsR0FBQyxBQUFHLElBQVAsQUFBUSxRQUFRLEFBQUMsS0FBQSxBQUFFLEdBQUMsQUFBRyxJQUFQLEFBQVEsZUFBZSxBQUFJLEtBQUMsQUFBTSxPQUFsQyxBQUFtQyxNQUMvQixBQUFJLEtBQUMsQUFBTSxPQURmLEFBQ2dCLFFBRGhDLEFBQ3dDO2lCQUV4QyxBQUFDLEtBQUQsQUFBQyxhQUFhLEFBQUksS0FBbEIsQUFBbUIsUUFBUSxBQUFJLEtBbEJuQyxBQWtCSSxBQUFnQztBQXpCOUI7QUEyQlYsQUFBWTs7O2lDQUFBLEFBQUMsS0FBRCxBQUFNOztBQUNkLFlBQUcsQUFBRyxJQUFILEFBQUksUUFBUyxBQUFHLElBQUMsQUFBSSxLQUFSLEFBQVMsV0FBekIsQUFBbUM7QUFDL0IsQUFBQyxlQUFBLEFBQUUsR0FBQyxBQUFHLElBQVAsQUFBUSxRQUFRLEFBQUMsS0FBQSxBQUFFLEdBQUMsQUFBRyxJQUFQLEFBQVEsZUFBZSxBQUFJLEtBQUMsQUFBTSxPQUFsQyxBQUFtQyxNQUMzQixBQUFJLEtBQUMsQUFBTSxPQURuQixBQUNvQixRQURwQyxBQUM0QztpQkFFNUMsQUFBQyxLQUFELEFBQUMsYUFBYSxBQUFJLEtBQWxCLEFBQW1CLFFBQVEsQUFBSSxLQUpuQyxBQUlJLEFBQWdDO0FBSnBDLGVBQUE7aUJBT0ksQUFBQyxLQUFBLEFBQUUsR0FBQyxBQUFHLElBQVAsQUFBUSxTQUFTLEFBQUMsS0FBQSxBQUFFLEdBQUMsQUFBRyxJQUFQLEFBQVEsZUFBZSxBQUFJLEtBQUMsQUFBTSxPQUFsQyxBQUFtQyxNQUM1QyxBQUFJLEtBQUMsQUFBTSxPQURGLEFBQ0csUUFESCxBQUNXLDZCQUNwQixBQUFJLElBQUEsQUFBUyxTQUZKLEFBRUksVUFGSixBQUVjLE9BQU8sQUFBSSxJQUFBLEFBQVMsU0FGbEMsQUFFa0MsVUFUdkQsQUFPSSxBQUU2RDtBQVZ6RDtBQXhOaEI7Ozs7SUFBQSxBQUFnRDs7OztBQUM1QyxBQUFDLHFCQUFELEFBQUM7QUFDRyxhQUFBLEFBQVM7QUFDVCxrQkFBYyxDQURkLEFBQ2MsQUFBQztBQUNmLGtCQUZBLEFBRWM7QUFDZCx1QkFIQSxBQUdtQjtBQUNuQixXQUpBLEFBSU87QUFKUDs7QUFLSixBQUFDLHFCQUFELEFBQUM7QUFDRztBQUNJLGFBQU8sQ0FBQSxBQUFDLE1BQUQsQUFBTyxNQUFQLEFBQWEsTUFBYixBQUFtQixNQUFuQixBQUF5QixNQUF6QixBQUErQixNQUEvQixBQUFxQyxNQUFyQyxBQUEyQyxNQUEzQyxBQUFpRCxNQUFqRCxBQUF1RCxNQUF2RCxBQUNDLE1BREQsQUFDTyxNQURQLEFBQ2EsTUFEYixBQUNtQixNQURuQixBQUN5QixNQUR6QixBQUMrQixNQUQvQixBQUNxQyxNQURyQyxBQUMyQyxNQUQzQyxBQUNpRCxNQURqRCxBQUN1RCxNQUR2RCxBQUVDLE1BRkQsQUFFTyxNQUZQLEFBRWEsTUFGYixBQUVtQixXQUg5QixBQUNJLEFBQU8sQUFFOEI7QUFGckM7QUFHSixlQUpBLEFBSVc7QUFKWDs7Ozs7Ozs7Ozs7O0FDWkYsQUFBTSxPQUFDLEFBQU8sUUFBQztBQUFyQixNQUFBLEFBT0ssQUFBYTs7O2tDQUFBLEFBQUMsV0FBRCxBQUFZLGFBRXRCO1lBQUEsUUFBQSxLQUFBOztBQUFBLEFBQUMsYUFBQSxBQUFFLFVBQUgsQUFBRyxPQUFPO0FBRVYsWUFBRyxxQkFBSDtBQUNJLEFBQUMsWUFBRCxBQUFFLE9BQU8sQUFBQyxLQUFBLEFBQUUsVUFBWixBQUFZLE1BQU0sQUFBQyxLQUR2QixBQUNJLEFBQW1COztBQUV2Qix5Q0FBRyxJQUFBLElBQTJCLGFBQWEsQUFBQyxLQUE1QyxBQUE0QztBQUN4QyxBQUFDLFlBQUQsQUFBRSxPQUFPLEFBQUMsS0FBQSxBQUFFLFVBQVosQUFBWSxNQUFNLEFBQUMsS0FBQSxBQUFxQixxQkFENUMsQUFDSSxBQUF3Qzs7QUFFNUMsWUFBRyxBQUFDLEtBQUQsQUFBQyxRQUFKLEFBQVksYUFHUjs7O0FBQUEsZUFBQSxVQUFBOztrQkFBNkMsVUFBVSxBQUFDLEtBQUEsQUFBRSxVQUFBOzs7QUFDdEQsQUFBQyxpQkFBQSxBQUFFLFVBQUEsQUFBSyxLQUFSLEFBQVEsVUFBVTtBQUNsQixtQkFBTyxBQUFZLFlBQUEsQUFBQyxLQUFELEFBQUMsQUFBTSxNQUY5QixBQUU4QjtBQUxsQzs7QUFPQSxZQUFHLENBQUksQUFBQyxLQUFBLEFBQUUsVUFBQSxBQUFJLEtBQWQsQUFBZTtBQUNYLGlCQUFPLEFBQVksWUFBQSxBQUFDLEtBQXBCLEFBQW1CLEFBQUM7O0FBR3BCLGdCQUFNLElBQUEsQUFBSSxNQUpkLEFBSVUsQUFBVTs7QUFFcEIsWUFBRyxBQUFDLEVBQUQsQUFBRSxjQUFjLEFBQVksWUFBQSxBQUFDLEtBQWhDLEFBQUcsQUFBNEIsQUFBQztpQkFDNUIsT0FBTyxBQUFZLFlBQUEsQUFBQyxLQUR4QixBQUN1QixBQUFDO0FBeEJkOzs7O0FBMEJkLEFBQWEsb0JBQUE7OztBQUFDLEFBQUMsV0FBQSxLQUFGO0FBakNqQjs7Ozs7OzttQkFtQ0ksV0FBVTs7bUJBQ1YsWUFBVzs7bUJBQ1gsY0FBYTs7bUJBQ2IsZ0JBQWU7O21CQUNmLHFCQUFvQjs7bUJBQ3BCLGVBQWMiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMi4xLjFcbi8vIEphdmFTY3JpcHQgYXV4aWxpYXJ5IGxpYnJhcnlcbi8vIENvcHlyaWdodCAoQykgMjAxMiBEYXJpbyBHaW92YW5uZXR0aSA8ZGV2QGRhcmlvZ2lvdmFubmV0dGkubmV0PlxuXG4vLyBUaGlzIGZpbGUgaXMgcGFydCBvZiBKYXZhU2NyaXB0IGF1eGlsaWFyeSBsaWJyYXJ5LlxuXG4vLyBKYXZhU2NyaXB0IGF1eGlsaWFyeSBsaWJyYXJ5IGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0XG4vLyBhbmQvb3IgbW9kaWZ5IGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFzIHB1Ymxpc2hlZCBieSB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzXG4vLyBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuLy8gSmF2YVNjcmlwdCBhdXhpbGlhcnkgbGlicmFyeSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmVcbi8vIHVzZWZ1bCwgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIEphdmFTY3JpcHQgYXV4aWxpYXJ5IGxpYnJhcnkuXG4vLyBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG5tb2R1bGUuZXhwb3J0cy5leGVjdXRlQXN5bmMgPSBmdW5jdGlvbiAoZnVuY3Rpb25zLCBpZCkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHZhciBjYWxsQ29udGludWUsIGZpZDtcbiAgaWQrKztcbiAgaWYgKGZ1bmN0aW9uc1tpZF0pIHtcbiAgICBmaWQgPSBmdW5jdGlvbnNbaWRdO1xuICAgIGNhbGxDb250aW51ZSA9IGZ1bmN0aW9uIGNhbGxDb250aW51ZSgpIHtcbiAgICAgIHJldHVybiBfdGhpcy5leGVjdXRlQXN5bmMoZnVuY3Rpb25zLCBpZCk7XG4gICAgfTtcbiAgICByZXR1cm4gZmlkWzBdKGZpZFsxXSwgY2FsbENvbnRpbnVlKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMucmVjdXJzZVRyZWVBc3luYyA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgdmFyIHBhcmVudDtcbiAgLy8gcGFyYW1zID0ge1xuICAvLyAgIG5vZGU6ICxcbiAgLy8gICBwYXJlbnRJbmRleDogLFxuICAvLyAgIHNpYmxpbmdJbmRleDogLFxuICAvLyAgIGFuY2VzdG9yczogLFxuICAvLyAgIGNoaWxkcmVuOiAsXG4gIC8vICAgY2FsbENoaWxkcmVuOiAsXG4gIC8vICAgY2FsbE5vZGU6ICxcbiAgLy8gICBjYWxsRW5kOiAsXG4gIC8vICAgY2FsbEFyZ3M6ICxcbiAgLy8gICBzdGFnZTogLFxuICAvLyAgIG5vZGVzTGlzdDpcbiAgLy8gfVxuXG4gIC8vIG5vZGVzTGlzdDogW1xuICAvLyAgIHtcbiAgLy8gICAgIG5vZGU6ICxcbiAgLy8gICAgIHBhcmVudEluZGV4OiAsXG4gIC8vICAgICBzaWJsaW5nSW5kZXg6ICxcbiAgLy8gICAgIGFuY2VzdG9yczogWy4uLl0sXG4gIC8vICAgICBjaGlsZHJlbjogWy4uLl1cbiAgLy8gICB9LFxuICAvLyAgIHsuLi59XG4gIC8vIF1cblxuICAvLyBFeGFtcGxlOlxuXG4gIC8vIHJlY3Vyc2VUcmVlQXN5bmMoe1xuICAvLyAgIG5vZGU6ICxcbiAgLy8gICBjYWxsQ2hpbGRyZW46ICxcbiAgLy8gICBjYWxsTm9kZTogLFxuICAvLyAgIGNhbGxFbmQ6ICxcbiAgLy8gICBjYWxsQXJnczpcbiAgLy8gfSk7XG5cbiAgLy8gY2FsbENoaWxkcmVuKHBhcmFtcykge1xuICAvLyAgIHBhcmFtcy5jaGlsZHJlbiA9IDtcbiAgLy8gICByZWN1cnNlVHJlZUFzeW5jKHBhcmFtcyk7XG4gIC8vIH1cblxuICAvLyBjYWxsTm9kZShwYXJhbXMpIHtcbiAgLy8gICByZWN1cnNlVHJlZUFzeW5jKHBhcmFtcyk7XG4gIC8vIH1cblxuICAvLyBjYWxsRW5kKHBhcmFtcykge31cbiAgc3dpdGNoIChwYXJhbXMuc3RhZ2UpIHtcbiAgICBjYXNlIHZvaWQgMDpcbiAgICAgIHBhcmFtcy5wYXJlbnRJbmRleCA9IG51bGw7XG4gICAgICBwYXJhbXMuc2libGluZ0luZGV4ID0gMDtcbiAgICAgIHBhcmFtcy5hbmNlc3RvcnMgPSBbXTtcbiAgICAgIHBhcmFtcy5jaGlsZHJlbiA9IFtdO1xuICAgICAgcGFyYW1zLm5vZGVzTGlzdCA9IFtdO1xuICAgICAgcGFyYW1zLnN0YWdlID0gMTtcbiAgICAgIHJldHVybiB0aGlzLnJlY3Vyc2VUcmVlQXN5bmMocGFyYW1zKTtcbiAgICBjYXNlIDE6XG4gICAgICBwYXJhbXMuc3RhZ2UgPSAyO1xuICAgICAgLy8gUHJldmVudCBpbmZpbml0ZSBsb29wc1xuICAgICAgaWYgKHBhcmFtcy5hbmNlc3RvcnMuaW5kZXhPZihwYXJhbXMubm9kZSkgPT09IC0xKSB7XG4gICAgICAgIHJldHVybiBwYXJhbXMuY2FsbENoaWxkcmVuKHBhcmFtcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJhbXMuY2hpbGRyZW4gPSBcImxvb3BcIjtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVjdXJzZVRyZWVBc3luYyhwYXJhbXMpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAyOlxuICAgICAgcGFyYW1zLm5vZGVzTGlzdC5wdXNoKHtcbiAgICAgICAgbm9kZTogcGFyYW1zLm5vZGUsXG4gICAgICAgIHBhcmVudEluZGV4OiBwYXJhbXMucGFyZW50SW5kZXgsXG4gICAgICAgIHNpYmxpbmdJbmRleDogcGFyYW1zLnNpYmxpbmdJbmRleCxcbiAgICAgICAgYW5jZXN0b3JzOiBwYXJhbXMuYW5jZXN0b3JzLnNsaWNlKDApLFxuICAgICAgICBjaGlsZHJlbjogcGFyYW1zLmNoaWxkcmVuLnNsaWNlKDApXG4gICAgICB9KTtcbiAgICAgIHBhcmFtcy5zdGFnZSA9IDM7XG4gICAgICByZXR1cm4gcGFyYW1zLmNhbGxOb2RlKHBhcmFtcyk7XG4gICAgY2FzZSAzOlxuICAgICAgaWYgKHBhcmFtcy5jaGlsZHJlbi5sZW5ndGggJiYgcGFyYW1zLmNoaWxkcmVuICE9PSBcImxvb3BcIikge1xuICAgICAgICAvLyBHbyB0byB0aGUgZmlyc3QgY2hpbGRcbiAgICAgICAgcGFyYW1zLmFuY2VzdG9ycy5wdXNoKHBhcmFtcy5ub2RlKTtcbiAgICAgICAgcGFyYW1zLm5vZGUgPSBwYXJhbXMuY2hpbGRyZW5bMF07XG4gICAgICAgIHBhcmFtcy5wYXJlbnRJbmRleCA9IHBhcmFtcy5ub2Rlc0xpc3QubGVuZ3RoIC0gMTtcbiAgICAgICAgcGFyYW1zLnNpYmxpbmdJbmRleCA9IDA7XG4gICAgICAgIHBhcmFtcy5jaGlsZHJlbiA9IFtdO1xuICAgICAgICBwYXJhbXMuc3RhZ2UgPSAxO1xuICAgICAgICByZXR1cm4gdGhpcy5yZWN1cnNlVHJlZUFzeW5jKHBhcmFtcyk7XG4gICAgICB9IGVsc2UgaWYgKHBhcmFtcy5wYXJlbnRJbmRleCAhPT0gbnVsbCkge1xuICAgICAgICAvLyBHbyB0byB0aGUgbmV4dCBzaWJsaW5nXG4gICAgICAgIHBhcmVudCA9IHBhcmFtcy5ub2Rlc0xpc3RbcGFyYW1zLnBhcmVudEluZGV4XTtcbiAgICAgICAgcGFyYW1zLnNpYmxpbmdJbmRleCsrO1xuICAgICAgICBwYXJhbXMubm9kZSA9IHBhcmVudC5jaGlsZHJlbltwYXJhbXMuc2libGluZ0luZGV4XTtcbiAgICAgICAgcGFyYW1zLmNoaWxkcmVuID0gW107XG4gICAgICAgIGlmIChwYXJhbXMubm9kZSkge1xuICAgICAgICAgIHBhcmFtcy5zdGFnZSA9IDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gVGhlcmUgYXJlIG5vIG1vcmUgc2libGluZ3NcbiAgICAgICAgICBwYXJhbXMubm9kZSA9IHBhcmVudC5ub2RlO1xuICAgICAgICAgIHBhcmFtcy5wYXJlbnRJbmRleCA9IHBhcmVudC5wYXJlbnRJbmRleDtcbiAgICAgICAgICBwYXJhbXMuc2libGluZ0luZGV4ID0gcGFyZW50LnNpYmxpbmdJbmRleDtcbiAgICAgICAgICBwYXJhbXMuYW5jZXN0b3JzID0gcGFyZW50LmFuY2VzdG9ycy5zbGljZSgwKTtcbiAgICAgICAgICBwYXJhbXMuc3RhZ2UgPSAzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnJlY3Vyc2VUcmVlQXN5bmMocGFyYW1zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEVuZCBvZiByZWN1cnNpb25cbiAgICAgICAgcmV0dXJuIHBhcmFtcy5jYWxsRW5kKHBhcmFtcyk7XG4gICAgICB9XG4gIH1cbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDIuMS4xXG4vLyBKYXZhU2NyaXB0IGF1eGlsaWFyeSBsaWJyYXJ5XG4vLyBDb3B5cmlnaHQgKEMpIDIwMTIgRGFyaW8gR2lvdmFubmV0dGkgPGRldkBkYXJpb2dpb3Zhbm5ldHRpLm5ldD5cblxuLy8gVGhpcyBmaWxlIGlzIHBhcnQgb2YgSmF2YVNjcmlwdCBhdXhpbGlhcnkgbGlicmFyeS5cblxuLy8gSmF2YVNjcmlwdCBhdXhpbGlhcnkgbGlicmFyeSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdFxuLy8gYW5kL29yIG1vZGlmeSBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhcyBwdWJsaXNoZWQgYnkgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gM1xuLy8gb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbi8vIEphdmFTY3JpcHQgYXV4aWxpYXJ5IGxpYnJhcnkgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlXG4vLyB1c2VmdWwsIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCBKYXZhU2NyaXB0IGF1eGlsaWFyeSBsaWJyYXJ5LlxuLy8gSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxubW9kdWxlLmV4cG9ydHMuYWRkU3R5bGVFbGVtZW50ID0gZnVuY3Rpb24gKGNzcykge1xuICB2YXIgc3R5bGU7XG4gIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgc3R5bGUuc2V0QXR0cmlidXRlKCd0eXBlJywgJ3RleHQvY3NzJyk7XG4gIHN0eWxlLmlubmVySFRNTCA9IGNzcztcbiAgcmV0dXJuIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xufTsiLCIndXNlIHN0cmljdCc7XG5cbi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMi4xLjFcbi8vIEphdmFTY3JpcHQgYXV4aWxpYXJ5IGxpYnJhcnlcbi8vIENvcHlyaWdodCAoQykgMjAxMiBEYXJpbyBHaW92YW5uZXR0aSA8ZGV2QGRhcmlvZ2lvdmFubmV0dGkubmV0PlxuXG4vLyBUaGlzIGZpbGUgaXMgcGFydCBvZiBKYXZhU2NyaXB0IGF1eGlsaWFyeSBsaWJyYXJ5LlxuXG4vLyBKYXZhU2NyaXB0IGF1eGlsaWFyeSBsaWJyYXJ5IGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0XG4vLyBhbmQvb3IgbW9kaWZ5IGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFzIHB1Ymxpc2hlZCBieSB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzXG4vLyBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuLy8gSmF2YVNjcmlwdCBhdXhpbGlhcnkgbGlicmFyeSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmVcbi8vIHVzZWZ1bCwgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIEphdmFTY3JpcHQgYXV4aWxpYXJ5IGxpYnJhcnkuXG4vLyBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG5tb2R1bGUuZXhwb3J0cy5ub3JtYWxpemVDYXJyaWFnZVJldHVybnMgPSBmdW5jdGlvbiAoc291cmNlKSB7XG4gIC8vIE9wZXJhIGFuZCBJRSB1c2UgXFxyXFxuIGluc3RlYWQgb2YgXFxuXG4gIHJldHVybiBzb3VyY2UucmVwbGFjZSgvXFxyXFxuL2csICdcXG4nKTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDIuMS4xXG4vLyBKYXZhU2NyaXB0IGF1eGlsaWFyeSBsaWJyYXJ5XG4vLyBDb3B5cmlnaHQgKEMpIDIwMTIgRGFyaW8gR2lvdmFubmV0dGkgPGRldkBkYXJpb2dpb3Zhbm5ldHRpLm5ldD5cblxuLy8gVGhpcyBmaWxlIGlzIHBhcnQgb2YgSmF2YVNjcmlwdCBhdXhpbGlhcnkgbGlicmFyeS5cblxuLy8gSmF2YVNjcmlwdCBhdXhpbGlhcnkgbGlicmFyeSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdFxuLy8gYW5kL29yIG1vZGlmeSBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhcyBwdWJsaXNoZWQgYnkgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gM1xuLy8gb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbi8vIEphdmFTY3JpcHQgYXV4aWxpYXJ5IGxpYnJhcnkgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlXG4vLyB1c2VmdWwsIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCBKYXZhU2NyaXB0IGF1eGlsaWFyeSBsaWJyYXJ5LlxuLy8gSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxubW9kdWxlLmV4cG9ydHMuZ2V0VXJsTG9jYXRpb24gPSBmdW5jdGlvbiAodXJsKSB7XG4gIHZhciBsaW5rO1xuICBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICBsaW5rLmhyZWYgPSB1cmw7XG4gIHJldHVybiBsaW5rO1xufTtcblxubW9kdWxlLmV4cG9ydHMuZ2V0VVJJUGFyYW1ldGVycyA9IGZ1bmN0aW9uICh1cmkpIHtcbiAgdmFyIGksIGxlbiwgcGFyLCBxYXJyYXksIHFkaWN0LCBxc3RyaW5nLCBzO1xuICBpZiAodXJpKSB7XG4gICAgcXN0cmluZyA9IG1vZHVsZS5leHBvcnRzLmdldFVybExvY2F0aW9uKHVyaSkuc2VhcmNoO1xuICB9IGVsc2Uge1xuICAgIHFzdHJpbmcgPSBsb2NhdGlvbi5zZWFyY2g7XG4gIH1cbiAgcWFycmF5ID0gcXN0cmluZy5zdWJzdHIoMSkuc3BsaXQoJyYnKTtcbiAgcWRpY3QgPSBuZXcgT2JqZWN0KCk7XG4gIHMgPSBuZXcgQXJyYXkoKTtcbiAgZm9yIChpID0gMCwgbGVuID0gcWFycmF5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgcGFyID0gcWFycmF5W2ldO1xuICAgIHMgPSBwYXIuc3BsaXQoJz0nKTtcbiAgICBxZGljdFtzWzBdXSA9IHNbMV07XG4gIH1cbiAgcmV0dXJuIHFkaWN0O1xufTtcblxubW9kdWxlLmV4cG9ydHMuZ2V0VVJJUGFyYW1ldGVyID0gZnVuY3Rpb24gKHVyaSwgbmFtZSkge1xuICByZXR1cm4gbW9kdWxlLmV4cG9ydHMuZ2V0VVJJUGFyYW1ldGVycyh1cmkpW25hbWVdO1xufTtcblxubW9kdWxlLmV4cG9ydHMuc2VuZEdldEFzeW5jUmVxdWVzdCA9IGZ1bmN0aW9uICh1cmwsIGNhbGwpIHtcbiAgdmFyIHJlcTtcbiAgcmVxID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gIHJlcS5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHJlcS5yZWFkeVN0YXRlID09PSA0ICYmIHJlcS5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgcmV0dXJuIGNhbGwocmVxKTtcbiAgICB9XG4gIH07XG4gIHJlcS5vcGVuKFwiR0VUXCIsIHVybCwgdHJ1ZSk7XG4gIHJldHVybiByZXEuc2VuZCgpO1xufTtcblxubW9kdWxlLmV4cG9ydHMuc2VuZEdldFN5bmNSZXF1ZXN0ID0gZnVuY3Rpb24gKHVybCkge1xuICB2YXIgcmVxO1xuICByZXEgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgcmVxLm9wZW4oXCJHRVRcIiwgdXJsLCBmYWxzZSk7XG4gIHJlcS5zZW5kKCk7XG4gIHJldHVybiByZXE7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5zZW5kUG9zdEFzeW5jUmVxdWVzdCA9IGZ1bmN0aW9uICh1cmwsIGNhbGwsIHF1ZXJ5LCBoZWFkZXIsIGhlYWRlcnZhbHVlKSB7XG4gIHZhciByZXE7XG4gIHJlcSA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICByZXEub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChyZXEucmVhZHlTdGF0ZSA9PT0gNCAmJiByZXEuc3RhdHVzID09PSAyMDApIHtcbiAgICAgIHJldHVybiBjYWxsKHJlcSk7XG4gICAgfVxuICB9O1xuICByZXEub3BlbihcIlBPU1RcIiwgdXJsLCB0cnVlKTtcbiAgaWYgKGhlYWRlciAmJiBoZWFkZXJ2YWx1ZSkge1xuICAgIHJlcS5zZXRSZXF1ZXN0SGVhZGVyKGhlYWRlciwgaGVhZGVydmFsdWUpO1xuICB9XG4gIHJldHVybiByZXEuc2VuZChxdWVyeSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5zZW5kUG9zdFN5bmNSZXF1ZXN0ID0gZnVuY3Rpb24gKHVybCwgcXVlcnksIGhlYWRlciwgaGVhZGVydmFsdWUpIHtcbiAgdmFyIHJlcTtcbiAgcmVxID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gIHJlcS5vcGVuKFwiUE9TVFwiLCB1cmwsIGZhbHNlKTtcbiAgaWYgKGhlYWRlciAmJiBoZWFkZXJ2YWx1ZSkge1xuICAgIHJlcS5zZXRSZXF1ZXN0SGVhZGVyKGhlYWRlciwgaGVhZGVydmFsdWUpO1xuICB9XG4gIHJlcS5zZW5kKHF1ZXJ5KTtcbiAgcmV0dXJuIHJlcTtcbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMi4xLjFcbi8vIEphdmFTY3JpcHQgYXV4aWxpYXJ5IGxpYnJhcnlcbi8vIENvcHlyaWdodCAoQykgMjAxMiBEYXJpbyBHaW92YW5uZXR0aSA8ZGV2QGRhcmlvZ2lvdmFubmV0dGkubmV0PlxuXG4vLyBUaGlzIGZpbGUgaXMgcGFydCBvZiBKYXZhU2NyaXB0IGF1eGlsaWFyeSBsaWJyYXJ5LlxuXG4vLyBKYXZhU2NyaXB0IGF1eGlsaWFyeSBsaWJyYXJ5IGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0XG4vLyBhbmQvb3IgbW9kaWZ5IGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFzIHB1Ymxpc2hlZCBieSB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzXG4vLyBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuLy8gSmF2YVNjcmlwdCBhdXhpbGlhcnkgbGlicmFyeSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmVcbi8vIHVzZWZ1bCwgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIEphdmFTY3JpcHQgYXV4aWxpYXJ5IGxpYnJhcnkuXG4vLyBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG5tb2R1bGUuZXhwb3J0cy5nZXRLZXlzID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICB2YXIgaSwga2V5cztcbiAga2V5cyA9IFtdO1xuICBmb3IgKGkgaW4gb2JqZWN0KSB7XG4gICAga2V5cy5wdXNoKGkpO1xuICB9XG4gIHJldHVybiBrZXlzO1xufTtcblxubW9kdWxlLmV4cG9ydHMuZ2V0VmFsdWVzID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICB2YXIgaSwgdmFsdWVzO1xuICB2YWx1ZXMgPSBbXTtcbiAgZm9yIChpIGluIG9iamVjdCkge1xuICAgIHZhbHVlcy5wdXNoKG9iamVjdFtpXSk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlcztcbn07XG5cbm1vZHVsZS5leHBvcnRzLmdldEZpcnN0SXRlbSA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgdmFyIGk7XG4gIGZvciAoaSBpbiBvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0W2ldO1xuICB9XG59OyIsIlwidXNlIHN0cmljdFwiO1xuXG4vLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDIuMS4xXG4vLyBKYXZhU2NyaXB0IGF1eGlsaWFyeSBsaWJyYXJ5XG4vLyBDb3B5cmlnaHQgKEMpIDIwMTIgRGFyaW8gR2lvdmFubmV0dGkgPGRldkBkYXJpb2dpb3Zhbm5ldHRpLm5ldD5cblxuLy8gVGhpcyBmaWxlIGlzIHBhcnQgb2YgSmF2YVNjcmlwdCBhdXhpbGlhcnkgbGlicmFyeS5cblxuLy8gSmF2YVNjcmlwdCBhdXhpbGlhcnkgbGlicmFyeSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdFxuLy8gYW5kL29yIG1vZGlmeSBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhcyBwdWJsaXNoZWQgYnkgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gM1xuLy8gb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbi8vIEphdmFTY3JpcHQgYXV4aWxpYXJ5IGxpYnJhcnkgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlXG4vLyB1c2VmdWwsIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCBKYXZhU2NyaXB0IGF1eGlsaWFyeSBsaWJyYXJ5LlxuLy8gSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxubW9kdWxlLmV4cG9ydHMuZXNjYXBlUGF0dGVybiA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgLy8gRXNjYXBpbmcgYW55IG90aGVyIGNoYXJhY3RlcnMgaXMgbm90IG5lY2Vzc2FyeSwgcmVmZXJlbmNlczpcbiAgLy8gLSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L0d1aWRlL1JlZ3VsYXJfRXhwcmVzc2lvbnNcbiAgLy8gLSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzM1NjE0OTMvaXMtdGhlcmUtYS1yZWdleHAtZXNjYXBlLWZ1bmN0aW9uLWluLWphdmFzY3JpcHRcbiAgLy8gLSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzI1OTM2MzcvaG93LXRvLWVzY2FwZS1yZWd1bGFyLWV4cHJlc3Npb24taW4tamF2YXNjcmlwdFxuICAvLyAtIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNDk0MDM1L2hvdy1kby15b3UtcGFzcy1hLXZhcmlhYmxlLXRvLWEtcmVndWxhci1leHByZXNzaW9uLWphdmFzY3JpcHRcbiAgLy8gLSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzM0NDYxNzAvZXNjYXBlLXN0cmluZy1mb3ItdXNlLWluLWphdmFzY3JpcHQtcmVnZXhcbiAgLy8gLSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzM5OTA3OC93aGF0LXNwZWNpYWwtY2hhcmFjdGVycy1tdXN0LWJlLWVzY2FwZWQtaW4tcmVndWxhci1leHByZXNzaW9uc1xuXG4gIC8vIE5vdGUgZm9yIFdpa2kgTW9ua2V5OiBkbyAqbm90KiBlc2NhcGUgJ1xccycgaGVyZSBzbyB0aGF0IGl0IHdpbGwgYmVcbiAgLy8gc2FmZSB0byB1c2UgcHJlcGFyZVJlZ2V4cFdoaXRlc3BhY2UgaW4gV00uUGFyc2VyXG4gIHJldHVybiBzdHJpbmcucmVwbGFjZSgvWy1bXFxde30oKV4kKis/LnxcXFxcXS9nLCBcIlxcXFwkJlwiKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzLm1hdGNoQWxsID0gZnVuY3Rpb24gKHNvdXJjZSwgcmVnRXhwKSB7XG4gIHZhciBMLCBtYXRjaCwgcmVzdWx0O1xuICByZXN1bHQgPSBbXTtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBtYXRjaCA9IHJlZ0V4cC5leGVjKHNvdXJjZSk7XG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICBMID0gbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICBcIm1hdGNoXCI6IG1hdGNoLFxuICAgICAgICBcImluZGV4XCI6IHJlZ0V4cC5sYXN0SW5kZXggLSBMLFxuICAgICAgICBcImxlbmd0aFwiOiBMXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5tYXRjaEFsbENvbmRpdGlvbmFsID0gZnVuY3Rpb24gKHNvdXJjZSwgcmVnRXhwLCB0ZXN0KSB7XG4gIHZhciBMLCBtYXRjaCwgcmVzdWx0O1xuICByZXN1bHQgPSBbXTtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBtYXRjaCA9IHJlZ0V4cC5leGVjKHNvdXJjZSk7XG4gICAgaWYgKG1hdGNoICYmIHRlc3QobWF0Y2gpKSB7XG4gICAgICBMID0gbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICBcIm1hdGNoXCI6IG1hdGNoLFxuICAgICAgICBcImluZGV4XCI6IHJlZ0V4cC5sYXN0SW5kZXggLSBMLFxuICAgICAgICBcImxlbmd0aFwiOiBMXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59OyIsIlwidXNlIHN0cmljdFwiO1xuXG4vLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDIuMS4xXG4vLyBKYXZhU2NyaXB0IGF1eGlsaWFyeSBsaWJyYXJ5XG4vLyBDb3B5cmlnaHQgKEMpIDIwMTIgRGFyaW8gR2lvdmFubmV0dGkgPGRldkBkYXJpb2dpb3Zhbm5ldHRpLm5ldD5cblxuLy8gVGhpcyBmaWxlIGlzIHBhcnQgb2YgSmF2YVNjcmlwdCBhdXhpbGlhcnkgbGlicmFyeS5cblxuLy8gSmF2YVNjcmlwdCBhdXhpbGlhcnkgbGlicmFyeSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdFxuLy8gYW5kL29yIG1vZGlmeSBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhcyBwdWJsaXNoZWQgYnkgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gM1xuLy8gb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbi8vIEphdmFTY3JpcHQgYXV4aWxpYXJ5IGxpYnJhcnkgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlXG4vLyB1c2VmdWwsIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCBKYXZhU2NyaXB0IGF1eGlsaWFyeSBsaWJyYXJ5LlxuLy8gSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxubW9kdWxlLmV4cG9ydHMuaW5zZXJ0ID0gZnVuY3Rpb24gKHN0cmluZywgbmV3U3RyaW5nLCBpZCkge1xuICBpZiAoaWQgPT0gbnVsbCkge1xuICAgIGlkID0gMDtcbiAgfVxuICByZXR1cm4gc3RyaW5nLnN1YnN0cmluZygwLCBpZCkgKyBuZXdTdHJpbmcgKyBzdHJpbmcuc3Vic3RyKGlkKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzLm92ZXJ3cml0ZUZvciA9IGZ1bmN0aW9uIChzdHJpbmcsIG5ld1N0cmluZywgaWQsIGxlbmd0aCkge1xuICBpZiAoaWQgPT0gbnVsbCkge1xuICAgIGlkID0gMDtcbiAgfVxuICBpZiAoIWxlbmd0aCB8fCBsZW5ndGggPCAwKSB7XG4gICAgbGVuZ3RoID0gMDtcbiAgfVxuICByZXR1cm4gc3RyaW5nLnN1YnN0cmluZygwLCBpZCkgKyBuZXdTdHJpbmcgKyBzdHJpbmcuc3Vic3RyKGlkICsgbGVuZ3RoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzLm92ZXJ3cml0ZUF0ID0gZnVuY3Rpb24gKHN0cmluZywgbmV3U3RyaW5nLCBpZCkge1xuICByZXR1cm4gbW9kdWxlLmV4cG9ydHMub3ZlcndyaXRlRm9yKHN0cmluZywgbmV3U3RyaW5nLCBpZCwgbmV3U3RyaW5nLmxlbmd0aCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5vdmVyd3JpdGVCZXR3ZWVuID0gZnVuY3Rpb24gKHN0cmluZywgbmV3U3RyaW5nLCBpZDEsIGlkMikge1xuICB2YXIgdGVtcGlkO1xuICBpZiAoaWQxID09IG51bGwpIHtcbiAgICBpZDEgPSAwO1xuICB9XG4gIGlmIChpZDIgPT0gbnVsbCkge1xuICAgIGlkMiA9IGlkMTtcbiAgfVxuICBpZiAoaWQxID4gaWQyKSB7XG4gICAgdGVtcGlkID0gaWQyO1xuICAgIGlkMiA9IGlkMTtcbiAgICBpZDEgPSB0ZW1waWQ7XG4gIH1cbiAgcmV0dXJuIHN0cmluZy5zdWJzdHJpbmcoMCwgaWQxKSArIG5ld1N0cmluZyArIHN0cmluZy5zdWJzdHIoaWQyKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzLnJlbW92ZUZvciA9IGZ1bmN0aW9uIChzdHJpbmcsIGlkLCBsZW5ndGgpIHtcbiAgcmV0dXJuIG1vZHVsZS5leHBvcnRzLm92ZXJ3cml0ZUZvcihzdHJpbmcsIFwiXCIsIGlkLCBsZW5ndGgpO1xufTtcblxubW9kdWxlLmV4cG9ydHMucmVtb3ZlQmV0d2VlbiA9IGZ1bmN0aW9uIChzdHJpbmcsIGlkMSwgaWQyKSB7XG4gIHJldHVybiBtb2R1bGUuZXhwb3J0cy5vdmVyd3JpdGVCZXR3ZWVuKHN0cmluZywgXCJcIiwgaWQxLCBpZDIpO1xufTtcblxubW9kdWxlLmV4cG9ydHMucGFkTGVmdCA9IGZ1bmN0aW9uIChzdHJpbmcsIGZpbGxlciwgbGVuZ3RoKSB7XG4gIHdoaWxlIChzdHJpbmcubGVuZ3RoIDwgbGVuZ3RoKSB7XG4gICAgc3RyaW5nID0gZmlsbGVyICsgc3RyaW5nO1xuICB9XG4gIHJldHVybiBzdHJpbmc7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5wYWRSaWdodCA9IGZ1bmN0aW9uIChzdHJpbmcsIGZpbGxlciwgbGVuZ3RoKSB7XG4gIHdoaWxlIChzdHJpbmcubGVuZ3RoIDwgbGVuZ3RoKSB7XG4gICAgc3RyaW5nICs9IGZpbGxlcjtcbiAgfVxuICByZXR1cm4gc3RyaW5nO1xufTtcblxubW9kdWxlLmV4cG9ydHMuZmluZFNpbXBsZUVuY2xvc3VyZXMgPSBmdW5jdGlvbiAoc3RyaW5nLCBvcGVuVGFnLCBvcGVuTGVuZ3RoLCBjbG9zZVRhZywgY2xvc2VMZW5ndGgpIHtcbiAgdmFyIGNJbmRleCwgY0luZGV4UmVsLCBvSW5kZXgsIG9JbmRleFJlbCwgcmVzdWx0cywgc2VhcmNoSW5kZXg7XG4gIC8vIG9wZW5UYWcgYW5kIGNsb3NlVGFnIGNhbiBiZSBzdHJpbmdzIG9yIHJlZ3VsYXIgZXhwcmVzc2lvbnNcbiAgLy8gSWYgdGhlIHN0cmluZyBpcyBcIjw8Pj5cIiBhbmQgdGhlIHRhZ3MgYXJlIFwiPFwiIGFuZCBcIj5cIiwgdGhlIHJlc3VsdCBpc1xuICAvLyAgIFtbMCwgMl0sIF1cbiAgLy8gUmVzdWx0cyBhcmUgZ3VhcmFudGVlZCB0byBiZSBpbiBvcmRlciBvZiBhcHBlYXJhbmNlIGluIHRoZSBvcmlnaW5hbFxuICAvLyAgIHRleHRcbiAgcmVzdWx0cyA9IFtdO1xuICBzZWFyY2hJbmRleCA9IDA7XG4gIG9JbmRleFJlbCA9IHN0cmluZy5zZWFyY2gob3BlblRhZyk7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgaWYgKG9JbmRleFJlbCA+IC0xKSB7XG4gICAgICBvSW5kZXggPSBzZWFyY2hJbmRleCArIG9JbmRleFJlbDtcbiAgICAgIGNJbmRleFJlbCA9IHN0cmluZy5zdWJzdHIob0luZGV4ICsgb3Blbkxlbmd0aCkuc2VhcmNoKGNsb3NlVGFnKTtcbiAgICAgIGlmIChjSW5kZXhSZWwgPiAtMSkge1xuICAgICAgICBjSW5kZXggPSBvSW5kZXggKyBvcGVuTGVuZ3RoICsgY0luZGV4UmVsO1xuICAgICAgICByZXN1bHRzLnB1c2goW29JbmRleCwgY0luZGV4XSk7XG4gICAgICAgIHNlYXJjaEluZGV4ID0gY0luZGV4ICsgY2xvc2VMZW5ndGg7XG4gICAgICAgIGlmIChzZWFyY2hJbmRleCA8IHN0cmluZy5sZW5ndGgpIHtcbiAgICAgICAgICBvSW5kZXhSZWwgPSBzdHJpbmcuc3Vic3RyKHNlYXJjaEluZGV4KS5zZWFyY2gob3BlblRhZyk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEEgdGFnIGlzIGxlZnQgb3BlbiAobm8gY2xvc2luZyB0YWcgaXMgZm91bmQpXG4gICAgICAgIC8vIExldCBlYWNoIGltcGxlbWVudGF0aW9uIGRlY2lkZSB3aGF0IHRvIGRvIGluIHRoaXMgY2FzZVxuICAgICAgICAvLyAgIChlaXRoZXIgY29uc2lkZXIgdGhlIHRhZyB3b3JraW5nIHVudGlsIHRoZSBlbmQgb2YgdGV4dFxuICAgICAgICAvLyAgIG9yIG5vdClcbiAgICAgICAgcmVzdWx0cy5wdXNoKFtvSW5kZXgsIGZhbHNlXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdHM7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5maW5kTmVzdGVkRW5jbG9zdXJlcyA9IGZ1bmN0aW9uIChzdHJpbmcsIG9wZW5UYWcsIGNsb3NlVGFnLCBtYXNrQ2hhcikge1xuICB2YXIgY0luZGV4LCBjSW5kZXhSZWwsIGNsb3NlTGVuZ3RoLCBtYXNrTGVuZ3RoLCBtYXNrZWRTdHJpbmcsIG1hc2tlZFN0cmluZzEsIG1hc2tlZFN0cmluZzIsIG1hc2tlZFN0cmluZzMsIG9JbmRleCwgb0luZGV4UmVsLCBvcGVuTGVuZ3RoLCByZXN1bHRzLCBzZWFyY2hJbmRleDtcbiAgLy8gb3BlblRhZyBhbmQgY2xvc2VUYWcgbXVzdCBiZSBzdHJpbmdzLCAqbm90KiByZWd1bGFyIGV4cHJlc3Npb25zLFxuICAvLyAgIHVubGlrZSB0aGlzLmZpbmRTaW1wbGVFbmNsb3N1cmVzXG4gIC8vIG1hc2tDaGFyIG11c3QgYmUgYSAqMSotY2hhcmFjdGVyIHN0cmluZyBhbmQgbXVzdCAqbm90KiBiZSBwYXJ0IG9mXG4gIC8vICAgbmVpdGhlciBvcGVuVGFnIG5vciBjbG9zZVRhZ1xuICAvLyBJZiB0aGUgc3RyaW5nIGlzIFwiPDw+PlwiIGFuZCB0aGUgdGFncyBhcmUgXCI8XCIgYW5kIFwiPlwiLCB0aGUgcmVzdWx0IGlzXG4gIC8vICAgW1sxLCAyXSwgWzAsIDNdXVxuICBvcGVuTGVuZ3RoID0gb3BlblRhZy5sZW5ndGg7XG4gIGNsb3NlTGVuZ3RoID0gY2xvc2VUYWcubGVuZ3RoO1xuICByZXN1bHRzID0gW107XG4gIHNlYXJjaEluZGV4ID0gMDtcbiAgY0luZGV4UmVsID0gc3RyaW5nLmluZGV4T2YoY2xvc2VUYWcpO1xuICBtYXNrZWRTdHJpbmcgPSBzdHJpbmc7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgaWYgKGNJbmRleFJlbCA+IC0xKSB7XG4gICAgICBjSW5kZXggPSBzZWFyY2hJbmRleCArIGNJbmRleFJlbDtcbiAgICAgIG9JbmRleFJlbCA9IG1hc2tlZFN0cmluZy5zdWJzdHJpbmcoc2VhcmNoSW5kZXgsIGNJbmRleCkubGFzdEluZGV4T2Yob3BlblRhZyk7XG4gICAgICBpZiAob0luZGV4UmVsID4gLTEpIHtcbiAgICAgICAgb0luZGV4ID0gc2VhcmNoSW5kZXggKyBvSW5kZXhSZWw7XG4gICAgICAgIHJlc3VsdHMucHVzaChbb0luZGV4LCBjSW5kZXhdKTtcbiAgICAgICAgbWFza2VkU3RyaW5nMSA9IG1hc2tlZFN0cmluZy5zdWJzdHJpbmcoMCwgb0luZGV4KTtcbiAgICAgICAgbWFza0xlbmd0aCA9IGNJbmRleCAtIG9JbmRleCArIGNsb3NlTGVuZ3RoO1xuICAgICAgICBtYXNrZWRTdHJpbmcyID0gbW9kdWxlLmV4cG9ydHMucGFkUmlnaHQoXCJcIiwgbWFza0NoYXIsIG1hc2tMZW5ndGgpO1xuICAgICAgICBtYXNrZWRTdHJpbmczID0gbWFza2VkU3RyaW5nLnN1YnN0cmluZyhjSW5kZXggKyBjbG9zZUxlbmd0aCk7XG4gICAgICAgIG1hc2tlZFN0cmluZyA9IG1hc2tlZFN0cmluZzEgKyBtYXNrZWRTdHJpbmcyICsgbWFza2VkU3RyaW5nMztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIERvICpub3QqIGluY3JlbWVudCBzZWFyY2hJbmRleCBpbiB0aGlzIGNhc2UsIGluIGZhY3QgaW5cbiAgICAgICAgLy8gICB3ZSBkb24ndCBrbm93IHlldCB3aGV0aGVyIHRoZXJlIGFyZSBtb3JlIG9wZW5UYWdzXG4gICAgICAgIC8vICAgYmVmb3JlIHRoZSBvbmUgZm91bmRcbiAgICAgICAgc2VhcmNoSW5kZXggPSBjSW5kZXggKyBjbG9zZUxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGNJbmRleFJlbCA9IG1hc2tlZFN0cmluZy5zdWJzdHJpbmcoc2VhcmNoSW5kZXgpLmluZGV4T2YoY2xvc2VUYWcpO1xuICAgICAgY29udGludWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gW3Jlc3VsdHMsIG1hc2tlZFN0cmluZ107XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5maW5kSW5uZXJtb3N0RW5jbG9zdXJlcyA9IGZ1bmN0aW9uIChzdHJpbmcsIG9wZW5UYWcsIGNsb3NlVGFnKSB7XG4gIHZhciBjSW5kZXgsIGNJbmRleFJlbCwgY2xvc2VMZW5ndGgsIG9JbmRleCwgb0luZGV4UmVsLCBvcGVuTGVuZ3RoLCByZXN1bHRzLCBzZWFyY2hJbmRleDtcbiAgLy8gb3BlblRhZyBhbmQgY2xvc2VUYWcgbXVzdCBiZSBzdHJpbmdzLCAqbm90KiByZWd1bGFyIGV4cHJlc3Npb25zLFxuICAvLyAgIHVubGlrZSB0aGlzLmZpbmRTaW1wbGVFbmNsb3N1cmVzXG4gIC8vIElmIHRoZSBzdHJpbmcgaXMgXCI8PD4+XCIgYW5kIHRoZSB0YWdzIGFyZSBcIjxcIiBhbmQgXCI+XCIsIHRoZSByZXN1bHQgaXNcbiAgLy8gICBbWzEsIDJdLCBdXG4gIG9wZW5MZW5ndGggPSBvcGVuVGFnLmxlbmd0aDtcbiAgY2xvc2VMZW5ndGggPSBjbG9zZVRhZy5sZW5ndGg7XG4gIHJlc3VsdHMgPSBbXTtcbiAgc2VhcmNoSW5kZXggPSAwO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGNJbmRleFJlbCA9IHN0cmluZy5zdWJzdHJpbmcoc2VhcmNoSW5kZXgpLmluZGV4T2YoY2xvc2VUYWcpO1xuICAgIGlmIChjSW5kZXhSZWwgPiAtMSkge1xuICAgICAgY0luZGV4ID0gc2VhcmNoSW5kZXggKyBjSW5kZXhSZWw7XG4gICAgICBvSW5kZXhSZWwgPSBzdHJpbmcuc3Vic3RyaW5nKHNlYXJjaEluZGV4LCBjSW5kZXgpLmxhc3RJbmRleE9mKG9wZW5UYWcpO1xuICAgICAgaWYgKG9JbmRleFJlbCA+IC0xKSB7XG4gICAgICAgIG9JbmRleCA9IHNlYXJjaEluZGV4ICsgb0luZGV4UmVsO1xuICAgICAgICByZXN1bHRzLnB1c2goW29JbmRleCwgY0luZGV4XSk7XG4gICAgICB9XG4gICAgICBzZWFyY2hJbmRleCA9IGNJbmRleCArIGNsb3NlTGVuZ3RoO1xuICAgICAgY29udGludWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0cztcbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL3NoaW1cIik7XG5cbnJlcXVpcmUoXCJyZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWVcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL2ZuL3JlZ2V4cC9lc2NhcGVcIik7XG5cbmlmIChnbG9iYWwuX2JhYmVsUG9seWZpbGwpIHtcbiAgdGhyb3cgbmV3IEVycm9yKFwib25seSBvbmUgaW5zdGFuY2Ugb2YgYmFiZWwtcG9seWZpbGwgaXMgYWxsb3dlZFwiKTtcbn1cbmdsb2JhbC5fYmFiZWxQb2x5ZmlsbCA9IHRydWU7XG5cbnZhciBERUZJTkVfUFJPUEVSVFkgPSBcImRlZmluZVByb3BlcnR5XCI7XG5mdW5jdGlvbiBkZWZpbmUoTywga2V5LCB2YWx1ZSkge1xuICBPW2tleV0gfHwgT2JqZWN0W0RFRklORV9QUk9QRVJUWV0oTywga2V5LCB7XG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiB2YWx1ZVxuICB9KTtcbn1cblxuZGVmaW5lKFN0cmluZy5wcm90b3R5cGUsIFwicGFkTGVmdFwiLCBcIlwiLnBhZFN0YXJ0KTtcbmRlZmluZShTdHJpbmcucHJvdG90eXBlLCBcInBhZFJpZ2h0XCIsIFwiXCIucGFkRW5kKTtcblxuXCJwb3AscmV2ZXJzZSxzaGlmdCxrZXlzLHZhbHVlcyxlbnRyaWVzLGluZGV4T2YsZXZlcnksc29tZSxmb3JFYWNoLG1hcCxmaWx0ZXIsZmluZCxmaW5kSW5kZXgsaW5jbHVkZXMsam9pbixzbGljZSxjb25jYXQscHVzaCxzcGxpY2UsdW5zaGlmdCxzb3J0LGxhc3RJbmRleE9mLHJlZHVjZSxyZWR1Y2VSaWdodCxjb3B5V2l0aGluLGZpbGxcIi5zcGxpdChcIixcIikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIFtdW2tleV0gJiYgZGVmaW5lKEFycmF5LCBrZXksIEZ1bmN0aW9uLmNhbGwuYmluZChbXVtrZXldKSk7XG59KTsiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBodHRwczovL3Jhdy5naXRodWIuY29tL2ZhY2Vib29rL3JlZ2VuZXJhdG9yL21hc3Rlci9MSUNFTlNFIGZpbGUuIEFuXG4gKiBhZGRpdGlvbmFsIGdyYW50IG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW5cbiAqIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqL1xuXG4hKGZ1bmN0aW9uKGdsb2JhbCkge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICB2YXIgT3AgPSBPYmplY3QucHJvdG90eXBlO1xuICB2YXIgaGFzT3duID0gT3AuaGFzT3duUHJvcGVydHk7XG4gIHZhciB1bmRlZmluZWQ7IC8vIE1vcmUgY29tcHJlc3NpYmxlIHRoYW4gdm9pZCAwLlxuICB2YXIgJFN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiA/IFN5bWJvbCA6IHt9O1xuICB2YXIgaXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLml0ZXJhdG9yIHx8IFwiQEBpdGVyYXRvclwiO1xuICB2YXIgYXN5bmNJdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuYXN5bmNJdGVyYXRvciB8fCBcIkBAYXN5bmNJdGVyYXRvclwiO1xuICB2YXIgdG9TdHJpbmdUYWdTeW1ib2wgPSAkU3ltYm9sLnRvU3RyaW5nVGFnIHx8IFwiQEB0b1N0cmluZ1RhZ1wiO1xuXG4gIHZhciBpbk1vZHVsZSA9IHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCI7XG4gIHZhciBydW50aW1lID0gZ2xvYmFsLnJlZ2VuZXJhdG9yUnVudGltZTtcbiAgaWYgKHJ1bnRpbWUpIHtcbiAgICBpZiAoaW5Nb2R1bGUpIHtcbiAgICAgIC8vIElmIHJlZ2VuZXJhdG9yUnVudGltZSBpcyBkZWZpbmVkIGdsb2JhbGx5IGFuZCB3ZSdyZSBpbiBhIG1vZHVsZSxcbiAgICAgIC8vIG1ha2UgdGhlIGV4cG9ydHMgb2JqZWN0IGlkZW50aWNhbCB0byByZWdlbmVyYXRvclJ1bnRpbWUuXG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IHJ1bnRpbWU7XG4gICAgfVxuICAgIC8vIERvbid0IGJvdGhlciBldmFsdWF0aW5nIHRoZSByZXN0IG9mIHRoaXMgZmlsZSBpZiB0aGUgcnVudGltZSB3YXNcbiAgICAvLyBhbHJlYWR5IGRlZmluZWQgZ2xvYmFsbHkuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gRGVmaW5lIHRoZSBydW50aW1lIGdsb2JhbGx5IChhcyBleHBlY3RlZCBieSBnZW5lcmF0ZWQgY29kZSkgYXMgZWl0aGVyXG4gIC8vIG1vZHVsZS5leHBvcnRzIChpZiB3ZSdyZSBpbiBhIG1vZHVsZSkgb3IgYSBuZXcsIGVtcHR5IG9iamVjdC5cbiAgcnVudGltZSA9IGdsb2JhbC5yZWdlbmVyYXRvclJ1bnRpbWUgPSBpbk1vZHVsZSA/IG1vZHVsZS5leHBvcnRzIDoge307XG5cbiAgZnVuY3Rpb24gd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIC8vIElmIG91dGVyRm4gcHJvdmlkZWQgYW5kIG91dGVyRm4ucHJvdG90eXBlIGlzIGEgR2VuZXJhdG9yLCB0aGVuIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yLlxuICAgIHZhciBwcm90b0dlbmVyYXRvciA9IG91dGVyRm4gJiYgb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IgPyBvdXRlckZuIDogR2VuZXJhdG9yO1xuICAgIHZhciBnZW5lcmF0b3IgPSBPYmplY3QuY3JlYXRlKHByb3RvR2VuZXJhdG9yLnByb3RvdHlwZSk7XG4gICAgdmFyIGNvbnRleHQgPSBuZXcgQ29udGV4dCh0cnlMb2NzTGlzdCB8fCBbXSk7XG5cbiAgICAvLyBUaGUgLl9pbnZva2UgbWV0aG9kIHVuaWZpZXMgdGhlIGltcGxlbWVudGF0aW9ucyBvZiB0aGUgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzLlxuICAgIGdlbmVyYXRvci5faW52b2tlID0gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcblxuICAgIHJldHVybiBnZW5lcmF0b3I7XG4gIH1cbiAgcnVudGltZS53cmFwID0gd3JhcDtcblxuICAvLyBUcnkvY2F0Y2ggaGVscGVyIHRvIG1pbmltaXplIGRlb3B0aW1pemF0aW9ucy4gUmV0dXJucyBhIGNvbXBsZXRpb25cbiAgLy8gcmVjb3JkIGxpa2UgY29udGV4dC50cnlFbnRyaWVzW2ldLmNvbXBsZXRpb24uIFRoaXMgaW50ZXJmYWNlIGNvdWxkXG4gIC8vIGhhdmUgYmVlbiAoYW5kIHdhcyBwcmV2aW91c2x5KSBkZXNpZ25lZCB0byB0YWtlIGEgY2xvc3VyZSB0byBiZVxuICAvLyBpbnZva2VkIHdpdGhvdXQgYXJndW1lbnRzLCBidXQgaW4gYWxsIHRoZSBjYXNlcyB3ZSBjYXJlIGFib3V0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhbiBleGlzdGluZyBtZXRob2Qgd2Ugd2FudCB0byBjYWxsLCBzbyB0aGVyZSdzIG5vIG5lZWRcbiAgLy8gdG8gY3JlYXRlIGEgbmV3IGZ1bmN0aW9uIG9iamVjdC4gV2UgY2FuIGV2ZW4gZ2V0IGF3YXkgd2l0aCBhc3N1bWluZ1xuICAvLyB0aGUgbWV0aG9kIHRha2VzIGV4YWN0bHkgb25lIGFyZ3VtZW50LCBzaW5jZSB0aGF0IGhhcHBlbnMgdG8gYmUgdHJ1ZVxuICAvLyBpbiBldmVyeSBjYXNlLCBzbyB3ZSBkb24ndCBoYXZlIHRvIHRvdWNoIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBUaGVcbiAgLy8gb25seSBhZGRpdGlvbmFsIGFsbG9jYXRpb24gcmVxdWlyZWQgaXMgdGhlIGNvbXBsZXRpb24gcmVjb3JkLCB3aGljaFxuICAvLyBoYXMgYSBzdGFibGUgc2hhcGUgYW5kIHNvIGhvcGVmdWxseSBzaG91bGQgYmUgY2hlYXAgdG8gYWxsb2NhdGUuXG4gIGZ1bmN0aW9uIHRyeUNhdGNoKGZuLCBvYmosIGFyZykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcIm5vcm1hbFwiLCBhcmc6IGZuLmNhbGwob2JqLCBhcmcpIH07XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcInRocm93XCIsIGFyZzogZXJyIH07XG4gICAgfVxuICB9XG5cbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkU3RhcnQgPSBcInN1c3BlbmRlZFN0YXJ0XCI7XG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkID0gXCJzdXNwZW5kZWRZaWVsZFwiO1xuICB2YXIgR2VuU3RhdGVFeGVjdXRpbmcgPSBcImV4ZWN1dGluZ1wiO1xuICB2YXIgR2VuU3RhdGVDb21wbGV0ZWQgPSBcImNvbXBsZXRlZFwiO1xuXG4gIC8vIFJldHVybmluZyB0aGlzIG9iamVjdCBmcm9tIHRoZSBpbm5lckZuIGhhcyB0aGUgc2FtZSBlZmZlY3QgYXNcbiAgLy8gYnJlYWtpbmcgb3V0IG9mIHRoZSBkaXNwYXRjaCBzd2l0Y2ggc3RhdGVtZW50LlxuICB2YXIgQ29udGludWVTZW50aW5lbCA9IHt9O1xuXG4gIC8vIER1bW15IGNvbnN0cnVjdG9yIGZ1bmN0aW9ucyB0aGF0IHdlIHVzZSBhcyB0aGUgLmNvbnN0cnVjdG9yIGFuZFxuICAvLyAuY29uc3RydWN0b3IucHJvdG90eXBlIHByb3BlcnRpZXMgZm9yIGZ1bmN0aW9ucyB0aGF0IHJldHVybiBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0cy4gRm9yIGZ1bGwgc3BlYyBjb21wbGlhbmNlLCB5b3UgbWF5IHdpc2ggdG8gY29uZmlndXJlIHlvdXJcbiAgLy8gbWluaWZpZXIgbm90IHRvIG1hbmdsZSB0aGUgbmFtZXMgb2YgdGhlc2UgdHdvIGZ1bmN0aW9ucy5cbiAgZnVuY3Rpb24gR2VuZXJhdG9yKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb24oKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSgpIHt9XG5cbiAgLy8gVGhpcyBpcyBhIHBvbHlmaWxsIGZvciAlSXRlcmF0b3JQcm90b3R5cGUlIGZvciBlbnZpcm9ubWVudHMgdGhhdFxuICAvLyBkb24ndCBuYXRpdmVseSBzdXBwb3J0IGl0LlxuICB2YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcbiAgSXRlcmF0b3JQcm90b3R5cGVbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbiAgdmFyIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG8gJiYgZ2V0UHJvdG8oZ2V0UHJvdG8odmFsdWVzKFtdKSkpO1xuICBpZiAoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgJiZcbiAgICAgIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICE9PSBPcCAmJlxuICAgICAgaGFzT3duLmNhbGwoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUsIGl0ZXJhdG9yU3ltYm9sKSkge1xuICAgIC8vIFRoaXMgZW52aXJvbm1lbnQgaGFzIGEgbmF0aXZlICVJdGVyYXRvclByb3RvdHlwZSU7IHVzZSBpdCBpbnN0ZWFkXG4gICAgLy8gb2YgdGhlIHBvbHlmaWxsLlxuICAgIEl0ZXJhdG9yUHJvdG90eXBlID0gTmF0aXZlSXRlcmF0b3JQcm90b3R5cGU7XG4gIH1cblxuICB2YXIgR3AgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5wcm90b3R5cGUgPVxuICAgIEdlbmVyYXRvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlKTtcbiAgR2VuZXJhdG9yRnVuY3Rpb24ucHJvdG90eXBlID0gR3AuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvbjtcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGVbdG9TdHJpbmdUYWdTeW1ib2xdID1cbiAgICBHZW5lcmF0b3JGdW5jdGlvbi5kaXNwbGF5TmFtZSA9IFwiR2VuZXJhdG9yRnVuY3Rpb25cIjtcblxuICAvLyBIZWxwZXIgZm9yIGRlZmluaW5nIHRoZSAubmV4dCwgLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzIG9mIHRoZVxuICAvLyBJdGVyYXRvciBpbnRlcmZhY2UgaW4gdGVybXMgb2YgYSBzaW5nbGUgLl9pbnZva2UgbWV0aG9kLlxuICBmdW5jdGlvbiBkZWZpbmVJdGVyYXRvck1ldGhvZHMocHJvdG90eXBlKSB7XG4gICAgW1wibmV4dFwiLCBcInRocm93XCIsIFwicmV0dXJuXCJdLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICBwcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKGFyZykge1xuICAgICAgICByZXR1cm4gdGhpcy5faW52b2tlKG1ldGhvZCwgYXJnKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICBydW50aW1lLmlzR2VuZXJhdG9yRnVuY3Rpb24gPSBmdW5jdGlvbihnZW5GdW4pIHtcbiAgICB2YXIgY3RvciA9IHR5cGVvZiBnZW5GdW4gPT09IFwiZnVuY3Rpb25cIiAmJiBnZW5GdW4uY29uc3RydWN0b3I7XG4gICAgcmV0dXJuIGN0b3JcbiAgICAgID8gY3RvciA9PT0gR2VuZXJhdG9yRnVuY3Rpb24gfHxcbiAgICAgICAgLy8gRm9yIHRoZSBuYXRpdmUgR2VuZXJhdG9yRnVuY3Rpb24gY29uc3RydWN0b3IsIHRoZSBiZXN0IHdlIGNhblxuICAgICAgICAvLyBkbyBpcyB0byBjaGVjayBpdHMgLm5hbWUgcHJvcGVydHkuXG4gICAgICAgIChjdG9yLmRpc3BsYXlOYW1lIHx8IGN0b3IubmFtZSkgPT09IFwiR2VuZXJhdG9yRnVuY3Rpb25cIlxuICAgICAgOiBmYWxzZTtcbiAgfTtcblxuICBydW50aW1lLm1hcmsgPSBmdW5jdGlvbihnZW5GdW4pIHtcbiAgICBpZiAoT2JqZWN0LnNldFByb3RvdHlwZU9mKSB7XG4gICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoZ2VuRnVuLCBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdlbkZ1bi5fX3Byb3RvX18gPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgICAgIGlmICghKHRvU3RyaW5nVGFnU3ltYm9sIGluIGdlbkZ1bikpIHtcbiAgICAgICAgZ2VuRnVuW3RvU3RyaW5nVGFnU3ltYm9sXSA9IFwiR2VuZXJhdG9yRnVuY3Rpb25cIjtcbiAgICAgIH1cbiAgICB9XG4gICAgZ2VuRnVuLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoR3ApO1xuICAgIHJldHVybiBnZW5GdW47XG4gIH07XG5cbiAgLy8gV2l0aGluIHRoZSBib2R5IG9mIGFueSBhc3luYyBmdW5jdGlvbiwgYGF3YWl0IHhgIGlzIHRyYW5zZm9ybWVkIHRvXG4gIC8vIGB5aWVsZCByZWdlbmVyYXRvclJ1bnRpbWUuYXdyYXAoeClgLCBzbyB0aGF0IHRoZSBydW50aW1lIGNhbiB0ZXN0XG4gIC8vIGBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpYCB0byBkZXRlcm1pbmUgaWYgdGhlIHlpZWxkZWQgdmFsdWUgaXNcbiAgLy8gbWVhbnQgdG8gYmUgYXdhaXRlZC5cbiAgcnVudGltZS5hd3JhcCA9IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB7IF9fYXdhaXQ6IGFyZyB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIEFzeW5jSXRlcmF0b3IoZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChnZW5lcmF0b3JbbWV0aG9kXSwgZ2VuZXJhdG9yLCBhcmcpO1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgcmVqZWN0KHJlY29yZC5hcmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHJlY29yZC5hcmc7XG4gICAgICAgIHZhciB2YWx1ZSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgaWYgKHZhbHVlICYmXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIikpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlLl9fYXdhaXQpLnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIGludm9rZShcIm5leHRcIiwgdmFsdWUsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJ0aHJvd1wiLCBlcnIsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uKHVud3JhcHBlZCkge1xuICAgICAgICAgIC8vIFdoZW4gYSB5aWVsZGVkIFByb21pc2UgaXMgcmVzb2x2ZWQsIGl0cyBmaW5hbCB2YWx1ZSBiZWNvbWVzXG4gICAgICAgICAgLy8gdGhlIC52YWx1ZSBvZiB0aGUgUHJvbWlzZTx7dmFsdWUsZG9uZX0+IHJlc3VsdCBmb3IgdGhlXG4gICAgICAgICAgLy8gY3VycmVudCBpdGVyYXRpb24uIElmIHRoZSBQcm9taXNlIGlzIHJlamVjdGVkLCBob3dldmVyLCB0aGVcbiAgICAgICAgICAvLyByZXN1bHQgZm9yIHRoaXMgaXRlcmF0aW9uIHdpbGwgYmUgcmVqZWN0ZWQgd2l0aCB0aGUgc2FtZVxuICAgICAgICAgIC8vIHJlYXNvbi4gTm90ZSB0aGF0IHJlamVjdGlvbnMgb2YgeWllbGRlZCBQcm9taXNlcyBhcmUgbm90XG4gICAgICAgICAgLy8gdGhyb3duIGJhY2sgaW50byB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uLCBhcyBpcyB0aGUgY2FzZVxuICAgICAgICAgIC8vIHdoZW4gYW4gYXdhaXRlZCBQcm9taXNlIGlzIHJlamVjdGVkLiBUaGlzIGRpZmZlcmVuY2UgaW5cbiAgICAgICAgICAvLyBiZWhhdmlvciBiZXR3ZWVuIHlpZWxkIGFuZCBhd2FpdCBpcyBpbXBvcnRhbnQsIGJlY2F1c2UgaXRcbiAgICAgICAgICAvLyBhbGxvd3MgdGhlIGNvbnN1bWVyIHRvIGRlY2lkZSB3aGF0IHRvIGRvIHdpdGggdGhlIHlpZWxkZWRcbiAgICAgICAgICAvLyByZWplY3Rpb24gKHN3YWxsb3cgaXQgYW5kIGNvbnRpbnVlLCBtYW51YWxseSAudGhyb3cgaXQgYmFja1xuICAgICAgICAgIC8vIGludG8gdGhlIGdlbmVyYXRvciwgYWJhbmRvbiBpdGVyYXRpb24sIHdoYXRldmVyKS4gV2l0aFxuICAgICAgICAgIC8vIGF3YWl0LCBieSBjb250cmFzdCwgdGhlcmUgaXMgbm8gb3Bwb3J0dW5pdHkgdG8gZXhhbWluZSB0aGVcbiAgICAgICAgICAvLyByZWplY3Rpb24gcmVhc29uIG91dHNpZGUgdGhlIGdlbmVyYXRvciBmdW5jdGlvbiwgc28gdGhlXG4gICAgICAgICAgLy8gb25seSBvcHRpb24gaXMgdG8gdGhyb3cgaXQgZnJvbSB0aGUgYXdhaXQgZXhwcmVzc2lvbiwgYW5kXG4gICAgICAgICAgLy8gbGV0IHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24gaGFuZGxlIHRoZSBleGNlcHRpb24uXG4gICAgICAgICAgcmVzdWx0LnZhbHVlID0gdW53cmFwcGVkO1xuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGdsb2JhbC5wcm9jZXNzID09PSBcIm9iamVjdFwiICYmIGdsb2JhbC5wcm9jZXNzLmRvbWFpbikge1xuICAgICAgaW52b2tlID0gZ2xvYmFsLnByb2Nlc3MuZG9tYWluLmJpbmQoaW52b2tlKTtcbiAgICB9XG5cbiAgICB2YXIgcHJldmlvdXNQcm9taXNlO1xuXG4gICAgZnVuY3Rpb24gZW5xdWV1ZShtZXRob2QsIGFyZykge1xuICAgICAgZnVuY3Rpb24gY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJldmlvdXNQcm9taXNlID1cbiAgICAgICAgLy8gSWYgZW5xdWV1ZSBoYXMgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIHdlIHdhbnQgdG8gd2FpdCB1bnRpbFxuICAgICAgICAvLyBhbGwgcHJldmlvdXMgUHJvbWlzZXMgaGF2ZSBiZWVuIHJlc29sdmVkIGJlZm9yZSBjYWxsaW5nIGludm9rZSxcbiAgICAgICAgLy8gc28gdGhhdCByZXN1bHRzIGFyZSBhbHdheXMgZGVsaXZlcmVkIGluIHRoZSBjb3JyZWN0IG9yZGVyLiBJZlxuICAgICAgICAvLyBlbnF1ZXVlIGhhcyBub3QgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIGl0IGlzIGltcG9ydGFudCB0b1xuICAgICAgICAvLyBjYWxsIGludm9rZSBpbW1lZGlhdGVseSwgd2l0aG91dCB3YWl0aW5nIG9uIGEgY2FsbGJhY2sgdG8gZmlyZSxcbiAgICAgICAgLy8gc28gdGhhdCB0aGUgYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIGhhcyB0aGUgb3Bwb3J0dW5pdHkgdG8gZG9cbiAgICAgICAgLy8gYW55IG5lY2Vzc2FyeSBzZXR1cCBpbiBhIHByZWRpY3RhYmxlIHdheS4gVGhpcyBwcmVkaWN0YWJpbGl0eVxuICAgICAgICAvLyBpcyB3aHkgdGhlIFByb21pc2UgY29uc3RydWN0b3Igc3luY2hyb25vdXNseSBpbnZva2VzIGl0c1xuICAgICAgICAvLyBleGVjdXRvciBjYWxsYmFjaywgYW5kIHdoeSBhc3luYyBmdW5jdGlvbnMgc3luY2hyb25vdXNseVxuICAgICAgICAvLyBleGVjdXRlIGNvZGUgYmVmb3JlIHRoZSBmaXJzdCBhd2FpdC4gU2luY2Ugd2UgaW1wbGVtZW50IHNpbXBsZVxuICAgICAgICAvLyBhc3luYyBmdW5jdGlvbnMgaW4gdGVybXMgb2YgYXN5bmMgZ2VuZXJhdG9ycywgaXQgaXMgZXNwZWNpYWxseVxuICAgICAgICAvLyBpbXBvcnRhbnQgdG8gZ2V0IHRoaXMgcmlnaHQsIGV2ZW4gdGhvdWdoIGl0IHJlcXVpcmVzIGNhcmUuXG4gICAgICAgIHByZXZpb3VzUHJvbWlzZSA/IHByZXZpb3VzUHJvbWlzZS50aGVuKFxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnLFxuICAgICAgICAgIC8vIEF2b2lkIHByb3BhZ2F0aW5nIGZhaWx1cmVzIHRvIFByb21pc2VzIHJldHVybmVkIGJ5IGxhdGVyXG4gICAgICAgICAgLy8gaW52b2NhdGlvbnMgb2YgdGhlIGl0ZXJhdG9yLlxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnXG4gICAgICAgICkgOiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpO1xuICAgIH1cblxuICAgIC8vIERlZmluZSB0aGUgdW5pZmllZCBoZWxwZXIgbWV0aG9kIHRoYXQgaXMgdXNlZCB0byBpbXBsZW1lbnQgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiAoc2VlIGRlZmluZUl0ZXJhdG9yTWV0aG9kcykuXG4gICAgdGhpcy5faW52b2tlID0gZW5xdWV1ZTtcbiAgfVxuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSk7XG4gIEFzeW5jSXRlcmF0b3IucHJvdG90eXBlW2FzeW5jSXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBydW50aW1lLkFzeW5jSXRlcmF0b3IgPSBBc3luY0l0ZXJhdG9yO1xuXG4gIC8vIE5vdGUgdGhhdCBzaW1wbGUgYXN5bmMgZnVuY3Rpb25zIGFyZSBpbXBsZW1lbnRlZCBvbiB0b3Agb2ZcbiAgLy8gQXN5bmNJdGVyYXRvciBvYmplY3RzOyB0aGV5IGp1c3QgcmV0dXJuIGEgUHJvbWlzZSBmb3IgdGhlIHZhbHVlIG9mXG4gIC8vIHRoZSBmaW5hbCByZXN1bHQgcHJvZHVjZWQgYnkgdGhlIGl0ZXJhdG9yLlxuICBydW50aW1lLmFzeW5jID0gZnVuY3Rpb24oaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICB2YXIgaXRlciA9IG5ldyBBc3luY0l0ZXJhdG9yKFxuICAgICAgd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdClcbiAgICApO1xuXG4gICAgcmV0dXJuIHJ1bnRpbWUuaXNHZW5lcmF0b3JGdW5jdGlvbihvdXRlckZuKVxuICAgICAgPyBpdGVyIC8vIElmIG91dGVyRm4gaXMgYSBnZW5lcmF0b3IsIHJldHVybiB0aGUgZnVsbCBpdGVyYXRvci5cbiAgICAgIDogaXRlci5uZXh0KCkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0LmRvbmUgPyByZXN1bHQudmFsdWUgOiBpdGVyLm5leHQoKTtcbiAgICAgICAgfSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KSB7XG4gICAgdmFyIHN0YXRlID0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydDtcblxuICAgIHJldHVybiBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcpIHtcbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVFeGVjdXRpbmcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgcnVubmluZ1wiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUNvbXBsZXRlZCkge1xuICAgICAgICBpZiAobWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICB0aHJvdyBhcmc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCZSBmb3JnaXZpbmcsIHBlciAyNS4zLjMuMy4zIG9mIHRoZSBzcGVjOlxuICAgICAgICAvLyBodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtZ2VuZXJhdG9ycmVzdW1lXG4gICAgICAgIHJldHVybiBkb25lUmVzdWx0KCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQubWV0aG9kID0gbWV0aG9kO1xuICAgICAgY29udGV4dC5hcmcgPSBhcmc7XG5cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciBkZWxlZ2F0ZSA9IGNvbnRleHQuZGVsZWdhdGU7XG4gICAgICAgIGlmIChkZWxlZ2F0ZSkge1xuICAgICAgICAgIHZhciBkZWxlZ2F0ZVJlc3VsdCA9IG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0ID09PSBDb250aW51ZVNlbnRpbmVsKSBjb250aW51ZTtcbiAgICAgICAgICAgIHJldHVybiBkZWxlZ2F0ZVJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgICAgLy8gU2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgICAgICBjb250ZXh0LnNlbnQgPSBjb250ZXh0Ll9zZW50ID0gY29udGV4dC5hcmc7XG5cbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0KSB7XG4gICAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgICAgdGhyb3cgY29udGV4dC5hcmc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZyk7XG5cbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICAgIGNvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGNvbnRleHQuYXJnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlID0gR2VuU3RhdGVFeGVjdXRpbmc7XG5cbiAgICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIpIHtcbiAgICAgICAgICAvLyBJZiBhbiBleGNlcHRpb24gaXMgdGhyb3duIGZyb20gaW5uZXJGbiwgd2UgbGVhdmUgc3RhdGUgPT09XG4gICAgICAgICAgLy8gR2VuU3RhdGVFeGVjdXRpbmcgYW5kIGxvb3AgYmFjayBmb3IgYW5vdGhlciBpbnZvY2F0aW9uLlxuICAgICAgICAgIHN0YXRlID0gY29udGV4dC5kb25lXG4gICAgICAgICAgICA/IEdlblN0YXRlQ29tcGxldGVkXG4gICAgICAgICAgICA6IEdlblN0YXRlU3VzcGVuZGVkWWllbGQ7XG5cbiAgICAgICAgICBpZiAocmVjb3JkLmFyZyA9PT0gQ29udGludWVTZW50aW5lbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiByZWNvcmQuYXJnLFxuICAgICAgICAgICAgZG9uZTogY29udGV4dC5kb25lXG4gICAgICAgICAgfTtcblxuICAgICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgIC8vIERpc3BhdGNoIHRoZSBleGNlcHRpb24gYnkgbG9vcGluZyBiYWNrIGFyb3VuZCB0byB0aGVcbiAgICAgICAgICAvLyBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKSBjYWxsIGFib3ZlLlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvLyBDYWxsIGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXShjb250ZXh0LmFyZykgYW5kIGhhbmRsZSB0aGVcbiAgLy8gcmVzdWx0LCBlaXRoZXIgYnkgcmV0dXJuaW5nIGEgeyB2YWx1ZSwgZG9uZSB9IHJlc3VsdCBmcm9tIHRoZVxuICAvLyBkZWxlZ2F0ZSBpdGVyYXRvciwgb3IgYnkgbW9kaWZ5aW5nIGNvbnRleHQubWV0aG9kIGFuZCBjb250ZXh0LmFyZyxcbiAgLy8gc2V0dGluZyBjb250ZXh0LmRlbGVnYXRlIHRvIG51bGwsIGFuZCByZXR1cm5pbmcgdGhlIENvbnRpbnVlU2VudGluZWwuXG4gIGZ1bmN0aW9uIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpIHtcbiAgICB2YXIgbWV0aG9kID0gZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdO1xuICAgIGlmIChtZXRob2QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gQSAudGhyb3cgb3IgLnJldHVybiB3aGVuIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgbm8gLnRocm93XG4gICAgICAvLyBtZXRob2QgYWx3YXlzIHRlcm1pbmF0ZXMgdGhlIHlpZWxkKiBsb29wLlxuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIGlmIChkZWxlZ2F0ZS5pdGVyYXRvci5yZXR1cm4pIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIGEgcmV0dXJuIG1ldGhvZCwgZ2l2ZSBpdCBhXG4gICAgICAgICAgLy8gY2hhbmNlIHRvIGNsZWFuIHVwLlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcblxuICAgICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICAvLyBJZiBtYXliZUludm9rZURlbGVnYXRlKGNvbnRleHQpIGNoYW5nZWQgY29udGV4dC5tZXRob2QgZnJvbVxuICAgICAgICAgICAgLy8gXCJyZXR1cm5cIiB0byBcInRocm93XCIsIGxldCB0aGF0IG92ZXJyaWRlIHRoZSBUeXBlRXJyb3IgYmVsb3cuXG4gICAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgIFwiVGhlIGl0ZXJhdG9yIGRvZXMgbm90IHByb3ZpZGUgYSAndGhyb3cnIG1ldGhvZFwiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKG1ldGhvZCwgZGVsZWdhdGUuaXRlcmF0b3IsIGNvbnRleHQuYXJnKTtcblxuICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgdmFyIGluZm8gPSByZWNvcmQuYXJnO1xuXG4gICAgaWYgKCEgaW5mbykge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXCJpdGVyYXRvciByZXN1bHQgaXMgbm90IGFuIG9iamVjdFwiKTtcbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgaWYgKGluZm8uZG9uZSkge1xuICAgICAgLy8gQXNzaWduIHRoZSByZXN1bHQgb2YgdGhlIGZpbmlzaGVkIGRlbGVnYXRlIHRvIHRoZSB0ZW1wb3JhcnlcbiAgICAgIC8vIHZhcmlhYmxlIHNwZWNpZmllZCBieSBkZWxlZ2F0ZS5yZXN1bHROYW1lIChzZWUgZGVsZWdhdGVZaWVsZCkuXG4gICAgICBjb250ZXh0W2RlbGVnYXRlLnJlc3VsdE5hbWVdID0gaW5mby52YWx1ZTtcblxuICAgICAgLy8gUmVzdW1lIGV4ZWN1dGlvbiBhdCB0aGUgZGVzaXJlZCBsb2NhdGlvbiAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dC5uZXh0ID0gZGVsZWdhdGUubmV4dExvYztcblxuICAgICAgLy8gSWYgY29udGV4dC5tZXRob2Qgd2FzIFwidGhyb3dcIiBidXQgdGhlIGRlbGVnYXRlIGhhbmRsZWQgdGhlXG4gICAgICAvLyBleGNlcHRpb24sIGxldCB0aGUgb3V0ZXIgZ2VuZXJhdG9yIHByb2NlZWQgbm9ybWFsbHkuIElmXG4gICAgICAvLyBjb250ZXh0Lm1ldGhvZCB3YXMgXCJuZXh0XCIsIGZvcmdldCBjb250ZXh0LmFyZyBzaW5jZSBpdCBoYXMgYmVlblxuICAgICAgLy8gXCJjb25zdW1lZFwiIGJ5IHRoZSBkZWxlZ2F0ZSBpdGVyYXRvci4gSWYgY29udGV4dC5tZXRob2Qgd2FzXG4gICAgICAvLyBcInJldHVyblwiLCBhbGxvdyB0aGUgb3JpZ2luYWwgLnJldHVybiBjYWxsIHRvIGNvbnRpbnVlIGluIHRoZVxuICAgICAgLy8gb3V0ZXIgZ2VuZXJhdG9yLlxuICAgICAgaWYgKGNvbnRleHQubWV0aG9kICE9PSBcInJldHVyblwiKSB7XG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlLXlpZWxkIHRoZSByZXN1bHQgcmV0dXJuZWQgYnkgdGhlIGRlbGVnYXRlIG1ldGhvZC5cbiAgICAgIHJldHVybiBpbmZvO1xuICAgIH1cblxuICAgIC8vIFRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBpcyBmaW5pc2hlZCwgc28gZm9yZ2V0IGl0IGFuZCBjb250aW51ZSB3aXRoXG4gICAgLy8gdGhlIG91dGVyIGdlbmVyYXRvci5cbiAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgfVxuXG4gIC8vIERlZmluZSBHZW5lcmF0b3IucHJvdG90eXBlLntuZXh0LHRocm93LHJldHVybn0gaW4gdGVybXMgb2YgdGhlXG4gIC8vIHVuaWZpZWQgLl9pbnZva2UgaGVscGVyIG1ldGhvZC5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEdwKTtcblxuICBHcFt0b1N0cmluZ1RhZ1N5bWJvbF0gPSBcIkdlbmVyYXRvclwiO1xuXG4gIC8vIEEgR2VuZXJhdG9yIHNob3VsZCBhbHdheXMgcmV0dXJuIGl0c2VsZiBhcyB0aGUgaXRlcmF0b3Igb2JqZWN0IHdoZW4gdGhlXG4gIC8vIEBAaXRlcmF0b3IgZnVuY3Rpb24gaXMgY2FsbGVkIG9uIGl0LiBTb21lIGJyb3dzZXJzJyBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlXG4gIC8vIGl0ZXJhdG9yIHByb3RvdHlwZSBjaGFpbiBpbmNvcnJlY3RseSBpbXBsZW1lbnQgdGhpcywgY2F1c2luZyB0aGUgR2VuZXJhdG9yXG4gIC8vIG9iamVjdCB0byBub3QgYmUgcmV0dXJuZWQgZnJvbSB0aGlzIGNhbGwuIFRoaXMgZW5zdXJlcyB0aGF0IGRvZXNuJ3QgaGFwcGVuLlxuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlZ2VuZXJhdG9yL2lzc3Vlcy8yNzQgZm9yIG1vcmUgZGV0YWlscy5cbiAgR3BbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgR3AudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXCJbb2JqZWN0IEdlbmVyYXRvcl1cIjtcbiAgfTtcblxuICBmdW5jdGlvbiBwdXNoVHJ5RW50cnkobG9jcykge1xuICAgIHZhciBlbnRyeSA9IHsgdHJ5TG9jOiBsb2NzWzBdIH07XG5cbiAgICBpZiAoMSBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5jYXRjaExvYyA9IGxvY3NbMV07XG4gICAgfVxuXG4gICAgaWYgKDIgaW4gbG9jcykge1xuICAgICAgZW50cnkuZmluYWxseUxvYyA9IGxvY3NbMl07XG4gICAgICBlbnRyeS5hZnRlckxvYyA9IGxvY3NbM107XG4gICAgfVxuXG4gICAgdGhpcy50cnlFbnRyaWVzLnB1c2goZW50cnkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRUcnlFbnRyeShlbnRyeSkge1xuICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uIHx8IHt9O1xuICAgIHJlY29yZC50eXBlID0gXCJub3JtYWxcIjtcbiAgICBkZWxldGUgcmVjb3JkLmFyZztcbiAgICBlbnRyeS5jb21wbGV0aW9uID0gcmVjb3JkO1xuICB9XG5cbiAgZnVuY3Rpb24gQ29udGV4dCh0cnlMb2NzTGlzdCkge1xuICAgIC8vIFRoZSByb290IGVudHJ5IG9iamVjdCAoZWZmZWN0aXZlbHkgYSB0cnkgc3RhdGVtZW50IHdpdGhvdXQgYSBjYXRjaFxuICAgIC8vIG9yIGEgZmluYWxseSBibG9jaykgZ2l2ZXMgdXMgYSBwbGFjZSB0byBzdG9yZSB2YWx1ZXMgdGhyb3duIGZyb21cbiAgICAvLyBsb2NhdGlvbnMgd2hlcmUgdGhlcmUgaXMgbm8gZW5jbG9zaW5nIHRyeSBzdGF0ZW1lbnQuXG4gICAgdGhpcy50cnlFbnRyaWVzID0gW3sgdHJ5TG9jOiBcInJvb3RcIiB9XTtcbiAgICB0cnlMb2NzTGlzdC5mb3JFYWNoKHB1c2hUcnlFbnRyeSwgdGhpcyk7XG4gICAgdGhpcy5yZXNldCh0cnVlKTtcbiAgfVxuXG4gIHJ1bnRpbWUua2V5cyA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgfVxuICAgIGtleXMucmV2ZXJzZSgpO1xuXG4gICAgLy8gUmF0aGVyIHRoYW4gcmV0dXJuaW5nIGFuIG9iamVjdCB3aXRoIGEgbmV4dCBtZXRob2QsIHdlIGtlZXBcbiAgICAvLyB0aGluZ3Mgc2ltcGxlIGFuZCByZXR1cm4gdGhlIG5leHQgZnVuY3Rpb24gaXRzZWxmLlxuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgd2hpbGUgKGtleXMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzLnBvcCgpO1xuICAgICAgICBpZiAoa2V5IGluIG9iamVjdCkge1xuICAgICAgICAgIG5leHQudmFsdWUgPSBrZXk7XG4gICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVG8gYXZvaWQgY3JlYXRpbmcgYW4gYWRkaXRpb25hbCBvYmplY3QsIHdlIGp1c3QgaGFuZyB0aGUgLnZhbHVlXG4gICAgICAvLyBhbmQgLmRvbmUgcHJvcGVydGllcyBvZmYgdGhlIG5leHQgZnVuY3Rpb24gb2JqZWN0IGl0c2VsZi4gVGhpc1xuICAgICAgLy8gYWxzbyBlbnN1cmVzIHRoYXQgdGhlIG1pbmlmaWVyIHdpbGwgbm90IGFub255bWl6ZSB0aGUgZnVuY3Rpb24uXG4gICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfTtcbiAgfTtcblxuICBmdW5jdGlvbiB2YWx1ZXMoaXRlcmFibGUpIHtcbiAgICBpZiAoaXRlcmFibGUpIHtcbiAgICAgIHZhciBpdGVyYXRvck1ldGhvZCA9IGl0ZXJhYmxlW2l0ZXJhdG9yU3ltYm9sXTtcbiAgICAgIGlmIChpdGVyYXRvck1ldGhvZCkge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JNZXRob2QuY2FsbChpdGVyYWJsZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlcmFibGUubmV4dCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBpdGVyYWJsZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc05hTihpdGVyYWJsZS5sZW5ndGgpKSB7XG4gICAgICAgIHZhciBpID0gLTEsIG5leHQgPSBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICAgIHdoaWxlICgrK2kgPCBpdGVyYWJsZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd24uY2FsbChpdGVyYWJsZSwgaSkpIHtcbiAgICAgICAgICAgICAgbmV4dC52YWx1ZSA9IGl0ZXJhYmxlW2ldO1xuICAgICAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbmV4dC52YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuXG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIG5leHQubmV4dCA9IG5leHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIGFuIGl0ZXJhdG9yIHdpdGggbm8gdmFsdWVzLlxuICAgIHJldHVybiB7IG5leHQ6IGRvbmVSZXN1bHQgfTtcbiAgfVxuICBydW50aW1lLnZhbHVlcyA9IHZhbHVlcztcblxuICBmdW5jdGlvbiBkb25lUmVzdWx0KCkge1xuICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgfVxuXG4gIENvbnRleHQucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBDb250ZXh0LFxuXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKHNraXBUZW1wUmVzZXQpIHtcbiAgICAgIHRoaXMucHJldiA9IDA7XG4gICAgICB0aGlzLm5leHQgPSAwO1xuICAgICAgLy8gUmVzZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICB0aGlzLnNlbnQgPSB0aGlzLl9zZW50ID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICB0aGlzLmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkO1xuXG4gICAgICB0aGlzLnRyeUVudHJpZXMuZm9yRWFjaChyZXNldFRyeUVudHJ5KTtcblxuICAgICAgaWYgKCFza2lwVGVtcFJlc2V0KSB7XG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gdGhpcykge1xuICAgICAgICAgIC8vIE5vdCBzdXJlIGFib3V0IHRoZSBvcHRpbWFsIG9yZGVyIG9mIHRoZXNlIGNvbmRpdGlvbnM6XG4gICAgICAgICAgaWYgKG5hbWUuY2hhckF0KDApID09PSBcInRcIiAmJlxuICAgICAgICAgICAgICBoYXNPd24uY2FsbCh0aGlzLCBuYW1lKSAmJlxuICAgICAgICAgICAgICAhaXNOYU4oK25hbWUuc2xpY2UoMSkpKSB7XG4gICAgICAgICAgICB0aGlzW25hbWVdID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBzdG9wOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG5cbiAgICAgIHZhciByb290RW50cnkgPSB0aGlzLnRyeUVudHJpZXNbMF07XG4gICAgICB2YXIgcm9vdFJlY29yZCA9IHJvb3RFbnRyeS5jb21wbGV0aW9uO1xuICAgICAgaWYgKHJvb3RSZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJvb3RSZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5ydmFsO1xuICAgIH0sXG5cbiAgICBkaXNwYXRjaEV4Y2VwdGlvbjogZnVuY3Rpb24oZXhjZXB0aW9uKSB7XG4gICAgICBpZiAodGhpcy5kb25lKSB7XG4gICAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzO1xuICAgICAgZnVuY3Rpb24gaGFuZGxlKGxvYywgY2F1Z2h0KSB7XG4gICAgICAgIHJlY29yZC50eXBlID0gXCJ0aHJvd1wiO1xuICAgICAgICByZWNvcmQuYXJnID0gZXhjZXB0aW9uO1xuICAgICAgICBjb250ZXh0Lm5leHQgPSBsb2M7XG5cbiAgICAgICAgaWYgKGNhdWdodCkge1xuICAgICAgICAgIC8vIElmIHRoZSBkaXNwYXRjaGVkIGV4Y2VwdGlvbiB3YXMgY2F1Z2h0IGJ5IGEgY2F0Y2ggYmxvY2ssXG4gICAgICAgICAgLy8gdGhlbiBsZXQgdGhhdCBjYXRjaCBibG9jayBoYW5kbGUgdGhlIGV4Y2VwdGlvbiBub3JtYWxseS5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICEhIGNhdWdodDtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IFwicm9vdFwiKSB7XG4gICAgICAgICAgLy8gRXhjZXB0aW9uIHRocm93biBvdXRzaWRlIG9mIGFueSB0cnkgYmxvY2sgdGhhdCBjb3VsZCBoYW5kbGVcbiAgICAgICAgICAvLyBpdCwgc28gc2V0IHRoZSBjb21wbGV0aW9uIHZhbHVlIG9mIHRoZSBlbnRpcmUgZnVuY3Rpb24gdG9cbiAgICAgICAgICAvLyB0aHJvdyB0aGUgZXhjZXB0aW9uLlxuICAgICAgICAgIHJldHVybiBoYW5kbGUoXCJlbmRcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldikge1xuICAgICAgICAgIHZhciBoYXNDYXRjaCA9IGhhc093bi5jYWxsKGVudHJ5LCBcImNhdGNoTG9jXCIpO1xuICAgICAgICAgIHZhciBoYXNGaW5hbGx5ID0gaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKTtcblxuICAgICAgICAgIGlmIChoYXNDYXRjaCAmJiBoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzQ2F0Y2gpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0cnkgc3RhdGVtZW50IHdpdGhvdXQgY2F0Y2ggb3IgZmluYWxseVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYWJydXB0OiBmdW5jdGlvbih0eXBlLCBhcmcpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKSAmJlxuICAgICAgICAgICAgdGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgIHZhciBmaW5hbGx5RW50cnkgPSBlbnRyeTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZmluYWxseUVudHJ5ICYmXG4gICAgICAgICAgKHR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgICB0eXBlID09PSBcImNvbnRpbnVlXCIpICYmXG4gICAgICAgICAgZmluYWxseUVudHJ5LnRyeUxvYyA8PSBhcmcgJiZcbiAgICAgICAgICBhcmcgPD0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgLy8gSWdub3JlIHRoZSBmaW5hbGx5IGVudHJ5IGlmIGNvbnRyb2wgaXMgbm90IGp1bXBpbmcgdG8gYVxuICAgICAgICAvLyBsb2NhdGlvbiBvdXRzaWRlIHRoZSB0cnkvY2F0Y2ggYmxvY2suXG4gICAgICAgIGZpbmFsbHlFbnRyeSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWNvcmQgPSBmaW5hbGx5RW50cnkgPyBmaW5hbGx5RW50cnkuY29tcGxldGlvbiA6IHt9O1xuICAgICAgcmVjb3JkLnR5cGUgPSB0eXBlO1xuICAgICAgcmVjb3JkLmFyZyA9IGFyZztcblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSkge1xuICAgICAgICB0aGlzLm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICB0aGlzLm5leHQgPSBmaW5hbGx5RW50cnkuZmluYWxseUxvYztcbiAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmNvbXBsZXRlKHJlY29yZCk7XG4gICAgfSxcblxuICAgIGNvbXBsZXRlOiBmdW5jdGlvbihyZWNvcmQsIGFmdGVyTG9jKSB7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgIHJlY29yZC50eXBlID09PSBcImNvbnRpbnVlXCIpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gcmVjb3JkLmFyZztcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgdGhpcy5ydmFsID0gdGhpcy5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB0aGlzLm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgIHRoaXMubmV4dCA9IFwiZW5kXCI7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiICYmIGFmdGVyTG9jKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IGFmdGVyTG9jO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9LFxuXG4gICAgZmluaXNoOiBmdW5jdGlvbihmaW5hbGx5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LmZpbmFsbHlMb2MgPT09IGZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB0aGlzLmNvbXBsZXRlKGVudHJ5LmNvbXBsZXRpb24sIGVudHJ5LmFmdGVyTG9jKTtcbiAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBcImNhdGNoXCI6IGZ1bmN0aW9uKHRyeUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IHRyeUxvYykge1xuICAgICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICB2YXIgdGhyb3duID0gcmVjb3JkLmFyZztcbiAgICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhyb3duO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBjb250ZXh0LmNhdGNoIG1ldGhvZCBtdXN0IG9ubHkgYmUgY2FsbGVkIHdpdGggYSBsb2NhdGlvblxuICAgICAgLy8gYXJndW1lbnQgdGhhdCBjb3JyZXNwb25kcyB0byBhIGtub3duIGNhdGNoIGJsb2NrLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCBjYXRjaCBhdHRlbXB0XCIpO1xuICAgIH0sXG5cbiAgICBkZWxlZ2F0ZVlpZWxkOiBmdW5jdGlvbihpdGVyYWJsZSwgcmVzdWx0TmFtZSwgbmV4dExvYykge1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IHtcbiAgICAgICAgaXRlcmF0b3I6IHZhbHVlcyhpdGVyYWJsZSksXG4gICAgICAgIHJlc3VsdE5hbWU6IHJlc3VsdE5hbWUsXG4gICAgICAgIG5leHRMb2M6IG5leHRMb2NcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgLy8gRGVsaWJlcmF0ZWx5IGZvcmdldCB0aGUgbGFzdCBzZW50IHZhbHVlIHNvIHRoYXQgd2UgZG9uJ3RcbiAgICAgICAgLy8gYWNjaWRlbnRhbGx5IHBhc3MgaXQgb24gdG8gdGhlIGRlbGVnYXRlLlxuICAgICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuICB9O1xufSkoXG4gIC8vIEFtb25nIHRoZSB2YXJpb3VzIHRyaWNrcyBmb3Igb2J0YWluaW5nIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWxcbiAgLy8gb2JqZWN0LCB0aGlzIHNlZW1zIHRvIGJlIHRoZSBtb3N0IHJlbGlhYmxlIHRlY2huaXF1ZSB0aGF0IGRvZXMgbm90XG4gIC8vIHVzZSBpbmRpcmVjdCBldmFsICh3aGljaCB2aW9sYXRlcyBDb250ZW50IFNlY3VyaXR5IFBvbGljeSkuXG4gIHR5cGVvZiBnbG9iYWwgPT09IFwib2JqZWN0XCIgPyBnbG9iYWwgOlxuICB0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiID8gd2luZG93IDpcbiAgdHlwZW9mIHNlbGYgPT09IFwib2JqZWN0XCIgPyBzZWxmIDogdGhpc1xuKTtcbiIsIiIsIi8qIVxuICogQ3Jvc3MtQnJvd3NlciBTcGxpdCAxLjEuMVxuICogQ29weXJpZ2h0IDIwMDctMjAxMiBTdGV2ZW4gTGV2aXRoYW4gPHN0ZXZlbmxldml0aGFuLmNvbT5cbiAqIEF2YWlsYWJsZSB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqIEVDTUFTY3JpcHQgY29tcGxpYW50LCB1bmlmb3JtIGNyb3NzLWJyb3dzZXIgc3BsaXQgbWV0aG9kXG4gKi9cblxuLyoqXG4gKiBTcGxpdHMgYSBzdHJpbmcgaW50byBhbiBhcnJheSBvZiBzdHJpbmdzIHVzaW5nIGEgcmVnZXggb3Igc3RyaW5nIHNlcGFyYXRvci4gTWF0Y2hlcyBvZiB0aGVcbiAqIHNlcGFyYXRvciBhcmUgbm90IGluY2x1ZGVkIGluIHRoZSByZXN1bHQgYXJyYXkuIEhvd2V2ZXIsIGlmIGBzZXBhcmF0b3JgIGlzIGEgcmVnZXggdGhhdCBjb250YWluc1xuICogY2FwdHVyaW5nIGdyb3VwcywgYmFja3JlZmVyZW5jZXMgYXJlIHNwbGljZWQgaW50byB0aGUgcmVzdWx0IGVhY2ggdGltZSBgc2VwYXJhdG9yYCBpcyBtYXRjaGVkLlxuICogRml4ZXMgYnJvd3NlciBidWdzIGNvbXBhcmVkIHRvIHRoZSBuYXRpdmUgYFN0cmluZy5wcm90b3R5cGUuc3BsaXRgIGFuZCBjYW4gYmUgdXNlZCByZWxpYWJseVxuICogY3Jvc3MtYnJvd3Nlci5cbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgU3RyaW5nIHRvIHNwbGl0LlxuICogQHBhcmFtIHtSZWdFeHB8U3RyaW5nfSBzZXBhcmF0b3IgUmVnZXggb3Igc3RyaW5nIHRvIHVzZSBmb3Igc2VwYXJhdGluZyB0aGUgc3RyaW5nLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtsaW1pdF0gTWF4aW11bSBudW1iZXIgb2YgaXRlbXMgdG8gaW5jbHVkZSBpbiB0aGUgcmVzdWx0IGFycmF5LlxuICogQHJldHVybnMge0FycmF5fSBBcnJheSBvZiBzdWJzdHJpbmdzLlxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBCYXNpYyB1c2VcbiAqIHNwbGl0KCdhIGIgYyBkJywgJyAnKTtcbiAqIC8vIC0+IFsnYScsICdiJywgJ2MnLCAnZCddXG4gKlxuICogLy8gV2l0aCBsaW1pdFxuICogc3BsaXQoJ2EgYiBjIGQnLCAnICcsIDIpO1xuICogLy8gLT4gWydhJywgJ2InXVxuICpcbiAqIC8vIEJhY2tyZWZlcmVuY2VzIGluIHJlc3VsdCBhcnJheVxuICogc3BsaXQoJy4ud29yZDEgd29yZDIuLicsIC8oW2Etel0rKShcXGQrKS9pKTtcbiAqIC8vIC0+IFsnLi4nLCAnd29yZCcsICcxJywgJyAnLCAnd29yZCcsICcyJywgJy4uJ11cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24gc3BsaXQodW5kZWYpIHtcblxuICB2YXIgbmF0aXZlU3BsaXQgPSBTdHJpbmcucHJvdG90eXBlLnNwbGl0LFxuICAgIGNvbXBsaWFudEV4ZWNOcGNnID0gLygpPz8vLmV4ZWMoXCJcIilbMV0gPT09IHVuZGVmLFxuICAgIC8vIE5QQ0c6IG5vbnBhcnRpY2lwYXRpbmcgY2FwdHVyaW5nIGdyb3VwXG4gICAgc2VsZjtcblxuICBzZWxmID0gZnVuY3Rpb24oc3RyLCBzZXBhcmF0b3IsIGxpbWl0KSB7XG4gICAgLy8gSWYgYHNlcGFyYXRvcmAgaXMgbm90IGEgcmVnZXgsIHVzZSBgbmF0aXZlU3BsaXRgXG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzZXBhcmF0b3IpICE9PSBcIltvYmplY3QgUmVnRXhwXVwiKSB7XG4gICAgICByZXR1cm4gbmF0aXZlU3BsaXQuY2FsbChzdHIsIHNlcGFyYXRvciwgbGltaXQpO1xuICAgIH1cbiAgICB2YXIgb3V0cHV0ID0gW10sXG4gICAgICBmbGFncyA9IChzZXBhcmF0b3IuaWdub3JlQ2FzZSA/IFwiaVwiIDogXCJcIikgKyAoc2VwYXJhdG9yLm11bHRpbGluZSA/IFwibVwiIDogXCJcIikgKyAoc2VwYXJhdG9yLmV4dGVuZGVkID8gXCJ4XCIgOiBcIlwiKSArIC8vIFByb3Bvc2VkIGZvciBFUzZcbiAgICAgIChzZXBhcmF0b3Iuc3RpY2t5ID8gXCJ5XCIgOiBcIlwiKSxcbiAgICAgIC8vIEZpcmVmb3ggMytcbiAgICAgIGxhc3RMYXN0SW5kZXggPSAwLFxuICAgICAgLy8gTWFrZSBgZ2xvYmFsYCBhbmQgYXZvaWQgYGxhc3RJbmRleGAgaXNzdWVzIGJ5IHdvcmtpbmcgd2l0aCBhIGNvcHlcbiAgICAgIHNlcGFyYXRvciA9IG5ldyBSZWdFeHAoc2VwYXJhdG9yLnNvdXJjZSwgZmxhZ3MgKyBcImdcIiksXG4gICAgICBzZXBhcmF0b3IyLCBtYXRjaCwgbGFzdEluZGV4LCBsYXN0TGVuZ3RoO1xuICAgIHN0ciArPSBcIlwiOyAvLyBUeXBlLWNvbnZlcnRcbiAgICBpZiAoIWNvbXBsaWFudEV4ZWNOcGNnKSB7XG4gICAgICAvLyBEb2Vzbid0IG5lZWQgZmxhZ3MgZ3ksIGJ1dCB0aGV5IGRvbid0IGh1cnRcbiAgICAgIHNlcGFyYXRvcjIgPSBuZXcgUmVnRXhwKFwiXlwiICsgc2VwYXJhdG9yLnNvdXJjZSArIFwiJCg/IVxcXFxzKVwiLCBmbGFncyk7XG4gICAgfVxuICAgIC8qIFZhbHVlcyBmb3IgYGxpbWl0YCwgcGVyIHRoZSBzcGVjOlxuICAgICAqIElmIHVuZGVmaW5lZDogNDI5NDk2NzI5NSAvLyBNYXRoLnBvdygyLCAzMikgLSAxXG4gICAgICogSWYgMCwgSW5maW5pdHksIG9yIE5hTjogMFxuICAgICAqIElmIHBvc2l0aXZlIG51bWJlcjogbGltaXQgPSBNYXRoLmZsb29yKGxpbWl0KTsgaWYgKGxpbWl0ID4gNDI5NDk2NzI5NSkgbGltaXQgLT0gNDI5NDk2NzI5NjtcbiAgICAgKiBJZiBuZWdhdGl2ZSBudW1iZXI6IDQyOTQ5NjcyOTYgLSBNYXRoLmZsb29yKE1hdGguYWJzKGxpbWl0KSlcbiAgICAgKiBJZiBvdGhlcjogVHlwZS1jb252ZXJ0LCB0aGVuIHVzZSB0aGUgYWJvdmUgcnVsZXNcbiAgICAgKi9cbiAgICBsaW1pdCA9IGxpbWl0ID09PSB1bmRlZiA/IC0xID4+PiAwIDogLy8gTWF0aC5wb3coMiwgMzIpIC0gMVxuICAgIGxpbWl0ID4+PiAwOyAvLyBUb1VpbnQzMihsaW1pdClcbiAgICB3aGlsZSAobWF0Y2ggPSBzZXBhcmF0b3IuZXhlYyhzdHIpKSB7XG4gICAgICAvLyBgc2VwYXJhdG9yLmxhc3RJbmRleGAgaXMgbm90IHJlbGlhYmxlIGNyb3NzLWJyb3dzZXJcbiAgICAgIGxhc3RJbmRleCA9IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgaWYgKGxhc3RJbmRleCA+IGxhc3RMYXN0SW5kZXgpIHtcbiAgICAgICAgb3V0cHV0LnB1c2goc3RyLnNsaWNlKGxhc3RMYXN0SW5kZXgsIG1hdGNoLmluZGV4KSk7XG4gICAgICAgIC8vIEZpeCBicm93c2VycyB3aG9zZSBgZXhlY2AgbWV0aG9kcyBkb24ndCBjb25zaXN0ZW50bHkgcmV0dXJuIGB1bmRlZmluZWRgIGZvclxuICAgICAgICAvLyBub25wYXJ0aWNpcGF0aW5nIGNhcHR1cmluZyBncm91cHNcbiAgICAgICAgaWYgKCFjb21wbGlhbnRFeGVjTnBjZyAmJiBtYXRjaC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgbWF0Y2hbMF0ucmVwbGFjZShzZXBhcmF0b3IyLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aCAtIDI7IGkrKykge1xuICAgICAgICAgICAgICBpZiAoYXJndW1lbnRzW2ldID09PSB1bmRlZikge1xuICAgICAgICAgICAgICAgIG1hdGNoW2ldID0gdW5kZWY7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF0Y2gubGVuZ3RoID4gMSAmJiBtYXRjaC5pbmRleCA8IHN0ci5sZW5ndGgpIHtcbiAgICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShvdXRwdXQsIG1hdGNoLnNsaWNlKDEpKTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0TGVuZ3RoID0gbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICBsYXN0TGFzdEluZGV4ID0gbGFzdEluZGV4O1xuICAgICAgICBpZiAob3V0cHV0Lmxlbmd0aCA+PSBsaW1pdCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc2VwYXJhdG9yLmxhc3RJbmRleCA9PT0gbWF0Y2guaW5kZXgpIHtcbiAgICAgICAgc2VwYXJhdG9yLmxhc3RJbmRleCsrOyAvLyBBdm9pZCBhbiBpbmZpbml0ZSBsb29wXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChsYXN0TGFzdEluZGV4ID09PSBzdHIubGVuZ3RoKSB7XG4gICAgICBpZiAobGFzdExlbmd0aCB8fCAhc2VwYXJhdG9yLnRlc3QoXCJcIikpIHtcbiAgICAgICAgb3V0cHV0LnB1c2goXCJcIik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dC5wdXNoKHN0ci5zbGljZShsYXN0TGFzdEluZGV4KSk7XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXQubGVuZ3RoID4gbGltaXQgPyBvdXRwdXQuc2xpY2UoMCwgbGltaXQpIDogb3V0cHV0O1xuICB9O1xuXG4gIHJldHVybiBzZWxmO1xufSkoKTtcbiIsIi8vIGNvbnRhaW5zLCBhZGQsIHJlbW92ZSwgdG9nZ2xlXG52YXIgaW5kZXhvZiA9IHJlcXVpcmUoJ2luZGV4b2YnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IENsYXNzTGlzdFxuXG5mdW5jdGlvbiBDbGFzc0xpc3QoZWxlbSkge1xuICAgIHZhciBjbCA9IGVsZW0uY2xhc3NMaXN0XG5cbiAgICBpZiAoY2wpIHtcbiAgICAgICAgcmV0dXJuIGNsXG4gICAgfVxuXG4gICAgdmFyIGNsYXNzTGlzdCA9IHtcbiAgICAgICAgYWRkOiBhZGRcbiAgICAgICAgLCByZW1vdmU6IHJlbW92ZVxuICAgICAgICAsIGNvbnRhaW5zOiBjb250YWluc1xuICAgICAgICAsIHRvZ2dsZTogdG9nZ2xlXG4gICAgICAgICwgdG9TdHJpbmc6ICR0b1N0cmluZ1xuICAgICAgICAsIGxlbmd0aDogMFxuICAgICAgICAsIGl0ZW06IGl0ZW1cbiAgICB9XG5cbiAgICByZXR1cm4gY2xhc3NMaXN0XG5cbiAgICBmdW5jdGlvbiBhZGQodG9rZW4pIHtcbiAgICAgICAgdmFyIGxpc3QgPSBnZXRUb2tlbnMoKVxuICAgICAgICBpZiAoaW5kZXhvZihsaXN0LCB0b2tlbikgPiAtMSkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgbGlzdC5wdXNoKHRva2VuKVxuICAgICAgICBzZXRUb2tlbnMobGlzdClcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW1vdmUodG9rZW4pIHtcbiAgICAgICAgdmFyIGxpc3QgPSBnZXRUb2tlbnMoKVxuICAgICAgICAgICAgLCBpbmRleCA9IGluZGV4b2YobGlzdCwgdG9rZW4pXG5cbiAgICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBsaXN0LnNwbGljZShpbmRleCwgMSlcbiAgICAgICAgc2V0VG9rZW5zKGxpc3QpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29udGFpbnModG9rZW4pIHtcbiAgICAgICAgcmV0dXJuIGluZGV4b2YoZ2V0VG9rZW5zKCksIHRva2VuKSA+IC0xXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9nZ2xlKHRva2VuKSB7XG4gICAgICAgIGlmIChjb250YWlucyh0b2tlbikpIHtcbiAgICAgICAgICAgIHJlbW92ZSh0b2tlbilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWRkKHRva2VuKVxuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uICR0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIGVsZW0uY2xhc3NOYW1lXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXRlbShpbmRleCkge1xuICAgICAgICB2YXIgdG9rZW5zID0gZ2V0VG9rZW5zKClcbiAgICAgICAgcmV0dXJuIHRva2Vuc1tpbmRleF0gfHwgbnVsbFxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFRva2VucygpIHtcbiAgICAgICAgdmFyIGNsYXNzTmFtZSA9IGVsZW0uY2xhc3NOYW1lXG5cbiAgICAgICAgcmV0dXJuIGZpbHRlcihjbGFzc05hbWUuc3BsaXQoXCIgXCIpLCBpc1RydXRoeSlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRUb2tlbnMobGlzdCkge1xuICAgICAgICB2YXIgbGVuZ3RoID0gbGlzdC5sZW5ndGhcblxuICAgICAgICBlbGVtLmNsYXNzTmFtZSA9IGxpc3Quam9pbihcIiBcIilcbiAgICAgICAgY2xhc3NMaXN0Lmxlbmd0aCA9IGxlbmd0aFxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY2xhc3NMaXN0W2ldID0gbGlzdFtpXVxuICAgICAgICB9XG5cbiAgICAgICAgZGVsZXRlIGxpc3RbbGVuZ3RoXVxuICAgIH1cbn1cblxuZnVuY3Rpb24gZmlsdGVyIChhcnIsIGZuKSB7XG4gICAgdmFyIHJldCA9IFtdXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGZuKGFycltpXSkpIHJldC5wdXNoKGFycltpXSlcbiAgICB9XG4gICAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBpc1RydXRoeSh2YWx1ZSkge1xuICAgIHJldHVybiAhIXZhbHVlXG59XG4iLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2NvcmUucmVnZXhwLmVzY2FwZScpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuUmVnRXhwLmVzY2FwZTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmICh0eXBlb2YgaXQgIT0gJ2Z1bmN0aW9uJykgdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYSBmdW5jdGlvbiEnKTtcbiAgcmV0dXJuIGl0O1xufTtcbiIsInZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBtc2cpIHtcbiAgaWYgKHR5cGVvZiBpdCAhPSAnbnVtYmVyJyAmJiBjb2YoaXQpICE9ICdOdW1iZXInKSB0aHJvdyBUeXBlRXJyb3IobXNnKTtcbiAgcmV0dXJuICtpdDtcbn07XG4iLCIvLyAyMi4xLjMuMzEgQXJyYXkucHJvdG90eXBlW0BAdW5zY29wYWJsZXNdXG52YXIgVU5TQ09QQUJMRVMgPSByZXF1aXJlKCcuL193a3MnKSgndW5zY29wYWJsZXMnKTtcbnZhciBBcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuaWYgKEFycmF5UHJvdG9bVU5TQ09QQUJMRVNdID09IHVuZGVmaW5lZCkgcmVxdWlyZSgnLi9faGlkZScpKEFycmF5UHJvdG8sIFVOU0NPUEFCTEVTLCB7fSk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgQXJyYXlQcm90b1tVTlNDT1BBQkxFU11ba2V5XSA9IHRydWU7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIENvbnN0cnVjdG9yLCBuYW1lLCBmb3JiaWRkZW5GaWVsZCkge1xuICBpZiAoIShpdCBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSB8fCAoZm9yYmlkZGVuRmllbGQgIT09IHVuZGVmaW5lZCAmJiBmb3JiaWRkZW5GaWVsZCBpbiBpdCkpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IobmFtZSArICc6IGluY29ycmVjdCBpbnZvY2F0aW9uIScpO1xuICB9IHJldHVybiBpdDtcbn07XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmICghaXNPYmplY3QoaXQpKSB0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhbiBvYmplY3QhJyk7XG4gIHJldHVybiBpdDtcbn07XG4iLCIvLyAyMi4xLjMuMyBBcnJheS5wcm90b3R5cGUuY29weVdpdGhpbih0YXJnZXQsIHN0YXJ0LCBlbmQgPSB0aGlzLmxlbmd0aClcbid1c2Ugc3RyaWN0JztcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyIHRvQWJzb2x1dGVJbmRleCA9IHJlcXVpcmUoJy4vX3RvLWFic29sdXRlLWluZGV4Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBbXS5jb3B5V2l0aGluIHx8IGZ1bmN0aW9uIGNvcHlXaXRoaW4odGFyZ2V0IC8qID0gMCAqLywgc3RhcnQgLyogPSAwLCBlbmQgPSBAbGVuZ3RoICovKSB7XG4gIHZhciBPID0gdG9PYmplY3QodGhpcyk7XG4gIHZhciBsZW4gPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gIHZhciB0byA9IHRvQWJzb2x1dGVJbmRleCh0YXJnZXQsIGxlbik7XG4gIHZhciBmcm9tID0gdG9BYnNvbHV0ZUluZGV4KHN0YXJ0LCBsZW4pO1xuICB2YXIgZW5kID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQ7XG4gIHZhciBjb3VudCA9IE1hdGgubWluKChlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IHRvQWJzb2x1dGVJbmRleChlbmQsIGxlbikpIC0gZnJvbSwgbGVuIC0gdG8pO1xuICB2YXIgaW5jID0gMTtcbiAgaWYgKGZyb20gPCB0byAmJiB0byA8IGZyb20gKyBjb3VudCkge1xuICAgIGluYyA9IC0xO1xuICAgIGZyb20gKz0gY291bnQgLSAxO1xuICAgIHRvICs9IGNvdW50IC0gMTtcbiAgfVxuICB3aGlsZSAoY291bnQtLSA+IDApIHtcbiAgICBpZiAoZnJvbSBpbiBPKSBPW3RvXSA9IE9bZnJvbV07XG4gICAgZWxzZSBkZWxldGUgT1t0b107XG4gICAgdG8gKz0gaW5jO1xuICAgIGZyb20gKz0gaW5jO1xuICB9IHJldHVybiBPO1xufTtcbiIsIi8vIDIyLjEuMy42IEFycmF5LnByb3RvdHlwZS5maWxsKHZhbHVlLCBzdGFydCA9IDAsIGVuZCA9IHRoaXMubGVuZ3RoKVxuJ3VzZSBzdHJpY3QnO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gcmVxdWlyZSgnLi9fdG8tYWJzb2x1dGUtaW5kZXgnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBmaWxsKHZhbHVlIC8qICwgc3RhcnQgPSAwLCBlbmQgPSBAbGVuZ3RoICovKSB7XG4gIHZhciBPID0gdG9PYmplY3QodGhpcyk7XG4gIHZhciBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gIHZhciBhTGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgdmFyIGluZGV4ID0gdG9BYnNvbHV0ZUluZGV4KGFMZW4gPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkLCBsZW5ndGgpO1xuICB2YXIgZW5kID0gYUxlbiA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQ7XG4gIHZhciBlbmRQb3MgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IHRvQWJzb2x1dGVJbmRleChlbmQsIGxlbmd0aCk7XG4gIHdoaWxlIChlbmRQb3MgPiBpbmRleCkgT1tpbmRleCsrXSA9IHZhbHVlO1xuICByZXR1cm4gTztcbn07XG4iLCJ2YXIgZm9yT2YgPSByZXF1aXJlKCcuL19mb3Itb2YnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXRlciwgSVRFUkFUT1IpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBmb3JPZihpdGVyLCBmYWxzZSwgcmVzdWx0LnB1c2gsIHJlc3VsdCwgSVRFUkFUT1IpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcbiIsIi8vIGZhbHNlIC0+IEFycmF5I2luZGV4T2Zcbi8vIHRydWUgIC0+IEFycmF5I2luY2x1ZGVzXG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gcmVxdWlyZSgnLi9fdG8tYWJzb2x1dGUtaW5kZXgnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKElTX0lOQ0xVREVTKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIGVsLCBmcm9tSW5kZXgpIHtcbiAgICB2YXIgTyA9IHRvSU9iamVjdCgkdGhpcyk7XG4gICAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgICB2YXIgaW5kZXggPSB0b0Fic29sdXRlSW5kZXgoZnJvbUluZGV4LCBsZW5ndGgpO1xuICAgIHZhciB2YWx1ZTtcbiAgICAvLyBBcnJheSNpbmNsdWRlcyB1c2VzIFNhbWVWYWx1ZVplcm8gZXF1YWxpdHkgYWxnb3JpdGhtXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgIGlmIChJU19JTkNMVURFUyAmJiBlbCAhPSBlbCkgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSB7XG4gICAgICB2YWx1ZSA9IE9baW5kZXgrK107XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgICBpZiAodmFsdWUgIT0gdmFsdWUpIHJldHVybiB0cnVlO1xuICAgIC8vIEFycmF5I2luZGV4T2YgaWdub3JlcyBob2xlcywgQXJyYXkjaW5jbHVkZXMgLSBub3RcbiAgICB9IGVsc2UgZm9yICg7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIGlmIChJU19JTkNMVURFUyB8fCBpbmRleCBpbiBPKSB7XG4gICAgICBpZiAoT1tpbmRleF0gPT09IGVsKSByZXR1cm4gSVNfSU5DTFVERVMgfHwgaW5kZXggfHwgMDtcbiAgICB9IHJldHVybiAhSVNfSU5DTFVERVMgJiYgLTE7XG4gIH07XG59O1xuIiwiLy8gMCAtPiBBcnJheSNmb3JFYWNoXG4vLyAxIC0+IEFycmF5I21hcFxuLy8gMiAtPiBBcnJheSNmaWx0ZXJcbi8vIDMgLT4gQXJyYXkjc29tZVxuLy8gNCAtPiBBcnJheSNldmVyeVxuLy8gNSAtPiBBcnJheSNmaW5kXG4vLyA2IC0+IEFycmF5I2ZpbmRJbmRleFxudmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyIElPYmplY3QgPSByZXF1aXJlKCcuL19pb2JqZWN0Jyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIGFzYyA9IHJlcXVpcmUoJy4vX2FycmF5LXNwZWNpZXMtY3JlYXRlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChUWVBFLCAkY3JlYXRlKSB7XG4gIHZhciBJU19NQVAgPSBUWVBFID09IDE7XG4gIHZhciBJU19GSUxURVIgPSBUWVBFID09IDI7XG4gIHZhciBJU19TT01FID0gVFlQRSA9PSAzO1xuICB2YXIgSVNfRVZFUlkgPSBUWVBFID09IDQ7XG4gIHZhciBJU19GSU5EX0lOREVYID0gVFlQRSA9PSA2O1xuICB2YXIgTk9fSE9MRVMgPSBUWVBFID09IDUgfHwgSVNfRklORF9JTkRFWDtcbiAgdmFyIGNyZWF0ZSA9ICRjcmVhdGUgfHwgYXNjO1xuICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzLCBjYWxsYmFja2ZuLCB0aGF0KSB7XG4gICAgdmFyIE8gPSB0b09iamVjdCgkdGhpcyk7XG4gICAgdmFyIHNlbGYgPSBJT2JqZWN0KE8pO1xuICAgIHZhciBmID0gY3R4KGNhbGxiYWNrZm4sIHRoYXQsIDMpO1xuICAgIHZhciBsZW5ndGggPSB0b0xlbmd0aChzZWxmLmxlbmd0aCk7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgcmVzdWx0ID0gSVNfTUFQID8gY3JlYXRlKCR0aGlzLCBsZW5ndGgpIDogSVNfRklMVEVSID8gY3JlYXRlKCR0aGlzLCAwKSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgdmFsLCByZXM7XG4gICAgZm9yICg7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIGlmIChOT19IT0xFUyB8fCBpbmRleCBpbiBzZWxmKSB7XG4gICAgICB2YWwgPSBzZWxmW2luZGV4XTtcbiAgICAgIHJlcyA9IGYodmFsLCBpbmRleCwgTyk7XG4gICAgICBpZiAoVFlQRSkge1xuICAgICAgICBpZiAoSVNfTUFQKSByZXN1bHRbaW5kZXhdID0gcmVzOyAgIC8vIG1hcFxuICAgICAgICBlbHNlIGlmIChyZXMpIHN3aXRjaCAoVFlQRSkge1xuICAgICAgICAgIGNhc2UgMzogcmV0dXJuIHRydWU7ICAgICAgICAgICAgIC8vIHNvbWVcbiAgICAgICAgICBjYXNlIDU6IHJldHVybiB2YWw7ICAgICAgICAgICAgICAvLyBmaW5kXG4gICAgICAgICAgY2FzZSA2OiByZXR1cm4gaW5kZXg7ICAgICAgICAgICAgLy8gZmluZEluZGV4XG4gICAgICAgICAgY2FzZSAyOiByZXN1bHQucHVzaCh2YWwpOyAgICAgICAgLy8gZmlsdGVyXG4gICAgICAgIH0gZWxzZSBpZiAoSVNfRVZFUlkpIHJldHVybiBmYWxzZTsgLy8gZXZlcnlcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIElTX0ZJTkRfSU5ERVggPyAtMSA6IElTX1NPTUUgfHwgSVNfRVZFUlkgPyBJU19FVkVSWSA6IHJlc3VsdDtcbiAgfTtcbn07XG4iLCJ2YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgSU9iamVjdCA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh0aGF0LCBjYWxsYmFja2ZuLCBhTGVuLCBtZW1vLCBpc1JpZ2h0KSB7XG4gIGFGdW5jdGlvbihjYWxsYmFja2ZuKTtcbiAgdmFyIE8gPSB0b09iamVjdCh0aGF0KTtcbiAgdmFyIHNlbGYgPSBJT2JqZWN0KE8pO1xuICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICB2YXIgaW5kZXggPSBpc1JpZ2h0ID8gbGVuZ3RoIC0gMSA6IDA7XG4gIHZhciBpID0gaXNSaWdodCA/IC0xIDogMTtcbiAgaWYgKGFMZW4gPCAyKSBmb3IgKDs7KSB7XG4gICAgaWYgKGluZGV4IGluIHNlbGYpIHtcbiAgICAgIG1lbW8gPSBzZWxmW2luZGV4XTtcbiAgICAgIGluZGV4ICs9IGk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaW5kZXggKz0gaTtcbiAgICBpZiAoaXNSaWdodCA/IGluZGV4IDwgMCA6IGxlbmd0aCA8PSBpbmRleCkge1xuICAgICAgdGhyb3cgVHlwZUVycm9yKCdSZWR1Y2Ugb2YgZW1wdHkgYXJyYXkgd2l0aCBubyBpbml0aWFsIHZhbHVlJyk7XG4gICAgfVxuICB9XG4gIGZvciAoO2lzUmlnaHQgPyBpbmRleCA+PSAwIDogbGVuZ3RoID4gaW5kZXg7IGluZGV4ICs9IGkpIGlmIChpbmRleCBpbiBzZWxmKSB7XG4gICAgbWVtbyA9IGNhbGxiYWNrZm4obWVtbywgc2VsZltpbmRleF0sIGluZGV4LCBPKTtcbiAgfVxuICByZXR1cm4gbWVtbztcbn07XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi9faXMtYXJyYXknKTtcbnZhciBTUEVDSUVTID0gcmVxdWlyZSgnLi9fd2tzJykoJ3NwZWNpZXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3JpZ2luYWwpIHtcbiAgdmFyIEM7XG4gIGlmIChpc0FycmF5KG9yaWdpbmFsKSkge1xuICAgIEMgPSBvcmlnaW5hbC5jb25zdHJ1Y3RvcjtcbiAgICAvLyBjcm9zcy1yZWFsbSBmYWxsYmFja1xuICAgIGlmICh0eXBlb2YgQyA9PSAnZnVuY3Rpb24nICYmIChDID09PSBBcnJheSB8fCBpc0FycmF5KEMucHJvdG90eXBlKSkpIEMgPSB1bmRlZmluZWQ7XG4gICAgaWYgKGlzT2JqZWN0KEMpKSB7XG4gICAgICBDID0gQ1tTUEVDSUVTXTtcbiAgICAgIGlmIChDID09PSBudWxsKSBDID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfSByZXR1cm4gQyA9PT0gdW5kZWZpbmVkID8gQXJyYXkgOiBDO1xufTtcbiIsIi8vIDkuNC4yLjMgQXJyYXlTcGVjaWVzQ3JlYXRlKG9yaWdpbmFsQXJyYXksIGxlbmd0aClcbnZhciBzcGVjaWVzQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuL19hcnJheS1zcGVjaWVzLWNvbnN0cnVjdG9yJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9yaWdpbmFsLCBsZW5ndGgpIHtcbiAgcmV0dXJuIG5ldyAoc3BlY2llc0NvbnN0cnVjdG9yKG9yaWdpbmFsKSkobGVuZ3RoKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgaW52b2tlID0gcmVxdWlyZSgnLi9faW52b2tlJyk7XG52YXIgYXJyYXlTbGljZSA9IFtdLnNsaWNlO1xudmFyIGZhY3RvcmllcyA9IHt9O1xuXG52YXIgY29uc3RydWN0ID0gZnVuY3Rpb24gKEYsIGxlbiwgYXJncykge1xuICBpZiAoIShsZW4gaW4gZmFjdG9yaWVzKSkge1xuICAgIGZvciAodmFyIG4gPSBbXSwgaSA9IDA7IGkgPCBsZW47IGkrKykgbltpXSA9ICdhWycgKyBpICsgJ10nO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuY1xuICAgIGZhY3Rvcmllc1tsZW5dID0gRnVuY3Rpb24oJ0YsYScsICdyZXR1cm4gbmV3IEYoJyArIG4uam9pbignLCcpICsgJyknKTtcbiAgfSByZXR1cm4gZmFjdG9yaWVzW2xlbl0oRiwgYXJncyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZ1bmN0aW9uLmJpbmQgfHwgZnVuY3Rpb24gYmluZCh0aGF0IC8qICwgLi4uYXJncyAqLykge1xuICB2YXIgZm4gPSBhRnVuY3Rpb24odGhpcyk7XG4gIHZhciBwYXJ0QXJncyA9IGFycmF5U2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICB2YXIgYm91bmQgPSBmdW5jdGlvbiAoLyogYXJncy4uLiAqLykge1xuICAgIHZhciBhcmdzID0gcGFydEFyZ3MuY29uY2F0KGFycmF5U2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIGJvdW5kID8gY29uc3RydWN0KGZuLCBhcmdzLmxlbmd0aCwgYXJncykgOiBpbnZva2UoZm4sIGFyZ3MsIHRoYXQpO1xuICB9O1xuICBpZiAoaXNPYmplY3QoZm4ucHJvdG90eXBlKSkgYm91bmQucHJvdG90eXBlID0gZm4ucHJvdG90eXBlO1xuICByZXR1cm4gYm91bmQ7XG59O1xuIiwiLy8gZ2V0dGluZyB0YWcgZnJvbSAxOS4xLjMuNiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKClcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbnZhciBUQUcgPSByZXF1aXJlKCcuL193a3MnKSgndG9TdHJpbmdUYWcnKTtcbi8vIEVTMyB3cm9uZyBoZXJlXG52YXIgQVJHID0gY29mKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA9PSAnQXJndW1lbnRzJztcblxuLy8gZmFsbGJhY2sgZm9yIElFMTEgU2NyaXB0IEFjY2VzcyBEZW5pZWQgZXJyb3JcbnZhciB0cnlHZXQgPSBmdW5jdGlvbiAoaXQsIGtleSkge1xuICB0cnkge1xuICAgIHJldHVybiBpdFtrZXldO1xuICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBPLCBULCBCO1xuICByZXR1cm4gaXQgPT09IHVuZGVmaW5lZCA/ICdVbmRlZmluZWQnIDogaXQgPT09IG51bGwgPyAnTnVsbCdcbiAgICAvLyBAQHRvU3RyaW5nVGFnIGNhc2VcbiAgICA6IHR5cGVvZiAoVCA9IHRyeUdldChPID0gT2JqZWN0KGl0KSwgVEFHKSkgPT0gJ3N0cmluZycgPyBUXG4gICAgLy8gYnVpbHRpblRhZyBjYXNlXG4gICAgOiBBUkcgPyBjb2YoTylcbiAgICAvLyBFUzMgYXJndW1lbnRzIGZhbGxiYWNrXG4gICAgOiAoQiA9IGNvZihPKSkgPT0gJ09iamVjdCcgJiYgdHlwZW9mIE8uY2FsbGVlID09ICdmdW5jdGlvbicgPyAnQXJndW1lbnRzJyA6IEI7XG59O1xuIiwidmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGl0KS5zbGljZSg4LCAtMSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbnZhciBjcmVhdGUgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJyk7XG52YXIgcmVkZWZpbmVBbGwgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKTtcbnZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciBhbkluc3RhbmNlID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKTtcbnZhciBmb3JPZiA9IHJlcXVpcmUoJy4vX2Zvci1vZicpO1xudmFyICRpdGVyRGVmaW5lID0gcmVxdWlyZSgnLi9faXRlci1kZWZpbmUnKTtcbnZhciBzdGVwID0gcmVxdWlyZSgnLi9faXRlci1zdGVwJyk7XG52YXIgc2V0U3BlY2llcyA9IHJlcXVpcmUoJy4vX3NldC1zcGVjaWVzJyk7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpO1xudmFyIGZhc3RLZXkgPSByZXF1aXJlKCcuL19tZXRhJykuZmFzdEtleTtcbnZhciB2YWxpZGF0ZSA9IHJlcXVpcmUoJy4vX3ZhbGlkYXRlLWNvbGxlY3Rpb24nKTtcbnZhciBTSVpFID0gREVTQ1JJUFRPUlMgPyAnX3MnIDogJ3NpemUnO1xuXG52YXIgZ2V0RW50cnkgPSBmdW5jdGlvbiAodGhhdCwga2V5KSB7XG4gIC8vIGZhc3QgY2FzZVxuICB2YXIgaW5kZXggPSBmYXN0S2V5KGtleSk7XG4gIHZhciBlbnRyeTtcbiAgaWYgKGluZGV4ICE9PSAnRicpIHJldHVybiB0aGF0Ll9pW2luZGV4XTtcbiAgLy8gZnJvemVuIG9iamVjdCBjYXNlXG4gIGZvciAoZW50cnkgPSB0aGF0Ll9mOyBlbnRyeTsgZW50cnkgPSBlbnRyeS5uKSB7XG4gICAgaWYgKGVudHJ5LmsgPT0ga2V5KSByZXR1cm4gZW50cnk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBnZXRDb25zdHJ1Y3RvcjogZnVuY3Rpb24gKHdyYXBwZXIsIE5BTUUsIElTX01BUCwgQURERVIpIHtcbiAgICB2YXIgQyA9IHdyYXBwZXIoZnVuY3Rpb24gKHRoYXQsIGl0ZXJhYmxlKSB7XG4gICAgICBhbkluc3RhbmNlKHRoYXQsIEMsIE5BTUUsICdfaScpO1xuICAgICAgdGhhdC5fdCA9IE5BTUU7ICAgICAgICAgLy8gY29sbGVjdGlvbiB0eXBlXG4gICAgICB0aGF0Ll9pID0gY3JlYXRlKG51bGwpOyAvLyBpbmRleFxuICAgICAgdGhhdC5fZiA9IHVuZGVmaW5lZDsgICAgLy8gZmlyc3QgZW50cnlcbiAgICAgIHRoYXQuX2wgPSB1bmRlZmluZWQ7ICAgIC8vIGxhc3QgZW50cnlcbiAgICAgIHRoYXRbU0laRV0gPSAwOyAgICAgICAgIC8vIHNpemVcbiAgICAgIGlmIChpdGVyYWJsZSAhPSB1bmRlZmluZWQpIGZvck9mKGl0ZXJhYmxlLCBJU19NQVAsIHRoYXRbQURERVJdLCB0aGF0KTtcbiAgICB9KTtcbiAgICByZWRlZmluZUFsbChDLnByb3RvdHlwZSwge1xuICAgICAgLy8gMjMuMS4zLjEgTWFwLnByb3RvdHlwZS5jbGVhcigpXG4gICAgICAvLyAyMy4yLjMuMiBTZXQucHJvdG90eXBlLmNsZWFyKClcbiAgICAgIGNsZWFyOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgICAgZm9yICh2YXIgdGhhdCA9IHZhbGlkYXRlKHRoaXMsIE5BTUUpLCBkYXRhID0gdGhhdC5faSwgZW50cnkgPSB0aGF0Ll9mOyBlbnRyeTsgZW50cnkgPSBlbnRyeS5uKSB7XG4gICAgICAgICAgZW50cnkuciA9IHRydWU7XG4gICAgICAgICAgaWYgKGVudHJ5LnApIGVudHJ5LnAgPSBlbnRyeS5wLm4gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgZGVsZXRlIGRhdGFbZW50cnkuaV07XG4gICAgICAgIH1cbiAgICAgICAgdGhhdC5fZiA9IHRoYXQuX2wgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoYXRbU0laRV0gPSAwO1xuICAgICAgfSxcbiAgICAgIC8vIDIzLjEuMy4zIE1hcC5wcm90b3R5cGUuZGVsZXRlKGtleSlcbiAgICAgIC8vIDIzLjIuMy40IFNldC5wcm90b3R5cGUuZGVsZXRlKHZhbHVlKVxuICAgICAgJ2RlbGV0ZSc6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB2YWxpZGF0ZSh0aGlzLCBOQU1FKTtcbiAgICAgICAgdmFyIGVudHJ5ID0gZ2V0RW50cnkodGhhdCwga2V5KTtcbiAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgdmFyIG5leHQgPSBlbnRyeS5uO1xuICAgICAgICAgIHZhciBwcmV2ID0gZW50cnkucDtcbiAgICAgICAgICBkZWxldGUgdGhhdC5faVtlbnRyeS5pXTtcbiAgICAgICAgICBlbnRyeS5yID0gdHJ1ZTtcbiAgICAgICAgICBpZiAocHJldikgcHJldi5uID0gbmV4dDtcbiAgICAgICAgICBpZiAobmV4dCkgbmV4dC5wID0gcHJldjtcbiAgICAgICAgICBpZiAodGhhdC5fZiA9PSBlbnRyeSkgdGhhdC5fZiA9IG5leHQ7XG4gICAgICAgICAgaWYgKHRoYXQuX2wgPT0gZW50cnkpIHRoYXQuX2wgPSBwcmV2O1xuICAgICAgICAgIHRoYXRbU0laRV0tLTtcbiAgICAgICAgfSByZXR1cm4gISFlbnRyeTtcbiAgICAgIH0sXG4gICAgICAvLyAyMy4yLjMuNiBTZXQucHJvdG90eXBlLmZvckVhY2goY2FsbGJhY2tmbiwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbiAgICAgIC8vIDIzLjEuMy41IE1hcC5wcm90b3R5cGUuZm9yRWFjaChjYWxsYmFja2ZuLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxuICAgICAgZm9yRWFjaDogZnVuY3Rpb24gZm9yRWFjaChjYWxsYmFja2ZuIC8qICwgdGhhdCA9IHVuZGVmaW5lZCAqLykge1xuICAgICAgICB2YWxpZGF0ZSh0aGlzLCBOQU1FKTtcbiAgICAgICAgdmFyIGYgPSBjdHgoY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQsIDMpO1xuICAgICAgICB2YXIgZW50cnk7XG4gICAgICAgIHdoaWxlIChlbnRyeSA9IGVudHJ5ID8gZW50cnkubiA6IHRoaXMuX2YpIHtcbiAgICAgICAgICBmKGVudHJ5LnYsIGVudHJ5LmssIHRoaXMpO1xuICAgICAgICAgIC8vIHJldmVydCB0byB0aGUgbGFzdCBleGlzdGluZyBlbnRyeVxuICAgICAgICAgIHdoaWxlIChlbnRyeSAmJiBlbnRyeS5yKSBlbnRyeSA9IGVudHJ5LnA7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvLyAyMy4xLjMuNyBNYXAucHJvdG90eXBlLmhhcyhrZXkpXG4gICAgICAvLyAyMy4yLjMuNyBTZXQucHJvdG90eXBlLmhhcyh2YWx1ZSlcbiAgICAgIGhhczogZnVuY3Rpb24gaGFzKGtleSkge1xuICAgICAgICByZXR1cm4gISFnZXRFbnRyeSh2YWxpZGF0ZSh0aGlzLCBOQU1FKSwga2V5KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoREVTQ1JJUFRPUlMpIGRQKEMucHJvdG90eXBlLCAnc2l6ZScsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdmFsaWRhdGUodGhpcywgTkFNRSlbU0laRV07XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIEM7XG4gIH0sXG4gIGRlZjogZnVuY3Rpb24gKHRoYXQsIGtleSwgdmFsdWUpIHtcbiAgICB2YXIgZW50cnkgPSBnZXRFbnRyeSh0aGF0LCBrZXkpO1xuICAgIHZhciBwcmV2LCBpbmRleDtcbiAgICAvLyBjaGFuZ2UgZXhpc3RpbmcgZW50cnlcbiAgICBpZiAoZW50cnkpIHtcbiAgICAgIGVudHJ5LnYgPSB2YWx1ZTtcbiAgICAvLyBjcmVhdGUgbmV3IGVudHJ5XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoYXQuX2wgPSBlbnRyeSA9IHtcbiAgICAgICAgaTogaW5kZXggPSBmYXN0S2V5KGtleSwgdHJ1ZSksIC8vIDwtIGluZGV4XG4gICAgICAgIGs6IGtleSwgICAgICAgICAgICAgICAgICAgICAgICAvLyA8LSBrZXlcbiAgICAgICAgdjogdmFsdWUsICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIHZhbHVlXG4gICAgICAgIHA6IHByZXYgPSB0aGF0Ll9sLCAgICAgICAgICAgICAvLyA8LSBwcmV2aW91cyBlbnRyeVxuICAgICAgICBuOiB1bmRlZmluZWQsICAgICAgICAgICAgICAgICAgLy8gPC0gbmV4dCBlbnRyeVxuICAgICAgICByOiBmYWxzZSAgICAgICAgICAgICAgICAgICAgICAgLy8gPC0gcmVtb3ZlZFxuICAgICAgfTtcbiAgICAgIGlmICghdGhhdC5fZikgdGhhdC5fZiA9IGVudHJ5O1xuICAgICAgaWYgKHByZXYpIHByZXYubiA9IGVudHJ5O1xuICAgICAgdGhhdFtTSVpFXSsrO1xuICAgICAgLy8gYWRkIHRvIGluZGV4XG4gICAgICBpZiAoaW5kZXggIT09ICdGJykgdGhhdC5faVtpbmRleF0gPSBlbnRyeTtcbiAgICB9IHJldHVybiB0aGF0O1xuICB9LFxuICBnZXRFbnRyeTogZ2V0RW50cnksXG4gIHNldFN0cm9uZzogZnVuY3Rpb24gKEMsIE5BTUUsIElTX01BUCkge1xuICAgIC8vIGFkZCAua2V5cywgLnZhbHVlcywgLmVudHJpZXMsIFtAQGl0ZXJhdG9yXVxuICAgIC8vIDIzLjEuMy40LCAyMy4xLjMuOCwgMjMuMS4zLjExLCAyMy4xLjMuMTIsIDIzLjIuMy41LCAyMy4yLjMuOCwgMjMuMi4zLjEwLCAyMy4yLjMuMTFcbiAgICAkaXRlckRlZmluZShDLCBOQU1FLCBmdW5jdGlvbiAoaXRlcmF0ZWQsIGtpbmQpIHtcbiAgICAgIHRoaXMuX3QgPSB2YWxpZGF0ZShpdGVyYXRlZCwgTkFNRSk7IC8vIHRhcmdldFxuICAgICAgdGhpcy5fayA9IGtpbmQ7ICAgICAgICAgICAgICAgICAgICAgLy8ga2luZFxuICAgICAgdGhpcy5fbCA9IHVuZGVmaW5lZDsgICAgICAgICAgICAgICAgLy8gcHJldmlvdXNcbiAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICB2YXIga2luZCA9IHRoYXQuX2s7XG4gICAgICB2YXIgZW50cnkgPSB0aGF0Ll9sO1xuICAgICAgLy8gcmV2ZXJ0IHRvIHRoZSBsYXN0IGV4aXN0aW5nIGVudHJ5XG4gICAgICB3aGlsZSAoZW50cnkgJiYgZW50cnkucikgZW50cnkgPSBlbnRyeS5wO1xuICAgICAgLy8gZ2V0IG5leHQgZW50cnlcbiAgICAgIGlmICghdGhhdC5fdCB8fCAhKHRoYXQuX2wgPSBlbnRyeSA9IGVudHJ5ID8gZW50cnkubiA6IHRoYXQuX3QuX2YpKSB7XG4gICAgICAgIC8vIG9yIGZpbmlzaCB0aGUgaXRlcmF0aW9uXG4gICAgICAgIHRoYXQuX3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBzdGVwKDEpO1xuICAgICAgfVxuICAgICAgLy8gcmV0dXJuIHN0ZXAgYnkga2luZFxuICAgICAgaWYgKGtpbmQgPT0gJ2tleXMnKSByZXR1cm4gc3RlcCgwLCBlbnRyeS5rKTtcbiAgICAgIGlmIChraW5kID09ICd2YWx1ZXMnKSByZXR1cm4gc3RlcCgwLCBlbnRyeS52KTtcbiAgICAgIHJldHVybiBzdGVwKDAsIFtlbnRyeS5rLCBlbnRyeS52XSk7XG4gICAgfSwgSVNfTUFQID8gJ2VudHJpZXMnIDogJ3ZhbHVlcycsICFJU19NQVAsIHRydWUpO1xuXG4gICAgLy8gYWRkIFtAQHNwZWNpZXNdLCAyMy4xLjIuMiwgMjMuMi4yLjJcbiAgICBzZXRTcGVjaWVzKE5BTUUpO1xuICB9XG59O1xuIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL0RhdmlkQnJ1YW50L01hcC1TZXQucHJvdG90eXBlLnRvSlNPTlxudmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuL19jbGFzc29mJyk7XG52YXIgZnJvbSA9IHJlcXVpcmUoJy4vX2FycmF5LWZyb20taXRlcmFibGUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE5BTUUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICBpZiAoY2xhc3NvZih0aGlzKSAhPSBOQU1FKSB0aHJvdyBUeXBlRXJyb3IoTkFNRSArIFwiI3RvSlNPTiBpc24ndCBnZW5lcmljXCIpO1xuICAgIHJldHVybiBmcm9tKHRoaXMpO1xuICB9O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciByZWRlZmluZUFsbCA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpO1xudmFyIGdldFdlYWsgPSByZXF1aXJlKCcuL19tZXRhJykuZ2V0V2VhaztcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgYW5JbnN0YW5jZSA9IHJlcXVpcmUoJy4vX2FuLWluc3RhbmNlJyk7XG52YXIgZm9yT2YgPSByZXF1aXJlKCcuL19mb3Itb2YnKTtcbnZhciBjcmVhdGVBcnJheU1ldGhvZCA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKTtcbnZhciAkaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgdmFsaWRhdGUgPSByZXF1aXJlKCcuL192YWxpZGF0ZS1jb2xsZWN0aW9uJyk7XG52YXIgYXJyYXlGaW5kID0gY3JlYXRlQXJyYXlNZXRob2QoNSk7XG52YXIgYXJyYXlGaW5kSW5kZXggPSBjcmVhdGVBcnJheU1ldGhvZCg2KTtcbnZhciBpZCA9IDA7XG5cbi8vIGZhbGxiYWNrIGZvciB1bmNhdWdodCBmcm96ZW4ga2V5c1xudmFyIHVuY2F1Z2h0RnJvemVuU3RvcmUgPSBmdW5jdGlvbiAodGhhdCkge1xuICByZXR1cm4gdGhhdC5fbCB8fCAodGhhdC5fbCA9IG5ldyBVbmNhdWdodEZyb3plblN0b3JlKCkpO1xufTtcbnZhciBVbmNhdWdodEZyb3plblN0b3JlID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmEgPSBbXTtcbn07XG52YXIgZmluZFVuY2F1Z2h0RnJvemVuID0gZnVuY3Rpb24gKHN0b3JlLCBrZXkpIHtcbiAgcmV0dXJuIGFycmF5RmluZChzdG9yZS5hLCBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gaXRbMF0gPT09IGtleTtcbiAgfSk7XG59O1xuVW5jYXVnaHRGcm96ZW5TdG9yZS5wcm90b3R5cGUgPSB7XG4gIGdldDogZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciBlbnRyeSA9IGZpbmRVbmNhdWdodEZyb3plbih0aGlzLCBrZXkpO1xuICAgIGlmIChlbnRyeSkgcmV0dXJuIGVudHJ5WzFdO1xuICB9LFxuICBoYXM6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gISFmaW5kVW5jYXVnaHRGcm96ZW4odGhpcywga2V5KTtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgIHZhciBlbnRyeSA9IGZpbmRVbmNhdWdodEZyb3plbih0aGlzLCBrZXkpO1xuICAgIGlmIChlbnRyeSkgZW50cnlbMV0gPSB2YWx1ZTtcbiAgICBlbHNlIHRoaXMuYS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gIH0sXG4gICdkZWxldGUnOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIGluZGV4ID0gYXJyYXlGaW5kSW5kZXgodGhpcy5hLCBmdW5jdGlvbiAoaXQpIHtcbiAgICAgIHJldHVybiBpdFswXSA9PT0ga2V5O1xuICAgIH0pO1xuICAgIGlmICh+aW5kZXgpIHRoaXMuYS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIHJldHVybiAhIX5pbmRleDtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGdldENvbnN0cnVjdG9yOiBmdW5jdGlvbiAod3JhcHBlciwgTkFNRSwgSVNfTUFQLCBBRERFUikge1xuICAgIHZhciBDID0gd3JhcHBlcihmdW5jdGlvbiAodGhhdCwgaXRlcmFibGUpIHtcbiAgICAgIGFuSW5zdGFuY2UodGhhdCwgQywgTkFNRSwgJ19pJyk7XG4gICAgICB0aGF0Ll90ID0gTkFNRTsgICAgICAvLyBjb2xsZWN0aW9uIHR5cGVcbiAgICAgIHRoYXQuX2kgPSBpZCsrOyAgICAgIC8vIGNvbGxlY3Rpb24gaWRcbiAgICAgIHRoYXQuX2wgPSB1bmRlZmluZWQ7IC8vIGxlYWsgc3RvcmUgZm9yIHVuY2F1Z2h0IGZyb3plbiBvYmplY3RzXG4gICAgICBpZiAoaXRlcmFibGUgIT0gdW5kZWZpbmVkKSBmb3JPZihpdGVyYWJsZSwgSVNfTUFQLCB0aGF0W0FEREVSXSwgdGhhdCk7XG4gICAgfSk7XG4gICAgcmVkZWZpbmVBbGwoQy5wcm90b3R5cGUsIHtcbiAgICAgIC8vIDIzLjMuMy4yIFdlYWtNYXAucHJvdG90eXBlLmRlbGV0ZShrZXkpXG4gICAgICAvLyAyMy40LjMuMyBXZWFrU2V0LnByb3RvdHlwZS5kZWxldGUodmFsdWUpXG4gICAgICAnZGVsZXRlJzogZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAoIWlzT2JqZWN0KGtleSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgdmFyIGRhdGEgPSBnZXRXZWFrKGtleSk7XG4gICAgICAgIGlmIChkYXRhID09PSB0cnVlKSByZXR1cm4gdW5jYXVnaHRGcm96ZW5TdG9yZSh2YWxpZGF0ZSh0aGlzLCBOQU1FKSlbJ2RlbGV0ZSddKGtleSk7XG4gICAgICAgIHJldHVybiBkYXRhICYmICRoYXMoZGF0YSwgdGhpcy5faSkgJiYgZGVsZXRlIGRhdGFbdGhpcy5faV07XG4gICAgICB9LFxuICAgICAgLy8gMjMuMy4zLjQgV2Vha01hcC5wcm90b3R5cGUuaGFzKGtleSlcbiAgICAgIC8vIDIzLjQuMy40IFdlYWtTZXQucHJvdG90eXBlLmhhcyh2YWx1ZSlcbiAgICAgIGhhczogZnVuY3Rpb24gaGFzKGtleSkge1xuICAgICAgICBpZiAoIWlzT2JqZWN0KGtleSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgdmFyIGRhdGEgPSBnZXRXZWFrKGtleSk7XG4gICAgICAgIGlmIChkYXRhID09PSB0cnVlKSByZXR1cm4gdW5jYXVnaHRGcm96ZW5TdG9yZSh2YWxpZGF0ZSh0aGlzLCBOQU1FKSkuaGFzKGtleSk7XG4gICAgICAgIHJldHVybiBkYXRhICYmICRoYXMoZGF0YSwgdGhpcy5faSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIEM7XG4gIH0sXG4gIGRlZjogZnVuY3Rpb24gKHRoYXQsIGtleSwgdmFsdWUpIHtcbiAgICB2YXIgZGF0YSA9IGdldFdlYWsoYW5PYmplY3Qoa2V5KSwgdHJ1ZSk7XG4gICAgaWYgKGRhdGEgPT09IHRydWUpIHVuY2F1Z2h0RnJvemVuU3RvcmUodGhhdCkuc2V0KGtleSwgdmFsdWUpO1xuICAgIGVsc2UgZGF0YVt0aGF0Ll9pXSA9IHZhbHVlO1xuICAgIHJldHVybiB0aGF0O1xuICB9LFxuICB1ZnN0b3JlOiB1bmNhdWdodEZyb3plblN0b3JlXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJyk7XG52YXIgcmVkZWZpbmVBbGwgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKTtcbnZhciBtZXRhID0gcmVxdWlyZSgnLi9fbWV0YScpO1xudmFyIGZvck9mID0gcmVxdWlyZSgnLi9fZm9yLW9mJyk7XG52YXIgYW5JbnN0YW5jZSA9IHJlcXVpcmUoJy4vX2FuLWluc3RhbmNlJyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG52YXIgJGl0ZXJEZXRlY3QgPSByZXF1aXJlKCcuL19pdGVyLWRldGVjdCcpO1xudmFyIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKTtcbnZhciBpbmhlcml0SWZSZXF1aXJlZCA9IHJlcXVpcmUoJy4vX2luaGVyaXQtaWYtcmVxdWlyZWQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTkFNRSwgd3JhcHBlciwgbWV0aG9kcywgY29tbW9uLCBJU19NQVAsIElTX1dFQUspIHtcbiAgdmFyIEJhc2UgPSBnbG9iYWxbTkFNRV07XG4gIHZhciBDID0gQmFzZTtcbiAgdmFyIEFEREVSID0gSVNfTUFQID8gJ3NldCcgOiAnYWRkJztcbiAgdmFyIHByb3RvID0gQyAmJiBDLnByb3RvdHlwZTtcbiAgdmFyIE8gPSB7fTtcbiAgdmFyIGZpeE1ldGhvZCA9IGZ1bmN0aW9uIChLRVkpIHtcbiAgICB2YXIgZm4gPSBwcm90b1tLRVldO1xuICAgIHJlZGVmaW5lKHByb3RvLCBLRVksXG4gICAgICBLRVkgPT0gJ2RlbGV0ZScgPyBmdW5jdGlvbiAoYSkge1xuICAgICAgICByZXR1cm4gSVNfV0VBSyAmJiAhaXNPYmplY3QoYSkgPyBmYWxzZSA6IGZuLmNhbGwodGhpcywgYSA9PT0gMCA/IDAgOiBhKTtcbiAgICAgIH0gOiBLRVkgPT0gJ2hhcycgPyBmdW5jdGlvbiBoYXMoYSkge1xuICAgICAgICByZXR1cm4gSVNfV0VBSyAmJiAhaXNPYmplY3QoYSkgPyBmYWxzZSA6IGZuLmNhbGwodGhpcywgYSA9PT0gMCA/IDAgOiBhKTtcbiAgICAgIH0gOiBLRVkgPT0gJ2dldCcgPyBmdW5jdGlvbiBnZXQoYSkge1xuICAgICAgICByZXR1cm4gSVNfV0VBSyAmJiAhaXNPYmplY3QoYSkgPyB1bmRlZmluZWQgOiBmbi5jYWxsKHRoaXMsIGEgPT09IDAgPyAwIDogYSk7XG4gICAgICB9IDogS0VZID09ICdhZGQnID8gZnVuY3Rpb24gYWRkKGEpIHsgZm4uY2FsbCh0aGlzLCBhID09PSAwID8gMCA6IGEpOyByZXR1cm4gdGhpczsgfVxuICAgICAgICA6IGZ1bmN0aW9uIHNldChhLCBiKSB7IGZuLmNhbGwodGhpcywgYSA9PT0gMCA/IDAgOiBhLCBiKTsgcmV0dXJuIHRoaXM7IH1cbiAgICApO1xuICB9O1xuICBpZiAodHlwZW9mIEMgIT0gJ2Z1bmN0aW9uJyB8fCAhKElTX1dFQUsgfHwgcHJvdG8uZm9yRWFjaCAmJiAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIG5ldyBDKCkuZW50cmllcygpLm5leHQoKTtcbiAgfSkpKSB7XG4gICAgLy8gY3JlYXRlIGNvbGxlY3Rpb24gY29uc3RydWN0b3JcbiAgICBDID0gY29tbW9uLmdldENvbnN0cnVjdG9yKHdyYXBwZXIsIE5BTUUsIElTX01BUCwgQURERVIpO1xuICAgIHJlZGVmaW5lQWxsKEMucHJvdG90eXBlLCBtZXRob2RzKTtcbiAgICBtZXRhLk5FRUQgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHZhciBpbnN0YW5jZSA9IG5ldyBDKCk7XG4gICAgLy8gZWFybHkgaW1wbGVtZW50YXRpb25zIG5vdCBzdXBwb3J0cyBjaGFpbmluZ1xuICAgIHZhciBIQVNOVF9DSEFJTklORyA9IGluc3RhbmNlW0FEREVSXShJU19XRUFLID8ge30gOiAtMCwgMSkgIT0gaW5zdGFuY2U7XG4gICAgLy8gVjggfiAgQ2hyb21pdW0gNDAtIHdlYWstY29sbGVjdGlvbnMgdGhyb3dzIG9uIHByaW1pdGl2ZXMsIGJ1dCBzaG91bGQgcmV0dXJuIGZhbHNlXG4gICAgdmFyIFRIUk9XU19PTl9QUklNSVRJVkVTID0gZmFpbHMoZnVuY3Rpb24gKCkgeyBpbnN0YW5jZS5oYXMoMSk7IH0pO1xuICAgIC8vIG1vc3QgZWFybHkgaW1wbGVtZW50YXRpb25zIGRvZXNuJ3Qgc3VwcG9ydHMgaXRlcmFibGVzLCBtb3N0IG1vZGVybiAtIG5vdCBjbG9zZSBpdCBjb3JyZWN0bHlcbiAgICB2YXIgQUNDRVBUX0lURVJBQkxFUyA9ICRpdGVyRGV0ZWN0KGZ1bmN0aW9uIChpdGVyKSB7IG5ldyBDKGl0ZXIpOyB9KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICAvLyBmb3IgZWFybHkgaW1wbGVtZW50YXRpb25zIC0wIGFuZCArMCBub3QgdGhlIHNhbWVcbiAgICB2YXIgQlVHR1lfWkVSTyA9ICFJU19XRUFLICYmIGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIFY4IH4gQ2hyb21pdW0gNDItIGZhaWxzIG9ubHkgd2l0aCA1KyBlbGVtZW50c1xuICAgICAgdmFyICRpbnN0YW5jZSA9IG5ldyBDKCk7XG4gICAgICB2YXIgaW5kZXggPSA1O1xuICAgICAgd2hpbGUgKGluZGV4LS0pICRpbnN0YW5jZVtBRERFUl0oaW5kZXgsIGluZGV4KTtcbiAgICAgIHJldHVybiAhJGluc3RhbmNlLmhhcygtMCk7XG4gICAgfSk7XG4gICAgaWYgKCFBQ0NFUFRfSVRFUkFCTEVTKSB7XG4gICAgICBDID0gd3JhcHBlcihmdW5jdGlvbiAodGFyZ2V0LCBpdGVyYWJsZSkge1xuICAgICAgICBhbkluc3RhbmNlKHRhcmdldCwgQywgTkFNRSk7XG4gICAgICAgIHZhciB0aGF0ID0gaW5oZXJpdElmUmVxdWlyZWQobmV3IEJhc2UoKSwgdGFyZ2V0LCBDKTtcbiAgICAgICAgaWYgKGl0ZXJhYmxlICE9IHVuZGVmaW5lZCkgZm9yT2YoaXRlcmFibGUsIElTX01BUCwgdGhhdFtBRERFUl0sIHRoYXQpO1xuICAgICAgICByZXR1cm4gdGhhdDtcbiAgICAgIH0pO1xuICAgICAgQy5wcm90b3R5cGUgPSBwcm90bztcbiAgICAgIHByb3RvLmNvbnN0cnVjdG9yID0gQztcbiAgICB9XG4gICAgaWYgKFRIUk9XU19PTl9QUklNSVRJVkVTIHx8IEJVR0dZX1pFUk8pIHtcbiAgICAgIGZpeE1ldGhvZCgnZGVsZXRlJyk7XG4gICAgICBmaXhNZXRob2QoJ2hhcycpO1xuICAgICAgSVNfTUFQICYmIGZpeE1ldGhvZCgnZ2V0Jyk7XG4gICAgfVxuICAgIGlmIChCVUdHWV9aRVJPIHx8IEhBU05UX0NIQUlOSU5HKSBmaXhNZXRob2QoQURERVIpO1xuICAgIC8vIHdlYWsgY29sbGVjdGlvbnMgc2hvdWxkIG5vdCBjb250YWlucyAuY2xlYXIgbWV0aG9kXG4gICAgaWYgKElTX1dFQUsgJiYgcHJvdG8uY2xlYXIpIGRlbGV0ZSBwcm90by5jbGVhcjtcbiAgfVxuXG4gIHNldFRvU3RyaW5nVGFnKEMsIE5BTUUpO1xuXG4gIE9bTkFNRV0gPSBDO1xuICAkZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuVyArICRleHBvcnQuRiAqIChDICE9IEJhc2UpLCBPKTtcblxuICBpZiAoIUlTX1dFQUspIGNvbW1vbi5zZXRTdHJvbmcoQywgTkFNRSwgSVNfTUFQKTtcblxuICByZXR1cm4gQztcbn07XG4iLCJ2YXIgY29yZSA9IG1vZHVsZS5leHBvcnRzID0geyB2ZXJzaW9uOiAnMi41LjEnIH07XG5pZiAodHlwZW9mIF9fZSA9PSAnbnVtYmVyJykgX19lID0gY29yZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xudmFyIGNyZWF0ZURlc2MgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iamVjdCwgaW5kZXgsIHZhbHVlKSB7XG4gIGlmIChpbmRleCBpbiBvYmplY3QpICRkZWZpbmVQcm9wZXJ0eS5mKG9iamVjdCwgaW5kZXgsIGNyZWF0ZURlc2MoMCwgdmFsdWUpKTtcbiAgZWxzZSBvYmplY3RbaW5kZXhdID0gdmFsdWU7XG59O1xuIiwiLy8gb3B0aW9uYWwgLyBzaW1wbGUgY29udGV4dCBiaW5kaW5nXG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZm4sIHRoYXQsIGxlbmd0aCkge1xuICBhRnVuY3Rpb24oZm4pO1xuICBpZiAodGhhdCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gZm47XG4gIHN3aXRjaCAobGVuZ3RoKSB7XG4gICAgY2FzZSAxOiByZXR1cm4gZnVuY3Rpb24gKGEpIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEpO1xuICAgIH07XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIpO1xuICAgIH07XG4gICAgY2FzZSAzOiByZXR1cm4gZnVuY3Rpb24gKGEsIGIsIGMpIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIsIGMpO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uICgvKiAuLi5hcmdzICovKSB7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XG4gIH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gMjAuMy40LjM2IC8gMTUuOS41LjQzIERhdGUucHJvdG90eXBlLnRvSVNPU3RyaW5nKClcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG52YXIgZ2V0VGltZSA9IERhdGUucHJvdG90eXBlLmdldFRpbWU7XG52YXIgJHRvSVNPU3RyaW5nID0gRGF0ZS5wcm90b3R5cGUudG9JU09TdHJpbmc7XG5cbnZhciBseiA9IGZ1bmN0aW9uIChudW0pIHtcbiAgcmV0dXJuIG51bSA+IDkgPyBudW0gOiAnMCcgKyBudW07XG59O1xuXG4vLyBQaGFudG9tSlMgLyBvbGQgV2ViS2l0IGhhcyBhIGJyb2tlbiBpbXBsZW1lbnRhdGlvbnNcbm1vZHVsZS5leHBvcnRzID0gKGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICR0b0lTT1N0cmluZy5jYWxsKG5ldyBEYXRlKC01ZTEzIC0gMSkpICE9ICcwMzg1LTA3LTI1VDA3OjA2OjM5Ljk5OVonO1xufSkgfHwgIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgJHRvSVNPU3RyaW5nLmNhbGwobmV3IERhdGUoTmFOKSk7XG59KSkgPyBmdW5jdGlvbiB0b0lTT1N0cmluZygpIHtcbiAgaWYgKCFpc0Zpbml0ZShnZXRUaW1lLmNhbGwodGhpcykpKSB0aHJvdyBSYW5nZUVycm9yKCdJbnZhbGlkIHRpbWUgdmFsdWUnKTtcbiAgdmFyIGQgPSB0aGlzO1xuICB2YXIgeSA9IGQuZ2V0VVRDRnVsbFllYXIoKTtcbiAgdmFyIG0gPSBkLmdldFVUQ01pbGxpc2Vjb25kcygpO1xuICB2YXIgcyA9IHkgPCAwID8gJy0nIDogeSA+IDk5OTkgPyAnKycgOiAnJztcbiAgcmV0dXJuIHMgKyAoJzAwMDAwJyArIE1hdGguYWJzKHkpKS5zbGljZShzID8gLTYgOiAtNCkgK1xuICAgICctJyArIGx6KGQuZ2V0VVRDTW9udGgoKSArIDEpICsgJy0nICsgbHooZC5nZXRVVENEYXRlKCkpICtcbiAgICAnVCcgKyBseihkLmdldFVUQ0hvdXJzKCkpICsgJzonICsgbHooZC5nZXRVVENNaW51dGVzKCkpICtcbiAgICAnOicgKyBseihkLmdldFVUQ1NlY29uZHMoKSkgKyAnLicgKyAobSA+IDk5ID8gbSA6ICcwJyArIGx6KG0pKSArICdaJztcbn0gOiAkdG9JU09TdHJpbmc7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpO1xudmFyIE5VTUJFUiA9ICdudW1iZXInO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChoaW50KSB7XG4gIGlmIChoaW50ICE9PSAnc3RyaW5nJyAmJiBoaW50ICE9PSBOVU1CRVIgJiYgaGludCAhPT0gJ2RlZmF1bHQnKSB0aHJvdyBUeXBlRXJyb3IoJ0luY29ycmVjdCBoaW50Jyk7XG4gIHJldHVybiB0b1ByaW1pdGl2ZShhbk9iamVjdCh0aGlzKSwgaGludCAhPSBOVU1CRVIpO1xufTtcbiIsIi8vIDcuMi4xIFJlcXVpcmVPYmplY3RDb2VyY2libGUoYXJndW1lbnQpXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXQgPT0gdW5kZWZpbmVkKSB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjYWxsIG1ldGhvZCBvbiAgXCIgKyBpdCk7XG4gIHJldHVybiBpdDtcbn07XG4iLCIvLyBUaGFuaydzIElFOCBmb3IgaGlzIGZ1bm55IGRlZmluZVByb3BlcnR5XG5tb2R1bGUuZXhwb3J0cyA9ICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ2EnLCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfSB9KS5hICE9IDc7XG59KTtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGRvY3VtZW50ID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuZG9jdW1lbnQ7XG4vLyB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCBpcyAnb2JqZWN0JyBpbiBvbGQgSUVcbnZhciBpcyA9IGlzT2JqZWN0KGRvY3VtZW50KSAmJiBpc09iamVjdChkb2N1bWVudC5jcmVhdGVFbGVtZW50KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpcyA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoaXQpIDoge307XG59O1xuIiwiLy8gSUUgOC0gZG9uJ3QgZW51bSBidWcga2V5c1xubW9kdWxlLmV4cG9ydHMgPSAoXG4gICdjb25zdHJ1Y3RvcixoYXNPd25Qcm9wZXJ0eSxpc1Byb3RvdHlwZU9mLHByb3BlcnR5SXNFbnVtZXJhYmxlLHRvTG9jYWxlU3RyaW5nLHRvU3RyaW5nLHZhbHVlT2YnXG4pLnNwbGl0KCcsJyk7XG4iLCIvLyBhbGwgZW51bWVyYWJsZSBvYmplY3Qga2V5cywgaW5jbHVkZXMgc3ltYm9sc1xudmFyIGdldEtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xudmFyIGdPUFMgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wcycpO1xudmFyIHBJRSA9IHJlcXVpcmUoJy4vX29iamVjdC1waWUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciByZXN1bHQgPSBnZXRLZXlzKGl0KTtcbiAgdmFyIGdldFN5bWJvbHMgPSBnT1BTLmY7XG4gIGlmIChnZXRTeW1ib2xzKSB7XG4gICAgdmFyIHN5bWJvbHMgPSBnZXRTeW1ib2xzKGl0KTtcbiAgICB2YXIgaXNFbnVtID0gcElFLmY7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBrZXk7XG4gICAgd2hpbGUgKHN5bWJvbHMubGVuZ3RoID4gaSkgaWYgKGlzRW51bS5jYWxsKGl0LCBrZXkgPSBzeW1ib2xzW2krK10pKSByZXN1bHQucHVzaChrZXkpO1xuICB9IHJldHVybiByZXN1bHQ7XG59O1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGNvcmUgPSByZXF1aXJlKCcuL19jb3JlJyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJyk7XG52YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG5cbnZhciAkZXhwb3J0ID0gZnVuY3Rpb24gKHR5cGUsIG5hbWUsIHNvdXJjZSkge1xuICB2YXIgSVNfRk9SQ0VEID0gdHlwZSAmICRleHBvcnQuRjtcbiAgdmFyIElTX0dMT0JBTCA9IHR5cGUgJiAkZXhwb3J0Lkc7XG4gIHZhciBJU19TVEFUSUMgPSB0eXBlICYgJGV4cG9ydC5TO1xuICB2YXIgSVNfUFJPVE8gPSB0eXBlICYgJGV4cG9ydC5QO1xuICB2YXIgSVNfQklORCA9IHR5cGUgJiAkZXhwb3J0LkI7XG4gIHZhciB0YXJnZXQgPSBJU19HTE9CQUwgPyBnbG9iYWwgOiBJU19TVEFUSUMgPyBnbG9iYWxbbmFtZV0gfHwgKGdsb2JhbFtuYW1lXSA9IHt9KSA6IChnbG9iYWxbbmFtZV0gfHwge30pW1BST1RPVFlQRV07XG4gIHZhciBleHBvcnRzID0gSVNfR0xPQkFMID8gY29yZSA6IGNvcmVbbmFtZV0gfHwgKGNvcmVbbmFtZV0gPSB7fSk7XG4gIHZhciBleHBQcm90byA9IGV4cG9ydHNbUFJPVE9UWVBFXSB8fCAoZXhwb3J0c1tQUk9UT1RZUEVdID0ge30pO1xuICB2YXIga2V5LCBvd24sIG91dCwgZXhwO1xuICBpZiAoSVNfR0xPQkFMKSBzb3VyY2UgPSBuYW1lO1xuICBmb3IgKGtleSBpbiBzb3VyY2UpIHtcbiAgICAvLyBjb250YWlucyBpbiBuYXRpdmVcbiAgICBvd24gPSAhSVNfRk9SQ0VEICYmIHRhcmdldCAmJiB0YXJnZXRba2V5XSAhPT0gdW5kZWZpbmVkO1xuICAgIC8vIGV4cG9ydCBuYXRpdmUgb3IgcGFzc2VkXG4gICAgb3V0ID0gKG93biA/IHRhcmdldCA6IHNvdXJjZSlba2V5XTtcbiAgICAvLyBiaW5kIHRpbWVycyB0byBnbG9iYWwgZm9yIGNhbGwgZnJvbSBleHBvcnQgY29udGV4dFxuICAgIGV4cCA9IElTX0JJTkQgJiYgb3duID8gY3R4KG91dCwgZ2xvYmFsKSA6IElTX1BST1RPICYmIHR5cGVvZiBvdXQgPT0gJ2Z1bmN0aW9uJyA/IGN0eChGdW5jdGlvbi5jYWxsLCBvdXQpIDogb3V0O1xuICAgIC8vIGV4dGVuZCBnbG9iYWxcbiAgICBpZiAodGFyZ2V0KSByZWRlZmluZSh0YXJnZXQsIGtleSwgb3V0LCB0eXBlICYgJGV4cG9ydC5VKTtcbiAgICAvLyBleHBvcnRcbiAgICBpZiAoZXhwb3J0c1trZXldICE9IG91dCkgaGlkZShleHBvcnRzLCBrZXksIGV4cCk7XG4gICAgaWYgKElTX1BST1RPICYmIGV4cFByb3RvW2tleV0gIT0gb3V0KSBleHBQcm90b1trZXldID0gb3V0O1xuICB9XG59O1xuZ2xvYmFsLmNvcmUgPSBjb3JlO1xuLy8gdHlwZSBiaXRtYXBcbiRleHBvcnQuRiA9IDE7ICAgLy8gZm9yY2VkXG4kZXhwb3J0LkcgPSAyOyAgIC8vIGdsb2JhbFxuJGV4cG9ydC5TID0gNDsgICAvLyBzdGF0aWNcbiRleHBvcnQuUCA9IDg7ICAgLy8gcHJvdG9cbiRleHBvcnQuQiA9IDE2OyAgLy8gYmluZFxuJGV4cG9ydC5XID0gMzI7ICAvLyB3cmFwXG4kZXhwb3J0LlUgPSA2NDsgIC8vIHNhZmVcbiRleHBvcnQuUiA9IDEyODsgLy8gcmVhbCBwcm90byBtZXRob2QgZm9yIGBsaWJyYXJ5YFxubW9kdWxlLmV4cG9ydHMgPSAkZXhwb3J0O1xuIiwidmFyIE1BVENIID0gcmVxdWlyZSgnLi9fd2tzJykoJ21hdGNoJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChLRVkpIHtcbiAgdmFyIHJlID0gLy4vO1xuICB0cnkge1xuICAgICcvLi8nW0tFWV0ocmUpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJlW01BVENIXSA9IGZhbHNlO1xuICAgICAgcmV0dXJuICEnLy4vJ1tLRVldKHJlKTtcbiAgICB9IGNhdGNoIChmKSB7IC8qIGVtcHR5ICovIH1cbiAgfSByZXR1cm4gdHJ1ZTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChleGVjKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuICEhZXhlYygpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG52YXIgd2tzID0gcmVxdWlyZSgnLi9fd2tzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEtFWSwgbGVuZ3RoLCBleGVjKSB7XG4gIHZhciBTWU1CT0wgPSB3a3MoS0VZKTtcbiAgdmFyIGZucyA9IGV4ZWMoZGVmaW5lZCwgU1lNQk9MLCAnJ1tLRVldKTtcbiAgdmFyIHN0cmZuID0gZm5zWzBdO1xuICB2YXIgcnhmbiA9IGZuc1sxXTtcbiAgaWYgKGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgTyA9IHt9O1xuICAgIE9bU1lNQk9MXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH07XG4gICAgcmV0dXJuICcnW0tFWV0oTykgIT0gNztcbiAgfSkpIHtcbiAgICByZWRlZmluZShTdHJpbmcucHJvdG90eXBlLCBLRVksIHN0cmZuKTtcbiAgICBoaWRlKFJlZ0V4cC5wcm90b3R5cGUsIFNZTUJPTCwgbGVuZ3RoID09IDJcbiAgICAgIC8vIDIxLjIuNS44IFJlZ0V4cC5wcm90b3R5cGVbQEByZXBsYWNlXShzdHJpbmcsIHJlcGxhY2VWYWx1ZSlcbiAgICAgIC8vIDIxLjIuNS4xMSBSZWdFeHAucHJvdG90eXBlW0BAc3BsaXRdKHN0cmluZywgbGltaXQpXG4gICAgICA/IGZ1bmN0aW9uIChzdHJpbmcsIGFyZykgeyByZXR1cm4gcnhmbi5jYWxsKHN0cmluZywgdGhpcywgYXJnKTsgfVxuICAgICAgLy8gMjEuMi41LjYgUmVnRXhwLnByb3RvdHlwZVtAQG1hdGNoXShzdHJpbmcpXG4gICAgICAvLyAyMS4yLjUuOSBSZWdFeHAucHJvdG90eXBlW0BAc2VhcmNoXShzdHJpbmcpXG4gICAgICA6IGZ1bmN0aW9uIChzdHJpbmcpIHsgcmV0dXJuIHJ4Zm4uY2FsbChzdHJpbmcsIHRoaXMpOyB9XG4gICAgKTtcbiAgfVxufTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIDIxLjIuNS4zIGdldCBSZWdFeHAucHJvdG90eXBlLmZsYWdzXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgdGhhdCA9IGFuT2JqZWN0KHRoaXMpO1xuICB2YXIgcmVzdWx0ID0gJyc7XG4gIGlmICh0aGF0Lmdsb2JhbCkgcmVzdWx0ICs9ICdnJztcbiAgaWYgKHRoYXQuaWdub3JlQ2FzZSkgcmVzdWx0ICs9ICdpJztcbiAgaWYgKHRoYXQubXVsdGlsaW5lKSByZXN1bHQgKz0gJ20nO1xuICBpZiAodGhhdC51bmljb2RlKSByZXN1bHQgKz0gJ3UnO1xuICBpZiAodGhhdC5zdGlja3kpIHJlc3VsdCArPSAneSc7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9wcm9wb3NhbC1mbGF0TWFwLyNzZWMtRmxhdHRlbkludG9BcnJheVxudmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuL19pcy1hcnJheScpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciBJU19DT05DQVRfU1BSRUFEQUJMRSA9IHJlcXVpcmUoJy4vX3drcycpKCdpc0NvbmNhdFNwcmVhZGFibGUnKTtcblxuZnVuY3Rpb24gZmxhdHRlbkludG9BcnJheSh0YXJnZXQsIG9yaWdpbmFsLCBzb3VyY2UsIHNvdXJjZUxlbiwgc3RhcnQsIGRlcHRoLCBtYXBwZXIsIHRoaXNBcmcpIHtcbiAgdmFyIHRhcmdldEluZGV4ID0gc3RhcnQ7XG4gIHZhciBzb3VyY2VJbmRleCA9IDA7XG4gIHZhciBtYXBGbiA9IG1hcHBlciA/IGN0eChtYXBwZXIsIHRoaXNBcmcsIDMpIDogZmFsc2U7XG4gIHZhciBlbGVtZW50LCBzcHJlYWRhYmxlO1xuXG4gIHdoaWxlIChzb3VyY2VJbmRleCA8IHNvdXJjZUxlbikge1xuICAgIGlmIChzb3VyY2VJbmRleCBpbiBzb3VyY2UpIHtcbiAgICAgIGVsZW1lbnQgPSBtYXBGbiA/IG1hcEZuKHNvdXJjZVtzb3VyY2VJbmRleF0sIHNvdXJjZUluZGV4LCBvcmlnaW5hbCkgOiBzb3VyY2Vbc291cmNlSW5kZXhdO1xuXG4gICAgICBzcHJlYWRhYmxlID0gZmFsc2U7XG4gICAgICBpZiAoaXNPYmplY3QoZWxlbWVudCkpIHtcbiAgICAgICAgc3ByZWFkYWJsZSA9IGVsZW1lbnRbSVNfQ09OQ0FUX1NQUkVBREFCTEVdO1xuICAgICAgICBzcHJlYWRhYmxlID0gc3ByZWFkYWJsZSAhPT0gdW5kZWZpbmVkID8gISFzcHJlYWRhYmxlIDogaXNBcnJheShlbGVtZW50KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNwcmVhZGFibGUgJiYgZGVwdGggPiAwKSB7XG4gICAgICAgIHRhcmdldEluZGV4ID0gZmxhdHRlbkludG9BcnJheSh0YXJnZXQsIG9yaWdpbmFsLCBlbGVtZW50LCB0b0xlbmd0aChlbGVtZW50Lmxlbmd0aCksIHRhcmdldEluZGV4LCBkZXB0aCAtIDEpIC0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0YXJnZXRJbmRleCA+PSAweDFmZmZmZmZmZmZmZmZmKSB0aHJvdyBUeXBlRXJyb3IoKTtcbiAgICAgICAgdGFyZ2V0W3RhcmdldEluZGV4XSA9IGVsZW1lbnQ7XG4gICAgICB9XG5cbiAgICAgIHRhcmdldEluZGV4Kys7XG4gICAgfVxuICAgIHNvdXJjZUluZGV4Kys7XG4gIH1cbiAgcmV0dXJuIHRhcmdldEluZGV4O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZsYXR0ZW5JbnRvQXJyYXk7XG4iLCJ2YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG52YXIgY2FsbCA9IHJlcXVpcmUoJy4vX2l0ZXItY2FsbCcpO1xudmFyIGlzQXJyYXlJdGVyID0gcmVxdWlyZSgnLi9faXMtYXJyYXktaXRlcicpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciBnZXRJdGVyRm4gPSByZXF1aXJlKCcuL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZCcpO1xudmFyIEJSRUFLID0ge307XG52YXIgUkVUVVJOID0ge307XG52YXIgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0ZXJhYmxlLCBlbnRyaWVzLCBmbiwgdGhhdCwgSVRFUkFUT1IpIHtcbiAgdmFyIGl0ZXJGbiA9IElURVJBVE9SID8gZnVuY3Rpb24gKCkgeyByZXR1cm4gaXRlcmFibGU7IH0gOiBnZXRJdGVyRm4oaXRlcmFibGUpO1xuICB2YXIgZiA9IGN0eChmbiwgdGhhdCwgZW50cmllcyA/IDIgOiAxKTtcbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGxlbmd0aCwgc3RlcCwgaXRlcmF0b3IsIHJlc3VsdDtcbiAgaWYgKHR5cGVvZiBpdGVyRm4gIT0gJ2Z1bmN0aW9uJykgdGhyb3cgVHlwZUVycm9yKGl0ZXJhYmxlICsgJyBpcyBub3QgaXRlcmFibGUhJyk7XG4gIC8vIGZhc3QgY2FzZSBmb3IgYXJyYXlzIHdpdGggZGVmYXVsdCBpdGVyYXRvclxuICBpZiAoaXNBcnJheUl0ZXIoaXRlckZuKSkgZm9yIChsZW5ndGggPSB0b0xlbmd0aChpdGVyYWJsZS5sZW5ndGgpOyBsZW5ndGggPiBpbmRleDsgaW5kZXgrKykge1xuICAgIHJlc3VsdCA9IGVudHJpZXMgPyBmKGFuT2JqZWN0KHN0ZXAgPSBpdGVyYWJsZVtpbmRleF0pWzBdLCBzdGVwWzFdKSA6IGYoaXRlcmFibGVbaW5kZXhdKTtcbiAgICBpZiAocmVzdWx0ID09PSBCUkVBSyB8fCByZXN1bHQgPT09IFJFVFVSTikgcmV0dXJuIHJlc3VsdDtcbiAgfSBlbHNlIGZvciAoaXRlcmF0b3IgPSBpdGVyRm4uY2FsbChpdGVyYWJsZSk7ICEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZTspIHtcbiAgICByZXN1bHQgPSBjYWxsKGl0ZXJhdG9yLCBmLCBzdGVwLnZhbHVlLCBlbnRyaWVzKTtcbiAgICBpZiAocmVzdWx0ID09PSBCUkVBSyB8fCByZXN1bHQgPT09IFJFVFVSTikgcmV0dXJuIHJlc3VsdDtcbiAgfVxufTtcbmV4cG9ydHMuQlJFQUsgPSBCUkVBSztcbmV4cG9ydHMuUkVUVVJOID0gUkVUVVJOO1xuIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzg2I2lzc3VlY29tbWVudC0xMTU3NTkwMjhcbnZhciBnbG9iYWwgPSBtb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiB3aW5kb3cgIT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lk1hdGggPT0gTWF0aFxuICA/IHdpbmRvdyA6IHR5cGVvZiBzZWxmICE9ICd1bmRlZmluZWQnICYmIHNlbGYuTWF0aCA9PSBNYXRoID8gc2VsZlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LWZ1bmNcbiAgOiBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuaWYgKHR5cGVvZiBfX2cgPT0gJ251bWJlcicpIF9fZyA9IGdsb2JhbDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuIiwidmFyIGhhc093blByb3BlcnR5ID0ge30uaGFzT3duUHJvcGVydHk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwga2V5KSB7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGl0LCBrZXkpO1xufTtcbiIsInZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xudmFyIGNyZWF0ZURlc2MgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIHJldHVybiBkUC5mKG9iamVjdCwga2V5LCBjcmVhdGVEZXNjKDEsIHZhbHVlKSk7XG59IDogZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICByZXR1cm4gb2JqZWN0O1xufTtcbiIsInZhciBkb2N1bWVudCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLmRvY3VtZW50O1xubW9kdWxlLmV4cG9ydHMgPSBkb2N1bWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4iLCJtb2R1bGUuZXhwb3J0cyA9ICFyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXF1aXJlKCcuL19kb20tY3JlYXRlJykoJ2RpdicpLCAnYScsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9IH0pLmEgIT0gNztcbn0pO1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19zZXQtcHJvdG8nKS5zZXQ7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh0aGF0LCB0YXJnZXQsIEMpIHtcbiAgdmFyIFMgPSB0YXJnZXQuY29uc3RydWN0b3I7XG4gIHZhciBQO1xuICBpZiAoUyAhPT0gQyAmJiB0eXBlb2YgUyA9PSAnZnVuY3Rpb24nICYmIChQID0gUy5wcm90b3R5cGUpICE9PSBDLnByb3RvdHlwZSAmJiBpc09iamVjdChQKSAmJiBzZXRQcm90b3R5cGVPZikge1xuICAgIHNldFByb3RvdHlwZU9mKHRoYXQsIFApO1xuICB9IHJldHVybiB0aGF0O1xufTtcbiIsIi8vIGZhc3QgYXBwbHksIGh0dHA6Ly9qc3BlcmYubG5raXQuY29tL2Zhc3QtYXBwbHkvNVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZm4sIGFyZ3MsIHRoYXQpIHtcbiAgdmFyIHVuID0gdGhhdCA9PT0gdW5kZWZpbmVkO1xuICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgY2FzZSAwOiByZXR1cm4gdW4gPyBmbigpXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQpO1xuICAgIGNhc2UgMTogcmV0dXJuIHVuID8gZm4oYXJnc1swXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSk7XG4gICAgY2FzZSAyOiByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICBjYXNlIDM6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgIGNhc2UgNDogcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSk7XG4gIH0gcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3MpO1xufTtcbiIsIi8vIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgYW5kIG5vbi1lbnVtZXJhYmxlIG9sZCBWOCBzdHJpbmdzXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdCgneicpLnByb3BlcnR5SXNFbnVtZXJhYmxlKDApID8gT2JqZWN0IDogZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBjb2YoaXQpID09ICdTdHJpbmcnID8gaXQuc3BsaXQoJycpIDogT2JqZWN0KGl0KTtcbn07XG4iLCIvLyBjaGVjayBvbiBkZWZhdWx0IEFycmF5IGl0ZXJhdG9yXG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG52YXIgSVRFUkFUT1IgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKTtcbnZhciBBcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgIT09IHVuZGVmaW5lZCAmJiAoSXRlcmF0b3JzLkFycmF5ID09PSBpdCB8fCBBcnJheVByb3RvW0lURVJBVE9SXSA9PT0gaXQpO1xufTtcbiIsIi8vIDcuMi4yIElzQXJyYXkoYXJndW1lbnQpXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gaXNBcnJheShhcmcpIHtcbiAgcmV0dXJuIGNvZihhcmcpID09ICdBcnJheSc7XG59O1xuIiwiLy8gMjAuMS4yLjMgTnVtYmVyLmlzSW50ZWdlcihudW1iZXIpXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzSW50ZWdlcihpdCkge1xuICByZXR1cm4gIWlzT2JqZWN0KGl0KSAmJiBpc0Zpbml0ZShpdCkgJiYgZmxvb3IoaXQpID09PSBpdDtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdHlwZW9mIGl0ID09PSAnb2JqZWN0JyA/IGl0ICE9PSBudWxsIDogdHlwZW9mIGl0ID09PSAnZnVuY3Rpb24nO1xufTtcbiIsIi8vIDcuMi44IElzUmVnRXhwKGFyZ3VtZW50KVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG52YXIgTUFUQ0ggPSByZXF1aXJlKCcuL193a3MnKSgnbWF0Y2gnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBpc1JlZ0V4cDtcbiAgcmV0dXJuIGlzT2JqZWN0KGl0KSAmJiAoKGlzUmVnRXhwID0gaXRbTUFUQ0hdKSAhPT0gdW5kZWZpbmVkID8gISFpc1JlZ0V4cCA6IGNvZihpdCkgPT0gJ1JlZ0V4cCcpO1xufTtcbiIsIi8vIGNhbGwgc29tZXRoaW5nIG9uIGl0ZXJhdG9yIHN0ZXAgd2l0aCBzYWZlIGNsb3Npbmcgb24gZXJyb3JcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXRlcmF0b3IsIGZuLCB2YWx1ZSwgZW50cmllcykge1xuICB0cnkge1xuICAgIHJldHVybiBlbnRyaWVzID8gZm4oYW5PYmplY3QodmFsdWUpWzBdLCB2YWx1ZVsxXSkgOiBmbih2YWx1ZSk7XG4gIC8vIDcuNC42IEl0ZXJhdG9yQ2xvc2UoaXRlcmF0b3IsIGNvbXBsZXRpb24pXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB2YXIgcmV0ID0gaXRlcmF0b3JbJ3JldHVybiddO1xuICAgIGlmIChyZXQgIT09IHVuZGVmaW5lZCkgYW5PYmplY3QocmV0LmNhbGwoaXRlcmF0b3IpKTtcbiAgICB0aHJvdyBlO1xuICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGNyZWF0ZSA9IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKTtcbnZhciBkZXNjcmlwdG9yID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xudmFyIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKTtcbnZhciBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xuXG4vLyAyNS4xLjIuMS4xICVJdGVyYXRvclByb3RvdHlwZSVbQEBpdGVyYXRvcl0oKVxucmVxdWlyZSgnLi9faGlkZScpKEl0ZXJhdG9yUHJvdG90eXBlLCByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KSB7XG4gIENvbnN0cnVjdG9yLnByb3RvdHlwZSA9IGNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSwgeyBuZXh0OiBkZXNjcmlwdG9yKDEsIG5leHQpIH0pO1xuICBzZXRUb1N0cmluZ1RhZyhDb25zdHJ1Y3RvciwgTkFNRSArICcgSXRlcmF0b3InKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgTElCUkFSWSA9IHJlcXVpcmUoJy4vX2xpYnJhcnknKTtcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuL19yZWRlZmluZScpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG52YXIgJGl0ZXJDcmVhdGUgPSByZXF1aXJlKCcuL19pdGVyLWNyZWF0ZScpO1xudmFyIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKTtcbnZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKTtcbnZhciBJVEVSQVRPUiA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpO1xudmFyIEJVR0dZID0gIShbXS5rZXlzICYmICduZXh0JyBpbiBbXS5rZXlzKCkpOyAvLyBTYWZhcmkgaGFzIGJ1Z2d5IGl0ZXJhdG9ycyB3L28gYG5leHRgXG52YXIgRkZfSVRFUkFUT1IgPSAnQEBpdGVyYXRvcic7XG52YXIgS0VZUyA9ICdrZXlzJztcbnZhciBWQUxVRVMgPSAndmFsdWVzJztcblxudmFyIHJldHVyblRoaXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChCYXNlLCBOQU1FLCBDb25zdHJ1Y3RvciwgbmV4dCwgREVGQVVMVCwgSVNfU0VULCBGT1JDRUQpIHtcbiAgJGl0ZXJDcmVhdGUoQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpO1xuICB2YXIgZ2V0TWV0aG9kID0gZnVuY3Rpb24gKGtpbmQpIHtcbiAgICBpZiAoIUJVR0dZICYmIGtpbmQgaW4gcHJvdG8pIHJldHVybiBwcm90b1traW5kXTtcbiAgICBzd2l0Y2ggKGtpbmQpIHtcbiAgICAgIGNhc2UgS0VZUzogcmV0dXJuIGZ1bmN0aW9uIGtleXMoKSB7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gICAgICBjYXNlIFZBTFVFUzogcmV0dXJuIGZ1bmN0aW9uIHZhbHVlcygpIHsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgICB9IHJldHVybiBmdW5jdGlvbiBlbnRyaWVzKCkgeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICB9O1xuICB2YXIgVEFHID0gTkFNRSArICcgSXRlcmF0b3InO1xuICB2YXIgREVGX1ZBTFVFUyA9IERFRkFVTFQgPT0gVkFMVUVTO1xuICB2YXIgVkFMVUVTX0JVRyA9IGZhbHNlO1xuICB2YXIgcHJvdG8gPSBCYXNlLnByb3RvdHlwZTtcbiAgdmFyICRuYXRpdmUgPSBwcm90b1tJVEVSQVRPUl0gfHwgcHJvdG9bRkZfSVRFUkFUT1JdIHx8IERFRkFVTFQgJiYgcHJvdG9bREVGQVVMVF07XG4gIHZhciAkZGVmYXVsdCA9ICRuYXRpdmUgfHwgZ2V0TWV0aG9kKERFRkFVTFQpO1xuICB2YXIgJGVudHJpZXMgPSBERUZBVUxUID8gIURFRl9WQUxVRVMgPyAkZGVmYXVsdCA6IGdldE1ldGhvZCgnZW50cmllcycpIDogdW5kZWZpbmVkO1xuICB2YXIgJGFueU5hdGl2ZSA9IE5BTUUgPT0gJ0FycmF5JyA/IHByb3RvLmVudHJpZXMgfHwgJG5hdGl2ZSA6ICRuYXRpdmU7XG4gIHZhciBtZXRob2RzLCBrZXksIEl0ZXJhdG9yUHJvdG90eXBlO1xuICAvLyBGaXggbmF0aXZlXG4gIGlmICgkYW55TmF0aXZlKSB7XG4gICAgSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90b3R5cGVPZigkYW55TmF0aXZlLmNhbGwobmV3IEJhc2UoKSkpO1xuICAgIGlmIChJdGVyYXRvclByb3RvdHlwZSAhPT0gT2JqZWN0LnByb3RvdHlwZSAmJiBJdGVyYXRvclByb3RvdHlwZS5uZXh0KSB7XG4gICAgICAvLyBTZXQgQEB0b1N0cmluZ1RhZyB0byBuYXRpdmUgaXRlcmF0b3JzXG4gICAgICBzZXRUb1N0cmluZ1RhZyhJdGVyYXRvclByb3RvdHlwZSwgVEFHLCB0cnVlKTtcbiAgICAgIC8vIGZpeCBmb3Igc29tZSBvbGQgZW5naW5lc1xuICAgICAgaWYgKCFMSUJSQVJZICYmICFoYXMoSXRlcmF0b3JQcm90b3R5cGUsIElURVJBVE9SKSkgaGlkZShJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IsIHJldHVyblRoaXMpO1xuICAgIH1cbiAgfVxuICAvLyBmaXggQXJyYXkje3ZhbHVlcywgQEBpdGVyYXRvcn0ubmFtZSBpbiBWOCAvIEZGXG4gIGlmIChERUZfVkFMVUVTICYmICRuYXRpdmUgJiYgJG5hdGl2ZS5uYW1lICE9PSBWQUxVRVMpIHtcbiAgICBWQUxVRVNfQlVHID0gdHJ1ZTtcbiAgICAkZGVmYXVsdCA9IGZ1bmN0aW9uIHZhbHVlcygpIHsgcmV0dXJuICRuYXRpdmUuY2FsbCh0aGlzKTsgfTtcbiAgfVxuICAvLyBEZWZpbmUgaXRlcmF0b3JcbiAgaWYgKCghTElCUkFSWSB8fCBGT1JDRUQpICYmIChCVUdHWSB8fCBWQUxVRVNfQlVHIHx8ICFwcm90b1tJVEVSQVRPUl0pKSB7XG4gICAgaGlkZShwcm90bywgSVRFUkFUT1IsICRkZWZhdWx0KTtcbiAgfVxuICAvLyBQbHVnIGZvciBsaWJyYXJ5XG4gIEl0ZXJhdG9yc1tOQU1FXSA9ICRkZWZhdWx0O1xuICBJdGVyYXRvcnNbVEFHXSA9IHJldHVyblRoaXM7XG4gIGlmIChERUZBVUxUKSB7XG4gICAgbWV0aG9kcyA9IHtcbiAgICAgIHZhbHVlczogREVGX1ZBTFVFUyA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKFZBTFVFUyksXG4gICAgICBrZXlzOiBJU19TRVQgPyAkZGVmYXVsdCA6IGdldE1ldGhvZChLRVlTKSxcbiAgICAgIGVudHJpZXM6ICRlbnRyaWVzXG4gICAgfTtcbiAgICBpZiAoRk9SQ0VEKSBmb3IgKGtleSBpbiBtZXRob2RzKSB7XG4gICAgICBpZiAoIShrZXkgaW4gcHJvdG8pKSByZWRlZmluZShwcm90bywga2V5LCBtZXRob2RzW2tleV0pO1xuICAgIH0gZWxzZSAkZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIChCVUdHWSB8fCBWQUxVRVNfQlVHKSwgTkFNRSwgbWV0aG9kcyk7XG4gIH1cbiAgcmV0dXJuIG1ldGhvZHM7XG59O1xuIiwidmFyIElURVJBVE9SID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyk7XG52YXIgU0FGRV9DTE9TSU5HID0gZmFsc2U7XG5cbnRyeSB7XG4gIHZhciByaXRlciA9IFs3XVtJVEVSQVRPUl0oKTtcbiAgcml0ZXJbJ3JldHVybiddID0gZnVuY3Rpb24gKCkgeyBTQUZFX0NMT1NJTkcgPSB0cnVlOyB9O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdGhyb3ctbGl0ZXJhbFxuICBBcnJheS5mcm9tKHJpdGVyLCBmdW5jdGlvbiAoKSB7IHRocm93IDI7IH0pO1xufSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGV4ZWMsIHNraXBDbG9zaW5nKSB7XG4gIGlmICghc2tpcENsb3NpbmcgJiYgIVNBRkVfQ0xPU0lORykgcmV0dXJuIGZhbHNlO1xuICB2YXIgc2FmZSA9IGZhbHNlO1xuICB0cnkge1xuICAgIHZhciBhcnIgPSBbN107XG4gICAgdmFyIGl0ZXIgPSBhcnJbSVRFUkFUT1JdKCk7XG4gICAgaXRlci5uZXh0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4geyBkb25lOiBzYWZlID0gdHJ1ZSB9OyB9O1xuICAgIGFycltJVEVSQVRPUl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiBpdGVyOyB9O1xuICAgIGV4ZWMoYXJyKTtcbiAgfSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG4gIHJldHVybiBzYWZlO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGRvbmUsIHZhbHVlKSB7XG4gIHJldHVybiB7IHZhbHVlOiB2YWx1ZSwgZG9uZTogISFkb25lIH07XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7fTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZmFsc2U7XG4iLCIvLyAyMC4yLjIuMTQgTWF0aC5leHBtMSh4KVxudmFyICRleHBtMSA9IE1hdGguZXhwbTE7XG5tb2R1bGUuZXhwb3J0cyA9ICghJGV4cG0xXG4gIC8vIE9sZCBGRiBidWdcbiAgfHwgJGV4cG0xKDEwKSA+IDIyMDI1LjQ2NTc5NDgwNjcxOSB8fCAkZXhwbTEoMTApIDwgMjIwMjUuNDY1Nzk0ODA2NzE2NTE2OFxuICAvLyBUb3IgQnJvd3NlciBidWdcbiAgfHwgJGV4cG0xKC0yZS0xNykgIT0gLTJlLTE3XG4pID8gZnVuY3Rpb24gZXhwbTEoeCkge1xuICByZXR1cm4gKHggPSAreCkgPT0gMCA/IHggOiB4ID4gLTFlLTYgJiYgeCA8IDFlLTYgPyB4ICsgeCAqIHggLyAyIDogTWF0aC5leHAoeCkgLSAxO1xufSA6ICRleHBtMTtcbiIsIi8vIDIwLjIuMi4xNiBNYXRoLmZyb3VuZCh4KVxudmFyIHNpZ24gPSByZXF1aXJlKCcuL19tYXRoLXNpZ24nKTtcbnZhciBwb3cgPSBNYXRoLnBvdztcbnZhciBFUFNJTE9OID0gcG93KDIsIC01Mik7XG52YXIgRVBTSUxPTjMyID0gcG93KDIsIC0yMyk7XG52YXIgTUFYMzIgPSBwb3coMiwgMTI3KSAqICgyIC0gRVBTSUxPTjMyKTtcbnZhciBNSU4zMiA9IHBvdygyLCAtMTI2KTtcblxudmFyIHJvdW5kVGllc1RvRXZlbiA9IGZ1bmN0aW9uIChuKSB7XG4gIHJldHVybiBuICsgMSAvIEVQU0lMT04gLSAxIC8gRVBTSUxPTjtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTWF0aC5mcm91bmQgfHwgZnVuY3Rpb24gZnJvdW5kKHgpIHtcbiAgdmFyICRhYnMgPSBNYXRoLmFicyh4KTtcbiAgdmFyICRzaWduID0gc2lnbih4KTtcbiAgdmFyIGEsIHJlc3VsdDtcbiAgaWYgKCRhYnMgPCBNSU4zMikgcmV0dXJuICRzaWduICogcm91bmRUaWVzVG9FdmVuKCRhYnMgLyBNSU4zMiAvIEVQU0lMT04zMikgKiBNSU4zMiAqIEVQU0lMT04zMjtcbiAgYSA9ICgxICsgRVBTSUxPTjMyIC8gRVBTSUxPTikgKiAkYWJzO1xuICByZXN1bHQgPSBhIC0gKGEgLSAkYWJzKTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICBpZiAocmVzdWx0ID4gTUFYMzIgfHwgcmVzdWx0ICE9IHJlc3VsdCkgcmV0dXJuICRzaWduICogSW5maW5pdHk7XG4gIHJldHVybiAkc2lnbiAqIHJlc3VsdDtcbn07XG4iLCIvLyAyMC4yLjIuMjAgTWF0aC5sb2cxcCh4KVxubW9kdWxlLmV4cG9ydHMgPSBNYXRoLmxvZzFwIHx8IGZ1bmN0aW9uIGxvZzFwKHgpIHtcbiAgcmV0dXJuICh4ID0gK3gpID4gLTFlLTggJiYgeCA8IDFlLTggPyB4IC0geCAqIHggLyAyIDogTWF0aC5sb2coMSArIHgpO1xufTtcbiIsIi8vIGh0dHBzOi8vcndhbGRyb24uZ2l0aHViLmlvL3Byb3Bvc2FsLW1hdGgtZXh0ZW5zaW9ucy9cbm1vZHVsZS5leHBvcnRzID0gTWF0aC5zY2FsZSB8fCBmdW5jdGlvbiBzY2FsZSh4LCBpbkxvdywgaW5IaWdoLCBvdXRMb3csIG91dEhpZ2gpIHtcbiAgaWYgKFxuICAgIGFyZ3VtZW50cy5sZW5ndGggPT09IDBcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICAgIHx8IHggIT0geFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgICAgfHwgaW5Mb3cgIT0gaW5Mb3dcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICAgIHx8IGluSGlnaCAhPSBpbkhpZ2hcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICAgIHx8IG91dExvdyAhPSBvdXRMb3dcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICAgIHx8IG91dEhpZ2ggIT0gb3V0SGlnaFxuICApIHJldHVybiBOYU47XG4gIGlmICh4ID09PSBJbmZpbml0eSB8fCB4ID09PSAtSW5maW5pdHkpIHJldHVybiB4O1xuICByZXR1cm4gKHggLSBpbkxvdykgKiAob3V0SGlnaCAtIG91dExvdykgLyAoaW5IaWdoIC0gaW5Mb3cpICsgb3V0TG93O1xufTtcbiIsIi8vIDIwLjIuMi4yOCBNYXRoLnNpZ24oeClcbm1vZHVsZS5leHBvcnRzID0gTWF0aC5zaWduIHx8IGZ1bmN0aW9uIHNpZ24oeCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gIHJldHVybiAoeCA9ICt4KSA9PSAwIHx8IHggIT0geCA/IHggOiB4IDwgMCA/IC0xIDogMTtcbn07XG4iLCJ2YXIgTUVUQSA9IHJlcXVpcmUoJy4vX3VpZCcpKCdtZXRhJyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciBzZXREZXNjID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbnZhciBpZCA9IDA7XG52YXIgaXNFeHRlbnNpYmxlID0gT2JqZWN0LmlzRXh0ZW5zaWJsZSB8fCBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0cnVlO1xufTtcbnZhciBGUkVFWkUgPSAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBpc0V4dGVuc2libGUoT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKHt9KSk7XG59KTtcbnZhciBzZXRNZXRhID0gZnVuY3Rpb24gKGl0KSB7XG4gIHNldERlc2MoaXQsIE1FVEEsIHsgdmFsdWU6IHtcbiAgICBpOiAnTycgKyArK2lkLCAvLyBvYmplY3QgSURcbiAgICB3OiB7fSAgICAgICAgICAvLyB3ZWFrIGNvbGxlY3Rpb25zIElEc1xuICB9IH0pO1xufTtcbnZhciBmYXN0S2V5ID0gZnVuY3Rpb24gKGl0LCBjcmVhdGUpIHtcbiAgLy8gcmV0dXJuIHByaW1pdGl2ZSB3aXRoIHByZWZpeFxuICBpZiAoIWlzT2JqZWN0KGl0KSkgcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJyA/IGl0IDogKHR5cGVvZiBpdCA9PSAnc3RyaW5nJyA/ICdTJyA6ICdQJykgKyBpdDtcbiAgaWYgKCFoYXMoaXQsIE1FVEEpKSB7XG4gICAgLy8gY2FuJ3Qgc2V0IG1ldGFkYXRhIHRvIHVuY2F1Z2h0IGZyb3plbiBvYmplY3RcbiAgICBpZiAoIWlzRXh0ZW5zaWJsZShpdCkpIHJldHVybiAnRic7XG4gICAgLy8gbm90IG5lY2Vzc2FyeSB0byBhZGQgbWV0YWRhdGFcbiAgICBpZiAoIWNyZWF0ZSkgcmV0dXJuICdFJztcbiAgICAvLyBhZGQgbWlzc2luZyBtZXRhZGF0YVxuICAgIHNldE1ldGEoaXQpO1xuICAvLyByZXR1cm4gb2JqZWN0IElEXG4gIH0gcmV0dXJuIGl0W01FVEFdLmk7XG59O1xudmFyIGdldFdlYWsgPSBmdW5jdGlvbiAoaXQsIGNyZWF0ZSkge1xuICBpZiAoIWhhcyhpdCwgTUVUQSkpIHtcbiAgICAvLyBjYW4ndCBzZXQgbWV0YWRhdGEgdG8gdW5jYXVnaHQgZnJvemVuIG9iamVjdFxuICAgIGlmICghaXNFeHRlbnNpYmxlKGl0KSkgcmV0dXJuIHRydWU7XG4gICAgLy8gbm90IG5lY2Vzc2FyeSB0byBhZGQgbWV0YWRhdGFcbiAgICBpZiAoIWNyZWF0ZSkgcmV0dXJuIGZhbHNlO1xuICAgIC8vIGFkZCBtaXNzaW5nIG1ldGFkYXRhXG4gICAgc2V0TWV0YShpdCk7XG4gIC8vIHJldHVybiBoYXNoIHdlYWsgY29sbGVjdGlvbnMgSURzXG4gIH0gcmV0dXJuIGl0W01FVEFdLnc7XG59O1xuLy8gYWRkIG1ldGFkYXRhIG9uIGZyZWV6ZS1mYW1pbHkgbWV0aG9kcyBjYWxsaW5nXG52YXIgb25GcmVlemUgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKEZSRUVaRSAmJiBtZXRhLk5FRUQgJiYgaXNFeHRlbnNpYmxlKGl0KSAmJiAhaGFzKGl0LCBNRVRBKSkgc2V0TWV0YShpdCk7XG4gIHJldHVybiBpdDtcbn07XG52YXIgbWV0YSA9IG1vZHVsZS5leHBvcnRzID0ge1xuICBLRVk6IE1FVEEsXG4gIE5FRUQ6IGZhbHNlLFxuICBmYXN0S2V5OiBmYXN0S2V5LFxuICBnZXRXZWFrOiBnZXRXZWFrLFxuICBvbkZyZWV6ZTogb25GcmVlemVcbn07XG4iLCJ2YXIgTWFwID0gcmVxdWlyZSgnLi9lczYubWFwJyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHNoYXJlZCA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpKCdtZXRhZGF0YScpO1xudmFyIHN0b3JlID0gc2hhcmVkLnN0b3JlIHx8IChzaGFyZWQuc3RvcmUgPSBuZXcgKHJlcXVpcmUoJy4vZXM2LndlYWstbWFwJykpKCkpO1xuXG52YXIgZ2V0T3JDcmVhdGVNZXRhZGF0YU1hcCA9IGZ1bmN0aW9uICh0YXJnZXQsIHRhcmdldEtleSwgY3JlYXRlKSB7XG4gIHZhciB0YXJnZXRNZXRhZGF0YSA9IHN0b3JlLmdldCh0YXJnZXQpO1xuICBpZiAoIXRhcmdldE1ldGFkYXRhKSB7XG4gICAgaWYgKCFjcmVhdGUpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgc3RvcmUuc2V0KHRhcmdldCwgdGFyZ2V0TWV0YWRhdGEgPSBuZXcgTWFwKCkpO1xuICB9XG4gIHZhciBrZXlNZXRhZGF0YSA9IHRhcmdldE1ldGFkYXRhLmdldCh0YXJnZXRLZXkpO1xuICBpZiAoIWtleU1ldGFkYXRhKSB7XG4gICAgaWYgKCFjcmVhdGUpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgdGFyZ2V0TWV0YWRhdGEuc2V0KHRhcmdldEtleSwga2V5TWV0YWRhdGEgPSBuZXcgTWFwKCkpO1xuICB9IHJldHVybiBrZXlNZXRhZGF0YTtcbn07XG52YXIgb3JkaW5hcnlIYXNPd25NZXRhZGF0YSA9IGZ1bmN0aW9uIChNZXRhZGF0YUtleSwgTywgUCkge1xuICB2YXIgbWV0YWRhdGFNYXAgPSBnZXRPckNyZWF0ZU1ldGFkYXRhTWFwKE8sIFAsIGZhbHNlKTtcbiAgcmV0dXJuIG1ldGFkYXRhTWFwID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IG1ldGFkYXRhTWFwLmhhcyhNZXRhZGF0YUtleSk7XG59O1xudmFyIG9yZGluYXJ5R2V0T3duTWV0YWRhdGEgPSBmdW5jdGlvbiAoTWV0YWRhdGFLZXksIE8sIFApIHtcbiAgdmFyIG1ldGFkYXRhTWFwID0gZ2V0T3JDcmVhdGVNZXRhZGF0YU1hcChPLCBQLCBmYWxzZSk7XG4gIHJldHVybiBtZXRhZGF0YU1hcCA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogbWV0YWRhdGFNYXAuZ2V0KE1ldGFkYXRhS2V5KTtcbn07XG52YXIgb3JkaW5hcnlEZWZpbmVPd25NZXRhZGF0YSA9IGZ1bmN0aW9uIChNZXRhZGF0YUtleSwgTWV0YWRhdGFWYWx1ZSwgTywgUCkge1xuICBnZXRPckNyZWF0ZU1ldGFkYXRhTWFwKE8sIFAsIHRydWUpLnNldChNZXRhZGF0YUtleSwgTWV0YWRhdGFWYWx1ZSk7XG59O1xudmFyIG9yZGluYXJ5T3duTWV0YWRhdGFLZXlzID0gZnVuY3Rpb24gKHRhcmdldCwgdGFyZ2V0S2V5KSB7XG4gIHZhciBtZXRhZGF0YU1hcCA9IGdldE9yQ3JlYXRlTWV0YWRhdGFNYXAodGFyZ2V0LCB0YXJnZXRLZXksIGZhbHNlKTtcbiAgdmFyIGtleXMgPSBbXTtcbiAgaWYgKG1ldGFkYXRhTWFwKSBtZXRhZGF0YU1hcC5mb3JFYWNoKGZ1bmN0aW9uIChfLCBrZXkpIHsga2V5cy5wdXNoKGtleSk7IH0pO1xuICByZXR1cm4ga2V5cztcbn07XG52YXIgdG9NZXRhS2V5ID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiBpdCA9PSAnc3ltYm9sJyA/IGl0IDogU3RyaW5nKGl0KTtcbn07XG52YXIgZXhwID0gZnVuY3Rpb24gKE8pIHtcbiAgJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0JywgTyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc3RvcmU6IHN0b3JlLFxuICBtYXA6IGdldE9yQ3JlYXRlTWV0YWRhdGFNYXAsXG4gIGhhczogb3JkaW5hcnlIYXNPd25NZXRhZGF0YSxcbiAgZ2V0OiBvcmRpbmFyeUdldE93bk1ldGFkYXRhLFxuICBzZXQ6IG9yZGluYXJ5RGVmaW5lT3duTWV0YWRhdGEsXG4gIGtleXM6IG9yZGluYXJ5T3duTWV0YWRhdGFLZXlzLFxuICBrZXk6IHRvTWV0YUtleSxcbiAgZXhwOiBleHBcbn07XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgbWFjcm90YXNrID0gcmVxdWlyZSgnLi9fdGFzaycpLnNldDtcbnZhciBPYnNlcnZlciA9IGdsb2JhbC5NdXRhdGlvbk9ic2VydmVyIHx8IGdsb2JhbC5XZWJLaXRNdXRhdGlvbk9ic2VydmVyO1xudmFyIHByb2Nlc3MgPSBnbG9iYWwucHJvY2VzcztcbnZhciBQcm9taXNlID0gZ2xvYmFsLlByb21pc2U7XG52YXIgaXNOb2RlID0gcmVxdWlyZSgnLi9fY29mJykocHJvY2VzcykgPT0gJ3Byb2Nlc3MnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhlYWQsIGxhc3QsIG5vdGlmeTtcblxuICB2YXIgZmx1c2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHBhcmVudCwgZm47XG4gICAgaWYgKGlzTm9kZSAmJiAocGFyZW50ID0gcHJvY2Vzcy5kb21haW4pKSBwYXJlbnQuZXhpdCgpO1xuICAgIHdoaWxlIChoZWFkKSB7XG4gICAgICBmbiA9IGhlYWQuZm47XG4gICAgICBoZWFkID0gaGVhZC5uZXh0O1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm4oKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGhlYWQpIG5vdGlmeSgpO1xuICAgICAgICBlbHNlIGxhc3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfSBsYXN0ID0gdW5kZWZpbmVkO1xuICAgIGlmIChwYXJlbnQpIHBhcmVudC5lbnRlcigpO1xuICB9O1xuXG4gIC8vIE5vZGUuanNcbiAgaWYgKGlzTm9kZSkge1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZmx1c2gpO1xuICAgIH07XG4gIC8vIGJyb3dzZXJzIHdpdGggTXV0YXRpb25PYnNlcnZlclxuICB9IGVsc2UgaWYgKE9ic2VydmVyKSB7XG4gICAgdmFyIHRvZ2dsZSA9IHRydWU7XG4gICAgdmFyIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyk7XG4gICAgbmV3IE9ic2VydmVyKGZsdXNoKS5vYnNlcnZlKG5vZGUsIHsgY2hhcmFjdGVyRGF0YTogdHJ1ZSB9KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICBub3RpZnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBub2RlLmRhdGEgPSB0b2dnbGUgPSAhdG9nZ2xlO1xuICAgIH07XG4gIC8vIGVudmlyb25tZW50cyB3aXRoIG1heWJlIG5vbi1jb21wbGV0ZWx5IGNvcnJlY3QsIGJ1dCBleGlzdGVudCBQcm9taXNlXG4gIH0gZWxzZSBpZiAoUHJvbWlzZSAmJiBQcm9taXNlLnJlc29sdmUpIHtcbiAgICB2YXIgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHByb21pc2UudGhlbihmbHVzaCk7XG4gICAgfTtcbiAgLy8gZm9yIG90aGVyIGVudmlyb25tZW50cyAtIG1hY3JvdGFzayBiYXNlZCBvbjpcbiAgLy8gLSBzZXRJbW1lZGlhdGVcbiAgLy8gLSBNZXNzYWdlQ2hhbm5lbFxuICAvLyAtIHdpbmRvdy5wb3N0TWVzc2FnXG4gIC8vIC0gb25yZWFkeXN0YXRlY2hhbmdlXG4gIC8vIC0gc2V0VGltZW91dFxuICB9IGVsc2Uge1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIHN0cmFuZ2UgSUUgKyB3ZWJwYWNrIGRldiBzZXJ2ZXIgYnVnIC0gdXNlIC5jYWxsKGdsb2JhbClcbiAgICAgIG1hY3JvdGFzay5jYWxsKGdsb2JhbCwgZmx1c2gpO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKGZuKSB7XG4gICAgdmFyIHRhc2sgPSB7IGZuOiBmbiwgbmV4dDogdW5kZWZpbmVkIH07XG4gICAgaWYgKGxhc3QpIGxhc3QubmV4dCA9IHRhc2s7XG4gICAgaWYgKCFoZWFkKSB7XG4gICAgICBoZWFkID0gdGFzaztcbiAgICAgIG5vdGlmeSgpO1xuICAgIH0gbGFzdCA9IHRhc2s7XG4gIH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gMjUuNC4xLjUgTmV3UHJvbWlzZUNhcGFiaWxpdHkoQylcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG5cbmZ1bmN0aW9uIFByb21pc2VDYXBhYmlsaXR5KEMpIHtcbiAgdmFyIHJlc29sdmUsIHJlamVjdDtcbiAgdGhpcy5wcm9taXNlID0gbmV3IEMoZnVuY3Rpb24gKCQkcmVzb2x2ZSwgJCRyZWplY3QpIHtcbiAgICBpZiAocmVzb2x2ZSAhPT0gdW5kZWZpbmVkIHx8IHJlamVjdCAhPT0gdW5kZWZpbmVkKSB0aHJvdyBUeXBlRXJyb3IoJ0JhZCBQcm9taXNlIGNvbnN0cnVjdG9yJyk7XG4gICAgcmVzb2x2ZSA9ICQkcmVzb2x2ZTtcbiAgICByZWplY3QgPSAkJHJlamVjdDtcbiAgfSk7XG4gIHRoaXMucmVzb2x2ZSA9IGFGdW5jdGlvbihyZXNvbHZlKTtcbiAgdGhpcy5yZWplY3QgPSBhRnVuY3Rpb24ocmVqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMuZiA9IGZ1bmN0aW9uIChDKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZUNhcGFiaWxpdHkoQyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gMTkuMS4yLjEgT2JqZWN0LmFzc2lnbih0YXJnZXQsIHNvdXJjZSwgLi4uKVxudmFyIGdldEtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xudmFyIGdPUFMgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wcycpO1xudmFyIHBJRSA9IHJlcXVpcmUoJy4vX29iamVjdC1waWUnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyIElPYmplY3QgPSByZXF1aXJlKCcuL19pb2JqZWN0Jyk7XG52YXIgJGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XG5cbi8vIHNob3VsZCB3b3JrIHdpdGggc3ltYm9scyBhbmQgc2hvdWxkIGhhdmUgZGV0ZXJtaW5pc3RpYyBwcm9wZXJ0eSBvcmRlciAoVjggYnVnKVxubW9kdWxlLmV4cG9ydHMgPSAhJGFzc2lnbiB8fCByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgdmFyIEEgPSB7fTtcbiAgdmFyIEIgPSB7fTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gIHZhciBTID0gU3ltYm9sKCk7XG4gIHZhciBLID0gJ2FiY2RlZmdoaWprbG1ub3BxcnN0JztcbiAgQVtTXSA9IDc7XG4gIEsuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24gKGspIHsgQltrXSA9IGs7IH0pO1xuICByZXR1cm4gJGFzc2lnbih7fSwgQSlbU10gIT0gNyB8fCBPYmplY3Qua2V5cygkYXNzaWduKHt9LCBCKSkuam9pbignJykgIT0gSztcbn0pID8gZnVuY3Rpb24gYXNzaWduKHRhcmdldCwgc291cmNlKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgdmFyIFQgPSB0b09iamVjdCh0YXJnZXQpO1xuICB2YXIgYUxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHZhciBpbmRleCA9IDE7XG4gIHZhciBnZXRTeW1ib2xzID0gZ09QUy5mO1xuICB2YXIgaXNFbnVtID0gcElFLmY7XG4gIHdoaWxlIChhTGVuID4gaW5kZXgpIHtcbiAgICB2YXIgUyA9IElPYmplY3QoYXJndW1lbnRzW2luZGV4KytdKTtcbiAgICB2YXIga2V5cyA9IGdldFN5bWJvbHMgPyBnZXRLZXlzKFMpLmNvbmNhdChnZXRTeW1ib2xzKFMpKSA6IGdldEtleXMoUyk7XG4gICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIHZhciBqID0gMDtcbiAgICB2YXIga2V5O1xuICAgIHdoaWxlIChsZW5ndGggPiBqKSBpZiAoaXNFbnVtLmNhbGwoUywga2V5ID0ga2V5c1tqKytdKSkgVFtrZXldID0gU1trZXldO1xuICB9IHJldHVybiBUO1xufSA6ICRhc3NpZ247XG4iLCIvLyAxOS4xLjIuMiAvIDE1LjIuMy41IE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGRQcyA9IHJlcXVpcmUoJy4vX29iamVjdC1kcHMnKTtcbnZhciBlbnVtQnVnS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKTtcbnZhciBJRV9QUk9UTyA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKTtcbnZhciBFbXB0eSA9IGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfTtcbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcblxuLy8gQ3JlYXRlIG9iamVjdCB3aXRoIGZha2UgYG51bGxgIHByb3RvdHlwZTogdXNlIGlmcmFtZSBPYmplY3Qgd2l0aCBjbGVhcmVkIHByb3RvdHlwZVxudmFyIGNyZWF0ZURpY3QgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIFRocmFzaCwgd2FzdGUgYW5kIHNvZG9teTogSUUgR0MgYnVnXG4gIHZhciBpZnJhbWUgPSByZXF1aXJlKCcuL19kb20tY3JlYXRlJykoJ2lmcmFtZScpO1xuICB2YXIgaSA9IGVudW1CdWdLZXlzLmxlbmd0aDtcbiAgdmFyIGx0ID0gJzwnO1xuICB2YXIgZ3QgPSAnPic7XG4gIHZhciBpZnJhbWVEb2N1bWVudDtcbiAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIHJlcXVpcmUoJy4vX2h0bWwnKS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICBpZnJhbWUuc3JjID0gJ2phdmFzY3JpcHQ6JzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zY3JpcHQtdXJsXG4gIC8vIGNyZWF0ZURpY3QgPSBpZnJhbWUuY29udGVudFdpbmRvdy5PYmplY3Q7XG4gIC8vIGh0bWwucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcbiAgaWZyYW1lRG9jdW1lbnQgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDtcbiAgaWZyYW1lRG9jdW1lbnQub3BlbigpO1xuICBpZnJhbWVEb2N1bWVudC53cml0ZShsdCArICdzY3JpcHQnICsgZ3QgKyAnZG9jdW1lbnQuRj1PYmplY3QnICsgbHQgKyAnL3NjcmlwdCcgKyBndCk7XG4gIGlmcmFtZURvY3VtZW50LmNsb3NlKCk7XG4gIGNyZWF0ZURpY3QgPSBpZnJhbWVEb2N1bWVudC5GO1xuICB3aGlsZSAoaS0tKSBkZWxldGUgY3JlYXRlRGljdFtQUk9UT1RZUEVdW2VudW1CdWdLZXlzW2ldXTtcbiAgcmV0dXJuIGNyZWF0ZURpY3QoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmNyZWF0ZSB8fCBmdW5jdGlvbiBjcmVhdGUoTywgUHJvcGVydGllcykge1xuICB2YXIgcmVzdWx0O1xuICBpZiAoTyAhPT0gbnVsbCkge1xuICAgIEVtcHR5W1BST1RPVFlQRV0gPSBhbk9iamVjdChPKTtcbiAgICByZXN1bHQgPSBuZXcgRW1wdHkoKTtcbiAgICBFbXB0eVtQUk9UT1RZUEVdID0gbnVsbDtcbiAgICAvLyBhZGQgXCJfX3Byb3RvX19cIiBmb3IgT2JqZWN0LmdldFByb3RvdHlwZU9mIHBvbHlmaWxsXG4gICAgcmVzdWx0W0lFX1BST1RPXSA9IE87XG4gIH0gZWxzZSByZXN1bHQgPSBjcmVhdGVEaWN0KCk7XG4gIHJldHVybiBQcm9wZXJ0aWVzID09PSB1bmRlZmluZWQgPyByZXN1bHQgOiBkUHMocmVzdWx0LCBQcm9wZXJ0aWVzKTtcbn07XG4iLCJ2YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBJRThfRE9NX0RFRklORSA9IHJlcXVpcmUoJy4vX2llOC1kb20tZGVmaW5lJyk7XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcbnZhciBkUCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcblxuZXhwb3J0cy5mID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpIHtcbiAgYW5PYmplY3QoTyk7XG4gIFAgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcbiAgYW5PYmplY3QoQXR0cmlidXRlcyk7XG4gIGlmIChJRThfRE9NX0RFRklORSkgdHJ5IHtcbiAgICByZXR1cm4gZFAoTywgUCwgQXR0cmlidXRlcyk7XG4gIH0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxuICBpZiAoJ2dldCcgaW4gQXR0cmlidXRlcyB8fCAnc2V0JyBpbiBBdHRyaWJ1dGVzKSB0aHJvdyBUeXBlRXJyb3IoJ0FjY2Vzc29ycyBub3Qgc3VwcG9ydGVkIScpO1xuICBpZiAoJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzKSBPW1BdID0gQXR0cmlidXRlcy52YWx1ZTtcbiAgcmV0dXJuIE87XG59O1xuIiwidmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBnZXRLZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpIHtcbiAgYW5PYmplY3QoTyk7XG4gIHZhciBrZXlzID0gZ2V0S2V5cyhQcm9wZXJ0aWVzKTtcbiAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICB2YXIgaSA9IDA7XG4gIHZhciBQO1xuICB3aGlsZSAobGVuZ3RoID4gaSkgZFAuZihPLCBQID0ga2V5c1tpKytdLCBQcm9wZXJ0aWVzW1BdKTtcbiAgcmV0dXJuIE87XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gRm9yY2VkIHJlcGxhY2VtZW50IHByb3RvdHlwZSBhY2Nlc3NvcnMgbWV0aG9kc1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19saWJyYXJ5JykgfHwgIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICB2YXIgSyA9IE1hdGgucmFuZG9tKCk7XG4gIC8vIEluIEZGIHRocm93cyBvbmx5IGRlZmluZSBtZXRob2RzXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZiwgbm8tdXNlbGVzcy1jYWxsXG4gIF9fZGVmaW5lU2V0dGVyX18uY2FsbChudWxsLCBLLCBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH0pO1xuICBkZWxldGUgcmVxdWlyZSgnLi9fZ2xvYmFsJylbS107XG59KTtcbiIsInZhciBwSUUgPSByZXF1aXJlKCcuL19vYmplY3QtcGllJyk7XG52YXIgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciBJRThfRE9NX0RFRklORSA9IHJlcXVpcmUoJy4vX2llOC1kb20tZGVmaW5lJyk7XG52YXIgZ09QRCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5cbmV4cG9ydHMuZiA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBnT1BEIDogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApIHtcbiAgTyA9IHRvSU9iamVjdChPKTtcbiAgUCA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuICBpZiAoSUU4X0RPTV9ERUZJTkUpIHRyeSB7XG4gICAgcmV0dXJuIGdPUEQoTywgUCk7XG4gIH0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxuICBpZiAoaGFzKE8sIFApKSByZXR1cm4gY3JlYXRlRGVzYyghcElFLmYuY2FsbChPLCBQKSwgT1tQXSk7XG59O1xuIiwiLy8gZmFsbGJhY2sgZm9yIElFMTEgYnVnZ3kgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgd2l0aCBpZnJhbWUgYW5kIHdpbmRvd1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciBnT1BOID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mO1xudmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbnZhciB3aW5kb3dOYW1lcyA9IHR5cGVvZiB3aW5kb3cgPT0gJ29iamVjdCcgJiYgd2luZG93ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzXG4gID8gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMod2luZG93KSA6IFtdO1xuXG52YXIgZ2V0V2luZG93TmFtZXMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZ09QTihpdCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gd2luZG93TmFtZXMuc2xpY2UoKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMuZiA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoaXQpIHtcbiAgcmV0dXJuIHdpbmRvd05hbWVzICYmIHRvU3RyaW5nLmNhbGwoaXQpID09ICdbb2JqZWN0IFdpbmRvd10nID8gZ2V0V2luZG93TmFtZXMoaXQpIDogZ09QTih0b0lPYmplY3QoaXQpKTtcbn07XG4iLCIvLyAxOS4xLjIuNyAvIDE1LjIuMy40IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE8pXG52YXIgJGtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cy1pbnRlcm5hbCcpO1xudmFyIGhpZGRlbktleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJykuY29uY2F0KCdsZW5ndGgnLCAncHJvdG90eXBlJyk7XG5cbmV4cG9ydHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoTykge1xuICByZXR1cm4gJGtleXMoTywgaGlkZGVuS2V5cyk7XG59O1xuIiwiZXhwb3J0cy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbiIsIi8vIDE5LjEuMi45IC8gMTUuMi4zLjIgT2JqZWN0LmdldFByb3RvdHlwZU9mKE8pXG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciBJRV9QUk9UTyA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKTtcbnZhciBPYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmdldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIChPKSB7XG4gIE8gPSB0b09iamVjdChPKTtcbiAgaWYgKGhhcyhPLCBJRV9QUk9UTykpIHJldHVybiBPW0lFX1BST1RPXTtcbiAgaWYgKHR5cGVvZiBPLmNvbnN0cnVjdG9yID09ICdmdW5jdGlvbicgJiYgTyBpbnN0YW5jZW9mIE8uY29uc3RydWN0b3IpIHtcbiAgICByZXR1cm4gTy5jb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gIH0gcmV0dXJuIE8gaW5zdGFuY2VvZiBPYmplY3QgPyBPYmplY3RQcm90byA6IG51bGw7XG59O1xuIiwidmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciBhcnJheUluZGV4T2YgPSByZXF1aXJlKCcuL19hcnJheS1pbmNsdWRlcycpKGZhbHNlKTtcbnZhciBJRV9QUk9UTyA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lcykge1xuICB2YXIgTyA9IHRvSU9iamVjdChvYmplY3QpO1xuICB2YXIgaSA9IDA7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGtleTtcbiAgZm9yIChrZXkgaW4gTykgaWYgKGtleSAhPSBJRV9QUk9UTykgaGFzKE8sIGtleSkgJiYgcmVzdWx0LnB1c2goa2V5KTtcbiAgLy8gRG9uJ3QgZW51bSBidWcgJiBoaWRkZW4ga2V5c1xuICB3aGlsZSAobmFtZXMubGVuZ3RoID4gaSkgaWYgKGhhcyhPLCBrZXkgPSBuYW1lc1tpKytdKSkge1xuICAgIH5hcnJheUluZGV4T2YocmVzdWx0LCBrZXkpIHx8IHJlc3VsdC5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG4iLCIvLyAxOS4xLjIuMTQgLyAxNS4yLjMuMTQgT2JqZWN0LmtleXMoTylcbnZhciAka2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzLWludGVybmFsJyk7XG52YXIgZW51bUJ1Z0tleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24ga2V5cyhPKSB7XG4gIHJldHVybiAka2V5cyhPLCBlbnVtQnVnS2V5cyk7XG59O1xuIiwiZXhwb3J0cy5mID0ge30ucHJvcGVydHlJc0VudW1lcmFibGU7XG4iLCIvLyBtb3N0IE9iamVjdCBtZXRob2RzIGJ5IEVTNiBzaG91bGQgYWNjZXB0IHByaW1pdGl2ZXNcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgY29yZSA9IHJlcXVpcmUoJy4vX2NvcmUnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChLRVksIGV4ZWMpIHtcbiAgdmFyIGZuID0gKGNvcmUuT2JqZWN0IHx8IHt9KVtLRVldIHx8IE9iamVjdFtLRVldO1xuICB2YXIgZXhwID0ge307XG4gIGV4cFtLRVldID0gZXhlYyhmbik7XG4gICRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogZmFpbHMoZnVuY3Rpb24gKCkgeyBmbigxKTsgfSksICdPYmplY3QnLCBleHApO1xufTtcbiIsInZhciBnZXRLZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgaXNFbnVtID0gcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpLmY7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpc0VudHJpZXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChpdCkge1xuICAgIHZhciBPID0gdG9JT2JqZWN0KGl0KTtcbiAgICB2YXIga2V5cyA9IGdldEtleXMoTyk7XG4gICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIGtleTtcbiAgICB3aGlsZSAobGVuZ3RoID4gaSkgaWYgKGlzRW51bS5jYWxsKE8sIGtleSA9IGtleXNbaSsrXSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGlzRW50cmllcyA/IFtrZXksIE9ba2V5XV0gOiBPW2tleV0pO1xuICAgIH0gcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn07XG4iLCIvLyBhbGwgb2JqZWN0IGtleXMsIGluY2x1ZGVzIG5vbi1lbnVtZXJhYmxlIGFuZCBzeW1ib2xzXG52YXIgZ09QTiA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuJyk7XG52YXIgZ09QUyA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BzJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBSZWZsZWN0ID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuUmVmbGVjdDtcbm1vZHVsZS5leHBvcnRzID0gUmVmbGVjdCAmJiBSZWZsZWN0Lm93bktleXMgfHwgZnVuY3Rpb24gb3duS2V5cyhpdCkge1xuICB2YXIga2V5cyA9IGdPUE4uZihhbk9iamVjdChpdCkpO1xuICB2YXIgZ2V0U3ltYm9scyA9IGdPUFMuZjtcbiAgcmV0dXJuIGdldFN5bWJvbHMgPyBrZXlzLmNvbmNhdChnZXRTeW1ib2xzKGl0KSkgOiBrZXlzO1xufTtcbiIsInZhciAkcGFyc2VGbG9hdCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLnBhcnNlRmxvYXQ7XG52YXIgJHRyaW0gPSByZXF1aXJlKCcuL19zdHJpbmctdHJpbScpLnRyaW07XG5cbm1vZHVsZS5leHBvcnRzID0gMSAvICRwYXJzZUZsb2F0KHJlcXVpcmUoJy4vX3N0cmluZy13cycpICsgJy0wJykgIT09IC1JbmZpbml0eSA/IGZ1bmN0aW9uIHBhcnNlRmxvYXQoc3RyKSB7XG4gIHZhciBzdHJpbmcgPSAkdHJpbShTdHJpbmcoc3RyKSwgMyk7XG4gIHZhciByZXN1bHQgPSAkcGFyc2VGbG9hdChzdHJpbmcpO1xuICByZXR1cm4gcmVzdWx0ID09PSAwICYmIHN0cmluZy5jaGFyQXQoMCkgPT0gJy0nID8gLTAgOiByZXN1bHQ7XG59IDogJHBhcnNlRmxvYXQ7XG4iLCJ2YXIgJHBhcnNlSW50ID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykucGFyc2VJbnQ7XG52YXIgJHRyaW0gPSByZXF1aXJlKCcuL19zdHJpbmctdHJpbScpLnRyaW07XG52YXIgd3MgPSByZXF1aXJlKCcuL19zdHJpbmctd3MnKTtcbnZhciBoZXggPSAvXlstK10/MFt4WF0vO1xuXG5tb2R1bGUuZXhwb3J0cyA9ICRwYXJzZUludCh3cyArICcwOCcpICE9PSA4IHx8ICRwYXJzZUludCh3cyArICcweDE2JykgIT09IDIyID8gZnVuY3Rpb24gcGFyc2VJbnQoc3RyLCByYWRpeCkge1xuICB2YXIgc3RyaW5nID0gJHRyaW0oU3RyaW5nKHN0ciksIDMpO1xuICByZXR1cm4gJHBhcnNlSW50KHN0cmluZywgKHJhZGl4ID4+PiAwKSB8fCAoaGV4LnRlc3Qoc3RyaW5nKSA/IDE2IDogMTApKTtcbn0gOiAkcGFyc2VJbnQ7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChleGVjKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHsgZTogZmFsc2UsIHY6IGV4ZWMoKSB9O1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHsgZTogdHJ1ZSwgdjogZSB9O1xuICB9XG59O1xuIiwidmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eSA9IHJlcXVpcmUoJy4vX25ldy1wcm9taXNlLWNhcGFiaWxpdHknKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQywgeCkge1xuICBhbk9iamVjdChDKTtcbiAgaWYgKGlzT2JqZWN0KHgpICYmIHguY29uc3RydWN0b3IgPT09IEMpIHJldHVybiB4O1xuICB2YXIgcHJvbWlzZUNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eS5mKEMpO1xuICB2YXIgcmVzb2x2ZSA9IHByb21pc2VDYXBhYmlsaXR5LnJlc29sdmU7XG4gIHJlc29sdmUoeCk7XG4gIHJldHVybiBwcm9taXNlQ2FwYWJpbGl0eS5wcm9taXNlO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGJpdG1hcCwgdmFsdWUpIHtcbiAgcmV0dXJuIHtcbiAgICBlbnVtZXJhYmxlOiAhKGJpdG1hcCAmIDEpLFxuICAgIGNvbmZpZ3VyYWJsZTogIShiaXRtYXAgJiAyKSxcbiAgICB3cml0YWJsZTogIShiaXRtYXAgJiA0KSxcbiAgICB2YWx1ZTogdmFsdWVcbiAgfTtcbn07XG4iLCJ2YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuL19yZWRlZmluZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodGFyZ2V0LCBzcmMsIHNhZmUpIHtcbiAgZm9yICh2YXIga2V5IGluIHNyYykgcmVkZWZpbmUodGFyZ2V0LCBrZXksIHNyY1trZXldLCBzYWZlKTtcbiAgcmV0dXJuIHRhcmdldDtcbn07XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciBTUkMgPSByZXF1aXJlKCcuL191aWQnKSgnc3JjJyk7XG52YXIgVE9fU1RSSU5HID0gJ3RvU3RyaW5nJztcbnZhciAkdG9TdHJpbmcgPSBGdW5jdGlvbltUT19TVFJJTkddO1xudmFyIFRQTCA9ICgnJyArICR0b1N0cmluZykuc3BsaXQoVE9fU1RSSU5HKTtcblxucmVxdWlyZSgnLi9fY29yZScpLmluc3BlY3RTb3VyY2UgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuICR0b1N0cmluZy5jYWxsKGl0KTtcbn07XG5cbihtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChPLCBrZXksIHZhbCwgc2FmZSkge1xuICB2YXIgaXNGdW5jdGlvbiA9IHR5cGVvZiB2YWwgPT0gJ2Z1bmN0aW9uJztcbiAgaWYgKGlzRnVuY3Rpb24pIGhhcyh2YWwsICduYW1lJykgfHwgaGlkZSh2YWwsICduYW1lJywga2V5KTtcbiAgaWYgKE9ba2V5XSA9PT0gdmFsKSByZXR1cm47XG4gIGlmIChpc0Z1bmN0aW9uKSBoYXModmFsLCBTUkMpIHx8IGhpZGUodmFsLCBTUkMsIE9ba2V5XSA/ICcnICsgT1trZXldIDogVFBMLmpvaW4oU3RyaW5nKGtleSkpKTtcbiAgaWYgKE8gPT09IGdsb2JhbCkge1xuICAgIE9ba2V5XSA9IHZhbDtcbiAgfSBlbHNlIGlmICghc2FmZSkge1xuICAgIGRlbGV0ZSBPW2tleV07XG4gICAgaGlkZShPLCBrZXksIHZhbCk7XG4gIH0gZWxzZSBpZiAoT1trZXldKSB7XG4gICAgT1trZXldID0gdmFsO1xuICB9IGVsc2Uge1xuICAgIGhpZGUoTywga2V5LCB2YWwpO1xuICB9XG4vLyBhZGQgZmFrZSBGdW5jdGlvbiN0b1N0cmluZyBmb3IgY29ycmVjdCB3b3JrIHdyYXBwZWQgbWV0aG9kcyAvIGNvbnN0cnVjdG9ycyB3aXRoIG1ldGhvZHMgbGlrZSBMb0Rhc2ggaXNOYXRpdmVcbn0pKEZ1bmN0aW9uLnByb3RvdHlwZSwgVE9fU1RSSU5HLCBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgcmV0dXJuIHR5cGVvZiB0aGlzID09ICdmdW5jdGlvbicgJiYgdGhpc1tTUkNdIHx8ICR0b1N0cmluZy5jYWxsKHRoaXMpO1xufSk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChyZWdFeHAsIHJlcGxhY2UpIHtcbiAgdmFyIHJlcGxhY2VyID0gcmVwbGFjZSA9PT0gT2JqZWN0KHJlcGxhY2UpID8gZnVuY3Rpb24gKHBhcnQpIHtcbiAgICByZXR1cm4gcmVwbGFjZVtwYXJ0XTtcbiAgfSA6IHJlcGxhY2U7XG4gIHJldHVybiBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gU3RyaW5nKGl0KS5yZXBsYWNlKHJlZ0V4cCwgcmVwbGFjZXIpO1xuICB9O1xufTtcbiIsIi8vIDcuMi45IFNhbWVWYWx1ZSh4LCB5KVxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuaXMgfHwgZnVuY3Rpb24gaXMoeCwgeSkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gIHJldHVybiB4ID09PSB5ID8geCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHkgOiB4ICE9IHggJiYgeSAhPSB5O1xufTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vcHJvcG9zYWwtc2V0bWFwLW9mZnJvbS9cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xudmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyIGZvck9mID0gcmVxdWlyZSgnLi9fZm9yLW9mJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKENPTExFQ1RJT04pIHtcbiAgJGV4cG9ydCgkZXhwb3J0LlMsIENPTExFQ1RJT04sIHsgZnJvbTogZnVuY3Rpb24gZnJvbShzb3VyY2UgLyogLCBtYXBGbiwgdGhpc0FyZyAqLykge1xuICAgIHZhciBtYXBGbiA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgbWFwcGluZywgQSwgbiwgY2I7XG4gICAgYUZ1bmN0aW9uKHRoaXMpO1xuICAgIG1hcHBpbmcgPSBtYXBGbiAhPT0gdW5kZWZpbmVkO1xuICAgIGlmIChtYXBwaW5nKSBhRnVuY3Rpb24obWFwRm4pO1xuICAgIGlmIChzb3VyY2UgPT0gdW5kZWZpbmVkKSByZXR1cm4gbmV3IHRoaXMoKTtcbiAgICBBID0gW107XG4gICAgaWYgKG1hcHBpbmcpIHtcbiAgICAgIG4gPSAwO1xuICAgICAgY2IgPSBjdHgobWFwRm4sIGFyZ3VtZW50c1syXSwgMik7XG4gICAgICBmb3JPZihzb3VyY2UsIGZhbHNlLCBmdW5jdGlvbiAobmV4dEl0ZW0pIHtcbiAgICAgICAgQS5wdXNoKGNiKG5leHRJdGVtLCBuKyspKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3JPZihzb3VyY2UsIGZhbHNlLCBBLnB1c2gsIEEpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IHRoaXMoQSk7XG4gIH0gfSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9wcm9wb3NhbC1zZXRtYXAtb2Zmcm9tL1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQ09MTEVDVElPTikge1xuICAkZXhwb3J0KCRleHBvcnQuUywgQ09MTEVDVElPTiwgeyBvZjogZnVuY3Rpb24gb2YoKSB7XG4gICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIEEgPSBBcnJheShsZW5ndGgpO1xuICAgIHdoaWxlIChsZW5ndGgtLSkgQVtsZW5ndGhdID0gYXJndW1lbnRzW2xlbmd0aF07XG4gICAgcmV0dXJuIG5ldyB0aGlzKEEpO1xuICB9IH0pO1xufTtcbiIsIi8vIFdvcmtzIHdpdGggX19wcm90b19fIG9ubHkuIE9sZCB2OCBjYW4ndCB3b3JrIHdpdGggbnVsbCBwcm90byBvYmplY3RzLlxuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgY2hlY2sgPSBmdW5jdGlvbiAoTywgcHJvdG8pIHtcbiAgYW5PYmplY3QoTyk7XG4gIGlmICghaXNPYmplY3QocHJvdG8pICYmIHByb3RvICE9PSBudWxsKSB0aHJvdyBUeXBlRXJyb3IocHJvdG8gKyBcIjogY2FuJ3Qgc2V0IGFzIHByb3RvdHlwZSFcIik7XG59O1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNldDogT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8ICgnX19wcm90b19fJyBpbiB7fSA/IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICBmdW5jdGlvbiAodGVzdCwgYnVnZ3ksIHNldCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc2V0ID0gcmVxdWlyZSgnLi9fY3R4JykoRnVuY3Rpb24uY2FsbCwgcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKS5mKE9iamVjdC5wcm90b3R5cGUsICdfX3Byb3RvX18nKS5zZXQsIDIpO1xuICAgICAgICBzZXQodGVzdCwgW10pO1xuICAgICAgICBidWdneSA9ICEodGVzdCBpbnN0YW5jZW9mIEFycmF5KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHsgYnVnZ3kgPSB0cnVlOyB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24gc2V0UHJvdG90eXBlT2YoTywgcHJvdG8pIHtcbiAgICAgICAgY2hlY2soTywgcHJvdG8pO1xuICAgICAgICBpZiAoYnVnZ3kpIE8uX19wcm90b19fID0gcHJvdG87XG4gICAgICAgIGVsc2Ugc2V0KE8sIHByb3RvKTtcbiAgICAgICAgcmV0dXJuIE87XG4gICAgICB9O1xuICAgIH0oe30sIGZhbHNlKSA6IHVuZGVmaW5lZCksXG4gIGNoZWNrOiBjaGVja1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKTtcbnZhciBTUEVDSUVTID0gcmVxdWlyZSgnLi9fd2tzJykoJ3NwZWNpZXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoS0VZKSB7XG4gIHZhciBDID0gZ2xvYmFsW0tFWV07XG4gIGlmIChERVNDUklQVE9SUyAmJiBDICYmICFDW1NQRUNJRVNdKSBkUC5mKEMsIFNQRUNJRVMsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9XG4gIH0pO1xufTtcbiIsInZhciBkZWYgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIFRBRyA9IHJlcXVpcmUoJy4vX3drcycpKCd0b1N0cmluZ1RhZycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgdGFnLCBzdGF0KSB7XG4gIGlmIChpdCAmJiAhaGFzKGl0ID0gc3RhdCA/IGl0IDogaXQucHJvdG90eXBlLCBUQUcpKSBkZWYoaXQsIFRBRywgeyBjb25maWd1cmFibGU6IHRydWUsIHZhbHVlOiB0YWcgfSk7XG59O1xuIiwidmFyIHNoYXJlZCA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpKCdrZXlzJyk7XG52YXIgdWlkID0gcmVxdWlyZSgnLi9fdWlkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuIHNoYXJlZFtrZXldIHx8IChzaGFyZWRba2V5XSA9IHVpZChrZXkpKTtcbn07XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgU0hBUkVEID0gJ19fY29yZS1qc19zaGFyZWRfXyc7XG52YXIgc3RvcmUgPSBnbG9iYWxbU0hBUkVEXSB8fCAoZ2xvYmFsW1NIQVJFRF0gPSB7fSk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuIHN0b3JlW2tleV0gfHwgKHN0b3JlW2tleV0gPSB7fSk7XG59O1xuIiwiLy8gNy4zLjIwIFNwZWNpZXNDb25zdHJ1Y3RvcihPLCBkZWZhdWx0Q29uc3RydWN0b3IpXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG52YXIgU1BFQ0lFUyA9IHJlcXVpcmUoJy4vX3drcycpKCdzcGVjaWVzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChPLCBEKSB7XG4gIHZhciBDID0gYW5PYmplY3QoTykuY29uc3RydWN0b3I7XG4gIHZhciBTO1xuICByZXR1cm4gQyA9PT0gdW5kZWZpbmVkIHx8IChTID0gYW5PYmplY3QoQylbU1BFQ0lFU10pID09IHVuZGVmaW5lZCA/IEQgOiBhRnVuY3Rpb24oUyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobWV0aG9kLCBhcmcpIHtcbiAgcmV0dXJuICEhbWV0aG9kICYmIGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdXNlbGVzcy1jYWxsXG4gICAgYXJnID8gbWV0aG9kLmNhbGwobnVsbCwgZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9LCAxKSA6IG1ldGhvZC5jYWxsKG51bGwpO1xuICB9KTtcbn07XG4iLCJ2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG4vLyB0cnVlICAtPiBTdHJpbmcjYXRcbi8vIGZhbHNlIC0+IFN0cmluZyNjb2RlUG9pbnRBdFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoVE9fU1RSSU5HKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodGhhdCwgcG9zKSB7XG4gICAgdmFyIHMgPSBTdHJpbmcoZGVmaW5lZCh0aGF0KSk7XG4gICAgdmFyIGkgPSB0b0ludGVnZXIocG9zKTtcbiAgICB2YXIgbCA9IHMubGVuZ3RoO1xuICAgIHZhciBhLCBiO1xuICAgIGlmIChpIDwgMCB8fCBpID49IGwpIHJldHVybiBUT19TVFJJTkcgPyAnJyA6IHVuZGVmaW5lZDtcbiAgICBhID0gcy5jaGFyQ29kZUF0KGkpO1xuICAgIHJldHVybiBhIDwgMHhkODAwIHx8IGEgPiAweGRiZmYgfHwgaSArIDEgPT09IGwgfHwgKGIgPSBzLmNoYXJDb2RlQXQoaSArIDEpKSA8IDB4ZGMwMCB8fCBiID4gMHhkZmZmXG4gICAgICA/IFRPX1NUUklORyA/IHMuY2hhckF0KGkpIDogYVxuICAgICAgOiBUT19TVFJJTkcgPyBzLnNsaWNlKGksIGkgKyAyKSA6IChhIC0gMHhkODAwIDw8IDEwKSArIChiIC0gMHhkYzAwKSArIDB4MTAwMDA7XG4gIH07XG59O1xuIiwiLy8gaGVscGVyIGZvciBTdHJpbmcje3N0YXJ0c1dpdGgsIGVuZHNXaXRoLCBpbmNsdWRlc31cbnZhciBpc1JlZ0V4cCA9IHJlcXVpcmUoJy4vX2lzLXJlZ2V4cCcpO1xudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHRoYXQsIHNlYXJjaFN0cmluZywgTkFNRSkge1xuICBpZiAoaXNSZWdFeHAoc2VhcmNoU3RyaW5nKSkgdGhyb3cgVHlwZUVycm9yKCdTdHJpbmcjJyArIE5BTUUgKyBcIiBkb2Vzbid0IGFjY2VwdCByZWdleCFcIik7XG4gIHJldHVybiBTdHJpbmcoZGVmaW5lZCh0aGF0KSk7XG59O1xuIiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbnZhciBxdW90ID0gL1wiL2c7XG4vLyBCLjIuMy4yLjEgQ3JlYXRlSFRNTChzdHJpbmcsIHRhZywgYXR0cmlidXRlLCB2YWx1ZSlcbnZhciBjcmVhdGVIVE1MID0gZnVuY3Rpb24gKHN0cmluZywgdGFnLCBhdHRyaWJ1dGUsIHZhbHVlKSB7XG4gIHZhciBTID0gU3RyaW5nKGRlZmluZWQoc3RyaW5nKSk7XG4gIHZhciBwMSA9ICc8JyArIHRhZztcbiAgaWYgKGF0dHJpYnV0ZSAhPT0gJycpIHAxICs9ICcgJyArIGF0dHJpYnV0ZSArICc9XCInICsgU3RyaW5nKHZhbHVlKS5yZXBsYWNlKHF1b3QsICcmcXVvdDsnKSArICdcIic7XG4gIHJldHVybiBwMSArICc+JyArIFMgKyAnPC8nICsgdGFnICsgJz4nO1xufTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE5BTUUsIGV4ZWMpIHtcbiAgdmFyIE8gPSB7fTtcbiAgT1tOQU1FXSA9IGV4ZWMoY3JlYXRlSFRNTCk7XG4gICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIHZhciB0ZXN0ID0gJydbTkFNRV0oJ1wiJyk7XG4gICAgcmV0dXJuIHRlc3QgIT09IHRlc3QudG9Mb3dlckNhc2UoKSB8fCB0ZXN0LnNwbGl0KCdcIicpLmxlbmd0aCA+IDM7XG4gIH0pLCAnU3RyaW5nJywgTyk7XG59O1xuIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtc3RyaW5nLXBhZC1zdGFydC1lbmRcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIHJlcGVhdCA9IHJlcXVpcmUoJy4vX3N0cmluZy1yZXBlYXQnKTtcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh0aGF0LCBtYXhMZW5ndGgsIGZpbGxTdHJpbmcsIGxlZnQpIHtcbiAgdmFyIFMgPSBTdHJpbmcoZGVmaW5lZCh0aGF0KSk7XG4gIHZhciBzdHJpbmdMZW5ndGggPSBTLmxlbmd0aDtcbiAgdmFyIGZpbGxTdHIgPSBmaWxsU3RyaW5nID09PSB1bmRlZmluZWQgPyAnICcgOiBTdHJpbmcoZmlsbFN0cmluZyk7XG4gIHZhciBpbnRNYXhMZW5ndGggPSB0b0xlbmd0aChtYXhMZW5ndGgpO1xuICBpZiAoaW50TWF4TGVuZ3RoIDw9IHN0cmluZ0xlbmd0aCB8fCBmaWxsU3RyID09ICcnKSByZXR1cm4gUztcbiAgdmFyIGZpbGxMZW4gPSBpbnRNYXhMZW5ndGggLSBzdHJpbmdMZW5ndGg7XG4gIHZhciBzdHJpbmdGaWxsZXIgPSByZXBlYXQuY2FsbChmaWxsU3RyLCBNYXRoLmNlaWwoZmlsbExlbiAvIGZpbGxTdHIubGVuZ3RoKSk7XG4gIGlmIChzdHJpbmdGaWxsZXIubGVuZ3RoID4gZmlsbExlbikgc3RyaW5nRmlsbGVyID0gc3RyaW5nRmlsbGVyLnNsaWNlKDAsIGZpbGxMZW4pO1xuICByZXR1cm4gbGVmdCA/IHN0cmluZ0ZpbGxlciArIFMgOiBTICsgc3RyaW5nRmlsbGVyO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiByZXBlYXQoY291bnQpIHtcbiAgdmFyIHN0ciA9IFN0cmluZyhkZWZpbmVkKHRoaXMpKTtcbiAgdmFyIHJlcyA9ICcnO1xuICB2YXIgbiA9IHRvSW50ZWdlcihjb3VudCk7XG4gIGlmIChuIDwgMCB8fCBuID09IEluZmluaXR5KSB0aHJvdyBSYW5nZUVycm9yKFwiQ291bnQgY2FuJ3QgYmUgbmVnYXRpdmVcIik7XG4gIGZvciAoO24gPiAwOyAobiA+Pj49IDEpICYmIChzdHIgKz0gc3RyKSkgaWYgKG4gJiAxKSByZXMgKz0gc3RyO1xuICByZXR1cm4gcmVzO1xufTtcbiIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG52YXIgc3BhY2VzID0gcmVxdWlyZSgnLi9fc3RyaW5nLXdzJyk7XG52YXIgc3BhY2UgPSAnWycgKyBzcGFjZXMgKyAnXSc7XG52YXIgbm9uID0gJ1xcdTIwMGJcXHUwMDg1JztcbnZhciBsdHJpbSA9IFJlZ0V4cCgnXicgKyBzcGFjZSArIHNwYWNlICsgJyonKTtcbnZhciBydHJpbSA9IFJlZ0V4cChzcGFjZSArIHNwYWNlICsgJyokJyk7XG5cbnZhciBleHBvcnRlciA9IGZ1bmN0aW9uIChLRVksIGV4ZWMsIEFMSUFTKSB7XG4gIHZhciBleHAgPSB7fTtcbiAgdmFyIEZPUkNFID0gZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAhIXNwYWNlc1tLRVldKCkgfHwgbm9uW0tFWV0oKSAhPSBub247XG4gIH0pO1xuICB2YXIgZm4gPSBleHBbS0VZXSA9IEZPUkNFID8gZXhlYyh0cmltKSA6IHNwYWNlc1tLRVldO1xuICBpZiAoQUxJQVMpIGV4cFtBTElBU10gPSBmbjtcbiAgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiBGT1JDRSwgJ1N0cmluZycsIGV4cCk7XG59O1xuXG4vLyAxIC0+IFN0cmluZyN0cmltTGVmdFxuLy8gMiAtPiBTdHJpbmcjdHJpbVJpZ2h0XG4vLyAzIC0+IFN0cmluZyN0cmltXG52YXIgdHJpbSA9IGV4cG9ydGVyLnRyaW0gPSBmdW5jdGlvbiAoc3RyaW5nLCBUWVBFKSB7XG4gIHN0cmluZyA9IFN0cmluZyhkZWZpbmVkKHN0cmluZykpO1xuICBpZiAoVFlQRSAmIDEpIHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKGx0cmltLCAnJyk7XG4gIGlmIChUWVBFICYgMikgc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UocnRyaW0sICcnKTtcbiAgcmV0dXJuIHN0cmluZztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0ZXI7XG4iLCJtb2R1bGUuZXhwb3J0cyA9ICdcXHgwOVxceDBBXFx4MEJcXHgwQ1xceDBEXFx4MjBcXHhBMFxcdTE2ODBcXHUxODBFXFx1MjAwMFxcdTIwMDFcXHUyMDAyXFx1MjAwMycgK1xuICAnXFx1MjAwNFxcdTIwMDVcXHUyMDA2XFx1MjAwN1xcdTIwMDhcXHUyMDA5XFx1MjAwQVxcdTIwMkZcXHUyMDVGXFx1MzAwMFxcdTIwMjhcXHUyMDI5XFx1RkVGRic7XG4iLCJ2YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG52YXIgaW52b2tlID0gcmVxdWlyZSgnLi9faW52b2tlJyk7XG52YXIgaHRtbCA9IHJlcXVpcmUoJy4vX2h0bWwnKTtcbnZhciBjZWwgPSByZXF1aXJlKCcuL19kb20tY3JlYXRlJyk7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgcHJvY2VzcyA9IGdsb2JhbC5wcm9jZXNzO1xudmFyIHNldFRhc2sgPSBnbG9iYWwuc2V0SW1tZWRpYXRlO1xudmFyIGNsZWFyVGFzayA9IGdsb2JhbC5jbGVhckltbWVkaWF0ZTtcbnZhciBNZXNzYWdlQ2hhbm5lbCA9IGdsb2JhbC5NZXNzYWdlQ2hhbm5lbDtcbnZhciBEaXNwYXRjaCA9IGdsb2JhbC5EaXNwYXRjaDtcbnZhciBjb3VudGVyID0gMDtcbnZhciBxdWV1ZSA9IHt9O1xudmFyIE9OUkVBRFlTVEFURUNIQU5HRSA9ICdvbnJlYWR5c3RhdGVjaGFuZ2UnO1xudmFyIGRlZmVyLCBjaGFubmVsLCBwb3J0O1xudmFyIHJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGlkID0gK3RoaXM7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcbiAgaWYgKHF1ZXVlLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgIHZhciBmbiA9IHF1ZXVlW2lkXTtcbiAgICBkZWxldGUgcXVldWVbaWRdO1xuICAgIGZuKCk7XG4gIH1cbn07XG52YXIgbGlzdGVuZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgcnVuLmNhbGwoZXZlbnQuZGF0YSk7XG59O1xuLy8gTm9kZS5qcyAwLjkrICYgSUUxMCsgaGFzIHNldEltbWVkaWF0ZSwgb3RoZXJ3aXNlOlxuaWYgKCFzZXRUYXNrIHx8ICFjbGVhclRhc2spIHtcbiAgc2V0VGFzayA9IGZ1bmN0aW9uIHNldEltbWVkaWF0ZShmbikge1xuICAgIHZhciBhcmdzID0gW107XG4gICAgdmFyIGkgPSAxO1xuICAgIHdoaWxlIChhcmd1bWVudHMubGVuZ3RoID4gaSkgYXJncy5wdXNoKGFyZ3VtZW50c1tpKytdKTtcbiAgICBxdWV1ZVsrK2NvdW50ZXJdID0gZnVuY3Rpb24gKCkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jXG4gICAgICBpbnZva2UodHlwZW9mIGZuID09ICdmdW5jdGlvbicgPyBmbiA6IEZ1bmN0aW9uKGZuKSwgYXJncyk7XG4gICAgfTtcbiAgICBkZWZlcihjb3VudGVyKTtcbiAgICByZXR1cm4gY291bnRlcjtcbiAgfTtcbiAgY2xlYXJUYXNrID0gZnVuY3Rpb24gY2xlYXJJbW1lZGlhdGUoaWQpIHtcbiAgICBkZWxldGUgcXVldWVbaWRdO1xuICB9O1xuICAvLyBOb2RlLmpzIDAuOC1cbiAgaWYgKHJlcXVpcmUoJy4vX2NvZicpKHByb2Nlc3MpID09ICdwcm9jZXNzJykge1xuICAgIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGN0eChydW4sIGlkLCAxKSk7XG4gICAgfTtcbiAgLy8gU3BoZXJlIChKUyBnYW1lIGVuZ2luZSkgRGlzcGF0Y2ggQVBJXG4gIH0gZWxzZSBpZiAoRGlzcGF0Y2ggJiYgRGlzcGF0Y2gubm93KSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIERpc3BhdGNoLm5vdyhjdHgocnVuLCBpZCwgMSkpO1xuICAgIH07XG4gIC8vIEJyb3dzZXJzIHdpdGggTWVzc2FnZUNoYW5uZWwsIGluY2x1ZGVzIFdlYldvcmtlcnNcbiAgfSBlbHNlIGlmIChNZXNzYWdlQ2hhbm5lbCkge1xuICAgIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICBwb3J0ID0gY2hhbm5lbC5wb3J0MjtcbiAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGxpc3RlbmVyO1xuICAgIGRlZmVyID0gY3R4KHBvcnQucG9zdE1lc3NhZ2UsIHBvcnQsIDEpO1xuICAvLyBCcm93c2VycyB3aXRoIHBvc3RNZXNzYWdlLCBza2lwIFdlYldvcmtlcnNcbiAgLy8gSUU4IGhhcyBwb3N0TWVzc2FnZSwgYnV0IGl0J3Mgc3luYyAmIHR5cGVvZiBpdHMgcG9zdE1lc3NhZ2UgaXMgJ29iamVjdCdcbiAgfSBlbHNlIGlmIChnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lciAmJiB0eXBlb2YgcG9zdE1lc3NhZ2UgPT0gJ2Z1bmN0aW9uJyAmJiAhZ2xvYmFsLmltcG9ydFNjcmlwdHMpIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKGlkICsgJycsICcqJyk7XG4gICAgfTtcbiAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGxpc3RlbmVyLCBmYWxzZSk7XG4gIC8vIElFOC1cbiAgfSBlbHNlIGlmIChPTlJFQURZU1RBVEVDSEFOR0UgaW4gY2VsKCdzY3JpcHQnKSkge1xuICAgIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICBodG1sLmFwcGVuZENoaWxkKGNlbCgnc2NyaXB0JykpW09OUkVBRFlTVEFURUNIQU5HRV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGh0bWwucmVtb3ZlQ2hpbGQodGhpcyk7XG4gICAgICAgIHJ1bi5jYWxsKGlkKTtcbiAgICAgIH07XG4gICAgfTtcbiAgLy8gUmVzdCBvbGQgYnJvd3NlcnNcbiAgfSBlbHNlIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgc2V0VGltZW91dChjdHgocnVuLCBpZCwgMSksIDApO1xuICAgIH07XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzZXQ6IHNldFRhc2ssXG4gIGNsZWFyOiBjbGVhclRhc2tcbn07XG4iLCJ2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xudmFyIG1heCA9IE1hdGgubWF4O1xudmFyIG1pbiA9IE1hdGgubWluO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaW5kZXgsIGxlbmd0aCkge1xuICBpbmRleCA9IHRvSW50ZWdlcihpbmRleCk7XG4gIHJldHVybiBpbmRleCA8IDAgPyBtYXgoaW5kZXggKyBsZW5ndGgsIDApIDogbWluKGluZGV4LCBsZW5ndGgpO1xufTtcbiIsIi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXRvaW5kZXhcbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpdCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gMDtcbiAgdmFyIG51bWJlciA9IHRvSW50ZWdlcihpdCk7XG4gIHZhciBsZW5ndGggPSB0b0xlbmd0aChudW1iZXIpO1xuICBpZiAobnVtYmVyICE9PSBsZW5ndGgpIHRocm93IFJhbmdlRXJyb3IoJ1dyb25nIGxlbmd0aCEnKTtcbiAgcmV0dXJuIGxlbmd0aDtcbn07XG4iLCIvLyA3LjEuNCBUb0ludGVnZXJcbnZhciBjZWlsID0gTWF0aC5jZWlsO1xudmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpc05hTihpdCA9ICtpdCkgPyAwIDogKGl0ID4gMCA/IGZsb29yIDogY2VpbCkoaXQpO1xufTtcbiIsIi8vIHRvIGluZGV4ZWQgb2JqZWN0LCB0b09iamVjdCB3aXRoIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgc3RyaW5nc1xudmFyIElPYmplY3QgPSByZXF1aXJlKCcuL19pb2JqZWN0Jyk7XG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBJT2JqZWN0KGRlZmluZWQoaXQpKTtcbn07XG4iLCIvLyA3LjEuMTUgVG9MZW5ndGhcbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG52YXIgbWluID0gTWF0aC5taW47XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgPiAwID8gbWluKHRvSW50ZWdlcihpdCksIDB4MWZmZmZmZmZmZmZmZmYpIDogMDsgLy8gcG93KDIsIDUzKSAtIDEgPT0gOTAwNzE5OTI1NDc0MDk5MVxufTtcbiIsIi8vIDcuMS4xMyBUb09iamVjdChhcmd1bWVudClcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIE9iamVjdChkZWZpbmVkKGl0KSk7XG59O1xuIiwiLy8gNy4xLjEgVG9QcmltaXRpdmUoaW5wdXQgWywgUHJlZmVycmVkVHlwZV0pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbi8vIGluc3RlYWQgb2YgdGhlIEVTNiBzcGVjIHZlcnNpb24sIHdlIGRpZG4ndCBpbXBsZW1lbnQgQEB0b1ByaW1pdGl2ZSBjYXNlXG4vLyBhbmQgdGhlIHNlY29uZCBhcmd1bWVudCAtIGZsYWcgLSBwcmVmZXJyZWQgdHlwZSBpcyBhIHN0cmluZ1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIFMpIHtcbiAgaWYgKCFpc09iamVjdChpdCkpIHJldHVybiBpdDtcbiAgdmFyIGZuLCB2YWw7XG4gIGlmIChTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKSByZXR1cm4gdmFsO1xuICBpZiAodHlwZW9mIChmbiA9IGl0LnZhbHVlT2YpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSkgcmV0dXJuIHZhbDtcbiAgaWYgKCFTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKSByZXR1cm4gdmFsO1xuICB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIik7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuaWYgKHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykpIHtcbiAgdmFyIExJQlJBUlkgPSByZXF1aXJlKCcuL19saWJyYXJ5Jyk7XG4gIHZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbiAgdmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbiAgdmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbiAgdmFyICR0eXBlZCA9IHJlcXVpcmUoJy4vX3R5cGVkJyk7XG4gIHZhciAkYnVmZmVyID0gcmVxdWlyZSgnLi9fdHlwZWQtYnVmZmVyJyk7XG4gIHZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbiAgdmFyIGFuSW5zdGFuY2UgPSByZXF1aXJlKCcuL19hbi1pbnN0YW5jZScpO1xuICB2YXIgcHJvcGVydHlEZXNjID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xuICB2YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbiAgdmFyIHJlZGVmaW5lQWxsID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUtYWxsJyk7XG4gIHZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG4gIHZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xuICB2YXIgdG9JbmRleCA9IHJlcXVpcmUoJy4vX3RvLWluZGV4Jyk7XG4gIHZhciB0b0Fic29sdXRlSW5kZXggPSByZXF1aXJlKCcuL190by1hYnNvbHV0ZS1pbmRleCcpO1xuICB2YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcbiAgdmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xuICB2YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4vX2NsYXNzb2YnKTtcbiAgdmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG4gIHZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xuICB2YXIgaXNBcnJheUl0ZXIgPSByZXF1aXJlKCcuL19pcy1hcnJheS1pdGVyJyk7XG4gIHZhciBjcmVhdGUgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJyk7XG4gIHZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKTtcbiAgdmFyIGdPUE4gPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbicpLmY7XG4gIHZhciBnZXRJdGVyRm4gPSByZXF1aXJlKCcuL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZCcpO1xuICB2YXIgdWlkID0gcmVxdWlyZSgnLi9fdWlkJyk7XG4gIHZhciB3a3MgPSByZXF1aXJlKCcuL193a3MnKTtcbiAgdmFyIGNyZWF0ZUFycmF5TWV0aG9kID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpO1xuICB2YXIgY3JlYXRlQXJyYXlJbmNsdWRlcyA9IHJlcXVpcmUoJy4vX2FycmF5LWluY2x1ZGVzJyk7XG4gIHZhciBzcGVjaWVzQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuL19zcGVjaWVzLWNvbnN0cnVjdG9yJyk7XG4gIHZhciBBcnJheUl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vZXM2LmFycmF5Lml0ZXJhdG9yJyk7XG4gIHZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbiAgdmFyICRpdGVyRGV0ZWN0ID0gcmVxdWlyZSgnLi9faXRlci1kZXRlY3QnKTtcbiAgdmFyIHNldFNwZWNpZXMgPSByZXF1aXJlKCcuL19zZXQtc3BlY2llcycpO1xuICB2YXIgYXJyYXlGaWxsID0gcmVxdWlyZSgnLi9fYXJyYXktZmlsbCcpO1xuICB2YXIgYXJyYXlDb3B5V2l0aGluID0gcmVxdWlyZSgnLi9fYXJyYXktY29weS13aXRoaW4nKTtcbiAgdmFyICREUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xuICB2YXIgJEdPUEQgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpO1xuICB2YXIgZFAgPSAkRFAuZjtcbiAgdmFyIGdPUEQgPSAkR09QRC5mO1xuICB2YXIgUmFuZ2VFcnJvciA9IGdsb2JhbC5SYW5nZUVycm9yO1xuICB2YXIgVHlwZUVycm9yID0gZ2xvYmFsLlR5cGVFcnJvcjtcbiAgdmFyIFVpbnQ4QXJyYXkgPSBnbG9iYWwuVWludDhBcnJheTtcbiAgdmFyIEFSUkFZX0JVRkZFUiA9ICdBcnJheUJ1ZmZlcic7XG4gIHZhciBTSEFSRURfQlVGRkVSID0gJ1NoYXJlZCcgKyBBUlJBWV9CVUZGRVI7XG4gIHZhciBCWVRFU19QRVJfRUxFTUVOVCA9ICdCWVRFU19QRVJfRUxFTUVOVCc7XG4gIHZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcbiAgdmFyIEFycmF5UHJvdG8gPSBBcnJheVtQUk9UT1RZUEVdO1xuICB2YXIgJEFycmF5QnVmZmVyID0gJGJ1ZmZlci5BcnJheUJ1ZmZlcjtcbiAgdmFyICREYXRhVmlldyA9ICRidWZmZXIuRGF0YVZpZXc7XG4gIHZhciBhcnJheUZvckVhY2ggPSBjcmVhdGVBcnJheU1ldGhvZCgwKTtcbiAgdmFyIGFycmF5RmlsdGVyID0gY3JlYXRlQXJyYXlNZXRob2QoMik7XG4gIHZhciBhcnJheVNvbWUgPSBjcmVhdGVBcnJheU1ldGhvZCgzKTtcbiAgdmFyIGFycmF5RXZlcnkgPSBjcmVhdGVBcnJheU1ldGhvZCg0KTtcbiAgdmFyIGFycmF5RmluZCA9IGNyZWF0ZUFycmF5TWV0aG9kKDUpO1xuICB2YXIgYXJyYXlGaW5kSW5kZXggPSBjcmVhdGVBcnJheU1ldGhvZCg2KTtcbiAgdmFyIGFycmF5SW5jbHVkZXMgPSBjcmVhdGVBcnJheUluY2x1ZGVzKHRydWUpO1xuICB2YXIgYXJyYXlJbmRleE9mID0gY3JlYXRlQXJyYXlJbmNsdWRlcyhmYWxzZSk7XG4gIHZhciBhcnJheVZhbHVlcyA9IEFycmF5SXRlcmF0b3JzLnZhbHVlcztcbiAgdmFyIGFycmF5S2V5cyA9IEFycmF5SXRlcmF0b3JzLmtleXM7XG4gIHZhciBhcnJheUVudHJpZXMgPSBBcnJheUl0ZXJhdG9ycy5lbnRyaWVzO1xuICB2YXIgYXJyYXlMYXN0SW5kZXhPZiA9IEFycmF5UHJvdG8ubGFzdEluZGV4T2Y7XG4gIHZhciBhcnJheVJlZHVjZSA9IEFycmF5UHJvdG8ucmVkdWNlO1xuICB2YXIgYXJyYXlSZWR1Y2VSaWdodCA9IEFycmF5UHJvdG8ucmVkdWNlUmlnaHQ7XG4gIHZhciBhcnJheUpvaW4gPSBBcnJheVByb3RvLmpvaW47XG4gIHZhciBhcnJheVNvcnQgPSBBcnJheVByb3RvLnNvcnQ7XG4gIHZhciBhcnJheVNsaWNlID0gQXJyYXlQcm90by5zbGljZTtcbiAgdmFyIGFycmF5VG9TdHJpbmcgPSBBcnJheVByb3RvLnRvU3RyaW5nO1xuICB2YXIgYXJyYXlUb0xvY2FsZVN0cmluZyA9IEFycmF5UHJvdG8udG9Mb2NhbGVTdHJpbmc7XG4gIHZhciBJVEVSQVRPUiA9IHdrcygnaXRlcmF0b3InKTtcbiAgdmFyIFRBRyA9IHdrcygndG9TdHJpbmdUYWcnKTtcbiAgdmFyIFRZUEVEX0NPTlNUUlVDVE9SID0gdWlkKCd0eXBlZF9jb25zdHJ1Y3RvcicpO1xuICB2YXIgREVGX0NPTlNUUlVDVE9SID0gdWlkKCdkZWZfY29uc3RydWN0b3InKTtcbiAgdmFyIEFMTF9DT05TVFJVQ1RPUlMgPSAkdHlwZWQuQ09OU1RSO1xuICB2YXIgVFlQRURfQVJSQVkgPSAkdHlwZWQuVFlQRUQ7XG4gIHZhciBWSUVXID0gJHR5cGVkLlZJRVc7XG4gIHZhciBXUk9OR19MRU5HVEggPSAnV3JvbmcgbGVuZ3RoISc7XG5cbiAgdmFyICRtYXAgPSBjcmVhdGVBcnJheU1ldGhvZCgxLCBmdW5jdGlvbiAoTywgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGFsbG9jYXRlKHNwZWNpZXNDb25zdHJ1Y3RvcihPLCBPW0RFRl9DT05TVFJVQ1RPUl0pLCBsZW5ndGgpO1xuICB9KTtcblxuICB2YXIgTElUVExFX0VORElBTiA9IGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobmV3IFVpbnQxNkFycmF5KFsxXSkuYnVmZmVyKVswXSA9PT0gMTtcbiAgfSk7XG5cbiAgdmFyIEZPUkNFRF9TRVQgPSAhIVVpbnQ4QXJyYXkgJiYgISFVaW50OEFycmF5W1BST1RPVFlQRV0uc2V0ICYmIGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICBuZXcgVWludDhBcnJheSgxKS5zZXQoe30pO1xuICB9KTtcblxuICB2YXIgdG9PZmZzZXQgPSBmdW5jdGlvbiAoaXQsIEJZVEVTKSB7XG4gICAgdmFyIG9mZnNldCA9IHRvSW50ZWdlcihpdCk7XG4gICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ICUgQllURVMpIHRocm93IFJhbmdlRXJyb3IoJ1dyb25nIG9mZnNldCEnKTtcbiAgICByZXR1cm4gb2Zmc2V0O1xuICB9O1xuXG4gIHZhciB2YWxpZGF0ZSA9IGZ1bmN0aW9uIChpdCkge1xuICAgIGlmIChpc09iamVjdChpdCkgJiYgVFlQRURfQVJSQVkgaW4gaXQpIHJldHVybiBpdDtcbiAgICB0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhIHR5cGVkIGFycmF5IScpO1xuICB9O1xuXG4gIHZhciBhbGxvY2F0ZSA9IGZ1bmN0aW9uIChDLCBsZW5ndGgpIHtcbiAgICBpZiAoIShpc09iamVjdChDKSAmJiBUWVBFRF9DT05TVFJVQ1RPUiBpbiBDKSkge1xuICAgICAgdGhyb3cgVHlwZUVycm9yKCdJdCBpcyBub3QgYSB0eXBlZCBhcnJheSBjb25zdHJ1Y3RvciEnKTtcbiAgICB9IHJldHVybiBuZXcgQyhsZW5ndGgpO1xuICB9O1xuXG4gIHZhciBzcGVjaWVzRnJvbUxpc3QgPSBmdW5jdGlvbiAoTywgbGlzdCkge1xuICAgIHJldHVybiBmcm9tTGlzdChzcGVjaWVzQ29uc3RydWN0b3IoTywgT1tERUZfQ09OU1RSVUNUT1JdKSwgbGlzdCk7XG4gIH07XG5cbiAgdmFyIGZyb21MaXN0ID0gZnVuY3Rpb24gKEMsIGxpc3QpIHtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBsZW5ndGggPSBsaXN0Lmxlbmd0aDtcbiAgICB2YXIgcmVzdWx0ID0gYWxsb2NhdGUoQywgbGVuZ3RoKTtcbiAgICB3aGlsZSAobGVuZ3RoID4gaW5kZXgpIHJlc3VsdFtpbmRleF0gPSBsaXN0W2luZGV4KytdO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgdmFyIGFkZEdldHRlciA9IGZ1bmN0aW9uIChpdCwga2V5LCBpbnRlcm5hbCkge1xuICAgIGRQKGl0LCBrZXksIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kW2ludGVybmFsXTsgfSB9KTtcbiAgfTtcblxuICB2YXIgJGZyb20gPSBmdW5jdGlvbiBmcm9tKHNvdXJjZSAvKiAsIG1hcGZuLCB0aGlzQXJnICovKSB7XG4gICAgdmFyIE8gPSB0b09iamVjdChzb3VyY2UpO1xuICAgIHZhciBhTGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgbWFwZm4gPSBhTGVuID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgbWFwcGluZyA9IG1hcGZuICE9PSB1bmRlZmluZWQ7XG4gICAgdmFyIGl0ZXJGbiA9IGdldEl0ZXJGbihPKTtcbiAgICB2YXIgaSwgbGVuZ3RoLCB2YWx1ZXMsIHJlc3VsdCwgc3RlcCwgaXRlcmF0b3I7XG4gICAgaWYgKGl0ZXJGbiAhPSB1bmRlZmluZWQgJiYgIWlzQXJyYXlJdGVyKGl0ZXJGbikpIHtcbiAgICAgIGZvciAoaXRlcmF0b3IgPSBpdGVyRm4uY2FsbChPKSwgdmFsdWVzID0gW10sIGkgPSAwOyAhKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmU7IGkrKykge1xuICAgICAgICB2YWx1ZXMucHVzaChzdGVwLnZhbHVlKTtcbiAgICAgIH0gTyA9IHZhbHVlcztcbiAgICB9XG4gICAgaWYgKG1hcHBpbmcgJiYgYUxlbiA+IDIpIG1hcGZuID0gY3R4KG1hcGZuLCBhcmd1bWVudHNbMl0sIDIpO1xuICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKSwgcmVzdWx0ID0gYWxsb2NhdGUodGhpcywgbGVuZ3RoKTsgbGVuZ3RoID4gaTsgaSsrKSB7XG4gICAgICByZXN1bHRbaV0gPSBtYXBwaW5nID8gbWFwZm4oT1tpXSwgaSkgOiBPW2ldO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIHZhciAkb2YgPSBmdW5jdGlvbiBvZigvKiAuLi5pdGVtcyAqLykge1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIHJlc3VsdCA9IGFsbG9jYXRlKHRoaXMsIGxlbmd0aCk7XG4gICAgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSByZXN1bHRbaW5kZXhdID0gYXJndW1lbnRzW2luZGV4KytdO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gaU9TIFNhZmFyaSA2LnggZmFpbHMgaGVyZVxuICB2YXIgVE9fTE9DQUxFX0JVRyA9ICEhVWludDhBcnJheSAmJiBmYWlscyhmdW5jdGlvbiAoKSB7IGFycmF5VG9Mb2NhbGVTdHJpbmcuY2FsbChuZXcgVWludDhBcnJheSgxKSk7IH0pO1xuXG4gIHZhciAkdG9Mb2NhbGVTdHJpbmcgPSBmdW5jdGlvbiB0b0xvY2FsZVN0cmluZygpIHtcbiAgICByZXR1cm4gYXJyYXlUb0xvY2FsZVN0cmluZy5hcHBseShUT19MT0NBTEVfQlVHID8gYXJyYXlTbGljZS5jYWxsKHZhbGlkYXRlKHRoaXMpKSA6IHZhbGlkYXRlKHRoaXMpLCBhcmd1bWVudHMpO1xuICB9O1xuXG4gIHZhciBwcm90byA9IHtcbiAgICBjb3B5V2l0aGluOiBmdW5jdGlvbiBjb3B5V2l0aGluKHRhcmdldCwgc3RhcnQgLyogLCBlbmQgKi8pIHtcbiAgICAgIHJldHVybiBhcnJheUNvcHlXaXRoaW4uY2FsbCh2YWxpZGF0ZSh0aGlzKSwgdGFyZ2V0LCBzdGFydCwgYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgZXZlcnk6IGZ1bmN0aW9uIGV2ZXJ5KGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKSB7XG4gICAgICByZXR1cm4gYXJyYXlFdmVyeSh2YWxpZGF0ZSh0aGlzKSwgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgZmlsbDogZnVuY3Rpb24gZmlsbCh2YWx1ZSAvKiAsIHN0YXJ0LCBlbmQgKi8pIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgcmV0dXJuIGFycmF5RmlsbC5hcHBseSh2YWxpZGF0ZSh0aGlzKSwgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIGZpbHRlcjogZnVuY3Rpb24gZmlsdGVyKGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKSB7XG4gICAgICByZXR1cm4gc3BlY2llc0Zyb21MaXN0KHRoaXMsIGFycmF5RmlsdGVyKHZhbGlkYXRlKHRoaXMpLCBjYWxsYmFja2ZuLFxuICAgICAgICBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCkpO1xuICAgIH0sXG4gICAgZmluZDogZnVuY3Rpb24gZmluZChwcmVkaWNhdGUgLyogLCB0aGlzQXJnICovKSB7XG4gICAgICByZXR1cm4gYXJyYXlGaW5kKHZhbGlkYXRlKHRoaXMpLCBwcmVkaWNhdGUsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIGZpbmRJbmRleDogZnVuY3Rpb24gZmluZEluZGV4KHByZWRpY2F0ZSAvKiAsIHRoaXNBcmcgKi8pIHtcbiAgICAgIHJldHVybiBhcnJheUZpbmRJbmRleCh2YWxpZGF0ZSh0aGlzKSwgcHJlZGljYXRlLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBmb3JFYWNoOiBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKSB7XG4gICAgICBhcnJheUZvckVhY2godmFsaWRhdGUodGhpcyksIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIGluZGV4T2Y6IGZ1bmN0aW9uIGluZGV4T2Yoc2VhcmNoRWxlbWVudCAvKiAsIGZyb21JbmRleCAqLykge1xuICAgICAgcmV0dXJuIGFycmF5SW5kZXhPZih2YWxpZGF0ZSh0aGlzKSwgc2VhcmNoRWxlbWVudCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgaW5jbHVkZXM6IGZ1bmN0aW9uIGluY2x1ZGVzKHNlYXJjaEVsZW1lbnQgLyogLCBmcm9tSW5kZXggKi8pIHtcbiAgICAgIHJldHVybiBhcnJheUluY2x1ZGVzKHZhbGlkYXRlKHRoaXMpLCBzZWFyY2hFbGVtZW50LCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBqb2luOiBmdW5jdGlvbiBqb2luKHNlcGFyYXRvcikgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICByZXR1cm4gYXJyYXlKb2luLmFwcGx5KHZhbGlkYXRlKHRoaXMpLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgbGFzdEluZGV4T2Y6IGZ1bmN0aW9uIGxhc3RJbmRleE9mKHNlYXJjaEVsZW1lbnQgLyogLCBmcm9tSW5kZXggKi8pIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgcmV0dXJuIGFycmF5TGFzdEluZGV4T2YuYXBwbHkodmFsaWRhdGUodGhpcyksIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICBtYXA6IGZ1bmN0aW9uIG1hcChtYXBmbiAvKiAsIHRoaXNBcmcgKi8pIHtcbiAgICAgIHJldHVybiAkbWFwKHZhbGlkYXRlKHRoaXMpLCBtYXBmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgcmVkdWNlOiBmdW5jdGlvbiByZWR1Y2UoY2FsbGJhY2tmbiAvKiAsIGluaXRpYWxWYWx1ZSAqLykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICByZXR1cm4gYXJyYXlSZWR1Y2UuYXBwbHkodmFsaWRhdGUodGhpcyksIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICByZWR1Y2VSaWdodDogZnVuY3Rpb24gcmVkdWNlUmlnaHQoY2FsbGJhY2tmbiAvKiAsIGluaXRpYWxWYWx1ZSAqLykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICByZXR1cm4gYXJyYXlSZWR1Y2VSaWdodC5hcHBseSh2YWxpZGF0ZSh0aGlzKSwgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIHJldmVyc2U6IGZ1bmN0aW9uIHJldmVyc2UoKSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICB2YXIgbGVuZ3RoID0gdmFsaWRhdGUodGhhdCkubGVuZ3RoO1xuICAgICAgdmFyIG1pZGRsZSA9IE1hdGguZmxvb3IobGVuZ3RoIC8gMik7XG4gICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgdmFyIHZhbHVlO1xuICAgICAgd2hpbGUgKGluZGV4IDwgbWlkZGxlKSB7XG4gICAgICAgIHZhbHVlID0gdGhhdFtpbmRleF07XG4gICAgICAgIHRoYXRbaW5kZXgrK10gPSB0aGF0Wy0tbGVuZ3RoXTtcbiAgICAgICAgdGhhdFtsZW5ndGhdID0gdmFsdWU7XG4gICAgICB9IHJldHVybiB0aGF0O1xuICAgIH0sXG4gICAgc29tZTogZnVuY3Rpb24gc29tZShjYWxsYmFja2ZuIC8qICwgdGhpc0FyZyAqLykge1xuICAgICAgcmV0dXJuIGFycmF5U29tZSh2YWxpZGF0ZSh0aGlzKSwgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgc29ydDogZnVuY3Rpb24gc29ydChjb21wYXJlZm4pIHtcbiAgICAgIHJldHVybiBhcnJheVNvcnQuY2FsbCh2YWxpZGF0ZSh0aGlzKSwgY29tcGFyZWZuKTtcbiAgICB9LFxuICAgIHN1YmFycmF5OiBmdW5jdGlvbiBzdWJhcnJheShiZWdpbiwgZW5kKSB7XG4gICAgICB2YXIgTyA9IHZhbGlkYXRlKHRoaXMpO1xuICAgICAgdmFyIGxlbmd0aCA9IE8ubGVuZ3RoO1xuICAgICAgdmFyICRiZWdpbiA9IHRvQWJzb2x1dGVJbmRleChiZWdpbiwgbGVuZ3RoKTtcbiAgICAgIHJldHVybiBuZXcgKHNwZWNpZXNDb25zdHJ1Y3RvcihPLCBPW0RFRl9DT05TVFJVQ1RPUl0pKShcbiAgICAgICAgTy5idWZmZXIsXG4gICAgICAgIE8uYnl0ZU9mZnNldCArICRiZWdpbiAqIE8uQllURVNfUEVSX0VMRU1FTlQsXG4gICAgICAgIHRvTGVuZ3RoKChlbmQgPT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IHRvQWJzb2x1dGVJbmRleChlbmQsIGxlbmd0aCkpIC0gJGJlZ2luKVxuICAgICAgKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyICRzbGljZSA9IGZ1bmN0aW9uIHNsaWNlKHN0YXJ0LCBlbmQpIHtcbiAgICByZXR1cm4gc3BlY2llc0Zyb21MaXN0KHRoaXMsIGFycmF5U2xpY2UuY2FsbCh2YWxpZGF0ZSh0aGlzKSwgc3RhcnQsIGVuZCkpO1xuICB9O1xuXG4gIHZhciAkc2V0ID0gZnVuY3Rpb24gc2V0KGFycmF5TGlrZSAvKiAsIG9mZnNldCAqLykge1xuICAgIHZhbGlkYXRlKHRoaXMpO1xuICAgIHZhciBvZmZzZXQgPSB0b09mZnNldChhcmd1bWVudHNbMV0sIDEpO1xuICAgIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aDtcbiAgICB2YXIgc3JjID0gdG9PYmplY3QoYXJyYXlMaWtlKTtcbiAgICB2YXIgbGVuID0gdG9MZW5ndGgoc3JjLmxlbmd0aCk7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICBpZiAobGVuICsgb2Zmc2V0ID4gbGVuZ3RoKSB0aHJvdyBSYW5nZUVycm9yKFdST05HX0xFTkdUSCk7XG4gICAgd2hpbGUgKGluZGV4IDwgbGVuKSB0aGlzW29mZnNldCArIGluZGV4XSA9IHNyY1tpbmRleCsrXTtcbiAgfTtcblxuICB2YXIgJGl0ZXJhdG9ycyA9IHtcbiAgICBlbnRyaWVzOiBmdW5jdGlvbiBlbnRyaWVzKCkge1xuICAgICAgcmV0dXJuIGFycmF5RW50cmllcy5jYWxsKHZhbGlkYXRlKHRoaXMpKTtcbiAgICB9LFxuICAgIGtleXM6IGZ1bmN0aW9uIGtleXMoKSB7XG4gICAgICByZXR1cm4gYXJyYXlLZXlzLmNhbGwodmFsaWRhdGUodGhpcykpO1xuICAgIH0sXG4gICAgdmFsdWVzOiBmdW5jdGlvbiB2YWx1ZXMoKSB7XG4gICAgICByZXR1cm4gYXJyYXlWYWx1ZXMuY2FsbCh2YWxpZGF0ZSh0aGlzKSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBpc1RBSW5kZXggPSBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHtcbiAgICByZXR1cm4gaXNPYmplY3QodGFyZ2V0KVxuICAgICAgJiYgdGFyZ2V0W1RZUEVEX0FSUkFZXVxuICAgICAgJiYgdHlwZW9mIGtleSAhPSAnc3ltYm9sJ1xuICAgICAgJiYga2V5IGluIHRhcmdldFxuICAgICAgJiYgU3RyaW5nKCtrZXkpID09IFN0cmluZyhrZXkpO1xuICB9O1xuICB2YXIgJGdldERlc2MgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIHtcbiAgICByZXR1cm4gaXNUQUluZGV4KHRhcmdldCwga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKSlcbiAgICAgID8gcHJvcGVydHlEZXNjKDIsIHRhcmdldFtrZXldKVxuICAgICAgOiBnT1BEKHRhcmdldCwga2V5KTtcbiAgfTtcbiAgdmFyICRzZXREZXNjID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICBpZiAoaXNUQUluZGV4KHRhcmdldCwga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKSlcbiAgICAgICYmIGlzT2JqZWN0KGRlc2MpXG4gICAgICAmJiBoYXMoZGVzYywgJ3ZhbHVlJylcbiAgICAgICYmICFoYXMoZGVzYywgJ2dldCcpXG4gICAgICAmJiAhaGFzKGRlc2MsICdzZXQnKVxuICAgICAgLy8gVE9ETzogYWRkIHZhbGlkYXRpb24gZGVzY3JpcHRvciB3L28gY2FsbGluZyBhY2Nlc3NvcnNcbiAgICAgICYmICFkZXNjLmNvbmZpZ3VyYWJsZVxuICAgICAgJiYgKCFoYXMoZGVzYywgJ3dyaXRhYmxlJykgfHwgZGVzYy53cml0YWJsZSlcbiAgICAgICYmICghaGFzKGRlc2MsICdlbnVtZXJhYmxlJykgfHwgZGVzYy5lbnVtZXJhYmxlKVxuICAgICkge1xuICAgICAgdGFyZ2V0W2tleV0gPSBkZXNjLnZhbHVlO1xuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9IHJldHVybiBkUCh0YXJnZXQsIGtleSwgZGVzYyk7XG4gIH07XG5cbiAgaWYgKCFBTExfQ09OU1RSVUNUT1JTKSB7XG4gICAgJEdPUEQuZiA9ICRnZXREZXNjO1xuICAgICREUC5mID0gJHNldERlc2M7XG4gIH1cblxuICAkZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFBTExfQ09OU1RSVUNUT1JTLCAnT2JqZWN0Jywge1xuICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogJGdldERlc2MsXG4gICAgZGVmaW5lUHJvcGVydHk6ICRzZXREZXNjXG4gIH0pO1xuXG4gIGlmIChmYWlscyhmdW5jdGlvbiAoKSB7IGFycmF5VG9TdHJpbmcuY2FsbCh7fSk7IH0pKSB7XG4gICAgYXJyYXlUb1N0cmluZyA9IGFycmF5VG9Mb2NhbGVTdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiBhcnJheUpvaW4uY2FsbCh0aGlzKTtcbiAgICB9O1xuICB9XG5cbiAgdmFyICRUeXBlZEFycmF5UHJvdG90eXBlJCA9IHJlZGVmaW5lQWxsKHt9LCBwcm90byk7XG4gIHJlZGVmaW5lQWxsKCRUeXBlZEFycmF5UHJvdG90eXBlJCwgJGl0ZXJhdG9ycyk7XG4gIGhpZGUoJFR5cGVkQXJyYXlQcm90b3R5cGUkLCBJVEVSQVRPUiwgJGl0ZXJhdG9ycy52YWx1ZXMpO1xuICByZWRlZmluZUFsbCgkVHlwZWRBcnJheVByb3RvdHlwZSQsIHtcbiAgICBzbGljZTogJHNsaWNlLFxuICAgIHNldDogJHNldCxcbiAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gKCkgeyAvKiBub29wICovIH0sXG4gICAgdG9TdHJpbmc6IGFycmF5VG9TdHJpbmcsXG4gICAgdG9Mb2NhbGVTdHJpbmc6ICR0b0xvY2FsZVN0cmluZ1xuICB9KTtcbiAgYWRkR2V0dGVyKCRUeXBlZEFycmF5UHJvdG90eXBlJCwgJ2J1ZmZlcicsICdiJyk7XG4gIGFkZEdldHRlcigkVHlwZWRBcnJheVByb3RvdHlwZSQsICdieXRlT2Zmc2V0JywgJ28nKTtcbiAgYWRkR2V0dGVyKCRUeXBlZEFycmF5UHJvdG90eXBlJCwgJ2J5dGVMZW5ndGgnLCAnbCcpO1xuICBhZGRHZXR0ZXIoJFR5cGVkQXJyYXlQcm90b3R5cGUkLCAnbGVuZ3RoJywgJ2UnKTtcbiAgZFAoJFR5cGVkQXJyYXlQcm90b3R5cGUkLCBUQUcsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXNbVFlQRURfQVJSQVldOyB9XG4gIH0pO1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtc3RhdGVtZW50c1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChLRVksIEJZVEVTLCB3cmFwcGVyLCBDTEFNUEVEKSB7XG4gICAgQ0xBTVBFRCA9ICEhQ0xBTVBFRDtcbiAgICB2YXIgTkFNRSA9IEtFWSArIChDTEFNUEVEID8gJ0NsYW1wZWQnIDogJycpICsgJ0FycmF5JztcbiAgICB2YXIgR0VUVEVSID0gJ2dldCcgKyBLRVk7XG4gICAgdmFyIFNFVFRFUiA9ICdzZXQnICsgS0VZO1xuICAgIHZhciBUeXBlZEFycmF5ID0gZ2xvYmFsW05BTUVdO1xuICAgIHZhciBCYXNlID0gVHlwZWRBcnJheSB8fCB7fTtcbiAgICB2YXIgVEFDID0gVHlwZWRBcnJheSAmJiBnZXRQcm90b3R5cGVPZihUeXBlZEFycmF5KTtcbiAgICB2YXIgRk9SQ0VEID0gIVR5cGVkQXJyYXkgfHwgISR0eXBlZC5BQlY7XG4gICAgdmFyIE8gPSB7fTtcbiAgICB2YXIgVHlwZWRBcnJheVByb3RvdHlwZSA9IFR5cGVkQXJyYXkgJiYgVHlwZWRBcnJheVtQUk9UT1RZUEVdO1xuICAgIHZhciBnZXR0ZXIgPSBmdW5jdGlvbiAodGhhdCwgaW5kZXgpIHtcbiAgICAgIHZhciBkYXRhID0gdGhhdC5fZDtcbiAgICAgIHJldHVybiBkYXRhLnZbR0VUVEVSXShpbmRleCAqIEJZVEVTICsgZGF0YS5vLCBMSVRUTEVfRU5ESUFOKTtcbiAgICB9O1xuICAgIHZhciBzZXR0ZXIgPSBmdW5jdGlvbiAodGhhdCwgaW5kZXgsIHZhbHVlKSB7XG4gICAgICB2YXIgZGF0YSA9IHRoYXQuX2Q7XG4gICAgICBpZiAoQ0xBTVBFRCkgdmFsdWUgPSAodmFsdWUgPSBNYXRoLnJvdW5kKHZhbHVlKSkgPCAwID8gMCA6IHZhbHVlID4gMHhmZiA/IDB4ZmYgOiB2YWx1ZSAmIDB4ZmY7XG4gICAgICBkYXRhLnZbU0VUVEVSXShpbmRleCAqIEJZVEVTICsgZGF0YS5vLCB2YWx1ZSwgTElUVExFX0VORElBTik7XG4gICAgfTtcbiAgICB2YXIgYWRkRWxlbWVudCA9IGZ1bmN0aW9uICh0aGF0LCBpbmRleCkge1xuICAgICAgZFAodGhhdCwgaW5kZXgsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGdldHRlcih0aGlzLCBpbmRleCk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIHNldHRlcih0aGlzLCBpbmRleCwgdmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9O1xuICAgIGlmIChGT1JDRUQpIHtcbiAgICAgIFR5cGVkQXJyYXkgPSB3cmFwcGVyKGZ1bmN0aW9uICh0aGF0LCBkYXRhLCAkb2Zmc2V0LCAkbGVuZ3RoKSB7XG4gICAgICAgIGFuSW5zdGFuY2UodGhhdCwgVHlwZWRBcnJheSwgTkFNRSwgJ19kJyk7XG4gICAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICAgIHZhciBvZmZzZXQgPSAwO1xuICAgICAgICB2YXIgYnVmZmVyLCBieXRlTGVuZ3RoLCBsZW5ndGgsIGtsYXNzO1xuICAgICAgICBpZiAoIWlzT2JqZWN0KGRhdGEpKSB7XG4gICAgICAgICAgbGVuZ3RoID0gdG9JbmRleChkYXRhKTtcbiAgICAgICAgICBieXRlTGVuZ3RoID0gbGVuZ3RoICogQllURVM7XG4gICAgICAgICAgYnVmZmVyID0gbmV3ICRBcnJheUJ1ZmZlcihieXRlTGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIGlmIChkYXRhIGluc3RhbmNlb2YgJEFycmF5QnVmZmVyIHx8IChrbGFzcyA9IGNsYXNzb2YoZGF0YSkpID09IEFSUkFZX0JVRkZFUiB8fCBrbGFzcyA9PSBTSEFSRURfQlVGRkVSKSB7XG4gICAgICAgICAgYnVmZmVyID0gZGF0YTtcbiAgICAgICAgICBvZmZzZXQgPSB0b09mZnNldCgkb2Zmc2V0LCBCWVRFUyk7XG4gICAgICAgICAgdmFyICRsZW4gPSBkYXRhLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgaWYgKCRsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKCRsZW4gJSBCWVRFUykgdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19MRU5HVEgpO1xuICAgICAgICAgICAgYnl0ZUxlbmd0aCA9ICRsZW4gLSBvZmZzZXQ7XG4gICAgICAgICAgICBpZiAoYnl0ZUxlbmd0aCA8IDApIHRocm93IFJhbmdlRXJyb3IoV1JPTkdfTEVOR1RIKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnl0ZUxlbmd0aCA9IHRvTGVuZ3RoKCRsZW5ndGgpICogQllURVM7XG4gICAgICAgICAgICBpZiAoYnl0ZUxlbmd0aCArIG9mZnNldCA+ICRsZW4pIHRocm93IFJhbmdlRXJyb3IoV1JPTkdfTEVOR1RIKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGVuZ3RoID0gYnl0ZUxlbmd0aCAvIEJZVEVTO1xuICAgICAgICB9IGVsc2UgaWYgKFRZUEVEX0FSUkFZIGluIGRhdGEpIHtcbiAgICAgICAgICByZXR1cm4gZnJvbUxpc3QoVHlwZWRBcnJheSwgZGF0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuICRmcm9tLmNhbGwoVHlwZWRBcnJheSwgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgaGlkZSh0aGF0LCAnX2QnLCB7XG4gICAgICAgICAgYjogYnVmZmVyLFxuICAgICAgICAgIG86IG9mZnNldCxcbiAgICAgICAgICBsOiBieXRlTGVuZ3RoLFxuICAgICAgICAgIGU6IGxlbmd0aCxcbiAgICAgICAgICB2OiBuZXcgJERhdGFWaWV3KGJ1ZmZlcilcbiAgICAgICAgfSk7XG4gICAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkgYWRkRWxlbWVudCh0aGF0LCBpbmRleCsrKTtcbiAgICAgIH0pO1xuICAgICAgVHlwZWRBcnJheVByb3RvdHlwZSA9IFR5cGVkQXJyYXlbUFJPVE9UWVBFXSA9IGNyZWF0ZSgkVHlwZWRBcnJheVByb3RvdHlwZSQpO1xuICAgICAgaGlkZShUeXBlZEFycmF5UHJvdG90eXBlLCAnY29uc3RydWN0b3InLCBUeXBlZEFycmF5KTtcbiAgICB9IGVsc2UgaWYgKCFmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgICBUeXBlZEFycmF5KDEpO1xuICAgIH0pIHx8ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgICBuZXcgVHlwZWRBcnJheSgtMSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgfSkgfHwgISRpdGVyRGV0ZWN0KGZ1bmN0aW9uIChpdGVyKSB7XG4gICAgICBuZXcgVHlwZWRBcnJheSgpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgICAgbmV3IFR5cGVkQXJyYXkobnVsbCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgICBuZXcgVHlwZWRBcnJheSgxLjUpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgICAgbmV3IFR5cGVkQXJyYXkoaXRlcik7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgfSwgdHJ1ZSkpIHtcbiAgICAgIFR5cGVkQXJyYXkgPSB3cmFwcGVyKGZ1bmN0aW9uICh0aGF0LCBkYXRhLCAkb2Zmc2V0LCAkbGVuZ3RoKSB7XG4gICAgICAgIGFuSW5zdGFuY2UodGhhdCwgVHlwZWRBcnJheSwgTkFNRSk7XG4gICAgICAgIHZhciBrbGFzcztcbiAgICAgICAgLy8gYHdzYCBtb2R1bGUgYnVnLCB0ZW1wb3JhcmlseSByZW1vdmUgdmFsaWRhdGlvbiBsZW5ndGggZm9yIFVpbnQ4QXJyYXlcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3dlYnNvY2tldHMvd3MvcHVsbC82NDVcbiAgICAgICAgaWYgKCFpc09iamVjdChkYXRhKSkgcmV0dXJuIG5ldyBCYXNlKHRvSW5kZXgoZGF0YSkpO1xuICAgICAgICBpZiAoZGF0YSBpbnN0YW5jZW9mICRBcnJheUJ1ZmZlciB8fCAoa2xhc3MgPSBjbGFzc29mKGRhdGEpKSA9PSBBUlJBWV9CVUZGRVIgfHwga2xhc3MgPT0gU0hBUkVEX0JVRkZFUikge1xuICAgICAgICAgIHJldHVybiAkbGVuZ3RoICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gbmV3IEJhc2UoZGF0YSwgdG9PZmZzZXQoJG9mZnNldCwgQllURVMpLCAkbGVuZ3RoKVxuICAgICAgICAgICAgOiAkb2Zmc2V0ICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgPyBuZXcgQmFzZShkYXRhLCB0b09mZnNldCgkb2Zmc2V0LCBCWVRFUykpXG4gICAgICAgICAgICAgIDogbmV3IEJhc2UoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFRZUEVEX0FSUkFZIGluIGRhdGEpIHJldHVybiBmcm9tTGlzdChUeXBlZEFycmF5LCBkYXRhKTtcbiAgICAgICAgcmV0dXJuICRmcm9tLmNhbGwoVHlwZWRBcnJheSwgZGF0YSk7XG4gICAgICB9KTtcbiAgICAgIGFycmF5Rm9yRWFjaChUQUMgIT09IEZ1bmN0aW9uLnByb3RvdHlwZSA/IGdPUE4oQmFzZSkuY29uY2F0KGdPUE4oVEFDKSkgOiBnT1BOKEJhc2UpLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmICghKGtleSBpbiBUeXBlZEFycmF5KSkgaGlkZShUeXBlZEFycmF5LCBrZXksIEJhc2Vba2V5XSk7XG4gICAgICB9KTtcbiAgICAgIFR5cGVkQXJyYXlbUFJPVE9UWVBFXSA9IFR5cGVkQXJyYXlQcm90b3R5cGU7XG4gICAgICBpZiAoIUxJQlJBUlkpIFR5cGVkQXJyYXlQcm90b3R5cGUuY29uc3RydWN0b3IgPSBUeXBlZEFycmF5O1xuICAgIH1cbiAgICB2YXIgJG5hdGl2ZUl0ZXJhdG9yID0gVHlwZWRBcnJheVByb3RvdHlwZVtJVEVSQVRPUl07XG4gICAgdmFyIENPUlJFQ1RfSVRFUl9OQU1FID0gISEkbmF0aXZlSXRlcmF0b3JcbiAgICAgICYmICgkbmF0aXZlSXRlcmF0b3IubmFtZSA9PSAndmFsdWVzJyB8fCAkbmF0aXZlSXRlcmF0b3IubmFtZSA9PSB1bmRlZmluZWQpO1xuICAgIHZhciAkaXRlcmF0b3IgPSAkaXRlcmF0b3JzLnZhbHVlcztcbiAgICBoaWRlKFR5cGVkQXJyYXksIFRZUEVEX0NPTlNUUlVDVE9SLCB0cnVlKTtcbiAgICBoaWRlKFR5cGVkQXJyYXlQcm90b3R5cGUsIFRZUEVEX0FSUkFZLCBOQU1FKTtcbiAgICBoaWRlKFR5cGVkQXJyYXlQcm90b3R5cGUsIFZJRVcsIHRydWUpO1xuICAgIGhpZGUoVHlwZWRBcnJheVByb3RvdHlwZSwgREVGX0NPTlNUUlVDVE9SLCBUeXBlZEFycmF5KTtcblxuICAgIGlmIChDTEFNUEVEID8gbmV3IFR5cGVkQXJyYXkoMSlbVEFHXSAhPSBOQU1FIDogIShUQUcgaW4gVHlwZWRBcnJheVByb3RvdHlwZSkpIHtcbiAgICAgIGRQKFR5cGVkQXJyYXlQcm90b3R5cGUsIFRBRywge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE5BTUU7IH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIE9bTkFNRV0gPSBUeXBlZEFycmF5O1xuXG4gICAgJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAoVHlwZWRBcnJheSAhPSBCYXNlKSwgTyk7XG5cbiAgICAkZXhwb3J0KCRleHBvcnQuUywgTkFNRSwge1xuICAgICAgQllURVNfUEVSX0VMRU1FTlQ6IEJZVEVTXG4gICAgfSk7XG5cbiAgICAkZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIGZhaWxzKGZ1bmN0aW9uICgpIHsgQmFzZS5vZi5jYWxsKFR5cGVkQXJyYXksIDEpOyB9KSwgTkFNRSwge1xuICAgICAgZnJvbTogJGZyb20sXG4gICAgICBvZjogJG9mXG4gICAgfSk7XG5cbiAgICBpZiAoIShCWVRFU19QRVJfRUxFTUVOVCBpbiBUeXBlZEFycmF5UHJvdG90eXBlKSkgaGlkZShUeXBlZEFycmF5UHJvdG90eXBlLCBCWVRFU19QRVJfRUxFTUVOVCwgQllURVMpO1xuXG4gICAgJGV4cG9ydCgkZXhwb3J0LlAsIE5BTUUsIHByb3RvKTtcblxuICAgIHNldFNwZWNpZXMoTkFNRSk7XG5cbiAgICAkZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIEZPUkNFRF9TRVQsIE5BTUUsIHsgc2V0OiAkc2V0IH0pO1xuXG4gICAgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAhQ09SUkVDVF9JVEVSX05BTUUsIE5BTUUsICRpdGVyYXRvcnMpO1xuXG4gICAgaWYgKCFMSUJSQVJZICYmIFR5cGVkQXJyYXlQcm90b3R5cGUudG9TdHJpbmcgIT0gYXJyYXlUb1N0cmluZykgVHlwZWRBcnJheVByb3RvdHlwZS50b1N0cmluZyA9IGFycmF5VG9TdHJpbmc7XG5cbiAgICAkZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICAgIG5ldyBUeXBlZEFycmF5KDEpLnNsaWNlKCk7XG4gICAgfSksIE5BTUUsIHsgc2xpY2U6ICRzbGljZSB9KTtcblxuICAgICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBbMSwgMl0udG9Mb2NhbGVTdHJpbmcoKSAhPSBuZXcgVHlwZWRBcnJheShbMSwgMl0pLnRvTG9jYWxlU3RyaW5nKCk7XG4gICAgfSkgfHwgIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICAgIFR5cGVkQXJyYXlQcm90b3R5cGUudG9Mb2NhbGVTdHJpbmcuY2FsbChbMSwgMl0pO1xuICAgIH0pKSwgTkFNRSwgeyB0b0xvY2FsZVN0cmluZzogJHRvTG9jYWxlU3RyaW5nIH0pO1xuXG4gICAgSXRlcmF0b3JzW05BTUVdID0gQ09SUkVDVF9JVEVSX05BTUUgPyAkbmF0aXZlSXRlcmF0b3IgOiAkaXRlcmF0b3I7XG4gICAgaWYgKCFMSUJSQVJZICYmICFDT1JSRUNUX0lURVJfTkFNRSkgaGlkZShUeXBlZEFycmF5UHJvdG90eXBlLCBJVEVSQVRPUiwgJGl0ZXJhdG9yKTtcbiAgfTtcbn0gZWxzZSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJyk7XG52YXIgTElCUkFSWSA9IHJlcXVpcmUoJy4vX2xpYnJhcnknKTtcbnZhciAkdHlwZWQgPSByZXF1aXJlKCcuL190eXBlZCcpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG52YXIgcmVkZWZpbmVBbGwgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG52YXIgYW5JbnN0YW5jZSA9IHJlcXVpcmUoJy4vX2FuLWluc3RhbmNlJyk7XG52YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgdG9JbmRleCA9IHJlcXVpcmUoJy4vX3RvLWluZGV4Jyk7XG52YXIgZ09QTiA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuJykuZjtcbnZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG52YXIgYXJyYXlGaWxsID0gcmVxdWlyZSgnLi9fYXJyYXktZmlsbCcpO1xudmFyIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKTtcbnZhciBBUlJBWV9CVUZGRVIgPSAnQXJyYXlCdWZmZXInO1xudmFyIERBVEFfVklFVyA9ICdEYXRhVmlldyc7XG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG52YXIgV1JPTkdfTEVOR1RIID0gJ1dyb25nIGxlbmd0aCEnO1xudmFyIFdST05HX0lOREVYID0gJ1dyb25nIGluZGV4ISc7XG52YXIgJEFycmF5QnVmZmVyID0gZ2xvYmFsW0FSUkFZX0JVRkZFUl07XG52YXIgJERhdGFWaWV3ID0gZ2xvYmFsW0RBVEFfVklFV107XG52YXIgTWF0aCA9IGdsb2JhbC5NYXRoO1xudmFyIFJhbmdlRXJyb3IgPSBnbG9iYWwuUmFuZ2VFcnJvcjtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zaGFkb3ctcmVzdHJpY3RlZC1uYW1lc1xudmFyIEluZmluaXR5ID0gZ2xvYmFsLkluZmluaXR5O1xudmFyIEJhc2VCdWZmZXIgPSAkQXJyYXlCdWZmZXI7XG52YXIgYWJzID0gTWF0aC5hYnM7XG52YXIgcG93ID0gTWF0aC5wb3c7XG52YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xudmFyIGxvZyA9IE1hdGgubG9nO1xudmFyIExOMiA9IE1hdGguTE4yO1xudmFyIEJVRkZFUiA9ICdidWZmZXInO1xudmFyIEJZVEVfTEVOR1RIID0gJ2J5dGVMZW5ndGgnO1xudmFyIEJZVEVfT0ZGU0VUID0gJ2J5dGVPZmZzZXQnO1xudmFyICRCVUZGRVIgPSBERVNDUklQVE9SUyA/ICdfYicgOiBCVUZGRVI7XG52YXIgJExFTkdUSCA9IERFU0NSSVBUT1JTID8gJ19sJyA6IEJZVEVfTEVOR1RIO1xudmFyICRPRkZTRVQgPSBERVNDUklQVE9SUyA/ICdfbycgOiBCWVRFX09GRlNFVDtcblxuLy8gSUVFRTc1NCBjb252ZXJzaW9ucyBiYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2llZWU3NTRcbmZ1bmN0aW9uIHBhY2tJRUVFNzU0KHZhbHVlLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGJ1ZmZlciA9IEFycmF5KG5CeXRlcyk7XG4gIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxO1xuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMTtcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxO1xuICB2YXIgcnQgPSBtTGVuID09PSAyMyA/IHBvdygyLCAtMjQpIC0gcG93KDIsIC03NykgOiAwO1xuICB2YXIgaSA9IDA7XG4gIHZhciBzID0gdmFsdWUgPCAwIHx8IHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDAgPyAxIDogMDtcbiAgdmFyIGUsIG0sIGM7XG4gIHZhbHVlID0gYWJzKHZhbHVlKTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICBpZiAodmFsdWUgIT0gdmFsdWUgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgIG0gPSB2YWx1ZSAhPSB2YWx1ZSA/IDEgOiAwO1xuICAgIGUgPSBlTWF4O1xuICB9IGVsc2Uge1xuICAgIGUgPSBmbG9vcihsb2codmFsdWUpIC8gTE4yKTtcbiAgICBpZiAodmFsdWUgKiAoYyA9IHBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tO1xuICAgICAgYyAqPSAyO1xuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gYztcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBwb3coMiwgMSAtIGVCaWFzKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKys7XG4gICAgICBjIC89IDI7XG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDA7XG4gICAgICBlID0gZU1heDtcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKHZhbHVlICogYyAtIDEpICogcG93KDIsIG1MZW4pO1xuICAgICAgZSA9IGUgKyBlQmlhcztcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogcG93KDIsIGVCaWFzIC0gMSkgKiBwb3coMiwgbUxlbik7XG4gICAgICBlID0gMDtcbiAgICB9XG4gIH1cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW2krK10gPSBtICYgMjU1LCBtIC89IDI1NiwgbUxlbiAtPSA4KTtcbiAgZSA9IGUgPDwgbUxlbiB8IG07XG4gIGVMZW4gKz0gbUxlbjtcbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbaSsrXSA9IGUgJiAyNTUsIGUgLz0gMjU2LCBlTGVuIC09IDgpO1xuICBidWZmZXJbLS1pXSB8PSBzICogMTI4O1xuICByZXR1cm4gYnVmZmVyO1xufVxuZnVuY3Rpb24gdW5wYWNrSUVFRTc1NChidWZmZXIsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMTtcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDE7XG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMTtcbiAgdmFyIG5CaXRzID0gZUxlbiAtIDc7XG4gIHZhciBpID0gbkJ5dGVzIC0gMTtcbiAgdmFyIHMgPSBidWZmZXJbaS0tXTtcbiAgdmFyIGUgPSBzICYgMTI3O1xuICB2YXIgbTtcbiAgcyA+Pj0gNztcbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IGUgKiAyNTYgKyBidWZmZXJbaV0sIGktLSwgbkJpdHMgLT0gOCk7XG4gIG0gPSBlICYgKDEgPDwgLW5CaXRzKSAtIDE7XG4gIGUgPj49IC1uQml0cztcbiAgbkJpdHMgKz0gbUxlbjtcbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IG0gKiAyNTYgKyBidWZmZXJbaV0sIGktLSwgbkJpdHMgLT0gOCk7XG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhcztcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiBzID8gLUluZmluaXR5IDogSW5maW5pdHk7XG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBwb3coMiwgbUxlbik7XG4gICAgZSA9IGUgLSBlQmlhcztcbiAgfSByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIHBvdygyLCBlIC0gbUxlbik7XG59XG5cbmZ1bmN0aW9uIHVucGFja0kzMihieXRlcykge1xuICByZXR1cm4gYnl0ZXNbM10gPDwgMjQgfCBieXRlc1syXSA8PCAxNiB8IGJ5dGVzWzFdIDw8IDggfCBieXRlc1swXTtcbn1cbmZ1bmN0aW9uIHBhY2tJOChpdCkge1xuICByZXR1cm4gW2l0ICYgMHhmZl07XG59XG5mdW5jdGlvbiBwYWNrSTE2KGl0KSB7XG4gIHJldHVybiBbaXQgJiAweGZmLCBpdCA+PiA4ICYgMHhmZl07XG59XG5mdW5jdGlvbiBwYWNrSTMyKGl0KSB7XG4gIHJldHVybiBbaXQgJiAweGZmLCBpdCA+PiA4ICYgMHhmZiwgaXQgPj4gMTYgJiAweGZmLCBpdCA+PiAyNCAmIDB4ZmZdO1xufVxuZnVuY3Rpb24gcGFja0Y2NChpdCkge1xuICByZXR1cm4gcGFja0lFRUU3NTQoaXQsIDUyLCA4KTtcbn1cbmZ1bmN0aW9uIHBhY2tGMzIoaXQpIHtcbiAgcmV0dXJuIHBhY2tJRUVFNzU0KGl0LCAyMywgNCk7XG59XG5cbmZ1bmN0aW9uIGFkZEdldHRlcihDLCBrZXksIGludGVybmFsKSB7XG4gIGRQKENbUFJPVE9UWVBFXSwga2V5LCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpc1tpbnRlcm5hbF07IH0gfSk7XG59XG5cbmZ1bmN0aW9uIGdldCh2aWV3LCBieXRlcywgaW5kZXgsIGlzTGl0dGxlRW5kaWFuKSB7XG4gIHZhciBudW1JbmRleCA9ICtpbmRleDtcbiAgdmFyIGludEluZGV4ID0gdG9JbmRleChudW1JbmRleCk7XG4gIGlmIChpbnRJbmRleCArIGJ5dGVzID4gdmlld1skTEVOR1RIXSkgdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19JTkRFWCk7XG4gIHZhciBzdG9yZSA9IHZpZXdbJEJVRkZFUl0uX2I7XG4gIHZhciBzdGFydCA9IGludEluZGV4ICsgdmlld1skT0ZGU0VUXTtcbiAgdmFyIHBhY2sgPSBzdG9yZS5zbGljZShzdGFydCwgc3RhcnQgKyBieXRlcyk7XG4gIHJldHVybiBpc0xpdHRsZUVuZGlhbiA/IHBhY2sgOiBwYWNrLnJldmVyc2UoKTtcbn1cbmZ1bmN0aW9uIHNldCh2aWV3LCBieXRlcywgaW5kZXgsIGNvbnZlcnNpb24sIHZhbHVlLCBpc0xpdHRsZUVuZGlhbikge1xuICB2YXIgbnVtSW5kZXggPSAraW5kZXg7XG4gIHZhciBpbnRJbmRleCA9IHRvSW5kZXgobnVtSW5kZXgpO1xuICBpZiAoaW50SW5kZXggKyBieXRlcyA+IHZpZXdbJExFTkdUSF0pIHRocm93IFJhbmdlRXJyb3IoV1JPTkdfSU5ERVgpO1xuICB2YXIgc3RvcmUgPSB2aWV3WyRCVUZGRVJdLl9iO1xuICB2YXIgc3RhcnQgPSBpbnRJbmRleCArIHZpZXdbJE9GRlNFVF07XG4gIHZhciBwYWNrID0gY29udmVyc2lvbigrdmFsdWUpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzOyBpKyspIHN0b3JlW3N0YXJ0ICsgaV0gPSBwYWNrW2lzTGl0dGxlRW5kaWFuID8gaSA6IGJ5dGVzIC0gaSAtIDFdO1xufVxuXG5pZiAoISR0eXBlZC5BQlYpIHtcbiAgJEFycmF5QnVmZmVyID0gZnVuY3Rpb24gQXJyYXlCdWZmZXIobGVuZ3RoKSB7XG4gICAgYW5JbnN0YW5jZSh0aGlzLCAkQXJyYXlCdWZmZXIsIEFSUkFZX0JVRkZFUik7XG4gICAgdmFyIGJ5dGVMZW5ndGggPSB0b0luZGV4KGxlbmd0aCk7XG4gICAgdGhpcy5fYiA9IGFycmF5RmlsbC5jYWxsKEFycmF5KGJ5dGVMZW5ndGgpLCAwKTtcbiAgICB0aGlzWyRMRU5HVEhdID0gYnl0ZUxlbmd0aDtcbiAgfTtcblxuICAkRGF0YVZpZXcgPSBmdW5jdGlvbiBEYXRhVmlldyhidWZmZXIsIGJ5dGVPZmZzZXQsIGJ5dGVMZW5ndGgpIHtcbiAgICBhbkluc3RhbmNlKHRoaXMsICREYXRhVmlldywgREFUQV9WSUVXKTtcbiAgICBhbkluc3RhbmNlKGJ1ZmZlciwgJEFycmF5QnVmZmVyLCBEQVRBX1ZJRVcpO1xuICAgIHZhciBidWZmZXJMZW5ndGggPSBidWZmZXJbJExFTkdUSF07XG4gICAgdmFyIG9mZnNldCA9IHRvSW50ZWdlcihieXRlT2Zmc2V0KTtcbiAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgPiBidWZmZXJMZW5ndGgpIHRocm93IFJhbmdlRXJyb3IoJ1dyb25nIG9mZnNldCEnKTtcbiAgICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA9PT0gdW5kZWZpbmVkID8gYnVmZmVyTGVuZ3RoIC0gb2Zmc2V0IDogdG9MZW5ndGgoYnl0ZUxlbmd0aCk7XG4gICAgaWYgKG9mZnNldCArIGJ5dGVMZW5ndGggPiBidWZmZXJMZW5ndGgpIHRocm93IFJhbmdlRXJyb3IoV1JPTkdfTEVOR1RIKTtcbiAgICB0aGlzWyRCVUZGRVJdID0gYnVmZmVyO1xuICAgIHRoaXNbJE9GRlNFVF0gPSBvZmZzZXQ7XG4gICAgdGhpc1skTEVOR1RIXSA9IGJ5dGVMZW5ndGg7XG4gIH07XG5cbiAgaWYgKERFU0NSSVBUT1JTKSB7XG4gICAgYWRkR2V0dGVyKCRBcnJheUJ1ZmZlciwgQllURV9MRU5HVEgsICdfbCcpO1xuICAgIGFkZEdldHRlcigkRGF0YVZpZXcsIEJVRkZFUiwgJ19iJyk7XG4gICAgYWRkR2V0dGVyKCREYXRhVmlldywgQllURV9MRU5HVEgsICdfbCcpO1xuICAgIGFkZEdldHRlcigkRGF0YVZpZXcsIEJZVEVfT0ZGU0VULCAnX28nKTtcbiAgfVxuXG4gIHJlZGVmaW5lQWxsKCREYXRhVmlld1tQUk9UT1RZUEVdLCB7XG4gICAgZ2V0SW50ODogZnVuY3Rpb24gZ2V0SW50OChieXRlT2Zmc2V0KSB7XG4gICAgICByZXR1cm4gZ2V0KHRoaXMsIDEsIGJ5dGVPZmZzZXQpWzBdIDw8IDI0ID4+IDI0O1xuICAgIH0sXG4gICAgZ2V0VWludDg6IGZ1bmN0aW9uIGdldFVpbnQ4KGJ5dGVPZmZzZXQpIHtcbiAgICAgIHJldHVybiBnZXQodGhpcywgMSwgYnl0ZU9mZnNldClbMF07XG4gICAgfSxcbiAgICBnZXRJbnQxNjogZnVuY3Rpb24gZ2V0SW50MTYoYnl0ZU9mZnNldCAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgdmFyIGJ5dGVzID0gZ2V0KHRoaXMsIDIsIGJ5dGVPZmZzZXQsIGFyZ3VtZW50c1sxXSk7XG4gICAgICByZXR1cm4gKGJ5dGVzWzFdIDw8IDggfCBieXRlc1swXSkgPDwgMTYgPj4gMTY7XG4gICAgfSxcbiAgICBnZXRVaW50MTY6IGZ1bmN0aW9uIGdldFVpbnQxNihieXRlT2Zmc2V0IC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICB2YXIgYnl0ZXMgPSBnZXQodGhpcywgMiwgYnl0ZU9mZnNldCwgYXJndW1lbnRzWzFdKTtcbiAgICAgIHJldHVybiBieXRlc1sxXSA8PCA4IHwgYnl0ZXNbMF07XG4gICAgfSxcbiAgICBnZXRJbnQzMjogZnVuY3Rpb24gZ2V0SW50MzIoYnl0ZU9mZnNldCAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgcmV0dXJuIHVucGFja0kzMihnZXQodGhpcywgNCwgYnl0ZU9mZnNldCwgYXJndW1lbnRzWzFdKSk7XG4gICAgfSxcbiAgICBnZXRVaW50MzI6IGZ1bmN0aW9uIGdldFVpbnQzMihieXRlT2Zmc2V0IC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICByZXR1cm4gdW5wYWNrSTMyKGdldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBhcmd1bWVudHNbMV0pKSA+Pj4gMDtcbiAgICB9LFxuICAgIGdldEZsb2F0MzI6IGZ1bmN0aW9uIGdldEZsb2F0MzIoYnl0ZU9mZnNldCAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgcmV0dXJuIHVucGFja0lFRUU3NTQoZ2V0KHRoaXMsIDQsIGJ5dGVPZmZzZXQsIGFyZ3VtZW50c1sxXSksIDIzLCA0KTtcbiAgICB9LFxuICAgIGdldEZsb2F0NjQ6IGZ1bmN0aW9uIGdldEZsb2F0NjQoYnl0ZU9mZnNldCAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgcmV0dXJuIHVucGFja0lFRUU3NTQoZ2V0KHRoaXMsIDgsIGJ5dGVPZmZzZXQsIGFyZ3VtZW50c1sxXSksIDUyLCA4KTtcbiAgICB9LFxuICAgIHNldEludDg6IGZ1bmN0aW9uIHNldEludDgoYnl0ZU9mZnNldCwgdmFsdWUpIHtcbiAgICAgIHNldCh0aGlzLCAxLCBieXRlT2Zmc2V0LCBwYWNrSTgsIHZhbHVlKTtcbiAgICB9LFxuICAgIHNldFVpbnQ4OiBmdW5jdGlvbiBzZXRVaW50OChieXRlT2Zmc2V0LCB2YWx1ZSkge1xuICAgICAgc2V0KHRoaXMsIDEsIGJ5dGVPZmZzZXQsIHBhY2tJOCwgdmFsdWUpO1xuICAgIH0sXG4gICAgc2V0SW50MTY6IGZ1bmN0aW9uIHNldEludDE2KGJ5dGVPZmZzZXQsIHZhbHVlIC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICBzZXQodGhpcywgMiwgYnl0ZU9mZnNldCwgcGFja0kxNiwgdmFsdWUsIGFyZ3VtZW50c1syXSk7XG4gICAgfSxcbiAgICBzZXRVaW50MTY6IGZ1bmN0aW9uIHNldFVpbnQxNihieXRlT2Zmc2V0LCB2YWx1ZSAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgc2V0KHRoaXMsIDIsIGJ5dGVPZmZzZXQsIHBhY2tJMTYsIHZhbHVlLCBhcmd1bWVudHNbMl0pO1xuICAgIH0sXG4gICAgc2V0SW50MzI6IGZ1bmN0aW9uIHNldEludDMyKGJ5dGVPZmZzZXQsIHZhbHVlIC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICBzZXQodGhpcywgNCwgYnl0ZU9mZnNldCwgcGFja0kzMiwgdmFsdWUsIGFyZ3VtZW50c1syXSk7XG4gICAgfSxcbiAgICBzZXRVaW50MzI6IGZ1bmN0aW9uIHNldFVpbnQzMihieXRlT2Zmc2V0LCB2YWx1ZSAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgc2V0KHRoaXMsIDQsIGJ5dGVPZmZzZXQsIHBhY2tJMzIsIHZhbHVlLCBhcmd1bWVudHNbMl0pO1xuICAgIH0sXG4gICAgc2V0RmxvYXQzMjogZnVuY3Rpb24gc2V0RmxvYXQzMihieXRlT2Zmc2V0LCB2YWx1ZSAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgc2V0KHRoaXMsIDQsIGJ5dGVPZmZzZXQsIHBhY2tGMzIsIHZhbHVlLCBhcmd1bWVudHNbMl0pO1xuICAgIH0sXG4gICAgc2V0RmxvYXQ2NDogZnVuY3Rpb24gc2V0RmxvYXQ2NChieXRlT2Zmc2V0LCB2YWx1ZSAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgc2V0KHRoaXMsIDgsIGJ5dGVPZmZzZXQsIHBhY2tGNjQsIHZhbHVlLCBhcmd1bWVudHNbMl0pO1xuICAgIH1cbiAgfSk7XG59IGVsc2Uge1xuICBpZiAoIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICAkQXJyYXlCdWZmZXIoMSk7XG4gIH0pIHx8ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgbmV3ICRBcnJheUJ1ZmZlcigtMSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gIH0pIHx8IGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICBuZXcgJEFycmF5QnVmZmVyKCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgbmV3ICRBcnJheUJ1ZmZlcigxLjUpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgIG5ldyAkQXJyYXlCdWZmZXIoTmFOKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICByZXR1cm4gJEFycmF5QnVmZmVyLm5hbWUgIT0gQVJSQVlfQlVGRkVSO1xuICB9KSkge1xuICAgICRBcnJheUJ1ZmZlciA9IGZ1bmN0aW9uIEFycmF5QnVmZmVyKGxlbmd0aCkge1xuICAgICAgYW5JbnN0YW5jZSh0aGlzLCAkQXJyYXlCdWZmZXIpO1xuICAgICAgcmV0dXJuIG5ldyBCYXNlQnVmZmVyKHRvSW5kZXgobGVuZ3RoKSk7XG4gICAgfTtcbiAgICB2YXIgQXJyYXlCdWZmZXJQcm90byA9ICRBcnJheUJ1ZmZlcltQUk9UT1RZUEVdID0gQmFzZUJ1ZmZlcltQUk9UT1RZUEVdO1xuICAgIGZvciAodmFyIGtleXMgPSBnT1BOKEJhc2VCdWZmZXIpLCBqID0gMCwga2V5OyBrZXlzLmxlbmd0aCA+IGo7KSB7XG4gICAgICBpZiAoISgoa2V5ID0ga2V5c1tqKytdKSBpbiAkQXJyYXlCdWZmZXIpKSBoaWRlKCRBcnJheUJ1ZmZlciwga2V5LCBCYXNlQnVmZmVyW2tleV0pO1xuICAgIH1cbiAgICBpZiAoIUxJQlJBUlkpIEFycmF5QnVmZmVyUHJvdG8uY29uc3RydWN0b3IgPSAkQXJyYXlCdWZmZXI7XG4gIH1cbiAgLy8gaU9TIFNhZmFyaSA3LnggYnVnXG4gIHZhciB2aWV3ID0gbmV3ICREYXRhVmlldyhuZXcgJEFycmF5QnVmZmVyKDIpKTtcbiAgdmFyICRzZXRJbnQ4ID0gJERhdGFWaWV3W1BST1RPVFlQRV0uc2V0SW50ODtcbiAgdmlldy5zZXRJbnQ4KDAsIDIxNDc0ODM2NDgpO1xuICB2aWV3LnNldEludDgoMSwgMjE0NzQ4MzY0OSk7XG4gIGlmICh2aWV3LmdldEludDgoMCkgfHwgIXZpZXcuZ2V0SW50OCgxKSkgcmVkZWZpbmVBbGwoJERhdGFWaWV3W1BST1RPVFlQRV0sIHtcbiAgICBzZXRJbnQ4OiBmdW5jdGlvbiBzZXRJbnQ4KGJ5dGVPZmZzZXQsIHZhbHVlKSB7XG4gICAgICAkc2V0SW50OC5jYWxsKHRoaXMsIGJ5dGVPZmZzZXQsIHZhbHVlIDw8IDI0ID4+IDI0KTtcbiAgICB9LFxuICAgIHNldFVpbnQ4OiBmdW5jdGlvbiBzZXRVaW50OChieXRlT2Zmc2V0LCB2YWx1ZSkge1xuICAgICAgJHNldEludDguY2FsbCh0aGlzLCBieXRlT2Zmc2V0LCB2YWx1ZSA8PCAyNCA+PiAyNCk7XG4gICAgfVxuICB9LCB0cnVlKTtcbn1cbnNldFRvU3RyaW5nVGFnKCRBcnJheUJ1ZmZlciwgQVJSQVlfQlVGRkVSKTtcbnNldFRvU3RyaW5nVGFnKCREYXRhVmlldywgREFUQV9WSUVXKTtcbmhpZGUoJERhdGFWaWV3W1BST1RPVFlQRV0sICR0eXBlZC5WSUVXLCB0cnVlKTtcbmV4cG9ydHNbQVJSQVlfQlVGRkVSXSA9ICRBcnJheUJ1ZmZlcjtcbmV4cG9ydHNbREFUQV9WSUVXXSA9ICREYXRhVmlldztcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xudmFyIHVpZCA9IHJlcXVpcmUoJy4vX3VpZCcpO1xudmFyIFRZUEVEID0gdWlkKCd0eXBlZF9hcnJheScpO1xudmFyIFZJRVcgPSB1aWQoJ3ZpZXcnKTtcbnZhciBBQlYgPSAhIShnbG9iYWwuQXJyYXlCdWZmZXIgJiYgZ2xvYmFsLkRhdGFWaWV3KTtcbnZhciBDT05TVFIgPSBBQlY7XG52YXIgaSA9IDA7XG52YXIgbCA9IDk7XG52YXIgVHlwZWQ7XG5cbnZhciBUeXBlZEFycmF5Q29uc3RydWN0b3JzID0gKFxuICAnSW50OEFycmF5LFVpbnQ4QXJyYXksVWludDhDbGFtcGVkQXJyYXksSW50MTZBcnJheSxVaW50MTZBcnJheSxJbnQzMkFycmF5LFVpbnQzMkFycmF5LEZsb2F0MzJBcnJheSxGbG9hdDY0QXJyYXknXG4pLnNwbGl0KCcsJyk7XG5cbndoaWxlIChpIDwgbCkge1xuICBpZiAoVHlwZWQgPSBnbG9iYWxbVHlwZWRBcnJheUNvbnN0cnVjdG9yc1tpKytdXSkge1xuICAgIGhpZGUoVHlwZWQucHJvdG90eXBlLCBUWVBFRCwgdHJ1ZSk7XG4gICAgaGlkZShUeXBlZC5wcm90b3R5cGUsIFZJRVcsIHRydWUpO1xuICB9IGVsc2UgQ09OU1RSID0gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBBQlY6IEFCVixcbiAgQ09OU1RSOiBDT05TVFIsXG4gIFRZUEVEOiBUWVBFRCxcbiAgVklFVzogVklFV1xufTtcbiIsInZhciBpZCA9IDA7XG52YXIgcHggPSBNYXRoLnJhbmRvbSgpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiAnU3ltYm9sKCcuY29uY2F0KGtleSA9PT0gdW5kZWZpbmVkID8gJycgOiBrZXksICcpXycsICgrK2lkICsgcHgpLnRvU3RyaW5nKDM2KSk7XG59O1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgVFlQRSkge1xuICBpZiAoIWlzT2JqZWN0KGl0KSB8fCBpdC5fdCAhPT0gVFlQRSkgdGhyb3cgVHlwZUVycm9yKCdJbmNvbXBhdGlibGUgcmVjZWl2ZXIsICcgKyBUWVBFICsgJyByZXF1aXJlZCEnKTtcbiAgcmV0dXJuIGl0O1xufTtcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBjb3JlID0gcmVxdWlyZSgnLi9fY29yZScpO1xudmFyIExJQlJBUlkgPSByZXF1aXJlKCcuL19saWJyYXJ5Jyk7XG52YXIgd2tzRXh0ID0gcmVxdWlyZSgnLi9fd2tzLWV4dCcpO1xudmFyIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgdmFyICRTeW1ib2wgPSBjb3JlLlN5bWJvbCB8fCAoY29yZS5TeW1ib2wgPSBMSUJSQVJZID8ge30gOiBnbG9iYWwuU3ltYm9sIHx8IHt9KTtcbiAgaWYgKG5hbWUuY2hhckF0KDApICE9ICdfJyAmJiAhKG5hbWUgaW4gJFN5bWJvbCkpIGRlZmluZVByb3BlcnR5KCRTeW1ib2wsIG5hbWUsIHsgdmFsdWU6IHdrc0V4dC5mKG5hbWUpIH0pO1xufTtcbiIsImV4cG9ydHMuZiA9IHJlcXVpcmUoJy4vX3drcycpO1xuIiwidmFyIHN0b3JlID0gcmVxdWlyZSgnLi9fc2hhcmVkJykoJ3drcycpO1xudmFyIHVpZCA9IHJlcXVpcmUoJy4vX3VpZCcpO1xudmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLlN5bWJvbDtcbnZhciBVU0VfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PSAnZnVuY3Rpb24nO1xuXG52YXIgJGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBzdG9yZVtuYW1lXSB8fCAoc3RvcmVbbmFtZV0gPVxuICAgIFVTRV9TWU1CT0wgJiYgU3ltYm9sW25hbWVdIHx8IChVU0VfU1lNQk9MID8gU3ltYm9sIDogdWlkKSgnU3ltYm9sLicgKyBuYW1lKSk7XG59O1xuXG4kZXhwb3J0cy5zdG9yZSA9IHN0b3JlO1xuIiwidmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuL19jbGFzc29mJyk7XG52YXIgSVRFUkFUT1IgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fY29yZScpLmdldEl0ZXJhdG9yTWV0aG9kID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpdCAhPSB1bmRlZmluZWQpIHJldHVybiBpdFtJVEVSQVRPUl1cbiAgICB8fCBpdFsnQEBpdGVyYXRvciddXG4gICAgfHwgSXRlcmF0b3JzW2NsYXNzb2YoaXQpXTtcbn07XG4iLCIvLyBodHRwczovL2dpdGh1Yi5jb20vYmVuamFtaW5nci9SZXhFeHAuZXNjYXBlXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRyZSA9IHJlcXVpcmUoJy4vX3JlcGxhY2VyJykoL1tcXFxcXiQqKz8uKCl8W1xcXXt9XS9nLCAnXFxcXCQmJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVnRXhwJywgeyBlc2NhcGU6IGZ1bmN0aW9uIGVzY2FwZShpdCkgeyByZXR1cm4gJHJlKGl0KTsgfSB9KTtcbiIsIi8vIDIyLjEuMy4zIEFycmF5LnByb3RvdHlwZS5jb3B5V2l0aGluKHRhcmdldCwgc3RhcnQsIGVuZCA9IHRoaXMubGVuZ3RoKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAsICdBcnJheScsIHsgY29weVdpdGhpbjogcmVxdWlyZSgnLi9fYXJyYXktY29weS13aXRoaW4nKSB9KTtcblxucmVxdWlyZSgnLi9fYWRkLXRvLXVuc2NvcGFibGVzJykoJ2NvcHlXaXRoaW4nKTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJGV2ZXJ5ID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpKDQpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoW10uZXZlcnksIHRydWUpLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy41IC8gMTUuNC40LjE2IEFycmF5LnByb3RvdHlwZS5ldmVyeShjYWxsYmFja2ZuIFssIHRoaXNBcmddKVxuICBldmVyeTogZnVuY3Rpb24gZXZlcnkoY2FsbGJhY2tmbiAvKiAsIHRoaXNBcmcgKi8pIHtcbiAgICByZXR1cm4gJGV2ZXJ5KHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50c1sxXSk7XG4gIH1cbn0pO1xuIiwiLy8gMjIuMS4zLjYgQXJyYXkucHJvdG90eXBlLmZpbGwodmFsdWUsIHN0YXJ0ID0gMCwgZW5kID0gdGhpcy5sZW5ndGgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCwgJ0FycmF5JywgeyBmaWxsOiByZXF1aXJlKCcuL19hcnJheS1maWxsJykgfSk7XG5cbnJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpKCdmaWxsJyk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRmaWx0ZXIgPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJykoMik7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKShbXS5maWx0ZXIsIHRydWUpLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy43IC8gMTUuNC40LjIwIEFycmF5LnByb3RvdHlwZS5maWx0ZXIoY2FsbGJhY2tmbiBbLCB0aGlzQXJnXSlcbiAgZmlsdGVyOiBmdW5jdGlvbiBmaWx0ZXIoY2FsbGJhY2tmbiAvKiAsIHRoaXNBcmcgKi8pIHtcbiAgICByZXR1cm4gJGZpbHRlcih0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHNbMV0pO1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIDIyLjEuMy45IEFycmF5LnByb3RvdHlwZS5maW5kSW5kZXgocHJlZGljYXRlLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkZmluZCA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKSg2KTtcbnZhciBLRVkgPSAnZmluZEluZGV4JztcbnZhciBmb3JjZWQgPSB0cnVlO1xuLy8gU2hvdWxkbid0IHNraXAgaG9sZXNcbmlmIChLRVkgaW4gW10pIEFycmF5KDEpW0tFWV0oZnVuY3Rpb24gKCkgeyBmb3JjZWQgPSBmYWxzZTsgfSk7XG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIGZvcmNlZCwgJ0FycmF5Jywge1xuICBmaW5kSW5kZXg6IGZ1bmN0aW9uIGZpbmRJbmRleChjYWxsYmFja2ZuIC8qICwgdGhhdCA9IHVuZGVmaW5lZCAqLykge1xuICAgIHJldHVybiAkZmluZCh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gIH1cbn0pO1xucmVxdWlyZSgnLi9fYWRkLXRvLXVuc2NvcGFibGVzJykoS0VZKTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIDIyLjEuMy44IEFycmF5LnByb3RvdHlwZS5maW5kKHByZWRpY2F0ZSwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJGZpbmQgPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJykoNSk7XG52YXIgS0VZID0gJ2ZpbmQnO1xudmFyIGZvcmNlZCA9IHRydWU7XG4vLyBTaG91bGRuJ3Qgc2tpcCBob2xlc1xuaWYgKEtFWSBpbiBbXSkgQXJyYXkoMSlbS0VZXShmdW5jdGlvbiAoKSB7IGZvcmNlZCA9IGZhbHNlOyB9KTtcbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogZm9yY2VkLCAnQXJyYXknLCB7XG4gIGZpbmQ6IGZ1bmN0aW9uIGZpbmQoY2FsbGJhY2tmbiAvKiAsIHRoYXQgPSB1bmRlZmluZWQgKi8pIHtcbiAgICByZXR1cm4gJGZpbmQodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICB9XG59KTtcbnJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpKEtFWSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRmb3JFYWNoID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpKDApO1xudmFyIFNUUklDVCA9IHJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKShbXS5mb3JFYWNoLCB0cnVlKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAhU1RSSUNULCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy4xMCAvIDE1LjQuNC4xOCBBcnJheS5wcm90b3R5cGUuZm9yRWFjaChjYWxsYmFja2ZuIFssIHRoaXNBcmddKVxuICBmb3JFYWNoOiBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKSB7XG4gICAgcmV0dXJuICRmb3JFYWNoKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50c1sxXSk7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyIGNhbGwgPSByZXF1aXJlKCcuL19pdGVyLWNhbGwnKTtcbnZhciBpc0FycmF5SXRlciA9IHJlcXVpcmUoJy4vX2lzLWFycmF5LWl0ZXInKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIGNyZWF0ZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fY3JlYXRlLXByb3BlcnR5Jyk7XG52YXIgZ2V0SXRlckZuID0gcmVxdWlyZSgnLi9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9faXRlci1kZXRlY3QnKShmdW5jdGlvbiAoaXRlcikgeyBBcnJheS5mcm9tKGl0ZXIpOyB9KSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjIuMSBBcnJheS5mcm9tKGFycmF5TGlrZSwgbWFwZm4gPSB1bmRlZmluZWQsIHRoaXNBcmcgPSB1bmRlZmluZWQpXG4gIGZyb206IGZ1bmN0aW9uIGZyb20oYXJyYXlMaWtlIC8qICwgbWFwZm4gPSB1bmRlZmluZWQsIHRoaXNBcmcgPSB1bmRlZmluZWQgKi8pIHtcbiAgICB2YXIgTyA9IHRvT2JqZWN0KGFycmF5TGlrZSk7XG4gICAgdmFyIEMgPSB0eXBlb2YgdGhpcyA9PSAnZnVuY3Rpb24nID8gdGhpcyA6IEFycmF5O1xuICAgIHZhciBhTGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgbWFwZm4gPSBhTGVuID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgbWFwcGluZyA9IG1hcGZuICE9PSB1bmRlZmluZWQ7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgaXRlckZuID0gZ2V0SXRlckZuKE8pO1xuICAgIHZhciBsZW5ndGgsIHJlc3VsdCwgc3RlcCwgaXRlcmF0b3I7XG4gICAgaWYgKG1hcHBpbmcpIG1hcGZuID0gY3R4KG1hcGZuLCBhTGVuID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZCwgMik7XG4gICAgLy8gaWYgb2JqZWN0IGlzbid0IGl0ZXJhYmxlIG9yIGl0J3MgYXJyYXkgd2l0aCBkZWZhdWx0IGl0ZXJhdG9yIC0gdXNlIHNpbXBsZSBjYXNlXG4gICAgaWYgKGl0ZXJGbiAhPSB1bmRlZmluZWQgJiYgIShDID09IEFycmF5ICYmIGlzQXJyYXlJdGVyKGl0ZXJGbikpKSB7XG4gICAgICBmb3IgKGl0ZXJhdG9yID0gaXRlckZuLmNhbGwoTyksIHJlc3VsdCA9IG5ldyBDKCk7ICEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZTsgaW5kZXgrKykge1xuICAgICAgICBjcmVhdGVQcm9wZXJ0eShyZXN1bHQsIGluZGV4LCBtYXBwaW5nID8gY2FsbChpdGVyYXRvciwgbWFwZm4sIFtzdGVwLnZhbHVlLCBpbmRleF0sIHRydWUpIDogc3RlcC52YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgICAgIGZvciAocmVzdWx0ID0gbmV3IEMobGVuZ3RoKTsgbGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIHtcbiAgICAgICAgY3JlYXRlUHJvcGVydHkocmVzdWx0LCBpbmRleCwgbWFwcGluZyA/IG1hcGZuKE9baW5kZXhdLCBpbmRleCkgOiBPW2luZGV4XSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlc3VsdC5sZW5ndGggPSBpbmRleDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJGluZGV4T2YgPSByZXF1aXJlKCcuL19hcnJheS1pbmNsdWRlcycpKGZhbHNlKTtcbnZhciAkbmF0aXZlID0gW10uaW5kZXhPZjtcbnZhciBORUdBVElWRV9aRVJPID0gISEkbmF0aXZlICYmIDEgLyBbMV0uaW5kZXhPZigxLCAtMCkgPCAwO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIChORUdBVElWRV9aRVJPIHx8ICFyZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoJG5hdGl2ZSkpLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy4xMSAvIDE1LjQuNC4xNCBBcnJheS5wcm90b3R5cGUuaW5kZXhPZihzZWFyY2hFbGVtZW50IFssIGZyb21JbmRleF0pXG4gIGluZGV4T2Y6IGZ1bmN0aW9uIGluZGV4T2Yoc2VhcmNoRWxlbWVudCAvKiAsIGZyb21JbmRleCA9IDAgKi8pIHtcbiAgICByZXR1cm4gTkVHQVRJVkVfWkVST1xuICAgICAgLy8gY29udmVydCAtMCB0byArMFxuICAgICAgPyAkbmF0aXZlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgMFxuICAgICAgOiAkaW5kZXhPZih0aGlzLCBzZWFyY2hFbGVtZW50LCBhcmd1bWVudHNbMV0pO1xuICB9XG59KTtcbiIsIi8vIDIyLjEuMi4yIC8gMTUuNC4zLjIgQXJyYXkuaXNBcnJheShhcmcpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ0FycmF5JywgeyBpc0FycmF5OiByZXF1aXJlKCcuL19pcy1hcnJheScpIH0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGFkZFRvVW5zY29wYWJsZXMgPSByZXF1aXJlKCcuL19hZGQtdG8tdW5zY29wYWJsZXMnKTtcbnZhciBzdGVwID0gcmVxdWlyZSgnLi9faXRlci1zdGVwJyk7XG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xuXG4vLyAyMi4xLjMuNCBBcnJheS5wcm90b3R5cGUuZW50cmllcygpXG4vLyAyMi4xLjMuMTMgQXJyYXkucHJvdG90eXBlLmtleXMoKVxuLy8gMjIuMS4zLjI5IEFycmF5LnByb3RvdHlwZS52YWx1ZXMoKVxuLy8gMjIuMS4zLjMwIEFycmF5LnByb3RvdHlwZVtAQGl0ZXJhdG9yXSgpXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2l0ZXItZGVmaW5lJykoQXJyYXksICdBcnJheScsIGZ1bmN0aW9uIChpdGVyYXRlZCwga2luZCkge1xuICB0aGlzLl90ID0gdG9JT2JqZWN0KGl0ZXJhdGVkKTsgLy8gdGFyZ2V0XG4gIHRoaXMuX2kgPSAwOyAgICAgICAgICAgICAgICAgICAvLyBuZXh0IGluZGV4XG4gIHRoaXMuX2sgPSBraW5kOyAgICAgICAgICAgICAgICAvLyBraW5kXG4vLyAyMi4xLjUuMi4xICVBcnJheUl0ZXJhdG9yUHJvdG90eXBlJS5uZXh0KClcbn0sIGZ1bmN0aW9uICgpIHtcbiAgdmFyIE8gPSB0aGlzLl90O1xuICB2YXIga2luZCA9IHRoaXMuX2s7XG4gIHZhciBpbmRleCA9IHRoaXMuX2krKztcbiAgaWYgKCFPIHx8IGluZGV4ID49IE8ubGVuZ3RoKSB7XG4gICAgdGhpcy5fdCA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gc3RlcCgxKTtcbiAgfVxuICBpZiAoa2luZCA9PSAna2V5cycpIHJldHVybiBzdGVwKDAsIGluZGV4KTtcbiAgaWYgKGtpbmQgPT0gJ3ZhbHVlcycpIHJldHVybiBzdGVwKDAsIE9baW5kZXhdKTtcbiAgcmV0dXJuIHN0ZXAoMCwgW2luZGV4LCBPW2luZGV4XV0pO1xufSwgJ3ZhbHVlcycpO1xuXG4vLyBhcmd1bWVudHNMaXN0W0BAaXRlcmF0b3JdIGlzICVBcnJheVByb3RvX3ZhbHVlcyUgKDkuNC40LjYsIDkuNC40LjcpXG5JdGVyYXRvcnMuQXJndW1lbnRzID0gSXRlcmF0b3JzLkFycmF5O1xuXG5hZGRUb1Vuc2NvcGFibGVzKCdrZXlzJyk7XG5hZGRUb1Vuc2NvcGFibGVzKCd2YWx1ZXMnKTtcbmFkZFRvVW5zY29wYWJsZXMoJ2VudHJpZXMnKTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIDIyLjEuMy4xMyBBcnJheS5wcm90b3R5cGUuam9pbihzZXBhcmF0b3IpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciBhcnJheUpvaW4gPSBbXS5qb2luO1xuXG4vLyBmYWxsYmFjayBmb3Igbm90IGFycmF5LWxpa2Ugc3RyaW5nc1xuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAocmVxdWlyZSgnLi9faW9iamVjdCcpICE9IE9iamVjdCB8fCAhcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKGFycmF5Sm9pbikpLCAnQXJyYXknLCB7XG4gIGpvaW46IGZ1bmN0aW9uIGpvaW4oc2VwYXJhdG9yKSB7XG4gICAgcmV0dXJuIGFycmF5Sm9pbi5jYWxsKHRvSU9iamVjdCh0aGlzKSwgc2VwYXJhdG9yID09PSB1bmRlZmluZWQgPyAnLCcgOiBzZXBhcmF0b3IpO1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyICRuYXRpdmUgPSBbXS5sYXN0SW5kZXhPZjtcbnZhciBORUdBVElWRV9aRVJPID0gISEkbmF0aXZlICYmIDEgLyBbMV0ubGFzdEluZGV4T2YoMSwgLTApIDwgMDtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoTkVHQVRJVkVfWkVSTyB8fCAhcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKCRuYXRpdmUpKSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjMuMTQgLyAxNS40LjQuMTUgQXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mKHNlYXJjaEVsZW1lbnQgWywgZnJvbUluZGV4XSlcbiAgbGFzdEluZGV4T2Y6IGZ1bmN0aW9uIGxhc3RJbmRleE9mKHNlYXJjaEVsZW1lbnQgLyogLCBmcm9tSW5kZXggPSBAWyotMV0gKi8pIHtcbiAgICAvLyBjb252ZXJ0IC0wIHRvICswXG4gICAgaWYgKE5FR0FUSVZFX1pFUk8pIHJldHVybiAkbmF0aXZlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgMDtcbiAgICB2YXIgTyA9IHRvSU9iamVjdCh0aGlzKTtcbiAgICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICAgIHZhciBpbmRleCA9IGxlbmd0aCAtIDE7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSBpbmRleCA9IE1hdGgubWluKGluZGV4LCB0b0ludGVnZXIoYXJndW1lbnRzWzFdKSk7XG4gICAgaWYgKGluZGV4IDwgMCkgaW5kZXggPSBsZW5ndGggKyBpbmRleDtcbiAgICBmb3IgKDtpbmRleCA+PSAwOyBpbmRleC0tKSBpZiAoaW5kZXggaW4gTykgaWYgKE9baW5kZXhdID09PSBzZWFyY2hFbGVtZW50KSByZXR1cm4gaW5kZXggfHwgMDtcbiAgICByZXR1cm4gLTE7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkbWFwID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpKDEpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoW10ubWFwLCB0cnVlKSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjMuMTUgLyAxNS40LjQuMTkgQXJyYXkucHJvdG90eXBlLm1hcChjYWxsYmFja2ZuIFssIHRoaXNBcmddKVxuICBtYXA6IGZ1bmN0aW9uIG1hcChjYWxsYmFja2ZuIC8qICwgdGhpc0FyZyAqLykge1xuICAgIHJldHVybiAkbWFwKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50c1sxXSk7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBjcmVhdGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2NyZWF0ZS1wcm9wZXJ0eScpO1xuXG4vLyBXZWJLaXQgQXJyYXkub2YgaXNuJ3QgZ2VuZXJpY1xuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRigpIHsgLyogZW1wdHkgKi8gfVxuICByZXR1cm4gIShBcnJheS5vZi5jYWxsKEYpIGluc3RhbmNlb2YgRik7XG59KSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjIuMyBBcnJheS5vZiggLi4uaXRlbXMpXG4gIG9mOiBmdW5jdGlvbiBvZigvKiAuLi5hcmdzICovKSB7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgYUxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIHJlc3VsdCA9IG5ldyAodHlwZW9mIHRoaXMgPT0gJ2Z1bmN0aW9uJyA/IHRoaXMgOiBBcnJheSkoYUxlbik7XG4gICAgd2hpbGUgKGFMZW4gPiBpbmRleCkgY3JlYXRlUHJvcGVydHkocmVzdWx0LCBpbmRleCwgYXJndW1lbnRzW2luZGV4KytdKTtcbiAgICByZXN1bHQubGVuZ3RoID0gYUxlbjtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJHJlZHVjZSA9IHJlcXVpcmUoJy4vX2FycmF5LXJlZHVjZScpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoW10ucmVkdWNlUmlnaHQsIHRydWUpLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy4xOSAvIDE1LjQuNC4yMiBBcnJheS5wcm90b3R5cGUucmVkdWNlUmlnaHQoY2FsbGJhY2tmbiBbLCBpbml0aWFsVmFsdWVdKVxuICByZWR1Y2VSaWdodDogZnVuY3Rpb24gcmVkdWNlUmlnaHQoY2FsbGJhY2tmbiAvKiAsIGluaXRpYWxWYWx1ZSAqLykge1xuICAgIHJldHVybiAkcmVkdWNlKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3VtZW50c1sxXSwgdHJ1ZSk7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkcmVkdWNlID0gcmVxdWlyZSgnLi9fYXJyYXktcmVkdWNlJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKShbXS5yZWR1Y2UsIHRydWUpLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy4xOCAvIDE1LjQuNC4yMSBBcnJheS5wcm90b3R5cGUucmVkdWNlKGNhbGxiYWNrZm4gWywgaW5pdGlhbFZhbHVlXSlcbiAgcmVkdWNlOiBmdW5jdGlvbiByZWR1Y2UoY2FsbGJhY2tmbiAvKiAsIGluaXRpYWxWYWx1ZSAqLykge1xuICAgIHJldHVybiAkcmVkdWNlKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3VtZW50c1sxXSwgZmFsc2UpO1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgaHRtbCA9IHJlcXVpcmUoJy4vX2h0bWwnKTtcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbnZhciB0b0Fic29sdXRlSW5kZXggPSByZXF1aXJlKCcuL190by1hYnNvbHV0ZS1pbmRleCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgYXJyYXlTbGljZSA9IFtdLnNsaWNlO1xuXG4vLyBmYWxsYmFjayBmb3Igbm90IGFycmF5LWxpa2UgRVMzIHN0cmluZ3MgYW5kIERPTSBvYmplY3RzXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICBpZiAoaHRtbCkgYXJyYXlTbGljZS5jYWxsKGh0bWwpO1xufSksICdBcnJheScsIHtcbiAgc2xpY2U6IGZ1bmN0aW9uIHNsaWNlKGJlZ2luLCBlbmQpIHtcbiAgICB2YXIgbGVuID0gdG9MZW5ndGgodGhpcy5sZW5ndGgpO1xuICAgIHZhciBrbGFzcyA9IGNvZih0aGlzKTtcbiAgICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IGVuZDtcbiAgICBpZiAoa2xhc3MgPT0gJ0FycmF5JykgcmV0dXJuIGFycmF5U2xpY2UuY2FsbCh0aGlzLCBiZWdpbiwgZW5kKTtcbiAgICB2YXIgc3RhcnQgPSB0b0Fic29sdXRlSW5kZXgoYmVnaW4sIGxlbik7XG4gICAgdmFyIHVwVG8gPSB0b0Fic29sdXRlSW5kZXgoZW5kLCBsZW4pO1xuICAgIHZhciBzaXplID0gdG9MZW5ndGgodXBUbyAtIHN0YXJ0KTtcbiAgICB2YXIgY2xvbmVkID0gQXJyYXkoc2l6ZSk7XG4gICAgdmFyIGkgPSAwO1xuICAgIGZvciAoOyBpIDwgc2l6ZTsgaSsrKSBjbG9uZWRbaV0gPSBrbGFzcyA9PSAnU3RyaW5nJ1xuICAgICAgPyB0aGlzLmNoYXJBdChzdGFydCArIGkpXG4gICAgICA6IHRoaXNbc3RhcnQgKyBpXTtcbiAgICByZXR1cm4gY2xvbmVkO1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJHNvbWUgPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJykoMyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKShbXS5zb21lLCB0cnVlKSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjMuMjMgLyAxNS40LjQuMTcgQXJyYXkucHJvdG90eXBlLnNvbWUoY2FsbGJhY2tmbiBbLCB0aGlzQXJnXSlcbiAgc29tZTogZnVuY3Rpb24gc29tZShjYWxsYmFja2ZuIC8qICwgdGhpc0FyZyAqLykge1xuICAgIHJldHVybiAkc29tZSh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHNbMV0pO1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xudmFyICRzb3J0ID0gW10uc29ydDtcbnZhciB0ZXN0ID0gWzEsIDIsIDNdO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIChmYWlscyhmdW5jdGlvbiAoKSB7XG4gIC8vIElFOC1cbiAgdGVzdC5zb3J0KHVuZGVmaW5lZCk7XG59KSB8fCAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvLyBWOCBidWdcbiAgdGVzdC5zb3J0KG51bGwpO1xuICAvLyBPbGQgV2ViS2l0XG59KSB8fCAhcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKCRzb3J0KSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjI1IEFycmF5LnByb3RvdHlwZS5zb3J0KGNvbXBhcmVmbilcbiAgc29ydDogZnVuY3Rpb24gc29ydChjb21wYXJlZm4pIHtcbiAgICByZXR1cm4gY29tcGFyZWZuID09PSB1bmRlZmluZWRcbiAgICAgID8gJHNvcnQuY2FsbCh0b09iamVjdCh0aGlzKSlcbiAgICAgIDogJHNvcnQuY2FsbCh0b09iamVjdCh0aGlzKSwgYUZ1bmN0aW9uKGNvbXBhcmVmbikpO1xuICB9XG59KTtcbiIsInJlcXVpcmUoJy4vX3NldC1zcGVjaWVzJykoJ0FycmF5Jyk7XG4iLCIvLyAyMC4zLjMuMSAvIDE1LjkuNC40IERhdGUubm93KClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnRGF0ZScsIHsgbm93OiBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTsgfSB9KTtcbiIsIi8vIDIwLjMuNC4zNiAvIDE1LjkuNS40MyBEYXRlLnByb3RvdHlwZS50b0lTT1N0cmluZygpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHRvSVNPU3RyaW5nID0gcmVxdWlyZSgnLi9fZGF0ZS10by1pc28tc3RyaW5nJyk7XG5cbi8vIFBoYW50b21KUyAvIG9sZCBXZWJLaXQgaGFzIGEgYnJva2VuIGltcGxlbWVudGF0aW9uc1xuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoRGF0ZS5wcm90b3R5cGUudG9JU09TdHJpbmcgIT09IHRvSVNPU3RyaW5nKSwgJ0RhdGUnLCB7XG4gIHRvSVNPU3RyaW5nOiB0b0lTT1N0cmluZ1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIG5ldyBEYXRlKE5hTikudG9KU09OKCkgIT09IG51bGxcbiAgICB8fCBEYXRlLnByb3RvdHlwZS50b0pTT04uY2FsbCh7IHRvSVNPU3RyaW5nOiBmdW5jdGlvbiAoKSB7IHJldHVybiAxOyB9IH0pICE9PSAxO1xufSksICdEYXRlJywge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgdG9KU09OOiBmdW5jdGlvbiB0b0pTT04oa2V5KSB7XG4gICAgdmFyIE8gPSB0b09iamVjdCh0aGlzKTtcbiAgICB2YXIgcHYgPSB0b1ByaW1pdGl2ZShPKTtcbiAgICByZXR1cm4gdHlwZW9mIHB2ID09ICdudW1iZXInICYmICFpc0Zpbml0ZShwdikgPyBudWxsIDogTy50b0lTT1N0cmluZygpO1xuICB9XG59KTtcbiIsInZhciBUT19QUklNSVRJVkUgPSByZXF1aXJlKCcuL193a3MnKSgndG9QcmltaXRpdmUnKTtcbnZhciBwcm90byA9IERhdGUucHJvdG90eXBlO1xuXG5pZiAoIShUT19QUklNSVRJVkUgaW4gcHJvdG8pKSByZXF1aXJlKCcuL19oaWRlJykocHJvdG8sIFRPX1BSSU1JVElWRSwgcmVxdWlyZSgnLi9fZGF0ZS10by1wcmltaXRpdmUnKSk7XG4iLCJ2YXIgRGF0ZVByb3RvID0gRGF0ZS5wcm90b3R5cGU7XG52YXIgSU5WQUxJRF9EQVRFID0gJ0ludmFsaWQgRGF0ZSc7XG52YXIgVE9fU1RSSU5HID0gJ3RvU3RyaW5nJztcbnZhciAkdG9TdHJpbmcgPSBEYXRlUHJvdG9bVE9fU1RSSU5HXTtcbnZhciBnZXRUaW1lID0gRGF0ZVByb3RvLmdldFRpbWU7XG5pZiAobmV3IERhdGUoTmFOKSArICcnICE9IElOVkFMSURfREFURSkge1xuICByZXF1aXJlKCcuL19yZWRlZmluZScpKERhdGVQcm90bywgVE9fU1RSSU5HLCBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICB2YXIgdmFsdWUgPSBnZXRUaW1lLmNhbGwodGhpcyk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgIHJldHVybiB2YWx1ZSA9PT0gdmFsdWUgPyAkdG9TdHJpbmcuY2FsbCh0aGlzKSA6IElOVkFMSURfREFURTtcbiAgfSk7XG59XG4iLCIvLyAxOS4yLjMuMiAvIDE1LjMuNC41IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kKHRoaXNBcmcsIGFyZ3MuLi4pXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCwgJ0Z1bmN0aW9uJywgeyBiaW5kOiByZXF1aXJlKCcuL19iaW5kJykgfSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKTtcbnZhciBIQVNfSU5TVEFOQ0UgPSByZXF1aXJlKCcuL193a3MnKSgnaGFzSW5zdGFuY2UnKTtcbnZhciBGdW5jdGlvblByb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuLy8gMTkuMi4zLjYgRnVuY3Rpb24ucHJvdG90eXBlW0BAaGFzSW5zdGFuY2VdKFYpXG5pZiAoIShIQVNfSU5TVEFOQ0UgaW4gRnVuY3Rpb25Qcm90bykpIHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmYoRnVuY3Rpb25Qcm90bywgSEFTX0lOU1RBTkNFLCB7IHZhbHVlOiBmdW5jdGlvbiAoTykge1xuICBpZiAodHlwZW9mIHRoaXMgIT0gJ2Z1bmN0aW9uJyB8fCAhaXNPYmplY3QoTykpIHJldHVybiBmYWxzZTtcbiAgaWYgKCFpc09iamVjdCh0aGlzLnByb3RvdHlwZSkpIHJldHVybiBPIGluc3RhbmNlb2YgdGhpcztcbiAgLy8gZm9yIGVudmlyb25tZW50IHcvbyBuYXRpdmUgYEBAaGFzSW5zdGFuY2VgIGxvZ2ljIGVub3VnaCBgaW5zdGFuY2VvZmAsIGJ1dCBhZGQgdGhpczpcbiAgd2hpbGUgKE8gPSBnZXRQcm90b3R5cGVPZihPKSkgaWYgKHRoaXMucHJvdG90eXBlID09PSBPKSByZXR1cm4gdHJ1ZTtcbiAgcmV0dXJuIGZhbHNlO1xufSB9KTtcbiIsInZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG52YXIgRlByb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlO1xudmFyIG5hbWVSRSA9IC9eXFxzKmZ1bmN0aW9uIChbXiAoXSopLztcbnZhciBOQU1FID0gJ25hbWUnO1xuXG4vLyAxOS4yLjQuMiBuYW1lXG5OQU1FIGluIEZQcm90byB8fCByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmIGRQKEZQcm90bywgTkFNRSwge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gKCcnICsgdGhpcykubWF0Y2gobmFtZVJFKVsxXTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBzdHJvbmcgPSByZXF1aXJlKCcuL19jb2xsZWN0aW9uLXN0cm9uZycpO1xudmFyIHZhbGlkYXRlID0gcmVxdWlyZSgnLi9fdmFsaWRhdGUtY29sbGVjdGlvbicpO1xudmFyIE1BUCA9ICdNYXAnO1xuXG4vLyAyMy4xIE1hcCBPYmplY3RzXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24nKShNQVAsIGZ1bmN0aW9uIChnZXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIE1hcCgpIHsgcmV0dXJuIGdldCh0aGlzLCBhcmd1bWVudHMubGVuZ3RoID4gMCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7IH07XG59LCB7XG4gIC8vIDIzLjEuMy42IE1hcC5wcm90b3R5cGUuZ2V0KGtleSlcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoa2V5KSB7XG4gICAgdmFyIGVudHJ5ID0gc3Ryb25nLmdldEVudHJ5KHZhbGlkYXRlKHRoaXMsIE1BUCksIGtleSk7XG4gICAgcmV0dXJuIGVudHJ5ICYmIGVudHJ5LnY7XG4gIH0sXG4gIC8vIDIzLjEuMy45IE1hcC5wcm90b3R5cGUuc2V0KGtleSwgdmFsdWUpXG4gIHNldDogZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpIHtcbiAgICByZXR1cm4gc3Ryb25nLmRlZih2YWxpZGF0ZSh0aGlzLCBNQVApLCBrZXkgPT09IDAgPyAwIDoga2V5LCB2YWx1ZSk7XG4gIH1cbn0sIHN0cm9uZywgdHJ1ZSk7XG4iLCIvLyAyMC4yLjIuMyBNYXRoLmFjb3NoKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGxvZzFwID0gcmVxdWlyZSgnLi9fbWF0aC1sb2cxcCcpO1xudmFyIHNxcnQgPSBNYXRoLnNxcnQ7XG52YXIgJGFjb3NoID0gTWF0aC5hY29zaDtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhKCRhY29zaFxuICAvLyBWOCBidWc6IGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zNTA5XG4gICYmIE1hdGguZmxvb3IoJGFjb3NoKE51bWJlci5NQVhfVkFMVUUpKSA9PSA3MTBcbiAgLy8gVG9yIEJyb3dzZXIgYnVnOiBNYXRoLmFjb3NoKEluZmluaXR5KSAtPiBOYU5cbiAgJiYgJGFjb3NoKEluZmluaXR5KSA9PSBJbmZpbml0eVxuKSwgJ01hdGgnLCB7XG4gIGFjb3NoOiBmdW5jdGlvbiBhY29zaCh4KSB7XG4gICAgcmV0dXJuICh4ID0gK3gpIDwgMSA/IE5hTiA6IHggPiA5NDkwNjI2NS42MjQyNTE1NlxuICAgICAgPyBNYXRoLmxvZyh4KSArIE1hdGguTE4yXG4gICAgICA6IGxvZzFwKHggLSAxICsgc3FydCh4IC0gMSkgKiBzcXJ0KHggKyAxKSk7XG4gIH1cbn0pO1xuIiwiLy8gMjAuMi4yLjUgTWF0aC5hc2luaCh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkYXNpbmggPSBNYXRoLmFzaW5oO1xuXG5mdW5jdGlvbiBhc2luaCh4KSB7XG4gIHJldHVybiAhaXNGaW5pdGUoeCA9ICt4KSB8fCB4ID09IDAgPyB4IDogeCA8IDAgPyAtYXNpbmgoLXgpIDogTWF0aC5sb2coeCArIE1hdGguc3FydCh4ICogeCArIDEpKTtcbn1cblxuLy8gVG9yIEJyb3dzZXIgYnVnOiBNYXRoLmFzaW5oKDApIC0+IC0wXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICEoJGFzaW5oICYmIDEgLyAkYXNpbmgoMCkgPiAwKSwgJ01hdGgnLCB7IGFzaW5oOiBhc2luaCB9KTtcbiIsIi8vIDIwLjIuMi43IE1hdGguYXRhbmgoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJGF0YW5oID0gTWF0aC5hdGFuaDtcblxuLy8gVG9yIEJyb3dzZXIgYnVnOiBNYXRoLmF0YW5oKC0wKSAtPiAwXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICEoJGF0YW5oICYmIDEgLyAkYXRhbmgoLTApIDwgMCksICdNYXRoJywge1xuICBhdGFuaDogZnVuY3Rpb24gYXRhbmgoeCkge1xuICAgIHJldHVybiAoeCA9ICt4KSA9PSAwID8geCA6IE1hdGgubG9nKCgxICsgeCkgLyAoMSAtIHgpKSAvIDI7XG4gIH1cbn0pO1xuIiwiLy8gMjAuMi4yLjkgTWF0aC5jYnJ0KHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHNpZ24gPSByZXF1aXJlKCcuL19tYXRoLXNpZ24nKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBjYnJ0OiBmdW5jdGlvbiBjYnJ0KHgpIHtcbiAgICByZXR1cm4gc2lnbih4ID0gK3gpICogTWF0aC5wb3coTWF0aC5hYnMoeCksIDEgLyAzKTtcbiAgfVxufSk7XG4iLCIvLyAyMC4yLjIuMTEgTWF0aC5jbHozMih4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBjbHozMjogZnVuY3Rpb24gY2x6MzIoeCkge1xuICAgIHJldHVybiAoeCA+Pj49IDApID8gMzEgLSBNYXRoLmZsb29yKE1hdGgubG9nKHggKyAwLjUpICogTWF0aC5MT0cyRSkgOiAzMjtcbiAgfVxufSk7XG4iLCIvLyAyMC4yLjIuMTIgTWF0aC5jb3NoKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGV4cCA9IE1hdGguZXhwO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGNvc2g6IGZ1bmN0aW9uIGNvc2goeCkge1xuICAgIHJldHVybiAoZXhwKHggPSAreCkgKyBleHAoLXgpKSAvIDI7XG4gIH1cbn0pO1xuIiwiLy8gMjAuMi4yLjE0IE1hdGguZXhwbTEoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJGV4cG0xID0gcmVxdWlyZSgnLi9fbWF0aC1leHBtMScpO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICgkZXhwbTEgIT0gTWF0aC5leHBtMSksICdNYXRoJywgeyBleHBtMTogJGV4cG0xIH0pO1xuIiwiLy8gMjAuMi4yLjE2IE1hdGguZnJvdW5kKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7IGZyb3VuZDogcmVxdWlyZSgnLi9fbWF0aC1mcm91bmQnKSB9KTtcbiIsIi8vIDIwLjIuMi4xNyBNYXRoLmh5cG90KFt2YWx1ZTFbLCB2YWx1ZTJbLCDigKYgXV1dKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBhYnMgPSBNYXRoLmFicztcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBoeXBvdDogZnVuY3Rpb24gaHlwb3QodmFsdWUxLCB2YWx1ZTIpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIHZhciBzdW0gPSAwO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgYUxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIGxhcmcgPSAwO1xuICAgIHZhciBhcmcsIGRpdjtcbiAgICB3aGlsZSAoaSA8IGFMZW4pIHtcbiAgICAgIGFyZyA9IGFicyhhcmd1bWVudHNbaSsrXSk7XG4gICAgICBpZiAobGFyZyA8IGFyZykge1xuICAgICAgICBkaXYgPSBsYXJnIC8gYXJnO1xuICAgICAgICBzdW0gPSBzdW0gKiBkaXYgKiBkaXYgKyAxO1xuICAgICAgICBsYXJnID0gYXJnO1xuICAgICAgfSBlbHNlIGlmIChhcmcgPiAwKSB7XG4gICAgICAgIGRpdiA9IGFyZyAvIGxhcmc7XG4gICAgICAgIHN1bSArPSBkaXYgKiBkaXY7XG4gICAgICB9IGVsc2Ugc3VtICs9IGFyZztcbiAgICB9XG4gICAgcmV0dXJuIGxhcmcgPT09IEluZmluaXR5ID8gSW5maW5pdHkgOiBsYXJnICogTWF0aC5zcXJ0KHN1bSk7XG4gIH1cbn0pO1xuIiwiLy8gMjAuMi4yLjE4IE1hdGguaW11bCh4LCB5KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkaW11bCA9IE1hdGguaW11bDtcblxuLy8gc29tZSBXZWJLaXQgdmVyc2lvbnMgZmFpbHMgd2l0aCBiaWcgbnVtYmVycywgc29tZSBoYXMgd3JvbmcgYXJpdHlcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAkaW11bCgweGZmZmZmZmZmLCA1KSAhPSAtNSB8fCAkaW11bC5sZW5ndGggIT0gMjtcbn0pLCAnTWF0aCcsIHtcbiAgaW11bDogZnVuY3Rpb24gaW11bCh4LCB5KSB7XG4gICAgdmFyIFVJTlQxNiA9IDB4ZmZmZjtcbiAgICB2YXIgeG4gPSAreDtcbiAgICB2YXIgeW4gPSAreTtcbiAgICB2YXIgeGwgPSBVSU5UMTYgJiB4bjtcbiAgICB2YXIgeWwgPSBVSU5UMTYgJiB5bjtcbiAgICByZXR1cm4gMCB8IHhsICogeWwgKyAoKFVJTlQxNiAmIHhuID4+PiAxNikgKiB5bCArIHhsICogKFVJTlQxNiAmIHluID4+PiAxNikgPDwgMTYgPj4+IDApO1xuICB9XG59KTtcbiIsIi8vIDIwLjIuMi4yMSBNYXRoLmxvZzEwKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGxvZzEwOiBmdW5jdGlvbiBsb2cxMCh4KSB7XG4gICAgcmV0dXJuIE1hdGgubG9nKHgpICogTWF0aC5MT0cxMEU7XG4gIH1cbn0pO1xuIiwiLy8gMjAuMi4yLjIwIE1hdGgubG9nMXAoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHsgbG9nMXA6IHJlcXVpcmUoJy4vX21hdGgtbG9nMXAnKSB9KTtcbiIsIi8vIDIwLjIuMi4yMiBNYXRoLmxvZzIoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgbG9nMjogZnVuY3Rpb24gbG9nMih4KSB7XG4gICAgcmV0dXJuIE1hdGgubG9nKHgpIC8gTWF0aC5MTjI7XG4gIH1cbn0pO1xuIiwiLy8gMjAuMi4yLjI4IE1hdGguc2lnbih4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywgeyBzaWduOiByZXF1aXJlKCcuL19tYXRoLXNpZ24nKSB9KTtcbiIsIi8vIDIwLjIuMi4zMCBNYXRoLnNpbmgoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgZXhwbTEgPSByZXF1aXJlKCcuL19tYXRoLWV4cG0xJyk7XG52YXIgZXhwID0gTWF0aC5leHA7XG5cbi8vIFY4IG5lYXIgQ2hyb21pdW0gMzggaGFzIGEgcHJvYmxlbSB3aXRoIHZlcnkgc21hbGwgbnVtYmVyc1xuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICFNYXRoLnNpbmgoLTJlLTE3KSAhPSAtMmUtMTc7XG59KSwgJ01hdGgnLCB7XG4gIHNpbmg6IGZ1bmN0aW9uIHNpbmgoeCkge1xuICAgIHJldHVybiBNYXRoLmFicyh4ID0gK3gpIDwgMVxuICAgICAgPyAoZXhwbTEoeCkgLSBleHBtMSgteCkpIC8gMlxuICAgICAgOiAoZXhwKHggLSAxKSAtIGV4cCgteCAtIDEpKSAqIChNYXRoLkUgLyAyKTtcbiAgfVxufSk7XG4iLCIvLyAyMC4yLjIuMzMgTWF0aC50YW5oKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGV4cG0xID0gcmVxdWlyZSgnLi9fbWF0aC1leHBtMScpO1xudmFyIGV4cCA9IE1hdGguZXhwO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIHRhbmg6IGZ1bmN0aW9uIHRhbmgoeCkge1xuICAgIHZhciBhID0gZXhwbTEoeCA9ICt4KTtcbiAgICB2YXIgYiA9IGV4cG0xKC14KTtcbiAgICByZXR1cm4gYSA9PSBJbmZpbml0eSA/IDEgOiBiID09IEluZmluaXR5ID8gLTEgOiAoYSAtIGIpIC8gKGV4cCh4KSArIGV4cCgteCkpO1xuICB9XG59KTtcbiIsIi8vIDIwLjIuMi4zNCBNYXRoLnRydW5jKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIHRydW5jOiBmdW5jdGlvbiB0cnVuYyhpdCkge1xuICAgIHJldHVybiAoaXQgPiAwID8gTWF0aC5mbG9vciA6IE1hdGguY2VpbCkoaXQpO1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbnZhciBpbmhlcml0SWZSZXF1aXJlZCA9IHJlcXVpcmUoJy4vX2luaGVyaXQtaWYtcmVxdWlyZWQnKTtcbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbnZhciBnT1BOID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mO1xudmFyIGdPUEQgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpLmY7XG52YXIgZFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mO1xudmFyICR0cmltID0gcmVxdWlyZSgnLi9fc3RyaW5nLXRyaW0nKS50cmltO1xudmFyIE5VTUJFUiA9ICdOdW1iZXInO1xudmFyICROdW1iZXIgPSBnbG9iYWxbTlVNQkVSXTtcbnZhciBCYXNlID0gJE51bWJlcjtcbnZhciBwcm90byA9ICROdW1iZXIucHJvdG90eXBlO1xuLy8gT3BlcmEgfjEyIGhhcyBicm9rZW4gT2JqZWN0I3RvU3RyaW5nXG52YXIgQlJPS0VOX0NPRiA9IGNvZihyZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJykocHJvdG8pKSA9PSBOVU1CRVI7XG52YXIgVFJJTSA9ICd0cmltJyBpbiBTdHJpbmcucHJvdG90eXBlO1xuXG4vLyA3LjEuMyBUb051bWJlcihhcmd1bWVudClcbnZhciB0b051bWJlciA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICB2YXIgaXQgPSB0b1ByaW1pdGl2ZShhcmd1bWVudCwgZmFsc2UpO1xuICBpZiAodHlwZW9mIGl0ID09ICdzdHJpbmcnICYmIGl0Lmxlbmd0aCA+IDIpIHtcbiAgICBpdCA9IFRSSU0gPyBpdC50cmltKCkgOiAkdHJpbShpdCwgMyk7XG4gICAgdmFyIGZpcnN0ID0gaXQuY2hhckNvZGVBdCgwKTtcbiAgICB2YXIgdGhpcmQsIHJhZGl4LCBtYXhDb2RlO1xuICAgIGlmIChmaXJzdCA9PT0gNDMgfHwgZmlyc3QgPT09IDQ1KSB7XG4gICAgICB0aGlyZCA9IGl0LmNoYXJDb2RlQXQoMik7XG4gICAgICBpZiAodGhpcmQgPT09IDg4IHx8IHRoaXJkID09PSAxMjApIHJldHVybiBOYU47IC8vIE51bWJlcignKzB4MScpIHNob3VsZCBiZSBOYU4sIG9sZCBWOCBmaXhcbiAgICB9IGVsc2UgaWYgKGZpcnN0ID09PSA0OCkge1xuICAgICAgc3dpdGNoIChpdC5jaGFyQ29kZUF0KDEpKSB7XG4gICAgICAgIGNhc2UgNjY6IGNhc2UgOTg6IHJhZGl4ID0gMjsgbWF4Q29kZSA9IDQ5OyBicmVhazsgLy8gZmFzdCBlcXVhbCAvXjBiWzAxXSskL2lcbiAgICAgICAgY2FzZSA3OTogY2FzZSAxMTE6IHJhZGl4ID0gODsgbWF4Q29kZSA9IDU1OyBicmVhazsgLy8gZmFzdCBlcXVhbCAvXjBvWzAtN10rJC9pXG4gICAgICAgIGRlZmF1bHQ6IHJldHVybiAraXQ7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBkaWdpdHMgPSBpdC5zbGljZSgyKSwgaSA9IDAsIGwgPSBkaWdpdHMubGVuZ3RoLCBjb2RlOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGNvZGUgPSBkaWdpdHMuY2hhckNvZGVBdChpKTtcbiAgICAgICAgLy8gcGFyc2VJbnQgcGFyc2VzIGEgc3RyaW5nIHRvIGEgZmlyc3QgdW5hdmFpbGFibGUgc3ltYm9sXG4gICAgICAgIC8vIGJ1dCBUb051bWJlciBzaG91bGQgcmV0dXJuIE5hTiBpZiBhIHN0cmluZyBjb250YWlucyB1bmF2YWlsYWJsZSBzeW1ib2xzXG4gICAgICAgIGlmIChjb2RlIDwgNDggfHwgY29kZSA+IG1heENvZGUpIHJldHVybiBOYU47XG4gICAgICB9IHJldHVybiBwYXJzZUludChkaWdpdHMsIHJhZGl4KTtcbiAgICB9XG4gIH0gcmV0dXJuICtpdDtcbn07XG5cbmlmICghJE51bWJlcignIDBvMScpIHx8ICEkTnVtYmVyKCcwYjEnKSB8fCAkTnVtYmVyKCcrMHgxJykpIHtcbiAgJE51bWJlciA9IGZ1bmN0aW9uIE51bWJlcih2YWx1ZSkge1xuICAgIHZhciBpdCA9IGFyZ3VtZW50cy5sZW5ndGggPCAxID8gMCA6IHZhbHVlO1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICByZXR1cm4gdGhhdCBpbnN0YW5jZW9mICROdW1iZXJcbiAgICAgIC8vIGNoZWNrIG9uIDEuLmNvbnN0cnVjdG9yKGZvbykgY2FzZVxuICAgICAgJiYgKEJST0tFTl9DT0YgPyBmYWlscyhmdW5jdGlvbiAoKSB7IHByb3RvLnZhbHVlT2YuY2FsbCh0aGF0KTsgfSkgOiBjb2YodGhhdCkgIT0gTlVNQkVSKVxuICAgICAgICA/IGluaGVyaXRJZlJlcXVpcmVkKG5ldyBCYXNlKHRvTnVtYmVyKGl0KSksIHRoYXQsICROdW1iZXIpIDogdG9OdW1iZXIoaXQpO1xuICB9O1xuICBmb3IgKHZhciBrZXlzID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IGdPUE4oQmFzZSkgOiAoXG4gICAgLy8gRVMzOlxuICAgICdNQVhfVkFMVUUsTUlOX1ZBTFVFLE5hTixORUdBVElWRV9JTkZJTklUWSxQT1NJVElWRV9JTkZJTklUWSwnICtcbiAgICAvLyBFUzYgKGluIGNhc2UsIGlmIG1vZHVsZXMgd2l0aCBFUzYgTnVtYmVyIHN0YXRpY3MgcmVxdWlyZWQgYmVmb3JlKTpcbiAgICAnRVBTSUxPTixpc0Zpbml0ZSxpc0ludGVnZXIsaXNOYU4saXNTYWZlSW50ZWdlcixNQVhfU0FGRV9JTlRFR0VSLCcgK1xuICAgICdNSU5fU0FGRV9JTlRFR0VSLHBhcnNlRmxvYXQscGFyc2VJbnQsaXNJbnRlZ2VyJ1xuICApLnNwbGl0KCcsJyksIGogPSAwLCBrZXk7IGtleXMubGVuZ3RoID4gajsgaisrKSB7XG4gICAgaWYgKGhhcyhCYXNlLCBrZXkgPSBrZXlzW2pdKSAmJiAhaGFzKCROdW1iZXIsIGtleSkpIHtcbiAgICAgIGRQKCROdW1iZXIsIGtleSwgZ09QRChCYXNlLCBrZXkpKTtcbiAgICB9XG4gIH1cbiAgJE51bWJlci5wcm90b3R5cGUgPSBwcm90bztcbiAgcHJvdG8uY29uc3RydWN0b3IgPSAkTnVtYmVyO1xuICByZXF1aXJlKCcuL19yZWRlZmluZScpKGdsb2JhbCwgTlVNQkVSLCAkTnVtYmVyKTtcbn1cbiIsIi8vIDIwLjEuMi4xIE51bWJlci5FUFNJTE9OXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ051bWJlcicsIHsgRVBTSUxPTjogTWF0aC5wb3coMiwgLTUyKSB9KTtcbiIsIi8vIDIwLjEuMi4yIE51bWJlci5pc0Zpbml0ZShudW1iZXIpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIF9pc0Zpbml0ZSA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLmlzRmluaXRlO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ051bWJlcicsIHtcbiAgaXNGaW5pdGU6IGZ1bmN0aW9uIGlzRmluaXRlKGl0KSB7XG4gICAgcmV0dXJuIHR5cGVvZiBpdCA9PSAnbnVtYmVyJyAmJiBfaXNGaW5pdGUoaXQpO1xuICB9XG59KTtcbiIsIi8vIDIwLjEuMi4zIE51bWJlci5pc0ludGVnZXIobnVtYmVyKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdOdW1iZXInLCB7IGlzSW50ZWdlcjogcmVxdWlyZSgnLi9faXMtaW50ZWdlcicpIH0pO1xuIiwiLy8gMjAuMS4yLjQgTnVtYmVyLmlzTmFOKG51bWJlcilcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTnVtYmVyJywge1xuICBpc05hTjogZnVuY3Rpb24gaXNOYU4obnVtYmVyKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgIHJldHVybiBudW1iZXIgIT0gbnVtYmVyO1xuICB9XG59KTtcbiIsIi8vIDIwLjEuMi41IE51bWJlci5pc1NhZmVJbnRlZ2VyKG51bWJlcilcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgaXNJbnRlZ2VyID0gcmVxdWlyZSgnLi9faXMtaW50ZWdlcicpO1xudmFyIGFicyA9IE1hdGguYWJzO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ051bWJlcicsIHtcbiAgaXNTYWZlSW50ZWdlcjogZnVuY3Rpb24gaXNTYWZlSW50ZWdlcihudW1iZXIpIHtcbiAgICByZXR1cm4gaXNJbnRlZ2VyKG51bWJlcikgJiYgYWJzKG51bWJlcikgPD0gMHgxZmZmZmZmZmZmZmZmZjtcbiAgfVxufSk7XG4iLCIvLyAyMC4xLjIuNiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUlxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdOdW1iZXInLCB7IE1BWF9TQUZFX0lOVEVHRVI6IDB4MWZmZmZmZmZmZmZmZmYgfSk7XG4iLCIvLyAyMC4xLjIuMTAgTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVJcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTnVtYmVyJywgeyBNSU5fU0FGRV9JTlRFR0VSOiAtMHgxZmZmZmZmZmZmZmZmZiB9KTtcbiIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJHBhcnNlRmxvYXQgPSByZXF1aXJlKCcuL19wYXJzZS1mbG9hdCcpO1xuLy8gMjAuMS4yLjEyIE51bWJlci5wYXJzZUZsb2F0KHN0cmluZylcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKE51bWJlci5wYXJzZUZsb2F0ICE9ICRwYXJzZUZsb2F0KSwgJ051bWJlcicsIHsgcGFyc2VGbG9hdDogJHBhcnNlRmxvYXQgfSk7XG4iLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRwYXJzZUludCA9IHJlcXVpcmUoJy4vX3BhcnNlLWludCcpO1xuLy8gMjAuMS4yLjEzIE51bWJlci5wYXJzZUludChzdHJpbmcsIHJhZGl4KVxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoTnVtYmVyLnBhcnNlSW50ICE9ICRwYXJzZUludCksICdOdW1iZXInLCB7IHBhcnNlSW50OiAkcGFyc2VJbnQgfSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcbnZhciBhTnVtYmVyVmFsdWUgPSByZXF1aXJlKCcuL19hLW51bWJlci12YWx1ZScpO1xudmFyIHJlcGVhdCA9IHJlcXVpcmUoJy4vX3N0cmluZy1yZXBlYXQnKTtcbnZhciAkdG9GaXhlZCA9IDEuMC50b0ZpeGVkO1xudmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbnZhciBkYXRhID0gWzAsIDAsIDAsIDAsIDAsIDBdO1xudmFyIEVSUk9SID0gJ051bWJlci50b0ZpeGVkOiBpbmNvcnJlY3QgaW52b2NhdGlvbiEnO1xudmFyIFpFUk8gPSAnMCc7XG5cbnZhciBtdWx0aXBseSA9IGZ1bmN0aW9uIChuLCBjKSB7XG4gIHZhciBpID0gLTE7XG4gIHZhciBjMiA9IGM7XG4gIHdoaWxlICgrK2kgPCA2KSB7XG4gICAgYzIgKz0gbiAqIGRhdGFbaV07XG4gICAgZGF0YVtpXSA9IGMyICUgMWU3O1xuICAgIGMyID0gZmxvb3IoYzIgLyAxZTcpO1xuICB9XG59O1xudmFyIGRpdmlkZSA9IGZ1bmN0aW9uIChuKSB7XG4gIHZhciBpID0gNjtcbiAgdmFyIGMgPSAwO1xuICB3aGlsZSAoLS1pID49IDApIHtcbiAgICBjICs9IGRhdGFbaV07XG4gICAgZGF0YVtpXSA9IGZsb29yKGMgLyBuKTtcbiAgICBjID0gKGMgJSBuKSAqIDFlNztcbiAgfVxufTtcbnZhciBudW1Ub1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGkgPSA2O1xuICB2YXIgcyA9ICcnO1xuICB3aGlsZSAoLS1pID49IDApIHtcbiAgICBpZiAocyAhPT0gJycgfHwgaSA9PT0gMCB8fCBkYXRhW2ldICE9PSAwKSB7XG4gICAgICB2YXIgdCA9IFN0cmluZyhkYXRhW2ldKTtcbiAgICAgIHMgPSBzID09PSAnJyA/IHQgOiBzICsgcmVwZWF0LmNhbGwoWkVSTywgNyAtIHQubGVuZ3RoKSArIHQ7XG4gICAgfVxuICB9IHJldHVybiBzO1xufTtcbnZhciBwb3cgPSBmdW5jdGlvbiAoeCwgbiwgYWNjKSB7XG4gIHJldHVybiBuID09PSAwID8gYWNjIDogbiAlIDIgPT09IDEgPyBwb3coeCwgbiAtIDEsIGFjYyAqIHgpIDogcG93KHggKiB4LCBuIC8gMiwgYWNjKTtcbn07XG52YXIgbG9nID0gZnVuY3Rpb24gKHgpIHtcbiAgdmFyIG4gPSAwO1xuICB2YXIgeDIgPSB4O1xuICB3aGlsZSAoeDIgPj0gNDA5Nikge1xuICAgIG4gKz0gMTI7XG4gICAgeDIgLz0gNDA5NjtcbiAgfVxuICB3aGlsZSAoeDIgPj0gMikge1xuICAgIG4gKz0gMTtcbiAgICB4MiAvPSAyO1xuICB9IHJldHVybiBuO1xufTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoISEkdG9GaXhlZCAmJiAoXG4gIDAuMDAwMDgudG9GaXhlZCgzKSAhPT0gJzAuMDAwJyB8fFxuICAwLjkudG9GaXhlZCgwKSAhPT0gJzEnIHx8XG4gIDEuMjU1LnRvRml4ZWQoMikgIT09ICcxLjI1JyB8fFxuICAxMDAwMDAwMDAwMDAwMDAwMTI4LjAudG9GaXhlZCgwKSAhPT0gJzEwMDAwMDAwMDAwMDAwMDAxMjgnXG4pIHx8ICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgLy8gVjggfiBBbmRyb2lkIDQuMy1cbiAgJHRvRml4ZWQuY2FsbCh7fSk7XG59KSksICdOdW1iZXInLCB7XG4gIHRvRml4ZWQ6IGZ1bmN0aW9uIHRvRml4ZWQoZnJhY3Rpb25EaWdpdHMpIHtcbiAgICB2YXIgeCA9IGFOdW1iZXJWYWx1ZSh0aGlzLCBFUlJPUik7XG4gICAgdmFyIGYgPSB0b0ludGVnZXIoZnJhY3Rpb25EaWdpdHMpO1xuICAgIHZhciBzID0gJyc7XG4gICAgdmFyIG0gPSBaRVJPO1xuICAgIHZhciBlLCB6LCBqLCBrO1xuICAgIGlmIChmIDwgMCB8fCBmID4gMjApIHRocm93IFJhbmdlRXJyb3IoRVJST1IpO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICBpZiAoeCAhPSB4KSByZXR1cm4gJ05hTic7XG4gICAgaWYgKHggPD0gLTFlMjEgfHwgeCA+PSAxZTIxKSByZXR1cm4gU3RyaW5nKHgpO1xuICAgIGlmICh4IDwgMCkge1xuICAgICAgcyA9ICctJztcbiAgICAgIHggPSAteDtcbiAgICB9XG4gICAgaWYgKHggPiAxZS0yMSkge1xuICAgICAgZSA9IGxvZyh4ICogcG93KDIsIDY5LCAxKSkgLSA2OTtcbiAgICAgIHogPSBlIDwgMCA/IHggKiBwb3coMiwgLWUsIDEpIDogeCAvIHBvdygyLCBlLCAxKTtcbiAgICAgIHogKj0gMHgxMDAwMDAwMDAwMDAwMDtcbiAgICAgIGUgPSA1MiAtIGU7XG4gICAgICBpZiAoZSA+IDApIHtcbiAgICAgICAgbXVsdGlwbHkoMCwgeik7XG4gICAgICAgIGogPSBmO1xuICAgICAgICB3aGlsZSAoaiA+PSA3KSB7XG4gICAgICAgICAgbXVsdGlwbHkoMWU3LCAwKTtcbiAgICAgICAgICBqIC09IDc7XG4gICAgICAgIH1cbiAgICAgICAgbXVsdGlwbHkocG93KDEwLCBqLCAxKSwgMCk7XG4gICAgICAgIGogPSBlIC0gMTtcbiAgICAgICAgd2hpbGUgKGogPj0gMjMpIHtcbiAgICAgICAgICBkaXZpZGUoMSA8PCAyMyk7XG4gICAgICAgICAgaiAtPSAyMztcbiAgICAgICAgfVxuICAgICAgICBkaXZpZGUoMSA8PCBqKTtcbiAgICAgICAgbXVsdGlwbHkoMSwgMSk7XG4gICAgICAgIGRpdmlkZSgyKTtcbiAgICAgICAgbSA9IG51bVRvU3RyaW5nKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtdWx0aXBseSgwLCB6KTtcbiAgICAgICAgbXVsdGlwbHkoMSA8PCAtZSwgMCk7XG4gICAgICAgIG0gPSBudW1Ub1N0cmluZygpICsgcmVwZWF0LmNhbGwoWkVSTywgZik7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChmID4gMCkge1xuICAgICAgayA9IG0ubGVuZ3RoO1xuICAgICAgbSA9IHMgKyAoayA8PSBmID8gJzAuJyArIHJlcGVhdC5jYWxsKFpFUk8sIGYgLSBrKSArIG0gOiBtLnNsaWNlKDAsIGsgLSBmKSArICcuJyArIG0uc2xpY2UoayAtIGYpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHMgKyBtO1xuICAgIH0gcmV0dXJuIG07XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xudmFyIGFOdW1iZXJWYWx1ZSA9IHJlcXVpcmUoJy4vX2EtbnVtYmVyLXZhbHVlJyk7XG52YXIgJHRvUHJlY2lzaW9uID0gMS4wLnRvUHJlY2lzaW9uO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqICgkZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvLyBJRTctXG4gIHJldHVybiAkdG9QcmVjaXNpb24uY2FsbCgxLCB1bmRlZmluZWQpICE9PSAnMSc7XG59KSB8fCAhJGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgLy8gVjggfiBBbmRyb2lkIDQuMy1cbiAgJHRvUHJlY2lzaW9uLmNhbGwoe30pO1xufSkpLCAnTnVtYmVyJywge1xuICB0b1ByZWNpc2lvbjogZnVuY3Rpb24gdG9QcmVjaXNpb24ocHJlY2lzaW9uKSB7XG4gICAgdmFyIHRoYXQgPSBhTnVtYmVyVmFsdWUodGhpcywgJ051bWJlciN0b1ByZWNpc2lvbjogaW5jb3JyZWN0IGludm9jYXRpb24hJyk7XG4gICAgcmV0dXJuIHByZWNpc2lvbiA9PT0gdW5kZWZpbmVkID8gJHRvUHJlY2lzaW9uLmNhbGwodGhhdCkgOiAkdG9QcmVjaXNpb24uY2FsbCh0aGF0LCBwcmVjaXNpb24pO1xuICB9XG59KTtcbiIsIi8vIDE5LjEuMy4xIE9iamVjdC5hc3NpZ24odGFyZ2V0LCBzb3VyY2UpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiwgJ09iamVjdCcsIHsgYXNzaWduOiByZXF1aXJlKCcuL19vYmplY3QtYXNzaWduJykgfSk7XG4iLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuLy8gMTkuMS4yLjIgLyAxNS4yLjMuNSBPYmplY3QuY3JlYXRlKE8gWywgUHJvcGVydGllc10pXG4kZXhwb3J0KCRleHBvcnQuUywgJ09iamVjdCcsIHsgY3JlYXRlOiByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJykgfSk7XG4iLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuLy8gMTkuMS4yLjMgLyAxNS4yLjMuNyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKVxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSwgJ09iamVjdCcsIHsgZGVmaW5lUHJvcGVydGllczogcmVxdWlyZSgnLi9fb2JqZWN0LWRwcycpIH0pO1xuIiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbi8vIDE5LjEuMi40IC8gMTUuMi4zLjYgT2JqZWN0LmRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpLCAnT2JqZWN0JywgeyBkZWZpbmVQcm9wZXJ0eTogcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZiB9KTtcbiIsIi8vIDE5LjEuMi41IE9iamVjdC5mcmVlemUoTylcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIG1ldGEgPSByZXF1aXJlKCcuL19tZXRhJykub25GcmVlemU7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgnZnJlZXplJywgZnVuY3Rpb24gKCRmcmVlemUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGZyZWV6ZShpdCkge1xuICAgIHJldHVybiAkZnJlZXplICYmIGlzT2JqZWN0KGl0KSA/ICRmcmVlemUobWV0YShpdCkpIDogaXQ7XG4gIH07XG59KTtcbiIsIi8vIDE5LjEuMi42IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUClcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgJGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJykuZjtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3InLCBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSkge1xuICAgIHJldHVybiAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRvSU9iamVjdChpdCksIGtleSk7XG4gIH07XG59KTtcbiIsIi8vIDE5LjEuMi43IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE8pXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2dldE93blByb3BlcnR5TmFtZXMnLCBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiByZXF1aXJlKCcuL19vYmplY3QtZ29wbi1leHQnKS5mO1xufSk7XG4iLCIvLyAxOS4xLjIuOSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTylcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyICRnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKTtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdnZXRQcm90b3R5cGVPZicsIGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGdldFByb3RvdHlwZU9mKGl0KSB7XG4gICAgcmV0dXJuICRnZXRQcm90b3R5cGVPZih0b09iamVjdChpdCkpO1xuICB9O1xufSk7XG4iLCIvLyAxOS4xLjIuMTEgT2JqZWN0LmlzRXh0ZW5zaWJsZShPKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgnaXNFeHRlbnNpYmxlJywgZnVuY3Rpb24gKCRpc0V4dGVuc2libGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGlzRXh0ZW5zaWJsZShpdCkge1xuICAgIHJldHVybiBpc09iamVjdChpdCkgPyAkaXNFeHRlbnNpYmxlID8gJGlzRXh0ZW5zaWJsZShpdCkgOiB0cnVlIDogZmFsc2U7XG4gIH07XG59KTtcbiIsIi8vIDE5LjEuMi4xMiBPYmplY3QuaXNGcm96ZW4oTylcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2lzRnJvemVuJywgZnVuY3Rpb24gKCRpc0Zyb3plbikge1xuICByZXR1cm4gZnVuY3Rpb24gaXNGcm96ZW4oaXQpIHtcbiAgICByZXR1cm4gaXNPYmplY3QoaXQpID8gJGlzRnJvemVuID8gJGlzRnJvemVuKGl0KSA6IGZhbHNlIDogdHJ1ZTtcbiAgfTtcbn0pO1xuIiwiLy8gMTkuMS4yLjEzIE9iamVjdC5pc1NlYWxlZChPKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgnaXNTZWFsZWQnLCBmdW5jdGlvbiAoJGlzU2VhbGVkKSB7XG4gIHJldHVybiBmdW5jdGlvbiBpc1NlYWxlZChpdCkge1xuICAgIHJldHVybiBpc09iamVjdChpdCkgPyAkaXNTZWFsZWQgPyAkaXNTZWFsZWQoaXQpIDogZmFsc2UgOiB0cnVlO1xuICB9O1xufSk7XG4iLCIvLyAxOS4xLjMuMTAgT2JqZWN0LmlzKHZhbHVlMSwgdmFsdWUyKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbiRleHBvcnQoJGV4cG9ydC5TLCAnT2JqZWN0JywgeyBpczogcmVxdWlyZSgnLi9fc2FtZS12YWx1ZScpIH0pO1xuIiwiLy8gMTkuMS4yLjE0IE9iamVjdC5rZXlzKE8pXG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciAka2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgna2V5cycsIGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGtleXMoaXQpIHtcbiAgICByZXR1cm4gJGtleXModG9PYmplY3QoaXQpKTtcbiAgfTtcbn0pO1xuIiwiLy8gMTkuMS4yLjE1IE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyhPKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgbWV0YSA9IHJlcXVpcmUoJy4vX21ldGEnKS5vbkZyZWV6ZTtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdwcmV2ZW50RXh0ZW5zaW9ucycsIGZ1bmN0aW9uICgkcHJldmVudEV4dGVuc2lvbnMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHByZXZlbnRFeHRlbnNpb25zKGl0KSB7XG4gICAgcmV0dXJuICRwcmV2ZW50RXh0ZW5zaW9ucyAmJiBpc09iamVjdChpdCkgPyAkcHJldmVudEV4dGVuc2lvbnMobWV0YShpdCkpIDogaXQ7XG4gIH07XG59KTtcbiIsIi8vIDE5LjEuMi4xNyBPYmplY3Quc2VhbChPKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgbWV0YSA9IHJlcXVpcmUoJy4vX21ldGEnKS5vbkZyZWV6ZTtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdzZWFsJywgZnVuY3Rpb24gKCRzZWFsKSB7XG4gIHJldHVybiBmdW5jdGlvbiBzZWFsKGl0KSB7XG4gICAgcmV0dXJuICRzZWFsICYmIGlzT2JqZWN0KGl0KSA/ICRzZWFsKG1ldGEoaXQpKSA6IGl0O1xuICB9O1xufSk7XG4iLCIvLyAxOS4xLjMuMTkgT2JqZWN0LnNldFByb3RvdHlwZU9mKE8sIHByb3RvKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbiRleHBvcnQoJGV4cG9ydC5TLCAnT2JqZWN0JywgeyBzZXRQcm90b3R5cGVPZjogcmVxdWlyZSgnLi9fc2V0LXByb3RvJykuc2V0IH0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gMTkuMS4zLjYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZygpXG52YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4vX2NsYXNzb2YnKTtcbnZhciB0ZXN0ID0ge307XG50ZXN0W3JlcXVpcmUoJy4vX3drcycpKCd0b1N0cmluZ1RhZycpXSA9ICd6JztcbmlmICh0ZXN0ICsgJycgIT0gJ1tvYmplY3Qgel0nKSB7XG4gIHJlcXVpcmUoJy4vX3JlZGVmaW5lJykoT2JqZWN0LnByb3RvdHlwZSwgJ3RvU3RyaW5nJywgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuICdbb2JqZWN0ICcgKyBjbGFzc29mKHRoaXMpICsgJ10nO1xuICB9LCB0cnVlKTtcbn1cbiIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJHBhcnNlRmxvYXQgPSByZXF1aXJlKCcuL19wYXJzZS1mbG9hdCcpO1xuLy8gMTguMi40IHBhcnNlRmxvYXQoc3RyaW5nKVxuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LkYgKiAocGFyc2VGbG9hdCAhPSAkcGFyc2VGbG9hdCksIHsgcGFyc2VGbG9hdDogJHBhcnNlRmxvYXQgfSk7XG4iLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRwYXJzZUludCA9IHJlcXVpcmUoJy4vX3BhcnNlLWludCcpO1xuLy8gMTguMi41IHBhcnNlSW50KHN0cmluZywgcmFkaXgpXG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuRiAqIChwYXJzZUludCAhPSAkcGFyc2VJbnQpLCB7IHBhcnNlSW50OiAkcGFyc2VJbnQgfSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgTElCUkFSWSA9IHJlcXVpcmUoJy4vX2xpYnJhcnknKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciBjbGFzc29mID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcbnZhciBhbkluc3RhbmNlID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKTtcbnZhciBmb3JPZiA9IHJlcXVpcmUoJy4vX2Zvci1vZicpO1xudmFyIHNwZWNpZXNDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4vX3NwZWNpZXMtY29uc3RydWN0b3InKTtcbnZhciB0YXNrID0gcmVxdWlyZSgnLi9fdGFzaycpLnNldDtcbnZhciBtaWNyb3Rhc2sgPSByZXF1aXJlKCcuL19taWNyb3Rhc2snKSgpO1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlID0gcmVxdWlyZSgnLi9fbmV3LXByb21pc2UtY2FwYWJpbGl0eScpO1xudmFyIHBlcmZvcm0gPSByZXF1aXJlKCcuL19wZXJmb3JtJyk7XG52YXIgcHJvbWlzZVJlc29sdmUgPSByZXF1aXJlKCcuL19wcm9taXNlLXJlc29sdmUnKTtcbnZhciBQUk9NSVNFID0gJ1Byb21pc2UnO1xudmFyIFR5cGVFcnJvciA9IGdsb2JhbC5UeXBlRXJyb3I7XG52YXIgcHJvY2VzcyA9IGdsb2JhbC5wcm9jZXNzO1xudmFyICRQcm9taXNlID0gZ2xvYmFsW1BST01JU0VdO1xudmFyIGlzTm9kZSA9IGNsYXNzb2YocHJvY2VzcykgPT0gJ3Byb2Nlc3MnO1xudmFyIGVtcHR5ID0gZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9O1xudmFyIEludGVybmFsLCBuZXdHZW5lcmljUHJvbWlzZUNhcGFiaWxpdHksIE93blByb21pc2VDYXBhYmlsaXR5LCBXcmFwcGVyO1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5ID0gbmV3R2VuZXJpY1Byb21pc2VDYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUuZjtcblxudmFyIFVTRV9OQVRJVkUgPSAhIWZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICAvLyBjb3JyZWN0IHN1YmNsYXNzaW5nIHdpdGggQEBzcGVjaWVzIHN1cHBvcnRcbiAgICB2YXIgcHJvbWlzZSA9ICRQcm9taXNlLnJlc29sdmUoMSk7XG4gICAgdmFyIEZha2VQcm9taXNlID0gKHByb21pc2UuY29uc3RydWN0b3IgPSB7fSlbcmVxdWlyZSgnLi9fd2tzJykoJ3NwZWNpZXMnKV0gPSBmdW5jdGlvbiAoZXhlYykge1xuICAgICAgZXhlYyhlbXB0eSwgZW1wdHkpO1xuICAgIH07XG4gICAgLy8gdW5oYW5kbGVkIHJlamVjdGlvbnMgdHJhY2tpbmcgc3VwcG9ydCwgTm9kZUpTIFByb21pc2Ugd2l0aG91dCBpdCBmYWlscyBAQHNwZWNpZXMgdGVzdFxuICAgIHJldHVybiAoaXNOb2RlIHx8IHR5cGVvZiBQcm9taXNlUmVqZWN0aW9uRXZlbnQgPT0gJ2Z1bmN0aW9uJykgJiYgcHJvbWlzZS50aGVuKGVtcHR5KSBpbnN0YW5jZW9mIEZha2VQcm9taXNlO1xuICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cbn0oKTtcblxuLy8gaGVscGVyc1xudmFyIGlzVGhlbmFibGUgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIHRoZW47XG4gIHJldHVybiBpc09iamVjdChpdCkgJiYgdHlwZW9mICh0aGVuID0gaXQudGhlbikgPT0gJ2Z1bmN0aW9uJyA/IHRoZW4gOiBmYWxzZTtcbn07XG52YXIgbm90aWZ5ID0gZnVuY3Rpb24gKHByb21pc2UsIGlzUmVqZWN0KSB7XG4gIGlmIChwcm9taXNlLl9uKSByZXR1cm47XG4gIHByb21pc2UuX24gPSB0cnVlO1xuICB2YXIgY2hhaW4gPSBwcm9taXNlLl9jO1xuICBtaWNyb3Rhc2soZnVuY3Rpb24gKCkge1xuICAgIHZhciB2YWx1ZSA9IHByb21pc2UuX3Y7XG4gICAgdmFyIG9rID0gcHJvbWlzZS5fcyA9PSAxO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgcnVuID0gZnVuY3Rpb24gKHJlYWN0aW9uKSB7XG4gICAgICB2YXIgaGFuZGxlciA9IG9rID8gcmVhY3Rpb24ub2sgOiByZWFjdGlvbi5mYWlsO1xuICAgICAgdmFyIHJlc29sdmUgPSByZWFjdGlvbi5yZXNvbHZlO1xuICAgICAgdmFyIHJlamVjdCA9IHJlYWN0aW9uLnJlamVjdDtcbiAgICAgIHZhciBkb21haW4gPSByZWFjdGlvbi5kb21haW47XG4gICAgICB2YXIgcmVzdWx0LCB0aGVuO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgICBpZiAoIW9rKSB7XG4gICAgICAgICAgICBpZiAocHJvbWlzZS5faCA9PSAyKSBvbkhhbmRsZVVuaGFuZGxlZChwcm9taXNlKTtcbiAgICAgICAgICAgIHByb21pc2UuX2ggPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaGFuZGxlciA9PT0gdHJ1ZSkgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoZG9tYWluKSBkb21haW4uZW50ZXIoKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IGhhbmRsZXIodmFsdWUpO1xuICAgICAgICAgICAgaWYgKGRvbWFpbikgZG9tYWluLmV4aXQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gcmVhY3Rpb24ucHJvbWlzZSkge1xuICAgICAgICAgICAgcmVqZWN0KFR5cGVFcnJvcignUHJvbWlzZS1jaGFpbiBjeWNsZScpKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoZW4gPSBpc1RoZW5hYmxlKHJlc3VsdCkpIHtcbiAgICAgICAgICAgIHRoZW4uY2FsbChyZXN1bHQsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSBlbHNlIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSBlbHNlIHJlamVjdCh2YWx1ZSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHdoaWxlIChjaGFpbi5sZW5ndGggPiBpKSBydW4oY2hhaW5baSsrXSk7IC8vIHZhcmlhYmxlIGxlbmd0aCAtIGNhbid0IHVzZSBmb3JFYWNoXG4gICAgcHJvbWlzZS5fYyA9IFtdO1xuICAgIHByb21pc2UuX24gPSBmYWxzZTtcbiAgICBpZiAoaXNSZWplY3QgJiYgIXByb21pc2UuX2gpIG9uVW5oYW5kbGVkKHByb21pc2UpO1xuICB9KTtcbn07XG52YXIgb25VbmhhbmRsZWQgPSBmdW5jdGlvbiAocHJvbWlzZSkge1xuICB0YXNrLmNhbGwoZ2xvYmFsLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZhbHVlID0gcHJvbWlzZS5fdjtcbiAgICB2YXIgdW5oYW5kbGVkID0gaXNVbmhhbmRsZWQocHJvbWlzZSk7XG4gICAgdmFyIHJlc3VsdCwgaGFuZGxlciwgY29uc29sZTtcbiAgICBpZiAodW5oYW5kbGVkKSB7XG4gICAgICByZXN1bHQgPSBwZXJmb3JtKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGlzTm9kZSkge1xuICAgICAgICAgIHByb2Nlc3MuZW1pdCgndW5oYW5kbGVkUmVqZWN0aW9uJywgdmFsdWUsIHByb21pc2UpO1xuICAgICAgICB9IGVsc2UgaWYgKGhhbmRsZXIgPSBnbG9iYWwub251bmhhbmRsZWRyZWplY3Rpb24pIHtcbiAgICAgICAgICBoYW5kbGVyKHsgcHJvbWlzZTogcHJvbWlzZSwgcmVhc29uOiB2YWx1ZSB9KTtcbiAgICAgICAgfSBlbHNlIGlmICgoY29uc29sZSA9IGdsb2JhbC5jb25zb2xlKSAmJiBjb25zb2xlLmVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignVW5oYW5kbGVkIHByb21pc2UgcmVqZWN0aW9uJywgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIC8vIEJyb3dzZXJzIHNob3VsZCBub3QgdHJpZ2dlciBgcmVqZWN0aW9uSGFuZGxlZGAgZXZlbnQgaWYgaXQgd2FzIGhhbmRsZWQgaGVyZSwgTm9kZUpTIC0gc2hvdWxkXG4gICAgICBwcm9taXNlLl9oID0gaXNOb2RlIHx8IGlzVW5oYW5kbGVkKHByb21pc2UpID8gMiA6IDE7XG4gICAgfSBwcm9taXNlLl9hID0gdW5kZWZpbmVkO1xuICAgIGlmICh1bmhhbmRsZWQgJiYgcmVzdWx0LmUpIHRocm93IHJlc3VsdC52O1xuICB9KTtcbn07XG52YXIgaXNVbmhhbmRsZWQgPSBmdW5jdGlvbiAocHJvbWlzZSkge1xuICBpZiAocHJvbWlzZS5faCA9PSAxKSByZXR1cm4gZmFsc2U7XG4gIHZhciBjaGFpbiA9IHByb21pc2UuX2EgfHwgcHJvbWlzZS5fYztcbiAgdmFyIGkgPSAwO1xuICB2YXIgcmVhY3Rpb247XG4gIHdoaWxlIChjaGFpbi5sZW5ndGggPiBpKSB7XG4gICAgcmVhY3Rpb24gPSBjaGFpbltpKytdO1xuICAgIGlmIChyZWFjdGlvbi5mYWlsIHx8ICFpc1VuaGFuZGxlZChyZWFjdGlvbi5wcm9taXNlKSkgcmV0dXJuIGZhbHNlO1xuICB9IHJldHVybiB0cnVlO1xufTtcbnZhciBvbkhhbmRsZVVuaGFuZGxlZCA9IGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gIHRhc2suY2FsbChnbG9iYWwsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaGFuZGxlcjtcbiAgICBpZiAoaXNOb2RlKSB7XG4gICAgICBwcm9jZXNzLmVtaXQoJ3JlamVjdGlvbkhhbmRsZWQnLCBwcm9taXNlKTtcbiAgICB9IGVsc2UgaWYgKGhhbmRsZXIgPSBnbG9iYWwub25yZWplY3Rpb25oYW5kbGVkKSB7XG4gICAgICBoYW5kbGVyKHsgcHJvbWlzZTogcHJvbWlzZSwgcmVhc29uOiBwcm9taXNlLl92IH0pO1xuICAgIH1cbiAgfSk7XG59O1xudmFyICRyZWplY3QgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgdmFyIHByb21pc2UgPSB0aGlzO1xuICBpZiAocHJvbWlzZS5fZCkgcmV0dXJuO1xuICBwcm9taXNlLl9kID0gdHJ1ZTtcbiAgcHJvbWlzZSA9IHByb21pc2UuX3cgfHwgcHJvbWlzZTsgLy8gdW53cmFwXG4gIHByb21pc2UuX3YgPSB2YWx1ZTtcbiAgcHJvbWlzZS5fcyA9IDI7XG4gIGlmICghcHJvbWlzZS5fYSkgcHJvbWlzZS5fYSA9IHByb21pc2UuX2Muc2xpY2UoKTtcbiAgbm90aWZ5KHByb21pc2UsIHRydWUpO1xufTtcbnZhciAkcmVzb2x2ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICB2YXIgcHJvbWlzZSA9IHRoaXM7XG4gIHZhciB0aGVuO1xuICBpZiAocHJvbWlzZS5fZCkgcmV0dXJuO1xuICBwcm9taXNlLl9kID0gdHJ1ZTtcbiAgcHJvbWlzZSA9IHByb21pc2UuX3cgfHwgcHJvbWlzZTsgLy8gdW53cmFwXG4gIHRyeSB7XG4gICAgaWYgKHByb21pc2UgPT09IHZhbHVlKSB0aHJvdyBUeXBlRXJyb3IoXCJQcm9taXNlIGNhbid0IGJlIHJlc29sdmVkIGl0c2VsZlwiKTtcbiAgICBpZiAodGhlbiA9IGlzVGhlbmFibGUodmFsdWUpKSB7XG4gICAgICBtaWNyb3Rhc2soZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgd3JhcHBlciA9IHsgX3c6IHByb21pc2UsIF9kOiBmYWxzZSB9OyAvLyB3cmFwXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhlbi5jYWxsKHZhbHVlLCBjdHgoJHJlc29sdmUsIHdyYXBwZXIsIDEpLCBjdHgoJHJlamVjdCwgd3JhcHBlciwgMSkpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgJHJlamVjdC5jYWxsKHdyYXBwZXIsIGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvbWlzZS5fdiA9IHZhbHVlO1xuICAgICAgcHJvbWlzZS5fcyA9IDE7XG4gICAgICBub3RpZnkocHJvbWlzZSwgZmFsc2UpO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgICRyZWplY3QuY2FsbCh7IF93OiBwcm9taXNlLCBfZDogZmFsc2UgfSwgZSk7IC8vIHdyYXBcbiAgfVxufTtcblxuLy8gY29uc3RydWN0b3IgcG9seWZpbGxcbmlmICghVVNFX05BVElWRSkge1xuICAvLyAyNS40LjMuMSBQcm9taXNlKGV4ZWN1dG9yKVxuICAkUHJvbWlzZSA9IGZ1bmN0aW9uIFByb21pc2UoZXhlY3V0b3IpIHtcbiAgICBhbkluc3RhbmNlKHRoaXMsICRQcm9taXNlLCBQUk9NSVNFLCAnX2gnKTtcbiAgICBhRnVuY3Rpb24oZXhlY3V0b3IpO1xuICAgIEludGVybmFsLmNhbGwodGhpcyk7XG4gICAgdHJ5IHtcbiAgICAgIGV4ZWN1dG9yKGN0eCgkcmVzb2x2ZSwgdGhpcywgMSksIGN0eCgkcmVqZWN0LCB0aGlzLCAxKSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAkcmVqZWN0LmNhbGwodGhpcywgZXJyKTtcbiAgICB9XG4gIH07XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuICBJbnRlcm5hbCA9IGZ1bmN0aW9uIFByb21pc2UoZXhlY3V0b3IpIHtcbiAgICB0aGlzLl9jID0gW107ICAgICAgICAgICAgIC8vIDwtIGF3YWl0aW5nIHJlYWN0aW9uc1xuICAgIHRoaXMuX2EgPSB1bmRlZmluZWQ7ICAgICAgLy8gPC0gY2hlY2tlZCBpbiBpc1VuaGFuZGxlZCByZWFjdGlvbnNcbiAgICB0aGlzLl9zID0gMDsgICAgICAgICAgICAgIC8vIDwtIHN0YXRlXG4gICAgdGhpcy5fZCA9IGZhbHNlOyAgICAgICAgICAvLyA8LSBkb25lXG4gICAgdGhpcy5fdiA9IHVuZGVmaW5lZDsgICAgICAvLyA8LSB2YWx1ZVxuICAgIHRoaXMuX2ggPSAwOyAgICAgICAgICAgICAgLy8gPC0gcmVqZWN0aW9uIHN0YXRlLCAwIC0gZGVmYXVsdCwgMSAtIGhhbmRsZWQsIDIgLSB1bmhhbmRsZWRcbiAgICB0aGlzLl9uID0gZmFsc2U7ICAgICAgICAgIC8vIDwtIG5vdGlmeVxuICB9O1xuICBJbnRlcm5hbC5wcm90b3R5cGUgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKSgkUHJvbWlzZS5wcm90b3R5cGUsIHtcbiAgICAvLyAyNS40LjUuMyBQcm9taXNlLnByb3RvdHlwZS50aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKVxuICAgIHRoZW46IGZ1bmN0aW9uIHRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgICAgIHZhciByZWFjdGlvbiA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KHNwZWNpZXNDb25zdHJ1Y3Rvcih0aGlzLCAkUHJvbWlzZSkpO1xuICAgICAgcmVhY3Rpb24ub2sgPSB0eXBlb2Ygb25GdWxmaWxsZWQgPT0gJ2Z1bmN0aW9uJyA/IG9uRnVsZmlsbGVkIDogdHJ1ZTtcbiAgICAgIHJlYWN0aW9uLmZhaWwgPSB0eXBlb2Ygb25SZWplY3RlZCA9PSAnZnVuY3Rpb24nICYmIG9uUmVqZWN0ZWQ7XG4gICAgICByZWFjdGlvbi5kb21haW4gPSBpc05vZGUgPyBwcm9jZXNzLmRvbWFpbiA6IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuX2MucHVzaChyZWFjdGlvbik7XG4gICAgICBpZiAodGhpcy5fYSkgdGhpcy5fYS5wdXNoKHJlYWN0aW9uKTtcbiAgICAgIGlmICh0aGlzLl9zKSBub3RpZnkodGhpcywgZmFsc2UpO1xuICAgICAgcmV0dXJuIHJlYWN0aW9uLnByb21pc2U7XG4gICAgfSxcbiAgICAvLyAyNS40LjUuMSBQcm9taXNlLnByb3RvdHlwZS5jYXRjaChvblJlamVjdGVkKVxuICAgICdjYXRjaCc6IGZ1bmN0aW9uIChvblJlamVjdGVkKSB7XG4gICAgICByZXR1cm4gdGhpcy50aGVuKHVuZGVmaW5lZCwgb25SZWplY3RlZCk7XG4gICAgfVxuICB9KTtcbiAgT3duUHJvbWlzZUNhcGFiaWxpdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHByb21pc2UgPSBuZXcgSW50ZXJuYWwoKTtcbiAgICB0aGlzLnByb21pc2UgPSBwcm9taXNlO1xuICAgIHRoaXMucmVzb2x2ZSA9IGN0eCgkcmVzb2x2ZSwgcHJvbWlzZSwgMSk7XG4gICAgdGhpcy5yZWplY3QgPSBjdHgoJHJlamVjdCwgcHJvbWlzZSwgMSk7XG4gIH07XG4gIG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlLmYgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eSA9IGZ1bmN0aW9uIChDKSB7XG4gICAgcmV0dXJuIEMgPT09ICRQcm9taXNlIHx8IEMgPT09IFdyYXBwZXJcbiAgICAgID8gbmV3IE93blByb21pc2VDYXBhYmlsaXR5KEMpXG4gICAgICA6IG5ld0dlbmVyaWNQcm9taXNlQ2FwYWJpbGl0eShDKTtcbiAgfTtcbn1cblxuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgeyBQcm9taXNlOiAkUHJvbWlzZSB9KTtcbnJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJykoJFByb21pc2UsIFBST01JU0UpO1xucmVxdWlyZSgnLi9fc2V0LXNwZWNpZXMnKShQUk9NSVNFKTtcbldyYXBwZXIgPSByZXF1aXJlKCcuL19jb3JlJylbUFJPTUlTRV07XG5cbi8vIHN0YXRpY3NcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsIFBST01JU0UsIHtcbiAgLy8gMjUuNC40LjUgUHJvbWlzZS5yZWplY3QocilcbiAgcmVqZWN0OiBmdW5jdGlvbiByZWplY3Qocikge1xuICAgIHZhciBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkodGhpcyk7XG4gICAgdmFyICQkcmVqZWN0ID0gY2FwYWJpbGl0eS5yZWplY3Q7XG4gICAgJCRyZWplY3Qocik7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxufSk7XG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIChMSUJSQVJZIHx8ICFVU0VfTkFUSVZFKSwgUFJPTUlTRSwge1xuICAvLyAyNS40LjQuNiBQcm9taXNlLnJlc29sdmUoeClcbiAgcmVzb2x2ZTogZnVuY3Rpb24gcmVzb2x2ZSh4KSB7XG4gICAgcmV0dXJuIHByb21pc2VSZXNvbHZlKExJQlJBUlkgJiYgdGhpcyA9PT0gV3JhcHBlciA/ICRQcm9taXNlIDogdGhpcywgeCk7XG4gIH1cbn0pO1xuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhKFVTRV9OQVRJVkUgJiYgcmVxdWlyZSgnLi9faXRlci1kZXRlY3QnKShmdW5jdGlvbiAoaXRlcikge1xuICAkUHJvbWlzZS5hbGwoaXRlcilbJ2NhdGNoJ10oZW1wdHkpO1xufSkpLCBQUk9NSVNFLCB7XG4gIC8vIDI1LjQuNC4xIFByb21pc2UuYWxsKGl0ZXJhYmxlKVxuICBhbGw6IGZ1bmN0aW9uIGFsbChpdGVyYWJsZSkge1xuICAgIHZhciBDID0gdGhpcztcbiAgICB2YXIgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KEMpO1xuICAgIHZhciByZXNvbHZlID0gY2FwYWJpbGl0eS5yZXNvbHZlO1xuICAgIHZhciByZWplY3QgPSBjYXBhYmlsaXR5LnJlamVjdDtcbiAgICB2YXIgcmVzdWx0ID0gcGVyZm9ybShmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdmFsdWVzID0gW107XG4gICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgdmFyIHJlbWFpbmluZyA9IDE7XG4gICAgICBmb3JPZihpdGVyYWJsZSwgZmFsc2UsIGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gICAgICAgIHZhciAkaW5kZXggPSBpbmRleCsrO1xuICAgICAgICB2YXIgYWxyZWFkeUNhbGxlZCA9IGZhbHNlO1xuICAgICAgICB2YWx1ZXMucHVzaCh1bmRlZmluZWQpO1xuICAgICAgICByZW1haW5pbmcrKztcbiAgICAgICAgQy5yZXNvbHZlKHByb21pc2UpLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgaWYgKGFscmVhZHlDYWxsZWQpIHJldHVybjtcbiAgICAgICAgICBhbHJlYWR5Q2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICB2YWx1ZXNbJGluZGV4XSA9IHZhbHVlO1xuICAgICAgICAgIC0tcmVtYWluaW5nIHx8IHJlc29sdmUodmFsdWVzKTtcbiAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgIH0pO1xuICAgICAgLS1yZW1haW5pbmcgfHwgcmVzb2x2ZSh2YWx1ZXMpO1xuICAgIH0pO1xuICAgIGlmIChyZXN1bHQuZSkgcmVqZWN0KHJlc3VsdC52KTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9LFxuICAvLyAyNS40LjQuNCBQcm9taXNlLnJhY2UoaXRlcmFibGUpXG4gIHJhY2U6IGZ1bmN0aW9uIHJhY2UoaXRlcmFibGUpIHtcbiAgICB2YXIgQyA9IHRoaXM7XG4gICAgdmFyIGNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eShDKTtcbiAgICB2YXIgcmVqZWN0ID0gY2FwYWJpbGl0eS5yZWplY3Q7XG4gICAgdmFyIHJlc3VsdCA9IHBlcmZvcm0oZnVuY3Rpb24gKCkge1xuICAgICAgZm9yT2YoaXRlcmFibGUsIGZhbHNlLCBmdW5jdGlvbiAocHJvbWlzZSkge1xuICAgICAgICBDLnJlc29sdmUocHJvbWlzZSkudGhlbihjYXBhYmlsaXR5LnJlc29sdmUsIHJlamVjdCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBpZiAocmVzdWx0LmUpIHJlamVjdChyZXN1bHQudik7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxufSk7XG4iLCIvLyAyNi4xLjEgUmVmbGVjdC5hcHBseSh0YXJnZXQsIHRoaXNBcmd1bWVudCwgYXJndW1lbnRzTGlzdClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgckFwcGx5ID0gKHJlcXVpcmUoJy4vX2dsb2JhbCcpLlJlZmxlY3QgfHwge30pLmFwcGx5O1xudmFyIGZBcHBseSA9IEZ1bmN0aW9uLmFwcGx5O1xuLy8gTVMgRWRnZSBhcmd1bWVudHNMaXN0IGFyZ3VtZW50IGlzIG9wdGlvbmFsXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgckFwcGx5KGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSk7XG59KSwgJ1JlZmxlY3QnLCB7XG4gIGFwcGx5OiBmdW5jdGlvbiBhcHBseSh0YXJnZXQsIHRoaXNBcmd1bWVudCwgYXJndW1lbnRzTGlzdCkge1xuICAgIHZhciBUID0gYUZ1bmN0aW9uKHRhcmdldCk7XG4gICAgdmFyIEwgPSBhbk9iamVjdChhcmd1bWVudHNMaXN0KTtcbiAgICByZXR1cm4gckFwcGx5ID8gckFwcGx5KFQsIHRoaXNBcmd1bWVudCwgTCkgOiBmQXBwbHkuY2FsbChULCB0aGlzQXJndW1lbnQsIEwpO1xuICB9XG59KTtcbiIsIi8vIDI2LjEuMiBSZWZsZWN0LmNvbnN0cnVjdCh0YXJnZXQsIGFyZ3VtZW50c0xpc3QgWywgbmV3VGFyZ2V0XSlcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgY3JlYXRlID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpO1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xudmFyIGJpbmQgPSByZXF1aXJlKCcuL19iaW5kJyk7XG52YXIgckNvbnN0cnVjdCA9IChyZXF1aXJlKCcuL19nbG9iYWwnKS5SZWZsZWN0IHx8IHt9KS5jb25zdHJ1Y3Q7XG5cbi8vIE1TIEVkZ2Ugc3VwcG9ydHMgb25seSAyIGFyZ3VtZW50cyBhbmQgYXJndW1lbnRzTGlzdCBhcmd1bWVudCBpcyBvcHRpb25hbFxuLy8gRkYgTmlnaHRseSBzZXRzIHRoaXJkIGFyZ3VtZW50IGFzIGBuZXcudGFyZ2V0YCwgYnV0IGRvZXMgbm90IGNyZWF0ZSBgdGhpc2AgZnJvbSBpdFxudmFyIE5FV19UQVJHRVRfQlVHID0gZmFpbHMoZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBGKCkgeyAvKiBlbXB0eSAqLyB9XG4gIHJldHVybiAhKHJDb25zdHJ1Y3QoZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9LCBbXSwgRikgaW5zdGFuY2VvZiBGKTtcbn0pO1xudmFyIEFSR1NfQlVHID0gIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgckNvbnN0cnVjdChmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH0pO1xufSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKE5FV19UQVJHRVRfQlVHIHx8IEFSR1NfQlVHKSwgJ1JlZmxlY3QnLCB7XG4gIGNvbnN0cnVjdDogZnVuY3Rpb24gY29uc3RydWN0KFRhcmdldCwgYXJncyAvKiAsIG5ld1RhcmdldCAqLykge1xuICAgIGFGdW5jdGlvbihUYXJnZXQpO1xuICAgIGFuT2JqZWN0KGFyZ3MpO1xuICAgIHZhciBuZXdUYXJnZXQgPSBhcmd1bWVudHMubGVuZ3RoIDwgMyA/IFRhcmdldCA6IGFGdW5jdGlvbihhcmd1bWVudHNbMl0pO1xuICAgIGlmIChBUkdTX0JVRyAmJiAhTkVXX1RBUkdFVF9CVUcpIHJldHVybiByQ29uc3RydWN0KFRhcmdldCwgYXJncywgbmV3VGFyZ2V0KTtcbiAgICBpZiAoVGFyZ2V0ID09IG5ld1RhcmdldCkge1xuICAgICAgLy8gdy9vIGFsdGVyZWQgbmV3VGFyZ2V0LCBvcHRpbWl6YXRpb24gZm9yIDAtNCBhcmd1bWVudHNcbiAgICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAwOiByZXR1cm4gbmV3IFRhcmdldCgpO1xuICAgICAgICBjYXNlIDE6IHJldHVybiBuZXcgVGFyZ2V0KGFyZ3NbMF0pO1xuICAgICAgICBjYXNlIDI6IHJldHVybiBuZXcgVGFyZ2V0KGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICBjYXNlIDM6IHJldHVybiBuZXcgVGFyZ2V0KGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgICBjYXNlIDQ6IHJldHVybiBuZXcgVGFyZ2V0KGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pO1xuICAgICAgfVxuICAgICAgLy8gdy9vIGFsdGVyZWQgbmV3VGFyZ2V0LCBsb3Qgb2YgYXJndW1lbnRzIGNhc2VcbiAgICAgIHZhciAkYXJncyA9IFtudWxsXTtcbiAgICAgICRhcmdzLnB1c2guYXBwbHkoJGFyZ3MsIGFyZ3MpO1xuICAgICAgcmV0dXJuIG5ldyAoYmluZC5hcHBseShUYXJnZXQsICRhcmdzKSkoKTtcbiAgICB9XG4gICAgLy8gd2l0aCBhbHRlcmVkIG5ld1RhcmdldCwgbm90IHN1cHBvcnQgYnVpbHQtaW4gY29uc3RydWN0b3JzXG4gICAgdmFyIHByb3RvID0gbmV3VGFyZ2V0LnByb3RvdHlwZTtcbiAgICB2YXIgaW5zdGFuY2UgPSBjcmVhdGUoaXNPYmplY3QocHJvdG8pID8gcHJvdG8gOiBPYmplY3QucHJvdG90eXBlKTtcbiAgICB2YXIgcmVzdWx0ID0gRnVuY3Rpb24uYXBwbHkuY2FsbChUYXJnZXQsIGluc3RhbmNlLCBhcmdzKTtcbiAgICByZXR1cm4gaXNPYmplY3QocmVzdWx0KSA/IHJlc3VsdCA6IGluc3RhbmNlO1xuICB9XG59KTtcbiIsIi8vIDI2LjEuMyBSZWZsZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHlLZXksIGF0dHJpYnV0ZXMpXG52YXIgZFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpO1xuXG4vLyBNUyBFZGdlIGhhcyBicm9rZW4gUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eSAtIHRocm93aW5nIGluc3RlYWQgb2YgcmV0dXJuaW5nIGZhbHNlXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eShkUC5mKHt9LCAxLCB7IHZhbHVlOiAxIH0pLCAxLCB7IHZhbHVlOiAyIH0pO1xufSksICdSZWZsZWN0Jywge1xuICBkZWZpbmVQcm9wZXJ0eTogZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eUtleSwgYXR0cmlidXRlcykge1xuICAgIGFuT2JqZWN0KHRhcmdldCk7XG4gICAgcHJvcGVydHlLZXkgPSB0b1ByaW1pdGl2ZShwcm9wZXJ0eUtleSwgdHJ1ZSk7XG4gICAgYW5PYmplY3QoYXR0cmlidXRlcyk7XG4gICAgdHJ5IHtcbiAgICAgIGRQLmYodGFyZ2V0LCBwcm9wZXJ0eUtleSwgYXR0cmlidXRlcyk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG59KTtcbiIsIi8vIDI2LjEuNCBSZWZsZWN0LmRlbGV0ZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHlLZXkpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGdPUEQgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpLmY7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge1xuICBkZWxldGVQcm9wZXJ0eTogZnVuY3Rpb24gZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eUtleSkge1xuICAgIHZhciBkZXNjID0gZ09QRChhbk9iamVjdCh0YXJnZXQpLCBwcm9wZXJ0eUtleSk7XG4gICAgcmV0dXJuIGRlc2MgJiYgIWRlc2MuY29uZmlndXJhYmxlID8gZmFsc2UgOiBkZWxldGUgdGFyZ2V0W3Byb3BlcnR5S2V5XTtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG4vLyAyNi4xLjUgUmVmbGVjdC5lbnVtZXJhdGUodGFyZ2V0KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIEVudW1lcmF0ZSA9IGZ1bmN0aW9uIChpdGVyYXRlZCkge1xuICB0aGlzLl90ID0gYW5PYmplY3QoaXRlcmF0ZWQpOyAvLyB0YXJnZXRcbiAgdGhpcy5faSA9IDA7ICAgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxuICB2YXIga2V5cyA9IHRoaXMuX2sgPSBbXTsgICAgICAvLyBrZXlzXG4gIHZhciBrZXk7XG4gIGZvciAoa2V5IGluIGl0ZXJhdGVkKSBrZXlzLnB1c2goa2V5KTtcbn07XG5yZXF1aXJlKCcuL19pdGVyLWNyZWF0ZScpKEVudW1lcmF0ZSwgJ09iamVjdCcsIGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRoYXQgPSB0aGlzO1xuICB2YXIga2V5cyA9IHRoYXQuX2s7XG4gIHZhciBrZXk7XG4gIGRvIHtcbiAgICBpZiAodGhhdC5faSA+PSBrZXlzLmxlbmd0aCkgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICB9IHdoaWxlICghKChrZXkgPSBrZXlzW3RoYXQuX2krK10pIGluIHRoYXQuX3QpKTtcbiAgcmV0dXJuIHsgdmFsdWU6IGtleSwgZG9uZTogZmFsc2UgfTtcbn0pO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7XG4gIGVudW1lcmF0ZTogZnVuY3Rpb24gZW51bWVyYXRlKHRhcmdldCkge1xuICAgIHJldHVybiBuZXcgRW51bWVyYXRlKHRhcmdldCk7XG4gIH1cbn0pO1xuIiwiLy8gMjYuMS43IFJlZmxlY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwgcHJvcGVydHlLZXkpXG52YXIgZ09QRCA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHtcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBwcm9wZXJ0eUtleSkge1xuICAgIHJldHVybiBnT1BELmYoYW5PYmplY3QodGFyZ2V0KSwgcHJvcGVydHlLZXkpO1xuICB9XG59KTtcbiIsIi8vIDI2LjEuOCBSZWZsZWN0LmdldFByb3RvdHlwZU9mKHRhcmdldClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgZ2V0UHJvdG8gPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge1xuICBnZXRQcm90b3R5cGVPZjogZnVuY3Rpb24gZ2V0UHJvdG90eXBlT2YodGFyZ2V0KSB7XG4gICAgcmV0dXJuIGdldFByb3RvKGFuT2JqZWN0KHRhcmdldCkpO1xuICB9XG59KTtcbiIsIi8vIDI2LjEuNiBSZWZsZWN0LmdldCh0YXJnZXQsIHByb3BlcnR5S2V5IFssIHJlY2VpdmVyXSlcbnZhciBnT1BEID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKTtcbnZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xuXG5mdW5jdGlvbiBnZXQodGFyZ2V0LCBwcm9wZXJ0eUtleSAvKiAsIHJlY2VpdmVyICovKSB7XG4gIHZhciByZWNlaXZlciA9IGFyZ3VtZW50cy5sZW5ndGggPCAzID8gdGFyZ2V0IDogYXJndW1lbnRzWzJdO1xuICB2YXIgZGVzYywgcHJvdG87XG4gIGlmIChhbk9iamVjdCh0YXJnZXQpID09PSByZWNlaXZlcikgcmV0dXJuIHRhcmdldFtwcm9wZXJ0eUtleV07XG4gIGlmIChkZXNjID0gZ09QRC5mKHRhcmdldCwgcHJvcGVydHlLZXkpKSByZXR1cm4gaGFzKGRlc2MsICd2YWx1ZScpXG4gICAgPyBkZXNjLnZhbHVlXG4gICAgOiBkZXNjLmdldCAhPT0gdW5kZWZpbmVkXG4gICAgICA/IGRlc2MuZ2V0LmNhbGwocmVjZWl2ZXIpXG4gICAgICA6IHVuZGVmaW5lZDtcbiAgaWYgKGlzT2JqZWN0KHByb3RvID0gZ2V0UHJvdG90eXBlT2YodGFyZ2V0KSkpIHJldHVybiBnZXQocHJvdG8sIHByb3BlcnR5S2V5LCByZWNlaXZlcik7XG59XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHsgZ2V0OiBnZXQgfSk7XG4iLCIvLyAyNi4xLjkgUmVmbGVjdC5oYXModGFyZ2V0LCBwcm9wZXJ0eUtleSlcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHtcbiAgaGFzOiBmdW5jdGlvbiBoYXModGFyZ2V0LCBwcm9wZXJ0eUtleSkge1xuICAgIHJldHVybiBwcm9wZXJ0eUtleSBpbiB0YXJnZXQ7XG4gIH1cbn0pO1xuIiwiLy8gMjYuMS4xMCBSZWZsZWN0LmlzRXh0ZW5zaWJsZSh0YXJnZXQpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgJGlzRXh0ZW5zaWJsZSA9IE9iamVjdC5pc0V4dGVuc2libGU7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHtcbiAgaXNFeHRlbnNpYmxlOiBmdW5jdGlvbiBpc0V4dGVuc2libGUodGFyZ2V0KSB7XG4gICAgYW5PYmplY3QodGFyZ2V0KTtcbiAgICByZXR1cm4gJGlzRXh0ZW5zaWJsZSA/ICRpc0V4dGVuc2libGUodGFyZ2V0KSA6IHRydWU7XG4gIH1cbn0pO1xuIiwiLy8gMjYuMS4xMSBSZWZsZWN0Lm93bktleXModGFyZ2V0KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0JywgeyBvd25LZXlzOiByZXF1aXJlKCcuL19vd24ta2V5cycpIH0pO1xuIiwiLy8gMjYuMS4xMiBSZWZsZWN0LnByZXZlbnRFeHRlbnNpb25zKHRhcmdldClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciAkcHJldmVudEV4dGVuc2lvbnMgPSBPYmplY3QucHJldmVudEV4dGVuc2lvbnM7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHtcbiAgcHJldmVudEV4dGVuc2lvbnM6IGZ1bmN0aW9uIHByZXZlbnRFeHRlbnNpb25zKHRhcmdldCkge1xuICAgIGFuT2JqZWN0KHRhcmdldCk7XG4gICAgdHJ5IHtcbiAgICAgIGlmICgkcHJldmVudEV4dGVuc2lvbnMpICRwcmV2ZW50RXh0ZW5zaW9ucyh0YXJnZXQpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxufSk7XG4iLCIvLyAyNi4xLjE0IFJlZmxlY3Quc2V0UHJvdG90eXBlT2YodGFyZ2V0LCBwcm90bylcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgc2V0UHJvdG8gPSByZXF1aXJlKCcuL19zZXQtcHJvdG8nKTtcblxuaWYgKHNldFByb3RvKSAkZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7XG4gIHNldFByb3RvdHlwZU9mOiBmdW5jdGlvbiBzZXRQcm90b3R5cGVPZih0YXJnZXQsIHByb3RvKSB7XG4gICAgc2V0UHJvdG8uY2hlY2sodGFyZ2V0LCBwcm90byk7XG4gICAgdHJ5IHtcbiAgICAgIHNldFByb3RvLnNldCh0YXJnZXQsIHByb3RvKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbn0pO1xuIiwiLy8gMjYuMS4xMyBSZWZsZWN0LnNldCh0YXJnZXQsIHByb3BlcnR5S2V5LCBWIFssIHJlY2VpdmVyXSlcbnZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xudmFyIGdPUEQgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpO1xudmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBjcmVhdGVEZXNjID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcblxuZnVuY3Rpb24gc2V0KHRhcmdldCwgcHJvcGVydHlLZXksIFYgLyogLCByZWNlaXZlciAqLykge1xuICB2YXIgcmVjZWl2ZXIgPSBhcmd1bWVudHMubGVuZ3RoIDwgNCA/IHRhcmdldCA6IGFyZ3VtZW50c1szXTtcbiAgdmFyIG93bkRlc2MgPSBnT1BELmYoYW5PYmplY3QodGFyZ2V0KSwgcHJvcGVydHlLZXkpO1xuICB2YXIgZXhpc3RpbmdEZXNjcmlwdG9yLCBwcm90bztcbiAgaWYgKCFvd25EZXNjKSB7XG4gICAgaWYgKGlzT2JqZWN0KHByb3RvID0gZ2V0UHJvdG90eXBlT2YodGFyZ2V0KSkpIHtcbiAgICAgIHJldHVybiBzZXQocHJvdG8sIHByb3BlcnR5S2V5LCBWLCByZWNlaXZlcik7XG4gICAgfVxuICAgIG93bkRlc2MgPSBjcmVhdGVEZXNjKDApO1xuICB9XG4gIGlmIChoYXMob3duRGVzYywgJ3ZhbHVlJykpIHtcbiAgICBpZiAob3duRGVzYy53cml0YWJsZSA9PT0gZmFsc2UgfHwgIWlzT2JqZWN0KHJlY2VpdmVyKSkgcmV0dXJuIGZhbHNlO1xuICAgIGV4aXN0aW5nRGVzY3JpcHRvciA9IGdPUEQuZihyZWNlaXZlciwgcHJvcGVydHlLZXkpIHx8IGNyZWF0ZURlc2MoMCk7XG4gICAgZXhpc3RpbmdEZXNjcmlwdG9yLnZhbHVlID0gVjtcbiAgICBkUC5mKHJlY2VpdmVyLCBwcm9wZXJ0eUtleSwgZXhpc3RpbmdEZXNjcmlwdG9yKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gb3duRGVzYy5zZXQgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogKG93bkRlc2Muc2V0LmNhbGwocmVjZWl2ZXIsIFYpLCB0cnVlKTtcbn1cblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0JywgeyBzZXQ6IHNldCB9KTtcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBpbmhlcml0SWZSZXF1aXJlZCA9IHJlcXVpcmUoJy4vX2luaGVyaXQtaWYtcmVxdWlyZWQnKTtcbnZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG52YXIgZ09QTiA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuJykuZjtcbnZhciBpc1JlZ0V4cCA9IHJlcXVpcmUoJy4vX2lzLXJlZ2V4cCcpO1xudmFyICRmbGFncyA9IHJlcXVpcmUoJy4vX2ZsYWdzJyk7XG52YXIgJFJlZ0V4cCA9IGdsb2JhbC5SZWdFeHA7XG52YXIgQmFzZSA9ICRSZWdFeHA7XG52YXIgcHJvdG8gPSAkUmVnRXhwLnByb3RvdHlwZTtcbnZhciByZTEgPSAvYS9nO1xudmFyIHJlMiA9IC9hL2c7XG4vLyBcIm5ld1wiIGNyZWF0ZXMgYSBuZXcgb2JqZWN0LCBvbGQgd2Via2l0IGJ1Z2d5IGhlcmVcbnZhciBDT1JSRUNUX05FVyA9IG5ldyAkUmVnRXhwKHJlMSkgIT09IHJlMTtcblxuaWYgKHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgKCFDT1JSRUNUX05FVyB8fCByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgcmUyW3JlcXVpcmUoJy4vX3drcycpKCdtYXRjaCcpXSA9IGZhbHNlO1xuICAvLyBSZWdFeHAgY29uc3RydWN0b3IgY2FuIGFsdGVyIGZsYWdzIGFuZCBJc1JlZ0V4cCB3b3JrcyBjb3JyZWN0IHdpdGggQEBtYXRjaFxuICByZXR1cm4gJFJlZ0V4cChyZTEpICE9IHJlMSB8fCAkUmVnRXhwKHJlMikgPT0gcmUyIHx8ICRSZWdFeHAocmUxLCAnaScpICE9ICcvYS9pJztcbn0pKSkge1xuICAkUmVnRXhwID0gZnVuY3Rpb24gUmVnRXhwKHAsIGYpIHtcbiAgICB2YXIgdGlSRSA9IHRoaXMgaW5zdGFuY2VvZiAkUmVnRXhwO1xuICAgIHZhciBwaVJFID0gaXNSZWdFeHAocCk7XG4gICAgdmFyIGZpVSA9IGYgPT09IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gIXRpUkUgJiYgcGlSRSAmJiBwLmNvbnN0cnVjdG9yID09PSAkUmVnRXhwICYmIGZpVSA/IHBcbiAgICAgIDogaW5oZXJpdElmUmVxdWlyZWQoQ09SUkVDVF9ORVdcbiAgICAgICAgPyBuZXcgQmFzZShwaVJFICYmICFmaVUgPyBwLnNvdXJjZSA6IHAsIGYpXG4gICAgICAgIDogQmFzZSgocGlSRSA9IHAgaW5zdGFuY2VvZiAkUmVnRXhwKSA/IHAuc291cmNlIDogcCwgcGlSRSAmJiBmaVUgPyAkZmxhZ3MuY2FsbChwKSA6IGYpXG4gICAgICAsIHRpUkUgPyB0aGlzIDogcHJvdG8sICRSZWdFeHApO1xuICB9O1xuICB2YXIgcHJveHkgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAga2V5IGluICRSZWdFeHAgfHwgZFAoJFJlZ0V4cCwga2V5LCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEJhc2Vba2V5XTsgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKGl0KSB7IEJhc2Vba2V5XSA9IGl0OyB9XG4gICAgfSk7XG4gIH07XG4gIGZvciAodmFyIGtleXMgPSBnT1BOKEJhc2UpLCBpID0gMDsga2V5cy5sZW5ndGggPiBpOykgcHJveHkoa2V5c1tpKytdKTtcbiAgcHJvdG8uY29uc3RydWN0b3IgPSAkUmVnRXhwO1xuICAkUmVnRXhwLnByb3RvdHlwZSA9IHByb3RvO1xuICByZXF1aXJlKCcuL19yZWRlZmluZScpKGdsb2JhbCwgJ1JlZ0V4cCcsICRSZWdFeHApO1xufVxuXG5yZXF1aXJlKCcuL19zZXQtc3BlY2llcycpKCdSZWdFeHAnKTtcbiIsIi8vIDIxLjIuNS4zIGdldCBSZWdFeHAucHJvdG90eXBlLmZsYWdzKClcbmlmIChyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmIC8uL2cuZmxhZ3MgIT0gJ2cnKSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mKFJlZ0V4cC5wcm90b3R5cGUsICdmbGFncycsIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBnZXQ6IHJlcXVpcmUoJy4vX2ZsYWdzJylcbn0pO1xuIiwiLy8gQEBtYXRjaCBsb2dpY1xucmVxdWlyZSgnLi9fZml4LXJlLXdrcycpKCdtYXRjaCcsIDEsIGZ1bmN0aW9uIChkZWZpbmVkLCBNQVRDSCwgJG1hdGNoKSB7XG4gIC8vIDIxLjEuMy4xMSBTdHJpbmcucHJvdG90eXBlLm1hdGNoKHJlZ2V4cClcbiAgcmV0dXJuIFtmdW5jdGlvbiBtYXRjaChyZWdleHApIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgdmFyIE8gPSBkZWZpbmVkKHRoaXMpO1xuICAgIHZhciBmbiA9IHJlZ2V4cCA9PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiByZWdleHBbTUFUQ0hdO1xuICAgIHJldHVybiBmbiAhPT0gdW5kZWZpbmVkID8gZm4uY2FsbChyZWdleHAsIE8pIDogbmV3IFJlZ0V4cChyZWdleHApW01BVENIXShTdHJpbmcoTykpO1xuICB9LCAkbWF0Y2hdO1xufSk7XG4iLCIvLyBAQHJlcGxhY2UgbG9naWNcbnJlcXVpcmUoJy4vX2ZpeC1yZS13a3MnKSgncmVwbGFjZScsIDIsIGZ1bmN0aW9uIChkZWZpbmVkLCBSRVBMQUNFLCAkcmVwbGFjZSkge1xuICAvLyAyMS4xLjMuMTQgU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlKHNlYXJjaFZhbHVlLCByZXBsYWNlVmFsdWUpXG4gIHJldHVybiBbZnVuY3Rpb24gcmVwbGFjZShzZWFyY2hWYWx1ZSwgcmVwbGFjZVZhbHVlKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIHZhciBPID0gZGVmaW5lZCh0aGlzKTtcbiAgICB2YXIgZm4gPSBzZWFyY2hWYWx1ZSA9PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBzZWFyY2hWYWx1ZVtSRVBMQUNFXTtcbiAgICByZXR1cm4gZm4gIT09IHVuZGVmaW5lZFxuICAgICAgPyBmbi5jYWxsKHNlYXJjaFZhbHVlLCBPLCByZXBsYWNlVmFsdWUpXG4gICAgICA6ICRyZXBsYWNlLmNhbGwoU3RyaW5nKE8pLCBzZWFyY2hWYWx1ZSwgcmVwbGFjZVZhbHVlKTtcbiAgfSwgJHJlcGxhY2VdO1xufSk7XG4iLCIvLyBAQHNlYXJjaCBsb2dpY1xucmVxdWlyZSgnLi9fZml4LXJlLXdrcycpKCdzZWFyY2gnLCAxLCBmdW5jdGlvbiAoZGVmaW5lZCwgU0VBUkNILCAkc2VhcmNoKSB7XG4gIC8vIDIxLjEuMy4xNSBTdHJpbmcucHJvdG90eXBlLnNlYXJjaChyZWdleHApXG4gIHJldHVybiBbZnVuY3Rpb24gc2VhcmNoKHJlZ2V4cCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICB2YXIgTyA9IGRlZmluZWQodGhpcyk7XG4gICAgdmFyIGZuID0gcmVnZXhwID09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHJlZ2V4cFtTRUFSQ0hdO1xuICAgIHJldHVybiBmbiAhPT0gdW5kZWZpbmVkID8gZm4uY2FsbChyZWdleHAsIE8pIDogbmV3IFJlZ0V4cChyZWdleHApW1NFQVJDSF0oU3RyaW5nKE8pKTtcbiAgfSwgJHNlYXJjaF07XG59KTtcbiIsIi8vIEBAc3BsaXQgbG9naWNcbnJlcXVpcmUoJy4vX2ZpeC1yZS13a3MnKSgnc3BsaXQnLCAyLCBmdW5jdGlvbiAoZGVmaW5lZCwgU1BMSVQsICRzcGxpdCkge1xuICAndXNlIHN0cmljdCc7XG4gIHZhciBpc1JlZ0V4cCA9IHJlcXVpcmUoJy4vX2lzLXJlZ2V4cCcpO1xuICB2YXIgX3NwbGl0ID0gJHNwbGl0O1xuICB2YXIgJHB1c2ggPSBbXS5wdXNoO1xuICB2YXIgJFNQTElUID0gJ3NwbGl0JztcbiAgdmFyIExFTkdUSCA9ICdsZW5ndGgnO1xuICB2YXIgTEFTVF9JTkRFWCA9ICdsYXN0SW5kZXgnO1xuICBpZiAoXG4gICAgJ2FiYmMnWyRTUExJVF0oLyhiKSovKVsxXSA9PSAnYycgfHxcbiAgICAndGVzdCdbJFNQTElUXSgvKD86KS8sIC0xKVtMRU5HVEhdICE9IDQgfHxcbiAgICAnYWInWyRTUExJVF0oLyg/OmFiKSovKVtMRU5HVEhdICE9IDIgfHxcbiAgICAnLidbJFNQTElUXSgvKC4/KSguPykvKVtMRU5HVEhdICE9IDQgfHxcbiAgICAnLidbJFNQTElUXSgvKCkoKS8pW0xFTkdUSF0gPiAxIHx8XG4gICAgJydbJFNQTElUXSgvLj8vKVtMRU5HVEhdXG4gICkge1xuICAgIHZhciBOUENHID0gLygpPz8vLmV4ZWMoJycpWzFdID09PSB1bmRlZmluZWQ7IC8vIG5vbnBhcnRpY2lwYXRpbmcgY2FwdHVyaW5nIGdyb3VwXG4gICAgLy8gYmFzZWQgb24gZXM1LXNoaW0gaW1wbGVtZW50YXRpb24sIG5lZWQgdG8gcmV3b3JrIGl0XG4gICAgJHNwbGl0ID0gZnVuY3Rpb24gKHNlcGFyYXRvciwgbGltaXQpIHtcbiAgICAgIHZhciBzdHJpbmcgPSBTdHJpbmcodGhpcyk7XG4gICAgICBpZiAoc2VwYXJhdG9yID09PSB1bmRlZmluZWQgJiYgbGltaXQgPT09IDApIHJldHVybiBbXTtcbiAgICAgIC8vIElmIGBzZXBhcmF0b3JgIGlzIG5vdCBhIHJlZ2V4LCB1c2UgbmF0aXZlIHNwbGl0XG4gICAgICBpZiAoIWlzUmVnRXhwKHNlcGFyYXRvcikpIHJldHVybiBfc3BsaXQuY2FsbChzdHJpbmcsIHNlcGFyYXRvciwgbGltaXQpO1xuICAgICAgdmFyIG91dHB1dCA9IFtdO1xuICAgICAgdmFyIGZsYWdzID0gKHNlcGFyYXRvci5pZ25vcmVDYXNlID8gJ2knIDogJycpICtcbiAgICAgICAgICAgICAgICAgIChzZXBhcmF0b3IubXVsdGlsaW5lID8gJ20nIDogJycpICtcbiAgICAgICAgICAgICAgICAgIChzZXBhcmF0b3IudW5pY29kZSA/ICd1JyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAoc2VwYXJhdG9yLnN0aWNreSA/ICd5JyA6ICcnKTtcbiAgICAgIHZhciBsYXN0TGFzdEluZGV4ID0gMDtcbiAgICAgIHZhciBzcGxpdExpbWl0ID0gbGltaXQgPT09IHVuZGVmaW5lZCA/IDQyOTQ5NjcyOTUgOiBsaW1pdCA+Pj4gMDtcbiAgICAgIC8vIE1ha2UgYGdsb2JhbGAgYW5kIGF2b2lkIGBsYXN0SW5kZXhgIGlzc3VlcyBieSB3b3JraW5nIHdpdGggYSBjb3B5XG4gICAgICB2YXIgc2VwYXJhdG9yQ29weSA9IG5ldyBSZWdFeHAoc2VwYXJhdG9yLnNvdXJjZSwgZmxhZ3MgKyAnZycpO1xuICAgICAgdmFyIHNlcGFyYXRvcjIsIG1hdGNoLCBsYXN0SW5kZXgsIGxhc3RMZW5ndGgsIGk7XG4gICAgICAvLyBEb2Vzbid0IG5lZWQgZmxhZ3MgZ3ksIGJ1dCB0aGV5IGRvbid0IGh1cnRcbiAgICAgIGlmICghTlBDRykgc2VwYXJhdG9yMiA9IG5ldyBSZWdFeHAoJ14nICsgc2VwYXJhdG9yQ29weS5zb3VyY2UgKyAnJCg/IVxcXFxzKScsIGZsYWdzKTtcbiAgICAgIHdoaWxlIChtYXRjaCA9IHNlcGFyYXRvckNvcHkuZXhlYyhzdHJpbmcpKSB7XG4gICAgICAgIC8vIGBzZXBhcmF0b3JDb3B5Lmxhc3RJbmRleGAgaXMgbm90IHJlbGlhYmxlIGNyb3NzLWJyb3dzZXJcbiAgICAgICAgbGFzdEluZGV4ID0gbWF0Y2guaW5kZXggKyBtYXRjaFswXVtMRU5HVEhdO1xuICAgICAgICBpZiAobGFzdEluZGV4ID4gbGFzdExhc3RJbmRleCkge1xuICAgICAgICAgIG91dHB1dC5wdXNoKHN0cmluZy5zbGljZShsYXN0TGFzdEluZGV4LCBtYXRjaC5pbmRleCkpO1xuICAgICAgICAgIC8vIEZpeCBicm93c2VycyB3aG9zZSBgZXhlY2AgbWV0aG9kcyBkb24ndCBjb25zaXN0ZW50bHkgcmV0dXJuIGB1bmRlZmluZWRgIGZvciBOUENHXG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWxvb3AtZnVuY1xuICAgICAgICAgIGlmICghTlBDRyAmJiBtYXRjaFtMRU5HVEhdID4gMSkgbWF0Y2hbMF0ucmVwbGFjZShzZXBhcmF0b3IyLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAxOyBpIDwgYXJndW1lbnRzW0xFTkdUSF0gLSAyOyBpKyspIGlmIChhcmd1bWVudHNbaV0gPT09IHVuZGVmaW5lZCkgbWF0Y2hbaV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKG1hdGNoW0xFTkdUSF0gPiAxICYmIG1hdGNoLmluZGV4IDwgc3RyaW5nW0xFTkdUSF0pICRwdXNoLmFwcGx5KG91dHB1dCwgbWF0Y2guc2xpY2UoMSkpO1xuICAgICAgICAgIGxhc3RMZW5ndGggPSBtYXRjaFswXVtMRU5HVEhdO1xuICAgICAgICAgIGxhc3RMYXN0SW5kZXggPSBsYXN0SW5kZXg7XG4gICAgICAgICAgaWYgKG91dHB1dFtMRU5HVEhdID49IHNwbGl0TGltaXQpIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZXBhcmF0b3JDb3B5W0xBU1RfSU5ERVhdID09PSBtYXRjaC5pbmRleCkgc2VwYXJhdG9yQ29weVtMQVNUX0lOREVYXSsrOyAvLyBBdm9pZCBhbiBpbmZpbml0ZSBsb29wXG4gICAgICB9XG4gICAgICBpZiAobGFzdExhc3RJbmRleCA9PT0gc3RyaW5nW0xFTkdUSF0pIHtcbiAgICAgICAgaWYgKGxhc3RMZW5ndGggfHwgIXNlcGFyYXRvckNvcHkudGVzdCgnJykpIG91dHB1dC5wdXNoKCcnKTtcbiAgICAgIH0gZWxzZSBvdXRwdXQucHVzaChzdHJpbmcuc2xpY2UobGFzdExhc3RJbmRleCkpO1xuICAgICAgcmV0dXJuIG91dHB1dFtMRU5HVEhdID4gc3BsaXRMaW1pdCA/IG91dHB1dC5zbGljZSgwLCBzcGxpdExpbWl0KSA6IG91dHB1dDtcbiAgICB9O1xuICAvLyBDaGFrcmEsIFY4XG4gIH0gZWxzZSBpZiAoJzAnWyRTUExJVF0odW5kZWZpbmVkLCAwKVtMRU5HVEhdKSB7XG4gICAgJHNwbGl0ID0gZnVuY3Rpb24gKHNlcGFyYXRvciwgbGltaXQpIHtcbiAgICAgIHJldHVybiBzZXBhcmF0b3IgPT09IHVuZGVmaW5lZCAmJiBsaW1pdCA9PT0gMCA/IFtdIDogX3NwbGl0LmNhbGwodGhpcywgc2VwYXJhdG9yLCBsaW1pdCk7XG4gICAgfTtcbiAgfVxuICAvLyAyMS4xLjMuMTcgU3RyaW5nLnByb3RvdHlwZS5zcGxpdChzZXBhcmF0b3IsIGxpbWl0KVxuICByZXR1cm4gW2Z1bmN0aW9uIHNwbGl0KHNlcGFyYXRvciwgbGltaXQpIHtcbiAgICB2YXIgTyA9IGRlZmluZWQodGhpcyk7XG4gICAgdmFyIGZuID0gc2VwYXJhdG9yID09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHNlcGFyYXRvcltTUExJVF07XG4gICAgcmV0dXJuIGZuICE9PSB1bmRlZmluZWQgPyBmbi5jYWxsKHNlcGFyYXRvciwgTywgbGltaXQpIDogJHNwbGl0LmNhbGwoU3RyaW5nKE8pLCBzZXBhcmF0b3IsIGxpbWl0KTtcbiAgfSwgJHNwbGl0XTtcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xucmVxdWlyZSgnLi9lczYucmVnZXhwLmZsYWdzJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciAkZmxhZ3MgPSByZXF1aXJlKCcuL19mbGFncycpO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKTtcbnZhciBUT19TVFJJTkcgPSAndG9TdHJpbmcnO1xudmFyICR0b1N0cmluZyA9IC8uL1tUT19TVFJJTkddO1xuXG52YXIgZGVmaW5lID0gZnVuY3Rpb24gKGZuKSB7XG4gIHJlcXVpcmUoJy4vX3JlZGVmaW5lJykoUmVnRXhwLnByb3RvdHlwZSwgVE9fU1RSSU5HLCBmbiwgdHJ1ZSk7XG59O1xuXG4vLyAyMS4yLjUuMTQgUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZygpXG5pZiAocmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7IHJldHVybiAkdG9TdHJpbmcuY2FsbCh7IHNvdXJjZTogJ2EnLCBmbGFnczogJ2InIH0pICE9ICcvYS9iJzsgfSkpIHtcbiAgZGVmaW5lKGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHZhciBSID0gYW5PYmplY3QodGhpcyk7XG4gICAgcmV0dXJuICcvJy5jb25jYXQoUi5zb3VyY2UsICcvJyxcbiAgICAgICdmbGFncycgaW4gUiA/IFIuZmxhZ3MgOiAhREVTQ1JJUFRPUlMgJiYgUiBpbnN0YW5jZW9mIFJlZ0V4cCA/ICRmbGFncy5jYWxsKFIpIDogdW5kZWZpbmVkKTtcbiAgfSk7XG4vLyBGRjQ0LSBSZWdFeHAjdG9TdHJpbmcgaGFzIGEgd3JvbmcgbmFtZVxufSBlbHNlIGlmICgkdG9TdHJpbmcubmFtZSAhPSBUT19TVFJJTkcpIHtcbiAgZGVmaW5lKGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiAkdG9TdHJpbmcuY2FsbCh0aGlzKTtcbiAgfSk7XG59XG4iLCIndXNlIHN0cmljdCc7XG52YXIgc3Ryb25nID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbi1zdHJvbmcnKTtcbnZhciB2YWxpZGF0ZSA9IHJlcXVpcmUoJy4vX3ZhbGlkYXRlLWNvbGxlY3Rpb24nKTtcbnZhciBTRVQgPSAnU2V0JztcblxuLy8gMjMuMiBTZXQgT2JqZWN0c1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19jb2xsZWN0aW9uJykoU0VULCBmdW5jdGlvbiAoZ2V0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBTZXQoKSB7IHJldHVybiBnZXQodGhpcywgYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpOyB9O1xufSwge1xuICAvLyAyMy4yLjMuMSBTZXQucHJvdG90eXBlLmFkZCh2YWx1ZSlcbiAgYWRkOiBmdW5jdGlvbiBhZGQodmFsdWUpIHtcbiAgICByZXR1cm4gc3Ryb25nLmRlZih2YWxpZGF0ZSh0aGlzLCBTRVQpLCB2YWx1ZSA9IHZhbHVlID09PSAwID8gMCA6IHZhbHVlLCB2YWx1ZSk7XG4gIH1cbn0sIHN0cm9uZyk7XG4iLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy4yIFN0cmluZy5wcm90b3R5cGUuYW5jaG9yKG5hbWUpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdhbmNob3InLCBmdW5jdGlvbiAoY3JlYXRlSFRNTCkge1xuICByZXR1cm4gZnVuY3Rpb24gYW5jaG9yKG5hbWUpIHtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnYScsICduYW1lJywgbmFtZSk7XG4gIH07XG59KTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjMgU3RyaW5nLnByb3RvdHlwZS5iaWcoKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnYmlnJywgZnVuY3Rpb24gKGNyZWF0ZUhUTUwpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGJpZygpIHtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnYmlnJywgJycsICcnKTtcbiAgfTtcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuNCBTdHJpbmcucHJvdG90eXBlLmJsaW5rKClcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ2JsaW5rJywgZnVuY3Rpb24gKGNyZWF0ZUhUTUwpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGJsaW5rKCkge1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdibGluaycsICcnLCAnJyk7XG4gIH07XG59KTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjUgU3RyaW5nLnByb3RvdHlwZS5ib2xkKClcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ2JvbGQnLCBmdW5jdGlvbiAoY3JlYXRlSFRNTCkge1xuICByZXR1cm4gZnVuY3Rpb24gYm9sZCgpIHtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnYicsICcnLCAnJyk7XG4gIH07XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJGF0ID0gcmVxdWlyZSgnLi9fc3RyaW5nLWF0JykoZmFsc2UpO1xuJGV4cG9ydCgkZXhwb3J0LlAsICdTdHJpbmcnLCB7XG4gIC8vIDIxLjEuMy4zIFN0cmluZy5wcm90b3R5cGUuY29kZVBvaW50QXQocG9zKVxuICBjb2RlUG9pbnRBdDogZnVuY3Rpb24gY29kZVBvaW50QXQocG9zKSB7XG4gICAgcmV0dXJuICRhdCh0aGlzLCBwb3MpO1xuICB9XG59KTtcbiIsIi8vIDIxLjEuMy42IFN0cmluZy5wcm90b3R5cGUuZW5kc1dpdGgoc2VhcmNoU3RyaW5nIFssIGVuZFBvc2l0aW9uXSlcbid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciBjb250ZXh0ID0gcmVxdWlyZSgnLi9fc3RyaW5nLWNvbnRleHQnKTtcbnZhciBFTkRTX1dJVEggPSAnZW5kc1dpdGgnO1xudmFyICRlbmRzV2l0aCA9ICcnW0VORFNfV0lUSF07XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogcmVxdWlyZSgnLi9fZmFpbHMtaXMtcmVnZXhwJykoRU5EU19XSVRIKSwgJ1N0cmluZycsIHtcbiAgZW5kc1dpdGg6IGZ1bmN0aW9uIGVuZHNXaXRoKHNlYXJjaFN0cmluZyAvKiAsIGVuZFBvc2l0aW9uID0gQGxlbmd0aCAqLykge1xuICAgIHZhciB0aGF0ID0gY29udGV4dCh0aGlzLCBzZWFyY2hTdHJpbmcsIEVORFNfV0lUSCk7XG4gICAgdmFyIGVuZFBvc2l0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQ7XG4gICAgdmFyIGxlbiA9IHRvTGVuZ3RoKHRoYXQubGVuZ3RoKTtcbiAgICB2YXIgZW5kID0gZW5kUG9zaXRpb24gPT09IHVuZGVmaW5lZCA/IGxlbiA6IE1hdGgubWluKHRvTGVuZ3RoKGVuZFBvc2l0aW9uKSwgbGVuKTtcbiAgICB2YXIgc2VhcmNoID0gU3RyaW5nKHNlYXJjaFN0cmluZyk7XG4gICAgcmV0dXJuICRlbmRzV2l0aFxuICAgICAgPyAkZW5kc1dpdGguY2FsbCh0aGF0LCBzZWFyY2gsIGVuZClcbiAgICAgIDogdGhhdC5zbGljZShlbmQgLSBzZWFyY2gubGVuZ3RoLCBlbmQpID09PSBzZWFyY2g7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuNiBTdHJpbmcucHJvdG90eXBlLmZpeGVkKClcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ2ZpeGVkJywgZnVuY3Rpb24gKGNyZWF0ZUhUTUwpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGZpeGVkKCkge1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICd0dCcsICcnLCAnJyk7XG4gIH07XG59KTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjcgU3RyaW5nLnByb3RvdHlwZS5mb250Y29sb3IoY29sb3IpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdmb250Y29sb3InLCBmdW5jdGlvbiAoY3JlYXRlSFRNTCkge1xuICByZXR1cm4gZnVuY3Rpb24gZm9udGNvbG9yKGNvbG9yKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ2ZvbnQnLCAnY29sb3InLCBjb2xvcik7XG4gIH07XG59KTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjggU3RyaW5nLnByb3RvdHlwZS5mb250c2l6ZShzaXplKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnZm9udHNpemUnLCBmdW5jdGlvbiAoY3JlYXRlSFRNTCkge1xuICByZXR1cm4gZnVuY3Rpb24gZm9udHNpemUoc2l6ZSkge1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdmb250JywgJ3NpemUnLCBzaXplKTtcbiAgfTtcbn0pO1xuIiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciB0b0Fic29sdXRlSW5kZXggPSByZXF1aXJlKCcuL190by1hYnNvbHV0ZS1pbmRleCcpO1xudmFyIGZyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XG52YXIgJGZyb21Db2RlUG9pbnQgPSBTdHJpbmcuZnJvbUNvZGVQb2ludDtcblxuLy8gbGVuZ3RoIHNob3VsZCBiZSAxLCBvbGQgRkYgcHJvYmxlbVxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoISEkZnJvbUNvZGVQb2ludCAmJiAkZnJvbUNvZGVQb2ludC5sZW5ndGggIT0gMSksICdTdHJpbmcnLCB7XG4gIC8vIDIxLjEuMi4yIFN0cmluZy5mcm9tQ29kZVBvaW50KC4uLmNvZGVQb2ludHMpXG4gIGZyb21Db2RlUG9pbnQ6IGZ1bmN0aW9uIGZyb21Db2RlUG9pbnQoeCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIHZhciBhTGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGNvZGU7XG4gICAgd2hpbGUgKGFMZW4gPiBpKSB7XG4gICAgICBjb2RlID0gK2FyZ3VtZW50c1tpKytdO1xuICAgICAgaWYgKHRvQWJzb2x1dGVJbmRleChjb2RlLCAweDEwZmZmZikgIT09IGNvZGUpIHRocm93IFJhbmdlRXJyb3IoY29kZSArICcgaXMgbm90IGEgdmFsaWQgY29kZSBwb2ludCcpO1xuICAgICAgcmVzLnB1c2goY29kZSA8IDB4MTAwMDBcbiAgICAgICAgPyBmcm9tQ2hhckNvZGUoY29kZSlcbiAgICAgICAgOiBmcm9tQ2hhckNvZGUoKChjb2RlIC09IDB4MTAwMDApID4+IDEwKSArIDB4ZDgwMCwgY29kZSAlIDB4NDAwICsgMHhkYzAwKVxuICAgICAgKTtcbiAgICB9IHJldHVybiByZXMuam9pbignJyk7XG4gIH1cbn0pO1xuIiwiLy8gMjEuMS4zLjcgU3RyaW5nLnByb3RvdHlwZS5pbmNsdWRlcyhzZWFyY2hTdHJpbmcsIHBvc2l0aW9uID0gMClcbid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgY29udGV4dCA9IHJlcXVpcmUoJy4vX3N0cmluZy1jb250ZXh0Jyk7XG52YXIgSU5DTFVERVMgPSAnaW5jbHVkZXMnO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzLWlzLXJlZ2V4cCcpKElOQ0xVREVTKSwgJ1N0cmluZycsIHtcbiAgaW5jbHVkZXM6IGZ1bmN0aW9uIGluY2x1ZGVzKHNlYXJjaFN0cmluZyAvKiAsIHBvc2l0aW9uID0gMCAqLykge1xuICAgIHJldHVybiAhIX5jb250ZXh0KHRoaXMsIHNlYXJjaFN0cmluZywgSU5DTFVERVMpXG4gICAgICAuaW5kZXhPZihzZWFyY2hTdHJpbmcsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy45IFN0cmluZy5wcm90b3R5cGUuaXRhbGljcygpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdpdGFsaWNzJywgZnVuY3Rpb24gKGNyZWF0ZUhUTUwpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGl0YWxpY3MoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ2knLCAnJywgJycpO1xuICB9O1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJGF0ID0gcmVxdWlyZSgnLi9fc3RyaW5nLWF0JykodHJ1ZSk7XG5cbi8vIDIxLjEuMy4yNyBTdHJpbmcucHJvdG90eXBlW0BAaXRlcmF0b3JdKClcbnJlcXVpcmUoJy4vX2l0ZXItZGVmaW5lJykoU3RyaW5nLCAnU3RyaW5nJywgZnVuY3Rpb24gKGl0ZXJhdGVkKSB7XG4gIHRoaXMuX3QgPSBTdHJpbmcoaXRlcmF0ZWQpOyAvLyB0YXJnZXRcbiAgdGhpcy5faSA9IDA7ICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXhcbi8vIDIxLjEuNS4yLjEgJVN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlJS5uZXh0KClcbn0sIGZ1bmN0aW9uICgpIHtcbiAgdmFyIE8gPSB0aGlzLl90O1xuICB2YXIgaW5kZXggPSB0aGlzLl9pO1xuICB2YXIgcG9pbnQ7XG4gIGlmIChpbmRleCA+PSBPLmxlbmd0aCkgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICBwb2ludCA9ICRhdChPLCBpbmRleCk7XG4gIHRoaXMuX2kgKz0gcG9pbnQubGVuZ3RoO1xuICByZXR1cm4geyB2YWx1ZTogcG9pbnQsIGRvbmU6IGZhbHNlIH07XG59KTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjEwIFN0cmluZy5wcm90b3R5cGUubGluayh1cmwpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdsaW5rJywgZnVuY3Rpb24gKGNyZWF0ZUhUTUwpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGxpbmsodXJsKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ2EnLCAnaHJlZicsIHVybCk7XG4gIH07XG59KTtcbiIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnU3RyaW5nJywge1xuICAvLyAyMS4xLjIuNCBTdHJpbmcucmF3KGNhbGxTaXRlLCAuLi5zdWJzdGl0dXRpb25zKVxuICByYXc6IGZ1bmN0aW9uIHJhdyhjYWxsU2l0ZSkge1xuICAgIHZhciB0cGwgPSB0b0lPYmplY3QoY2FsbFNpdGUucmF3KTtcbiAgICB2YXIgbGVuID0gdG9MZW5ndGgodHBsLmxlbmd0aCk7XG4gICAgdmFyIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciByZXMgPSBbXTtcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKGxlbiA+IGkpIHtcbiAgICAgIHJlcy5wdXNoKFN0cmluZyh0cGxbaSsrXSkpO1xuICAgICAgaWYgKGkgPCBhTGVuKSByZXMucHVzaChTdHJpbmcoYXJndW1lbnRzW2ldKSk7XG4gICAgfSByZXR1cm4gcmVzLmpvaW4oJycpO1xuICB9XG59KTtcbiIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QLCAnU3RyaW5nJywge1xuICAvLyAyMS4xLjMuMTMgU3RyaW5nLnByb3RvdHlwZS5yZXBlYXQoY291bnQpXG4gIHJlcGVhdDogcmVxdWlyZSgnLi9fc3RyaW5nLXJlcGVhdCcpXG59KTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjExIFN0cmluZy5wcm90b3R5cGUuc21hbGwoKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnc21hbGwnLCBmdW5jdGlvbiAoY3JlYXRlSFRNTCkge1xuICByZXR1cm4gZnVuY3Rpb24gc21hbGwoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ3NtYWxsJywgJycsICcnKTtcbiAgfTtcbn0pO1xuIiwiLy8gMjEuMS4zLjE4IFN0cmluZy5wcm90b3R5cGUuc3RhcnRzV2l0aChzZWFyY2hTdHJpbmcgWywgcG9zaXRpb24gXSlcbid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciBjb250ZXh0ID0gcmVxdWlyZSgnLi9fc3RyaW5nLWNvbnRleHQnKTtcbnZhciBTVEFSVFNfV0lUSCA9ICdzdGFydHNXaXRoJztcbnZhciAkc3RhcnRzV2l0aCA9ICcnW1NUQVJUU19XSVRIXTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscy1pcy1yZWdleHAnKShTVEFSVFNfV0lUSCksICdTdHJpbmcnLCB7XG4gIHN0YXJ0c1dpdGg6IGZ1bmN0aW9uIHN0YXJ0c1dpdGgoc2VhcmNoU3RyaW5nIC8qICwgcG9zaXRpb24gPSAwICovKSB7XG4gICAgdmFyIHRoYXQgPSBjb250ZXh0KHRoaXMsIHNlYXJjaFN0cmluZywgU1RBUlRTX1dJVEgpO1xuICAgIHZhciBpbmRleCA9IHRvTGVuZ3RoKE1hdGgubWluKGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkLCB0aGF0Lmxlbmd0aCkpO1xuICAgIHZhciBzZWFyY2ggPSBTdHJpbmcoc2VhcmNoU3RyaW5nKTtcbiAgICByZXR1cm4gJHN0YXJ0c1dpdGhcbiAgICAgID8gJHN0YXJ0c1dpdGguY2FsbCh0aGF0LCBzZWFyY2gsIGluZGV4KVxuICAgICAgOiB0aGF0LnNsaWNlKGluZGV4LCBpbmRleCArIHNlYXJjaC5sZW5ndGgpID09PSBzZWFyY2g7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuMTIgU3RyaW5nLnByb3RvdHlwZS5zdHJpa2UoKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnc3RyaWtlJywgZnVuY3Rpb24gKGNyZWF0ZUhUTUwpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHN0cmlrZSgpIHtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnc3RyaWtlJywgJycsICcnKTtcbiAgfTtcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuMTMgU3RyaW5nLnByb3RvdHlwZS5zdWIoKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnc3ViJywgZnVuY3Rpb24gKGNyZWF0ZUhUTUwpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHN1YigpIHtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnc3ViJywgJycsICcnKTtcbiAgfTtcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuMTQgU3RyaW5nLnByb3RvdHlwZS5zdXAoKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnc3VwJywgZnVuY3Rpb24gKGNyZWF0ZUhUTUwpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHN1cCgpIHtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnc3VwJywgJycsICcnKTtcbiAgfTtcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gMjEuMS4zLjI1IFN0cmluZy5wcm90b3R5cGUudHJpbSgpXG5yZXF1aXJlKCcuL19zdHJpbmctdHJpbScpKCd0cmltJywgZnVuY3Rpb24gKCR0cmltKSB7XG4gIHJldHVybiBmdW5jdGlvbiB0cmltKCkge1xuICAgIHJldHVybiAkdHJpbSh0aGlzLCAzKTtcbiAgfTtcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gRUNNQVNjcmlwdCA2IHN5bWJvbHMgc2hpbVxudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKTtcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuL19yZWRlZmluZScpO1xudmFyIE1FVEEgPSByZXF1aXJlKCcuL19tZXRhJykuS0VZO1xudmFyICRmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG52YXIgc2hhcmVkID0gcmVxdWlyZSgnLi9fc2hhcmVkJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIHVpZCA9IHJlcXVpcmUoJy4vX3VpZCcpO1xudmFyIHdrcyA9IHJlcXVpcmUoJy4vX3drcycpO1xudmFyIHdrc0V4dCA9IHJlcXVpcmUoJy4vX3drcy1leHQnKTtcbnZhciB3a3NEZWZpbmUgPSByZXF1aXJlKCcuL193a3MtZGVmaW5lJyk7XG52YXIgZW51bUtleXMgPSByZXF1aXJlKCcuL19lbnVtLWtleXMnKTtcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi9faXMtYXJyYXknKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpO1xudmFyIGNyZWF0ZURlc2MgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG52YXIgX2NyZWF0ZSA9IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKTtcbnZhciBnT1BORXh0ID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4tZXh0Jyk7XG52YXIgJEdPUEQgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpO1xudmFyICREUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xudmFyICRrZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcbnZhciBnT1BEID0gJEdPUEQuZjtcbnZhciBkUCA9ICREUC5mO1xudmFyIGdPUE4gPSBnT1BORXh0LmY7XG52YXIgJFN5bWJvbCA9IGdsb2JhbC5TeW1ib2w7XG52YXIgJEpTT04gPSBnbG9iYWwuSlNPTjtcbnZhciBfc3RyaW5naWZ5ID0gJEpTT04gJiYgJEpTT04uc3RyaW5naWZ5O1xudmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xudmFyIEhJRERFTiA9IHdrcygnX2hpZGRlbicpO1xudmFyIFRPX1BSSU1JVElWRSA9IHdrcygndG9QcmltaXRpdmUnKTtcbnZhciBpc0VudW0gPSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBTeW1ib2xSZWdpc3RyeSA9IHNoYXJlZCgnc3ltYm9sLXJlZ2lzdHJ5Jyk7XG52YXIgQWxsU3ltYm9scyA9IHNoYXJlZCgnc3ltYm9scycpO1xudmFyIE9QU3ltYm9scyA9IHNoYXJlZCgnb3Atc3ltYm9scycpO1xudmFyIE9iamVjdFByb3RvID0gT2JqZWN0W1BST1RPVFlQRV07XG52YXIgVVNFX05BVElWRSA9IHR5cGVvZiAkU3ltYm9sID09ICdmdW5jdGlvbic7XG52YXIgUU9iamVjdCA9IGdsb2JhbC5RT2JqZWN0O1xuLy8gRG9uJ3QgdXNlIHNldHRlcnMgaW4gUXQgU2NyaXB0LCBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvMTczXG52YXIgc2V0dGVyID0gIVFPYmplY3QgfHwgIVFPYmplY3RbUFJPVE9UWVBFXSB8fCAhUU9iamVjdFtQUk9UT1RZUEVdLmZpbmRDaGlsZDtcblxuLy8gZmFsbGJhY2sgZm9yIG9sZCBBbmRyb2lkLCBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9Njg3XG52YXIgc2V0U3ltYm9sRGVzYyA9IERFU0NSSVBUT1JTICYmICRmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBfY3JlYXRlKGRQKHt9LCAnYScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRQKHRoaXMsICdhJywgeyB2YWx1ZTogNyB9KS5hOyB9XG4gIH0pKS5hICE9IDc7XG59KSA/IGZ1bmN0aW9uIChpdCwga2V5LCBEKSB7XG4gIHZhciBwcm90b0Rlc2MgPSBnT1BEKE9iamVjdFByb3RvLCBrZXkpO1xuICBpZiAocHJvdG9EZXNjKSBkZWxldGUgT2JqZWN0UHJvdG9ba2V5XTtcbiAgZFAoaXQsIGtleSwgRCk7XG4gIGlmIChwcm90b0Rlc2MgJiYgaXQgIT09IE9iamVjdFByb3RvKSBkUChPYmplY3RQcm90bywga2V5LCBwcm90b0Rlc2MpO1xufSA6IGRQO1xuXG52YXIgd3JhcCA9IGZ1bmN0aW9uICh0YWcpIHtcbiAgdmFyIHN5bSA9IEFsbFN5bWJvbHNbdGFnXSA9IF9jcmVhdGUoJFN5bWJvbFtQUk9UT1RZUEVdKTtcbiAgc3ltLl9rID0gdGFnO1xuICByZXR1cm4gc3ltO1xufTtcblxudmFyIGlzU3ltYm9sID0gVVNFX05BVElWRSAmJiB0eXBlb2YgJFN5bWJvbC5pdGVyYXRvciA9PSAnc3ltYm9sJyA/IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnO1xufSA6IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgaW5zdGFuY2VvZiAkU3ltYm9sO1xufTtcblxudmFyICRkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KGl0LCBrZXksIEQpIHtcbiAgaWYgKGl0ID09PSBPYmplY3RQcm90bykgJGRlZmluZVByb3BlcnR5KE9QU3ltYm9scywga2V5LCBEKTtcbiAgYW5PYmplY3QoaXQpO1xuICBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpO1xuICBhbk9iamVjdChEKTtcbiAgaWYgKGhhcyhBbGxTeW1ib2xzLCBrZXkpKSB7XG4gICAgaWYgKCFELmVudW1lcmFibGUpIHtcbiAgICAgIGlmICghaGFzKGl0LCBISURERU4pKSBkUChpdCwgSElEREVOLCBjcmVhdGVEZXNjKDEsIHt9KSk7XG4gICAgICBpdFtISURERU5dW2tleV0gPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaGFzKGl0LCBISURERU4pICYmIGl0W0hJRERFTl1ba2V5XSkgaXRbSElEREVOXVtrZXldID0gZmFsc2U7XG4gICAgICBEID0gX2NyZWF0ZShELCB7IGVudW1lcmFibGU6IGNyZWF0ZURlc2MoMCwgZmFsc2UpIH0pO1xuICAgIH0gcmV0dXJuIHNldFN5bWJvbERlc2MoaXQsIGtleSwgRCk7XG4gIH0gcmV0dXJuIGRQKGl0LCBrZXksIEQpO1xufTtcbnZhciAkZGVmaW5lUHJvcGVydGllcyA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoaXQsIFApIHtcbiAgYW5PYmplY3QoaXQpO1xuICB2YXIga2V5cyA9IGVudW1LZXlzKFAgPSB0b0lPYmplY3QoUCkpO1xuICB2YXIgaSA9IDA7XG4gIHZhciBsID0ga2V5cy5sZW5ndGg7XG4gIHZhciBrZXk7XG4gIHdoaWxlIChsID4gaSkgJGRlZmluZVByb3BlcnR5KGl0LCBrZXkgPSBrZXlzW2krK10sIFBba2V5XSk7XG4gIHJldHVybiBpdDtcbn07XG52YXIgJGNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShpdCwgUCkge1xuICByZXR1cm4gUCA9PT0gdW5kZWZpbmVkID8gX2NyZWF0ZShpdCkgOiAkZGVmaW5lUHJvcGVydGllcyhfY3JlYXRlKGl0KSwgUCk7XG59O1xudmFyICRwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IGZ1bmN0aW9uIHByb3BlcnR5SXNFbnVtZXJhYmxlKGtleSkge1xuICB2YXIgRSA9IGlzRW51bS5jYWxsKHRoaXMsIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSkpO1xuICBpZiAodGhpcyA9PT0gT2JqZWN0UHJvdG8gJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIWhhcyhPUFN5bWJvbHMsIGtleSkpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIEUgfHwgIWhhcyh0aGlzLCBrZXkpIHx8ICFoYXMoQWxsU3ltYm9scywga2V5KSB8fCBoYXModGhpcywgSElEREVOKSAmJiB0aGlzW0hJRERFTl1ba2V5XSA/IEUgOiB0cnVlO1xufTtcbnZhciAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGl0LCBrZXkpIHtcbiAgaXQgPSB0b0lPYmplY3QoaXQpO1xuICBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpO1xuICBpZiAoaXQgPT09IE9iamVjdFByb3RvICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICFoYXMoT1BTeW1ib2xzLCBrZXkpKSByZXR1cm47XG4gIHZhciBEID0gZ09QRChpdCwga2V5KTtcbiAgaWYgKEQgJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIShoYXMoaXQsIEhJRERFTikgJiYgaXRbSElEREVOXVtrZXldKSkgRC5lbnVtZXJhYmxlID0gdHJ1ZTtcbiAgcmV0dXJuIEQ7XG59O1xudmFyICRnZXRPd25Qcm9wZXJ0eU5hbWVzID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhpdCkge1xuICB2YXIgbmFtZXMgPSBnT1BOKHRvSU9iamVjdChpdCkpO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBpID0gMDtcbiAgdmFyIGtleTtcbiAgd2hpbGUgKG5hbWVzLmxlbmd0aCA+IGkpIHtcbiAgICBpZiAoIWhhcyhBbGxTeW1ib2xzLCBrZXkgPSBuYW1lc1tpKytdKSAmJiBrZXkgIT0gSElEREVOICYmIGtleSAhPSBNRVRBKSByZXN1bHQucHVzaChrZXkpO1xuICB9IHJldHVybiByZXN1bHQ7XG59O1xudmFyICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoaXQpIHtcbiAgdmFyIElTX09QID0gaXQgPT09IE9iamVjdFByb3RvO1xuICB2YXIgbmFtZXMgPSBnT1BOKElTX09QID8gT1BTeW1ib2xzIDogdG9JT2JqZWN0KGl0KSk7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGkgPSAwO1xuICB2YXIga2V5O1xuICB3aGlsZSAobmFtZXMubGVuZ3RoID4gaSkge1xuICAgIGlmIChoYXMoQWxsU3ltYm9scywga2V5ID0gbmFtZXNbaSsrXSkgJiYgKElTX09QID8gaGFzKE9iamVjdFByb3RvLCBrZXkpIDogdHJ1ZSkpIHJlc3VsdC5wdXNoKEFsbFN5bWJvbHNba2V5XSk7XG4gIH0gcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8vIDE5LjQuMS4xIFN5bWJvbChbZGVzY3JpcHRpb25dKVxuaWYgKCFVU0VfTkFUSVZFKSB7XG4gICRTeW1ib2wgPSBmdW5jdGlvbiBTeW1ib2woKSB7XG4gICAgaWYgKHRoaXMgaW5zdGFuY2VvZiAkU3ltYm9sKSB0aHJvdyBUeXBlRXJyb3IoJ1N5bWJvbCBpcyBub3QgYSBjb25zdHJ1Y3RvciEnKTtcbiAgICB2YXIgdGFnID0gdWlkKGFyZ3VtZW50cy5sZW5ndGggPiAwID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTtcbiAgICB2YXIgJHNldCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgaWYgKHRoaXMgPT09IE9iamVjdFByb3RvKSAkc2V0LmNhbGwoT1BTeW1ib2xzLCB2YWx1ZSk7XG4gICAgICBpZiAoaGFzKHRoaXMsIEhJRERFTikgJiYgaGFzKHRoaXNbSElEREVOXSwgdGFnKSkgdGhpc1tISURERU5dW3RhZ10gPSBmYWxzZTtcbiAgICAgIHNldFN5bWJvbERlc2ModGhpcywgdGFnLCBjcmVhdGVEZXNjKDEsIHZhbHVlKSk7XG4gICAgfTtcbiAgICBpZiAoREVTQ1JJUFRPUlMgJiYgc2V0dGVyKSBzZXRTeW1ib2xEZXNjKE9iamVjdFByb3RvLCB0YWcsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBzZXQ6ICRzZXQgfSk7XG4gICAgcmV0dXJuIHdyYXAodGFnKTtcbiAgfTtcbiAgcmVkZWZpbmUoJFN5bWJvbFtQUk9UT1RZUEVdLCAndG9TdHJpbmcnLCBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5faztcbiAgfSk7XG5cbiAgJEdPUEQuZiA9ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG4gICREUC5mID0gJGRlZmluZVByb3BlcnR5O1xuICByZXF1aXJlKCcuL19vYmplY3QtZ29wbicpLmYgPSBnT1BORXh0LmYgPSAkZ2V0T3duUHJvcGVydHlOYW1lcztcbiAgcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpLmYgPSAkcHJvcGVydHlJc0VudW1lcmFibGU7XG4gIHJlcXVpcmUoJy4vX29iamVjdC1nb3BzJykuZiA9ICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cbiAgaWYgKERFU0NSSVBUT1JTICYmICFyZXF1aXJlKCcuL19saWJyYXJ5JykpIHtcbiAgICByZWRlZmluZShPYmplY3RQcm90bywgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJywgJHByb3BlcnR5SXNFbnVtZXJhYmxlLCB0cnVlKTtcbiAgfVxuXG4gIHdrc0V4dC5mID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICByZXR1cm4gd3JhcCh3a3MobmFtZSkpO1xuICB9O1xufVxuXG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuVyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCB7IFN5bWJvbDogJFN5bWJvbCB9KTtcblxuZm9yICh2YXIgZXM2U3ltYm9scyA9IChcbiAgLy8gMTkuNC4yLjIsIDE5LjQuMi4zLCAxOS40LjIuNCwgMTkuNC4yLjYsIDE5LjQuMi44LCAxOS40LjIuOSwgMTkuNC4yLjEwLCAxOS40LjIuMTEsIDE5LjQuMi4xMiwgMTkuNC4yLjEzLCAxOS40LjIuMTRcbiAgJ2hhc0luc3RhbmNlLGlzQ29uY2F0U3ByZWFkYWJsZSxpdGVyYXRvcixtYXRjaCxyZXBsYWNlLHNlYXJjaCxzcGVjaWVzLHNwbGl0LHRvUHJpbWl0aXZlLHRvU3RyaW5nVGFnLHVuc2NvcGFibGVzJ1xuKS5zcGxpdCgnLCcpLCBqID0gMDsgZXM2U3ltYm9scy5sZW5ndGggPiBqOyl3a3MoZXM2U3ltYm9sc1tqKytdKTtcblxuZm9yICh2YXIgd2VsbEtub3duU3ltYm9scyA9ICRrZXlzKHdrcy5zdG9yZSksIGsgPSAwOyB3ZWxsS25vd25TeW1ib2xzLmxlbmd0aCA+IGs7KSB3a3NEZWZpbmUod2VsbEtub3duU3ltYm9sc1trKytdKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgJ1N5bWJvbCcsIHtcbiAgLy8gMTkuNC4yLjEgU3ltYm9sLmZvcihrZXkpXG4gICdmb3InOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIGhhcyhTeW1ib2xSZWdpc3RyeSwga2V5ICs9ICcnKVxuICAgICAgPyBTeW1ib2xSZWdpc3RyeVtrZXldXG4gICAgICA6IFN5bWJvbFJlZ2lzdHJ5W2tleV0gPSAkU3ltYm9sKGtleSk7XG4gIH0sXG4gIC8vIDE5LjQuMi41IFN5bWJvbC5rZXlGb3Ioc3ltKVxuICBrZXlGb3I6IGZ1bmN0aW9uIGtleUZvcihzeW0pIHtcbiAgICBpZiAoIWlzU3ltYm9sKHN5bSkpIHRocm93IFR5cGVFcnJvcihzeW0gKyAnIGlzIG5vdCBhIHN5bWJvbCEnKTtcbiAgICBmb3IgKHZhciBrZXkgaW4gU3ltYm9sUmVnaXN0cnkpIGlmIChTeW1ib2xSZWdpc3RyeVtrZXldID09PSBzeW0pIHJldHVybiBrZXk7XG4gIH0sXG4gIHVzZVNldHRlcjogZnVuY3Rpb24gKCkgeyBzZXR0ZXIgPSB0cnVlOyB9LFxuICB1c2VTaW1wbGU6IGZ1bmN0aW9uICgpIHsgc2V0dGVyID0gZmFsc2U7IH1cbn0pO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCAnT2JqZWN0Jywge1xuICAvLyAxOS4xLjIuMiBPYmplY3QuY3JlYXRlKE8gWywgUHJvcGVydGllc10pXG4gIGNyZWF0ZTogJGNyZWF0ZSxcbiAgLy8gMTkuMS4yLjQgT2JqZWN0LmRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpXG4gIGRlZmluZVByb3BlcnR5OiAkZGVmaW5lUHJvcGVydHksXG4gIC8vIDE5LjEuMi4zIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpXG4gIGRlZmluZVByb3BlcnRpZXM6ICRkZWZpbmVQcm9wZXJ0aWVzLFxuICAvLyAxOS4xLjIuNiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApXG4gIGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogJGdldE93blByb3BlcnR5RGVzY3JpcHRvcixcbiAgLy8gMTkuMS4yLjcgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTylcbiAgZ2V0T3duUHJvcGVydHlOYW1lczogJGdldE93blByb3BlcnR5TmFtZXMsXG4gIC8vIDE5LjEuMi44IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoTylcbiAgZ2V0T3duUHJvcGVydHlTeW1ib2xzOiAkZ2V0T3duUHJvcGVydHlTeW1ib2xzXG59KTtcblxuLy8gMjQuMy4yIEpTT04uc3RyaW5naWZ5KHZhbHVlIFssIHJlcGxhY2VyIFssIHNwYWNlXV0pXG4kSlNPTiAmJiAkZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICghVVNFX05BVElWRSB8fCAkZmFpbHMoZnVuY3Rpb24gKCkge1xuICB2YXIgUyA9ICRTeW1ib2woKTtcbiAgLy8gTVMgRWRnZSBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMge31cbiAgLy8gV2ViS2l0IGNvbnZlcnRzIHN5bWJvbCB2YWx1ZXMgdG8gSlNPTiBhcyBudWxsXG4gIC8vIFY4IHRocm93cyBvbiBib3hlZCBzeW1ib2xzXG4gIHJldHVybiBfc3RyaW5naWZ5KFtTXSkgIT0gJ1tudWxsXScgfHwgX3N0cmluZ2lmeSh7IGE6IFMgfSkgIT0gJ3t9JyB8fCBfc3RyaW5naWZ5KE9iamVjdChTKSkgIT0gJ3t9Jztcbn0pKSwgJ0pTT04nLCB7XG4gIHN0cmluZ2lmeTogZnVuY3Rpb24gc3RyaW5naWZ5KGl0KSB7XG4gICAgaWYgKGl0ID09PSB1bmRlZmluZWQgfHwgaXNTeW1ib2woaXQpKSByZXR1cm47IC8vIElFOCByZXR1cm5zIHN0cmluZyBvbiB1bmRlZmluZWRcbiAgICB2YXIgYXJncyA9IFtpdF07XG4gICAgdmFyIGkgPSAxO1xuICAgIHZhciByZXBsYWNlciwgJHJlcGxhY2VyO1xuICAgIHdoaWxlIChhcmd1bWVudHMubGVuZ3RoID4gaSkgYXJncy5wdXNoKGFyZ3VtZW50c1tpKytdKTtcbiAgICByZXBsYWNlciA9IGFyZ3NbMV07XG4gICAgaWYgKHR5cGVvZiByZXBsYWNlciA9PSAnZnVuY3Rpb24nKSAkcmVwbGFjZXIgPSByZXBsYWNlcjtcbiAgICBpZiAoJHJlcGxhY2VyIHx8ICFpc0FycmF5KHJlcGxhY2VyKSkgcmVwbGFjZXIgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgaWYgKCRyZXBsYWNlcikgdmFsdWUgPSAkcmVwbGFjZXIuY2FsbCh0aGlzLCBrZXksIHZhbHVlKTtcbiAgICAgIGlmICghaXNTeW1ib2wodmFsdWUpKSByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICBhcmdzWzFdID0gcmVwbGFjZXI7XG4gICAgcmV0dXJuIF9zdHJpbmdpZnkuYXBwbHkoJEpTT04sIGFyZ3MpO1xuICB9XG59KTtcblxuLy8gMTkuNC4zLjQgU3ltYm9sLnByb3RvdHlwZVtAQHRvUHJpbWl0aXZlXShoaW50KVxuJFN5bWJvbFtQUk9UT1RZUEVdW1RPX1BSSU1JVElWRV0gfHwgcmVxdWlyZSgnLi9faGlkZScpKCRTeW1ib2xbUFJPVE9UWVBFXSwgVE9fUFJJTUlUSVZFLCAkU3ltYm9sW1BST1RPVFlQRV0udmFsdWVPZik7XG4vLyAxOS40LjMuNSBTeW1ib2wucHJvdG90eXBlW0BAdG9TdHJpbmdUYWddXG5zZXRUb1N0cmluZ1RhZygkU3ltYm9sLCAnU3ltYm9sJyk7XG4vLyAyMC4yLjEuOSBNYXRoW0BAdG9TdHJpbmdUYWddXG5zZXRUb1N0cmluZ1RhZyhNYXRoLCAnTWF0aCcsIHRydWUpO1xuLy8gMjQuMy4zIEpTT05bQEB0b1N0cmluZ1RhZ11cbnNldFRvU3RyaW5nVGFnKGdsb2JhbC5KU09OLCAnSlNPTicsIHRydWUpO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkdHlwZWQgPSByZXF1aXJlKCcuL190eXBlZCcpO1xudmFyIGJ1ZmZlciA9IHJlcXVpcmUoJy4vX3R5cGVkLWJ1ZmZlcicpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gcmVxdWlyZSgnLi9fdG8tYWJzb2x1dGUtaW5kZXgnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgQXJyYXlCdWZmZXIgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5BcnJheUJ1ZmZlcjtcbnZhciBzcGVjaWVzQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuL19zcGVjaWVzLWNvbnN0cnVjdG9yJyk7XG52YXIgJEFycmF5QnVmZmVyID0gYnVmZmVyLkFycmF5QnVmZmVyO1xudmFyICREYXRhVmlldyA9IGJ1ZmZlci5EYXRhVmlldztcbnZhciAkaXNWaWV3ID0gJHR5cGVkLkFCViAmJiBBcnJheUJ1ZmZlci5pc1ZpZXc7XG52YXIgJHNsaWNlID0gJEFycmF5QnVmZmVyLnByb3RvdHlwZS5zbGljZTtcbnZhciBWSUVXID0gJHR5cGVkLlZJRVc7XG52YXIgQVJSQVlfQlVGRkVSID0gJ0FycmF5QnVmZmVyJztcblxuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAoQXJyYXlCdWZmZXIgIT09ICRBcnJheUJ1ZmZlciksIHsgQXJyYXlCdWZmZXI6ICRBcnJheUJ1ZmZlciB9KTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhJHR5cGVkLkNPTlNUUiwgQVJSQVlfQlVGRkVSLCB7XG4gIC8vIDI0LjEuMy4xIEFycmF5QnVmZmVyLmlzVmlldyhhcmcpXG4gIGlzVmlldzogZnVuY3Rpb24gaXNWaWV3KGl0KSB7XG4gICAgcmV0dXJuICRpc1ZpZXcgJiYgJGlzVmlldyhpdCkgfHwgaXNPYmplY3QoaXQpICYmIFZJRVcgaW4gaXQ7XG4gIH1cbn0pO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuVSArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gIW5ldyAkQXJyYXlCdWZmZXIoMikuc2xpY2UoMSwgdW5kZWZpbmVkKS5ieXRlTGVuZ3RoO1xufSksIEFSUkFZX0JVRkZFUiwge1xuICAvLyAyNC4xLjQuMyBBcnJheUJ1ZmZlci5wcm90b3R5cGUuc2xpY2Uoc3RhcnQsIGVuZClcbiAgc2xpY2U6IGZ1bmN0aW9uIHNsaWNlKHN0YXJ0LCBlbmQpIHtcbiAgICBpZiAoJHNsaWNlICE9PSB1bmRlZmluZWQgJiYgZW5kID09PSB1bmRlZmluZWQpIHJldHVybiAkc2xpY2UuY2FsbChhbk9iamVjdCh0aGlzKSwgc3RhcnQpOyAvLyBGRiBmaXhcbiAgICB2YXIgbGVuID0gYW5PYmplY3QodGhpcykuYnl0ZUxlbmd0aDtcbiAgICB2YXIgZmlyc3QgPSB0b0Fic29sdXRlSW5kZXgoc3RhcnQsIGxlbik7XG4gICAgdmFyIGZpbmFsID0gdG9BYnNvbHV0ZUluZGV4KGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogZW5kLCBsZW4pO1xuICAgIHZhciByZXN1bHQgPSBuZXcgKHNwZWNpZXNDb25zdHJ1Y3Rvcih0aGlzLCAkQXJyYXlCdWZmZXIpKSh0b0xlbmd0aChmaW5hbCAtIGZpcnN0KSk7XG4gICAgdmFyIHZpZXdTID0gbmV3ICREYXRhVmlldyh0aGlzKTtcbiAgICB2YXIgdmlld1QgPSBuZXcgJERhdGFWaWV3KHJlc3VsdCk7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB3aGlsZSAoZmlyc3QgPCBmaW5hbCkge1xuICAgICAgdmlld1Quc2V0VWludDgoaW5kZXgrKywgdmlld1MuZ2V0VWludDgoZmlyc3QrKykpO1xuICAgIH0gcmV0dXJuIHJlc3VsdDtcbiAgfVxufSk7XG5cbnJlcXVpcmUoJy4vX3NldC1zcGVjaWVzJykoQVJSQVlfQlVGRkVSKTtcbiIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuVyArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL190eXBlZCcpLkFCViwge1xuICBEYXRhVmlldzogcmVxdWlyZSgnLi9fdHlwZWQtYnVmZmVyJykuRGF0YVZpZXdcbn0pO1xuIiwicmVxdWlyZSgnLi9fdHlwZWQtYXJyYXknKSgnRmxvYXQzMicsIDQsIGZ1bmN0aW9uIChpbml0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBGbG9hdDMyQXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcbn0pO1xuIiwicmVxdWlyZSgnLi9fdHlwZWQtYXJyYXknKSgnRmxvYXQ2NCcsIDgsIGZ1bmN0aW9uIChpbml0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBGbG9hdDY0QXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcbn0pO1xuIiwicmVxdWlyZSgnLi9fdHlwZWQtYXJyYXknKSgnSW50MTYnLCAyLCBmdW5jdGlvbiAoaW5pdCkge1xuICByZXR1cm4gZnVuY3Rpb24gSW50MTZBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7XG4iLCJyZXF1aXJlKCcuL190eXBlZC1hcnJheScpKCdJbnQzMicsIDQsIGZ1bmN0aW9uIChpbml0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBJbnQzMkFycmF5KGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59KTtcbiIsInJlcXVpcmUoJy4vX3R5cGVkLWFycmF5JykoJ0ludDgnLCAxLCBmdW5jdGlvbiAoaW5pdCkge1xuICByZXR1cm4gZnVuY3Rpb24gSW50OEFycmF5KGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59KTtcbiIsInJlcXVpcmUoJy4vX3R5cGVkLWFycmF5JykoJ1VpbnQxNicsIDIsIGZ1bmN0aW9uIChpbml0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBVaW50MTZBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7XG4iLCJyZXF1aXJlKCcuL190eXBlZC1hcnJheScpKCdVaW50MzInLCA0LCBmdW5jdGlvbiAoaW5pdCkge1xuICByZXR1cm4gZnVuY3Rpb24gVWludDMyQXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcbn0pO1xuIiwicmVxdWlyZSgnLi9fdHlwZWQtYXJyYXknKSgnVWludDgnLCAxLCBmdW5jdGlvbiAoaW5pdCkge1xuICByZXR1cm4gZnVuY3Rpb24gVWludDhBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7XG4iLCJyZXF1aXJlKCcuL190eXBlZC1hcnJheScpKCdVaW50OCcsIDEsIGZ1bmN0aW9uIChpbml0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBVaW50OENsYW1wZWRBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSwgdHJ1ZSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZWFjaCA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKSgwKTtcbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJyk7XG52YXIgbWV0YSA9IHJlcXVpcmUoJy4vX21ldGEnKTtcbnZhciBhc3NpZ24gPSByZXF1aXJlKCcuL19vYmplY3QtYXNzaWduJyk7XG52YXIgd2VhayA9IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24td2VhaycpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xudmFyIHZhbGlkYXRlID0gcmVxdWlyZSgnLi9fdmFsaWRhdGUtY29sbGVjdGlvbicpO1xudmFyIFdFQUtfTUFQID0gJ1dlYWtNYXAnO1xudmFyIGdldFdlYWsgPSBtZXRhLmdldFdlYWs7XG52YXIgaXNFeHRlbnNpYmxlID0gT2JqZWN0LmlzRXh0ZW5zaWJsZTtcbnZhciB1bmNhdWdodEZyb3plblN0b3JlID0gd2Vhay51ZnN0b3JlO1xudmFyIHRtcCA9IHt9O1xudmFyIEludGVybmFsTWFwO1xuXG52YXIgd3JhcHBlciA9IGZ1bmN0aW9uIChnZXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIFdlYWtNYXAoKSB7XG4gICAgcmV0dXJuIGdldCh0aGlzLCBhcmd1bWVudHMubGVuZ3RoID4gMCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7XG4gIH07XG59O1xuXG52YXIgbWV0aG9kcyA9IHtcbiAgLy8gMjMuMy4zLjMgV2Vha01hcC5wcm90b3R5cGUuZ2V0KGtleSlcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoa2V5KSB7XG4gICAgaWYgKGlzT2JqZWN0KGtleSkpIHtcbiAgICAgIHZhciBkYXRhID0gZ2V0V2VhayhrZXkpO1xuICAgICAgaWYgKGRhdGEgPT09IHRydWUpIHJldHVybiB1bmNhdWdodEZyb3plblN0b3JlKHZhbGlkYXRlKHRoaXMsIFdFQUtfTUFQKSkuZ2V0KGtleSk7XG4gICAgICByZXR1cm4gZGF0YSA/IGRhdGFbdGhpcy5faV0gOiB1bmRlZmluZWQ7XG4gICAgfVxuICB9LFxuICAvLyAyMy4zLjMuNSBXZWFrTWFwLnByb3RvdHlwZS5zZXQoa2V5LCB2YWx1ZSlcbiAgc2V0OiBmdW5jdGlvbiBzZXQoa2V5LCB2YWx1ZSkge1xuICAgIHJldHVybiB3ZWFrLmRlZih2YWxpZGF0ZSh0aGlzLCBXRUFLX01BUCksIGtleSwgdmFsdWUpO1xuICB9XG59O1xuXG4vLyAyMy4zIFdlYWtNYXAgT2JqZWN0c1xudmFyICRXZWFrTWFwID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19jb2xsZWN0aW9uJykoV0VBS19NQVAsIHdyYXBwZXIsIG1ldGhvZHMsIHdlYWssIHRydWUsIHRydWUpO1xuXG4vLyBJRTExIFdlYWtNYXAgZnJvemVuIGtleXMgZml4XG5pZiAoZmFpbHMoZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3ICRXZWFrTWFwKCkuc2V0KChPYmplY3QuZnJlZXplIHx8IE9iamVjdCkodG1wKSwgNykuZ2V0KHRtcCkgIT0gNzsgfSkpIHtcbiAgSW50ZXJuYWxNYXAgPSB3ZWFrLmdldENvbnN0cnVjdG9yKHdyYXBwZXIsIFdFQUtfTUFQKTtcbiAgYXNzaWduKEludGVybmFsTWFwLnByb3RvdHlwZSwgbWV0aG9kcyk7XG4gIG1ldGEuTkVFRCA9IHRydWU7XG4gIGVhY2goWydkZWxldGUnLCAnaGFzJywgJ2dldCcsICdzZXQnXSwgZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciBwcm90byA9ICRXZWFrTWFwLnByb3RvdHlwZTtcbiAgICB2YXIgbWV0aG9kID0gcHJvdG9ba2V5XTtcbiAgICByZWRlZmluZShwcm90bywga2V5LCBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgLy8gc3RvcmUgZnJvemVuIG9iamVjdHMgb24gaW50ZXJuYWwgd2Vha21hcCBzaGltXG4gICAgICBpZiAoaXNPYmplY3QoYSkgJiYgIWlzRXh0ZW5zaWJsZShhKSkge1xuICAgICAgICBpZiAoIXRoaXMuX2YpIHRoaXMuX2YgPSBuZXcgSW50ZXJuYWxNYXAoKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuX2Zba2V5XShhLCBiKTtcbiAgICAgICAgcmV0dXJuIGtleSA9PSAnc2V0JyA/IHRoaXMgOiByZXN1bHQ7XG4gICAgICAvLyBzdG9yZSBhbGwgdGhlIHJlc3Qgb24gbmF0aXZlIHdlYWttYXBcbiAgICAgIH0gcmV0dXJuIG1ldGhvZC5jYWxsKHRoaXMsIGEsIGIpO1xuICAgIH0pO1xuICB9KTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcbnZhciB3ZWFrID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbi13ZWFrJyk7XG52YXIgdmFsaWRhdGUgPSByZXF1aXJlKCcuL192YWxpZGF0ZS1jb2xsZWN0aW9uJyk7XG52YXIgV0VBS19TRVQgPSAnV2Vha1NldCc7XG5cbi8vIDIzLjQgV2Vha1NldCBPYmplY3RzXG5yZXF1aXJlKCcuL19jb2xsZWN0aW9uJykoV0VBS19TRVQsIGZ1bmN0aW9uIChnZXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIFdlYWtTZXQoKSB7IHJldHVybiBnZXQodGhpcywgYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpOyB9O1xufSwge1xuICAvLyAyMy40LjMuMSBXZWFrU2V0LnByb3RvdHlwZS5hZGQodmFsdWUpXG4gIGFkZDogZnVuY3Rpb24gYWRkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHdlYWsuZGVmKHZhbGlkYXRlKHRoaXMsIFdFQUtfU0VUKSwgdmFsdWUsIHRydWUpO1xuICB9XG59LCB3ZWFrLCBmYWxzZSwgdHJ1ZSk7XG4iLCIndXNlIHN0cmljdCc7XG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL3Byb3Bvc2FsLWZsYXRNYXAvI3NlYy1BcnJheS5wcm90b3R5cGUuZmxhdE1hcFxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBmbGF0dGVuSW50b0FycmF5ID0gcmVxdWlyZSgnLi9fZmxhdHRlbi1pbnRvLWFycmF5Jyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcbnZhciBhcnJheVNwZWNpZXNDcmVhdGUgPSByZXF1aXJlKCcuL19hcnJheS1zcGVjaWVzLWNyZWF0ZScpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCwgJ0FycmF5Jywge1xuICBmbGF0TWFwOiBmdW5jdGlvbiBmbGF0TWFwKGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKSB7XG4gICAgdmFyIE8gPSB0b09iamVjdCh0aGlzKTtcbiAgICB2YXIgc291cmNlTGVuLCBBO1xuICAgIGFGdW5jdGlvbihjYWxsYmFja2ZuKTtcbiAgICBzb3VyY2VMZW4gPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gICAgQSA9IGFycmF5U3BlY2llc0NyZWF0ZShPLCAwKTtcbiAgICBmbGF0dGVuSW50b0FycmF5KEEsIE8sIE8sIHNvdXJjZUxlbiwgMCwgMSwgY2FsbGJhY2tmbiwgYXJndW1lbnRzWzFdKTtcbiAgICByZXR1cm4gQTtcbiAgfVxufSk7XG5cbnJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpKCdmbGF0TWFwJyk7XG4iLCIndXNlIHN0cmljdCc7XG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL3Byb3Bvc2FsLWZsYXRNYXAvI3NlYy1BcnJheS5wcm90b3R5cGUuZmxhdHRlblxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBmbGF0dGVuSW50b0FycmF5ID0gcmVxdWlyZSgnLi9fZmxhdHRlbi1pbnRvLWFycmF5Jyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcbnZhciBhcnJheVNwZWNpZXNDcmVhdGUgPSByZXF1aXJlKCcuL19hcnJheS1zcGVjaWVzLWNyZWF0ZScpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCwgJ0FycmF5Jywge1xuICBmbGF0dGVuOiBmdW5jdGlvbiBmbGF0dGVuKC8qIGRlcHRoQXJnID0gMSAqLykge1xuICAgIHZhciBkZXB0aEFyZyA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgTyA9IHRvT2JqZWN0KHRoaXMpO1xuICAgIHZhciBzb3VyY2VMZW4gPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gICAgdmFyIEEgPSBhcnJheVNwZWNpZXNDcmVhdGUoTywgMCk7XG4gICAgZmxhdHRlbkludG9BcnJheShBLCBPLCBPLCBzb3VyY2VMZW4sIDAsIGRlcHRoQXJnID09PSB1bmRlZmluZWQgPyAxIDogdG9JbnRlZ2VyKGRlcHRoQXJnKSk7XG4gICAgcmV0dXJuIEE7XG4gIH1cbn0pO1xuXG5yZXF1aXJlKCcuL19hZGQtdG8tdW5zY29wYWJsZXMnKSgnZmxhdHRlbicpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvQXJyYXkucHJvdG90eXBlLmluY2x1ZGVzXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRpbmNsdWRlcyA9IHJlcXVpcmUoJy4vX2FycmF5LWluY2x1ZGVzJykodHJ1ZSk7XG5cbiRleHBvcnQoJGV4cG9ydC5QLCAnQXJyYXknLCB7XG4gIGluY2x1ZGVzOiBmdW5jdGlvbiBpbmNsdWRlcyhlbCAvKiAsIGZyb21JbmRleCA9IDAgKi8pIHtcbiAgICByZXR1cm4gJGluY2x1ZGVzKHRoaXMsIGVsLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gIH1cbn0pO1xuXG5yZXF1aXJlKCcuL19hZGQtdG8tdW5zY29wYWJsZXMnKSgnaW5jbHVkZXMnKTtcbiIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9yd2FsZHJvbi90YzM5LW5vdGVzL2Jsb2IvbWFzdGVyL2VzNi8yMDE0LTA5L3NlcHQtMjUubWQjNTEwLWdsb2JhbGFzYXAtZm9yLWVucXVldWluZy1hLW1pY3JvdGFza1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBtaWNyb3Rhc2sgPSByZXF1aXJlKCcuL19taWNyb3Rhc2snKSgpO1xudmFyIHByb2Nlc3MgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5wcm9jZXNzO1xudmFyIGlzTm9kZSA9IHJlcXVpcmUoJy4vX2NvZicpKHByb2Nlc3MpID09ICdwcm9jZXNzJztcblxuJGV4cG9ydCgkZXhwb3J0LkcsIHtcbiAgYXNhcDogZnVuY3Rpb24gYXNhcChmbikge1xuICAgIHZhciBkb21haW4gPSBpc05vZGUgJiYgcHJvY2Vzcy5kb21haW47XG4gICAgbWljcm90YXNrKGRvbWFpbiA/IGRvbWFpbi5iaW5kKGZuKSA6IGZuKTtcbiAgfVxufSk7XG4iLCIvLyBodHRwczovL2dpdGh1Yi5jb20vbGpoYXJiL3Byb3Bvc2FsLWlzLWVycm9yXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ0Vycm9yJywge1xuICBpc0Vycm9yOiBmdW5jdGlvbiBpc0Vycm9yKGl0KSB7XG4gICAgcmV0dXJuIGNvZihpdCkgPT09ICdFcnJvcic7XG4gIH1cbn0pO1xuIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtZ2xvYmFsXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuRywgeyBnbG9iYWw6IHJlcXVpcmUoJy4vX2dsb2JhbCcpIH0pO1xuIiwiLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9wcm9wb3NhbC1zZXRtYXAtb2Zmcm9tLyNzZWMtbWFwLmZyb21cbnJlcXVpcmUoJy4vX3NldC1jb2xsZWN0aW9uLWZyb20nKSgnTWFwJyk7XG4iLCIvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL3Byb3Bvc2FsLXNldG1hcC1vZmZyb20vI3NlYy1tYXAub2ZcbnJlcXVpcmUoJy4vX3NldC1jb2xsZWN0aW9uLW9mJykoJ01hcCcpO1xuIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL0RhdmlkQnJ1YW50L01hcC1TZXQucHJvdG90eXBlLnRvSlNPTlxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LlIsICdNYXAnLCB7IHRvSlNPTjogcmVxdWlyZSgnLi9fY29sbGVjdGlvbi10by1qc29uJykoJ01hcCcpIH0pO1xuIiwiLy8gaHR0cHM6Ly9yd2FsZHJvbi5naXRodWIuaW8vcHJvcG9zYWwtbWF0aC1leHRlbnNpb25zL1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBjbGFtcDogZnVuY3Rpb24gY2xhbXAoeCwgbG93ZXIsIHVwcGVyKSB7XG4gICAgcmV0dXJuIE1hdGgubWluKHVwcGVyLCBNYXRoLm1heChsb3dlciwgeCkpO1xuICB9XG59KTtcbiIsIi8vIGh0dHBzOi8vcndhbGRyb24uZ2l0aHViLmlvL3Byb3Bvc2FsLW1hdGgtZXh0ZW5zaW9ucy9cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHsgREVHX1BFUl9SQUQ6IE1hdGguUEkgLyAxODAgfSk7XG4iLCIvLyBodHRwczovL3J3YWxkcm9uLmdpdGh1Yi5pby9wcm9wb3NhbC1tYXRoLWV4dGVuc2lvbnMvXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIFJBRF9QRVJfREVHID0gMTgwIC8gTWF0aC5QSTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBkZWdyZWVzOiBmdW5jdGlvbiBkZWdyZWVzKHJhZGlhbnMpIHtcbiAgICByZXR1cm4gcmFkaWFucyAqIFJBRF9QRVJfREVHO1xuICB9XG59KTtcbiIsIi8vIGh0dHBzOi8vcndhbGRyb24uZ2l0aHViLmlvL3Byb3Bvc2FsLW1hdGgtZXh0ZW5zaW9ucy9cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgc2NhbGUgPSByZXF1aXJlKCcuL19tYXRoLXNjYWxlJyk7XG52YXIgZnJvdW5kID0gcmVxdWlyZSgnLi9fbWF0aC1mcm91bmQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBmc2NhbGU6IGZ1bmN0aW9uIGZzY2FsZSh4LCBpbkxvdywgaW5IaWdoLCBvdXRMb3csIG91dEhpZ2gpIHtcbiAgICByZXR1cm4gZnJvdW5kKHNjYWxlKHgsIGluTG93LCBpbkhpZ2gsIG91dExvdywgb3V0SGlnaCkpO1xuICB9XG59KTtcbiIsIi8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL0JyZW5kYW5FaWNoLzQyOTRkNWMyMTJhNmQyMjU0NzAzXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGlhZGRoOiBmdW5jdGlvbiBpYWRkaCh4MCwgeDEsIHkwLCB5MSkge1xuICAgIHZhciAkeDAgPSB4MCA+Pj4gMDtcbiAgICB2YXIgJHgxID0geDEgPj4+IDA7XG4gICAgdmFyICR5MCA9IHkwID4+PiAwO1xuICAgIHJldHVybiAkeDEgKyAoeTEgPj4+IDApICsgKCgkeDAgJiAkeTAgfCAoJHgwIHwgJHkwKSAmIH4oJHgwICsgJHkwID4+PiAwKSkgPj4+IDMxKSB8IDA7XG4gIH1cbn0pO1xuIiwiLy8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vQnJlbmRhbkVpY2gvNDI5NGQ1YzIxMmE2ZDIyNTQ3MDNcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgaW11bGg6IGZ1bmN0aW9uIGltdWxoKHUsIHYpIHtcbiAgICB2YXIgVUlOVDE2ID0gMHhmZmZmO1xuICAgIHZhciAkdSA9ICt1O1xuICAgIHZhciAkdiA9ICt2O1xuICAgIHZhciB1MCA9ICR1ICYgVUlOVDE2O1xuICAgIHZhciB2MCA9ICR2ICYgVUlOVDE2O1xuICAgIHZhciB1MSA9ICR1ID4+IDE2O1xuICAgIHZhciB2MSA9ICR2ID4+IDE2O1xuICAgIHZhciB0ID0gKHUxICogdjAgPj4+IDApICsgKHUwICogdjAgPj4+IDE2KTtcbiAgICByZXR1cm4gdTEgKiB2MSArICh0ID4+IDE2KSArICgodTAgKiB2MSA+Pj4gMCkgKyAodCAmIFVJTlQxNikgPj4gMTYpO1xuICB9XG59KTtcbiIsIi8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL0JyZW5kYW5FaWNoLzQyOTRkNWMyMTJhNmQyMjU0NzAzXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGlzdWJoOiBmdW5jdGlvbiBpc3ViaCh4MCwgeDEsIHkwLCB5MSkge1xuICAgIHZhciAkeDAgPSB4MCA+Pj4gMDtcbiAgICB2YXIgJHgxID0geDEgPj4+IDA7XG4gICAgdmFyICR5MCA9IHkwID4+PiAwO1xuICAgIHJldHVybiAkeDEgLSAoeTEgPj4+IDApIC0gKCh+JHgwICYgJHkwIHwgfigkeDAgXiAkeTApICYgJHgwIC0gJHkwID4+PiAwKSA+Pj4gMzEpIHwgMDtcbiAgfVxufSk7XG4iLCIvLyBodHRwczovL3J3YWxkcm9uLmdpdGh1Yi5pby9wcm9wb3NhbC1tYXRoLWV4dGVuc2lvbnMvXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7IFJBRF9QRVJfREVHOiAxODAgLyBNYXRoLlBJIH0pO1xuIiwiLy8gaHR0cHM6Ly9yd2FsZHJvbi5naXRodWIuaW8vcHJvcG9zYWwtbWF0aC1leHRlbnNpb25zL1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBERUdfUEVSX1JBRCA9IE1hdGguUEkgLyAxODA7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgcmFkaWFuczogZnVuY3Rpb24gcmFkaWFucyhkZWdyZWVzKSB7XG4gICAgcmV0dXJuIGRlZ3JlZXMgKiBERUdfUEVSX1JBRDtcbiAgfVxufSk7XG4iLCIvLyBodHRwczovL3J3YWxkcm9uLmdpdGh1Yi5pby9wcm9wb3NhbC1tYXRoLWV4dGVuc2lvbnMvXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7IHNjYWxlOiByZXF1aXJlKCcuL19tYXRoLXNjYWxlJykgfSk7XG4iLCIvLyBodHRwOi8vamZiYXN0aWVuLmdpdGh1Yi5pby9wYXBlcnMvTWF0aC5zaWduYml0Lmh0bWxcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHsgc2lnbmJpdDogZnVuY3Rpb24gc2lnbmJpdCh4KSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgcmV0dXJuICh4ID0gK3gpICE9IHggPyB4IDogeCA9PSAwID8gMSAvIHggPT0gSW5maW5pdHkgOiB4ID4gMDtcbn0gfSk7XG4iLCIvLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9CcmVuZGFuRWljaC80Mjk0ZDVjMjEyYTZkMjI1NDcwM1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICB1bXVsaDogZnVuY3Rpb24gdW11bGgodSwgdikge1xuICAgIHZhciBVSU5UMTYgPSAweGZmZmY7XG4gICAgdmFyICR1ID0gK3U7XG4gICAgdmFyICR2ID0gK3Y7XG4gICAgdmFyIHUwID0gJHUgJiBVSU5UMTY7XG4gICAgdmFyIHYwID0gJHYgJiBVSU5UMTY7XG4gICAgdmFyIHUxID0gJHUgPj4+IDE2O1xuICAgIHZhciB2MSA9ICR2ID4+PiAxNjtcbiAgICB2YXIgdCA9ICh1MSAqIHYwID4+PiAwKSArICh1MCAqIHYwID4+PiAxNik7XG4gICAgcmV0dXJuIHUxICogdjEgKyAodCA+Pj4gMTYpICsgKCh1MCAqIHYxID4+PiAwKSArICh0ICYgVUlOVDE2KSA+Pj4gMTYpO1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG52YXIgJGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG5cbi8vIEIuMi4yLjIgT2JqZWN0LnByb3RvdHlwZS5fX2RlZmluZUdldHRlcl9fKFAsIGdldHRlcilcbnJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgJGV4cG9ydCgkZXhwb3J0LlAgKyByZXF1aXJlKCcuL19vYmplY3QtZm9yY2VkLXBhbScpLCAnT2JqZWN0Jywge1xuICBfX2RlZmluZUdldHRlcl9fOiBmdW5jdGlvbiBfX2RlZmluZUdldHRlcl9fKFAsIGdldHRlcikge1xuICAgICRkZWZpbmVQcm9wZXJ0eS5mKHRvT2JqZWN0KHRoaXMpLCBQLCB7IGdldDogYUZ1bmN0aW9uKGdldHRlciksIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9KTtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xudmFyICRkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xuXG4vLyBCLjIuMi4zIE9iamVjdC5wcm90b3R5cGUuX19kZWZpbmVTZXR0ZXJfXyhQLCBzZXR0ZXIpXG5yZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmICRleHBvcnQoJGV4cG9ydC5QICsgcmVxdWlyZSgnLi9fb2JqZWN0LWZvcmNlZC1wYW0nKSwgJ09iamVjdCcsIHtcbiAgX19kZWZpbmVTZXR0ZXJfXzogZnVuY3Rpb24gX19kZWZpbmVTZXR0ZXJfXyhQLCBzZXR0ZXIpIHtcbiAgICAkZGVmaW5lUHJvcGVydHkuZih0b09iamVjdCh0aGlzKSwgUCwgeyBzZXQ6IGFGdW5jdGlvbihzZXR0ZXIpLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSk7XG4gIH1cbn0pO1xuIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtb2JqZWN0LXZhbHVlcy1lbnRyaWVzXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRlbnRyaWVzID0gcmVxdWlyZSgnLi9fb2JqZWN0LXRvLWFycmF5JykodHJ1ZSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnT2JqZWN0Jywge1xuICBlbnRyaWVzOiBmdW5jdGlvbiBlbnRyaWVzKGl0KSB7XG4gICAgcmV0dXJuICRlbnRyaWVzKGl0KTtcbiAgfVxufSk7XG4iLCIvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1vYmplY3QtZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yc1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBvd25LZXlzID0gcmVxdWlyZSgnLi9fb3duLWtleXMnKTtcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgZ09QRCA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJyk7XG52YXIgY3JlYXRlUHJvcGVydHkgPSByZXF1aXJlKCcuL19jcmVhdGUtcHJvcGVydHknKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdPYmplY3QnLCB7XG4gIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnM6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMob2JqZWN0KSB7XG4gICAgdmFyIE8gPSB0b0lPYmplY3Qob2JqZWN0KTtcbiAgICB2YXIgZ2V0RGVzYyA9IGdPUEQuZjtcbiAgICB2YXIga2V5cyA9IG93bktleXMoTyk7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIga2V5LCBkZXNjO1xuICAgIHdoaWxlIChrZXlzLmxlbmd0aCA+IGkpIHtcbiAgICAgIGRlc2MgPSBnZXREZXNjKE8sIGtleSA9IGtleXNbaSsrXSk7XG4gICAgICBpZiAoZGVzYyAhPT0gdW5kZWZpbmVkKSBjcmVhdGVQcm9wZXJ0eShyZXN1bHQsIGtleSwgZGVzYyk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJyk7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKS5mO1xuXG4vLyBCLjIuMi40IE9iamVjdC5wcm90b3R5cGUuX19sb29rdXBHZXR0ZXJfXyhQKVxucmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiAkZXhwb3J0KCRleHBvcnQuUCArIHJlcXVpcmUoJy4vX29iamVjdC1mb3JjZWQtcGFtJyksICdPYmplY3QnLCB7XG4gIF9fbG9va3VwR2V0dGVyX186IGZ1bmN0aW9uIF9fbG9va3VwR2V0dGVyX18oUCkge1xuICAgIHZhciBPID0gdG9PYmplY3QodGhpcyk7XG4gICAgdmFyIEsgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcbiAgICB2YXIgRDtcbiAgICBkbyB7XG4gICAgICBpZiAoRCA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBLKSkgcmV0dXJuIEQuZ2V0O1xuICAgIH0gd2hpbGUgKE8gPSBnZXRQcm90b3R5cGVPZihPKSk7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJyk7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKS5mO1xuXG4vLyBCLjIuMi41IE9iamVjdC5wcm90b3R5cGUuX19sb29rdXBTZXR0ZXJfXyhQKVxucmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiAkZXhwb3J0KCRleHBvcnQuUCArIHJlcXVpcmUoJy4vX29iamVjdC1mb3JjZWQtcGFtJyksICdPYmplY3QnLCB7XG4gIF9fbG9va3VwU2V0dGVyX186IGZ1bmN0aW9uIF9fbG9va3VwU2V0dGVyX18oUCkge1xuICAgIHZhciBPID0gdG9PYmplY3QodGhpcyk7XG4gICAgdmFyIEsgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcbiAgICB2YXIgRDtcbiAgICBkbyB7XG4gICAgICBpZiAoRCA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBLKSkgcmV0dXJuIEQuc2V0O1xuICAgIH0gd2hpbGUgKE8gPSBnZXRQcm90b3R5cGVPZihPKSk7XG4gIH1cbn0pO1xuIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtb2JqZWN0LXZhbHVlcy1lbnRyaWVzXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICR2YWx1ZXMgPSByZXF1aXJlKCcuL19vYmplY3QtdG8tYXJyYXknKShmYWxzZSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnT2JqZWN0Jywge1xuICB2YWx1ZXM6IGZ1bmN0aW9uIHZhbHVlcyhpdCkge1xuICAgIHJldHVybiAkdmFsdWVzKGl0KTtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG4vLyBodHRwczovL2dpdGh1Yi5jb20vemVucGFyc2luZy9lcy1vYnNlcnZhYmxlXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGNvcmUgPSByZXF1aXJlKCcuL19jb3JlJyk7XG52YXIgbWljcm90YXNrID0gcmVxdWlyZSgnLi9fbWljcm90YXNrJykoKTtcbnZhciBPQlNFUlZBQkxFID0gcmVxdWlyZSgnLi9fd2tzJykoJ29ic2VydmFibGUnKTtcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBhbkluc3RhbmNlID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKTtcbnZhciByZWRlZmluZUFsbCA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG52YXIgZm9yT2YgPSByZXF1aXJlKCcuL19mb3Itb2YnKTtcbnZhciBSRVRVUk4gPSBmb3JPZi5SRVRVUk47XG5cbnZhciBnZXRNZXRob2QgPSBmdW5jdGlvbiAoZm4pIHtcbiAgcmV0dXJuIGZuID09IG51bGwgPyB1bmRlZmluZWQgOiBhRnVuY3Rpb24oZm4pO1xufTtcblxudmFyIGNsZWFudXBTdWJzY3JpcHRpb24gPSBmdW5jdGlvbiAoc3Vic2NyaXB0aW9uKSB7XG4gIHZhciBjbGVhbnVwID0gc3Vic2NyaXB0aW9uLl9jO1xuICBpZiAoY2xlYW51cCkge1xuICAgIHN1YnNjcmlwdGlvbi5fYyA9IHVuZGVmaW5lZDtcbiAgICBjbGVhbnVwKCk7XG4gIH1cbn07XG5cbnZhciBzdWJzY3JpcHRpb25DbG9zZWQgPSBmdW5jdGlvbiAoc3Vic2NyaXB0aW9uKSB7XG4gIHJldHVybiBzdWJzY3JpcHRpb24uX28gPT09IHVuZGVmaW5lZDtcbn07XG5cbnZhciBjbG9zZVN1YnNjcmlwdGlvbiA9IGZ1bmN0aW9uIChzdWJzY3JpcHRpb24pIHtcbiAgaWYgKCFzdWJzY3JpcHRpb25DbG9zZWQoc3Vic2NyaXB0aW9uKSkge1xuICAgIHN1YnNjcmlwdGlvbi5fbyA9IHVuZGVmaW5lZDtcbiAgICBjbGVhbnVwU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbik7XG4gIH1cbn07XG5cbnZhciBTdWJzY3JpcHRpb24gPSBmdW5jdGlvbiAob2JzZXJ2ZXIsIHN1YnNjcmliZXIpIHtcbiAgYW5PYmplY3Qob2JzZXJ2ZXIpO1xuICB0aGlzLl9jID0gdW5kZWZpbmVkO1xuICB0aGlzLl9vID0gb2JzZXJ2ZXI7XG4gIG9ic2VydmVyID0gbmV3IFN1YnNjcmlwdGlvbk9ic2VydmVyKHRoaXMpO1xuICB0cnkge1xuICAgIHZhciBjbGVhbnVwID0gc3Vic2NyaWJlcihvYnNlcnZlcik7XG4gICAgdmFyIHN1YnNjcmlwdGlvbiA9IGNsZWFudXA7XG4gICAgaWYgKGNsZWFudXAgIT0gbnVsbCkge1xuICAgICAgaWYgKHR5cGVvZiBjbGVhbnVwLnVuc3Vic2NyaWJlID09PSAnZnVuY3Rpb24nKSBjbGVhbnVwID0gZnVuY3Rpb24gKCkgeyBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTsgfTtcbiAgICAgIGVsc2UgYUZ1bmN0aW9uKGNsZWFudXApO1xuICAgICAgdGhpcy5fYyA9IGNsZWFudXA7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgb2JzZXJ2ZXIuZXJyb3IoZSk7XG4gICAgcmV0dXJuO1xuICB9IGlmIChzdWJzY3JpcHRpb25DbG9zZWQodGhpcykpIGNsZWFudXBTdWJzY3JpcHRpb24odGhpcyk7XG59O1xuXG5TdWJzY3JpcHRpb24ucHJvdG90eXBlID0gcmVkZWZpbmVBbGwoe30sIHtcbiAgdW5zdWJzY3JpYmU6IGZ1bmN0aW9uIHVuc3Vic2NyaWJlKCkgeyBjbG9zZVN1YnNjcmlwdGlvbih0aGlzKTsgfVxufSk7XG5cbnZhciBTdWJzY3JpcHRpb25PYnNlcnZlciA9IGZ1bmN0aW9uIChzdWJzY3JpcHRpb24pIHtcbiAgdGhpcy5fcyA9IHN1YnNjcmlwdGlvbjtcbn07XG5cblN1YnNjcmlwdGlvbk9ic2VydmVyLnByb3RvdHlwZSA9IHJlZGVmaW5lQWxsKHt9LCB7XG4gIG5leHQ6IGZ1bmN0aW9uIG5leHQodmFsdWUpIHtcbiAgICB2YXIgc3Vic2NyaXB0aW9uID0gdGhpcy5fcztcbiAgICBpZiAoIXN1YnNjcmlwdGlvbkNsb3NlZChzdWJzY3JpcHRpb24pKSB7XG4gICAgICB2YXIgb2JzZXJ2ZXIgPSBzdWJzY3JpcHRpb24uX287XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgbSA9IGdldE1ldGhvZChvYnNlcnZlci5uZXh0KTtcbiAgICAgICAgaWYgKG0pIHJldHVybiBtLmNhbGwob2JzZXJ2ZXIsIHZhbHVlKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjbG9zZVN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb24pO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGVycm9yOiBmdW5jdGlvbiBlcnJvcih2YWx1ZSkge1xuICAgIHZhciBzdWJzY3JpcHRpb24gPSB0aGlzLl9zO1xuICAgIGlmIChzdWJzY3JpcHRpb25DbG9zZWQoc3Vic2NyaXB0aW9uKSkgdGhyb3cgdmFsdWU7XG4gICAgdmFyIG9ic2VydmVyID0gc3Vic2NyaXB0aW9uLl9vO1xuICAgIHN1YnNjcmlwdGlvbi5fbyA9IHVuZGVmaW5lZDtcbiAgICB0cnkge1xuICAgICAgdmFyIG0gPSBnZXRNZXRob2Qob2JzZXJ2ZXIuZXJyb3IpO1xuICAgICAgaWYgKCFtKSB0aHJvdyB2YWx1ZTtcbiAgICAgIHZhbHVlID0gbS5jYWxsKG9ic2VydmVyLCB2YWx1ZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY2xlYW51cFN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb24pO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9IGNsZWFudXBTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uKTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH0sXG4gIGNvbXBsZXRlOiBmdW5jdGlvbiBjb21wbGV0ZSh2YWx1ZSkge1xuICAgIHZhciBzdWJzY3JpcHRpb24gPSB0aGlzLl9zO1xuICAgIGlmICghc3Vic2NyaXB0aW9uQ2xvc2VkKHN1YnNjcmlwdGlvbikpIHtcbiAgICAgIHZhciBvYnNlcnZlciA9IHN1YnNjcmlwdGlvbi5fbztcbiAgICAgIHN1YnNjcmlwdGlvbi5fbyA9IHVuZGVmaW5lZDtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBtID0gZ2V0TWV0aG9kKG9ic2VydmVyLmNvbXBsZXRlKTtcbiAgICAgICAgdmFsdWUgPSBtID8gbS5jYWxsKG9ic2VydmVyLCB2YWx1ZSkgOiB1bmRlZmluZWQ7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY2xlYW51cFN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb24pO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgIH0gY2xlYW51cFN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb24pO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgfVxufSk7XG5cbnZhciAkT2JzZXJ2YWJsZSA9IGZ1bmN0aW9uIE9ic2VydmFibGUoc3Vic2NyaWJlcikge1xuICBhbkluc3RhbmNlKHRoaXMsICRPYnNlcnZhYmxlLCAnT2JzZXJ2YWJsZScsICdfZicpLl9mID0gYUZ1bmN0aW9uKHN1YnNjcmliZXIpO1xufTtcblxucmVkZWZpbmVBbGwoJE9ic2VydmFibGUucHJvdG90eXBlLCB7XG4gIHN1YnNjcmliZTogZnVuY3Rpb24gc3Vic2NyaWJlKG9ic2VydmVyKSB7XG4gICAgcmV0dXJuIG5ldyBTdWJzY3JpcHRpb24ob2JzZXJ2ZXIsIHRoaXMuX2YpO1xuICB9LFxuICBmb3JFYWNoOiBmdW5jdGlvbiBmb3JFYWNoKGZuKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIHJldHVybiBuZXcgKGNvcmUuUHJvbWlzZSB8fCBnbG9iYWwuUHJvbWlzZSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgYUZ1bmN0aW9uKGZuKTtcbiAgICAgIHZhciBzdWJzY3JpcHRpb24gPSB0aGF0LnN1YnNjcmliZSh7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZm4odmFsdWUpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZXJyb3I6IHJlamVjdCxcbiAgICAgICAgY29tcGxldGU6IHJlc29sdmVcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG59KTtcblxucmVkZWZpbmVBbGwoJE9ic2VydmFibGUsIHtcbiAgZnJvbTogZnVuY3Rpb24gZnJvbSh4KSB7XG4gICAgdmFyIEMgPSB0eXBlb2YgdGhpcyA9PT0gJ2Z1bmN0aW9uJyA/IHRoaXMgOiAkT2JzZXJ2YWJsZTtcbiAgICB2YXIgbWV0aG9kID0gZ2V0TWV0aG9kKGFuT2JqZWN0KHgpW09CU0VSVkFCTEVdKTtcbiAgICBpZiAobWV0aG9kKSB7XG4gICAgICB2YXIgb2JzZXJ2YWJsZSA9IGFuT2JqZWN0KG1ldGhvZC5jYWxsKHgpKTtcbiAgICAgIHJldHVybiBvYnNlcnZhYmxlLmNvbnN0cnVjdG9yID09PSBDID8gb2JzZXJ2YWJsZSA6IG5ldyBDKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgICByZXR1cm4gb2JzZXJ2YWJsZS5zdWJzY3JpYmUob2JzZXJ2ZXIpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgQyhmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgIHZhciBkb25lID0gZmFsc2U7XG4gICAgICBtaWNyb3Rhc2soZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWRvbmUpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKGZvck9mKHgsIGZhbHNlLCBmdW5jdGlvbiAoaXQpIHtcbiAgICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dChpdCk7XG4gICAgICAgICAgICAgIGlmIChkb25lKSByZXR1cm4gUkVUVVJOO1xuICAgICAgICAgICAgfSkgPT09IFJFVFVSTikgcmV0dXJuO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmIChkb25lKSB0aHJvdyBlO1xuICAgICAgICAgICAgb2JzZXJ2ZXIuZXJyb3IoZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfSBvYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IGRvbmUgPSB0cnVlOyB9O1xuICAgIH0pO1xuICB9LFxuICBvZjogZnVuY3Rpb24gb2YoKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhcmd1bWVudHMubGVuZ3RoLCBpdGVtcyA9IEFycmF5KGwpOyBpIDwgbDspIGl0ZW1zW2ldID0gYXJndW1lbnRzW2krK107XG4gICAgcmV0dXJuIG5ldyAodHlwZW9mIHRoaXMgPT09ICdmdW5jdGlvbicgPyB0aGlzIDogJE9ic2VydmFibGUpKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgdmFyIGRvbmUgPSBmYWxzZTtcbiAgICAgIG1pY3JvdGFzayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghZG9uZSkge1xuICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaXRlbXMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgIG9ic2VydmVyLm5leHQoaXRlbXNbal0pO1xuICAgICAgICAgICAgaWYgKGRvbmUpIHJldHVybjtcbiAgICAgICAgICB9IG9ic2VydmVyLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgZG9uZSA9IHRydWU7IH07XG4gICAgfSk7XG4gIH1cbn0pO1xuXG5oaWRlKCRPYnNlcnZhYmxlLnByb3RvdHlwZSwgT0JTRVJWQUJMRSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSk7XG5cbiRleHBvcnQoJGV4cG9ydC5HLCB7IE9ic2VydmFibGU6ICRPYnNlcnZhYmxlIH0pO1xuXG5yZXF1aXJlKCcuL19zZXQtc3BlY2llcycpKCdPYnNlcnZhYmxlJyk7XG4iLCIvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1wcm9taXNlLWZpbmFsbHlcbid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgY29yZSA9IHJlcXVpcmUoJy4vX2NvcmUnKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBzcGVjaWVzQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuL19zcGVjaWVzLWNvbnN0cnVjdG9yJyk7XG52YXIgcHJvbWlzZVJlc29sdmUgPSByZXF1aXJlKCcuL19wcm9taXNlLXJlc29sdmUnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LlIsICdQcm9taXNlJywgeyAnZmluYWxseSc6IGZ1bmN0aW9uIChvbkZpbmFsbHkpIHtcbiAgdmFyIEMgPSBzcGVjaWVzQ29uc3RydWN0b3IodGhpcywgY29yZS5Qcm9taXNlIHx8IGdsb2JhbC5Qcm9taXNlKTtcbiAgdmFyIGlzRnVuY3Rpb24gPSB0eXBlb2Ygb25GaW5hbGx5ID09ICdmdW5jdGlvbic7XG4gIHJldHVybiB0aGlzLnRoZW4oXG4gICAgaXNGdW5jdGlvbiA/IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4gcHJvbWlzZVJlc29sdmUoQywgb25GaW5hbGx5KCkpLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4geDsgfSk7XG4gICAgfSA6IG9uRmluYWxseSxcbiAgICBpc0Z1bmN0aW9uID8gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZShDLCBvbkZpbmFsbHkoKSkudGhlbihmdW5jdGlvbiAoKSB7IHRocm93IGU7IH0pO1xuICAgIH0gOiBvbkZpbmFsbHlcbiAgKTtcbn0gfSk7XG4iLCIndXNlIHN0cmljdCc7XG4vLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1wcm9taXNlLXRyeVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eSA9IHJlcXVpcmUoJy4vX25ldy1wcm9taXNlLWNhcGFiaWxpdHknKTtcbnZhciBwZXJmb3JtID0gcmVxdWlyZSgnLi9fcGVyZm9ybScpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1Byb21pc2UnLCB7ICd0cnknOiBmdW5jdGlvbiAoY2FsbGJhY2tmbikge1xuICB2YXIgcHJvbWlzZUNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eS5mKHRoaXMpO1xuICB2YXIgcmVzdWx0ID0gcGVyZm9ybShjYWxsYmFja2ZuKTtcbiAgKHJlc3VsdC5lID8gcHJvbWlzZUNhcGFiaWxpdHkucmVqZWN0IDogcHJvbWlzZUNhcGFiaWxpdHkucmVzb2x2ZSkocmVzdWx0LnYpO1xuICByZXR1cm4gcHJvbWlzZUNhcGFiaWxpdHkucHJvbWlzZTtcbn0gfSk7XG4iLCJ2YXIgbWV0YWRhdGEgPSByZXF1aXJlKCcuL19tZXRhZGF0YScpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgdG9NZXRhS2V5ID0gbWV0YWRhdGEua2V5O1xudmFyIG9yZGluYXJ5RGVmaW5lT3duTWV0YWRhdGEgPSBtZXRhZGF0YS5zZXQ7XG5cbm1ldGFkYXRhLmV4cCh7IGRlZmluZU1ldGFkYXRhOiBmdW5jdGlvbiBkZWZpbmVNZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSwgdGFyZ2V0LCB0YXJnZXRLZXkpIHtcbiAgb3JkaW5hcnlEZWZpbmVPd25NZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSwgYW5PYmplY3QodGFyZ2V0KSwgdG9NZXRhS2V5KHRhcmdldEtleSkpO1xufSB9KTtcbiIsInZhciBtZXRhZGF0YSA9IHJlcXVpcmUoJy4vX21ldGFkYXRhJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciB0b01ldGFLZXkgPSBtZXRhZGF0YS5rZXk7XG52YXIgZ2V0T3JDcmVhdGVNZXRhZGF0YU1hcCA9IG1ldGFkYXRhLm1hcDtcbnZhciBzdG9yZSA9IG1ldGFkYXRhLnN0b3JlO1xuXG5tZXRhZGF0YS5leHAoeyBkZWxldGVNZXRhZGF0YTogZnVuY3Rpb24gZGVsZXRlTWV0YWRhdGEobWV0YWRhdGFLZXksIHRhcmdldCAvKiAsIHRhcmdldEtleSAqLykge1xuICB2YXIgdGFyZ2V0S2V5ID0gYXJndW1lbnRzLmxlbmd0aCA8IDMgPyB1bmRlZmluZWQgOiB0b01ldGFLZXkoYXJndW1lbnRzWzJdKTtcbiAgdmFyIG1ldGFkYXRhTWFwID0gZ2V0T3JDcmVhdGVNZXRhZGF0YU1hcChhbk9iamVjdCh0YXJnZXQpLCB0YXJnZXRLZXksIGZhbHNlKTtcbiAgaWYgKG1ldGFkYXRhTWFwID09PSB1bmRlZmluZWQgfHwgIW1ldGFkYXRhTWFwWydkZWxldGUnXShtZXRhZGF0YUtleSkpIHJldHVybiBmYWxzZTtcbiAgaWYgKG1ldGFkYXRhTWFwLnNpemUpIHJldHVybiB0cnVlO1xuICB2YXIgdGFyZ2V0TWV0YWRhdGEgPSBzdG9yZS5nZXQodGFyZ2V0KTtcbiAgdGFyZ2V0TWV0YWRhdGFbJ2RlbGV0ZSddKHRhcmdldEtleSk7XG4gIHJldHVybiAhIXRhcmdldE1ldGFkYXRhLnNpemUgfHwgc3RvcmVbJ2RlbGV0ZSddKHRhcmdldCk7XG59IH0pO1xuIiwidmFyIFNldCA9IHJlcXVpcmUoJy4vZXM2LnNldCcpO1xudmFyIGZyb20gPSByZXF1aXJlKCcuL19hcnJheS1mcm9tLWl0ZXJhYmxlJyk7XG52YXIgbWV0YWRhdGEgPSByZXF1aXJlKCcuL19tZXRhZGF0YScpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJyk7XG52YXIgb3JkaW5hcnlPd25NZXRhZGF0YUtleXMgPSBtZXRhZGF0YS5rZXlzO1xudmFyIHRvTWV0YUtleSA9IG1ldGFkYXRhLmtleTtcblxudmFyIG9yZGluYXJ5TWV0YWRhdGFLZXlzID0gZnVuY3Rpb24gKE8sIFApIHtcbiAgdmFyIG9LZXlzID0gb3JkaW5hcnlPd25NZXRhZGF0YUtleXMoTywgUCk7XG4gIHZhciBwYXJlbnQgPSBnZXRQcm90b3R5cGVPZihPKTtcbiAgaWYgKHBhcmVudCA9PT0gbnVsbCkgcmV0dXJuIG9LZXlzO1xuICB2YXIgcEtleXMgPSBvcmRpbmFyeU1ldGFkYXRhS2V5cyhwYXJlbnQsIFApO1xuICByZXR1cm4gcEtleXMubGVuZ3RoID8gb0tleXMubGVuZ3RoID8gZnJvbShuZXcgU2V0KG9LZXlzLmNvbmNhdChwS2V5cykpKSA6IHBLZXlzIDogb0tleXM7XG59O1xuXG5tZXRhZGF0YS5leHAoeyBnZXRNZXRhZGF0YUtleXM6IGZ1bmN0aW9uIGdldE1ldGFkYXRhS2V5cyh0YXJnZXQgLyogLCB0YXJnZXRLZXkgKi8pIHtcbiAgcmV0dXJuIG9yZGluYXJ5TWV0YWRhdGFLZXlzKGFuT2JqZWN0KHRhcmdldCksIGFyZ3VtZW50cy5sZW5ndGggPCAyID8gdW5kZWZpbmVkIDogdG9NZXRhS2V5KGFyZ3VtZW50c1sxXSkpO1xufSB9KTtcbiIsInZhciBtZXRhZGF0YSA9IHJlcXVpcmUoJy4vX21ldGFkYXRhJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKTtcbnZhciBvcmRpbmFyeUhhc093bk1ldGFkYXRhID0gbWV0YWRhdGEuaGFzO1xudmFyIG9yZGluYXJ5R2V0T3duTWV0YWRhdGEgPSBtZXRhZGF0YS5nZXQ7XG52YXIgdG9NZXRhS2V5ID0gbWV0YWRhdGEua2V5O1xuXG52YXIgb3JkaW5hcnlHZXRNZXRhZGF0YSA9IGZ1bmN0aW9uIChNZXRhZGF0YUtleSwgTywgUCkge1xuICB2YXIgaGFzT3duID0gb3JkaW5hcnlIYXNPd25NZXRhZGF0YShNZXRhZGF0YUtleSwgTywgUCk7XG4gIGlmIChoYXNPd24pIHJldHVybiBvcmRpbmFyeUdldE93bk1ldGFkYXRhKE1ldGFkYXRhS2V5LCBPLCBQKTtcbiAgdmFyIHBhcmVudCA9IGdldFByb3RvdHlwZU9mKE8pO1xuICByZXR1cm4gcGFyZW50ICE9PSBudWxsID8gb3JkaW5hcnlHZXRNZXRhZGF0YShNZXRhZGF0YUtleSwgcGFyZW50LCBQKSA6IHVuZGVmaW5lZDtcbn07XG5cbm1ldGFkYXRhLmV4cCh7IGdldE1ldGFkYXRhOiBmdW5jdGlvbiBnZXRNZXRhZGF0YShtZXRhZGF0YUtleSwgdGFyZ2V0IC8qICwgdGFyZ2V0S2V5ICovKSB7XG4gIHJldHVybiBvcmRpbmFyeUdldE1ldGFkYXRhKG1ldGFkYXRhS2V5LCBhbk9iamVjdCh0YXJnZXQpLCBhcmd1bWVudHMubGVuZ3RoIDwgMyA/IHVuZGVmaW5lZCA6IHRvTWV0YUtleShhcmd1bWVudHNbMl0pKTtcbn0gfSk7XG4iLCJ2YXIgbWV0YWRhdGEgPSByZXF1aXJlKCcuL19tZXRhZGF0YScpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgb3JkaW5hcnlPd25NZXRhZGF0YUtleXMgPSBtZXRhZGF0YS5rZXlzO1xudmFyIHRvTWV0YUtleSA9IG1ldGFkYXRhLmtleTtcblxubWV0YWRhdGEuZXhwKHsgZ2V0T3duTWV0YWRhdGFLZXlzOiBmdW5jdGlvbiBnZXRPd25NZXRhZGF0YUtleXModGFyZ2V0IC8qICwgdGFyZ2V0S2V5ICovKSB7XG4gIHJldHVybiBvcmRpbmFyeU93bk1ldGFkYXRhS2V5cyhhbk9iamVjdCh0YXJnZXQpLCBhcmd1bWVudHMubGVuZ3RoIDwgMiA/IHVuZGVmaW5lZCA6IHRvTWV0YUtleShhcmd1bWVudHNbMV0pKTtcbn0gfSk7XG4iLCJ2YXIgbWV0YWRhdGEgPSByZXF1aXJlKCcuL19tZXRhZGF0YScpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgb3JkaW5hcnlHZXRPd25NZXRhZGF0YSA9IG1ldGFkYXRhLmdldDtcbnZhciB0b01ldGFLZXkgPSBtZXRhZGF0YS5rZXk7XG5cbm1ldGFkYXRhLmV4cCh7IGdldE93bk1ldGFkYXRhOiBmdW5jdGlvbiBnZXRPd25NZXRhZGF0YShtZXRhZGF0YUtleSwgdGFyZ2V0IC8qICwgdGFyZ2V0S2V5ICovKSB7XG4gIHJldHVybiBvcmRpbmFyeUdldE93bk1ldGFkYXRhKG1ldGFkYXRhS2V5LCBhbk9iamVjdCh0YXJnZXQpXG4gICAgLCBhcmd1bWVudHMubGVuZ3RoIDwgMyA/IHVuZGVmaW5lZCA6IHRvTWV0YUtleShhcmd1bWVudHNbMl0pKTtcbn0gfSk7XG4iLCJ2YXIgbWV0YWRhdGEgPSByZXF1aXJlKCcuL19tZXRhZGF0YScpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJyk7XG52YXIgb3JkaW5hcnlIYXNPd25NZXRhZGF0YSA9IG1ldGFkYXRhLmhhcztcbnZhciB0b01ldGFLZXkgPSBtZXRhZGF0YS5rZXk7XG5cbnZhciBvcmRpbmFyeUhhc01ldGFkYXRhID0gZnVuY3Rpb24gKE1ldGFkYXRhS2V5LCBPLCBQKSB7XG4gIHZhciBoYXNPd24gPSBvcmRpbmFyeUhhc093bk1ldGFkYXRhKE1ldGFkYXRhS2V5LCBPLCBQKTtcbiAgaWYgKGhhc093bikgcmV0dXJuIHRydWU7XG4gIHZhciBwYXJlbnQgPSBnZXRQcm90b3R5cGVPZihPKTtcbiAgcmV0dXJuIHBhcmVudCAhPT0gbnVsbCA/IG9yZGluYXJ5SGFzTWV0YWRhdGEoTWV0YWRhdGFLZXksIHBhcmVudCwgUCkgOiBmYWxzZTtcbn07XG5cbm1ldGFkYXRhLmV4cCh7IGhhc01ldGFkYXRhOiBmdW5jdGlvbiBoYXNNZXRhZGF0YShtZXRhZGF0YUtleSwgdGFyZ2V0IC8qICwgdGFyZ2V0S2V5ICovKSB7XG4gIHJldHVybiBvcmRpbmFyeUhhc01ldGFkYXRhKG1ldGFkYXRhS2V5LCBhbk9iamVjdCh0YXJnZXQpLCBhcmd1bWVudHMubGVuZ3RoIDwgMyA/IHVuZGVmaW5lZCA6IHRvTWV0YUtleShhcmd1bWVudHNbMl0pKTtcbn0gfSk7XG4iLCJ2YXIgbWV0YWRhdGEgPSByZXF1aXJlKCcuL19tZXRhZGF0YScpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgb3JkaW5hcnlIYXNPd25NZXRhZGF0YSA9IG1ldGFkYXRhLmhhcztcbnZhciB0b01ldGFLZXkgPSBtZXRhZGF0YS5rZXk7XG5cbm1ldGFkYXRhLmV4cCh7IGhhc093bk1ldGFkYXRhOiBmdW5jdGlvbiBoYXNPd25NZXRhZGF0YShtZXRhZGF0YUtleSwgdGFyZ2V0IC8qICwgdGFyZ2V0S2V5ICovKSB7XG4gIHJldHVybiBvcmRpbmFyeUhhc093bk1ldGFkYXRhKG1ldGFkYXRhS2V5LCBhbk9iamVjdCh0YXJnZXQpXG4gICAgLCBhcmd1bWVudHMubGVuZ3RoIDwgMyA/IHVuZGVmaW5lZCA6IHRvTWV0YUtleShhcmd1bWVudHNbMl0pKTtcbn0gfSk7XG4iLCJ2YXIgJG1ldGFkYXRhID0gcmVxdWlyZSgnLi9fbWV0YWRhdGEnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcbnZhciB0b01ldGFLZXkgPSAkbWV0YWRhdGEua2V5O1xudmFyIG9yZGluYXJ5RGVmaW5lT3duTWV0YWRhdGEgPSAkbWV0YWRhdGEuc2V0O1xuXG4kbWV0YWRhdGEuZXhwKHsgbWV0YWRhdGE6IGZ1bmN0aW9uIG1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbiBkZWNvcmF0b3IodGFyZ2V0LCB0YXJnZXRLZXkpIHtcbiAgICBvcmRpbmFyeURlZmluZU93bk1ldGFkYXRhKFxuICAgICAgbWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUsXG4gICAgICAodGFyZ2V0S2V5ICE9PSB1bmRlZmluZWQgPyBhbk9iamVjdCA6IGFGdW5jdGlvbikodGFyZ2V0KSxcbiAgICAgIHRvTWV0YUtleSh0YXJnZXRLZXkpXG4gICAgKTtcbiAgfTtcbn0gfSk7XG4iLCIvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL3Byb3Bvc2FsLXNldG1hcC1vZmZyb20vI3NlYy1zZXQuZnJvbVxucmVxdWlyZSgnLi9fc2V0LWNvbGxlY3Rpb24tZnJvbScpKCdTZXQnKTtcbiIsIi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vcHJvcG9zYWwtc2V0bWFwLW9mZnJvbS8jc2VjLXNldC5vZlxucmVxdWlyZSgnLi9fc2V0LWNvbGxlY3Rpb24tb2YnKSgnU2V0Jyk7XG4iLCIvLyBodHRwczovL2dpdGh1Yi5jb20vRGF2aWRCcnVhbnQvTWFwLVNldC5wcm90b3R5cGUudG9KU09OXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuUiwgJ1NldCcsIHsgdG9KU09OOiByZXF1aXJlKCcuL19jb2xsZWN0aW9uLXRvLWpzb24nKSgnU2V0JykgfSk7XG4iLCIndXNlIHN0cmljdCc7XG4vLyBodHRwczovL2dpdGh1Yi5jb20vbWF0aGlhc2J5bmVucy9TdHJpbmcucHJvdG90eXBlLmF0XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRhdCA9IHJlcXVpcmUoJy4vX3N0cmluZy1hdCcpKHRydWUpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCwgJ1N0cmluZycsIHtcbiAgYXQ6IGZ1bmN0aW9uIGF0KHBvcykge1xuICAgIHJldHVybiAkYXQodGhpcywgcG9zKTtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL1N0cmluZy5wcm90b3R5cGUubWF0Y2hBbGwvXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciBpc1JlZ0V4cCA9IHJlcXVpcmUoJy4vX2lzLXJlZ2V4cCcpO1xudmFyIGdldEZsYWdzID0gcmVxdWlyZSgnLi9fZmxhZ3MnKTtcbnZhciBSZWdFeHBQcm90byA9IFJlZ0V4cC5wcm90b3R5cGU7XG5cbnZhciAkUmVnRXhwU3RyaW5nSXRlcmF0b3IgPSBmdW5jdGlvbiAocmVnZXhwLCBzdHJpbmcpIHtcbiAgdGhpcy5fciA9IHJlZ2V4cDtcbiAgdGhpcy5fcyA9IHN0cmluZztcbn07XG5cbnJlcXVpcmUoJy4vX2l0ZXItY3JlYXRlJykoJFJlZ0V4cFN0cmluZ0l0ZXJhdG9yLCAnUmVnRXhwIFN0cmluZycsIGZ1bmN0aW9uIG5leHQoKSB7XG4gIHZhciBtYXRjaCA9IHRoaXMuX3IuZXhlYyh0aGlzLl9zKTtcbiAgcmV0dXJuIHsgdmFsdWU6IG1hdGNoLCBkb25lOiBtYXRjaCA9PT0gbnVsbCB9O1xufSk7XG5cbiRleHBvcnQoJGV4cG9ydC5QLCAnU3RyaW5nJywge1xuICBtYXRjaEFsbDogZnVuY3Rpb24gbWF0Y2hBbGwocmVnZXhwKSB7XG4gICAgZGVmaW5lZCh0aGlzKTtcbiAgICBpZiAoIWlzUmVnRXhwKHJlZ2V4cCkpIHRocm93IFR5cGVFcnJvcihyZWdleHAgKyAnIGlzIG5vdCBhIHJlZ2V4cCEnKTtcbiAgICB2YXIgUyA9IFN0cmluZyh0aGlzKTtcbiAgICB2YXIgZmxhZ3MgPSAnZmxhZ3MnIGluIFJlZ0V4cFByb3RvID8gU3RyaW5nKHJlZ2V4cC5mbGFncykgOiBnZXRGbGFncy5jYWxsKHJlZ2V4cCk7XG4gICAgdmFyIHJ4ID0gbmV3IFJlZ0V4cChyZWdleHAuc291cmNlLCB+ZmxhZ3MuaW5kZXhPZignZycpID8gZmxhZ3MgOiAnZycgKyBmbGFncyk7XG4gICAgcngubGFzdEluZGV4ID0gdG9MZW5ndGgocmVnZXhwLmxhc3RJbmRleCk7XG4gICAgcmV0dXJuIG5ldyAkUmVnRXhwU3RyaW5nSXRlcmF0b3IocngsIFMpO1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLXN0cmluZy1wYWQtc3RhcnQtZW5kXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRwYWQgPSByZXF1aXJlKCcuL19zdHJpbmctcGFkJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QLCAnU3RyaW5nJywge1xuICBwYWRFbmQ6IGZ1bmN0aW9uIHBhZEVuZChtYXhMZW5ndGggLyogLCBmaWxsU3RyaW5nID0gJyAnICovKSB7XG4gICAgcmV0dXJuICRwYWQodGhpcywgbWF4TGVuZ3RoLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCwgZmFsc2UpO1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLXN0cmluZy1wYWQtc3RhcnQtZW5kXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRwYWQgPSByZXF1aXJlKCcuL19zdHJpbmctcGFkJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QLCAnU3RyaW5nJywge1xuICBwYWRTdGFydDogZnVuY3Rpb24gcGFkU3RhcnQobWF4TGVuZ3RoIC8qICwgZmlsbFN0cmluZyA9ICcgJyAqLykge1xuICAgIHJldHVybiAkcGFkKHRoaXMsIG1heExlbmd0aCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQsIHRydWUpO1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zZWJtYXJrYmFnZS9lY21hc2NyaXB0LXN0cmluZy1sZWZ0LXJpZ2h0LXRyaW1cbnJlcXVpcmUoJy4vX3N0cmluZy10cmltJykoJ3RyaW1MZWZ0JywgZnVuY3Rpb24gKCR0cmltKSB7XG4gIHJldHVybiBmdW5jdGlvbiB0cmltTGVmdCgpIHtcbiAgICByZXR1cm4gJHRyaW0odGhpcywgMSk7XG4gIH07XG59LCAndHJpbVN0YXJ0Jyk7XG4iLCIndXNlIHN0cmljdCc7XG4vLyBodHRwczovL2dpdGh1Yi5jb20vc2VibWFya2JhZ2UvZWNtYXNjcmlwdC1zdHJpbmctbGVmdC1yaWdodC10cmltXG5yZXF1aXJlKCcuL19zdHJpbmctdHJpbScpKCd0cmltUmlnaHQnLCBmdW5jdGlvbiAoJHRyaW0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHRyaW1SaWdodCgpIHtcbiAgICByZXR1cm4gJHRyaW0odGhpcywgMik7XG4gIH07XG59LCAndHJpbUVuZCcpO1xuIiwicmVxdWlyZSgnLi9fd2tzLWRlZmluZScpKCdhc3luY0l0ZXJhdG9yJyk7XG4iLCJyZXF1aXJlKCcuL193a3MtZGVmaW5lJykoJ29ic2VydmFibGUnKTtcbiIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLWdsb2JhbFxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdTeXN0ZW0nLCB7IGdsb2JhbDogcmVxdWlyZSgnLi9fZ2xvYmFsJykgfSk7XG4iLCIvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL3Byb3Bvc2FsLXNldG1hcC1vZmZyb20vI3NlYy13ZWFrbWFwLmZyb21cbnJlcXVpcmUoJy4vX3NldC1jb2xsZWN0aW9uLWZyb20nKSgnV2Vha01hcCcpO1xuIiwiLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9wcm9wb3NhbC1zZXRtYXAtb2Zmcm9tLyNzZWMtd2Vha21hcC5vZlxucmVxdWlyZSgnLi9fc2V0LWNvbGxlY3Rpb24tb2YnKSgnV2Vha01hcCcpO1xuIiwiLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9wcm9wb3NhbC1zZXRtYXAtb2Zmcm9tLyNzZWMtd2Vha3NldC5mcm9tXG5yZXF1aXJlKCcuL19zZXQtY29sbGVjdGlvbi1mcm9tJykoJ1dlYWtTZXQnKTtcbiIsIi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vcHJvcG9zYWwtc2V0bWFwLW9mZnJvbS8jc2VjLXdlYWtzZXQub2ZcbnJlcXVpcmUoJy4vX3NldC1jb2xsZWN0aW9uLW9mJykoJ1dlYWtTZXQnKTtcbiIsInZhciAkaXRlcmF0b3JzID0gcmVxdWlyZSgnLi9lczYuYXJyYXkuaXRlcmF0b3InKTtcbnZhciBnZXRLZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJyk7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbnZhciB3a3MgPSByZXF1aXJlKCcuL193a3MnKTtcbnZhciBJVEVSQVRPUiA9IHdrcygnaXRlcmF0b3InKTtcbnZhciBUT19TVFJJTkdfVEFHID0gd2tzKCd0b1N0cmluZ1RhZycpO1xudmFyIEFycmF5VmFsdWVzID0gSXRlcmF0b3JzLkFycmF5O1xuXG52YXIgRE9NSXRlcmFibGVzID0ge1xuICBDU1NSdWxlTGlzdDogdHJ1ZSwgLy8gVE9ETzogTm90IHNwZWMgY29tcGxpYW50LCBzaG91bGQgYmUgZmFsc2UuXG4gIENTU1N0eWxlRGVjbGFyYXRpb246IGZhbHNlLFxuICBDU1NWYWx1ZUxpc3Q6IGZhbHNlLFxuICBDbGllbnRSZWN0TGlzdDogZmFsc2UsXG4gIERPTVJlY3RMaXN0OiBmYWxzZSxcbiAgRE9NU3RyaW5nTGlzdDogZmFsc2UsXG4gIERPTVRva2VuTGlzdDogdHJ1ZSxcbiAgRGF0YVRyYW5zZmVySXRlbUxpc3Q6IGZhbHNlLFxuICBGaWxlTGlzdDogZmFsc2UsXG4gIEhUTUxBbGxDb2xsZWN0aW9uOiBmYWxzZSxcbiAgSFRNTENvbGxlY3Rpb246IGZhbHNlLFxuICBIVE1MRm9ybUVsZW1lbnQ6IGZhbHNlLFxuICBIVE1MU2VsZWN0RWxlbWVudDogZmFsc2UsXG4gIE1lZGlhTGlzdDogdHJ1ZSwgLy8gVE9ETzogTm90IHNwZWMgY29tcGxpYW50LCBzaG91bGQgYmUgZmFsc2UuXG4gIE1pbWVUeXBlQXJyYXk6IGZhbHNlLFxuICBOYW1lZE5vZGVNYXA6IGZhbHNlLFxuICBOb2RlTGlzdDogdHJ1ZSxcbiAgUGFpbnRSZXF1ZXN0TGlzdDogZmFsc2UsXG4gIFBsdWdpbjogZmFsc2UsXG4gIFBsdWdpbkFycmF5OiBmYWxzZSxcbiAgU1ZHTGVuZ3RoTGlzdDogZmFsc2UsXG4gIFNWR051bWJlckxpc3Q6IGZhbHNlLFxuICBTVkdQYXRoU2VnTGlzdDogZmFsc2UsXG4gIFNWR1BvaW50TGlzdDogZmFsc2UsXG4gIFNWR1N0cmluZ0xpc3Q6IGZhbHNlLFxuICBTVkdUcmFuc2Zvcm1MaXN0OiBmYWxzZSxcbiAgU291cmNlQnVmZmVyTGlzdDogZmFsc2UsXG4gIFN0eWxlU2hlZXRMaXN0OiB0cnVlLCAvLyBUT0RPOiBOb3Qgc3BlYyBjb21wbGlhbnQsIHNob3VsZCBiZSBmYWxzZS5cbiAgVGV4dFRyYWNrQ3VlTGlzdDogZmFsc2UsXG4gIFRleHRUcmFja0xpc3Q6IGZhbHNlLFxuICBUb3VjaExpc3Q6IGZhbHNlXG59O1xuXG5mb3IgKHZhciBjb2xsZWN0aW9ucyA9IGdldEtleXMoRE9NSXRlcmFibGVzKSwgaSA9IDA7IGkgPCBjb2xsZWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICB2YXIgTkFNRSA9IGNvbGxlY3Rpb25zW2ldO1xuICB2YXIgZXhwbGljaXQgPSBET01JdGVyYWJsZXNbTkFNRV07XG4gIHZhciBDb2xsZWN0aW9uID0gZ2xvYmFsW05BTUVdO1xuICB2YXIgcHJvdG8gPSBDb2xsZWN0aW9uICYmIENvbGxlY3Rpb24ucHJvdG90eXBlO1xuICB2YXIga2V5O1xuICBpZiAocHJvdG8pIHtcbiAgICBpZiAoIXByb3RvW0lURVJBVE9SXSkgaGlkZShwcm90bywgSVRFUkFUT1IsIEFycmF5VmFsdWVzKTtcbiAgICBpZiAoIXByb3RvW1RPX1NUUklOR19UQUddKSBoaWRlKHByb3RvLCBUT19TVFJJTkdfVEFHLCBOQU1FKTtcbiAgICBJdGVyYXRvcnNbTkFNRV0gPSBBcnJheVZhbHVlcztcbiAgICBpZiAoZXhwbGljaXQpIGZvciAoa2V5IGluICRpdGVyYXRvcnMpIGlmICghcHJvdG9ba2V5XSkgcmVkZWZpbmUocHJvdG8sIGtleSwgJGl0ZXJhdG9yc1trZXldLCB0cnVlKTtcbiAgfVxufVxuIiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkdGFzayA9IHJlcXVpcmUoJy4vX3Rhc2snKTtcbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5CLCB7XG4gIHNldEltbWVkaWF0ZTogJHRhc2suc2V0LFxuICBjbGVhckltbWVkaWF0ZTogJHRhc2suY2xlYXJcbn0pO1xuIiwiLy8gaWU5LSBzZXRUaW1lb3V0ICYgc2V0SW50ZXJ2YWwgYWRkaXRpb25hbCBwYXJhbWV0ZXJzIGZpeFxudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBuYXZpZ2F0b3IgPSBnbG9iYWwubmF2aWdhdG9yO1xudmFyIHNsaWNlID0gW10uc2xpY2U7XG52YXIgTVNJRSA9ICEhbmF2aWdhdG9yICYmIC9NU0lFIC5cXC4vLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7IC8vIDwtIGRpcnR5IGllOS0gY2hlY2tcbnZhciB3cmFwID0gZnVuY3Rpb24gKHNldCkge1xuICByZXR1cm4gZnVuY3Rpb24gKGZuLCB0aW1lIC8qICwgLi4uYXJncyAqLykge1xuICAgIHZhciBib3VuZEFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMjtcbiAgICB2YXIgYXJncyA9IGJvdW5kQXJncyA/IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKSA6IGZhbHNlO1xuICAgIHJldHVybiBzZXQoYm91bmRBcmdzID8gZnVuY3Rpb24gKCkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jXG4gICAgICAodHlwZW9mIGZuID09ICdmdW5jdGlvbicgPyBmbiA6IEZ1bmN0aW9uKGZuKSkuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfSA6IGZuLCB0aW1lKTtcbiAgfTtcbn07XG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuQiArICRleHBvcnQuRiAqIE1TSUUsIHtcbiAgc2V0VGltZW91dDogd3JhcChnbG9iYWwuc2V0VGltZW91dCksXG4gIHNldEludGVydmFsOiB3cmFwKGdsb2JhbC5zZXRJbnRlcnZhbClcbn0pO1xuIiwicmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zeW1ib2wnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmNyZWF0ZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuZGVmaW5lLXByb3BlcnR5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydGllcycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtcHJvdG90eXBlLW9mJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5rZXlzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtb3duLXByb3BlcnR5LW5hbWVzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5mcmVlemUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LnNlYWwnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LnByZXZlbnQtZXh0ZW5zaW9ucycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuaXMtZnJvemVuJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5pcy1zZWFsZWQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmlzLWV4dGVuc2libGUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmFzc2lnbicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuaXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LnNldC1wcm90b3R5cGUtb2YnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5mdW5jdGlvbi5iaW5kJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmZ1bmN0aW9uLm5hbWUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuZnVuY3Rpb24uaGFzLWluc3RhbmNlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnBhcnNlLWludCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5wYXJzZS1mbG9hdCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIuY29uc3RydWN0b3InKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLnRvLWZpeGVkJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci50by1wcmVjaXNpb24nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLmVwc2lsb24nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLmlzLWZpbml0ZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIuaXMtaW50ZWdlcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIuaXMtbmFuJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci5pcy1zYWZlLWludGVnZXInKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLm1heC1zYWZlLWludGVnZXInKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLm1pbi1zYWZlLWludGVnZXInKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLnBhcnNlLWZsb2F0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci5wYXJzZS1pbnQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5hY29zaCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmFzaW5oJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGguYXRhbmgnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5jYnJ0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGguY2x6MzInKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5jb3NoJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGguZXhwbTEnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5mcm91bmQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5oeXBvdCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmltdWwnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5sb2cxMCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmxvZzFwJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGgubG9nMicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLnNpZ24nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5zaW5oJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGgudGFuaCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLnRydW5jJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5mcm9tLWNvZGUtcG9pbnQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLnJhdycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcudHJpbScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3InKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmNvZGUtcG9pbnQtYXQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmVuZHMtd2l0aCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuaW5jbHVkZXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLnJlcGVhdCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuc3RhcnRzLXdpdGgnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmFuY2hvcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuYmlnJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5ibGluaycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuYm9sZCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuZml4ZWQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmZvbnRjb2xvcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuZm9udHNpemUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLml0YWxpY3MnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmxpbmsnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLnNtYWxsJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5zdHJpa2UnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLnN1YicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuc3VwJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmRhdGUubm93Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmRhdGUudG8tanNvbicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5kYXRlLnRvLWlzby1zdHJpbmcnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuZGF0ZS50by1zdHJpbmcnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuZGF0ZS50by1wcmltaXRpdmUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuaXMtYXJyYXknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuZnJvbScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5vZicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5qb2luJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LnNsaWNlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LnNvcnQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuZm9yLWVhY2gnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkubWFwJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LmZpbHRlcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5zb21lJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LmV2ZXJ5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LnJlZHVjZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5yZWR1Y2UtcmlnaHQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuaW5kZXgtb2YnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkubGFzdC1pbmRleC1vZicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5jb3B5LXdpdGhpbicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5maWxsJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LmZpbmQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuZmluZC1pbmRleCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5zcGVjaWVzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5Lml0ZXJhdG9yJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZ2V4cC5jb25zdHJ1Y3RvcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWdleHAudG8tc3RyaW5nJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZ2V4cC5mbGFncycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWdleHAubWF0Y2gnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVnZXhwLnJlcGxhY2UnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVnZXhwLnNlYXJjaCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWdleHAuc3BsaXQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucHJvbWlzZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXAnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc2V0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LndlYWstbWFwJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LndlYWstc2V0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnR5cGVkLmFycmF5LWJ1ZmZlcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi50eXBlZC5kYXRhLXZpZXcnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYudHlwZWQuaW50OC1hcnJheScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi50eXBlZC51aW50OC1hcnJheScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi50eXBlZC51aW50OC1jbGFtcGVkLWFycmF5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnR5cGVkLmludDE2LWFycmF5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnR5cGVkLnVpbnQxNi1hcnJheScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi50eXBlZC5pbnQzMi1hcnJheScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi50eXBlZC51aW50MzItYXJyYXknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYudHlwZWQuZmxvYXQzMi1hcnJheScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi50eXBlZC5mbG9hdDY0LWFycmF5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3QuYXBwbHknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5jb25zdHJ1Y3QnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5kZWZpbmUtcHJvcGVydHknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5kZWxldGUtcHJvcGVydHknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5lbnVtZXJhdGUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5nZXQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3InKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5nZXQtcHJvdG90eXBlLW9mJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3QuaGFzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3QuaXMtZXh0ZW5zaWJsZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0Lm93bi1rZXlzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3QucHJldmVudC1leHRlbnNpb25zJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3Quc2V0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3Quc2V0LXByb3RvdHlwZS1vZicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5hcnJheS5pbmNsdWRlcycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5hcnJheS5mbGF0LW1hcCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5hcnJheS5mbGF0dGVuJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnN0cmluZy5hdCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5zdHJpbmcucGFkLXN0YXJ0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnN0cmluZy5wYWQtZW5kJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnN0cmluZy50cmltLWxlZnQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuc3RyaW5nLnRyaW0tcmlnaHQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuc3RyaW5nLm1hdGNoLWFsbCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5zeW1ib2wuYXN5bmMtaXRlcmF0b3InKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuc3ltYm9sLm9ic2VydmFibGUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcub2JqZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcnMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcub2JqZWN0LnZhbHVlcycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5vYmplY3QuZW50cmllcycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5vYmplY3QuZGVmaW5lLWdldHRlcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5vYmplY3QuZGVmaW5lLXNldHRlcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5vYmplY3QubG9va3VwLWdldHRlcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5vYmplY3QubG9va3VwLXNldHRlcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5tYXAudG8tanNvbicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5zZXQudG8tanNvbicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5tYXAub2YnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuc2V0Lm9mJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LndlYWstbWFwLm9mJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LndlYWstc2V0Lm9mJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm1hcC5mcm9tJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnNldC5mcm9tJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LndlYWstbWFwLmZyb20nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcud2Vhay1zZXQuZnJvbScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5nbG9iYWwnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuc3lzdGVtLmdsb2JhbCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5lcnJvci5pcy1lcnJvcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5tYXRoLmNsYW1wJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm1hdGguZGVnLXBlci1yYWQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcubWF0aC5kZWdyZWVzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm1hdGguZnNjYWxlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm1hdGguaWFkZGgnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcubWF0aC5pc3ViaCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5tYXRoLmltdWxoJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm1hdGgucmFkLXBlci1kZWcnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcubWF0aC5yYWRpYW5zJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm1hdGguc2NhbGUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcubWF0aC51bXVsaCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5tYXRoLnNpZ25iaXQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcucHJvbWlzZS5maW5hbGx5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnByb21pc2UudHJ5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnJlZmxlY3QuZGVmaW5lLW1ldGFkYXRhJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnJlZmxlY3QuZGVsZXRlLW1ldGFkYXRhJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnJlZmxlY3QuZ2V0LW1ldGFkYXRhJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnJlZmxlY3QuZ2V0LW1ldGFkYXRhLWtleXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcucmVmbGVjdC5nZXQtb3duLW1ldGFkYXRhJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnJlZmxlY3QuZ2V0LW93bi1tZXRhZGF0YS1rZXlzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnJlZmxlY3QuaGFzLW1ldGFkYXRhJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnJlZmxlY3QuaGFzLW93bi1tZXRhZGF0YScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5yZWZsZWN0Lm1ldGFkYXRhJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LmFzYXAnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcub2JzZXJ2YWJsZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL3dlYi50aW1lcnMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy93ZWIuaW1tZWRpYXRlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZScpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL21vZHVsZXMvX2NvcmUnKTtcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGNhbWVsaXplO1xudmFyIHJlZ0V4cCA9IC9bLVxcc10rKC4pPy9nO1xuXG4vKipcbiAqIENvbnZlcnQgZGFzaCBzZXBhcmF0ZWQgc3RyaW5ncyB0byBjYW1lbCBjYXNlZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGNhbWVsaXplKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UocmVnRXhwLCB0b1VwcGVyKTtcbn1cblxuZnVuY3Rpb24gdG9VcHBlcihtYXRjaCwgYykge1xuICByZXR1cm4gYyA/IGMudG9VcHBlckNhc2UoKSA6ICcnO1xufSIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuc3VwcG9ydGVkVmFsdWUgPSBleHBvcnRzLnN1cHBvcnRlZFByb3BlcnR5ID0gZXhwb3J0cy5wcmVmaXggPSB1bmRlZmluZWQ7XG5cbnZhciBfcHJlZml4ID0gcmVxdWlyZSgnLi9wcmVmaXgnKTtcblxudmFyIF9wcmVmaXgyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcHJlZml4KTtcblxudmFyIF9zdXBwb3J0ZWRQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vc3VwcG9ydGVkLXByb3BlcnR5Jyk7XG5cbnZhciBfc3VwcG9ydGVkUHJvcGVydHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3VwcG9ydGVkUHJvcGVydHkpO1xuXG52YXIgX3N1cHBvcnRlZFZhbHVlID0gcmVxdWlyZSgnLi9zdXBwb3J0ZWQtdmFsdWUnKTtcblxudmFyIF9zdXBwb3J0ZWRWYWx1ZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zdXBwb3J0ZWRWYWx1ZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZXhwb3J0c1snZGVmYXVsdCddID0ge1xuICBwcmVmaXg6IF9wcmVmaXgyWydkZWZhdWx0J10sXG4gIHN1cHBvcnRlZFByb3BlcnR5OiBfc3VwcG9ydGVkUHJvcGVydHkyWydkZWZhdWx0J10sXG4gIHN1cHBvcnRlZFZhbHVlOiBfc3VwcG9ydGVkVmFsdWUyWydkZWZhdWx0J11cbn07IC8qKlxuICAgICogQ1NTIFZlbmRvciBwcmVmaXggZGV0ZWN0aW9uIGFuZCBwcm9wZXJ0eSBmZWF0dXJlIHRlc3RpbmcuXG4gICAgKlxuICAgICogQGNvcHlyaWdodCBPbGVnIFNsb2JvZHNrb2kgMjAxNVxuICAgICogQHdlYnNpdGUgaHR0cHM6Ly9naXRodWIuY29tL2pzc3R5bGVzL2Nzcy12ZW5kb3JcbiAgICAqIEBsaWNlbnNlIE1JVFxuICAgICovXG5cbmV4cG9ydHMucHJlZml4ID0gX3ByZWZpeDJbJ2RlZmF1bHQnXTtcbmV4cG9ydHMuc3VwcG9ydGVkUHJvcGVydHkgPSBfc3VwcG9ydGVkUHJvcGVydHkyWydkZWZhdWx0J107XG5leHBvcnRzLnN1cHBvcnRlZFZhbHVlID0gX3N1cHBvcnRlZFZhbHVlMlsnZGVmYXVsdCddOyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9pc0luQnJvd3NlciA9IHJlcXVpcmUoJ2lzLWluLWJyb3dzZXInKTtcblxudmFyIF9pc0luQnJvd3NlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pc0luQnJvd3Nlcik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIGpzID0gJyc7IC8qKlxuICAgICAgICAgICAgICAqIEV4cG9ydCBqYXZhc2NyaXB0IHN0eWxlIGFuZCBjc3Mgc3R5bGUgdmVuZG9yIHByZWZpeGVzLlxuICAgICAgICAgICAgICAqIEJhc2VkIG9uIFwidHJhbnNmb3JtXCIgc3VwcG9ydCB0ZXN0LlxuICAgICAgICAgICAgICAqL1xuXG52YXIgY3NzID0gJyc7XG5cbi8vIFdlIHNob3VsZCBub3QgZG8gYW55dGhpbmcgaWYgcmVxdWlyZWQgc2VydmVyc2lkZS5cbmlmIChfaXNJbkJyb3dzZXIyWydkZWZhdWx0J10pIHtcbiAgLy8gT3JkZXIgbWF0dGVycy4gV2UgbmVlZCB0byBjaGVjayBXZWJraXQgdGhlIGxhc3Qgb25lIGJlY2F1c2VcbiAgLy8gb3RoZXIgdmVuZG9ycyB1c2UgdG8gYWRkIFdlYmtpdCBwcmVmaXhlcyB0byBzb21lIHByb3BlcnRpZXNcbiAgdmFyIGpzQ3NzTWFwID0ge1xuICAgIE1vejogJy1tb3otJyxcbiAgICAvLyBJRSBkaWQgaXQgd3JvbmcgYWdhaW4gLi4uXG4gICAgbXM6ICctbXMtJyxcbiAgICBPOiAnLW8tJyxcbiAgICBXZWJraXQ6ICctd2Via2l0LSdcbiAgfTtcbiAgdmFyIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncCcpLnN0eWxlO1xuICB2YXIgdGVzdFByb3AgPSAnVHJhbnNmb3JtJztcblxuICBmb3IgKHZhciBrZXkgaW4ganNDc3NNYXApIHtcbiAgICBpZiAoa2V5ICsgdGVzdFByb3AgaW4gc3R5bGUpIHtcbiAgICAgIGpzID0ga2V5O1xuICAgICAgY3NzID0ganNDc3NNYXBba2V5XTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFZlbmRvciBwcmVmaXggc3RyaW5nIGZvciB0aGUgY3VycmVudCBicm93c2VyLlxuICpcbiAqIEB0eXBlIHt7anM6IFN0cmluZywgY3NzOiBTdHJpbmd9fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuZXhwb3J0c1snZGVmYXVsdCddID0geyBqczoganMsIGNzczogY3NzIH07IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0c1snZGVmYXVsdCddID0gc3VwcG9ydGVkUHJvcGVydHk7XG5cbnZhciBfaXNJbkJyb3dzZXIgPSByZXF1aXJlKCdpcy1pbi1icm93c2VyJyk7XG5cbnZhciBfaXNJbkJyb3dzZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaXNJbkJyb3dzZXIpO1xuXG52YXIgX3ByZWZpeCA9IHJlcXVpcmUoJy4vcHJlZml4Jyk7XG5cbnZhciBfcHJlZml4MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3ByZWZpeCk7XG5cbnZhciBfY2FtZWxpemUgPSByZXF1aXJlKCcuL2NhbWVsaXplJyk7XG5cbnZhciBfY2FtZWxpemUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2FtZWxpemUpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBlbCA9IHZvaWQgMDtcbnZhciBjYWNoZSA9IHt9O1xuXG5pZiAoX2lzSW5Ccm93c2VyMlsnZGVmYXVsdCddKSB7XG4gIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncCcpO1xuXG4gIC8qKlxuICAgKiBXZSB0ZXN0IGV2ZXJ5IHByb3BlcnR5IG9uIHZlbmRvciBwcmVmaXggcmVxdWlyZW1lbnQuXG4gICAqIE9uY2UgdGVzdGVkLCByZXN1bHQgaXMgY2FjaGVkLiBJdCBnaXZlcyB1cyB1cCB0byA3MCUgcGVyZiBib29zdC5cbiAgICogaHR0cDovL2pzcGVyZi5jb20vZWxlbWVudC1zdHlsZS1vYmplY3QtYWNjZXNzLXZzLXBsYWluLW9iamVjdFxuICAgKlxuICAgKiBQcmVmaWxsIGNhY2hlIHdpdGgga25vd24gY3NzIHByb3BlcnRpZXMgdG8gcmVkdWNlIGFtb3VudCBvZlxuICAgKiBwcm9wZXJ0aWVzIHdlIG5lZWQgdG8gZmVhdHVyZSB0ZXN0IGF0IHJ1bnRpbWUuXG4gICAqIGh0dHA6Ly9kYXZpZHdhbHNoLm5hbWUvdmVuZG9yLXByZWZpeFxuICAgKi9cbiAgdmFyIGNvbXB1dGVkID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCAnJyk7XG4gIGZvciAodmFyIGtleSBpbiBjb21wdXRlZCkge1xuICAgIGlmICghaXNOYU4oa2V5KSkgY2FjaGVbY29tcHV0ZWRba2V5XV0gPSBjb21wdXRlZFtrZXldO1xuICB9XG59XG5cbi8qKlxuICogVGVzdCBpZiBhIHByb3BlcnR5IGlzIHN1cHBvcnRlZCwgcmV0dXJucyBzdXBwb3J0ZWQgcHJvcGVydHkgd2l0aCB2ZW5kb3JcbiAqIHByZWZpeCBpZiByZXF1aXJlZC4gUmV0dXJucyBgZmFsc2VgIGlmIG5vdCBzdXBwb3J0ZWQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHByb3AgZGFzaCBzZXBhcmF0ZWRcbiAqIEByZXR1cm4ge1N0cmluZ3xCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gc3VwcG9ydGVkUHJvcGVydHkocHJvcCkge1xuICAvLyBGb3Igc2VydmVyLXNpZGUgcmVuZGVyaW5nLlxuICBpZiAoIWVsKSByZXR1cm4gcHJvcDtcblxuICAvLyBXZSBoYXZlIG5vdCB0ZXN0ZWQgdGhpcyBwcm9wIHlldCwgbGV0cyBkbyB0aGUgdGVzdC5cbiAgaWYgKGNhY2hlW3Byb3BdICE9IG51bGwpIHJldHVybiBjYWNoZVtwcm9wXTtcblxuICAvLyBDYW1lbGl6YXRpb24gaXMgcmVxdWlyZWQgYmVjYXVzZSB3ZSBjYW4ndCB0ZXN0IHVzaW5nXG4gIC8vIGNzcyBzeW50YXggZm9yIGUuZy4gaW4gRkYuXG4gIC8vIFRlc3QgaWYgcHJvcGVydHkgaXMgc3VwcG9ydGVkIGFzIGl0IGlzLlxuICBpZiAoKDAsIF9jYW1lbGl6ZTJbJ2RlZmF1bHQnXSkocHJvcCkgaW4gZWwuc3R5bGUpIHtcbiAgICBjYWNoZVtwcm9wXSA9IHByb3A7XG4gIH1cbiAgLy8gVGVzdCBpZiBwcm9wZXJ0eSBpcyBzdXBwb3J0ZWQgd2l0aCB2ZW5kb3IgcHJlZml4LlxuICBlbHNlIGlmIChfcHJlZml4MlsnZGVmYXVsdCddLmpzICsgKDAsIF9jYW1lbGl6ZTJbJ2RlZmF1bHQnXSkoJy0nICsgcHJvcCkgaW4gZWwuc3R5bGUpIHtcbiAgICAgIGNhY2hlW3Byb3BdID0gX3ByZWZpeDJbJ2RlZmF1bHQnXS5jc3MgKyBwcm9wO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWNoZVtwcm9wXSA9IGZhbHNlO1xuICAgIH1cblxuICByZXR1cm4gY2FjaGVbcHJvcF07XG59IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0c1snZGVmYXVsdCddID0gc3VwcG9ydGVkVmFsdWU7XG5cbnZhciBfaXNJbkJyb3dzZXIgPSByZXF1aXJlKCdpcy1pbi1icm93c2VyJyk7XG5cbnZhciBfaXNJbkJyb3dzZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaXNJbkJyb3dzZXIpO1xuXG52YXIgX3ByZWZpeCA9IHJlcXVpcmUoJy4vcHJlZml4Jyk7XG5cbnZhciBfcHJlZml4MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3ByZWZpeCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIGNhY2hlID0ge307XG52YXIgZWwgPSB2b2lkIDA7XG5cbmlmIChfaXNJbkJyb3dzZXIyWydkZWZhdWx0J10pIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncCcpO1xuXG4vKipcbiAqIFJldHVybnMgcHJlZml4ZWQgdmFsdWUgaWYgbmVlZGVkLiBSZXR1cm5zIGBmYWxzZWAgaWYgdmFsdWUgaXMgbm90IHN1cHBvcnRlZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHlcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICogQHJldHVybiB7U3RyaW5nfEJvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5mdW5jdGlvbiBzdXBwb3J0ZWRWYWx1ZShwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgLy8gRm9yIHNlcnZlci1zaWRlIHJlbmRlcmluZy5cbiAgaWYgKCFlbCkgcmV0dXJuIHZhbHVlO1xuXG4gIC8vIEl0IGlzIGEgc3RyaW5nIG9yIGEgbnVtYmVyIGFzIGEgc3RyaW5nIGxpa2UgJzEnLlxuICAvLyBXZSB3YW50IG9ubHkgcHJlZml4YWJsZSB2YWx1ZXMgaGVyZS5cbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycgfHwgIWlzTmFOKHBhcnNlSW50KHZhbHVlLCAxMCkpKSByZXR1cm4gdmFsdWU7XG5cbiAgdmFyIGNhY2hlS2V5ID0gcHJvcGVydHkgKyB2YWx1ZTtcblxuICBpZiAoY2FjaGVbY2FjaGVLZXldICE9IG51bGwpIHJldHVybiBjYWNoZVtjYWNoZUtleV07XG5cbiAgLy8gSUUgY2FuIGV2ZW4gdGhyb3cgYW4gZXJyb3IgaW4gc29tZSBjYXNlcywgZm9yIGUuZy4gc3R5bGUuY29udGVudCA9ICdiYXInXG4gIHRyeSB7XG4gICAgLy8gVGVzdCB2YWx1ZSBhcyBpdCBpcy5cbiAgICBlbC5zdHlsZVtwcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY2FjaGVbY2FjaGVLZXldID0gZmFsc2U7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gVmFsdWUgaXMgc3VwcG9ydGVkIGFzIGl0IGlzLlxuICBpZiAoZWwuc3R5bGVbcHJvcGVydHldICE9PSAnJykge1xuICAgIGNhY2hlW2NhY2hlS2V5XSA9IHZhbHVlO1xuICB9IGVsc2Uge1xuICAgIC8vIFRlc3QgdmFsdWUgd2l0aCB2ZW5kb3IgcHJlZml4LlxuICAgIHZhbHVlID0gX3ByZWZpeDJbJ2RlZmF1bHQnXS5jc3MgKyB2YWx1ZTtcblxuICAgIC8vIEhhcmRjb2RlIHRlc3QgdG8gY29udmVydCBcImZsZXhcIiB0byBcIi1tcy1mbGV4Ym94XCIgZm9yIElFMTAuXG4gICAgaWYgKHZhbHVlID09PSAnLW1zLWZsZXgnKSB2YWx1ZSA9ICctbXMtZmxleGJveCc7XG5cbiAgICBlbC5zdHlsZVtwcm9wZXJ0eV0gPSB2YWx1ZTtcblxuICAgIC8vIFZhbHVlIGlzIHN1cHBvcnRlZCB3aXRoIHZlbmRvciBwcmVmaXguXG4gICAgaWYgKGVsLnN0eWxlW3Byb3BlcnR5XSAhPT0gJycpIGNhY2hlW2NhY2hlS2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgaWYgKCFjYWNoZVtjYWNoZUtleV0pIGNhY2hlW2NhY2hlS2V5XSA9IGZhbHNlO1xuXG4gIC8vIFJlc2V0IHN0eWxlIHZhbHVlLlxuICBlbC5zdHlsZVtwcm9wZXJ0eV0gPSAnJztcblxuICByZXR1cm4gY2FjaGVbY2FjaGVLZXldO1xufSIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG52YXIgaXNWYWxpZFN0cmluZyA9IGZ1bmN0aW9uIGlzVmFsaWRTdHJpbmcocGFyYW0pIHtcbiAgcmV0dXJuIHR5cGVvZiBwYXJhbSA9PT0gJ3N0cmluZycgJiYgcGFyYW0ubGVuZ3RoID4gMDtcbn07XG5cbnZhciBzdGFydHNXaXRoID0gZnVuY3Rpb24gc3RhcnRzV2l0aChzdHJpbmcsIHN0YXJ0KSB7XG4gIHJldHVybiBzdHJpbmdbMF0gPT09IHN0YXJ0O1xufTtcblxudmFyIGlzU2VsZWN0b3IgPSBmdW5jdGlvbiBpc1NlbGVjdG9yKHBhcmFtKSB7XG4gIHJldHVybiBpc1ZhbGlkU3RyaW5nKHBhcmFtKSAmJiAoc3RhcnRzV2l0aChwYXJhbSwgJy4nKSB8fCBzdGFydHNXaXRoKHBhcmFtLCAnIycpKTtcbn07XG5cbnZhciBub2RlID0gZnVuY3Rpb24gbm9kZShoKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodGFnTmFtZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZmlyc3QpIHtcbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCByZXN0ID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICByZXN0W19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzU2VsZWN0b3IoZmlyc3QpKSB7XG4gICAgICAgIHJldHVybiBoLmFwcGx5KHVuZGVmaW5lZCwgW3RhZ05hbWUgKyBmaXJzdF0uY29uY2F0KHJlc3QpKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGZpcnN0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gaCh0YWdOYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBoLmFwcGx5KHVuZGVmaW5lZCwgW3RhZ05hbWUsIGZpcnN0XS5jb25jYXQocmVzdCkpO1xuICAgICAgfVxuICAgIH07XG4gIH07XG59O1xuXG52YXIgVEFHX05BTUVTID0gWydhJywgJ2FiYnInLCAnYWNyb255bScsICdhZGRyZXNzJywgJ2FwcGxldCcsICdhcmVhJywgJ2FydGljbGUnLCAnYXNpZGUnLCAnYXVkaW8nLCAnYicsICdiYXNlJywgJ2Jhc2Vmb250JywgJ2JkaScsICdiZG8nLCAnYmdzb3VuZCcsICdiaWcnLCAnYmxpbmsnLCAnYmxvY2txdW90ZScsICdib2R5JywgJ2JyJywgJ2J1dHRvbicsICdjYW52YXMnLCAnY2FwdGlvbicsICdjZW50ZXInLCAnY2l0ZScsICdjb2RlJywgJ2NvbCcsICdjb2xncm91cCcsICdjb21tYW5kJywgJ2NvbnRlbnQnLCAnZGF0YScsICdkYXRhbGlzdCcsICdkZCcsICdkZWwnLCAnZGV0YWlscycsICdkZm4nLCAnZGlhbG9nJywgJ2RpcicsICdkaXYnLCAnZGwnLCAnZHQnLCAnZWxlbWVudCcsICdlbScsICdlbWJlZCcsICdmaWVsZHNldCcsICdmaWdjYXB0aW9uJywgJ2ZpZ3VyZScsICdmb250JywgJ2Zvb3RlcicsICdmb3JtJywgJ2ZyYW1lJywgJ2ZyYW1lc2V0JywgJ2gxJywgJ2gyJywgJ2gzJywgJ2g0JywgJ2g1JywgJ2g2JywgJ2hlYWQnLCAnaGVhZGVyJywgJ2hncm91cCcsICdocicsICdodG1sJywgJ2knLCAnaWZyYW1lJywgJ2ltYWdlJywgJ2ltZycsICdpbnB1dCcsICdpbnMnLCAnaXNpbmRleCcsICdrYmQnLCAna2V5Z2VuJywgJ2xhYmVsJywgJ2xlZ2VuZCcsICdsaScsICdsaW5rJywgJ2xpc3RpbmcnLCAnbWFpbicsICdtYXAnLCAnbWFyaycsICdtYXJxdWVlJywgJ21hdGgnLCAnbWVudScsICdtZW51aXRlbScsICdtZXRhJywgJ21ldGVyJywgJ211bHRpY29sJywgJ25hdicsICduZXh0aWQnLCAnbm9icicsICdub2VtYmVkJywgJ25vZnJhbWVzJywgJ25vc2NyaXB0JywgJ29iamVjdCcsICdvbCcsICdvcHRncm91cCcsICdvcHRpb24nLCAnb3V0cHV0JywgJ3AnLCAncGFyYW0nLCAncGljdHVyZScsICdwbGFpbnRleHQnLCAncHJlJywgJ3Byb2dyZXNzJywgJ3EnLCAncmInLCAncmJjJywgJ3JwJywgJ3J0JywgJ3J0YycsICdydWJ5JywgJ3MnLCAnc2FtcCcsICdzY3JpcHQnLCAnc2VjdGlvbicsICdzZWxlY3QnLCAnc2hhZG93JywgJ3Nsb3QnLCAnc21hbGwnLCAnc291cmNlJywgJ3NwYWNlcicsICdzcGFuJywgJ3N0cmlrZScsICdzdHJvbmcnLCAnc3R5bGUnLCAnc3ViJywgJ3N1bW1hcnknLCAnc3VwJywgJ3N2ZycsICd0YWJsZScsICd0Ym9keScsICd0ZCcsICd0ZW1wbGF0ZScsICd0ZXh0YXJlYScsICd0Zm9vdCcsICd0aCcsICd0aGVhZCcsICd0aW1lJywgJ3RpdGxlJywgJ3RyJywgJ3RyYWNrJywgJ3R0JywgJ3UnLCAndWwnLCAndmFyJywgJ3ZpZGVvJywgJ3dicicsICd4bXAnXTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gZnVuY3Rpb24gKGgpIHtcbiAgdmFyIGNyZWF0ZVRhZyA9IG5vZGUoaCk7XG4gIHZhciBleHBvcnRlZCA9IHsgVEFHX05BTUVTOiBUQUdfTkFNRVMsIGlzU2VsZWN0b3I6IGlzU2VsZWN0b3IsIGNyZWF0ZVRhZzogY3JlYXRlVGFnIH07XG4gIFRBR19OQU1FUy5mb3JFYWNoKGZ1bmN0aW9uIChuKSB7XG4gICAgZXhwb3J0ZWRbbl0gPSBjcmVhdGVUYWcobik7XG4gIH0pO1xuICByZXR1cm4gZXhwb3J0ZWQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCJ2YXIgc3BsaXQgPSByZXF1aXJlKCdicm93c2VyLXNwbGl0JylcbnZhciBDbGFzc0xpc3QgPSByZXF1aXJlKCdjbGFzcy1saXN0JylcblxudmFyIHcgPSB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/IHJlcXVpcmUoJ2h0bWwtZWxlbWVudCcpIDogd2luZG93XG52YXIgZG9jdW1lbnQgPSB3LmRvY3VtZW50XG52YXIgVGV4dCA9IHcuVGV4dFxuXG5mdW5jdGlvbiBjb250ZXh0ICgpIHtcblxuICB2YXIgY2xlYW51cEZ1bmNzID0gW11cblxuICBmdW5jdGlvbiBoKCkge1xuICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpLCBlID0gbnVsbFxuICAgIGZ1bmN0aW9uIGl0ZW0gKGwpIHtcbiAgICAgIHZhciByXG4gICAgICBmdW5jdGlvbiBwYXJzZUNsYXNzIChzdHJpbmcpIHtcbiAgICAgICAgLy8gT3VyIG1pbmltYWwgcGFyc2VyIGRvZXNu4oCZdCB1bmRlcnN0YW5kIGVzY2FwaW5nIENTUyBzcGVjaWFsXG4gICAgICAgIC8vIGNoYXJhY3RlcnMgbGlrZSBgI2AuIERvbuKAmXQgdXNlIHRoZW0uIE1vcmUgcmVhZGluZzpcbiAgICAgICAgLy8gaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2Nzcy1lc2NhcGVzIC5cblxuICAgICAgICB2YXIgbSA9IHNwbGl0KHN0cmluZywgLyhbXFwuI10/W15cXHMjLl0rKS8pXG4gICAgICAgIGlmKC9eXFwufCMvLnRlc3QobVsxXSkpXG4gICAgICAgICAgZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgICAgIGZvckVhY2gobSwgZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICB2YXIgcyA9IHYuc3Vic3RyaW5nKDEsdi5sZW5ndGgpXG4gICAgICAgICAgaWYoIXYpIHJldHVyblxuICAgICAgICAgIGlmKCFlKVxuICAgICAgICAgICAgZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodilcbiAgICAgICAgICBlbHNlIGlmICh2WzBdID09PSAnLicpXG4gICAgICAgICAgICBDbGFzc0xpc3QoZSkuYWRkKHMpXG4gICAgICAgICAgZWxzZSBpZiAodlswXSA9PT0gJyMnKVxuICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoJ2lkJywgcylcbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgaWYobCA9PSBudWxsKVxuICAgICAgICA7XG4gICAgICBlbHNlIGlmKCdzdHJpbmcnID09PSB0eXBlb2YgbCkge1xuICAgICAgICBpZighZSlcbiAgICAgICAgICBwYXJzZUNsYXNzKGwpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBlLmFwcGVuZENoaWxkKHIgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShsKSlcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYoJ251bWJlcicgPT09IHR5cGVvZiBsXG4gICAgICAgIHx8ICdib29sZWFuJyA9PT0gdHlwZW9mIGxcbiAgICAgICAgfHwgbCBpbnN0YW5jZW9mIERhdGVcbiAgICAgICAgfHwgbCBpbnN0YW5jZW9mIFJlZ0V4cCApIHtcbiAgICAgICAgICBlLmFwcGVuZENoaWxkKHIgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShsLnRvU3RyaW5nKCkpKVxuICAgICAgfVxuICAgICAgLy90aGVyZSBtaWdodCBiZSBhIGJldHRlciB3YXkgdG8gaGFuZGxlIHRoaXMuLi5cbiAgICAgIGVsc2UgaWYgKGlzQXJyYXkobCkpXG4gICAgICAgIGZvckVhY2gobCwgaXRlbSlcbiAgICAgIGVsc2UgaWYoaXNOb2RlKGwpKVxuICAgICAgICBlLmFwcGVuZENoaWxkKHIgPSBsKVxuICAgICAgZWxzZSBpZihsIGluc3RhbmNlb2YgVGV4dClcbiAgICAgICAgZS5hcHBlbmRDaGlsZChyID0gbClcbiAgICAgIGVsc2UgaWYgKCdvYmplY3QnID09PSB0eXBlb2YgbCkge1xuICAgICAgICBmb3IgKHZhciBrIGluIGwpIHtcbiAgICAgICAgICBpZignZnVuY3Rpb24nID09PSB0eXBlb2YgbFtrXSkge1xuICAgICAgICAgICAgaWYoL15vblxcdysvLnRlc3QoaykpIHtcbiAgICAgICAgICAgICAgKGZ1bmN0aW9uIChrLCBsKSB7IC8vIGNhcHR1cmUgaywgbCBpbiB0aGUgY2xvc3VyZVxuICAgICAgICAgICAgICAgIGlmIChlLmFkZEV2ZW50TGlzdGVuZXIpe1xuICAgICAgICAgICAgICAgICAgZS5hZGRFdmVudExpc3RlbmVyKGsuc3Vic3RyaW5nKDIpLCBsW2tdLCBmYWxzZSlcbiAgICAgICAgICAgICAgICAgIGNsZWFudXBGdW5jcy5wdXNoKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICAgIGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihrLnN1YnN0cmluZygyKSwgbFtrXSwgZmFsc2UpXG4gICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgICAgZS5hdHRhY2hFdmVudChrLCBsW2tdKVxuICAgICAgICAgICAgICAgICAgY2xlYW51cEZ1bmNzLnB1c2goZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgZS5kZXRhY2hFdmVudChrLCBsW2tdKVxuICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pKGssIGwpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBvYnNlcnZhYmxlXG4gICAgICAgICAgICAgIGVba10gPSBsW2tdKClcbiAgICAgICAgICAgICAgY2xlYW51cEZ1bmNzLnB1c2gobFtrXShmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICAgIGVba10gPSB2XG4gICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmKGsgPT09ICdzdHlsZScpIHtcbiAgICAgICAgICAgIGlmKCdzdHJpbmcnID09PSB0eXBlb2YgbFtrXSkge1xuICAgICAgICAgICAgICBlLnN0eWxlLmNzc1RleHQgPSBsW2tdXG4gICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgZm9yICh2YXIgcyBpbiBsW2tdKSAoZnVuY3Rpb24ocywgdikge1xuICAgICAgICAgICAgICAgIGlmKCdmdW5jdGlvbicgPT09IHR5cGVvZiB2KSB7XG4gICAgICAgICAgICAgICAgICAvLyBvYnNlcnZhYmxlXG4gICAgICAgICAgICAgICAgICBlLnN0eWxlLnNldFByb3BlcnR5KHMsIHYoKSlcbiAgICAgICAgICAgICAgICAgIGNsZWFudXBGdW5jcy5wdXNoKHYoZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgICAgICAgICBlLnN0eWxlLnNldFByb3BlcnR5KHMsIHZhbClcbiAgICAgICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgICAgdmFyIG1hdGNoID0gbFtrXVtzXS5tYXRjaCgvKC4qKVxcVyshaW1wb3J0YW50XFxXKiQvKTtcbiAgICAgICAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICBlLnN0eWxlLnNldFByb3BlcnR5KHMsIG1hdGNoWzFdLCAnaW1wb3J0YW50JylcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGUuc3R5bGUuc2V0UHJvcGVydHkocywgbFtrXVtzXSlcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSkocywgbFtrXVtzXSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYoayA9PT0gJ2F0dHJzJykge1xuICAgICAgICAgICAgZm9yICh2YXIgdiBpbiBsW2tdKSB7XG4gICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKHYsIGxba11bdl0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKGsuc3Vic3RyKDAsIDUpID09PSBcImRhdGEtXCIpIHtcbiAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGssIGxba10pXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVba10gPSBsW2tdXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBsKSB7XG4gICAgICAgIC8vYXNzdW1lIGl0J3MgYW4gb2JzZXJ2YWJsZSFcbiAgICAgICAgdmFyIHYgPSBsKClcbiAgICAgICAgZS5hcHBlbmRDaGlsZChyID0gaXNOb2RlKHYpID8gdiA6IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHYpKVxuXG4gICAgICAgIGNsZWFudXBGdW5jcy5wdXNoKGwoZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICBpZihpc05vZGUodikgJiYgci5wYXJlbnRFbGVtZW50KVxuICAgICAgICAgICAgci5wYXJlbnRFbGVtZW50LnJlcGxhY2VDaGlsZCh2LCByKSwgciA9IHZcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICByLnRleHRDb250ZW50ID0gdlxuICAgICAgICB9KSlcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJcbiAgICB9XG4gICAgd2hpbGUoYXJncy5sZW5ndGgpXG4gICAgICBpdGVtKGFyZ3Muc2hpZnQoKSlcblxuICAgIHJldHVybiBlXG4gIH1cblxuICBoLmNsZWFudXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbGVhbnVwRnVuY3MubGVuZ3RoOyBpKyspe1xuICAgICAgY2xlYW51cEZ1bmNzW2ldKClcbiAgICB9XG4gICAgY2xlYW51cEZ1bmNzLmxlbmd0aCA9IDBcbiAgfVxuXG4gIHJldHVybiBoXG59XG5cbnZhciBoID0gbW9kdWxlLmV4cG9ydHMgPSBjb250ZXh0KClcbmguY29udGV4dCA9IGNvbnRleHRcblxuZnVuY3Rpb24gaXNOb2RlIChlbCkge1xuICByZXR1cm4gZWwgJiYgZWwubm9kZU5hbWUgJiYgZWwubm9kZVR5cGVcbn1cblxuZnVuY3Rpb24gZm9yRWFjaCAoYXJyLCBmbikge1xuICBpZiAoYXJyLmZvckVhY2gpIHJldHVybiBhcnIuZm9yRWFjaChmbilcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIGZuKGFycltpXSwgaSlcbn1cblxuZnVuY3Rpb24gaXNBcnJheSAoYXJyKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nXG59XG5cblxuIiwiXG52YXIgaW5kZXhPZiA9IFtdLmluZGV4T2Y7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXJyLCBvYmope1xuICBpZiAoaW5kZXhPZikgcmV0dXJuIGFyci5pbmRleE9mKG9iaik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKGFycltpXSA9PT0gb2JqKSByZXR1cm4gaTtcbiAgfVxuICByZXR1cm4gLTE7XG59OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxudmFyIGlzQnJvd3NlciA9IGV4cG9ydHMuaXNCcm93c2VyID0gKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZih3aW5kb3cpKSA9PT0gXCJvYmplY3RcIiAmJiAodHlwZW9mIGRvY3VtZW50ID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YoZG9jdW1lbnQpKSA9PT0gJ29iamVjdCcgJiYgZG9jdW1lbnQubm9kZVR5cGUgPT09IDk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGlzQnJvd3NlcjsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gY2FtZWxDYXNlO1xudmFyIHJlZ0V4cCA9IC8oW0EtWl0pL2c7XG5cbi8qKlxuICogUmVwbGFjZSBhIHN0cmluZyBwYXNzZWQgZnJvbSBTdHJpbmcjcmVwbGFjZS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuZnVuY3Rpb24gcmVwbGFjZShzdHIpIHtcbiAgcmV0dXJuIFwiLVwiICsgc3RyLnRvTG93ZXJDYXNlKCk7XG59XG5cbi8qKlxuICogQ29udmVydCBjYW1lbCBjYXNlZCBwcm9wZXJ0eSBuYW1lcyB0byBkYXNoIHNlcGFyYXRlZC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gc3R5bGVcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuZnVuY3Rpb24gY29udmVydENhc2Uoc3R5bGUpIHtcbiAgdmFyIGNvbnZlcnRlZCA9IHt9O1xuXG4gIGZvciAodmFyIHByb3AgaW4gc3R5bGUpIHtcbiAgICBjb252ZXJ0ZWRbcHJvcC5yZXBsYWNlKHJlZ0V4cCwgcmVwbGFjZSldID0gc3R5bGVbcHJvcF07XG4gIH1cblxuICBpZiAoc3R5bGUuZmFsbGJhY2tzKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc3R5bGUuZmFsbGJhY2tzKSkgY29udmVydGVkLmZhbGxiYWNrcyA9IHN0eWxlLmZhbGxiYWNrcy5tYXAoY29udmVydENhc2UpO2Vsc2UgY29udmVydGVkLmZhbGxiYWNrcyA9IGNvbnZlcnRDYXNlKHN0eWxlLmZhbGxiYWNrcyk7XG4gIH1cblxuICByZXR1cm4gY29udmVydGVkO1xufVxuXG4vKipcbiAqIEFsbG93IGNhbWVsIGNhc2VkIHByb3BlcnR5IG5hbWVzIGJ5IGNvbnZlcnRpbmcgdGhlbSBiYWNrIHRvIGRhc2hlcml6ZWQuXG4gKlxuICogQHBhcmFtIHtSdWxlfSBydWxlXG4gKi9cbmZ1bmN0aW9uIGNhbWVsQ2FzZSgpIHtcbiAgZnVuY3Rpb24gb25Qcm9jZXNzU3R5bGUoc3R5bGUpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShzdHlsZSkpIHtcbiAgICAgIC8vIEhhbmRsZSBydWxlcyBsaWtlIEBmb250LWZhY2UsIHdoaWNoIGNhbiBoYXZlIG11bHRpcGxlIHN0eWxlcyBpbiBhbiBhcnJheVxuICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IHN0eWxlLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICBzdHlsZVtpbmRleF0gPSBjb252ZXJ0Q2FzZShzdHlsZVtpbmRleF0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0eWxlO1xuICAgIH1cblxuICAgIHJldHVybiBjb252ZXJ0Q2FzZShzdHlsZSk7XG4gIH1cblxuICByZXR1cm4geyBvblByb2Nlc3NTdHlsZTogb25Qcm9jZXNzU3R5bGUgfTtcbn0iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBqc3NDb21wb3NlO1xuXG52YXIgX3dhcm5pbmcgPSByZXF1aXJlKCd3YXJuaW5nJyk7XG5cbnZhciBfd2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93YXJuaW5nKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLyoqXG4gKiBTZXQgc2VsZWN0b3IuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9yaWdpbmFsIHJ1bGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBjbGFzc05hbWUgY2xhc3Mgc3RyaW5nXG4gKiBAcmV0dXJuIHtCb29sZWFufSBmbGFnLCBpbmRpY2F0aW5nIGZ1bmN0aW9uIHdhcyBzdWNjZXNzZnVsbCBvciBub3RcbiAqL1xuZnVuY3Rpb24gcmVnaXN0ZXJDbGFzcyhydWxlLCBjbGFzc05hbWUpIHtcbiAgLy8gU2tpcCBmYWxzeSB2YWx1ZXNcbiAgaWYgKCFjbGFzc05hbWUpIHJldHVybiB0cnVlO1xuXG4gIC8vIFN1cHBvcnQgYXJyYXkgb2YgY2xhc3MgbmFtZXMgYHtjb21wb3NlczogWydmb28nLCAnYmFyJ119YFxuICBpZiAoQXJyYXkuaXNBcnJheShjbGFzc05hbWUpKSB7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGNsYXNzTmFtZS5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIHZhciBpc1NldHRlZCA9IHJlZ2lzdGVyQ2xhc3MocnVsZSwgY2xhc3NOYW1lW2luZGV4XSk7XG4gICAgICBpZiAoIWlzU2V0dGVkKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBTdXBwb3J0IHNwYWNlIHNlcGFyYXRlZCBjbGFzcyBuYW1lcyBge2NvbXBvc2VzOiAnZm9vIGJhcid9YFxuICBpZiAoY2xhc3NOYW1lLmluZGV4T2YoJyAnKSA+IC0xKSB7XG4gICAgcmV0dXJuIHJlZ2lzdGVyQ2xhc3MocnVsZSwgY2xhc3NOYW1lLnNwbGl0KCcgJykpO1xuICB9XG5cbiAgdmFyIHBhcmVudCA9IHJ1bGUub3B0aW9ucy5wYXJlbnQ7XG5cbiAgLy8gSXQgaXMgYSByZWYgdG8gYSBsb2NhbCBydWxlLlxuXG4gIGlmIChjbGFzc05hbWVbMF0gPT09ICckJykge1xuICAgIHZhciByZWZSdWxlID0gcGFyZW50LmdldFJ1bGUoY2xhc3NOYW1lLnN1YnN0cigxKSk7XG5cbiAgICBpZiAoIXJlZlJ1bGUpIHtcbiAgICAgICgwLCBfd2FybmluZzIuZGVmYXVsdCkoZmFsc2UsICdbSlNTXSBSZWZlcmVuY2VkIHJ1bGUgaXMgbm90IGRlZmluZWQuIFxcclxcbiVzJywgcnVsZSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHJlZlJ1bGUgPT09IHJ1bGUpIHtcbiAgICAgICgwLCBfd2FybmluZzIuZGVmYXVsdCkoZmFsc2UsICdbSlNTXSBDeWNsaWMgY29tcG9zaXRpb24gZGV0ZWN0ZWQuIFxcclxcbiVzJywgcnVsZSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcGFyZW50LmNsYXNzZXNbcnVsZS5rZXldICs9ICcgJyArIHBhcmVudC5jbGFzc2VzW3JlZlJ1bGUua2V5XTtcblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcnVsZS5vcHRpb25zLnBhcmVudC5jbGFzc2VzW3J1bGUua2V5XSArPSAnICcgKyBjbGFzc05hbWU7XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogQ29udmVydCBjb21wb3NlIHByb3BlcnR5IHRvIGFkZGl0aW9uYWwgY2xhc3MsIHJlbW92ZSBwcm9wZXJ0eSBmcm9tIG9yaWdpbmFsIHN0eWxlcy5cbiAqXG4gKiBAcGFyYW0ge1J1bGV9IHJ1bGVcbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIGpzc0NvbXBvc2UoKSB7XG4gIGZ1bmN0aW9uIG9uUHJvY2Vzc1N0eWxlKHN0eWxlLCBydWxlKSB7XG4gICAgaWYgKCFzdHlsZS5jb21wb3NlcykgcmV0dXJuIHN0eWxlO1xuICAgIHJlZ2lzdGVyQ2xhc3MocnVsZSwgc3R5bGUuY29tcG9zZXMpO1xuICAgIC8vIFJlbW92ZSBjb21wb3NlcyBwcm9wZXJ0eSB0byBwcmV2ZW50IGluZmluaXRlIGxvb3AuXG4gICAgZGVsZXRlIHN0eWxlLmNvbXBvc2VzO1xuICAgIHJldHVybiBzdHlsZTtcbiAgfVxuICByZXR1cm4geyBvblByb2Nlc3NTdHlsZTogb25Qcm9jZXNzU3R5bGUgfTtcbn0iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG4vKipcbiAqIEdlbmVyYXRlZCBqc3MtZGVmYXVsdC11bml0IENTUyBwcm9wZXJ0eSB1bml0c1xuICpcbiAqIEB0eXBlIG9iamVjdFxuICovXG5leHBvcnRzWydkZWZhdWx0J10gPSB7XG4gICdhbmltYXRpb24tZGVsYXknOiAnbXMnLFxuICAnYW5pbWF0aW9uLWR1cmF0aW9uJzogJ21zJyxcbiAgJ2JhY2tncm91bmQtcG9zaXRpb24nOiAncHgnLFxuICAnYmFja2dyb3VuZC1wb3NpdGlvbi14JzogJ3B4JyxcbiAgJ2JhY2tncm91bmQtcG9zaXRpb24teSc6ICdweCcsXG4gICdiYWNrZ3JvdW5kLXNpemUnOiAncHgnLFxuICBib3JkZXI6ICdweCcsXG4gICdib3JkZXItYm90dG9tJzogJ3B4JyxcbiAgJ2JvcmRlci1ib3R0b20tbGVmdC1yYWRpdXMnOiAncHgnLFxuICAnYm9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXMnOiAncHgnLFxuICAnYm9yZGVyLWJvdHRvbS13aWR0aCc6ICdweCcsXG4gICdib3JkZXItbGVmdCc6ICdweCcsXG4gICdib3JkZXItbGVmdC13aWR0aCc6ICdweCcsXG4gICdib3JkZXItcmFkaXVzJzogJ3B4JyxcbiAgJ2JvcmRlci1yaWdodCc6ICdweCcsXG4gICdib3JkZXItcmlnaHQtd2lkdGgnOiAncHgnLFxuICAnYm9yZGVyLXNwYWNpbmcnOiAncHgnLFxuICAnYm9yZGVyLXRvcCc6ICdweCcsXG4gICdib3JkZXItdG9wLWxlZnQtcmFkaXVzJzogJ3B4JyxcbiAgJ2JvcmRlci10b3AtcmlnaHQtcmFkaXVzJzogJ3B4JyxcbiAgJ2JvcmRlci10b3Atd2lkdGgnOiAncHgnLFxuICAnYm9yZGVyLXdpZHRoJzogJ3B4JyxcbiAgJ2JvcmRlci1hZnRlci13aWR0aCc6ICdweCcsXG4gICdib3JkZXItYmVmb3JlLXdpZHRoJzogJ3B4JyxcbiAgJ2JvcmRlci1lbmQtd2lkdGgnOiAncHgnLFxuICAnYm9yZGVyLWhvcml6b250YWwtc3BhY2luZyc6ICdweCcsXG4gICdib3JkZXItc3RhcnQtd2lkdGgnOiAncHgnLFxuICAnYm9yZGVyLXZlcnRpY2FsLXNwYWNpbmcnOiAncHgnLFxuICBib3R0b206ICdweCcsXG4gICdib3gtc2hhZG93JzogJ3B4JyxcbiAgJ2NvbHVtbi1nYXAnOiAncHgnLFxuICAnY29sdW1uLXJ1bGUnOiAncHgnLFxuICAnY29sdW1uLXJ1bGUtd2lkdGgnOiAncHgnLFxuICAnY29sdW1uLXdpZHRoJzogJ3B4JyxcbiAgJ2ZsZXgtYmFzaXMnOiAncHgnLFxuICAnZm9udC1zaXplJzogJ3B4JyxcbiAgJ2ZvbnQtc2l6ZS1kZWx0YSc6ICdweCcsXG4gIGhlaWdodDogJ3B4JyxcbiAgbGVmdDogJ3B4JyxcbiAgJ2xldHRlci1zcGFjaW5nJzogJ3B4JyxcbiAgJ2xvZ2ljYWwtaGVpZ2h0JzogJ3B4JyxcbiAgJ2xvZ2ljYWwtd2lkdGgnOiAncHgnLFxuICBtYXJnaW46ICdweCcsXG4gICdtYXJnaW4tYWZ0ZXInOiAncHgnLFxuICAnbWFyZ2luLWJlZm9yZSc6ICdweCcsXG4gICdtYXJnaW4tYm90dG9tJzogJ3B4JyxcbiAgJ21hcmdpbi1sZWZ0JzogJ3B4JyxcbiAgJ21hcmdpbi1yaWdodCc6ICdweCcsXG4gICdtYXJnaW4tdG9wJzogJ3B4JyxcbiAgJ21heC1oZWlnaHQnOiAncHgnLFxuICAnbWF4LXdpZHRoJzogJ3B4JyxcbiAgJ21hcmdpbi1lbmQnOiAncHgnLFxuICAnbWFyZ2luLXN0YXJ0JzogJ3B4JyxcbiAgJ21hc2stcG9zaXRpb24teCc6ICdweCcsXG4gICdtYXNrLXBvc2l0aW9uLXknOiAncHgnLFxuICAnbWFzay1zaXplJzogJ3B4JyxcbiAgJ21heC1sb2dpY2FsLWhlaWdodCc6ICdweCcsXG4gICdtYXgtbG9naWNhbC13aWR0aCc6ICdweCcsXG4gICdtaW4taGVpZ2h0JzogJ3B4JyxcbiAgJ21pbi13aWR0aCc6ICdweCcsXG4gICdtaW4tbG9naWNhbC1oZWlnaHQnOiAncHgnLFxuICAnbWluLWxvZ2ljYWwtd2lkdGgnOiAncHgnLFxuICBtb3Rpb246ICdweCcsXG4gICdtb3Rpb24tb2Zmc2V0JzogJ3B4JyxcbiAgb3V0bGluZTogJ3B4JyxcbiAgJ291dGxpbmUtb2Zmc2V0JzogJ3B4JyxcbiAgJ291dGxpbmUtd2lkdGgnOiAncHgnLFxuICBwYWRkaW5nOiAncHgnLFxuICAncGFkZGluZy1ib3R0b20nOiAncHgnLFxuICAncGFkZGluZy1sZWZ0JzogJ3B4JyxcbiAgJ3BhZGRpbmctcmlnaHQnOiAncHgnLFxuICAncGFkZGluZy10b3AnOiAncHgnLFxuICAncGFkZGluZy1hZnRlcic6ICdweCcsXG4gICdwYWRkaW5nLWJlZm9yZSc6ICdweCcsXG4gICdwYWRkaW5nLWVuZCc6ICdweCcsXG4gICdwYWRkaW5nLXN0YXJ0JzogJ3B4JyxcbiAgJ3BlcnNwZWN0aXZlLW9yaWdpbi14JzogJyUnLFxuICAncGVyc3BlY3RpdmUtb3JpZ2luLXknOiAnJScsXG4gIHBlcnNwZWN0aXZlOiAncHgnLFxuICByaWdodDogJ3B4JyxcbiAgJ3NoYXBlLW1hcmdpbic6ICdweCcsXG4gIHNpemU6ICdweCcsXG4gICd0ZXh0LWluZGVudCc6ICdweCcsXG4gICd0ZXh0LXN0cm9rZSc6ICdweCcsXG4gICd0ZXh0LXN0cm9rZS13aWR0aCc6ICdweCcsXG4gIHRvcDogJ3B4JyxcbiAgJ3RyYW5zZm9ybS1vcmlnaW4nOiAnJScsXG4gICd0cmFuc2Zvcm0tb3JpZ2luLXgnOiAnJScsXG4gICd0cmFuc2Zvcm0tb3JpZ2luLXknOiAnJScsXG4gICd0cmFuc2Zvcm0tb3JpZ2luLXonOiAnJScsXG4gICd0cmFuc2l0aW9uLWRlbGF5JzogJ21zJyxcbiAgJ3RyYW5zaXRpb24tZHVyYXRpb24nOiAnbXMnLFxuICAndmVydGljYWwtYWxpZ24nOiAncHgnLFxuICB3aWR0aDogJ3B4JyxcbiAgJ3dvcmQtc3BhY2luZyc6ICdweCcsXG4gIC8vIE5vdCBleGlzdGluZyBwcm9wZXJ0aWVzLlxuICAvLyBVc2VkIHRvIGF2b2lkIGlzc3VlcyB3aXRoIGpzcy1leHBhbmQgaW50ZXJncmF0aW9uLlxuICAnYm94LXNoYWRvdy14JzogJ3B4JyxcbiAgJ2JveC1zaGFkb3cteSc6ICdweCcsXG4gICdib3gtc2hhZG93LWJsdXInOiAncHgnLFxuICAnYm94LXNoYWRvdy1zcHJlYWQnOiAncHgnLFxuICAnZm9udC1saW5lLWhlaWdodCc6ICdweCcsXG4gICd0ZXh0LXNoYWRvdy14JzogJ3B4JyxcbiAgJ3RleHQtc2hhZG93LXknOiAncHgnLFxuICAndGV4dC1zaGFkb3ctYmx1cic6ICdweCdcbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGRlZmF1bHRVbml0O1xuXG52YXIgX2RlZmF1bHRVbml0cyA9IHJlcXVpcmUoJy4vZGVmYXVsdFVuaXRzJyk7XG5cbnZhciBfZGVmYXVsdFVuaXRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RlZmF1bHRVbml0cyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuLyoqXG4gKiBDbG9uZXMgdGhlIG9iamVjdCBhbmQgYWRkcyBhIGNhbWVsIGNhc2VkIHByb3BlcnR5IHZlcnNpb24uXG4gKi9cbmZ1bmN0aW9uIGFkZENhbWVsQ2FzZWRWZXJzaW9uKG9iaikge1xuICB2YXIgcmVnRXhwID0gLygtW2Etel0pL2c7XG4gIHZhciByZXBsYWNlID0gZnVuY3Rpb24gcmVwbGFjZShzdHIpIHtcbiAgICByZXR1cm4gc3RyWzFdLnRvVXBwZXJDYXNlKCk7XG4gIH07XG4gIHZhciBuZXdPYmogPSB7fTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIG5ld09ialtrZXldID0gb2JqW2tleV07XG4gICAgbmV3T2JqW2tleS5yZXBsYWNlKHJlZ0V4cCwgcmVwbGFjZSldID0gb2JqW2tleV07XG4gIH1cbiAgcmV0dXJuIG5ld09iajtcbn1cblxudmFyIHVuaXRzID0gYWRkQ2FtZWxDYXNlZFZlcnNpb24oX2RlZmF1bHRVbml0czJbJ2RlZmF1bHQnXSk7XG5cbi8qKlxuICogUmVjdXJzaXZlIGRlZXAgc3R5bGUgcGFzc2luZyBmdW5jdGlvblxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBjdXJyZW50IHByb3BlcnR5XG4gKiBAcGFyYW0geyhPYmplY3R8QXJyYXl8TnVtYmVyfFN0cmluZyl9IHByb3BlcnR5IHZhbHVlXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7KE9iamVjdHxBcnJheXxOdW1iZXJ8U3RyaW5nKX0gcmVzdWx0aW5nIHZhbHVlXG4gKi9cbmZ1bmN0aW9uIGl0ZXJhdGUocHJvcCwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgaWYgKCF2YWx1ZSkgcmV0dXJuIHZhbHVlO1xuXG4gIHZhciBjb252ZXJ0ZWRWYWx1ZSA9IHZhbHVlO1xuXG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih2YWx1ZSk7XG4gIGlmICh0eXBlID09PSAnb2JqZWN0JyAmJiBBcnJheS5pc0FycmF5KHZhbHVlKSkgdHlwZSA9ICdhcnJheSc7XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIGlmIChwcm9wID09PSAnZmFsbGJhY2tzJykge1xuICAgICAgICBmb3IgKHZhciBpbm5lclByb3AgaW4gdmFsdWUpIHtcbiAgICAgICAgICB2YWx1ZVtpbm5lclByb3BdID0gaXRlcmF0ZShpbm5lclByb3AsIHZhbHVlW2lubmVyUHJvcF0sIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgX2lubmVyUHJvcCBpbiB2YWx1ZSkge1xuICAgICAgICB2YWx1ZVtfaW5uZXJQcm9wXSA9IGl0ZXJhdGUocHJvcCArICctJyArIF9pbm5lclByb3AsIHZhbHVlW19pbm5lclByb3BdLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2FycmF5JzpcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFsdWVbaV0gPSBpdGVyYXRlKHByb3AsIHZhbHVlW2ldLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ251bWJlcic6XG4gICAgICBpZiAodmFsdWUgIT09IDApIHtcbiAgICAgICAgY29udmVydGVkVmFsdWUgPSB2YWx1ZSArIChvcHRpb25zW3Byb3BdIHx8IHVuaXRzW3Byb3BdIHx8ICcnKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBicmVhaztcbiAgfVxuXG4gIHJldHVybiBjb252ZXJ0ZWRWYWx1ZTtcbn1cblxuLyoqXG4gKiBBZGQgdW5pdCB0byBudW1lcmljIHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gZGVmYXVsdFVuaXQoKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICB2YXIgY2FtZWxDYXNlZE9wdGlvbnMgPSBhZGRDYW1lbENhc2VkVmVyc2lvbihvcHRpb25zKTtcblxuICBmdW5jdGlvbiBvblByb2Nlc3NTdHlsZShzdHlsZSwgcnVsZSkge1xuICAgIGlmIChydWxlLnR5cGUgIT09ICdzdHlsZScpIHJldHVybiBzdHlsZTtcblxuICAgIGZvciAodmFyIHByb3AgaW4gc3R5bGUpIHtcbiAgICAgIHN0eWxlW3Byb3BdID0gaXRlcmF0ZShwcm9wLCBzdHlsZVtwcm9wXSwgY2FtZWxDYXNlZE9wdGlvbnMpO1xuICAgIH1cblxuICAgIHJldHVybiBzdHlsZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uQ2hhbmdlVmFsdWUodmFsdWUsIHByb3ApIHtcbiAgICByZXR1cm4gaXRlcmF0ZShwcm9wLCB2YWx1ZSwgY2FtZWxDYXNlZE9wdGlvbnMpO1xuICB9XG5cbiAgcmV0dXJuIHsgb25Qcm9jZXNzU3R5bGU6IG9uUHJvY2Vzc1N0eWxlLCBvbkNoYW5nZVZhbHVlOiBvbkNoYW5nZVZhbHVlIH07XG59IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGpzc0V4cGFuZDtcblxudmFyIF9wcm9wcyA9IHJlcXVpcmUoJy4vcHJvcHMnKTtcblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuLyoqXG4gKiBNYXAgdmFsdWVzIGJ5IGdpdmVuIHByb3AuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgb2YgdmFsdWVzXG4gKiBAcGFyYW0ge1N0cmluZ30gb3JpZ2luYWwgcHJvcGVydHlcbiAqIEBwYXJhbSB7U3RyaW5nfSBvcmlnaW5hbCBydWxlXG4gKiBAcmV0dXJuIHtTdHJpbmd9IG1hcHBlZCB2YWx1ZXNcbiAqL1xuZnVuY3Rpb24gbWFwVmFsdWVzQnlQcm9wKHZhbHVlLCBwcm9wLCBydWxlKSB7XG4gIHJldHVybiB2YWx1ZS5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICByZXR1cm4gb2JqZWN0VG9TdHJpbmcoaXRlbSwgcHJvcCwgcnVsZSk7XG4gIH0pO1xufVxuXG4vKipcbiAqIENvbnZlcnQgYXJyYXkgdG8gc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IG9mIHZhbHVlc1xuICogQHBhcmFtIHtTdHJpbmd9IG9yaWdpbmFsIHByb3BlcnR5XG4gKiBAcGFyYW0ge09iamVjdH0gc2hlbWUsIGZvciBjb252ZXJ0aW5nIGFycmF5cyBpbiBzdHJpbmdzXG4gKiBAcGFyYW0ge09iamVjdH0gb3JpZ2luYWwgcnVsZVxuICogQHJldHVybiB7U3RyaW5nfSBjb252ZXJ0ZWQgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIGFycmF5VG9TdHJpbmcodmFsdWUsIHByb3AsIHNjaGVtZSwgcnVsZSkge1xuICBpZiAoc2NoZW1lW3Byb3BdID09IG51bGwpIHJldHVybiB2YWx1ZS5qb2luKCcsJyk7XG4gIGlmICh2YWx1ZS5sZW5ndGggPT09IDApIHJldHVybiAnJztcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVbMF0pKSByZXR1cm4gYXJyYXlUb1N0cmluZyh2YWx1ZVswXSwgcHJvcCwgc2NoZW1lKTtcbiAgaWYgKF90eXBlb2YodmFsdWVbMF0pID09PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBtYXBWYWx1ZXNCeVByb3AodmFsdWUsIHByb3AsIHJ1bGUpO1xuICB9XG4gIHJldHVybiB2YWx1ZS5qb2luKCcgJyk7XG59XG5cbi8qKlxuICogQ29udmVydCBvYmplY3QgdG8gc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3Qgb2YgdmFsdWVzXG4gKiBAcGFyYW0ge1N0cmluZ30gb3JpZ2luYWwgcHJvcGVydHlcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcmlnaW5hbCBydWxlXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGlzIGZhbGxiYWNrIHByb3BcbiAqIEByZXR1cm4ge1N0cmluZ30gY29udmVydGVkIHN0cmluZ1xuICovXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyh2YWx1ZSwgcHJvcCwgcnVsZSwgaXNGYWxsYmFjaykge1xuICBpZiAoIShfcHJvcHMucHJvcE9ialtwcm9wXSB8fCBfcHJvcHMuY3VzdG9tUHJvcE9ialtwcm9wXSkpIHJldHVybiAnJztcblxuICB2YXIgcmVzdWx0ID0gW107XG5cbiAgLy8gQ2hlY2sgaWYgZXhpc3RzIGFueSBub24tc3RhbmRhcnQgcHJvcGVydHlcbiAgaWYgKF9wcm9wcy5jdXN0b21Qcm9wT2JqW3Byb3BdKSB7XG4gICAgdmFsdWUgPSBjdXN0b21Qcm9wc1RvU3R5bGUodmFsdWUsIHJ1bGUsIF9wcm9wcy5jdXN0b21Qcm9wT2JqW3Byb3BdLCBpc0ZhbGxiYWNrKTtcbiAgfVxuXG4gIC8vIFBhc3MgdGhyb3VnaHQgYWxsIHN0YW5kYXJ0IHByb3BzXG4gIGlmIChPYmplY3Qua2V5cyh2YWx1ZSkubGVuZ3RoKSB7XG4gICAgZm9yICh2YXIgYmFzZVByb3AgaW4gX3Byb3BzLnByb3BPYmpbcHJvcF0pIHtcbiAgICAgIGlmICh2YWx1ZVtiYXNlUHJvcF0pIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVbYmFzZVByb3BdKSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGFycmF5VG9TdHJpbmcodmFsdWVbYmFzZVByb3BdLCBiYXNlUHJvcCwgX3Byb3BzLnByb3BBcnJheUluT2JqKSk7XG4gICAgICAgIH0gZWxzZSByZXN1bHQucHVzaCh2YWx1ZVtiYXNlUHJvcF0pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gQWRkIGRlZmF1bHQgdmFsdWUgZnJvbSBwcm9wcyBjb25maWcuXG4gICAgICBpZiAoX3Byb3BzLnByb3BPYmpbcHJvcF1bYmFzZVByb3BdICE9IG51bGwpIHtcbiAgICAgICAgcmVzdWx0LnB1c2goX3Byb3BzLnByb3BPYmpbcHJvcF1bYmFzZVByb3BdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0LmpvaW4oJyAnKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGN1c3RvbSBwcm9wZXJ0aWVzIHZhbHVlcyB0byBzdHlsZXMgYWRkaW5nIHRoZW0gdG8gcnVsZSBkaXJlY3RseVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3Qgb2YgdmFsdWVzXG4gKiBAcGFyYW0ge09iamVjdH0gb3JpZ2luYWwgcnVsZVxuICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5LCB0aGF0IGNvbnRhaW4gcGFydGlhbCBjdXN0b20gcHJvcGVydGllc1xuICogQHBhcmFtIHtCb29sZWFufSBpcyBmYWxsYmFjayBwcm9wXG4gKiBAcmV0dXJuIHtPYmplY3R9IHZhbHVlIHdpdGhvdXQgY3VzdG9tIHByb3BlcnRpZXMsIHRoYXQgd2FzIGFscmVhZHkgYWRkZWQgdG8gcnVsZVxuICovXG5mdW5jdGlvbiBjdXN0b21Qcm9wc1RvU3R5bGUodmFsdWUsIHJ1bGUsIGN1c3RvbVByb3BzLCBpc0ZhbGxiYWNrKSB7XG4gIGZvciAodmFyIHByb3AgaW4gY3VzdG9tUHJvcHMpIHtcbiAgICB2YXIgcHJvcE5hbWUgPSBjdXN0b21Qcm9wc1twcm9wXTtcblxuICAgIC8vIElmIGN1cnJlbnQgcHJvcGVydHkgZG9lc24ndCBleGlzdCBhbHJlYWR5IGluIHJ1bGUgLSBhZGQgbmV3IG9uZVxuICAgIGlmICh0eXBlb2YgdmFsdWVbcHJvcF0gIT09ICd1bmRlZmluZWQnICYmIChpc0ZhbGxiYWNrIHx8ICFydWxlLnByb3AocHJvcE5hbWUpKSkge1xuICAgICAgdmFyIGFwcGVuZGVkVmFsdWUgPSBzdHlsZURldGVjdG9yKF9kZWZpbmVQcm9wZXJ0eSh7fSwgcHJvcE5hbWUsIHZhbHVlW3Byb3BdKSwgcnVsZSlbcHJvcE5hbWVdO1xuXG4gICAgICAvLyBBZGQgc3R5bGUgZGlyZWN0bHkgaW4gcnVsZVxuICAgICAgaWYgKGlzRmFsbGJhY2spIHJ1bGUuc3R5bGUuZmFsbGJhY2tzW3Byb3BOYW1lXSA9IGFwcGVuZGVkVmFsdWU7ZWxzZSBydWxlLnN0eWxlW3Byb3BOYW1lXSA9IGFwcGVuZGVkVmFsdWU7XG4gICAgfVxuICAgIC8vIERlbGV0ZSBjb252ZXJ0ZWQgcHJvcGVydHkgdG8gYXZvaWQgZG91YmxlIGNvbnZlcnRpbmdcbiAgICBkZWxldGUgdmFsdWVbcHJvcF07XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59XG5cbi8qKlxuICogRGV0ZWN0IGlmIGEgc3R5bGUgbmVlZHMgdG8gYmUgY29udmVydGVkLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdHlsZVxuICogQHBhcmFtIHtPYmplY3R9IHJ1bGVcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaXMgZmFsbGJhY2sgcHJvcFxuICogQHJldHVybiB7T2JqZWN0fSBjb252ZXJ0ZWRTdHlsZVxuICovXG5mdW5jdGlvbiBzdHlsZURldGVjdG9yKHN0eWxlLCBydWxlLCBpc0ZhbGxiYWNrKSB7XG4gIGZvciAodmFyIHByb3AgaW4gc3R5bGUpIHtcbiAgICB2YXIgdmFsdWUgPSBzdHlsZVtwcm9wXTtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgLy8gQ2hlY2sgZG91YmxlIGFycmF5cyB0byBhdm9pZCByZWN1cnNpb24uXG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWVbMF0pKSB7XG4gICAgICAgIGlmIChwcm9wID09PSAnZmFsbGJhY2tzJykge1xuICAgICAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBzdHlsZS5mYWxsYmFja3MubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICBzdHlsZS5mYWxsYmFja3NbaW5kZXhdID0gc3R5bGVEZXRlY3RvcihzdHlsZS5mYWxsYmFja3NbaW5kZXhdLCBydWxlLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBzdHlsZVtwcm9wXSA9IGFycmF5VG9TdHJpbmcodmFsdWUsIHByb3AsIF9wcm9wcy5wcm9wQXJyYXkpO1xuICAgICAgICAvLyBBdm9pZCBjcmVhdGluZyBwcm9wZXJ0aWVzIHdpdGggZW1wdHkgdmFsdWVzXG4gICAgICAgIGlmICghc3R5bGVbcHJvcF0pIGRlbGV0ZSBzdHlsZVtwcm9wXTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHZhbHVlKSkgPT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAocHJvcCA9PT0gJ2ZhbGxiYWNrcycpIHtcbiAgICAgICAgc3R5bGUuZmFsbGJhY2tzID0gc3R5bGVEZXRlY3RvcihzdHlsZS5mYWxsYmFja3MsIHJ1bGUsIHRydWUpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgc3R5bGVbcHJvcF0gPSBvYmplY3RUb1N0cmluZyh2YWx1ZSwgcHJvcCwgcnVsZSwgaXNGYWxsYmFjayk7XG4gICAgICAvLyBBdm9pZCBjcmVhdGluZyBwcm9wZXJ0aWVzIHdpdGggZW1wdHkgdmFsdWVzXG4gICAgICBpZiAoIXN0eWxlW3Byb3BdKSBkZWxldGUgc3R5bGVbcHJvcF07XG4gICAgfVxuXG4gICAgLy8gTWF5YmUgYSBjb21wdXRlZCB2YWx1ZSByZXN1bHRpbmcgaW4gYW4gZW1wdHkgc3RyaW5nXG4gICAgZWxzZSBpZiAoc3R5bGVbcHJvcF0gPT09ICcnKSBkZWxldGUgc3R5bGVbcHJvcF07XG4gIH1cblxuICByZXR1cm4gc3R5bGU7XG59XG5cbi8qKlxuICogQWRkcyBwb3NzaWJpbGl0eSB0byB3cml0ZSBleHBhbmRlZCBzdHlsZXMuXG4gKlxuICogQHBhcmFtIHtSdWxlfSBydWxlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5mdW5jdGlvbiBqc3NFeHBhbmQoKSB7XG4gIGZ1bmN0aW9uIG9uUHJvY2Vzc1N0eWxlKHN0eWxlLCBydWxlKSB7XG4gICAgaWYgKCFzdHlsZSB8fCBydWxlLnR5cGUgIT09ICdzdHlsZScpIHJldHVybiBzdHlsZTtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KHN0eWxlKSkge1xuICAgICAgLy8gUGFzcyBydWxlcyBvbmUgYnkgb25lIGFuZCByZWZvcm1hdCB0aGVtXG4gICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgc3R5bGUubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIHN0eWxlW2luZGV4XSA9IHN0eWxlRGV0ZWN0b3Ioc3R5bGVbaW5kZXhdLCBydWxlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHlsZTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3R5bGVEZXRlY3RvcihzdHlsZSwgcnVsZSk7XG4gIH1cblxuICByZXR1cm4geyBvblByb2Nlc3NTdHlsZTogb25Qcm9jZXNzU3R5bGUgfTtcbn0iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG4vKipcbiAqIEEgc2NoZW1lIGZvciBjb252ZXJ0aW5nIHByb3BlcnRpZXMgZnJvbSBhcnJheSB0byByZWd1bGFyIHN0eWxlLlxuICogQWxsIHByb3BlcnRpZXMgbGlzdGVkIGJlbG93IHdpbGwgYmUgdHJhbnNmb3JtZWQgdG8gYSBzdHJpbmcgc2VwYXJhdGVkIGJ5IHNwYWNlLlxuICovXG52YXIgcHJvcEFycmF5ID0gZXhwb3J0cy5wcm9wQXJyYXkgPSB7XG4gICdiYWNrZ3JvdW5kLXNpemUnOiB0cnVlLFxuICAnYmFja2dyb3VuZC1wb3NpdGlvbic6IHRydWUsXG4gIGJvcmRlcjogdHJ1ZSxcbiAgJ2JvcmRlci1ib3R0b20nOiB0cnVlLFxuICAnYm9yZGVyLWxlZnQnOiB0cnVlLFxuICAnYm9yZGVyLXRvcCc6IHRydWUsXG4gICdib3JkZXItcmlnaHQnOiB0cnVlLFxuICAnYm9yZGVyLXJhZGl1cyc6IHRydWUsXG4gICdib3JkZXItaW1hZ2UnOiB0cnVlLFxuICAnYm94LXNoYWRvdyc6IHRydWUsXG4gIGZsZXg6IHRydWUsXG4gIG1hcmdpbjogdHJ1ZSxcbiAgcGFkZGluZzogdHJ1ZSxcbiAgb3V0bGluZTogdHJ1ZSxcbiAgJ3RyYW5zZm9ybS1vcmlnaW4nOiB0cnVlLFxuICB0cmFuc2Zvcm06IHRydWUsXG4gIHRyYW5zaXRpb246IHRydWVcblxuICAvKipcbiAgICogQSBzY2hlbWUgZm9yIGNvbnZlcnRpbmcgYXJyYXlzIHRvIHJlZ3VsYXIgc3R5bGVzIGluc2lkZSBvZiBvYmplY3RzLlxuICAgKiBGb3IgZS5nLjogXCJ7cG9zaXRpb246IFswLCAwXX1cIiA9PiBcImJhY2tncm91bmQtcG9zaXRpb246IDAgMDtcIi5cbiAgICovXG59O3ZhciBwcm9wQXJyYXlJbk9iaiA9IGV4cG9ydHMucHJvcEFycmF5SW5PYmogPSB7XG4gIHBvc2l0aW9uOiB0cnVlLCAvLyBiYWNrZ3JvdW5kLXBvc2l0aW9uXG4gIHNpemU6IHRydWUgLy8gYmFja2dyb3VuZC1zaXplXG5cblxuICAvKipcbiAgICogQSBzY2hlbWUgZm9yIHBhcnNpbmcgYW5kIGJ1aWxkaW5nIGNvcnJlY3Qgc3R5bGVzIGZyb20gcGFzc2VkIG9iamVjdHMuXG4gICAqL1xufTt2YXIgcHJvcE9iaiA9IGV4cG9ydHMucHJvcE9iaiA9IHtcbiAgcGFkZGluZzoge1xuICAgIHRvcDogMCxcbiAgICByaWdodDogMCxcbiAgICBib3R0b206IDAsXG4gICAgbGVmdDogMFxuICB9LFxuICBtYXJnaW46IHtcbiAgICB0b3A6IDAsXG4gICAgcmlnaHQ6IDAsXG4gICAgYm90dG9tOiAwLFxuICAgIGxlZnQ6IDBcbiAgfSxcbiAgYmFja2dyb3VuZDoge1xuICAgIGF0dGFjaG1lbnQ6IG51bGwsXG4gICAgY29sb3I6IG51bGwsXG4gICAgaW1hZ2U6IG51bGwsXG4gICAgcG9zaXRpb246IG51bGwsXG4gICAgcmVwZWF0OiBudWxsXG4gIH0sXG4gIGJvcmRlcjoge1xuICAgIHdpZHRoOiBudWxsLFxuICAgIHN0eWxlOiBudWxsLFxuICAgIGNvbG9yOiBudWxsXG4gIH0sXG4gICdib3JkZXItdG9wJzoge1xuICAgIHdpZHRoOiBudWxsLFxuICAgIHN0eWxlOiBudWxsLFxuICAgIGNvbG9yOiBudWxsXG4gIH0sXG4gICdib3JkZXItcmlnaHQnOiB7XG4gICAgd2lkdGg6IG51bGwsXG4gICAgc3R5bGU6IG51bGwsXG4gICAgY29sb3I6IG51bGxcbiAgfSxcbiAgJ2JvcmRlci1ib3R0b20nOiB7XG4gICAgd2lkdGg6IG51bGwsXG4gICAgc3R5bGU6IG51bGwsXG4gICAgY29sb3I6IG51bGxcbiAgfSxcbiAgJ2JvcmRlci1sZWZ0Jzoge1xuICAgIHdpZHRoOiBudWxsLFxuICAgIHN0eWxlOiBudWxsLFxuICAgIGNvbG9yOiBudWxsXG4gIH0sXG4gIG91dGxpbmU6IHtcbiAgICB3aWR0aDogbnVsbCxcbiAgICBzdHlsZTogbnVsbCxcbiAgICBjb2xvcjogbnVsbFxuICB9LFxuICAnbGlzdC1zdHlsZSc6IHtcbiAgICB0eXBlOiBudWxsLFxuICAgIHBvc2l0aW9uOiBudWxsLFxuICAgIGltYWdlOiBudWxsXG4gIH0sXG4gIHRyYW5zaXRpb246IHtcbiAgICBwcm9wZXJ0eTogbnVsbCxcbiAgICBkdXJhdGlvbjogbnVsbCxcbiAgICAndGltaW5nLWZ1bmN0aW9uJzogbnVsbCxcbiAgICB0aW1pbmdGdW5jdGlvbjogbnVsbCwgLy8gTmVlZGVkIGZvciBhdm9pZGluZyBjb21pbGF0aW9uIGlzc3VlcyB3aXRoIGpzcy1jYW1lbC1jYXNlXG4gICAgZGVsYXk6IG51bGxcbiAgfSxcbiAgYW5pbWF0aW9uOiB7XG4gICAgbmFtZTogbnVsbCxcbiAgICBkdXJhdGlvbjogbnVsbCxcbiAgICAndGltaW5nLWZ1bmN0aW9uJzogbnVsbCxcbiAgICB0aW1pbmdGdW5jdGlvbjogbnVsbCwgLy8gTmVlZGVkIHRvIGF2b2lkIGNvbXBpbGF0aW9uIGlzc3VlcyB3aXRoIGpzcy1jYW1lbC1jYXNlXG4gICAgZGVsYXk6IG51bGwsXG4gICAgJ2l0ZXJhdGlvbi1jb3VudCc6IG51bGwsXG4gICAgaXRlcmF0aW9uQ291bnQ6IG51bGwsIC8vIE5lZWRlZCB0byBhdm9pZCBjb21waWxhdGlvbiBpc3N1ZXMgd2l0aCBqc3MtY2FtZWwtY2FzZVxuICAgIGRpcmVjdGlvbjogbnVsbCxcbiAgICAnZmlsbC1tb2RlJzogbnVsbCxcbiAgICBmaWxsTW9kZTogbnVsbCwgLy8gTmVlZGVkIHRvIGF2b2lkIGNvbXBpbGF0aW9uIGlzc3VlcyB3aXRoIGpzcy1jYW1lbC1jYXNlXG4gICAgJ3BsYXktc3RhdGUnOiBudWxsLFxuICAgIHBsYXlTdGF0ZTogbnVsbCAvLyBOZWVkZWQgdG8gYXZvaWQgY29tcGlsYXRpb24gaXNzdWVzIHdpdGgganNzLWNhbWVsLWNhc2VcbiAgfSxcbiAgJ2JveC1zaGFkb3cnOiB7XG4gICAgeDogMCxcbiAgICB5OiAwLFxuICAgIGJsdXI6IDAsXG4gICAgc3ByZWFkOiAwLFxuICAgIGNvbG9yOiBudWxsLFxuICAgIGluc2V0OiBudWxsXG4gIH0sXG4gICd0ZXh0LXNoYWRvdyc6IHtcbiAgICB4OiAwLFxuICAgIHk6IDAsXG4gICAgYmx1cjogbnVsbCxcbiAgICBjb2xvcjogbnVsbFxuICB9XG5cbiAgLyoqXG4gICAqIEEgc2NoZW1lIGZvciBjb252ZXJ0aW5nIG5vbi1zdGFuZGFydCBwcm9wZXJ0aWVzIGluc2lkZSBvYmplY3QuXG4gICAqIEZvciBlLmcuOiBpbmNsdWRlICdib3JkZXItcmFkaXVzJyBwcm9wZXJ0eSBpbnNpZGUgJ2JvcmRlcicgb2JqZWN0LlxuICAgKi9cbn07dmFyIGN1c3RvbVByb3BPYmogPSBleHBvcnRzLmN1c3RvbVByb3BPYmogPSB7XG4gIGJvcmRlcjoge1xuICAgIHJhZGl1czogJ2JvcmRlci1yYWRpdXMnLFxuICAgIGltYWdlOiAnYm9yZGVyLWltYWdlJ1xuICB9LFxuICBiYWNrZ3JvdW5kOiB7XG4gICAgc2l6ZTogJ2JhY2tncm91bmQtc2l6ZScsXG4gICAgaW1hZ2U6ICdiYWNrZ3JvdW5kLWltYWdlJ1xuICB9LFxuICBmb250OiB7XG4gICAgc3R5bGU6ICdmb250LXN0eWxlJyxcbiAgICB2YXJpYW50OiAnZm9udC12YXJpYW50JyxcbiAgICB3ZWlnaHQ6ICdmb250LXdlaWdodCcsXG4gICAgc3RyZXRjaDogJ2ZvbnQtc3RyZXRjaCcsXG4gICAgc2l6ZTogJ2ZvbnQtc2l6ZScsXG4gICAgZmFtaWx5OiAnZm9udC1mYW1pbHknLFxuICAgIGxpbmVIZWlnaHQ6ICdsaW5lLWhlaWdodCcsIC8vIE5lZWRlZCB0byBhdm9pZCBjb21waWxhdGlvbiBpc3N1ZXMgd2l0aCBqc3MtY2FtZWwtY2FzZVxuICAgICdsaW5lLWhlaWdodCc6ICdsaW5lLWhlaWdodCdcbiAgfSxcbiAgZmxleDoge1xuICAgIGdyb3c6ICdmbGV4LWdyb3cnLFxuICAgIGJhc2lzOiAnZmxleC1iYXNpcycsXG4gICAgZGlyZWN0aW9uOiAnZmxleC1kaXJlY3Rpb24nLFxuICAgIHdyYXA6ICdmbGV4LXdyYXAnLFxuICAgIGZsb3c6ICdmbGV4LWZsb3cnLFxuICAgIHNocmluazogJ2ZsZXgtc2hyaW5rJ1xuICB9LFxuICBhbGlnbjoge1xuICAgIHNlbGY6ICdhbGlnbi1zZWxmJyxcbiAgICBpdGVtczogJ2FsaWduLWl0ZW1zJyxcbiAgICBjb250ZW50OiAnYWxpZ24tY29udGVudCdcbiAgfVxufTsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0ganNzRXh0ZW5kO1xuXG52YXIgX3dhcm5pbmcgPSByZXF1aXJlKCd3YXJuaW5nJyk7XG5cbnZhciBfd2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93YXJuaW5nKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgaXNPYmplY3QgPSBmdW5jdGlvbiBpc09iamVjdChvYmopIHtcbiAgcmV0dXJuIG9iaiAmJiAodHlwZW9mIG9iaiA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2Yob2JqKSkgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KG9iaik7XG59O1xuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IGV4dGVuZCBzdHlsZXMuXG4gKi9cbmZ1bmN0aW9uIGV4dGVuZChzdHlsZSwgcnVsZSwgc2hlZXQpIHtcbiAgdmFyIG5ld1N0eWxlID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB7fTtcblxuICBpZiAodHlwZW9mIHN0eWxlLmV4dGVuZCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAoc2hlZXQpIHtcbiAgICAgIHZhciByZWZSdWxlID0gc2hlZXQuZ2V0UnVsZShzdHlsZS5leHRlbmQpO1xuICAgICAgaWYgKHJlZlJ1bGUpIHtcbiAgICAgICAgaWYgKHJlZlJ1bGUgPT09IHJ1bGUpICgwLCBfd2FybmluZzJbJ2RlZmF1bHQnXSkoZmFsc2UsICdbSlNTXSBBIHJ1bGUgdHJpZXMgdG8gZXh0ZW5kIGl0c2VsZiBcXHJcXG4lcycsIHJ1bGUpO2Vsc2UgaWYgKHJlZlJ1bGUub3B0aW9ucy5wYXJlbnQpIHtcbiAgICAgICAgICB2YXIgb3JpZ2luYWxTdHlsZSA9IHJlZlJ1bGUub3B0aW9ucy5wYXJlbnQucnVsZXMucmF3W3N0eWxlLmV4dGVuZF07XG4gICAgICAgICAgZXh0ZW5kKG9yaWdpbmFsU3R5bGUsIHJ1bGUsIHNoZWV0LCBuZXdTdHlsZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShzdHlsZS5leHRlbmQpKSB7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IHN0eWxlLmV4dGVuZC5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIGV4dGVuZChzdHlsZS5leHRlbmRbaW5kZXhdLCBydWxlLCBzaGVldCwgbmV3U3R5bGUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBwcm9wIGluIHN0eWxlLmV4dGVuZCkge1xuICAgICAgaWYgKHByb3AgPT09ICdleHRlbmQnKSB7XG4gICAgICAgIGV4dGVuZChzdHlsZS5leHRlbmQuZXh0ZW5kLCBydWxlLCBzaGVldCwgbmV3U3R5bGUpO1xuICAgICAgfSBlbHNlIGlmIChpc09iamVjdChzdHlsZS5leHRlbmRbcHJvcF0pKSB7XG4gICAgICAgIGlmICghbmV3U3R5bGVbcHJvcF0pIG5ld1N0eWxlW3Byb3BdID0ge307XG4gICAgICAgIGV4dGVuZChzdHlsZS5leHRlbmRbcHJvcF0sIHJ1bGUsIHNoZWV0LCBuZXdTdHlsZVtwcm9wXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdTdHlsZVtwcm9wXSA9IHN0eWxlLmV4dGVuZFtwcm9wXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy8gQ29weSBiYXNlIHN0eWxlLlxuICBmb3IgKHZhciBfcHJvcCBpbiBzdHlsZSkge1xuICAgIGlmIChfcHJvcCA9PT0gJ2V4dGVuZCcpIGNvbnRpbnVlO1xuICAgIGlmIChpc09iamVjdChuZXdTdHlsZVtfcHJvcF0pICYmIGlzT2JqZWN0KHN0eWxlW19wcm9wXSkpIHtcbiAgICAgIGV4dGVuZChzdHlsZVtfcHJvcF0sIHJ1bGUsIHNoZWV0LCBuZXdTdHlsZVtfcHJvcF0pO1xuICAgIH0gZWxzZSBpZiAoaXNPYmplY3Qoc3R5bGVbX3Byb3BdKSkge1xuICAgICAgbmV3U3R5bGVbX3Byb3BdID0gZXh0ZW5kKHN0eWxlW19wcm9wXSwgcnVsZSwgc2hlZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXdTdHlsZVtfcHJvcF0gPSBzdHlsZVtfcHJvcF07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ld1N0eWxlO1xufVxuXG4vKipcbiAqIEhhbmRsZSBgZXh0ZW5kYCBwcm9wZXJ0eS5cbiAqXG4gKiBAcGFyYW0ge1J1bGV9IHJ1bGVcbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIGpzc0V4dGVuZCgpIHtcbiAgZnVuY3Rpb24gb25Qcm9jZXNzU3R5bGUoc3R5bGUsIHJ1bGUsIHNoZWV0KSB7XG4gICAgcmV0dXJuIHN0eWxlLmV4dGVuZCA/IGV4dGVuZChzdHlsZSwgcnVsZSwgc2hlZXQpIDogc3R5bGU7XG4gIH1cblxuICByZXR1cm4geyBvblByb2Nlc3NTdHlsZTogb25Qcm9jZXNzU3R5bGUgfTtcbn0iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGpzc0dsb2JhbDtcblxudmFyIF9qc3MgPSByZXF1aXJlKCdqc3MnKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIHByb3BLZXkgPSAnQGdsb2JhbCc7XG52YXIgcHJlZml4S2V5ID0gJ0BnbG9iYWwgJztcblxudmFyIEdsb2JhbENvbnRhaW5lclJ1bGUgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEdsb2JhbENvbnRhaW5lclJ1bGUoa2V5LCBzdHlsZXMsIG9wdGlvbnMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgR2xvYmFsQ29udGFpbmVyUnVsZSk7XG5cbiAgICB0aGlzLnR5cGUgPSAnZ2xvYmFsJztcblxuICAgIHRoaXMua2V5ID0ga2V5O1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5ydWxlcyA9IG5ldyBfanNzLlJ1bGVMaXN0KF9leHRlbmRzKHt9LCBvcHRpb25zLCB7XG4gICAgICBwYXJlbnQ6IHRoaXNcbiAgICB9KSk7XG5cbiAgICBmb3IgKHZhciBzZWxlY3RvciBpbiBzdHlsZXMpIHtcbiAgICAgIHRoaXMucnVsZXMuYWRkKHNlbGVjdG9yLCBzdHlsZXNbc2VsZWN0b3JdLCB7IHNlbGVjdG9yOiBzZWxlY3RvciB9KTtcbiAgICB9XG5cbiAgICB0aGlzLnJ1bGVzLnByb2Nlc3MoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSBydWxlLlxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhHbG9iYWxDb250YWluZXJSdWxlLCBbe1xuICAgIGtleTogJ2dldFJ1bGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRSdWxlKG5hbWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnJ1bGVzLmdldChuYW1lKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYW5kIHJlZ2lzdGVyIHJ1bGUsIHJ1biBwbHVnaW5zLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdhZGRSdWxlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkUnVsZShuYW1lLCBzdHlsZSwgb3B0aW9ucykge1xuICAgICAgdmFyIHJ1bGUgPSB0aGlzLnJ1bGVzLmFkZChuYW1lLCBzdHlsZSwgb3B0aW9ucyk7XG4gICAgICB0aGlzLm9wdGlvbnMuanNzLnBsdWdpbnMub25Qcm9jZXNzUnVsZShydWxlKTtcbiAgICAgIHJldHVybiBydWxlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBpbmRleCBvZiBhIHJ1bGUuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2luZGV4T2YnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbmRleE9mKHJ1bGUpIHtcbiAgICAgIHJldHVybiB0aGlzLnJ1bGVzLmluZGV4T2YocnVsZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGEgQ1NTIHN0cmluZy5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAndG9TdHJpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiB0aGlzLnJ1bGVzLnRvU3RyaW5nKCk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEdsb2JhbENvbnRhaW5lclJ1bGU7XG59KCk7XG5cbnZhciBHbG9iYWxQcmVmaXhlZFJ1bGUgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEdsb2JhbFByZWZpeGVkUnVsZShuYW1lLCBzdHlsZSwgb3B0aW9ucykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBHbG9iYWxQcmVmaXhlZFJ1bGUpO1xuXG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHZhciBzZWxlY3RvciA9IG5hbWUuc3Vic3RyKHByZWZpeEtleS5sZW5ndGgpO1xuICAgIHRoaXMucnVsZSA9IG9wdGlvbnMuanNzLmNyZWF0ZVJ1bGUoc2VsZWN0b3IsIHN0eWxlLCBfZXh0ZW5kcyh7fSwgb3B0aW9ucywge1xuICAgICAgcGFyZW50OiB0aGlzLFxuICAgICAgc2VsZWN0b3I6IHNlbGVjdG9yXG4gICAgfSkpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEdsb2JhbFByZWZpeGVkUnVsZSwgW3tcbiAgICBrZXk6ICd0b1N0cmluZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLnJ1bGUudG9TdHJpbmcob3B0aW9ucyk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEdsb2JhbFByZWZpeGVkUnVsZTtcbn0oKTtcblxudmFyIHNlcGFyYXRvclJlZ0V4cCA9IC9cXHMqLFxccyovZztcblxuZnVuY3Rpb24gYWRkU2NvcGUoc2VsZWN0b3IsIHNjb3BlKSB7XG4gIHZhciBwYXJ0cyA9IHNlbGVjdG9yLnNwbGl0KHNlcGFyYXRvclJlZ0V4cCk7XG4gIHZhciBzY29wZWQgPSAnJztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgIHNjb3BlZCArPSBzY29wZSArICcgJyArIHBhcnRzW2ldLnRyaW0oKTtcbiAgICBpZiAocGFydHNbaSArIDFdKSBzY29wZWQgKz0gJywgJztcbiAgfVxuICByZXR1cm4gc2NvcGVkO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVOZXN0ZWRHbG9iYWxDb250YWluZXJSdWxlKHJ1bGUpIHtcbiAgdmFyIG9wdGlvbnMgPSBydWxlLm9wdGlvbnMsXG4gICAgICBzdHlsZSA9IHJ1bGUuc3R5bGU7XG5cbiAgdmFyIHJ1bGVzID0gc3R5bGVbcHJvcEtleV07XG5cbiAgaWYgKCFydWxlcykgcmV0dXJuO1xuXG4gIGZvciAodmFyIG5hbWUgaW4gcnVsZXMpIHtcbiAgICBvcHRpb25zLnNoZWV0LmFkZFJ1bGUobmFtZSwgcnVsZXNbbmFtZV0sIF9leHRlbmRzKHt9LCBvcHRpb25zLCB7XG4gICAgICBzZWxlY3RvcjogYWRkU2NvcGUobmFtZSwgcnVsZS5zZWxlY3RvcilcbiAgICB9KSk7XG4gIH1cblxuICBkZWxldGUgc3R5bGVbcHJvcEtleV07XG59XG5cbmZ1bmN0aW9uIGhhbmRsZVByZWZpeGVkR2xvYmFsUnVsZShydWxlKSB7XG4gIHZhciBvcHRpb25zID0gcnVsZS5vcHRpb25zLFxuICAgICAgc3R5bGUgPSBydWxlLnN0eWxlO1xuXG4gIGZvciAodmFyIHByb3AgaW4gc3R5bGUpIHtcbiAgICBpZiAocHJvcC5zdWJzdHIoMCwgcHJvcEtleS5sZW5ndGgpICE9PSBwcm9wS2V5KSBjb250aW51ZTtcblxuICAgIHZhciBzZWxlY3RvciA9IGFkZFNjb3BlKHByb3Auc3Vic3RyKHByb3BLZXkubGVuZ3RoKSwgcnVsZS5zZWxlY3Rvcik7XG4gICAgb3B0aW9ucy5zaGVldC5hZGRSdWxlKHNlbGVjdG9yLCBzdHlsZVtwcm9wXSwgX2V4dGVuZHMoe30sIG9wdGlvbnMsIHtcbiAgICAgIHNlbGVjdG9yOiBzZWxlY3RvclxuICAgIH0pKTtcbiAgICBkZWxldGUgc3R5bGVbcHJvcF07XG4gIH1cbn1cblxuLyoqXG4gKiBDb252ZXJ0IG5lc3RlZCBydWxlcyB0byBzZXBhcmF0ZSwgcmVtb3ZlIHRoZW0gZnJvbSBvcmlnaW5hbCBzdHlsZXMuXG4gKlxuICogQHBhcmFtIHtSdWxlfSBydWxlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5mdW5jdGlvbiBqc3NHbG9iYWwoKSB7XG4gIGZ1bmN0aW9uIG9uQ3JlYXRlUnVsZShuYW1lLCBzdHlsZXMsIG9wdGlvbnMpIHtcbiAgICBpZiAobmFtZSA9PT0gcHJvcEtleSkge1xuICAgICAgcmV0dXJuIG5ldyBHbG9iYWxDb250YWluZXJSdWxlKG5hbWUsIHN0eWxlcywgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgaWYgKG5hbWVbMF0gPT09ICdAJyAmJiBuYW1lLnN1YnN0cigwLCBwcmVmaXhLZXkubGVuZ3RoKSA9PT0gcHJlZml4S2V5KSB7XG4gICAgICByZXR1cm4gbmV3IEdsb2JhbFByZWZpeGVkUnVsZShuYW1lLCBzdHlsZXMsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIHZhciBwYXJlbnQgPSBvcHRpb25zLnBhcmVudDtcblxuXG4gICAgaWYgKHBhcmVudCkge1xuICAgICAgaWYgKHBhcmVudC50eXBlID09PSAnZ2xvYmFsJyB8fCBwYXJlbnQub3B0aW9ucy5wYXJlbnQudHlwZSA9PT0gJ2dsb2JhbCcpIHtcbiAgICAgICAgb3B0aW9ucy5nbG9iYWwgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmdsb2JhbCkgb3B0aW9ucy5zZWxlY3RvciA9IG5hbWU7XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uUHJvY2Vzc1J1bGUocnVsZSkge1xuICAgIGlmIChydWxlLnR5cGUgIT09ICdzdHlsZScpIHJldHVybjtcblxuICAgIGhhbmRsZU5lc3RlZEdsb2JhbENvbnRhaW5lclJ1bGUocnVsZSk7XG4gICAgaGFuZGxlUHJlZml4ZWRHbG9iYWxSdWxlKHJ1bGUpO1xuICB9XG5cbiAgcmV0dXJuIHsgb25DcmVhdGVSdWxlOiBvbkNyZWF0ZVJ1bGUsIG9uUHJvY2Vzc1J1bGU6IG9uUHJvY2Vzc1J1bGUgfTtcbn0iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGpzc05lc3RlZDtcblxudmFyIF93YXJuaW5nID0gcmVxdWlyZSgnd2FybmluZycpO1xuXG52YXIgX3dhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd2FybmluZyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBzZXBhcmF0b3JSZWdFeHAgPSAvXFxzKixcXHMqL2c7XG52YXIgcGFyZW50UmVnRXhwID0gLyYvZztcbnZhciByZWZSZWdFeHAgPSAvXFwkKFtcXHctXSspL2c7XG5cbi8qKlxuICogQ29udmVydCBuZXN0ZWQgcnVsZXMgdG8gc2VwYXJhdGUsIHJlbW92ZSB0aGVtIGZyb20gb3JpZ2luYWwgc3R5bGVzLlxuICpcbiAqIEBwYXJhbSB7UnVsZX0gcnVsZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuZnVuY3Rpb24ganNzTmVzdGVkKCkge1xuICAvLyBHZXQgYSBmdW5jdGlvbiB0byBiZSB1c2VkIGZvciAkcmVmIHJlcGxhY2VtZW50LlxuICBmdW5jdGlvbiBnZXRSZXBsYWNlUmVmKGNvbnRhaW5lcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAobWF0Y2gsIGtleSkge1xuICAgICAgdmFyIHJ1bGUgPSBjb250YWluZXIuZ2V0UnVsZShrZXkpO1xuICAgICAgaWYgKHJ1bGUpIHJldHVybiBydWxlLnNlbGVjdG9yO1xuICAgICAgKDAsIF93YXJuaW5nMi5kZWZhdWx0KShmYWxzZSwgJ1tKU1NdIENvdWxkIG5vdCBmaW5kIHRoZSByZWZlcmVuY2VkIHJ1bGUgJXMgaW4gJXMuJywga2V5LCBjb250YWluZXIub3B0aW9ucy5tZXRhIHx8IGNvbnRhaW5lcik7XG4gICAgICByZXR1cm4ga2V5O1xuICAgIH07XG4gIH1cblxuICB2YXIgaGFzQW5kID0gZnVuY3Rpb24gaGFzQW5kKHN0cikge1xuICAgIHJldHVybiBzdHIuaW5kZXhPZignJicpICE9PSAtMTtcbiAgfTtcblxuICBmdW5jdGlvbiByZXBsYWNlUGFyZW50UmVmcyhuZXN0ZWRQcm9wLCBwYXJlbnRQcm9wKSB7XG4gICAgdmFyIHBhcmVudFNlbGVjdG9ycyA9IHBhcmVudFByb3Auc3BsaXQoc2VwYXJhdG9yUmVnRXhwKTtcbiAgICB2YXIgbmVzdGVkU2VsZWN0b3JzID0gbmVzdGVkUHJvcC5zcGxpdChzZXBhcmF0b3JSZWdFeHApO1xuXG4gICAgdmFyIHJlc3VsdCA9ICcnO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJlbnRTZWxlY3RvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwYXJlbnQgPSBwYXJlbnRTZWxlY3RvcnNbaV07XG5cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbmVzdGVkU2VsZWN0b3JzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHZhciBuZXN0ZWQgPSBuZXN0ZWRTZWxlY3RvcnNbal07XG4gICAgICAgIGlmIChyZXN1bHQpIHJlc3VsdCArPSAnLCAnO1xuICAgICAgICAvLyBSZXBsYWNlIGFsbCAmIGJ5IHRoZSBwYXJlbnQgb3IgcHJlZml4ICYgd2l0aCB0aGUgcGFyZW50LlxuICAgICAgICByZXN1bHQgKz0gaGFzQW5kKG5lc3RlZCkgPyBuZXN0ZWQucmVwbGFjZShwYXJlbnRSZWdFeHAsIHBhcmVudCkgOiBwYXJlbnQgKyAnICcgKyBuZXN0ZWQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldE9wdGlvbnMocnVsZSwgY29udGFpbmVyLCBvcHRpb25zKSB7XG4gICAgLy8gT3B0aW9ucyBoYXMgYmVlbiBhbHJlYWR5IGNyZWF0ZWQsIG5vdyB3ZSBvbmx5IGluY3JlYXNlIGluZGV4LlxuICAgIGlmIChvcHRpb25zKSByZXR1cm4gX2V4dGVuZHMoe30sIG9wdGlvbnMsIHsgaW5kZXg6IG9wdGlvbnMuaW5kZXggKyAxIH0pO1xuXG4gICAgdmFyIG5lc3RpbmdMZXZlbCA9IHJ1bGUub3B0aW9ucy5uZXN0aW5nTGV2ZWw7XG5cbiAgICBuZXN0aW5nTGV2ZWwgPSBuZXN0aW5nTGV2ZWwgPT09IHVuZGVmaW5lZCA/IDEgOiBuZXN0aW5nTGV2ZWwgKyAxO1xuXG4gICAgcmV0dXJuIF9leHRlbmRzKHt9LCBydWxlLm9wdGlvbnMsIHtcbiAgICAgIG5lc3RpbmdMZXZlbDogbmVzdGluZ0xldmVsLFxuICAgICAgaW5kZXg6IGNvbnRhaW5lci5pbmRleE9mKHJ1bGUpICsgMVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gb25Qcm9jZXNzU3R5bGUoc3R5bGUsIHJ1bGUpIHtcbiAgICBpZiAocnVsZS50eXBlICE9PSAnc3R5bGUnKSByZXR1cm4gc3R5bGU7XG4gICAgdmFyIGNvbnRhaW5lciA9IHJ1bGUub3B0aW9ucy5wYXJlbnQ7XG4gICAgdmFyIG9wdGlvbnMgPSB2b2lkIDA7XG4gICAgdmFyIHJlcGxhY2VSZWYgPSB2b2lkIDA7XG4gICAgZm9yICh2YXIgcHJvcCBpbiBzdHlsZSkge1xuICAgICAgdmFyIGlzTmVzdGVkID0gaGFzQW5kKHByb3ApO1xuICAgICAgdmFyIGlzTmVzdGVkQ29uZGl0aW9uYWwgPSBwcm9wWzBdID09PSAnQCc7XG5cbiAgICAgIGlmICghaXNOZXN0ZWQgJiYgIWlzTmVzdGVkQ29uZGl0aW9uYWwpIGNvbnRpbnVlO1xuXG4gICAgICBvcHRpb25zID0gZ2V0T3B0aW9ucyhydWxlLCBjb250YWluZXIsIG9wdGlvbnMpO1xuXG4gICAgICBpZiAoaXNOZXN0ZWQpIHtcbiAgICAgICAgdmFyIHNlbGVjdG9yID0gcmVwbGFjZVBhcmVudFJlZnMocHJvcCwgcnVsZS5zZWxlY3RvclxuICAgICAgICAvLyBMYXppbHkgY3JlYXRlIHRoZSByZWYgcmVwbGFjZXIgZnVuY3Rpb24ganVzdCBvbmNlIGZvclxuICAgICAgICAvLyBhbGwgbmVzdGVkIHJ1bGVzIHdpdGhpbiB0aGUgc2hlZXQuXG4gICAgICAgICk7aWYgKCFyZXBsYWNlUmVmKSByZXBsYWNlUmVmID0gZ2V0UmVwbGFjZVJlZihjb250YWluZXJcbiAgICAgICAgLy8gUmVwbGFjZSBhbGwgJHJlZnMuXG4gICAgICAgICk7c2VsZWN0b3IgPSBzZWxlY3Rvci5yZXBsYWNlKHJlZlJlZ0V4cCwgcmVwbGFjZVJlZik7XG5cbiAgICAgICAgY29udGFpbmVyLmFkZFJ1bGUoc2VsZWN0b3IsIHN0eWxlW3Byb3BdLCBfZXh0ZW5kcyh7fSwgb3B0aW9ucywgeyBzZWxlY3Rvcjogc2VsZWN0b3IgfSkpO1xuICAgICAgfSBlbHNlIGlmIChpc05lc3RlZENvbmRpdGlvbmFsKSB7XG4gICAgICAgIGNvbnRhaW5lclxuICAgICAgICAvLyBQbGFjZSBjb25kaXRpb25hbCByaWdodCBhZnRlciB0aGUgcGFyZW50IHJ1bGUgdG8gZW5zdXJlIHJpZ2h0IG9yZGVyaW5nLlxuICAgICAgICAuYWRkUnVsZShwcm9wLCBudWxsLCBvcHRpb25zKS5hZGRSdWxlKHJ1bGUua2V5LCBzdHlsZVtwcm9wXSwgeyBzZWxlY3RvcjogcnVsZS5zZWxlY3RvciB9KTtcbiAgICAgIH1cblxuICAgICAgZGVsZXRlIHN0eWxlW3Byb3BdO1xuICAgIH1cblxuICAgIHJldHVybiBzdHlsZTtcbiAgfVxuXG4gIHJldHVybiB7IG9uUHJvY2Vzc1N0eWxlOiBvblByb2Nlc3NTdHlsZSB9O1xufSIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9qc3NUZW1wbGF0ZSA9IHJlcXVpcmUoJ2pzcy10ZW1wbGF0ZScpO1xuXG52YXIgX2pzc1RlbXBsYXRlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2pzc1RlbXBsYXRlKTtcblxudmFyIF9qc3NHbG9iYWwgPSByZXF1aXJlKCdqc3MtZ2xvYmFsJyk7XG5cbnZhciBfanNzR2xvYmFsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2pzc0dsb2JhbCk7XG5cbnZhciBfanNzRXh0ZW5kID0gcmVxdWlyZSgnanNzLWV4dGVuZCcpO1xuXG52YXIgX2pzc0V4dGVuZDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9qc3NFeHRlbmQpO1xuXG52YXIgX2pzc05lc3RlZCA9IHJlcXVpcmUoJ2pzcy1uZXN0ZWQnKTtcblxudmFyIF9qc3NOZXN0ZWQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfanNzTmVzdGVkKTtcblxudmFyIF9qc3NDb21wb3NlID0gcmVxdWlyZSgnanNzLWNvbXBvc2UnKTtcblxudmFyIF9qc3NDb21wb3NlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2pzc0NvbXBvc2UpO1xuXG52YXIgX2pzc0NhbWVsQ2FzZSA9IHJlcXVpcmUoJ2pzcy1jYW1lbC1jYXNlJyk7XG5cbnZhciBfanNzQ2FtZWxDYXNlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2pzc0NhbWVsQ2FzZSk7XG5cbnZhciBfanNzRGVmYXVsdFVuaXQgPSByZXF1aXJlKCdqc3MtZGVmYXVsdC11bml0Jyk7XG5cbnZhciBfanNzRGVmYXVsdFVuaXQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfanNzRGVmYXVsdFVuaXQpO1xuXG52YXIgX2pzc0V4cGFuZCA9IHJlcXVpcmUoJ2pzcy1leHBhbmQnKTtcblxudmFyIF9qc3NFeHBhbmQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfanNzRXhwYW5kKTtcblxudmFyIF9qc3NWZW5kb3JQcmVmaXhlciA9IHJlcXVpcmUoJ2pzcy12ZW5kb3ItcHJlZml4ZXInKTtcblxudmFyIF9qc3NWZW5kb3JQcmVmaXhlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9qc3NWZW5kb3JQcmVmaXhlcik7XG5cbnZhciBfanNzUHJvcHNTb3J0ID0gcmVxdWlyZSgnanNzLXByb3BzLXNvcnQnKTtcblxudmFyIF9qc3NQcm9wc1NvcnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfanNzUHJvcHNTb3J0KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gIHJldHVybiB7XG4gICAgcGx1Z2luczogWygwLCBfanNzVGVtcGxhdGUyLmRlZmF1bHQpKG9wdGlvbnMudGVtcGxhdGUpLCAoMCwgX2pzc0dsb2JhbDIuZGVmYXVsdCkob3B0aW9ucy5nbG9iYWwpLCAoMCwgX2pzc0V4dGVuZDIuZGVmYXVsdCkob3B0aW9ucy5leHRlbmQpLCAoMCwgX2pzc05lc3RlZDIuZGVmYXVsdCkob3B0aW9ucy5uZXN0ZWQpLCAoMCwgX2pzc0NvbXBvc2UyLmRlZmF1bHQpKG9wdGlvbnMuY29tcG9zZSksICgwLCBfanNzQ2FtZWxDYXNlMi5kZWZhdWx0KShvcHRpb25zLmNhbWVsQ2FzZSksICgwLCBfanNzRGVmYXVsdFVuaXQyLmRlZmF1bHQpKG9wdGlvbnMuZGVmYXVsdFVuaXQpLCAoMCwgX2pzc0V4cGFuZDIuZGVmYXVsdCkob3B0aW9ucy5leHBhbmQpLCAoMCwgX2pzc1ZlbmRvclByZWZpeGVyMi5kZWZhdWx0KShvcHRpb25zLnZlbmRvclByZWZpeGVyKSwgKDAsIF9qc3NQcm9wc1NvcnQyLmRlZmF1bHQpKG9wdGlvbnMucHJvcHNTb3J0KV1cbiAgfTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0c1snZGVmYXVsdCddID0ganNzUHJvcHNTb3J0O1xuLyoqXG4gKiBTb3J0IHByb3BzIGJ5IGxlbmd0aC5cbiAqL1xuZnVuY3Rpb24ganNzUHJvcHNTb3J0KCkge1xuICBmdW5jdGlvbiBzb3J0KHByb3AwLCBwcm9wMSkge1xuICAgIHJldHVybiBwcm9wMC5sZW5ndGggLSBwcm9wMS5sZW5ndGg7XG4gIH1cblxuICBmdW5jdGlvbiBvblByb2Nlc3NTdHlsZShzdHlsZSwgcnVsZSkge1xuICAgIGlmIChydWxlLnR5cGUgIT09ICdzdHlsZScpIHJldHVybiBzdHlsZTtcblxuICAgIHZhciBuZXdTdHlsZSA9IHt9O1xuICAgIHZhciBwcm9wcyA9IE9iamVjdC5rZXlzKHN0eWxlKS5zb3J0KHNvcnQpO1xuICAgIGZvciAodmFyIHByb3AgaW4gcHJvcHMpIHtcbiAgICAgIG5ld1N0eWxlW3Byb3BzW3Byb3BdXSA9IHN0eWxlW3Byb3BzW3Byb3BdXTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld1N0eWxlO1xuICB9XG5cbiAgcmV0dXJuIHsgb25Qcm9jZXNzU3R5bGU6IG9uUHJvY2Vzc1N0eWxlIH07XG59IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3BhcnNlID0gcmVxdWlyZSgnLi9wYXJzZScpO1xuXG52YXIgX3BhcnNlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3BhcnNlKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgb25Qcm9jZXNzUnVsZSA9IGZ1bmN0aW9uIG9uUHJvY2Vzc1J1bGUocnVsZSkge1xuICBpZiAodHlwZW9mIHJ1bGUuc3R5bGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcnVsZS5zdHlsZSA9ICgwLCBfcGFyc2UyWydkZWZhdWx0J10pKHJ1bGUuc3R5bGUpO1xuICB9XG59O1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB7IG9uUHJvY2Vzc1J1bGU6IG9uUHJvY2Vzc1J1bGUgfTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3dhcm5pbmcgPSByZXF1aXJlKCd3YXJuaW5nJyk7XG5cbnZhciBfd2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93YXJuaW5nKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgc2VtaVdpdGhObCA9IC87XFxuLztcblxuLyoqXG4gKiBOYWl2ZSBDU1MgcGFyc2VyLlxuICogLSBTdXBwb3J0cyBvbmx5IHJ1bGUgYm9keSAobm8gc2VsZWN0b3JzKVxuICogLSBSZXF1aXJlcyBzZW1pY29sb24gYW5kIG5ldyBsaW5lIGFmdGVyIHRoZSB2YWx1ZSAoZXhjZXB0IG9mIGxhc3QgbGluZSlcbiAqIC0gTm8gbmVzdGVkIHJ1bGVzIHN1cHBvcnRcbiAqL1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBmdW5jdGlvbiAoY3NzVGV4dCkge1xuICB2YXIgc3R5bGUgPSB7fTtcbiAgdmFyIHNwbGl0ID0gY3NzVGV4dC5zcGxpdChzZW1pV2l0aE5sKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzcGxpdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZWNsID0gKHNwbGl0W2ldIHx8ICcnKS50cmltKCk7XG5cbiAgICBpZiAoIWRlY2wpIGNvbnRpbnVlO1xuICAgIHZhciBjb2xvbkluZGV4ID0gZGVjbC5pbmRleE9mKCc6Jyk7XG4gICAgaWYgKGNvbG9uSW5kZXggPT09IC0xKSB7XG4gICAgICAoMCwgX3dhcm5pbmcyWydkZWZhdWx0J10pKGZhbHNlLCAnTWFsZm9ybWVkIENTUyBzdHJpbmcgXCIlc1wiJywgZGVjbCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFyIHByb3AgPSBkZWNsLnN1YnN0cigwLCBjb2xvbkluZGV4KS50cmltKCk7XG4gICAgdmFyIHZhbHVlID0gZGVjbC5zdWJzdHIoY29sb25JbmRleCArIDEpLnRyaW0oKTtcbiAgICBzdHlsZVtwcm9wXSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiBzdHlsZTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0c1snZGVmYXVsdCddID0ganNzVmVuZG9yUHJlZml4ZXI7XG5cbnZhciBfY3NzVmVuZG9yID0gcmVxdWlyZSgnY3NzLXZlbmRvcicpO1xuXG52YXIgdmVuZG9yID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX2Nzc1ZlbmRvcik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmpbJ2RlZmF1bHQnXSA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbi8qKlxuICogQWRkIHZlbmRvciBwcmVmaXggdG8gYSBwcm9wZXJ0eSBuYW1lIHdoZW4gbmVlZGVkLlxuICpcbiAqIEBwYXJhbSB7UnVsZX0gcnVsZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuZnVuY3Rpb24ganNzVmVuZG9yUHJlZml4ZXIoKSB7XG4gIGZ1bmN0aW9uIG9uUHJvY2Vzc1J1bGUocnVsZSkge1xuICAgIGlmIChydWxlLnR5cGUgPT09ICdrZXlmcmFtZXMnKSB7XG4gICAgICBydWxlLmtleSA9ICdAJyArIHZlbmRvci5wcmVmaXguY3NzICsgcnVsZS5rZXkuc3Vic3RyKDEpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uUHJvY2Vzc1N0eWxlKHN0eWxlLCBydWxlKSB7XG4gICAgaWYgKHJ1bGUudHlwZSAhPT0gJ3N0eWxlJykgcmV0dXJuIHN0eWxlO1xuXG4gICAgZm9yICh2YXIgcHJvcCBpbiBzdHlsZSkge1xuICAgICAgdmFyIHZhbHVlID0gc3R5bGVbcHJvcF07XG5cbiAgICAgIHZhciBjaGFuZ2VQcm9wID0gZmFsc2U7XG4gICAgICB2YXIgc3VwcG9ydGVkUHJvcCA9IHZlbmRvci5zdXBwb3J0ZWRQcm9wZXJ0eShwcm9wKTtcbiAgICAgIGlmIChzdXBwb3J0ZWRQcm9wICYmIHN1cHBvcnRlZFByb3AgIT09IHByb3ApIGNoYW5nZVByb3AgPSB0cnVlO1xuXG4gICAgICB2YXIgY2hhbmdlVmFsdWUgPSBmYWxzZTtcbiAgICAgIHZhciBzdXBwb3J0ZWRWYWx1ZSA9IHZlbmRvci5zdXBwb3J0ZWRWYWx1ZShzdXBwb3J0ZWRQcm9wLCB2YWx1ZSk7XG4gICAgICBpZiAoc3VwcG9ydGVkVmFsdWUgJiYgc3VwcG9ydGVkVmFsdWUgIT09IHZhbHVlKSBjaGFuZ2VWYWx1ZSA9IHRydWU7XG5cbiAgICAgIGlmIChjaGFuZ2VQcm9wIHx8IGNoYW5nZVZhbHVlKSB7XG4gICAgICAgIGlmIChjaGFuZ2VQcm9wKSBkZWxldGUgc3R5bGVbcHJvcF07XG4gICAgICAgIHN0eWxlW3N1cHBvcnRlZFByb3AgfHwgcHJvcF0gPSBzdXBwb3J0ZWRWYWx1ZSB8fCB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc3R5bGU7XG4gIH1cblxuICBmdW5jdGlvbiBvbkNoYW5nZVZhbHVlKHZhbHVlLCBwcm9wKSB7XG4gICAgcmV0dXJuIHZlbmRvci5zdXBwb3J0ZWRWYWx1ZShwcm9wLCB2YWx1ZSk7XG4gIH1cblxuICByZXR1cm4geyBvblByb2Nlc3NSdWxlOiBvblByb2Nlc3NSdWxlLCBvblByb2Nlc3NTdHlsZTogb25Qcm9jZXNzU3R5bGUsIG9uQ2hhbmdlVmFsdWU6IG9uQ2hhbmdlVmFsdWUgfTtcbn0iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9pc0luQnJvd3NlciA9IHJlcXVpcmUoJ2lzLWluLWJyb3dzZXInKTtcblxudmFyIF9pc0luQnJvd3NlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pc0luQnJvd3Nlcik7XG5cbnZhciBfU3R5bGVTaGVldCA9IHJlcXVpcmUoJy4vU3R5bGVTaGVldCcpO1xuXG52YXIgX1N0eWxlU2hlZXQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU3R5bGVTaGVldCk7XG5cbnZhciBfUGx1Z2luc1JlZ2lzdHJ5ID0gcmVxdWlyZSgnLi9QbHVnaW5zUmVnaXN0cnknKTtcblxudmFyIF9QbHVnaW5zUmVnaXN0cnkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUGx1Z2luc1JlZ2lzdHJ5KTtcblxudmFyIF9ydWxlcyA9IHJlcXVpcmUoJy4vcGx1Z2lucy9ydWxlcycpO1xuXG52YXIgX3J1bGVzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3J1bGVzKTtcblxudmFyIF9vYnNlcnZhYmxlcyA9IHJlcXVpcmUoJy4vcGx1Z2lucy9vYnNlcnZhYmxlcycpO1xuXG52YXIgX29ic2VydmFibGVzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX29ic2VydmFibGVzKTtcblxudmFyIF9mdW5jdGlvbnMgPSByZXF1aXJlKCcuL3BsdWdpbnMvZnVuY3Rpb25zJyk7XG5cbnZhciBfZnVuY3Rpb25zMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Z1bmN0aW9ucyk7XG5cbnZhciBfc2hlZXRzID0gcmVxdWlyZSgnLi9zaGVldHMnKTtcblxudmFyIF9zaGVldHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc2hlZXRzKTtcblxudmFyIF9TdHlsZVJ1bGUgPSByZXF1aXJlKCcuL3J1bGVzL1N0eWxlUnVsZScpO1xuXG52YXIgX1N0eWxlUnVsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9TdHlsZVJ1bGUpO1xuXG52YXIgX2NyZWF0ZUdlbmVyYXRlQ2xhc3NOYW1lID0gcmVxdWlyZSgnLi91dGlscy9jcmVhdGVHZW5lcmF0ZUNsYXNzTmFtZScpO1xuXG52YXIgX2NyZWF0ZUdlbmVyYXRlQ2xhc3NOYW1lMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZUdlbmVyYXRlQ2xhc3NOYW1lKTtcblxudmFyIF9jcmVhdGVSdWxlMiA9IHJlcXVpcmUoJy4vdXRpbHMvY3JlYXRlUnVsZScpO1xuXG52YXIgX2NyZWF0ZVJ1bGUzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlUnVsZTIpO1xuXG52YXIgX0RvbVJlbmRlcmVyID0gcmVxdWlyZSgnLi9yZW5kZXJlcnMvRG9tUmVuZGVyZXInKTtcblxudmFyIF9Eb21SZW5kZXJlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Eb21SZW5kZXJlcik7XG5cbnZhciBfVmlydHVhbFJlbmRlcmVyID0gcmVxdWlyZSgnLi9yZW5kZXJlcnMvVmlydHVhbFJlbmRlcmVyJyk7XG5cbnZhciBfVmlydHVhbFJlbmRlcmVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1ZpcnR1YWxSZW5kZXJlcik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIGRlZmF1bHRQbHVnaW5zID0gX3J1bGVzMlsnZGVmYXVsdCddLmNvbmNhdChbX29ic2VydmFibGVzMlsnZGVmYXVsdCddLCBfZnVuY3Rpb25zMlsnZGVmYXVsdCddXSk7XG5cbnZhciBpbnN0YW5jZUNvdW50ZXIgPSAwO1xuXG52YXIgSnNzID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBKc3Mob3B0aW9ucykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBKc3MpO1xuXG4gICAgdGhpcy5pZCA9IGluc3RhbmNlQ291bnRlcisrO1xuICAgIHRoaXMudmVyc2lvbiA9IFwiOS41LjFcIjtcbiAgICB0aGlzLnBsdWdpbnMgPSBuZXcgX1BsdWdpbnNSZWdpc3RyeTJbJ2RlZmF1bHQnXSgpO1xuICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgIGNyZWF0ZUdlbmVyYXRlQ2xhc3NOYW1lOiBfY3JlYXRlR2VuZXJhdGVDbGFzc05hbWUyWydkZWZhdWx0J10sXG4gICAgICBSZW5kZXJlcjogX2lzSW5Ccm93c2VyMlsnZGVmYXVsdCddID8gX0RvbVJlbmRlcmVyMlsnZGVmYXVsdCddIDogX1ZpcnR1YWxSZW5kZXJlcjJbJ2RlZmF1bHQnXSxcbiAgICAgIHBsdWdpbnM6IFtdXG4gICAgfTtcbiAgICB0aGlzLmdlbmVyYXRlQ2xhc3NOYW1lID0gKDAsIF9jcmVhdGVHZW5lcmF0ZUNsYXNzTmFtZTJbJ2RlZmF1bHQnXSkoKTtcblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItc3ByZWFkXG4gICAgdGhpcy51c2UuYXBwbHkodGhpcywgZGVmYXVsdFBsdWdpbnMpO1xuICAgIHRoaXMuc2V0dXAob3B0aW9ucyk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoSnNzLCBbe1xuICAgIGtleTogJ3NldHVwJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0dXAoKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICAgIGlmIChvcHRpb25zLmNyZWF0ZUdlbmVyYXRlQ2xhc3NOYW1lKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5jcmVhdGVHZW5lcmF0ZUNsYXNzTmFtZSA9IG9wdGlvbnMuY3JlYXRlR2VuZXJhdGVDbGFzc05hbWU7XG4gICAgICAgIC8vICRGbG93Rml4TWVcbiAgICAgICAgdGhpcy5nZW5lcmF0ZUNsYXNzTmFtZSA9IG9wdGlvbnMuY3JlYXRlR2VuZXJhdGVDbGFzc05hbWUoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMuaW5zZXJ0aW9uUG9pbnQgIT0gbnVsbCkgdGhpcy5vcHRpb25zLmluc2VydGlvblBvaW50ID0gb3B0aW9ucy5pbnNlcnRpb25Qb2ludDtcbiAgICAgIGlmIChvcHRpb25zLnZpcnR1YWwgfHwgb3B0aW9ucy5SZW5kZXJlcikge1xuICAgICAgICB0aGlzLm9wdGlvbnMuUmVuZGVyZXIgPSBvcHRpb25zLlJlbmRlcmVyIHx8IChvcHRpb25zLnZpcnR1YWwgPyBfVmlydHVhbFJlbmRlcmVyMlsnZGVmYXVsdCddIDogX0RvbVJlbmRlcmVyMlsnZGVmYXVsdCddKTtcbiAgICAgIH1cblxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1zcHJlYWRcbiAgICAgIGlmIChvcHRpb25zLnBsdWdpbnMpIHRoaXMudXNlLmFwcGx5KHRoaXMsIG9wdGlvbnMucGx1Z2lucyk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIFN0eWxlIFNoZWV0LlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdjcmVhdGVTdHlsZVNoZWV0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlU3R5bGVTaGVldChzdHlsZXMpIHtcbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgICAgdmFyIGluZGV4ID0gb3B0aW9ucy5pbmRleDtcbiAgICAgIGlmICh0eXBlb2YgaW5kZXggIT09ICdudW1iZXInKSB7XG4gICAgICAgIGluZGV4ID0gX3NoZWV0czJbJ2RlZmF1bHQnXS5pbmRleCA9PT0gMCA/IDAgOiBfc2hlZXRzMlsnZGVmYXVsdCddLmluZGV4ICsgMTtcbiAgICAgIH1cbiAgICAgIHZhciBzaGVldCA9IG5ldyBfU3R5bGVTaGVldDJbJ2RlZmF1bHQnXShzdHlsZXMsIF9leHRlbmRzKHt9LCBvcHRpb25zLCB7XG4gICAgICAgIGpzczogdGhpcyxcbiAgICAgICAgZ2VuZXJhdGVDbGFzc05hbWU6IG9wdGlvbnMuZ2VuZXJhdGVDbGFzc05hbWUgfHwgdGhpcy5nZW5lcmF0ZUNsYXNzTmFtZSxcbiAgICAgICAgaW5zZXJ0aW9uUG9pbnQ6IHRoaXMub3B0aW9ucy5pbnNlcnRpb25Qb2ludCxcbiAgICAgICAgUmVuZGVyZXI6IHRoaXMub3B0aW9ucy5SZW5kZXJlcixcbiAgICAgICAgaW5kZXg6IGluZGV4XG4gICAgICB9KSk7XG4gICAgICB0aGlzLnBsdWdpbnMub25Qcm9jZXNzU2hlZXQoc2hlZXQpO1xuXG4gICAgICByZXR1cm4gc2hlZXQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGV0YWNoIHRoZSBTdHlsZSBTaGVldCBhbmQgcmVtb3ZlIGl0IGZyb20gdGhlIHJlZ2lzdHJ5LlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdyZW1vdmVTdHlsZVNoZWV0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlU3R5bGVTaGVldChzaGVldCkge1xuICAgICAgc2hlZXQuZGV0YWNoKCk7XG4gICAgICBfc2hlZXRzMlsnZGVmYXVsdCddLnJlbW92ZShzaGVldCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBydWxlIHdpdGhvdXQgYSBTdHlsZSBTaGVldC5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnY3JlYXRlUnVsZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZVJ1bGUobmFtZSkge1xuICAgICAgdmFyIHN0eWxlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcblxuICAgICAgLy8gRW5hYmxlIHJ1bGUgd2l0aG91dCBuYW1lIGZvciBpbmxpbmUgc3R5bGVzLlxuICAgICAgaWYgKCh0eXBlb2YgbmFtZSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YobmFtZSkpID09PSAnb2JqZWN0Jykge1xuICAgICAgICBvcHRpb25zID0gc3R5bGU7XG4gICAgICAgIHN0eWxlID0gbmFtZTtcbiAgICAgICAgbmFtZSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgLy8gQ2FzdCBmcm9tIFJ1bGVGYWN0b3J5T3B0aW9ucyB0byBSdWxlT3B0aW9uc1xuICAgICAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNDEzMjg3MjgvZm9yY2UtY2FzdGluZy1pbi1mbG93XG4gICAgICB2YXIgcnVsZU9wdGlvbnMgPSBvcHRpb25zO1xuXG4gICAgICBydWxlT3B0aW9ucy5qc3MgPSB0aGlzO1xuICAgICAgcnVsZU9wdGlvbnMuUmVuZGVyZXIgPSB0aGlzLm9wdGlvbnMuUmVuZGVyZXI7XG4gICAgICBpZiAoIXJ1bGVPcHRpb25zLmdlbmVyYXRlQ2xhc3NOYW1lKSBydWxlT3B0aW9ucy5nZW5lcmF0ZUNsYXNzTmFtZSA9IHRoaXMuZ2VuZXJhdGVDbGFzc05hbWU7XG4gICAgICBpZiAoIXJ1bGVPcHRpb25zLmNsYXNzZXMpIHJ1bGVPcHRpb25zLmNsYXNzZXMgPSB7fTtcbiAgICAgIHZhciBydWxlID0gKDAsIF9jcmVhdGVSdWxlM1snZGVmYXVsdCddKShuYW1lLCBzdHlsZSwgcnVsZU9wdGlvbnMpO1xuXG4gICAgICBpZiAoIXJ1bGVPcHRpb25zLnNlbGVjdG9yICYmIHJ1bGUgaW5zdGFuY2VvZiBfU3R5bGVSdWxlMlsnZGVmYXVsdCddKSB7XG4gICAgICAgIHJ1bGUuc2VsZWN0b3IgPSAnLicgKyBydWxlT3B0aW9ucy5nZW5lcmF0ZUNsYXNzTmFtZShydWxlKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wbHVnaW5zLm9uUHJvY2Vzc1J1bGUocnVsZSk7XG5cbiAgICAgIHJldHVybiBydWxlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIHBsdWdpbi4gUGFzc2VkIGZ1bmN0aW9uIHdpbGwgYmUgaW52b2tlZCB3aXRoIGEgcnVsZSBpbnN0YW5jZS5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAndXNlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXNlKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHBsdWdpbnMgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgcGx1Z2luc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cblxuICAgICAgcGx1Z2lucy5mb3JFYWNoKGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgICAgICAgLy8gQXZvaWRzIGFwcGx5aW5nIHNhbWUgcGx1Z2luIHR3aWNlLCBhdCBsZWFzdCBiYXNlZCBvbiByZWYuXG4gICAgICAgIGlmIChfdGhpcy5vcHRpb25zLnBsdWdpbnMuaW5kZXhPZihwbHVnaW4pID09PSAtMSkge1xuICAgICAgICAgIF90aGlzLm9wdGlvbnMucGx1Z2lucy5wdXNoKHBsdWdpbik7XG4gICAgICAgICAgX3RoaXMucGx1Z2lucy51c2UocGx1Z2luKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBKc3M7XG59KCk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IEpzczsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfd2FybmluZyA9IHJlcXVpcmUoJ3dhcm5pbmcnKTtcblxudmFyIF93YXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dhcm5pbmcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBQbHVnaW5zUmVnaXN0cnkgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFBsdWdpbnNSZWdpc3RyeSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUGx1Z2luc1JlZ2lzdHJ5KTtcblxuICAgIHRoaXMuaG9va3MgPSB7XG4gICAgICBvbkNyZWF0ZVJ1bGU6IFtdLFxuICAgICAgb25Qcm9jZXNzUnVsZTogW10sXG4gICAgICBvblByb2Nlc3NTdHlsZTogW10sXG4gICAgICBvblByb2Nlc3NTaGVldDogW10sXG4gICAgICBvbkNoYW5nZVZhbHVlOiBbXSxcbiAgICAgIG9uVXBkYXRlOiBbXVxuXG4gICAgICAvKipcbiAgICAgICAqIENhbGwgYG9uQ3JlYXRlUnVsZWAgaG9va3MgYW5kIHJldHVybiBhbiBvYmplY3QgaWYgcmV0dXJuZWQgYnkgYSBob29rLlxuICAgICAgICovXG4gICAgfTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhQbHVnaW5zUmVnaXN0cnksIFt7XG4gICAga2V5OiAnb25DcmVhdGVSdWxlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25DcmVhdGVSdWxlKG5hbWUsIGRlY2wsIG9wdGlvbnMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ob29rcy5vbkNyZWF0ZVJ1bGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHJ1bGUgPSB0aGlzLmhvb2tzLm9uQ3JlYXRlUnVsZVtpXShuYW1lLCBkZWNsLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKHJ1bGUpIHJldHVybiBydWxlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbCBgb25Qcm9jZXNzUnVsZWAgaG9va3MuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ29uUHJvY2Vzc1J1bGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvblByb2Nlc3NSdWxlKHJ1bGUpIHtcbiAgICAgIGlmIChydWxlLmlzUHJvY2Vzc2VkKSByZXR1cm47XG4gICAgICB2YXIgc2hlZXQgPSBydWxlLm9wdGlvbnMuc2hlZXQ7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ob29rcy5vblByb2Nlc3NSdWxlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuaG9va3Mub25Qcm9jZXNzUnVsZVtpXShydWxlLCBzaGVldCk7XG4gICAgICB9XG5cbiAgICAgIC8vICRGbG93Rml4TWVcbiAgICAgIGlmIChydWxlLnN0eWxlKSB0aGlzLm9uUHJvY2Vzc1N0eWxlKHJ1bGUuc3R5bGUsIHJ1bGUsIHNoZWV0KTtcblxuICAgICAgcnVsZS5pc1Byb2Nlc3NlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbCBgb25Qcm9jZXNzU3R5bGVgIGhvb2tzLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdvblByb2Nlc3NTdHlsZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uUHJvY2Vzc1N0eWxlKHN0eWxlLCBydWxlLCBzaGVldCkge1xuICAgICAgdmFyIG5leHRTdHlsZSA9IHN0eWxlO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaG9va3Mub25Qcm9jZXNzU3R5bGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbmV4dFN0eWxlID0gdGhpcy5ob29rcy5vblByb2Nlc3NTdHlsZVtpXShuZXh0U3R5bGUsIHJ1bGUsIHNoZWV0KTtcbiAgICAgICAgLy8gJEZsb3dGaXhNZVxuICAgICAgICBydWxlLnN0eWxlID0gbmV4dFN0eWxlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGwgYG9uUHJvY2Vzc1NoZWV0YCBob29rcy5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnb25Qcm9jZXNzU2hlZXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvblByb2Nlc3NTaGVldChzaGVldCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmhvb2tzLm9uUHJvY2Vzc1NoZWV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuaG9va3Mub25Qcm9jZXNzU2hlZXRbaV0oc2hlZXQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGwgYG9uVXBkYXRlYCBob29rcy5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnb25VcGRhdGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvblVwZGF0ZShkYXRhLCBydWxlLCBzaGVldCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmhvb2tzLm9uVXBkYXRlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuaG9va3Mub25VcGRhdGVbaV0oZGF0YSwgcnVsZSwgc2hlZXQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGwgYG9uQ2hhbmdlVmFsdWVgIGhvb2tzLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdvbkNoYW5nZVZhbHVlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25DaGFuZ2VWYWx1ZSh2YWx1ZSwgcHJvcCwgcnVsZSkge1xuICAgICAgdmFyIHByb2Nlc3NlZFZhbHVlID0gdmFsdWU7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaG9va3Mub25DaGFuZ2VWYWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBwcm9jZXNzZWRWYWx1ZSA9IHRoaXMuaG9va3Mub25DaGFuZ2VWYWx1ZVtpXShwcm9jZXNzZWRWYWx1ZSwgcHJvcCwgcnVsZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcHJvY2Vzc2VkVmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgYSBwbHVnaW4uXG4gICAgICogSWYgZnVuY3Rpb24gaXMgcGFzc2VkLCBpdCBpcyBhIHNob3J0Y3V0IGZvciBge29uUHJvY2Vzc1J1bGV9YC5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAndXNlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXNlKHBsdWdpbikge1xuICAgICAgZm9yICh2YXIgbmFtZSBpbiBwbHVnaW4pIHtcbiAgICAgICAgaWYgKHRoaXMuaG9va3NbbmFtZV0pIHRoaXMuaG9va3NbbmFtZV0ucHVzaChwbHVnaW5bbmFtZV0pO2Vsc2UgKDAsIF93YXJuaW5nMlsnZGVmYXVsdCddKShmYWxzZSwgJ1tKU1NdIFVua25vd24gaG9vayBcIiVzXCIuJywgbmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFBsdWdpbnNSZWdpc3RyeTtcbn0oKTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gUGx1Z2luc1JlZ2lzdHJ5OyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9jcmVhdGVSdWxlID0gcmVxdWlyZSgnLi91dGlscy9jcmVhdGVSdWxlJyk7XG5cbnZhciBfY3JlYXRlUnVsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVSdWxlKTtcblxudmFyIF9saW5rUnVsZSA9IHJlcXVpcmUoJy4vdXRpbHMvbGlua1J1bGUnKTtcblxudmFyIF9saW5rUnVsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9saW5rUnVsZSk7XG5cbnZhciBfU3R5bGVSdWxlID0gcmVxdWlyZSgnLi9ydWxlcy9TdHlsZVJ1bGUnKTtcblxudmFyIF9TdHlsZVJ1bGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU3R5bGVSdWxlKTtcblxudmFyIF9lc2NhcGUgPSByZXF1aXJlKCcuL3V0aWxzL2VzY2FwZScpO1xuXG52YXIgX2VzY2FwZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9lc2NhcGUpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbi8qKlxuICogQ29udGFpbnMgcnVsZXMgb2JqZWN0cyBhbmQgYWxsb3dzIGFkZGluZy9yZW1vdmluZyBldGMuXG4gKiBJcyB1c2VkIGZvciBlLmcuIGJ5IGBTdHlsZVNoZWV0YCBvciBgQ29uZGl0aW9uYWxSdWxlYC5cbiAqL1xudmFyIFJ1bGVMaXN0ID0gZnVuY3Rpb24gKCkge1xuXG4gIC8vIE9yaWdpbmFsIHN0eWxlcyBvYmplY3QuXG4gIGZ1bmN0aW9uIFJ1bGVMaXN0KG9wdGlvbnMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUnVsZUxpc3QpO1xuXG4gICAgdGhpcy5tYXAgPSB7fTtcbiAgICB0aGlzLnJhdyA9IHt9O1xuICAgIHRoaXMuaW5kZXggPSBbXTtcblxuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5jbGFzc2VzID0gb3B0aW9ucy5jbGFzc2VzO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbmQgcmVnaXN0ZXIgcnVsZS5cbiAgICpcbiAgICogV2lsbCBub3QgcmVuZGVyIGFmdGVyIFN0eWxlIFNoZWV0IHdhcyByZW5kZXJlZCB0aGUgZmlyc3QgdGltZS5cbiAgICovXG5cblxuICAvLyBVc2VkIHRvIGVuc3VyZSBjb3JyZWN0IHJ1bGVzIG9yZGVyLlxuXG4gIC8vIFJ1bGVzIHJlZ2lzdHJ5IGZvciBhY2Nlc3MgYnkgLmdldCgpIG1ldGhvZC5cbiAgLy8gSXQgY29udGFpbnMgdGhlIHNhbWUgcnVsZSByZWdpc3RlcmVkIGJ5IG5hbWUgYW5kIGJ5IHNlbGVjdG9yLlxuXG5cbiAgX2NyZWF0ZUNsYXNzKFJ1bGVMaXN0LCBbe1xuICAgIGtleTogJ2FkZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZChuYW1lLCBkZWNsLCBvcHRpb25zKSB7XG4gICAgICB2YXIgX29wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgICAgcGFyZW50ID0gX29wdGlvbnMucGFyZW50LFxuICAgICAgICAgIHNoZWV0ID0gX29wdGlvbnMuc2hlZXQsXG4gICAgICAgICAganNzID0gX29wdGlvbnMuanNzLFxuICAgICAgICAgIFJlbmRlcmVyID0gX29wdGlvbnMuUmVuZGVyZXIsXG4gICAgICAgICAgZ2VuZXJhdGVDbGFzc05hbWUgPSBfb3B0aW9ucy5nZW5lcmF0ZUNsYXNzTmFtZTtcblxuXG4gICAgICBvcHRpb25zID0gX2V4dGVuZHMoe1xuICAgICAgICBjbGFzc2VzOiB0aGlzLmNsYXNzZXMsXG4gICAgICAgIHBhcmVudDogcGFyZW50LFxuICAgICAgICBzaGVldDogc2hlZXQsXG4gICAgICAgIGpzczoganNzLFxuICAgICAgICBSZW5kZXJlcjogUmVuZGVyZXIsXG4gICAgICAgIGdlbmVyYXRlQ2xhc3NOYW1lOiBnZW5lcmF0ZUNsYXNzTmFtZVxuICAgICAgfSwgb3B0aW9ucyk7XG5cbiAgICAgIGlmICghb3B0aW9ucy5zZWxlY3RvciAmJiB0aGlzLmNsYXNzZXNbbmFtZV0pIHtcbiAgICAgICAgb3B0aW9ucy5zZWxlY3RvciA9ICcuJyArICgwLCBfZXNjYXBlMlsnZGVmYXVsdCddKSh0aGlzLmNsYXNzZXNbbmFtZV0pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnJhd1tuYW1lXSA9IGRlY2w7XG5cbiAgICAgIHZhciBydWxlID0gKDAsIF9jcmVhdGVSdWxlMlsnZGVmYXVsdCddKShuYW1lLCBkZWNsLCBvcHRpb25zKTtcblxuICAgICAgdmFyIGNsYXNzTmFtZSA9IHZvaWQgMDtcblxuICAgICAgaWYgKCFvcHRpb25zLnNlbGVjdG9yICYmIHJ1bGUgaW5zdGFuY2VvZiBfU3R5bGVSdWxlMlsnZGVmYXVsdCddKSB7XG4gICAgICAgIGNsYXNzTmFtZSA9IGdlbmVyYXRlQ2xhc3NOYW1lKHJ1bGUsIHNoZWV0KTtcbiAgICAgICAgcnVsZS5zZWxlY3RvciA9ICcuJyArICgwLCBfZXNjYXBlMlsnZGVmYXVsdCddKShjbGFzc05hbWUpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnJlZ2lzdGVyKHJ1bGUsIGNsYXNzTmFtZSk7XG5cbiAgICAgIHZhciBpbmRleCA9IG9wdGlvbnMuaW5kZXggPT09IHVuZGVmaW5lZCA/IHRoaXMuaW5kZXgubGVuZ3RoIDogb3B0aW9ucy5pbmRleDtcbiAgICAgIHRoaXMuaW5kZXguc3BsaWNlKGluZGV4LCAwLCBydWxlKTtcblxuICAgICAgcmV0dXJuIHJ1bGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGEgcnVsZS5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZ2V0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0KG5hbWUpIHtcbiAgICAgIHJldHVybiB0aGlzLm1hcFtuYW1lXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWxldGUgYSBydWxlLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdyZW1vdmUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmUocnVsZSkge1xuICAgICAgdGhpcy51bnJlZ2lzdGVyKHJ1bGUpO1xuICAgICAgdGhpcy5pbmRleC5zcGxpY2UodGhpcy5pbmRleE9mKHJ1bGUpLCAxKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgaW5kZXggb2YgYSBydWxlLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdpbmRleE9mJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5kZXhPZihydWxlKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbmRleC5pbmRleE9mKHJ1bGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJ1biBgb25Qcm9jZXNzUnVsZSgpYCBwbHVnaW5zIG9uIGV2ZXJ5IHJ1bGUuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3Byb2Nlc3MnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9jZXNzKCkge1xuICAgICAgdmFyIHBsdWdpbnMgPSB0aGlzLm9wdGlvbnMuanNzLnBsdWdpbnM7XG4gICAgICAvLyBXZSBuZWVkIHRvIGNsb25lIGFycmF5IGJlY2F1c2UgaWYgd2UgbW9kaWZ5IHRoZSBpbmRleCBzb21ld2hlcmUgZWxzZSBkdXJpbmcgYSBsb29wXG4gICAgICAvLyB3ZSBlbmQgdXAgd2l0aCB2ZXJ5IGhhcmQtdG8tdHJhY2stZG93biBzaWRlIGVmZmVjdHMuXG5cbiAgICAgIHRoaXMuaW5kZXguc2xpY2UoMCkuZm9yRWFjaChwbHVnaW5zLm9uUHJvY2Vzc1J1bGUsIHBsdWdpbnMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIGEgcnVsZSBpbiBgLm1hcGAgYW5kIGAuY2xhc3Nlc2AgbWFwcy5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAncmVnaXN0ZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWdpc3RlcihydWxlLCBjbGFzc05hbWUpIHtcbiAgICAgIHRoaXMubWFwW3J1bGUua2V5XSA9IHJ1bGU7XG4gICAgICBpZiAocnVsZSBpbnN0YW5jZW9mIF9TdHlsZVJ1bGUyWydkZWZhdWx0J10pIHtcbiAgICAgICAgdGhpcy5tYXBbcnVsZS5zZWxlY3Rvcl0gPSBydWxlO1xuICAgICAgICBpZiAoY2xhc3NOYW1lKSB0aGlzLmNsYXNzZXNbcnVsZS5rZXldID0gY2xhc3NOYW1lO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVucmVnaXN0ZXIgYSBydWxlLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICd1bnJlZ2lzdGVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW5yZWdpc3RlcihydWxlKSB7XG4gICAgICBkZWxldGUgdGhpcy5tYXBbcnVsZS5rZXldO1xuICAgICAgaWYgKHJ1bGUgaW5zdGFuY2VvZiBfU3R5bGVSdWxlMlsnZGVmYXVsdCddKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLm1hcFtydWxlLnNlbGVjdG9yXTtcbiAgICAgICAgZGVsZXRlIHRoaXMuY2xhc3Nlc1tydWxlLmtleV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSBmdW5jdGlvbiB2YWx1ZXMgd2l0aCBhIG5ldyBkYXRhLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICd1cGRhdGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGUobmFtZSwgZGF0YSkge1xuICAgICAgdmFyIF9vcHRpb25zMiA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgICBwbHVnaW5zID0gX29wdGlvbnMyLmpzcy5wbHVnaW5zLFxuICAgICAgICAgIHNoZWV0ID0gX29wdGlvbnMyLnNoZWV0O1xuXG4gICAgICBpZiAodHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHBsdWdpbnMub25VcGRhdGUoZGF0YSwgdGhpcy5nZXQobmFtZSksIHNoZWV0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5pbmRleC5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgcGx1Z2lucy5vblVwZGF0ZShuYW1lLCB0aGlzLmluZGV4W2luZGV4XSwgc2hlZXQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpbmsgcmVuZGVyYWJsZSBydWxlcyB3aXRoIENTU1J1bGVMaXN0LlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdsaW5rJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbGluayhjc3NSdWxlcykge1xuICAgICAgdmFyIG1hcCA9IHRoaXMub3B0aW9ucy5zaGVldC5yZW5kZXJlci5nZXRVbmVzY2FwZWRLZXlzTWFwKHRoaXMuaW5kZXgpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNzc1J1bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjc3NSdWxlID0gY3NzUnVsZXNbaV07XG4gICAgICAgIHZhciBfa2V5ID0gdGhpcy5vcHRpb25zLnNoZWV0LnJlbmRlcmVyLmdldEtleShjc3NSdWxlKTtcbiAgICAgICAgaWYgKG1hcFtfa2V5XSkgX2tleSA9IG1hcFtfa2V5XTtcbiAgICAgICAgdmFyIHJ1bGUgPSB0aGlzLm1hcFtfa2V5XTtcbiAgICAgICAgaWYgKHJ1bGUpICgwLCBfbGlua1J1bGUyWydkZWZhdWx0J10pKHJ1bGUsIGNzc1J1bGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgcnVsZXMgdG8gYSBDU1Mgc3RyaW5nLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICd0b1N0cmluZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKG9wdGlvbnMpIHtcbiAgICAgIHZhciBzdHIgPSAnJztcbiAgICAgIHZhciBzaGVldCA9IHRoaXMub3B0aW9ucy5zaGVldDtcblxuICAgICAgdmFyIGxpbmsgPSBzaGVldCA/IHNoZWV0Lm9wdGlvbnMubGluayA6IGZhbHNlO1xuXG4gICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5pbmRleC5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgdmFyIHJ1bGUgPSB0aGlzLmluZGV4W2luZGV4XTtcbiAgICAgICAgdmFyIGNzcyA9IHJ1bGUudG9TdHJpbmcob3B0aW9ucyk7XG5cbiAgICAgICAgLy8gTm8gbmVlZCB0byByZW5kZXIgYW4gZW1wdHkgcnVsZS5cbiAgICAgICAgaWYgKCFjc3MgJiYgIWxpbmspIGNvbnRpbnVlO1xuXG4gICAgICAgIGlmIChzdHIpIHN0ciArPSAnXFxuJztcbiAgICAgICAgc3RyICs9IGNzcztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUnVsZUxpc3Q7XG59KCk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IFJ1bGVMaXN0OyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF93YXJuaW5nID0gcmVxdWlyZSgnd2FybmluZycpO1xuXG52YXIgX3dhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd2FybmluZyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuLyoqXG4gKiBTaGVldHNNYW5hZ2VyIGlzIGxpa2UgYSBXZWFrTWFwIHdoaWNoIGlzIGRlc2lnbmVkIHRvIGNvdW50IFN0eWxlU2hlZXRcbiAqIGluc3RhbmNlcyBhbmQgYXR0YWNoL2RldGFjaCBhdXRvbWF0aWNhbGx5LlxuICovXG52YXIgU2hlZXRzTWFuYWdlciA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU2hlZXRzTWFuYWdlcigpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU2hlZXRzTWFuYWdlcik7XG5cbiAgICB0aGlzLnNoZWV0cyA9IFtdO1xuICAgIHRoaXMucmVmcyA9IFtdO1xuICAgIHRoaXMua2V5cyA9IFtdO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFNoZWV0c01hbmFnZXIsIFt7XG4gICAga2V5OiAnZ2V0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0KGtleSkge1xuICAgICAgdmFyIGluZGV4ID0gdGhpcy5rZXlzLmluZGV4T2Yoa2V5KTtcbiAgICAgIHJldHVybiB0aGlzLnNoZWV0c1tpbmRleF07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnYWRkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkKGtleSwgc2hlZXQpIHtcbiAgICAgIHZhciBzaGVldHMgPSB0aGlzLnNoZWV0cyxcbiAgICAgICAgICByZWZzID0gdGhpcy5yZWZzLFxuICAgICAgICAgIGtleXMgPSB0aGlzLmtleXM7XG5cbiAgICAgIHZhciBpbmRleCA9IHNoZWV0cy5pbmRleE9mKHNoZWV0KTtcblxuICAgICAgaWYgKGluZGV4ICE9PSAtMSkgcmV0dXJuIGluZGV4O1xuXG4gICAgICBzaGVldHMucHVzaChzaGVldCk7XG4gICAgICByZWZzLnB1c2goMCk7XG4gICAgICBrZXlzLnB1c2goa2V5KTtcblxuICAgICAgcmV0dXJuIHNoZWV0cy5sZW5ndGggLSAxO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ21hbmFnZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1hbmFnZShrZXkpIHtcbiAgICAgIHZhciBpbmRleCA9IHRoaXMua2V5cy5pbmRleE9mKGtleSk7XG4gICAgICB2YXIgc2hlZXQgPSB0aGlzLnNoZWV0c1tpbmRleF07XG4gICAgICBpZiAodGhpcy5yZWZzW2luZGV4XSA9PT0gMCkgc2hlZXQuYXR0YWNoKCk7XG4gICAgICB0aGlzLnJlZnNbaW5kZXhdKys7XG4gICAgICBpZiAoIXRoaXMua2V5c1tpbmRleF0pIHRoaXMua2V5cy5zcGxpY2UoaW5kZXgsIDAsIGtleSk7XG4gICAgICByZXR1cm4gc2hlZXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndW5tYW5hZ2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bm1hbmFnZShrZXkpIHtcbiAgICAgIHZhciBpbmRleCA9IHRoaXMua2V5cy5pbmRleE9mKGtleSk7XG4gICAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgIC8vIGVzbGludC1pZ25vcmUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgKDAsIF93YXJuaW5nMlsnZGVmYXVsdCddKShmYWxzZSwgJ1NoZWV0c01hbmFnZXI6IGNhblxcJ3QgZmluZCBzaGVldCB0byB1bm1hbmFnZScpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5yZWZzW2luZGV4XSA+IDApIHtcbiAgICAgICAgdGhpcy5yZWZzW2luZGV4XS0tO1xuICAgICAgICBpZiAodGhpcy5yZWZzW2luZGV4XSA9PT0gMCkgdGhpcy5zaGVldHNbaW5kZXhdLmRldGFjaCgpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3NpemUnLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMua2V5cy5sZW5ndGg7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFNoZWV0c01hbmFnZXI7XG59KCk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IFNoZWV0c01hbmFnZXI7IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4vKipcbiAqIFNoZWV0cyByZWdpc3RyeSB0byBhY2Nlc3MgdGhlbSBhbGwgYXQgb25lIHBsYWNlLlxuICovXG52YXIgU2hlZXRzUmVnaXN0cnkgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFNoZWV0c1JlZ2lzdHJ5KCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTaGVldHNSZWdpc3RyeSk7XG5cbiAgICB0aGlzLnJlZ2lzdHJ5ID0gW107XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoU2hlZXRzUmVnaXN0cnksIFt7XG4gICAga2V5OiAnYWRkJyxcblxuXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgYSBTdHlsZSBTaGVldC5cbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkKHNoZWV0KSB7XG4gICAgICB2YXIgcmVnaXN0cnkgPSB0aGlzLnJlZ2lzdHJ5O1xuICAgICAgdmFyIGluZGV4ID0gc2hlZXQub3B0aW9ucy5pbmRleDtcblxuXG4gICAgICBpZiAocmVnaXN0cnkuaW5kZXhPZihzaGVldCkgIT09IC0xKSByZXR1cm47XG5cbiAgICAgIGlmIChyZWdpc3RyeS5sZW5ndGggPT09IDAgfHwgaW5kZXggPj0gdGhpcy5pbmRleCkge1xuICAgICAgICByZWdpc3RyeS5wdXNoKHNoZWV0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBGaW5kIGEgcG9zaXRpb24uXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlZ2lzdHJ5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChyZWdpc3RyeVtpXS5vcHRpb25zLmluZGV4ID4gaW5kZXgpIHtcbiAgICAgICAgICByZWdpc3RyeS5zcGxpY2UoaSwgMCwgc2hlZXQpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlc2V0IHRoZSByZWdpc3RyeS5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAncmVzZXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgIHRoaXMucmVnaXN0cnkgPSBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYSBTdHlsZSBTaGVldC5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAncmVtb3ZlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlKHNoZWV0KSB7XG4gICAgICB2YXIgaW5kZXggPSB0aGlzLnJlZ2lzdHJ5LmluZGV4T2Yoc2hlZXQpO1xuICAgICAgdGhpcy5yZWdpc3RyeS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgYWxsIGF0dGFjaGVkIHNoZWV0cyB0byBhIENTUyBzdHJpbmcuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3RvU3RyaW5nJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcob3B0aW9ucykge1xuICAgICAgcmV0dXJuIHRoaXMucmVnaXN0cnkuZmlsdGVyKGZ1bmN0aW9uIChzaGVldCkge1xuICAgICAgICByZXR1cm4gc2hlZXQuYXR0YWNoZWQ7XG4gICAgICB9KS5tYXAoZnVuY3Rpb24gKHNoZWV0KSB7XG4gICAgICAgIHJldHVybiBzaGVldC50b1N0cmluZyhvcHRpb25zKTtcbiAgICAgIH0pLmpvaW4oJ1xcbicpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2luZGV4JyxcblxuXG4gICAgLyoqXG4gICAgICogQ3VycmVudCBoaWdoZXN0IGluZGV4IG51bWJlci5cbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlZ2lzdHJ5Lmxlbmd0aCA9PT0gMCA/IDAgOiB0aGlzLnJlZ2lzdHJ5W3RoaXMucmVnaXN0cnkubGVuZ3RoIC0gMV0ub3B0aW9ucy5pbmRleDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU2hlZXRzUmVnaXN0cnk7XG59KCk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IFNoZWV0c1JlZ2lzdHJ5OyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9saW5rUnVsZSA9IHJlcXVpcmUoJy4vdXRpbHMvbGlua1J1bGUnKTtcblxudmFyIF9saW5rUnVsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9saW5rUnVsZSk7XG5cbnZhciBfUnVsZUxpc3QgPSByZXF1aXJlKCcuL1J1bGVMaXN0Jyk7XG5cbnZhciBfUnVsZUxpc3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUnVsZUxpc3QpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBTdHlsZVNoZWV0ID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTdHlsZVNoZWV0KHN0eWxlcywgb3B0aW9ucykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTdHlsZVNoZWV0KTtcblxuICAgIHRoaXMuYXR0YWNoZWQgPSBmYWxzZTtcbiAgICB0aGlzLmRlcGxveWVkID0gZmFsc2U7XG4gICAgdGhpcy5saW5rZWQgPSBmYWxzZTtcbiAgICB0aGlzLmNsYXNzZXMgPSB7fTtcbiAgICB0aGlzLm9wdGlvbnMgPSBfZXh0ZW5kcyh7fSwgb3B0aW9ucywge1xuICAgICAgc2hlZXQ6IHRoaXMsXG4gICAgICBwYXJlbnQ6IHRoaXMsXG4gICAgICBjbGFzc2VzOiB0aGlzLmNsYXNzZXNcbiAgICB9KTtcbiAgICB0aGlzLnJlbmRlcmVyID0gbmV3IG9wdGlvbnMuUmVuZGVyZXIodGhpcyk7XG4gICAgdGhpcy5ydWxlcyA9IG5ldyBfUnVsZUxpc3QyWydkZWZhdWx0J10odGhpcy5vcHRpb25zKTtcblxuICAgIGZvciAodmFyIG5hbWUgaW4gc3R5bGVzKSB7XG4gICAgICB0aGlzLnJ1bGVzLmFkZChuYW1lLCBzdHlsZXNbbmFtZV0pO1xuICAgIH1cblxuICAgIHRoaXMucnVsZXMucHJvY2VzcygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEF0dGFjaCByZW5kZXJhYmxlIHRvIHRoZSByZW5kZXIgdHJlZS5cbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoU3R5bGVTaGVldCwgW3tcbiAgICBrZXk6ICdhdHRhY2gnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhdHRhY2goKSB7XG4gICAgICBpZiAodGhpcy5hdHRhY2hlZCkgcmV0dXJuIHRoaXM7XG4gICAgICBpZiAoIXRoaXMuZGVwbG95ZWQpIHRoaXMuZGVwbG95KCk7XG4gICAgICB0aGlzLnJlbmRlcmVyLmF0dGFjaCgpO1xuICAgICAgaWYgKCF0aGlzLmxpbmtlZCAmJiB0aGlzLm9wdGlvbnMubGluaykgdGhpcy5saW5rKCk7XG4gICAgICB0aGlzLmF0dGFjaGVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSByZW5kZXJhYmxlIGZyb20gcmVuZGVyIHRyZWUuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2RldGFjaCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRldGFjaCgpIHtcbiAgICAgIGlmICghdGhpcy5hdHRhY2hlZCkgcmV0dXJuIHRoaXM7XG4gICAgICB0aGlzLnJlbmRlcmVyLmRldGFjaCgpO1xuICAgICAgdGhpcy5hdHRhY2hlZCA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkIGEgcnVsZSB0byB0aGUgY3VycmVudCBzdHlsZXNoZWV0LlxuICAgICAqIFdpbGwgaW5zZXJ0IGEgcnVsZSBhbHNvIGFmdGVyIHRoZSBzdHlsZXNoZWV0IGhhcyBiZWVuIHJlbmRlcmVkIGZpcnN0IHRpbWUuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2FkZFJ1bGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRSdWxlKG5hbWUsIGRlY2wsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBxdWV1ZSA9IHRoaXMucXVldWU7XG5cbiAgICAgIC8vIFBsdWdpbnMgY2FuIGNyZWF0ZSBydWxlcy5cbiAgICAgIC8vIEluIG9yZGVyIHRvIHByZXNlcnZlIHRoZSByaWdodCBvcmRlciwgd2UgbmVlZCB0byBxdWV1ZSBhbGwgYC5hZGRSdWxlYCBjYWxscyxcbiAgICAgIC8vIHdoaWNoIGhhcHBlbiBhZnRlciB0aGUgZmlyc3QgYHJ1bGVzLmFkZCgpYCBjYWxsLlxuXG4gICAgICBpZiAodGhpcy5hdHRhY2hlZCAmJiAhcXVldWUpIHRoaXMucXVldWUgPSBbXTtcblxuICAgICAgdmFyIHJ1bGUgPSB0aGlzLnJ1bGVzLmFkZChuYW1lLCBkZWNsLCBvcHRpb25zKTtcbiAgICAgIHRoaXMub3B0aW9ucy5qc3MucGx1Z2lucy5vblByb2Nlc3NSdWxlKHJ1bGUpO1xuXG4gICAgICBpZiAodGhpcy5hdHRhY2hlZCkge1xuICAgICAgICBpZiAoIXRoaXMuZGVwbG95ZWQpIHJldHVybiBydWxlO1xuICAgICAgICAvLyBEb24ndCBpbnNlcnQgcnVsZSBkaXJlY3RseSBpZiB0aGVyZSBpcyBubyBzdHJpbmdpZmllZCB2ZXJzaW9uIHlldC5cbiAgICAgICAgLy8gSXQgd2lsbCBiZSBpbnNlcnRlZCBhbGwgdG9nZXRoZXIgd2hlbiAuYXR0YWNoIGlzIGNhbGxlZC5cbiAgICAgICAgaWYgKHF1ZXVlKSBxdWV1ZS5wdXNoKHJ1bGUpO2Vsc2Uge1xuICAgICAgICAgIHRoaXMuaW5zZXJ0UnVsZShydWxlKTtcbiAgICAgICAgICBpZiAodGhpcy5xdWV1ZSkge1xuICAgICAgICAgICAgdGhpcy5xdWV1ZS5mb3JFYWNoKHRoaXMuaW5zZXJ0UnVsZSwgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLnF1ZXVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcnVsZTtcbiAgICAgIH1cblxuICAgICAgLy8gV2UgY2FuJ3QgYWRkIHJ1bGVzIHRvIGEgZGV0YWNoZWQgc3R5bGUgbm9kZS5cbiAgICAgIC8vIFdlIHdpbGwgcmVkZXBsb3kgdGhlIHNoZWV0IG9uY2UgdXNlciB3aWxsIGF0dGFjaCBpdC5cbiAgICAgIHRoaXMuZGVwbG95ZWQgPSBmYWxzZTtcblxuICAgICAgcmV0dXJuIHJ1bGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5zZXJ0IHJ1bGUgaW50byB0aGUgU3R5bGVTaGVldFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdpbnNlcnRSdWxlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5zZXJ0UnVsZShydWxlKSB7XG4gICAgICB2YXIgcmVuZGVyYWJsZSA9IHRoaXMucmVuZGVyZXIuaW5zZXJ0UnVsZShydWxlKTtcbiAgICAgIGlmIChyZW5kZXJhYmxlICYmIHRoaXMub3B0aW9ucy5saW5rKSAoMCwgX2xpbmtSdWxlMlsnZGVmYXVsdCddKShydWxlLCByZW5kZXJhYmxlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYW5kIGFkZCBydWxlcy5cbiAgICAgKiBXaWxsIHJlbmRlciBhbHNvIGFmdGVyIFN0eWxlIFNoZWV0IHdhcyByZW5kZXJlZCB0aGUgZmlyc3QgdGltZS5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnYWRkUnVsZXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRSdWxlcyhzdHlsZXMsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBhZGRlZCA9IFtdO1xuICAgICAgZm9yICh2YXIgbmFtZSBpbiBzdHlsZXMpIHtcbiAgICAgICAgYWRkZWQucHVzaCh0aGlzLmFkZFJ1bGUobmFtZSwgc3R5bGVzW25hbWVdLCBvcHRpb25zKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWRkZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGEgcnVsZSBieSBuYW1lLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdnZXRSdWxlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UnVsZShuYW1lKSB7XG4gICAgICByZXR1cm4gdGhpcy5ydWxlcy5nZXQobmFtZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVsZXRlIGEgcnVsZSBieSBuYW1lLlxuICAgICAqIFJldHVybnMgYHRydWVgOiBpZiBydWxlIGhhcyBiZWVuIGRlbGV0ZWQgZnJvbSB0aGUgRE9NLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdkZWxldGVSdWxlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVsZXRlUnVsZShuYW1lKSB7XG4gICAgICB2YXIgcnVsZSA9IHRoaXMucnVsZXMuZ2V0KG5hbWUpO1xuXG4gICAgICBpZiAoIXJ1bGUpIHJldHVybiBmYWxzZTtcblxuICAgICAgdGhpcy5ydWxlcy5yZW1vdmUocnVsZSk7XG5cbiAgICAgIGlmICh0aGlzLmF0dGFjaGVkICYmIHJ1bGUucmVuZGVyYWJsZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5kZWxldGVSdWxlKHJ1bGUucmVuZGVyYWJsZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBpbmRleCBvZiBhIHJ1bGUuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2luZGV4T2YnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbmRleE9mKHJ1bGUpIHtcbiAgICAgIHJldHVybiB0aGlzLnJ1bGVzLmluZGV4T2YocnVsZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVwbG95IHB1cmUgQ1NTIHN0cmluZyB0byBhIHJlbmRlcmFibGUuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2RlcGxveScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlcGxveSgpIHtcbiAgICAgIHRoaXMucmVuZGVyZXIuZGVwbG95KCk7XG4gICAgICB0aGlzLmRlcGxveWVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpbmsgcmVuZGVyYWJsZSBDU1MgcnVsZXMgZnJvbSBzaGVldCB3aXRoIHRoZWlyIGNvcnJlc3BvbmRpbmcgbW9kZWxzLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdsaW5rJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbGluaygpIHtcbiAgICAgIHZhciBjc3NSdWxlcyA9IHRoaXMucmVuZGVyZXIuZ2V0UnVsZXMoKTtcblxuICAgICAgLy8gSXMgdW5kZWZpbmVkIHdoZW4gVmlydHVhbFJlbmRlcmVyIGlzIHVzZWQuXG4gICAgICBpZiAoY3NzUnVsZXMpIHRoaXMucnVsZXMubGluayhjc3NSdWxlcyk7XG4gICAgICB0aGlzLmxpbmtlZCA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIGZ1bmN0aW9uIHZhbHVlcyB3aXRoIGEgbmV3IGRhdGEuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3VwZGF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZShuYW1lLCBkYXRhKSB7XG4gICAgICB0aGlzLnJ1bGVzLnVwZGF0ZShuYW1lLCBkYXRhKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgcnVsZXMgdG8gYSBDU1Mgc3RyaW5nLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICd0b1N0cmluZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLnJ1bGVzLnRvU3RyaW5nKG9wdGlvbnMpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTdHlsZVNoZWV0O1xufSgpO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBTdHlsZVNoZWV0OyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuY3JlYXRlID0gZXhwb3J0cy5jcmVhdGVHZW5lcmF0ZUNsYXNzTmFtZSA9IGV4cG9ydHMuc2hlZXRzID0gZXhwb3J0cy5SdWxlTGlzdCA9IGV4cG9ydHMuU2hlZXRzTWFuYWdlciA9IGV4cG9ydHMuU2hlZXRzUmVnaXN0cnkgPSBleHBvcnRzLnRvQ3NzVmFsdWUgPSBleHBvcnRzLmdldER5bmFtaWNTdHlsZXMgPSB1bmRlZmluZWQ7XG5cbnZhciBfZ2V0RHluYW1pY1N0eWxlcyA9IHJlcXVpcmUoJy4vdXRpbHMvZ2V0RHluYW1pY1N0eWxlcycpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ2dldER5bmFtaWNTdHlsZXMnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXREeW5hbWljU3R5bGVzKVsnZGVmYXVsdCddO1xuICB9XG59KTtcblxudmFyIF90b0Nzc1ZhbHVlID0gcmVxdWlyZSgnLi91dGlscy90b0Nzc1ZhbHVlJyk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAndG9Dc3NWYWx1ZScsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RvQ3NzVmFsdWUpWydkZWZhdWx0J107XG4gIH1cbn0pO1xuXG52YXIgX1NoZWV0c1JlZ2lzdHJ5ID0gcmVxdWlyZSgnLi9TaGVldHNSZWdpc3RyeScpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ1NoZWV0c1JlZ2lzdHJ5Jywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU2hlZXRzUmVnaXN0cnkpWydkZWZhdWx0J107XG4gIH1cbn0pO1xuXG52YXIgX1NoZWV0c01hbmFnZXIgPSByZXF1aXJlKCcuL1NoZWV0c01hbmFnZXInKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdTaGVldHNNYW5hZ2VyJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU2hlZXRzTWFuYWdlcilbJ2RlZmF1bHQnXTtcbiAgfVxufSk7XG5cbnZhciBfUnVsZUxpc3QgPSByZXF1aXJlKCcuL1J1bGVMaXN0Jyk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnUnVsZUxpc3QnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9SdWxlTGlzdClbJ2RlZmF1bHQnXTtcbiAgfVxufSk7XG5cbnZhciBfc2hlZXRzID0gcmVxdWlyZSgnLi9zaGVldHMnKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdzaGVldHMnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zaGVldHMpWydkZWZhdWx0J107XG4gIH1cbn0pO1xuXG52YXIgX2NyZWF0ZUdlbmVyYXRlQ2xhc3NOYW1lID0gcmVxdWlyZSgnLi91dGlscy9jcmVhdGVHZW5lcmF0ZUNsYXNzTmFtZScpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ2NyZWF0ZUdlbmVyYXRlQ2xhc3NOYW1lJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlR2VuZXJhdGVDbGFzc05hbWUpWydkZWZhdWx0J107XG4gIH1cbn0pO1xuXG52YXIgX0pzcyA9IHJlcXVpcmUoJy4vSnNzJyk7XG5cbnZhciBfSnNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0pzcyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIEpzcy5cbiAqL1xudmFyIGNyZWF0ZSA9IGV4cG9ydHMuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBfSnNzMlsnZGVmYXVsdCddKG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBBIGdsb2JhbCBKc3MgaW5zdGFuY2UuXG4gKi9cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGNyZWF0ZSgpOyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9SdWxlTGlzdCA9IHJlcXVpcmUoJy4uL1J1bGVMaXN0Jyk7XG5cbnZhciBfUnVsZUxpc3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUnVsZUxpc3QpO1xuXG52YXIgX1N0eWxlUnVsZSA9IHJlcXVpcmUoJy4uL3J1bGVzL1N0eWxlUnVsZScpO1xuXG52YXIgX1N0eWxlUnVsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9TdHlsZVJ1bGUpO1xuXG52YXIgX2tlYmFiQ2FzZSA9IHJlcXVpcmUoJy4uL3V0aWxzL2tlYmFiQ2FzZScpO1xuXG52YXIgX2tlYmFiQ2FzZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9rZWJhYkNhc2UpO1xuXG52YXIgX2NyZWF0ZVJ1bGUgPSByZXF1aXJlKCcuLi91dGlscy9jcmVhdGVSdWxlJyk7XG5cbnZhciBfY3JlYXRlUnVsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVSdWxlKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG4vLyBBIHN5bWJvbCByZXBsYWNlbWVudC5cbnZhciBub3cgPSBEYXRlLm5vdygpO1xudmFyIGZuVmFsdWVzTnMgPSAnZm5WYWx1ZXMnICsgbm93O1xudmFyIGZuU3R5bGVOcyA9ICdmblN0eWxlJyArICsrbm93O1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSB7XG4gIG9uQ3JlYXRlUnVsZTogZnVuY3Rpb24gb25DcmVhdGVSdWxlKG5hbWUsIGRlY2wsIG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIGRlY2wgIT09ICdmdW5jdGlvbicpIHJldHVybiBudWxsO1xuICAgIHZhciBydWxlID0gKDAsIF9jcmVhdGVSdWxlMlsnZGVmYXVsdCddKShuYW1lLCB7fSwgb3B0aW9ucyk7XG4gICAgcnVsZVtmblN0eWxlTnNdID0gZGVjbDtcbiAgICByZXR1cm4gcnVsZTtcbiAgfSxcbiAgb25Qcm9jZXNzU3R5bGU6IGZ1bmN0aW9uIG9uUHJvY2Vzc1N0eWxlKHN0eWxlLCBydWxlKSB7XG4gICAgdmFyIGZuID0ge307XG4gICAgZm9yICh2YXIgcHJvcCBpbiBzdHlsZSkge1xuICAgICAgdmFyIHZhbHVlID0gc3R5bGVbcHJvcF07XG4gICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnZnVuY3Rpb24nKSBjb250aW51ZTtcbiAgICAgIGRlbGV0ZSBzdHlsZVtwcm9wXTtcbiAgICAgIGZuWygwLCBfa2ViYWJDYXNlMlsnZGVmYXVsdCddKShwcm9wKV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcnVsZSA9IHJ1bGU7XG4gICAgcnVsZVtmblZhbHVlc05zXSA9IGZuO1xuICAgIHJldHVybiBzdHlsZTtcbiAgfSxcbiAgb25VcGRhdGU6IGZ1bmN0aW9uIG9uVXBkYXRlKGRhdGEsIHJ1bGUpIHtcbiAgICAvLyBJdCBpcyBhIHJ1bGVzIGNvbnRhaW5lciBsaWtlIGZvciBlLmcuIENvbmRpdGlvbmFsUnVsZS5cbiAgICBpZiAocnVsZS5ydWxlcyBpbnN0YW5jZW9mIF9SdWxlTGlzdDJbJ2RlZmF1bHQnXSkge1xuICAgICAgcnVsZS5ydWxlcy51cGRhdGUoZGF0YSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghKHJ1bGUgaW5zdGFuY2VvZiBfU3R5bGVSdWxlMlsnZGVmYXVsdCddKSkgcmV0dXJuO1xuXG4gICAgcnVsZSA9IHJ1bGU7XG5cbiAgICAvLyBJZiB3ZSBoYXZlIGEgZm4gdmFsdWVzIG1hcCwgaXQgaXMgYSBydWxlIHdpdGggZnVuY3Rpb24gdmFsdWVzLlxuICAgIGlmIChydWxlW2ZuVmFsdWVzTnNdKSB7XG4gICAgICBmb3IgKHZhciBwcm9wIGluIHJ1bGVbZm5WYWx1ZXNOc10pIHtcbiAgICAgICAgcnVsZS5wcm9wKHByb3AsIHJ1bGVbZm5WYWx1ZXNOc11bcHJvcF0oZGF0YSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJ1bGUgPSBydWxlO1xuXG4gICAgdmFyIGZuU3R5bGUgPSBydWxlW2ZuU3R5bGVOc107XG5cbiAgICAvLyBJZiB3ZSBoYXZlIGEgc3R5bGUgZnVuY3Rpb24sIHRoZSBlbnRpcmUgcnVsZSBpcyBkeW5hbWljIGFuZCBzdHlsZSBvYmplY3RcbiAgICAvLyB3aWxsIGJlIHJldHVybmVkIGZyb20gdGhhdCBmdW5jdGlvbi5cbiAgICBpZiAoZm5TdHlsZSkge1xuICAgICAgdmFyIHN0eWxlID0gZm5TdHlsZShkYXRhKTtcbiAgICAgIGZvciAodmFyIF9wcm9wIGluIHN0eWxlKSB7XG4gICAgICAgIHJ1bGUucHJvcChfcHJvcCwgc3R5bGVbX3Byb3BdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX1N0eWxlUnVsZSA9IHJlcXVpcmUoJy4uL3J1bGVzL1N0eWxlUnVsZScpO1xuXG52YXIgX1N0eWxlUnVsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9TdHlsZVJ1bGUpO1xuXG52YXIgX2NyZWF0ZVJ1bGUgPSByZXF1aXJlKCcuLi91dGlscy9jcmVhdGVSdWxlJyk7XG5cbnZhciBfY3JlYXRlUnVsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVSdWxlKTtcblxudmFyIF9pc09ic2VydmFibGUgPSByZXF1aXJlKCcuLi91dGlscy9pc09ic2VydmFibGUnKTtcblxudmFyIF9pc09ic2VydmFibGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaXNPYnNlcnZhYmxlKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5leHBvcnRzWydkZWZhdWx0J10gPSB7XG4gIG9uQ3JlYXRlUnVsZTogZnVuY3Rpb24gb25DcmVhdGVSdWxlKG5hbWUsIGRlY2wsIG9wdGlvbnMpIHtcbiAgICBpZiAoISgwLCBfaXNPYnNlcnZhYmxlMlsnZGVmYXVsdCddKShkZWNsKSkgcmV0dXJuIG51bGw7XG5cbiAgICAvLyBDYXN0IGBkZWNsYCB0byBgT2JzZXJ2YWJsZWAsIHNpbmNlIGl0IHBhc3NlZCB0aGUgdHlwZSBndWFyZC5cbiAgICB2YXIgc3R5bGUkID0gZGVjbDtcblxuICAgIHZhciBydWxlID0gKDAsIF9jcmVhdGVSdWxlMlsnZGVmYXVsdCddKShuYW1lLCB7fSwgb3B0aW9ucyk7XG5cbiAgICAvLyBUT0RPXG4gICAgLy8gQ2FsbCBgc3RyZWFtLnN1YnNjcmliZSgpYCByZXR1cm5zIGEgc3Vic2NyaXB0aW9uLCB3aGljaCBzaG91bGQgYmUgZXhwbGljaXRseVxuICAgIC8vIHVuc3Vic2NyaWJlZCBmcm9tIHdoZW4gd2Uga25vdyB0aGlzIHNoZWV0IGlzIG5vIGxvbmdlciBuZWVkZWQuXG4gICAgc3R5bGUkLnN1YnNjcmliZShmdW5jdGlvbiAoc3R5bGUpIHtcbiAgICAgIGZvciAodmFyIHByb3AgaW4gc3R5bGUpIHtcbiAgICAgICAgcnVsZS5wcm9wKHByb3AsIHN0eWxlW3Byb3BdKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBydWxlO1xuICB9LFxuICBvblByb2Nlc3NSdWxlOiBmdW5jdGlvbiBvblByb2Nlc3NSdWxlKHJ1bGUpIHtcbiAgICBpZiAoIShydWxlIGluc3RhbmNlb2YgX1N0eWxlUnVsZTJbJ2RlZmF1bHQnXSkpIHJldHVybjtcbiAgICB2YXIgc3R5bGVSdWxlID0gcnVsZTtcbiAgICB2YXIgc3R5bGUgPSBzdHlsZVJ1bGUuc3R5bGU7XG5cbiAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChwcm9wKSB7XG4gICAgICB2YXIgdmFsdWUgPSBzdHlsZVtwcm9wXTtcbiAgICAgIGlmICghKDAsIF9pc09ic2VydmFibGUyWydkZWZhdWx0J10pKHZhbHVlKSkgcmV0dXJuICdjb250aW51ZSc7XG4gICAgICBkZWxldGUgc3R5bGVbcHJvcF07XG4gICAgICB2YWx1ZS5zdWJzY3JpYmUoe1xuICAgICAgICBuZXh0OiBmdW5jdGlvbiBuZXh0KG5leHRWYWx1ZSkge1xuICAgICAgICAgIHN0eWxlUnVsZS5wcm9wKHByb3AsIG5leHRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBmb3IgKHZhciBwcm9wIGluIHN0eWxlKSB7XG4gICAgICB2YXIgX3JldCA9IF9sb29wKHByb3ApO1xuXG4gICAgICBpZiAoX3JldCA9PT0gJ2NvbnRpbnVlJykgY29udGludWU7XG4gICAgfVxuICB9XG59OyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9TaW1wbGVSdWxlID0gcmVxdWlyZSgnLi4vcnVsZXMvU2ltcGxlUnVsZScpO1xuXG52YXIgX1NpbXBsZVJ1bGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU2ltcGxlUnVsZSk7XG5cbnZhciBfS2V5ZnJhbWVzUnVsZSA9IHJlcXVpcmUoJy4uL3J1bGVzL0tleWZyYW1lc1J1bGUnKTtcblxudmFyIF9LZXlmcmFtZXNSdWxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0tleWZyYW1lc1J1bGUpO1xuXG52YXIgX0NvbmRpdGlvbmFsUnVsZSA9IHJlcXVpcmUoJy4uL3J1bGVzL0NvbmRpdGlvbmFsUnVsZScpO1xuXG52YXIgX0NvbmRpdGlvbmFsUnVsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Db25kaXRpb25hbFJ1bGUpO1xuXG52YXIgX0ZvbnRGYWNlUnVsZSA9IHJlcXVpcmUoJy4uL3J1bGVzL0ZvbnRGYWNlUnVsZScpO1xuXG52YXIgX0ZvbnRGYWNlUnVsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Gb250RmFjZVJ1bGUpO1xuXG52YXIgX1ZpZXdwb3J0UnVsZSA9IHJlcXVpcmUoJy4uL3J1bGVzL1ZpZXdwb3J0UnVsZScpO1xuXG52YXIgX1ZpZXdwb3J0UnVsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9WaWV3cG9ydFJ1bGUpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBjbGFzc2VzID0ge1xuICAnQGNoYXJzZXQnOiBfU2ltcGxlUnVsZTJbJ2RlZmF1bHQnXSxcbiAgJ0BpbXBvcnQnOiBfU2ltcGxlUnVsZTJbJ2RlZmF1bHQnXSxcbiAgJ0BuYW1lc3BhY2UnOiBfU2ltcGxlUnVsZTJbJ2RlZmF1bHQnXSxcbiAgJ0BrZXlmcmFtZXMnOiBfS2V5ZnJhbWVzUnVsZTJbJ2RlZmF1bHQnXSxcbiAgJ0BtZWRpYSc6IF9Db25kaXRpb25hbFJ1bGUyWydkZWZhdWx0J10sXG4gICdAc3VwcG9ydHMnOiBfQ29uZGl0aW9uYWxSdWxlMlsnZGVmYXVsdCddLFxuICAnQGZvbnQtZmFjZSc6IF9Gb250RmFjZVJ1bGUyWydkZWZhdWx0J10sXG4gICdAdmlld3BvcnQnOiBfVmlld3BvcnRSdWxlMlsnZGVmYXVsdCddLFxuICAnQC1tcy12aWV3cG9ydCc6IF9WaWV3cG9ydFJ1bGUyWydkZWZhdWx0J11cblxuICAvKipcbiAgICogR2VuZXJhdGUgcGx1Z2lucyB3aGljaCB3aWxsIHJlZ2lzdGVyIGFsbCBydWxlcy5cbiAgICovXG59O1xuZXhwb3J0c1snZGVmYXVsdCddID0gT2JqZWN0LmtleXMoY2xhc3NlcykubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgLy8gaHR0cHM6Ly9qc3BlcmYuY29tL2luZGV4b2YtdnMtc3Vic3RyLXZzLXJlZ2V4LWF0LXRoZS1iZWdpbm5pbmctM1xuICB2YXIgcmUgPSBuZXcgUmVnRXhwKCdeJyArIGtleSk7XG4gIHZhciBvbkNyZWF0ZVJ1bGUgPSBmdW5jdGlvbiBvbkNyZWF0ZVJ1bGUobmFtZSwgZGVjbCwgb3B0aW9ucykge1xuICAgIHJldHVybiByZS50ZXN0KG5hbWUpID8gbmV3IGNsYXNzZXNba2V5XShuYW1lLCBkZWNsLCBvcHRpb25zKSA6IG51bGw7XG4gIH07XG4gIHJldHVybiB7IG9uQ3JlYXRlUnVsZTogb25DcmVhdGVSdWxlIH07XG59KTsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfd2FybmluZyA9IHJlcXVpcmUoJ3dhcm5pbmcnKTtcblxudmFyIF93YXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dhcm5pbmcpO1xuXG52YXIgX3NoZWV0cyA9IHJlcXVpcmUoJy4uL3NoZWV0cycpO1xuXG52YXIgX3NoZWV0czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zaGVldHMpO1xuXG52YXIgX1N0eWxlUnVsZSA9IHJlcXVpcmUoJy4uL3J1bGVzL1N0eWxlUnVsZScpO1xuXG52YXIgX1N0eWxlUnVsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9TdHlsZVJ1bGUpO1xuXG52YXIgX3RvQ3NzVmFsdWUgPSByZXF1aXJlKCcuLi91dGlscy90b0Nzc1ZhbHVlJyk7XG5cbnZhciBfdG9Dc3NWYWx1ZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90b0Nzc1ZhbHVlKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4vKipcbiAqIEdldCBhIHN0eWxlIHByb3BlcnR5LlxuICovXG5mdW5jdGlvbiBnZXRTdHlsZShjc3NSdWxlLCBwcm9wKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGNzc1J1bGUuc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShwcm9wKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gSUUgbWF5IHRocm93IGlmIHByb3BlcnR5IGlzIHVua25vd24uXG4gICAgcmV0dXJuICcnO1xuICB9XG59XG5cbi8qKlxuICogU2V0IGEgc3R5bGUgcHJvcGVydHkuXG4gKi9cbmZ1bmN0aW9uIHNldFN0eWxlKGNzc1J1bGUsIHByb3AsIHZhbHVlKSB7XG4gIHRyeSB7XG4gICAgdmFyIGNzc1ZhbHVlID0gdmFsdWU7XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIGNzc1ZhbHVlID0gKDAsIF90b0Nzc1ZhbHVlMlsnZGVmYXVsdCddKSh2YWx1ZSwgdHJ1ZSk7XG5cbiAgICAgIGlmICh2YWx1ZVt2YWx1ZS5sZW5ndGggLSAxXSA9PT0gJyFpbXBvcnRhbnQnKSB7XG4gICAgICAgIGNzc1J1bGUuc3R5bGUuc2V0UHJvcGVydHkocHJvcCwgY3NzVmFsdWUsICdpbXBvcnRhbnQnKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY3NzUnVsZS5zdHlsZS5zZXRQcm9wZXJ0eShwcm9wLCBjc3NWYWx1ZSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIElFIG1heSB0aHJvdyBpZiBwcm9wZXJ0eSBpcyB1bmtub3duLlxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxudmFyIENTU1J1bGVUeXBlcyA9IHtcbiAgU1RZTEVfUlVMRTogMSxcbiAgS0VZRlJBTUVTX1JVTEU6IDdcblxuICAvKipcbiAgICogR2V0IHRoZSBDU1MgUnVsZSBrZXkuXG4gICAqL1xuXG59O3ZhciBnZXRLZXkgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBleHRyYWN0S2V5ID0gZnVuY3Rpb24gZXh0cmFjdEtleShjc3NUZXh0KSB7XG4gICAgdmFyIGZyb20gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG4gICAgcmV0dXJuIGNzc1RleHQuc3Vic3RyKGZyb20sIGNzc1RleHQuaW5kZXhPZigneycpIC0gMSk7XG4gIH07XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChjc3NSdWxlKSB7XG4gICAgaWYgKGNzc1J1bGUudHlwZSA9PT0gQ1NTUnVsZVR5cGVzLlNUWUxFX1JVTEUpIHJldHVybiBjc3NSdWxlLnNlbGVjdG9yVGV4dDtcbiAgICBpZiAoY3NzUnVsZS50eXBlID09PSBDU1NSdWxlVHlwZXMuS0VZRlJBTUVTX1JVTEUpIHtcbiAgICAgIHZhciBuYW1lID0gY3NzUnVsZS5uYW1lO1xuXG4gICAgICBpZiAobmFtZSkgcmV0dXJuICdAa2V5ZnJhbWVzICcgKyBuYW1lO1xuXG4gICAgICAvLyBUaGVyZSBpcyBubyBydWxlLm5hbWUgaW4gdGhlIGZvbGxvd2luZyBicm93c2VyczpcbiAgICAgIC8vIC0gSUUgOVxuICAgICAgLy8gLSBTYWZhcmkgNy4xLjhcbiAgICAgIC8vIC0gTW9iaWxlIFNhZmFyaSA5LjAuMFxuICAgICAgdmFyIGNzc1RleHQgPSBjc3NSdWxlLmNzc1RleHQ7XG5cbiAgICAgIHJldHVybiAnQCcgKyBleHRyYWN0S2V5KGNzc1RleHQsIGNzc1RleHQuaW5kZXhPZigna2V5ZnJhbWVzJykpO1xuICAgIH1cblxuICAgIC8vIENvbmRpdGlvbmFscy5cbiAgICByZXR1cm4gZXh0cmFjdEtleShjc3NSdWxlLmNzc1RleHQpO1xuICB9O1xufSgpO1xuXG4vKipcbiAqIFNldCB0aGUgc2VsZWN0b3IuXG4gKi9cbmZ1bmN0aW9uIHNldFNlbGVjdG9yKGNzc1J1bGUsIHNlbGVjdG9yVGV4dCkge1xuICBjc3NSdWxlLnNlbGVjdG9yVGV4dCA9IHNlbGVjdG9yVGV4dDtcblxuICAvLyBSZXR1cm4gZmFsc2UgaWYgc2V0dGVyIHdhcyBub3Qgc3VjY2Vzc2Z1bC5cbiAgLy8gQ3VycmVudGx5IHdvcmtzIGluIGNocm9tZSBvbmx5LlxuICByZXR1cm4gY3NzUnVsZS5zZWxlY3RvclRleHQgPT09IHNlbGVjdG9yVGV4dDtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBgaGVhZGAgZWxlbWVudCB1cG9uIHRoZSBmaXJzdCBjYWxsIGFuZCBjYWNoZXMgaXQuXG4gKi9cbnZhciBnZXRIZWFkID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaGVhZCA9IHZvaWQgMDtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIWhlYWQpIGhlYWQgPSBkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF07XG4gICAgcmV0dXJuIGhlYWQ7XG4gIH07XG59KCk7XG5cbi8qKlxuICogR2V0cyBhIG1hcCBvZiBydWxlIGtleXMsIHdoZXJlIHRoZSBwcm9wZXJ0eSBpcyBhbiB1bmVzY2FwZWQga2V5IGFuZCB2YWx1ZVxuICogaXMgYSBwb3RlbnRpYWxseSBlc2NhcGVkIG9uZS5cbiAqIEl0IGlzIHVzZWQgdG8gaWRlbnRpZnkgQ1NTIHJ1bGVzIGFuZCB0aGUgY29ycmVzcG9uZGluZyBKU1MgcnVsZXMuIEFzIGFuIGlkZW50aWZpZXJcbiAqIGZvciBDU1NTdHlsZVJ1bGUgd2Ugbm9ybWFsbHkgdXNlIGBzZWxlY3RvclRleHRgLiBUaG91Z2ggaWYgb3JpZ2luYWwgc2VsZWN0b3IgdGV4dFxuICogY29udGFpbnMgZXNjYXBlZCBjb2RlIHBvaW50cyBlLmcuIGA6bm90KCNcXFxcMjApYCwgQ1NTT00gd2lsbCBjb21waWxlIGl0IHRvIGA6bm90KCMgKWBcbiAqIGFuZCBzbyBDU1MgcnVsZSdzIGBzZWxlY3RvclRleHRgIHdvbid0IG1hdGNoIEpTUyBydWxlIHNlbGVjdG9yLlxuICpcbiAqIGh0dHBzOi8vd3d3LnczLm9yZy9JbnRlcm5hdGlvbmFsL3F1ZXN0aW9ucy9xYS1lc2NhcGVzI2Nzc2VzY2FwZXNcbiAqL1xudmFyIGdldFVuZXNjYXBlZEtleXNNYXAgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdHlsZSA9IHZvaWQgMDtcbiAgdmFyIGlzQXR0YWNoZWQgPSBmYWxzZTtcblxuICByZXR1cm4gZnVuY3Rpb24gKHJ1bGVzKSB7XG4gICAgdmFyIG1hcCA9IHt9O1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mbG93L2lzc3Vlcy8yNjk2XG4gICAgaWYgKCFzdHlsZSkgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcnVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBydWxlID0gcnVsZXNbaV07XG4gICAgICBpZiAoIShydWxlIGluc3RhbmNlb2YgX1N0eWxlUnVsZTJbJ2RlZmF1bHQnXSkpIGNvbnRpbnVlO1xuICAgICAgdmFyIHNlbGVjdG9yID0gcnVsZS5zZWxlY3RvcjtcbiAgICAgIC8vIE9ubHkgdW5lc2NhcGUgc2VsZWN0b3Igb3ZlciBDU1NPTSBpZiBpdCBjb250YWlucyBhIGJhY2sgc2xhc2guXG5cbiAgICAgIGlmIChzZWxlY3RvciAmJiBzZWxlY3Rvci5pbmRleE9mKCdcXFxcJykgIT09IC0xKSB7XG4gICAgICAgIC8vIExhemlsbHkgYXR0YWNoIHdoZW4gbmVlZGVkLlxuICAgICAgICBpZiAoIWlzQXR0YWNoZWQpIHtcbiAgICAgICAgICBnZXRIZWFkKCkuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuICAgICAgICAgIGlzQXR0YWNoZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHN0eWxlLnRleHRDb250ZW50ID0gc2VsZWN0b3IgKyAnIHt9JztcbiAgICAgICAgdmFyIF9zdHlsZSA9IHN0eWxlLFxuICAgICAgICAgICAgc2hlZXQgPSBfc3R5bGUuc2hlZXQ7XG5cbiAgICAgICAgaWYgKHNoZWV0KSB7XG4gICAgICAgICAgdmFyIGNzc1J1bGVzID0gc2hlZXQuY3NzUnVsZXM7XG5cbiAgICAgICAgICBpZiAoY3NzUnVsZXMpIG1hcFtjc3NSdWxlc1swXS5zZWxlY3RvclRleHRdID0gcnVsZS5rZXk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzQXR0YWNoZWQpIHtcbiAgICAgIGdldEhlYWQoKS5yZW1vdmVDaGlsZChzdHlsZSk7XG4gICAgICBpc0F0dGFjaGVkID0gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBtYXA7XG4gIH07XG59KCk7XG5cbi8qKlxuICogRmluZCBhdHRhY2hlZCBzaGVldCB3aXRoIGFuIGluZGV4IGhpZ2hlciB0aGFuIHRoZSBwYXNzZWQgb25lLlxuICovXG5mdW5jdGlvbiBmaW5kSGlnaGVyU2hlZXQocmVnaXN0cnksIG9wdGlvbnMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByZWdpc3RyeS5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzaGVldCA9IHJlZ2lzdHJ5W2ldO1xuICAgIGlmIChzaGVldC5hdHRhY2hlZCAmJiBzaGVldC5vcHRpb25zLmluZGV4ID4gb3B0aW9ucy5pbmRleCAmJiBzaGVldC5vcHRpb25zLmluc2VydGlvblBvaW50ID09PSBvcHRpb25zLmluc2VydGlvblBvaW50KSB7XG4gICAgICByZXR1cm4gc2hlZXQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIEZpbmQgYXR0YWNoZWQgc2hlZXQgd2l0aCB0aGUgaGlnaGVzdCBpbmRleC5cbiAqL1xuZnVuY3Rpb24gZmluZEhpZ2hlc3RTaGVldChyZWdpc3RyeSwgb3B0aW9ucykge1xuICBmb3IgKHZhciBpID0gcmVnaXN0cnkubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgc2hlZXQgPSByZWdpc3RyeVtpXTtcbiAgICBpZiAoc2hlZXQuYXR0YWNoZWQgJiYgc2hlZXQub3B0aW9ucy5pbnNlcnRpb25Qb2ludCA9PT0gb3B0aW9ucy5pbnNlcnRpb25Qb2ludCkge1xuICAgICAgcmV0dXJuIHNoZWV0O1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBGaW5kIGEgY29tbWVudCB3aXRoIFwianNzXCIgaW5zaWRlLlxuICovXG5mdW5jdGlvbiBmaW5kQ29tbWVudE5vZGUodGV4dCkge1xuICB2YXIgaGVhZCA9IGdldEhlYWQoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBoZWFkLmNoaWxkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbm9kZSA9IGhlYWQuY2hpbGROb2Rlc1tpXTtcbiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gOCAmJiBub2RlLm5vZGVWYWx1ZS50cmltKCkgPT09IHRleHQpIHtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBGaW5kIGEgbm9kZSBiZWZvcmUgd2hpY2ggd2UgY2FuIGluc2VydCB0aGUgc2hlZXQuXG4gKi9cbmZ1bmN0aW9uIGZpbmRQcmV2Tm9kZShvcHRpb25zKSB7XG4gIHZhciByZWdpc3RyeSA9IF9zaGVldHMyWydkZWZhdWx0J10ucmVnaXN0cnk7XG5cblxuICBpZiAocmVnaXN0cnkubGVuZ3RoID4gMCkge1xuICAgIC8vIFRyeSB0byBpbnNlcnQgYmVmb3JlIHRoZSBuZXh0IGhpZ2hlciBzaGVldC5cbiAgICB2YXIgc2hlZXQgPSBmaW5kSGlnaGVyU2hlZXQocmVnaXN0cnksIG9wdGlvbnMpO1xuICAgIGlmIChzaGVldCkgcmV0dXJuIHNoZWV0LnJlbmRlcmVyLmVsZW1lbnQ7XG5cbiAgICAvLyBPdGhlcndpc2UgaW5zZXJ0IGFmdGVyIHRoZSBsYXN0IGF0dGFjaGVkLlxuICAgIHNoZWV0ID0gZmluZEhpZ2hlc3RTaGVldChyZWdpc3RyeSwgb3B0aW9ucyk7XG4gICAgaWYgKHNoZWV0KSByZXR1cm4gc2hlZXQucmVuZGVyZXIuZWxlbWVudC5uZXh0RWxlbWVudFNpYmxpbmc7XG4gIH1cblxuICAvLyBUcnkgdG8gZmluZCBhIGNvbW1lbnQgcGxhY2Vob2xkZXIgaWYgcmVnaXN0cnkgaXMgZW1wdHkuXG4gIHZhciBpbnNlcnRpb25Qb2ludCA9IG9wdGlvbnMuaW5zZXJ0aW9uUG9pbnQ7XG5cbiAgaWYgKGluc2VydGlvblBvaW50ICYmIHR5cGVvZiBpbnNlcnRpb25Qb2ludCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgY29tbWVudCA9IGZpbmRDb21tZW50Tm9kZShpbnNlcnRpb25Qb2ludCk7XG4gICAgaWYgKGNvbW1lbnQpIHJldHVybiBjb21tZW50Lm5leHRTaWJsaW5nO1xuICAgIC8vIElmIHVzZXIgc3BlY2lmaWVzIGFuIGluc2VydGlvbiBwb2ludCBhbmQgaXQgY2FuJ3QgYmUgZm91bmQgaW4gdGhlIGRvY3VtZW50IC1cbiAgICAvLyBiYWQgc3BlY2lmaWNpdHkgaXNzdWVzIG1heSBhcHBlYXIuXG4gICAgKDAsIF93YXJuaW5nMlsnZGVmYXVsdCddKShpbnNlcnRpb25Qb2ludCA9PT0gJ2pzcycsICdbSlNTXSBJbnNlcnRpb24gcG9pbnQgXCIlc1wiIG5vdCBmb3VuZC4nLCBpbnNlcnRpb25Qb2ludCk7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBJbnNlcnQgc3R5bGUgZWxlbWVudCBpbnRvIHRoZSBET00uXG4gKi9cbmZ1bmN0aW9uIGluc2VydFN0eWxlKHN0eWxlLCBvcHRpb25zKSB7XG4gIHZhciBpbnNlcnRpb25Qb2ludCA9IG9wdGlvbnMuaW5zZXJ0aW9uUG9pbnQ7XG5cbiAgdmFyIHByZXZOb2RlID0gZmluZFByZXZOb2RlKG9wdGlvbnMpO1xuXG4gIGlmIChwcmV2Tm9kZSkge1xuICAgIHZhciBwYXJlbnROb2RlID0gcHJldk5vZGUucGFyZW50Tm9kZTtcblxuICAgIGlmIChwYXJlbnROb2RlKSBwYXJlbnROb2RlLmluc2VydEJlZm9yZShzdHlsZSwgcHJldk5vZGUpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIFdvcmtzIHdpdGggaWZyYW1lcyBhbmQgYW55IG5vZGUgdHlwZXMuXG4gIGlmIChpbnNlcnRpb25Qb2ludCAmJiB0eXBlb2YgaW5zZXJ0aW9uUG9pbnQubm9kZVR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNDEzMjg3MjgvZm9yY2UtY2FzdGluZy1pbi1mbG93XG4gICAgdmFyIGluc2VydGlvblBvaW50RWxlbWVudCA9IGluc2VydGlvblBvaW50O1xuICAgIHZhciBfcGFyZW50Tm9kZSA9IGluc2VydGlvblBvaW50RWxlbWVudC5wYXJlbnROb2RlO1xuXG4gICAgaWYgKF9wYXJlbnROb2RlKSBfcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoc3R5bGUsIGluc2VydGlvblBvaW50RWxlbWVudC5uZXh0U2libGluZyk7ZWxzZSAoMCwgX3dhcm5pbmcyWydkZWZhdWx0J10pKGZhbHNlLCAnW0pTU10gSW5zZXJ0aW9uIHBvaW50IGlzIG5vdCBpbiB0aGUgRE9NLicpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGdldEhlYWQoKS5pbnNlcnRCZWZvcmUoc3R5bGUsIHByZXZOb2RlKTtcbn1cblxudmFyIERvbVJlbmRlcmVyID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBEb21SZW5kZXJlcihzaGVldCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEb21SZW5kZXJlcik7XG5cbiAgICB0aGlzLmdldFN0eWxlID0gZ2V0U3R5bGU7XG4gICAgdGhpcy5zZXRTdHlsZSA9IHNldFN0eWxlO1xuICAgIHRoaXMuc2V0U2VsZWN0b3IgPSBzZXRTZWxlY3RvcjtcbiAgICB0aGlzLmdldEtleSA9IGdldEtleTtcbiAgICB0aGlzLmdldFVuZXNjYXBlZEtleXNNYXAgPSBnZXRVbmVzY2FwZWRLZXlzTWFwO1xuICAgIHRoaXMuaGFzSW5zZXJ0ZWRSdWxlcyA9IGZhbHNlO1xuXG4gICAgLy8gVGhlcmUgaXMgbm8gc2hlZXQgd2hlbiB0aGUgcmVuZGVyZXIgaXMgdXNlZCBmcm9tIGEgc3RhbmRhbG9uZSBTdHlsZVJ1bGUuXG4gICAgaWYgKHNoZWV0KSBfc2hlZXRzMlsnZGVmYXVsdCddLmFkZChzaGVldCk7XG5cbiAgICB0aGlzLnNoZWV0ID0gc2hlZXQ7XG5cbiAgICB2YXIgX3JlZiA9IHRoaXMuc2hlZXQgPyB0aGlzLnNoZWV0Lm9wdGlvbnMgOiB7fSxcbiAgICAgICAgbWVkaWEgPSBfcmVmLm1lZGlhLFxuICAgICAgICBtZXRhID0gX3JlZi5tZXRhLFxuICAgICAgICBlbGVtZW50ID0gX3JlZi5lbGVtZW50O1xuXG4gICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudCB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgIHRoaXMuZWxlbWVudC50eXBlID0gJ3RleHQvY3NzJztcbiAgICB0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKCdkYXRhLWpzcycsICcnKTtcbiAgICBpZiAobWVkaWEpIHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ21lZGlhJywgbWVkaWEpO1xuICAgIGlmIChtZXRhKSB0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKCdkYXRhLW1ldGEnLCBtZXRhKTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZXJzY29yZS1kYW5nbGVcbiAgICB2YXIgbm9uY2UgPSBnbG9iYWwuX193ZWJwYWNrX25vbmNlX187XG4gICAgaWYgKG5vbmNlKSB0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKCdub25jZScsIG5vbmNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnNlcnQgc3R5bGUgZWxlbWVudCBpbnRvIHJlbmRlciB0cmVlLlxuICAgKi9cblxuXG4gIC8vIEhUTUxTdHlsZUVsZW1lbnQgbmVlZHMgZml4aW5nIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mbG93L2lzc3Vlcy8yNjk2XG5cblxuICBfY3JlYXRlQ2xhc3MoRG9tUmVuZGVyZXIsIFt7XG4gICAga2V5OiAnYXR0YWNoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXR0YWNoKCkge1xuICAgICAgLy8gSW4gdGhlIGNhc2UgdGhlIGVsZW1lbnQgbm9kZSBpcyBleHRlcm5hbCBhbmQgaXQgaXMgYWxyZWFkeSBpbiB0aGUgRE9NLlxuICAgICAgaWYgKHRoaXMuZWxlbWVudC5wYXJlbnROb2RlIHx8ICF0aGlzLnNoZWV0KSByZXR1cm47XG5cbiAgICAgIC8vIFdoZW4gcnVsZXMgYXJlIGluc2VydGVkIHVzaW5nIGBpbnNlcnRSdWxlYCBBUEksIGFmdGVyIGBzaGVldC5kZXRhY2goKS5hdHRhY2goKWBcbiAgICAgIC8vIGJyb3dzZXJzIHJlbW92ZSB0aG9zZSBydWxlcy5cbiAgICAgIC8vIFRPRE8gZmlndXJlIG91dCBpZiBpdHMgYSBidWcgYW5kIGlmIGl0IGlzIGtub3duLlxuICAgICAgLy8gV29ya2Fyb3VuZCBpcyB0byByZWRlcGxveSB0aGUgc2hlZXQgYmVmb3JlIGF0dGFjaGluZyBhcyBhIHN0cmluZy5cbiAgICAgIGlmICh0aGlzLmhhc0luc2VydGVkUnVsZXMpIHtcbiAgICAgICAgdGhpcy5kZXBsb3koKTtcbiAgICAgICAgdGhpcy5oYXNJbnNlcnRlZFJ1bGVzID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGluc2VydFN0eWxlKHRoaXMuZWxlbWVudCwgdGhpcy5zaGVldC5vcHRpb25zKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgc3R5bGUgZWxlbWVudCBmcm9tIHJlbmRlciB0cmVlLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdkZXRhY2gnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXRhY2goKSB7XG4gICAgICB0aGlzLmVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmVsZW1lbnQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluamVjdCBDU1Mgc3RyaW5nIGludG8gZWxlbWVudC5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZGVwbG95JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVwbG95KCkge1xuICAgICAgaWYgKCF0aGlzLnNoZWV0KSByZXR1cm47XG4gICAgICB0aGlzLmVsZW1lbnQudGV4dENvbnRlbnQgPSAnXFxuJyArIHRoaXMuc2hlZXQudG9TdHJpbmcoKSArICdcXG4nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluc2VydCBhIHJ1bGUgaW50byBlbGVtZW50LlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdpbnNlcnRSdWxlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5zZXJ0UnVsZShydWxlLCBpbmRleCkge1xuICAgICAgdmFyIHNoZWV0ID0gdGhpcy5lbGVtZW50LnNoZWV0O1xuICAgICAgdmFyIGNzc1J1bGVzID0gc2hlZXQuY3NzUnVsZXM7XG5cbiAgICAgIHZhciBzdHIgPSBydWxlLnRvU3RyaW5nKCk7XG4gICAgICBpZiAoIWluZGV4KSBpbmRleCA9IGNzc1J1bGVzLmxlbmd0aDtcblxuICAgICAgaWYgKCFzdHIpIHJldHVybiBmYWxzZTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgc2hlZXQuaW5zZXJ0UnVsZShzdHIsIGluZGV4KTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAoMCwgX3dhcm5pbmcyWydkZWZhdWx0J10pKGZhbHNlLCAnW0pTU10gQ2FuIG5vdCBpbnNlcnQgYW4gdW5zdXBwb3J0ZWQgcnVsZSBcXG5cXHIlcycsIHJ1bGUpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB0aGlzLmhhc0luc2VydGVkUnVsZXMgPSB0cnVlO1xuXG4gICAgICByZXR1cm4gY3NzUnVsZXNbaW5kZXhdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBhIHJ1bGUuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2RlbGV0ZVJ1bGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWxldGVSdWxlKGNzc1J1bGUpIHtcbiAgICAgIHZhciBzaGVldCA9IHRoaXMuZWxlbWVudC5zaGVldDtcblxuICAgICAgdmFyIGluZGV4ID0gdGhpcy5pbmRleE9mKGNzc1J1bGUpO1xuICAgICAgaWYgKGluZGV4ID09PSAtMSkgcmV0dXJuIGZhbHNlO1xuICAgICAgc2hlZXQuZGVsZXRlUnVsZShpbmRleCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgaW5kZXggb2YgYSBDU1MgUnVsZS5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnaW5kZXhPZicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluZGV4T2YoY3NzUnVsZSkge1xuICAgICAgdmFyIGNzc1J1bGVzID0gdGhpcy5lbGVtZW50LnNoZWV0LmNzc1J1bGVzO1xuXG4gICAgICBmb3IgKHZhciBfaW5kZXggPSAwOyBfaW5kZXggPCBjc3NSdWxlcy5sZW5ndGg7IF9pbmRleCsrKSB7XG4gICAgICAgIGlmIChjc3NSdWxlID09PSBjc3NSdWxlc1tfaW5kZXhdKSByZXR1cm4gX2luZGV4O1xuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIGEgbmV3IENTUyBydWxlIGFuZCByZXBsYWNlIHRoZSBleGlzdGluZyBvbmUuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3JlcGxhY2VSdWxlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVwbGFjZVJ1bGUoY3NzUnVsZSwgcnVsZSkge1xuICAgICAgdmFyIGluZGV4ID0gdGhpcy5pbmRleE9mKGNzc1J1bGUpO1xuICAgICAgdmFyIG5ld0Nzc1J1bGUgPSB0aGlzLmluc2VydFJ1bGUocnVsZSwgaW5kZXgpO1xuICAgICAgdGhpcy5lbGVtZW50LnNoZWV0LmRlbGV0ZVJ1bGUoaW5kZXgpO1xuICAgICAgcmV0dXJuIG5ld0Nzc1J1bGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGFsbCBydWxlcyBlbGVtZW50cy5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZ2V0UnVsZXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRSdWxlcygpIHtcbiAgICAgIHJldHVybiB0aGlzLmVsZW1lbnQuc2hlZXQuY3NzUnVsZXM7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIERvbVJlbmRlcmVyO1xufSgpO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBEb21SZW5kZXJlcjsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbi8qIGVzbGludC1kaXNhYmxlIGNsYXNzLW1ldGhvZHMtdXNlLXRoaXMgKi9cblxuLyoqXG4gKiBSZW5kZXJpbmcgYmFja2VuZCB0byBkbyBub3RoaW5nIGluIG5vZGVqcy5cbiAqL1xudmFyIFZpcnR1YWxSZW5kZXJlciA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVmlydHVhbFJlbmRlcmVyKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBWaXJ0dWFsUmVuZGVyZXIpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFZpcnR1YWxSZW5kZXJlciwgW3tcbiAgICBrZXk6ICdzZXRTdHlsZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFN0eWxlKCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0U3R5bGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTdHlsZSgpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdzZXRTZWxlY3RvcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFNlbGVjdG9yKCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0S2V5JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0S2V5KCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2F0dGFjaCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGF0dGFjaCgpIHt9XG4gIH0sIHtcbiAgICBrZXk6ICdkZXRhY2gnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXRhY2goKSB7fVxuICB9LCB7XG4gICAga2V5OiAnZGVwbG95JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVwbG95KCkge31cbiAgfSwge1xuICAgIGtleTogJ2luc2VydFJ1bGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnNlcnRSdWxlKCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2RlbGV0ZVJ1bGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWxldGVSdWxlKCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncmVwbGFjZVJ1bGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXBsYWNlUnVsZSgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdnZXRSdWxlcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFJ1bGVzKCkge31cbiAgfSwge1xuICAgIGtleTogJ2luZGV4T2YnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbmRleE9mKCkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBWaXJ0dWFsUmVuZGVyZXI7XG59KCk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IFZpcnR1YWxSZW5kZXJlcjsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfUnVsZUxpc3QgPSByZXF1aXJlKCcuLi9SdWxlTGlzdCcpO1xuXG52YXIgX1J1bGVMaXN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1J1bGVMaXN0KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4vKipcbiAqIENvbmRpdGlvbmFsIHJ1bGUgZm9yIEBtZWRpYSwgQHN1cHBvcnRzXG4gKi9cbnZhciBDb25kaXRpb25hbFJ1bGUgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIENvbmRpdGlvbmFsUnVsZShrZXksIHN0eWxlcywgb3B0aW9ucykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDb25kaXRpb25hbFJ1bGUpO1xuXG4gICAgdGhpcy50eXBlID0gJ2NvbmRpdGlvbmFsJztcbiAgICB0aGlzLmlzUHJvY2Vzc2VkID0gZmFsc2U7XG5cbiAgICB0aGlzLmtleSA9IGtleTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMucnVsZXMgPSBuZXcgX1J1bGVMaXN0MlsnZGVmYXVsdCddKF9leHRlbmRzKHt9LCBvcHRpb25zLCB7IHBhcmVudDogdGhpcyB9KSk7XG5cbiAgICBmb3IgKHZhciBuYW1lIGluIHN0eWxlcykge1xuICAgICAgdGhpcy5ydWxlcy5hZGQobmFtZSwgc3R5bGVzW25hbWVdKTtcbiAgICB9XG5cbiAgICB0aGlzLnJ1bGVzLnByb2Nlc3MoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSBydWxlLlxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhDb25kaXRpb25hbFJ1bGUsIFt7XG4gICAga2V5OiAnZ2V0UnVsZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFJ1bGUobmFtZSkge1xuICAgICAgcmV0dXJuIHRoaXMucnVsZXMuZ2V0KG5hbWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBpbmRleCBvZiBhIHJ1bGUuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2luZGV4T2YnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbmRleE9mKHJ1bGUpIHtcbiAgICAgIHJldHVybiB0aGlzLnJ1bGVzLmluZGV4T2YocnVsZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuZCByZWdpc3RlciBydWxlLCBydW4gcGx1Z2lucy5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnYWRkUnVsZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZFJ1bGUobmFtZSwgc3R5bGUsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBydWxlID0gdGhpcy5ydWxlcy5hZGQobmFtZSwgc3R5bGUsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5vcHRpb25zLmpzcy5wbHVnaW5zLm9uUHJvY2Vzc1J1bGUocnVsZSk7XG4gICAgICByZXR1cm4gcnVsZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSBDU1Mgc3RyaW5nLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICd0b1N0cmluZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHsgaW5kZW50OiAxIH07XG5cbiAgICAgIHZhciBpbm5lciA9IHRoaXMucnVsZXMudG9TdHJpbmcob3B0aW9ucyk7XG4gICAgICByZXR1cm4gaW5uZXIgPyB0aGlzLmtleSArICcge1xcbicgKyBpbm5lciArICdcXG59JyA6ICcnO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBDb25kaXRpb25hbFJ1bGU7XG59KCk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IENvbmRpdGlvbmFsUnVsZTsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfdG9Dc3MgPSByZXF1aXJlKCcuLi91dGlscy90b0NzcycpO1xuXG52YXIgX3RvQ3NzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RvQ3NzKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgRm9udEZhY2VSdWxlID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBGb250RmFjZVJ1bGUoa2V5LCBzdHlsZSwgb3B0aW9ucykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBGb250RmFjZVJ1bGUpO1xuXG4gICAgdGhpcy50eXBlID0gJ2ZvbnQtZmFjZSc7XG4gICAgdGhpcy5pc1Byb2Nlc3NlZCA9IGZhbHNlO1xuXG4gICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgdGhpcy5zdHlsZSA9IHN0eWxlO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGVzIGEgQ1NTIHN0cmluZy5cbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoRm9udEZhY2VSdWxlLCBbe1xuICAgIGtleTogJ3RvU3RyaW5nJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcob3B0aW9ucykge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5zdHlsZSkpIHtcbiAgICAgICAgdmFyIHN0ciA9ICcnO1xuICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5zdHlsZS5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICBzdHIgKz0gKDAsIF90b0NzczJbJ2RlZmF1bHQnXSkodGhpcy5rZXksIHRoaXMuc3R5bGVbaW5kZXhdKTtcbiAgICAgICAgICBpZiAodGhpcy5zdHlsZVtpbmRleCArIDFdKSBzdHIgKz0gJ1xcbic7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICgwLCBfdG9Dc3MyWydkZWZhdWx0J10pKHRoaXMua2V5LCB0aGlzLnN0eWxlLCBvcHRpb25zKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRm9udEZhY2VSdWxlO1xufSgpO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBGb250RmFjZVJ1bGU7IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX1J1bGVMaXN0ID0gcmVxdWlyZSgnLi4vUnVsZUxpc3QnKTtcblxudmFyIF9SdWxlTGlzdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9SdWxlTGlzdCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuLyoqXG4gKiBSdWxlIGZvciBAa2V5ZnJhbWVzXG4gKi9cbnZhciBLZXlmcmFtZXNSdWxlID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBLZXlmcmFtZXNSdWxlKGtleSwgZnJhbWVzLCBvcHRpb25zKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEtleWZyYW1lc1J1bGUpO1xuXG4gICAgdGhpcy50eXBlID0gJ2tleWZyYW1lcyc7XG4gICAgdGhpcy5pc1Byb2Nlc3NlZCA9IGZhbHNlO1xuXG4gICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLnJ1bGVzID0gbmV3IF9SdWxlTGlzdDJbJ2RlZmF1bHQnXShfZXh0ZW5kcyh7fSwgb3B0aW9ucywgeyBwYXJlbnQ6IHRoaXMgfSkpO1xuXG4gICAgZm9yICh2YXIgbmFtZSBpbiBmcmFtZXMpIHtcbiAgICAgIHRoaXMucnVsZXMuYWRkKG5hbWUsIGZyYW1lc1tuYW1lXSwgX2V4dGVuZHMoe30sIHRoaXMub3B0aW9ucywge1xuICAgICAgICBwYXJlbnQ6IHRoaXMsXG4gICAgICAgIHNlbGVjdG9yOiBuYW1lXG4gICAgICB9KSk7XG4gICAgfVxuXG4gICAgdGhpcy5ydWxlcy5wcm9jZXNzKCk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGVzIGEgQ1NTIHN0cmluZy5cbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoS2V5ZnJhbWVzUnVsZSwgW3tcbiAgICBrZXk6ICd0b1N0cmluZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHsgaW5kZW50OiAxIH07XG5cbiAgICAgIHZhciBpbm5lciA9IHRoaXMucnVsZXMudG9TdHJpbmcob3B0aW9ucyk7XG4gICAgICBpZiAoaW5uZXIpIGlubmVyICs9ICdcXG4nO1xuICAgICAgcmV0dXJuIHRoaXMua2V5ICsgJyB7XFxuJyArIGlubmVyICsgJ30nO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBLZXlmcmFtZXNSdWxlO1xufSgpO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBLZXlmcmFtZXNSdWxlOyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIFNpbXBsZVJ1bGUgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFNpbXBsZVJ1bGUoa2V5LCB2YWx1ZSwgb3B0aW9ucykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTaW1wbGVSdWxlKTtcblxuICAgIHRoaXMudHlwZSA9ICdzaW1wbGUnO1xuICAgIHRoaXMuaXNQcm9jZXNzZWQgPSBmYWxzZTtcblxuICAgIHRoaXMua2V5ID0ga2V5O1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhIENTUyBzdHJpbmcuXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcblxuXG4gIF9jcmVhdGVDbGFzcyhTaW1wbGVSdWxlLCBbe1xuICAgIGtleTogJ3RvU3RyaW5nJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcob3B0aW9ucykge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy52YWx1ZSkpIHtcbiAgICAgICAgdmFyIHN0ciA9ICcnO1xuICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy52YWx1ZS5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICBzdHIgKz0gdGhpcy5rZXkgKyAnICcgKyB0aGlzLnZhbHVlW2luZGV4XSArICc7JztcbiAgICAgICAgICBpZiAodGhpcy52YWx1ZVtpbmRleCArIDFdKSBzdHIgKz0gJ1xcbic7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMua2V5ICsgJyAnICsgdGhpcy52YWx1ZSArICc7JztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU2ltcGxlUnVsZTtcbn0oKTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gU2ltcGxlUnVsZTsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF93YXJuaW5nID0gcmVxdWlyZSgnd2FybmluZycpO1xuXG52YXIgX3dhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd2FybmluZyk7XG5cbnZhciBfdG9Dc3MgPSByZXF1aXJlKCcuLi91dGlscy90b0NzcycpO1xuXG52YXIgX3RvQ3NzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RvQ3NzKTtcblxudmFyIF90b0Nzc1ZhbHVlID0gcmVxdWlyZSgnLi4vdXRpbHMvdG9Dc3NWYWx1ZScpO1xuXG52YXIgX3RvQ3NzVmFsdWUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdG9Dc3NWYWx1ZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIFN0eWxlUnVsZSA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU3R5bGVSdWxlKGtleSwgc3R5bGUsIG9wdGlvbnMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3R5bGVSdWxlKTtcblxuICAgIHRoaXMudHlwZSA9ICdzdHlsZSc7XG4gICAgdGhpcy5pc1Byb2Nlc3NlZCA9IGZhbHNlO1xuICAgIHZhciBzaGVldCA9IG9wdGlvbnMuc2hlZXQsXG4gICAgICAgIFJlbmRlcmVyID0gb3B0aW9ucy5SZW5kZXJlcixcbiAgICAgICAgc2VsZWN0b3IgPSBvcHRpb25zLnNlbGVjdG9yO1xuXG4gICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLnN0eWxlID0gc3R5bGU7XG4gICAgaWYgKHNlbGVjdG9yKSB0aGlzLnNlbGVjdG9yVGV4dCA9IHNlbGVjdG9yO1xuICAgIHRoaXMucmVuZGVyZXIgPSBzaGVldCA/IHNoZWV0LnJlbmRlcmVyIDogbmV3IFJlbmRlcmVyKCk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHNlbGVjdG9yIHN0cmluZy5cbiAgICogQXR0ZW50aW9uOiB1c2UgdGhpcyB3aXRoIGNhdXRpb24uIE1vc3QgYnJvd3NlcnMgZGlkbid0IGltcGxlbWVudFxuICAgKiBzZWxlY3RvclRleHQgc2V0dGVyLCBzbyB0aGlzIG1heSByZXN1bHQgaW4gcmVyZW5kZXJpbmcgb2YgZW50aXJlIFN0eWxlIFNoZWV0LlxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhTdHlsZVJ1bGUsIFt7XG4gICAga2V5OiAncHJvcCcsXG5cblxuICAgIC8qKlxuICAgICAqIEdldCBvciBzZXQgYSBzdHlsZSBwcm9wZXJ0eS5cbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJvcChuYW1lLCBuZXh0VmFsdWUpIHtcbiAgICAgIC8vIEl0J3MgYSBzZXR0ZXIuXG4gICAgICBpZiAobmV4dFZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgLy8gRG9uJ3QgZG8gYW55dGhpbmcgaWYgdGhlIHZhbHVlIGhhcyBub3QgY2hhbmdlZC5cbiAgICAgICAgaWYgKHRoaXMuc3R5bGVbbmFtZV0gIT09IG5leHRWYWx1ZSkge1xuICAgICAgICAgIG5leHRWYWx1ZSA9IHRoaXMub3B0aW9ucy5qc3MucGx1Z2lucy5vbkNoYW5nZVZhbHVlKG5leHRWYWx1ZSwgbmFtZSwgdGhpcyk7XG4gICAgICAgICAgdGhpcy5zdHlsZVtuYW1lXSA9IG5leHRWYWx1ZTtcblxuICAgICAgICAgIC8vIFJlbmRlcmFibGUgaXMgZGVmaW5lZCBpZiBTdHlsZVNoZWV0IG9wdGlvbiBgbGlua2AgaXMgdHJ1ZS5cbiAgICAgICAgICBpZiAodGhpcy5yZW5kZXJhYmxlKSB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKHRoaXMucmVuZGVyYWJsZSwgbmFtZSwgbmV4dFZhbHVlKTtlbHNlIHtcbiAgICAgICAgICAgIHZhciBzaGVldCA9IHRoaXMub3B0aW9ucy5zaGVldDtcblxuICAgICAgICAgICAgaWYgKHNoZWV0ICYmIHNoZWV0LmF0dGFjaGVkKSB7XG4gICAgICAgICAgICAgICgwLCBfd2FybmluZzJbJ2RlZmF1bHQnXSkoZmFsc2UsICdSdWxlIGlzIG5vdCBsaW5rZWQuIE1pc3Npbmcgc2hlZXQgb3B0aW9uIFwibGluazogdHJ1ZVwiLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuc3R5bGVbbmFtZV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXBwbHkgcnVsZSB0byBhbiBlbGVtZW50IGlubGluZS5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnYXBwbHlUbycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFwcGx5VG8ocmVuZGVyYWJsZSkge1xuICAgICAgdmFyIGpzb24gPSB0aGlzLnRvSlNPTigpO1xuICAgICAgZm9yICh2YXIgcHJvcCBpbiBqc29uKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUocmVuZGVyYWJsZSwgcHJvcCwganNvbltwcm9wXSk7XG4gICAgICB9cmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBKU09OIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBydWxlLlxuICAgICAqIEZhbGxiYWNrcyBhcmUgbm90IHN1cHBvcnRlZC5cbiAgICAgKiBVc2VmdWwgZm9yIGlubGluZSBzdHlsZXMuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3RvSlNPTicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgIHZhciBqc29uID0ge307XG4gICAgICBmb3IgKHZhciBwcm9wIGluIHRoaXMuc3R5bGUpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5zdHlsZVtwcm9wXTtcbiAgICAgICAgaWYgKCh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHZhbHVlKSkgIT09ICdvYmplY3QnKSBqc29uW3Byb3BdID0gdmFsdWU7ZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIGpzb25bcHJvcF0gPSAoMCwgX3RvQ3NzVmFsdWUyWydkZWZhdWx0J10pKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBqc29uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhIENTUyBzdHJpbmcuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3RvU3RyaW5nJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcob3B0aW9ucykge1xuICAgICAgdmFyIHNoZWV0ID0gdGhpcy5vcHRpb25zLnNoZWV0O1xuXG4gICAgICB2YXIgbGluayA9IHNoZWV0ID8gc2hlZXQub3B0aW9ucy5saW5rIDogZmFsc2U7XG4gICAgICB2YXIgb3B0cyA9IGxpbmsgPyBfZXh0ZW5kcyh7fSwgb3B0aW9ucywgeyBhbGxvd0VtcHR5OiB0cnVlIH0pIDogb3B0aW9ucztcbiAgICAgIHJldHVybiAoMCwgX3RvQ3NzMlsnZGVmYXVsdCddKSh0aGlzLnNlbGVjdG9yLCB0aGlzLnN0eWxlLCBvcHRzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdzZWxlY3RvcicsXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQoc2VsZWN0b3IpIHtcbiAgICAgIGlmIChzZWxlY3RvciA9PT0gdGhpcy5zZWxlY3RvclRleHQpIHJldHVybjtcblxuICAgICAgdGhpcy5zZWxlY3RvclRleHQgPSBzZWxlY3RvcjtcblxuICAgICAgaWYgKHRoaXMucmVuZGVyYWJsZSkge1xuICAgICAgICB2YXIgaGFzQ2hhbmdlZCA9IHRoaXMucmVuZGVyZXIuc2V0U2VsZWN0b3IodGhpcy5yZW5kZXJhYmxlLCBzZWxlY3Rvcik7XG5cbiAgICAgICAgLy8gSWYgc2VsZWN0b3Igc2V0dGVyIGlzIG5vdCBpbXBsZW1lbnRlZCwgcmVyZW5kZXIgdGhlIHJ1bGUuXG4gICAgICAgIGlmICghaGFzQ2hhbmdlZCAmJiB0aGlzLnJlbmRlcmFibGUpIHtcbiAgICAgICAgICB2YXIgcmVuZGVyYWJsZSA9IHRoaXMucmVuZGVyZXIucmVwbGFjZVJ1bGUodGhpcy5yZW5kZXJhYmxlLCB0aGlzKTtcbiAgICAgICAgICBpZiAocmVuZGVyYWJsZSkgdGhpcy5yZW5kZXJhYmxlID0gcmVuZGVyYWJsZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBzZWxlY3RvciBzdHJpbmcuXG4gICAgICovXG4gICAgLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0b3JUZXh0O1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTdHlsZVJ1bGU7XG59KCk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IFN0eWxlUnVsZTsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfdG9Dc3MgPSByZXF1aXJlKCcuLi91dGlscy90b0NzcycpO1xuXG52YXIgX3RvQ3NzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RvQ3NzKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgVmlld3BvcnRSdWxlID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBWaWV3cG9ydFJ1bGUoa2V5LCBzdHlsZSwgb3B0aW9ucykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBWaWV3cG9ydFJ1bGUpO1xuXG4gICAgdGhpcy50eXBlID0gJ3ZpZXdwb3J0JztcbiAgICB0aGlzLmlzUHJvY2Vzc2VkID0gZmFsc2U7XG5cbiAgICB0aGlzLmtleSA9IGtleTtcbiAgICB0aGlzLnN0eWxlID0gc3R5bGU7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYSBDU1Mgc3RyaW5nLlxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhWaWV3cG9ydFJ1bGUsIFt7XG4gICAga2V5OiAndG9TdHJpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZyhvcHRpb25zKSB7XG4gICAgICByZXR1cm4gKDAsIF90b0NzczJbJ2RlZmF1bHQnXSkodGhpcy5rZXksIHRoaXMuc3R5bGUsIG9wdGlvbnMpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBWaWV3cG9ydFJ1bGU7XG59KCk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IFZpZXdwb3J0UnVsZTsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfU2hlZXRzUmVnaXN0cnkgPSByZXF1aXJlKCcuL1NoZWV0c1JlZ2lzdHJ5Jyk7XG5cbnZhciBfU2hlZXRzUmVnaXN0cnkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU2hlZXRzUmVnaXN0cnkpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbi8qKlxuICogVGhpcyBpcyBhIGdsb2JhbCBzaGVldHMgcmVnaXN0cnkuIE9ubHkgRG9tUmVuZGVyZXIgd2lsbCBhZGQgc2hlZXRzIHRvIGl0LlxuICogT24gdGhlIHNlcnZlciBvbmUgc2hvdWxkIHVzZSBhbiBvd24gU2hlZXRzUmVnaXN0cnkgaW5zdGFuY2UgYW5kIGFkZCB0aGVcbiAqIHNoZWV0cyB0byBpdCwgYmVjYXVzZSB5b3UgbmVlZCB0byBtYWtlIHN1cmUgdG8gY3JlYXRlIGEgbmV3IHJlZ2lzdHJ5IGZvclxuICogZWFjaCByZXF1ZXN0IGluIG9yZGVyIHRvIG5vdCBsZWFrIHNoZWV0cyBhY3Jvc3MgcmVxdWVzdHMuXG4gKi9cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IG5ldyBfU2hlZXRzUmVnaXN0cnkyWydkZWZhdWx0J10oKTsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gY2xvbmVTdHlsZTtcblxudmFyIF9pc09ic2VydmFibGUgPSByZXF1aXJlKCcuL2lzT2JzZXJ2YWJsZScpO1xuXG52YXIgX2lzT2JzZXJ2YWJsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pc09ic2VydmFibGUpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcbmZ1bmN0aW9uIGNsb25lU3R5bGUoc3R5bGUpIHtcbiAgLy8gU3VwcG9ydCBlbXB0eSB2YWx1ZXMgaW4gY2FzZSB1c2VyIGVuZHMgdXAgd2l0aCB0aGVtIGJ5IGFjY2lkZW50LlxuICBpZiAoc3R5bGUgPT0gbnVsbCkgcmV0dXJuIHN0eWxlO1xuXG4gIC8vIFN1cHBvcnQgc3RyaW5nIHZhbHVlIGZvciBTaW1wbGVSdWxlLlxuICB2YXIgdHlwZU9mU3R5bGUgPSB0eXBlb2Ygc3R5bGUgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHN0eWxlKTtcblxuICBpZiAodHlwZU9mU3R5bGUgPT09ICdzdHJpbmcnIHx8IHR5cGVPZlN0eWxlID09PSAnbnVtYmVyJyB8fCB0eXBlT2ZTdHlsZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBzdHlsZTtcbiAgfVxuXG4gIC8vIFN1cHBvcnQgYXJyYXkgZm9yIEZvbnRGYWNlUnVsZS5cbiAgaWYgKGlzQXJyYXkoc3R5bGUpKSByZXR1cm4gc3R5bGUubWFwKGNsb25lU3R5bGUpO1xuXG4gIC8vIFN1cHBvcnQgT2JzZXJ2YWJsZSBzdHlsZXMuICBPYnNlcnZhYmxlcyBhcmUgaW1tdXRhYmxlLCBzbyB3ZSBkb24ndCBuZWVkIHRvXG4gIC8vIGNvcHkgdGhlbS5cbiAgaWYgKCgwLCBfaXNPYnNlcnZhYmxlMlsnZGVmYXVsdCddKShzdHlsZSkpIHJldHVybiBzdHlsZTtcblxuICB2YXIgbmV3U3R5bGUgPSB7fTtcbiAgZm9yICh2YXIgbmFtZSBpbiBzdHlsZSkge1xuICAgIHZhciB2YWx1ZSA9IHN0eWxlW25hbWVdO1xuICAgIGlmICgodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih2YWx1ZSkpID09PSAnb2JqZWN0Jykge1xuICAgICAgbmV3U3R5bGVbbmFtZV0gPSBjbG9uZVN0eWxlKHZhbHVlKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBuZXdTdHlsZVtuYW1lXSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG5ld1N0eWxlO1xufSIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF93YXJuaW5nID0gcmVxdWlyZSgnd2FybmluZycpO1xuXG52YXIgX3dhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd2FybmluZyk7XG5cbnZhciBfU3R5bGVTaGVldCA9IHJlcXVpcmUoJy4uL1N0eWxlU2hlZXQnKTtcblxudmFyIF9TdHlsZVNoZWV0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1N0eWxlU2hlZXQpO1xuXG52YXIgX21vZHVsZUlkID0gcmVxdWlyZSgnLi9tb2R1bGVJZCcpO1xuXG52YXIgX21vZHVsZUlkMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX21vZHVsZUlkKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgbWF4UnVsZXMgPSAxZTEwO1xuXG5cbnZhciBlbnYgPSBwcm9jZXNzLmVudi5OT0RFX0VOVjtcblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gd2hpY2ggZ2VuZXJhdGVzIHVuaXF1ZSBjbGFzcyBuYW1lcyBiYXNlZCBvbiBjb3VudGVycy5cbiAqIFdoZW4gbmV3IGdlbmVyYXRvciBmdW5jdGlvbiBpcyBjcmVhdGVkLCBydWxlIGNvdW50ZXIgaXMgcmVzZXRlZC5cbiAqIFdlIG5lZWQgdG8gcmVzZXQgdGhlIHJ1bGUgY291bnRlciBmb3IgU1NSIGZvciBlYWNoIHJlcXVlc3QuXG4gKi9cblxuZXhwb3J0c1snZGVmYXVsdCddID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcnVsZUNvdW50ZXIgPSAwO1xuICB2YXIgZGVmYXVsdFByZWZpeCA9IGVudiA9PT0gJ3Byb2R1Y3Rpb24nID8gJ2MnIDogJyc7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChydWxlLCBzaGVldCkge1xuICAgIHJ1bGVDb3VudGVyICs9IDE7XG5cbiAgICBpZiAocnVsZUNvdW50ZXIgPiBtYXhSdWxlcykge1xuICAgICAgKDAsIF93YXJuaW5nMlsnZGVmYXVsdCddKShmYWxzZSwgJ1tKU1NdIFlvdSBtaWdodCBoYXZlIGEgbWVtb3J5IGxlYWsuIFJ1bGUgY291bnRlciBpcyBhdCAlcy4nLCBydWxlQ291bnRlcik7XG4gICAgfVxuXG4gICAgdmFyIHByZWZpeCA9IGRlZmF1bHRQcmVmaXg7XG4gICAgdmFyIGpzc0lkID0gJyc7XG5cbiAgICBpZiAoc2hlZXQpIHtcbiAgICAgIHByZWZpeCA9IHNoZWV0Lm9wdGlvbnMuY2xhc3NOYW1lUHJlZml4IHx8IGRlZmF1bHRQcmVmaXg7XG4gICAgICBpZiAoc2hlZXQub3B0aW9ucy5qc3MuaWQgIT0gbnVsbCkganNzSWQgKz0gc2hlZXQub3B0aW9ucy5qc3MuaWQ7XG4gICAgfVxuXG4gICAgaWYgKGVudiA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICByZXR1cm4gJycgKyBwcmVmaXggKyBfbW9kdWxlSWQyWydkZWZhdWx0J10gKyBqc3NJZCArIHJ1bGVDb3VudGVyO1xuICAgIH1cblxuICAgIHJldHVybiBwcmVmaXggKyBydWxlLmtleSArICctJyArIF9tb2R1bGVJZDJbJ2RlZmF1bHQnXSArIChqc3NJZCAmJiAnLScgKyBqc3NJZCkgKyAnLScgKyBydWxlQ291bnRlcjtcbiAgfTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0c1snZGVmYXVsdCddID0gY3JlYXRlUnVsZTtcblxudmFyIF93YXJuaW5nID0gcmVxdWlyZSgnd2FybmluZycpO1xuXG52YXIgX3dhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd2FybmluZyk7XG5cbnZhciBfU3R5bGVSdWxlID0gcmVxdWlyZSgnLi4vcnVsZXMvU3R5bGVSdWxlJyk7XG5cbnZhciBfU3R5bGVSdWxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1N0eWxlUnVsZSk7XG5cbnZhciBfY2xvbmVTdHlsZSA9IHJlcXVpcmUoJy4uL3V0aWxzL2Nsb25lU3R5bGUnKTtcblxudmFyIF9jbG9uZVN0eWxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Nsb25lU3R5bGUpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbi8qKlxuICogQ3JlYXRlIGEgcnVsZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUnVsZSgpIHtcbiAgdmFyIG5hbWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6ICd1bm5hbWVkJztcbiAgdmFyIGRlY2wgPSBhcmd1bWVudHNbMV07XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzWzJdO1xuICB2YXIganNzID0gb3B0aW9ucy5qc3M7XG5cbiAgdmFyIGRlY2xDb3B5ID0gKDAsIF9jbG9uZVN0eWxlMlsnZGVmYXVsdCddKShkZWNsKTtcblxuICB2YXIgcnVsZSA9IGpzcy5wbHVnaW5zLm9uQ3JlYXRlUnVsZShuYW1lLCBkZWNsQ29weSwgb3B0aW9ucyk7XG4gIGlmIChydWxlKSByZXR1cm4gcnVsZTtcblxuICAvLyBJdCBpcyBhbiBhdC1ydWxlIGFuZCBpdCBoYXMgbm8gaW5zdGFuY2UuXG4gIGlmIChuYW1lWzBdID09PSAnQCcpIHtcbiAgICAoMCwgX3dhcm5pbmcyWydkZWZhdWx0J10pKGZhbHNlLCAnW0pTU10gVW5rbm93biBhdC1ydWxlICVzJywgbmFtZSk7XG4gIH1cblxuICByZXR1cm4gbmV3IF9TdHlsZVJ1bGUyWydkZWZhdWx0J10obmFtZSwgZGVjbENvcHksIG9wdGlvbnMpO1xufSIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbnZhciBDU1MgPSBnbG9iYWwuQ1NTO1xuXG52YXIgZW52ID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlY7XG5cbnZhciBlc2NhcGVSZWdleCA9IC8oW1tcXF0uIyokPjwrfj18XjooKSxcIidgXSkvZztcblxuZXhwb3J0c1snZGVmYXVsdCddID0gZnVuY3Rpb24gKHN0cikge1xuICAvLyBXZSBkb24ndCBuZWVkIHRvIGVzY2FwZSBpdCBpbiBwcm9kdWN0aW9uLCBiZWNhdXNlIHdlIGFyZSBub3QgdXNpbmcgdXNlcidzXG4gIC8vIGlucHV0IGZvciBzZWxlY3RvcnMsIHdlIGFyZSBnZW5lcmF0aW5nIGEgdmFsaWQgc2VsZWN0b3IuXG4gIGlmIChlbnYgPT09ICdwcm9kdWN0aW9uJykgcmV0dXJuIHN0cjtcblxuICBpZiAoIUNTUyB8fCAhQ1NTLmVzY2FwZSkge1xuICAgIHJldHVybiBzdHIucmVwbGFjZShlc2NhcGVSZWdleCwgJ1xcXFwkMScpO1xuICB9XG5cbiAgcmV0dXJuIENTUy5lc2NhcGUoc3RyKTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbi8qKlxuICogRXh0cmFjdHMgYSBzdHlsZXMgb2JqZWN0IHdpdGggb25seSBwcm9wcyB0aGF0IGNvbnRhaW4gZnVuY3Rpb24gdmFsdWVzLlxuICovXG5leHBvcnRzWydkZWZhdWx0J10gPSBmdW5jdGlvbiAoc3R5bGVzKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zaGFkb3dcbiAgZnVuY3Rpb24gZXh0cmFjdChzdHlsZXMpIHtcbiAgICB2YXIgdG8gPSBudWxsO1xuXG4gICAgZm9yICh2YXIga2V5IGluIHN0eWxlcykge1xuICAgICAgdmFyIHZhbHVlID0gc3R5bGVzW2tleV07XG4gICAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YodmFsdWUpO1xuXG4gICAgICBpZiAodHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBpZiAoIXRvKSB0byA9IHt9O1xuICAgICAgICB0b1trZXldID0gdmFsdWU7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICB2YXIgZXh0cmFjdGVkID0gZXh0cmFjdCh2YWx1ZSk7XG4gICAgICAgIGlmIChleHRyYWN0ZWQpIHtcbiAgICAgICAgICBpZiAoIXRvKSB0byA9IHt9O1xuICAgICAgICAgIHRvW2tleV0gPSBleHRyYWN0ZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdG87XG4gIH1cblxuICByZXR1cm4gZXh0cmFjdChzdHlsZXMpO1xufTsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfc3ltYm9sT2JzZXJ2YWJsZSA9IHJlcXVpcmUoJ3N5bWJvbC1vYnNlcnZhYmxlJyk7XG5cbnZhciBfc3ltYm9sT2JzZXJ2YWJsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zeW1ib2xPYnNlcnZhYmxlKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5leHBvcnRzWydkZWZhdWx0J10gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICYmIHZhbHVlW19zeW1ib2xPYnNlcnZhYmxlMlsnZGVmYXVsdCddXSAmJiB2YWx1ZSA9PT0gdmFsdWVbX3N5bWJvbE9ic2VydmFibGUyWydkZWZhdWx0J11dKCk7XG59OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xudmFyIHJlZ0V4cCA9IC8oW0EtWl0pL2c7XG52YXIgcmVwbGFjZSA9IGZ1bmN0aW9uIHJlcGxhY2Uoc3RyKSB7XG4gIHJldHVybiBcIi1cIiArIHN0ci50b0xvd2VyQ2FzZSgpO1xufTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZShyZWdFeHAsIHJlcGxhY2UpO1xufTsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbGlua1J1bGU7XG4vKipcbiAqIExpbmsgcnVsZSB3aXRoIENTU1N0eWxlUnVsZSBhbmQgbmVzdGVkIHJ1bGVzIHdpdGggY29ycmVzcG9uZGluZyBuZXN0ZWQgY3NzUnVsZXMgaWYgYm90aCBleGlzdHMuXG4gKi9cbmZ1bmN0aW9uIGxpbmtSdWxlKHJ1bGUsIGNzc1J1bGUpIHtcbiAgcnVsZS5yZW5kZXJhYmxlID0gY3NzUnVsZTtcbiAgaWYgKHJ1bGUucnVsZXMgJiYgY3NzUnVsZS5jc3NSdWxlcykgcnVsZS5ydWxlcy5saW5rKGNzc1J1bGUuY3NzUnVsZXMpO1xufSIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbnZhciBucyA9ICcyZjFhY2M2YzNhNjA2YjA4MmU1ZWVmNWU1NDQxNGZmYic7XG5pZiAoZ2xvYmFsW25zXSA9PSBudWxsKSBnbG9iYWxbbnNdID0gMDtcblxuLy8gQnVuZGxlIG1heSBjb250YWluIG11bHRpcGxlIEpTUyB2ZXJzaW9ucyBhdCB0aGUgc2FtZSB0aW1lLiBJbiBvcmRlciB0byBpZGVudGlmeVxuLy8gdGhlIGN1cnJlbnQgdmVyc2lvbiB3aXRoIGp1c3Qgb25lIHNob3J0IG51bWJlciBhbmQgdXNlIGl0IGZvciBjbGFzc2VzIGdlbmVyYXRpb25cbi8vIHdlIHVzZSBhIGNvdW50ZXIuIEFsc28gaXQgaXMgbW9yZSBhY2N1cmF0ZSwgYmVjYXVzZSB1c2VyIGNhbiBtYW51YWxseSByZWV2YWx1YXRlXG4vLyB0aGUgbW9kdWxlLlxuZXhwb3J0c1snZGVmYXVsdCddID0gZ2xvYmFsW25zXSsrOyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IHRvQ3NzO1xuXG52YXIgX3RvQ3NzVmFsdWUgPSByZXF1aXJlKCcuL3RvQ3NzVmFsdWUnKTtcblxudmFyIF90b0Nzc1ZhbHVlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RvQ3NzVmFsdWUpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbi8qKlxuICogSW5kZW50IGEgc3RyaW5nLlxuICogaHR0cDovL2pzcGVyZi5jb20vYXJyYXktam9pbi12cy1mb3JcbiAqL1xuZnVuY3Rpb24gaW5kZW50U3RyKHN0ciwgaW5kZW50KSB7XG4gIHZhciByZXN1bHQgPSAnJztcbiAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGluZGVudDsgaW5kZXgrKykge1xuICAgIHJlc3VsdCArPSAnICAnO1xuICB9cmV0dXJuIHJlc3VsdCArIHN0cjtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhIFJ1bGUgdG8gQ1NTIHN0cmluZy5cbiAqL1xuXG5mdW5jdGlvbiB0b0NzcyhzZWxlY3Rvciwgc3R5bGUpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuXG4gIHZhciByZXN1bHQgPSAnJztcblxuICBpZiAoIXN0eWxlKSByZXR1cm4gcmVzdWx0O1xuXG4gIHZhciBfb3B0aW9ucyRpbmRlbnQgPSBvcHRpb25zLmluZGVudCxcbiAgICAgIGluZGVudCA9IF9vcHRpb25zJGluZGVudCA9PT0gdW5kZWZpbmVkID8gMCA6IF9vcHRpb25zJGluZGVudDtcbiAgdmFyIGZhbGxiYWNrcyA9IHN0eWxlLmZhbGxiYWNrcztcblxuXG4gIGluZGVudCsrO1xuXG4gIC8vIEFwcGx5IGZhbGxiYWNrcyBmaXJzdC5cbiAgaWYgKGZhbGxiYWNrcykge1xuICAgIC8vIEFycmF5IHN5bnRheCB7ZmFsbGJhY2tzOiBbe3Byb3A6IHZhbHVlfV19XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZmFsbGJhY2tzKSkge1xuICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGZhbGxiYWNrcy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgdmFyIGZhbGxiYWNrID0gZmFsbGJhY2tzW2luZGV4XTtcbiAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBmYWxsYmFjaykge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IGZhbGxiYWNrW3Byb3BdO1xuICAgICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gJ1xcbicgKyBpbmRlbnRTdHIocHJvcCArICc6ICcgKyAoMCwgX3RvQ3NzVmFsdWUyWydkZWZhdWx0J10pKHZhbHVlKSArICc7JywgaW5kZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gT2JqZWN0IHN5bnRheCB7ZmFsbGJhY2tzOiB7cHJvcDogdmFsdWV9fVxuICAgIGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBfcHJvcCBpbiBmYWxsYmFja3MpIHtcbiAgICAgICAgICB2YXIgX3ZhbHVlID0gZmFsbGJhY2tzW19wcm9wXTtcbiAgICAgICAgICBpZiAoX3ZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSAnXFxuJyArIGluZGVudFN0cihfcHJvcCArICc6ICcgKyAoMCwgX3RvQ3NzVmFsdWUyWydkZWZhdWx0J10pKF92YWx1ZSkgKyAnOycsIGluZGVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gIH1cblxuICBmb3IgKHZhciBfcHJvcDIgaW4gc3R5bGUpIHtcbiAgICB2YXIgX3ZhbHVlMiA9IHN0eWxlW19wcm9wMl07XG4gICAgaWYgKF92YWx1ZTIgIT0gbnVsbCAmJiBfcHJvcDIgIT09ICdmYWxsYmFja3MnKSB7XG4gICAgICByZXN1bHQgKz0gJ1xcbicgKyBpbmRlbnRTdHIoX3Byb3AyICsgJzogJyArICgwLCBfdG9Dc3NWYWx1ZTJbJ2RlZmF1bHQnXSkoX3ZhbHVlMikgKyAnOycsIGluZGVudCk7XG4gICAgfVxuICB9XG5cbiAgLy8gQWxsb3cgZW1wdHkgc3R5bGUgaW4gdGhpcyBjYXNlLCBiZWNhdXNlIHByb3BlcnRpZXMgd2lsbCBiZSBhZGRlZCBkeW5hbWljYWxseS5cbiAgaWYgKCFyZXN1bHQgJiYgIW9wdGlvbnMuYWxsb3dFbXB0eSkgcmV0dXJuIHJlc3VsdDtcblxuICBpbmRlbnQtLTtcbiAgcmVzdWx0ID0gaW5kZW50U3RyKHNlbGVjdG9yICsgJyB7JyArIHJlc3VsdCArICdcXG4nLCBpbmRlbnQpICsgaW5kZW50U3RyKCd9JywgaW5kZW50KTtcblxuICByZXR1cm4gcmVzdWx0O1xufSIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IHRvQ3NzVmFsdWU7XG52YXIgam9pbiA9IGZ1bmN0aW9uIGpvaW4odmFsdWUsIGJ5KSB7XG4gIHZhciByZXN1bHQgPSAnJztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgIC8vIFJlbW92ZSAhaW1wb3J0YW50IGZyb20gdGhlIHZhbHVlLCBpdCB3aWxsIGJlIHJlYWRkZWQgbGF0ZXIuXG4gICAgaWYgKHZhbHVlW2ldID09PSAnIWltcG9ydGFudCcpIGJyZWFrO1xuICAgIGlmIChyZXN1bHQpIHJlc3VsdCArPSBieTtcbiAgICByZXN1bHQgKz0gdmFsdWVbaV07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYXJyYXkgdmFsdWVzIHRvIHN0cmluZy5cbiAqXG4gKiBgbWFyZ2luOiBbWyc1cHgnLCAnMTBweCddXWAgPiBgbWFyZ2luOiA1cHggMTBweDtgXG4gKiBgYm9yZGVyOiBbJzFweCcsICcycHgnXWAgPiBgYm9yZGVyOiAxcHgsIDJweDtgXG4gKiBgbWFyZ2luOiBbWyc1cHgnLCAnMTBweCddLCAnIWltcG9ydGFudCddYCA+IGBtYXJnaW46IDVweCAxMHB4ICFpbXBvcnRhbnQ7YFxuICogYGNvbG9yOiBbJ3JlZCcsICFpbXBvcnRhbnRdYCA+IGBjb2xvcjogcmVkICFpbXBvcnRhbnQ7YFxuICovXG5mdW5jdGlvbiB0b0Nzc1ZhbHVlKHZhbHVlKSB7XG4gIHZhciBpZ25vcmVJbXBvcnRhbnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuXG4gIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHJldHVybiB2YWx1ZTtcblxuICB2YXIgY3NzVmFsdWUgPSAnJztcblxuICAvLyBTdXBwb3J0IHNwYWNlIHNlcGFyYXRlZCB2YWx1ZXMgdmlhIGBbWyc1cHgnLCAnMTBweCddXWAuXG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlWzBdKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh2YWx1ZVtpXSA9PT0gJyFpbXBvcnRhbnQnKSBicmVhaztcbiAgICAgIGlmIChjc3NWYWx1ZSkgY3NzVmFsdWUgKz0gJywgJztcbiAgICAgIGNzc1ZhbHVlICs9IGpvaW4odmFsdWVbaV0sICcgJyk7XG4gICAgfVxuICB9IGVsc2UgY3NzVmFsdWUgPSBqb2luKHZhbHVlLCAnLCAnKTtcblxuICAvLyBBZGQgIWltcG9ydGFudCwgYmVjYXVzZSBpdCB3YXMgaWdub3JlZC5cbiAgaWYgKCFpZ25vcmVJbXBvcnRhbnQgJiYgdmFsdWVbdmFsdWUubGVuZ3RoIC0gMV0gPT09ICchaW1wb3J0YW50Jykge1xuICAgIGNzc1ZhbHVlICs9ICcgIWltcG9ydGFudCc7XG4gIH1cblxuICByZXR1cm4gY3NzVmFsdWU7XG59IiwiLy8hIG1vbWVudC5qc1xuLy8hIHZlcnNpb24gOiAyLjIwLjFcbi8vISBhdXRob3JzIDogVGltIFdvb2QsIElza3JlbiBDaGVybmV2LCBNb21lbnQuanMgY29udHJpYnV0b3JzXG4vLyEgbGljZW5zZSA6IE1JVFxuLy8hIG1vbWVudGpzLmNvbVxuXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XG4gICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcbiAgICBnbG9iYWwubW9tZW50ID0gZmFjdG9yeSgpXG59KHRoaXMsIChmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxudmFyIGhvb2tDYWxsYmFjaztcblxuZnVuY3Rpb24gaG9va3MgKCkge1xuICAgIHJldHVybiBob29rQ2FsbGJhY2suYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn1cblxuLy8gVGhpcyBpcyBkb25lIHRvIHJlZ2lzdGVyIHRoZSBtZXRob2QgY2FsbGVkIHdpdGggbW9tZW50KClcbi8vIHdpdGhvdXQgY3JlYXRpbmcgY2lyY3VsYXIgZGVwZW5kZW5jaWVzLlxuZnVuY3Rpb24gc2V0SG9va0NhbGxiYWNrIChjYWxsYmFjaykge1xuICAgIGhvb2tDYWxsYmFjayA9IGNhbGxiYWNrO1xufVxuXG5mdW5jdGlvbiBpc0FycmF5KGlucHV0KSB7XG4gICAgcmV0dXJuIGlucHV0IGluc3RhbmNlb2YgQXJyYXkgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn1cblxuZnVuY3Rpb24gaXNPYmplY3QoaW5wdXQpIHtcbiAgICAvLyBJRTggd2lsbCB0cmVhdCB1bmRlZmluZWQgYW5kIG51bGwgYXMgb2JqZWN0IGlmIGl0IHdhc24ndCBmb3JcbiAgICAvLyBpbnB1dCAhPSBudWxsXG4gICAgcmV0dXJuIGlucHV0ICE9IG51bGwgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gJ1tvYmplY3QgT2JqZWN0XSc7XG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0RW1wdHkob2JqKSB7XG4gICAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKSB7XG4gICAgICAgIHJldHVybiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqKS5sZW5ndGggPT09IDApO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBrO1xuICAgICAgICBmb3IgKGsgaW4gb2JqKSB7XG4gICAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGspKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoaW5wdXQpIHtcbiAgICByZXR1cm4gaW5wdXQgPT09IHZvaWQgMDtcbn1cblxuZnVuY3Rpb24gaXNOdW1iZXIoaW5wdXQpIHtcbiAgICByZXR1cm4gdHlwZW9mIGlucHV0ID09PSAnbnVtYmVyJyB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBOdW1iZXJdJztcbn1cblxuZnVuY3Rpb24gaXNEYXRlKGlucHV0KSB7XG4gICAgcmV0dXJuIGlucHV0IGluc3RhbmNlb2YgRGF0ZSB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5cbmZ1bmN0aW9uIG1hcChhcnIsIGZuKSB7XG4gICAgdmFyIHJlcyA9IFtdLCBpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgcmVzLnB1c2goZm4oYXJyW2ldLCBpKSk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5cbmZ1bmN0aW9uIGhhc093blByb3AoYSwgYikge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYSwgYik7XG59XG5cbmZ1bmN0aW9uIGV4dGVuZChhLCBiKSB7XG4gICAgZm9yICh2YXIgaSBpbiBiKSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wKGIsIGkpKSB7XG4gICAgICAgICAgICBhW2ldID0gYltpXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoYXNPd25Qcm9wKGIsICd0b1N0cmluZycpKSB7XG4gICAgICAgIGEudG9TdHJpbmcgPSBiLnRvU3RyaW5nO1xuICAgIH1cblxuICAgIGlmIChoYXNPd25Qcm9wKGIsICd2YWx1ZU9mJykpIHtcbiAgICAgICAgYS52YWx1ZU9mID0gYi52YWx1ZU9mO1xuICAgIH1cblxuICAgIHJldHVybiBhO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVVVEMgKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0KSB7XG4gICAgcmV0dXJuIGNyZWF0ZUxvY2FsT3JVVEMoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QsIHRydWUpLnV0YygpO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0UGFyc2luZ0ZsYWdzKCkge1xuICAgIC8vIFdlIG5lZWQgdG8gZGVlcCBjbG9uZSB0aGlzIG9iamVjdC5cbiAgICByZXR1cm4ge1xuICAgICAgICBlbXB0eSAgICAgICAgICAgOiBmYWxzZSxcbiAgICAgICAgdW51c2VkVG9rZW5zICAgIDogW10sXG4gICAgICAgIHVudXNlZElucHV0ICAgICA6IFtdLFxuICAgICAgICBvdmVyZmxvdyAgICAgICAgOiAtMixcbiAgICAgICAgY2hhcnNMZWZ0T3ZlciAgIDogMCxcbiAgICAgICAgbnVsbElucHV0ICAgICAgIDogZmFsc2UsXG4gICAgICAgIGludmFsaWRNb250aCAgICA6IG51bGwsXG4gICAgICAgIGludmFsaWRGb3JtYXQgICA6IGZhbHNlLFxuICAgICAgICB1c2VySW52YWxpZGF0ZWQgOiBmYWxzZSxcbiAgICAgICAgaXNvICAgICAgICAgICAgIDogZmFsc2UsXG4gICAgICAgIHBhcnNlZERhdGVQYXJ0cyA6IFtdLFxuICAgICAgICBtZXJpZGllbSAgICAgICAgOiBudWxsLFxuICAgICAgICByZmMyODIyICAgICAgICAgOiBmYWxzZSxcbiAgICAgICAgd2Vla2RheU1pc21hdGNoIDogZmFsc2VcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBnZXRQYXJzaW5nRmxhZ3MobSkge1xuICAgIGlmIChtLl9wZiA9PSBudWxsKSB7XG4gICAgICAgIG0uX3BmID0gZGVmYXVsdFBhcnNpbmdGbGFncygpO1xuICAgIH1cbiAgICByZXR1cm4gbS5fcGY7XG59XG5cbnZhciBzb21lO1xuaWYgKEFycmF5LnByb3RvdHlwZS5zb21lKSB7XG4gICAgc29tZSA9IEFycmF5LnByb3RvdHlwZS5zb21lO1xufSBlbHNlIHtcbiAgICBzb21lID0gZnVuY3Rpb24gKGZ1bikge1xuICAgICAgICB2YXIgdCA9IE9iamVjdCh0aGlzKTtcbiAgICAgICAgdmFyIGxlbiA9IHQubGVuZ3RoID4+PiAwO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpIGluIHQgJiYgZnVuLmNhbGwodGhpcywgdFtpXSwgaSwgdCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBpc1ZhbGlkKG0pIHtcbiAgICBpZiAobS5faXNWYWxpZCA9PSBudWxsKSB7XG4gICAgICAgIHZhciBmbGFncyA9IGdldFBhcnNpbmdGbGFncyhtKTtcbiAgICAgICAgdmFyIHBhcnNlZFBhcnRzID0gc29tZS5jYWxsKGZsYWdzLnBhcnNlZERhdGVQYXJ0cywgZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgIHJldHVybiBpICE9IG51bGw7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgaXNOb3dWYWxpZCA9ICFpc05hTihtLl9kLmdldFRpbWUoKSkgJiZcbiAgICAgICAgICAgIGZsYWdzLm92ZXJmbG93IDwgMCAmJlxuICAgICAgICAgICAgIWZsYWdzLmVtcHR5ICYmXG4gICAgICAgICAgICAhZmxhZ3MuaW52YWxpZE1vbnRoICYmXG4gICAgICAgICAgICAhZmxhZ3MuaW52YWxpZFdlZWtkYXkgJiZcbiAgICAgICAgICAgICFmbGFncy53ZWVrZGF5TWlzbWF0Y2ggJiZcbiAgICAgICAgICAgICFmbGFncy5udWxsSW5wdXQgJiZcbiAgICAgICAgICAgICFmbGFncy5pbnZhbGlkRm9ybWF0ICYmXG4gICAgICAgICAgICAhZmxhZ3MudXNlckludmFsaWRhdGVkICYmXG4gICAgICAgICAgICAoIWZsYWdzLm1lcmlkaWVtIHx8IChmbGFncy5tZXJpZGllbSAmJiBwYXJzZWRQYXJ0cykpO1xuXG4gICAgICAgIGlmIChtLl9zdHJpY3QpIHtcbiAgICAgICAgICAgIGlzTm93VmFsaWQgPSBpc05vd1ZhbGlkICYmXG4gICAgICAgICAgICAgICAgZmxhZ3MuY2hhcnNMZWZ0T3ZlciA9PT0gMCAmJlxuICAgICAgICAgICAgICAgIGZsYWdzLnVudXNlZFRva2Vucy5sZW5ndGggPT09IDAgJiZcbiAgICAgICAgICAgICAgICBmbGFncy5iaWdIb3VyID09PSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoT2JqZWN0LmlzRnJvemVuID09IG51bGwgfHwgIU9iamVjdC5pc0Zyb3plbihtKSkge1xuICAgICAgICAgICAgbS5faXNWYWxpZCA9IGlzTm93VmFsaWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaXNOb3dWYWxpZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbS5faXNWYWxpZDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlSW52YWxpZCAoZmxhZ3MpIHtcbiAgICB2YXIgbSA9IGNyZWF0ZVVUQyhOYU4pO1xuICAgIGlmIChmbGFncyAhPSBudWxsKSB7XG4gICAgICAgIGV4dGVuZChnZXRQYXJzaW5nRmxhZ3MobSksIGZsYWdzKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhtKS51c2VySW52YWxpZGF0ZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBtO1xufVxuXG4vLyBQbHVnaW5zIHRoYXQgYWRkIHByb3BlcnRpZXMgc2hvdWxkIGFsc28gYWRkIHRoZSBrZXkgaGVyZSAobnVsbCB2YWx1ZSksXG4vLyBzbyB3ZSBjYW4gcHJvcGVybHkgY2xvbmUgb3Vyc2VsdmVzLlxudmFyIG1vbWVudFByb3BlcnRpZXMgPSBob29rcy5tb21lbnRQcm9wZXJ0aWVzID0gW107XG5cbmZ1bmN0aW9uIGNvcHlDb25maWcodG8sIGZyb20pIHtcbiAgICB2YXIgaSwgcHJvcCwgdmFsO1xuXG4gICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9pc0FNb21lbnRPYmplY3QpKSB7XG4gICAgICAgIHRvLl9pc0FNb21lbnRPYmplY3QgPSBmcm9tLl9pc0FNb21lbnRPYmplY3Q7XG4gICAgfVxuICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5faSkpIHtcbiAgICAgICAgdG8uX2kgPSBmcm9tLl9pO1xuICAgIH1cbiAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2YpKSB7XG4gICAgICAgIHRvLl9mID0gZnJvbS5fZjtcbiAgICB9XG4gICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9sKSkge1xuICAgICAgICB0by5fbCA9IGZyb20uX2w7XG4gICAgfVxuICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fc3RyaWN0KSkge1xuICAgICAgICB0by5fc3RyaWN0ID0gZnJvbS5fc3RyaWN0O1xuICAgIH1cbiAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX3R6bSkpIHtcbiAgICAgICAgdG8uX3R6bSA9IGZyb20uX3R6bTtcbiAgICB9XG4gICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9pc1VUQykpIHtcbiAgICAgICAgdG8uX2lzVVRDID0gZnJvbS5faXNVVEM7XG4gICAgfVxuICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fb2Zmc2V0KSkge1xuICAgICAgICB0by5fb2Zmc2V0ID0gZnJvbS5fb2Zmc2V0O1xuICAgIH1cbiAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX3BmKSkge1xuICAgICAgICB0by5fcGYgPSBnZXRQYXJzaW5nRmxhZ3MoZnJvbSk7XG4gICAgfVxuICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fbG9jYWxlKSkge1xuICAgICAgICB0by5fbG9jYWxlID0gZnJvbS5fbG9jYWxlO1xuICAgIH1cblxuICAgIGlmIChtb21lbnRQcm9wZXJ0aWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG1vbWVudFByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHByb3AgPSBtb21lbnRQcm9wZXJ0aWVzW2ldO1xuICAgICAgICAgICAgdmFsID0gZnJvbVtwcm9wXTtcbiAgICAgICAgICAgIGlmICghaXNVbmRlZmluZWQodmFsKSkge1xuICAgICAgICAgICAgICAgIHRvW3Byb3BdID0gdmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRvO1xufVxuXG52YXIgdXBkYXRlSW5Qcm9ncmVzcyA9IGZhbHNlO1xuXG4vLyBNb21lbnQgcHJvdG90eXBlIG9iamVjdFxuZnVuY3Rpb24gTW9tZW50KGNvbmZpZykge1xuICAgIGNvcHlDb25maWcodGhpcywgY29uZmlnKTtcbiAgICB0aGlzLl9kID0gbmV3IERhdGUoY29uZmlnLl9kICE9IG51bGwgPyBjb25maWcuX2QuZ2V0VGltZSgpIDogTmFOKTtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgIHRoaXMuX2QgPSBuZXcgRGF0ZShOYU4pO1xuICAgIH1cbiAgICAvLyBQcmV2ZW50IGluZmluaXRlIGxvb3AgaW4gY2FzZSB1cGRhdGVPZmZzZXQgY3JlYXRlcyBuZXcgbW9tZW50XG4gICAgLy8gb2JqZWN0cy5cbiAgICBpZiAodXBkYXRlSW5Qcm9ncmVzcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgdXBkYXRlSW5Qcm9ncmVzcyA9IHRydWU7XG4gICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldCh0aGlzKTtcbiAgICAgICAgdXBkYXRlSW5Qcm9ncmVzcyA9IGZhbHNlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaXNNb21lbnQgKG9iaikge1xuICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBNb21lbnQgfHwgKG9iaiAhPSBudWxsICYmIG9iai5faXNBTW9tZW50T2JqZWN0ICE9IG51bGwpO1xufVxuXG5mdW5jdGlvbiBhYnNGbG9vciAobnVtYmVyKSB7XG4gICAgaWYgKG51bWJlciA8IDApIHtcbiAgICAgICAgLy8gLTAgLT4gMFxuICAgICAgICByZXR1cm4gTWF0aC5jZWlsKG51bWJlcikgfHwgMDtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihudW1iZXIpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gdG9JbnQoYXJndW1lbnRGb3JDb2VyY2lvbikge1xuICAgIHZhciBjb2VyY2VkTnVtYmVyID0gK2FyZ3VtZW50Rm9yQ29lcmNpb24sXG4gICAgICAgIHZhbHVlID0gMDtcblxuICAgIGlmIChjb2VyY2VkTnVtYmVyICE9PSAwICYmIGlzRmluaXRlKGNvZXJjZWROdW1iZXIpKSB7XG4gICAgICAgIHZhbHVlID0gYWJzRmxvb3IoY29lcmNlZE51bWJlcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xufVxuXG4vLyBjb21wYXJlIHR3byBhcnJheXMsIHJldHVybiB0aGUgbnVtYmVyIG9mIGRpZmZlcmVuY2VzXG5mdW5jdGlvbiBjb21wYXJlQXJyYXlzKGFycmF5MSwgYXJyYXkyLCBkb250Q29udmVydCkge1xuICAgIHZhciBsZW4gPSBNYXRoLm1pbihhcnJheTEubGVuZ3RoLCBhcnJheTIubGVuZ3RoKSxcbiAgICAgICAgbGVuZ3RoRGlmZiA9IE1hdGguYWJzKGFycmF5MS5sZW5ndGggLSBhcnJheTIubGVuZ3RoKSxcbiAgICAgICAgZGlmZnMgPSAwLFxuICAgICAgICBpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAoKGRvbnRDb252ZXJ0ICYmIGFycmF5MVtpXSAhPT0gYXJyYXkyW2ldKSB8fFxuICAgICAgICAgICAgKCFkb250Q29udmVydCAmJiB0b0ludChhcnJheTFbaV0pICE9PSB0b0ludChhcnJheTJbaV0pKSkge1xuICAgICAgICAgICAgZGlmZnMrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGlmZnMgKyBsZW5ndGhEaWZmO1xufVxuXG5mdW5jdGlvbiB3YXJuKG1zZykge1xuICAgIGlmIChob29rcy5zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZ3MgPT09IGZhbHNlICYmXG4gICAgICAgICAgICAodHlwZW9mIGNvbnNvbGUgIT09ICAndW5kZWZpbmVkJykgJiYgY29uc29sZS53YXJuKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignRGVwcmVjYXRpb24gd2FybmluZzogJyArIG1zZyk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkZXByZWNhdGUobXNnLCBmbikge1xuICAgIHZhciBmaXJzdFRpbWUgPSB0cnVlO1xuXG4gICAgcmV0dXJuIGV4dGVuZChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChob29rcy5kZXByZWNhdGlvbkhhbmRsZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgaG9va3MuZGVwcmVjYXRpb25IYW5kbGVyKG51bGwsIG1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpcnN0VGltZSkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgIHZhciBhcmc7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGFyZyA9ICcnO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYXJndW1lbnRzW2ldID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICBhcmcgKz0gJ1xcblsnICsgaSArICddICc7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBhcmd1bWVudHNbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZyArPSBrZXkgKyAnOiAnICsgYXJndW1lbnRzWzBdW2tleV0gKyAnLCAnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGFyZyA9IGFyZy5zbGljZSgwLCAtMik7IC8vIFJlbW92ZSB0cmFpbGluZyBjb21tYSBhbmQgc3BhY2VcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhcmcgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFyZ3MucHVzaChhcmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2Fybihtc2cgKyAnXFxuQXJndW1lbnRzOiAnICsgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncykuam9pbignJykgKyAnXFxuJyArIChuZXcgRXJyb3IoKSkuc3RhY2spO1xuICAgICAgICAgICAgZmlyc3RUaW1lID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSwgZm4pO1xufVxuXG52YXIgZGVwcmVjYXRpb25zID0ge307XG5cbmZ1bmN0aW9uIGRlcHJlY2F0ZVNpbXBsZShuYW1lLCBtc2cpIHtcbiAgICBpZiAoaG9va3MuZGVwcmVjYXRpb25IYW5kbGVyICE9IG51bGwpIHtcbiAgICAgICAgaG9va3MuZGVwcmVjYXRpb25IYW5kbGVyKG5hbWUsIG1zZyk7XG4gICAgfVxuICAgIGlmICghZGVwcmVjYXRpb25zW25hbWVdKSB7XG4gICAgICAgIHdhcm4obXNnKTtcbiAgICAgICAgZGVwcmVjYXRpb25zW25hbWVdID0gdHJ1ZTtcbiAgICB9XG59XG5cbmhvb2tzLnN1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5ncyA9IGZhbHNlO1xuaG9va3MuZGVwcmVjYXRpb25IYW5kbGVyID0gbnVsbDtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihpbnB1dCkge1xuICAgIHJldHVybiBpbnB1dCBpbnN0YW5jZW9mIEZ1bmN0aW9uIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG59XG5cbmZ1bmN0aW9uIHNldCAoY29uZmlnKSB7XG4gICAgdmFyIHByb3AsIGk7XG4gICAgZm9yIChpIGluIGNvbmZpZykge1xuICAgICAgICBwcm9wID0gY29uZmlnW2ldO1xuICAgICAgICBpZiAoaXNGdW5jdGlvbihwcm9wKSkge1xuICAgICAgICAgICAgdGhpc1tpXSA9IHByb3A7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzWydfJyArIGldID0gcHJvcDtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9jb25maWcgPSBjb25maWc7XG4gICAgLy8gTGVuaWVudCBvcmRpbmFsIHBhcnNpbmcgYWNjZXB0cyBqdXN0IGEgbnVtYmVyIGluIGFkZGl0aW9uIHRvXG4gICAgLy8gbnVtYmVyICsgKHBvc3NpYmx5KSBzdHVmZiBjb21pbmcgZnJvbSBfZGF5T2ZNb250aE9yZGluYWxQYXJzZS5cbiAgICAvLyBUT0RPOiBSZW1vdmUgXCJvcmRpbmFsUGFyc2VcIiBmYWxsYmFjayBpbiBuZXh0IG1ham9yIHJlbGVhc2UuXG4gICAgdGhpcy5fZGF5T2ZNb250aE9yZGluYWxQYXJzZUxlbmllbnQgPSBuZXcgUmVnRXhwKFxuICAgICAgICAodGhpcy5fZGF5T2ZNb250aE9yZGluYWxQYXJzZS5zb3VyY2UgfHwgdGhpcy5fb3JkaW5hbFBhcnNlLnNvdXJjZSkgK1xuICAgICAgICAgICAgJ3wnICsgKC9cXGR7MSwyfS8pLnNvdXJjZSk7XG59XG5cbmZ1bmN0aW9uIG1lcmdlQ29uZmlncyhwYXJlbnRDb25maWcsIGNoaWxkQ29uZmlnKSB7XG4gICAgdmFyIHJlcyA9IGV4dGVuZCh7fSwgcGFyZW50Q29uZmlnKSwgcHJvcDtcbiAgICBmb3IgKHByb3AgaW4gY2hpbGRDb25maWcpIHtcbiAgICAgICAgaWYgKGhhc093blByb3AoY2hpbGRDb25maWcsIHByb3ApKSB7XG4gICAgICAgICAgICBpZiAoaXNPYmplY3QocGFyZW50Q29uZmlnW3Byb3BdKSAmJiBpc09iamVjdChjaGlsZENvbmZpZ1twcm9wXSkpIHtcbiAgICAgICAgICAgICAgICByZXNbcHJvcF0gPSB7fTtcbiAgICAgICAgICAgICAgICBleHRlbmQocmVzW3Byb3BdLCBwYXJlbnRDb25maWdbcHJvcF0pO1xuICAgICAgICAgICAgICAgIGV4dGVuZChyZXNbcHJvcF0sIGNoaWxkQ29uZmlnW3Byb3BdKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hpbGRDb25maWdbcHJvcF0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlc1twcm9wXSA9IGNoaWxkQ29uZmlnW3Byb3BdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgcmVzW3Byb3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAocHJvcCBpbiBwYXJlbnRDb25maWcpIHtcbiAgICAgICAgaWYgKGhhc093blByb3AocGFyZW50Q29uZmlnLCBwcm9wKSAmJlxuICAgICAgICAgICAgICAgICFoYXNPd25Qcm9wKGNoaWxkQ29uZmlnLCBwcm9wKSAmJlxuICAgICAgICAgICAgICAgIGlzT2JqZWN0KHBhcmVudENvbmZpZ1twcm9wXSkpIHtcbiAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSBjaGFuZ2VzIHRvIHByb3BlcnRpZXMgZG9uJ3QgbW9kaWZ5IHBhcmVudCBjb25maWdcbiAgICAgICAgICAgIHJlc1twcm9wXSA9IGV4dGVuZCh7fSwgcmVzW3Byb3BdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuXG5mdW5jdGlvbiBMb2NhbGUoY29uZmlnKSB7XG4gICAgaWYgKGNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMuc2V0KGNvbmZpZyk7XG4gICAgfVxufVxuXG52YXIga2V5cztcblxuaWYgKE9iamVjdC5rZXlzKSB7XG4gICAga2V5cyA9IE9iamVjdC5rZXlzO1xufSBlbHNlIHtcbiAgICBrZXlzID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICB2YXIgaSwgcmVzID0gW107XG4gICAgICAgIGZvciAoaSBpbiBvYmopIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wKG9iaiwgaSkpIHtcbiAgICAgICAgICAgICAgICByZXMucHVzaChpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG59XG5cbnZhciBkZWZhdWx0Q2FsZW5kYXIgPSB7XG4gICAgc2FtZURheSA6ICdbVG9kYXkgYXRdIExUJyxcbiAgICBuZXh0RGF5IDogJ1tUb21vcnJvdyBhdF0gTFQnLFxuICAgIG5leHRXZWVrIDogJ2RkZGQgW2F0XSBMVCcsXG4gICAgbGFzdERheSA6ICdbWWVzdGVyZGF5IGF0XSBMVCcsXG4gICAgbGFzdFdlZWsgOiAnW0xhc3RdIGRkZGQgW2F0XSBMVCcsXG4gICAgc2FtZUVsc2UgOiAnTCdcbn07XG5cbmZ1bmN0aW9uIGNhbGVuZGFyIChrZXksIG1vbSwgbm93KSB7XG4gICAgdmFyIG91dHB1dCA9IHRoaXMuX2NhbGVuZGFyW2tleV0gfHwgdGhpcy5fY2FsZW5kYXJbJ3NhbWVFbHNlJ107XG4gICAgcmV0dXJuIGlzRnVuY3Rpb24ob3V0cHV0KSA/IG91dHB1dC5jYWxsKG1vbSwgbm93KSA6IG91dHB1dDtcbn1cblxudmFyIGRlZmF1bHRMb25nRGF0ZUZvcm1hdCA9IHtcbiAgICBMVFMgIDogJ2g6bW06c3MgQScsXG4gICAgTFQgICA6ICdoOm1tIEEnLFxuICAgIEwgICAgOiAnTU0vREQvWVlZWScsXG4gICAgTEwgICA6ICdNTU1NIEQsIFlZWVknLFxuICAgIExMTCAgOiAnTU1NTSBELCBZWVlZIGg6bW0gQScsXG4gICAgTExMTCA6ICdkZGRkLCBNTU1NIEQsIFlZWVkgaDptbSBBJ1xufTtcblxuZnVuY3Rpb24gbG9uZ0RhdGVGb3JtYXQgKGtleSkge1xuICAgIHZhciBmb3JtYXQgPSB0aGlzLl9sb25nRGF0ZUZvcm1hdFtrZXldLFxuICAgICAgICBmb3JtYXRVcHBlciA9IHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleS50b1VwcGVyQ2FzZSgpXTtcblxuICAgIGlmIChmb3JtYXQgfHwgIWZvcm1hdFVwcGVyKSB7XG4gICAgICAgIHJldHVybiBmb3JtYXQ7XG4gICAgfVxuXG4gICAgdGhpcy5fbG9uZ0RhdGVGb3JtYXRba2V5XSA9IGZvcm1hdFVwcGVyLnJlcGxhY2UoL01NTU18TU18RER8ZGRkZC9nLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIHJldHVybiB2YWwuc2xpY2UoMSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcy5fbG9uZ0RhdGVGb3JtYXRba2V5XTtcbn1cblxudmFyIGRlZmF1bHRJbnZhbGlkRGF0ZSA9ICdJbnZhbGlkIGRhdGUnO1xuXG5mdW5jdGlvbiBpbnZhbGlkRGF0ZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ludmFsaWREYXRlO1xufVxuXG52YXIgZGVmYXVsdE9yZGluYWwgPSAnJWQnO1xudmFyIGRlZmF1bHREYXlPZk1vbnRoT3JkaW5hbFBhcnNlID0gL1xcZHsxLDJ9LztcblxuZnVuY3Rpb24gb3JkaW5hbCAobnVtYmVyKSB7XG4gICAgcmV0dXJuIHRoaXMuX29yZGluYWwucmVwbGFjZSgnJWQnLCBudW1iZXIpO1xufVxuXG52YXIgZGVmYXVsdFJlbGF0aXZlVGltZSA9IHtcbiAgICBmdXR1cmUgOiAnaW4gJXMnLFxuICAgIHBhc3QgICA6ICclcyBhZ28nLFxuICAgIHMgIDogJ2EgZmV3IHNlY29uZHMnLFxuICAgIHNzIDogJyVkIHNlY29uZHMnLFxuICAgIG0gIDogJ2EgbWludXRlJyxcbiAgICBtbSA6ICclZCBtaW51dGVzJyxcbiAgICBoICA6ICdhbiBob3VyJyxcbiAgICBoaCA6ICclZCBob3VycycsXG4gICAgZCAgOiAnYSBkYXknLFxuICAgIGRkIDogJyVkIGRheXMnLFxuICAgIE0gIDogJ2EgbW9udGgnLFxuICAgIE1NIDogJyVkIG1vbnRocycsXG4gICAgeSAgOiAnYSB5ZWFyJyxcbiAgICB5eSA6ICclZCB5ZWFycydcbn07XG5cbmZ1bmN0aW9uIHJlbGF0aXZlVGltZSAobnVtYmVyLCB3aXRob3V0U3VmZml4LCBzdHJpbmcsIGlzRnV0dXJlKSB7XG4gICAgdmFyIG91dHB1dCA9IHRoaXMuX3JlbGF0aXZlVGltZVtzdHJpbmddO1xuICAgIHJldHVybiAoaXNGdW5jdGlvbihvdXRwdXQpKSA/XG4gICAgICAgIG91dHB1dChudW1iZXIsIHdpdGhvdXRTdWZmaXgsIHN0cmluZywgaXNGdXR1cmUpIDpcbiAgICAgICAgb3V0cHV0LnJlcGxhY2UoLyVkL2ksIG51bWJlcik7XG59XG5cbmZ1bmN0aW9uIHBhc3RGdXR1cmUgKGRpZmYsIG91dHB1dCkge1xuICAgIHZhciBmb3JtYXQgPSB0aGlzLl9yZWxhdGl2ZVRpbWVbZGlmZiA+IDAgPyAnZnV0dXJlJyA6ICdwYXN0J107XG4gICAgcmV0dXJuIGlzRnVuY3Rpb24oZm9ybWF0KSA/IGZvcm1hdChvdXRwdXQpIDogZm9ybWF0LnJlcGxhY2UoLyVzL2ksIG91dHB1dCk7XG59XG5cbnZhciBhbGlhc2VzID0ge307XG5cbmZ1bmN0aW9uIGFkZFVuaXRBbGlhcyAodW5pdCwgc2hvcnRoYW5kKSB7XG4gICAgdmFyIGxvd2VyQ2FzZSA9IHVuaXQudG9Mb3dlckNhc2UoKTtcbiAgICBhbGlhc2VzW2xvd2VyQ2FzZV0gPSBhbGlhc2VzW2xvd2VyQ2FzZSArICdzJ10gPSBhbGlhc2VzW3Nob3J0aGFuZF0gPSB1bml0O1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVVbml0cyh1bml0cykge1xuICAgIHJldHVybiB0eXBlb2YgdW5pdHMgPT09ICdzdHJpbmcnID8gYWxpYXNlc1t1bml0c10gfHwgYWxpYXNlc1t1bml0cy50b0xvd2VyQ2FzZSgpXSA6IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplT2JqZWN0VW5pdHMoaW5wdXRPYmplY3QpIHtcbiAgICB2YXIgbm9ybWFsaXplZElucHV0ID0ge30sXG4gICAgICAgIG5vcm1hbGl6ZWRQcm9wLFxuICAgICAgICBwcm9wO1xuXG4gICAgZm9yIChwcm9wIGluIGlucHV0T2JqZWN0KSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wKGlucHV0T2JqZWN0LCBwcm9wKSkge1xuICAgICAgICAgICAgbm9ybWFsaXplZFByb3AgPSBub3JtYWxpemVVbml0cyhwcm9wKTtcbiAgICAgICAgICAgIGlmIChub3JtYWxpemVkUHJvcCkge1xuICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRJbnB1dFtub3JtYWxpemVkUHJvcF0gPSBpbnB1dE9iamVjdFtwcm9wXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBub3JtYWxpemVkSW5wdXQ7XG59XG5cbnZhciBwcmlvcml0aWVzID0ge307XG5cbmZ1bmN0aW9uIGFkZFVuaXRQcmlvcml0eSh1bml0LCBwcmlvcml0eSkge1xuICAgIHByaW9yaXRpZXNbdW5pdF0gPSBwcmlvcml0eTtcbn1cblxuZnVuY3Rpb24gZ2V0UHJpb3JpdGl6ZWRVbml0cyh1bml0c09iaikge1xuICAgIHZhciB1bml0cyA9IFtdO1xuICAgIGZvciAodmFyIHUgaW4gdW5pdHNPYmopIHtcbiAgICAgICAgdW5pdHMucHVzaCh7dW5pdDogdSwgcHJpb3JpdHk6IHByaW9yaXRpZXNbdV19KTtcbiAgICB9XG4gICAgdW5pdHMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gYS5wcmlvcml0eSAtIGIucHJpb3JpdHk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHVuaXRzO1xufVxuXG5mdW5jdGlvbiB6ZXJvRmlsbChudW1iZXIsIHRhcmdldExlbmd0aCwgZm9yY2VTaWduKSB7XG4gICAgdmFyIGFic051bWJlciA9ICcnICsgTWF0aC5hYnMobnVtYmVyKSxcbiAgICAgICAgemVyb3NUb0ZpbGwgPSB0YXJnZXRMZW5ndGggLSBhYnNOdW1iZXIubGVuZ3RoLFxuICAgICAgICBzaWduID0gbnVtYmVyID49IDA7XG4gICAgcmV0dXJuIChzaWduID8gKGZvcmNlU2lnbiA/ICcrJyA6ICcnKSA6ICctJykgK1xuICAgICAgICBNYXRoLnBvdygxMCwgTWF0aC5tYXgoMCwgemVyb3NUb0ZpbGwpKS50b1N0cmluZygpLnN1YnN0cigxKSArIGFic051bWJlcjtcbn1cblxudmFyIGZvcm1hdHRpbmdUb2tlbnMgPSAvKFxcW1teXFxbXSpcXF0pfChcXFxcKT8oW0hoXW1tKHNzKT98TW98TU0/TT9NP3xEb3xERERvfEREP0Q/RD98ZGRkP2Q/fGRvP3x3W298d10/fFdbb3xXXT98UW8/fFlZWVlZWXxZWVlZWXxZWVlZfFlZfGdnKGdnZz8pP3xHRyhHR0c/KT98ZXxFfGF8QXxoaD98SEg/fGtrP3xtbT98c3M/fFN7MSw5fXx4fFh8eno/fFpaP3wuKS9nO1xuXG52YXIgbG9jYWxGb3JtYXR0aW5nVG9rZW5zID0gLyhcXFtbXlxcW10qXFxdKXwoXFxcXCk/KExUU3xMVHxMTD9MP0w/fGx7MSw0fSkvZztcblxudmFyIGZvcm1hdEZ1bmN0aW9ucyA9IHt9O1xuXG52YXIgZm9ybWF0VG9rZW5GdW5jdGlvbnMgPSB7fTtcblxuLy8gdG9rZW46ICAgICdNJ1xuLy8gcGFkZGVkOiAgIFsnTU0nLCAyXVxuLy8gb3JkaW5hbDogICdNbydcbi8vIGNhbGxiYWNrOiBmdW5jdGlvbiAoKSB7IHRoaXMubW9udGgoKSArIDEgfVxuZnVuY3Rpb24gYWRkRm9ybWF0VG9rZW4gKHRva2VuLCBwYWRkZWQsIG9yZGluYWwsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGZ1bmMgPSBjYWxsYmFjaztcbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnc3RyaW5nJykge1xuICAgICAgICBmdW5jID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNbY2FsbGJhY2tdKCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmICh0b2tlbikge1xuICAgICAgICBmb3JtYXRUb2tlbkZ1bmN0aW9uc1t0b2tlbl0gPSBmdW5jO1xuICAgIH1cbiAgICBpZiAocGFkZGVkKSB7XG4gICAgICAgIGZvcm1hdFRva2VuRnVuY3Rpb25zW3BhZGRlZFswXV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gemVyb0ZpbGwoZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCBwYWRkZWRbMV0sIHBhZGRlZFsyXSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmIChvcmRpbmFsKSB7XG4gICAgICAgIGZvcm1hdFRva2VuRnVuY3Rpb25zW29yZGluYWxdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm9yZGluYWwoZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCB0b2tlbik7XG4gICAgICAgIH07XG4gICAgfVxufVxuXG5mdW5jdGlvbiByZW1vdmVGb3JtYXR0aW5nVG9rZW5zKGlucHV0KSB7XG4gICAgaWYgKGlucHV0Lm1hdGNoKC9cXFtbXFxzXFxTXS8pKSB7XG4gICAgICAgIHJldHVybiBpbnB1dC5yZXBsYWNlKC9eXFxbfFxcXSQvZywgJycpO1xuICAgIH1cbiAgICByZXR1cm4gaW5wdXQucmVwbGFjZSgvXFxcXC9nLCAnJyk7XG59XG5cbmZ1bmN0aW9uIG1ha2VGb3JtYXRGdW5jdGlvbihmb3JtYXQpIHtcbiAgICB2YXIgYXJyYXkgPSBmb3JtYXQubWF0Y2goZm9ybWF0dGluZ1Rva2VucyksIGksIGxlbmd0aDtcblxuICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChmb3JtYXRUb2tlbkZ1bmN0aW9uc1thcnJheVtpXV0pIHtcbiAgICAgICAgICAgIGFycmF5W2ldID0gZm9ybWF0VG9rZW5GdW5jdGlvbnNbYXJyYXlbaV1dO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXJyYXlbaV0gPSByZW1vdmVGb3JtYXR0aW5nVG9rZW5zKGFycmF5W2ldKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiAobW9tKSB7XG4gICAgICAgIHZhciBvdXRwdXQgPSAnJywgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBvdXRwdXQgKz0gaXNGdW5jdGlvbihhcnJheVtpXSkgPyBhcnJheVtpXS5jYWxsKG1vbSwgZm9ybWF0KSA6IGFycmF5W2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfTtcbn1cblxuLy8gZm9ybWF0IGRhdGUgdXNpbmcgbmF0aXZlIGRhdGUgb2JqZWN0XG5mdW5jdGlvbiBmb3JtYXRNb21lbnQobSwgZm9ybWF0KSB7XG4gICAgaWYgKCFtLmlzVmFsaWQoKSkge1xuICAgICAgICByZXR1cm4gbS5sb2NhbGVEYXRhKCkuaW52YWxpZERhdGUoKTtcbiAgICB9XG5cbiAgICBmb3JtYXQgPSBleHBhbmRGb3JtYXQoZm9ybWF0LCBtLmxvY2FsZURhdGEoKSk7XG4gICAgZm9ybWF0RnVuY3Rpb25zW2Zvcm1hdF0gPSBmb3JtYXRGdW5jdGlvbnNbZm9ybWF0XSB8fCBtYWtlRm9ybWF0RnVuY3Rpb24oZm9ybWF0KTtcblxuICAgIHJldHVybiBmb3JtYXRGdW5jdGlvbnNbZm9ybWF0XShtKTtcbn1cblxuZnVuY3Rpb24gZXhwYW5kRm9ybWF0KGZvcm1hdCwgbG9jYWxlKSB7XG4gICAgdmFyIGkgPSA1O1xuXG4gICAgZnVuY3Rpb24gcmVwbGFjZUxvbmdEYXRlRm9ybWF0VG9rZW5zKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUubG9uZ0RhdGVGb3JtYXQoaW5wdXQpIHx8IGlucHV0O1xuICAgIH1cblxuICAgIGxvY2FsRm9ybWF0dGluZ1Rva2Vucy5sYXN0SW5kZXggPSAwO1xuICAgIHdoaWxlIChpID49IDAgJiYgbG9jYWxGb3JtYXR0aW5nVG9rZW5zLnRlc3QoZm9ybWF0KSkge1xuICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZShsb2NhbEZvcm1hdHRpbmdUb2tlbnMsIHJlcGxhY2VMb25nRGF0ZUZvcm1hdFRva2Vucyk7XG4gICAgICAgIGxvY2FsRm9ybWF0dGluZ1Rva2Vucy5sYXN0SW5kZXggPSAwO1xuICAgICAgICBpIC09IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZvcm1hdDtcbn1cblxudmFyIG1hdGNoMSAgICAgICAgID0gL1xcZC87ICAgICAgICAgICAgLy8gICAgICAgMCAtIDlcbnZhciBtYXRjaDIgICAgICAgICA9IC9cXGRcXGQvOyAgICAgICAgICAvLyAgICAgIDAwIC0gOTlcbnZhciBtYXRjaDMgICAgICAgICA9IC9cXGR7M30vOyAgICAgICAgIC8vICAgICAwMDAgLSA5OTlcbnZhciBtYXRjaDQgICAgICAgICA9IC9cXGR7NH0vOyAgICAgICAgIC8vICAgIDAwMDAgLSA5OTk5XG52YXIgbWF0Y2g2ICAgICAgICAgPSAvWystXT9cXGR7Nn0vOyAgICAvLyAtOTk5OTk5IC0gOTk5OTk5XG52YXIgbWF0Y2gxdG8yICAgICAgPSAvXFxkXFxkPy87ICAgICAgICAgLy8gICAgICAgMCAtIDk5XG52YXIgbWF0Y2gzdG80ICAgICAgPSAvXFxkXFxkXFxkXFxkPy87ICAgICAvLyAgICAgOTk5IC0gOTk5OVxudmFyIG1hdGNoNXRvNiAgICAgID0gL1xcZFxcZFxcZFxcZFxcZFxcZD8vOyAvLyAgIDk5OTk5IC0gOTk5OTk5XG52YXIgbWF0Y2gxdG8zICAgICAgPSAvXFxkezEsM30vOyAgICAgICAvLyAgICAgICAwIC0gOTk5XG52YXIgbWF0Y2gxdG80ICAgICAgPSAvXFxkezEsNH0vOyAgICAgICAvLyAgICAgICAwIC0gOTk5OVxudmFyIG1hdGNoMXRvNiAgICAgID0gL1srLV0/XFxkezEsNn0vOyAgLy8gLTk5OTk5OSAtIDk5OTk5OVxuXG52YXIgbWF0Y2hVbnNpZ25lZCAgPSAvXFxkKy87ICAgICAgICAgICAvLyAgICAgICAwIC0gaW5mXG52YXIgbWF0Y2hTaWduZWQgICAgPSAvWystXT9cXGQrLzsgICAgICAvLyAgICAtaW5mIC0gaW5mXG5cbnZhciBtYXRjaE9mZnNldCAgICA9IC9afFsrLV1cXGRcXGQ6P1xcZFxcZC9naTsgLy8gKzAwOjAwIC0wMDowMCArMDAwMCAtMDAwMCBvciBaXG52YXIgbWF0Y2hTaG9ydE9mZnNldCA9IC9afFsrLV1cXGRcXGQoPzo6P1xcZFxcZCk/L2dpOyAvLyArMDAgLTAwICswMDowMCAtMDA6MDAgKzAwMDAgLTAwMDAgb3IgWlxuXG52YXIgbWF0Y2hUaW1lc3RhbXAgPSAvWystXT9cXGQrKFxcLlxcZHsxLDN9KT8vOyAvLyAxMjM0NTY3ODkgMTIzNDU2Nzg5LjEyM1xuXG4vLyBhbnkgd29yZCAob3IgdHdvKSBjaGFyYWN0ZXJzIG9yIG51bWJlcnMgaW5jbHVkaW5nIHR3by90aHJlZSB3b3JkIG1vbnRoIGluIGFyYWJpYy5cbi8vIGluY2x1ZGVzIHNjb3R0aXNoIGdhZWxpYyB0d28gd29yZCBhbmQgaHlwaGVuYXRlZCBtb250aHNcbnZhciBtYXRjaFdvcmQgPSAvWzAtOV17MCwyNTZ9WydhLXpcXHUwMEEwLVxcdTA1RkZcXHUwNzAwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGMDdcXHVGRjEwLVxcdUZGRUZdezEsMjU2fXxbXFx1MDYwMC1cXHUwNkZGXFwvXXsxLDI1Nn0oXFxzKj9bXFx1MDYwMC1cXHUwNkZGXXsxLDI1Nn0pezEsMn0vaTtcblxuXG52YXIgcmVnZXhlcyA9IHt9O1xuXG5mdW5jdGlvbiBhZGRSZWdleFRva2VuICh0b2tlbiwgcmVnZXgsIHN0cmljdFJlZ2V4KSB7XG4gICAgcmVnZXhlc1t0b2tlbl0gPSBpc0Z1bmN0aW9uKHJlZ2V4KSA/IHJlZ2V4IDogZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGVEYXRhKSB7XG4gICAgICAgIHJldHVybiAoaXNTdHJpY3QgJiYgc3RyaWN0UmVnZXgpID8gc3RyaWN0UmVnZXggOiByZWdleDtcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBnZXRQYXJzZVJlZ2V4Rm9yVG9rZW4gKHRva2VuLCBjb25maWcpIHtcbiAgICBpZiAoIWhhc093blByb3AocmVnZXhlcywgdG9rZW4pKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVnRXhwKHVuZXNjYXBlRm9ybWF0KHRva2VuKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlZ2V4ZXNbdG9rZW5dKGNvbmZpZy5fc3RyaWN0LCBjb25maWcuX2xvY2FsZSk7XG59XG5cbi8vIENvZGUgZnJvbSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzM1NjE0OTMvaXMtdGhlcmUtYS1yZWdleHAtZXNjYXBlLWZ1bmN0aW9uLWluLWphdmFzY3JpcHRcbmZ1bmN0aW9uIHVuZXNjYXBlRm9ybWF0KHMpIHtcbiAgICByZXR1cm4gcmVnZXhFc2NhcGUocy5yZXBsYWNlKCdcXFxcJywgJycpLnJlcGxhY2UoL1xcXFwoXFxbKXxcXFxcKFxcXSl8XFxbKFteXFxdXFxbXSopXFxdfFxcXFwoLikvZywgZnVuY3Rpb24gKG1hdGNoZWQsIHAxLCBwMiwgcDMsIHA0KSB7XG4gICAgICAgIHJldHVybiBwMSB8fCBwMiB8fCBwMyB8fCBwNDtcbiAgICB9KSk7XG59XG5cbmZ1bmN0aW9uIHJlZ2V4RXNjYXBlKHMpIHtcbiAgICByZXR1cm4gcy5yZXBsYWNlKC9bLVxcL1xcXFxeJCorPy4oKXxbXFxde31dL2csICdcXFxcJCYnKTtcbn1cblxudmFyIHRva2VucyA9IHt9O1xuXG5mdW5jdGlvbiBhZGRQYXJzZVRva2VuICh0b2tlbiwgY2FsbGJhY2spIHtcbiAgICB2YXIgaSwgZnVuYyA9IGNhbGxiYWNrO1xuICAgIGlmICh0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRva2VuID0gW3Rva2VuXTtcbiAgICB9XG4gICAgaWYgKGlzTnVtYmVyKGNhbGxiYWNrKSkge1xuICAgICAgICBmdW5jID0gZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICAgICAgYXJyYXlbY2FsbGJhY2tdID0gdG9JbnQoaW5wdXQpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgdG9rZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdG9rZW5zW3Rva2VuW2ldXSA9IGZ1bmM7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBhZGRXZWVrUGFyc2VUb2tlbiAodG9rZW4sIGNhbGxiYWNrKSB7XG4gICAgYWRkUGFyc2VUb2tlbih0b2tlbiwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnLCB0b2tlbikge1xuICAgICAgICBjb25maWcuX3cgPSBjb25maWcuX3cgfHwge307XG4gICAgICAgIGNhbGxiYWNrKGlucHV0LCBjb25maWcuX3csIGNvbmZpZywgdG9rZW4pO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBhZGRUaW1lVG9BcnJheUZyb21Ub2tlbih0b2tlbiwgaW5wdXQsIGNvbmZpZykge1xuICAgIGlmIChpbnB1dCAhPSBudWxsICYmIGhhc093blByb3AodG9rZW5zLCB0b2tlbikpIHtcbiAgICAgICAgdG9rZW5zW3Rva2VuXShpbnB1dCwgY29uZmlnLl9hLCBjb25maWcsIHRva2VuKTtcbiAgICB9XG59XG5cbnZhciBZRUFSID0gMDtcbnZhciBNT05USCA9IDE7XG52YXIgREFURSA9IDI7XG52YXIgSE9VUiA9IDM7XG52YXIgTUlOVVRFID0gNDtcbnZhciBTRUNPTkQgPSA1O1xudmFyIE1JTExJU0VDT05EID0gNjtcbnZhciBXRUVLID0gNztcbnZhciBXRUVLREFZID0gODtcblxuLy8gRk9STUFUVElOR1xuXG5hZGRGb3JtYXRUb2tlbignWScsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgeSA9IHRoaXMueWVhcigpO1xuICAgIHJldHVybiB5IDw9IDk5OTkgPyAnJyArIHkgOiAnKycgKyB5O1xufSk7XG5cbmFkZEZvcm1hdFRva2VuKDAsIFsnWVknLCAyXSwgMCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnllYXIoKSAlIDEwMDtcbn0pO1xuXG5hZGRGb3JtYXRUb2tlbigwLCBbJ1lZWVknLCAgIDRdLCAgICAgICAwLCAneWVhcicpO1xuYWRkRm9ybWF0VG9rZW4oMCwgWydZWVlZWScsICA1XSwgICAgICAgMCwgJ3llYXInKTtcbmFkZEZvcm1hdFRva2VuKDAsIFsnWVlZWVlZJywgNiwgdHJ1ZV0sIDAsICd5ZWFyJyk7XG5cbi8vIEFMSUFTRVNcblxuYWRkVW5pdEFsaWFzKCd5ZWFyJywgJ3knKTtcblxuLy8gUFJJT1JJVElFU1xuXG5hZGRVbml0UHJpb3JpdHkoJ3llYXInLCAxKTtcblxuLy8gUEFSU0lOR1xuXG5hZGRSZWdleFRva2VuKCdZJywgICAgICBtYXRjaFNpZ25lZCk7XG5hZGRSZWdleFRva2VuKCdZWScsICAgICBtYXRjaDF0bzIsIG1hdGNoMik7XG5hZGRSZWdleFRva2VuKCdZWVlZJywgICBtYXRjaDF0bzQsIG1hdGNoNCk7XG5hZGRSZWdleFRva2VuKCdZWVlZWScsICBtYXRjaDF0bzYsIG1hdGNoNik7XG5hZGRSZWdleFRva2VuKCdZWVlZWVknLCBtYXRjaDF0bzYsIG1hdGNoNik7XG5cbmFkZFBhcnNlVG9rZW4oWydZWVlZWScsICdZWVlZWVknXSwgWUVBUik7XG5hZGRQYXJzZVRva2VuKCdZWVlZJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgIGFycmF5W1lFQVJdID0gaW5wdXQubGVuZ3RoID09PSAyID8gaG9va3MucGFyc2VUd29EaWdpdFllYXIoaW5wdXQpIDogdG9JbnQoaW5wdXQpO1xufSk7XG5hZGRQYXJzZVRva2VuKCdZWScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICBhcnJheVtZRUFSXSA9IGhvb2tzLnBhcnNlVHdvRGlnaXRZZWFyKGlucHV0KTtcbn0pO1xuYWRkUGFyc2VUb2tlbignWScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICBhcnJheVtZRUFSXSA9IHBhcnNlSW50KGlucHV0LCAxMCk7XG59KTtcblxuLy8gSEVMUEVSU1xuXG5mdW5jdGlvbiBkYXlzSW5ZZWFyKHllYXIpIHtcbiAgICByZXR1cm4gaXNMZWFwWWVhcih5ZWFyKSA/IDM2NiA6IDM2NTtcbn1cblxuZnVuY3Rpb24gaXNMZWFwWWVhcih5ZWFyKSB7XG4gICAgcmV0dXJuICh5ZWFyICUgNCA9PT0gMCAmJiB5ZWFyICUgMTAwICE9PSAwKSB8fCB5ZWFyICUgNDAwID09PSAwO1xufVxuXG4vLyBIT09LU1xuXG5ob29rcy5wYXJzZVR3b0RpZ2l0WWVhciA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgIHJldHVybiB0b0ludChpbnB1dCkgKyAodG9JbnQoaW5wdXQpID4gNjggPyAxOTAwIDogMjAwMCk7XG59O1xuXG4vLyBNT01FTlRTXG5cbnZhciBnZXRTZXRZZWFyID0gbWFrZUdldFNldCgnRnVsbFllYXInLCB0cnVlKTtcblxuZnVuY3Rpb24gZ2V0SXNMZWFwWWVhciAoKSB7XG4gICAgcmV0dXJuIGlzTGVhcFllYXIodGhpcy55ZWFyKCkpO1xufVxuXG5mdW5jdGlvbiBtYWtlR2V0U2V0ICh1bml0LCBrZWVwVGltZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHNldCQxKHRoaXMsIHVuaXQsIHZhbHVlKTtcbiAgICAgICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldCh0aGlzLCBrZWVwVGltZSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBnZXQodGhpcywgdW5pdCk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG5mdW5jdGlvbiBnZXQgKG1vbSwgdW5pdCkge1xuICAgIHJldHVybiBtb20uaXNWYWxpZCgpID9cbiAgICAgICAgbW9tLl9kWydnZXQnICsgKG1vbS5faXNVVEMgPyAnVVRDJyA6ICcnKSArIHVuaXRdKCkgOiBOYU47XG59XG5cbmZ1bmN0aW9uIHNldCQxIChtb20sIHVuaXQsIHZhbHVlKSB7XG4gICAgaWYgKG1vbS5pc1ZhbGlkKCkgJiYgIWlzTmFOKHZhbHVlKSkge1xuICAgICAgICBpZiAodW5pdCA9PT0gJ0Z1bGxZZWFyJyAmJiBpc0xlYXBZZWFyKG1vbS55ZWFyKCkpICYmIG1vbS5tb250aCgpID09PSAxICYmIG1vbS5kYXRlKCkgPT09IDI5KSB7XG4gICAgICAgICAgICBtb20uX2RbJ3NldCcgKyAobW9tLl9pc1VUQyA/ICdVVEMnIDogJycpICsgdW5pdF0odmFsdWUsIG1vbS5tb250aCgpLCBkYXlzSW5Nb250aCh2YWx1ZSwgbW9tLm1vbnRoKCkpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1vbS5fZFsnc2V0JyArIChtb20uX2lzVVRDID8gJ1VUQycgOiAnJykgKyB1bml0XSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8vIE1PTUVOVFNcblxuZnVuY3Rpb24gc3RyaW5nR2V0ICh1bml0cykge1xuICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgIGlmIChpc0Z1bmN0aW9uKHRoaXNbdW5pdHNdKSkge1xuICAgICAgICByZXR1cm4gdGhpc1t1bml0c10oKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59XG5cblxuZnVuY3Rpb24gc3RyaW5nU2V0ICh1bml0cywgdmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHVuaXRzID09PSAnb2JqZWN0Jykge1xuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZU9iamVjdFVuaXRzKHVuaXRzKTtcbiAgICAgICAgdmFyIHByaW9yaXRpemVkID0gZ2V0UHJpb3JpdGl6ZWRVbml0cyh1bml0cyk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJpb3JpdGl6ZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXNbcHJpb3JpdGl6ZWRbaV0udW5pdF0odW5pdHNbcHJpb3JpdGl6ZWRbaV0udW5pdF0pO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKHRoaXNbdW5pdHNdKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNbdW5pdHNdKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn1cblxuZnVuY3Rpb24gbW9kKG4sIHgpIHtcbiAgICByZXR1cm4gKChuICUgeCkgKyB4KSAlIHg7XG59XG5cbnZhciBpbmRleE9mO1xuXG5pZiAoQXJyYXkucHJvdG90eXBlLmluZGV4T2YpIHtcbiAgICBpbmRleE9mID0gQXJyYXkucHJvdG90eXBlLmluZGV4T2Y7XG59IGVsc2Uge1xuICAgIGluZGV4T2YgPSBmdW5jdGlvbiAobykge1xuICAgICAgICAvLyBJIGtub3dcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAodGhpc1tpXSA9PT0gbykge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBkYXlzSW5Nb250aCh5ZWFyLCBtb250aCkge1xuICAgIGlmIChpc05hTih5ZWFyKSB8fCBpc05hTihtb250aCkpIHtcbiAgICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG4gICAgdmFyIG1vZE1vbnRoID0gbW9kKG1vbnRoLCAxMik7XG4gICAgeWVhciArPSAobW9udGggLSBtb2RNb250aCkgLyAxMjtcbiAgICByZXR1cm4gbW9kTW9udGggPT09IDEgPyAoaXNMZWFwWWVhcih5ZWFyKSA/IDI5IDogMjgpIDogKDMxIC0gbW9kTW9udGggJSA3ICUgMik7XG59XG5cbi8vIEZPUk1BVFRJTkdcblxuYWRkRm9ybWF0VG9rZW4oJ00nLCBbJ01NJywgMl0sICdNbycsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5tb250aCgpICsgMTtcbn0pO1xuXG5hZGRGb3JtYXRUb2tlbignTU1NJywgMCwgMCwgZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5tb250aHNTaG9ydCh0aGlzLCBmb3JtYXQpO1xufSk7XG5cbmFkZEZvcm1hdFRva2VuKCdNTU1NJywgMCwgMCwgZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5tb250aHModGhpcywgZm9ybWF0KTtcbn0pO1xuXG4vLyBBTElBU0VTXG5cbmFkZFVuaXRBbGlhcygnbW9udGgnLCAnTScpO1xuXG4vLyBQUklPUklUWVxuXG5hZGRVbml0UHJpb3JpdHkoJ21vbnRoJywgOCk7XG5cbi8vIFBBUlNJTkdcblxuYWRkUmVnZXhUb2tlbignTScsICAgIG1hdGNoMXRvMik7XG5hZGRSZWdleFRva2VuKCdNTScsICAgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuYWRkUmVnZXhUb2tlbignTU1NJywgIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgcmV0dXJuIGxvY2FsZS5tb250aHNTaG9ydFJlZ2V4KGlzU3RyaWN0KTtcbn0pO1xuYWRkUmVnZXhUb2tlbignTU1NTScsIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgcmV0dXJuIGxvY2FsZS5tb250aHNSZWdleChpc1N0cmljdCk7XG59KTtcblxuYWRkUGFyc2VUb2tlbihbJ00nLCAnTU0nXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgIGFycmF5W01PTlRIXSA9IHRvSW50KGlucHV0KSAtIDE7XG59KTtcblxuYWRkUGFyc2VUb2tlbihbJ01NTScsICdNTU1NJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZywgdG9rZW4pIHtcbiAgICB2YXIgbW9udGggPSBjb25maWcuX2xvY2FsZS5tb250aHNQYXJzZShpbnB1dCwgdG9rZW4sIGNvbmZpZy5fc3RyaWN0KTtcbiAgICAvLyBpZiB3ZSBkaWRuJ3QgZmluZCBhIG1vbnRoIG5hbWUsIG1hcmsgdGhlIGRhdGUgYXMgaW52YWxpZC5cbiAgICBpZiAobW9udGggIT0gbnVsbCkge1xuICAgICAgICBhcnJheVtNT05USF0gPSBtb250aDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5pbnZhbGlkTW9udGggPSBpbnB1dDtcbiAgICB9XG59KTtcblxuLy8gTE9DQUxFU1xuXG52YXIgTU9OVEhTX0lOX0ZPUk1BVCA9IC9EW29EXT8oXFxbW15cXFtcXF1dKlxcXXxcXHMpK01NTU0/LztcbnZhciBkZWZhdWx0TG9jYWxlTW9udGhzID0gJ0phbnVhcnlfRmVicnVhcnlfTWFyY2hfQXByaWxfTWF5X0p1bmVfSnVseV9BdWd1c3RfU2VwdGVtYmVyX09jdG9iZXJfTm92ZW1iZXJfRGVjZW1iZXInLnNwbGl0KCdfJyk7XG5mdW5jdGlvbiBsb2NhbGVNb250aHMgKG0sIGZvcm1hdCkge1xuICAgIGlmICghbSkge1xuICAgICAgICByZXR1cm4gaXNBcnJheSh0aGlzLl9tb250aHMpID8gdGhpcy5fbW9udGhzIDpcbiAgICAgICAgICAgIHRoaXMuX21vbnRoc1snc3RhbmRhbG9uZSddO1xuICAgIH1cbiAgICByZXR1cm4gaXNBcnJheSh0aGlzLl9tb250aHMpID8gdGhpcy5fbW9udGhzW20ubW9udGgoKV0gOlxuICAgICAgICB0aGlzLl9tb250aHNbKHRoaXMuX21vbnRocy5pc0Zvcm1hdCB8fCBNT05USFNfSU5fRk9STUFUKS50ZXN0KGZvcm1hdCkgPyAnZm9ybWF0JyA6ICdzdGFuZGFsb25lJ11bbS5tb250aCgpXTtcbn1cblxudmFyIGRlZmF1bHRMb2NhbGVNb250aHNTaG9ydCA9ICdKYW5fRmViX01hcl9BcHJfTWF5X0p1bl9KdWxfQXVnX1NlcF9PY3RfTm92X0RlYycuc3BsaXQoJ18nKTtcbmZ1bmN0aW9uIGxvY2FsZU1vbnRoc1Nob3J0IChtLCBmb3JtYXQpIHtcbiAgICBpZiAoIW0pIHtcbiAgICAgICAgcmV0dXJuIGlzQXJyYXkodGhpcy5fbW9udGhzU2hvcnQpID8gdGhpcy5fbW9udGhzU2hvcnQgOlxuICAgICAgICAgICAgdGhpcy5fbW9udGhzU2hvcnRbJ3N0YW5kYWxvbmUnXTtcbiAgICB9XG4gICAgcmV0dXJuIGlzQXJyYXkodGhpcy5fbW9udGhzU2hvcnQpID8gdGhpcy5fbW9udGhzU2hvcnRbbS5tb250aCgpXSA6XG4gICAgICAgIHRoaXMuX21vbnRoc1Nob3J0W01PTlRIU19JTl9GT1JNQVQudGVzdChmb3JtYXQpID8gJ2Zvcm1hdCcgOiAnc3RhbmRhbG9uZSddW20ubW9udGgoKV07XG59XG5cbmZ1bmN0aW9uIGhhbmRsZVN0cmljdFBhcnNlKG1vbnRoTmFtZSwgZm9ybWF0LCBzdHJpY3QpIHtcbiAgICB2YXIgaSwgaWksIG1vbSwgbGxjID0gbW9udGhOYW1lLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgaWYgKCF0aGlzLl9tb250aHNQYXJzZSkge1xuICAgICAgICAvLyB0aGlzIGlzIG5vdCB1c2VkXG4gICAgICAgIHRoaXMuX21vbnRoc1BhcnNlID0gW107XG4gICAgICAgIHRoaXMuX2xvbmdNb250aHNQYXJzZSA9IFtdO1xuICAgICAgICB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlID0gW107XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgKytpKSB7XG4gICAgICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIGldKTtcbiAgICAgICAgICAgIHRoaXMuX3Nob3J0TW9udGhzUGFyc2VbaV0gPSB0aGlzLm1vbnRoc1Nob3J0KG1vbSwgJycpLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB0aGlzLl9sb25nTW9udGhzUGFyc2VbaV0gPSB0aGlzLm1vbnRocyhtb20sICcnKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHN0cmljdCkge1xuICAgICAgICBpZiAoZm9ybWF0ID09PSAnTU1NJykge1xuICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRNb250aHNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9sb25nTW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ01NTScpIHtcbiAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0TW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbG9uZ01vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX2xvbmdNb250aHNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydE1vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gbG9jYWxlTW9udGhzUGFyc2UgKG1vbnRoTmFtZSwgZm9ybWF0LCBzdHJpY3QpIHtcbiAgICB2YXIgaSwgbW9tLCByZWdleDtcblxuICAgIGlmICh0aGlzLl9tb250aHNQYXJzZUV4YWN0KSB7XG4gICAgICAgIHJldHVybiBoYW5kbGVTdHJpY3RQYXJzZS5jYWxsKHRoaXMsIG1vbnRoTmFtZSwgZm9ybWF0LCBzdHJpY3QpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fbW9udGhzUGFyc2UpIHtcbiAgICAgICAgdGhpcy5fbW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgdGhpcy5fbG9uZ01vbnRoc1BhcnNlID0gW107XG4gICAgICAgIHRoaXMuX3Nob3J0TW9udGhzUGFyc2UgPSBbXTtcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBhZGQgc29ydGluZ1xuICAgIC8vIFNvcnRpbmcgbWFrZXMgc3VyZSBpZiBvbmUgbW9udGggKG9yIGFiYnIpIGlzIGEgcHJlZml4IG9mIGFub3RoZXJcbiAgICAvLyBzZWUgc29ydGluZyBpbiBjb21wdXRlTW9udGhzUGFyc2VcbiAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgICAvLyBtYWtlIHRoZSByZWdleCBpZiB3ZSBkb24ndCBoYXZlIGl0IGFscmVhZHlcbiAgICAgICAgbW9tID0gY3JlYXRlVVRDKFsyMDAwLCBpXSk7XG4gICAgICAgIGlmIChzdHJpY3QgJiYgIXRoaXMuX2xvbmdNb250aHNQYXJzZVtpXSkge1xuICAgICAgICAgICAgdGhpcy5fbG9uZ01vbnRoc1BhcnNlW2ldID0gbmV3IFJlZ0V4cCgnXicgKyB0aGlzLm1vbnRocyhtb20sICcnKS5yZXBsYWNlKCcuJywgJycpICsgJyQnLCAnaScpO1xuICAgICAgICAgICAgdGhpcy5fc2hvcnRNb250aHNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoJ14nICsgdGhpcy5tb250aHNTaG9ydChtb20sICcnKS5yZXBsYWNlKCcuJywgJycpICsgJyQnLCAnaScpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc3RyaWN0ICYmICF0aGlzLl9tb250aHNQYXJzZVtpXSkge1xuICAgICAgICAgICAgcmVnZXggPSAnXicgKyB0aGlzLm1vbnRocyhtb20sICcnKSArICd8XicgKyB0aGlzLm1vbnRoc1Nob3J0KG1vbSwgJycpO1xuICAgICAgICAgICAgdGhpcy5fbW9udGhzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKHJlZ2V4LnJlcGxhY2UoJy4nLCAnJyksICdpJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGVzdCB0aGUgcmVnZXhcbiAgICAgICAgaWYgKHN0cmljdCAmJiBmb3JtYXQgPT09ICdNTU1NJyAmJiB0aGlzLl9sb25nTW9udGhzUGFyc2VbaV0udGVzdChtb250aE5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfSBlbHNlIGlmIChzdHJpY3QgJiYgZm9ybWF0ID09PSAnTU1NJyAmJiB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlW2ldLnRlc3QobW9udGhOYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH0gZWxzZSBpZiAoIXN0cmljdCAmJiB0aGlzLl9tb250aHNQYXJzZVtpXS50ZXN0KG1vbnRoTmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vLyBNT01FTlRTXG5cbmZ1bmN0aW9uIHNldE1vbnRoIChtb20sIHZhbHVlKSB7XG4gICAgdmFyIGRheU9mTW9udGg7XG5cbiAgICBpZiAoIW1vbS5pc1ZhbGlkKCkpIHtcbiAgICAgICAgLy8gTm8gb3BcbiAgICAgICAgcmV0dXJuIG1vbTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAoL15cXGQrJC8udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdG9JbnQodmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUgPSBtb20ubG9jYWxlRGF0YSgpLm1vbnRoc1BhcnNlKHZhbHVlKTtcbiAgICAgICAgICAgIC8vIFRPRE86IEFub3RoZXIgc2lsZW50IGZhaWx1cmU/XG4gICAgICAgICAgICBpZiAoIWlzTnVtYmVyKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtb207XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkYXlPZk1vbnRoID0gTWF0aC5taW4obW9tLmRhdGUoKSwgZGF5c0luTW9udGgobW9tLnllYXIoKSwgdmFsdWUpKTtcbiAgICBtb20uX2RbJ3NldCcgKyAobW9tLl9pc1VUQyA/ICdVVEMnIDogJycpICsgJ01vbnRoJ10odmFsdWUsIGRheU9mTW9udGgpO1xuICAgIHJldHVybiBtb207XG59XG5cbmZ1bmN0aW9uIGdldFNldE1vbnRoICh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIHNldE1vbnRoKHRoaXMsIHZhbHVlKTtcbiAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KHRoaXMsIHRydWUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZ2V0KHRoaXMsICdNb250aCcpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZ2V0RGF5c0luTW9udGggKCkge1xuICAgIHJldHVybiBkYXlzSW5Nb250aCh0aGlzLnllYXIoKSwgdGhpcy5tb250aCgpKTtcbn1cblxudmFyIGRlZmF1bHRNb250aHNTaG9ydFJlZ2V4ID0gbWF0Y2hXb3JkO1xuZnVuY3Rpb24gbW9udGhzU2hvcnRSZWdleCAoaXNTdHJpY3QpIHtcbiAgICBpZiAodGhpcy5fbW9udGhzUGFyc2VFeGFjdCkge1xuICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ19tb250aHNSZWdleCcpKSB7XG4gICAgICAgICAgICBjb21wdXRlTW9udGhzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNTdHJpY3QpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHNTaG9ydFN0cmljdFJlZ2V4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1Nob3J0UmVnZXg7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ19tb250aHNTaG9ydFJlZ2V4JykpIHtcbiAgICAgICAgICAgIHRoaXMuX21vbnRoc1Nob3J0UmVnZXggPSBkZWZhdWx0TW9udGhzU2hvcnRSZWdleDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU2hvcnRTdHJpY3RSZWdleCAmJiBpc1N0cmljdCA/XG4gICAgICAgICAgICB0aGlzLl9tb250aHNTaG9ydFN0cmljdFJlZ2V4IDogdGhpcy5fbW9udGhzU2hvcnRSZWdleDtcbiAgICB9XG59XG5cbnZhciBkZWZhdWx0TW9udGhzUmVnZXggPSBtYXRjaFdvcmQ7XG5mdW5jdGlvbiBtb250aHNSZWdleCAoaXNTdHJpY3QpIHtcbiAgICBpZiAodGhpcy5fbW9udGhzUGFyc2VFeGFjdCkge1xuICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ19tb250aHNSZWdleCcpKSB7XG4gICAgICAgICAgICBjb21wdXRlTW9udGhzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNTdHJpY3QpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHNTdHJpY3RSZWdleDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHNSZWdleDtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX21vbnRoc1JlZ2V4JykpIHtcbiAgICAgICAgICAgIHRoaXMuX21vbnRoc1JlZ2V4ID0gZGVmYXVsdE1vbnRoc1JlZ2V4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9tb250aHNTdHJpY3RSZWdleCAmJiBpc1N0cmljdCA/XG4gICAgICAgICAgICB0aGlzLl9tb250aHNTdHJpY3RSZWdleCA6IHRoaXMuX21vbnRoc1JlZ2V4O1xuICAgIH1cbn1cblxuZnVuY3Rpb24gY29tcHV0ZU1vbnRoc1BhcnNlICgpIHtcbiAgICBmdW5jdGlvbiBjbXBMZW5SZXYoYSwgYikge1xuICAgICAgICByZXR1cm4gYi5sZW5ndGggLSBhLmxlbmd0aDtcbiAgICB9XG5cbiAgICB2YXIgc2hvcnRQaWVjZXMgPSBbXSwgbG9uZ1BpZWNlcyA9IFtdLCBtaXhlZFBpZWNlcyA9IFtdLFxuICAgICAgICBpLCBtb207XG4gICAgZm9yIChpID0gMDsgaSA8IDEyOyBpKyspIHtcbiAgICAgICAgLy8gbWFrZSB0aGUgcmVnZXggaWYgd2UgZG9uJ3QgaGF2ZSBpdCBhbHJlYWR5XG4gICAgICAgIG1vbSA9IGNyZWF0ZVVUQyhbMjAwMCwgaV0pO1xuICAgICAgICBzaG9ydFBpZWNlcy5wdXNoKHRoaXMubW9udGhzU2hvcnQobW9tLCAnJykpO1xuICAgICAgICBsb25nUGllY2VzLnB1c2godGhpcy5tb250aHMobW9tLCAnJykpO1xuICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKHRoaXMubW9udGhzKG1vbSwgJycpKTtcbiAgICAgICAgbWl4ZWRQaWVjZXMucHVzaCh0aGlzLm1vbnRoc1Nob3J0KG1vbSwgJycpKTtcbiAgICB9XG4gICAgLy8gU29ydGluZyBtYWtlcyBzdXJlIGlmIG9uZSBtb250aCAob3IgYWJicikgaXMgYSBwcmVmaXggb2YgYW5vdGhlciBpdFxuICAgIC8vIHdpbGwgbWF0Y2ggdGhlIGxvbmdlciBwaWVjZS5cbiAgICBzaG9ydFBpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgbG9uZ1BpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgbWl4ZWRQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgIHNob3J0UGllY2VzW2ldID0gcmVnZXhFc2NhcGUoc2hvcnRQaWVjZXNbaV0pO1xuICAgICAgICBsb25nUGllY2VzW2ldID0gcmVnZXhFc2NhcGUobG9uZ1BpZWNlc1tpXSk7XG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCAyNDsgaSsrKSB7XG4gICAgICAgIG1peGVkUGllY2VzW2ldID0gcmVnZXhFc2NhcGUobWl4ZWRQaWVjZXNbaV0pO1xuICAgIH1cblxuICAgIHRoaXMuX21vbnRoc1JlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgbWl4ZWRQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgIHRoaXMuX21vbnRoc1Nob3J0UmVnZXggPSB0aGlzLl9tb250aHNSZWdleDtcbiAgICB0aGlzLl9tb250aHNTdHJpY3RSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIGxvbmdQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgIHRoaXMuX21vbnRoc1Nob3J0U3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBzaG9ydFBpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZURhdGUgKHksIG0sIGQsIGgsIE0sIHMsIG1zKSB7XG4gICAgLy8gY2FuJ3QganVzdCBhcHBseSgpIHRvIGNyZWF0ZSBhIGRhdGU6XG4gICAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xLzE4MTM0OFxuICAgIHZhciBkYXRlID0gbmV3IERhdGUoeSwgbSwgZCwgaCwgTSwgcywgbXMpO1xuXG4gICAgLy8gdGhlIGRhdGUgY29uc3RydWN0b3IgcmVtYXBzIHllYXJzIDAtOTkgdG8gMTkwMC0xOTk5XG4gICAgaWYgKHkgPCAxMDAgJiYgeSA+PSAwICYmIGlzRmluaXRlKGRhdGUuZ2V0RnVsbFllYXIoKSkpIHtcbiAgICAgICAgZGF0ZS5zZXRGdWxsWWVhcih5KTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGU7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVVUQ0RhdGUgKHkpIHtcbiAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKERhdGUuVVRDLmFwcGx5KG51bGwsIGFyZ3VtZW50cykpO1xuXG4gICAgLy8gdGhlIERhdGUuVVRDIGZ1bmN0aW9uIHJlbWFwcyB5ZWFycyAwLTk5IHRvIDE5MDAtMTk5OVxuICAgIGlmICh5IDwgMTAwICYmIHkgPj0gMCAmJiBpc0Zpbml0ZShkYXRlLmdldFVUQ0Z1bGxZZWFyKCkpKSB7XG4gICAgICAgIGRhdGUuc2V0VVRDRnVsbFllYXIoeSk7XG4gICAgfVxuICAgIHJldHVybiBkYXRlO1xufVxuXG4vLyBzdGFydC1vZi1maXJzdC13ZWVrIC0gc3RhcnQtb2YteWVhclxuZnVuY3Rpb24gZmlyc3RXZWVrT2Zmc2V0KHllYXIsIGRvdywgZG95KSB7XG4gICAgdmFyIC8vIGZpcnN0LXdlZWsgZGF5IC0tIHdoaWNoIGphbnVhcnkgaXMgYWx3YXlzIGluIHRoZSBmaXJzdCB3ZWVrICg0IGZvciBpc28sIDEgZm9yIG90aGVyKVxuICAgICAgICBmd2QgPSA3ICsgZG93IC0gZG95LFxuICAgICAgICAvLyBmaXJzdC13ZWVrIGRheSBsb2NhbCB3ZWVrZGF5IC0tIHdoaWNoIGxvY2FsIHdlZWtkYXkgaXMgZndkXG4gICAgICAgIGZ3ZGx3ID0gKDcgKyBjcmVhdGVVVENEYXRlKHllYXIsIDAsIGZ3ZCkuZ2V0VVRDRGF5KCkgLSBkb3cpICUgNztcblxuICAgIHJldHVybiAtZndkbHcgKyBmd2QgLSAxO1xufVxuXG4vLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fd2Vla19kYXRlI0NhbGN1bGF0aW5nX2FfZGF0ZV9naXZlbl90aGVfeWVhci4yQ193ZWVrX251bWJlcl9hbmRfd2Vla2RheVxuZnVuY3Rpb24gZGF5T2ZZZWFyRnJvbVdlZWtzKHllYXIsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KSB7XG4gICAgdmFyIGxvY2FsV2Vla2RheSA9ICg3ICsgd2Vla2RheSAtIGRvdykgJSA3LFxuICAgICAgICB3ZWVrT2Zmc2V0ID0gZmlyc3RXZWVrT2Zmc2V0KHllYXIsIGRvdywgZG95KSxcbiAgICAgICAgZGF5T2ZZZWFyID0gMSArIDcgKiAod2VlayAtIDEpICsgbG9jYWxXZWVrZGF5ICsgd2Vla09mZnNldCxcbiAgICAgICAgcmVzWWVhciwgcmVzRGF5T2ZZZWFyO1xuXG4gICAgaWYgKGRheU9mWWVhciA8PSAwKSB7XG4gICAgICAgIHJlc1llYXIgPSB5ZWFyIC0gMTtcbiAgICAgICAgcmVzRGF5T2ZZZWFyID0gZGF5c0luWWVhcihyZXNZZWFyKSArIGRheU9mWWVhcjtcbiAgICB9IGVsc2UgaWYgKGRheU9mWWVhciA+IGRheXNJblllYXIoeWVhcikpIHtcbiAgICAgICAgcmVzWWVhciA9IHllYXIgKyAxO1xuICAgICAgICByZXNEYXlPZlllYXIgPSBkYXlPZlllYXIgLSBkYXlzSW5ZZWFyKHllYXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc1llYXIgPSB5ZWFyO1xuICAgICAgICByZXNEYXlPZlllYXIgPSBkYXlPZlllYXI7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgeWVhcjogcmVzWWVhcixcbiAgICAgICAgZGF5T2ZZZWFyOiByZXNEYXlPZlllYXJcbiAgICB9O1xufVxuXG5mdW5jdGlvbiB3ZWVrT2ZZZWFyKG1vbSwgZG93LCBkb3kpIHtcbiAgICB2YXIgd2Vla09mZnNldCA9IGZpcnN0V2Vla09mZnNldChtb20ueWVhcigpLCBkb3csIGRveSksXG4gICAgICAgIHdlZWsgPSBNYXRoLmZsb29yKChtb20uZGF5T2ZZZWFyKCkgLSB3ZWVrT2Zmc2V0IC0gMSkgLyA3KSArIDEsXG4gICAgICAgIHJlc1dlZWssIHJlc1llYXI7XG5cbiAgICBpZiAod2VlayA8IDEpIHtcbiAgICAgICAgcmVzWWVhciA9IG1vbS55ZWFyKCkgLSAxO1xuICAgICAgICByZXNXZWVrID0gd2VlayArIHdlZWtzSW5ZZWFyKHJlc1llYXIsIGRvdywgZG95KTtcbiAgICB9IGVsc2UgaWYgKHdlZWsgPiB3ZWVrc0luWWVhcihtb20ueWVhcigpLCBkb3csIGRveSkpIHtcbiAgICAgICAgcmVzV2VlayA9IHdlZWsgLSB3ZWVrc0luWWVhcihtb20ueWVhcigpLCBkb3csIGRveSk7XG4gICAgICAgIHJlc1llYXIgPSBtb20ueWVhcigpICsgMTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXNZZWFyID0gbW9tLnllYXIoKTtcbiAgICAgICAgcmVzV2VlayA9IHdlZWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgd2VlazogcmVzV2VlayxcbiAgICAgICAgeWVhcjogcmVzWWVhclxuICAgIH07XG59XG5cbmZ1bmN0aW9uIHdlZWtzSW5ZZWFyKHllYXIsIGRvdywgZG95KSB7XG4gICAgdmFyIHdlZWtPZmZzZXQgPSBmaXJzdFdlZWtPZmZzZXQoeWVhciwgZG93LCBkb3kpLFxuICAgICAgICB3ZWVrT2Zmc2V0TmV4dCA9IGZpcnN0V2Vla09mZnNldCh5ZWFyICsgMSwgZG93LCBkb3kpO1xuICAgIHJldHVybiAoZGF5c0luWWVhcih5ZWFyKSAtIHdlZWtPZmZzZXQgKyB3ZWVrT2Zmc2V0TmV4dCkgLyA3O1xufVxuXG4vLyBGT1JNQVRUSU5HXG5cbmFkZEZvcm1hdFRva2VuKCd3JywgWyd3dycsIDJdLCAnd28nLCAnd2VlaycpO1xuYWRkRm9ybWF0VG9rZW4oJ1cnLCBbJ1dXJywgMl0sICdXbycsICdpc29XZWVrJyk7XG5cbi8vIEFMSUFTRVNcblxuYWRkVW5pdEFsaWFzKCd3ZWVrJywgJ3cnKTtcbmFkZFVuaXRBbGlhcygnaXNvV2VlaycsICdXJyk7XG5cbi8vIFBSSU9SSVRJRVNcblxuYWRkVW5pdFByaW9yaXR5KCd3ZWVrJywgNSk7XG5hZGRVbml0UHJpb3JpdHkoJ2lzb1dlZWsnLCA1KTtcblxuLy8gUEFSU0lOR1xuXG5hZGRSZWdleFRva2VuKCd3JywgIG1hdGNoMXRvMik7XG5hZGRSZWdleFRva2VuKCd3dycsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbmFkZFJlZ2V4VG9rZW4oJ1cnLCAgbWF0Y2gxdG8yKTtcbmFkZFJlZ2V4VG9rZW4oJ1dXJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuXG5hZGRXZWVrUGFyc2VUb2tlbihbJ3cnLCAnd3cnLCAnVycsICdXVyddLCBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcbiAgICB3ZWVrW3Rva2VuLnN1YnN0cigwLCAxKV0gPSB0b0ludChpbnB1dCk7XG59KTtcblxuLy8gSEVMUEVSU1xuXG4vLyBMT0NBTEVTXG5cbmZ1bmN0aW9uIGxvY2FsZVdlZWsgKG1vbSkge1xuICAgIHJldHVybiB3ZWVrT2ZZZWFyKG1vbSwgdGhpcy5fd2Vlay5kb3csIHRoaXMuX3dlZWsuZG95KS53ZWVrO1xufVxuXG52YXIgZGVmYXVsdExvY2FsZVdlZWsgPSB7XG4gICAgZG93IDogMCwgLy8gU3VuZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgZG95IDogNiAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gMXN0IGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxufTtcblxuZnVuY3Rpb24gbG9jYWxlRmlyc3REYXlPZldlZWsgKCkge1xuICAgIHJldHVybiB0aGlzLl93ZWVrLmRvdztcbn1cblxuZnVuY3Rpb24gbG9jYWxlRmlyc3REYXlPZlllYXIgKCkge1xuICAgIHJldHVybiB0aGlzLl93ZWVrLmRveTtcbn1cblxuLy8gTU9NRU5UU1xuXG5mdW5jdGlvbiBnZXRTZXRXZWVrIChpbnB1dCkge1xuICAgIHZhciB3ZWVrID0gdGhpcy5sb2NhbGVEYXRhKCkud2Vlayh0aGlzKTtcbiAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IHdlZWsgOiB0aGlzLmFkZCgoaW5wdXQgLSB3ZWVrKSAqIDcsICdkJyk7XG59XG5cbmZ1bmN0aW9uIGdldFNldElTT1dlZWsgKGlucHV0KSB7XG4gICAgdmFyIHdlZWsgPSB3ZWVrT2ZZZWFyKHRoaXMsIDEsIDQpLndlZWs7XG4gICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyB3ZWVrIDogdGhpcy5hZGQoKGlucHV0IC0gd2VlaykgKiA3LCAnZCcpO1xufVxuXG4vLyBGT1JNQVRUSU5HXG5cbmFkZEZvcm1hdFRva2VuKCdkJywgMCwgJ2RvJywgJ2RheScpO1xuXG5hZGRGb3JtYXRUb2tlbignZGQnLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLndlZWtkYXlzTWluKHRoaXMsIGZvcm1hdCk7XG59KTtcblxuYWRkRm9ybWF0VG9rZW4oJ2RkZCcsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkud2Vla2RheXNTaG9ydCh0aGlzLCBmb3JtYXQpO1xufSk7XG5cbmFkZEZvcm1hdFRva2VuKCdkZGRkJywgMCwgMCwgZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS53ZWVrZGF5cyh0aGlzLCBmb3JtYXQpO1xufSk7XG5cbmFkZEZvcm1hdFRva2VuKCdlJywgMCwgMCwgJ3dlZWtkYXknKTtcbmFkZEZvcm1hdFRva2VuKCdFJywgMCwgMCwgJ2lzb1dlZWtkYXknKTtcblxuLy8gQUxJQVNFU1xuXG5hZGRVbml0QWxpYXMoJ2RheScsICdkJyk7XG5hZGRVbml0QWxpYXMoJ3dlZWtkYXknLCAnZScpO1xuYWRkVW5pdEFsaWFzKCdpc29XZWVrZGF5JywgJ0UnKTtcblxuLy8gUFJJT1JJVFlcbmFkZFVuaXRQcmlvcml0eSgnZGF5JywgMTEpO1xuYWRkVW5pdFByaW9yaXR5KCd3ZWVrZGF5JywgMTEpO1xuYWRkVW5pdFByaW9yaXR5KCdpc29XZWVrZGF5JywgMTEpO1xuXG4vLyBQQVJTSU5HXG5cbmFkZFJlZ2V4VG9rZW4oJ2QnLCAgICBtYXRjaDF0bzIpO1xuYWRkUmVnZXhUb2tlbignZScsICAgIG1hdGNoMXRvMik7XG5hZGRSZWdleFRva2VuKCdFJywgICAgbWF0Y2gxdG8yKTtcbmFkZFJlZ2V4VG9rZW4oJ2RkJywgICBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgIHJldHVybiBsb2NhbGUud2Vla2RheXNNaW5SZWdleChpc1N0cmljdCk7XG59KTtcbmFkZFJlZ2V4VG9rZW4oJ2RkZCcsICAgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICByZXR1cm4gbG9jYWxlLndlZWtkYXlzU2hvcnRSZWdleChpc1N0cmljdCk7XG59KTtcbmFkZFJlZ2V4VG9rZW4oJ2RkZGQnLCAgIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgcmV0dXJuIGxvY2FsZS53ZWVrZGF5c1JlZ2V4KGlzU3RyaWN0KTtcbn0pO1xuXG5hZGRXZWVrUGFyc2VUb2tlbihbJ2RkJywgJ2RkZCcsICdkZGRkJ10sIGZ1bmN0aW9uIChpbnB1dCwgd2VlaywgY29uZmlnLCB0b2tlbikge1xuICAgIHZhciB3ZWVrZGF5ID0gY29uZmlnLl9sb2NhbGUud2Vla2RheXNQYXJzZShpbnB1dCwgdG9rZW4sIGNvbmZpZy5fc3RyaWN0KTtcbiAgICAvLyBpZiB3ZSBkaWRuJ3QgZ2V0IGEgd2Vla2RheSBuYW1lLCBtYXJrIHRoZSBkYXRlIGFzIGludmFsaWRcbiAgICBpZiAod2Vla2RheSAhPSBudWxsKSB7XG4gICAgICAgIHdlZWsuZCA9IHdlZWtkYXk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuaW52YWxpZFdlZWtkYXkgPSBpbnB1dDtcbiAgICB9XG59KTtcblxuYWRkV2Vla1BhcnNlVG9rZW4oWydkJywgJ2UnLCAnRSddLCBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcbiAgICB3ZWVrW3Rva2VuXSA9IHRvSW50KGlucHV0KTtcbn0pO1xuXG4vLyBIRUxQRVJTXG5cbmZ1bmN0aW9uIHBhcnNlV2Vla2RheShpbnB1dCwgbG9jYWxlKSB7XG4gICAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgIH1cblxuICAgIGlmICghaXNOYU4oaW5wdXQpKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUludChpbnB1dCwgMTApO1xuICAgIH1cblxuICAgIGlucHV0ID0gbG9jYWxlLndlZWtkYXlzUGFyc2UoaW5wdXQpO1xuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiBpbnB1dDtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gcGFyc2VJc29XZWVrZGF5KGlucHV0LCBsb2NhbGUpIHtcbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gbG9jYWxlLndlZWtkYXlzUGFyc2UoaW5wdXQpICUgNyB8fCA3O1xuICAgIH1cbiAgICByZXR1cm4gaXNOYU4oaW5wdXQpID8gbnVsbCA6IGlucHV0O1xufVxuXG4vLyBMT0NBTEVTXG5cbnZhciBkZWZhdWx0TG9jYWxlV2Vla2RheXMgPSAnU3VuZGF5X01vbmRheV9UdWVzZGF5X1dlZG5lc2RheV9UaHVyc2RheV9GcmlkYXlfU2F0dXJkYXknLnNwbGl0KCdfJyk7XG5mdW5jdGlvbiBsb2NhbGVXZWVrZGF5cyAobSwgZm9ybWF0KSB7XG4gICAgaWYgKCFtKSB7XG4gICAgICAgIHJldHVybiBpc0FycmF5KHRoaXMuX3dlZWtkYXlzKSA/IHRoaXMuX3dlZWtkYXlzIDpcbiAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzWydzdGFuZGFsb25lJ107XG4gICAgfVxuICAgIHJldHVybiBpc0FycmF5KHRoaXMuX3dlZWtkYXlzKSA/IHRoaXMuX3dlZWtkYXlzW20uZGF5KCldIDpcbiAgICAgICAgdGhpcy5fd2Vla2RheXNbdGhpcy5fd2Vla2RheXMuaXNGb3JtYXQudGVzdChmb3JtYXQpID8gJ2Zvcm1hdCcgOiAnc3RhbmRhbG9uZSddW20uZGF5KCldO1xufVxuXG52YXIgZGVmYXVsdExvY2FsZVdlZWtkYXlzU2hvcnQgPSAnU3VuX01vbl9UdWVfV2VkX1RodV9GcmlfU2F0Jy5zcGxpdCgnXycpO1xuZnVuY3Rpb24gbG9jYWxlV2Vla2RheXNTaG9ydCAobSkge1xuICAgIHJldHVybiAobSkgPyB0aGlzLl93ZWVrZGF5c1Nob3J0W20uZGF5KCldIDogdGhpcy5fd2Vla2RheXNTaG9ydDtcbn1cblxudmFyIGRlZmF1bHRMb2NhbGVXZWVrZGF5c01pbiA9ICdTdV9Nb19UdV9XZV9UaF9Gcl9TYScuc3BsaXQoJ18nKTtcbmZ1bmN0aW9uIGxvY2FsZVdlZWtkYXlzTWluIChtKSB7XG4gICAgcmV0dXJuIChtKSA/IHRoaXMuX3dlZWtkYXlzTWluW20uZGF5KCldIDogdGhpcy5fd2Vla2RheXNNaW47XG59XG5cbmZ1bmN0aW9uIGhhbmRsZVN0cmljdFBhcnNlJDEod2Vla2RheU5hbWUsIGZvcm1hdCwgc3RyaWN0KSB7XG4gICAgdmFyIGksIGlpLCBtb20sIGxsYyA9IHdlZWtkYXlOYW1lLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgaWYgKCF0aGlzLl93ZWVrZGF5c1BhcnNlKSB7XG4gICAgICAgIHRoaXMuX3dlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgdGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgIHRoaXMuX21pbldlZWtkYXlzUGFyc2UgPSBbXTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNzsgKytpKSB7XG4gICAgICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIDFdKS5kYXkoaSk7XG4gICAgICAgICAgICB0aGlzLl9taW5XZWVrZGF5c1BhcnNlW2ldID0gdGhpcy53ZWVrZGF5c01pbihtb20sICcnKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgdGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlW2ldID0gdGhpcy53ZWVrZGF5c1Nob3J0KG1vbSwgJycpLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1BhcnNlW2ldID0gdGhpcy53ZWVrZGF5cyhtb20sICcnKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHN0cmljdCkge1xuICAgICAgICBpZiAoZm9ybWF0ID09PSAnZGRkZCcpIHtcbiAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3dlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gJ2RkZCcpIHtcbiAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9taW5XZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmb3JtYXQgPT09ICdkZGRkJykge1xuICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fd2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbWluV2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgIH0gZWxzZSBpZiAoZm9ybWF0ID09PSAnZGRkJykge1xuICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3dlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbWluV2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9taW5XZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3dlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gbG9jYWxlV2Vla2RheXNQYXJzZSAod2Vla2RheU5hbWUsIGZvcm1hdCwgc3RyaWN0KSB7XG4gICAgdmFyIGksIG1vbSwgcmVnZXg7XG5cbiAgICBpZiAodGhpcy5fd2Vla2RheXNQYXJzZUV4YWN0KSB7XG4gICAgICAgIHJldHVybiBoYW5kbGVTdHJpY3RQYXJzZSQxLmNhbGwodGhpcywgd2Vla2RheU5hbWUsIGZvcm1hdCwgc3RyaWN0KTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX3dlZWtkYXlzUGFyc2UpIHtcbiAgICAgICAgdGhpcy5fd2Vla2RheXNQYXJzZSA9IFtdO1xuICAgICAgICB0aGlzLl9taW5XZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgIHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZSA9IFtdO1xuICAgICAgICB0aGlzLl9mdWxsV2Vla2RheXNQYXJzZSA9IFtdO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCA3OyBpKyspIHtcbiAgICAgICAgLy8gbWFrZSB0aGUgcmVnZXggaWYgd2UgZG9uJ3QgaGF2ZSBpdCBhbHJlYWR5XG5cbiAgICAgICAgbW9tID0gY3JlYXRlVVRDKFsyMDAwLCAxXSkuZGF5KGkpO1xuICAgICAgICBpZiAoc3RyaWN0ICYmICF0aGlzLl9mdWxsV2Vla2RheXNQYXJzZVtpXSkge1xuICAgICAgICAgICAgdGhpcy5fZnVsbFdlZWtkYXlzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKCdeJyArIHRoaXMud2Vla2RheXMobW9tLCAnJykucmVwbGFjZSgnLicsICdcXC4/JykgKyAnJCcsICdpJyk7XG4gICAgICAgICAgICB0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKCdeJyArIHRoaXMud2Vla2RheXNTaG9ydChtb20sICcnKS5yZXBsYWNlKCcuJywgJ1xcLj8nKSArICckJywgJ2knKTtcbiAgICAgICAgICAgIHRoaXMuX21pbldlZWtkYXlzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKCdeJyArIHRoaXMud2Vla2RheXNNaW4obW9tLCAnJykucmVwbGFjZSgnLicsICdcXC4/JykgKyAnJCcsICdpJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl93ZWVrZGF5c1BhcnNlW2ldKSB7XG4gICAgICAgICAgICByZWdleCA9ICdeJyArIHRoaXMud2Vla2RheXMobW9tLCAnJykgKyAnfF4nICsgdGhpcy53ZWVrZGF5c1Nob3J0KG1vbSwgJycpICsgJ3xeJyArIHRoaXMud2Vla2RheXNNaW4obW9tLCAnJyk7XG4gICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1BhcnNlW2ldID0gbmV3IFJlZ0V4cChyZWdleC5yZXBsYWNlKCcuJywgJycpLCAnaScpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRlc3QgdGhlIHJlZ2V4XG4gICAgICAgIGlmIChzdHJpY3QgJiYgZm9ybWF0ID09PSAnZGRkZCcgJiYgdGhpcy5fZnVsbFdlZWtkYXlzUGFyc2VbaV0udGVzdCh3ZWVrZGF5TmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9IGVsc2UgaWYgKHN0cmljdCAmJiBmb3JtYXQgPT09ICdkZGQnICYmIHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZVtpXS50ZXN0KHdlZWtkYXlOYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RyaWN0ICYmIGZvcm1hdCA9PT0gJ2RkJyAmJiB0aGlzLl9taW5XZWVrZGF5c1BhcnNlW2ldLnRlc3Qod2Vla2RheU5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfSBlbHNlIGlmICghc3RyaWN0ICYmIHRoaXMuX3dlZWtkYXlzUGFyc2VbaV0udGVzdCh3ZWVrZGF5TmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vLyBNT01FTlRTXG5cbmZ1bmN0aW9uIGdldFNldERheU9mV2VlayAoaW5wdXQpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgIHJldHVybiBpbnB1dCAhPSBudWxsID8gdGhpcyA6IE5hTjtcbiAgICB9XG4gICAgdmFyIGRheSA9IHRoaXMuX2lzVVRDID8gdGhpcy5fZC5nZXRVVENEYXkoKSA6IHRoaXMuX2QuZ2V0RGF5KCk7XG4gICAgaWYgKGlucHV0ICE9IG51bGwpIHtcbiAgICAgICAgaW5wdXQgPSBwYXJzZVdlZWtkYXkoaW5wdXQsIHRoaXMubG9jYWxlRGF0YSgpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkKGlucHV0IC0gZGF5LCAnZCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBkYXk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBnZXRTZXRMb2NhbGVEYXlPZldlZWsgKGlucHV0KSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICByZXR1cm4gaW5wdXQgIT0gbnVsbCA/IHRoaXMgOiBOYU47XG4gICAgfVxuICAgIHZhciB3ZWVrZGF5ID0gKHRoaXMuZGF5KCkgKyA3IC0gdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWsuZG93KSAlIDc7XG4gICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyB3ZWVrZGF5IDogdGhpcy5hZGQoaW5wdXQgLSB3ZWVrZGF5LCAnZCcpO1xufVxuXG5mdW5jdGlvbiBnZXRTZXRJU09EYXlPZldlZWsgKGlucHV0KSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICByZXR1cm4gaW5wdXQgIT0gbnVsbCA/IHRoaXMgOiBOYU47XG4gICAgfVxuXG4gICAgLy8gYmVoYXZlcyB0aGUgc2FtZSBhcyBtb21lbnQjZGF5IGV4Y2VwdFxuICAgIC8vIGFzIGEgZ2V0dGVyLCByZXR1cm5zIDcgaW5zdGVhZCBvZiAwICgxLTcgcmFuZ2UgaW5zdGVhZCBvZiAwLTYpXG4gICAgLy8gYXMgYSBzZXR0ZXIsIHN1bmRheSBzaG91bGQgYmVsb25nIHRvIHRoZSBwcmV2aW91cyB3ZWVrLlxuXG4gICAgaWYgKGlucHV0ICE9IG51bGwpIHtcbiAgICAgICAgdmFyIHdlZWtkYXkgPSBwYXJzZUlzb1dlZWtkYXkoaW5wdXQsIHRoaXMubG9jYWxlRGF0YSgpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF5KHRoaXMuZGF5KCkgJSA3ID8gd2Vla2RheSA6IHdlZWtkYXkgLSA3KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXkoKSB8fCA3O1xuICAgIH1cbn1cblxudmFyIGRlZmF1bHRXZWVrZGF5c1JlZ2V4ID0gbWF0Y2hXb3JkO1xuZnVuY3Rpb24gd2Vla2RheXNSZWdleCAoaXNTdHJpY3QpIHtcbiAgICBpZiAodGhpcy5fd2Vla2RheXNQYXJzZUV4YWN0KSB7XG4gICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzUmVnZXgnKSkge1xuICAgICAgICAgICAgY29tcHV0ZVdlZWtkYXlzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNTdHJpY3QpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1N0cmljdFJlZ2V4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzUmVnZXg7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ193ZWVrZGF5c1JlZ2V4JykpIHtcbiAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzUmVnZXggPSBkZWZhdWx0V2Vla2RheXNSZWdleDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTdHJpY3RSZWdleCAmJiBpc1N0cmljdCA/XG4gICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1N0cmljdFJlZ2V4IDogdGhpcy5fd2Vla2RheXNSZWdleDtcbiAgICB9XG59XG5cbnZhciBkZWZhdWx0V2Vla2RheXNTaG9ydFJlZ2V4ID0gbWF0Y2hXb3JkO1xuZnVuY3Rpb24gd2Vla2RheXNTaG9ydFJlZ2V4IChpc1N0cmljdCkge1xuICAgIGlmICh0aGlzLl93ZWVrZGF5c1BhcnNlRXhhY3QpIHtcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNSZWdleCcpKSB7XG4gICAgICAgICAgICBjb21wdXRlV2Vla2RheXNQYXJzZS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1N0cmljdCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzU2hvcnRTdHJpY3RSZWdleDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1Nob3J0UmVnZXg7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ193ZWVrZGF5c1Nob3J0UmVnZXgnKSkge1xuICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNTaG9ydFJlZ2V4ID0gZGVmYXVsdFdlZWtkYXlzU2hvcnRSZWdleDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTaG9ydFN0cmljdFJlZ2V4ICYmIGlzU3RyaWN0ID9cbiAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzU2hvcnRTdHJpY3RSZWdleCA6IHRoaXMuX3dlZWtkYXlzU2hvcnRSZWdleDtcbiAgICB9XG59XG5cbnZhciBkZWZhdWx0V2Vla2RheXNNaW5SZWdleCA9IG1hdGNoV29yZDtcbmZ1bmN0aW9uIHdlZWtkYXlzTWluUmVnZXggKGlzU3RyaWN0KSB7XG4gICAgaWYgKHRoaXMuX3dlZWtkYXlzUGFyc2VFeGFjdCkge1xuICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ193ZWVrZGF5c1JlZ2V4JykpIHtcbiAgICAgICAgICAgIGNvbXB1dGVXZWVrZGF5c1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzU3RyaWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNNaW5TdHJpY3RSZWdleDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c01pblJlZ2V4O1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNNaW5SZWdleCcpKSB7XG4gICAgICAgICAgICB0aGlzLl93ZWVrZGF5c01pblJlZ2V4ID0gZGVmYXVsdFdlZWtkYXlzTWluUmVnZXg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzTWluU3RyaWN0UmVnZXggJiYgaXNTdHJpY3QgP1xuICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNNaW5TdHJpY3RSZWdleCA6IHRoaXMuX3dlZWtkYXlzTWluUmVnZXg7XG4gICAgfVxufVxuXG5cbmZ1bmN0aW9uIGNvbXB1dGVXZWVrZGF5c1BhcnNlICgpIHtcbiAgICBmdW5jdGlvbiBjbXBMZW5SZXYoYSwgYikge1xuICAgICAgICByZXR1cm4gYi5sZW5ndGggLSBhLmxlbmd0aDtcbiAgICB9XG5cbiAgICB2YXIgbWluUGllY2VzID0gW10sIHNob3J0UGllY2VzID0gW10sIGxvbmdQaWVjZXMgPSBbXSwgbWl4ZWRQaWVjZXMgPSBbXSxcbiAgICAgICAgaSwgbW9tLCBtaW5wLCBzaG9ydHAsIGxvbmdwO1xuICAgIGZvciAoaSA9IDA7IGkgPCA3OyBpKyspIHtcbiAgICAgICAgLy8gbWFrZSB0aGUgcmVnZXggaWYgd2UgZG9uJ3QgaGF2ZSBpdCBhbHJlYWR5XG4gICAgICAgIG1vbSA9IGNyZWF0ZVVUQyhbMjAwMCwgMV0pLmRheShpKTtcbiAgICAgICAgbWlucCA9IHRoaXMud2Vla2RheXNNaW4obW9tLCAnJyk7XG4gICAgICAgIHNob3J0cCA9IHRoaXMud2Vla2RheXNTaG9ydChtb20sICcnKTtcbiAgICAgICAgbG9uZ3AgPSB0aGlzLndlZWtkYXlzKG1vbSwgJycpO1xuICAgICAgICBtaW5QaWVjZXMucHVzaChtaW5wKTtcbiAgICAgICAgc2hvcnRQaWVjZXMucHVzaChzaG9ydHApO1xuICAgICAgICBsb25nUGllY2VzLnB1c2gobG9uZ3ApO1xuICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKG1pbnApO1xuICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKHNob3J0cCk7XG4gICAgICAgIG1peGVkUGllY2VzLnB1c2gobG9uZ3ApO1xuICAgIH1cbiAgICAvLyBTb3J0aW5nIG1ha2VzIHN1cmUgaWYgb25lIHdlZWtkYXkgKG9yIGFiYnIpIGlzIGEgcHJlZml4IG9mIGFub3RoZXIgaXRcbiAgICAvLyB3aWxsIG1hdGNoIHRoZSBsb25nZXIgcGllY2UuXG4gICAgbWluUGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICBzaG9ydFBpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgbG9uZ1BpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgbWl4ZWRQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgIGZvciAoaSA9IDA7IGkgPCA3OyBpKyspIHtcbiAgICAgICAgc2hvcnRQaWVjZXNbaV0gPSByZWdleEVzY2FwZShzaG9ydFBpZWNlc1tpXSk7XG4gICAgICAgIGxvbmdQaWVjZXNbaV0gPSByZWdleEVzY2FwZShsb25nUGllY2VzW2ldKTtcbiAgICAgICAgbWl4ZWRQaWVjZXNbaV0gPSByZWdleEVzY2FwZShtaXhlZFBpZWNlc1tpXSk7XG4gICAgfVxuXG4gICAgdGhpcy5fd2Vla2RheXNSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIG1peGVkUGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbiAgICB0aGlzLl93ZWVrZGF5c1Nob3J0UmVnZXggPSB0aGlzLl93ZWVrZGF5c1JlZ2V4O1xuICAgIHRoaXMuX3dlZWtkYXlzTWluUmVnZXggPSB0aGlzLl93ZWVrZGF5c1JlZ2V4O1xuXG4gICAgdGhpcy5fd2Vla2RheXNTdHJpY3RSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIGxvbmdQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgIHRoaXMuX3dlZWtkYXlzU2hvcnRTdHJpY3RSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIHNob3J0UGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbiAgICB0aGlzLl93ZWVrZGF5c01pblN0cmljdFJlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgbWluUGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbn1cblxuLy8gRk9STUFUVElOR1xuXG5mdW5jdGlvbiBoRm9ybWF0KCkge1xuICAgIHJldHVybiB0aGlzLmhvdXJzKCkgJSAxMiB8fCAxMjtcbn1cblxuZnVuY3Rpb24ga0Zvcm1hdCgpIHtcbiAgICByZXR1cm4gdGhpcy5ob3VycygpIHx8IDI0O1xufVxuXG5hZGRGb3JtYXRUb2tlbignSCcsIFsnSEgnLCAyXSwgMCwgJ2hvdXInKTtcbmFkZEZvcm1hdFRva2VuKCdoJywgWydoaCcsIDJdLCAwLCBoRm9ybWF0KTtcbmFkZEZvcm1hdFRva2VuKCdrJywgWydraycsIDJdLCAwLCBrRm9ybWF0KTtcblxuYWRkRm9ybWF0VG9rZW4oJ2htbScsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gJycgKyBoRm9ybWF0LmFwcGx5KHRoaXMpICsgemVyb0ZpbGwodGhpcy5taW51dGVzKCksIDIpO1xufSk7XG5cbmFkZEZvcm1hdFRva2VuKCdobW1zcycsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gJycgKyBoRm9ybWF0LmFwcGx5KHRoaXMpICsgemVyb0ZpbGwodGhpcy5taW51dGVzKCksIDIpICtcbiAgICAgICAgemVyb0ZpbGwodGhpcy5zZWNvbmRzKCksIDIpO1xufSk7XG5cbmFkZEZvcm1hdFRva2VuKCdIbW0nLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICcnICsgdGhpcy5ob3VycygpICsgemVyb0ZpbGwodGhpcy5taW51dGVzKCksIDIpO1xufSk7XG5cbmFkZEZvcm1hdFRva2VuKCdIbW1zcycsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gJycgKyB0aGlzLmhvdXJzKCkgKyB6ZXJvRmlsbCh0aGlzLm1pbnV0ZXMoKSwgMikgK1xuICAgICAgICB6ZXJvRmlsbCh0aGlzLnNlY29uZHMoKSwgMik7XG59KTtcblxuZnVuY3Rpb24gbWVyaWRpZW0gKHRva2VuLCBsb3dlcmNhc2UpIHtcbiAgICBhZGRGb3JtYXRUb2tlbih0b2tlbiwgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkubWVyaWRpZW0odGhpcy5ob3VycygpLCB0aGlzLm1pbnV0ZXMoKSwgbG93ZXJjYXNlKTtcbiAgICB9KTtcbn1cblxubWVyaWRpZW0oJ2EnLCB0cnVlKTtcbm1lcmlkaWVtKCdBJywgZmFsc2UpO1xuXG4vLyBBTElBU0VTXG5cbmFkZFVuaXRBbGlhcygnaG91cicsICdoJyk7XG5cbi8vIFBSSU9SSVRZXG5hZGRVbml0UHJpb3JpdHkoJ2hvdXInLCAxMyk7XG5cbi8vIFBBUlNJTkdcblxuZnVuY3Rpb24gbWF0Y2hNZXJpZGllbSAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgIHJldHVybiBsb2NhbGUuX21lcmlkaWVtUGFyc2U7XG59XG5cbmFkZFJlZ2V4VG9rZW4oJ2EnLCAgbWF0Y2hNZXJpZGllbSk7XG5hZGRSZWdleFRva2VuKCdBJywgIG1hdGNoTWVyaWRpZW0pO1xuYWRkUmVnZXhUb2tlbignSCcsICBtYXRjaDF0bzIpO1xuYWRkUmVnZXhUb2tlbignaCcsICBtYXRjaDF0bzIpO1xuYWRkUmVnZXhUb2tlbignaycsICBtYXRjaDF0bzIpO1xuYWRkUmVnZXhUb2tlbignSEgnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG5hZGRSZWdleFRva2VuKCdoaCcsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbmFkZFJlZ2V4VG9rZW4oJ2trJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuXG5hZGRSZWdleFRva2VuKCdobW0nLCBtYXRjaDN0bzQpO1xuYWRkUmVnZXhUb2tlbignaG1tc3MnLCBtYXRjaDV0bzYpO1xuYWRkUmVnZXhUb2tlbignSG1tJywgbWF0Y2gzdG80KTtcbmFkZFJlZ2V4VG9rZW4oJ0htbXNzJywgbWF0Y2g1dG82KTtcblxuYWRkUGFyc2VUb2tlbihbJ0gnLCAnSEgnXSwgSE9VUik7XG5hZGRQYXJzZVRva2VuKFsnaycsICdrayddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICB2YXIga0lucHV0ID0gdG9JbnQoaW5wdXQpO1xuICAgIGFycmF5W0hPVVJdID0ga0lucHV0ID09PSAyNCA/IDAgOiBrSW5wdXQ7XG59KTtcbmFkZFBhcnNlVG9rZW4oWydhJywgJ0EnXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgY29uZmlnLl9pc1BtID0gY29uZmlnLl9sb2NhbGUuaXNQTShpbnB1dCk7XG4gICAgY29uZmlnLl9tZXJpZGllbSA9IGlucHV0O1xufSk7XG5hZGRQYXJzZVRva2VuKFsnaCcsICdoaCddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICBhcnJheVtIT1VSXSA9IHRvSW50KGlucHV0KTtcbiAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5iaWdIb3VyID0gdHJ1ZTtcbn0pO1xuYWRkUGFyc2VUb2tlbignaG1tJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgdmFyIHBvcyA9IGlucHV0Lmxlbmd0aCAtIDI7XG4gICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dC5zdWJzdHIoMCwgcG9zKSk7XG4gICAgYXJyYXlbTUlOVVRFXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MpKTtcbiAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5iaWdIb3VyID0gdHJ1ZTtcbn0pO1xuYWRkUGFyc2VUb2tlbignaG1tc3MnLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICB2YXIgcG9zMSA9IGlucHV0Lmxlbmd0aCAtIDQ7XG4gICAgdmFyIHBvczIgPSBpbnB1dC5sZW5ndGggLSAyO1xuICAgIGFycmF5W0hPVVJdID0gdG9JbnQoaW5wdXQuc3Vic3RyKDAsIHBvczEpKTtcbiAgICBhcnJheVtNSU5VVEVdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvczEsIDIpKTtcbiAgICBhcnJheVtTRUNPTkRdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvczIpKTtcbiAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5iaWdIb3VyID0gdHJ1ZTtcbn0pO1xuYWRkUGFyc2VUb2tlbignSG1tJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgdmFyIHBvcyA9IGlucHV0Lmxlbmd0aCAtIDI7XG4gICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dC5zdWJzdHIoMCwgcG9zKSk7XG4gICAgYXJyYXlbTUlOVVRFXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MpKTtcbn0pO1xuYWRkUGFyc2VUb2tlbignSG1tc3MnLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICB2YXIgcG9zMSA9IGlucHV0Lmxlbmd0aCAtIDQ7XG4gICAgdmFyIHBvczIgPSBpbnB1dC5sZW5ndGggLSAyO1xuICAgIGFycmF5W0hPVVJdID0gdG9JbnQoaW5wdXQuc3Vic3RyKDAsIHBvczEpKTtcbiAgICBhcnJheVtNSU5VVEVdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvczEsIDIpKTtcbiAgICBhcnJheVtTRUNPTkRdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvczIpKTtcbn0pO1xuXG4vLyBMT0NBTEVTXG5cbmZ1bmN0aW9uIGxvY2FsZUlzUE0gKGlucHV0KSB7XG4gICAgLy8gSUU4IFF1aXJrcyBNb2RlICYgSUU3IFN0YW5kYXJkcyBNb2RlIGRvIG5vdCBhbGxvdyBhY2Nlc3Npbmcgc3RyaW5ncyBsaWtlIGFycmF5c1xuICAgIC8vIFVzaW5nIGNoYXJBdCBzaG91bGQgYmUgbW9yZSBjb21wYXRpYmxlLlxuICAgIHJldHVybiAoKGlucHV0ICsgJycpLnRvTG93ZXJDYXNlKCkuY2hhckF0KDApID09PSAncCcpO1xufVxuXG52YXIgZGVmYXVsdExvY2FsZU1lcmlkaWVtUGFyc2UgPSAvW2FwXVxcLj9tP1xcLj8vaTtcbmZ1bmN0aW9uIGxvY2FsZU1lcmlkaWVtIChob3VycywgbWludXRlcywgaXNMb3dlcikge1xuICAgIGlmIChob3VycyA+IDExKSB7XG4gICAgICAgIHJldHVybiBpc0xvd2VyID8gJ3BtJyA6ICdQTSc7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGlzTG93ZXIgPyAnYW0nIDogJ0FNJztcbiAgICB9XG59XG5cblxuLy8gTU9NRU5UU1xuXG4vLyBTZXR0aW5nIHRoZSBob3VyIHNob3VsZCBrZWVwIHRoZSB0aW1lLCBiZWNhdXNlIHRoZSB1c2VyIGV4cGxpY2l0bHlcbi8vIHNwZWNpZmllZCB3aGljaCBob3VyIGhlIHdhbnRzLiBTbyB0cnlpbmcgdG8gbWFpbnRhaW4gdGhlIHNhbWUgaG91ciAoaW5cbi8vIGEgbmV3IHRpbWV6b25lKSBtYWtlcyBzZW5zZS4gQWRkaW5nL3N1YnRyYWN0aW5nIGhvdXJzIGRvZXMgbm90IGZvbGxvd1xuLy8gdGhpcyBydWxlLlxudmFyIGdldFNldEhvdXIgPSBtYWtlR2V0U2V0KCdIb3VycycsIHRydWUpO1xuXG4vLyBtb250aHNcbi8vIHdlZWtcbi8vIHdlZWtkYXlzXG4vLyBtZXJpZGllbVxudmFyIGJhc2VDb25maWcgPSB7XG4gICAgY2FsZW5kYXI6IGRlZmF1bHRDYWxlbmRhcixcbiAgICBsb25nRGF0ZUZvcm1hdDogZGVmYXVsdExvbmdEYXRlRm9ybWF0LFxuICAgIGludmFsaWREYXRlOiBkZWZhdWx0SW52YWxpZERhdGUsXG4gICAgb3JkaW5hbDogZGVmYXVsdE9yZGluYWwsXG4gICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogZGVmYXVsdERheU9mTW9udGhPcmRpbmFsUGFyc2UsXG4gICAgcmVsYXRpdmVUaW1lOiBkZWZhdWx0UmVsYXRpdmVUaW1lLFxuXG4gICAgbW9udGhzOiBkZWZhdWx0TG9jYWxlTW9udGhzLFxuICAgIG1vbnRoc1Nob3J0OiBkZWZhdWx0TG9jYWxlTW9udGhzU2hvcnQsXG5cbiAgICB3ZWVrOiBkZWZhdWx0TG9jYWxlV2VlayxcblxuICAgIHdlZWtkYXlzOiBkZWZhdWx0TG9jYWxlV2Vla2RheXMsXG4gICAgd2Vla2RheXNNaW46IGRlZmF1bHRMb2NhbGVXZWVrZGF5c01pbixcbiAgICB3ZWVrZGF5c1Nob3J0OiBkZWZhdWx0TG9jYWxlV2Vla2RheXNTaG9ydCxcblxuICAgIG1lcmlkaWVtUGFyc2U6IGRlZmF1bHRMb2NhbGVNZXJpZGllbVBhcnNlXG59O1xuXG4vLyBpbnRlcm5hbCBzdG9yYWdlIGZvciBsb2NhbGUgY29uZmlnIGZpbGVzXG52YXIgbG9jYWxlcyA9IHt9O1xudmFyIGxvY2FsZUZhbWlsaWVzID0ge307XG52YXIgZ2xvYmFsTG9jYWxlO1xuXG5mdW5jdGlvbiBub3JtYWxpemVMb2NhbGUoa2V5KSB7XG4gICAgcmV0dXJuIGtleSA/IGtleS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoJ18nLCAnLScpIDoga2V5O1xufVxuXG4vLyBwaWNrIHRoZSBsb2NhbGUgZnJvbSB0aGUgYXJyYXlcbi8vIHRyeSBbJ2VuLWF1JywgJ2VuLWdiJ10gYXMgJ2VuLWF1JywgJ2VuLWdiJywgJ2VuJywgYXMgaW4gbW92ZSB0aHJvdWdoIHRoZSBsaXN0IHRyeWluZyBlYWNoXG4vLyBzdWJzdHJpbmcgZnJvbSBtb3N0IHNwZWNpZmljIHRvIGxlYXN0LCBidXQgbW92ZSB0byB0aGUgbmV4dCBhcnJheSBpdGVtIGlmIGl0J3MgYSBtb3JlIHNwZWNpZmljIHZhcmlhbnQgdGhhbiB0aGUgY3VycmVudCByb290XG5mdW5jdGlvbiBjaG9vc2VMb2NhbGUobmFtZXMpIHtcbiAgICB2YXIgaSA9IDAsIGosIG5leHQsIGxvY2FsZSwgc3BsaXQ7XG5cbiAgICB3aGlsZSAoaSA8IG5hbWVzLmxlbmd0aCkge1xuICAgICAgICBzcGxpdCA9IG5vcm1hbGl6ZUxvY2FsZShuYW1lc1tpXSkuc3BsaXQoJy0nKTtcbiAgICAgICAgaiA9IHNwbGl0Lmxlbmd0aDtcbiAgICAgICAgbmV4dCA9IG5vcm1hbGl6ZUxvY2FsZShuYW1lc1tpICsgMV0pO1xuICAgICAgICBuZXh0ID0gbmV4dCA/IG5leHQuc3BsaXQoJy0nKSA6IG51bGw7XG4gICAgICAgIHdoaWxlIChqID4gMCkge1xuICAgICAgICAgICAgbG9jYWxlID0gbG9hZExvY2FsZShzcGxpdC5zbGljZSgwLCBqKS5qb2luKCctJykpO1xuICAgICAgICAgICAgaWYgKGxvY2FsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsb2NhbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV4dCAmJiBuZXh0Lmxlbmd0aCA+PSBqICYmIGNvbXBhcmVBcnJheXMoc3BsaXQsIG5leHQsIHRydWUpID49IGogLSAxKSB7XG4gICAgICAgICAgICAgICAgLy90aGUgbmV4dCBhcnJheSBpdGVtIGlzIGJldHRlciB0aGFuIGEgc2hhbGxvd2VyIHN1YnN0cmluZyBvZiB0aGlzIG9uZVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgai0tO1xuICAgICAgICB9XG4gICAgICAgIGkrKztcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGxvYWRMb2NhbGUobmFtZSkge1xuICAgIHZhciBvbGRMb2NhbGUgPSBudWxsO1xuICAgIC8vIFRPRE86IEZpbmQgYSBiZXR0ZXIgd2F5IHRvIHJlZ2lzdGVyIGFuZCBsb2FkIGFsbCB0aGUgbG9jYWxlcyBpbiBOb2RlXG4gICAgaWYgKCFsb2NhbGVzW25hbWVdICYmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykgJiZcbiAgICAgICAgICAgIG1vZHVsZSAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgb2xkTG9jYWxlID0gZ2xvYmFsTG9jYWxlLl9hYmJyO1xuICAgICAgICAgICAgdmFyIGFsaWFzZWRSZXF1aXJlID0gcmVxdWlyZTtcbiAgICAgICAgICAgIGFsaWFzZWRSZXF1aXJlKCcuL2xvY2FsZS8nICsgbmFtZSk7XG4gICAgICAgICAgICBnZXRTZXRHbG9iYWxMb2NhbGUob2xkTG9jYWxlKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICB9XG4gICAgcmV0dXJuIGxvY2FsZXNbbmFtZV07XG59XG5cbi8vIFRoaXMgZnVuY3Rpb24gd2lsbCBsb2FkIGxvY2FsZSBhbmQgdGhlbiBzZXQgdGhlIGdsb2JhbCBsb2NhbGUuICBJZlxuLy8gbm8gYXJndW1lbnRzIGFyZSBwYXNzZWQgaW4sIGl0IHdpbGwgc2ltcGx5IHJldHVybiB0aGUgY3VycmVudCBnbG9iYWxcbi8vIGxvY2FsZSBrZXkuXG5mdW5jdGlvbiBnZXRTZXRHbG9iYWxMb2NhbGUgKGtleSwgdmFsdWVzKSB7XG4gICAgdmFyIGRhdGE7XG4gICAgaWYgKGtleSkge1xuICAgICAgICBpZiAoaXNVbmRlZmluZWQodmFsdWVzKSkge1xuICAgICAgICAgICAgZGF0YSA9IGdldExvY2FsZShrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGF0YSA9IGRlZmluZUxvY2FsZShrZXksIHZhbHVlcyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgLy8gbW9tZW50LmR1cmF0aW9uLl9sb2NhbGUgPSBtb21lbnQuX2xvY2FsZSA9IGRhdGE7XG4gICAgICAgICAgICBnbG9iYWxMb2NhbGUgPSBkYXRhO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGdsb2JhbExvY2FsZS5fYWJicjtcbn1cblxuZnVuY3Rpb24gZGVmaW5lTG9jYWxlIChuYW1lLCBjb25maWcpIHtcbiAgICBpZiAoY29uZmlnICE9PSBudWxsKSB7XG4gICAgICAgIHZhciBwYXJlbnRDb25maWcgPSBiYXNlQ29uZmlnO1xuICAgICAgICBjb25maWcuYWJiciA9IG5hbWU7XG4gICAgICAgIGlmIChsb2NhbGVzW25hbWVdICE9IG51bGwpIHtcbiAgICAgICAgICAgIGRlcHJlY2F0ZVNpbXBsZSgnZGVmaW5lTG9jYWxlT3ZlcnJpZGUnLFxuICAgICAgICAgICAgICAgICAgICAndXNlIG1vbWVudC51cGRhdGVMb2NhbGUobG9jYWxlTmFtZSwgY29uZmlnKSB0byBjaGFuZ2UgJyArXG4gICAgICAgICAgICAgICAgICAgICdhbiBleGlzdGluZyBsb2NhbGUuIG1vbWVudC5kZWZpbmVMb2NhbGUobG9jYWxlTmFtZSwgJyArXG4gICAgICAgICAgICAgICAgICAgICdjb25maWcpIHNob3VsZCBvbmx5IGJlIHVzZWQgZm9yIGNyZWF0aW5nIGEgbmV3IGxvY2FsZSAnICtcbiAgICAgICAgICAgICAgICAgICAgJ1NlZSBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL2RlZmluZS1sb2NhbGUvIGZvciBtb3JlIGluZm8uJyk7XG4gICAgICAgICAgICBwYXJlbnRDb25maWcgPSBsb2NhbGVzW25hbWVdLl9jb25maWc7XG4gICAgICAgIH0gZWxzZSBpZiAoY29uZmlnLnBhcmVudExvY2FsZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAobG9jYWxlc1tjb25maWcucGFyZW50TG9jYWxlXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50Q29uZmlnID0gbG9jYWxlc1tjb25maWcucGFyZW50TG9jYWxlXS5fY29uZmlnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIWxvY2FsZUZhbWlsaWVzW2NvbmZpZy5wYXJlbnRMb2NhbGVdKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsZUZhbWlsaWVzW2NvbmZpZy5wYXJlbnRMb2NhbGVdID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxvY2FsZUZhbWlsaWVzW2NvbmZpZy5wYXJlbnRMb2NhbGVdLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICAgICAgICBjb25maWc6IGNvbmZpZ1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxvY2FsZXNbbmFtZV0gPSBuZXcgTG9jYWxlKG1lcmdlQ29uZmlncyhwYXJlbnRDb25maWcsIGNvbmZpZykpO1xuXG4gICAgICAgIGlmIChsb2NhbGVGYW1pbGllc1tuYW1lXSkge1xuICAgICAgICAgICAgbG9jYWxlRmFtaWxpZXNbbmFtZV0uZm9yRWFjaChmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgICAgIGRlZmluZUxvY2FsZSh4Lm5hbWUsIHguY29uZmlnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYmFja3dhcmRzIGNvbXBhdCBmb3Igbm93OiBhbHNvIHNldCB0aGUgbG9jYWxlXG4gICAgICAgIC8vIG1ha2Ugc3VyZSB3ZSBzZXQgdGhlIGxvY2FsZSBBRlRFUiBhbGwgY2hpbGQgbG9jYWxlcyBoYXZlIGJlZW5cbiAgICAgICAgLy8gY3JlYXRlZCwgc28gd2Ugd29uJ3QgZW5kIHVwIHdpdGggdGhlIGNoaWxkIGxvY2FsZSBzZXQuXG4gICAgICAgIGdldFNldEdsb2JhbExvY2FsZShuYW1lKTtcblxuXG4gICAgICAgIHJldHVybiBsb2NhbGVzW25hbWVdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHVzZWZ1bCBmb3IgdGVzdGluZ1xuICAgICAgICBkZWxldGUgbG9jYWxlc1tuYW1lXTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVMb2NhbGUobmFtZSwgY29uZmlnKSB7XG4gICAgaWYgKGNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHZhciBsb2NhbGUsIHRtcExvY2FsZSwgcGFyZW50Q29uZmlnID0gYmFzZUNvbmZpZztcbiAgICAgICAgLy8gTUVSR0VcbiAgICAgICAgdG1wTG9jYWxlID0gbG9hZExvY2FsZShuYW1lKTtcbiAgICAgICAgaWYgKHRtcExvY2FsZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBwYXJlbnRDb25maWcgPSB0bXBMb2NhbGUuX2NvbmZpZztcbiAgICAgICAgfVxuICAgICAgICBjb25maWcgPSBtZXJnZUNvbmZpZ3MocGFyZW50Q29uZmlnLCBjb25maWcpO1xuICAgICAgICBsb2NhbGUgPSBuZXcgTG9jYWxlKGNvbmZpZyk7XG4gICAgICAgIGxvY2FsZS5wYXJlbnRMb2NhbGUgPSBsb2NhbGVzW25hbWVdO1xuICAgICAgICBsb2NhbGVzW25hbWVdID0gbG9jYWxlO1xuXG4gICAgICAgIC8vIGJhY2t3YXJkcyBjb21wYXQgZm9yIG5vdzogYWxzbyBzZXQgdGhlIGxvY2FsZVxuICAgICAgICBnZXRTZXRHbG9iYWxMb2NhbGUobmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gcGFzcyBudWxsIGZvciBjb25maWcgdG8gdW51cGRhdGUsIHVzZWZ1bCBmb3IgdGVzdHNcbiAgICAgICAgaWYgKGxvY2FsZXNbbmFtZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGxvY2FsZXNbbmFtZV0ucGFyZW50TG9jYWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBsb2NhbGVzW25hbWVdID0gbG9jYWxlc1tuYW1lXS5wYXJlbnRMb2NhbGU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGxvY2FsZXNbbmFtZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBsb2NhbGVzW25hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsb2NhbGVzW25hbWVdO1xufVxuXG4vLyByZXR1cm5zIGxvY2FsZSBkYXRhXG5mdW5jdGlvbiBnZXRMb2NhbGUgKGtleSkge1xuICAgIHZhciBsb2NhbGU7XG5cbiAgICBpZiAoa2V5ICYmIGtleS5fbG9jYWxlICYmIGtleS5fbG9jYWxlLl9hYmJyKSB7XG4gICAgICAgIGtleSA9IGtleS5fbG9jYWxlLl9hYmJyO1xuICAgIH1cblxuICAgIGlmICgha2V5KSB7XG4gICAgICAgIHJldHVybiBnbG9iYWxMb2NhbGU7XG4gICAgfVxuXG4gICAgaWYgKCFpc0FycmF5KGtleSkpIHtcbiAgICAgICAgLy9zaG9ydC1jaXJjdWl0IGV2ZXJ5dGhpbmcgZWxzZVxuICAgICAgICBsb2NhbGUgPSBsb2FkTG9jYWxlKGtleSk7XG4gICAgICAgIGlmIChsb2NhbGUpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbGU7XG4gICAgICAgIH1cbiAgICAgICAga2V5ID0gW2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGNob29zZUxvY2FsZShrZXkpO1xufVxuXG5mdW5jdGlvbiBsaXN0TG9jYWxlcygpIHtcbiAgICByZXR1cm4ga2V5cyhsb2NhbGVzKTtcbn1cblxuZnVuY3Rpb24gY2hlY2tPdmVyZmxvdyAobSkge1xuICAgIHZhciBvdmVyZmxvdztcbiAgICB2YXIgYSA9IG0uX2E7XG5cbiAgICBpZiAoYSAmJiBnZXRQYXJzaW5nRmxhZ3MobSkub3ZlcmZsb3cgPT09IC0yKSB7XG4gICAgICAgIG92ZXJmbG93ID1cbiAgICAgICAgICAgIGFbTU9OVEhdICAgICAgIDwgMCB8fCBhW01PTlRIXSAgICAgICA+IDExICA/IE1PTlRIIDpcbiAgICAgICAgICAgIGFbREFURV0gICAgICAgIDwgMSB8fCBhW0RBVEVdICAgICAgICA+IGRheXNJbk1vbnRoKGFbWUVBUl0sIGFbTU9OVEhdKSA/IERBVEUgOlxuICAgICAgICAgICAgYVtIT1VSXSAgICAgICAgPCAwIHx8IGFbSE9VUl0gICAgICAgID4gMjQgfHwgKGFbSE9VUl0gPT09IDI0ICYmIChhW01JTlVURV0gIT09IDAgfHwgYVtTRUNPTkRdICE9PSAwIHx8IGFbTUlMTElTRUNPTkRdICE9PSAwKSkgPyBIT1VSIDpcbiAgICAgICAgICAgIGFbTUlOVVRFXSAgICAgIDwgMCB8fCBhW01JTlVURV0gICAgICA+IDU5ICA/IE1JTlVURSA6XG4gICAgICAgICAgICBhW1NFQ09ORF0gICAgICA8IDAgfHwgYVtTRUNPTkRdICAgICAgPiA1OSAgPyBTRUNPTkQgOlxuICAgICAgICAgICAgYVtNSUxMSVNFQ09ORF0gPCAwIHx8IGFbTUlMTElTRUNPTkRdID4gOTk5ID8gTUlMTElTRUNPTkQgOlxuICAgICAgICAgICAgLTE7XG5cbiAgICAgICAgaWYgKGdldFBhcnNpbmdGbGFncyhtKS5fb3ZlcmZsb3dEYXlPZlllYXIgJiYgKG92ZXJmbG93IDwgWUVBUiB8fCBvdmVyZmxvdyA+IERBVEUpKSB7XG4gICAgICAgICAgICBvdmVyZmxvdyA9IERBVEU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdldFBhcnNpbmdGbGFncyhtKS5fb3ZlcmZsb3dXZWVrcyAmJiBvdmVyZmxvdyA9PT0gLTEpIHtcbiAgICAgICAgICAgIG92ZXJmbG93ID0gV0VFSztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ2V0UGFyc2luZ0ZsYWdzKG0pLl9vdmVyZmxvd1dlZWtkYXkgJiYgb3ZlcmZsb3cgPT09IC0xKSB7XG4gICAgICAgICAgICBvdmVyZmxvdyA9IFdFRUtEQVk7XG4gICAgICAgIH1cblxuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MobSkub3ZlcmZsb3cgPSBvdmVyZmxvdztcbiAgICB9XG5cbiAgICByZXR1cm4gbTtcbn1cblxuLy8gUGljayB0aGUgZmlyc3QgZGVmaW5lZCBvZiB0d28gb3IgdGhyZWUgYXJndW1lbnRzLlxuZnVuY3Rpb24gZGVmYXVsdHMoYSwgYiwgYykge1xuICAgIGlmIChhICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgfVxuICAgIGlmIChiICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGI7XG4gICAgfVxuICAgIHJldHVybiBjO1xufVxuXG5mdW5jdGlvbiBjdXJyZW50RGF0ZUFycmF5KGNvbmZpZykge1xuICAgIC8vIGhvb2tzIGlzIGFjdHVhbGx5IHRoZSBleHBvcnRlZCBtb21lbnQgb2JqZWN0XG4gICAgdmFyIG5vd1ZhbHVlID0gbmV3IERhdGUoaG9va3Mubm93KCkpO1xuICAgIGlmIChjb25maWcuX3VzZVVUQykge1xuICAgICAgICByZXR1cm4gW25vd1ZhbHVlLmdldFVUQ0Z1bGxZZWFyKCksIG5vd1ZhbHVlLmdldFVUQ01vbnRoKCksIG5vd1ZhbHVlLmdldFVUQ0RhdGUoKV07XG4gICAgfVxuICAgIHJldHVybiBbbm93VmFsdWUuZ2V0RnVsbFllYXIoKSwgbm93VmFsdWUuZ2V0TW9udGgoKSwgbm93VmFsdWUuZ2V0RGF0ZSgpXTtcbn1cblxuLy8gY29udmVydCBhbiBhcnJheSB0byBhIGRhdGUuXG4vLyB0aGUgYXJyYXkgc2hvdWxkIG1pcnJvciB0aGUgcGFyYW1ldGVycyBiZWxvd1xuLy8gbm90ZTogYWxsIHZhbHVlcyBwYXN0IHRoZSB5ZWFyIGFyZSBvcHRpb25hbCBhbmQgd2lsbCBkZWZhdWx0IHRvIHRoZSBsb3dlc3QgcG9zc2libGUgdmFsdWUuXG4vLyBbeWVhciwgbW9udGgsIGRheSAsIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZF1cbmZ1bmN0aW9uIGNvbmZpZ0Zyb21BcnJheSAoY29uZmlnKSB7XG4gICAgdmFyIGksIGRhdGUsIGlucHV0ID0gW10sIGN1cnJlbnREYXRlLCBleHBlY3RlZFdlZWtkYXksIHllYXJUb1VzZTtcblxuICAgIGlmIChjb25maWcuX2QpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGN1cnJlbnREYXRlID0gY3VycmVudERhdGVBcnJheShjb25maWcpO1xuXG4gICAgLy9jb21wdXRlIGRheSBvZiB0aGUgeWVhciBmcm9tIHdlZWtzIGFuZCB3ZWVrZGF5c1xuICAgIGlmIChjb25maWcuX3cgJiYgY29uZmlnLl9hW0RBVEVdID09IG51bGwgJiYgY29uZmlnLl9hW01PTlRIXSA9PSBudWxsKSB7XG4gICAgICAgIGRheU9mWWVhckZyb21XZWVrSW5mbyhjb25maWcpO1xuICAgIH1cblxuICAgIC8vaWYgdGhlIGRheSBvZiB0aGUgeWVhciBpcyBzZXQsIGZpZ3VyZSBvdXQgd2hhdCBpdCBpc1xuICAgIGlmIChjb25maWcuX2RheU9mWWVhciAhPSBudWxsKSB7XG4gICAgICAgIHllYXJUb1VzZSA9IGRlZmF1bHRzKGNvbmZpZy5fYVtZRUFSXSwgY3VycmVudERhdGVbWUVBUl0pO1xuXG4gICAgICAgIGlmIChjb25maWcuX2RheU9mWWVhciA+IGRheXNJblllYXIoeWVhclRvVXNlKSB8fCBjb25maWcuX2RheU9mWWVhciA9PT0gMCkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuX292ZXJmbG93RGF5T2ZZZWFyID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRhdGUgPSBjcmVhdGVVVENEYXRlKHllYXJUb1VzZSwgMCwgY29uZmlnLl9kYXlPZlllYXIpO1xuICAgICAgICBjb25maWcuX2FbTU9OVEhdID0gZGF0ZS5nZXRVVENNb250aCgpO1xuICAgICAgICBjb25maWcuX2FbREFURV0gPSBkYXRlLmdldFVUQ0RhdGUoKTtcbiAgICB9XG5cbiAgICAvLyBEZWZhdWx0IHRvIGN1cnJlbnQgZGF0ZS5cbiAgICAvLyAqIGlmIG5vIHllYXIsIG1vbnRoLCBkYXkgb2YgbW9udGggYXJlIGdpdmVuLCBkZWZhdWx0IHRvIHRvZGF5XG4gICAgLy8gKiBpZiBkYXkgb2YgbW9udGggaXMgZ2l2ZW4sIGRlZmF1bHQgbW9udGggYW5kIHllYXJcbiAgICAvLyAqIGlmIG1vbnRoIGlzIGdpdmVuLCBkZWZhdWx0IG9ubHkgeWVhclxuICAgIC8vICogaWYgeWVhciBpcyBnaXZlbiwgZG9uJ3QgZGVmYXVsdCBhbnl0aGluZ1xuICAgIGZvciAoaSA9IDA7IGkgPCAzICYmIGNvbmZpZy5fYVtpXSA9PSBudWxsOyArK2kpIHtcbiAgICAgICAgY29uZmlnLl9hW2ldID0gaW5wdXRbaV0gPSBjdXJyZW50RGF0ZVtpXTtcbiAgICB9XG5cbiAgICAvLyBaZXJvIG91dCB3aGF0ZXZlciB3YXMgbm90IGRlZmF1bHRlZCwgaW5jbHVkaW5nIHRpbWVcbiAgICBmb3IgKDsgaSA8IDc7IGkrKykge1xuICAgICAgICBjb25maWcuX2FbaV0gPSBpbnB1dFtpXSA9IChjb25maWcuX2FbaV0gPT0gbnVsbCkgPyAoaSA9PT0gMiA/IDEgOiAwKSA6IGNvbmZpZy5fYVtpXTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgMjQ6MDA6MDAuMDAwXG4gICAgaWYgKGNvbmZpZy5fYVtIT1VSXSA9PT0gMjQgJiZcbiAgICAgICAgICAgIGNvbmZpZy5fYVtNSU5VVEVdID09PSAwICYmXG4gICAgICAgICAgICBjb25maWcuX2FbU0VDT05EXSA9PT0gMCAmJlxuICAgICAgICAgICAgY29uZmlnLl9hW01JTExJU0VDT05EXSA9PT0gMCkge1xuICAgICAgICBjb25maWcuX25leHREYXkgPSB0cnVlO1xuICAgICAgICBjb25maWcuX2FbSE9VUl0gPSAwO1xuICAgIH1cblxuICAgIGNvbmZpZy5fZCA9IChjb25maWcuX3VzZVVUQyA/IGNyZWF0ZVVUQ0RhdGUgOiBjcmVhdGVEYXRlKS5hcHBseShudWxsLCBpbnB1dCk7XG4gICAgZXhwZWN0ZWRXZWVrZGF5ID0gY29uZmlnLl91c2VVVEMgPyBjb25maWcuX2QuZ2V0VVRDRGF5KCkgOiBjb25maWcuX2QuZ2V0RGF5KCk7XG5cbiAgICAvLyBBcHBseSB0aW1lem9uZSBvZmZzZXQgZnJvbSBpbnB1dC4gVGhlIGFjdHVhbCB1dGNPZmZzZXQgY2FuIGJlIGNoYW5nZWRcbiAgICAvLyB3aXRoIHBhcnNlWm9uZS5cbiAgICBpZiAoY29uZmlnLl90em0gIT0gbnVsbCkge1xuICAgICAgICBjb25maWcuX2Quc2V0VVRDTWludXRlcyhjb25maWcuX2QuZ2V0VVRDTWludXRlcygpIC0gY29uZmlnLl90em0pO1xuICAgIH1cblxuICAgIGlmIChjb25maWcuX25leHREYXkpIHtcbiAgICAgICAgY29uZmlnLl9hW0hPVVJdID0gMjQ7XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgZm9yIG1pc21hdGNoaW5nIGRheSBvZiB3ZWVrXG4gICAgaWYgKGNvbmZpZy5fdyAmJiB0eXBlb2YgY29uZmlnLl93LmQgIT09ICd1bmRlZmluZWQnICYmIGNvbmZpZy5fdy5kICE9PSBleHBlY3RlZFdlZWtkYXkpIHtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykud2Vla2RheU1pc21hdGNoID0gdHJ1ZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRheU9mWWVhckZyb21XZWVrSW5mbyhjb25maWcpIHtcbiAgICB2YXIgdywgd2Vla1llYXIsIHdlZWssIHdlZWtkYXksIGRvdywgZG95LCB0ZW1wLCB3ZWVrZGF5T3ZlcmZsb3c7XG5cbiAgICB3ID0gY29uZmlnLl93O1xuICAgIGlmICh3LkdHICE9IG51bGwgfHwgdy5XICE9IG51bGwgfHwgdy5FICE9IG51bGwpIHtcbiAgICAgICAgZG93ID0gMTtcbiAgICAgICAgZG95ID0gNDtcblxuICAgICAgICAvLyBUT0RPOiBXZSBuZWVkIHRvIHRha2UgdGhlIGN1cnJlbnQgaXNvV2Vla1llYXIsIGJ1dCB0aGF0IGRlcGVuZHMgb25cbiAgICAgICAgLy8gaG93IHdlIGludGVycHJldCBub3cgKGxvY2FsLCB1dGMsIGZpeGVkIG9mZnNldCkuIFNvIGNyZWF0ZVxuICAgICAgICAvLyBhIG5vdyB2ZXJzaW9uIG9mIGN1cnJlbnQgY29uZmlnICh0YWtlIGxvY2FsL3V0Yy9vZmZzZXQgZmxhZ3MsIGFuZFxuICAgICAgICAvLyBjcmVhdGUgbm93KS5cbiAgICAgICAgd2Vla1llYXIgPSBkZWZhdWx0cyh3LkdHLCBjb25maWcuX2FbWUVBUl0sIHdlZWtPZlllYXIoY3JlYXRlTG9jYWwoKSwgMSwgNCkueWVhcik7XG4gICAgICAgIHdlZWsgPSBkZWZhdWx0cyh3LlcsIDEpO1xuICAgICAgICB3ZWVrZGF5ID0gZGVmYXVsdHMody5FLCAxKTtcbiAgICAgICAgaWYgKHdlZWtkYXkgPCAxIHx8IHdlZWtkYXkgPiA3KSB7XG4gICAgICAgICAgICB3ZWVrZGF5T3ZlcmZsb3cgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZG93ID0gY29uZmlnLl9sb2NhbGUuX3dlZWsuZG93O1xuICAgICAgICBkb3kgPSBjb25maWcuX2xvY2FsZS5fd2Vlay5kb3k7XG5cbiAgICAgICAgdmFyIGN1cldlZWsgPSB3ZWVrT2ZZZWFyKGNyZWF0ZUxvY2FsKCksIGRvdywgZG95KTtcblxuICAgICAgICB3ZWVrWWVhciA9IGRlZmF1bHRzKHcuZ2csIGNvbmZpZy5fYVtZRUFSXSwgY3VyV2Vlay55ZWFyKTtcblxuICAgICAgICAvLyBEZWZhdWx0IHRvIGN1cnJlbnQgd2Vlay5cbiAgICAgICAgd2VlayA9IGRlZmF1bHRzKHcudywgY3VyV2Vlay53ZWVrKTtcblxuICAgICAgICBpZiAody5kICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIHdlZWtkYXkgLS0gbG93IGRheSBudW1iZXJzIGFyZSBjb25zaWRlcmVkIG5leHQgd2Vla1xuICAgICAgICAgICAgd2Vla2RheSA9IHcuZDtcbiAgICAgICAgICAgIGlmICh3ZWVrZGF5IDwgMCB8fCB3ZWVrZGF5ID4gNikge1xuICAgICAgICAgICAgICAgIHdlZWtkYXlPdmVyZmxvdyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAody5lICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIGxvY2FsIHdlZWtkYXkgLS0gY291bnRpbmcgc3RhcnRzIGZyb20gYmVnaW5pbmcgb2Ygd2Vla1xuICAgICAgICAgICAgd2Vla2RheSA9IHcuZSArIGRvdztcbiAgICAgICAgICAgIGlmICh3LmUgPCAwIHx8IHcuZSA+IDYpIHtcbiAgICAgICAgICAgICAgICB3ZWVrZGF5T3ZlcmZsb3cgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gZGVmYXVsdCB0byBiZWdpbmluZyBvZiB3ZWVrXG4gICAgICAgICAgICB3ZWVrZGF5ID0gZG93O1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh3ZWVrIDwgMSB8fCB3ZWVrID4gd2Vla3NJblllYXIod2Vla1llYXIsIGRvdywgZG95KSkge1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5fb3ZlcmZsb3dXZWVrcyA9IHRydWU7XG4gICAgfSBlbHNlIGlmICh3ZWVrZGF5T3ZlcmZsb3cgIT0gbnVsbCkge1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5fb3ZlcmZsb3dXZWVrZGF5ID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0ZW1wID0gZGF5T2ZZZWFyRnJvbVdlZWtzKHdlZWtZZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSk7XG4gICAgICAgIGNvbmZpZy5fYVtZRUFSXSA9IHRlbXAueWVhcjtcbiAgICAgICAgY29uZmlnLl9kYXlPZlllYXIgPSB0ZW1wLmRheU9mWWVhcjtcbiAgICB9XG59XG5cbi8vIGlzbyA4NjAxIHJlZ2V4XG4vLyAwMDAwLTAwLTAwIDAwMDAtVzAwIG9yIDAwMDAtVzAwLTAgKyBUICsgMDAgb3IgMDA6MDAgb3IgMDA6MDA6MDAgb3IgMDA6MDA6MDAuMDAwICsgKzAwOjAwIG9yICswMDAwIG9yICswMClcbnZhciBleHRlbmRlZElzb1JlZ2V4ID0gL15cXHMqKCg/OlsrLV1cXGR7Nn18XFxkezR9KS0oPzpcXGRcXGQtXFxkXFxkfFdcXGRcXGQtXFxkfFdcXGRcXGR8XFxkXFxkXFxkfFxcZFxcZCkpKD86KFR8ICkoXFxkXFxkKD86OlxcZFxcZCg/OjpcXGRcXGQoPzpbLixdXFxkKyk/KT8pPykoW1xcK1xcLV1cXGRcXGQoPzo6P1xcZFxcZCk/fFxccypaKT8pPyQvO1xudmFyIGJhc2ljSXNvUmVnZXggPSAvXlxccyooKD86WystXVxcZHs2fXxcXGR7NH0pKD86XFxkXFxkXFxkXFxkfFdcXGRcXGRcXGR8V1xcZFxcZHxcXGRcXGRcXGR8XFxkXFxkKSkoPzooVHwgKShcXGRcXGQoPzpcXGRcXGQoPzpcXGRcXGQoPzpbLixdXFxkKyk/KT8pPykoW1xcK1xcLV1cXGRcXGQoPzo6P1xcZFxcZCk/fFxccypaKT8pPyQvO1xuXG52YXIgdHpSZWdleCA9IC9afFsrLV1cXGRcXGQoPzo6P1xcZFxcZCk/LztcblxudmFyIGlzb0RhdGVzID0gW1xuICAgIFsnWVlZWVlZLU1NLUREJywgL1srLV1cXGR7Nn0tXFxkXFxkLVxcZFxcZC9dLFxuICAgIFsnWVlZWS1NTS1ERCcsIC9cXGR7NH0tXFxkXFxkLVxcZFxcZC9dLFxuICAgIFsnR0dHRy1bV11XVy1FJywgL1xcZHs0fS1XXFxkXFxkLVxcZC9dLFxuICAgIFsnR0dHRy1bV11XVycsIC9cXGR7NH0tV1xcZFxcZC8sIGZhbHNlXSxcbiAgICBbJ1lZWVktREREJywgL1xcZHs0fS1cXGR7M30vXSxcbiAgICBbJ1lZWVktTU0nLCAvXFxkezR9LVxcZFxcZC8sIGZhbHNlXSxcbiAgICBbJ1lZWVlZWU1NREQnLCAvWystXVxcZHsxMH0vXSxcbiAgICBbJ1lZWVlNTUREJywgL1xcZHs4fS9dLFxuICAgIC8vIFlZWVlNTSBpcyBOT1QgYWxsb3dlZCBieSB0aGUgc3RhbmRhcmRcbiAgICBbJ0dHR0dbV11XV0UnLCAvXFxkezR9V1xcZHszfS9dLFxuICAgIFsnR0dHR1tXXVdXJywgL1xcZHs0fVdcXGR7Mn0vLCBmYWxzZV0sXG4gICAgWydZWVlZREREJywgL1xcZHs3fS9dXG5dO1xuXG4vLyBpc28gdGltZSBmb3JtYXRzIGFuZCByZWdleGVzXG52YXIgaXNvVGltZXMgPSBbXG4gICAgWydISDptbTpzcy5TU1NTJywgL1xcZFxcZDpcXGRcXGQ6XFxkXFxkXFwuXFxkKy9dLFxuICAgIFsnSEg6bW06c3MsU1NTUycsIC9cXGRcXGQ6XFxkXFxkOlxcZFxcZCxcXGQrL10sXG4gICAgWydISDptbTpzcycsIC9cXGRcXGQ6XFxkXFxkOlxcZFxcZC9dLFxuICAgIFsnSEg6bW0nLCAvXFxkXFxkOlxcZFxcZC9dLFxuICAgIFsnSEhtbXNzLlNTU1MnLCAvXFxkXFxkXFxkXFxkXFxkXFxkXFwuXFxkKy9dLFxuICAgIFsnSEhtbXNzLFNTU1MnLCAvXFxkXFxkXFxkXFxkXFxkXFxkLFxcZCsvXSxcbiAgICBbJ0hIbW1zcycsIC9cXGRcXGRcXGRcXGRcXGRcXGQvXSxcbiAgICBbJ0hIbW0nLCAvXFxkXFxkXFxkXFxkL10sXG4gICAgWydISCcsIC9cXGRcXGQvXVxuXTtcblxudmFyIGFzcE5ldEpzb25SZWdleCA9IC9eXFwvP0RhdGVcXCgoXFwtP1xcZCspL2k7XG5cbi8vIGRhdGUgZnJvbSBpc28gZm9ybWF0XG5mdW5jdGlvbiBjb25maWdGcm9tSVNPKGNvbmZpZykge1xuICAgIHZhciBpLCBsLFxuICAgICAgICBzdHJpbmcgPSBjb25maWcuX2ksXG4gICAgICAgIG1hdGNoID0gZXh0ZW5kZWRJc29SZWdleC5leGVjKHN0cmluZykgfHwgYmFzaWNJc29SZWdleC5leGVjKHN0cmluZyksXG4gICAgICAgIGFsbG93VGltZSwgZGF0ZUZvcm1hdCwgdGltZUZvcm1hdCwgdHpGb3JtYXQ7XG5cbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuaXNvID0gdHJ1ZTtcblxuICAgICAgICBmb3IgKGkgPSAwLCBsID0gaXNvRGF0ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaXNvRGF0ZXNbaV1bMV0uZXhlYyhtYXRjaFsxXSkpIHtcbiAgICAgICAgICAgICAgICBkYXRlRm9ybWF0ID0gaXNvRGF0ZXNbaV1bMF07XG4gICAgICAgICAgICAgICAgYWxsb3dUaW1lID0gaXNvRGF0ZXNbaV1bMl0gIT09IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRlRm9ybWF0ID09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXRjaFszXSkge1xuICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IGlzb1RpbWVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChpc29UaW1lc1tpXVsxXS5leGVjKG1hdGNoWzNdKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBtYXRjaFsyXSBzaG91bGQgYmUgJ1QnIG9yIHNwYWNlXG4gICAgICAgICAgICAgICAgICAgIHRpbWVGb3JtYXQgPSAobWF0Y2hbMl0gfHwgJyAnKSArIGlzb1RpbWVzW2ldWzBdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGltZUZvcm1hdCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghYWxsb3dUaW1lICYmIHRpbWVGb3JtYXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hdGNoWzRdKSB7XG4gICAgICAgICAgICBpZiAodHpSZWdleC5leGVjKG1hdGNoWzRdKSkge1xuICAgICAgICAgICAgICAgIHR6Rm9ybWF0ID0gJ1onO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uZmlnLl9mID0gZGF0ZUZvcm1hdCArICh0aW1lRm9ybWF0IHx8ICcnKSArICh0ekZvcm1hdCB8fCAnJyk7XG4gICAgICAgIGNvbmZpZ0Zyb21TdHJpbmdBbmRGb3JtYXQoY29uZmlnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICB9XG59XG5cbi8vIFJGQyAyODIyIHJlZ2V4OiBGb3IgZGV0YWlscyBzZWUgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzI4MjIjc2VjdGlvbi0zLjNcbnZhciByZmMyODIyID0gL14oPzooTW9ufFR1ZXxXZWR8VGh1fEZyaXxTYXR8U3VuKSw/XFxzKT8oXFxkezEsMn0pXFxzKEphbnxGZWJ8TWFyfEFwcnxNYXl8SnVufEp1bHxBdWd8U2VwfE9jdHxOb3Z8RGVjKVxccyhcXGR7Miw0fSlcXHMoXFxkXFxkKTooXFxkXFxkKSg/OjooXFxkXFxkKSk/XFxzKD86KFVUfEdNVHxbRUNNUF1bU0RdVCl8KFtael0pfChbKy1dXFxkezR9KSkkLztcblxuZnVuY3Rpb24gZXh0cmFjdEZyb21SRkMyODIyU3RyaW5ncyh5ZWFyU3RyLCBtb250aFN0ciwgZGF5U3RyLCBob3VyU3RyLCBtaW51dGVTdHIsIHNlY29uZFN0cikge1xuICAgIHZhciByZXN1bHQgPSBbXG4gICAgICAgIHVudHJ1bmNhdGVZZWFyKHllYXJTdHIpLFxuICAgICAgICBkZWZhdWx0TG9jYWxlTW9udGhzU2hvcnQuaW5kZXhPZihtb250aFN0ciksXG4gICAgICAgIHBhcnNlSW50KGRheVN0ciwgMTApLFxuICAgICAgICBwYXJzZUludChob3VyU3RyLCAxMCksXG4gICAgICAgIHBhcnNlSW50KG1pbnV0ZVN0ciwgMTApXG4gICAgXTtcblxuICAgIGlmIChzZWNvbmRTdHIpIHtcbiAgICAgICAgcmVzdWx0LnB1c2gocGFyc2VJbnQoc2Vjb25kU3RyLCAxMCkpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHVudHJ1bmNhdGVZZWFyKHllYXJTdHIpIHtcbiAgICB2YXIgeWVhciA9IHBhcnNlSW50KHllYXJTdHIsIDEwKTtcbiAgICBpZiAoeWVhciA8PSA0OSkge1xuICAgICAgICByZXR1cm4gMjAwMCArIHllYXI7XG4gICAgfSBlbHNlIGlmICh5ZWFyIDw9IDk5OSkge1xuICAgICAgICByZXR1cm4gMTkwMCArIHllYXI7XG4gICAgfVxuICAgIHJldHVybiB5ZWFyO1xufVxuXG5mdW5jdGlvbiBwcmVwcm9jZXNzUkZDMjgyMihzKSB7XG4gICAgLy8gUmVtb3ZlIGNvbW1lbnRzIGFuZCBmb2xkaW5nIHdoaXRlc3BhY2UgYW5kIHJlcGxhY2UgbXVsdGlwbGUtc3BhY2VzIHdpdGggYSBzaW5nbGUgc3BhY2VcbiAgICByZXR1cm4gcy5yZXBsYWNlKC9cXChbXildKlxcKXxbXFxuXFx0XS9nLCAnICcpLnJlcGxhY2UoLyhcXHNcXHMrKS9nLCAnICcpLnRyaW0oKTtcbn1cblxuZnVuY3Rpb24gY2hlY2tXZWVrZGF5KHdlZWtkYXlTdHIsIHBhcnNlZElucHV0LCBjb25maWcpIHtcbiAgICBpZiAod2Vla2RheVN0cikge1xuICAgICAgICAvLyBUT0RPOiBSZXBsYWNlIHRoZSB2YW5pbGxhIEpTIERhdGUgb2JqZWN0IHdpdGggYW4gaW5kZXBlbnRlbnQgZGF5LW9mLXdlZWsgY2hlY2suXG4gICAgICAgIHZhciB3ZWVrZGF5UHJvdmlkZWQgPSBkZWZhdWx0TG9jYWxlV2Vla2RheXNTaG9ydC5pbmRleE9mKHdlZWtkYXlTdHIpLFxuICAgICAgICAgICAgd2Vla2RheUFjdHVhbCA9IG5ldyBEYXRlKHBhcnNlZElucHV0WzBdLCBwYXJzZWRJbnB1dFsxXSwgcGFyc2VkSW5wdXRbMl0pLmdldERheSgpO1xuICAgICAgICBpZiAod2Vla2RheVByb3ZpZGVkICE9PSB3ZWVrZGF5QWN0dWFsKSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS53ZWVrZGF5TWlzbWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbnZhciBvYnNPZmZzZXRzID0ge1xuICAgIFVUOiAwLFxuICAgIEdNVDogMCxcbiAgICBFRFQ6IC00ICogNjAsXG4gICAgRVNUOiAtNSAqIDYwLFxuICAgIENEVDogLTUgKiA2MCxcbiAgICBDU1Q6IC02ICogNjAsXG4gICAgTURUOiAtNiAqIDYwLFxuICAgIE1TVDogLTcgKiA2MCxcbiAgICBQRFQ6IC03ICogNjAsXG4gICAgUFNUOiAtOCAqIDYwXG59O1xuXG5mdW5jdGlvbiBjYWxjdWxhdGVPZmZzZXQob2JzT2Zmc2V0LCBtaWxpdGFyeU9mZnNldCwgbnVtT2Zmc2V0KSB7XG4gICAgaWYgKG9ic09mZnNldCkge1xuICAgICAgICByZXR1cm4gb2JzT2Zmc2V0c1tvYnNPZmZzZXRdO1xuICAgIH0gZWxzZSBpZiAobWlsaXRhcnlPZmZzZXQpIHtcbiAgICAgICAgLy8gdGhlIG9ubHkgYWxsb3dlZCBtaWxpdGFyeSB0eiBpcyBaXG4gICAgICAgIHJldHVybiAwO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBobSA9IHBhcnNlSW50KG51bU9mZnNldCwgMTApO1xuICAgICAgICB2YXIgbSA9IGhtICUgMTAwLCBoID0gKGhtIC0gbSkgLyAxMDA7XG4gICAgICAgIHJldHVybiBoICogNjAgKyBtO1xuICAgIH1cbn1cblxuLy8gZGF0ZSBhbmQgdGltZSBmcm9tIHJlZiAyODIyIGZvcm1hdFxuZnVuY3Rpb24gY29uZmlnRnJvbVJGQzI4MjIoY29uZmlnKSB7XG4gICAgdmFyIG1hdGNoID0gcmZjMjgyMi5leGVjKHByZXByb2Nlc3NSRkMyODIyKGNvbmZpZy5faSkpO1xuICAgIGlmIChtYXRjaCkge1xuICAgICAgICB2YXIgcGFyc2VkQXJyYXkgPSBleHRyYWN0RnJvbVJGQzI4MjJTdHJpbmdzKG1hdGNoWzRdLCBtYXRjaFszXSwgbWF0Y2hbMl0sIG1hdGNoWzVdLCBtYXRjaFs2XSwgbWF0Y2hbN10pO1xuICAgICAgICBpZiAoIWNoZWNrV2Vla2RheShtYXRjaFsxXSwgcGFyc2VkQXJyYXksIGNvbmZpZykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbmZpZy5fYSA9IHBhcnNlZEFycmF5O1xuICAgICAgICBjb25maWcuX3R6bSA9IGNhbGN1bGF0ZU9mZnNldChtYXRjaFs4XSwgbWF0Y2hbOV0sIG1hdGNoWzEwXSk7XG5cbiAgICAgICAgY29uZmlnLl9kID0gY3JlYXRlVVRDRGF0ZS5hcHBseShudWxsLCBjb25maWcuX2EpO1xuICAgICAgICBjb25maWcuX2Quc2V0VVRDTWludXRlcyhjb25maWcuX2QuZ2V0VVRDTWludXRlcygpIC0gY29uZmlnLl90em0pO1xuXG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnJmYzI4MjIgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgIH1cbn1cblxuLy8gZGF0ZSBmcm9tIGlzbyBmb3JtYXQgb3IgZmFsbGJhY2tcbmZ1bmN0aW9uIGNvbmZpZ0Zyb21TdHJpbmcoY29uZmlnKSB7XG4gICAgdmFyIG1hdGNoZWQgPSBhc3BOZXRKc29uUmVnZXguZXhlYyhjb25maWcuX2kpO1xuXG4gICAgaWYgKG1hdGNoZWQgIT09IG51bGwpIHtcbiAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoK21hdGNoZWRbMV0pO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uZmlnRnJvbUlTTyhjb25maWcpO1xuICAgIGlmIChjb25maWcuX2lzVmFsaWQgPT09IGZhbHNlKSB7XG4gICAgICAgIGRlbGV0ZSBjb25maWcuX2lzVmFsaWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbmZpZ0Zyb21SRkMyODIyKGNvbmZpZyk7XG4gICAgaWYgKGNvbmZpZy5faXNWYWxpZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgZGVsZXRlIGNvbmZpZy5faXNWYWxpZDtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gRmluYWwgYXR0ZW1wdCwgdXNlIElucHV0IEZhbGxiYWNrXG4gICAgaG9va3MuY3JlYXRlRnJvbUlucHV0RmFsbGJhY2soY29uZmlnKTtcbn1cblxuaG9va3MuY3JlYXRlRnJvbUlucHV0RmFsbGJhY2sgPSBkZXByZWNhdGUoXG4gICAgJ3ZhbHVlIHByb3ZpZGVkIGlzIG5vdCBpbiBhIHJlY29nbml6ZWQgUkZDMjgyMiBvciBJU08gZm9ybWF0LiBtb21lbnQgY29uc3RydWN0aW9uIGZhbGxzIGJhY2sgdG8ganMgRGF0ZSgpLCAnICtcbiAgICAnd2hpY2ggaXMgbm90IHJlbGlhYmxlIGFjcm9zcyBhbGwgYnJvd3NlcnMgYW5kIHZlcnNpb25zLiBOb24gUkZDMjgyMi9JU08gZGF0ZSBmb3JtYXRzIGFyZSAnICtcbiAgICAnZGlzY291cmFnZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBhbiB1cGNvbWluZyBtYWpvciByZWxlYXNlLiBQbGVhc2UgcmVmZXIgdG8gJyArXG4gICAgJ2h0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvanMtZGF0ZS8gZm9yIG1vcmUgaW5mby4nLFxuICAgIGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoY29uZmlnLl9pICsgKGNvbmZpZy5fdXNlVVRDID8gJyBVVEMnIDogJycpKTtcbiAgICB9XG4pO1xuXG4vLyBjb25zdGFudCB0aGF0IHJlZmVycyB0byB0aGUgSVNPIHN0YW5kYXJkXG5ob29rcy5JU09fODYwMSA9IGZ1bmN0aW9uICgpIHt9O1xuXG4vLyBjb25zdGFudCB0aGF0IHJlZmVycyB0byB0aGUgUkZDIDI4MjIgZm9ybVxuaG9va3MuUkZDXzI4MjIgPSBmdW5jdGlvbiAoKSB7fTtcblxuLy8gZGF0ZSBmcm9tIHN0cmluZyBhbmQgZm9ybWF0IHN0cmluZ1xuZnVuY3Rpb24gY29uZmlnRnJvbVN0cmluZ0FuZEZvcm1hdChjb25maWcpIHtcbiAgICAvLyBUT0RPOiBNb3ZlIHRoaXMgdG8gYW5vdGhlciBwYXJ0IG9mIHRoZSBjcmVhdGlvbiBmbG93IHRvIHByZXZlbnQgY2lyY3VsYXIgZGVwc1xuICAgIGlmIChjb25maWcuX2YgPT09IGhvb2tzLklTT184NjAxKSB7XG4gICAgICAgIGNvbmZpZ0Zyb21JU08oY29uZmlnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoY29uZmlnLl9mID09PSBob29rcy5SRkNfMjgyMikge1xuICAgICAgICBjb25maWdGcm9tUkZDMjgyMihjb25maWcpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbmZpZy5fYSA9IFtdO1xuICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmVtcHR5ID0gdHJ1ZTtcblxuICAgIC8vIFRoaXMgYXJyYXkgaXMgdXNlZCB0byBtYWtlIGEgRGF0ZSwgZWl0aGVyIHdpdGggYG5ldyBEYXRlYCBvciBgRGF0ZS5VVENgXG4gICAgdmFyIHN0cmluZyA9ICcnICsgY29uZmlnLl9pLFxuICAgICAgICBpLCBwYXJzZWRJbnB1dCwgdG9rZW5zLCB0b2tlbiwgc2tpcHBlZCxcbiAgICAgICAgc3RyaW5nTGVuZ3RoID0gc3RyaW5nLmxlbmd0aCxcbiAgICAgICAgdG90YWxQYXJzZWRJbnB1dExlbmd0aCA9IDA7XG5cbiAgICB0b2tlbnMgPSBleHBhbmRGb3JtYXQoY29uZmlnLl9mLCBjb25maWcuX2xvY2FsZSkubWF0Y2goZm9ybWF0dGluZ1Rva2VucykgfHwgW107XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRva2VuID0gdG9rZW5zW2ldO1xuICAgICAgICBwYXJzZWRJbnB1dCA9IChzdHJpbmcubWF0Y2goZ2V0UGFyc2VSZWdleEZvclRva2VuKHRva2VuLCBjb25maWcpKSB8fCBbXSlbMF07XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCd0b2tlbicsIHRva2VuLCAncGFyc2VkSW5wdXQnLCBwYXJzZWRJbnB1dCxcbiAgICAgICAgLy8gICAgICAgICAncmVnZXgnLCBnZXRQYXJzZVJlZ2V4Rm9yVG9rZW4odG9rZW4sIGNvbmZpZykpO1xuICAgICAgICBpZiAocGFyc2VkSW5wdXQpIHtcbiAgICAgICAgICAgIHNraXBwZWQgPSBzdHJpbmcuc3Vic3RyKDAsIHN0cmluZy5pbmRleE9mKHBhcnNlZElucHV0KSk7XG4gICAgICAgICAgICBpZiAoc2tpcHBlZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykudW51c2VkSW5wdXQucHVzaChza2lwcGVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0cmluZyA9IHN0cmluZy5zbGljZShzdHJpbmcuaW5kZXhPZihwYXJzZWRJbnB1dCkgKyBwYXJzZWRJbnB1dC5sZW5ndGgpO1xuICAgICAgICAgICAgdG90YWxQYXJzZWRJbnB1dExlbmd0aCArPSBwYXJzZWRJbnB1dC5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZG9uJ3QgcGFyc2UgaWYgaXQncyBub3QgYSBrbm93biB0b2tlblxuICAgICAgICBpZiAoZm9ybWF0VG9rZW5GdW5jdGlvbnNbdG9rZW5dKSB7XG4gICAgICAgICAgICBpZiAocGFyc2VkSW5wdXQpIHtcbiAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5lbXB0eSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykudW51c2VkVG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWRkVGltZVRvQXJyYXlGcm9tVG9rZW4odG9rZW4sIHBhcnNlZElucHV0LCBjb25maWcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbmZpZy5fc3RyaWN0ICYmICFwYXJzZWRJbnB1dCkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykudW51c2VkVG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gYWRkIHJlbWFpbmluZyB1bnBhcnNlZCBpbnB1dCBsZW5ndGggdG8gdGhlIHN0cmluZ1xuICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmNoYXJzTGVmdE92ZXIgPSBzdHJpbmdMZW5ndGggLSB0b3RhbFBhcnNlZElucHV0TGVuZ3RoO1xuICAgIGlmIChzdHJpbmcubGVuZ3RoID4gMCkge1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS51bnVzZWRJbnB1dC5wdXNoKHN0cmluZyk7XG4gICAgfVxuXG4gICAgLy8gY2xlYXIgXzEyaCBmbGFnIGlmIGhvdXIgaXMgPD0gMTJcbiAgICBpZiAoY29uZmlnLl9hW0hPVVJdIDw9IDEyICYmXG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPT09IHRydWUgJiZcbiAgICAgICAgY29uZmlnLl9hW0hPVVJdID4gMCkge1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5iaWdIb3VyID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnBhcnNlZERhdGVQYXJ0cyA9IGNvbmZpZy5fYS5zbGljZSgwKTtcbiAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5tZXJpZGllbSA9IGNvbmZpZy5fbWVyaWRpZW07XG4gICAgLy8gaGFuZGxlIG1lcmlkaWVtXG4gICAgY29uZmlnLl9hW0hPVVJdID0gbWVyaWRpZW1GaXhXcmFwKGNvbmZpZy5fbG9jYWxlLCBjb25maWcuX2FbSE9VUl0sIGNvbmZpZy5fbWVyaWRpZW0pO1xuXG4gICAgY29uZmlnRnJvbUFycmF5KGNvbmZpZyk7XG4gICAgY2hlY2tPdmVyZmxvdyhjb25maWcpO1xufVxuXG5cbmZ1bmN0aW9uIG1lcmlkaWVtRml4V3JhcCAobG9jYWxlLCBob3VyLCBtZXJpZGllbSkge1xuICAgIHZhciBpc1BtO1xuXG4gICAgaWYgKG1lcmlkaWVtID09IG51bGwpIHtcbiAgICAgICAgLy8gbm90aGluZyB0byBkb1xuICAgICAgICByZXR1cm4gaG91cjtcbiAgICB9XG4gICAgaWYgKGxvY2FsZS5tZXJpZGllbUhvdXIgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLm1lcmlkaWVtSG91cihob3VyLCBtZXJpZGllbSk7XG4gICAgfSBlbHNlIGlmIChsb2NhbGUuaXNQTSAhPSBudWxsKSB7XG4gICAgICAgIC8vIEZhbGxiYWNrXG4gICAgICAgIGlzUG0gPSBsb2NhbGUuaXNQTShtZXJpZGllbSk7XG4gICAgICAgIGlmIChpc1BtICYmIGhvdXIgPCAxMikge1xuICAgICAgICAgICAgaG91ciArPSAxMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzUG0gJiYgaG91ciA9PT0gMTIpIHtcbiAgICAgICAgICAgIGhvdXIgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBob3VyO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHRoaXMgaXMgbm90IHN1cHBvc2VkIHRvIGhhcHBlblxuICAgICAgICByZXR1cm4gaG91cjtcbiAgICB9XG59XG5cbi8vIGRhdGUgZnJvbSBzdHJpbmcgYW5kIGFycmF5IG9mIGZvcm1hdCBzdHJpbmdzXG5mdW5jdGlvbiBjb25maWdGcm9tU3RyaW5nQW5kQXJyYXkoY29uZmlnKSB7XG4gICAgdmFyIHRlbXBDb25maWcsXG4gICAgICAgIGJlc3RNb21lbnQsXG5cbiAgICAgICAgc2NvcmVUb0JlYXQsXG4gICAgICAgIGksXG4gICAgICAgIGN1cnJlbnRTY29yZTtcblxuICAgIGlmIChjb25maWcuX2YubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmludmFsaWRGb3JtYXQgPSB0cnVlO1xuICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShOYU4pO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IGNvbmZpZy5fZi5sZW5ndGg7IGkrKykge1xuICAgICAgICBjdXJyZW50U2NvcmUgPSAwO1xuICAgICAgICB0ZW1wQ29uZmlnID0gY29weUNvbmZpZyh7fSwgY29uZmlnKTtcbiAgICAgICAgaWYgKGNvbmZpZy5fdXNlVVRDICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRlbXBDb25maWcuX3VzZVVUQyA9IGNvbmZpZy5fdXNlVVRDO1xuICAgICAgICB9XG4gICAgICAgIHRlbXBDb25maWcuX2YgPSBjb25maWcuX2ZbaV07XG4gICAgICAgIGNvbmZpZ0Zyb21TdHJpbmdBbmRGb3JtYXQodGVtcENvbmZpZyk7XG5cbiAgICAgICAgaWYgKCFpc1ZhbGlkKHRlbXBDb25maWcpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHRoZXJlIGlzIGFueSBpbnB1dCB0aGF0IHdhcyBub3QgcGFyc2VkIGFkZCBhIHBlbmFsdHkgZm9yIHRoYXQgZm9ybWF0XG4gICAgICAgIGN1cnJlbnRTY29yZSArPSBnZXRQYXJzaW5nRmxhZ3ModGVtcENvbmZpZykuY2hhcnNMZWZ0T3ZlcjtcblxuICAgICAgICAvL29yIHRva2Vuc1xuICAgICAgICBjdXJyZW50U2NvcmUgKz0gZ2V0UGFyc2luZ0ZsYWdzKHRlbXBDb25maWcpLnVudXNlZFRva2Vucy5sZW5ndGggKiAxMDtcblxuICAgICAgICBnZXRQYXJzaW5nRmxhZ3ModGVtcENvbmZpZykuc2NvcmUgPSBjdXJyZW50U2NvcmU7XG5cbiAgICAgICAgaWYgKHNjb3JlVG9CZWF0ID09IG51bGwgfHwgY3VycmVudFNjb3JlIDwgc2NvcmVUb0JlYXQpIHtcbiAgICAgICAgICAgIHNjb3JlVG9CZWF0ID0gY3VycmVudFNjb3JlO1xuICAgICAgICAgICAgYmVzdE1vbWVudCA9IHRlbXBDb25maWc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBleHRlbmQoY29uZmlnLCBiZXN0TW9tZW50IHx8IHRlbXBDb25maWcpO1xufVxuXG5mdW5jdGlvbiBjb25maWdGcm9tT2JqZWN0KGNvbmZpZykge1xuICAgIGlmIChjb25maWcuX2QpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBpID0gbm9ybWFsaXplT2JqZWN0VW5pdHMoY29uZmlnLl9pKTtcbiAgICBjb25maWcuX2EgPSBtYXAoW2kueWVhciwgaS5tb250aCwgaS5kYXkgfHwgaS5kYXRlLCBpLmhvdXIsIGkubWludXRlLCBpLnNlY29uZCwgaS5taWxsaXNlY29uZF0sIGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiAmJiBwYXJzZUludChvYmosIDEwKTtcbiAgICB9KTtcblxuICAgIGNvbmZpZ0Zyb21BcnJheShjb25maWcpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVGcm9tQ29uZmlnIChjb25maWcpIHtcbiAgICB2YXIgcmVzID0gbmV3IE1vbWVudChjaGVja092ZXJmbG93KHByZXBhcmVDb25maWcoY29uZmlnKSkpO1xuICAgIGlmIChyZXMuX25leHREYXkpIHtcbiAgICAgICAgLy8gQWRkaW5nIGlzIHNtYXJ0IGVub3VnaCBhcm91bmQgRFNUXG4gICAgICAgIHJlcy5hZGQoMSwgJ2QnKTtcbiAgICAgICAgcmVzLl9uZXh0RGF5ID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHJldHVybiByZXM7XG59XG5cbmZ1bmN0aW9uIHByZXBhcmVDb25maWcgKGNvbmZpZykge1xuICAgIHZhciBpbnB1dCA9IGNvbmZpZy5faSxcbiAgICAgICAgZm9ybWF0ID0gY29uZmlnLl9mO1xuXG4gICAgY29uZmlnLl9sb2NhbGUgPSBjb25maWcuX2xvY2FsZSB8fCBnZXRMb2NhbGUoY29uZmlnLl9sKTtcblxuICAgIGlmIChpbnB1dCA9PT0gbnVsbCB8fCAoZm9ybWF0ID09PSB1bmRlZmluZWQgJiYgaW5wdXQgPT09ICcnKSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlSW52YWxpZCh7bnVsbElucHV0OiB0cnVlfSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29uZmlnLl9pID0gaW5wdXQgPSBjb25maWcuX2xvY2FsZS5wcmVwYXJzZShpbnB1dCk7XG4gICAgfVxuXG4gICAgaWYgKGlzTW9tZW50KGlucHV0KSkge1xuICAgICAgICByZXR1cm4gbmV3IE1vbWVudChjaGVja092ZXJmbG93KGlucHV0KSk7XG4gICAgfSBlbHNlIGlmIChpc0RhdGUoaW5wdXQpKSB7XG4gICAgICAgIGNvbmZpZy5fZCA9IGlucHV0O1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheShmb3JtYXQpKSB7XG4gICAgICAgIGNvbmZpZ0Zyb21TdHJpbmdBbmRBcnJheShjb25maWcpO1xuICAgIH0gZWxzZSBpZiAoZm9ybWF0KSB7XG4gICAgICAgIGNvbmZpZ0Zyb21TdHJpbmdBbmRGb3JtYXQoY29uZmlnKTtcbiAgICB9ICBlbHNlIHtcbiAgICAgICAgY29uZmlnRnJvbUlucHV0KGNvbmZpZyk7XG4gICAgfVxuXG4gICAgaWYgKCFpc1ZhbGlkKGNvbmZpZykpIHtcbiAgICAgICAgY29uZmlnLl9kID0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gY29uZmlnO1xufVxuXG5mdW5jdGlvbiBjb25maWdGcm9tSW5wdXQoY29uZmlnKSB7XG4gICAgdmFyIGlucHV0ID0gY29uZmlnLl9pO1xuICAgIGlmIChpc1VuZGVmaW5lZChpbnB1dCkpIHtcbiAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoaG9va3Mubm93KCkpO1xuICAgIH0gZWxzZSBpZiAoaXNEYXRlKGlucHV0KSkge1xuICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShpbnB1dC52YWx1ZU9mKCkpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICBjb25maWdGcm9tU3RyaW5nKGNvbmZpZyk7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KGlucHV0KSkge1xuICAgICAgICBjb25maWcuX2EgPSBtYXAoaW5wdXQuc2xpY2UoMCksIGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUludChvYmosIDEwKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbmZpZ0Zyb21BcnJheShjb25maWcpO1xuICAgIH0gZWxzZSBpZiAoaXNPYmplY3QoaW5wdXQpKSB7XG4gICAgICAgIGNvbmZpZ0Zyb21PYmplY3QoY29uZmlnKTtcbiAgICB9IGVsc2UgaWYgKGlzTnVtYmVyKGlucHV0KSkge1xuICAgICAgICAvLyBmcm9tIG1pbGxpc2Vjb25kc1xuICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShpbnB1dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaG9va3MuY3JlYXRlRnJvbUlucHV0RmFsbGJhY2soY29uZmlnKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUxvY2FsT3JVVEMgKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0LCBpc1VUQykge1xuICAgIHZhciBjID0ge307XG5cbiAgICBpZiAobG9jYWxlID09PSB0cnVlIHx8IGxvY2FsZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgc3RyaWN0ID0gbG9jYWxlO1xuICAgICAgICBsb2NhbGUgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgaWYgKChpc09iamVjdChpbnB1dCkgJiYgaXNPYmplY3RFbXB0eShpbnB1dCkpIHx8XG4gICAgICAgICAgICAoaXNBcnJheShpbnB1dCkgJiYgaW5wdXQubGVuZ3RoID09PSAwKSkge1xuICAgICAgICBpbnB1dCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLy8gb2JqZWN0IGNvbnN0cnVjdGlvbiBtdXN0IGJlIGRvbmUgdGhpcyB3YXkuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvaXNzdWVzLzE0MjNcbiAgICBjLl9pc0FNb21lbnRPYmplY3QgPSB0cnVlO1xuICAgIGMuX3VzZVVUQyA9IGMuX2lzVVRDID0gaXNVVEM7XG4gICAgYy5fbCA9IGxvY2FsZTtcbiAgICBjLl9pID0gaW5wdXQ7XG4gICAgYy5fZiA9IGZvcm1hdDtcbiAgICBjLl9zdHJpY3QgPSBzdHJpY3Q7XG5cbiAgICByZXR1cm4gY3JlYXRlRnJvbUNvbmZpZyhjKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTG9jYWwgKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0KSB7XG4gICAgcmV0dXJuIGNyZWF0ZUxvY2FsT3JVVEMoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QsIGZhbHNlKTtcbn1cblxudmFyIHByb3RvdHlwZU1pbiA9IGRlcHJlY2F0ZShcbiAgICAnbW9tZW50KCkubWluIGlzIGRlcHJlY2F0ZWQsIHVzZSBtb21lbnQubWF4IGluc3RlYWQuIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvbWluLW1heC8nLFxuICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG90aGVyID0gY3JlYXRlTG9jYWwuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgaWYgKHRoaXMuaXNWYWxpZCgpICYmIG90aGVyLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG90aGVyIDwgdGhpcyA/IHRoaXMgOiBvdGhlcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVJbnZhbGlkKCk7XG4gICAgICAgIH1cbiAgICB9XG4pO1xuXG52YXIgcHJvdG90eXBlTWF4ID0gZGVwcmVjYXRlKFxuICAgICdtb21lbnQoKS5tYXggaXMgZGVwcmVjYXRlZCwgdXNlIG1vbWVudC5taW4gaW5zdGVhZC4gaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9taW4tbWF4LycsXG4gICAgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb3RoZXIgPSBjcmVhdGVMb2NhbC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICBpZiAodGhpcy5pc1ZhbGlkKCkgJiYgb3RoZXIuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gb3RoZXIgPiB0aGlzID8gdGhpcyA6IG90aGVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUludmFsaWQoKTtcbiAgICAgICAgfVxuICAgIH1cbik7XG5cbi8vIFBpY2sgYSBtb21lbnQgbSBmcm9tIG1vbWVudHMgc28gdGhhdCBtW2ZuXShvdGhlcikgaXMgdHJ1ZSBmb3IgYWxsXG4vLyBvdGhlci4gVGhpcyByZWxpZXMgb24gdGhlIGZ1bmN0aW9uIGZuIHRvIGJlIHRyYW5zaXRpdmUuXG4vL1xuLy8gbW9tZW50cyBzaG91bGQgZWl0aGVyIGJlIGFuIGFycmF5IG9mIG1vbWVudCBvYmplY3RzIG9yIGFuIGFycmF5LCB3aG9zZVxuLy8gZmlyc3QgZWxlbWVudCBpcyBhbiBhcnJheSBvZiBtb21lbnQgb2JqZWN0cy5cbmZ1bmN0aW9uIHBpY2tCeShmbiwgbW9tZW50cykge1xuICAgIHZhciByZXMsIGk7XG4gICAgaWYgKG1vbWVudHMubGVuZ3RoID09PSAxICYmIGlzQXJyYXkobW9tZW50c1swXSkpIHtcbiAgICAgICAgbW9tZW50cyA9IG1vbWVudHNbMF07XG4gICAgfVxuICAgIGlmICghbW9tZW50cy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUxvY2FsKCk7XG4gICAgfVxuICAgIHJlcyA9IG1vbWVudHNbMF07XG4gICAgZm9yIChpID0gMTsgaSA8IG1vbWVudHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKCFtb21lbnRzW2ldLmlzVmFsaWQoKSB8fCBtb21lbnRzW2ldW2ZuXShyZXMpKSB7XG4gICAgICAgICAgICByZXMgPSBtb21lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5cbi8vIFRPRE86IFVzZSBbXS5zb3J0IGluc3RlYWQ/XG5mdW5jdGlvbiBtaW4gKCkge1xuICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuXG4gICAgcmV0dXJuIHBpY2tCeSgnaXNCZWZvcmUnLCBhcmdzKTtcbn1cblxuZnVuY3Rpb24gbWF4ICgpIHtcbiAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcblxuICAgIHJldHVybiBwaWNrQnkoJ2lzQWZ0ZXInLCBhcmdzKTtcbn1cblxudmFyIG5vdyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gRGF0ZS5ub3cgPyBEYXRlLm5vdygpIDogKyhuZXcgRGF0ZSgpKTtcbn07XG5cbnZhciBvcmRlcmluZyA9IFsneWVhcicsICdxdWFydGVyJywgJ21vbnRoJywgJ3dlZWsnLCAnZGF5JywgJ2hvdXInLCAnbWludXRlJywgJ3NlY29uZCcsICdtaWxsaXNlY29uZCddO1xuXG5mdW5jdGlvbiBpc0R1cmF0aW9uVmFsaWQobSkge1xuICAgIGZvciAodmFyIGtleSBpbiBtKSB7XG4gICAgICAgIGlmICghKGluZGV4T2YuY2FsbChvcmRlcmluZywga2V5KSAhPT0gLTEgJiYgKG1ba2V5XSA9PSBudWxsIHx8ICFpc05hTihtW2tleV0pKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciB1bml0SGFzRGVjaW1hbCA9IGZhbHNlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3JkZXJpbmcubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKG1bb3JkZXJpbmdbaV1dKSB7XG4gICAgICAgICAgICBpZiAodW5pdEhhc0RlY2ltYWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIG9ubHkgYWxsb3cgbm9uLWludGVnZXJzIGZvciBzbWFsbGVzdCB1bml0XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFyc2VGbG9hdChtW29yZGVyaW5nW2ldXSkgIT09IHRvSW50KG1bb3JkZXJpbmdbaV1dKSkge1xuICAgICAgICAgICAgICAgIHVuaXRIYXNEZWNpbWFsID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBpc1ZhbGlkJDEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzVmFsaWQ7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUludmFsaWQkMSgpIHtcbiAgICByZXR1cm4gY3JlYXRlRHVyYXRpb24oTmFOKTtcbn1cblxuZnVuY3Rpb24gRHVyYXRpb24gKGR1cmF0aW9uKSB7XG4gICAgdmFyIG5vcm1hbGl6ZWRJbnB1dCA9IG5vcm1hbGl6ZU9iamVjdFVuaXRzKGR1cmF0aW9uKSxcbiAgICAgICAgeWVhcnMgPSBub3JtYWxpemVkSW5wdXQueWVhciB8fCAwLFxuICAgICAgICBxdWFydGVycyA9IG5vcm1hbGl6ZWRJbnB1dC5xdWFydGVyIHx8IDAsXG4gICAgICAgIG1vbnRocyA9IG5vcm1hbGl6ZWRJbnB1dC5tb250aCB8fCAwLFxuICAgICAgICB3ZWVrcyA9IG5vcm1hbGl6ZWRJbnB1dC53ZWVrIHx8IDAsXG4gICAgICAgIGRheXMgPSBub3JtYWxpemVkSW5wdXQuZGF5IHx8IDAsXG4gICAgICAgIGhvdXJzID0gbm9ybWFsaXplZElucHV0LmhvdXIgfHwgMCxcbiAgICAgICAgbWludXRlcyA9IG5vcm1hbGl6ZWRJbnB1dC5taW51dGUgfHwgMCxcbiAgICAgICAgc2Vjb25kcyA9IG5vcm1hbGl6ZWRJbnB1dC5zZWNvbmQgfHwgMCxcbiAgICAgICAgbWlsbGlzZWNvbmRzID0gbm9ybWFsaXplZElucHV0Lm1pbGxpc2Vjb25kIHx8IDA7XG5cbiAgICB0aGlzLl9pc1ZhbGlkID0gaXNEdXJhdGlvblZhbGlkKG5vcm1hbGl6ZWRJbnB1dCk7XG5cbiAgICAvLyByZXByZXNlbnRhdGlvbiBmb3IgZGF0ZUFkZFJlbW92ZVxuICAgIHRoaXMuX21pbGxpc2Vjb25kcyA9ICttaWxsaXNlY29uZHMgK1xuICAgICAgICBzZWNvbmRzICogMWUzICsgLy8gMTAwMFxuICAgICAgICBtaW51dGVzICogNmU0ICsgLy8gMTAwMCAqIDYwXG4gICAgICAgIGhvdXJzICogMTAwMCAqIDYwICogNjA7IC8vdXNpbmcgMTAwMCAqIDYwICogNjAgaW5zdGVhZCBvZiAzNmU1IHRvIGF2b2lkIGZsb2F0aW5nIHBvaW50IHJvdW5kaW5nIGVycm9ycyBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9pc3N1ZXMvMjk3OFxuICAgIC8vIEJlY2F1c2Ugb2YgZGF0ZUFkZFJlbW92ZSB0cmVhdHMgMjQgaG91cnMgYXMgZGlmZmVyZW50IGZyb20gYVxuICAgIC8vIGRheSB3aGVuIHdvcmtpbmcgYXJvdW5kIERTVCwgd2UgbmVlZCB0byBzdG9yZSB0aGVtIHNlcGFyYXRlbHlcbiAgICB0aGlzLl9kYXlzID0gK2RheXMgK1xuICAgICAgICB3ZWVrcyAqIDc7XG4gICAgLy8gSXQgaXMgaW1wb3NzaWJsZSB0byB0cmFuc2xhdGUgbW9udGhzIGludG8gZGF5cyB3aXRob3V0IGtub3dpbmdcbiAgICAvLyB3aGljaCBtb250aHMgeW91IGFyZSBhcmUgdGFsa2luZyBhYm91dCwgc28gd2UgaGF2ZSB0byBzdG9yZVxuICAgIC8vIGl0IHNlcGFyYXRlbHkuXG4gICAgdGhpcy5fbW9udGhzID0gK21vbnRocyArXG4gICAgICAgIHF1YXJ0ZXJzICogMyArXG4gICAgICAgIHllYXJzICogMTI7XG5cbiAgICB0aGlzLl9kYXRhID0ge307XG5cbiAgICB0aGlzLl9sb2NhbGUgPSBnZXRMb2NhbGUoKTtcblxuICAgIHRoaXMuX2J1YmJsZSgpO1xufVxuXG5mdW5jdGlvbiBpc0R1cmF0aW9uIChvYmopIHtcbiAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgRHVyYXRpb247XG59XG5cbmZ1bmN0aW9uIGFic1JvdW5kIChudW1iZXIpIHtcbiAgICBpZiAobnVtYmVyIDwgMCkge1xuICAgICAgICByZXR1cm4gTWF0aC5yb3VuZCgtMSAqIG51bWJlcikgKiAtMTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChudW1iZXIpO1xuICAgIH1cbn1cblxuLy8gRk9STUFUVElOR1xuXG5mdW5jdGlvbiBvZmZzZXQgKHRva2VuLCBzZXBhcmF0b3IpIHtcbiAgICBhZGRGb3JtYXRUb2tlbih0b2tlbiwgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy51dGNPZmZzZXQoKTtcbiAgICAgICAgdmFyIHNpZ24gPSAnKyc7XG4gICAgICAgIGlmIChvZmZzZXQgPCAwKSB7XG4gICAgICAgICAgICBvZmZzZXQgPSAtb2Zmc2V0O1xuICAgICAgICAgICAgc2lnbiA9ICctJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2lnbiArIHplcm9GaWxsKH5+KG9mZnNldCAvIDYwKSwgMikgKyBzZXBhcmF0b3IgKyB6ZXJvRmlsbCh+fihvZmZzZXQpICUgNjAsIDIpO1xuICAgIH0pO1xufVxuXG5vZmZzZXQoJ1onLCAnOicpO1xub2Zmc2V0KCdaWicsICcnKTtcblxuLy8gUEFSU0lOR1xuXG5hZGRSZWdleFRva2VuKCdaJywgIG1hdGNoU2hvcnRPZmZzZXQpO1xuYWRkUmVnZXhUb2tlbignWlonLCBtYXRjaFNob3J0T2Zmc2V0KTtcbmFkZFBhcnNlVG9rZW4oWydaJywgJ1paJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgIGNvbmZpZy5fdXNlVVRDID0gdHJ1ZTtcbiAgICBjb25maWcuX3R6bSA9IG9mZnNldEZyb21TdHJpbmcobWF0Y2hTaG9ydE9mZnNldCwgaW5wdXQpO1xufSk7XG5cbi8vIEhFTFBFUlNcblxuLy8gdGltZXpvbmUgY2h1bmtlclxuLy8gJysxMDowMCcgPiBbJzEwJywgICcwMCddXG4vLyAnLTE1MzAnICA+IFsnLTE1JywgJzMwJ11cbnZhciBjaHVua09mZnNldCA9IC8oW1xcK1xcLV18XFxkXFxkKS9naTtcblxuZnVuY3Rpb24gb2Zmc2V0RnJvbVN0cmluZyhtYXRjaGVyLCBzdHJpbmcpIHtcbiAgICB2YXIgbWF0Y2hlcyA9IChzdHJpbmcgfHwgJycpLm1hdGNoKG1hdGNoZXIpO1xuXG4gICAgaWYgKG1hdGNoZXMgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGNodW5rICAgPSBtYXRjaGVzW21hdGNoZXMubGVuZ3RoIC0gMV0gfHwgW107XG4gICAgdmFyIHBhcnRzICAgPSAoY2h1bmsgKyAnJykubWF0Y2goY2h1bmtPZmZzZXQpIHx8IFsnLScsIDAsIDBdO1xuICAgIHZhciBtaW51dGVzID0gKyhwYXJ0c1sxXSAqIDYwKSArIHRvSW50KHBhcnRzWzJdKTtcblxuICAgIHJldHVybiBtaW51dGVzID09PSAwID9cbiAgICAgIDAgOlxuICAgICAgcGFydHNbMF0gPT09ICcrJyA/IG1pbnV0ZXMgOiAtbWludXRlcztcbn1cblxuLy8gUmV0dXJuIGEgbW9tZW50IGZyb20gaW5wdXQsIHRoYXQgaXMgbG9jYWwvdXRjL3pvbmUgZXF1aXZhbGVudCB0byBtb2RlbC5cbmZ1bmN0aW9uIGNsb25lV2l0aE9mZnNldChpbnB1dCwgbW9kZWwpIHtcbiAgICB2YXIgcmVzLCBkaWZmO1xuICAgIGlmIChtb2RlbC5faXNVVEMpIHtcbiAgICAgICAgcmVzID0gbW9kZWwuY2xvbmUoKTtcbiAgICAgICAgZGlmZiA9IChpc01vbWVudChpbnB1dCkgfHwgaXNEYXRlKGlucHV0KSA/IGlucHV0LnZhbHVlT2YoKSA6IGNyZWF0ZUxvY2FsKGlucHV0KS52YWx1ZU9mKCkpIC0gcmVzLnZhbHVlT2YoKTtcbiAgICAgICAgLy8gVXNlIGxvdy1sZXZlbCBhcGksIGJlY2F1c2UgdGhpcyBmbiBpcyBsb3ctbGV2ZWwgYXBpLlxuICAgICAgICByZXMuX2Quc2V0VGltZShyZXMuX2QudmFsdWVPZigpICsgZGlmZik7XG4gICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldChyZXMsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gY3JlYXRlTG9jYWwoaW5wdXQpLmxvY2FsKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBnZXREYXRlT2Zmc2V0IChtKSB7XG4gICAgLy8gT24gRmlyZWZveC4yNCBEYXRlI2dldFRpbWV6b25lT2Zmc2V0IHJldHVybnMgYSBmbG9hdGluZyBwb2ludC5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9wdWxsLzE4NzFcbiAgICByZXR1cm4gLU1hdGgucm91bmQobS5fZC5nZXRUaW1lem9uZU9mZnNldCgpIC8gMTUpICogMTU7XG59XG5cbi8vIEhPT0tTXG5cbi8vIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgd2hlbmV2ZXIgYSBtb21lbnQgaXMgbXV0YXRlZC5cbi8vIEl0IGlzIGludGVuZGVkIHRvIGtlZXAgdGhlIG9mZnNldCBpbiBzeW5jIHdpdGggdGhlIHRpbWV6b25lLlxuaG9va3MudXBkYXRlT2Zmc2V0ID0gZnVuY3Rpb24gKCkge307XG5cbi8vIE1PTUVOVFNcblxuLy8ga2VlcExvY2FsVGltZSA9IHRydWUgbWVhbnMgb25seSBjaGFuZ2UgdGhlIHRpbWV6b25lLCB3aXRob3V0XG4vLyBhZmZlY3RpbmcgdGhlIGxvY2FsIGhvdXIuIFNvIDU6MzE6MjYgKzAzMDAgLS1bdXRjT2Zmc2V0KDIsIHRydWUpXS0tPlxuLy8gNTozMToyNiArMDIwMCBJdCBpcyBwb3NzaWJsZSB0aGF0IDU6MzE6MjYgZG9lc24ndCBleGlzdCB3aXRoIG9mZnNldFxuLy8gKzAyMDAsIHNvIHdlIGFkanVzdCB0aGUgdGltZSBhcyBuZWVkZWQsIHRvIGJlIHZhbGlkLlxuLy9cbi8vIEtlZXBpbmcgdGhlIHRpbWUgYWN0dWFsbHkgYWRkcy9zdWJ0cmFjdHMgKG9uZSBob3VyKVxuLy8gZnJvbSB0aGUgYWN0dWFsIHJlcHJlc2VudGVkIHRpbWUuIFRoYXQgaXMgd2h5IHdlIGNhbGwgdXBkYXRlT2Zmc2V0XG4vLyBhIHNlY29uZCB0aW1lLiBJbiBjYXNlIGl0IHdhbnRzIHVzIHRvIGNoYW5nZSB0aGUgb2Zmc2V0IGFnYWluXG4vLyBfY2hhbmdlSW5Qcm9ncmVzcyA9PSB0cnVlIGNhc2UsIHRoZW4gd2UgaGF2ZSB0byBhZGp1c3QsIGJlY2F1c2Vcbi8vIHRoZXJlIGlzIG5vIHN1Y2ggdGltZSBpbiB0aGUgZ2l2ZW4gdGltZXpvbmUuXG5mdW5jdGlvbiBnZXRTZXRPZmZzZXQgKGlucHV0LCBrZWVwTG9jYWxUaW1lLCBrZWVwTWludXRlcykge1xuICAgIHZhciBvZmZzZXQgPSB0aGlzLl9vZmZzZXQgfHwgMCxcbiAgICAgICAgbG9jYWxBZGp1c3Q7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICByZXR1cm4gaW5wdXQgIT0gbnVsbCA/IHRoaXMgOiBOYU47XG4gICAgfVxuICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpbnB1dCA9IG9mZnNldEZyb21TdHJpbmcobWF0Y2hTaG9ydE9mZnNldCwgaW5wdXQpO1xuICAgICAgICAgICAgaWYgKGlucHV0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoTWF0aC5hYnMoaW5wdXQpIDwgMTYgJiYgIWtlZXBNaW51dGVzKSB7XG4gICAgICAgICAgICBpbnB1dCA9IGlucHV0ICogNjA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9pc1VUQyAmJiBrZWVwTG9jYWxUaW1lKSB7XG4gICAgICAgICAgICBsb2NhbEFkanVzdCA9IGdldERhdGVPZmZzZXQodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fb2Zmc2V0ID0gaW5wdXQ7XG4gICAgICAgIHRoaXMuX2lzVVRDID0gdHJ1ZTtcbiAgICAgICAgaWYgKGxvY2FsQWRqdXN0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkKGxvY2FsQWRqdXN0LCAnbScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvZmZzZXQgIT09IGlucHV0KSB7XG4gICAgICAgICAgICBpZiAoIWtlZXBMb2NhbFRpbWUgfHwgdGhpcy5fY2hhbmdlSW5Qcm9ncmVzcykge1xuICAgICAgICAgICAgICAgIGFkZFN1YnRyYWN0KHRoaXMsIGNyZWF0ZUR1cmF0aW9uKGlucHV0IC0gb2Zmc2V0LCAnbScpLCAxLCBmYWxzZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLl9jaGFuZ2VJblByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2hhbmdlSW5Qcm9ncmVzcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KHRoaXMsIHRydWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5nZUluUHJvZ3Jlc3MgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc1VUQyA/IG9mZnNldCA6IGdldERhdGVPZmZzZXQodGhpcyk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBnZXRTZXRab25lIChpbnB1dCwga2VlcExvY2FsVGltZSkge1xuICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpbnB1dCA9IC1pbnB1dDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudXRjT2Zmc2V0KGlucHV0LCBrZWVwTG9jYWxUaW1lKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gLXRoaXMudXRjT2Zmc2V0KCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBzZXRPZmZzZXRUb1VUQyAoa2VlcExvY2FsVGltZSkge1xuICAgIHJldHVybiB0aGlzLnV0Y09mZnNldCgwLCBrZWVwTG9jYWxUaW1lKTtcbn1cblxuZnVuY3Rpb24gc2V0T2Zmc2V0VG9Mb2NhbCAoa2VlcExvY2FsVGltZSkge1xuICAgIGlmICh0aGlzLl9pc1VUQykge1xuICAgICAgICB0aGlzLnV0Y09mZnNldCgwLCBrZWVwTG9jYWxUaW1lKTtcbiAgICAgICAgdGhpcy5faXNVVEMgPSBmYWxzZTtcblxuICAgICAgICBpZiAoa2VlcExvY2FsVGltZSkge1xuICAgICAgICAgICAgdGhpcy5zdWJ0cmFjdChnZXREYXRlT2Zmc2V0KHRoaXMpLCAnbScpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufVxuXG5mdW5jdGlvbiBzZXRPZmZzZXRUb1BhcnNlZE9mZnNldCAoKSB7XG4gICAgaWYgKHRoaXMuX3R6bSAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMudXRjT2Zmc2V0KHRoaXMuX3R6bSwgZmFsc2UsIHRydWUpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoaXMuX2kgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHZhciB0Wm9uZSA9IG9mZnNldEZyb21TdHJpbmcobWF0Y2hPZmZzZXQsIHRoaXMuX2kpO1xuICAgICAgICBpZiAodFpvbmUgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQodFpvbmUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQoMCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59XG5cbmZ1bmN0aW9uIGhhc0FsaWduZWRIb3VyT2Zmc2V0IChpbnB1dCkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpbnB1dCA9IGlucHV0ID8gY3JlYXRlTG9jYWwoaW5wdXQpLnV0Y09mZnNldCgpIDogMDtcblxuICAgIHJldHVybiAodGhpcy51dGNPZmZzZXQoKSAtIGlucHV0KSAlIDYwID09PSAwO1xufVxuXG5mdW5jdGlvbiBpc0RheWxpZ2h0U2F2aW5nVGltZSAoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgdGhpcy51dGNPZmZzZXQoKSA+IHRoaXMuY2xvbmUoKS5tb250aCgwKS51dGNPZmZzZXQoKSB8fFxuICAgICAgICB0aGlzLnV0Y09mZnNldCgpID4gdGhpcy5jbG9uZSgpLm1vbnRoKDUpLnV0Y09mZnNldCgpXG4gICAgKTtcbn1cblxuZnVuY3Rpb24gaXNEYXlsaWdodFNhdmluZ1RpbWVTaGlmdGVkICgpIHtcbiAgICBpZiAoIWlzVW5kZWZpbmVkKHRoaXMuX2lzRFNUU2hpZnRlZCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzRFNUU2hpZnRlZDtcbiAgICB9XG5cbiAgICB2YXIgYyA9IHt9O1xuXG4gICAgY29weUNvbmZpZyhjLCB0aGlzKTtcbiAgICBjID0gcHJlcGFyZUNvbmZpZyhjKTtcblxuICAgIGlmIChjLl9hKSB7XG4gICAgICAgIHZhciBvdGhlciA9IGMuX2lzVVRDID8gY3JlYXRlVVRDKGMuX2EpIDogY3JlYXRlTG9jYWwoYy5fYSk7XG4gICAgICAgIHRoaXMuX2lzRFNUU2hpZnRlZCA9IHRoaXMuaXNWYWxpZCgpICYmXG4gICAgICAgICAgICBjb21wYXJlQXJyYXlzKGMuX2EsIG90aGVyLnRvQXJyYXkoKSkgPiAwO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2lzRFNUU2hpZnRlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9pc0RTVFNoaWZ0ZWQ7XG59XG5cbmZ1bmN0aW9uIGlzTG9jYWwgKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/ICF0aGlzLl9pc1VUQyA6IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1V0Y09mZnNldCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpID8gdGhpcy5faXNVVEMgOiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNVdGMgKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/IHRoaXMuX2lzVVRDICYmIHRoaXMuX29mZnNldCA9PT0gMCA6IGZhbHNlO1xufVxuXG4vLyBBU1AuTkVUIGpzb24gZGF0ZSBmb3JtYXQgcmVnZXhcbnZhciBhc3BOZXRSZWdleCA9IC9eKFxcLXxcXCspPyg/OihcXGQqKVsuIF0pPyhcXGQrKVxcOihcXGQrKSg/OlxcOihcXGQrKShcXC5cXGQqKT8pPyQvO1xuXG4vLyBmcm9tIGh0dHA6Ly9kb2NzLmNsb3N1cmUtbGlicmFyeS5nb29nbGVjb2RlLmNvbS9naXQvY2xvc3VyZV9nb29nX2RhdGVfZGF0ZS5qcy5zb3VyY2UuaHRtbFxuLy8gc29tZXdoYXQgbW9yZSBpbiBsaW5lIHdpdGggNC40LjMuMiAyMDA0IHNwZWMsIGJ1dCBhbGxvd3MgZGVjaW1hbCBhbnl3aGVyZVxuLy8gYW5kIGZ1cnRoZXIgbW9kaWZpZWQgdG8gYWxsb3cgZm9yIHN0cmluZ3MgY29udGFpbmluZyBib3RoIHdlZWsgYW5kIGRheVxudmFyIGlzb1JlZ2V4ID0gL14oLXxcXCspP1AoPzooWy0rXT9bMC05LC5dKilZKT8oPzooWy0rXT9bMC05LC5dKilNKT8oPzooWy0rXT9bMC05LC5dKilXKT8oPzooWy0rXT9bMC05LC5dKilEKT8oPzpUKD86KFstK10/WzAtOSwuXSopSCk/KD86KFstK10/WzAtOSwuXSopTSk/KD86KFstK10/WzAtOSwuXSopUyk/KT8kLztcblxuZnVuY3Rpb24gY3JlYXRlRHVyYXRpb24gKGlucHV0LCBrZXkpIHtcbiAgICB2YXIgZHVyYXRpb24gPSBpbnB1dCxcbiAgICAgICAgLy8gbWF0Y2hpbmcgYWdhaW5zdCByZWdleHAgaXMgZXhwZW5zaXZlLCBkbyBpdCBvbiBkZW1hbmRcbiAgICAgICAgbWF0Y2ggPSBudWxsLFxuICAgICAgICBzaWduLFxuICAgICAgICByZXQsXG4gICAgICAgIGRpZmZSZXM7XG5cbiAgICBpZiAoaXNEdXJhdGlvbihpbnB1dCkpIHtcbiAgICAgICAgZHVyYXRpb24gPSB7XG4gICAgICAgICAgICBtcyA6IGlucHV0Ll9taWxsaXNlY29uZHMsXG4gICAgICAgICAgICBkICA6IGlucHV0Ll9kYXlzLFxuICAgICAgICAgICAgTSAgOiBpbnB1dC5fbW9udGhzXG4gICAgICAgIH07XG4gICAgfSBlbHNlIGlmIChpc051bWJlcihpbnB1dCkpIHtcbiAgICAgICAgZHVyYXRpb24gPSB7fTtcbiAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgICAgZHVyYXRpb25ba2V5XSA9IGlucHV0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZHVyYXRpb24ubWlsbGlzZWNvbmRzID0gaW5wdXQ7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCEhKG1hdGNoID0gYXNwTmV0UmVnZXguZXhlYyhpbnB1dCkpKSB7XG4gICAgICAgIHNpZ24gPSAobWF0Y2hbMV0gPT09ICctJykgPyAtMSA6IDE7XG4gICAgICAgIGR1cmF0aW9uID0ge1xuICAgICAgICAgICAgeSAgOiAwLFxuICAgICAgICAgICAgZCAgOiB0b0ludChtYXRjaFtEQVRFXSkgICAgICAgICAgICAgICAgICAgICAgICAgKiBzaWduLFxuICAgICAgICAgICAgaCAgOiB0b0ludChtYXRjaFtIT1VSXSkgICAgICAgICAgICAgICAgICAgICAgICAgKiBzaWduLFxuICAgICAgICAgICAgbSAgOiB0b0ludChtYXRjaFtNSU5VVEVdKSAgICAgICAgICAgICAgICAgICAgICAgKiBzaWduLFxuICAgICAgICAgICAgcyAgOiB0b0ludChtYXRjaFtTRUNPTkRdKSAgICAgICAgICAgICAgICAgICAgICAgKiBzaWduLFxuICAgICAgICAgICAgbXMgOiB0b0ludChhYnNSb3VuZChtYXRjaFtNSUxMSVNFQ09ORF0gKiAxMDAwKSkgKiBzaWduIC8vIHRoZSBtaWxsaXNlY29uZCBkZWNpbWFsIHBvaW50IGlzIGluY2x1ZGVkIGluIHRoZSBtYXRjaFxuICAgICAgICB9O1xuICAgIH0gZWxzZSBpZiAoISEobWF0Y2ggPSBpc29SZWdleC5leGVjKGlucHV0KSkpIHtcbiAgICAgICAgc2lnbiA9IChtYXRjaFsxXSA9PT0gJy0nKSA/IC0xIDogKG1hdGNoWzFdID09PSAnKycpID8gMSA6IDE7XG4gICAgICAgIGR1cmF0aW9uID0ge1xuICAgICAgICAgICAgeSA6IHBhcnNlSXNvKG1hdGNoWzJdLCBzaWduKSxcbiAgICAgICAgICAgIE0gOiBwYXJzZUlzbyhtYXRjaFszXSwgc2lnbiksXG4gICAgICAgICAgICB3IDogcGFyc2VJc28obWF0Y2hbNF0sIHNpZ24pLFxuICAgICAgICAgICAgZCA6IHBhcnNlSXNvKG1hdGNoWzVdLCBzaWduKSxcbiAgICAgICAgICAgIGggOiBwYXJzZUlzbyhtYXRjaFs2XSwgc2lnbiksXG4gICAgICAgICAgICBtIDogcGFyc2VJc28obWF0Y2hbN10sIHNpZ24pLFxuICAgICAgICAgICAgcyA6IHBhcnNlSXNvKG1hdGNoWzhdLCBzaWduKVxuICAgICAgICB9O1xuICAgIH0gZWxzZSBpZiAoZHVyYXRpb24gPT0gbnVsbCkgey8vIGNoZWNrcyBmb3IgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgZHVyYXRpb24gPSB7fTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBkdXJhdGlvbiA9PT0gJ29iamVjdCcgJiYgKCdmcm9tJyBpbiBkdXJhdGlvbiB8fCAndG8nIGluIGR1cmF0aW9uKSkge1xuICAgICAgICBkaWZmUmVzID0gbW9tZW50c0RpZmZlcmVuY2UoY3JlYXRlTG9jYWwoZHVyYXRpb24uZnJvbSksIGNyZWF0ZUxvY2FsKGR1cmF0aW9uLnRvKSk7XG5cbiAgICAgICAgZHVyYXRpb24gPSB7fTtcbiAgICAgICAgZHVyYXRpb24ubXMgPSBkaWZmUmVzLm1pbGxpc2Vjb25kcztcbiAgICAgICAgZHVyYXRpb24uTSA9IGRpZmZSZXMubW9udGhzO1xuICAgIH1cblxuICAgIHJldCA9IG5ldyBEdXJhdGlvbihkdXJhdGlvbik7XG5cbiAgICBpZiAoaXNEdXJhdGlvbihpbnB1dCkgJiYgaGFzT3duUHJvcChpbnB1dCwgJ19sb2NhbGUnKSkge1xuICAgICAgICByZXQuX2xvY2FsZSA9IGlucHV0Ll9sb2NhbGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcbn1cblxuY3JlYXRlRHVyYXRpb24uZm4gPSBEdXJhdGlvbi5wcm90b3R5cGU7XG5jcmVhdGVEdXJhdGlvbi5pbnZhbGlkID0gY3JlYXRlSW52YWxpZCQxO1xuXG5mdW5jdGlvbiBwYXJzZUlzbyAoaW5wLCBzaWduKSB7XG4gICAgLy8gV2UnZCBub3JtYWxseSB1c2Ugfn5pbnAgZm9yIHRoaXMsIGJ1dCB1bmZvcnR1bmF0ZWx5IGl0IGFsc29cbiAgICAvLyBjb252ZXJ0cyBmbG9hdHMgdG8gaW50cy5cbiAgICAvLyBpbnAgbWF5IGJlIHVuZGVmaW5lZCwgc28gY2FyZWZ1bCBjYWxsaW5nIHJlcGxhY2Ugb24gaXQuXG4gICAgdmFyIHJlcyA9IGlucCAmJiBwYXJzZUZsb2F0KGlucC5yZXBsYWNlKCcsJywgJy4nKSk7XG4gICAgLy8gYXBwbHkgc2lnbiB3aGlsZSB3ZSdyZSBhdCBpdFxuICAgIHJldHVybiAoaXNOYU4ocmVzKSA/IDAgOiByZXMpICogc2lnbjtcbn1cblxuZnVuY3Rpb24gcG9zaXRpdmVNb21lbnRzRGlmZmVyZW5jZShiYXNlLCBvdGhlcikge1xuICAgIHZhciByZXMgPSB7bWlsbGlzZWNvbmRzOiAwLCBtb250aHM6IDB9O1xuXG4gICAgcmVzLm1vbnRocyA9IG90aGVyLm1vbnRoKCkgLSBiYXNlLm1vbnRoKCkgK1xuICAgICAgICAob3RoZXIueWVhcigpIC0gYmFzZS55ZWFyKCkpICogMTI7XG4gICAgaWYgKGJhc2UuY2xvbmUoKS5hZGQocmVzLm1vbnRocywgJ00nKS5pc0FmdGVyKG90aGVyKSkge1xuICAgICAgICAtLXJlcy5tb250aHM7XG4gICAgfVxuXG4gICAgcmVzLm1pbGxpc2Vjb25kcyA9ICtvdGhlciAtICsoYmFzZS5jbG9uZSgpLmFkZChyZXMubW9udGhzLCAnTScpKTtcblxuICAgIHJldHVybiByZXM7XG59XG5cbmZ1bmN0aW9uIG1vbWVudHNEaWZmZXJlbmNlKGJhc2UsIG90aGVyKSB7XG4gICAgdmFyIHJlcztcbiAgICBpZiAoIShiYXNlLmlzVmFsaWQoKSAmJiBvdGhlci5pc1ZhbGlkKCkpKSB7XG4gICAgICAgIHJldHVybiB7bWlsbGlzZWNvbmRzOiAwLCBtb250aHM6IDB9O1xuICAgIH1cblxuICAgIG90aGVyID0gY2xvbmVXaXRoT2Zmc2V0KG90aGVyLCBiYXNlKTtcbiAgICBpZiAoYmFzZS5pc0JlZm9yZShvdGhlcikpIHtcbiAgICAgICAgcmVzID0gcG9zaXRpdmVNb21lbnRzRGlmZmVyZW5jZShiYXNlLCBvdGhlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmVzID0gcG9zaXRpdmVNb21lbnRzRGlmZmVyZW5jZShvdGhlciwgYmFzZSk7XG4gICAgICAgIHJlcy5taWxsaXNlY29uZHMgPSAtcmVzLm1pbGxpc2Vjb25kcztcbiAgICAgICAgcmVzLm1vbnRocyA9IC1yZXMubW9udGhzO1xuICAgIH1cblxuICAgIHJldHVybiByZXM7XG59XG5cbi8vIFRPRE86IHJlbW92ZSAnbmFtZScgYXJnIGFmdGVyIGRlcHJlY2F0aW9uIGlzIHJlbW92ZWRcbmZ1bmN0aW9uIGNyZWF0ZUFkZGVyKGRpcmVjdGlvbiwgbmFtZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAodmFsLCBwZXJpb2QpIHtcbiAgICAgICAgdmFyIGR1ciwgdG1wO1xuICAgICAgICAvL2ludmVydCB0aGUgYXJndW1lbnRzLCBidXQgY29tcGxhaW4gYWJvdXQgaXRcbiAgICAgICAgaWYgKHBlcmlvZCAhPT0gbnVsbCAmJiAhaXNOYU4oK3BlcmlvZCkpIHtcbiAgICAgICAgICAgIGRlcHJlY2F0ZVNpbXBsZShuYW1lLCAnbW9tZW50KCkuJyArIG5hbWUgICsgJyhwZXJpb2QsIG51bWJlcikgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBtb21lbnQoKS4nICsgbmFtZSArICcobnVtYmVyLCBwZXJpb2QpLiAnICtcbiAgICAgICAgICAgICdTZWUgaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9hZGQtaW52ZXJ0ZWQtcGFyYW0vIGZvciBtb3JlIGluZm8uJyk7XG4gICAgICAgICAgICB0bXAgPSB2YWw7IHZhbCA9IHBlcmlvZDsgcGVyaW9kID0gdG1wO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFsID0gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgPyArdmFsIDogdmFsO1xuICAgICAgICBkdXIgPSBjcmVhdGVEdXJhdGlvbih2YWwsIHBlcmlvZCk7XG4gICAgICAgIGFkZFN1YnRyYWN0KHRoaXMsIGR1ciwgZGlyZWN0aW9uKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gYWRkU3VidHJhY3QgKG1vbSwgZHVyYXRpb24sIGlzQWRkaW5nLCB1cGRhdGVPZmZzZXQpIHtcbiAgICB2YXIgbWlsbGlzZWNvbmRzID0gZHVyYXRpb24uX21pbGxpc2Vjb25kcyxcbiAgICAgICAgZGF5cyA9IGFic1JvdW5kKGR1cmF0aW9uLl9kYXlzKSxcbiAgICAgICAgbW9udGhzID0gYWJzUm91bmQoZHVyYXRpb24uX21vbnRocyk7XG5cbiAgICBpZiAoIW1vbS5pc1ZhbGlkKCkpIHtcbiAgICAgICAgLy8gTm8gb3BcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHVwZGF0ZU9mZnNldCA9IHVwZGF0ZU9mZnNldCA9PSBudWxsID8gdHJ1ZSA6IHVwZGF0ZU9mZnNldDtcblxuICAgIGlmIChtb250aHMpIHtcbiAgICAgICAgc2V0TW9udGgobW9tLCBnZXQobW9tLCAnTW9udGgnKSArIG1vbnRocyAqIGlzQWRkaW5nKTtcbiAgICB9XG4gICAgaWYgKGRheXMpIHtcbiAgICAgICAgc2V0JDEobW9tLCAnRGF0ZScsIGdldChtb20sICdEYXRlJykgKyBkYXlzICogaXNBZGRpbmcpO1xuICAgIH1cbiAgICBpZiAobWlsbGlzZWNvbmRzKSB7XG4gICAgICAgIG1vbS5fZC5zZXRUaW1lKG1vbS5fZC52YWx1ZU9mKCkgKyBtaWxsaXNlY29uZHMgKiBpc0FkZGluZyk7XG4gICAgfVxuICAgIGlmICh1cGRhdGVPZmZzZXQpIHtcbiAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KG1vbSwgZGF5cyB8fCBtb250aHMpO1xuICAgIH1cbn1cblxudmFyIGFkZCAgICAgID0gY3JlYXRlQWRkZXIoMSwgJ2FkZCcpO1xudmFyIHN1YnRyYWN0ID0gY3JlYXRlQWRkZXIoLTEsICdzdWJ0cmFjdCcpO1xuXG5mdW5jdGlvbiBnZXRDYWxlbmRhckZvcm1hdChteU1vbWVudCwgbm93KSB7XG4gICAgdmFyIGRpZmYgPSBteU1vbWVudC5kaWZmKG5vdywgJ2RheXMnLCB0cnVlKTtcbiAgICByZXR1cm4gZGlmZiA8IC02ID8gJ3NhbWVFbHNlJyA6XG4gICAgICAgICAgICBkaWZmIDwgLTEgPyAnbGFzdFdlZWsnIDpcbiAgICAgICAgICAgIGRpZmYgPCAwID8gJ2xhc3REYXknIDpcbiAgICAgICAgICAgIGRpZmYgPCAxID8gJ3NhbWVEYXknIDpcbiAgICAgICAgICAgIGRpZmYgPCAyID8gJ25leHREYXknIDpcbiAgICAgICAgICAgIGRpZmYgPCA3ID8gJ25leHRXZWVrJyA6ICdzYW1lRWxzZSc7XG59XG5cbmZ1bmN0aW9uIGNhbGVuZGFyJDEgKHRpbWUsIGZvcm1hdHMpIHtcbiAgICAvLyBXZSB3YW50IHRvIGNvbXBhcmUgdGhlIHN0YXJ0IG9mIHRvZGF5LCB2cyB0aGlzLlxuICAgIC8vIEdldHRpbmcgc3RhcnQtb2YtdG9kYXkgZGVwZW5kcyBvbiB3aGV0aGVyIHdlJ3JlIGxvY2FsL3V0Yy9vZmZzZXQgb3Igbm90LlxuICAgIHZhciBub3cgPSB0aW1lIHx8IGNyZWF0ZUxvY2FsKCksXG4gICAgICAgIHNvZCA9IGNsb25lV2l0aE9mZnNldChub3csIHRoaXMpLnN0YXJ0T2YoJ2RheScpLFxuICAgICAgICBmb3JtYXQgPSBob29rcy5jYWxlbmRhckZvcm1hdCh0aGlzLCBzb2QpIHx8ICdzYW1lRWxzZSc7XG5cbiAgICB2YXIgb3V0cHV0ID0gZm9ybWF0cyAmJiAoaXNGdW5jdGlvbihmb3JtYXRzW2Zvcm1hdF0pID8gZm9ybWF0c1tmb3JtYXRdLmNhbGwodGhpcywgbm93KSA6IGZvcm1hdHNbZm9ybWF0XSk7XG5cbiAgICByZXR1cm4gdGhpcy5mb3JtYXQob3V0cHV0IHx8IHRoaXMubG9jYWxlRGF0YSgpLmNhbGVuZGFyKGZvcm1hdCwgdGhpcywgY3JlYXRlTG9jYWwobm93KSkpO1xufVxuXG5mdW5jdGlvbiBjbG9uZSAoKSB7XG4gICAgcmV0dXJuIG5ldyBNb21lbnQodGhpcyk7XG59XG5cbmZ1bmN0aW9uIGlzQWZ0ZXIgKGlucHV0LCB1bml0cykge1xuICAgIHZhciBsb2NhbElucHV0ID0gaXNNb21lbnQoaW5wdXQpID8gaW5wdXQgOiBjcmVhdGVMb2NhbChpbnB1dCk7XG4gICAgaWYgKCEodGhpcy5pc1ZhbGlkKCkgJiYgbG9jYWxJbnB1dC5pc1ZhbGlkKCkpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyghaXNVbmRlZmluZWQodW5pdHMpID8gdW5pdHMgOiAnbWlsbGlzZWNvbmQnKTtcbiAgICBpZiAodW5pdHMgPT09ICdtaWxsaXNlY29uZCcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVPZigpID4gbG9jYWxJbnB1dC52YWx1ZU9mKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsSW5wdXQudmFsdWVPZigpIDwgdGhpcy5jbG9uZSgpLnN0YXJ0T2YodW5pdHMpLnZhbHVlT2YoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGlzQmVmb3JlIChpbnB1dCwgdW5pdHMpIHtcbiAgICB2YXIgbG9jYWxJbnB1dCA9IGlzTW9tZW50KGlucHV0KSA/IGlucHV0IDogY3JlYXRlTG9jYWwoaW5wdXQpO1xuICAgIGlmICghKHRoaXMuaXNWYWxpZCgpICYmIGxvY2FsSW5wdXQuaXNWYWxpZCgpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHMoIWlzVW5kZWZpbmVkKHVuaXRzKSA/IHVuaXRzIDogJ21pbGxpc2Vjb25kJyk7XG4gICAgaWYgKHVuaXRzID09PSAnbWlsbGlzZWNvbmQnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlT2YoKSA8IGxvY2FsSW5wdXQudmFsdWVPZigpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKCkuZW5kT2YodW5pdHMpLnZhbHVlT2YoKSA8IGxvY2FsSW5wdXQudmFsdWVPZigpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaXNCZXR3ZWVuIChmcm9tLCB0bywgdW5pdHMsIGluY2x1c2l2aXR5KSB7XG4gICAgaW5jbHVzaXZpdHkgPSBpbmNsdXNpdml0eSB8fCAnKCknO1xuICAgIHJldHVybiAoaW5jbHVzaXZpdHlbMF0gPT09ICcoJyA/IHRoaXMuaXNBZnRlcihmcm9tLCB1bml0cykgOiAhdGhpcy5pc0JlZm9yZShmcm9tLCB1bml0cykpICYmXG4gICAgICAgIChpbmNsdXNpdml0eVsxXSA9PT0gJyknID8gdGhpcy5pc0JlZm9yZSh0bywgdW5pdHMpIDogIXRoaXMuaXNBZnRlcih0bywgdW5pdHMpKTtcbn1cblxuZnVuY3Rpb24gaXNTYW1lIChpbnB1dCwgdW5pdHMpIHtcbiAgICB2YXIgbG9jYWxJbnB1dCA9IGlzTW9tZW50KGlucHV0KSA/IGlucHV0IDogY3JlYXRlTG9jYWwoaW5wdXQpLFxuICAgICAgICBpbnB1dE1zO1xuICAgIGlmICghKHRoaXMuaXNWYWxpZCgpICYmIGxvY2FsSW5wdXQuaXNWYWxpZCgpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMgfHwgJ21pbGxpc2Vjb25kJyk7XG4gICAgaWYgKHVuaXRzID09PSAnbWlsbGlzZWNvbmQnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlT2YoKSA9PT0gbG9jYWxJbnB1dC52YWx1ZU9mKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaW5wdXRNcyA9IGxvY2FsSW5wdXQudmFsdWVPZigpO1xuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLnN0YXJ0T2YodW5pdHMpLnZhbHVlT2YoKSA8PSBpbnB1dE1zICYmIGlucHV0TXMgPD0gdGhpcy5jbG9uZSgpLmVuZE9mKHVuaXRzKS52YWx1ZU9mKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBpc1NhbWVPckFmdGVyIChpbnB1dCwgdW5pdHMpIHtcbiAgICByZXR1cm4gdGhpcy5pc1NhbWUoaW5wdXQsIHVuaXRzKSB8fCB0aGlzLmlzQWZ0ZXIoaW5wdXQsdW5pdHMpO1xufVxuXG5mdW5jdGlvbiBpc1NhbWVPckJlZm9yZSAoaW5wdXQsIHVuaXRzKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNTYW1lKGlucHV0LCB1bml0cykgfHwgdGhpcy5pc0JlZm9yZShpbnB1dCx1bml0cyk7XG59XG5cbmZ1bmN0aW9uIGRpZmYgKGlucHV0LCB1bml0cywgYXNGbG9hdCkge1xuICAgIHZhciB0aGF0LFxuICAgICAgICB6b25lRGVsdGEsXG4gICAgICAgIGRlbHRhLCBvdXRwdXQ7XG5cbiAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgIHJldHVybiBOYU47XG4gICAgfVxuXG4gICAgdGhhdCA9IGNsb25lV2l0aE9mZnNldChpbnB1dCwgdGhpcyk7XG5cbiAgICBpZiAoIXRoYXQuaXNWYWxpZCgpKSB7XG4gICAgICAgIHJldHVybiBOYU47XG4gICAgfVxuXG4gICAgem9uZURlbHRhID0gKHRoYXQudXRjT2Zmc2V0KCkgLSB0aGlzLnV0Y09mZnNldCgpKSAqIDZlNDtcblxuICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuXG4gICAgc3dpdGNoICh1bml0cykge1xuICAgICAgICBjYXNlICd5ZWFyJzogb3V0cHV0ID0gbW9udGhEaWZmKHRoaXMsIHRoYXQpIC8gMTI7IGJyZWFrO1xuICAgICAgICBjYXNlICdtb250aCc6IG91dHB1dCA9IG1vbnRoRGlmZih0aGlzLCB0aGF0KTsgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3F1YXJ0ZXInOiBvdXRwdXQgPSBtb250aERpZmYodGhpcywgdGhhdCkgLyAzOyBicmVhaztcbiAgICAgICAgY2FzZSAnc2Vjb25kJzogb3V0cHV0ID0gKHRoaXMgLSB0aGF0KSAvIDFlMzsgYnJlYWs7IC8vIDEwMDBcbiAgICAgICAgY2FzZSAnbWludXRlJzogb3V0cHV0ID0gKHRoaXMgLSB0aGF0KSAvIDZlNDsgYnJlYWs7IC8vIDEwMDAgKiA2MFxuICAgICAgICBjYXNlICdob3VyJzogb3V0cHV0ID0gKHRoaXMgLSB0aGF0KSAvIDM2ZTU7IGJyZWFrOyAvLyAxMDAwICogNjAgKiA2MFxuICAgICAgICBjYXNlICdkYXknOiBvdXRwdXQgPSAodGhpcyAtIHRoYXQgLSB6b25lRGVsdGEpIC8gODY0ZTU7IGJyZWFrOyAvLyAxMDAwICogNjAgKiA2MCAqIDI0LCBuZWdhdGUgZHN0XG4gICAgICAgIGNhc2UgJ3dlZWsnOiBvdXRwdXQgPSAodGhpcyAtIHRoYXQgLSB6b25lRGVsdGEpIC8gNjA0OGU1OyBicmVhazsgLy8gMTAwMCAqIDYwICogNjAgKiAyNCAqIDcsIG5lZ2F0ZSBkc3RcbiAgICAgICAgZGVmYXVsdDogb3V0cHV0ID0gdGhpcyAtIHRoYXQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFzRmxvYXQgPyBvdXRwdXQgOiBhYnNGbG9vcihvdXRwdXQpO1xufVxuXG5mdW5jdGlvbiBtb250aERpZmYgKGEsIGIpIHtcbiAgICAvLyBkaWZmZXJlbmNlIGluIG1vbnRoc1xuICAgIHZhciB3aG9sZU1vbnRoRGlmZiA9ICgoYi55ZWFyKCkgLSBhLnllYXIoKSkgKiAxMikgKyAoYi5tb250aCgpIC0gYS5tb250aCgpKSxcbiAgICAgICAgLy8gYiBpcyBpbiAoYW5jaG9yIC0gMSBtb250aCwgYW5jaG9yICsgMSBtb250aClcbiAgICAgICAgYW5jaG9yID0gYS5jbG9uZSgpLmFkZCh3aG9sZU1vbnRoRGlmZiwgJ21vbnRocycpLFxuICAgICAgICBhbmNob3IyLCBhZGp1c3Q7XG5cbiAgICBpZiAoYiAtIGFuY2hvciA8IDApIHtcbiAgICAgICAgYW5jaG9yMiA9IGEuY2xvbmUoKS5hZGQod2hvbGVNb250aERpZmYgLSAxLCAnbW9udGhzJyk7XG4gICAgICAgIC8vIGxpbmVhciBhY3Jvc3MgdGhlIG1vbnRoXG4gICAgICAgIGFkanVzdCA9IChiIC0gYW5jaG9yKSAvIChhbmNob3IgLSBhbmNob3IyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBhbmNob3IyID0gYS5jbG9uZSgpLmFkZCh3aG9sZU1vbnRoRGlmZiArIDEsICdtb250aHMnKTtcbiAgICAgICAgLy8gbGluZWFyIGFjcm9zcyB0aGUgbW9udGhcbiAgICAgICAgYWRqdXN0ID0gKGIgLSBhbmNob3IpIC8gKGFuY2hvcjIgLSBhbmNob3IpO1xuICAgIH1cblxuICAgIC8vY2hlY2sgZm9yIG5lZ2F0aXZlIHplcm8sIHJldHVybiB6ZXJvIGlmIG5lZ2F0aXZlIHplcm9cbiAgICByZXR1cm4gLSh3aG9sZU1vbnRoRGlmZiArIGFkanVzdCkgfHwgMDtcbn1cblxuaG9va3MuZGVmYXVsdEZvcm1hdCA9ICdZWVlZLU1NLUREVEhIOm1tOnNzWic7XG5ob29rcy5kZWZhdWx0Rm9ybWF0VXRjID0gJ1lZWVktTU0tRERUSEg6bW06c3NbWl0nO1xuXG5mdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5sb2NhbGUoJ2VuJykuZm9ybWF0KCdkZGQgTU1NIEREIFlZWVkgSEg6bW06c3MgW0dNVF1aWicpO1xufVxuXG5mdW5jdGlvbiB0b0lTT1N0cmluZyhrZWVwT2Zmc2V0KSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIHV0YyA9IGtlZXBPZmZzZXQgIT09IHRydWU7XG4gICAgdmFyIG0gPSB1dGMgPyB0aGlzLmNsb25lKCkudXRjKCkgOiB0aGlzO1xuICAgIGlmIChtLnllYXIoKSA8IDAgfHwgbS55ZWFyKCkgPiA5OTk5KSB7XG4gICAgICAgIHJldHVybiBmb3JtYXRNb21lbnQobSwgdXRjID8gJ1lZWVlZWS1NTS1ERFtUXUhIOm1tOnNzLlNTU1taXScgOiAnWVlZWVlZLU1NLUREW1RdSEg6bW06c3MuU1NTWicpO1xuICAgIH1cbiAgICBpZiAoaXNGdW5jdGlvbihEYXRlLnByb3RvdHlwZS50b0lTT1N0cmluZykpIHtcbiAgICAgICAgLy8gbmF0aXZlIGltcGxlbWVudGF0aW9uIGlzIH41MHggZmFzdGVyLCB1c2UgaXQgd2hlbiB3ZSBjYW5cbiAgICAgICAgaWYgKHV0Yykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9EYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLl9kLnZhbHVlT2YoKSkudG9JU09TdHJpbmcoKS5yZXBsYWNlKCdaJywgZm9ybWF0TW9tZW50KG0sICdaJykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmb3JtYXRNb21lbnQobSwgdXRjID8gJ1lZWVktTU0tRERbVF1ISDptbTpzcy5TU1NbWl0nIDogJ1lZWVktTU0tRERbVF1ISDptbTpzcy5TU1NaJyk7XG59XG5cbi8qKlxuICogUmV0dXJuIGEgaHVtYW4gcmVhZGFibGUgcmVwcmVzZW50YXRpb24gb2YgYSBtb21lbnQgdGhhdCBjYW5cbiAqIGFsc28gYmUgZXZhbHVhdGVkIHRvIGdldCBhIG5ldyBtb21lbnQgd2hpY2ggaXMgdGhlIHNhbWVcbiAqXG4gKiBAbGluayBodHRwczovL25vZGVqcy5vcmcvZGlzdC9sYXRlc3QvZG9jcy9hcGkvdXRpbC5odG1sI3V0aWxfY3VzdG9tX2luc3BlY3RfZnVuY3Rpb25fb25fb2JqZWN0c1xuICovXG5mdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgIHJldHVybiAnbW9tZW50LmludmFsaWQoLyogJyArIHRoaXMuX2kgKyAnICovKSc7XG4gICAgfVxuICAgIHZhciBmdW5jID0gJ21vbWVudCc7XG4gICAgdmFyIHpvbmUgPSAnJztcbiAgICBpZiAoIXRoaXMuaXNMb2NhbCgpKSB7XG4gICAgICAgIGZ1bmMgPSB0aGlzLnV0Y09mZnNldCgpID09PSAwID8gJ21vbWVudC51dGMnIDogJ21vbWVudC5wYXJzZVpvbmUnO1xuICAgICAgICB6b25lID0gJ1onO1xuICAgIH1cbiAgICB2YXIgcHJlZml4ID0gJ1snICsgZnVuYyArICcoXCJdJztcbiAgICB2YXIgeWVhciA9ICgwIDw9IHRoaXMueWVhcigpICYmIHRoaXMueWVhcigpIDw9IDk5OTkpID8gJ1lZWVknIDogJ1lZWVlZWSc7XG4gICAgdmFyIGRhdGV0aW1lID0gJy1NTS1ERFtUXUhIOm1tOnNzLlNTUyc7XG4gICAgdmFyIHN1ZmZpeCA9IHpvbmUgKyAnW1wiKV0nO1xuXG4gICAgcmV0dXJuIHRoaXMuZm9ybWF0KHByZWZpeCArIHllYXIgKyBkYXRldGltZSArIHN1ZmZpeCk7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdCAoaW5wdXRTdHJpbmcpIHtcbiAgICBpZiAoIWlucHV0U3RyaW5nKSB7XG4gICAgICAgIGlucHV0U3RyaW5nID0gdGhpcy5pc1V0YygpID8gaG9va3MuZGVmYXVsdEZvcm1hdFV0YyA6IGhvb2tzLmRlZmF1bHRGb3JtYXQ7XG4gICAgfVxuICAgIHZhciBvdXRwdXQgPSBmb3JtYXRNb21lbnQodGhpcywgaW5wdXRTdHJpbmcpO1xuICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5wb3N0Zm9ybWF0KG91dHB1dCk7XG59XG5cbmZ1bmN0aW9uIGZyb20gKHRpbWUsIHdpdGhvdXRTdWZmaXgpIHtcbiAgICBpZiAodGhpcy5pc1ZhbGlkKCkgJiZcbiAgICAgICAgICAgICgoaXNNb21lbnQodGltZSkgJiYgdGltZS5pc1ZhbGlkKCkpIHx8XG4gICAgICAgICAgICAgY3JlYXRlTG9jYWwodGltZSkuaXNWYWxpZCgpKSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlRHVyYXRpb24oe3RvOiB0aGlzLCBmcm9tOiB0aW1lfSkubG9jYWxlKHRoaXMubG9jYWxlKCkpLmh1bWFuaXplKCF3aXRob3V0U3VmZml4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkuaW52YWxpZERhdGUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGZyb21Ob3cgKHdpdGhvdXRTdWZmaXgpIHtcbiAgICByZXR1cm4gdGhpcy5mcm9tKGNyZWF0ZUxvY2FsKCksIHdpdGhvdXRTdWZmaXgpO1xufVxuXG5mdW5jdGlvbiB0byAodGltZSwgd2l0aG91dFN1ZmZpeCkge1xuICAgIGlmICh0aGlzLmlzVmFsaWQoKSAmJlxuICAgICAgICAgICAgKChpc01vbWVudCh0aW1lKSAmJiB0aW1lLmlzVmFsaWQoKSkgfHxcbiAgICAgICAgICAgICBjcmVhdGVMb2NhbCh0aW1lKS5pc1ZhbGlkKCkpKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVEdXJhdGlvbih7ZnJvbTogdGhpcywgdG86IHRpbWV9KS5sb2NhbGUodGhpcy5sb2NhbGUoKSkuaHVtYW5pemUoIXdpdGhvdXRTdWZmaXgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gdG9Ob3cgKHdpdGhvdXRTdWZmaXgpIHtcbiAgICByZXR1cm4gdGhpcy50byhjcmVhdGVMb2NhbCgpLCB3aXRob3V0U3VmZml4KTtcbn1cblxuLy8gSWYgcGFzc2VkIGEgbG9jYWxlIGtleSwgaXQgd2lsbCBzZXQgdGhlIGxvY2FsZSBmb3IgdGhpc1xuLy8gaW5zdGFuY2UuICBPdGhlcndpc2UsIGl0IHdpbGwgcmV0dXJuIHRoZSBsb2NhbGUgY29uZmlndXJhdGlvblxuLy8gdmFyaWFibGVzIGZvciB0aGlzIGluc3RhbmNlLlxuZnVuY3Rpb24gbG9jYWxlIChrZXkpIHtcbiAgICB2YXIgbmV3TG9jYWxlRGF0YTtcblxuICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbG9jYWxlLl9hYmJyO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG5ld0xvY2FsZURhdGEgPSBnZXRMb2NhbGUoa2V5KTtcbiAgICAgICAgaWYgKG5ld0xvY2FsZURhdGEgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fbG9jYWxlID0gbmV3TG9jYWxlRGF0YTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5cbnZhciBsYW5nID0gZGVwcmVjYXRlKFxuICAgICdtb21lbnQoKS5sYW5nKCkgaXMgZGVwcmVjYXRlZC4gSW5zdGVhZCwgdXNlIG1vbWVudCgpLmxvY2FsZURhdGEoKSB0byBnZXQgdGhlIGxhbmd1YWdlIGNvbmZpZ3VyYXRpb24uIFVzZSBtb21lbnQoKS5sb2NhbGUoKSB0byBjaGFuZ2UgbGFuZ3VhZ2VzLicsXG4gICAgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZShrZXkpO1xuICAgICAgICB9XG4gICAgfVxuKTtcblxuZnVuY3Rpb24gbG9jYWxlRGF0YSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xvY2FsZTtcbn1cblxuZnVuY3Rpb24gc3RhcnRPZiAodW5pdHMpIHtcbiAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICAvLyB0aGUgZm9sbG93aW5nIHN3aXRjaCBpbnRlbnRpb25hbGx5IG9taXRzIGJyZWFrIGtleXdvcmRzXG4gICAgLy8gdG8gdXRpbGl6ZSBmYWxsaW5nIHRocm91Z2ggdGhlIGNhc2VzLlxuICAgIHN3aXRjaCAodW5pdHMpIHtcbiAgICAgICAgY2FzZSAneWVhcic6XG4gICAgICAgICAgICB0aGlzLm1vbnRoKDApO1xuICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICBjYXNlICdxdWFydGVyJzpcbiAgICAgICAgY2FzZSAnbW9udGgnOlxuICAgICAgICAgICAgdGhpcy5kYXRlKDEpO1xuICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICBjYXNlICd3ZWVrJzpcbiAgICAgICAgY2FzZSAnaXNvV2Vlayc6XG4gICAgICAgIGNhc2UgJ2RheSc6XG4gICAgICAgIGNhc2UgJ2RhdGUnOlxuICAgICAgICAgICAgdGhpcy5ob3VycygwKTtcbiAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgY2FzZSAnaG91cic6XG4gICAgICAgICAgICB0aGlzLm1pbnV0ZXMoMCk7XG4gICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgICAgICAgICB0aGlzLnNlY29uZHMoMCk7XG4gICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgICAgICAgICB0aGlzLm1pbGxpc2Vjb25kcygwKTtcbiAgICB9XG5cbiAgICAvLyB3ZWVrcyBhcmUgYSBzcGVjaWFsIGNhc2VcbiAgICBpZiAodW5pdHMgPT09ICd3ZWVrJykge1xuICAgICAgICB0aGlzLndlZWtkYXkoMCk7XG4gICAgfVxuICAgIGlmICh1bml0cyA9PT0gJ2lzb1dlZWsnKSB7XG4gICAgICAgIHRoaXMuaXNvV2Vla2RheSgxKTtcbiAgICB9XG5cbiAgICAvLyBxdWFydGVycyBhcmUgYWxzbyBzcGVjaWFsXG4gICAgaWYgKHVuaXRzID09PSAncXVhcnRlcicpIHtcbiAgICAgICAgdGhpcy5tb250aChNYXRoLmZsb29yKHRoaXMubW9udGgoKSAvIDMpICogMyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG59XG5cbmZ1bmN0aW9uIGVuZE9mICh1bml0cykge1xuICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgIGlmICh1bml0cyA9PT0gdW5kZWZpbmVkIHx8IHVuaXRzID09PSAnbWlsbGlzZWNvbmQnKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vICdkYXRlJyBpcyBhbiBhbGlhcyBmb3IgJ2RheScsIHNvIGl0IHNob3VsZCBiZSBjb25zaWRlcmVkIGFzIHN1Y2guXG4gICAgaWYgKHVuaXRzID09PSAnZGF0ZScpIHtcbiAgICAgICAgdW5pdHMgPSAnZGF5JztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zdGFydE9mKHVuaXRzKS5hZGQoMSwgKHVuaXRzID09PSAnaXNvV2VlaycgPyAnd2VlaycgOiB1bml0cykpLnN1YnRyYWN0KDEsICdtcycpO1xufVxuXG5mdW5jdGlvbiB2YWx1ZU9mICgpIHtcbiAgICByZXR1cm4gdGhpcy5fZC52YWx1ZU9mKCkgLSAoKHRoaXMuX29mZnNldCB8fCAwKSAqIDYwMDAwKTtcbn1cblxuZnVuY3Rpb24gdW5peCAoKSB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IodGhpcy52YWx1ZU9mKCkgLyAxMDAwKTtcbn1cblxuZnVuY3Rpb24gdG9EYXRlICgpIHtcbiAgICByZXR1cm4gbmV3IERhdGUodGhpcy52YWx1ZU9mKCkpO1xufVxuXG5mdW5jdGlvbiB0b0FycmF5ICgpIHtcbiAgICB2YXIgbSA9IHRoaXM7XG4gICAgcmV0dXJuIFttLnllYXIoKSwgbS5tb250aCgpLCBtLmRhdGUoKSwgbS5ob3VyKCksIG0ubWludXRlKCksIG0uc2Vjb25kKCksIG0ubWlsbGlzZWNvbmQoKV07XG59XG5cbmZ1bmN0aW9uIHRvT2JqZWN0ICgpIHtcbiAgICB2YXIgbSA9IHRoaXM7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeWVhcnM6IG0ueWVhcigpLFxuICAgICAgICBtb250aHM6IG0ubW9udGgoKSxcbiAgICAgICAgZGF0ZTogbS5kYXRlKCksXG4gICAgICAgIGhvdXJzOiBtLmhvdXJzKCksXG4gICAgICAgIG1pbnV0ZXM6IG0ubWludXRlcygpLFxuICAgICAgICBzZWNvbmRzOiBtLnNlY29uZHMoKSxcbiAgICAgICAgbWlsbGlzZWNvbmRzOiBtLm1pbGxpc2Vjb25kcygpXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgICAvLyBuZXcgRGF0ZShOYU4pLnRvSlNPTigpID09PSBudWxsXG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpID8gdGhpcy50b0lTT1N0cmluZygpIDogbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNWYWxpZCQyICgpIHtcbiAgICByZXR1cm4gaXNWYWxpZCh0aGlzKTtcbn1cblxuZnVuY3Rpb24gcGFyc2luZ0ZsYWdzICgpIHtcbiAgICByZXR1cm4gZXh0ZW5kKHt9LCBnZXRQYXJzaW5nRmxhZ3ModGhpcykpO1xufVxuXG5mdW5jdGlvbiBpbnZhbGlkQXQgKCkge1xuICAgIHJldHVybiBnZXRQYXJzaW5nRmxhZ3ModGhpcykub3ZlcmZsb3c7XG59XG5cbmZ1bmN0aW9uIGNyZWF0aW9uRGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBpbnB1dDogdGhpcy5faSxcbiAgICAgICAgZm9ybWF0OiB0aGlzLl9mLFxuICAgICAgICBsb2NhbGU6IHRoaXMuX2xvY2FsZSxcbiAgICAgICAgaXNVVEM6IHRoaXMuX2lzVVRDLFxuICAgICAgICBzdHJpY3Q6IHRoaXMuX3N0cmljdFxuICAgIH07XG59XG5cbi8vIEZPUk1BVFRJTkdcblxuYWRkRm9ybWF0VG9rZW4oMCwgWydnZycsIDJdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMud2Vla1llYXIoKSAlIDEwMDtcbn0pO1xuXG5hZGRGb3JtYXRUb2tlbigwLCBbJ0dHJywgMl0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5pc29XZWVrWWVhcigpICUgMTAwO1xufSk7XG5cbmZ1bmN0aW9uIGFkZFdlZWtZZWFyRm9ybWF0VG9rZW4gKHRva2VuLCBnZXR0ZXIpIHtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbdG9rZW4sIHRva2VuLmxlbmd0aF0sIDAsIGdldHRlcik7XG59XG5cbmFkZFdlZWtZZWFyRm9ybWF0VG9rZW4oJ2dnZ2cnLCAgICAgJ3dlZWtZZWFyJyk7XG5hZGRXZWVrWWVhckZvcm1hdFRva2VuKCdnZ2dnZycsICAgICd3ZWVrWWVhcicpO1xuYWRkV2Vla1llYXJGb3JtYXRUb2tlbignR0dHRycsICAnaXNvV2Vla1llYXInKTtcbmFkZFdlZWtZZWFyRm9ybWF0VG9rZW4oJ0dHR0dHJywgJ2lzb1dlZWtZZWFyJyk7XG5cbi8vIEFMSUFTRVNcblxuYWRkVW5pdEFsaWFzKCd3ZWVrWWVhcicsICdnZycpO1xuYWRkVW5pdEFsaWFzKCdpc29XZWVrWWVhcicsICdHRycpO1xuXG4vLyBQUklPUklUWVxuXG5hZGRVbml0UHJpb3JpdHkoJ3dlZWtZZWFyJywgMSk7XG5hZGRVbml0UHJpb3JpdHkoJ2lzb1dlZWtZZWFyJywgMSk7XG5cblxuLy8gUEFSU0lOR1xuXG5hZGRSZWdleFRva2VuKCdHJywgICAgICBtYXRjaFNpZ25lZCk7XG5hZGRSZWdleFRva2VuKCdnJywgICAgICBtYXRjaFNpZ25lZCk7XG5hZGRSZWdleFRva2VuKCdHRycsICAgICBtYXRjaDF0bzIsIG1hdGNoMik7XG5hZGRSZWdleFRva2VuKCdnZycsICAgICBtYXRjaDF0bzIsIG1hdGNoMik7XG5hZGRSZWdleFRva2VuKCdHR0dHJywgICBtYXRjaDF0bzQsIG1hdGNoNCk7XG5hZGRSZWdleFRva2VuKCdnZ2dnJywgICBtYXRjaDF0bzQsIG1hdGNoNCk7XG5hZGRSZWdleFRva2VuKCdHR0dHRycsICBtYXRjaDF0bzYsIG1hdGNoNik7XG5hZGRSZWdleFRva2VuKCdnZ2dnZycsICBtYXRjaDF0bzYsIG1hdGNoNik7XG5cbmFkZFdlZWtQYXJzZVRva2VuKFsnZ2dnZycsICdnZ2dnZycsICdHR0dHJywgJ0dHR0dHJ10sIGZ1bmN0aW9uIChpbnB1dCwgd2VlaywgY29uZmlnLCB0b2tlbikge1xuICAgIHdlZWtbdG9rZW4uc3Vic3RyKDAsIDIpXSA9IHRvSW50KGlucHV0KTtcbn0pO1xuXG5hZGRXZWVrUGFyc2VUb2tlbihbJ2dnJywgJ0dHJ10sIGZ1bmN0aW9uIChpbnB1dCwgd2VlaywgY29uZmlnLCB0b2tlbikge1xuICAgIHdlZWtbdG9rZW5dID0gaG9va3MucGFyc2VUd29EaWdpdFllYXIoaW5wdXQpO1xufSk7XG5cbi8vIE1PTUVOVFNcblxuZnVuY3Rpb24gZ2V0U2V0V2Vla1llYXIgKGlucHV0KSB7XG4gICAgcmV0dXJuIGdldFNldFdlZWtZZWFySGVscGVyLmNhbGwodGhpcyxcbiAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgdGhpcy53ZWVrKCksXG4gICAgICAgICAgICB0aGlzLndlZWtkYXkoKSxcbiAgICAgICAgICAgIHRoaXMubG9jYWxlRGF0YSgpLl93ZWVrLmRvdyxcbiAgICAgICAgICAgIHRoaXMubG9jYWxlRGF0YSgpLl93ZWVrLmRveSk7XG59XG5cbmZ1bmN0aW9uIGdldFNldElTT1dlZWtZZWFyIChpbnB1dCkge1xuICAgIHJldHVybiBnZXRTZXRXZWVrWWVhckhlbHBlci5jYWxsKHRoaXMsXG4gICAgICAgICAgICBpbnB1dCwgdGhpcy5pc29XZWVrKCksIHRoaXMuaXNvV2Vla2RheSgpLCAxLCA0KTtcbn1cblxuZnVuY3Rpb24gZ2V0SVNPV2Vla3NJblllYXIgKCkge1xuICAgIHJldHVybiB3ZWVrc0luWWVhcih0aGlzLnllYXIoKSwgMSwgNCk7XG59XG5cbmZ1bmN0aW9uIGdldFdlZWtzSW5ZZWFyICgpIHtcbiAgICB2YXIgd2Vla0luZm8gPSB0aGlzLmxvY2FsZURhdGEoKS5fd2VlaztcbiAgICByZXR1cm4gd2Vla3NJblllYXIodGhpcy55ZWFyKCksIHdlZWtJbmZvLmRvdywgd2Vla0luZm8uZG95KTtcbn1cblxuZnVuY3Rpb24gZ2V0U2V0V2Vla1llYXJIZWxwZXIoaW5wdXQsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KSB7XG4gICAgdmFyIHdlZWtzVGFyZ2V0O1xuICAgIGlmIChpbnB1dCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB3ZWVrT2ZZZWFyKHRoaXMsIGRvdywgZG95KS55ZWFyO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHdlZWtzVGFyZ2V0ID0gd2Vla3NJblllYXIoaW5wdXQsIGRvdywgZG95KTtcbiAgICAgICAgaWYgKHdlZWsgPiB3ZWVrc1RhcmdldCkge1xuICAgICAgICAgICAgd2VlayA9IHdlZWtzVGFyZ2V0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZXRXZWVrQWxsLmNhbGwodGhpcywgaW5wdXQsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHNldFdlZWtBbGwod2Vla1llYXIsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KSB7XG4gICAgdmFyIGRheU9mWWVhckRhdGEgPSBkYXlPZlllYXJGcm9tV2Vla3Mod2Vla1llYXIsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KSxcbiAgICAgICAgZGF0ZSA9IGNyZWF0ZVVUQ0RhdGUoZGF5T2ZZZWFyRGF0YS55ZWFyLCAwLCBkYXlPZlllYXJEYXRhLmRheU9mWWVhcik7XG5cbiAgICB0aGlzLnllYXIoZGF0ZS5nZXRVVENGdWxsWWVhcigpKTtcbiAgICB0aGlzLm1vbnRoKGRhdGUuZ2V0VVRDTW9udGgoKSk7XG4gICAgdGhpcy5kYXRlKGRhdGUuZ2V0VVRDRGF0ZSgpKTtcbiAgICByZXR1cm4gdGhpcztcbn1cblxuLy8gRk9STUFUVElOR1xuXG5hZGRGb3JtYXRUb2tlbignUScsIDAsICdRbycsICdxdWFydGVyJyk7XG5cbi8vIEFMSUFTRVNcblxuYWRkVW5pdEFsaWFzKCdxdWFydGVyJywgJ1EnKTtcblxuLy8gUFJJT1JJVFlcblxuYWRkVW5pdFByaW9yaXR5KCdxdWFydGVyJywgNyk7XG5cbi8vIFBBUlNJTkdcblxuYWRkUmVnZXhUb2tlbignUScsIG1hdGNoMSk7XG5hZGRQYXJzZVRva2VuKCdRJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgIGFycmF5W01PTlRIXSA9ICh0b0ludChpbnB1dCkgLSAxKSAqIDM7XG59KTtcblxuLy8gTU9NRU5UU1xuXG5mdW5jdGlvbiBnZXRTZXRRdWFydGVyIChpbnB1dCkge1xuICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gTWF0aC5jZWlsKCh0aGlzLm1vbnRoKCkgKyAxKSAvIDMpIDogdGhpcy5tb250aCgoaW5wdXQgLSAxKSAqIDMgKyB0aGlzLm1vbnRoKCkgJSAzKTtcbn1cblxuLy8gRk9STUFUVElOR1xuXG5hZGRGb3JtYXRUb2tlbignRCcsIFsnREQnLCAyXSwgJ0RvJywgJ2RhdGUnKTtcblxuLy8gQUxJQVNFU1xuXG5hZGRVbml0QWxpYXMoJ2RhdGUnLCAnRCcpO1xuXG4vLyBQUklPUk9JVFlcbmFkZFVuaXRQcmlvcml0eSgnZGF0ZScsIDkpO1xuXG4vLyBQQVJTSU5HXG5cbmFkZFJlZ2V4VG9rZW4oJ0QnLCAgbWF0Y2gxdG8yKTtcbmFkZFJlZ2V4VG9rZW4oJ0REJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuYWRkUmVnZXhUb2tlbignRG8nLCBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgIC8vIFRPRE86IFJlbW92ZSBcIm9yZGluYWxQYXJzZVwiIGZhbGxiYWNrIGluIG5leHQgbWFqb3IgcmVsZWFzZS5cbiAgICByZXR1cm4gaXNTdHJpY3QgP1xuICAgICAgKGxvY2FsZS5fZGF5T2ZNb250aE9yZGluYWxQYXJzZSB8fCBsb2NhbGUuX29yZGluYWxQYXJzZSkgOlxuICAgICAgbG9jYWxlLl9kYXlPZk1vbnRoT3JkaW5hbFBhcnNlTGVuaWVudDtcbn0pO1xuXG5hZGRQYXJzZVRva2VuKFsnRCcsICdERCddLCBEQVRFKTtcbmFkZFBhcnNlVG9rZW4oJ0RvJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgIGFycmF5W0RBVEVdID0gdG9JbnQoaW5wdXQubWF0Y2gobWF0Y2gxdG8yKVswXSk7XG59KTtcblxuLy8gTU9NRU5UU1xuXG52YXIgZ2V0U2V0RGF5T2ZNb250aCA9IG1ha2VHZXRTZXQoJ0RhdGUnLCB0cnVlKTtcblxuLy8gRk9STUFUVElOR1xuXG5hZGRGb3JtYXRUb2tlbignREREJywgWydEREREJywgM10sICdERERvJywgJ2RheU9mWWVhcicpO1xuXG4vLyBBTElBU0VTXG5cbmFkZFVuaXRBbGlhcygnZGF5T2ZZZWFyJywgJ0RERCcpO1xuXG4vLyBQUklPUklUWVxuYWRkVW5pdFByaW9yaXR5KCdkYXlPZlllYXInLCA0KTtcblxuLy8gUEFSU0lOR1xuXG5hZGRSZWdleFRva2VuKCdEREQnLCAgbWF0Y2gxdG8zKTtcbmFkZFJlZ2V4VG9rZW4oJ0REREQnLCBtYXRjaDMpO1xuYWRkUGFyc2VUb2tlbihbJ0RERCcsICdEREREJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgIGNvbmZpZy5fZGF5T2ZZZWFyID0gdG9JbnQoaW5wdXQpO1xufSk7XG5cbi8vIEhFTFBFUlNcblxuLy8gTU9NRU5UU1xuXG5mdW5jdGlvbiBnZXRTZXREYXlPZlllYXIgKGlucHV0KSB7XG4gICAgdmFyIGRheU9mWWVhciA9IE1hdGgucm91bmQoKHRoaXMuY2xvbmUoKS5zdGFydE9mKCdkYXknKSAtIHRoaXMuY2xvbmUoKS5zdGFydE9mKCd5ZWFyJykpIC8gODY0ZTUpICsgMTtcbiAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IGRheU9mWWVhciA6IHRoaXMuYWRkKChpbnB1dCAtIGRheU9mWWVhciksICdkJyk7XG59XG5cbi8vIEZPUk1BVFRJTkdcblxuYWRkRm9ybWF0VG9rZW4oJ20nLCBbJ21tJywgMl0sIDAsICdtaW51dGUnKTtcblxuLy8gQUxJQVNFU1xuXG5hZGRVbml0QWxpYXMoJ21pbnV0ZScsICdtJyk7XG5cbi8vIFBSSU9SSVRZXG5cbmFkZFVuaXRQcmlvcml0eSgnbWludXRlJywgMTQpO1xuXG4vLyBQQVJTSU5HXG5cbmFkZFJlZ2V4VG9rZW4oJ20nLCAgbWF0Y2gxdG8yKTtcbmFkZFJlZ2V4VG9rZW4oJ21tJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuYWRkUGFyc2VUb2tlbihbJ20nLCAnbW0nXSwgTUlOVVRFKTtcblxuLy8gTU9NRU5UU1xuXG52YXIgZ2V0U2V0TWludXRlID0gbWFrZUdldFNldCgnTWludXRlcycsIGZhbHNlKTtcblxuLy8gRk9STUFUVElOR1xuXG5hZGRGb3JtYXRUb2tlbigncycsIFsnc3MnLCAyXSwgMCwgJ3NlY29uZCcpO1xuXG4vLyBBTElBU0VTXG5cbmFkZFVuaXRBbGlhcygnc2Vjb25kJywgJ3MnKTtcblxuLy8gUFJJT1JJVFlcblxuYWRkVW5pdFByaW9yaXR5KCdzZWNvbmQnLCAxNSk7XG5cbi8vIFBBUlNJTkdcblxuYWRkUmVnZXhUb2tlbigncycsICBtYXRjaDF0bzIpO1xuYWRkUmVnZXhUb2tlbignc3MnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG5hZGRQYXJzZVRva2VuKFsncycsICdzcyddLCBTRUNPTkQpO1xuXG4vLyBNT01FTlRTXG5cbnZhciBnZXRTZXRTZWNvbmQgPSBtYWtlR2V0U2V0KCdTZWNvbmRzJywgZmFsc2UpO1xuXG4vLyBGT1JNQVRUSU5HXG5cbmFkZEZvcm1hdFRva2VuKCdTJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB+fih0aGlzLm1pbGxpc2Vjb25kKCkgLyAxMDApO1xufSk7XG5cbmFkZEZvcm1hdFRva2VuKDAsIFsnU1MnLCAyXSwgMCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB+fih0aGlzLm1pbGxpc2Vjb25kKCkgLyAxMCk7XG59KTtcblxuYWRkRm9ybWF0VG9rZW4oMCwgWydTU1MnLCAzXSwgMCwgJ21pbGxpc2Vjb25kJyk7XG5hZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1MnLCA0XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDtcbn0pO1xuYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTUycsIDVdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDtcbn0pO1xuYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTU1MnLCA2XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDAwO1xufSk7XG5hZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1NTU1MnLCA3XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDAwMDtcbn0pO1xuYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTU1NTUycsIDhdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDAwMDtcbn0pO1xuYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTU1NTU1MnLCA5XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDAwMDAwO1xufSk7XG5cblxuLy8gQUxJQVNFU1xuXG5hZGRVbml0QWxpYXMoJ21pbGxpc2Vjb25kJywgJ21zJyk7XG5cbi8vIFBSSU9SSVRZXG5cbmFkZFVuaXRQcmlvcml0eSgnbWlsbGlzZWNvbmQnLCAxNik7XG5cbi8vIFBBUlNJTkdcblxuYWRkUmVnZXhUb2tlbignUycsICAgIG1hdGNoMXRvMywgbWF0Y2gxKTtcbmFkZFJlZ2V4VG9rZW4oJ1NTJywgICBtYXRjaDF0bzMsIG1hdGNoMik7XG5hZGRSZWdleFRva2VuKCdTU1MnLCAgbWF0Y2gxdG8zLCBtYXRjaDMpO1xuXG52YXIgdG9rZW47XG5mb3IgKHRva2VuID0gJ1NTU1MnOyB0b2tlbi5sZW5ndGggPD0gOTsgdG9rZW4gKz0gJ1MnKSB7XG4gICAgYWRkUmVnZXhUb2tlbih0b2tlbiwgbWF0Y2hVbnNpZ25lZCk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlTXMoaW5wdXQsIGFycmF5KSB7XG4gICAgYXJyYXlbTUlMTElTRUNPTkRdID0gdG9JbnQoKCcwLicgKyBpbnB1dCkgKiAxMDAwKTtcbn1cblxuZm9yICh0b2tlbiA9ICdTJzsgdG9rZW4ubGVuZ3RoIDw9IDk7IHRva2VuICs9ICdTJykge1xuICAgIGFkZFBhcnNlVG9rZW4odG9rZW4sIHBhcnNlTXMpO1xufVxuLy8gTU9NRU5UU1xuXG52YXIgZ2V0U2V0TWlsbGlzZWNvbmQgPSBtYWtlR2V0U2V0KCdNaWxsaXNlY29uZHMnLCBmYWxzZSk7XG5cbi8vIEZPUk1BVFRJTkdcblxuYWRkRm9ybWF0VG9rZW4oJ3onLCAgMCwgMCwgJ3pvbmVBYmJyJyk7XG5hZGRGb3JtYXRUb2tlbignenonLCAwLCAwLCAnem9uZU5hbWUnKTtcblxuLy8gTU9NRU5UU1xuXG5mdW5jdGlvbiBnZXRab25lQWJiciAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzVVRDID8gJ1VUQycgOiAnJztcbn1cblxuZnVuY3Rpb24gZ2V0Wm9uZU5hbWUgKCkge1xuICAgIHJldHVybiB0aGlzLl9pc1VUQyA/ICdDb29yZGluYXRlZCBVbml2ZXJzYWwgVGltZScgOiAnJztcbn1cblxudmFyIHByb3RvID0gTW9tZW50LnByb3RvdHlwZTtcblxucHJvdG8uYWRkICAgICAgICAgICAgICAgPSBhZGQ7XG5wcm90by5jYWxlbmRhciAgICAgICAgICA9IGNhbGVuZGFyJDE7XG5wcm90by5jbG9uZSAgICAgICAgICAgICA9IGNsb25lO1xucHJvdG8uZGlmZiAgICAgICAgICAgICAgPSBkaWZmO1xucHJvdG8uZW5kT2YgICAgICAgICAgICAgPSBlbmRPZjtcbnByb3RvLmZvcm1hdCAgICAgICAgICAgID0gZm9ybWF0O1xucHJvdG8uZnJvbSAgICAgICAgICAgICAgPSBmcm9tO1xucHJvdG8uZnJvbU5vdyAgICAgICAgICAgPSBmcm9tTm93O1xucHJvdG8udG8gICAgICAgICAgICAgICAgPSB0bztcbnByb3RvLnRvTm93ICAgICAgICAgICAgID0gdG9Ob3c7XG5wcm90by5nZXQgICAgICAgICAgICAgICA9IHN0cmluZ0dldDtcbnByb3RvLmludmFsaWRBdCAgICAgICAgID0gaW52YWxpZEF0O1xucHJvdG8uaXNBZnRlciAgICAgICAgICAgPSBpc0FmdGVyO1xucHJvdG8uaXNCZWZvcmUgICAgICAgICAgPSBpc0JlZm9yZTtcbnByb3RvLmlzQmV0d2VlbiAgICAgICAgID0gaXNCZXR3ZWVuO1xucHJvdG8uaXNTYW1lICAgICAgICAgICAgPSBpc1NhbWU7XG5wcm90by5pc1NhbWVPckFmdGVyICAgICA9IGlzU2FtZU9yQWZ0ZXI7XG5wcm90by5pc1NhbWVPckJlZm9yZSAgICA9IGlzU2FtZU9yQmVmb3JlO1xucHJvdG8uaXNWYWxpZCAgICAgICAgICAgPSBpc1ZhbGlkJDI7XG5wcm90by5sYW5nICAgICAgICAgICAgICA9IGxhbmc7XG5wcm90by5sb2NhbGUgICAgICAgICAgICA9IGxvY2FsZTtcbnByb3RvLmxvY2FsZURhdGEgICAgICAgID0gbG9jYWxlRGF0YTtcbnByb3RvLm1heCAgICAgICAgICAgICAgID0gcHJvdG90eXBlTWF4O1xucHJvdG8ubWluICAgICAgICAgICAgICAgPSBwcm90b3R5cGVNaW47XG5wcm90by5wYXJzaW5nRmxhZ3MgICAgICA9IHBhcnNpbmdGbGFncztcbnByb3RvLnNldCAgICAgICAgICAgICAgID0gc3RyaW5nU2V0O1xucHJvdG8uc3RhcnRPZiAgICAgICAgICAgPSBzdGFydE9mO1xucHJvdG8uc3VidHJhY3QgICAgICAgICAgPSBzdWJ0cmFjdDtcbnByb3RvLnRvQXJyYXkgICAgICAgICAgID0gdG9BcnJheTtcbnByb3RvLnRvT2JqZWN0ICAgICAgICAgID0gdG9PYmplY3Q7XG5wcm90by50b0RhdGUgICAgICAgICAgICA9IHRvRGF0ZTtcbnByb3RvLnRvSVNPU3RyaW5nICAgICAgID0gdG9JU09TdHJpbmc7XG5wcm90by5pbnNwZWN0ICAgICAgICAgICA9IGluc3BlY3Q7XG5wcm90by50b0pTT04gICAgICAgICAgICA9IHRvSlNPTjtcbnByb3RvLnRvU3RyaW5nICAgICAgICAgID0gdG9TdHJpbmc7XG5wcm90by51bml4ICAgICAgICAgICAgICA9IHVuaXg7XG5wcm90by52YWx1ZU9mICAgICAgICAgICA9IHZhbHVlT2Y7XG5wcm90by5jcmVhdGlvbkRhdGEgICAgICA9IGNyZWF0aW9uRGF0YTtcblxuLy8gWWVhclxucHJvdG8ueWVhciAgICAgICA9IGdldFNldFllYXI7XG5wcm90by5pc0xlYXBZZWFyID0gZ2V0SXNMZWFwWWVhcjtcblxuLy8gV2VlayBZZWFyXG5wcm90by53ZWVrWWVhciAgICA9IGdldFNldFdlZWtZZWFyO1xucHJvdG8uaXNvV2Vla1llYXIgPSBnZXRTZXRJU09XZWVrWWVhcjtcblxuLy8gUXVhcnRlclxucHJvdG8ucXVhcnRlciA9IHByb3RvLnF1YXJ0ZXJzID0gZ2V0U2V0UXVhcnRlcjtcblxuLy8gTW9udGhcbnByb3RvLm1vbnRoICAgICAgID0gZ2V0U2V0TW9udGg7XG5wcm90by5kYXlzSW5Nb250aCA9IGdldERheXNJbk1vbnRoO1xuXG4vLyBXZWVrXG5wcm90by53ZWVrICAgICAgICAgICA9IHByb3RvLndlZWtzICAgICAgICA9IGdldFNldFdlZWs7XG5wcm90by5pc29XZWVrICAgICAgICA9IHByb3RvLmlzb1dlZWtzICAgICA9IGdldFNldElTT1dlZWs7XG5wcm90by53ZWVrc0luWWVhciAgICA9IGdldFdlZWtzSW5ZZWFyO1xucHJvdG8uaXNvV2Vla3NJblllYXIgPSBnZXRJU09XZWVrc0luWWVhcjtcblxuLy8gRGF5XG5wcm90by5kYXRlICAgICAgID0gZ2V0U2V0RGF5T2ZNb250aDtcbnByb3RvLmRheSAgICAgICAgPSBwcm90by5kYXlzICAgICAgICAgICAgID0gZ2V0U2V0RGF5T2ZXZWVrO1xucHJvdG8ud2Vla2RheSAgICA9IGdldFNldExvY2FsZURheU9mV2VlaztcbnByb3RvLmlzb1dlZWtkYXkgPSBnZXRTZXRJU09EYXlPZldlZWs7XG5wcm90by5kYXlPZlllYXIgID0gZ2V0U2V0RGF5T2ZZZWFyO1xuXG4vLyBIb3VyXG5wcm90by5ob3VyID0gcHJvdG8uaG91cnMgPSBnZXRTZXRIb3VyO1xuXG4vLyBNaW51dGVcbnByb3RvLm1pbnV0ZSA9IHByb3RvLm1pbnV0ZXMgPSBnZXRTZXRNaW51dGU7XG5cbi8vIFNlY29uZFxucHJvdG8uc2Vjb25kID0gcHJvdG8uc2Vjb25kcyA9IGdldFNldFNlY29uZDtcblxuLy8gTWlsbGlzZWNvbmRcbnByb3RvLm1pbGxpc2Vjb25kID0gcHJvdG8ubWlsbGlzZWNvbmRzID0gZ2V0U2V0TWlsbGlzZWNvbmQ7XG5cbi8vIE9mZnNldFxucHJvdG8udXRjT2Zmc2V0ICAgICAgICAgICAgPSBnZXRTZXRPZmZzZXQ7XG5wcm90by51dGMgICAgICAgICAgICAgICAgICA9IHNldE9mZnNldFRvVVRDO1xucHJvdG8ubG9jYWwgICAgICAgICAgICAgICAgPSBzZXRPZmZzZXRUb0xvY2FsO1xucHJvdG8ucGFyc2Vab25lICAgICAgICAgICAgPSBzZXRPZmZzZXRUb1BhcnNlZE9mZnNldDtcbnByb3RvLmhhc0FsaWduZWRIb3VyT2Zmc2V0ID0gaGFzQWxpZ25lZEhvdXJPZmZzZXQ7XG5wcm90by5pc0RTVCAgICAgICAgICAgICAgICA9IGlzRGF5bGlnaHRTYXZpbmdUaW1lO1xucHJvdG8uaXNMb2NhbCAgICAgICAgICAgICAgPSBpc0xvY2FsO1xucHJvdG8uaXNVdGNPZmZzZXQgICAgICAgICAgPSBpc1V0Y09mZnNldDtcbnByb3RvLmlzVXRjICAgICAgICAgICAgICAgID0gaXNVdGM7XG5wcm90by5pc1VUQyAgICAgICAgICAgICAgICA9IGlzVXRjO1xuXG4vLyBUaW1lem9uZVxucHJvdG8uem9uZUFiYnIgPSBnZXRab25lQWJicjtcbnByb3RvLnpvbmVOYW1lID0gZ2V0Wm9uZU5hbWU7XG5cbi8vIERlcHJlY2F0aW9uc1xucHJvdG8uZGF0ZXMgID0gZGVwcmVjYXRlKCdkYXRlcyBhY2Nlc3NvciBpcyBkZXByZWNhdGVkLiBVc2UgZGF0ZSBpbnN0ZWFkLicsIGdldFNldERheU9mTW9udGgpO1xucHJvdG8ubW9udGhzID0gZGVwcmVjYXRlKCdtb250aHMgYWNjZXNzb3IgaXMgZGVwcmVjYXRlZC4gVXNlIG1vbnRoIGluc3RlYWQnLCBnZXRTZXRNb250aCk7XG5wcm90by55ZWFycyAgPSBkZXByZWNhdGUoJ3llYXJzIGFjY2Vzc29yIGlzIGRlcHJlY2F0ZWQuIFVzZSB5ZWFyIGluc3RlYWQnLCBnZXRTZXRZZWFyKTtcbnByb3RvLnpvbmUgICA9IGRlcHJlY2F0ZSgnbW9tZW50KCkuem9uZSBpcyBkZXByZWNhdGVkLCB1c2UgbW9tZW50KCkudXRjT2Zmc2V0IGluc3RlYWQuIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3Mvem9uZS8nLCBnZXRTZXRab25lKTtcbnByb3RvLmlzRFNUU2hpZnRlZCA9IGRlcHJlY2F0ZSgnaXNEU1RTaGlmdGVkIGlzIGRlcHJlY2F0ZWQuIFNlZSBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL2RzdC1zaGlmdGVkLyBmb3IgbW9yZSBpbmZvcm1hdGlvbicsIGlzRGF5bGlnaHRTYXZpbmdUaW1lU2hpZnRlZCk7XG5cbmZ1bmN0aW9uIGNyZWF0ZVVuaXggKGlucHV0KSB7XG4gICAgcmV0dXJuIGNyZWF0ZUxvY2FsKGlucHV0ICogMTAwMCk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUluWm9uZSAoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUxvY2FsLmFwcGx5KG51bGwsIGFyZ3VtZW50cykucGFyc2Vab25lKCk7XG59XG5cbmZ1bmN0aW9uIHByZVBhcnNlUG9zdEZvcm1hdCAoc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZztcbn1cblxudmFyIHByb3RvJDEgPSBMb2NhbGUucHJvdG90eXBlO1xuXG5wcm90byQxLmNhbGVuZGFyICAgICAgICA9IGNhbGVuZGFyO1xucHJvdG8kMS5sb25nRGF0ZUZvcm1hdCAgPSBsb25nRGF0ZUZvcm1hdDtcbnByb3RvJDEuaW52YWxpZERhdGUgICAgID0gaW52YWxpZERhdGU7XG5wcm90byQxLm9yZGluYWwgICAgICAgICA9IG9yZGluYWw7XG5wcm90byQxLnByZXBhcnNlICAgICAgICA9IHByZVBhcnNlUG9zdEZvcm1hdDtcbnByb3RvJDEucG9zdGZvcm1hdCAgICAgID0gcHJlUGFyc2VQb3N0Rm9ybWF0O1xucHJvdG8kMS5yZWxhdGl2ZVRpbWUgICAgPSByZWxhdGl2ZVRpbWU7XG5wcm90byQxLnBhc3RGdXR1cmUgICAgICA9IHBhc3RGdXR1cmU7XG5wcm90byQxLnNldCAgICAgICAgICAgICA9IHNldDtcblxuLy8gTW9udGhcbnByb3RvJDEubW9udGhzICAgICAgICAgICAgPSAgICAgICAgbG9jYWxlTW9udGhzO1xucHJvdG8kMS5tb250aHNTaG9ydCAgICAgICA9ICAgICAgICBsb2NhbGVNb250aHNTaG9ydDtcbnByb3RvJDEubW9udGhzUGFyc2UgICAgICAgPSAgICAgICAgbG9jYWxlTW9udGhzUGFyc2U7XG5wcm90byQxLm1vbnRoc1JlZ2V4ICAgICAgID0gbW9udGhzUmVnZXg7XG5wcm90byQxLm1vbnRoc1Nob3J0UmVnZXggID0gbW9udGhzU2hvcnRSZWdleDtcblxuLy8gV2Vla1xucHJvdG8kMS53ZWVrID0gbG9jYWxlV2VlaztcbnByb3RvJDEuZmlyc3REYXlPZlllYXIgPSBsb2NhbGVGaXJzdERheU9mWWVhcjtcbnByb3RvJDEuZmlyc3REYXlPZldlZWsgPSBsb2NhbGVGaXJzdERheU9mV2VlaztcblxuLy8gRGF5IG9mIFdlZWtcbnByb3RvJDEud2Vla2RheXMgICAgICAgPSAgICAgICAgbG9jYWxlV2Vla2RheXM7XG5wcm90byQxLndlZWtkYXlzTWluICAgID0gICAgICAgIGxvY2FsZVdlZWtkYXlzTWluO1xucHJvdG8kMS53ZWVrZGF5c1Nob3J0ICA9ICAgICAgICBsb2NhbGVXZWVrZGF5c1Nob3J0O1xucHJvdG8kMS53ZWVrZGF5c1BhcnNlICA9ICAgICAgICBsb2NhbGVXZWVrZGF5c1BhcnNlO1xuXG5wcm90byQxLndlZWtkYXlzUmVnZXggICAgICAgPSAgICAgICAgd2Vla2RheXNSZWdleDtcbnByb3RvJDEud2Vla2RheXNTaG9ydFJlZ2V4ICA9ICAgICAgICB3ZWVrZGF5c1Nob3J0UmVnZXg7XG5wcm90byQxLndlZWtkYXlzTWluUmVnZXggICAgPSAgICAgICAgd2Vla2RheXNNaW5SZWdleDtcblxuLy8gSG91cnNcbnByb3RvJDEuaXNQTSA9IGxvY2FsZUlzUE07XG5wcm90byQxLm1lcmlkaWVtID0gbG9jYWxlTWVyaWRpZW07XG5cbmZ1bmN0aW9uIGdldCQxIChmb3JtYXQsIGluZGV4LCBmaWVsZCwgc2V0dGVyKSB7XG4gICAgdmFyIGxvY2FsZSA9IGdldExvY2FsZSgpO1xuICAgIHZhciB1dGMgPSBjcmVhdGVVVEMoKS5zZXQoc2V0dGVyLCBpbmRleCk7XG4gICAgcmV0dXJuIGxvY2FsZVtmaWVsZF0odXRjLCBmb3JtYXQpO1xufVxuXG5mdW5jdGlvbiBsaXN0TW9udGhzSW1wbCAoZm9ybWF0LCBpbmRleCwgZmllbGQpIHtcbiAgICBpZiAoaXNOdW1iZXIoZm9ybWF0KSkge1xuICAgICAgICBpbmRleCA9IGZvcm1hdDtcbiAgICAgICAgZm9ybWF0ID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGZvcm1hdCA9IGZvcm1hdCB8fCAnJztcblxuICAgIGlmIChpbmRleCAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBnZXQkMShmb3JtYXQsIGluZGV4LCBmaWVsZCwgJ21vbnRoJyk7XG4gICAgfVxuXG4gICAgdmFyIGk7XG4gICAgdmFyIG91dCA9IFtdO1xuICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgIG91dFtpXSA9IGdldCQxKGZvcm1hdCwgaSwgZmllbGQsICdtb250aCcpO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xufVxuXG4vLyAoKVxuLy8gKDUpXG4vLyAoZm10LCA1KVxuLy8gKGZtdClcbi8vICh0cnVlKVxuLy8gKHRydWUsIDUpXG4vLyAodHJ1ZSwgZm10LCA1KVxuLy8gKHRydWUsIGZtdClcbmZ1bmN0aW9uIGxpc3RXZWVrZGF5c0ltcGwgKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCwgZmllbGQpIHtcbiAgICBpZiAodHlwZW9mIGxvY2FsZVNvcnRlZCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIGlmIChpc051bWJlcihmb3JtYXQpKSB7XG4gICAgICAgICAgICBpbmRleCA9IGZvcm1hdDtcbiAgICAgICAgICAgIGZvcm1hdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvcm1hdCA9IGZvcm1hdCB8fCAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3JtYXQgPSBsb2NhbGVTb3J0ZWQ7XG4gICAgICAgIGluZGV4ID0gZm9ybWF0O1xuICAgICAgICBsb2NhbGVTb3J0ZWQgPSBmYWxzZTtcblxuICAgICAgICBpZiAoaXNOdW1iZXIoZm9ybWF0KSkge1xuICAgICAgICAgICAgaW5kZXggPSBmb3JtYXQ7XG4gICAgICAgICAgICBmb3JtYXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBmb3JtYXQgPSBmb3JtYXQgfHwgJyc7XG4gICAgfVxuXG4gICAgdmFyIGxvY2FsZSA9IGdldExvY2FsZSgpLFxuICAgICAgICBzaGlmdCA9IGxvY2FsZVNvcnRlZCA/IGxvY2FsZS5fd2Vlay5kb3cgOiAwO1xuXG4gICAgaWYgKGluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGdldCQxKGZvcm1hdCwgKGluZGV4ICsgc2hpZnQpICUgNywgZmllbGQsICdkYXknKTtcbiAgICB9XG5cbiAgICB2YXIgaTtcbiAgICB2YXIgb3V0ID0gW107XG4gICAgZm9yIChpID0gMDsgaSA8IDc7IGkrKykge1xuICAgICAgICBvdXRbaV0gPSBnZXQkMShmb3JtYXQsIChpICsgc2hpZnQpICUgNywgZmllbGQsICdkYXknKTtcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbn1cblxuZnVuY3Rpb24gbGlzdE1vbnRocyAoZm9ybWF0LCBpbmRleCkge1xuICAgIHJldHVybiBsaXN0TW9udGhzSW1wbChmb3JtYXQsIGluZGV4LCAnbW9udGhzJyk7XG59XG5cbmZ1bmN0aW9uIGxpc3RNb250aHNTaG9ydCAoZm9ybWF0LCBpbmRleCkge1xuICAgIHJldHVybiBsaXN0TW9udGhzSW1wbChmb3JtYXQsIGluZGV4LCAnbW9udGhzU2hvcnQnKTtcbn1cblxuZnVuY3Rpb24gbGlzdFdlZWtkYXlzIChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgpIHtcbiAgICByZXR1cm4gbGlzdFdlZWtkYXlzSW1wbChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgsICd3ZWVrZGF5cycpO1xufVxuXG5mdW5jdGlvbiBsaXN0V2Vla2RheXNTaG9ydCAobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4KSB7XG4gICAgcmV0dXJuIGxpc3RXZWVrZGF5c0ltcGwobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4LCAnd2Vla2RheXNTaG9ydCcpO1xufVxuXG5mdW5jdGlvbiBsaXN0V2Vla2RheXNNaW4gKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCkge1xuICAgIHJldHVybiBsaXN0V2Vla2RheXNJbXBsKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCwgJ3dlZWtkYXlzTWluJyk7XG59XG5cbmdldFNldEdsb2JhbExvY2FsZSgnZW4nLCB7XG4gICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogL1xcZHsxLDJ9KHRofHN0fG5kfHJkKS8sXG4gICAgb3JkaW5hbCA6IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgICAgICAgdmFyIGIgPSBudW1iZXIgJSAxMCxcbiAgICAgICAgICAgIG91dHB1dCA9ICh0b0ludChudW1iZXIgJSAxMDAgLyAxMCkgPT09IDEpID8gJ3RoJyA6XG4gICAgICAgICAgICAoYiA9PT0gMSkgPyAnc3QnIDpcbiAgICAgICAgICAgIChiID09PSAyKSA/ICduZCcgOlxuICAgICAgICAgICAgKGIgPT09IDMpID8gJ3JkJyA6ICd0aCc7XG4gICAgICAgIHJldHVybiBudW1iZXIgKyBvdXRwdXQ7XG4gICAgfVxufSk7XG5cbi8vIFNpZGUgZWZmZWN0IGltcG9ydHNcbmhvb2tzLmxhbmcgPSBkZXByZWNhdGUoJ21vbWVudC5sYW5nIGlzIGRlcHJlY2F0ZWQuIFVzZSBtb21lbnQubG9jYWxlIGluc3RlYWQuJywgZ2V0U2V0R2xvYmFsTG9jYWxlKTtcbmhvb2tzLmxhbmdEYXRhID0gZGVwcmVjYXRlKCdtb21lbnQubGFuZ0RhdGEgaXMgZGVwcmVjYXRlZC4gVXNlIG1vbWVudC5sb2NhbGVEYXRhIGluc3RlYWQuJywgZ2V0TG9jYWxlKTtcblxudmFyIG1hdGhBYnMgPSBNYXRoLmFicztcblxuZnVuY3Rpb24gYWJzICgpIHtcbiAgICB2YXIgZGF0YSAgICAgICAgICAgPSB0aGlzLl9kYXRhO1xuXG4gICAgdGhpcy5fbWlsbGlzZWNvbmRzID0gbWF0aEFicyh0aGlzLl9taWxsaXNlY29uZHMpO1xuICAgIHRoaXMuX2RheXMgICAgICAgICA9IG1hdGhBYnModGhpcy5fZGF5cyk7XG4gICAgdGhpcy5fbW9udGhzICAgICAgID0gbWF0aEFicyh0aGlzLl9tb250aHMpO1xuXG4gICAgZGF0YS5taWxsaXNlY29uZHMgID0gbWF0aEFicyhkYXRhLm1pbGxpc2Vjb25kcyk7XG4gICAgZGF0YS5zZWNvbmRzICAgICAgID0gbWF0aEFicyhkYXRhLnNlY29uZHMpO1xuICAgIGRhdGEubWludXRlcyAgICAgICA9IG1hdGhBYnMoZGF0YS5taW51dGVzKTtcbiAgICBkYXRhLmhvdXJzICAgICAgICAgPSBtYXRoQWJzKGRhdGEuaG91cnMpO1xuICAgIGRhdGEubW9udGhzICAgICAgICA9IG1hdGhBYnMoZGF0YS5tb250aHMpO1xuICAgIGRhdGEueWVhcnMgICAgICAgICA9IG1hdGhBYnMoZGF0YS55ZWFycyk7XG5cbiAgICByZXR1cm4gdGhpcztcbn1cblxuZnVuY3Rpb24gYWRkU3VidHJhY3QkMSAoZHVyYXRpb24sIGlucHV0LCB2YWx1ZSwgZGlyZWN0aW9uKSB7XG4gICAgdmFyIG90aGVyID0gY3JlYXRlRHVyYXRpb24oaW5wdXQsIHZhbHVlKTtcblxuICAgIGR1cmF0aW9uLl9taWxsaXNlY29uZHMgKz0gZGlyZWN0aW9uICogb3RoZXIuX21pbGxpc2Vjb25kcztcbiAgICBkdXJhdGlvbi5fZGF5cyAgICAgICAgICs9IGRpcmVjdGlvbiAqIG90aGVyLl9kYXlzO1xuICAgIGR1cmF0aW9uLl9tb250aHMgICAgICAgKz0gZGlyZWN0aW9uICogb3RoZXIuX21vbnRocztcblxuICAgIHJldHVybiBkdXJhdGlvbi5fYnViYmxlKCk7XG59XG5cbi8vIHN1cHBvcnRzIG9ubHkgMi4wLXN0eWxlIGFkZCgxLCAncycpIG9yIGFkZChkdXJhdGlvbilcbmZ1bmN0aW9uIGFkZCQxIChpbnB1dCwgdmFsdWUpIHtcbiAgICByZXR1cm4gYWRkU3VidHJhY3QkMSh0aGlzLCBpbnB1dCwgdmFsdWUsIDEpO1xufVxuXG4vLyBzdXBwb3J0cyBvbmx5IDIuMC1zdHlsZSBzdWJ0cmFjdCgxLCAncycpIG9yIHN1YnRyYWN0KGR1cmF0aW9uKVxuZnVuY3Rpb24gc3VidHJhY3QkMSAoaW5wdXQsIHZhbHVlKSB7XG4gICAgcmV0dXJuIGFkZFN1YnRyYWN0JDEodGhpcywgaW5wdXQsIHZhbHVlLCAtMSk7XG59XG5cbmZ1bmN0aW9uIGFic0NlaWwgKG51bWJlcikge1xuICAgIGlmIChudW1iZXIgPCAwKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKG51bWJlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIE1hdGguY2VpbChudW1iZXIpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gYnViYmxlICgpIHtcbiAgICB2YXIgbWlsbGlzZWNvbmRzID0gdGhpcy5fbWlsbGlzZWNvbmRzO1xuICAgIHZhciBkYXlzICAgICAgICAgPSB0aGlzLl9kYXlzO1xuICAgIHZhciBtb250aHMgICAgICAgPSB0aGlzLl9tb250aHM7XG4gICAgdmFyIGRhdGEgICAgICAgICA9IHRoaXMuX2RhdGE7XG4gICAgdmFyIHNlY29uZHMsIG1pbnV0ZXMsIGhvdXJzLCB5ZWFycywgbW9udGhzRnJvbURheXM7XG5cbiAgICAvLyBpZiB3ZSBoYXZlIGEgbWl4IG9mIHBvc2l0aXZlIGFuZCBuZWdhdGl2ZSB2YWx1ZXMsIGJ1YmJsZSBkb3duIGZpcnN0XG4gICAgLy8gY2hlY2s6IGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L2lzc3Vlcy8yMTY2XG4gICAgaWYgKCEoKG1pbGxpc2Vjb25kcyA+PSAwICYmIGRheXMgPj0gMCAmJiBtb250aHMgPj0gMCkgfHxcbiAgICAgICAgICAgIChtaWxsaXNlY29uZHMgPD0gMCAmJiBkYXlzIDw9IDAgJiYgbW9udGhzIDw9IDApKSkge1xuICAgICAgICBtaWxsaXNlY29uZHMgKz0gYWJzQ2VpbChtb250aHNUb0RheXMobW9udGhzKSArIGRheXMpICogODY0ZTU7XG4gICAgICAgIGRheXMgPSAwO1xuICAgICAgICBtb250aHMgPSAwO1xuICAgIH1cblxuICAgIC8vIFRoZSBmb2xsb3dpbmcgY29kZSBidWJibGVzIHVwIHZhbHVlcywgc2VlIHRoZSB0ZXN0cyBmb3JcbiAgICAvLyBleGFtcGxlcyBvZiB3aGF0IHRoYXQgbWVhbnMuXG4gICAgZGF0YS5taWxsaXNlY29uZHMgPSBtaWxsaXNlY29uZHMgJSAxMDAwO1xuXG4gICAgc2Vjb25kcyAgICAgICAgICAgPSBhYnNGbG9vcihtaWxsaXNlY29uZHMgLyAxMDAwKTtcbiAgICBkYXRhLnNlY29uZHMgICAgICA9IHNlY29uZHMgJSA2MDtcblxuICAgIG1pbnV0ZXMgICAgICAgICAgID0gYWJzRmxvb3Ioc2Vjb25kcyAvIDYwKTtcbiAgICBkYXRhLm1pbnV0ZXMgICAgICA9IG1pbnV0ZXMgJSA2MDtcblxuICAgIGhvdXJzICAgICAgICAgICAgID0gYWJzRmxvb3IobWludXRlcyAvIDYwKTtcbiAgICBkYXRhLmhvdXJzICAgICAgICA9IGhvdXJzICUgMjQ7XG5cbiAgICBkYXlzICs9IGFic0Zsb29yKGhvdXJzIC8gMjQpO1xuXG4gICAgLy8gY29udmVydCBkYXlzIHRvIG1vbnRoc1xuICAgIG1vbnRoc0Zyb21EYXlzID0gYWJzRmxvb3IoZGF5c1RvTW9udGhzKGRheXMpKTtcbiAgICBtb250aHMgKz0gbW9udGhzRnJvbURheXM7XG4gICAgZGF5cyAtPSBhYnNDZWlsKG1vbnRoc1RvRGF5cyhtb250aHNGcm9tRGF5cykpO1xuXG4gICAgLy8gMTIgbW9udGhzIC0+IDEgeWVhclxuICAgIHllYXJzID0gYWJzRmxvb3IobW9udGhzIC8gMTIpO1xuICAgIG1vbnRocyAlPSAxMjtcblxuICAgIGRhdGEuZGF5cyAgID0gZGF5cztcbiAgICBkYXRhLm1vbnRocyA9IG1vbnRocztcbiAgICBkYXRhLnllYXJzICA9IHllYXJzO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59XG5cbmZ1bmN0aW9uIGRheXNUb01vbnRocyAoZGF5cykge1xuICAgIC8vIDQwMCB5ZWFycyBoYXZlIDE0NjA5NyBkYXlzICh0YWtpbmcgaW50byBhY2NvdW50IGxlYXAgeWVhciBydWxlcylcbiAgICAvLyA0MDAgeWVhcnMgaGF2ZSAxMiBtb250aHMgPT09IDQ4MDBcbiAgICByZXR1cm4gZGF5cyAqIDQ4MDAgLyAxNDYwOTc7XG59XG5cbmZ1bmN0aW9uIG1vbnRoc1RvRGF5cyAobW9udGhzKSB7XG4gICAgLy8gdGhlIHJldmVyc2Ugb2YgZGF5c1RvTW9udGhzXG4gICAgcmV0dXJuIG1vbnRocyAqIDE0NjA5NyAvIDQ4MDA7XG59XG5cbmZ1bmN0aW9uIGFzICh1bml0cykge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG4gICAgdmFyIGRheXM7XG4gICAgdmFyIG1vbnRocztcbiAgICB2YXIgbWlsbGlzZWNvbmRzID0gdGhpcy5fbWlsbGlzZWNvbmRzO1xuXG4gICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG5cbiAgICBpZiAodW5pdHMgPT09ICdtb250aCcgfHwgdW5pdHMgPT09ICd5ZWFyJykge1xuICAgICAgICBkYXlzICAgPSB0aGlzLl9kYXlzICAgKyBtaWxsaXNlY29uZHMgLyA4NjRlNTtcbiAgICAgICAgbW9udGhzID0gdGhpcy5fbW9udGhzICsgZGF5c1RvTW9udGhzKGRheXMpO1xuICAgICAgICByZXR1cm4gdW5pdHMgPT09ICdtb250aCcgPyBtb250aHMgOiBtb250aHMgLyAxMjtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBoYW5kbGUgbWlsbGlzZWNvbmRzIHNlcGFyYXRlbHkgYmVjYXVzZSBvZiBmbG9hdGluZyBwb2ludCBtYXRoIGVycm9ycyAoaXNzdWUgIzE4NjcpXG4gICAgICAgIGRheXMgPSB0aGlzLl9kYXlzICsgTWF0aC5yb3VuZChtb250aHNUb0RheXModGhpcy5fbW9udGhzKSk7XG4gICAgICAgIHN3aXRjaCAodW5pdHMpIHtcbiAgICAgICAgICAgIGNhc2UgJ3dlZWsnICAgOiByZXR1cm4gZGF5cyAvIDcgICAgICsgbWlsbGlzZWNvbmRzIC8gNjA0OGU1O1xuICAgICAgICAgICAgY2FzZSAnZGF5JyAgICA6IHJldHVybiBkYXlzICAgICAgICAgKyBtaWxsaXNlY29uZHMgLyA4NjRlNTtcbiAgICAgICAgICAgIGNhc2UgJ2hvdXInICAgOiByZXR1cm4gZGF5cyAqIDI0ICAgICsgbWlsbGlzZWNvbmRzIC8gMzZlNTtcbiAgICAgICAgICAgIGNhc2UgJ21pbnV0ZScgOiByZXR1cm4gZGF5cyAqIDE0NDAgICsgbWlsbGlzZWNvbmRzIC8gNmU0O1xuICAgICAgICAgICAgY2FzZSAnc2Vjb25kJyA6IHJldHVybiBkYXlzICogODY0MDAgKyBtaWxsaXNlY29uZHMgLyAxMDAwO1xuICAgICAgICAgICAgLy8gTWF0aC5mbG9vciBwcmV2ZW50cyBmbG9hdGluZyBwb2ludCBtYXRoIGVycm9ycyBoZXJlXG4gICAgICAgICAgICBjYXNlICdtaWxsaXNlY29uZCc6IHJldHVybiBNYXRoLmZsb29yKGRheXMgKiA4NjRlNSkgKyBtaWxsaXNlY29uZHM7XG4gICAgICAgICAgICBkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gdW5pdCAnICsgdW5pdHMpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vLyBUT0RPOiBVc2UgdGhpcy5hcygnbXMnKT9cbmZ1bmN0aW9uIHZhbHVlT2YkMSAoKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICByZXR1cm4gTmFOO1xuICAgIH1cbiAgICByZXR1cm4gKFxuICAgICAgICB0aGlzLl9taWxsaXNlY29uZHMgK1xuICAgICAgICB0aGlzLl9kYXlzICogODY0ZTUgK1xuICAgICAgICAodGhpcy5fbW9udGhzICUgMTIpICogMjU5MmU2ICtcbiAgICAgICAgdG9JbnQodGhpcy5fbW9udGhzIC8gMTIpICogMzE1MzZlNlxuICAgICk7XG59XG5cbmZ1bmN0aW9uIG1ha2VBcyAoYWxpYXMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hcyhhbGlhcyk7XG4gICAgfTtcbn1cblxudmFyIGFzTWlsbGlzZWNvbmRzID0gbWFrZUFzKCdtcycpO1xudmFyIGFzU2Vjb25kcyAgICAgID0gbWFrZUFzKCdzJyk7XG52YXIgYXNNaW51dGVzICAgICAgPSBtYWtlQXMoJ20nKTtcbnZhciBhc0hvdXJzICAgICAgICA9IG1ha2VBcygnaCcpO1xudmFyIGFzRGF5cyAgICAgICAgID0gbWFrZUFzKCdkJyk7XG52YXIgYXNXZWVrcyAgICAgICAgPSBtYWtlQXMoJ3cnKTtcbnZhciBhc01vbnRocyAgICAgICA9IG1ha2VBcygnTScpO1xudmFyIGFzWWVhcnMgICAgICAgID0gbWFrZUFzKCd5Jyk7XG5cbmZ1bmN0aW9uIGNsb25lJDEgKCkge1xuICAgIHJldHVybiBjcmVhdGVEdXJhdGlvbih0aGlzKTtcbn1cblxuZnVuY3Rpb24gZ2V0JDIgKHVuaXRzKSB7XG4gICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpID8gdGhpc1t1bml0cyArICdzJ10oKSA6IE5hTjtcbn1cblxuZnVuY3Rpb24gbWFrZUdldHRlcihuYW1lKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpID8gdGhpcy5fZGF0YVtuYW1lXSA6IE5hTjtcbiAgICB9O1xufVxuXG52YXIgbWlsbGlzZWNvbmRzID0gbWFrZUdldHRlcignbWlsbGlzZWNvbmRzJyk7XG52YXIgc2Vjb25kcyAgICAgID0gbWFrZUdldHRlcignc2Vjb25kcycpO1xudmFyIG1pbnV0ZXMgICAgICA9IG1ha2VHZXR0ZXIoJ21pbnV0ZXMnKTtcbnZhciBob3VycyAgICAgICAgPSBtYWtlR2V0dGVyKCdob3VycycpO1xudmFyIGRheXMgICAgICAgICA9IG1ha2VHZXR0ZXIoJ2RheXMnKTtcbnZhciBtb250aHMgICAgICAgPSBtYWtlR2V0dGVyKCdtb250aHMnKTtcbnZhciB5ZWFycyAgICAgICAgPSBtYWtlR2V0dGVyKCd5ZWFycycpO1xuXG5mdW5jdGlvbiB3ZWVrcyAoKSB7XG4gICAgcmV0dXJuIGFic0Zsb29yKHRoaXMuZGF5cygpIC8gNyk7XG59XG5cbnZhciByb3VuZCA9IE1hdGgucm91bmQ7XG52YXIgdGhyZXNob2xkcyA9IHtcbiAgICBzczogNDQsICAgICAgICAgLy8gYSBmZXcgc2Vjb25kcyB0byBzZWNvbmRzXG4gICAgcyA6IDQ1LCAgICAgICAgIC8vIHNlY29uZHMgdG8gbWludXRlXG4gICAgbSA6IDQ1LCAgICAgICAgIC8vIG1pbnV0ZXMgdG8gaG91clxuICAgIGggOiAyMiwgICAgICAgICAvLyBob3VycyB0byBkYXlcbiAgICBkIDogMjYsICAgICAgICAgLy8gZGF5cyB0byBtb250aFxuICAgIE0gOiAxMSAgICAgICAgICAvLyBtb250aHMgdG8geWVhclxufTtcblxuLy8gaGVscGVyIGZ1bmN0aW9uIGZvciBtb21lbnQuZm4uZnJvbSwgbW9tZW50LmZuLmZyb21Ob3csIGFuZCBtb21lbnQuZHVyYXRpb24uZm4uaHVtYW5pemVcbmZ1bmN0aW9uIHN1YnN0aXR1dGVUaW1lQWdvKHN0cmluZywgbnVtYmVyLCB3aXRob3V0U3VmZml4LCBpc0Z1dHVyZSwgbG9jYWxlKSB7XG4gICAgcmV0dXJuIGxvY2FsZS5yZWxhdGl2ZVRpbWUobnVtYmVyIHx8IDEsICEhd2l0aG91dFN1ZmZpeCwgc3RyaW5nLCBpc0Z1dHVyZSk7XG59XG5cbmZ1bmN0aW9uIHJlbGF0aXZlVGltZSQxIChwb3NOZWdEdXJhdGlvbiwgd2l0aG91dFN1ZmZpeCwgbG9jYWxlKSB7XG4gICAgdmFyIGR1cmF0aW9uID0gY3JlYXRlRHVyYXRpb24ocG9zTmVnRHVyYXRpb24pLmFicygpO1xuICAgIHZhciBzZWNvbmRzICA9IHJvdW5kKGR1cmF0aW9uLmFzKCdzJykpO1xuICAgIHZhciBtaW51dGVzICA9IHJvdW5kKGR1cmF0aW9uLmFzKCdtJykpO1xuICAgIHZhciBob3VycyAgICA9IHJvdW5kKGR1cmF0aW9uLmFzKCdoJykpO1xuICAgIHZhciBkYXlzICAgICA9IHJvdW5kKGR1cmF0aW9uLmFzKCdkJykpO1xuICAgIHZhciBtb250aHMgICA9IHJvdW5kKGR1cmF0aW9uLmFzKCdNJykpO1xuICAgIHZhciB5ZWFycyAgICA9IHJvdW5kKGR1cmF0aW9uLmFzKCd5JykpO1xuXG4gICAgdmFyIGEgPSBzZWNvbmRzIDw9IHRocmVzaG9sZHMuc3MgJiYgWydzJywgc2Vjb25kc10gIHx8XG4gICAgICAgICAgICBzZWNvbmRzIDwgdGhyZXNob2xkcy5zICAgJiYgWydzcycsIHNlY29uZHNdIHx8XG4gICAgICAgICAgICBtaW51dGVzIDw9IDEgICAgICAgICAgICAgJiYgWydtJ10gICAgICAgICAgIHx8XG4gICAgICAgICAgICBtaW51dGVzIDwgdGhyZXNob2xkcy5tICAgJiYgWydtbScsIG1pbnV0ZXNdIHx8XG4gICAgICAgICAgICBob3VycyAgIDw9IDEgICAgICAgICAgICAgJiYgWydoJ10gICAgICAgICAgIHx8XG4gICAgICAgICAgICBob3VycyAgIDwgdGhyZXNob2xkcy5oICAgJiYgWydoaCcsIGhvdXJzXSAgIHx8XG4gICAgICAgICAgICBkYXlzICAgIDw9IDEgICAgICAgICAgICAgJiYgWydkJ10gICAgICAgICAgIHx8XG4gICAgICAgICAgICBkYXlzICAgIDwgdGhyZXNob2xkcy5kICAgJiYgWydkZCcsIGRheXNdICAgIHx8XG4gICAgICAgICAgICBtb250aHMgIDw9IDEgICAgICAgICAgICAgJiYgWydNJ10gICAgICAgICAgIHx8XG4gICAgICAgICAgICBtb250aHMgIDwgdGhyZXNob2xkcy5NICAgJiYgWydNTScsIG1vbnRoc10gIHx8XG4gICAgICAgICAgICB5ZWFycyAgIDw9IDEgICAgICAgICAgICAgJiYgWyd5J10gICAgICAgICAgIHx8IFsneXknLCB5ZWFyc107XG5cbiAgICBhWzJdID0gd2l0aG91dFN1ZmZpeDtcbiAgICBhWzNdID0gK3Bvc05lZ0R1cmF0aW9uID4gMDtcbiAgICBhWzRdID0gbG9jYWxlO1xuICAgIHJldHVybiBzdWJzdGl0dXRlVGltZUFnby5hcHBseShudWxsLCBhKTtcbn1cblxuLy8gVGhpcyBmdW5jdGlvbiBhbGxvd3MgeW91IHRvIHNldCB0aGUgcm91bmRpbmcgZnVuY3Rpb24gZm9yIHJlbGF0aXZlIHRpbWUgc3RyaW5nc1xuZnVuY3Rpb24gZ2V0U2V0UmVsYXRpdmVUaW1lUm91bmRpbmcgKHJvdW5kaW5nRnVuY3Rpb24pIHtcbiAgICBpZiAocm91bmRpbmdGdW5jdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiByb3VuZDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZihyb3VuZGluZ0Z1bmN0aW9uKSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByb3VuZCA9IHJvdW5kaW5nRnVuY3Rpb247XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIFRoaXMgZnVuY3Rpb24gYWxsb3dzIHlvdSB0byBzZXQgYSB0aHJlc2hvbGQgZm9yIHJlbGF0aXZlIHRpbWUgc3RyaW5nc1xuZnVuY3Rpb24gZ2V0U2V0UmVsYXRpdmVUaW1lVGhyZXNob2xkICh0aHJlc2hvbGQsIGxpbWl0KSB7XG4gICAgaWYgKHRocmVzaG9sZHNbdGhyZXNob2xkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGxpbWl0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHRocmVzaG9sZHNbdGhyZXNob2xkXTtcbiAgICB9XG4gICAgdGhyZXNob2xkc1t0aHJlc2hvbGRdID0gbGltaXQ7XG4gICAgaWYgKHRocmVzaG9sZCA9PT0gJ3MnKSB7XG4gICAgICAgIHRocmVzaG9sZHMuc3MgPSBsaW1pdCAtIDE7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBodW1hbml6ZSAod2l0aFN1ZmZpeCkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLmludmFsaWREYXRlKCk7XG4gICAgfVxuXG4gICAgdmFyIGxvY2FsZSA9IHRoaXMubG9jYWxlRGF0YSgpO1xuICAgIHZhciBvdXRwdXQgPSByZWxhdGl2ZVRpbWUkMSh0aGlzLCAhd2l0aFN1ZmZpeCwgbG9jYWxlKTtcblxuICAgIGlmICh3aXRoU3VmZml4KSB7XG4gICAgICAgIG91dHB1dCA9IGxvY2FsZS5wYXN0RnV0dXJlKCt0aGlzLCBvdXRwdXQpO1xuICAgIH1cblxuICAgIHJldHVybiBsb2NhbGUucG9zdGZvcm1hdChvdXRwdXQpO1xufVxuXG52YXIgYWJzJDEgPSBNYXRoLmFicztcblxuZnVuY3Rpb24gc2lnbih4KSB7XG4gICAgcmV0dXJuICgoeCA+IDApIC0gKHggPCAwKSkgfHwgK3g7XG59XG5cbmZ1bmN0aW9uIHRvSVNPU3RyaW5nJDEoKSB7XG4gICAgLy8gZm9yIElTTyBzdHJpbmdzIHdlIGRvIG5vdCB1c2UgdGhlIG5vcm1hbCBidWJibGluZyBydWxlczpcbiAgICAvLyAgKiBtaWxsaXNlY29uZHMgYnViYmxlIHVwIHVudGlsIHRoZXkgYmVjb21lIGhvdXJzXG4gICAgLy8gICogZGF5cyBkbyBub3QgYnViYmxlIGF0IGFsbFxuICAgIC8vICAqIG1vbnRocyBidWJibGUgdXAgdW50aWwgdGhleSBiZWNvbWUgeWVhcnNcbiAgICAvLyBUaGlzIGlzIGJlY2F1c2UgdGhlcmUgaXMgbm8gY29udGV4dC1mcmVlIGNvbnZlcnNpb24gYmV0d2VlbiBob3VycyBhbmQgZGF5c1xuICAgIC8vICh0aGluayBvZiBjbG9jayBjaGFuZ2VzKVxuICAgIC8vIGFuZCBhbHNvIG5vdCBiZXR3ZWVuIGRheXMgYW5kIG1vbnRocyAoMjgtMzEgZGF5cyBwZXIgbW9udGgpXG4gICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkuaW52YWxpZERhdGUoKTtcbiAgICB9XG5cbiAgICB2YXIgc2Vjb25kcyA9IGFicyQxKHRoaXMuX21pbGxpc2Vjb25kcykgLyAxMDAwO1xuICAgIHZhciBkYXlzICAgICAgICAgPSBhYnMkMSh0aGlzLl9kYXlzKTtcbiAgICB2YXIgbW9udGhzICAgICAgID0gYWJzJDEodGhpcy5fbW9udGhzKTtcbiAgICB2YXIgbWludXRlcywgaG91cnMsIHllYXJzO1xuXG4gICAgLy8gMzYwMCBzZWNvbmRzIC0+IDYwIG1pbnV0ZXMgLT4gMSBob3VyXG4gICAgbWludXRlcyAgICAgICAgICAgPSBhYnNGbG9vcihzZWNvbmRzIC8gNjApO1xuICAgIGhvdXJzICAgICAgICAgICAgID0gYWJzRmxvb3IobWludXRlcyAvIDYwKTtcbiAgICBzZWNvbmRzICU9IDYwO1xuICAgIG1pbnV0ZXMgJT0gNjA7XG5cbiAgICAvLyAxMiBtb250aHMgLT4gMSB5ZWFyXG4gICAgeWVhcnMgID0gYWJzRmxvb3IobW9udGhzIC8gMTIpO1xuICAgIG1vbnRocyAlPSAxMjtcblxuXG4gICAgLy8gaW5zcGlyZWQgYnkgaHR0cHM6Ly9naXRodWIuY29tL2RvcmRpbGxlL21vbWVudC1pc29kdXJhdGlvbi9ibG9iL21hc3Rlci9tb21lbnQuaXNvZHVyYXRpb24uanNcbiAgICB2YXIgWSA9IHllYXJzO1xuICAgIHZhciBNID0gbW9udGhzO1xuICAgIHZhciBEID0gZGF5cztcbiAgICB2YXIgaCA9IGhvdXJzO1xuICAgIHZhciBtID0gbWludXRlcztcbiAgICB2YXIgcyA9IHNlY29uZHMgPyBzZWNvbmRzLnRvRml4ZWQoMykucmVwbGFjZSgvXFwuPzArJC8sICcnKSA6ICcnO1xuICAgIHZhciB0b3RhbCA9IHRoaXMuYXNTZWNvbmRzKCk7XG5cbiAgICBpZiAoIXRvdGFsKSB7XG4gICAgICAgIC8vIHRoaXMgaXMgdGhlIHNhbWUgYXMgQyMncyAoTm9kYSkgYW5kIHB5dGhvbiAoaXNvZGF0ZSkuLi5cbiAgICAgICAgLy8gYnV0IG5vdCBvdGhlciBKUyAoZ29vZy5kYXRlKVxuICAgICAgICByZXR1cm4gJ1AwRCc7XG4gICAgfVxuXG4gICAgdmFyIHRvdGFsU2lnbiA9IHRvdGFsIDwgMCA/ICctJyA6ICcnO1xuICAgIHZhciB5bVNpZ24gPSBzaWduKHRoaXMuX21vbnRocykgIT09IHNpZ24odG90YWwpID8gJy0nIDogJyc7XG4gICAgdmFyIGRheXNTaWduID0gc2lnbih0aGlzLl9kYXlzKSAhPT0gc2lnbih0b3RhbCkgPyAnLScgOiAnJztcbiAgICB2YXIgaG1zU2lnbiA9IHNpZ24odGhpcy5fbWlsbGlzZWNvbmRzKSAhPT0gc2lnbih0b3RhbCkgPyAnLScgOiAnJztcblxuICAgIHJldHVybiB0b3RhbFNpZ24gKyAnUCcgK1xuICAgICAgICAoWSA/IHltU2lnbiArIFkgKyAnWScgOiAnJykgK1xuICAgICAgICAoTSA/IHltU2lnbiArIE0gKyAnTScgOiAnJykgK1xuICAgICAgICAoRCA/IGRheXNTaWduICsgRCArICdEJyA6ICcnKSArXG4gICAgICAgICgoaCB8fCBtIHx8IHMpID8gJ1QnIDogJycpICtcbiAgICAgICAgKGggPyBobXNTaWduICsgaCArICdIJyA6ICcnKSArXG4gICAgICAgIChtID8gaG1zU2lnbiArIG0gKyAnTScgOiAnJykgK1xuICAgICAgICAocyA/IGhtc1NpZ24gKyBzICsgJ1MnIDogJycpO1xufVxuXG52YXIgcHJvdG8kMiA9IER1cmF0aW9uLnByb3RvdHlwZTtcblxucHJvdG8kMi5pc1ZhbGlkICAgICAgICA9IGlzVmFsaWQkMTtcbnByb3RvJDIuYWJzICAgICAgICAgICAgPSBhYnM7XG5wcm90byQyLmFkZCAgICAgICAgICAgID0gYWRkJDE7XG5wcm90byQyLnN1YnRyYWN0ICAgICAgID0gc3VidHJhY3QkMTtcbnByb3RvJDIuYXMgICAgICAgICAgICAgPSBhcztcbnByb3RvJDIuYXNNaWxsaXNlY29uZHMgPSBhc01pbGxpc2Vjb25kcztcbnByb3RvJDIuYXNTZWNvbmRzICAgICAgPSBhc1NlY29uZHM7XG5wcm90byQyLmFzTWludXRlcyAgICAgID0gYXNNaW51dGVzO1xucHJvdG8kMi5hc0hvdXJzICAgICAgICA9IGFzSG91cnM7XG5wcm90byQyLmFzRGF5cyAgICAgICAgID0gYXNEYXlzO1xucHJvdG8kMi5hc1dlZWtzICAgICAgICA9IGFzV2Vla3M7XG5wcm90byQyLmFzTW9udGhzICAgICAgID0gYXNNb250aHM7XG5wcm90byQyLmFzWWVhcnMgICAgICAgID0gYXNZZWFycztcbnByb3RvJDIudmFsdWVPZiAgICAgICAgPSB2YWx1ZU9mJDE7XG5wcm90byQyLl9idWJibGUgICAgICAgID0gYnViYmxlO1xucHJvdG8kMi5jbG9uZSAgICAgICAgICA9IGNsb25lJDE7XG5wcm90byQyLmdldCAgICAgICAgICAgID0gZ2V0JDI7XG5wcm90byQyLm1pbGxpc2Vjb25kcyAgID0gbWlsbGlzZWNvbmRzO1xucHJvdG8kMi5zZWNvbmRzICAgICAgICA9IHNlY29uZHM7XG5wcm90byQyLm1pbnV0ZXMgICAgICAgID0gbWludXRlcztcbnByb3RvJDIuaG91cnMgICAgICAgICAgPSBob3VycztcbnByb3RvJDIuZGF5cyAgICAgICAgICAgPSBkYXlzO1xucHJvdG8kMi53ZWVrcyAgICAgICAgICA9IHdlZWtzO1xucHJvdG8kMi5tb250aHMgICAgICAgICA9IG1vbnRocztcbnByb3RvJDIueWVhcnMgICAgICAgICAgPSB5ZWFycztcbnByb3RvJDIuaHVtYW5pemUgICAgICAgPSBodW1hbml6ZTtcbnByb3RvJDIudG9JU09TdHJpbmcgICAgPSB0b0lTT1N0cmluZyQxO1xucHJvdG8kMi50b1N0cmluZyAgICAgICA9IHRvSVNPU3RyaW5nJDE7XG5wcm90byQyLnRvSlNPTiAgICAgICAgID0gdG9JU09TdHJpbmckMTtcbnByb3RvJDIubG9jYWxlICAgICAgICAgPSBsb2NhbGU7XG5wcm90byQyLmxvY2FsZURhdGEgICAgID0gbG9jYWxlRGF0YTtcblxuLy8gRGVwcmVjYXRpb25zXG5wcm90byQyLnRvSXNvU3RyaW5nID0gZGVwcmVjYXRlKCd0b0lzb1N0cmluZygpIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgdG9JU09TdHJpbmcoKSBpbnN0ZWFkIChub3RpY2UgdGhlIGNhcGl0YWxzKScsIHRvSVNPU3RyaW5nJDEpO1xucHJvdG8kMi5sYW5nID0gbGFuZztcblxuLy8gU2lkZSBlZmZlY3QgaW1wb3J0c1xuXG4vLyBGT1JNQVRUSU5HXG5cbmFkZEZvcm1hdFRva2VuKCdYJywgMCwgMCwgJ3VuaXgnKTtcbmFkZEZvcm1hdFRva2VuKCd4JywgMCwgMCwgJ3ZhbHVlT2YnKTtcblxuLy8gUEFSU0lOR1xuXG5hZGRSZWdleFRva2VuKCd4JywgbWF0Y2hTaWduZWQpO1xuYWRkUmVnZXhUb2tlbignWCcsIG1hdGNoVGltZXN0YW1wKTtcbmFkZFBhcnNlVG9rZW4oJ1gnLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShwYXJzZUZsb2F0KGlucHV0LCAxMCkgKiAxMDAwKTtcbn0pO1xuYWRkUGFyc2VUb2tlbigneCcsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKHRvSW50KGlucHV0KSk7XG59KTtcblxuLy8gU2lkZSBlZmZlY3QgaW1wb3J0c1xuXG5cbmhvb2tzLnZlcnNpb24gPSAnMi4yMC4xJztcblxuc2V0SG9va0NhbGxiYWNrKGNyZWF0ZUxvY2FsKTtcblxuaG9va3MuZm4gICAgICAgICAgICAgICAgICAgID0gcHJvdG87XG5ob29rcy5taW4gICAgICAgICAgICAgICAgICAgPSBtaW47XG5ob29rcy5tYXggICAgICAgICAgICAgICAgICAgPSBtYXg7XG5ob29rcy5ub3cgICAgICAgICAgICAgICAgICAgPSBub3c7XG5ob29rcy51dGMgICAgICAgICAgICAgICAgICAgPSBjcmVhdGVVVEM7XG5ob29rcy51bml4ICAgICAgICAgICAgICAgICAgPSBjcmVhdGVVbml4O1xuaG9va3MubW9udGhzICAgICAgICAgICAgICAgID0gbGlzdE1vbnRocztcbmhvb2tzLmlzRGF0ZSAgICAgICAgICAgICAgICA9IGlzRGF0ZTtcbmhvb2tzLmxvY2FsZSAgICAgICAgICAgICAgICA9IGdldFNldEdsb2JhbExvY2FsZTtcbmhvb2tzLmludmFsaWQgICAgICAgICAgICAgICA9IGNyZWF0ZUludmFsaWQ7XG5ob29rcy5kdXJhdGlvbiAgICAgICAgICAgICAgPSBjcmVhdGVEdXJhdGlvbjtcbmhvb2tzLmlzTW9tZW50ICAgICAgICAgICAgICA9IGlzTW9tZW50O1xuaG9va3Mud2Vla2RheXMgICAgICAgICAgICAgID0gbGlzdFdlZWtkYXlzO1xuaG9va3MucGFyc2Vab25lICAgICAgICAgICAgID0gY3JlYXRlSW5ab25lO1xuaG9va3MubG9jYWxlRGF0YSAgICAgICAgICAgID0gZ2V0TG9jYWxlO1xuaG9va3MuaXNEdXJhdGlvbiAgICAgICAgICAgID0gaXNEdXJhdGlvbjtcbmhvb2tzLm1vbnRoc1Nob3J0ICAgICAgICAgICA9IGxpc3RNb250aHNTaG9ydDtcbmhvb2tzLndlZWtkYXlzTWluICAgICAgICAgICA9IGxpc3RXZWVrZGF5c01pbjtcbmhvb2tzLmRlZmluZUxvY2FsZSAgICAgICAgICA9IGRlZmluZUxvY2FsZTtcbmhvb2tzLnVwZGF0ZUxvY2FsZSAgICAgICAgICA9IHVwZGF0ZUxvY2FsZTtcbmhvb2tzLmxvY2FsZXMgICAgICAgICAgICAgICA9IGxpc3RMb2NhbGVzO1xuaG9va3Mud2Vla2RheXNTaG9ydCAgICAgICAgID0gbGlzdFdlZWtkYXlzU2hvcnQ7XG5ob29rcy5ub3JtYWxpemVVbml0cyAgICAgICAgPSBub3JtYWxpemVVbml0cztcbmhvb2tzLnJlbGF0aXZlVGltZVJvdW5kaW5nICA9IGdldFNldFJlbGF0aXZlVGltZVJvdW5kaW5nO1xuaG9va3MucmVsYXRpdmVUaW1lVGhyZXNob2xkID0gZ2V0U2V0UmVsYXRpdmVUaW1lVGhyZXNob2xkO1xuaG9va3MuY2FsZW5kYXJGb3JtYXQgICAgICAgID0gZ2V0Q2FsZW5kYXJGb3JtYXQ7XG5ob29rcy5wcm90b3R5cGUgICAgICAgICAgICAgPSBwcm90bztcblxuLy8gY3VycmVudGx5IEhUTUw1IGlucHV0IHR5cGUgb25seSBzdXBwb3J0cyAyNC1ob3VyIGZvcm1hdHNcbmhvb2tzLkhUTUw1X0ZNVCA9IHtcbiAgICBEQVRFVElNRV9MT0NBTDogJ1lZWVktTU0tRERUSEg6bW0nLCAgICAgICAgICAgICAvLyA8aW5wdXQgdHlwZT1cImRhdGV0aW1lLWxvY2FsXCIgLz5cbiAgICBEQVRFVElNRV9MT0NBTF9TRUNPTkRTOiAnWVlZWS1NTS1ERFRISDptbTpzcycsICAvLyA8aW5wdXQgdHlwZT1cImRhdGV0aW1lLWxvY2FsXCIgc3RlcD1cIjFcIiAvPlxuICAgIERBVEVUSU1FX0xPQ0FMX01TOiAnWVlZWS1NTS1ERFRISDptbTpzcy5TU1MnLCAgIC8vIDxpbnB1dCB0eXBlPVwiZGF0ZXRpbWUtbG9jYWxcIiBzdGVwPVwiMC4wMDFcIiAvPlxuICAgIERBVEU6ICdZWVlZLU1NLUREJywgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDxpbnB1dCB0eXBlPVwiZGF0ZVwiIC8+XG4gICAgVElNRTogJ0hIOm1tJywgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gPGlucHV0IHR5cGU9XCJ0aW1lXCIgLz5cbiAgICBUSU1FX1NFQ09ORFM6ICdISDptbTpzcycsICAgICAgICAgICAgICAgICAgICAgICAvLyA8aW5wdXQgdHlwZT1cInRpbWVcIiBzdGVwPVwiMVwiIC8+XG4gICAgVElNRV9NUzogJ0hIOm1tOnNzLlNTUycsICAgICAgICAgICAgICAgICAgICAgICAgLy8gPGlucHV0IHR5cGU9XCJ0aW1lXCIgc3RlcD1cIjAuMDAxXCIgLz5cbiAgICBXRUVLOiAnWVlZWS1bV11XVycsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyA8aW5wdXQgdHlwZT1cIndlZWtcIiAvPlxuICAgIE1PTlRIOiAnWVlZWS1NTScgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDxpbnB1dCB0eXBlPVwibW9udGhcIiAvPlxufTtcblxucmV0dXJuIGhvb2tzO1xuXG59KSkpO1xuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvaW5kZXgnKTtcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9wb255ZmlsbCA9IHJlcXVpcmUoJy4vcG9ueWZpbGwuanMnKTtcblxudmFyIF9wb255ZmlsbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wb255ZmlsbCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIHJvb3Q7IC8qIGdsb2JhbCB3aW5kb3cgKi9cblxuXG5pZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7XG4gIHJvb3QgPSBzZWxmO1xufSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICByb290ID0gd2luZG93O1xufSBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuICByb290ID0gZ2xvYmFsO1xufSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykge1xuICByb290ID0gbW9kdWxlO1xufSBlbHNlIHtcbiAgcm9vdCA9IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG59XG5cbnZhciByZXN1bHQgPSAoMCwgX3BvbnlmaWxsMlsnZGVmYXVsdCddKShyb290KTtcbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IHJlc3VsdDsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHR2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzWydkZWZhdWx0J10gPSBzeW1ib2xPYnNlcnZhYmxlUG9ueWZpbGw7XG5mdW5jdGlvbiBzeW1ib2xPYnNlcnZhYmxlUG9ueWZpbGwocm9vdCkge1xuXHR2YXIgcmVzdWx0O1xuXHR2YXIgX1N5bWJvbCA9IHJvb3QuU3ltYm9sO1xuXG5cdGlmICh0eXBlb2YgX1N5bWJvbCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdGlmIChfU3ltYm9sLm9ic2VydmFibGUpIHtcblx0XHRcdHJlc3VsdCA9IF9TeW1ib2wub2JzZXJ2YWJsZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmVzdWx0ID0gX1N5bWJvbCgnb2JzZXJ2YWJsZScpO1xuXHRcdFx0X1N5bWJvbC5vYnNlcnZhYmxlID0gcmVzdWx0O1xuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRyZXN1bHQgPSAnQEBvYnNlcnZhYmxlJztcblx0fVxuXG5cdHJldHVybiByZXN1bHQ7XG59OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBTaW1pbGFyIHRvIGludmFyaWFudCBidXQgb25seSBsb2dzIGEgd2FybmluZyBpZiB0aGUgY29uZGl0aW9uIGlzIG5vdCBtZXQuXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGxvZyBpc3N1ZXMgaW4gZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzIGluIGNyaXRpY2FsXG4gKiBwYXRocy4gUmVtb3ZpbmcgdGhlIGxvZ2dpbmcgY29kZSBmb3IgcHJvZHVjdGlvbiBlbnZpcm9ubWVudHMgd2lsbCBrZWVwIHRoZVxuICogc2FtZSBsb2dpYyBhbmQgZm9sbG93IHRoZSBzYW1lIGNvZGUgcGF0aHMuXG4gKi9cblxudmFyIHdhcm5pbmcgPSBmdW5jdGlvbigpIHt9O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB3YXJuaW5nID0gZnVuY3Rpb24oY29uZGl0aW9uLCBmb3JtYXQsIGFyZ3MpIHtcbiAgICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBhcmdzID0gbmV3IEFycmF5KGxlbiA+IDIgPyBsZW4gLSAyIDogMCk7XG4gICAgZm9yICh2YXIga2V5ID0gMjsga2V5IDwgbGVuOyBrZXkrKykge1xuICAgICAgYXJnc1trZXkgLSAyXSA9IGFyZ3VtZW50c1trZXldO1xuICAgIH1cbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ2B3YXJuaW5nKGNvbmRpdGlvbiwgZm9ybWF0LCAuLi5hcmdzKWAgcmVxdWlyZXMgYSB3YXJuaW5nICcgK1xuICAgICAgICAnbWVzc2FnZSBhcmd1bWVudCdcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKGZvcm1hdC5sZW5ndGggPCAxMCB8fCAoL15bc1xcV10qJC8pLnRlc3QoZm9ybWF0KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnVGhlIHdhcm5pbmcgZm9ybWF0IHNob3VsZCBiZSBhYmxlIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgJyArXG4gICAgICAgICd3YXJuaW5nLiBQbGVhc2UsIHVzZSBhIG1vcmUgZGVzY3JpcHRpdmUgZm9ybWF0IHRoYW46ICcgKyBmb3JtYXRcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICtcbiAgICAgICAgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgICAgICB9KTtcbiAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgfSBjYXRjaCh4KSB7fVxuICAgIH1cbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB3YXJuaW5nO1xuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIm5hbWVcIjogXCJAa3luaWtvcy93aWtpLW1vbmtleVwiLFxuICBcInZlcnNpb25cIjogXCI0LjAuMFwiLFxuICBcImF1dGhvclwiOiBcIkRhcmlvIEdpb3Zhbm5ldHRpXCIsXG4gIFwiZGVzY3JpcHRpb25cIjogXCJNZWRpYVdpa2kgYm90IGFuZCBlZGl0b3ItYXNzaXN0YW50IHVzZXIgc2NyaXB0LlwiLFxuICBcImxpY2Vuc2VcIjogXCJHUEwtMy4wXCIsXG4gIFwicmVwb3NpdG9yeVwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiZ2l0XCIsXG4gICAgXCJ1cmxcIjogXCJodHRwczovL2dpdGh1Yi5jb20va3luaWtvcy93aWtpLW1vbmtleS5naXRcIlxuICB9LFxuICBcImtleXdvcmRzXCI6IFtcbiAgICBcIndpa2kgbWVkaWF3aWtpIGJvdFwiXG4gIF0sXG4gIFwiZGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcIkBreW5pa29zL21pc2NcIjogXCJeMC4xLjNcIixcbiAgICBcImJhYmVsLXBvbHlmaWxsXCI6IFwiXjYuMjYuMFwiLFxuICAgIFwiaHlwZXJzY3JpcHRcIjogXCJeMi4wLjJcIixcbiAgICBcImh5cGVyc2NyaXB0LWhlbHBlcnNcIjogXCJeMy4wLjNcIixcbiAgICBcImpzc1wiOiBcIl45LjUuMVwiLFxuICAgIFwianNzLXByZXNldC1kZWZhdWx0XCI6IFwiXjQuMS4wXCIsXG4gICAgXCJtb21lbnRcIjogXCJeMi4yMC4xXCJcbiAgfSxcbiAgXCJkZXZEZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiQGt5bmlrb3MvYnJvd3NlcmlmeS1oZWxwZXJzXCI6IFwiXjEuMC43XCIsXG4gICAgXCJiYWJlbC1jb3JlXCI6IFwiXjYuMjYuMFwiLFxuICAgIFwiYmFiZWwtcHJlc2V0LWVudlwiOiBcIl4xLjYuMVwiLFxuICAgIFwiY29mZmVlbGludFwiOiBcIl4yLjAuN1wiLFxuICAgIFwiY29mZmVlc2NyaXB0XCI6IFwiXjIuMS4xXCIsXG4gICAgXCJodHRwLXNlcnZlclwiOiBcIl4wLjExLjFcIlxuICB9XG59XG4iLCIjIFdpa2kgTW9ua2V5IC0gTWVkaWFXaWtpIGJvdCBhbmQgZWRpdG9yLWFzc2lzdGFudCB1c2VyIHNjcmlwdFxuIyBDb3B5cmlnaHQgKEMpIDIwMTEgRGFyaW8gR2lvdmFubmV0dGkgPGRldkBkYXJpb2dpb3Zhbm5ldHRpLm5ldD5cbiNcbiMgVGhpcyBmaWxlIGlzIHBhcnQgb2YgV2lraSBNb25rZXkuXG4jXG4jIFdpa2kgTW9ua2V5IGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiMgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiMgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiMgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbiNcbiMgV2lraSBNb25rZXkgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiMgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiMgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuIyBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuI1xuIyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuIyBhbG9uZyB3aXRoIFdpa2kgTW9ua2V5LiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuXG57V019ID0gcmVxdWlyZSgnLi9tb2R1bGVzL19Jbml0JylcblxubmV3IFdNKFxuICAgIFwiQXJjaFdpa2lcIixcblxuICAgICMgVGhlIHJlcXVpcmUgcGF0aHMgY2FuJ3QgYmUgY29uc3RydWN0ZWQgZHluYW1pY2FsbHksIG9yIGJyb3dzZXJpZnkgd29uJ3RcbiAgICAjIHVuZGVyc3RhbmQgYW5kIGltcG9ydCB0aGVtXG4gICAgcmVxdWlyZShcIi4vcGx1Z2lucy9BcmNoV2lraUZpeEhlYWRlclwiKSxcbiAgICByZXF1aXJlKFwiLi9wbHVnaW5zL0FyY2hXaWtpRml4SGVhZGluZ3NcIiksXG4gICAgcmVxdWlyZShcIi4vcGx1Z2lucy9BcmNoV2lraUZpeExpbmtzXCIpLFxuICAgIHJlcXVpcmUoXCIuL3BsdWdpbnMvQXJjaFdpa2lOZXdUZW1wbGF0ZXNcIiksXG4gICAgcmVxdWlyZShcIi4vcGx1Z2lucy9BcmNoV2lraU5QRmlsdGVyXCIpLFxuICAgIHJlcXVpcmUoXCIuL3BsdWdpbnMvQXJjaFdpa2lSQ0ZpbHRlclwiKSxcbiAgICByZXF1aXJlKFwiLi9wbHVnaW5zL0FyY2hXaWtpU2F2ZVRhbGtcIiksXG4gICAgcmVxdWlyZShcIi4vcGx1Z2lucy9BcmNoV2lraVNvcnRDb250YWN0c1wiKSxcbiAgICAjIFRoZSBBcmNoUGFja2FnZXMgbW9kdWxlIGlzIGN1cnJlbnRseSB1bnVzYWJsZVxuICAgICNyZXF1aXJlKFwiLi9wbHVnaW5zL0FyY2hXaWtpVXBkYXRlUGFja2FnZVRlbXBsYXRlc1wiKSxcbiAgICByZXF1aXJlKFwiLi9wbHVnaW5zL0FyY2hXaWtpV2FudGVkQ2F0ZWdvcmllc1wiKSxcbiAgICByZXF1aXJlKFwiLi9wbHVnaW5zL0RlbGV0ZVBhZ2VzXCIpLFxuICAgIHJlcXVpcmUoXCIuL3BsdWdpbnMvRXhwYW5kQ29udHJhY3Rpb25zXCIpLFxuICAgIHJlcXVpcmUoXCIuL3BsdWdpbnMvRml4QmFja2xpbmtGcmFnbWVudHNcIiksXG4gICAgcmVxdWlyZShcIi4vcGx1Z2lucy9GaXhEb3VibGVSZWRpcmVjdHNcIiksXG4gICAgcmVxdWlyZShcIi4vcGx1Z2lucy9GaXhGcmFnbWVudHNcIiksXG4gICAgcmVxdWlyZShcIi4vcGx1Z2lucy9GaXhMaW5rRnJhZ21lbnRzXCIpLFxuICAgIHJlcXVpcmUoXCIuL3BsdWdpbnMvTXVsdGlwbGVMaW5lQnJlYWtzXCIpLFxuICAgIHJlcXVpcmUoXCIuL3BsdWdpbnMvU2ltcGxlUmVwbGFjZVwiKSxcbiAgICByZXF1aXJlKFwiLi9wbHVnaW5zL1N5bmNocm9uaXplSW50ZXJsYW5ndWFnZUxpbmtzXCIpLFxuICAgIHJlcXVpcmUoXCIuL3BsdWdpbnMvVXBkYXRlQ2F0ZWdvcnlUcmVlXCIpLFxuKVxuIiwiIyBXaWtpIE1vbmtleSAtIE1lZGlhV2lraSBib3QgYW5kIGVkaXRvci1hc3Npc3RhbnQgdXNlciBzY3JpcHRcbiMgQ29weXJpZ2h0IChDKSAyMDExIERhcmlvIEdpb3Zhbm5ldHRpIDxkZXZAZGFyaW9naW92YW5uZXR0aS5uZXQ+XG4jXG4jIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFdpa2kgTW9ua2V5LlxuI1xuIyBXaWtpIE1vbmtleSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4jIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4jIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4jIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4jXG4jIFdpa2kgTW9ua2V5IGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4jIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4jIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiMgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbiNcbiMgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiMgYWxvbmcgd2l0aCBXaWtpIE1vbmtleS4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cblxuXG5jbGFzcyBtb2R1bGUuZXhwb3J0c1xuICAgIGNvbnN0cnVjdG9yOiAoQFdNKSAtPlxuXG4gICAgbGFuZ3VhZ2VzID0ge1xuICAgICAgICBsb2NhbDogXCJFbmdsaXNoXCIsXG4gICAgICAgIG5hbWVzOiB7XG4gICAgICAgICAgICBcItin2YTYudix2KjZitipXCI6IHtzdWJ0YWc6IFwiYXJcIiwgZW5nbGlzaDogXCJBcmFiaWNcIn0sXG4gICAgICAgICAgICBcItCR0YrQu9Cz0LDRgNGB0LrQuFwiOiB7c3VidGFnOiBcImJnXCIsIGVuZ2xpc2g6IFwiQnVsZ2FyaWFuXCJ9LFxuICAgICAgICAgICAgXCJDYXRhbMOgXCI6IHtzdWJ0YWc6IFwiY2FcIiwgZW5nbGlzaDogXCJDYXRhbGFuXCJ9LFxuICAgICAgICAgICAgXCLEjGVza3lcIjoge3N1YnRhZzogXCJjc1wiLCBlbmdsaXNoOiBcIkN6ZWNoXCJ9LFxuICAgICAgICAgICAgXCJEYW5za1wiOiB7c3VidGFnOiBcImRhXCIsIGVuZ2xpc2g6IFwiRGFuaXNoXCJ9LFxuICAgICAgICAgICAgXCJEZXV0c2NoXCI6IHtzdWJ0YWc6IFwiZGVcIiwgZW5nbGlzaDogXCJHZXJtYW5cIn0sXG4gICAgICAgICAgICBcIs6VzrvOu863zr3Ouc66zqxcIjoge3N1YnRhZzogXCJlbFwiLCBlbmdsaXNoOiBcIkdyZWVrXCJ9LFxuICAgICAgICAgICAgXCJFbmdsaXNoXCI6IHtzdWJ0YWc6IFwiZW5cIiwgZW5nbGlzaDogXCJFbmdsaXNoXCJ9LFxuICAgICAgICAgICAgXCJFc3BlcmFudG9cIjoge3N1YnRhZzogXCJlb1wiLCBlbmdsaXNoOiBcIkVzcGVyYW50b1wifSxcbiAgICAgICAgICAgIFwiRXNwYcOxb2xcIjoge3N1YnRhZzogXCJlc1wiLCBlbmdsaXNoOiBcIlNwYW5pc2hcIn0sXG4gICAgICAgICAgICBcItmB2KfYsdiz24xcIjoge3N1YnRhZzogXCJmYVwiLCBlbmdsaXNoOiBcIlBlcnNpYW5cIn0sXG4gICAgICAgICAgICBcIlN1b21pXCI6IHtzdWJ0YWc6IFwiZmlcIiwgZW5nbGlzaDogXCJGaW5uaXNoXCJ9LFxuICAgICAgICAgICAgXCJGcmFuw6dhaXNcIjoge3N1YnRhZzogXCJmclwiLCBlbmdsaXNoOiBcIkZyZW5jaFwifSxcbiAgICAgICAgICAgIFwi16LXkdeo15nXqlwiOiB7c3VidGFnOiBcImhlXCIsIGVuZ2xpc2g6IFwiSGVicmV3XCJ9LFxuICAgICAgICAgICAgXCJIcnZhdHNraVwiOiB7c3VidGFnOiBcImhyXCIsIGVuZ2xpc2g6IFwiQ3JvYXRpYW5cIn0sXG4gICAgICAgICAgICBcIk1hZ3lhclwiOiB7c3VidGFnOiBcImh1XCIsIGVuZ2xpc2g6IFwiSHVuZ2FyaWFuXCJ9LFxuICAgICAgICAgICAgXCJJbmRvbmVzaWFcIjoge3N1YnRhZzogXCJpZFwiLCBlbmdsaXNoOiBcIkluZG9uZXNpYW5cIn0sXG4gICAgICAgICAgICBcIkl0YWxpYW5vXCI6IHtzdWJ0YWc6IFwiaXRcIiwgZW5nbGlzaDogXCJJdGFsaWFuXCJ9LFxuICAgICAgICAgICAgXCLml6XmnKzoqp5cIjoge3N1YnRhZzogXCJqYVwiLCBlbmdsaXNoOiBcIkphcGFuZXNlXCJ9LFxuICAgICAgICAgICAgXCLtlZzqta3slrRcIjoge3N1YnRhZzogXCJrb1wiLCBlbmdsaXNoOiBcIktvcmVhblwifSxcbiAgICAgICAgICAgIFwiTGlldHV2acWha2FpXCI6IHtzdWJ0YWc6IFwibHRcIiwgZW5nbGlzaDogXCJMaXRodWFuaWFuXCJ9LFxuICAgICAgICAgICAgXCJOb3JzayBCb2ttw6VsXCI6IHtzdWJ0YWc6IFwibmJcIiwgZW5nbGlzaDogXCJOb3J3ZWdpYW4gKEJva23DpWwpXCJ9LFxuICAgICAgICAgICAgXCJOZWRlcmxhbmRzXCI6IHtzdWJ0YWc6IFwibmxcIiwgZW5nbGlzaDogXCJEdXRjaFwifSxcbiAgICAgICAgICAgIFwiUG9sc2tpXCI6IHtzdWJ0YWc6IFwicGxcIiwgZW5nbGlzaDogXCJQb2xpc2hcIn0sXG4gICAgICAgICAgICBcIlBvcnR1Z3XDqnNcIjoge3N1YnRhZzogXCJwdFwiLCBlbmdsaXNoOiBcIlBvcnR1Z3Vlc2VcIn0sXG4gICAgICAgICAgICBcIlJvbcOibsSDXCI6IHtzdWJ0YWc6IFwicm9cIiwgZW5nbGlzaDogXCJSb21hbmlhblwifSxcbiAgICAgICAgICAgIFwi0KDRg9GB0YHQutC40LlcIjoge3N1YnRhZzogXCJydVwiLCBlbmdsaXNoOiBcIlJ1c3NpYW5cIn0sXG4gICAgICAgICAgICBcIlNsb3ZlbnNrw71cIjoge3N1YnRhZzogXCJza1wiLCBlbmdsaXNoOiBcIlNsb3Zha1wifSxcbiAgICAgICAgICAgIFwi0KHRgNC/0YHQutC4XCI6IHtzdWJ0YWc6IFwic3JcIiwgZW5nbGlzaDogXCJTZXJiaWFuXCJ9LFxuICAgICAgICAgICAgXCJTdmVuc2thXCI6IHtzdWJ0YWc6IFwic3ZcIiwgZW5nbGlzaDogXCJTd2VkaXNoXCJ9LFxuICAgICAgICAgICAgXCLguYTguJfguKJcIjoge3N1YnRhZzogXCJ0aFwiLCBlbmdsaXNoOiBcIlRoYWlcIn0sXG4gICAgICAgICAgICBcIlTDvHJrw6dlXCI6IHtzdWJ0YWc6IFwidHJcIiwgZW5nbGlzaDogXCJUdXJraXNoXCJ9LFxuICAgICAgICAgICAgXCLQo9C60YDQsNGX0L3RgdGM0LrQsFwiOiB7c3VidGFnOiBcInVrXCIsIGVuZ2xpc2g6IFwiVWtyYWluaWFuXCJ9LFxuICAgICAgICAgICAgXCJUaeG6v25nIFZp4buHdFwiOiB7c3VidGFnOiBcInZpXCIsIGVuZ2xpc2g6IFwiVmlldG5hbWVzZVwifSxcbiAgICAgICAgICAgIFwi566A5L2T5Lit5paHXCI6IHtzdWJ0YWc6IFwiemgtaGFuc1wiLCBlbmdsaXNoOiBcIkNoaW5lc2UgKFNpbXBsaWZpZWQpXCJ9LFxuICAgICAgICAgICAgXCLmraPpq5TkuK3mlodcIjoge3N1YnRhZzogXCJ6aC1oYW50XCIsIGVuZ2xpc2g6IFwiQ2hpbmVzZSAoVHJhZGl0aW9uYWwpXCJ9XG4gICAgICAgIH0sXG4gICAgICAgIGNhdGVnb3JpZXM6IFtcbiAgICAgICAgICAgIFwi2KfZhNi52LHYqNmK2KlcIixcbiAgICAgICAgICAgIFwi0JHRitC70LPQsNGA0YHQutC4XCIsXG4gICAgICAgICAgICBcIkNhdGFsw6BcIixcbiAgICAgICAgICAgIFwixIxlc2t5XCIsXG4gICAgICAgICAgICBcIkRhbnNrXCIsXG4gICAgICAgICAgICBcIs6VzrvOu863zr3Ouc66zqxcIixcbiAgICAgICAgICAgIFwiRW5nbGlzaFwiLFxuICAgICAgICAgICAgXCJFc3BlcmFudG9cIixcbiAgICAgICAgICAgIFwiRXNwYcOxb2xcIixcbiAgICAgICAgICAgIFwiU3VvbWlcIixcbiAgICAgICAgICAgIFwi16LXkdeo15nXqlwiLFxuICAgICAgICAgICAgXCJIcnZhdHNraVwiLFxuICAgICAgICAgICAgXCJNYWd5YXJcIixcbiAgICAgICAgICAgIFwiSW5kb25lc2lhXCIsXG4gICAgICAgICAgICBcIkl0YWxpYW5vXCIsXG4gICAgICAgICAgICBcIuaXpeacrOiqnlwiLFxuICAgICAgICAgICAgXCLtlZzqta3slrRcIixcbiAgICAgICAgICAgIFwiTGlldHV2acWha2FpXCIsXG4gICAgICAgICAgICBcIk5vcnNrIEJva23DpWxcIixcbiAgICAgICAgICAgIFwiTmVkZXJsYW5kc1wiLFxuICAgICAgICAgICAgXCJQb2xza2lcIixcbiAgICAgICAgICAgIFwiUG9ydHVndcOqc1wiLFxuICAgICAgICAgICAgXCLQoNGD0YHRgdC60LjQuVwiLFxuICAgICAgICAgICAgXCJTbG92ZW5za8O9XCIsXG4gICAgICAgICAgICBcItCh0YDQv9GB0LrQuFwiLFxuICAgICAgICAgICAgXCLguYTguJfguKJcIixcbiAgICAgICAgICAgIFwiVMO8cmvDp2VcIixcbiAgICAgICAgICAgIFwi0KPQutGA0LDRl9C90YHRjNC60LBcIixcbiAgICAgICAgICAgIFwi566A5L2T5Lit5paHXCIsXG4gICAgICAgICAgICBcIuato+mrlOS4reaWh1wiXG4gICAgICAgIF0sXG4gICAgICAgIGludGVybGFuZ3VhZ2U6IHtcbiAgICAgICAgICAgIGV4dGVybmFsOiBbXCJkZVwiLCBcImZhXCIsIFwiZnJcIiwgXCJqYVwiLCBcInJvXCJdLFxuICAgICAgICAgICAgaW50ZXJuYWw6IFtcImFyXCIsIFwiYmdcIiwgXCJjc1wiLCBcImRhXCIsIFwiZWxcIiwgXCJlblwiLCBcImVzXCIsIFwiZmlcIiwgXCJoZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICBcImhyXCIsIFwiaHVcIiwgXCJpZFwiLCBcIml0XCIsIFwia29cIiwgXCJsdFwiLCBcIm5sXCIsIFwicGxcIiwgXCJwdFwiLFxuICAgICAgICAgICAgICAgICAgICAgICBcInJ1XCIsIFwic2tcIiwgXCJzclwiLCBcInN2XCIsIFwidGhcIiwgXCJ0clwiLCBcInVrXCIsIFwiemgtaGFuc1wiLFxuICAgICAgICAgICAgICAgICAgICAgICBcInpoLWhhbnRcIl0sXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0YWJsZXNPZkNvbnRlbnRzID0ge1xuICAgICAgICBcImFyXCI6IHtcbiAgICAgICAgICAgIFwicGFnZVwiOiBcIlRhYmxlIG9mIGNvbnRlbnRzICjYp9mE2LnYsdio2YrYqSlcIixcbiAgICAgICAgICAgIFwicm9vdFwiOiBcIkNhdGVnb3J5Otin2YTYudix2KjZitipXCIsXG4gICAgICAgICAgICBcImFsc29JblwiOiBcImFsc28gaW5cIiwgICMgVE9ETzogVW50cmFuc2xhdGVkLCBSaWdodC10by1sZWZ0IHByb2JsZW1zXG4gICAgICAgICAgICBcImluZGVudFR5cGVcIjogXCI6XCIsXG4gICAgICAgICAgICBcInJlcGxhY2VcIjogW1wiWyBfXVxcXFwo2KfZhNi52LHYqNmK2KlcXFxcKVwiLCBcIlwiLCBcIlwiXSxcbiAgICAgICAgICAgIFwia2VlcEFsdE5hbWVcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwic2hvd0luZGljZXNcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwicmlnaHRUb0xlZnRcIjogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICBcImJnXCI6IHtcbiAgICAgICAgICAgIFwicGFnZVwiOiBcIlRhYmxlIG9mIGNvbnRlbnRzICjQkdGK0LvQs9Cw0YDRgdC60LgpXCIsXG4gICAgICAgICAgICBcInJvb3RcIjogXCJDYXRlZ29yeTrQkdGK0LvQs9Cw0YDRgdC60LhcIixcbiAgICAgICAgICAgIFwiYWxzb0luXCI6IFwi0YHRitGJ0L4g0LJcIiwgICMgVW5jb25maXJtZWRcbiAgICAgICAgICAgIFwiaW5kZW50VHlwZVwiOiBcIjpcIixcbiAgICAgICAgICAgIFwicmVwbGFjZVwiOiBbXCJbIF9dXFxcXCjQkdGK0LvQs9Cw0YDRgdC60LhcXFxcKVwiLCBcIlwiLCBcIlwiXSxcbiAgICAgICAgICAgIFwia2VlcEFsdE5hbWVcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwic2hvd0luZGljZXNcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwicmlnaHRUb0xlZnRcIjogZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgXCJjc1wiOiB7XG4gICAgICAgICAgICBcInBhZ2VcIjogXCJUYWJsZSBvZiBjb250ZW50cyAoxIxlc2t5KVwiLFxuICAgICAgICAgICAgXCJyb290XCI6IFwiQ2F0ZWdvcnk6xIxlc2t5XCIsXG4gICAgICAgICAgICBcImFsc29JblwiOiBcInRha8OpIHZcIixcbiAgICAgICAgICAgIFwiaW5kZW50VHlwZVwiOiBcIjpcIixcbiAgICAgICAgICAgIFwicmVwbGFjZVwiOiBbXCJbIF9dXFxcXCjEjGVza3lcXFxcKVwiLCBcIlwiLCBcIlwiXSxcbiAgICAgICAgICAgIFwia2VlcEFsdE5hbWVcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwic2hvd0luZGljZXNcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwicmlnaHRUb0xlZnRcIjogZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgXCJkYVwiOiB7XG4gICAgICAgICAgICBcInBhZ2VcIjogXCJUYWJsZSBvZiBjb250ZW50cyAoRGFuc2spXCIsXG4gICAgICAgICAgICBcInJvb3RcIjogXCJDYXRlZ29yeTpEYW5za1wiLFxuICAgICAgICAgICAgXCJhbHNvSW5cIjogXCJvZ3PDpSBpXCIsICAjIFVuY29uZmlybWVkXG4gICAgICAgICAgICBcImluZGVudFR5cGVcIjogXCI6XCIsXG4gICAgICAgICAgICBcInJlcGxhY2VcIjogW1wiWyBfXVxcXFwoRGFuc2tcXFxcKVwiLCBcIlwiLCBcIlwiXSxcbiAgICAgICAgICAgIFwia2VlcEFsdE5hbWVcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwic2hvd0luZGljZXNcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwicmlnaHRUb0xlZnRcIjogZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgXCJlbFwiOiB7XG4gICAgICAgICAgICBcInBhZ2VcIjogXCJUYWJsZSBvZiBjb250ZW50cyAozpXOu867zrfOvc65zrrOrClcIixcbiAgICAgICAgICAgIFwicm9vdFwiOiBcIkNhdGVnb3J5Os6VzrvOu863zr3Ouc66zqxcIixcbiAgICAgICAgICAgIFwiYWxzb0luXCI6IFwizrXPgM6vz4POt8+CIM+DzrVcIiwgICMgVW5jb25maXJtZWRcbiAgICAgICAgICAgIFwiaW5kZW50VHlwZVwiOiBcIjpcIixcbiAgICAgICAgICAgIFwicmVwbGFjZVwiOiBbXCJbIF9dXFxcXCjOlc67zrvOt869zrnOus6sXFxcXClcIiwgXCJcIiwgXCJcIl0sXG4gICAgICAgICAgICBcImtlZXBBbHROYW1lXCI6IHRydWUsXG4gICAgICAgICAgICBcInNob3dJbmRpY2VzXCI6IHRydWUsXG4gICAgICAgICAgICBcInJpZ2h0VG9MZWZ0XCI6IGZhbHNlXG4gICAgICAgIH0sXG4gICAgICAgIFwiZW5cIjoge1xuICAgICAgICAgICAgXCJwYWdlXCI6IFwiVGFibGUgb2YgY29udGVudHNcIixcbiAgICAgICAgICAgIFwicm9vdFwiOiBcIkNhdGVnb3J5OkVuZ2xpc2hcIixcbiAgICAgICAgICAgIFwiYWxzb0luXCI6IFwiYWxzbyBpblwiLFxuICAgICAgICAgICAgXCJpbmRlbnRUeXBlXCI6IFwiOlwiLFxuICAgICAgICAgICAgXCJyZXBsYWNlXCI6IG51bGwsXG4gICAgICAgICAgICBcImtlZXBBbHROYW1lXCI6IGZhbHNlLFxuICAgICAgICAgICAgXCJzaG93SW5kaWNlc1wiOiB0cnVlLFxuICAgICAgICAgICAgXCJyaWdodFRvTGVmdFwiOiBmYWxzZVxuICAgICAgICB9LFxuICAgICAgICBcImVzXCI6IHtcbiAgICAgICAgICAgIFwicGFnZVwiOiBcIlRhYmxlIG9mIGNvbnRlbnRzIChFc3Bhw7FvbClcIixcbiAgICAgICAgICAgIFwicm9vdFwiOiBcIkNhdGVnb3J5OkVzcGHDsW9sXCIsXG4gICAgICAgICAgICBcImFsc29JblwiOiBcInRhbWJpw6luIGVuXCIsXG4gICAgICAgICAgICBcImluZGVudFR5cGVcIjogXCI6XCIsXG4gICAgICAgICAgICBcInJlcGxhY2VcIjogW1wiWyBfXVxcXFwoRXNwYcOxb2xcXFxcKVwiLCBcIlwiLCBcIlwiXSxcbiAgICAgICAgICAgIFwia2VlcEFsdE5hbWVcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwic2hvd0luZGljZXNcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwicmlnaHRUb0xlZnRcIjogZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgXCJoZVwiOiB7XG4gICAgICAgICAgICBcInBhZ2VcIjogXCJUYWJsZSBvZiBjb250ZW50cyAo16LXkdeo15nXqilcIixcbiAgICAgICAgICAgIFwicm9vdFwiOiBcIkNhdGVnb3J5Otei15HXqNeZ16pcIixcbiAgICAgICAgICAgIFwiYWxzb0luXCI6IFwiYWxzbyBpblwiLCAgIyBUT0RPOiBVbnRyYW5zbGF0ZWQsIFJpZ2h0LXRvLWxlZnQgcHJvYmxlbXNcbiAgICAgICAgICAgIFwiaW5kZW50VHlwZVwiOiBcIjpcIixcbiAgICAgICAgICAgIFwicmVwbGFjZVwiOiBbXCJbIF9dXFxcXCjXoteR16jXmdeqXFxcXClcIiwgXCJcIiwgXCJcIl0sXG4gICAgICAgICAgICBcImtlZXBBbHROYW1lXCI6IHRydWUsXG4gICAgICAgICAgICBcInNob3dJbmRpY2VzXCI6IHRydWUsXG4gICAgICAgICAgICBcInJpZ2h0VG9MZWZ0XCI6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgXCJoclwiOiB7XG4gICAgICAgICAgICBcInBhZ2VcIjogXCJUYWJsZSBvZiBjb250ZW50cyAoSHJ2YXRza2kpXCIsXG4gICAgICAgICAgICBcInJvb3RcIjogXCJDYXRlZ29yeTpIcnZhdHNraVwiLFxuICAgICAgICAgICAgXCJhbHNvSW5cIjogXCJ0YWtvxJFlciB1XCIsICAjIFVuY29uZmlybWVkXG4gICAgICAgICAgICBcImluZGVudFR5cGVcIjogXCI6XCIsXG4gICAgICAgICAgICBcInJlcGxhY2VcIjogW1wiWyBfXVxcXFwoSHJ2YXRza2lcXFxcKVwiLCBcIlwiLCBcIlwiXSxcbiAgICAgICAgICAgIFwia2VlcEFsdE5hbWVcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwic2hvd0luZGljZXNcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwicmlnaHRUb0xlZnRcIjogZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgXCJodVwiOiB7XG4gICAgICAgICAgICBcInBhZ2VcIjogXCJUYWJsZSBvZiBjb250ZW50cyAoTWFneWFyKVwiLFxuICAgICAgICAgICAgXCJyb290XCI6IFwiQ2F0ZWdvcnk6TWFneWFyXCIsXG4gICAgICAgICAgICBcImFsc29JblwiOiBcImlzXCIsICAjIFVuY29uZmlybWVkXG4gICAgICAgICAgICBcImluZGVudFR5cGVcIjogXCI6XCIsXG4gICAgICAgICAgICBcInJlcGxhY2VcIjogW1wiWyBfXVxcXFwoTWFneWFyXFxcXClcIiwgXCJcIiwgXCJcIl0sXG4gICAgICAgICAgICBcImtlZXBBbHROYW1lXCI6IHRydWUsXG4gICAgICAgICAgICBcInNob3dJbmRpY2VzXCI6IHRydWUsXG4gICAgICAgICAgICBcInJpZ2h0VG9MZWZ0XCI6IGZhbHNlXG4gICAgICAgIH0sXG4gICAgICAgIFwiaWRcIjoge1xuICAgICAgICAgICAgXCJwYWdlXCI6IFwiVGFibGUgb2YgY29udGVudHMgKEluZG9uZXNpYSlcIixcbiAgICAgICAgICAgIFwicm9vdFwiOiBcIkNhdGVnb3J5OkluZG9uZXNpYVwiLFxuICAgICAgICAgICAgXCJhbHNvSW5cIjogXCJqdWdhIGRpXCIsICAjIFVuY29uZmlybWVkXG4gICAgICAgICAgICBcImluZGVudFR5cGVcIjogXCI6XCIsXG4gICAgICAgICAgICBcInJlcGxhY2VcIjogW1wiWyBfXVxcXFwoSW5kb25lc2lhXFxcXClcIiwgXCJcIiwgXCJcIl0sXG4gICAgICAgICAgICBcImtlZXBBbHROYW1lXCI6IHRydWUsXG4gICAgICAgICAgICBcInNob3dJbmRpY2VzXCI6IHRydWUsXG4gICAgICAgICAgICBcInJpZ2h0VG9MZWZ0XCI6IGZhbHNlXG4gICAgICAgIH0sXG4gICAgICAgIFwiaXRcIjoge1xuICAgICAgICAgICAgXCJwYWdlXCI6IFwiVGFibGUgb2YgY29udGVudHMgKEl0YWxpYW5vKVwiLFxuICAgICAgICAgICAgXCJyb290XCI6IFwiQ2F0ZWdvcnk6SXRhbGlhbm9cIixcbiAgICAgICAgICAgIFwiYWxzb0luXCI6IFwiYW5jaGUgaW5cIixcbiAgICAgICAgICAgIFwiaW5kZW50VHlwZVwiOiBcIjpcIixcbiAgICAgICAgICAgIFwicmVwbGFjZVwiOiBbXCJbIF9dXFxcXChJdGFsaWFub1xcXFwpXCIsIFwiXCIsIFwiXCJdLFxuICAgICAgICAgICAgXCJrZWVwQWx0TmFtZVwiOiB0cnVlLFxuICAgICAgICAgICAgXCJzaG93SW5kaWNlc1wiOiB0cnVlLFxuICAgICAgICAgICAgXCJyaWdodFRvTGVmdFwiOiBmYWxzZVxuICAgICAgICB9LFxuICAgICAgICBcImtvXCI6IHtcbiAgICAgICAgICAgIFwicGFnZVwiOiBcIlRhYmxlIG9mIGNvbnRlbnRzICjtlZzqta3slrQpXCIsXG4gICAgICAgICAgICBcInJvb3RcIjogXCJDYXRlZ29yeTrtlZzqta3slrRcIixcbiAgICAgICAgICAgIFwiYWxzb0luXCI6IFwi65iQ7ZWcIOyXkFwiLCAgIyBVbmNvbmZpcm1lZFxuICAgICAgICAgICAgXCJpbmRlbnRUeXBlXCI6IFwiOlwiLFxuICAgICAgICAgICAgXCJyZXBsYWNlXCI6IFtcIlsgX11cXFxcKO2VnOq1reyWtFxcXFwpXCIsIFwiXCIsIFwiXCJdLFxuICAgICAgICAgICAgXCJrZWVwQWx0TmFtZVwiOiB0cnVlLFxuICAgICAgICAgICAgXCJzaG93SW5kaWNlc1wiOiB0cnVlLFxuICAgICAgICAgICAgXCJyaWdodFRvTGVmdFwiOiBmYWxzZVxuICAgICAgICB9LFxuICAgICAgICBcImx0XCI6IHtcbiAgICAgICAgICAgIFwicGFnZVwiOiBcIlRhYmxlIG9mIGNvbnRlbnRzIChMaWV0dXZpxaFrYWkpXCIsXG4gICAgICAgICAgICBcInJvb3RcIjogXCJDYXRlZ29yeTpMaWV0dXZpxaFrYWlcIixcbiAgICAgICAgICAgIFwiYWxzb0luXCI6IFwidGFpcCBwYXQgaXJcIiwgICMgVW5jb25maXJtZWRcbiAgICAgICAgICAgIFwiaW5kZW50VHlwZVwiOiBcIjpcIixcbiAgICAgICAgICAgIFwicmVwbGFjZVwiOiBbXCJbIF9dXFxcXChMaWV0dXZpxaFrYWlcXFxcKVwiLCBcIlwiLCBcIlwiXSxcbiAgICAgICAgICAgIFwia2VlcEFsdE5hbWVcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwic2hvd0luZGljZXNcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwicmlnaHRUb0xlZnRcIjogZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgXCJubFwiOiB7XG4gICAgICAgICAgICBcInBhZ2VcIjogXCJUYWJsZSBvZiBjb250ZW50cyAoTmVkZXJsYW5kcylcIixcbiAgICAgICAgICAgIFwicm9vdFwiOiBcIkNhdGVnb3J5Ok5lZGVybGFuZHNcIixcbiAgICAgICAgICAgIFwiYWxzb0luXCI6IFwib29rIGluXCIsICAjIFVuY29uZmlybWVkXG4gICAgICAgICAgICBcImluZGVudFR5cGVcIjogXCI6XCIsXG4gICAgICAgICAgICBcInJlcGxhY2VcIjogW1wiWyBfXVxcXFwoTmVkZXJsYW5kc1xcXFwpXCIsIFwiXCIsIFwiXCJdLFxuICAgICAgICAgICAgXCJrZWVwQWx0TmFtZVwiOiB0cnVlLFxuICAgICAgICAgICAgXCJzaG93SW5kaWNlc1wiOiB0cnVlLFxuICAgICAgICAgICAgXCJyaWdodFRvTGVmdFwiOiBmYWxzZVxuICAgICAgICB9LFxuICAgICAgICBcInBsXCI6IHtcbiAgICAgICAgICAgIFwicGFnZVwiOiBcIlRhYmxlIG9mIGNvbnRlbnRzIChQb2xza2kpXCIsXG4gICAgICAgICAgICBcInJvb3RcIjogXCJDYXRlZ29yeTpQb2xza2lcIixcbiAgICAgICAgICAgIFwiYWxzb0luXCI6IFwicsOzd25pZcW8IHdcIiwgICMgVW5jb25maXJtZWRcbiAgICAgICAgICAgIFwiaW5kZW50VHlwZVwiOiBcIjpcIixcbiAgICAgICAgICAgIFwicmVwbGFjZVwiOiBbXCJbIF9dXFxcXChQb2xza2lcXFxcKVwiLCBcIlwiLCBcIlwiXSxcbiAgICAgICAgICAgIFwia2VlcEFsdE5hbWVcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwic2hvd0luZGljZXNcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwicmlnaHRUb0xlZnRcIjogZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgXCJwdFwiOiB7XG4gICAgICAgICAgICBcInBhZ2VcIjogXCJUYWJsZSBvZiBjb250ZW50cyAoUG9ydHVndcOqcylcIixcbiAgICAgICAgICAgIFwicm9vdFwiOiBcIkNhdGVnb3J5OlBvcnR1Z3XDqnNcIixcbiAgICAgICAgICAgIFwiYWxzb0luXCI6IFwidGFtYsOpbSBlbVwiLFxuICAgICAgICAgICAgXCJpbmRlbnRUeXBlXCI6IFwiOlwiLFxuICAgICAgICAgICAgXCJyZXBsYWNlXCI6IFtcIlsgX11cXFxcKFBvcnR1Z3XDqnNcXFxcKVwiLCBcIlwiLCBcIlwiXSxcbiAgICAgICAgICAgIFwia2VlcEFsdE5hbWVcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwic2hvd0luZGljZXNcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwicmlnaHRUb0xlZnRcIjogZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgXCJydVwiOiB7XG4gICAgICAgICAgICBcInBhZ2VcIjogXCJUYWJsZSBvZiBjb250ZW50cyAo0KDRg9GB0YHQutC40LkpXCIsXG4gICAgICAgICAgICBcInJvb3RcIjogXCJDYXRlZ29yeTrQoNGD0YHRgdC60LjQuVwiLFxuICAgICAgICAgICAgXCJhbHNvSW5cIjogXCLQotCw0LrQttC1INCyXCIsXG4gICAgICAgICAgICBcImluZGVudFR5cGVcIjogXCI6XCIsXG4gICAgICAgICAgICBcInJlcGxhY2VcIjogW1wiWyBfXVxcXFwo0KDRg9GB0YHQutC40LlcXFxcKVwiLCBcIlwiLCBcIlwiXSxcbiAgICAgICAgICAgIFwia2VlcEFsdE5hbWVcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwic2hvd0luZGljZXNcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwicmlnaHRUb0xlZnRcIjogZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgXCJza1wiOiB7XG4gICAgICAgICAgICBcInBhZ2VcIjogXCJUYWJsZSBvZiBjb250ZW50cyAoU2xvdmVuc2vDvSlcIixcbiAgICAgICAgICAgIFwicm9vdFwiOiBcIkNhdGVnb3J5OlNsb3ZlbnNrw71cIixcbiAgICAgICAgICAgIFwiYWxzb0luXCI6IFwidGllxb4gdlwiLFxuICAgICAgICAgICAgXCJpbmRlbnRUeXBlXCI6IFwiOlwiLFxuICAgICAgICAgICAgXCJyZXBsYWNlXCI6IFtcIlsgX11cXFxcKFNsb3ZlbnNrw71cXFxcKVwiLCBcIlwiLCBcIlwiXSxcbiAgICAgICAgICAgIFwia2VlcEFsdE5hbWVcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwic2hvd0luZGljZXNcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwicmlnaHRUb0xlZnRcIjogZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgXCJzclwiOiB7XG4gICAgICAgICAgICBcInBhZ2VcIjogXCJUYWJsZSBvZiBjb250ZW50cyAo0KHRgNC/0YHQutC4KVwiLFxuICAgICAgICAgICAgXCJyb290XCI6IFwiQ2F0ZWdvcnk60KHRgNC/0YHQutC4XCIsXG4gICAgICAgICAgICBcImFsc29JblwiOiBcItGC0LDQutC+0ZLQtSDRg1wiLCAgIyBVbmNvbmZpcm1lZFxuICAgICAgICAgICAgXCJpbmRlbnRUeXBlXCI6IFwiOlwiLFxuICAgICAgICAgICAgXCJyZXBsYWNlXCI6IFtcIlsgX11cXFxcKNCh0YDQv9GB0LrQuFxcXFwpXCIsIFwiXCIsIFwiXCJdLFxuICAgICAgICAgICAgXCJrZWVwQWx0TmFtZVwiOiB0cnVlLFxuICAgICAgICAgICAgXCJzaG93SW5kaWNlc1wiOiB0cnVlLFxuICAgICAgICAgICAgXCJyaWdodFRvTGVmdFwiOiBmYWxzZVxuICAgICAgICB9LFxuICAgICAgICBcInRoXCI6IHtcbiAgICAgICAgICAgIFwicGFnZVwiOiBcIlRhYmxlIG9mIGNvbnRlbnRzICjguYTguJfguKIpXCIsXG4gICAgICAgICAgICBcInJvb3RcIjogXCJDYXRlZ29yeTrguYTguJfguKJcIixcbiAgICAgICAgICAgIFwiYWxzb0luXCI6IFwi4Lii4Lix4LiH4Lit4Lii4Li54LmI4LmD4LiZXCIsICAjIFVuY29uZmlybWVkXG4gICAgICAgICAgICBcImluZGVudFR5cGVcIjogXCI6XCIsXG4gICAgICAgICAgICBcInJlcGxhY2VcIjogW1wiWyBfXVxcXFwo4LmE4LiX4LiiXFxcXClcIiwgXCJcIiwgXCJcIl0sXG4gICAgICAgICAgICBcImtlZXBBbHROYW1lXCI6IHRydWUsXG4gICAgICAgICAgICBcInNob3dJbmRpY2VzXCI6IHRydWUsXG4gICAgICAgICAgICBcInJpZ2h0VG9MZWZ0XCI6IGZhbHNlXG4gICAgICAgIH0sXG4gICAgICAgIFwidHJcIjoge1xuICAgICAgICAgICAgXCJwYWdlXCI6IFwiVGFibGUgb2YgY29udGVudHMgKFTDvHJrw6dlKVwiLFxuICAgICAgICAgICAgXCJyb290XCI6IFwiQ2F0ZWdvcnk6VMO8cmvDp2VcIixcbiAgICAgICAgICAgIFwiYWxzb0luXCI6IFwiYXlyxLFjYVwiLCAgIyBVbmNvbmZpcm1lZFxuICAgICAgICAgICAgXCJpbmRlbnRUeXBlXCI6IFwiOlwiLFxuICAgICAgICAgICAgXCJyZXBsYWNlXCI6IFtcIlsgX11cXFxcKFTDvHJrw6dlXFxcXClcIiwgXCJcIiwgXCJcIl0sXG4gICAgICAgICAgICBcImtlZXBBbHROYW1lXCI6IHRydWUsXG4gICAgICAgICAgICBcInNob3dJbmRpY2VzXCI6IHRydWUsXG4gICAgICAgICAgICBcInJpZ2h0VG9MZWZ0XCI6IGZhbHNlXG4gICAgICAgIH0sXG4gICAgICAgIFwidWtcIjoge1xuICAgICAgICAgICAgXCJwYWdlXCI6IFwiVGFibGUgb2YgY29udGVudHMgKNCj0LrRgNCw0ZfQvdGB0YzQutCwKVwiLFxuICAgICAgICAgICAgXCJyb290XCI6IFwiQ2F0ZWdvcnk60KPQutGA0LDRl9C90YHRjNC60LBcIixcbiAgICAgICAgICAgIFwiYWxzb0luXCI6IFwi0YLQsNC60L7QtiDQslwiLCAgIyBVbmNvbmZpcm1lZFxuICAgICAgICAgICAgXCJpbmRlbnRUeXBlXCI6IFwiOlwiLFxuICAgICAgICAgICAgXCJyZXBsYWNlXCI6IFtcIlsgX11cXFxcKNCj0LrRgNCw0ZfQvdGB0YzQutCwXFxcXClcIiwgXCJcIiwgXCJcIl0sXG4gICAgICAgICAgICBcImtlZXBBbHROYW1lXCI6IHRydWUsXG4gICAgICAgICAgICBcInNob3dJbmRpY2VzXCI6IHRydWUsXG4gICAgICAgICAgICBcInJpZ2h0VG9MZWZ0XCI6IGZhbHNlXG4gICAgICAgIH0sXG4gICAgICAgIFwiemgtaGFuc1wiOiB7XG4gICAgICAgICAgICBcInBhZ2VcIjogXCJUYWJsZSBvZiBjb250ZW50cyAo566A5L2T5Lit5paHKVwiLFxuICAgICAgICAgICAgXCJyb290XCI6IFwiQ2F0ZWdvcnk6566A5L2T5Lit5paHXCIsXG4gICAgICAgICAgICBcImFsc29JblwiOiBcIuWQjOaXtui/mOWxnuS6jlwiLFxuICAgICAgICAgICAgXCJpbmRlbnRUeXBlXCI6IFwiOlwiLFxuICAgICAgICAgICAgXCJyZXBsYWNlXCI6IFtcIlsgX11cXFxcKOeugOS9k+S4reaWh1xcXFwpXCIsIFwiXCIsIFwiXCJdLFxuICAgICAgICAgICAgXCJrZWVwQWx0TmFtZVwiOiB0cnVlLFxuICAgICAgICAgICAgXCJzaG93SW5kaWNlc1wiOiB0cnVlLFxuICAgICAgICAgICAgXCJyaWdodFRvTGVmdFwiOiBmYWxzZVxuICAgICAgICB9LFxuICAgICAgICBcInpoLWhhbnRcIjoge1xuICAgICAgICAgICAgXCJwYWdlXCI6IFwiVGFibGUgb2YgY29udGVudHMgKOato+mrlOS4reaWhylcIixcbiAgICAgICAgICAgIFwicm9vdFwiOiBcIkNhdGVnb3J5Ouato+mrlOS4reaWh1wiLFxuICAgICAgICAgICAgXCJhbHNvSW5cIjogXCLpgoTlnKhcIiwgICMgVW5jb25maXJtZWRcbiAgICAgICAgICAgIFwiaW5kZW50VHlwZVwiOiBcIjpcIixcbiAgICAgICAgICAgIFwicmVwbGFjZVwiOiBbXCJbIF9dXFxcXCjmraPpq5TkuK3mlodcXFxcKVwiLCBcIlwiLCBcIlwiXSxcbiAgICAgICAgICAgIFwia2VlcEFsdE5hbWVcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwic2hvd0luZGljZXNcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwicmlnaHRUb0xlZnRcIjogZmFsc2VcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldExvY2FsTGFuZ3VhZ2U6IC0+XG4gICAgICAgIHJldHVybiBsYW5ndWFnZXMubG9jYWxcblxuICAgIGdldENhdGVnb3J5TGFuZ3VhZ2VzOiAtPlxuICAgICAgICByZXR1cm4gbGFuZ3VhZ2VzLmNhdGVnb3JpZXNcblxuICAgIGlzQ2F0ZWdvcnlMYW5ndWFnZTogKGxhbmcpIC0+XG4gICAgICAgIHJldHVybiBsYW5ndWFnZXMuY2F0ZWdvcmllcy5pbmRleE9mKGxhbmcpID4gLTFcblxuICAgIGdldEludGVyd2lraUxhbmd1YWdlczogLT5cbiAgICAgICAgcmV0dXJuIGxhbmd1YWdlcy5pbnRlcmxhbmd1YWdlLmV4dGVybmFsLmNvbmNhdChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFuZ3VhZ2VzLmludGVybGFuZ3VhZ2UuaW50ZXJuYWwpXG5cbiAgICBpc0ludGVyd2lraUxhbmd1YWdlOiAobGFuZykgLT5cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0SW50ZXJ3aWtpTGFuZ3VhZ2VzKCkuaW5kZXhPZihsYW5nKSA+IC0xXG5cbiAgICBnZXRJbnRlcm5hbEludGVyd2lraUxhbmd1YWdlczogLT5cbiAgICAgICAgcmV0dXJuIGxhbmd1YWdlcy5pbnRlcmxhbmd1YWdlLmludGVybmFsXG5cbiAgICBpc0ludGVybmFsSW50ZXJ3aWtpTGFuZ3VhZ2U6IChsYW5nKSAtPlxuICAgICAgICByZXR1cm4gbGFuZ3VhZ2VzLmludGVybGFuZ3VhZ2UuaW50ZXJuYWwuaW5kZXhPZihsYW5nKSA+IC0xXG5cbiAgICBnZXRJbnRlcmxhbmd1YWdlVGFnOiAobGFuZ3VhZ2UpIC0+XG4gICAgICAgIHJldHVybiBsYW5ndWFnZXMubmFtZXNbbGFuZ3VhZ2VdLnN1YnRhZ1xuXG4gICAgZGV0ZWN0TGFuZ3VhZ2U6ICh0aXRsZSkgLT5cbiAgICAgICAgbWF0Y2hlcyA9IHRpdGxlLm1hdGNoKC9eKC4rPykoPzpbIF9dXFwoKFteXFwoXSspXFwpKT8kLylcbiAgICAgICAgcHVyZVRpdGxlID0gbWF0Y2hlc1sxXVxuICAgICAgICBkZXRlY3RlZExhbmd1YWdlID0gbWF0Y2hlc1syXVxuXG4gICAgICAgIGlmIG5vdCBkZXRlY3RlZExhbmd1YWdlIG9yIG5vdCBAaXNDYXRlZ29yeUxhbmd1YWdlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXRlY3RlZExhbmd1YWdlKVxuICAgICAgICAgICAgIyBMYW5ndWFnZSBjYXRlZ29yaWVzIGFyZSBleGNlcHRpb25zXG4gICAgICAgICAgICAjIERvbid0IGp1c3QgdXNlIC9eWyBfXSooLis/KVsgX10qJC8gYnV0IHJlcXVpcmUgdGhlIHdob2xlXG4gICAgICAgICAgICAjICAgbmFtZXNwYWNlK3RpdGxlIHRvIGJlIHBhc3NlZCBhcyB0aGUgYXJndW1lbnQgKGkuZS4gaW5jbHVkaW5nXG4gICAgICAgICAgICAjICAgXCJDYXRlZ29yeTpcIilcbiAgICAgICAgICAgIHRlc3RMYW5nQ2F0ID0gbWF0Y2hlc1sxXS5tYXRjaChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC9eWyBfXSpbQ2NdYXRlZ29yeVsgX10qOlsgX10qKC4rPylbIF9dKiQvKVxuICAgICAgICAgICAgaWYgdGVzdExhbmdDYXQgYW5kIEBpc0NhdGVnb3J5TGFuZ3VhZ2UodGVzdExhbmdDYXRbMV0pXG4gICAgICAgICAgICAgICAgZGV0ZWN0ZWRMYW5ndWFnZSA9IHRlc3RMYW5nQ2F0WzFdXG4gICAgICAgICAgICAgICAgcHVyZVRpdGxlID0gbWF0Y2hlc1sxXVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGRldGVjdGVkTGFuZ3VhZ2UgPSB0aGlzLmdldExvY2FsTGFuZ3VhZ2UoKVxuICAgICAgICAgICAgICAgIHB1cmVUaXRsZSA9IG1hdGNoZXNbMF1cblxuICAgICAgICByZXR1cm4gW3B1cmVUaXRsZSwgZGV0ZWN0ZWRMYW5ndWFnZV1cblxuICAgIGZpbmRBbGxJbnRlcmxhbmd1YWdlTGlua3M6IChzb3VyY2UpIC0+XG4gICAgICAgICMgU2VlIGFsc28gQFdNLlBhcnNlci5maW5kSW50ZXJsYW5ndWFnZUxpbmtzISEhXG4gICAgICAgIHJldHVybiBAV00uUGFyc2VyLmZpbmRTcGVjaWFsTGlua3Moc291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRJbnRlcndpa2lMYW5ndWFnZXMoKS5qb2luKFwifFwiKSlcblxuICAgIGZpbmRJbnRlcm5hbEludGVybGFuZ3VhZ2VMaW5rczogKHNvdXJjZSkgLT5cbiAgICAgICAgIyBTZWUgYWxzbyBAV00uUGFyc2VyLmZpbmRJbnRlcmxhbmd1YWdlTGlua3MhISFcbiAgICAgICAgcmV0dXJuIEBXTS5QYXJzZXIuZmluZFNwZWNpYWxMaW5rcyhzb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRJbnRlcm5hbEludGVyd2lraUxhbmd1YWdlcygpLmpvaW4oXCJ8XCIpKVxuXG4gICAgZ2V0VGFibGVPZkNvbnRlbnRzOiAodGFnKSAtPlxuICAgICAgICByZXR1cm4gdGFibGVzT2ZDb250ZW50c1t0YWddXG4iLCIjIFdpa2kgTW9ua2V5IC0gTWVkaWFXaWtpIGJvdCBhbmQgZWRpdG9yLWFzc2lzdGFudCB1c2VyIHNjcmlwdFxuIyBDb3B5cmlnaHQgKEMpIDIwMTEgRGFyaW8gR2lvdmFubmV0dGkgPGRldkBkYXJpb2dpb3Zhbm5ldHRpLm5ldD5cbiNcbiMgVGhpcyBmaWxlIGlzIHBhcnQgb2YgV2lraSBNb25rZXkuXG4jXG4jIFdpa2kgTW9ua2V5IGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiMgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiMgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiMgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbiNcbiMgV2lraSBNb25rZXkgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiMgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiMgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuIyBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuI1xuIyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuIyBhbG9uZyB3aXRoIFdpa2kgTW9ua2V5LiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuXG5DU1MgPSByZXF1aXJlKCdAa3luaWtvcy9taXNjL2Rpc3QvQ1NTJylcblxuXG5jbGFzcyBtb2R1bGUuZXhwb3J0c1xuICAgIGNvbnN0cnVjdG9yOiAoQFdNKSAtPlxuICAgICAgICBAY29uZmlndXJhdGlvbiA9XG4gICAgICAgICAgICBwbHVnaW5fbmFtZTogbnVsbFxuICAgICAgICAgICAgZnVuY3Rpb25fOiAtPlxuICAgICAgICAgICAgZmlsdGVyczogW11cbiAgICAgICAgICAgIGxpc3Q6XG4gICAgICAgICAgICAgICAgY3VycmVudDogbnVsbFxuICAgICAgICAgICAgICAgIHByZXZpb3VzOiBudWxsXG4gICAgICAgICAgICB2aXNpdGVkOiBbXVxuXG4gICAgICAgICMgbG9jYWxTdG9yYWdlIGNhbiBvbmx5IHN0b3JlIHN0cmluZ3NcbiAgICAgICAgQGJvdFRva2VuID0gXCIwXCJcblxuICAgIF9tYWtlVUk6IChmdW5jdGlvbnMsIGxpc3RzKSAtPlxuICAgICAgICBkaXZDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgICAgICBkaXZDb250YWluZXIuaWQgPSAnV2lraU1vbmtleUJvdCdcblxuICAgICAgICBDU1MuYWRkU3R5bGVFbGVtZW50KFwiI1dpa2lNb25rZXlCb3QtUGx1Z2luU2VsZWN0IHt3aWR0aDoxMDAlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmdpbi1ib3R0b206MWVtO31cbiAgICAgICAgICAgICAgICAgICAgI1dpa2lNb25rZXlCb3QtTGlzdFNlbGVjdCB7bWFyZ2luLWJvdHRvbToxZW07fVxuICAgICAgICAgICAgICAgICAgICAjV2lraU1vbmtleUJvdEZpbHRlciB7aGVpZ2h0OjZlbTsgbWFyZ2luLWJvdHRvbToxZW07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc2l6ZTp2ZXJ0aWNhbDt9XG4gICAgICAgICAgICAgICAgICAgICNXaWtpTW9ua2V5Qm90U3RhcnQsICNXaWtpTW9ua2V5Qm90U3RvcFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7bWFyZ2luLXJpZ2h0OjAuMzNlbTsgbWFyZ2luLWJvdHRvbToxZW07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvbnQtd2VpZ2h0OmJvbGQ7fVxuICAgICAgICAgICAgICAgICAgICBhLldpa2lNb25rZXlCb3RTZWxlY3RlZCB7YmFja2dyb3VuZC1jb2xvcjojZmFhO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZGRpbmc6MC4yZW0gMC40ZW07fVxuICAgICAgICAgICAgICAgICAgICBhLldpa2lNb25rZXlCb3RQcm9jZXNzaW5nIHtiYWNrZ3JvdW5kLWNvbG9yOiNmZjg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFkZGluZzowLjJlbSAwLjRlbTt9XG4gICAgICAgICAgICAgICAgICAgIGEuV2lraU1vbmtleUJvdENoYW5nZWQge2JhY2tncm91bmQtY29sb3I6I2FmYTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWRkaW5nOjAuMmVtIDAuNGVtO31cbiAgICAgICAgICAgICAgICAgICAgYS5XaWtpTW9ua2V5Qm90VW5jaGFuZ2VkIHtiYWNrZ3JvdW5kLWNvbG9yOiNhYWY7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFkZGluZzowLjJlbSAwLjRlbTt9XG4gICAgICAgICAgICAgICAgICAgIGEuV2lraU1vbmtleUJvdEJ5cGFzc2VkIHtiYWNrZ3JvdW5kLWNvbG9yOm9yYW5nZXJlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWRkaW5nOjAuMmVtIDAuNGVtO31cbiAgICAgICAgICAgICAgICAgICAgYS5XaWtpTW9ua2V5Qm90RmFpbGVkIHtiYWNrZ3JvdW5kLWNvbG9yOnJlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWRkaW5nOjAuMmVtIDAuNGVtO31cIilcblxuICAgICAgICBmZGl2ID0gQG1ha2VGdW5jdGlvblVJKGZ1bmN0aW9ucylcblxuICAgICAgICBpZiBmZGl2XG4gICAgICAgICAgICBkaXZDb250YWluZXIuYXBwZW5kQ2hpbGQoZmRpdilcbiAgICAgICAgICAgIGRpdkNvbnRhaW5lci5hcHBlbmRDaGlsZChAbWFrZUNvbmZVSShsaXN0cykpXG4gICAgICAgICAgICByZXR1cm4gZGl2Q29udGFpbmVyXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuXG4gICAgbWFrZUZ1bmN0aW9uVUk6IChmdW5jdGlvbnMpIC0+XG4gICAgICAgIHNlbGYgPSB0aGlzXG4gICAgICAgIGZpZWxkc2V0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZmllbGRzZXQnKVxuXG4gICAgICAgIGxlZ2VuZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xlZ2VuZCcpXG4gICAgICAgIGxlZ2VuZC5pbm5lckhUTUwgPSAnUGx1Z2luJ1xuXG4gICAgICAgIHNlbGVjdEZ1bmN0aW9ucyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NlbGVjdCcpXG4gICAgICAgIHNlbGVjdEZ1bmN0aW9ucy5pZCA9ICdXaWtpTW9ua2V5Qm90LVBsdWdpblNlbGVjdCdcblxuICAgICAgICBmZnVuY3Rpb25zID0gW11cblxuICAgICAgICBmb3IgUGx1Z2luIGluIGZ1bmN0aW9uc1xuICAgICAgICAgICAgcGx1Z2luID0gbmV3IFBsdWdpbihAV00pXG4gICAgICAgICAgICBwbHVnaW5JbnN0ID0gcGx1Z2luLmNvbmYuYm90X2xhYmVsXG5cbiAgICAgICAgICAgICMgVGhpcyBhbGxvd3MgdG8gZGlzYWJsZSBhbiBlbnRyeSBieSBnaXZpbmcgaXQgYW55IHNlY29uZFxuICAgICAgICAgICAgIyBwYXJhbWV0ZXIgdGhhdCBldmFsdWF0ZXMgdG8gZmFsc2VcbiAgICAgICAgICAgIGlmIG5vdCBwbHVnaW5JbnN0IG9yIG5vdCBwbHVnaW5JbnN0Lmxlbmd0aFxuICAgICAgICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgICAgIGZmdW5jdGlvbnMucHVzaChwbHVnaW4pXG4gICAgICAgICAgICBvcHRpb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdvcHRpb24nKVxuICAgICAgICAgICAgb3B0aW9uLmlubmVySFRNTCA9IHBsdWdpbkluc3RcblxuICAgICAgICAgICAgaWYgcGx1Z2luLmNvbnN0cnVjdG9yLm5hbWUgaXMgQFdNLmNvbmYuZGVmYXVsdF9ib3RfcGx1Z2luXG4gICAgICAgICAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gdHJ1ZVxuXG4gICAgICAgICAgICBzZWxlY3RGdW5jdGlvbnMuYXBwZW5kQ2hpbGQob3B0aW9uKVxuXG4gICAgICAgIGlmIGZmdW5jdGlvbnMubGVuZ3RoXG4gICAgICAgICAgICBzZWxlY3RGdW5jdGlvbnMuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCAoIChmZnVuY3Rpb25zKSAtPlxuICAgICAgICAgICAgICAgIHJldHVybiAtPlxuICAgICAgICAgICAgICAgICAgICBzZWxlY3QgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdXaWtpTW9ua2V5Qm90LVBsdWdpblNlbGVjdCcpXG4gICAgICAgICAgICAgICAgICAgIGlkID0gc2VsZWN0LnNlbGVjdGVkSW5kZXhcbiAgICAgICAgICAgICAgICAgICAgVUkgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnV2lraU1vbmtleUJvdEZ1bmN0aW9uJylcbiAgICAgICAgICAgICAgICAgICAgcGx1Z2luID0gZmZ1bmN0aW9uc1tpZF1cbiAgICAgICAgICAgICAgICAgICAgIyBbMV0gTm90ZSB0aGF0IHRoaXMgbXVzdCBhbHNvIGJlIGV4ZWN1dGVkIGltbWVkaWF0ZWx5LFxuICAgICAgICAgICAgICAgICAgICAjICAgc2VlIFsyXVxuICAgICAgICAgICAgICAgICAgICBtYWtlVUkgPSBwbHVnaW4ubWFrZUJvdFVJXG4gICAgICAgICAgICAgICAgICAgIGlmIG1ha2VVSSBpbnN0YW5jZW9mIEZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICBVSS5yZXBsYWNlQ2hpbGQobWFrZVVJKCksIFVJLmZpcnN0Q2hpbGQpXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICMgRG9uJ3QgcmVtb3ZlQ2hpbGQsIG90aGVyd2lzZSBpZiBhbm90aGVyIHBsdWdpbiB3aXRoXG4gICAgICAgICAgICAgICAgICAgICAgICAjIGludGVyZmFjZSBpcyBzZWxlY3RlZCwgcmVwbGFjZUNoaWxkIHdvbid0IHdvcmtcbiAgICAgICAgICAgICAgICAgICAgICAgIFVJLnJlcGxhY2VDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBVSS5maXJzdENoaWxkKVxuICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZ3VyYXRpb24ucGx1Z2luX25hbWUgPSBwbHVnaW4uY29uc3RydWN0b3IubmFtZVxuICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZ3VyYXRpb24uZnVuY3Rpb25fID0gKHRpdGxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxDb250aW51ZSwgY2hhaW5BcmdzKSAtPlxuICAgICAgICAgICAgICAgICAgICAgICAgcGx1Z2luLm1haW5fYm90KHRpdGxlLCBjYWxsQ29udGludWUsIGNoYWluQXJncylcbiAgICAgICAgICAgICkoZmZ1bmN0aW9ucyksIGZhbHNlKVxuXG4gICAgICAgICAgICBkaXZGdW5jdGlvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgICAgICAgICBkaXZGdW5jdGlvbi5pZCA9IFwiV2lraU1vbmtleUJvdEZ1bmN0aW9uXCJcblxuICAgICAgICAgICAgcGx1Z2luID0gZmZ1bmN0aW9uc1tzZWxlY3RGdW5jdGlvbnMuc2VsZWN0ZWRJbmRleF1cblxuICAgICAgICAgICAgIyBbMl0gTm90ZSB0aGF0IHRoaXMgaXMgYWxzbyBleGVjdXRlZCBvbmNoYW5nZSwgc2VlIFsxXVxuICAgICAgICAgICAgbWFrZVVJID0gcGx1Z2luLm1ha2VCb3RVSVxuICAgICAgICAgICAgaWYgbWFrZVVJIGluc3RhbmNlb2YgRnVuY3Rpb25cbiAgICAgICAgICAgICAgICBkaXZGdW5jdGlvbi5hcHBlbmRDaGlsZChtYWtlVUkoKSlcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBkaXZGdW5jdGlvbi5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSlcbiAgICAgICAgICAgIEBjb25maWd1cmF0aW9uLnBsdWdpbl9uYW1lID0gcGx1Z2luLmNvbnN0cnVjdG9yLm5hbWVcbiAgICAgICAgICAgIEBjb25maWd1cmF0aW9uLmZ1bmN0aW9uXyA9ICh0aXRsZSwgY2FsbENvbnRpbnVlLCBjaGFpbkFyZ3MpIC0+XG4gICAgICAgICAgICAgICAgcGx1Z2luLm1haW5fYm90KHRpdGxlLCBjYWxsQ29udGludWUsIGNoYWluQXJncylcblxuICAgICAgICAgICAgZmllbGRzZXQuYXBwZW5kQ2hpbGQobGVnZW5kKVxuICAgICAgICAgICAgZmllbGRzZXQuYXBwZW5kQ2hpbGQoc2VsZWN0RnVuY3Rpb25zKVxuICAgICAgICAgICAgZmllbGRzZXQuYXBwZW5kQ2hpbGQoZGl2RnVuY3Rpb24pXG5cbiAgICAgICAgICAgIHJldHVybiBmaWVsZHNldFxuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcblxuICAgIG1ha2VMaXN0U2VsZWN0b3I6IChsaXN0cykgLT5cbiAgICAgICAgc2VsZiA9IHRoaXNcbiAgICAgICAgc2VsZWN0TGlzdHMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzZWxlY3QnKVxuICAgICAgICBzZWxlY3RMaXN0cy5pZCA9ICdXaWtpTW9ua2V5Qm90LUxpc3RTZWxlY3QnXG5cbiAgICAgICAgZm9yIGxpc3QgaW4gbGlzdHNcbiAgICAgICAgICAgIGlmIGxpc3RbMF1cbiAgICAgICAgICAgICAgICBvcHRpb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdvcHRpb24nKVxuICAgICAgICAgICAgICAgIG9wdGlvbi5pbm5lckhUTUwgPSBsaXN0WzJdXG4gICAgICAgICAgICAgICAgc2VsZWN0TGlzdHMuYXBwZW5kQ2hpbGQob3B0aW9uKVxuXG4gICAgICAgICAgICAgICAgaWYgbm90IEBjb25maWd1cmF0aW9uLmxpc3QuY3VycmVudFxuICAgICAgICAgICAgICAgICAgICAjIFsxXSBOb3RlIHRoYXQgdGhpcyBpcyBhbHNvIGV4ZWN1dGVkIG9uY2hhbmdlLCBzZWUgWzJdXG4gICAgICAgICAgICAgICAgICAgIEBjb25maWd1cmF0aW9uLmxpc3QuY3VycmVudCA9IGxpc3RcblxuICAgICAgICBzZWxlY3RMaXN0cy5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsICggKGxzcykgLT5cbiAgICAgICAgICAgIHJldHVybiAtPlxuICAgICAgICAgICAgICAgIHNlbGVjdCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1dpa2lNb25rZXlCb3QtTGlzdFNlbGVjdCcpXG4gICAgICAgICAgICAgICAgaWQgPSBzZWxlY3Quc2VsZWN0ZWRJbmRleFxuICAgICAgICAgICAgICAgIHNlbGYuY29uZmlndXJhdGlvbi5saXN0LnByZXZpb3VzID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jb25maWd1cmF0aW9uLmxpc3QuY3VycmVudFxuICAgICAgICAgICAgICAgICMgWzJdIE5vdGUgdGhhdCB0aGlzIG11c3QgYWxzbyBiZSBleGVjdXRlZCBpbW1lZGlhdGVseSxcbiAgICAgICAgICAgICAgICAjICAgc2VlIFsxXVxuICAgICAgICAgICAgICAgIHNlbGYuY29uZmlndXJhdGlvbi5saXN0LmN1cnJlbnQgPSBsc3NbaWRdXG4gICAgICAgICkobGlzdHMpLCBmYWxzZSlcblxuICAgICAgICByZXR1cm4gc2VsZWN0TGlzdHNcblxuICAgIG1ha2VDb25mVUk6IChsaXN0cykgLT5cbiAgICAgICAgc2VsZiA9IHRoaXNcbiAgICAgICAgYm90ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcblxuICAgICAgICBmaWVsZHNldCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ZpZWxkc2V0JylcblxuICAgICAgICBsZWdlbmQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsZWdlbmQnKVxuICAgICAgICBsZWdlbmQuaW5uZXJIVE1MID0gJ0ZpbHRlcidcblxuICAgICAgICBsaXN0U2VsZWN0ID0gQG1ha2VMaXN0U2VsZWN0b3IobGlzdHMpXG5cbiAgICAgICAgZmlsdGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGV4dGFyZWEnKVxuICAgICAgICBmaWx0ZXIuaWQgPSAnV2lraU1vbmtleUJvdEZpbHRlcidcblxuICAgICAgICBwcmV2aWV3ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKVxuICAgICAgICBwcmV2aWV3LmlkID0gJ1dpa2lNb25rZXlCb3RQcmV2aWV3J1xuICAgICAgICBwcmV2aWV3LnR5cGUgPSAnYnV0dG9uJ1xuICAgICAgICBwcmV2aWV3LnZhbHVlID0gJ1ByZXZpZXcnXG5cbiAgICAgICAgZHVwbGljYXRlcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0JylcbiAgICAgICAgZHVwbGljYXRlcy50eXBlID0gJ2NoZWNrYm94J1xuICAgICAgICBkdXBsaWNhdGVzLmlkID0gJ1dpa2lNb25rZXlCb3REdXBsaWNhdGVzJ1xuXG4gICAgICAgIGludmVyc2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpXG4gICAgICAgIGludmVyc2UudHlwZSA9ICdjaGVja2JveCdcbiAgICAgICAgaW52ZXJzZS5pZCA9ICdXaWtpTW9ua2V5Qm90SW52ZXJzZSdcblxuICAgICAgICBlbGVtcyA9IFtmaWx0ZXIsIGR1cGxpY2F0ZXMsIGludmVyc2VdXG5cbiAgICAgICAgZm9yIGVsZW0gaW4gZWxlbXNcbiAgICAgICAgICAgIGVsZW0uYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCAtPlxuICAgICAgICAgICAgICAgIHNlbGYuX2Rpc2FibGVTdGFydEJvdChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0ZpbHRlcnMgaGF2ZSBjaGFuZ2VkLCBwcmV2aWV3IHRoZSBzZWxlY3Rpb24nKVxuICAgICAgICAgICAgLCBmYWxzZSlcblxuICAgICAgICBkdXBsaWNhdGVzdGFnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpXG4gICAgICAgIGR1cGxpY2F0ZXN0YWcuaW5uZXJIVE1MID0gJ0R1cGxpY2F0ZXMnXG5cbiAgICAgICAgaW52ZXJzZXRhZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKVxuICAgICAgICBpbnZlcnNldGFnLmlubmVySFRNTCA9ICdJbnZlcnNlJ1xuXG4gICAgICAgIHByZXZpZXcuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIEBfcHJldmlld0ZpbHRlciwgZmFsc2UpXG5cbiAgICAgICAgZmllbGRzZXQuYXBwZW5kQ2hpbGQobGVnZW5kKVxuICAgICAgICBpZiBsaXN0U2VsZWN0Lmxlbmd0aCA+IDFcbiAgICAgICAgICAgIGZpZWxkc2V0LmFwcGVuZENoaWxkKGxpc3RTZWxlY3QpXG4gICAgICAgIGZpZWxkc2V0LmFwcGVuZENoaWxkKGZpbHRlcilcbiAgICAgICAgZmllbGRzZXQuYXBwZW5kQ2hpbGQocHJldmlldylcbiAgICAgICAgZmllbGRzZXQuYXBwZW5kQ2hpbGQoZHVwbGljYXRlcylcbiAgICAgICAgZmllbGRzZXQuYXBwZW5kQ2hpbGQoZHVwbGljYXRlc3RhZylcbiAgICAgICAgZmllbGRzZXQuYXBwZW5kQ2hpbGQoaW52ZXJzZSlcbiAgICAgICAgZmllbGRzZXQuYXBwZW5kQ2hpbGQoaW52ZXJzZXRhZylcblxuICAgICAgICBzdGFydCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0JylcbiAgICAgICAgc3RhcnQudHlwZSA9ICdidXR0b24nXG4gICAgICAgIHN0YXJ0LnZhbHVlID0gJ1N0YXJ0IGJvdCdcbiAgICAgICAgc3RhcnQuaWQgPSAnV2lraU1vbmtleUJvdFN0YXJ0J1xuXG4gICAgICAgIHN0YXJ0LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBAX3N0YXJ0QXV0b21hdGljLCBmYWxzZSlcblxuICAgICAgICBzdGFydC5kaXNhYmxlZCA9IHRydWVcblxuICAgICAgICBzdGFydE1zZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKVxuICAgICAgICBzdGFydE1zZy5pbm5lckhUTUwgPSAnU2V0IGFuZCBwcmV2aWV3IHRoZSBmaWx0ZXIgZmlyc3QnXG4gICAgICAgIHN0YXJ0TXNnLmlkID0gJ1dpa2lNb25rZXlCb3RTdGFydE1zZydcblxuICAgICAgICBmb3JjZVN0YXJ0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpXG4gICAgICAgIGZvcmNlU3RhcnQuaWQgPSAnV2lraU1vbmtleUJvdEZvcmNlU3RhcnQnXG5cbiAgICAgICAgZm9yY2VTdGFydENCID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKVxuICAgICAgICBmb3JjZVN0YXJ0Q0IudHlwZSA9ICdjaGVja2JveCdcbiAgICAgICAgZm9yY2VTdGFydENCLmRpc2FibGVkID0gdHJ1ZVxuXG4gICAgICAgIGZvcmNlU3RhcnRMYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKVxuICAgICAgICBmb3JjZVN0YXJ0TGFiZWwuaW5uZXJIVE1MID0gJ0ZvcmNlIHN0YXJ0LCBzdG9wcGluZyBhbnkgb3RoZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50bHkgcnVubmluZyBib3RzJ1xuXG4gICAgICAgIGZvcmNlU3RhcnQuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiXG4gICAgICAgIGZvcmNlU3RhcnQuYXBwZW5kQ2hpbGQoZm9yY2VTdGFydENCKVxuICAgICAgICBmb3JjZVN0YXJ0LmFwcGVuZENoaWxkKGZvcmNlU3RhcnRMYWJlbClcblxuICAgICAgICBib3QuYXBwZW5kQ2hpbGQoZmllbGRzZXQpXG4gICAgICAgIGJvdC5hcHBlbmRDaGlsZChzdGFydClcbiAgICAgICAgYm90LmFwcGVuZENoaWxkKHN0YXJ0TXNnKVxuICAgICAgICBib3QuYXBwZW5kQ2hpbGQoZm9yY2VTdGFydClcblxuICAgICAgICByZXR1cm4gYm90XG5cbiAgICBfZW5hYmxlU3RhcnRCb3Q6IC0+XG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdXaWtpTW9ua2V5Qm90U3RhcnRNc2cnKS5pbm5lckhUTUwgPSAnJ1xuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnV2lraU1vbmtleUJvdFN0YXJ0JykuZGlzYWJsZWQgPSBmYWxzZVxuXG4gICAgX2Rpc2FibGVTdGFydEJvdDogKG1lc3NhZ2UpIC0+XG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdXaWtpTW9ua2V5Qm90U3RhcnRNc2cnKS5pbm5lckhUTUwgPSBtZXNzYWdlXG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdXaWtpTW9ua2V5Qm90U3RhcnQnKS5kaXNhYmxlZCA9IHRydWVcblxuICAgIF9lbmFibGVTdG9wQm90OiAoc3RvcElkKSAtPlxuICAgICAgICBzZWxmID0gdGhpc1xuICAgICAgICBzdG9wID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKVxuICAgICAgICBzdG9wLnR5cGUgPSAnYnV0dG9uJ1xuICAgICAgICBzdG9wLnZhbHVlID0gJ1N0b3AgYm90J1xuICAgICAgICBzdG9wLmlkID0gJ1dpa2lNb25rZXlCb3RTdG9wJ1xuXG4gICAgICAgIHN0b3AuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsICggKGlkKSAtPlxuICAgICAgICAgICAgcmV0dXJuIC0+XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGlkKVxuICAgICAgICAgICAgICAgICMgcnVuIF9kaXNhYmxlU3RvcEJvdCgpIGhlcmUsIG5vdCBpbiBfZW5kQXV0b21hdGljKClcbiAgICAgICAgICAgICAgICBzZWxmLl9kaXNhYmxlU3RvcEJvdCgpXG4gICAgICAgICAgICAgICAgc2VsZi5fZW5kQXV0b21hdGljKHRydWUpXG4gICAgICAgICAgICAgICAgc2VsZi5XTS5Mb2cubG9nSW5mbygnQm90IHN0b3BwZWQgbWFudWFsbHknKVxuICAgICAgICApKHN0b3BJZCksIGZhbHNlKVxuXG4gICAgICAgIHN0YXJ0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ1dpa2lNb25rZXlCb3RTdGFydCcpXG4gICAgICAgIHN0YXJ0LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHN0b3AsIHN0YXJ0KVxuICAgICAgICBzdGFydC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnXG5cbiAgICBfZGlzYWJsZVN0b3BCb3Q6IC0+XG4gICAgICAgIHN0b3AgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnV2lraU1vbmtleUJvdFN0b3AnKVxuICAgICAgICBzdG9wLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3RvcClcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ1dpa2lNb25rZXlCb3RTdGFydCcpLnN0eWxlLmRpc3BsYXkgPSAnaW5saW5lJ1xuXG4gICAgX2Rpc2FibGVDb250cm9sczogLT5cbiAgICAgICAgQF9zZXRFbmFibGVDb250cm9scyh0cnVlKVxuXG4gICAgX3JlRW5hYmxlQ29udHJvbHM6IC0+XG4gICAgICAgIEBfc2V0RW5hYmxlQ29udHJvbHMoZmFsc2UpXG5cbiAgICBfc2V0RW5hYmxlQ29udHJvbHM6IChmbGFnKSAtPlxuICAgICAgICBmc2V0cyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdXaWtpTW9ua2V5Qm90JylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdmaWVsZHNldCcpXG4gICAgICAgIGZvciBmc2V0IGluIGZzZXRzXG4gICAgICAgICAgICAjIEhUTUw1LWNvbXBsaWFudFxuICAgICAgICAgICAgZnNldC5kaXNhYmxlZCA9IGZsYWdcblxuICAgIF9lbmFibGVGb3JjZVN0YXJ0OiAtPlxuICAgICAgICBmb3JjZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdXaWtpTW9ua2V5Qm90Rm9yY2VTdGFydCcpXG4gICAgICAgIGZvcmNlLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdpbnB1dCcpWzBdLmRpc2FibGVkID0gZmFsc2VcbiAgICAgICAgZm9yY2Uuc3R5bGUuZGlzcGxheSA9ICdpbmxpbmUnXG5cbiAgICBfZGlzYWJsZUZvcmNlU3RhcnQ6IC0+XG4gICAgICAgIGZvcmNlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ1dpa2lNb25rZXlCb3RGb3JjZVN0YXJ0JylcbiAgICAgICAgZm9yY2UuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2lucHV0JylbMF0uY2hlY2tlZCA9IGZhbHNlXG4gICAgICAgIGZvcmNlLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdpbnB1dCcpWzBdLmRpc2FibGVkID0gdHJ1ZVxuICAgICAgICBmb3JjZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnXG5cbiAgICBfY2FuRm9yY2VTdGFydDogLT5cbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdXaWtpTW9ua2V5Qm90Rm9yY2VTdGFydCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2lucHV0JylbMF0uY2hlY2tlZFxuXG4gICAgbWFrZUZpbHRlcnM6IC0+XG4gICAgICAgIEBjb25maWd1cmF0aW9uLmZpbHRlcnMgPSBbXVxuICAgICAgICBmaWx0ZXJzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ1dpa2lNb25rZXlCb3RGaWx0ZXInKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAudmFsdWUuc3BsaXQoJ1xcbicpXG5cbiAgICAgICAgZm9yIGZpbHRlciBpbiBmaWx0ZXJzXG4gICAgICAgICAgICAjIGZpbHRlciBjb3VsZCBiZSBhbiBlbXB0eSBzdHJpbmdcbiAgICAgICAgICAgIGlmIGZpbHRlclxuICAgICAgICAgICAgICAgIGZpcnN0U2xhc2ggPSBmaWx0ZXIuaW5kZXhPZignLycpXG4gICAgICAgICAgICAgICAgbGFzdFNsYXNoID0gZmlsdGVyLmxhc3RJbmRleE9mKCcvJylcbiAgICAgICAgICAgICAgICBwYXR0ZXJuID0gZmlsdGVyLnN1YnN0cmluZyhmaXJzdFNsYXNoICsgMSwgbGFzdFNsYXNoKVxuICAgICAgICAgICAgICAgIG1vZGlmaWVycyA9IGZpbHRlci5zdWJzdHJpbmcobGFzdFNsYXNoICsgMSlcbiAgICAgICAgICAgICAgICBuZWdhdGl2ZSA9IGZpbHRlci5jaGFyQXQoMCkgPT0gJyEnXG5cbiAgICAgICAgICAgICAgICB0cnlcbiAgICAgICAgICAgICAgICAgICAgcmVnZXhwID0gbmV3IFJlZ0V4cChwYXR0ZXJuLCBtb2RpZmllcnMpXG4gICAgICAgICAgICAgICAgY2F0Y2ggZXhjXG4gICAgICAgICAgICAgICAgICAgIEBXTS5Mb2cubG9nRXJyb3IoJ0ludmFsaWQgcmVnZXhwOiAnICsgZXhjKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcblxuICAgICAgICAgICAgICAgIEBjb25maWd1cmF0aW9uLmZpbHRlcnMucHVzaChbcmVnZXhwLCBuZWdhdGl2ZV0pXG4gICAgICAgICAgICAgICAgIyBEbyBub3QgcmV0dXJuIG5vciBicmVhaywgc28gdGhhdCBpZiBhbW9uZyB0aGUgZmlsdGVyc1xuICAgICAgICAgICAgICAgICMgICB0aGVyZSdzIGFuIGludmFsaWQgcmVnZXhwIHRoZSBmdW5jdGlvbiByZXR1cm5zIGZhbHNlXG5cbiAgICAgICAgcmV0dXJuIHRydWVcblxuICAgIGNhblByb2Nlc3NQYWdlOiAobGluaykgLT5cbiAgICAgICAgIyBFeGNsdWRlIHJlZCBsaW5rcyAodGhleSBjYW4gYmUgZm91bmQgaW4gc29tZSBzcGVjaWFsIHBhZ2VzKVxuICAgICAgICBpZiBsaW5rLmNsYXNzTmFtZS5zcGxpdChcIiBcIikuaW5kZXhPZihcIm5ld1wiKSA8IDBcbiAgICAgICAgICAgICMgRG9uJ3QgdXNlIGxpbmsudGl0bGUgYmVjYXVzZSBmb3IgZXhhbXBsZSBpbiBDYXRlZ29yeSBwYWdlcyBhbGxcbiAgICAgICAgICAgICMgICBzdWJwYWdlcyB3b3VsZCBpbmNsdWRlIFwiQ2F0ZWdvcnk6XCIsIHRodXMgYWx3YXlzIG1hdGNoaW5nXG4gICAgICAgICAgICAjICAgZmlsdGVycyBsaWtlIFwiL2EvXCIsIFwiL3QvXCIgZXRjLlxuICAgICAgICAgICAgdGl0bGUgPSBsaW5rLmlubmVySFRNTFxuICAgICAgICAgICAgZHVwbGljYXRlcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdXaWtpTW9ua2V5Qm90RHVwbGljYXRlcycpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jaGVja2VkXG5cbiAgICAgICAgICAgIGlmIGR1cGxpY2F0ZXMgb3IgQGNvbmZpZ3VyYXRpb24udmlzaXRlZC5pbmRleE9mKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlKSA8IDBcbiAgICAgICAgICAgICAgICBAY29uZmlndXJhdGlvbi52aXNpdGVkLnB1c2godGl0bGUpXG4gICAgICAgICAgICAgICAgZmlsdGVycyA9IEBjb25maWd1cmF0aW9uLmZpbHRlcnNcbiAgICAgICAgICAgICAgICBpbnZlcnNlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ1dpa2lNb25rZXlCb3RJbnZlcnNlJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNoZWNrZWRcblxuICAgICAgICAgICAgICAgIGlmIGZpbHRlcnMubGVuZ3RoID4gMFxuICAgICAgICAgICAgICAgICAgICBmb3IgZmlsdGVyIGluIGZpbHRlcnNcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2V4cCA9IGZpbHRlclswXVxuICAgICAgICAgICAgICAgICAgICAgICAgbmVnYXRpdmUgPSBmaWx0ZXJbMV1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRlc3QgPSByZWdleHAudGVzdCh0aXRsZSlcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgdGVzdCAhPSBuZWdhdGl2ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpZiBpbnZlcnNlIHRoZW4gZmFsc2UgZWxzZSB0cnVlXG5cbiAgICAgICAgICAgICAgICAgICAgIyBObyAodGVzdCAhPSBuZWdhdGl2ZSkgY29uZGl0aW9uIGhhcyBiZWVuIG1ldCBpbiB0aGUgbG9vcFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWYgaW52ZXJzZSB0aGVuIHRydWUgZWxzZSBmYWxzZVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlmIGludmVyc2UgdGhlbiBmYWxzZSBlbHNlIHRydWVcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG5cbiAgICBjaGFuZ2VXaWtpTW9ua2V5TGlua0NsYXNzTmFtZTogKGNsYXNzTmFtZSwgbmV3Q2xhc3MpIC0+XG4gICAgICAgIGNsYXNzZXMgPSBjbGFzc05hbWUuc3BsaXQoXCIgXCIpXG4gICAgICAgIG5ld0NsYXNzZXMgPSBbXVxuXG4gICAgICAgIGZvciBjbHMgaW4gY2xhc3Nlc1xuICAgICAgICAgICAgaWYgY2xzLmluZGV4T2YoXCJXaWtpTW9ua2V5XCIpIDwgMFxuICAgICAgICAgICAgICAgIG5ld0NsYXNzZXMucHVzaChjbHMpXG5cbiAgICAgICAgIyBEb24ndCBwdXNoIGluIGFuIGVsc2UgYmxvY2sgaW5zaWRlIHRoZSBsb29wLCBzbyB0aGF0IGlmIHRoZXJlIHdhc1xuICAgICAgICAjIG5vIFdpa2lNb25rZXkgY2xhc3Mgc2V0LCBpdCB3aWxsIGJlIGFkZGVkXG4gICAgICAgIG5ld0NsYXNzZXMucHVzaChuZXdDbGFzcylcblxuICAgICAgICByZXR1cm4gbmV3Q2xhc3Nlcy5qb2luKFwiIFwiKVxuXG4gICAgcmVzdG9yZU9yaWdpbmFsTGlua0NsYXNzTmFtZTogKGNsYXNzTmFtZSkgLT5cbiAgICAgICAgY2xhc3NlcyA9IGNsYXNzTmFtZS5zcGxpdChcIiBcIilcbiAgICAgICAgb3JpZ0NsYXNzZXMgPSBbXVxuXG4gICAgICAgIGZvciBjbHMgaW4gY2xhc3Nlc1xuICAgICAgICAgICAgaWYgY2xzLmluZGV4T2YoXCJXaWtpTW9ua2V5XCIpIDwgMFxuICAgICAgICAgICAgICAgIG9yaWdDbGFzc2VzLnB1c2goY2xzKVxuXG4gICAgICAgIHJldHVybiBvcmlnQ2xhc3Nlcy5qb2luKFwiIFwiKVxuXG4gICAgX3ByZXZpZXdGaWx0ZXI6ID0+XG4gICAgICAgIEBXTS5Mb2cubG9nSW5mbygnVXBkYXRpbmcgZmlsdGVyIHByZXZpZXcsIHBsZWFzZSB3YWl0IC4uLicpXG4gICAgICAgIEBfZGlzYWJsZVN0YXJ0Qm90KCdVcGRhdGluZyBmaWx0ZXIgcHJldmlldyAuLi4nKVxuXG4gICAgICAgIGlmIEBjb25maWd1cmF0aW9uLmxpc3QucHJldmlvdXNcbiAgICAgICAgICAgIGlmIEBjb25maWd1cmF0aW9uLmxpc3QuY3VycmVudFswXS5ub2RlTmFtZSA9PSAnVEJPRFknXG4gICAgICAgICAgICAgICAgaXRlbXMgPSBAY29uZmlndXJhdGlvbi5saXN0LnByZXZpb3VzWzBdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3RkJylcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBpdGVtcyA9IEBjb25maWd1cmF0aW9uLmxpc3QucHJldmlvdXNbMF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnbGknKVxuICAgICAgICAgICAgbGlua0lkID0gQGNvbmZpZ3VyYXRpb24ubGlzdC5wcmV2aW91c1sxXVxuXG4gICAgICAgICAgICBmb3IgaXRlbSBpbiBpdGVtc1xuICAgICAgICAgICAgICAgIGxpbmsgPSBpdGVtLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdhJylbbGlua0lkXVxuXG4gICAgICAgICAgICAgICAgIyBUaGUgbGlzdCBpdGVtIGNvdWxkIHJlZmVyIHRvIGFuIGludmFsaWQgdGl0bGUsIHJlcHJlc2VudGVkXG4gICAgICAgICAgICAgICAgIyBieSBlLmcuIDxzcGFuIGNsYXNzPVwibXctaW52YWxpZHRpdGxlXCI+SW52YWxpZCB0aXRsZSB3aXRoXG4gICAgICAgICAgICAgICAgIyBuYW1lc3BhY2UgXCJDYXRlZ29yeVwiIGFuZCB0ZXh0IFwiXCI8L3NwYW4+XG4gICAgICAgICAgICAgICAgaWYgbGlua1xuICAgICAgICAgICAgICAgICAgICBsaW5rLmNsYXNzTmFtZSA9IEByZXN0b3JlT3JpZ2luYWxMaW5rQ2xhc3NOYW1lKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluay5jbGFzc05hbWUpXG5cbiAgICAgICAgQGNvbmZpZ3VyYXRpb24udmlzaXRlZCA9IFtdXG5cbiAgICAgICAgbGlua0lkID0gQGNvbmZpZ3VyYXRpb24ubGlzdC5jdXJyZW50WzFdXG4gICAgICAgIGVuYWJsZSA9IGZhbHNlXG4gICAgICAgIE4gPSAwXG5cbiAgICAgICAgaWYgQG1ha2VGaWx0ZXJzKClcbiAgICAgICAgICAgIGlmIEBjb25maWd1cmF0aW9uLmxpc3QuY3VycmVudFswXS5ub2RlTmFtZSA9PSAnVEJPRFknXG4gICAgICAgICAgICAgICAgaXRlbXMgPVxuICAgICAgICAgICAgICAgICAgICBAY29uZmlndXJhdGlvbi5saXN0LmN1cnJlbnRbMF0uZ2V0RWxlbWVudHNCeVRhZ05hbWUoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAndGQnKVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGl0ZW1zID1cbiAgICAgICAgICAgICAgICAgICAgQGNvbmZpZ3VyYXRpb24ubGlzdC5jdXJyZW50WzBdLmdldEVsZW1lbnRzQnlUYWdOYW1lKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2xpJylcblxuICAgICAgICAgICAgZm9yIGl0ZW0gaW4gaXRlbXNcbiAgICAgICAgICAgICAgICBsaW5rID0gaXRlbS5nZXRFbGVtZW50c0J5VGFnTmFtZSgnYScpW2xpbmtJZF1cblxuICAgICAgICAgICAgICAgICMgQWxzbyB0ZXN0ICdsaW5rJyBpdHNlbGYsIGJlY2F1c2UgdGhlIGxpc3QgaXRlbSBjb3VsZCByZWZlclxuICAgICAgICAgICAgICAgICMgdG8gYW4gaW52YWxpZCB0aXRsZSwgcmVwcmVzZW50ZWQgYnkgZS5nLlxuICAgICAgICAgICAgICAgICMgPHNwYW4gY2xhc3M9XCJtdy1pbnZhbGlkdGl0bGVcIj5JbnZhbGlkIHRpdGxlIHdpdGggbmFtZXNwYWNlXG4gICAgICAgICAgICAgICAgIyBcIkNhdGVnb3J5XCIgYW5kIHRleHQgXCJcIjwvc3Bhbj5cbiAgICAgICAgICAgICAgICBpZiBsaW5rXG4gICAgICAgICAgICAgICAgICAgIGlmIEBjYW5Qcm9jZXNzUGFnZShsaW5rKVxuICAgICAgICAgICAgICAgICAgICAgICAgbGluay5jbGFzc05hbWUgPSBAY2hhbmdlV2lraU1vbmtleUxpbmtDbGFzc05hbWUoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rLmNsYXNzTmFtZSwgJ1dpa2lNb25rZXlCb3RTZWxlY3RlZCcpXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmFibGUgPSB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICBOKytcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgbGluay5jbGFzc05hbWUgPSBAcmVzdG9yZU9yaWdpbmFsTGlua0NsYXNzTmFtZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmsuY2xhc3NOYW1lKVxuXG4gICAgICAgIEBXTS5Mb2cubG9nSW5mbygnUHJldmlldyB1cGRhdGVkICgnICsgTiArICcgcGFnZXMgc2VsZWN0ZWQpJylcblxuICAgICAgICBpZiBlbmFibGVcbiAgICAgICAgICAgIEBfZW5hYmxlU3RhcnRCb3QoKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICBAX2Rpc2FibGVTdGFydEJvdChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnTm8gcGFnZXMgc2VsZWN0ZWQsIHJlc2V0IGFuZCBwcmV2aWV3IHRoZSBmaWx0ZXInKVxuXG4gICAgX3NldEJvdFRva2VuOiAtPlxuICAgICAgICBkYXRlID0gbmV3IERhdGUoKVxuICAgICAgICB0b2tlbiA9IGRhdGUuZ2V0VGltZSgpICsgXCJcIlxuICAgICAgICBAYm90VG9rZW4gPSB0b2tlblxuICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnV2lraU1vbmtleUJvdFRva2VuJywgdG9rZW4pXG5cbiAgICBfcmVzZXRCb3RUb2tlbjogKHJlc2V0KSAtPlxuICAgICAgICBAYm90VG9rZW4gPSBcIjBcIlxuICAgICAgICBpZiByZXNldFxuICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ1dpa2lNb25rZXlCb3RUb2tlbicsIFwiMFwiKVxuXG4gICAgX2dldEJvdFRva2VuOiAtPlxuICAgICAgICByZXR1cm4gQGJvdFRva2VuXG5cbiAgICBfY2hlY2tPdGhlckJvdHNSdW5uaW5nOiAtPlxuICAgICAgICB2YWx1ZSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdXaWtpTW9ua2V5Qm90VG9rZW4nKVxuXG4gICAgICAgICMgdmFsdWUgbWF5IGJlIG51bGwgaWYgaXQncyBuZXZlciBiZWVuIHN0b3JlZCBpbiBsb2NhbFN0b3JhZ2VcbiAgICAgICAgcmV0dXJuIHZhbHVlIGFuZCB2YWx1ZSAhPSBcIjBcIiBhbmQgdmFsdWUgIT0gQF9nZXRCb3RUb2tlbigpXG5cbiAgICBfc3RhcnRBdXRvbWF0aWM6ID0+XG4gICAgICAgIGlmIEBfY2hlY2tPdGhlckJvdHNSdW5uaW5nKCkgYW5kIG5vdCBAX2NhbkZvcmNlU3RhcnQoKVxuICAgICAgICAgICAgQFdNLkxvZy5sb2dFcnJvcihcIkl0J3Mgbm90IHBvc3NpYmxlIHRvIHN0YXJ0IHRoZSBib3QgKHdpdGhvdXRcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcmNpbmcgaXQpIGZvciBvbmUgb2YgdGhlIGZvbGxvd2luZyByZWFzb25zOjxicj5cbiAgICAgICAgICAgICAgICAgICAgICAgICogYW5vdGhlciBib3QgaW5zdGFuY2UgaXMgY3VycmVudGx5IHJ1bm5pbmc8YnI+XG4gICAgICAgICAgICAgICAgICAgICAgICAqIGEgcHJldmlvdXNseSBydW5uaW5nIGJvdCBoYXMgc3RvcHBlZCBkdWUgdG8gYVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFnZSBwcm9jZXNzaW5nIGVycm9yPGJyPlxuICAgICAgICAgICAgICAgICAgICAgICAgKiBhIHByZXZpb3VzbHkgcnVubmluZyBib3QgaGFzIHN0b3BwZWQgZHVlIHRvIGFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBKYXZhc2NyaXB0IGVycm9yPGJyPlxuICAgICAgICAgICAgICAgICAgICAgICAgKiBhIHByZXZpb3VzbHkgcnVubmluZyBib3QgaGFzIGJlZW4gaW50ZXJydXB0ZWQgYnlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhIGJyb3dzZXIgcGFnZSByZWZyZXNoXCIpXG4gICAgICAgICAgICBAX2VuYWJsZUZvcmNlU3RhcnQoKVxuICAgICAgICBlbHNlIGlmIEBtYWtlRmlsdGVycygpXG4gICAgICAgICAgICBpZiBAY29uZmlndXJhdGlvbi5saXN0LmN1cnJlbnRbMF0ubm9kZU5hbWUgPT0gJ1RCT0RZJ1xuICAgICAgICAgICAgICAgIGl0ZW1zRE9NID0gQGNvbmZpZ3VyYXRpb24ubGlzdC5jdXJyZW50WzBdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3RkJylcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBpdGVtc0RPTSA9IEBjb25maWd1cmF0aW9uLmxpc3QuY3VycmVudFswXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdsaScpXG5cbiAgICAgICAgICAgICMgUGFzc2luZyB0aGUgbGl2ZSBjb2xsZWN0aW9uIHdpdGggdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHdhc1xuICAgICAgICAgICAgIyAgIGNhdXNpbmcgaXQgdG8gYmUgbG9zdCBpbiBhbiBhcHBhcmVudGx5IHJhbmRvbSBtYW5uZXJcbiAgICAgICAgICAgIGl0ZW1zID0gW11cblxuICAgICAgICAgICAgZm9yIGl0ZW0gaW4gaXRlbXNET01cbiAgICAgICAgICAgICAgICBpdGVtcy5wdXNoKGl0ZW0pXG5cbiAgICAgICAgICAgIGxpbmtJZCA9IEBjb25maWd1cmF0aW9uLmxpc3QuY3VycmVudFsxXVxuXG4gICAgICAgICAgICBAX2Rpc2FibGVGb3JjZVN0YXJ0KClcbiAgICAgICAgICAgIEBfc2V0Qm90VG9rZW4oKVxuICAgICAgICAgICAgQFdNLkxvZy5sb2dJbmZvKCdTdGFydGluZyBib3QgLi4uJylcbiAgICAgICAgICAgIEBXTS5Mb2cubG9nSGlkZGVuKFwiUGx1Z2luOiBcIiArIEBjb25maWd1cmF0aW9uLnBsdWdpbl9uYW1lKVxuICAgICAgICAgICAgQFdNLkxvZy5sb2dIaWRkZW4oXCJGaWx0ZXI6IFwiICsgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnV2lraU1vbmtleUJvdEZpbHRlcicpLnZhbHVlKVxuICAgICAgICAgICAgQF9kaXNhYmxlU3RhcnRCb3QoJ0JvdCBpcyBydW5uaW5nIC4uLicpXG4gICAgICAgICAgICBAX2Rpc2FibGVDb250cm9scygpXG4gICAgICAgICAgICBAY29uZmlndXJhdGlvbi52aXNpdGVkID0gW11cblxuICAgICAgICAgICAgQFdNLk1XLmlzVXNlckJvdChAX3N0YXJ0QXV0b21hdGljQ29udGludWUsIFtpdGVtcywgbGlua0lkXSlcblxuICAgIF9zdGFydEF1dG9tYXRpY0NvbnRpbnVlOiAoYm90VGVzdCwgYXJncykgPT5cbiAgICAgICAgaXRlbXMgPSBhcmdzWzBdXG4gICAgICAgIGxpbmtJZCA9IGFyZ3NbMV1cblxuICAgICAgICBAY29uZmlndXJhdGlvbi5pbnRlcnZhbCA9IGlmIGJvdFRlc3QgdGhlbiAzMDAwIGVsc2UgMzAwMDBcbiAgICAgICAgQF9wcm9jZXNzSXRlbSgwLCBpdGVtcywgMCwgbGlua0lkLCBudWxsKVxuXG4gICAgbWFrZUNhbGxDb250aW51ZTogKGxpcywgaWQsIGxpbmtJZCwgbG4sIGFydGljbGUpIC0+XG4gICAgICAgIHNlbGYgPSB0aGlzXG4gICAgICAgIHJldHVybiAoc3RhdHVzLCByZXNBcmdzKSAtPlxuICAgICAgICAgICAgc3dpdGNoIHN0YXR1c1xuICAgICAgICAgICAgICAgICMgVGhlIGFydGljbGUgaGFzbid0IGJlZW4gc2F2ZWRcbiAgICAgICAgICAgICAgICB3aGVuIDBcbiAgICAgICAgICAgICAgICAgICAgbG4uY2xhc3NOYW1lID0gc2VsZi5jaGFuZ2VXaWtpTW9ua2V5TGlua0NsYXNzTmFtZShsbi5jbGFzc05hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1dpa2lNb25rZXlCb3RVbmNoYW5nZWQnKVxuICAgICAgICAgICAgICAgICAgICBzZWxmLldNLkxvZy5sb2dJbmZvKHNlbGYuV00uTG9nLmxpbmtUb1dpa2lQYWdlKGFydGljbGUsIGFydGljbGUpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIiBwcm9jZXNzZWQgKHVuY2hhbmdlZClcIilcbiAgICAgICAgICAgICAgICAgICAgaWQrK1xuICAgICAgICAgICAgICAgICAgICBzZWxmLl9wcm9jZXNzSXRlbShzdGF0dXMsIGxpcywgaWQsIGxpbmtJZCwgcmVzQXJncylcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAjIFRoZSBhcnRpY2xlIGhhcyBiZWVuIHNhdmVkXG4gICAgICAgICAgICAgICAgd2hlbiAxXG4gICAgICAgICAgICAgICAgICAgIGxuLmNsYXNzTmFtZSA9IHNlbGYuY2hhbmdlV2lraU1vbmtleUxpbmtDbGFzc05hbWUobG4uY2xhc3NOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdXaWtpTW9ua2V5Qm90Q2hhbmdlZCcpXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuV00uTG9nLmxvZ0luZm8oc2VsZi5XTS5Mb2cubGlua1RvV2lraVBhZ2UoYXJ0aWNsZSwgYXJ0aWNsZSkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiIHByb2Nlc3NlZCAoY2hhbmdlZClcIilcbiAgICAgICAgICAgICAgICAgICAgaWQrK1xuICAgICAgICAgICAgICAgICAgICBzZWxmLl9wcm9jZXNzSXRlbShzdGF0dXMsIGxpcywgaWQsIGxpbmtJZCwgcmVzQXJncylcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAjIFRoZSBwbHVnaW4gaGFzIGVuY291bnRlcmVkIGEgcHJvdGVjdGVkcGFnZSBlcnJvclxuICAgICAgICAgICAgICAgIHdoZW4gJ3Byb3RlY3RlZHBhZ2UnXG4gICAgICAgICAgICAgICAgICAgIGxuLmNsYXNzTmFtZSA9IHNlbGYuY2hhbmdlV2lraU1vbmtleUxpbmtDbGFzc05hbWUobG4uY2xhc3NOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdXaWtpTW9ua2V5Qm90QnlwYXNzZWQnKVxuICAgICAgICAgICAgICAgICAgICBzZWxmLldNLkxvZy5sb2dXYXJuaW5nKFwiVGhpcyB1c2VyIGRvZXNuJ3QgaGF2ZSB0aGUgcmlnaHRzIHRvIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZWRpdCBcIiArIHNlbGYuV00uTG9nLmxpbmtUb1dpa2lQYWdlKGFydGljbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnRpY2xlKSArIFwiLCBieXBhc3NpbmcgaXQgLi4uXCIpXG4gICAgICAgICAgICAgICAgICAgIGlkKytcbiAgICAgICAgICAgICAgICAgICAgIyBDaGFuZ2Ugc3RhdHVzIHRvIDAgKHBhZ2Ugbm90IGNoYW5nZWQpXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX3Byb2Nlc3NJdGVtKDAsIGxpcywgaWQsIGxpbmtJZCwgcmVzQXJncylcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAjIFRoZSBwbHVnaW4gaGFzIGVuY291bnRlcmVkIGEgY3JpdGljYWwgZXJyb3JcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGxuLmNsYXNzTmFtZSA9IHNlbGYuY2hhbmdlV2lraU1vbmtleUxpbmtDbGFzc05hbWUobG4uY2xhc3NOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnV2lraU1vbmtleUJvdEZhaWxlZCcpXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuV00uTG9nLmxvZ0Vycm9yKFwiRXJyb3IgcHJvY2Vzc2luZyBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLldNLkxvZy5saW5rVG9XaWtpUGFnZShhcnRpY2xlLCBhcnRpY2xlKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIiwgc3RvcHBpbmcgdGhlIGJvdFwiKVxuICAgICAgICAgICAgICAgICAgICBzZWxmLl9lbmRBdXRvbWF0aWModHJ1ZSlcblxuICAgIF9wcm9jZXNzSXRlbTogKHN0YXR1cywgaXRlbXMsIGluZGV4LCBsaW5rSWQsIGNoYWluQXJncykgLT5cbiAgICAgICAgc2VsZiA9IHRoaXNcbiAgICAgICAgaWYgaXRlbXNbaW5kZXhdXG4gICAgICAgICAgICBsaW5rID0gaXRlbXNbaW5kZXhdLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdhJylbbGlua0lkXVxuXG4gICAgICAgICAgICAjIEFsc28gdGVzdCAnbGluaycgaXRzZWxmLCBiZWNhdXNlIHRoZSBsaXN0IGl0ZW0gY291bGQgcmVmZXIgdG8gYW5cbiAgICAgICAgICAgICMgaW52YWxpZCB0aXRsZSwgcmVwcmVzZW50ZWQgYnkgZS5nLlxuICAgICAgICAgICAgIyA8c3BhbiBjbGFzcz1cIm13LWludmFsaWR0aXRsZVwiPkludmFsaWQgdGl0bGUgd2l0aCBuYW1lc3BhY2VcbiAgICAgICAgICAgICMgXCJDYXRlZ29yeVwiIGFuZCB0ZXh0IFwiXCI8L3NwYW4+XG4gICAgICAgICAgICBpZiBsaW5rIGFuZCBAY2FuUHJvY2Vzc1BhZ2UobGluaylcbiAgICAgICAgICAgICAgICB0aXRsZSA9IGxpbmsudGl0bGVcblxuICAgICAgICAgICAgICAgIGlmIHN0YXR1cyA9PSAwXG4gICAgICAgICAgICAgICAgICAgIGludGVydmFsID0gMTAwMFxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJ2YWwgPSBAY29uZmlndXJhdGlvbi5pbnRlcnZhbFxuXG4gICAgICAgICAgICAgICAgQFdNLkxvZy5sb2dJbmZvKCdXYWl0aW5nICcgKyAoaW50ZXJ2YWwgLyAxMDAwKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnIHNlY29uZHMgLi4uJylcblxuICAgICAgICAgICAgICAgIHN0b3BJZCA9IHNldFRpbWVvdXQoKCAobGlzLCBpZCwgbG4sIGFydGljbGUsIGNoYWluQXJncykgLT5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0+XG4gICAgICAgICAgICAgICAgICAgICAgICAjIFN0b3AgbXVzdCBiZSBkaXNhYmxlZCBiZWZvcmUgYW55IGNoZWNrIGlzIHBlcmZvcm1lZFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fZGlzYWJsZVN0b3BCb3QoKVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAjIENoZWNrIGhlcmUgaWYgb3RoZXIgYm90cyBoYXZlIGJlZW4gc3RhcnRlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICMgX25vdF8gYmVmb3JlIHNldFRpbWVvdXQhXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiBub3Qgc2VsZi5fY2hlY2tPdGhlckJvdHNSdW5uaW5nKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsbi5jbGFzc05hbWUgPSBzZWxmLmNoYW5nZVdpa2lNb25rZXlMaW5rQ2xhc3NOYW1lKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG4uY2xhc3NOYW1lLCAnV2lraU1vbmtleUJvdFByb2Nlc3NpbmcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuV00uTG9nLmxvZ0luZm8oXCJQcm9jZXNzaW5nIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuV00uTG9nLmxpbmtUb1dpa2lQYWdlKGFydGljbGUsIGFydGljbGUpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiIC4uLlwiKVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jb25maWd1cmF0aW9uLmZ1bmN0aW9uXyhhcnRpY2xlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLm1ha2VDYWxsQ29udGludWUobGlzLCBpZCwgbGlua0lkLCBsbiwgYXJ0aWNsZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYWluQXJncylcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLldNLkxvZy5sb2dFcnJvcignQW5vdGhlciBib3QgaGFzIGJlZW4gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZm9yY2Utc3RhcnRlZCwgc3RvcHBpbmcgLi4uJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9lbmRBdXRvbWF0aWMoZmFsc2UpXG4gICAgICAgICAgICAgICAgKShpdGVtcywgaW5kZXgsIGxpbmssIHRpdGxlLCBjaGFpbkFyZ3MpLCBpbnRlcnZhbClcblxuICAgICAgICAgICAgICAgIEBfZW5hYmxlU3RvcEJvdChzdG9wSWQpXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgaW5kZXgrK1xuICAgICAgICAgICAgICAgIEBfcHJvY2Vzc0l0ZW0oc3RhdHVzLCBpdGVtcywgaW5kZXgsIGxpbmtJZCwgY2hhaW5BcmdzKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICBAX2VuZEF1dG9tYXRpYyh0cnVlKVxuXG4gICAgX2VuZEF1dG9tYXRpYzogKHJlc2V0KSAtPlxuICAgICAgICBAX3Jlc2V0Qm90VG9rZW4ocmVzZXQpXG4gICAgICAgIEBXTS5Mb2cubG9nSW5mbygnQm90IG9wZXJhdGlvbnMgY29tcGxldGVkIChjaGVjayB0aGUgbG9nIGZvciAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3dhcm5pbmdzIG9yIGVycm9ycyknKVxuICAgICAgICBAX2Rpc2FibGVTdGFydEJvdCgnQm90IG9wZXJhdGlvbnMgY29tcGxldGVkLCByZXNldCBhbmQgcHJldmlldyAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAndGhlIGZpbHRlcicpXG4gICAgICAgIEBfcmVFbmFibGVDb250cm9scygpXG4iLCIjIFdpa2kgTW9ua2V5IC0gTWVkaWFXaWtpIGJvdCBhbmQgZWRpdG9yLWFzc2lzdGFudCB1c2VyIHNjcmlwdFxuIyBDb3B5cmlnaHQgKEMpIDIwMTEgRGFyaW8gR2lvdmFubmV0dGkgPGRldkBkYXJpb2dpb3Zhbm5ldHRpLm5ldD5cbiNcbiMgVGhpcyBmaWxlIGlzIHBhcnQgb2YgV2lraSBNb25rZXkuXG4jXG4jIFdpa2kgTW9ua2V5IGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiMgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiMgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiMgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbiNcbiMgV2lraSBNb25rZXkgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiMgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiMgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuIyBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuI1xuIyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuIyBhbG9uZyB3aXRoIFdpa2kgTW9ua2V5LiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuXG5Bc3luYyA9IHJlcXVpcmUoJ0BreW5pa29zL21pc2MvZGlzdC9Bc3luYycpXG5PYmogPSByZXF1aXJlKCdAa3luaWtvcy9taXNjL2Rpc3QvT2JqJylcblxuXG5jbGFzcyBtb2R1bGUuZXhwb3J0c1xuICAgIGNvbnN0cnVjdG9yOiAoQFdNKSAtPlxuXG4gICAgcmVjdXJzZVRyZWU6IChwYXJhbXMpIC0+XG4gICAgICAgIHBhcmFtcy5jYWxsQ2hpbGRyZW4gPSBAV00uQ2F0Ll9yZWN1cnNlVHJlZUNhbGxDaGlsZHJlblxuICAgICAgICBBc3luYy5yZWN1cnNlVHJlZUFzeW5jKHBhcmFtcylcblxuICAgIHJlY3Vyc2VUcmVlQ29udGludWU6IChwYXJhbXMpIC0+XG4gICAgICAgIEFzeW5jLnJlY3Vyc2VUcmVlQXN5bmMocGFyYW1zKVxuXG4gICAgX3JlY3Vyc2VUcmVlQ2FsbENoaWxkcmVuOiAocGFyYW1zKSAtPlxuICAgICAgICBAV00uQ2F0LmdldFN1YkNhdGVnb3JpZXMocGFyYW1zLm5vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQFdNLkNhdC5fcmVjdXJzZVRyZWVDYWxsQ2hpbGRyZW5Db250aW51ZSwgcGFyYW1zKVxuXG4gICAgX3JlY3Vyc2VUcmVlQ2FsbENoaWxkcmVuQ29udGludWU6IChzdWJDYXRzLCBwYXJhbXMpIC0+XG4gICAgICAgIGZvciBzdWJDYXQgaW4gc3ViQ2F0c1xuICAgICAgICAgICAgcGFyYW1zLmNoaWxkcmVuLnB1c2goc3ViQ2F0LnRpdGxlKVxuICAgICAgICBBc3luYy5yZWN1cnNlVHJlZUFzeW5jKHBhcmFtcylcblxuICAgIGdldFN1YkNhdGVnb3JpZXM6IChwYXJlbnQsIGNhbGwsIGNhbGxBcmdzKSAtPlxuICAgICAgICBAV00uQ2F0Ll9nZXRNZW1iZXJzKHBhcmVudCwgXCJzdWJjYXRcIiwgY2FsbCwgY2FsbEFyZ3MpXG5cbiAgICBnZXRBbGxNZW1iZXJzOiAocGFyZW50LCBjYWxsLCBjYWxsQXJncykgLT5cbiAgICAgICAgQFdNLkNhdC5fZ2V0TWVtYmVycyhwYXJlbnQsIG51bGwsIGNhbGwsIGNhbGxBcmdzKVxuXG4gICAgX2dldE1lbWJlcnM6IChuYW1lLCBjbXR5cGUsIGNhbGwsIGNhbGxBcmdzKSAtPlxuICAgICAgICBxdWVyeSA9XG4gICAgICAgICAgICBhY3Rpb246IFwicXVlcnlcIlxuICAgICAgICAgICAgbGlzdDogXCJjYXRlZ29yeW1lbWJlcnNcIlxuICAgICAgICAgICAgY210aXRsZTogbmFtZVxuICAgICAgICAgICAgY21saW1pdDogNTAwXG5cbiAgICAgICAgaWYgY210eXBlXG4gICAgICAgICAgICBxdWVyeS5jbXR5cGUgPSBjbXR5cGVcblxuICAgICAgICBAX2dldE1lbWJlcnNDb250aW51ZShxdWVyeSwgY2FsbCwgY2FsbEFyZ3MsIFtdKVxuXG4gICAgX2dldE1lbWJlcnNDb250aW51ZTogKHF1ZXJ5LCBjYWxsLCBjYWxsQXJncywgbWVtYmVycykgLT5cbiAgICAgICAgQFdNLk1XLmNhbGxBUElHZXQocXVlcnksIChyZXMsIGFyZ3MpIC0+XG4gICAgICAgICAgICBtZW1iZXJzID0gbWVtYmVycy5jb25jYXQocmVzLnF1ZXJ5LmNhdGVnb3J5bWVtYmVycylcbiAgICAgICAgICAgIGlmIHJlc1tcInF1ZXJ5LWNvbnRpbnVlXCJdXG4gICAgICAgICAgICAgICAgcXVlcnkuY21jb250aW51ZSA9IHJlc1tcInF1ZXJ5LWNvbnRpbnVlXCJdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY2F0ZWdvcnltZW1iZXJzLmNtY29udGludWVcbiAgICAgICAgICAgICAgICBAX2dldE1lbWJlcnNDb250aW51ZShxdWVyeSwgY2FsbCwgYXJncywgbWVtYmVycylcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBjYWxsKG1lbWJlcnMsIGFyZ3MpXG4gICAgICAgICxcbiAgICAgICAgY2FsbEFyZ3MsIG51bGwpXG5cbiAgICBnZXRQYXJlbnRzQW5kSW5mbzogKG5hbWUsIGNhbGwsIGNhbGxBcmdzKSAtPlxuICAgICAgICBxdWVyeSA9XG4gICAgICAgICAgICBhY3Rpb246IFwicXVlcnlcIlxuICAgICAgICAgICAgcHJvcDogXCJjYXRlZ29yaWVzfGNhdGVnb3J5aW5mb1wiXG4gICAgICAgICAgICB0aXRsZXM6IG5hbWVcbiAgICAgICAgICAgIGNscHJvcDogXCJoaWRkZW5cIlxuICAgICAgICAgICAgY2xsaW1pdDogNTAwXG5cbiAgICAgICAgQF9nZXRQYXJlbnRzQW5kSW5mb0NvbnRpbnVlKHF1ZXJ5LCBjYWxsLCBjYWxsQXJncywgW10sIG51bGwpXG5cbiAgICBfZ2V0UGFyZW50c0FuZEluZm9Db250aW51ZTogKHF1ZXJ5LCBjYWxsLCBjYWxsQXJncywgcGFyZW50cywgaW5mbykgLT5cbiAgICAgICAgQFdNLk1XLmNhbGxBUElHZXQocXVlcnksIChyZXMsIGFyZ3MpIC0+XG4gICAgICAgICAgICBwYWdlID0gT2JqLmdldEZpcnN0SXRlbShyZXMucXVlcnkucGFnZXMpXG5cbiAgICAgICAgICAgIGlmIHBhZ2UuY2F0ZWdvcmllc1xuICAgICAgICAgICAgICAgIHBhcmVudHMgPSBwYXJlbnRzLmNvbmNhdChwYWdlLmNhdGVnb3JpZXMpXG5cbiAgICAgICAgICAgIGlmIHBhZ2UuY2F0ZWdvcnlpbmZvXG4gICAgICAgICAgICAgICAgaW5mbyA9IHBhZ2UuY2F0ZWdvcnlpbmZvXG5cbiAgICAgICAgICAgIGlmIHJlc1tcInF1ZXJ5LWNvbnRpbnVlXCJdXG4gICAgICAgICAgICAgICAgIyBSZXF1ZXN0IGNhdGVnb3J5aW5mbyBvbmx5IG9uY2VcbiAgICAgICAgICAgICAgICBxdWVyeS5wcm9wID0gXCJjYXRlZ29yaWVzXCJcbiAgICAgICAgICAgICAgICBxdWVyeS5jbGNvbnRpbnVlID0gcmVzW1wicXVlcnktY29udGludWVcIl0uY2F0ZWdvcmllcy5jbGNvbnRpbnVlXG4gICAgICAgICAgICAgICAgQF9nZXRQYXJlbnRzQW5kSW5mb0NvbnRpbnVlKHF1ZXJ5LCBjYWxsLCBhcmdzLCBwYXJlbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5mbylcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBjYWxsKHBhcmVudHMsIGluZm8sIGFyZ3MpXG4gICAgICAgICxcbiAgICAgICAgY2FsbEFyZ3MsIG51bGwpXG4iLCIjIFdpa2kgTW9ua2V5IC0gTWVkaWFXaWtpIGJvdCBhbmQgZWRpdG9yLWFzc2lzdGFudCB1c2VyIHNjcmlwdFxuIyBDb3B5cmlnaHQgKEMpIDIwMTEgRGFyaW8gR2lvdmFubmV0dGkgPGRldkBkYXJpb2dpb3Zhbm5ldHRpLm5ldD5cbiNcbiMgVGhpcyBmaWxlIGlzIHBhcnQgb2YgV2lraSBNb25rZXkuXG4jXG4jIFdpa2kgTW9ua2V5IGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiMgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiMgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiMgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbiNcbiMgV2lraSBNb25rZXkgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiMgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiMgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuIyBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuI1xuIyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuIyBhbG9uZyB3aXRoIFdpa2kgTW9ua2V5LiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuXG5IVFRQID0gcmVxdWlyZSgnQGt5bmlrb3MvbWlzYy9kaXN0L0hUVFAnKVxuXG5cbmNsYXNzIG1vZHVsZS5leHBvcnRzXG4gICAgY29uc3RydWN0b3I6IChAV00pIC0+XG5cbiAgICBnZXRFbmRUaW1lc3RhbXA6IChjYWxsLCBjYWxsQXJncykgLT5cbiAgICAgICAgdGl0bGUgPSBkZWNvZGVVUklDb21wb25lbnQoSFRUUC5nZXRVUklQYXJhbWV0ZXIobnVsbCwgJ3RpdGxlJykpXG4gICAgICAgIGRpZmYgPSBIVFRQLmdldFVSSVBhcmFtZXRlcihudWxsLCAnZGlmZicpXG4gICAgICAgIG9sZGlkID0gSFRUUC5nZXRVUklQYXJhbWV0ZXIobnVsbCwgJ29sZGlkJylcblxuICAgICAgICBnaXZlRW5kVGltZXN0YW1wID0gKHBhZ2UsIGlkKSAtPlxuICAgICAgICAgICAgY2FsbChwYWdlLnJldmlzaW9uc1tpZF0udGltZXN0YW1wLCBjYWxsQXJncylcblxuICAgICAgICBzd2l0Y2ggZGlmZlxuICAgICAgICAgICAgd2hlbiAnbmV4dCdcbiAgICAgICAgICAgICAgICBwYXJzID1cbiAgICAgICAgICAgICAgICAgICAgcHJvcDogXCJyZXZpc2lvbnNcIlxuICAgICAgICAgICAgICAgICAgICB0aXRsZXM6IHRpdGxlXG4gICAgICAgICAgICAgICAgICAgIHJ2bGltaXQ6IFwiMlwiXG4gICAgICAgICAgICAgICAgICAgIHJ2cHJvcDogXCJ0aW1lc3RhbXBcIlxuICAgICAgICAgICAgICAgICAgICBydmRpcjogXCJuZXdlclwiXG4gICAgICAgICAgICAgICAgICAgIHJ2c3RhcnRpZDogb2xkaWRcbiAgICAgICAgICAgICAgICBAV00uTVcuY2FsbFF1ZXJ5KHBhcnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnaXZlRW5kVGltZXN0YW1wLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bGwpXG4gICAgICAgICAgICB3aGVuICdwcmV2J1xuICAgICAgICAgICAgICAgIHBhcnMgPVxuICAgICAgICAgICAgICAgICAgICBwcm9wOiBcInJldmlzaW9uc1wiXG4gICAgICAgICAgICAgICAgICAgIHJldmlkczogb2xkaWRcbiAgICAgICAgICAgICAgICAgICAgcnZwcm9wOiBcInRpbWVzdGFtcFwiXG4gICAgICAgICAgICAgICAgQFdNLk1XLmNhbGxRdWVyeShwYXJzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2l2ZUVuZFRpbWVzdGFtcCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudWxsKVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHBhcnMgPVxuICAgICAgICAgICAgICAgICAgICBwcm9wOiBcInJldmlzaW9uc1wiXG4gICAgICAgICAgICAgICAgICAgIHJldmlkczogZGlmZlxuICAgICAgICAgICAgICAgICAgICBydnByb3A6IFwidGltZXN0YW1wXCJcbiAgICAgICAgICAgICAgICBAV00uTVcuY2FsbFF1ZXJ5KHBhcnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnaXZlRW5kVGltZXN0YW1wLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bGwpXG4iLCIjIFdpa2kgTW9ua2V5IC0gTWVkaWFXaWtpIGJvdCBhbmQgZWRpdG9yLWFzc2lzdGFudCB1c2VyIHNjcmlwdFxuIyBDb3B5cmlnaHQgKEMpIDIwMTEgRGFyaW8gR2lvdmFubmV0dGkgPGRldkBkYXJpb2dpb3Zhbm5ldHRpLm5ldD5cbiNcbiMgVGhpcyBmaWxlIGlzIHBhcnQgb2YgV2lraSBNb25rZXkuXG4jXG4jIFdpa2kgTW9ua2V5IGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiMgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiMgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiMgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbiNcbiMgV2lraSBNb25rZXkgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiMgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiMgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuIyBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuI1xuIyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuIyBhbG9uZyB3aXRoIFdpa2kgTW9ua2V5LiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuXG5Db21wYXRpYmlsaXR5ID0gcmVxdWlyZSgnQGt5bmlrb3MvbWlzYy9kaXN0L0NvbXBhdGliaWxpdHknKVxuSFRUUCA9IHJlcXVpcmUoJ0BreW5pa29zL21pc2MvZGlzdC9IVFRQJylcblxuXG5jbGFzcyBtb2R1bGUuZXhwb3J0c1xuICAgIGNvbnN0cnVjdG9yOiAoQFdNKSAtPlxuXG4gICAgZ2V0VGl0bGU6IC0+XG4gICAgICAgIHJldHVybiBAV00uUGFyc2VyLnNxdWFzaENvbnRpZ3VvdXNXaGl0ZXNwYWNlKGRlY29kZVVSSUNvbXBvbmVudChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEhUVFAuZ2V0VVJJUGFyYW1ldGVyKG51bGwsICd0aXRsZScpKSlcblxuICAgIGlzU2VjdGlvbjogLT5cbiAgICAgICAgcmV0dXJuIGlmIGRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lKCd3cFNlY3Rpb24nKVswXS52YWx1ZSB0aGVuIHRydWUgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFsc2VcblxuICAgIHJlYWRTb3VyY2U6IC0+XG4gICAgICAgIHZhbHVlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3dwVGV4dGJveDEnKS52YWx1ZVxuICAgICAgICAjIEZvciBjb21wYXRpYmlsaXR5IHdpdGggT3BlcmEgYW5kIElFXG4gICAgICAgIHJldHVybiBDb21wYXRpYmlsaXR5Lm5vcm1hbGl6ZUNhcnJpYWdlUmV0dXJucyh2YWx1ZSlcblxuICAgIHdyaXRlU291cmNlOiAodGV4dCkgLT5cbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3dwVGV4dGJveDEnKS52YWx1ZSA9IHRleHRcblxuICAgIHJlYWRTdW1tYXJ5OiAtPlxuICAgICAgICByZXR1cm4gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3dwU3VtbWFyeScpLmdldEF0dHJpYnV0ZShcInZhbHVlXCIpXG5cbiAgICB3cml0ZVN1bW1hcnk6ICh0ZXh0KSAtPlxuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnd3BTdW1tYXJ5Jykuc2V0QXR0cmlidXRlKFwidmFsdWVcIiwgdGV4dClcblxuICAgIGFwcGVuZFRvU3VtbWFyeTogKHRleHQpIC0+XG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd3cFN1bW1hcnknKS5zZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZFN1bW1hcnkoKSArIHRleHQpXG4iLCIjIFdpa2kgTW9ua2V5IC0gTWVkaWFXaWtpIGJvdCBhbmQgZWRpdG9yLWFzc2lzdGFudCB1c2VyIHNjcmlwdFxuIyBDb3B5cmlnaHQgKEMpIDIwMTEgRGFyaW8gR2lvdmFubmV0dGkgPGRldkBkYXJpb2dpb3Zhbm5ldHRpLm5ldD5cbiNcbiMgVGhpcyBmaWxlIGlzIHBhcnQgb2YgV2lraSBNb25rZXkuXG4jXG4jIFdpa2kgTW9ua2V5IGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiMgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiMgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiMgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbiNcbiMgV2lraSBNb25rZXkgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiMgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiMgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuIyBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuI1xuIyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuIyBhbG9uZyB3aXRoIFdpa2kgTW9ua2V5LiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuXG5DU1MgPSByZXF1aXJlKCdAa3luaWtvcy9taXNjL2Rpc3QvQ1NTJylcblxuXG5jbGFzcyBtb2R1bGUuZXhwb3J0c1xuICAgIGNvbnN0cnVjdG9yOiAoQFdNKSAtPlxuXG4gICAgX21ha2VVSTogKEBwYWdlX3R5cGUsIHBsdWdpbnMpIC0+XG4gICAgICAgIENTUy5hZGRTdHlsZUVsZW1lbnQoXCIjV2lraU1vbmtleUZpbHRlcnMtQ29tbWFuZHMge2Rpc3BsYXk6ZmxleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsaWduLWl0ZW1zOmNlbnRlcjsganVzdGlmeS1jb250ZW50OnNwYWNlLWJldHdlZW47fVxuICAgICAgICAgICAgICAgICAgICAjV2lraU1vbmtleUZpbHRlcnMtQ29tbWFuZHMgPiBzZWxlY3Qge2ZsZXg6YXV0bzt9XG4gICAgICAgICAgICAgICAgICAgICNXaWtpTW9ua2V5RmlsdGVycy1Db21tYW5kcyA+IHNlbGVjdCxcbiAgICAgICAgICAgICAgICAgICAgI1dpa2lNb25rZXlGaWx0ZXJzLUNvbW1hbmRzID4gaW5wdXRbdHlwZT0nYnV0dG9uJ11cbiAgICAgICAgICAgICAgICAgICAgICAgIHttYXJnaW4tcmlnaHQ6MWVtO31cbiAgICAgICAgICAgICAgICAgICAgI1dpa2lNb25rZXlGaWx0ZXJzLUNvbW1hbmRzID4gaW5wdXRbdHlwZT0nY2hlY2tib3gnXVxuICAgICAgICAgICAgICAgICAgICAgICAge21hcmdpbi1yaWdodDowLjRlbTt9XCIpXG5cbiAgICAgICAgZmlsdGVycyA9IFtdXG4gICAgICAgIHNlbGVjdEZpbHRlciA9ICQoJzxzZWxlY3QvPicpLmNoYW5nZShAdXBkYXRlRmlsdGVyVUkoZmlsdGVycykpXG5cbiAgICAgICAgZm9yIFBsdWdpbiBpbiBwbHVnaW5zXG4gICAgICAgICAgICBwbHVnaW4gPSBuZXcgUGx1Z2luKEBXTSlcbiAgICAgICAgICAgIHBsdWdpbkluc3QgPSBwbHVnaW4uY29uZi5maWx0ZXJfbGFiZWxcblxuICAgICAgICAgICAgIyBUaGlzIGFsbG93cyB0byBkaXNhYmxlIGFuIGVudHJ5IGJ5IGdpdmluZyBpdCBhbnkgc2Vjb25kXG4gICAgICAgICAgICAjIHBhcmFtZXRlciB0aGF0IGV2YWx1YXRlcyB0byBmYWxzZVxuICAgICAgICAgICAgaWYgbm90IHBsdWdpbkluc3RcbiAgICAgICAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgICAgICBmaWx0ZXJzLnB1c2gocGx1Z2luKVxuICAgICAgICAgICAgb3B0aW9uID0gJCgnPG9wdGlvbi8+JykudGV4dChwbHVnaW5JbnN0KVxuXG4gICAgICAgICAgICBpZiBwbHVnaW4uY29uc3RydWN0b3IubmFtZSBpcyBAV00uY29uZltcImRlZmF1bHRfI3tAcGFnZV90eXBlfV9wbHVnaW5cIl1cbiAgICAgICAgICAgICAgICBvcHRpb25bMF0uc2VsZWN0ZWQgPSB0cnVlXG5cbiAgICAgICAgICAgIG9wdGlvbi5hcHBlbmRUbyhzZWxlY3RGaWx0ZXIpXG5cbiAgICAgICAgaWYgZmlsdGVycy5sZW5ndGhcbiAgICAgICAgICAgIGNvbW1hbmRzRmlsdGVyRGl2ID0gJCgnPGRpdi8+JylcbiAgICAgICAgICAgICAgICAuYXR0cignaWQnLCAnV2lraU1vbmtleUZpbHRlcnMtQ29tbWFuZHMnKVxuXG4gICAgICAgICAgICBjb21tYW5kc0ZpbHRlckRpdi5hcHBlbmQoc2VsZWN0RmlsdGVyKVxuXG4gICAgICAgICAgICAkKCc8aW5wdXQvPicpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3R5cGUnLCAnYnV0dG9uJylcbiAgICAgICAgICAgICAgICAudmFsKCdBcHBseSBmaWx0ZXInKVxuICAgICAgICAgICAgICAgIC5jbGljayhAZXhlY3V0ZVBsdWdpbihmaWx0ZXJzKSlcbiAgICAgICAgICAgICAgICAuYXBwZW5kVG8oY29tbWFuZHNGaWx0ZXJEaXYpXG5cbiAgICAgICAgICAgICQoJzxpbnB1dC8+JylcbiAgICAgICAgICAgICAgICAuYXR0cigndHlwZScsICdjaGVja2JveCcpXG4gICAgICAgICAgICAgICAgLmNoYW5nZShAdG9nZ2xlTG9nKVxuICAgICAgICAgICAgICAgIC5hcHBlbmRUbyhjb21tYW5kc0ZpbHRlckRpdilcblxuICAgICAgICAgICAgJCgnPHNwYW4vPicpXG4gICAgICAgICAgICAgICAgLnRleHQoJ1Nob3cgTG9nJylcbiAgICAgICAgICAgICAgICAuYXBwZW5kVG8oY29tbWFuZHNGaWx0ZXJEaXYpXG5cbiAgICAgICAgICAgIGRpdkZpbHRlciA9ICQoJzxkaXYvPicpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2lkJywgXCJXaWtpTW9ua2V5RmlsdGVycy1PcHRpb25zXCIpXG5cbiAgICAgICAgICAgICMgVGhpcyBhbGxvd3MgdXBkYXRlRmlsdGVyVUkgcmVwbGFjZSBpdCB0aGUgZmlyc3QgdGltZVxuICAgICAgICAgICAgJCgnPGRpdi8+JykuYXBwZW5kVG8oZGl2RmlsdGVyKVxuICAgICAgICAgICAgQGRvVXBkYXRlRmlsdGVyVUkoZGl2RmlsdGVyLCBmaWx0ZXJzLCBzZWxlY3RGaWx0ZXJbMF0uc2VsZWN0ZWRJbmRleClcblxuICAgICAgICAgICAgZGl2ID0gJCgnPGRpdi8+JylcbiAgICAgICAgICAgICAgICAuYXR0cignaWQnLCAnV2lraU1vbmtleUZpbHRlcnMnKVxuICAgICAgICAgICAgICAgIC5hcHBlbmQoY29tbWFuZHNGaWx0ZXJEaXYpXG4gICAgICAgICAgICAgICAgLmFwcGVuZChkaXZGaWx0ZXIpXG4gICAgICAgICAgICByZXR1cm4gZGl2WzBdXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuXG4gICAgdXBkYXRlRmlsdGVyVUk6IChmaWx0ZXJzKSA9PlxuICAgICAgICByZXR1cm4gKGV2ZW50KSA9PlxuICAgICAgICAgICAgVUkgPSAkKCcjV2lraU1vbmtleUZpbHRlcnMtT3B0aW9ucycpXG4gICAgICAgICAgICBzZWxlY3QgPSAkKCcjV2lraU1vbmtleUZpbHRlcnMtQ29tbWFuZHMnKVxuICAgICAgICAgICAgICAgIC5maW5kKCdzZWxlY3QnKVxuICAgICAgICAgICAgICAgIC5maXJzdCgpXG4gICAgICAgICAgICBpZCA9IHNlbGVjdFswXS5zZWxlY3RlZEluZGV4XG5cbiAgICAgICAgICAgIEBkb1VwZGF0ZUZpbHRlclVJKFVJLCBmaWx0ZXJzLCBpZClcblxuICAgIGRvVXBkYXRlRmlsdGVyVUk6IChVSSwgZmlsdGVycywgaWQpIC0+XG4gICAgICAgIG1ha2VVSSA9IGZpbHRlcnNbaWRdLm1ha2VVSVxuXG4gICAgICAgIGlmIG1ha2VVSSBpbnN0YW5jZW9mIEZ1bmN0aW9uXG4gICAgICAgICAgICBVSS5jaGlsZHJlbigpLmZpcnN0KCkucmVwbGFjZVdpdGgobWFrZVVJKCkpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgICMgRG9uJ3QgcmVtb3ZlLCBvdGhlcndpc2UgaWYgYW5vdGhlciBwbHVnaW4gd2l0aCBpbnRlcmZhY2UgaXNcbiAgICAgICAgICAgICMgc2VsZWN0ZWQsIHJlcGxhY2VXaXRoIHdvbid0IHdvcmtcbiAgICAgICAgICAgIFVJLmNoaWxkcmVuKCkuZmlyc3QoKS5yZXBsYWNlV2l0aCgkKCc8ZGl2Lz4nKSlcblxuICAgIGV4ZWN1dGVQbHVnaW46IChmaWx0ZXJzKSA9PlxuICAgICAgICByZXR1cm4gKGV2ZW50KSA9PlxuICAgICAgICAgICAgc2VsZWN0ID0gJCgnI1dpa2lNb25rZXlGaWx0ZXJzLUNvbW1hbmRzJylcbiAgICAgICAgICAgICAgICAuZmluZCgnc2VsZWN0JylcbiAgICAgICAgICAgICAgICAuZmlyc3QoKVxuICAgICAgICAgICAgaWQgPSBzZWxlY3RbMF0uc2VsZWN0ZWRJbmRleFxuXG4gICAgICAgICAgICBmaWx0ZXJzW2lkXVtcIm1haW5fI3tAcGFnZV90eXBlfVwiXSgpXG5cbiAgICAgICAgICAgIGV2ZW50LnRhcmdldC5kaXNhYmxlZCA9IHRydWVcblxuICAgIHRvZ2dsZUxvZzogKGV2ZW50KSAtPlxuICAgICAgICBpZiBAY2hlY2tlZFxuICAgICAgICAgICAgJCgnI1dpa2lNb25rZXlMb2cnKS5zaG93KClcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgJCgnI1dpa2lNb25rZXlMb2cnKS5oaWRlKClcbiIsIiMgV2lraSBNb25rZXkgLSBNZWRpYVdpa2kgYm90IGFuZCBlZGl0b3ItYXNzaXN0YW50IHVzZXIgc2NyaXB0XG4jIENvcHlyaWdodCAoQykgMjAxMSBEYXJpbyBHaW92YW5uZXR0aSA8ZGV2QGRhcmlvZ2lvdmFubmV0dGkubmV0PlxuI1xuIyBUaGlzIGZpbGUgaXMgcGFydCBvZiBXaWtpIE1vbmtleS5cbiNcbiMgV2lraSBNb25rZXkgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuIyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuIyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuIyAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuI1xuIyBXaWtpIE1vbmtleSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuIyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuIyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4jIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4jXG4jIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4jIGFsb25nIHdpdGggV2lraSBNb25rZXkuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG5cbk9iaiA9IHJlcXVpcmUoJ0BreW5pa29zL21pc2MvZGlzdC9PYmonKVxuXG5cbmNsYXNzIG1vZHVsZS5leHBvcnRzXG4gICAgY29uc3RydWN0b3I6IChAV00pIC0+XG5cbiAgICBwYXJzZUxpbmtzOiAoc3VwcG9ydGVkTGFuZ3MsIHNvdXJjZSwgaXdtYXApID0+XG4gICAgICAgIHBhcnNlZExpbmtzID0gQFdNLlBhcnNlci5maW5kU3BlY2lhbExpbmtzKFxuICAgICAgICAgICAgc291cmNlLFxuICAgICAgICAgICAgc3VwcG9ydGVkTGFuZ3Muam9pbihcInxcIilcbiAgICAgICAgKVxuXG4gICAgICAgIGxhbmdsaW5rcyA9IFtdXG4gICAgICAgIGZvciBsaW5rIGluIHBhcnNlZExpbmtzXG4gICAgICAgICAgICAjIERvIG5vdCBzdG9yZSB0aGUgdGFnIGxvd2VyY2FzZWQsIHNpbmNlIGl0IHNob3VsZCBiZSBrZXB0IGFzXG4gICAgICAgICAgICAjIG9yaWdpbmFsXG4gICAgICAgICAgICBsdGFnID0gbGluay5uYW1lc3BhY2VcbiAgICAgICAgICAgIGx0aXRsZSA9IGxpbmsudGl0bGUgKyAoaWYgbGluay5mcmFnbWVudCB0aGVuIChcIiNcIiArIGxpbmsuZnJhZ21lbnQpIGVsc2UgXCJcIilcbiAgICAgICAgICAgIGZvciBpdyBpbiBpd21hcFxuICAgICAgICAgICAgICAgIGlmIGl3LnByZWZpeC50b0xvd2VyQ2FzZSgpID09IGx0YWcudG9Mb3dlckNhc2UoKVxuICAgICAgICAgICAgICAgICAgICAjIEZpeCB0aGUgdXJsIF9iZWZvcmVfIHJlcGxhY2luZyAkMVxuICAgICAgICAgICAgICAgICAgICBsdXJsID0gQFdNLk1XLmZpeEludGVyd2lraVVybChpdy51cmwpXG4gICAgICAgICAgICAgICAgICAgIGx1cmwgPSBsdXJsLnJlcGxhY2UoXCIkMVwiLCBlbmNvZGVVUklDb21wb25lbnQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEBXTS5QYXJzZXIuc3F1YXNoQ29udGlndW91c1doaXRlc3BhY2UobHRpdGxlKSkpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgICAgIGxhbmdsaW5rcy5wdXNoKHtsYW5nOiBsdGFnLCB0aXRsZTogbHRpdGxlLCB1cmw6IGx1cmwsIGluZGV4OiBsaW5rLmluZGV4LCBsZW5ndGg6IGxpbmsubGVuZ3RofSlcblxuICAgICAgICByZXR1cm4gbGFuZ2xpbmtzXG5cbiAgICBxdWVyeUxpbmtzOiAocXVlcnlUaXRsZSwgdGl0bGUsIHN1cHBvcnRlZExhbmdzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpdGVsaXN0LCBmaXJzdFBhZ2UsIGNhbGxFbmQsIGNhbGxBcmdzKSA9PlxuICAgICAgICBxdWVyeSA9XG4gICAgICAgICAgICBhY3Rpb246IFwicXVlcnlcIlxuICAgICAgICAgICAgcHJvcDogXCJpbmZvfHJldmlzaW9uc1wiXG4gICAgICAgICAgICBydnByb3A6IFwiY29udGVudHx0aW1lc3RhbXBcIlxuICAgICAgICAgICAgaW50b2tlbjogXCJlZGl0XCJcbiAgICAgICAgICAgIHRpdGxlczogcXVlcnlUaXRsZVxuICAgICAgICAgICAgbWV0YTogXCJzaXRlaW5mb1wiXG4gICAgICAgICAgICBzaXByb3A6IFwiaW50ZXJ3aWtpbWFwXCJcbiAgICAgICAgICAgIHNpZmlsdGVyaXc6IFwibG9jYWxcIlxuXG4gICAgICAgICMgV2hlbiBjYWxsZWQgYnkgdGhlIGJvdCwgaWYgdGhlIHN0YXJ0IHBhZ2UgaXMgYSByZWRpcmVjdCBpdHNlbGYsIGl0XG4gICAgICAgICMgc2hvdWRsbid0IGJlIHJlc29sdmVkXG4gICAgICAgIGlmIG5vdCBmaXJzdFBhZ2VcbiAgICAgICAgICAgIHF1ZXJ5LnJlZGlyZWN0cyA9IFwiMVwiXG5cbiAgICAgICAgQFdNLk1XLmNhbGxBUElHZXQoXG4gICAgICAgICAgICBxdWVyeSxcbiAgICAgICAgICAgIChyZXMsIGFyZ3MpID0+XG4gICAgICAgICAgICAgICAgaWYgcmVzLnF1ZXJ5LnBhZ2VzXG4gICAgICAgICAgICAgICAgICAgIHBhZ2UgPSBPYmouZ2V0Rmlyc3RJdGVtKHJlcy5xdWVyeS5wYWdlcylcbiAgICAgICAgICAgICAgICAgICAgaWYgcGFnZS5yZXZpc2lvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yID0gbnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlID0gcGFnZS5yZXZpc2lvbnNbMF1bXCIqXCJdXG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXAgPSBwYWdlLnJldmlzaW9uc1swXS50aW1lc3RhbXBcbiAgICAgICAgICAgICAgICAgICAgICAgIGVkaXR0b2tlbiA9IHBhZ2UuZWRpdHRva2VuXG4gICAgICAgICAgICAgICAgICAgICAgICBpd21hcCA9IHJlcy5xdWVyeS5pbnRlcndpa2ltYXBcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhbmdsaW5rcyA9IEBXTS5JbnRlcmxhbmd1YWdlLnBhcnNlTGlua3MoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdXBwb3J0ZWRMYW5ncywgc291cmNlLCBpd21hcClcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgIyBUaGUgcmVxdWVzdGVkIGFydGljbGUgZG9lc24ndCBleGlzdFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSAnbm9uZXhpc3RpbmcnXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2UgPSBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZXN0YW1wID0gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGVkaXR0b2tlbiA9IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBpd21hcCA9IHJlcy5xdWVyeS5pbnRlcndpa2ltYXBcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhbmdsaW5rcyA9IGZhbHNlXG5cbiAgICAgICAgICAgICAgICBlbHNlIGlmIHJlcy5xdWVyeS5yZWRpcmVjdHNcbiAgICAgICAgICAgICAgICAgICAgIyBUaGUgcmVxdWVzdGVkIGFydGljbGUgaXMgYW4gdW5zb2x2ZWQgcmVkaXJlY3RcbiAgICAgICAgICAgICAgICAgICAgIyAocmVkaXJlY3Qgb3ZlciBpbnRlcndpa2kgbGluaz8pXG4gICAgICAgICAgICAgICAgICAgIGVycm9yID0gJ3Vuc29sdmVkcmVkaXJlY3QnXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZSA9IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcCA9IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIGVkaXR0b2tlbiA9IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIGl3bWFwID0gcmVzLnF1ZXJ5LmludGVyd2lraW1hcFxuICAgICAgICAgICAgICAgICAgICBsYW5nbGlua3MgPSBmYWxzZVxuXG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAjIFVua25vd24gZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSAndW5rbm93bidcbiAgICAgICAgICAgICAgICAgICAgc291cmNlID0gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgdGltZXN0YW1wID0gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgZWRpdHRva2VuID0gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgaXdtYXAgPSByZXMucXVlcnkuaW50ZXJ3aWtpbWFwXG4gICAgICAgICAgICAgICAgICAgIGxhbmdsaW5rcyA9IGZhbHNlXG5cbiAgICAgICAgICAgICAgICBjYWxsRW5kKFxuICAgICAgICAgICAgICAgICAgICB0aXRsZSxcbiAgICAgICAgICAgICAgICAgICAgc3VwcG9ydGVkTGFuZ3MsXG4gICAgICAgICAgICAgICAgICAgIHdoaXRlbGlzdCxcbiAgICAgICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgICAgICAgICBsYW5nbGlua3MsXG4gICAgICAgICAgICAgICAgICAgIGl3bWFwLFxuICAgICAgICAgICAgICAgICAgICBzb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcCxcbiAgICAgICAgICAgICAgICAgICAgZWRpdHRva2VuLFxuICAgICAgICAgICAgICAgICAgICBhcmdzXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgLFxuICAgICAgICAgICAgY2FsbEFyZ3MsXG4gICAgICAgICAgICAoYXJncykgLT5cbiAgICAgICAgICAgICAgICBjYWxsRW5kKFxuICAgICAgICAgICAgICAgICAgICB0aXRsZSxcbiAgICAgICAgICAgICAgICAgICAgc3VwcG9ydGVkTGFuZ3MsXG4gICAgICAgICAgICAgICAgICAgIHdoaXRlbGlzdCxcbiAgICAgICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICd1bmtub3duJyxcbiAgICAgICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBhcmdzXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICApXG5cbiAgICBjcmVhdGVOZXdMaW5rOiAob3JpZ1RhZywgdGl0bGUsIHVybCkgPT5cbiAgICAgICAgcmV0dXJuIHtvcmlnVGFnOiBvcmlnVGFnLCB0aXRsZTogdGl0bGUsIHVybDogdXJsfVxuXG4gICAgY3JlYXRlVmlzaXRlZExpbms6IChvcmlnVGFnLCB0aXRsZSwgdXJsLCBpd21hcCwgc291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZXN0YW1wLCBlZGl0dG9rZW4sIGxpbmtzKSA9PlxuICAgICAgICBlbnRyeSA9XG4gICAgICAgICAgICBvcmlnVGFnOiBvcmlnVGFnXG4gICAgICAgICAgICB0aXRsZTogdGl0bGVcbiAgICAgICAgICAgIHVybDogdXJsXG4gICAgICAgICAgICBpd21hcDogaXdtYXBcbiAgICAgICAgICAgIHNvdXJjZTogc291cmNlXG4gICAgICAgICAgICB0aW1lc3RhbXA6IHRpbWVzdGFtcFxuICAgICAgICAgICAgZWRpdHRva2VuOiBlZGl0dG9rZW5cbiAgICAgICAgICAgIGxpbmtzOiBbXVxuXG4gICAgICAgIGZvciBsaW5rIGluIGxpbmtzXG4gICAgICAgICAgICBlbnRyeS5saW5rcy5wdXNoKGxpbmspXG5cbiAgICAgICAgcmV0dXJuIGVudHJ5XG5cbiAgICBjb2xsZWN0TGlua3M6ICh2aXNpdGVkbGlua3MsIG5ld2xpbmtzLCBzdXBwb3J0ZWRMYW5ncyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaXRlbGlzdCwgZmlyc3RQYWdlLCBjYWxsRW5kLCBjYWxsQXJncykgPT5cbiAgICAgICAgZm9yIHRhZyBvZiBuZXdsaW5rc1xuICAgICAgICAgICAgbGluayA9IG5ld2xpbmtzW3RhZ11cbiAgICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgaWYgbGlua1xuICAgICAgICAgICAgZGVsZXRlIG5ld2xpbmtzW3RhZ11cblxuICAgICAgICAgICAgdXJsID0gbGluay51cmxcblxuICAgICAgICAgICAgIyBEb24ndCB1c2UgQFdNLk1XLmdldFRpdGxlRnJvbVdpa2lVcmwoZGVjb2RlVVJJKHVybCkpIGJlY2F1c2VcbiAgICAgICAgICAgICMgaXQgd291bGRuJ3QgZGVjb2RlIHNvbWUgY2hhcmFjdGVycyBsaWtlIGNvbG9ucywgd2hpY2ggYXJlXG4gICAgICAgICAgICAjIHJlcXVpcmVkIHRvIGJlIGRlY29kZWQgaW5zdGVhZCB3aGVuIG1ha2luZyBhbiBBUEkgY2FsbFxuICAgICAgICAgICAgcXVlcnlUaXRsZSA9IGRlY29kZVVSSUNvbXBvbmVudChAV00uTVcuZ2V0VGl0bGVGcm9tV2lraVVybCh1cmwpKVxuXG4gICAgICAgICAgICBpZiBxdWVyeVRpdGxlXG4gICAgICAgICAgICAgICAgb3JpZ1RhZyA9IGxpbmsub3JpZ1RhZ1xuICAgICAgICAgICAgICAgIHRpdGxlID0gbGluay50aXRsZVxuXG4gICAgICAgICAgICAgICAgIyBJZiB0aGlzIGlzIHRoZSBmaXJzdCBwcm9jZXNzZWQgcGFnZSwgaXQncyBsb2NhbCBmb3Igc3VyZSwgc29cbiAgICAgICAgICAgICAgICAjICAgcXVlcnkgaXRzIGxpbmtzIGluIGFueSBjYXNlLiBUaGlzIGUuZy4gcHJldmVudHMgdGhlXG4gICAgICAgICAgICAgICAgIyAgIGFwcGxpY2F0aW9uIGZyb20gY3Jhc2hpbmcgaW4gY2FzZSB0aGUgbG9jYWwgcGFnZSBpcyBpbiBhXG4gICAgICAgICAgICAgICAgIyAgIGxhbmd1YWdlIHdob3NlIGxhbmd1YWdlIHRhZyBpcyBub3QgaW4gdGhlIHdoaXRlIGxpc3RcbiAgICAgICAgICAgICAgICAjIHRhZyBpcyBhbHJlYWR5IGxvd2VyLWNhc2VkXG4gICAgICAgICAgICAgICAgaWYgZmlyc3RQYWdlIG9yIHdoaXRlbGlzdC5pbmRleE9mKHRhZykgPiAtMVxuICAgICAgICAgICAgICAgICAgICBAV00uTG9nLmxvZ0luZm8oXCJSZWFkaW5nIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQFdNLkxvZy5saW5rVG9QYWdlKHVybCwgXCJbW1wiICsgb3JpZ1RhZyArIFwiOlwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGUgKyBcIl1dXCIpICsgXCIgLi4uXCIpXG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5xdWVyeUxpbmtzKFxuICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnlUaXRsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3VwcG9ydGVkTGFuZ3MsXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGl0ZWxpc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICBmaXJzdFBhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBAV00uSW50ZXJsYW5ndWFnZS5fY29sbGVjdExpbmtzQ29udGludWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBbdXJsLCB0YWcsIG9yaWdUYWcsIHZpc2l0ZWRsaW5rcywgbmV3bGlua3MsIGNhbGxFbmQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxBcmdzXVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBAV00uSW50ZXJsYW5ndWFnZS5fY29sbGVjdExpbmtzQ29udGludWUoXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1cHBvcnRlZExhbmdzLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpdGVsaXN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3RQYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ25vdGlud2hpdGVsaXN0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBbdXJsLCB0YWcsIG9yaWdUYWcsIHZpc2l0ZWRsaW5rcywgbmV3bGlua3MsIGNhbGxFbmQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxBcmdzXVxuICAgICAgICAgICAgICAgICAgICApXG5cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBAV00uTG9nLmxvZ1dhcm5pbmcoXCJDYW5ub3QgZXh0cmFjdCB0aGUgcGFnZSB0aXRsZSBmcm9tIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBAV00uTG9nLmxpbmtUb1BhZ2UodXJsLCBkZWNvZGVVUkkodXJsKSkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLCByZW1vdmluZyBpdCBpZiBpdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhcyBsaW5rZWQgZnJvbSB0aGUgcHJvY2Vzc2VkIGFydGljbGVcIilcbiAgICAgICAgICAgICAgICBAV00uSW50ZXJsYW5ndWFnZS5jb2xsZWN0TGlua3MoXG4gICAgICAgICAgICAgICAgICAgIHZpc2l0ZWRsaW5rcyxcbiAgICAgICAgICAgICAgICAgICAgbmV3bGlua3MsXG4gICAgICAgICAgICAgICAgICAgIHN1cHBvcnRlZExhbmdzLFxuICAgICAgICAgICAgICAgICAgICB3aGl0ZWxpc3QsXG4gICAgICAgICAgICAgICAgICAgIGZpcnN0UGFnZSxcbiAgICAgICAgICAgICAgICAgICAgY2FsbEVuZCxcbiAgICAgICAgICAgICAgICAgICAgY2FsbEFyZ3NcbiAgICAgICAgICAgICAgICApXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGNhbGxFbmQodmlzaXRlZGxpbmtzLCBjYWxsQXJncylcblxuICAgIF9jb2xsZWN0TGlua3NDb250aW51ZTogKHRpdGxlLCBzdXBwb3J0ZWRMYW5ncyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpdGVsaXN0LCBmaXJzdFBhZ2UsIGVycm9yLCBsYW5nbGlua3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl3bWFwLCBzb3VyY2UsIHRpbWVzdGFtcCwgZWRpdHRva2VuLCBhcmdzKSA9PlxuICAgICAgICB1cmwgPSBhcmdzWzBdXG4gICAgICAgIHRhZyA9IGFyZ3NbMV1cbiAgICAgICAgb3JpZ1RhZyA9IGFyZ3NbMl1cbiAgICAgICAgdmlzaXRlZGxpbmtzID0gYXJnc1szXVxuICAgICAgICBuZXdsaW5rcyA9IGFyZ3NbNF1cbiAgICAgICAgY2FsbEVuZCA9IGFyZ3NbNV1cbiAgICAgICAgY2FsbEFyZ3MgPSBhcmdzWzZdXG5cbiAgICAgICAgaWYgZXJyb3IgPT0gJ25vbmV4aXN0aW5nJ1xuICAgICAgICAgICAgQFdNLkxvZy5sb2dXYXJuaW5nKEBXTS5Mb2cubGlua1RvUGFnZSh1cmwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiW1tcIiArIG9yaWdUYWcgKyBcIjpcIiArIHRpdGxlICsgXCJdXVwiKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiIHNlZW1zIHRvIHBvaW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvIGEgbm9uLWV4aXN0aW5nIGFydGljbGU6IHJlbW92aW5nIGl0IGlmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0IHdhcyBsaW5rZWQgZnJvbSB0aGUgcHJvY2Vzc2VkIGFydGljbGVcIilcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgaWYgZXJyb3IgPT0gJ3Vuc29sdmVkcmVkaXJlY3QnXG4gICAgICAgICAgICAgICAgQFdNLkxvZy5sb2dXYXJuaW5nKEBXTS5Mb2cubGlua1RvUGFnZSh1cmwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiW1tcIiArIG9yaWdUYWcgKyBcIjpcIiArIHRpdGxlICsgXCJdXVwiKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiIHdpbGwgbm90IGJlIGNoZWNrZWQgYmVjYXVzZSBpdCBwb2ludHMgdG9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW4gZXh0ZXJuYWwgcmVkaXJlY3RcIilcbiAgICAgICAgICAgIGVsc2UgaWYgZXJyb3IgPT0gJ3Vua25vd24nXG4gICAgICAgICAgICAgICAgQFdNLkxvZy5sb2dXYXJuaW5nKEBXTS5Mb2cubGlua1RvUGFnZSh1cmwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiW1tcIiArIG9yaWdUYWcgKyBcIjpcIiArIHRpdGxlICsgXCJdXVwiKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiIHdpbGwgbm90IGJlIGNoZWNrZWQgYmVjYXVzZSBvZiBhblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bnNwZWNpZmllZCBwcm9ibGVtXCIpXG4gICAgICAgICAgICBlbHNlIGlmIGVycm9yID09ICdub3RpbndoaXRlbGlzdCdcbiAgICAgICAgICAgICAgICBAV00uTG9nLmxvZ1dhcm5pbmcoQFdNLkxvZy5saW5rVG9QYWdlKHVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJbW1wiICsgb3JpZ1RhZyArIFwiOlwiICsgdGl0bGUgKyBcIl1dXCIpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgd2lsbCBub3QgYmUgY2hlY2tlZCBiZWNhdXNlIFwiICsgdGFnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgaXMgbm90IGluY2x1ZGVkIGluIHRoZSB3aGl0ZWxpc3QgZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbiB0aGUgY29uZmlndXJhdGlvblwiKVxuXG4gICAgICAgICAgICB2aXNpdGVkbGlua3NbdGFnXSA9IEBXTS5JbnRlcmxhbmd1YWdlLmNyZWF0ZVZpc2l0ZWRMaW5rKG9yaWdUYWcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlLCB1cmwsIGl3bWFwLCBzb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcCwgZWRpdHRva2VuLCBsYW5nbGlua3MpXG5cbiAgICAgICAgICAgIGZvciBsaW5rIGluIGxhbmdsaW5rc1xuICAgICAgICAgICAgICAgIG5saW5rID0gbmV3bGlua3NbbGluay5sYW5nLnRvTG93ZXJDYXNlKCldXG4gICAgICAgICAgICAgICAgdmxpbmsgPSB2aXNpdGVkbGlua3NbbGluay5sYW5nLnRvTG93ZXJDYXNlKCldXG5cbiAgICAgICAgICAgICAgICBpZiBub3QgdmxpbmsgYW5kIG5vdCBubGlua1xuICAgICAgICAgICAgICAgICAgICBuZXdsaW5rc1tsaW5rLmxhbmcudG9Mb3dlckNhc2UoKV0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQFdNLkludGVybGFuZ3VhZ2UuY3JlYXRlTmV3TGluayhsaW5rLmxhbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmsudGl0bGUsIGxpbmsudXJsKVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgdmxpbmsgYW5kIHZsaW5rLnVybCAhPSBsaW5rLnVybFxuICAgICAgICAgICAgICAgICAgICAjIEp1c3QgaWdub3JlIGFueSBjb25mbGljdGluZyBsaW5rcyBhbmQgd2FybiB0aGUgdXNlcjpcbiAgICAgICAgICAgICAgICAgICAgIyBpZiBpdCdzIGEgcmVhbCBjb25mbGljdCwgdGhlIHVzZXIgd2lsbCBpbnZlc3RpZ2F0ZSBpdCxcbiAgICAgICAgICAgICAgICAgICAgIyBvdGhlcndpc2UgdGhlIHVzZXIgd2lsbCBpZ25vcmUgaXRcbiAgICAgICAgICAgICAgICAgICAgQFdNLkxvZy5sb2dXYXJuaW5nKFwiUG9zc2libHkgY29uZmxpY3RpbmcgaW50ZXJsYW5ndWFnZVxuICAgICAgICAgICAgICAgICAgICAgICAgbGlua3M6IFwiICsgQFdNLkxvZy5saW5rVG9QYWdlKGxpbmsudXJsLCBcIltbXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgbGluay5sYW5nICsgXCI6XCIgKyBsaW5rLnRpdGxlICsgXCJdXVwiKSArIFwiIGFuZCBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICBAV00uTG9nLmxpbmtUb1BhZ2UodmxpbmsudXJsLCBcIltbXCIgKyBsaW5rLmxhbmcgKyBcIjpcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICB2aXNpdGVkbGlua3NbbGluay5sYW5nLnRvTG93ZXJDYXNlKCldLnRpdGxlICsgXCJdXVwiKSlcblxuICAgICAgICAgICAgICAgIGVsc2UgaWYgbmxpbmsgYW5kIG5saW5rLnVybCAhPSBsaW5rLnVybFxuICAgICAgICAgICAgICAgICAgICAjIEp1c3QgaWdub3JlIGFueSBjb25mbGljdGluZyBsaW5rcyBhbmQgd2FybiB0aGUgdXNlcjpcbiAgICAgICAgICAgICAgICAgICAgIyBpZiBpdCdzIGEgcmVhbCBjb25mbGljdCwgdGhlIHVzZXIgd2lsbCBpbnZlc3RpZ2F0ZSBpdCxcbiAgICAgICAgICAgICAgICAgICAgIyBvdGhlcndpc2UgdGhlIHVzZXIgd2lsbCBpZ25vcmUgaXRcbiAgICAgICAgICAgICAgICAgICAgQFdNLkxvZy5sb2dXYXJuaW5nKFwiUG9zc2libHkgY29uZmxpY3RpbmcgaW50ZXJsYW5ndWFnZVxuICAgICAgICAgICAgICAgICAgICAgICAgbGlua3M6IFwiICsgQFdNLkxvZy5saW5rVG9QYWdlKGxpbmsudXJsLCBcIltbXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgbGluay5sYW5nICsgXCI6XCIgKyBsaW5rLnRpdGxlICsgXCJdXVwiKSArIFwiIGFuZCBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICBAV00uTG9nLmxpbmtUb1BhZ2UobmxpbmsudXJsLCBcIltbXCIgKyBsaW5rLmxhbmcgKyBcIjpcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdsaW5rc1tsaW5rLmxhbmcudG9Mb3dlckNhc2UoKV0udGl0bGUgKyBcIl1dXCIpKVxuXG4gICAgICAgIEBXTS5JbnRlcmxhbmd1YWdlLmNvbGxlY3RMaW5rcyhcbiAgICAgICAgICAgIHZpc2l0ZWRsaW5rcyxcbiAgICAgICAgICAgIG5ld2xpbmtzLFxuICAgICAgICAgICAgc3VwcG9ydGVkTGFuZ3MsXG4gICAgICAgICAgICB3aGl0ZWxpc3QsXG4gICAgICAgICAgICBmaXJzdFBhZ2UsXG4gICAgICAgICAgICBjYWxsRW5kLFxuICAgICAgICAgICAgY2FsbEFyZ3NcbiAgICAgICAgKVxuXG4gICAgdXBkYXRlTGlua3M6IChsYW5nLCB1cmwsIGl3bWFwLCBzb3VyY2UsIG9sZGxpbmtzLCBuZXdsaW5rcykgPT5cbiAgICAgICAgbGFuZyA9IGxhbmcudG9Mb3dlckNhc2UoKVxuICAgICAgICBsaW5rTGlzdCA9IFtdXG5cbiAgICAgICAgZm9yIHRhZyBvZiBuZXdsaW5rc1xuICAgICAgICAgICAgaWYgdGFnICE9IGxhbmdcbiAgICAgICAgICAgICAgICBsaW5rID0gbmV3bGlua3NbdGFnXVxuICAgICAgICAgICAgICAgIHRhZ0ZvdW5kID0gZmFsc2VcblxuICAgICAgICAgICAgICAgICMgTmV3IGxpbmtzIHRoYXQgd2VyZSBub3QgaW4gdGhlIHdoaXRlIGxpc3Qgd2lsbCBoYXZlIHRoZVxuICAgICAgICAgICAgICAgICMgXCJpd21hcFwiIGF0dHJpYnV0ZSBmYWxzZSwgXCJ0aW1lc3RhbXBcIiBhbmQgXCJlZGl0dG9rZW5cIiBudWxsXG4gICAgICAgICAgICAgICAgIyBhbmQgXCJsaW5rc1wiIGFzIGFuIGVtcHR5IGFycmF5XG4gICAgICAgICAgICAgICAgIyBOb3RlIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gJ2l3bWFwJyBhbmQgJ2xpbmsuaXdtYXAnXG4gICAgICAgICAgICAgICAgZm9yIGl3IGluIGl3bWFwXG4gICAgICAgICAgICAgICAgICAgIGlmIGl3LnByZWZpeC50b0xvd2VyQ2FzZSgpID09IHRhZy50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rTGlzdC5wdXNoKFwiW1tcIiArIGxpbmsub3JpZ1RhZyArIFwiOlwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluay50aXRsZSArIFwiXV1cIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZ0ZvdW5kID0gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcblxuICAgICAgICAgICAgICAgIGlmIG5vdCB0YWdGb3VuZFxuICAgICAgICAgICAgICAgICAgICBAV00uTG9nLmxvZ1dhcm5pbmcodGFnICsgXCIgaW50ZXJsYW5ndWFnZSBsaW5rcyBhcmUgbm90XG4gICAgICAgICAgICAgICAgICAgICAgICBzdXBwb3J0ZWQgaW4gXCIgKyBAV00uTG9nLmxpbmtUb1BhZ2UodXJsLCBcIltbXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgbGluay5vcmlnVGFnICsgXCI6XCIgKyBsaW5rLnRpdGxlICsgXCJdXVwiKSArXG4gICAgICAgICAgICAgICAgICAgICAgICBcIiAsIGlnbm9yaW5nIHRoZW1cIilcblxuICAgICAgICBsaW5rTGlzdC5zb3J0KFxuICAgICAgICAgICAgKGEsIGIpIC0+XG4gICAgICAgICAgICAgICAgIyBTb3J0aW5nIGlzIGNhc2Ugc2Vuc2l0aXZlIGJ5IGRlZmF1bHRcbiAgICAgICAgICAgICAgICBpZiBhLnRvTG93ZXJDYXNlKCkgPiBiLnRvTG93ZXJDYXNlKClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDFcbiAgICAgICAgICAgICAgICBpZiBiLnRvTG93ZXJDYXNlKCkgPiBhLnRvTG93ZXJDYXNlKClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xXG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMFxuICAgICAgICApXG5cbiAgICAgICAgY2xlYW5UZXh0ID0gXCJcIlxuICAgICAgICB0ZXh0SWQgPSAwXG5cbiAgICAgICAgZm9yIGxpbmsgaW4gb2xkbGlua3NcbiAgICAgICAgICAgIGNsZWFuVGV4dCArPSBzb3VyY2Uuc3Vic3RyaW5nKHRleHRJZCwgbGluay5pbmRleClcbiAgICAgICAgICAgIHRleHRJZCA9IGxpbmsuaW5kZXggKyBsaW5rLmxlbmd0aFxuXG4gICAgICAgIGNsZWFuVGV4dCArPSBzb3VyY2Uuc3Vic3RyaW5nKHRleHRJZClcblxuICAgICAgICBpZiBvbGRsaW5rcy5sZW5ndGhcbiAgICAgICAgICAgICMgSW5zZXJ0IHRoZSBuZXcgbGlua3MgYXQgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBwcmV2aW91cyBsaW5rXG4gICAgICAgICAgICBmaXJzdExpbmsgPSBvbGRsaW5rc1swXS5pbmRleFxuICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaXJzdExpbmsgPSAwXG5cbiAgICAgICAgcGFydHMgPSBbXVxuICAgICAgICAjIERvIG5vdCBhZGQgZW1wdHkgc3RyaW5ncyB0byBwYXJ0cywgb3RoZXJ3aXNlIHdoZW4gaXQncyBqb2luZWRcbiAgICAgICAgIyAgIHVubmVjZXNzYXJ5IGxpbmUgYnJlYWtzIHdpbGwgYmUgYWRkZWRcblxuICAgICAgICBoZWFkID0gY2xlYW5UZXh0LnN1YnN0cmluZygwLCBmaXJzdExpbmspLnRyaW0oKVxuXG4gICAgICAgIGlmIGhlYWRcbiAgICAgICAgICAgIHBhcnRzLnB1c2goaGVhZClcblxuICAgICAgICBsaW5rcyA9IGxpbmtMaXN0LmpvaW4oXCJcXG5cIilcblxuICAgICAgICBpZiBsaW5rc1xuICAgICAgICAgICAgcGFydHMucHVzaChsaW5rcylcblxuICAgICAgICBib2R5ID0gY2xlYW5UZXh0LnN1YnN0cihmaXJzdExpbmspLnRyaW0oKVxuXG4gICAgICAgIGlmIGJvZHlcbiAgICAgICAgICAgIHBhcnRzLnB1c2goYm9keSlcblxuICAgICAgICAjIE1ha2Ugc3VyZSB0byBwcmVzZXJ2ZSB0aGUgb3JpZ2luYWwgd2hpdGUgc3BhY2UgYXQgdGhlIGVuZCwgb3RoZXJ3aXNlXG4gICAgICAgICMgICB0aGUgZmluYWwgKG5ld1RleHQgIT0gc291cmNlKSBtYXkgcmV0dXJuIHRydWUgZXZlbiB3aGVuIG5vIGFjdHVhbFxuICAgICAgICAjICAgY2hhbmdlIGhhcyBiZWVuIG1hZGVcbiAgICAgICAgIyBOb3RlIHRoYXQgL1xccyskLyB3b3VsZCByZXR1cm4gbnVsbCBpbiB0aGUgYWJzZW5jZSBvZiB0cmFpbGluZ1xuICAgICAgICAjICAgd2hpdGVzcGFjZSwgc28gYSBmdXJ0aGVyIGNoZWNrIHNob3VsZCBiZSBtYWRlLCB3aGlsZSAvXFxzKiQvXG4gICAgICAgICMgICBzYWZlbHkgcmV0dXJucyBhbiBlbXB0eSBzdHJpbmcgaW4gdGhhdCBjYXNlXG4gICAgICAgIHRyYWlsd3MgPSAvXFxzKiQvXG5cbiAgICAgICAgcmV0dXJuIHBhcnRzLmpvaW4oXCJcXG5cIikgKyB0cmFpbHdzLmV4ZWMoc291cmNlKVxuIiwiIyBXaWtpIE1vbmtleSAtIE1lZGlhV2lraSBib3QgYW5kIGVkaXRvci1hc3Npc3RhbnQgdXNlciBzY3JpcHRcbiMgQ29weXJpZ2h0IChDKSAyMDExIERhcmlvIEdpb3Zhbm5ldHRpIDxkZXZAZGFyaW9naW92YW5uZXR0aS5uZXQ+XG4jXG4jIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFdpa2kgTW9ua2V5LlxuI1xuIyBXaWtpIE1vbmtleSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4jIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4jIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4jIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4jXG4jIFdpa2kgTW9ua2V5IGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4jIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4jIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiMgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbiNcbiMgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiMgYWxvbmcgd2l0aCBXaWtpIE1vbmtleS4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cblxue2pzc30gPSByZXF1aXJlKCcuL2xpYnMnKVxuU3RyID0gcmVxdWlyZSgnQGt5bmlrb3MvbWlzYy9kaXN0L1N0cicpXG5cblxuY2xhc3MgbW9kdWxlLmV4cG9ydHNcbiAgICBjb25zdHJ1Y3RvcjogKEBXTSkgLT5cbiAgICAgICAgQF9jdXJyZW50SW5mb0Rpc3BsYXlTdGF0ZSA9IHRydWVcblxuICAgICAgICAjIFRoZSAud2FybmluZyBhbmQgLmVycm9yIGNsYXNzZXMgYXJlIGFscmVhZHkgdXNlZCBieVxuICAgICAgICAjIE1lZGlhV2lraSwgd2l0aG91dCBhc3NvY2lhdGluZyB0aGVtIHdpdGggYW4gaWQgYW5kIGEgdGFnXG4gICAgICAgIHN0eWxlcyA9XG4gICAgICAgICAgICBsb2c6XG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAnMTBlbSdcbiAgICAgICAgICAgICAgICBib3JkZXI6ICcycHggc29saWQgIzA3YidcbiAgICAgICAgICAgICAgICBwYWRkaW5nOiAnMC41ZW0nXG4gICAgICAgICAgICAgICAgb3ZlcmZsb3c6ICdhdXRvJ1xuICAgICAgICAgICAgICAgIHJlc2l6ZTogJ3ZlcnRpY2FsJ1xuICAgICAgICAgICAgICAgICdiYWNrZ3JvdW5kLWNvbG9yJzogJyMxMTEnXG5cbiAgICAgICAgICAgICAgICAnJiBwLnRpbWVzdGFtcCwgJiBwLm1lc3NhZ2UnOlxuICAgICAgICAgICAgICAgICAgICBib3JkZXI6ICdub25lJ1xuICAgICAgICAgICAgICAgICAgICBwYWRkaW5nOiAwXG4gICAgICAgICAgICAgICAgICAgICdmb250LWZhbWlseSc6ICdtb25vc3BhY2UnXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiAnI2VlZSdcblxuICAgICAgICAgICAgICAgICcmIHAudGltZXN0YW1wJzpcbiAgICAgICAgICAgICAgICAgICAgbWFyZ2luOiAnMCAxZW0gMCAwJ1xuICAgICAgICAgICAgICAgICAgICAnd2hpdGUtc3BhY2UnOiAnbm93cmFwJ1xuXG4gICAgICAgICAgICAgICAgJyYgcC5tZXNzYWdlJzpcbiAgICAgICAgICAgICAgICAgICAgbWFyZ2luOiAwXG5cbiAgICAgICAgICAgICAgICAnJiBkaXYubWRlYnVnLCAmIGRpdi5taW5mbywgJiBkaXYubXdhcm5pbmcsICYgZGl2Lm1lcnJvcic6XG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6ICdmbGV4J1xuXG4gICAgICAgICAgICAgICAgJyYgZGl2Lm1oaWRkZW4nOlxuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiAnbm9uZSdcblxuICAgICAgICAgICAgICAgICcmIGRpdi5tanNvbic6XG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6ICdub25lJ1xuXG4gICAgICAgICAgICAgICAgJyYgZGl2Lm1kZWJ1ZyBwLm1lc3NhZ2UnOlxuICAgICAgICAgICAgICAgICAgICBjb2xvcjogJ2N5YW4nXG5cbiAgICAgICAgICAgICAgICAnJiBkaXYubXdhcm5pbmcgcC5tZXNzYWdlJzpcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6ICdnb2xkJ1xuXG4gICAgICAgICAgICAgICAgJyYgZGl2Lm1lcnJvciBwLm1lc3NhZ2UnOlxuICAgICAgICAgICAgICAgICAgICAgY29sb3I6ICdyZWQnXG5cbiAgICAgICAgICAgICAgICAnJiBhJzpcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6ICdpbmhlcml0J1xuICAgICAgICAgICAgICAgICAgICAndGV4dC1kZWNvcmF0aW9uJzogJ3VuZGVybGluZSdcblxuICAgICAgICB7Y2xhc3Nlc30gPSBqc3MuY3JlYXRlU3R5bGVTaGVldChcbiAgICAgICAgICAgIHN0eWxlcywge2NsYXNzTmFtZVByZWZpeDogXCJXaWtpTW9ua2V5LVwifSkuYXR0YWNoKClcbiAgICAgICAgQGNsYXNzZXMgPSBjbGFzc2VzXG5cbiAgICBfbWFrZUxvZ0FyZWE6IC0+XG4gICAgICAgIGxvZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgICAgIGxvZy5pZCA9ICdXaWtpTW9ua2V5TG9nJ1xuXG4gICAgICAgIHBhciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3AnKVxuICAgICAgICBwYXIuYXBwZW5kQ2hpbGQoQG1ha2VGaWx0ZXJMaW5rKCkpXG4gICAgICAgIHBhci5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnICcpKVxuICAgICAgICBwYXIuYXBwZW5kQ2hpbGQoQG1ha2VTYXZlTGluaygpKVxuICAgICAgICBsb2cuYXBwZW5kQ2hpbGQocGFyKVxuXG4gICAgICAgIEBsb2dhcmVhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICAgICAgQGxvZ2FyZWEuY2xhc3NOYW1lID0gQGNsYXNzZXMubG9nXG4gICAgICAgIGxvZy5hcHBlbmRDaGlsZChAbG9nYXJlYSlcblxuICAgICAgICByZXR1cm4gbG9nXG5cbiAgICBtYWtlRmlsdGVyTGluazogLT5cbiAgICAgICAgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKVxuICAgICAgICBsaW5rLmhyZWYgPSAnI1dpa2lNb25rZXknXG4gICAgICAgIGxpbmsuaW5uZXJIVE1MID0gQGNvbXB1dGVGaWx0ZXJMaW5rQW5jaG9yKClcblxuICAgICAgICBsaW5rLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoZXZlbnQpID0+XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgICAgICAjIENoYW5nZSBfY3VycmVudEluZm9EaXNwbGF5U3RhdGUgKmJlZm9yZSogdGhlIGxvb3AsIHRvIHByZXZlbnRcbiAgICAgICAgICAgICMgcmFjZSBidWdzXG4gICAgICAgICAgICBAX2N1cnJlbnRJbmZvRGlzcGxheVN0YXRlID0gbm90IEBfY3VycmVudEluZm9EaXNwbGF5U3RhdGVcbiAgICAgICAgICAgIGxpbmsuaW5uZXJIVE1MID0gQGNvbXB1dGVGaWx0ZXJMaW5rQW5jaG9yKClcblxuICAgICAgICAgICAgbXNncyA9IEBsb2dhcmVhLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ21pbmZvJylcblxuICAgICAgICAgICAgZm9yIG1zZyBpbiBtc2dzXG4gICAgICAgICAgICAgICAgbXNnLnN0eWxlLmRpc3BsYXkgPSBAY29tcHV0ZUluZm9EaXNwbGF5U3R5bGUoKVxuXG4gICAgICAgICAgICBAc2Nyb2xsVG9Cb3R0b20oKVxuICAgICAgICAsIGZhbHNlKVxuXG4gICAgICAgIHJldHVybiBsaW5rXG5cbiAgICBtYWtlU2F2ZUxpbms6IC0+XG4gICAgICAgIGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJylcbiAgICAgICAgbGluay5ocmVmID0gJyMnXG4gICAgICAgIGxpbmsuZG93bmxvYWQgPSAnV2lraU1vbmtleS5sb2cnXG4gICAgICAgIGxpbmsuaW5uZXJIVE1MID0gJ1tzYXZlIGxvZ10nXG4gICAgICAgIGxpbmsuaWQgPSAnV2lraU1vbmtleUxvZy1TYXZlJ1xuXG4gICAgICAgIGxpbmsuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsID0+XG4gICAgICAgICAgICBsaW5rLmhyZWYgPSAnZGF0YTp0ZXh0L3BsYWluO2NoYXJzZXQ9dXRmLTgsJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoQGNvbXBvc2VTYXZlTG9nVGV4dCgpKVxuICAgICAgICAgICAgbGluay5kb3dubG9hZCA9IEBjb21wb3NlU2F2ZUxvZ0ZpbGVuYW1lKClcbiAgICAgICAgLCBmYWxzZSlcblxuICAgICAgICByZXR1cm4gbGlua1xuXG4gICAgY2xhc3Nlc1RvTGV2ZWxzID1cbiAgICAgICAgJ21oaWRkZW4nOiAnSEROJ1xuICAgICAgICAnbWpzb24nOiAnSlNOJ1xuICAgICAgICAnbWRlYnVnJzogJ0RCRydcbiAgICAgICAgJ21pbmZvJzogJ0lORidcbiAgICAgICAgJ213YXJuaW5nJzogJ1dSTidcbiAgICAgICAgJ21lcnJvcic6ICdFUlInXG5cbiAgICBjb21wb3NlU2F2ZUxvZ1RleHQ6IC0+XG4gICAgICAgIGRpdnMgPSBAbG9nYXJlYS5nZXRFbGVtZW50c0J5VGFnTmFtZSgnZGl2JylcbiAgICAgICAgdGV4dCA9ICcnXG5cbiAgICAgICAgZm9yIGRpdiBpbiBkaXZzXG4gICAgICAgICAgICBwcyA9IGRpdi5nZXRFbGVtZW50c0J5VGFnTmFtZSgncCcpXG4gICAgICAgICAgICB0c3RhbXAgPSBwc1swXS5pbm5lckhUTUxcbiAgICAgICAgICAgIGxldmVsID0gY2xhc3Nlc1RvTGV2ZWxzW2Rpdi5jbGFzc05hbWVdXG4gICAgICAgICAgICBtZXNzYWdlID0gcHNbMV0uaW5uZXJIVE1MXG5cbiAgICAgICAgICAgIHRleHQgKz0gdHN0YW1wICsgJ1xcdCcgKyBsZXZlbCArICdcXHQnICsgbWVzc2FnZSArICdcXG4nXG5cbiAgICAgICAgcmV0dXJuIHRleHRcblxuICAgIGNvbXBvc2VTYXZlTG9nRmlsZW5hbWU6IC0+XG4gICAgICAgIGRhdGUgPSBuZXcgRGF0ZSgpXG4gICAgICAgIHJldHVybiAnV2lraU1vbmtleS0nICsgZGF0ZS5nZXRGdWxsWWVhcigpICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFN0ci5wYWRMZWZ0KFN0cmluZyhkYXRlLmdldE1vbnRoKCkgKyAxKSwgJzAnLCAyKSArXG4gICAgICAgICAgICAgICAgICAgICAgICBTdHIucGFkTGVmdChTdHJpbmcoZGF0ZS5nZXREYXRlKCkpLCAnMCcsIDIpICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFN0ci5wYWRMZWZ0KFN0cmluZyhkYXRlLmdldEhvdXJzKCkpLCAnMCcsIDIpICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFN0ci5wYWRMZWZ0KFN0cmluZyhkYXRlLmdldE1pbnV0ZXMoKSksICcwJywgMikgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJy5sb2cnXG5cbiAgICBjb21wdXRlSW5mb0Rpc3BsYXlTdHlsZTogLT5cbiAgICAgICAgcmV0dXJuIGlmIEBfY3VycmVudEluZm9EaXNwbGF5U3RhdGUgdGhlbiAnZmxleCcgZWxzZSAnbm9uZSdcblxuICAgIGNvbXB1dGVGaWx0ZXJMaW5rQW5jaG9yOiAtPlxuICAgICAgICByZXR1cm4gaWYgQF9jdXJyZW50SW5mb0Rpc3BsYXlTdGF0ZSB0aGVuICdbaGlkZSBpbmZvIG1lc3NhZ2VzXScgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnW3Nob3cgaW5mbyBtZXNzYWdlc10nXG5cbiAgICBzY3JvbGxUb0JvdHRvbTogLT5cbiAgICAgICAgQGxvZ2FyZWEuc2Nyb2xsVG9wID0gQGxvZ2FyZWEuc2Nyb2xsSGVpZ2h0IC0gQGxvZ2FyZWEuY2xpZW50SGVpZ2h0XG5cbiAgICBhcHBlbmRNZXNzYWdlOiAodGV4dCwgdHlwZSkgLT5cbiAgICAgICAgdHN0YW1wID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncCcpXG4gICAgICAgIHRzdGFtcC5jbGFzc05hbWUgPSAndGltZXN0YW1wJ1xuICAgICAgICBub3cgPSBuZXcgRGF0ZSgpXG4gICAgICAgIHRzdGFtcC5pbm5lckhUTUwgPSBub3cudG9Mb2NhbGVUaW1lU3RyaW5nKClcblxuICAgICAgICBtc2cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwJylcbiAgICAgICAgbXNnLmNsYXNzTmFtZSA9ICdtZXNzYWdlJ1xuICAgICAgICAjIERvIG5vdCBhbGxvdyB0aGUgZW1wdHkgc3RyaW5nLCBvdGhlcndpc2UgdGhlIHJlc3VsdGluZyBodG1sIGVsZW1lbnRcbiAgICAgICAgIyBtYXkgbm90IGJlIHJlbmRlcmVkIGJ5IHRoZSBicm93c2VyXG4gICAgICAgIG1zZy5pbm5lckhUTUwgPSBpZiB0ZXh0IHRoZW4gdGV4dCBlbHNlIFwiIFwiXG5cbiAgICAgICAgbGluZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgICAgIGxpbmUuYXBwZW5kQ2hpbGQodHN0YW1wKVxuICAgICAgICBsaW5lLmFwcGVuZENoaWxkKG1zZylcbiAgICAgICAgbGluZS5jbGFzc05hbWUgPSB0eXBlXG5cbiAgICAgICAgaWYgdHlwZSA9PSAnbWluZm8nXG4gICAgICAgICAgICBsaW5lLnN0eWxlLmRpc3BsYXkgPSBAY29tcHV0ZUluZm9EaXNwbGF5U3R5bGUoKVxuXG4gICAgICAgICMgVGhpcyB0ZXN0IG11c3QgYmUgZG9uZSAqYmVmb3JlKiBhcHBlbmRpbmcgdGhlIG5ldyBsaW5lXG4gICAgICAgIHRlc3QgPSBAbG9nYXJlYS5zY3JvbGxUb3AgKyBAbG9nYXJlYS5jbGllbnRIZWlnaHQgPT0gXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQGxvZ2FyZWEuc2Nyb2xsSGVpZ2h0XG5cbiAgICAgICAgQGxvZ2FyZWEuYXBwZW5kQ2hpbGQobGluZSlcblxuICAgICAgICBpZiB0ZXN0XG4gICAgICAgICAgICBAc2Nyb2xsVG9Cb3R0b20oKVxuXG4gICAgbG9nSGlkZGVuOiAodGV4dCkgLT5cbiAgICAgICAgQGFwcGVuZE1lc3NhZ2UodGV4dCwgJ21oaWRkZW4nKVxuXG4gICAgbG9nSnNvbjogKGNvbXBvbmVudCwgZGF0YSkgLT5cbiAgICAgICAgdGV4dCA9IEpTT04uc3RyaW5naWZ5KHtcImNvbXBvbmVudFwiOiBjb21wb25lbnQsIFwiZGF0YVwiOiBkYXRhfSlcbiAgICAgICAgQGFwcGVuZE1lc3NhZ2UodGV4dCwgJ21qc29uJylcblxuICAgIGxvZ0RlYnVnOiAodGV4dCkgLT5cbiAgICAgICAgQGFwcGVuZE1lc3NhZ2UodGV4dCwgJ21kZWJ1ZycpXG5cbiAgICBsb2dJbmZvOiAodGV4dCkgLT5cbiAgICAgICAgQGFwcGVuZE1lc3NhZ2UodGV4dCwgJ21pbmZvJylcblxuICAgIGxvZ1dhcm5pbmc6ICh0ZXh0KSAtPlxuICAgICAgICBAYXBwZW5kTWVzc2FnZSh0ZXh0LCAnbXdhcm5pbmcnKVxuXG4gICAgbG9nRXJyb3I6ICh0ZXh0KSAtPlxuICAgICAgICBAYXBwZW5kTWVzc2FnZSh0ZXh0LCAnbWVycm9yJylcblxuICAgIGxpbmtUb1BhZ2U6ICh1cmwsIGFuY2hvcikgLT5cbiAgICAgICAgIyBNdXN0IHJldHVybiBhIHN0cmluZywgbm90IGEgRE9NIGVsZW1lbnRcbiAgICAgICAgcmV0dXJuIFwiPGEgaHJlZj1cXFwiXCIgKyB1cmwgKyBcIlxcXCI+XCIgKyBhbmNob3IgKyBcIjwvYT5cIlxuXG4gICAgbGlua1RvV2lraVBhZ2U6ICh0aXRsZSwgYW5jaG9yKSAtPlxuICAgICAgICAjIE11c3QgcmV0dXJuIGEgc3RyaW5nLCBub3QgYSBET00gZWxlbWVudFxuICAgICAgICAjIFVzZSBhbiBhYnNvbHV0ZSAoZnVsbCkgVVJMIHNvIGl0IHdpbGwgYmUgdXNhYmxlIGluIHRoZSBkb3dubG9hZGFibGVcbiAgICAgICAgIyAgIHZlcnNpb24gb2YgdGhlIGxvZ1xuICAgICAgICAjIERvICpub3QqIHVzZSBlbmNvZGVVUklDb21wb25lbnQodGl0bGUpIGJlY2F1c2UgdGhlIHBhc3NlZCB0aXRsZSBtYXlcbiAgICAgICAgIyAgIGhhdmUgYSBmcmFnbWVudCBvciBhIHF1ZXJ5IHN0cmluZyB0aGF0IHdvdWxkIHRoZW4gYmUgZW5jb2RlZFxuICAgICAgICAjICAgTWVkaWFXaWtpIHNob3VsZCBiZSBhYmxlIHRvIGNvcnJlY3RseSByZXNvbHZlIHRoZSB0aXRsZSBhbnl3YXlcbiAgICAgICAgd2lraVVybHMgPSBAV00uTVcuZ2V0V2lraVVybHMoKVxuICAgICAgICByZXR1cm4gXCI8YSBocmVmPVxcXCJcIiArIHdpa2lVcmxzLnNob3J0ICsgdGl0bGUgKyBcIlxcXCI+XCIgKyBhbmNob3IgKyBcIjwvYT5cIlxuIiwiIyBXaWtpIE1vbmtleSAtIE1lZGlhV2lraSBib3QgYW5kIGVkaXRvci1hc3Npc3RhbnQgdXNlciBzY3JpcHRcbiMgQ29weXJpZ2h0IChDKSAyMDExIERhcmlvIEdpb3Zhbm5ldHRpIDxkZXZAZGFyaW9naW92YW5uZXR0aS5uZXQ+XG4jXG4jIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFdpa2kgTW9ua2V5LlxuI1xuIyBXaWtpIE1vbmtleSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4jIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4jIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4jIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4jXG4jIFdpa2kgTW9ua2V5IGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4jIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4jIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiMgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbiNcbiMgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiMgYWxvbmcgd2l0aCBXaWtpIE1vbmtleS4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cblxuSFRUUCA9IHJlcXVpcmUoJ0BreW5pa29zL21pc2MvZGlzdC9IVFRQJylcbk9iaiA9IHJlcXVpcmUoJ0BreW5pa29zL21pc2MvZGlzdC9PYmonKVxue0F9ID0gcmVxdWlyZSgnLi9saWJzJylcblxuXG5jbGFzcyBtb2R1bGUuZXhwb3J0c1xuICAgIGxvY2FsV2lraVBhdGhzID0gbnVsbFxuICAgIGxvY2FsV2lraVVybHMgPSBudWxsXG5cbiAgICBjb25zdHJ1Y3RvcjogKEBXTSkgLT5cbiAgICAgICAgQGFwaSA9IG5ldyBtdy5BcGkoKVxuXG4gICAgICAgIHdwYXRocyA9IEBfZ2V0V2lraVBhdGhzKGxvY2F0aW9uLmhyZWYpXG4gICAgICAgIGhvc3RuYW1lID0gd3BhdGhzWzBdXG5cbiAgICAgICAgQHVzZXJJbmZvID0gbnVsbFxuXG4gICAgICAgIGxvY2FsV2lraVBhdGhzID0gd3BhdGhzWzFdXG4gICAgICAgIGxvY2FsV2lraVVybHMgPSB7fVxuXG4gICAgICAgIGZvciBrZXkgb2YgbG9jYWxXaWtpUGF0aHNcbiAgICAgICAgICAgIGxvY2FsV2lraVVybHNba2V5XSA9IGhvc3RuYW1lICsgbG9jYWxXaWtpUGF0aHNba2V5XVxuXG4gICAgd2lraVBhdGhzID1cbiAgICAgICAga25vd246XG4gICAgICAgICAgICBcIl5odHRwcz86Ly9bXlxcLl0rXFwud2lraXBlZGlhXFwub3JnXCI6XG4gICAgICAgICAgICAgICAgc2hvcnQ6IFwiL3dpa2kvXCJcbiAgICAgICAgICAgICAgICBmdWxsOiBcIi93L2luZGV4LnBocFwiXG4gICAgICAgICAgICAgICAgYXBpOiBcIi93L2FwaS5waHBcIlxuICAgICAgICAgICAgXCJeaHR0cHM/Oi8vd2lraVxcLmFyY2hsaW51eFxcLm9yZ1wiOlxuICAgICAgICAgICAgICAgIHNob3J0OiBcIi9pbmRleC5waHAvXCJcbiAgICAgICAgICAgICAgICBmdWxsOiBcIi9pbmRleC5waHBcIlxuICAgICAgICAgICAgICAgIGFwaTogXCIvYXBpLnBocFwiXG4gICAgICAgICAgICBcIl5odHRwcz86Ly93aWtpXFwuYXJjaGxpbnV4XFwuZGVcIjpcbiAgICAgICAgICAgICAgICBzaG9ydDogXCIvdGl0bGUvXCJcbiAgICAgICAgICAgICAgICBmdWxsOiBcIi9pbmRleC5waHBcIlxuICAgICAgICAgICAgICAgIGFwaTogXCIvYXBpLnBocFwiXG4gICAgICAgICAgICBcIl5odHRwOi8vd2lraVxcLmFyY2hsaW51eFxcLmZyXCI6XG4gICAgICAgICAgICAgICAgc2hvcnQ6IFwiL1wiXG4gICAgICAgICAgICAgICAgZnVsbDogXCIvaW5kZXgucGhwXCJcbiAgICAgICAgICAgICAgICBhcGk6IFwiL2FwaS5waHBcIlxuICAgICAgICAgICAgXCJeaHR0cHM/Oi8vd2lraVxcLmFyY2hsaW51eFxcLmpwXCI6XG4gICAgICAgICAgICAgICAgc2hvcnQ6IFwiL2luZGV4LnBocC9cIlxuICAgICAgICAgICAgICAgIGZ1bGw6IFwiL2luZGV4LnBocFwiXG4gICAgICAgICAgICAgICAgYXBpOiBcIi9hcGkucGhwXCJcbiAgICAgICAgICAgIFwiXmh0dHA6Ly93aWtpXFwuYXJjaGxpbnV4XFwucm9cIjpcbiAgICAgICAgICAgICAgICBzaG9ydDogXCIvaW5kZXgucGhwL1wiXG4gICAgICAgICAgICAgICAgZnVsbDogXCIvaW5kZXgucGhwXCJcbiAgICAgICAgICAgICAgICBhcGk6IFwiL2FwaS5waHBcIlxuICAgICAgICAgICAgXCJeaHR0cDovL3dpa2lcXC5hcmNobGludXhcXC5pclwiOlxuICAgICAgICAgICAgICAgIHNob3J0OiBcIi9pbmRleC5waHAvXCJcbiAgICAgICAgICAgICAgICBmdWxsOiBcIi9pbmRleC5waHBcIlxuICAgICAgICAgICAgICAgIGFwaTogXCIvYXBpLnBocFwiXG4gICAgICAgIGRlZmF1bHRfOlxuICAgICAgICAgICAgc2hvcnQ6IFwiL2luZGV4LnBocD90aXRsZT1cIlxuICAgICAgICAgICAgZnVsbDogXCIvaW5kZXgucGhwXCJcbiAgICAgICAgICAgIGFwaTogXCIvYXBpLnBocFwiXG5cbiAgICBpbnRlcndpa2lGaXhlcyA9IFtcbiAgICAgICAgW1wiaHR0cHM6Ly93aWtpLmFyY2hsaW51eC5vcmcvaW5kZXgucGhwLyQxXyhcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJodHRwczovL3dpa2kuYXJjaGxpbnV4Lm9yZy9pbmRleC5waHAvJDElMjAoXCJdXG4gICAgXVxuXG4gICAgX2dldFdpa2lQYXRoczogKGhyZWYpIC0+XG4gICAgICAgICMgSXQncyBuZWNlc3NhcnkgdG8ga2VlcCB0aGlzIGZ1bmN0aW9uIGluIGEgcHJpdmF0ZSBhdHRyaWJ1dGUsXG4gICAgICAgICMgb3RoZXJ3aXNlIGxvY2FsV2lraVBhdGhzIGFuZCBsb2NhbFdpa2lVcmxzIGNhbm5vdCBiZSBpbml0aWFsaXplZFxuICAgICAgICBmb3IgciBvZiB3aWtpUGF0aHMua25vd25cbiAgICAgICAgICAgIHJlID0gbmV3IFJlZ0V4cChyLCBcImlcIilcbiAgICAgICAgICAgIG1hdGNoID0gcmUuZXhlYyhocmVmKVxuXG4gICAgICAgICAgICBpZiBtYXRjaFxuICAgICAgICAgICAgICAgIGhvc3RuYW1lID0gbWF0Y2hbMF1cbiAgICAgICAgICAgICAgICBwYXRocyA9IHt9XG5cbiAgICAgICAgICAgICAgICBmb3IgcCBvZiB3aWtpUGF0aHMua25vd25bcl1cbiAgICAgICAgICAgICAgICAgICAgcGF0aHNbcF0gPSB3aWtpUGF0aHMua25vd25bcl1bcF1cblxuICAgICAgICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgaWYgbm90IHBhdGhzXG4gICAgICAgICAgICBob3N0bmFtZSA9IEhUVFAuZ2V0VXJsTG9jYXRpb24oaHJlZikuaG9zdG5hbWVcbiAgICAgICAgICAgIHBhdGhzID0ge31cblxuICAgICAgICAgICAgZm9yIHAgb2Ygd2lraVBhdGhzLmRlZmF1bHRfXG4gICAgICAgICAgICAgICAgcGF0aHNbcF0gPSB3aWtpUGF0aHMuZGVmYXVsdF9bcF1cblxuICAgICAgICByZXR1cm4gW2hvc3RuYW1lLCBwYXRoc11cblxuICAgIGdldFdpa2lQYXRoczogKGhyZWYpIC0+XG4gICAgICAgIGlmIGhyZWZcbiAgICAgICAgICAgIHJldHVybiBAX2dldFdpa2lQYXRocyhocmVmKVsxXVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gbG9jYWxXaWtpUGF0aHNcblxuICAgIGxpbmtBcnRpY2xlOiAocGFnZSwgbGFiZWwpIC0+XG4gICAgICAgIHJldHVybiBBKHtocmVmOiBtdy51dGlsLmdldFVybChwYWdlKX0sIGxhYmVsIG9yIHBhZ2UpXG5cbiAgICBnZXRXaWtpVXJsczogKGhyZWYpIC0+XG4gICAgICAgIGlmIGhyZWZcbiAgICAgICAgICAgIHdwYXRocyA9IEBfZ2V0V2lraVBhdGhzKGhyZWYpXG4gICAgICAgICAgICBob3N0bmFtZSA9IHdwYXRoc1swXVxuICAgICAgICAgICAgcGF0aHMgPSB3cGF0aHNbMV1cblxuICAgICAgICAgICAgdXJscyA9IHt9XG5cbiAgICAgICAgICAgIGZvciBrZXkgb2YgcGF0aHNcbiAgICAgICAgICAgICAgICB1cmxzW2tleV0gPSBob3N0bmFtZSArIHBhdGhzW2tleV1cblxuICAgICAgICAgICAgcmV0dXJuIHVybHNcblxuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gbG9jYWxXaWtpVXJsc1xuXG4gICAgZ2V0VGl0bGVGcm9tV2lraVVybDogKHVybCkgLT5cbiAgICAgICAgdGl0bGUgPSBIVFRQLmdldFVSSVBhcmFtZXRlcnModXJsKS50aXRsZVxuXG4gICAgICAgICMgVGVzdCB0aGlzICpiZWZvcmUqIHRoZSBzaG9ydCBwYXRocywgaW4gZmFjdCBhIHNob3J0IHBhdGggbWF5IGp1c3QgYmVcbiAgICAgICAgIyB0aGUgZnVsbCBvbmUgd2l0aCB0aGUgXCJ0aXRsZVwiIHBhcmFtZXRlciBwcmUtYWRkZWRcbiAgICAgICAgaWYgbm90IHRpdGxlXG4gICAgICAgICAgICBwYXRobmFtZSA9IEhUVFAuZ2V0VXJsTG9jYXRpb24odXJsKS5wYXRobmFtZVxuXG4gICAgICAgICAgICBmb3IgciBvZiB3aWtpUGF0aHMua25vd25cbiAgICAgICAgICAgICAgICByZSA9IG5ldyBSZWdFeHAociwgXCJpXCIpXG4gICAgICAgICAgICAgICAgbWF0Y2ggPSByZS5leGVjKHVybClcblxuICAgICAgICAgICAgICAgIGlmIG1hdGNoXG4gICAgICAgICAgICAgICAgICAgIGlmIHBhdGhuYW1lLmluZGV4T2Yod2lraVBhdGhzLmtub3duW3JdLnNob3J0KSA9PSAwXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZSA9IHBhdGhuYW1lLnN1YnN0cih3aWtpUGF0aHMua25vd25bcl1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zaG9ydC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlID0gZmFsc2VcblxuICAgICAgICAgICAgICAgICAgICBicmVha1xuXG4gICAgICAgICAgICBpZiBub3QgdGl0bGVcbiAgICAgICAgICAgICAgICBpZiBwYXRobmFtZS5pbmRleE9mKHdpa2lQYXRocy5kZWZhdWx0Xy5zaG9ydCkgPT0gMFxuICAgICAgICAgICAgICAgICAgICB0aXRsZSA9IHBhdGhuYW1lLnN1YnN0cih3aWtpUGF0aHMuZGVmYXVsdF8uc2hvcnQubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdGl0bGUgPSBmYWxzZVxuXG4gICAgICAgIHJldHVybiB0aXRsZVxuXG4gICAgZmFpbGVkUXVlcnlFcnJvcjogKHVybCkgLT5cbiAgICAgICAgaWYgdXJsXG4gICAgICAgICAgICByZXR1cm4gXCJGYWlsZWQgcXVlcnk6ICN7QFdNLkxvZy5saW5rVG9QYWdlKHVybCwgdXJsKX1cIlxuICAgICAgICByZXR1cm4gXCJGYWlsZWQgcXVlcnlcIlxuXG4gICAgY2FsbEFQSUdldDogKHBhcmFtcywgY2FsbCwgY2FsbEFyZ3MsIGNhbGxFcnJvcikgLT5cbiAgICAgICAgcGFyYW1zLmZvcm1hdCA9IFwianNvblwiXG5cbiAgICAgICAgcmV0dXJuIEBhcGkuZ2V0KHBhcmFtcylcbiAgICAgICAgLmRvbmUoKGRhdGEsIHRleHRTdGF0dXMsIGpxWEhSKSA9PlxuICAgICAgICAgICAgaWYgY2FsbFxuICAgICAgICAgICAgICAgIGNhbGwoZGF0YSwgY2FsbEFyZ3MpXG4gICAgICAgICkuZmFpbCgoanFYSFIsIHRleHRTdGF0dXMsIGVycm9yVGhyb3duKSA9PlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihqcVhIUiwgdGV4dFN0YXR1cywgZXJyb3JUaHJvd24pXG4gICAgICAgICAgICBAV00uTG9nLmxvZ0Vycm9yKEBmYWlsZWRRdWVyeUVycm9yKCkpXG4gICAgICAgICAgICBpZiBjb25maXJtKFwiV2lraSBNb25rZXkgZXJyb3I6IEZhaWxlZCBxdWVyeVxcblxcbkRvIHlvdSB3YW50IFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwidG8gcmV0cnk/XCIpXG4gICAgICAgICAgICAgICAgQFdNLkxvZy5sb2dJbmZvKFwiUmV0cnlpbmcgLi4uXCIpXG4gICAgICAgICAgICAgICAgQGNhbGxBUElHZXQocGFyYW1zLCBjYWxsLCBjYWxsQXJncywgY2FsbEVycm9yKVxuICAgICAgICAgICAgZWxzZSBpZiBjYWxsRXJyb3JcbiAgICAgICAgICAgICAgICBjYWxsRXJyb3IoY2FsbEFyZ3MpXG4gICAgICAgIClcblxuICAgIGNhbGxBUElQb3N0OiAocGFyYW1zLCBjYWxsLCBjYWxsQXJncywgY2FsbEVycm9yKSAtPlxuICAgICAgICBwYXJhbXMuZm9ybWF0ID0gXCJqc29uXCJcblxuICAgICAgICByZXR1cm4gQGFwaS5wb3N0KHBhcmFtcylcbiAgICAgICAgLmRvbmUoKGRhdGEsIHRleHRTdGF0dXMsIGpxWEhSKSA9PlxuICAgICAgICAgICAgaWYgY2FsbFxuICAgICAgICAgICAgICAgIGNhbGwoZGF0YSwgY2FsbEFyZ3MpXG4gICAgICAgICkuZmFpbCgoanFYSFIsIHRleHRTdGF0dXMsIGVycm9yVGhyb3duKSA9PlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihqcVhIUiwgdGV4dFN0YXR1cywgZXJyb3JUaHJvd24pXG4gICAgICAgICAgICBAV00uTG9nLmxvZ0Vycm9yKEBmYWlsZWRRdWVyeUVycm9yKCkpXG4gICAgICAgICAgICBpZiBjb25maXJtKFwiV2lraSBNb25rZXkgZXJyb3I6IEZhaWxlZCBxdWVyeVxcblxcbkRvIHlvdSB3YW50IFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwidG8gcmV0cnk/XCIpXG4gICAgICAgICAgICAgICAgQFdNLkxvZy5sb2dJbmZvKFwiUmV0cnlpbmcgLi4uXCIpXG4gICAgICAgICAgICAgICAgQGNhbGxBUElQb3N0KHBhcmFtcywgY2FsbCwgY2FsbEFyZ3MsIGNhbGxFcnJvcilcblxuICAgICAgICAgICAgZWxzZSBpZiBjYWxsRXJyb3JcbiAgICAgICAgICAgICAgICBjYWxsRXJyb3IoY2FsbEFyZ3MpXG4gICAgICAgIClcblxuICAgIGNhbGxRdWVyeTogKHBhcmFtcywgY2FsbCwgY2FsbEFyZ3MsIGNhbGxFcnJvcikgLT5cbiAgICAgICAgcGFyYW1zLmFjdGlvbiA9IFwicXVlcnlcIlxuXG4gICAgICAgIHRyeVxuICAgICAgICAgICAgcmVzID0gYXdhaXQgQGNhbGxBUElHZXQocGFyYW1zKVxuICAgICAgICBjYXRjaCBlcnJvclxuICAgICAgICAgICAgaWYgY2FsbEVycm9yXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxFcnJvcihjYWxsQXJncylcbiAgICAgICAgICAgIHRocm93IGVycm9yXG5cbiAgICAgICAgcGFnZSA9IE9iai5nZXRGaXJzdEl0ZW0ocmVzLnF1ZXJ5LnBhZ2VzKVxuXG4gICAgICAgIGlmIGNhbGxcbiAgICAgICAgICAgIHJldHVybiBjYWxsKHBhZ2UsIGNhbGxBcmdzKVxuICAgICAgICByZXR1cm4gcGFnZVxuXG4gICAgY2FsbFF1ZXJ5RWRpdDogKHRpdGxlLCBjYWxsLCBjYWxsQXJncykgLT5cbiAgICAgICAgcGFnZSA9IGF3YWl0IEBjYWxsUXVlcnkoXG4gICAgICAgICAgICBwcm9wOiBcImluZm98cmV2aXNpb25zXCJcbiAgICAgICAgICAgIHJ2cHJvcDogXCJjb250ZW50fHRpbWVzdGFtcFwiXG4gICAgICAgICAgICBpbnRva2VuOiBcImVkaXRcIlxuICAgICAgICAgICAgdGl0bGVzOiB0aXRsZVxuICAgICAgICApXG5cbiAgICAgICAgc291cmNlID0gcGFnZS5yZXZpc2lvbnNbMF1bXCIqXCJdXG4gICAgICAgIHRpbWVzdGFtcCA9IHBhZ2UucmV2aXNpb25zWzBdLnRpbWVzdGFtcFxuICAgICAgICBlZGl0dG9rZW4gPSBwYWdlLmVkaXR0b2tlblxuXG4gICAgICAgIGlmIGNhbGxcbiAgICAgICAgICAgIHJldHVybiBjYWxsKHRpdGxlLCBzb3VyY2UsIHRpbWVzdGFtcCwgZWRpdHRva2VuLCBjYWxsQXJncylcbiAgICAgICAgcmV0dXJuIHtzb3VyY2UsIHRpbWVzdGFtcCwgZWRpdHRva2VufVxuXG4gICAgZ2V0VXNlckluZm86IChjYWxsKSAtPlxuICAgICAgICBzdG9yZUluZm8gPSAocmVzLCBjYWxsKSA9PlxuICAgICAgICAgICAgQHVzZXJJbmZvID0gcmVzXG4gICAgICAgICAgICBjYWxsKClcblxuICAgICAgICBpZiBub3QgQHVzZXJJbmZvXG4gICAgICAgICAgICBwYXJzID1cbiAgICAgICAgICAgICAgICBhY3Rpb246IFwicXVlcnlcIlxuICAgICAgICAgICAgICAgIG1ldGE6IFwidXNlcmluZm9cIlxuICAgICAgICAgICAgICAgIHVpcHJvcDogXCJncm91cHNcIlxuICAgICAgICAgICAgQGNhbGxBUElHZXQocGFycywgc3RvcmVJbmZvLCBjYWxsLCBudWxsKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICBjYWxsKClcblxuICAgIGlzTG9nZ2VkSW46IChjYWxsLCBhcmdzKSAtPlxuICAgICAgICBAZ2V0VXNlckluZm8oID0+XG4gICAgICAgICAgICB0ZXN0ID0gQHVzZXJJbmZvLnF1ZXJ5LnVzZXJpbmZvLmlkICE9IDBcbiAgICAgICAgICAgIGNhbGwodGVzdCwgYXJncylcbiAgICAgICAgKVxuXG4gICAgZ2V0VXNlck5hbWU6IChjYWxsLCBhcmdzKSAtPlxuICAgICAgICBAZ2V0VXNlckluZm8oID0+XG4gICAgICAgICAgICBjYWxsKEB1c2VySW5mby5xdWVyeS51c2VyaW5mby5uYW1lLCBhcmdzKVxuICAgICAgICApXG5cbiAgICBpc1VzZXJCb3Q6IChjYWxsLCBhcmdzKSAtPlxuICAgICAgICBAZ2V0VXNlckluZm8oID0+XG4gICAgICAgICAgICBncm91cHMgPSBAdXNlckluZm8ucXVlcnkudXNlcmluZm8uZ3JvdXBzXG4gICAgICAgICAgICByZXMgPSBncm91cHMuaW5kZXhPZihcImJvdFwiKSA+IC0xXG4gICAgICAgICAgICBjYWxsKHJlcywgYXJncylcbiAgICAgICAgKVxuXG4gICAgZ2V0QmFja2xpbmtzOiAoYmx0aXRsZSwgYmxuYW1lc3BhY2UsIGNhbGwsIGNhbGxBcmdzKSAtPlxuICAgICAgICBxdWVyeSA9XG4gICAgICAgICAgICBhY3Rpb246IFwicXVlcnlcIlxuICAgICAgICAgICAgbGlzdDogXCJiYWNrbGlua3NcIlxuICAgICAgICAgICAgYmx0aXRsZTogYmx0aXRsZVxuICAgICAgICAgICAgYmxsaW1pdDogNTAwXG5cbiAgICAgICAgaWYgYmxuYW1lc3BhY2VcbiAgICAgICAgICAgIHF1ZXJ5LmJsbmFtZXNwYWNlID0gYmxuYW1lc3BhY2VcblxuICAgICAgICBAX2dldEJhY2tsaW5rc0NvbnRpbnVlKHF1ZXJ5LCBjYWxsLCBjYWxsQXJncywgW10pXG5cbiAgICBfZ2V0QmFja2xpbmtzQ29udGludWU6IChxdWVyeSwgY2FsbCwgY2FsbEFyZ3MsIGJhY2tsaW5rcykgLT5cbiAgICAgICAgQGNhbGxBUElHZXQocXVlcnksIChyZXMsIGFyZ3MpID0+XG4gICAgICAgICAgICBiYWNrbGlua3MgPSBiYWNrbGlua3MuY29uY2F0KHJlcy5xdWVyeS5iYWNrbGlua3MpXG4gICAgICAgICAgICBpZiByZXNbXCJxdWVyeS1jb250aW51ZVwiXVxuICAgICAgICAgICAgICAgIHF1ZXJ5LmJsY29udGludWUgPSByZXNbXCJxdWVyeS1jb250aW51ZVwiXS5iYWNrbGlua3MuYmxjb250aW51ZVxuICAgICAgICAgICAgICAgIEBfZ2V0QmFja2xpbmtzQ29udGludWUocXVlcnksIGNhbGwsIGFyZ3MsIGJhY2tsaW5rcylcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBjYWxsKGJhY2tsaW5rcywgYXJncylcbiAgICAgICAgLFxuICAgICAgICBjYWxsQXJncywgbnVsbClcblxuICAgIGdldExhbmdsaW5rczogKHRpdGxlLCBpd21hcCwgY2FsbCwgY2FsbEFyZ3MpIC0+XG4gICAgICAgIHF1ZXJ5ID1cbiAgICAgICAgICAgIGFjdGlvbjogXCJxdWVyeVwiXG4gICAgICAgICAgICBwcm9wOiBcImxhbmdsaW5rc1wiXG4gICAgICAgICAgICB0aXRsZXM6IHRpdGxlXG4gICAgICAgICAgICBsbGxpbWl0OiA1MDBcbiAgICAgICAgICAgIGxsdXJsOiBcIjFcIlxuICAgICAgICAgICAgcmVkaXJlY3RzOiBcIjFcIlxuXG4gICAgICAgIGlmIGl3bWFwXG4gICAgICAgICAgICBxdWVyeS5tZXRhID0gXCJzaXRlaW5mb1wiXG4gICAgICAgICAgICBxdWVyeS5zaXByb3AgPSBcImludGVyd2lraW1hcFwiXG4gICAgICAgICAgICBxdWVyeS5zaWZpbHRlcml3ID0gXCJsb2NhbFwiXG5cbiAgICAgICAgQF9nZXRMYW5nbGlua3NDb250aW51ZShxdWVyeSwgY2FsbCwgY2FsbEFyZ3MsIFtdLCBudWxsKVxuXG4gICAgX2dldExhbmdsaW5rc0NvbnRpbnVlOiAocXVlcnksIGNhbGwsIGNhbGxBcmdzLCBsYW5nbGlua3MsIGl3bWFwKSAtPlxuICAgICAgICBAY2FsbEFQSUdldChxdWVyeSwgKHJlcywgYXJncykgPT5cbiAgICAgICAgICAgIHBhZ2UgPSBPYmouZ2V0Rmlyc3RJdGVtKHJlcy5xdWVyeS5wYWdlcylcbiAgICAgICAgICAgIGxhbmdsaW5rcyA9IGxhbmdsaW5rcy5jb25jYXQocGFnZS5sYW5nbGlua3MpXG5cbiAgICAgICAgICAgIGlmIHJlcy5xdWVyeS5pbnRlcndpa2ltYXBcbiAgICAgICAgICAgICAgICBpd21hcCA9IHJlcy5xdWVyeS5pbnRlcndpa2ltYXBcblxuICAgICAgICAgICAgaWYgcXVlcnkubWV0YVxuICAgICAgICAgICAgICAgIGRlbGV0ZSBxdWVyeS5tZXRhXG4gICAgICAgICAgICAgICAgZGVsZXRlIHF1ZXJ5LnNpcHJvcFxuICAgICAgICAgICAgICAgIGRlbGV0ZSBxdWVyeS5zaWZpbHRlcml3XG5cbiAgICAgICAgICAgIGlmIHJlc1tcInF1ZXJ5LWNvbnRpbnVlXCJdXG4gICAgICAgICAgICAgICAgcXVlcnkubGxjb250aW51ZSA9IHJlc1tcInF1ZXJ5LWNvbnRpbnVlXCJdLmxhbmdsaW5rcy5sbGNvbnRpbnVlXG4gICAgICAgICAgICAgICAgQF9nZXRMYW5nbGlua3NDb250aW51ZShxdWVyeSwgY2FsbCwgYXJncywgbGFuZ2xpbmtzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXdtYXApXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgY2FsbChsYW5nbGlua3MsIGl3bWFwLCBhcmdzKVxuICAgICAgICAsXG4gICAgICAgIGNhbGxBcmdzLCBudWxsKVxuXG4gICAgZ2V0SW50ZXJ3aWtpTWFwOiAodGl0bGUpIC0+XG4gICAgICAgIHJldHVybiBAY2FsbEFQSUdldCh7XG4gICAgICAgICAgICBhY3Rpb246IFwicXVlcnlcIlxuICAgICAgICAgICAgbWV0YTogXCJzaXRlaW5mb1wiXG4gICAgICAgICAgICBzaXByb3A6IFwiaW50ZXJ3aWtpbWFwXCJcbiAgICAgICAgfSlcblxuICAgIGdldExvY2FsSW50ZXJ3aWtpTWFwOiAodGl0bGUsIGNhbGwsIGNhbGxBcmdzKSAtPlxuICAgICAgICBAY2FsbEFQSUdldChcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBhY3Rpb246IFwicXVlcnlcIlxuICAgICAgICAgICAgICAgIG1ldGE6IFwic2l0ZWluZm9cIlxuICAgICAgICAgICAgICAgIHNpcHJvcDogXCJpbnRlcndpa2ltYXBcIlxuICAgICAgICAgICAgICAgIHNpZmlsdGVyaXc6IFwibG9jYWxcIlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKHJlcywgYXJncykgPT5cbiAgICAgICAgICAgICAgICBjYWxsKHJlcy5xdWVyeS5pbnRlcndpa2ltYXAsIGFyZ3MpXG4gICAgICAgICAgICBjYWxsQXJnc1xuICAgICAgICAgICAgbnVsbFxuICAgICAgICApXG5cbiAgICBmaXhJbnRlcndpa2lVcmw6ICh1cmwpIC0+XG4gICAgICAgIGZvciBmIGluIFswLi4uaW50ZXJ3aWtpRml4ZXMubGVuZ3RoXVxuICAgICAgICAgICAgZnVybCA9IHVybC5yZXBsYWNlKGludGVyd2lraUZpeGVzW2ZdWzBdLCBpbnRlcndpa2lGaXhlc1tmXVsxXSlcblxuICAgICAgICAgICAgaWYgZnVybCAhPSB1cmxcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVybFxuXG4gICAgICAgICMgUmV0dXJuIHRoZSB1bm1vZGlmaWVkIHVybCBpZiBubyByZXBsYWNlbWVudCBoYXMgYmVlbiBkb25lXG4gICAgICAgIHJldHVybiB1cmxcblxuICAgIGdldFNwZWNpYWxMaXN0OiAocXBwYWdlLCBzaXByb3ApIC0+XG4gICAgICAgIHF1ZXJ5ID1cbiAgICAgICAgICAgIGFjdGlvbjogXCJxdWVyeVwiXG4gICAgICAgICAgICBsaXN0OiBcInF1ZXJ5cGFnZVwiXG4gICAgICAgICAgICBxcHBhZ2U6IHFwcGFnZVxuICAgICAgICAgICAgcXBsaW1pdDogNTAwXG5cbiAgICAgICAgaWYgc2lwcm9wXG4gICAgICAgICAgICBxdWVyeS5tZXRhID0gXCJzaXRlaW5mb1wiXG4gICAgICAgICAgICBxdWVyeS5zaXByb3AgPSBzaXByb3BcblxuICAgICAgICByZXN1bHRzID0gW11cbiAgICAgICAgc2l0ZWluZm8gPSB7fVxuXG4gICAgICAgIGxvb3BcbiAgICAgICAgICAgIHJlcyA9IGF3YWl0IEBjYWxsQVBJR2V0KHF1ZXJ5KVxuICAgICAgICAgICAgcmVzdWx0cyA9IHJlc3VsdHMuY29uY2F0KHJlcy5xdWVyeS5xdWVyeXBhZ2UucmVzdWx0cylcblxuICAgICAgICAgICAgZm9yIGtleSwgaW5mbyBvZiByZXMucXVlcnkgd2hlbiBrZXkgIT0gXCJxdWVyeXBhZ2VcIlxuICAgICAgICAgICAgICAgIHNpdGVpbmZvW2tleV0gPSBpbmZvXG5cbiAgICAgICAgICAgIGRlbGV0ZSBxdWVyeS5tZXRhXG4gICAgICAgICAgICBkZWxldGUgcXVlcnkuc2lwcm9wXG5cbiAgICAgICAgICAgIGlmIHJlc1tcInF1ZXJ5LWNvbnRpbnVlXCJdXG4gICAgICAgICAgICAgICAgcXVlcnkucXBvZmZzZXQgPSByZXNbXCJxdWVyeS1jb250aW51ZVwiXS5xdWVyeXBhZ2UucXBvZmZzZXRcbiAgICAgICAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgICAgICByZXR1cm4ge3Jlc3VsdHMsIHNpdGVpbmZvfVxuXG4gICAgZ2V0VXNlckNvbnRyaWJzOiAodWN1c2VyLCB1Y3N0YXJ0LCB1Y2VuZCwgY2FsbCwgY2FsbEFyZ3MpIC0+XG4gICAgICAgIHF1ZXJ5ID1cbiAgICAgICAgICAgIGFjdGlvbjogXCJxdWVyeVwiXG4gICAgICAgICAgICBsaXN0OiBcInVzZXJjb250cmlic1wiXG4gICAgICAgICAgICB1Y3VzZXI6IHVjdXNlclxuICAgICAgICAgICAgdWNwcm9wOiBcIlwiXG4gICAgICAgICAgICB1Y3N0YXJ0OiB1Y3N0YXJ0XG4gICAgICAgICAgICB1Y2VuZDogdWNlbmRcbiAgICAgICAgICAgIHVjbGltaXQ6IDUwMFxuXG4gICAgICAgIEBfZ2V0VXNlckNvbnRyaWJzQ29udGludWUocXVlcnksIGNhbGwsIGNhbGxBcmdzLCBbXSlcblxuICAgIF9nZXRVc2VyQ29udHJpYnNDb250aW51ZTogKHF1ZXJ5LCBjYWxsLCBjYWxsQXJncywgcmVzdWx0cykgLT5cbiAgICAgICAgQGNhbGxBUElHZXQocXVlcnksIChyZXMsIGFyZ3MpID0+XG4gICAgICAgICAgICByZXN1bHRzID0gcmVzdWx0cy5jb25jYXQocmVzLnF1ZXJ5LnVzZXJjb250cmlicylcblxuICAgICAgICAgICAgaWYgcmVzW1wicXVlcnktY29udGludWVcIl1cbiAgICAgICAgICAgICAgICBxdWVyeS51Y2NvbnRpbnVlID0gcmVzW1wicXVlcnktY29udGludWVcIl0udXNlcmNvbnRyaWJzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnVjY29udGludWVcbiAgICAgICAgICAgICAgICBAX2dldFVzZXJDb250cmlic0NvbnRpbnVlKHF1ZXJ5LCBjYWxsLCBhcmdzLCByZXN1bHRzKVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGNhbGwocmVzdWx0cywgYXJncylcbiAgICAgICAgLFxuICAgICAgICBjYWxsQXJncywgbnVsbClcbiIsIiMgV2lraSBNb25rZXkgLSBNZWRpYVdpa2kgYm90IGFuZCBlZGl0b3ItYXNzaXN0YW50IHVzZXIgc2NyaXB0XG4jIENvcHlyaWdodCAoQykgMjAxMSBEYXJpbyBHaW92YW5uZXR0aSA8ZGV2QGRhcmlvZ2lvdmFubmV0dGkubmV0PlxuI1xuIyBUaGlzIGZpbGUgaXMgcGFydCBvZiBXaWtpIE1vbmtleS5cbiNcbiMgV2lraSBNb25rZXkgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuIyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuIyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuIyAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuI1xuIyBXaWtpIE1vbmtleSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuIyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuIyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4jIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4jXG4jIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4jIGFsb25nIHdpdGggV2lraSBNb25rZXkuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG5cbkNTUyA9IHJlcXVpcmUoJ0BreW5pa29zL21pc2MvZGlzdC9DU1MnKVxuXG5cbmNsYXNzIG1vZHVsZS5leHBvcnRzXG4gICAgY29uc3RydWN0b3I6IChAV00pIC0+XG5cbiAgICBfbWFrZVVJOiAoQHBhZ2VfdHlwZSwgcGx1Z2lucykgLT5cbiAgICAgICAgQ1NTLmFkZFN0eWxlRWxlbWVudChcbiAgICAgICAgICAgICAgICBcIiNXaWtpTW9ua2V5TWVudSBpbnB1dC5tYXJnaW4ge21hcmdpbjowIDAuMzNlbSAwLjMzZW0gMDt9XCIpXG5cbiAgICAgICAgbWFpbkRpdiA9ICQoJzxkaXYvPicpLmF0dHIoJ2lkJywgJ1dpa2lNb25rZXlNZW51JylcbiAgICAgICAgZ3JvdXBBY3Rpb25zID0ge31cblxuICAgICAgICBmb3IgUGx1Z2luIGluIHBsdWdpbnNcbiAgICAgICAgICAgIHBsdWdpbiA9IG5ldyBQbHVnaW4oQFdNKVxuICAgICAgICAgICAgcGx1Z2luSW5zdCA9IHBsdWdpbi5jb25mW1wiI3tAcGFnZV90eXBlfV9tZW51XCJdXG5cbiAgICAgICAgICAgICMgVGhpcyBhbGxvd3MgdG8gZGlzYWJsZSBhbiBlbnRyeSBieSBnaXZpbmcgaXQgYSBtZW51X2VudHJ5XG4gICAgICAgICAgICAjIHBhcmFtZXRlciB0aGF0IGV2YWx1YXRlcyB0byBmYWxzZVxuICAgICAgICAgICAgaWYgbm90IHBsdWdpbkluc3Qgb3Igbm90IHBsdWdpbkluc3QubGVuZ3RoXG4gICAgICAgICAgICAgICAgY29udGludWVcblxuICAgICAgICAgICAgaWYgcGx1Z2luLm1ha2VVSVxuICAgICAgICAgICAgICAgIGdyb3VwQWN0aW9uID0gW0B3YXJuSW5wdXROZWVkZWQsIHBsdWdpbl1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBncm91cEFjdGlvbiA9IFtAZXhlY3V0ZUVudHJ5QWN0aW9uLCBwbHVnaW5dXG5cbiAgICAgICAgICAgIHBsdWdpbkluc3QudW5zaGlmdChcIldpa2lNb25rZXlNZW51Um9vdFwiKVxuICAgICAgICAgICAgY3VycklkID0gZmFsc2VcblxuICAgICAgICAgICAgZm9yIG0gaW4gWzAuLi5wbHVnaW5JbnN0Lmxlbmd0aCAtIDFdXG4gICAgICAgICAgICAgICAgcGFyZW50SWQgPSBjdXJySWRcbiAgICAgICAgICAgICAgICBjdXJySWQgPSBwbHVnaW5JbnN0LnNsaWNlKDAsIG0gKyAxKS5qb2luKFwiLVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8gL2csIFwiX1wiKVxuXG4gICAgICAgICAgICAgICAgIyBJIGNhbid0IHNpbXBseSBkbyAkKFwiI1wiICsgY3VycklkKSBiZWNhdXNlIG1haW5EaXZcbiAgICAgICAgICAgICAgICAjIGhhc24ndCBiZWVuIGFkZGVkIHRvIHRoZSBET00gdHJlZSB5ZXRcbiAgICAgICAgICAgICAgICBtZW51U2VsID0gbWFpbkRpdi5jaGlsZHJlbihcImRpdltpZD0nI3tjdXJySWR9J11cIilcblxuICAgICAgICAgICAgICAgIGlmIG5vdCBtZW51U2VsLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICBjdXJyTWVudSA9ICQoXCI8ZGl2Lz5cIilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiaWRcIiwgY3VycklkKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmhpZGUoKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZFRvKG1haW5EaXYpXG5cbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBBY3Rpb25zW2N1cnJJZF0gPSBbXVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIG0gPiAwXG4gICAgICAgICAgICAgICAgICAgICAgICAjIEkgY2FuJ3Qgc2ltcGx5IGRvICQoXCIjXCIgKyBjdXJySWQpIGJlY2F1c2UgbWFpbkRpdlxuICAgICAgICAgICAgICAgICAgICAgICAgIyBoYXNuJ3QgYmVlbiBhZGRlZCB0byB0aGUgRE9NIHRyZWUgeWV0XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRNZW51ID0gbWFpbkRpdi5jaGlsZHJlbihcImRpdltpZD0nI3twYXJlbnRJZH0nXVwiKVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAkKCc8aW5wdXQvPicpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3R5cGUnLCAnYnV0dG9uJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudmFsKCc8JylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoJ21hcmdpbicpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNsaWNrKG1ha2VDaGFuZ2VNZW51KGN1cnJNZW51LCBwYXJlbnRNZW51KSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kVG8oY3Vyck1lbnUpXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICQoJzxpbnB1dC8+JylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigndHlwZScsICdidXR0b24nKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC52YWwocGx1Z2luSW5zdFttXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY2xpY2sobWFrZUdyb3VwQWN0aW9uKGdyb3VwQWN0aW9uc1tjdXJySWRdKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kVG8ocGFyZW50TWVudSlcblxuICAgICAgICAgICAgICAgICAgICAgICAgJCgnPGlucHV0Lz4nKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0eXBlJywgJ2J1dHRvbicpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnZhbCgnPicpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKCdtYXJnaW4nKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jbGljayhtYWtlQ2hhbmdlTWVudShwYXJlbnRNZW51LCBjdXJyTWVudSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZFRvKHBhcmVudE1lbnUpXG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBjdXJyTWVudSA9IG1lbnVTZWwuZmlyc3QoKVxuXG4gICAgICAgICAgICAgICAgZ3JvdXBBY3Rpb25zW2N1cnJJZF0ucHVzaChncm91cEFjdGlvbilcblxuICAgICAgICAgICAgZW50cnkgPSAkKFwiPGlucHV0Lz5cIilcbiAgICAgICAgICAgICAgICAuYXR0cigndHlwZScsICdidXR0b24nKVxuICAgICAgICAgICAgICAgIC52YWwocGx1Z2luSW5zdFtwbHVnaW5JbnN0Lmxlbmd0aCAtIDFdKVxuICAgICAgICAgICAgICAgIC5hZGRDbGFzcygnbWFyZ2luJylcbiAgICAgICAgICAgICAgICAuYXBwZW5kVG8oY3Vyck1lbnUpXG5cbiAgICAgICAgICAgIGlmIHBsdWdpbi5tYWtlVUlcbiAgICAgICAgICAgICAgICBlbnRyeS5jbGljayhAbWFrZUVudHJ5VUkoY3Vyck1lbnUsIHBsdWdpbikpXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgZW50cnkuY2xpY2soQG1ha2VFbnRyeUFjdGlvbihwbHVnaW4pKVxuXG4gICAgICAgIG1lbnVzID0gbWFpbkRpdi5jaGlsZHJlbigpXG5cbiAgICAgICAgaWYgbWVudXMubGVuZ3RoXG4gICAgICAgICAgICBleGVjQWxsID0gJCgnPGlucHV0Lz4nKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd0eXBlJywgJ2J1dHRvbicpXG4gICAgICAgICAgICAgICAgLnZhbChcIipcIilcbiAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoJ21hcmdpbicpXG4gICAgICAgICAgICAgICAgLmNsaWNrKG1ha2VHcm91cEFjdGlvbihncm91cEFjdGlvbnNbXCJXaWtpTW9ua2V5TWVudVJvb3RcIl0pKVxuXG4gICAgICAgICAgICAjIEkgY2FuJ3Qgc2ltcGx5IGRvICQoXCIjXCIgKyBjdXJySWQpIGJlY2F1c2UgbWFpbkRpdlxuICAgICAgICAgICAgIyBoYXNuJ3QgYmVlbiBhZGRlZCB0byB0aGUgRE9NIHRyZWUgeWV0XG4gICAgICAgICAgICBtYWluRGl2XG4gICAgICAgICAgICAgICAgLmNoaWxkcmVuKFwiZGl2W2lkPSdXaWtpTW9ua2V5TWVudVJvb3QnXVwiKVxuICAgICAgICAgICAgICAgIC5maXJzdCgpXG4gICAgICAgICAgICAgICAgLnByZXBlbmQoZXhlY0FsbClcblxuICAgICAgICAgICAgbWVudXMuZmlyc3QoKS5zaG93KClcbiAgICAgICAgICAgIHJldHVybiBtYWluRGl2WzBdXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuXG4gICAgbWFrZUNoYW5nZU1lbnUgPSAoY3VycmVudE1lbnUsIGNoYW5nZU1lbnUpIC0+XG4gICAgICAgIHJldHVybiAoZXZlbnQpIC0+XG4gICAgICAgICAgICBjdXJyZW50TWVudS5oaWRlKClcbiAgICAgICAgICAgIGNoYW5nZU1lbnUuc2hvdygpXG5cbiAgICBtYWtlRW50cnlVSTogKGN1cnJNZW51LCBwbHVnaW4pIC0+XG4gICAgICAgIHJldHVybiAoZXZlbnQpID0+XG4gICAgICAgICAgICBjdXJyTWVudS5oaWRlKClcbiAgICAgICAgICAgIFVJZGl2ID0gJCgnPGRpdi8+JylcblxuICAgICAgICAgICAgJCgnPGlucHV0Lz4nKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd0eXBlJywgJ2J1dHRvbicpXG4gICAgICAgICAgICAgICAgLnZhbCgnPCcpXG4gICAgICAgICAgICAgICAgLmFkZENsYXNzKCdtYXJnaW4nKVxuICAgICAgICAgICAgICAgIC5jbGljayggKGV2ZW50KSAtPlxuICAgICAgICAgICAgICAgICAgICBVSWRpdi5yZW1vdmUoKVxuICAgICAgICAgICAgICAgICAgICBjdXJyTWVudS5zaG93KClcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgLmFwcGVuZFRvKFVJZGl2KVxuXG4gICAgICAgICAgICAkKCc8aW5wdXQvPicpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3R5cGUnLCAnYnV0dG9uJylcbiAgICAgICAgICAgICAgICAudmFsKCdFeGVjdXRlJylcbiAgICAgICAgICAgICAgICAuY2xpY2soQG1ha2VFbnRyeUFjdGlvbihwbHVnaW4pKVxuICAgICAgICAgICAgICAgIC5hcHBlbmRUbyhVSWRpdilcblxuICAgICAgICAgICAgVUkgPSBwbHVnaW4ubWFrZVVJKClcbiAgICAgICAgICAgIFVJZGl2LmFwcGVuZChVSSkuaW5zZXJ0QWZ0ZXIoY3Vyck1lbnUpXG5cbiAgICBtYWtlRW50cnlBY3Rpb246IChwbHVnaW4pIC0+XG4gICAgICAgIHJldHVybiAoZXZlbnQpID0+XG4gICAgICAgICAgICBAZXhlY3V0ZUVudHJ5QWN0aW9uKHBsdWdpbiwgbnVsbClcblxuICAgIGV4ZWN1dGVFbnRyeUFjdGlvbjogKHBsdWdpbiwgY2FsbE5leHQpID0+XG4gICAgICAgIEBXTS5Mb2cubG9nSGlkZGVuKFwiUGx1Z2luOiBcIiArIHBsdWdpbi5jb25zdHJ1Y3Rvci5uYW1lKVxuICAgICAgICBwbHVnaW5bXCJtYWluXyN7QHBhZ2VfdHlwZX1cIl0oY2FsbE5leHQpXG5cbiAgICB3YXJuSW5wdXROZWVkZWQ6IChwbHVnaW4sIGNhbGxOZXh0KSA9PlxuICAgICAgICBAV00uTG9nLmxvZ1dhcm5pbmcoXCJQbHVnaW4gXCIgKyBwbHVnaW4uY29uc3RydWN0b3IubmFtZSArXG4gICAgICAgICAgICBcIiB3YXMgbm90IGV4ZWN1dGVkIGJlY2F1c2UgaXQgcmVxdWlyZXMgaW5wdXQgZnJvbSBpdHMgaW50ZXJmYWNlLlwiKVxuXG4gICAgICAgIGlmIGNhbGxOZXh0XG4gICAgICAgICAgICBjYWxsTmV4dCgpXG5cbiAgICBtYWtlR3JvdXBBY3Rpb24gPSAoc3ViR3JvdXBBY3Rpb25zKSAtPlxuICAgICAgICByZXR1cm4gKGV2ZW50KSAtPlxuICAgICAgICAgICAgZXhlY3V0ZUdyb3VwQWN0aW9uKHN1Ykdyb3VwQWN0aW9ucywgLTEpXG5cbiAgICBleGVjdXRlR3JvdXBBY3Rpb24gPSAoc3ViR3JvdXBBY3Rpb25zLCBpZCkgLT5cbiAgICAgICAgaWQrK1xuICAgICAgICBpZiBzdWJHcm91cEFjdGlvbnNbaWRdXG4gICAgICAgICAgICBmaWQgPSBzdWJHcm91cEFjdGlvbnNbaWRdXG4gICAgICAgICAgICBjYWxsQ29udGludWUgPSA9PlxuICAgICAgICAgICAgICAgIGV4ZWN1dGVHcm91cEFjdGlvbihzdWJHcm91cEFjdGlvbnMsIGlkKVxuICAgICAgICAgICAgZmlkWzBdKGZpZFsxXSwgY2FsbENvbnRpbnVlKVxuIiwiIyBXaWtpIE1vbmtleSAtIE1lZGlhV2lraSBib3QgYW5kIGVkaXRvci1hc3Npc3RhbnQgdXNlciBzY3JpcHRcbiMgQ29weXJpZ2h0IChDKSAyMDExIERhcmlvIEdpb3Zhbm5ldHRpIDxkZXZAZGFyaW9naW92YW5uZXR0aS5uZXQ+XG4jXG4jIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFdpa2kgTW9ua2V5LlxuI1xuIyBXaWtpIE1vbmtleSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4jIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4jIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4jIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4jXG4jIFdpa2kgTW9ua2V5IGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4jIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4jIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiMgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbiNcbiMgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiMgYWxvbmcgd2l0aCBXaWtpIE1vbmtleS4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cblxuQ1NTID0gcmVxdWlyZSgnQGt5bmlrb3MvbWlzYy9kaXN0L0NTUycpXG5cblxuY2xhc3MgbW9kdWxlLmV4cG9ydHNcbiAgICBjb25zdHJ1Y3RvcjogKEBXTSkgLT5cblxuICAgIGRpc2FibGVFZGl0U3VtbWFyeVN1Ym1pdE9uRW50ZXIgPSAtPlxuICAgICAgICAkKCcjd3BTdW1tYXJ5Jykua2V5ZG93biggKGV2ZW50KSAtPlxuICAgICAgICAgICAgIyAna2V5Q29kZScgaXMgZGVwcmVjYXRlZCwgYnV0IG5vdCBhbGwgYnJvd3NlcnMgc3VwcG9ydCAna2V5JyB5ZXRcbiAgICAgICAgICAgIGlmIGV2ZW50LmtleSA9PSAnRW50ZXInIG9yICh0eXBlb2YgZXZlbnQua2V5ID09ICd1bmRlZmluZWQnIGFuZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudC5rZXlDb2RlID09IDEzKVxuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgKVxuXG4gICAgaGlkZVJvbGxiYWNrTGlua3MgPSAtPlxuICAgICAgICBDU1MuYWRkU3R5bGVFbGVtZW50KFwic3Bhbi5tdy1yb2xsYmFjay1saW5rIHtkaXNwbGF5Om5vbmU7fVwiKVxuXG4gICAgc2Nyb2xsVG9GaXJzdEhlYWRpbmcgPSAtPlxuICAgICAgICB3aW5kb3cuc2Nyb2xsVG8oMCwgJCgnI2ZpcnN0SGVhZGluZycpLm9mZnNldCgpLnRvcClcblxuICAgIGFwcGx5RWRpdG9yTW9kczogLT5cbiAgICAgICAgaWYgQFdNLmNvbmYuZGlzYWJsZV9lZGl0X3N1bW1hcnlfc3VibWl0X29uX2VudGVyXG4gICAgICAgICAgICBkaXNhYmxlRWRpdFN1bW1hcnlTdWJtaXRPbkVudGVyKClcbiAgICAgICAgaWYgQFdNLmNvbmYuc2Nyb2xsX3RvX2ZpcnN0X2hlYWRpbmdcbiAgICAgICAgICAgIHNjcm9sbFRvRmlyc3RIZWFkaW5nKClcblxuICAgIGFwcGx5UmVjZW50Q2hhbmdlc01vZHM6IC0+XG4gICAgICAgIGlmIEBXTS5jb25mLmhpZGVfcm9sbGJhY2tfbGlua3NcbiAgICAgICAgICAgIGhpZGVSb2xsYmFja0xpbmtzKClcblxuICAgIGFwcGx5Q29udHJpYnV0aW9uc01vZHM6IC0+XG4gICAgICAgIGlmIEBXTS5jb25mLmhpZGVfcm9sbGJhY2tfbGlua3NcbiAgICAgICAgICAgIGhpZGVSb2xsYmFja0xpbmtzKClcbiIsIiMgV2lraSBNb25rZXkgLSBNZWRpYVdpa2kgYm90IGFuZCBlZGl0b3ItYXNzaXN0YW50IHVzZXIgc2NyaXB0XG4jIENvcHlyaWdodCAoQykgMjAxMSBEYXJpbyBHaW92YW5uZXR0aSA8ZGV2QGRhcmlvZ2lvdmFubmV0dGkubmV0PlxuI1xuIyBUaGlzIGZpbGUgaXMgcGFydCBvZiBXaWtpIE1vbmtleS5cbiNcbiMgV2lraSBNb25rZXkgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuIyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuIyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuIyAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuI1xuIyBXaWtpIE1vbmtleSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuIyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuIyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4jIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4jXG4jIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4jIGFsb25nIHdpdGggV2lraSBNb25rZXkuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG5cblJlZ0V4ID0gcmVxdWlyZSgnQGt5bmlrb3MvbWlzYy9kaXN0L1JlZ0V4JylcblN0ciA9IHJlcXVpcmUoJ0BreW5pa29zL21pc2MvZGlzdC9TdHInKVxuXG5cbmNsYXNzIG1vZHVsZS5leHBvcnRzXG4gICAgY29uc3RydWN0b3I6IChAV00pIC0+XG5cbiAgICBzcXVhc2hDb250aWd1b3VzV2hpdGVzcGFjZTogKHRpdGxlKSAtPlxuICAgICAgICAjIE1lZGlhV2lraSB0cmVhdHMgY29uc2VjdXRpdmUgd2hpdGVzcGFjZSBjaGFyYWN0ZXJzIGluIHRpdGxlcyBhbmRcbiAgICAgICAgIyAgIHNlY3Rpb24gbmFtZXMgYXMgb25lXG4gICAgICAgICMgRm9yIGV4YW1wbGUgW1tNYWluIF9fIFBhZ2UjRmlyc3QgXyBfc2VjdGlvbl1dIGlzIHRoZSBzYW1lIGFzXG4gICAgICAgICMgICBbW01haW4gUGFnZSNGaXJzdCBzZWN0aW9uXV1cbiAgICAgICAgIyBDb25zaWRlciB0cmltbWluZyB0aGUgcmV0dXJuZWQgdGV4dFxuICAgICAgICByZXR1cm4gdGl0bGUucmVwbGFjZSgvW18gXSsvZywgXCIgXCIpXG5cbiAgICBuZXV0cmFsaXplTm93aWtpVGFnczogKHNvdXJjZSkgLT5cbiAgICAgICAgIyBFbXB0eSBub3dpa2kgdGFncyAoPG5vd2lraT48L25vd2lraT4pIG11c3QgYmUgbmV1dHJhbGl6ZWQgYXMgd2VsbCxcbiAgICAgICAgIyAgIG90aGVyd2lzZSBUYW1wZXJtb25rZXkgd2lsbCBoYW5nLCBzZWUgYWxzb1xuICAgICAgICAjICAgaHR0cHM6Ly9naXRodWIuY29tL2t5bmlrb3Mvd2lraS1tb25rZXkvaXNzdWVzLzEzM1xuICAgICAgICAjIE5vdGUgdGhhdCB0aGUgY29uY2VwdCBvZiBcIm5lc3RpbmdcIiBkb2Vzbid0IG1ha2Ugc2Vuc2Ugd2l0aCA8bm93aWtpPlxuICAgICAgICAjICAgdGFncywgc28gZG8gKm5vdCogdXNlIFN0ci5maW5kTmVzdGVkRW5jbG9zdXJlc1xuICAgICAgICBPUEVOTEVOR1RIID0gOFxuICAgICAgICBDTE9TRUxFTkdUSCA9IDlcbiAgICAgICAgdGFncyA9IFN0ci5maW5kU2ltcGxlRW5jbG9zdXJlcyhzb3VyY2UsIC88bm93aWtpPi9pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT1BFTkxFTkdUSCwgLzxcXC9ub3dpa2k+L2ksIENMT1NFTEVOR1RIKVxuICAgICAgICBtYXNrZWRUZXh0ID0gXCJcIlxuICAgICAgICBwcmV2SWQgPSAwXG5cbiAgICAgICAgZm9yIHRhZyBpbiB0YWdzXG4gICAgICAgICAgICBpZiB0YWdbMV1cbiAgICAgICAgICAgICAgICBtYXNrTGVuZ3RoID0gdGFnWzFdIC0gdGFnWzBdICsgQ0xPU0VMRU5HVEhcbiAgICAgICAgICAgICAgICBtYXNrU3RyaW5nID0gU3RyLnBhZFJpZ2h0KFwiXCIsIFwieFwiLCBtYXNrTGVuZ3RoKVxuICAgICAgICAgICAgICAgIG1hc2tlZFRleHQgKz0gc291cmNlLnN1YnN0cmluZyhwcmV2SWQsIHRhZ1swXSkgKyBtYXNrU3RyaW5nXG4gICAgICAgICAgICAgICAgcHJldklkID0gdGFnWzFdICsgQ0xPU0VMRU5HVEhcbiAgICAgICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICMgSWYgYSA8bm93aWtpPiB0YWcgaXMgbGVmdCBvcGVuIChubyBjbG9zaW5nIHRhZyBpcyBmb3VuZCksIGl0XG4gICAgICAgICAgICAgICAgIyAgIGRvZXMgaXRzIGpvYiB1bnRpbCB0aGUgZW5kIG9mIHRoZSB0ZXh0XG4gICAgICAgICAgICAgICAgIyBUaGlzIGFsc28gbmV1dHJhbGl6ZXMgdGhlIGZpbmFsIFxcbiwgYnV0IGl0IHNob3VsZG4ndCBtYXR0ZXJcbiAgICAgICAgICAgICAgICBtYXNrTGVuZ3RoID0gc291cmNlLnN1YnN0cih0YWdbMF0pLmxlbmd0aFxuICAgICAgICAgICAgICAgIG1hc2tTdHJpbmcgPSBTdHIucGFkUmlnaHQoXCJcIiwgXCJ4XCIsIG1hc2tMZW5ndGgpXG4gICAgICAgICAgICAgICAgbWFza2VkVGV4dCArPSBzb3VyY2Uuc3Vic3RyaW5nKHByZXZJZCwgdGFnWzBdKSArIG1hc2tTdHJpbmdcbiAgICAgICAgICAgICAgICBwcmV2SWQgPSBzb3VyY2UubGVuZ3RoXG4gICAgICAgICAgICAgICAgYnJlYWtcblxuICAgICAgICBtYXNrZWRUZXh0ICs9IHNvdXJjZS5zdWJzdHJpbmcocHJldklkKVxuXG4gICAgICAgIHJldHVybiBtYXNrZWRUZXh0XG5cbiAgICBkb3RFbmNvZGU6ICh0ZXh0KSAtPlxuICAgICAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHRleHQpLnJlcGxhY2UoLyUvZywgXCIuXCIpXG5cbiAgICBkb3RFbmNvZGVMaW5rQnJlYWtpbmdGcmFnbWVudENoYXJhY3RlcnM6IChmcmFnbWVudCkgLT5cbiAgICAgICAgIyBUaGVzZSBjaGFyYWN0ZXJzIGFyZSBrbm93biB0byBicmVhayBpbnRlcm5hbCBsaW5rcyBpZiBmb3VuZCBpblxuICAgICAgICAjICAgZnJhZ21lbnRzXG4gICAgICAgICMgVGhpcyBmdW5jdGlvbiBpcyBub3QgdGVzdGVkIG9uIGxpbmsgcGF0aHMgb3IgYW5jaG9ycyFcbiAgICAgICAgZnJhZ21lbnQgPSBmcmFnbWVudC5yZXBsYWNlKC9cXFsvZywgXCIuNUJcIilcbiAgICAgICAgZnJhZ21lbnQgPSBmcmFnbWVudC5yZXBsYWNlKC9cXF0vZywgXCIuNURcIilcbiAgICAgICAgZnJhZ21lbnQgPSBmcmFnbWVudC5yZXBsYWNlKC9cXHsvZywgXCIuN0JcIilcbiAgICAgICAgZnJhZ21lbnQgPSBmcmFnbWVudC5yZXBsYWNlKC9cXH0vZywgXCIuN0RcIilcbiAgICAgICAgZnJhZ21lbnQgPSBmcmFnbWVudC5yZXBsYWNlKC9cXHwvZywgXCIuN0NcIilcbiAgICAgICAgcmV0dXJuIGZyYWdtZW50XG5cbiAgICBwcmVwYXJlUmVnZXhwV2hpdGVzcGFjZSA9ICh0aXRsZSkgLT5cbiAgICAgICAgIyBNZWRpYVdpa2kgdHJlYXRzIGNvbnNlY3V0aXZlIHdoaXRlc3BhY2UgY2hhcmFjdGVycyBpbiB0aXRsZXMgYW5kXG4gICAgICAgICMgICBzZWN0aW9uIG5hbWVzIGFzIG9uZVxuICAgICAgICAjIEZvciBleGFtcGxlIFtbTWFpbiBfXyBQYWdlI0ZpcnN0IF8gX3NlY3Rpb25dXSBpcyB0aGUgc2FtZSBhc1xuICAgICAgICAjICAgW1tNYWluIFBhZ2UjRmlyc3Qgc2VjdGlvbl1dXG4gICAgICAgICMgQ29uc2lkZXIgdHJpbW1pbmcgdGhlIHRpdGxlIGJlZm9yZSBwYXNzaW5nIGl0IGhlcmVcbiAgICAgICAgcmV0dXJuIHRpdGxlLnJlcGxhY2UoL1tfIF0rL2csIFwiW18gXStcIilcblxuICAgIHByZXBhcmVUaXRsZUNhc2luZyA9IChwYXR0ZXJuKSAtPlxuICAgICAgICBmaXJzdENoYXIgPSBwYXR0ZXJuLmNoYXJBdCgwKVxuICAgICAgICBmY1VwcGVyID0gZmlyc3RDaGFyLnRvVXBwZXJDYXNlKClcbiAgICAgICAgZmNMb3dlciA9IGZpcnN0Q2hhci50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGlmIGZjVXBwZXIgIT0gZmNMb3dlclxuICAgICAgICAgICAgcGF0dGVybiA9IFwiW1wiICsgZmNVcHBlciArIGZjTG93ZXIgKyBcIl1cIiArIHBhdHRlcm4uc3Vic3RyKDEpXG4gICAgICAgIHJldHVybiBwYXR0ZXJuXG5cbiAgICBjb21wYXJlQXJ0aWNsZVRpdGxlczogKHRpdGxlMSwgdGl0bGUyKSAtPlxuICAgICAgICAjIEFjdHVhbGx5IGFsc28gbmFtZXNwYWNlcyBzaG91bGQgYmUga2VwdCBpbnRvIGFjY291bnQsXG4gICAgICAgICMgZS5nLiAnSGVscDpUaXRsZScgYW5kICdIZWxwOnRpdGxlJyBzaG91bGQgcmV0dXJuIHRydWVcbiAgICAgICAgdDEgPSBwcmVwYXJlVGl0bGVDYXNpbmcodGhpcy5zcXVhc2hDb250aWd1b3VzV2hpdGVzcGFjZSh0aXRsZTEpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50cmltKCkpXG4gICAgICAgIHQyID0gcHJlcGFyZVRpdGxlQ2FzaW5nKHRoaXMuc3F1YXNoQ29udGlndW91c1doaXRlc3BhY2UodGl0bGUyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAudHJpbSgpKVxuICAgICAgICByZXR1cm4gdDEgPT0gdDJcblxuICAgIGZpbmRCZWhhdmlvclN3aXRjaGVzOiAoc291cmNlLCB3b3JkKSAtPlxuICAgICAgICBzb3VyY2UgPSB0aGlzLm5ldXRyYWxpemVOb3dpa2lUYWdzKHNvdXJjZSlcbiAgICAgICAgcmVnRXhwXG4gICAgICAgIGlmIHdvcmRcbiAgICAgICAgICAgICMgQmVoYXZpb3Igc3dpdGNoZXMgYXJlbid0IGNhc2Utc2Vuc2l0aXZlXG4gICAgICAgICAgICByZWdFeHAgPSBuZXcgUmVnRXhwKFwiX19cIiArIFJlZ0V4LmVzY2FwZVBhdHRlcm4od29yZCkgKyBcIl9fXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImdpXCIpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgICMgQmVoYXZpb3Igc3dpdGNoZXMgYXJlbid0IGNhc2Utc2Vuc2l0aXZlXG4gICAgICAgICAgICByZWdFeHAgPSBuZXcgUmVnRXhwKFwiX18oVE9DfE5PVE9DfEZPUkNFVE9DfE5PRURJVFNFQ1RJT058XCIgK1xuICAgICAgICAgICAgICAgICAgICBcIk5FV1NFQ1RJT05MSU5LfE5PTkVXU0VDVElPTkxJTkt8Tk9HQUxMRVJZfEhJRERFTkNBVHxcIiArXG4gICAgICAgICAgICAgICAgICAgIFwiTk9DT05URU5UQ09OVkVSVHxOT0NDfE5PVElUTEVDT05WRVJUfE5PVEN8SU5ERVh8XCIgK1xuICAgICAgICAgICAgICAgICAgICBcIk5PSU5ERVh8U1RBVElDUkVESVJFQ1R8U1RBUlR8RU5EKV9fXCIsIFwiZ2lcIilcbiAgICAgICAgcmV0dXJuIFJlZ0V4Lm1hdGNoQWxsKHNvdXJjZSwgcmVnRXhwKVxuXG4gICAgZmluZExpbmtzRW5naW5lOiAoc291cmNlLCB0aXRsZVBhdHRlcm4sIHNwZWNpYWxPbmx5LCBjYXNlU2Vuc2l0aXZlKSAtPlxuICAgICAgICAjIExpbmtzIGNhbm5vdCBjb250YWluIG90aGVyIGxpbmtzLCBub3QgZXZlbiBpbiB0aGUgYWx0ZXJuYXRpdmUgdGV4dFxuICAgICAgICAjICAgKG9ubHkgdGhlIGlubmVybW9zdCBsaW5rcyBhcmUgdmFsaWQpXG4gICAgICAgICMgTWFrZSBzdXJlIHRvIHByZXBhcmUgd2hpdGVzcGFjZSBpbiB0aXRsZVBhdHRlcm4gbGlrZSBpblxuICAgICAgICAjICAgcHJlcGFyZVJlZ2V4cFdoaXRlc3BhY2VcbiAgICAgICAgIyBEbyAqbm90KiB1c2UgdGhlIGcgZmxhZywgb3Igd2hlbiB1c2luZyBSZWdFeHAuZXhlYyB0aGUgaW5kZXggd2lsbFxuICAgICAgICAjICAgaGF2ZSB0byBiZSByZXNldCBhdCBldmVyeSBsb29wXG4gICAgICAgIGZsYWdzID0gaWYgY2FzZVNlbnNpdGl2ZSB0aGVuIFwiXCIgZWxzZSBcImlcIlxuICAgICAgICAjIFRoZSBmb2xsb3dpbmcgY29sb24vc3BhY2UgY29tYmluYXRpb25zIGFyZSB2YWxpZFxuICAgICAgICAjICAgXCJbW2E6YiNjfGRdXVwiXG4gICAgICAgICMgICBcIltbIGE6YiNjfGRdXVwiXG4gICAgICAgICMgICBcIltbIDphOmIjY3xkXV1cIlxuICAgICAgICAjICAgXCJbWyA6IGE6YiNjfGRdXVwiXG4gICAgICAgICMgICBcIltbOmE6YiNjfGRdXVwiXG4gICAgICAgICMgICBcIltbOiBhOmIjY3xkXV1cIlxuICAgICAgICAjICAgXCJbWzo6YTpiI2N8ZF1dXCJcbiAgICAgICAgIyAgIFwiW1s6IDphOmIjY3xkXV1cIlxuICAgICAgICAjICAgXCJbWzo6IGE6YiNjfGRdXVwiXG4gICAgICAgICMgICBcIltbOiA6IGE6YiNjfGRdXVwiXG4gICAgICAgICMgQSBsaW5rIGxpa2UgXCJbWyA6OmE6YiNjfGRdXVwiIGlzbid0IHZhbGlkLCBidXQgaXQgd291bGQgc3RpbGwgYmVcbiAgICAgICAgIyAgIGZvdW5kIHdoZW4gc3BlY2lhbE9ubHkgaXMgZmFsc2UgKGJ1ZyAjMTY2KVxuICAgICAgICBzcGVjaWFsID0gaWYgc3BlY2lhbE9ubHkgdGhlbiBcIig/OlsgX10rOik/WyBfXSpcIiBlbHNlIFwiKD86XFxcXDo/WyBfXSopezAsMn1cIlxuICAgICAgICByZWdFeHAgPSBuZXcgUmVnRXhwKFwiXlwiICsgc3BlY2lhbCArIFwiKFwiICsgdGl0bGVQYXR0ZXJuICsgXCIpXCIgK1xuICAgICAgICAgICAgICAgICAgICBcIlsgX10qKD86XFxcXHxbX1xcXFxzXSooW1xcXFxzXFxcXFNdKz8pW19cXFxcc10qKT9bX1xcXFxzXSokXCIsIGZsYWdzKVxuICAgICAgICBuU291cmNlID0gQG5ldXRyYWxpemVOb3dpa2lUYWdzKHNvdXJjZSlcbiAgICAgICAgbGlua3MgPSBbXVxuICAgICAgICBkYnJhY2VzID0gU3RyLmZpbmRJbm5lcm1vc3RFbmNsb3N1cmVzKG5Tb3VyY2UsIFwiW1tcIiwgXCJdXVwiKVxuXG4gICAgICAgIGZvciBkYnJhY2UgaW4gZGJyYWNlc1xuICAgICAgICAgICAgaW5UZXh0ID0gc291cmNlLnN1YnN0cmluZyhkYnJhY2VbMF0gKyAyLCBkYnJhY2VbMV0pXG4gICAgICAgICAgICBtYXRjaCA9IHJlZ0V4cC5leGVjKGluVGV4dClcblxuICAgICAgICAgICAgaWYgbWF0Y2hcbiAgICAgICAgICAgICAgICBwdXNoID0gdHJ1ZVxuXG4gICAgICAgICAgICAgICAgaWYgbWF0Y2hbNl1cbiAgICAgICAgICAgICAgICAgICAgIyBJbmNvbXBsZXRlIHRlbXBsYXRlcyBpbiB0aGUgYWx0ZXJuYXRpdmUgdGV4dCBoYXZlIGFuXG4gICAgICAgICAgICAgICAgICAgICMgICBhcHBhcmVudGx5IHdlaXJkIGJlaGF2aW91ciwgaGFyZCB0byByZXZlcnNlLWVuZ2luZWVyLFxuICAgICAgICAgICAgICAgICAgICAjICAgc28gaXNzdWUgYSB3YXJuaW5nIHdoZW4gb25lIGlzIGZvdW5kXG4gICAgICAgICAgICAgICAgICAgICMgICBTZWUgYWxzbyB0aGUgZXhhbXBsZXMgaW4gQGZpbmRUcmFuc2NsdXNpb25Bcmd1bWVudHNcbiAgICAgICAgICAgICAgICAgICAgIyBOb3RlIHRoYXQgdGhlIHRpdGxlIGFscmVhZHkgZG9lc24ndCBhbGxvdyBcIntcIiBvciBcIn1cIlxuICAgICAgICAgICAgICAgICAgICBuVGV4dCA9IEBuZXV0cmFsaXplTm93aWtpVGFncyhtYXRjaFs2XSlcbiAgICAgICAgICAgICAgICAgICAgbWFza2VkVGV4dCA9IFN0ci5maW5kTmVzdGVkRW5jbG9zdXJlcyhuVGV4dCwgXCJ7e1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwifX1cIiwgXCJ4XCIpWzFdXG5cbiAgICAgICAgICAgICAgICAgICAgaWYgbWFza2VkVGV4dC5zZWFyY2goLyhcXHtcXHt8XFx9XFx9KS8pID4gLTFcbiAgICAgICAgICAgICAgICAgICAgICAgIEBXTS5Mb2cubG9nV2FybmluZyhcIltbXCIgKyBtYXRjaFswXSArIFwiXV0gc2VlbXMgdG9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250YWluIHBhcnQgb2YgYSB0ZW1wbGF0ZSwgYW5kIHRoZSByZXN1bHRpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZWhhdmlvdXIgY2Fubm90IGJlIHByZWRpY3RlZCBieSB0aGlzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24sIHNvIHRoZSBsaW5rIHdpbGwgYmUgaWdub3JlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsdG9nZXRoZXJcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHB1c2ggPSBmYWxzZVxuXG4gICAgICAgICAgICAgICAgaWYgcHVzaFxuICAgICAgICAgICAgICAgICAgICBsaW5rcy5wdXNoKFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJyYXdMaW5rXCI6IFwiW1tcIiArIG1hdGNoWzBdICsgXCJdXVwiXG4gICAgICAgICAgICAgICAgICAgICAgICBcImxpbmtcIjogbWF0Y2hbMV1cbiAgICAgICAgICAgICAgICAgICAgICAgIFwicmF3VGl0bGVcIjogbWF0Y2hbMl1cbiAgICAgICAgICAgICAgICAgICAgICAgIFwibmFtZXNwYWNlXCI6IG1hdGNoWzNdXG4gICAgICAgICAgICAgICAgICAgICAgICBcInRpdGxlXCI6IG1hdGNoWzRdXG4gICAgICAgICAgICAgICAgICAgICAgICBcImZyYWdtZW50XCI6IG1hdGNoWzVdXG4gICAgICAgICAgICAgICAgICAgICAgICBcImFuY2hvclwiOiBtYXRjaFs2XVxuICAgICAgICAgICAgICAgICAgICAgICAgXCJpbmRleFwiOiBkYnJhY2VbMF1cbiAgICAgICAgICAgICAgICAgICAgICAgIFwibGVuZ3RoXCI6IGRicmFjZVsxXSArIDIgLSBkYnJhY2VbMF0pXG5cbiAgICAgICAgcmV0dXJuIGxpbmtzXG5cbiAgICBmaW5kU2VjdGlvbkxpbmtzOiAoc291cmNlKSAtPlxuICAgICAgICAjIEtlZXAgdGhlIGNhcHR1cmluZyBncm91cHMgYXMgcmVxdWlyZWQgYnkgQGZpbmRMaW5rc0VuZ2luZVxuICAgICAgICBmcmFnbWVudENoYXJzID0gXCJbXlxcXFxuXFxcXHtcXFxcfVxcXFxbXFxcXF1cXFxcfF0qP1wiXG4gICAgICAgIHRpdGxlUGF0dGVybiA9IFwiKCgpKCkpIyhcIiArIGZyYWdtZW50Q2hhcnMgKyBcIilcIlxuICAgICAgICByZXR1cm4gQGZpbmRMaW5rc0VuZ2luZShzb3VyY2UsIHRpdGxlUGF0dGVybiwgZmFsc2UsIHRydWUpXG5cbiAgICBmaW5kSW50ZXJuYWxMaW5rczogKHNvdXJjZSwgbmFtZXNwYWNlLCB0aXRsZSkgLT5cbiAgICAgICAgIyBLZWVwIHRoZSBjYXB0dXJpbmcgZ3JvdXBzIGFzIHJlcXVpcmVkIGJ5IEBmaW5kTGlua3NFbmdpbmVcbiAgICAgICAgbmFtZXNwYWNlQ2hhcnMgPSBcIlteXFxcXG5cXFxce1xcXFx9XFxcXFtcXFxcXVxcXFx8XFxcXDpcXFxcI10rP1wiXG4gICAgICAgIHRpdGxlQ2hhcnMgPSBcIlteXFxcXG5cXFxce1xcXFx9XFxcXFtcXFxcXVxcXFx8XFxcXCNdKz9cIlxuICAgICAgICBmcmFnbWVudENoYXJzID0gXCJbXlxcXFxuXFxcXHtcXFxcfVxcXFxbXFxcXF1cXFxcfF0qP1wiXG5cbiAgICAgICAgaWYgbmFtZXNwYWNlXG4gICAgICAgICAgICByZW5zID0gcHJlcGFyZVJlZ2V4cFdoaXRlc3BhY2UoUmVnRXguZXNjYXBlUGF0dGVybihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lc3BhY2UpKVxuXG4gICAgICAgICAgICBpZiB0aXRsZVxuICAgICAgICAgICAgICAgIHJldGl0bGUgPSBwcmVwYXJlUmVnZXhwV2hpdGVzcGFjZShSZWdFeC5lc2NhcGVQYXR0ZXJuKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZSkpXG4gICAgICAgICAgICAgICAgdGl0bGVQYXR0ZXJuID0gXCIoKFwiICsgcmVucyArIFwiKVsgX10qOlsgX10qXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiKFwiICsgcmV0aXRsZSArIFwiKSlcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIoPzpbIF9dKiMoXCIgKyBmcmFnbWVudENoYXJzICsgXCIpKT9cIlxuXG4gICAgICAgICAgICAgICAgIyBOYW1lc3BhY2VzIHdvdWxkbid0IGJlIGNhc2Utc2Vuc2l0aXZlLCBidXQgdGl0bGVzIGFyZSwgc28gYmVcbiAgICAgICAgICAgICAgICAjICAgc2FmZSBhbmQgZG9uJ3QgdXNlIHRoZSBpIGZsYWdcbiAgICAgICAgICAgICAgICBjYXNlU2Vuc2l0aXZlID0gdHJ1ZVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRpdGxlUGF0dGVybiA9IFwiKChcIiArIHJlbnMgKyBcIilbIF9dKjpbIF9dKlwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIihcIiArIHRpdGxlQ2hhcnMgKyBcIikpXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiKD86WyBfXSojKFwiICsgZnJhZ21lbnRDaGFycyArIFwiKSk/XCJcblxuICAgICAgICAgICAgICAgICMgTmFtZXNwYWNlcyBhcmVuJ3QgY2FzZS1zZW5zaXRpdmVcbiAgICAgICAgICAgICAgICBjYXNlU2Vuc2l0aXZlID0gZmFsc2VcbiAgICAgICAgZWxzZSBpZiB0aXRsZVxuICAgICAgICAgICAgcmV0aXRsZSA9IHByZXBhcmVSZWdleHBXaGl0ZXNwYWNlKFJlZ0V4LmVzY2FwZVBhdHRlcm4oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlKSlcblxuICAgICAgICAgICAgIyBLZWVwIHRoZSBjYXB0dXJpbmcgZ3JvdXBzIGFzIHJlcXVpcmVkIGJ5IEBmaW5kTGlua3NFbmdpbmVcbiAgICAgICAgICAgIHRpdGxlUGF0dGVybiA9IFwiKCgpKFwiICsgcmV0aXRsZSArIFwiKSlcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIoPzpbIF9dKiMoXCIgKyBmcmFnbWVudENoYXJzICsgXCIpKT9cIlxuXG4gICAgICAgICAgICAjIFRpdGxlcyBhcmUgY2FzZS1zZW5zaXRpdmVcbiAgICAgICAgICAgIGNhc2VTZW5zaXRpdmUgPSB0cnVlXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRpdGxlUGF0dGVybiA9IFwiKCg/OihcIiArIG5hbWVzcGFjZUNoYXJzICsgXCIpWyBfXSo6WyBfXSopP1wiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIihcIiArIHRpdGxlQ2hhcnMgKyBcIikpXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiKD86WyBfXSojKFwiICsgZnJhZ21lbnRDaGFycyArIFwiKSk/XCJcbiAgICAgICAgICAgIGNhc2VTZW5zaXRpdmUgPSB0cnVlXG5cbiAgICAgICAgcmV0dXJuIEBmaW5kTGlua3NFbmdpbmUoc291cmNlLCB0aXRsZVBhdHRlcm4sIGZhbHNlLCBjYXNlU2Vuc2l0aXZlKVxuXG4gICAgZmluZEludGVyd2lraUxpbmtzOiAoc291cmNlLCB3aWtpKSAtPlxuICAgICAgICByZXR1cm4gdGhpcy5maW5kSW50ZXJuYWxMaW5rcyhzb3VyY2UsIHdpa2kpXG5cbiAgICBmaW5kU3BlY2lhbExpbmtzOiAoc291cmNlLCBwYXR0ZXJuKSAtPlxuICAgICAgICAjIE1ha2Ugc3VyZSB0byBwcmVwYXJlIHdoaXRlc3BhY2UgaW4gcGF0dGVybiBsaWtlIGluXG4gICAgICAgICMgICBwcmVwYXJlUmVnZXhwV2hpdGVzcGFjZVxuICAgICAgICAjIEtlZXAgdGhlIGNhcHR1cmluZyBncm91cHMgYXMgcmVxdWlyZWQgYnkgQGZpbmRMaW5rc0VuZ2luZVxuICAgICAgICAjIFNlZSBhbHNvIEBXTS5BcmNoV2lraS5maW5kQWxsSW50ZXJsYW5ndWFnZUxpbmtzXG4gICAgICAgIHRpdGxlQ2hhcnMgPSBcIlteXFxcXG5cXFxce1xcXFx9XFxcXFtcXFxcXVxcXFx8XFxcXCNdKz9cIlxuICAgICAgICBmcmFnbWVudENoYXJzID0gXCJbXlxcXFxuXFxcXHtcXFxcfVxcXFxbXFxcXF1cXFxcfF0qP1wiXG4gICAgICAgIHRpdGxlUGF0dGVybiA9IFwiKChcIiArIHBhdHRlcm4gKyBcIilbIF9dKjpbIF9dKlwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIihcIiArIHRpdGxlQ2hhcnMgKyBcIikpXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiKD86WyBfXSojKFwiICsgZnJhZ21lbnRDaGFycyArIFwiKSk/XCJcbiAgICAgICAgIyBDYXRlZ29yaWVzIGFuZCBsYW5ndWFnZSB0YWdzIGFyZW4ndCBjYXNlLXNlbnNpdGl2ZVxuICAgICAgICByZXR1cm4gQGZpbmRMaW5rc0VuZ2luZShzb3VyY2UsIHRpdGxlUGF0dGVybiwgdHJ1ZSwgZmFsc2UpXG5cbiAgICBmaW5kQ2F0ZWdvcmllczogKHNvdXJjZSkgLT5cbiAgICAgICAgcmV0dXJuIHRoaXMuZmluZFNwZWNpYWxMaW5rcyhzb3VyY2UsIFwiQ2F0ZWdvcnlcIilcblxuICAgIGZpbmRJbnRlcmxhbmd1YWdlTGlua3M6IChzb3VyY2UsIGxhbmd1YWdlKSAtPlxuICAgICAgICAjIFNlZSBhbHNvIEBXTS5BcmNoV2lraS5maW5kQWxsSW50ZXJsYW5ndWFnZUxpbmtzXG4gICAgICAgIHJldHVybiB0aGlzLmZpbmRTcGVjaWFsTGlua3Moc291cmNlLCBSZWdFeC5lc2NhcGVQYXR0ZXJuKGxhbmd1YWdlKSlcblxuICAgIGZpbmRWYXJpYWJsZXM6IChzb3VyY2UsIHZhcmlhYmxlKSAtPlxuICAgICAgICAjIFRoZXJlIGRvbid0IHNlZW0gdG8gZXhpc3QgdmFyaWFibGUgbmFtZXMgd2l0aCB3aGl0ZXNwYWNlLCBhcHBseWluZ1xuICAgICAgICAjICAgcHJlcGFyZVJlZ2V4cFdoaXRlc3BhY2UgY291bGQgYmUgZGFuZ2Vyb3VzIGluIHRoaXMgY2FzZVxuICAgICAgICBwYXR0ZXJuID0gUmVnRXguZXNjYXBlUGF0dGVybih2YXJpYWJsZSlcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluZFZhcmlhYmxlc1BhdHRlcm4oc291cmNlLCBwYXR0ZXJuKVxuXG4gICAgZmluZFZhcmlhYmxlc1BhdHRlcm46IChzb3VyY2UsIHBhdHRlcm4pIC0+XG4gICAgICAgICMgcGF0dGVybiBtdXN0IGJlIGEgc3RyaW5nIGFuZCBJVCBNVVNUIE5PVCBIQVZFIEFOWSBDQVBUVVJJTkdcbiAgICAgICAgIyAgIEdST1VQU1xuICAgICAgICAjIFRoZXJlIGNhbid0IGJlIGFuIHVuZGVyc2NvcmUgYmVmb3JlIHRoZSB2YXJpYWJsZSBuYW1lXG4gICAgICAgICMgVGhlcmUgY2FuJ3QgYmUgYSB3aGl0ZXNwYWNlIGJldHdlZW4gdGhlIHZhcmlhYmxlIG5hbWUgYW5kIHRoZSBjb2xvblxuICAgICAgICBuU291cmNlID0gdGhpcy5uZXV0cmFsaXplTm93aWtpVGFncyhzb3VyY2UpXG4gICAgICAgIHJlc3VsdHMgPSBbXVxuICAgICAgICBkYnJhY2tldHMgPSBTdHIuZmluZE5lc3RlZEVuY2xvc3VyZXMoblNvdXJjZSwgXCJ7e1wiLCBcIn19XCIsIFwieFwiKVswXVxuXG4gICAgICAgIGZvciBkYnJhY2tldCBpbiBkYnJhY2tldHNcbiAgICAgICAgICAgIGluVGV4dCA9IHNvdXJjZS5zdWJzdHJpbmcoZGJyYWNrZXRbMF0gKyAyLCBkYnJhY2tldFsxXSlcblxuICAgICAgICAgICAgIyBWYXJpYWJsZXMgYXJlIGNhc2Utc2Vuc2l0aXZlXG4gICAgICAgICAgICAjIERvICpub3QqIHVzZSB0aGUgZyBmbGFnLCBvciB3aGVuIHVzaW5nIFJlZ0V4cC5leGVjIHRoZSBpbmRleFxuICAgICAgICAgICAgIyAgIHdpbGwgaGF2ZSB0byBiZSByZXNldCBhdCBldmVyeSBsb29wXG4gICAgICAgICAgICByZWdFeHAgPSBuZXcgUmVnRXhwKFwiXlxcXFxzKihcIiArIHBhdHRlcm4gKyBcIilcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIoPzpcXFxcOlxcXFxzKihbXFxcXHNcXFxcU10qPykpP1xcXFxzKiRcIiwgXCJcIilcbiAgICAgICAgICAgIG1hdGNoID0gcmVnRXhwLmV4ZWMoaW5UZXh0KVxuXG4gICAgICAgICAgICBpZiBtYXRjaFxuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChcbiAgICAgICAgICAgICAgICAgICAgXCJyYXdWYXJpYWJsZVwiOiBcInt7XCIgKyBtYXRjaFswXSArIFwifX1cIlxuICAgICAgICAgICAgICAgICAgICBcIm5hbWVcIjogbWF0Y2hbMV1cbiAgICAgICAgICAgICAgICAgICAgXCJ2YWx1ZVwiOiBtYXRjaFsyXVxuICAgICAgICAgICAgICAgICAgICBcImluZGV4XCI6IGRicmFja2V0WzBdXG4gICAgICAgICAgICAgICAgICAgIFwibGVuZ3RoXCI6IGRicmFja2V0WzFdICsgMiAtIGRicmFja2V0WzBdKVxuXG4gICAgICAgIHJldHVybiByZXN1bHRzXG5cbiAgICBmaW5kVHJhbnNjbHVzaW9uc0VuZ2luZTogKHNvdXJjZSwgcGF0dGVybiwgdGVtcGxhdGVzT25seSkgLT5cbiAgICAgICAgIyBwYXR0ZXJuIG11c3QgYmUgYSBzdHJpbmcgYW5kIElUIE1VU1QgTk9UIEhBVkUgQU5ZIENBUFRVUklOR1xuICAgICAgICAjICAgR1JPVVBTXG4gICAgICAgICMgTWFrZSBzdXJlIHRvIHByZXBhcmUgd2hpdGVzcGFjZSBpbiBwYXR0ZXJuIGxpa2UgaW5cbiAgICAgICAgIyAgIHByZXBhcmVSZWdleHBXaGl0ZXNwYWNlXG4gICAgICAgICMgVGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBnZW5lcmljIHRyYW5zY2x1c2lvbnMgYW5kIHRlbXBsYXRlcyBpcyB0aGVcbiAgICAgICAgIyAgIHBvc3NpYmlsaXR5IG9mIGEgY29sb24gYmVmb3JlIHRoZSB0aXRsZSB3aGljaCBmb3JjZXMgdGhlXG4gICAgICAgICMgICB0cmFuc2NsdXNpb24gb2YgYSBwYWdlIGluc3RlYWQgb2YgYSB0ZW1wbGF0ZVxuICAgICAgICAjIFRoZXJlIGNhbid0IGJlIGFuIHVuZGVyc2NvcmUgYmVmb3JlIHRoZSBjb2xvblxuICAgICAgICAjIFRoZSB0aXRsZSBtdXN0IG5vdCBiZSBicm9rZW4gYnkgbmV3IGxpbmUgY2hhcmFjdGVyczsgYW55IHVuZGVyc2NvcmVzXG4gICAgICAgICMgICBtdXN0IGJlIGluIHRoZSBzYW1lIGxpbmUgYXMgdGhlIHRpdGxlLCBldmVuIHRob3VnaCB0aGVuIHRoZXkgYXJlXG4gICAgICAgICMgICBjb25zaWRlcmVkIGFzIHdoaXRlc3BhY2VcbiAgICAgICAgIyBUZW1wbGF0ZSBuYW1lcyBhcmUgY2FzZS1zZW5zaXRpdmUsIGp1c3QgbWFrZSBzdXJlIHRvIHByZXBhcmUgdGhlbVxuICAgICAgICAjICAgd2l0aCBwcmVwYXJlVGl0bGVDYXNpbmdcbiAgICAgICAgIyBEbyAqbm90KiB1c2UgdGhlIGcgZmxhZywgb3Igd2hlbiB1c2luZyBSZWdFeHAuZXhlYyB0aGUgaW5kZXggd2lsbFxuICAgICAgICAjICAgaGF2ZSB0byBiZSByZXNldCBhdCBldmVyeSBsb29wXG4gICAgICAgIHJlZ0V4cCA9IG5ldyBSZWdFeHAoXCJeKFxcXFxzKlwiICsgKGlmIHRlbXBsYXRlc09ubHkgdGhlbiBcIlwiIGVsc2UgXCI6P1wiKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJbXyBdKihcIiArIHBhdHRlcm4gKyBcIilbXyBdKlxcXFxzKilcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIoPzpcXFxcfChbXFxcXHNcXFxcU10qKSk/JFwiLCBcIlwiKVxuXG4gICAgICAgIG5Tb3VyY2UgPSBAbmV1dHJhbGl6ZU5vd2lraVRhZ3Moc291cmNlKVxuICAgICAgICB0cmFuc2NsdXNpb25zID0gW11cbiAgICAgICAgZGJyYWNrZXRzID0gU3RyLmZpbmROZXN0ZWRFbmNsb3N1cmVzKG5Tb3VyY2UsIFwie3tcIiwgXCJ9fVwiLCBcInhcIilbMF1cblxuICAgICAgICBmb3IgZGJyYWNrZXQgaW4gZGJyYWNrZXRzXG4gICAgICAgICAgICBpblRleHQgPSBzb3VyY2Uuc3Vic3RyaW5nKGRicmFja2V0WzBdICsgMiwgZGJyYWNrZXRbMV0pXG4gICAgICAgICAgICBtYXRjaCA9IHJlZ0V4cC5leGVjKGluVGV4dClcblxuICAgICAgICAgICAgaWYgbWF0Y2hcbiAgICAgICAgICAgICAgICAjIDMgaXMgdGhlIGxlbmd0aCBvZiBcInt7XCIgKyB0aGUgZmlyc3QgXCJ8XCJcbiAgICAgICAgICAgICAgICBhcmdJbmRleCA9IGRicmFja2V0WzBdICsgbWF0Y2hbMV0ubGVuZ3RoICsgM1xuXG4gICAgICAgICAgICAgICAgdHJhbnNjbHVzaW9ucy5wdXNoKFxuICAgICAgICAgICAgICAgICAgICBcInJhd1RyYW5zY2x1c2lvblwiOiBcInt7XCIgKyBtYXRjaFswXSArIFwifX1cIlxuICAgICAgICAgICAgICAgICAgICBcInRpdGxlXCI6IG1hdGNoWzJdXG4gICAgICAgICAgICAgICAgICAgIFwiaW5kZXhcIjogZGJyYWNrZXRbMF1cbiAgICAgICAgICAgICAgICAgICAgXCJsZW5ndGhcIjogZGJyYWNrZXRbMV0gLSBkYnJhY2tldFswXSArIDJcbiAgICAgICAgICAgICAgICAgICAgXCJhcmd1bWVudHNcIjogQGZpbmRUcmFuc2NsdXNpb25Bcmd1bWVudHMobWF0Y2gsIGFyZ0luZGV4KVxuICAgICAgICAgICAgICAgIClcblxuICAgICAgICByZXR1cm4gdHJhbnNjbHVzaW9uc1xuXG4gICAgZmluZFRyYW5zY2x1c2lvbkFyZ3VtZW50czogKG1hdGNoLCBhcmdJbmRleCkgLT5cbiAgICAgICAgcmF3QXJndW1lbnRzID0gbWF0Y2hbM11cbiAgICAgICAgYXJncyA9IFtdXG5cbiAgICAgICAgaWYgcmF3QXJndW1lbnRzXG4gICAgICAgICAgICBuQXJncyA9IEBuZXV0cmFsaXplTm93aWtpVGFncyhyYXdBcmd1bWVudHMpXG5cbiAgICAgICAgICAgICMgTWFzayBhbnkgaW5uZXIgbGlua3MsIHNvIHRoYXQgdGhlaXIgXCJ8XCIgY2hhcmFjdGVycyB3b24ndCBiZVxuICAgICAgICAgICAgIyAgIGludGVycHJldGVkIGFzIGJlbG9uZ2luZyB0byB0aGUgdGVtcGxhdGVcbiAgICAgICAgICAgICMgICBOb3RlIHRoYXQgZG91YmxlIGJyYWNlcyAoXCJbW11dXCIpIFwiZXNjYXBlXCIgYSBwaXBlIGluIGEgdGVtcGxhdGVcbiAgICAgICAgICAgICMgICBhcmd1bWVudCBldmVuIGlmIGEgbGluayBpcyBub3QgY29ycmVjdGx5IGZvcm1lZCwgZS5nLiBbW3xdXSBvclxuICAgICAgICAgICAgIyAgIHVzaW5nIHVuYWxsb3dlZCBjaGFyYWN0ZXJzIGV0Yy5cbiAgICAgICAgICAgIG1hc2tlZEFyZ3MgPSBTdHIuZmluZE5lc3RlZEVuY2xvc3VyZXMobkFyZ3MsIFwiW1tcIiwgXCJdXVwiLCBcInhcIilbMV1cblxuICAgICAgICAgICAgIyBNYXNrIGFueSBpbm5lciB0ZW1wbGF0ZXMsIHNvIHRoYXQgdGhlaXIgXCJ8XCIgY2hhcmFjdGVycyB3b24ndCBiZVxuICAgICAgICAgICAgIyAgIGludGVycHJldGVkIGFzIGJlbG9uZ2luZyB0byB0aGUgb3V0ZXIgdGVtcGxhdGVcbiAgICAgICAgICAgIG1hc2tlZEFyZ3MgPSBTdHIuZmluZE5lc3RlZEVuY2xvc3VyZXMobWFza2VkQXJncywgXCJ7e1wiLCBcIn19XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwieFwiKVsxXVxuXG4gICAgICAgICAgICAjIEFsc28gdGFibGVzIHdvdWxkIGhhdmUgcGlwZXMsIGJ1dCB1c2luZyB0YWJsZXMgaW5zaWRlIHRlbXBsYXRlc1xuICAgICAgICAgICAgIyAgIGRvZXNuJ3Qgc2VlbSB0byBiZSBzdXBwb3J0ZWQgYnkgTWVkaWFXaWtpLCBleGNlcHQgaWYgZW5jbG9zaW5nXG4gICAgICAgICAgICAjICAgdGhlbSBpbiBzcGVjaWFsIHBhcnNlciBmdW5jdGlvbnMsIGUuZy5cbiAgICAgICAgICAgICMgICBodHRwOi8vd3d3Lm1lZGlhd2lraS5vcmcvd2lraS9FeHRlbnNpb246UGlwZV9Fc2NhcGUgd2hpY2hcbiAgICAgICAgICAgICMgICB3b3VsZCB0aGVuIGJlIHNhZmVseSBtYXNrZWQgYnkgdGhlIGZ1bmN0aW9uIGFib3ZlXG5cbiAgICAgICAgICAgICMgSW5jb21wbGV0ZSBsaW5rcyBhbmQgdGVtcGxhdGVzIGluIHRoZSBhcmd1bWVudHMgdGV4dCBoYXZlIGFuXG4gICAgICAgICAgICAjICAgYXBwYXJlbnRseSB3ZWlyZCBiZWhhdmlvdXIsIGhhcmQgdG8gcmV2ZXJzZS1lbmdpbmVlciwgc28gaXNzdWVcbiAgICAgICAgICAgICMgICBhIHdhcm5pbmcgd2hlbiBvbmUgaXMgZm91bmRcbiAgICAgICAgICAgICMgICBUcnkgZm9yIGV4YW1wbGUgdGhlIGZvbGxvd2luZyBjYXNlczpcbiAgICAgICAgICAgICMgICAgIDAwMHt7aGN8QkJCW1tBQUF8WlpafX1DQ0NdXTExMVxuICAgICAgICAgICAgIyAgICAgMDAwe3toY3xCQkJbW0FBQX19Q0NDfFpaWl1dMTExXG4gICAgICAgICAgICAjICAgICAwMDBbW0JCQnt7aGN8QUFBfFpaWl1dQ0NDfX0xMTFcbiAgICAgICAgICAgICMgICAgIDAwMHt7aGN8QkJCW1tBQUF8WlpafX1bW0tLS11dMTExMDAwe3toY3xBQUF8QkJCfX0xMTFcbiAgICAgICAgICAgICMgICAgIHt7YmN8e3tBY2N1cmFjeXxbW3Rlc3R9fV1dfX1cbiAgICAgICAgICAgICMgICAgIHt7YmN8e3tBY2N1cmFjeXxbW3Rlc3R8fX1dXX19XG4gICAgICAgICAgICAjICAgICB7e0FjY3VyYWN5fFtbfX1dXVxuICAgICAgICAgICAgIyAgICAge3tBY2N1cmFjeXxbW3Rlc3R8fX1dXVxuICAgICAgICAgICAgIyAgICAgW1t7e0FjY3VyYWN5fF1dfX1cbiAgICAgICAgICAgICMgICAgIFtbdGVzdHx7e0FjY3VyYWN5fF1dfX1cbiAgICAgICAgICAgICMgICAgIFtbdGVzdHx7e0FjY3VyYWN5fF1dXG4gICAgICAgICAgICAjICAgICBbW3Rlc3R8e3tpY3xhYWFdXX19XG4gICAgICAgICAgICAjICAgTm90ZSB0aGF0IHRoZSB0aXRsZSBhbHJlYWR5IGRvZXNuJ3QgYWxsb3cgXCJ7XCIsIFwifVwiLCBcIltcIiBub3JcbiAgICAgICAgICAgICMgICAgIFwiXVwiXG4gICAgICAgICAgICBpZiBtYXNrZWRBcmdzLnNlYXJjaCgvKFxce1xce3xcXH1cXH18XFxbXFxbfFxcXVxcXSkvKSA+IC0xXG4gICAgICAgICAgICAgICAgQFdNLkxvZy5sb2dXYXJuaW5nKFwie3tcIiArIG1hdGNoWzBdICsgXCJ9fSBzZWVtcyB0b1xuICAgICAgICAgICAgICAgICAgICBjb250YWluIHBhcnQgb2YgYSBsaW5rIG9yIHRlbXBsYXRlLCBhbmQgdGhlIHJlc3VsdGluZ1xuICAgICAgICAgICAgICAgICAgICBiZWhhdmlvdXIgY2Fubm90IGJlIHByZWRpY3RlZCBieSB0aGlzIGZ1bmN0aW9uLCBzb1xuICAgICAgICAgICAgICAgICAgICB0aGUgd2hvbGUgdGVtcGxhdGUgd2lsbCBiZSBpZ25vcmVkIGFsdG9nZXRoZXJcIilcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBtQXJncyA9IG1hc2tlZEFyZ3Muc3BsaXQoXCJ8XCIpXG4gICAgICAgICAgICAgICAgcmVsSW5kZXggPSAwXG5cbiAgICAgICAgICAgICAgICBmb3IgbUFyZ3VtZW50IGluIG1BcmdzXG4gICAgICAgICAgICAgICAgICAgIGFyZ0wgPSBtQXJndW1lbnQubGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50ID0gcmF3QXJndW1lbnRzLnN1YnN0cihyZWxJbmRleCwgYXJnTClcbiAgICAgICAgICAgICAgICAgICAgZXFJbmRleCA9IG1Bcmd1bWVudC5pbmRleE9mKFwiPVwiKVxuXG4gICAgICAgICAgICAgICAgICAgICMgZXFJbmRleCBtdXN0IGJlID4gMCwgbm90IC0xLCBpbiBmYWN0IHRoZSBrZXkgbXVzdCBub3QgYmVcbiAgICAgICAgICAgICAgICAgICAgIyAgIGVtcHR5XG4gICAgICAgICAgICAgICAgICAgIGlmIGVxSW5kZXggPiAwXG4gICAgICAgICAgICAgICAgICAgICAgICByYXdLZXkgPSBhcmd1bWVudC5zdWJzdHJpbmcoMCwgZXFJbmRleClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlS2V5ID0gL14oXFxzKikoLis/KVxccyokL1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5TWF0Y2hlcyA9IHJlS2V5LmV4ZWMocmF3S2V5KVxuICAgICAgICAgICAgICAgICAgICAgICAga2V5ID0ga2V5TWF0Y2hlc1syXVxuICAgICAgICAgICAgICAgICAgICAgICAga2V5SW5kZXggPSBhcmdJbmRleCArIChpZiBrZXlNYXRjaGVzWzFdIHRoZW4ga2V5TWF0Y2hlc1sxXS5sZW5ndGggZWxzZSAwKVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAjIDEgaXMgdGhlIGxlbmd0aCBvZiBcIj1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBhcmd1bWVudC5zdWJzdHIoZXFJbmRleCArIDEpXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZUluZGV4ID0gYXJnSW5kZXggKyBrZXlNYXRjaGVzWzBdLmxlbmd0aCArIDFcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAga2V5ID0gbnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAga2V5SW5kZXggPSBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGFyZ3VtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZUluZGV4ID0gYXJnSW5kZXhcblxuICAgICAgICAgICAgICAgICAgICBhcmdzLnB1c2goXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6IGtleVxuICAgICAgICAgICAgICAgICAgICAgICAga2V5X2luZGV4OiBrZXlJbmRleFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZV9pbmRleDogdmFsdWVJbmRleFxuICAgICAgICAgICAgICAgICAgICApXG5cbiAgICAgICAgICAgICAgICAgICAgIyAxIGlzIHRoZSBsZW5ndGggb2YgXCJ8XCJcbiAgICAgICAgICAgICAgICAgICAgcmVsSW5kZXggKz0gYXJnTCArIDFcblxuICAgICAgICByZXR1cm4gYXJnc1xuXG4gICAgZmluZFRlbXBsYXRlczogKHNvdXJjZSwgdGVtcGxhdGUpIC0+XG4gICAgICAgIGlmIHRlbXBsYXRlXG4gICAgICAgICAgICBwYXR0ZXJuID0gUmVnRXguZXNjYXBlUGF0dGVybih0ZW1wbGF0ZSlcbiAgICAgICAgICAgIHBhdHRlcm4gPSBwcmVwYXJlUmVnZXhwV2hpdGVzcGFjZShwYXR0ZXJuKVxuICAgICAgICAgICAgcGF0dGVybiA9IHByZXBhcmVUaXRsZUNhc2luZyhwYXR0ZXJuKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICBwYXR0ZXJuID0gXCJbXlxcXFxuXFxcXHtcXFxcfVxcXFxbXFxcXF1cXFxcfHxcXFxcI10rP1wiXG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZmluZFRlbXBsYXRlc1BhdHRlcm4oc291cmNlLCBwYXR0ZXJuKVxuXG4gICAgZmluZFRlbXBsYXRlc1BhdHRlcm46IChzb3VyY2UsIHBhdHRlcm4pIC0+XG4gICAgICAgICMgcGF0dGVybiBtdXN0IGJlIGEgc3RyaW5nIGFuZCBJVCBNVVNUIE5PVCBIQVZFIEFOWSBDQVBUVVJJTkdcbiAgICAgICAgIyAgIEdST1VQU1xuICAgICAgICAjIE1ha2Ugc3VyZSB0byBwcmVwYXJlIHdoaXRlc3BhY2UgaW4gcGF0dGVybiBsaWtlIGluXG4gICAgICAgICMgICBwcmVwYXJlUmVnZXhwV2hpdGVzcGFjZVxuICAgICAgICAjIFRlbXBsYXRlcyBjYW4ndCBiZSB0cmFuc2NsdWRlZCB3aXRoIGEgY29sb24gYmVmb3JlIHRoZSB0aXRsZVxuICAgICAgICAjIFRoZSB0aXRsZSBtdXN0IG5vdCBiZSBicm9rZW4gYnkgbmV3IGxpbmUgY2hhcmFjdGVyczsgYW55IHVuZGVyc2NvcmVzXG4gICAgICAgICMgICBtdXN0IGJlIGluIHRoZSBzYW1lIGxpbmUgYXMgdGhlIHRpdGxlLCBldmVuIHRob3VnaCB0aGVuIHRoZXkgYXJlXG4gICAgICAgICMgICBjb25zaWRlcmVkIGFzIHdoaXRlc3BhY2VcbiAgICAgICAgcmV0dXJuIEBmaW5kVHJhbnNjbHVzaW9uc0VuZ2luZShzb3VyY2UsIHBhdHRlcm4sIHRydWUpXG5cbiAgICBmaW5kVHJhbnNjbHVzaW9uczogKHNvdXJjZSwgbmFtZXNwYWNlLCB0aXRsZSkgLT5cbiAgICAgICAgIyBUaGUgZGlmZmVyZW5jZSBmcm9tIHRlbXBsYXRlcyBpcyB0aGUgcG9zc2liaWxpdHkgb2YgYSBjb2xvbiBiZWZvcmVcbiAgICAgICAgIyAgIHRoZSB0aXRsZSB3aGljaCBmb3JjZXMgdGhlIHRyYW5zY2x1c2lvbiBvZiBhIHBhZ2UgaW5zdGVhZCBvZiBhXG4gICAgICAgICMgICB0ZW1wbGF0ZVxuICAgICAgICAjIFRoZXJlIGNhbid0IGJlIGFuIHVuZGVyc2NvcmUgYmVmb3JlIHRoZSBjb2xvblxuICAgICAgICAjIFRoZSB0aXRsZSBtdXN0IG5vdCBiZSBicm9rZW4gYnkgbmV3IGxpbmUgY2hhcmFjdGVyczsgYW55IHVuZGVyc2NvcmVzXG4gICAgICAgICMgICBtdXN0IGJlIGluIHRoZSBzYW1lIGxpbmUgYXMgdGhlIHRpdGxlLCBldmVuIHRob3VnaCB0aGVuIHRoZXkgYXJlXG4gICAgICAgICMgICBjb25zaWRlcmVkIGFzIHdoaXRlc3BhY2VcbiAgICAgICAgdGl0bGVDaGFycyA9IFwiW15cXFxcblxcXFx7XFxcXH1cXFxcW1xcXFxdXFxcXHx8XFxcXCNdKz9cIlxuXG4gICAgICAgIGlmIG5hbWVzcGFjZVxuICAgICAgICAgICAgbmFtZXNwYWNlUGF0dGVybiA9IFJlZ0V4LmVzY2FwZVBhdHRlcm4obmFtZXNwYWNlKVxuICAgICAgICAgICAgbmFtZXNwYWNlUGF0dGVybiA9IHByZXBhcmVSZWdleHBXaGl0ZXNwYWNlKG5hbWVzcGFjZVBhdHRlcm4pXG4gICAgICAgICAgICBuYW1lc3BhY2VQYXR0ZXJuID0gcHJlcGFyZVRpdGxlQ2FzaW5nKG5hbWVzcGFjZVBhdHRlcm4pXG5cbiAgICAgICAgaWYgdGl0bGVcbiAgICAgICAgICAgIHRpdGxlUGF0dGVybiA9IFJlZ0V4LmVzY2FwZVBhdHRlcm4odGl0bGUpXG4gICAgICAgICAgICB0aXRsZVBhdHRlcm4gPSBwcmVwYXJlUmVnZXhwV2hpdGVzcGFjZSh0aXRsZVBhdHRlcm4pXG4gICAgICAgICAgICB0aXRsZVBhdHRlcm4gPSBwcmVwYXJlVGl0bGVDYXNpbmcodGl0bGVQYXR0ZXJuKVxuXG4gICAgICAgIGlmIG5hbWVzcGFjZVBhdHRlcm4gYW5kIHRpdGxlUGF0dGVyblxuICAgICAgICAgICAgcGF0dGVybiA9IG5hbWVzcGFjZVBhdHRlcm4gKyBcIlsgX10qOlsgX10qXCIgKyB0aXRsZVBhdHRlcm5cbiAgICAgICAgZWxzZSBpZiBub3QgbmFtZXNwYWNlUGF0dGVybiBhbmQgdGl0bGVQYXR0ZXJuXG4gICAgICAgICAgICBwYXR0ZXJuID0gdGl0bGVQYXR0ZXJuXG4gICAgICAgIGVsc2UgaWYgbmFtZXNwYWNlUGF0dGVybiBhbmQgbm90IHRpdGxlUGF0dGVyblxuICAgICAgICAgICAgcGF0dGVybiA9IG5hbWVzcGFjZVBhdHRlcm4gKyBcIlsgX10qOlwiICsgdGl0bGVDaGFyc1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBwYXR0ZXJuID0gdGl0bGVDaGFyc1xuXG4gICAgICAgIHJldHVybiBAZmluZFRyYW5zY2x1c2lvbnNFbmdpbmUoc291cmNlLCBwYXR0ZXJuLCBmYWxzZSlcblxuICAgIGZpbmRTZWN0aW9uSGVhZGluZ3M6IChzb3VyY2UpIC0+XG4gICAgICAgICMgPT09PT09VGl0bGU9PT09PT0gaXMgdGhlIGRlZXBlc3QgbGV2ZWwgc3VwcG9ydGVkXG4gICAgICAgIE1BWExFVkVMID0gNlxuXG4gICAgICAgIHNlY3Rpb25zID0gW11cbiAgICAgICAgbWluTGV2ZWwgPSBNQVhMRVZFTFxuICAgICAgICBtYXhUb2NMZXZlbCA9IDBcbiAgICAgICAgdG9jTGV2ZWwgPSAxXG4gICAgICAgIHJlZ0V4cCA9IC9eKFxcPSsoWyBfXSooLis/KVsgX10qKVxcPSspWyBcXHRdKiQvZ21cblxuICAgICAgICB3aGlsZSB0cnVlXG4gICAgICAgICAgICBtYXRjaCA9IHJlZ0V4cC5leGVjKHNvdXJjZSlcblxuICAgICAgICAgICAgaWYgbWF0Y2hcbiAgICAgICAgICAgICAgICBMMCA9IG1hdGNoWzBdLmxlbmd0aFxuICAgICAgICAgICAgICAgIGxpbmUgPSBtYXRjaFsxXVxuICAgICAgICAgICAgICAgIHJhd2hlYWRpbmcgPSBtYXRjaFsyXVxuICAgICAgICAgICAgICAgIGhlYWRpbmcgPSBtYXRjaFszXVxuICAgICAgICAgICAgICAgIGNsZWFuaGVhZGluZyA9IEBzcXVhc2hDb250aWd1b3VzV2hpdGVzcGFjZShoZWFkaW5nKVxuICAgICAgICAgICAgICAgIEwxID0gbGluZS5sZW5ndGhcbiAgICAgICAgICAgICAgICBsZXZlbCA9IDFcbiAgICAgICAgICAgICAgICBzdGFydCA9IFwiPVwiXG4gICAgICAgICAgICAgICAgZW5kID0gXCI9XCJcblxuICAgICAgICAgICAgICAgICMgPT1UaXRsZT09PSBhbmQgPT09VGl0bGU9PSBhcmUgYm90aCAybmQgbGV2ZWxzIGFuZCBzbyBvblxuICAgICAgICAgICAgICAgICMgKHRoZSBzaG9ydGVzdCBzZXF1ZW5jZSBvZiA9IGJldHdlZW4gdGhlIHR3byBzaWRlcyBpc1xuICAgICAgICAgICAgICAgICMgIGNvbnNpZGVyZWQpXG5cbiAgICAgICAgICAgICAgICAjID0gYW5kID09IGFyZSBub3QgdGl0bGVzXG4gICAgICAgICAgICAgICAgIyA9PT0gaXMgcmVhZCBhcyA9KD0pPSwgPT09PSBpcyByZWFkIGFzID0oPT0pPSAoYm90aCAxc3RcbiAgICAgICAgICAgICAgICAjICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXZlbHMpXG4gICAgICAgICAgICAgICAgIyA9PT09PSBpcyByZWFkIGFzID09KD0pPT0gKDJuZCBsZXZlbCkgYW5kIHNvIG9uXG5cbiAgICAgICAgICAgICAgICB3aGlsZSB0cnVlXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gbGluZS5zdWJzdHIobGV2ZWwsIDEpXG4gICAgICAgICAgICAgICAgICAgIGVuZCA9IGxpbmUuc3Vic3RyKEwxIC0gbGV2ZWwgLSAxLCAxKVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIEwxIC0gbGV2ZWwgKiAyID4gMiBhbmQgc3RhcnQgPT0gXCI9XCIgYW5kIGVuZCA9PSBcIj1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgbGV2ZWwrK1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiBsZXZlbCA+IE1BWExFVkVMXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV2ZWwgPSBNQVhMRVZFTFxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiBsZXZlbCA8IG1pbkxldmVsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluTGV2ZWwgPSBsZXZlbFxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcblxuICAgICAgICAgICAgICAgIGlmIGxldmVsID09IG1pbkxldmVsXG4gICAgICAgICAgICAgICAgICAgIHRvY0xldmVsID0gMVxuICAgICAgICAgICAgICAgICAgICBwcmV2TGV2ZWxzID0ge31cbiAgICAgICAgICAgICAgICAgICAgcHJldkxldmVsc1tsZXZlbF0gPSAxXG4gICAgICAgICAgICAgICAgICAgIHByZXZMZXZlbHMucmVsTWF4ID0gbGV2ZWxcbiAgICAgICAgICAgICAgICAgICAgaWYgbWF4VG9jTGV2ZWwgPT0gMFxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4VG9jTGV2ZWwgPSB0b2NMZXZlbFxuICAgICAgICAgICAgICAgIGVsc2UgaWYgbGV2ZWwgPiBwcmV2TGV2ZWxzLnJlbE1heFxuICAgICAgICAgICAgICAgICAgICB0b2NMZXZlbCsrXG4gICAgICAgICAgICAgICAgICAgIHByZXZMZXZlbHNbbGV2ZWxdID0gdG9jTGV2ZWxcbiAgICAgICAgICAgICAgICAgICAgcHJldkxldmVscy5yZWxNYXggPSBsZXZlbFxuICAgICAgICAgICAgICAgICAgICBpZiB0b2NMZXZlbCA+IG1heFRvY0xldmVsXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhUb2NMZXZlbCA9IHRvY0xldmVsXG4gICAgICAgICAgICAgICAgZWxzZSBpZiBsZXZlbCA8IHByZXZMZXZlbHMucmVsTWF4XG4gICAgICAgICAgICAgICAgICAgIGlmIHByZXZMZXZlbHNbbGV2ZWxdXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2NMZXZlbCA9IHByZXZMZXZlbHNbbGV2ZWxdXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICMgdG9jUGVlciBpcyB0aGUgbGV2ZWwgaW1tZWRpYXRlbHkgZ3JlYXRlciB0aGFuIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgIyBjdXJyZW50IG9uZSwgYW5kIGl0IHNob3VsZCBoYXZlIHRoZSBzYW1lIHRvY0xldmVsXG4gICAgICAgICAgICAgICAgICAgICAgICAjIEkgbXVzdCByZXNldCB0b2NQZWVyIGhlcmUgdG8gdGhlIHJlbGF0aXZlIG1heGltdW1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRvY1BlZXIgPSBwcmV2TGV2ZWxzLnJlbE1heFxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIHBMZXZlbCBpbiBwcmV2TGV2ZWxzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgcExldmVsID4gbGV2ZWwgYW5kIHBMZXZlbCA8IHRvY1BlZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9jUGVlciA9IHBMZXZlbFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9jTGV2ZWwgPSBwcmV2TGV2ZWxzW3RvY1BlZXJdXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2TGV2ZWxzW2xldmVsXSA9IHRvY0xldmVsXG4gICAgICAgICAgICAgICAgICAgIHByZXZMZXZlbHMucmVsTWF4ID0gbGV2ZWxcblxuICAgICAgICAgICAgICAgIHNlY3Rpb25zLnB1c2goXG4gICAgICAgICAgICAgICAgICAgIGxpbmU6IGxpbmVcbiAgICAgICAgICAgICAgICAgICAgcmF3aGVhZGluZzogcmF3aGVhZGluZ1xuICAgICAgICAgICAgICAgICAgICBoZWFkaW5nOiBoZWFkaW5nXG4gICAgICAgICAgICAgICAgICAgIGNsZWFuaGVhZGluZzogY2xlYW5oZWFkaW5nXG4gICAgICAgICAgICAgICAgICAgIGxldmVsOiBsZXZlbFxuICAgICAgICAgICAgICAgICAgICB0b2NMZXZlbDogdG9jTGV2ZWxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IChyZWdFeHAubGFzdEluZGV4IC0gTDApXG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aDA6IEwwXG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aDE6IEwxXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgIyBBcnRpY2xlcyB3aXRob3V0IHNlY3Rpb25zXG4gICAgICAgIGlmIG1heFRvY0xldmVsID09IDBcbiAgICAgICAgICAgIG1pbkxldmVsID0gMFxuXG4gICAgICAgIHJldHVybiB7c2VjdGlvbnM6IHNlY3Rpb25zLCBtaW5MZXZlbDogbWluTGV2ZWwsIG1heFRvY0xldmVsOiBtYXhUb2NMZXZlbH1cbiIsIiMgV2lraSBNb25rZXkgLSBNZWRpYVdpa2kgYm90IGFuZCBlZGl0b3ItYXNzaXN0YW50IHVzZXIgc2NyaXB0XG4jIENvcHlyaWdodCAoQykgMjAxMSBEYXJpbyBHaW92YW5uZXR0aSA8ZGV2QGRhcmlvZ2lvdmFubmV0dGkubmV0PlxuI1xuIyBUaGlzIGZpbGUgaXMgcGFydCBvZiBXaWtpIE1vbmtleS5cbiNcbiMgV2lraSBNb25rZXkgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuIyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuIyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuIyAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuI1xuIyBXaWtpIE1vbmtleSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuIyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuIyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4jIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4jXG4jIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4jIGFsb25nIHdpdGggV2lraSBNb25rZXkuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG5cblN0ciA9IHJlcXVpcmUoJ0BreW5pa29zL21pc2MvZGlzdC9TdHInKVxuXG5cbmNsYXNzIG1vZHVsZS5leHBvcnRzXG4gICAgY29uc3RydWN0b3I6IChAV00pIC0+XG5cbiAgICBhcHBlbmRSb3c6IChzb3VyY2UsIG1hcmssIHZhbHVlcykgLT5cbiAgICAgICAgbGFzdElkID0gc291cmNlLmxhc3RJbmRleE9mKCd8fScgKyBtYXJrKVxuICAgICAgICBlbmR0YWJsZSA9IGlmIGxhc3RJZCA+IC0xIHRoZW4gbGFzdElkIGVsc2Ugc291cmNlLmxhc3RJbmRleE9mKCd8fScpXG5cbiAgICAgICAgcm93ID0gXCJ8LVxcbnxcIiArIHZhbHVlcy5qb2luKFwiXFxufFwiKSArIFwiXFxuXCJcblxuICAgICAgICBuZXdUZXh0ID0gU3RyLmluc2VydChzb3VyY2UsIHJvdywgZW5kdGFibGUpXG5cbiAgICAgICAgcmV0dXJuIG5ld1RleHRcbiIsIiMgV2lraSBNb25rZXkgLSBNZWRpYVdpa2kgYm90IGFuZCBlZGl0b3ItYXNzaXN0YW50IHVzZXIgc2NyaXB0XG4jIENvcHlyaWdodCAoQykgMjAxMSBEYXJpbyBHaW92YW5uZXR0aSA8ZGV2QGRhcmlvZ2lvdmFubmV0dGkubmV0PlxuI1xuIyBUaGlzIGZpbGUgaXMgcGFydCBvZiBXaWtpIE1vbmtleS5cbiNcbiMgV2lraSBNb25rZXkgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuIyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuIyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuIyAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuI1xuIyBXaWtpIE1vbmtleSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuIyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuIyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4jIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4jXG4jIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4jIGFsb25nIHdpdGggV2lraSBNb25rZXkuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG5cbnt2ZXJzaW9ufSA9IHJlcXVpcmUoJy4uLy4uL3BhY2thZ2UuanNvbicpXG5DU1MgPSByZXF1aXJlKCdAa3luaWtvcy9taXNjL2Rpc3QvQ1NTJylcblJlZ0V4ID0gcmVxdWlyZSgnQGt5bmlrb3MvbWlzYy9kaXN0L1JlZ0V4JylcblxuXG5jbGFzcyBtb2R1bGUuZXhwb3J0c1xuICAgIGNvbnN0cnVjdG9yOiAoQFdNKSAtPlxuXG4gICAgX21ha2VVSTogLT5cbiAgICAgICAgZGlzcGxheSA9IHRydWVcbiAgICAgICAgZGlzcGxheUxvZyA9IHRydWVcblxuICAgICAgICBpZiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZWRpdGZvcm0nKVxuICAgICAgICAgICAgbmV4dE5vZGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnd3BTdW1tYXJ5TGFiZWwnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucGFyZW50Tm9kZS5uZXh0U2libGluZ1xuICAgICAgICAgICAgY29uZiA9IEBXTS5QbHVnaW5zLmVkaXRvclxuICAgICAgICAgICAgVUkgPSBpZiBjb25mLmxlbmd0aCB0aGVuIEBXTS5NZW51Ll9tYWtlVUkoJ2VkaXRvcicsIGNvbmYpIGVsc2UgbnVsbFxuICAgICAgICAgICAgQFdNLk1vZHMuYXBwbHlFZGl0b3JNb2RzKClcblxuICAgICAgICBlbHNlIGlmIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtdy1kaWZmLW90aXRsZTEnKVxuICAgICAgICAgICAgbmV4dE5vZGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYm9keUNvbnRlbnQnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoMicpWzBdXG4gICAgICAgICAgICBjb25mID0gQFdNLlBsdWdpbnMuZGlmZlxuICAgICAgICAgICAgVUkgPSBpZiBjb25mLmxlbmd0aCB0aGVuIEBXTS5NZW51Ll9tYWtlVUkoJ2RpZmYnLCBjb25mKSBlbHNlIG51bGxcblxuICAgICAgICBlbHNlIGlmIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtdy1zdWJjYXRlZ29yaWVzJykgb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbXctcGFnZXMnKVxuICAgICAgICAgICAgbmV4dE5vZGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYm9keUNvbnRlbnQnKVxuICAgICAgICAgICAgY29uZiA9IEBXTS5QbHVnaW5zLmJvdFxuICAgICAgICAgICAgVUkgPSBpZiBjb25mLmxlbmd0aCB0aGVuIEBXTS5Cb3QuX21ha2VVSShjb25mLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtbZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ213LXBhZ2VzJyksIDAsIFwiUGFnZXNcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW2RvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtdy1zdWJjYXRlZ29yaWVzJyksIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJTdWJjYXRlZ29yaWVzXCJdXSkgZWxzZSBudWxsXG4gICAgICAgICAgICBkaXNwbGF5ID0gZmFsc2VcblxuICAgICAgICBlbHNlIGlmIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtdy13aGF0bGlua3NoZXJlLWxpc3QnKVxuICAgICAgICAgICAgbmV4dE5vZGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYm9keUNvbnRlbnQnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2Zvcm0nKVswXS5uZXh0U2libGluZ1xuICAgICAgICAgICAgY29uZiA9IEBXTS5QbHVnaW5zLmJvdFxuICAgICAgICAgICAgVUkgPSBpZiBjb25mLmxlbmd0aCB0aGVuIEBXTS5Cb3QuX21ha2VVSShjb25mLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtbZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ213LXdoYXRsaW5rc2hlcmUtbGlzdCcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAsIFwiUGFnZXNcIl1dKSBlbHNlIG51bGxcbiAgICAgICAgICAgIGRpc3BsYXkgPSBmYWxzZVxuXG4gICAgICAgIGVsc2UgaWYgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuY29udGFpbnMoJ213LXNwZWNpYWwtTGlua1NlYXJjaCcpIGFuZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdib2R5Q29udGVudCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdvbCcpWzBdXG4gICAgICAgICAgICBuZXh0Tm9kZSA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ213LXNwY29udGVudCcpWzBdXG4gICAgICAgICAgICBjb25mID0gQFdNLlBsdWdpbnMuYm90XG4gICAgICAgICAgICBVSSA9IGlmIGNvbmYubGVuZ3RoIHRoZW4gQFdNLkJvdC5fbWFrZVVJKGNvbmYsXG4gICAgICAgICAgICAgICAgICAgICAgICBbW2RvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdib2R5Q29udGVudCdcbiAgICAgICAgICAgICAgICAgICAgICAgICkuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ29sJylbMF0sIDEsIFwiUGFnZXNcIl1dKSBlbHNlIG51bGxcbiAgICAgICAgICAgIGRpc3BsYXkgPSBmYWxzZVxuXG4gICAgICAgIGVsc2UgaWYgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ213LXByZWZpeGluZGV4LWxpc3QtdGFibGUnKVxuICAgICAgICAgICAgbmV4dE5vZGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbXctcHJlZml4aW5kZXgtbGlzdC10YWJsZScpXG4gICAgICAgICAgICBjb25mID0gQFdNLlBsdWdpbnMuYm90XG4gICAgICAgICAgICBVSSA9IGlmIGNvbmYubGVuZ3RoIHRoZW4gQFdNLkJvdC5fbWFrZVVJKGNvbmYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtbbmV4dE5vZGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3Rib2R5JylbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAsIFwiUGFnZXNcIl1dKSBlbHNlIG51bGxcbiAgICAgICAgICAgIGRpc3BsYXkgPSBmYWxzZVxuXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHdpa2lVcmxzID0gQFdNLk1XLmdldFdpa2lVcmxzKClcbiAgICAgICAgICAgIHBhdHQxQSA9IG5ldyBSZWdFeHAoUmVnRXguZXNjYXBlUGF0dGVybih3aWtpVXJscy5mdWxsKSArXG4gICAgICAgICAgICAgICAgICAgIFwiXFw/Lio/XCIgKyBcInRpdGxlXFxcXD1TcGVjaWFsKFxcXFw6fCUzW0FhXSlTcGVjaWFsUGFnZXNcIiwgJycpXG4gICAgICAgICAgICBwYXR0MUIgPSBuZXcgUmVnRXhwKFJlZ0V4LmVzY2FwZVBhdHRlcm4od2lraVVybHMuc2hvcnQpICtcbiAgICAgICAgICAgICAgICAgICAgXCJTcGVjaWFsKFxcXFw6fCUzW0FhXSlTcGVjaWFsUGFnZXNcIiwgJycpXG4gICAgICAgICAgICBwYXR0MkEgPSBuZXcgUmVnRXhwKFJlZ0V4LmVzY2FwZVBhdHRlcm4od2lraVVybHMuZnVsbCkgK1xuICAgICAgICAgICAgICAgICAgICBcIlxcPy4qP1wiICsgXCJ0aXRsZVxcXFw9U3BlY2lhbChcXFxcOnwlM1tBYV0pUmVjZW50Q2hhbmdlc1wiLCAnJylcbiAgICAgICAgICAgIHBhdHQyQiA9IG5ldyBSZWdFeHAoUmVnRXguZXNjYXBlUGF0dGVybih3aWtpVXJscy5zaG9ydCkgK1xuICAgICAgICAgICAgICAgICAgICBcIlNwZWNpYWwoXFxcXDp8JTNbQWFdKVJlY2VudENoYW5nZXNcIiwgJycpXG4gICAgICAgICAgICBwYXR0M0EgPSBuZXcgUmVnRXhwKFJlZ0V4LmVzY2FwZVBhdHRlcm4od2lraVVybHMuZnVsbCkgK1xuICAgICAgICAgICAgICAgICAgICBcIlxcPy4qP1wiICsgXCJ0aXRsZVxcXFw9U3BlY2lhbChcXFxcOnwlM1tBYV0pTmV3UGFnZXNcIiwgJycpXG4gICAgICAgICAgICBwYXR0M0IgPSBuZXcgUmVnRXhwKFJlZ0V4LmVzY2FwZVBhdHRlcm4od2lraVVybHMuc2hvcnQpICtcbiAgICAgICAgICAgICAgICAgICAgXCJTcGVjaWFsKFxcXFw6fCUzW0FhXSlOZXdQYWdlc1wiLCAnJylcbiAgICAgICAgICAgIHBhdHQ0QSA9IG5ldyBSZWdFeHAoUmVnRXguZXNjYXBlUGF0dGVybih3aWtpVXJscy5mdWxsKSArXG4gICAgICAgICAgICAgICAgICAgIFwiXFw/Lio/XCIgKyBcInRpdGxlXFxcXD1TcGVjaWFsKFxcXFw6fCUzW0FhXSlQcm90ZWN0ZWRQYWdlc1wiLCAnJylcbiAgICAgICAgICAgIHBhdHQ0QiA9IG5ldyBSZWdFeHAoUmVnRXguZXNjYXBlUGF0dGVybih3aWtpVXJscy5zaG9ydCkgK1xuICAgICAgICAgICAgICAgICAgICBcIlNwZWNpYWwoXFxcXDp8JTNbQWFdKVByb3RlY3RlZFBhZ2VzXCIsICcnKVxuICAgICAgICAgICAgcGF0dDVBID0gbmV3IFJlZ0V4cChSZWdFeC5lc2NhcGVQYXR0ZXJuKHdpa2lVcmxzLmZ1bGwpICtcbiAgICAgICAgICAgICAgICAgICAgXCJcXD8uKj9cIiArIFwidGl0bGVcXFxcPVNwZWNpYWwoXFxcXDp8JTNbQWFdKUNvbnRyaWJ1dGlvbnNcIiwgJycpXG4gICAgICAgICAgICBwYXR0NUIgPSBuZXcgUmVnRXhwKFJlZ0V4LmVzY2FwZVBhdHRlcm4od2lraVVybHMuc2hvcnQpICtcbiAgICAgICAgICAgICAgICAgICAgXCJTcGVjaWFsKFxcXFw6fCUzW0FhXSlDb250cmlidXRpb25zXCIsICcnKVxuXG4gICAgICAgICAgICBpZiBsb2NhdGlvbi5ocmVmLnNlYXJjaChwYXR0MUEpID4gLTEgb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2NhdGlvbi5ocmVmLnNlYXJjaChwYXR0MUIpID4gLTFcbiAgICAgICAgICAgICAgICBuZXh0Tm9kZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdib2R5Q29udGVudCcpXG4gICAgICAgICAgICAgICAgY29uZiA9IEBXTS5QbHVnaW5zLnNwZWNpYWxcbiAgICAgICAgICAgICAgICBVSSA9IGlmIGNvbmYubGVuZ3RoIHRoZW4gQFdNLk1lbnUuX21ha2VVSSgnc3BlY2lhbCcsIGNvbmYpIFxcXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgbnVsbFxuXG4gICAgICAgICAgICBlbHNlIGlmIGxvY2F0aW9uLmhyZWYuc2VhcmNoKHBhdHQyQSkgPiAtMSBvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uLmhyZWYuc2VhcmNoKHBhdHQyQikgPiAtMVxuICAgICAgICAgICAgICAgIG5leHROb2RlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ213LWNvbnRlbnQtdGV4dCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaDQnKVswXVxuICAgICAgICAgICAgICAgIGNvbmYgPSBAV00uUGx1Z2lucy5yZWNlbnRjaGFuZ2VzXG4gICAgICAgICAgICAgICAgVUkgPSBpZiBjb25mLmxlbmd0aCB0aGVuIEBXTS5GaWx0ZXJzLl9tYWtlVUkoJ3JlY2VudGNoYW5nZXMnLCBjb25mKSBlbHNlIG51bGxcbiAgICAgICAgICAgICAgICBkaXNwbGF5TG9nID0gZmFsc2VcbiAgICAgICAgICAgICAgICBAV00uTW9kcy5hcHBseVJlY2VudENoYW5nZXNNb2RzKClcblxuICAgICAgICAgICAgZWxzZSBpZiBsb2NhdGlvbi5ocmVmLnNlYXJjaChwYXR0M0EpID4gLTEgb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2NhdGlvbi5ocmVmLnNlYXJjaChwYXR0M0IpID4gLTFcbiAgICAgICAgICAgICAgICBuZXh0Tm9kZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtdy1jb250ZW50LXRleHQnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3VsJylbMF1cbiAgICAgICAgICAgICAgICBjb25mID0gQFdNLlBsdWdpbnMubmV3cGFnZXNcbiAgICAgICAgICAgICAgICBVSSA9IGlmIGNvbmYubGVuZ3RoIHRoZW4gQFdNLkZpbHRlcnMuX21ha2VVSSgnbmV3cGFnZXMnLCBjb25mKSBlbHNlIG51bGxcbiAgICAgICAgICAgICAgICBkaXNwbGF5TG9nID0gZmFsc2VcblxuICAgICAgICAgICAgZWxzZSBpZiBsb2NhdGlvbi5ocmVmLnNlYXJjaChwYXR0NEEpID4gLTEgb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2NhdGlvbi5ocmVmLnNlYXJjaChwYXR0NEIpID4gLTFcbiAgICAgICAgICAgICAgICBuZXh0Tm9kZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtdy1jb250ZW50LXRleHQnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3VsJylbMF1cbiAgICAgICAgICAgICAgICBjb25mID0gQFdNLlBsdWdpbnMuYm90XG4gICAgICAgICAgICAgICAgVUkgPSBpZiBjb25mLmxlbmd0aCB0aGVuIEBXTS5Cb3QuX21ha2VVSShjb25mLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbW2RvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtdy1jb250ZW50LXRleHQnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5nZXRFbGVtZW50c0J5VGFnTmFtZSgndWwnKVswXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMCwgXCJQYWdlc1wiXV0pIGVsc2UgbnVsbFxuICAgICAgICAgICAgICAgIGRpc3BsYXkgPSBmYWxzZVxuXG4gICAgICAgICAgICBlbHNlIGlmIGxvY2F0aW9uLmhyZWYuc2VhcmNoKHBhdHQ1QSkgPiAtMSBvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uLmhyZWYuc2VhcmNoKHBhdHQ1QikgPiAtMVxuICAgICAgICAgICAgICAgIEBXTS5Nb2RzLmFwcGx5Q29udHJpYnV0aW9uc01vZHMoKVxuXG4gICAgICAgICAgICBlbHNlIGlmIGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ213LXNwY29udGVudCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmxlbmd0aCA+IDBcbiAgICAgICAgICAgICAgICBuZXh0Tm9kZSA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ213LXNwY29udGVudCcpWzBdXG4gICAgICAgICAgICAgICAgY29uZiA9IEBXTS5QbHVnaW5zLmJvdFxuICAgICAgICAgICAgICAgIFVJID0gaWYgY29uZi5sZW5ndGggdGhlbiBAV00uQm90Ll9tYWtlVUkoY29uZixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtbbmV4dE5vZGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ29sJylbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwLCBcIlBhZ2VzXCJdXSkgZWxzZSBudWxsXG4gICAgICAgICAgICAgICAgZGlzcGxheSA9IGZhbHNlXG5cbiAgICAgICAgICAgIGVsc2UgaWYgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnbXctYWxscGFnZXMtdGFibGUtY2h1bmsnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5sZW5ndGggPiAwXG4gICAgICAgICAgICAgICAgbmV4dE5vZGUgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ213LWFsbHBhZ2VzLXRhYmxlLWNodW5rJylbMF1cbiAgICAgICAgICAgICAgICBjb25mID0gQFdNLlBsdWdpbnMuYm90XG4gICAgICAgICAgICAgICAgVUkgPSBpZiBjb25mLmxlbmd0aCB0aGVuIEBXTS5Cb3QuX21ha2VVSShjb25mLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbW25leHROb2RlLmdldEVsZW1lbnRzQnlUYWdOYW1lKCd0Ym9keScpWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwLCBcIlBhZ2VzXCJdXSkgZWxzZSBudWxsXG4gICAgICAgICAgICAgICAgZGlzcGxheSA9IGZhbHNlXG5cbiAgICAgICAgaWYgVUlcbiAgICAgICAgICAgIENTUy5hZGRTdHlsZUVsZW1lbnQoXCIjV2lraU1vbmtleSB7cG9zaXRpb246cmVsYXRpdmU7fVxuICAgICAgICAgICAgICAgICAgICAgICAgI1dpa2lNb25rZXkgZmllbGRzZXQge21hcmdpbjowIDAgMWVtIDA7fVwiKVxuXG4gICAgICAgICAgICBtYWluID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZmllbGRzZXQnKVxuICAgICAgICAgICAgbWFpbi5pZCA9ICdXaWtpTW9ua2V5J1xuXG4gICAgICAgICAgICBsZWdlbmQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsZWdlbmQnKVxuICAgICAgICAgICAgbGVnZW5kLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCdXaWtpIE1vbmtleSAnKSlcblxuICAgICAgICAgICAgaGlkZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKVxuICAgICAgICAgICAgaGlkZS5ocmVmID0gJyNXaWtpTW9ua2V5J1xuICAgICAgICAgICAgaGlkZS5pbm5lckhUTUwgPSAnW2hpZGVdJ1xuICAgICAgICAgICAgaGlkZS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKGV2ZW50KSAtPlxuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgICAgICAgICB3bW1haW4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnV2lraU1vbmtleU1haW4nKVxuICAgICAgICAgICAgICAgIGlmIHdtbWFpbi5zdHlsZS5kaXNwbGF5ID09ICdub25lJ1xuICAgICAgICAgICAgICAgICAgICB3bW1haW4uc3R5bGUuZGlzcGxheSA9ICdibG9jaydcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbm5lckhUTUwgPSAnW2hpZGVdJ1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgd21tYWluLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSdcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbm5lckhUTUwgPSAnW3Nob3ddJ1xuICAgICAgICAgICAgLCBmYWxzZSlcbiAgICAgICAgICAgIGxlZ2VuZC5hcHBlbmRDaGlsZChoaWRlKVxuXG4gICAgICAgICAgICBtYWluLmFwcGVuZENoaWxkKGxlZ2VuZClcblxuICAgICAgICAgICAgbWFpbjIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgICAgICAgICAgbWFpbjIuaWQgPSAnV2lraU1vbmtleU1haW4nXG5cbiAgICAgICAgICAgIG1haW4yLmFwcGVuZENoaWxkKFVJKVxuXG4gICAgICAgICAgICBsb2dBcmVhID0gQFdNLkxvZy5fbWFrZUxvZ0FyZWEoKVxuICAgICAgICAgICAgaWYgbm90IGRpc3BsYXlMb2dcbiAgICAgICAgICAgICAgICBsb2dBcmVhLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSdcblxuICAgICAgICAgICAgbWFpbjIuYXBwZW5kQ2hpbGQobG9nQXJlYSlcblxuICAgICAgICAgICAgaWYgbm90IGRpc3BsYXlcbiAgICAgICAgICAgICAgICBtYWluMi5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnXG4gICAgICAgICAgICAgICAgaGlkZS5pbm5lckhUTUwgPSAnW3Nob3ddJ1xuXG4gICAgICAgICAgICBtYWluLmFwcGVuZENoaWxkKG1haW4yKVxuXG4gICAgICAgICAgICBuZXh0Tm9kZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShtYWluLCBuZXh0Tm9kZSlcblxuICAgICAgICAgICAgQFdNLkxvZy5sb2dIaWRkZW4oXCJXaWtpIE1vbmtleSB2ZXJzaW9uOiAje3ZlcnNpb259XCIpXG4gICAgICAgICAgICBkYXRlID0gbmV3IERhdGUoKVxuICAgICAgICAgICAgQFdNLkxvZy5sb2dIaWRkZW4oXCJEYXRlOiAje2RhdGUudG9TdHJpbmcoKX1cIilcbiAgICAgICAgICAgIEBXTS5Mb2cubG9nSGlkZGVuKFwiVVJMOiAje2xvY2F0aW9uLmhyZWZ9XCIpXG4iLCIjIFdpa2kgTW9ua2V5IC0gTWVkaWFXaWtpIGJvdCBhbmQgZWRpdG9yLWFzc2lzdGFudCB1c2VyIHNjcmlwdFxuIyBDb3B5cmlnaHQgKEMpIDIwMTEgRGFyaW8gR2lvdmFubmV0dGkgPGRldkBkYXJpb2dpb3Zhbm5ldHRpLm5ldD5cbiNcbiMgVGhpcyBmaWxlIGlzIHBhcnQgb2YgV2lraSBNb25rZXkuXG4jXG4jIFdpa2kgTW9ua2V5IGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiMgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiMgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiMgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbiNcbiMgV2lraSBNb25rZXkgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiMgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiMgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuIyBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuI1xuIyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuIyBhbG9uZyB3aXRoIFdpa2kgTW9ua2V5LiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuXG57bW9tZW50LCBBLCBCciwgRGl2fSA9IHJlcXVpcmUoJy4vbGlicycpXG57dmVyc2lvbn0gPSByZXF1aXJlKCcuLi8uLi9wYWNrYWdlLmpzb24nKVxuXG5cbmNsYXNzIG1vZHVsZS5leHBvcnRzXG4gICAgUEFDS0FHRV9VUkwgPSAnaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2t5bmlrb3Mvd2lraS1tb25rZXkvbWFzdGVyL3BhY2thZ2UuanNvbicgICMgbm9xYVxuXG4gICAgY29uc3RydWN0b3I6IChAV00pIC0+XG5cbiAgICBjaGVja19hbmRfbm90aWZ5OiAtPlxuICAgICAgICBpZiBAc2hvdWxkX2NoZWNrKClcbiAgICAgICAgICAgIHVwc3RyZWFtX3BhY2thZ2UgPSBhd2FpdCAkLmdldEpTT04oUEFDS0FHRV9VUkwpXG4gICAgICAgICAgICAjIFdlbGwsIG9rLCB0aGlzIGlzIGFzc3VtaW5nIHRoYXQgaWYgdGhlIHZlcnNpb25zIGFyZVxuICAgICAgICAgICAgIyBkaWZmZXJlbnQsIHVwc3RyZWFtIGhhcyB0aGUgbGF0ZXN0XG4gICAgICAgICAgICBpZiB2ZXJzaW9uICE9IHVwc3RyZWFtX3BhY2thZ2UudmVyc2lvblxuICAgICAgICAgICAgICAgIEBkaXNwbGF5X25vdGlmaWNhdGlvbihbXG4gICAgICAgICAgICAgICAgICAgIFwiVmVyc2lvbiAje3Vwc3RyZWFtX3BhY2thZ2UudmVyc2lvbn0gaXMgYXZhaWxhYmxlLlwiXG4gICAgICAgICAgICAgICAgICAgIEJyKClcbiAgICAgICAgICAgICAgICAgICAgQSh7aHJlZjogXCJodHRwczovL2dpdGh1Yi5jb20va3luaWtvcy93aWtpLW1vbmtleS93aWtpL0NoYW5nZWxvZ1wifSAgIyBub3FhXG4gICAgICAgICAgICAgICAgICAgICAgXCJDaGFuZ2Vsb2dcIilcbiAgICAgICAgICAgICAgICAgICAgQnIoKVxuICAgICAgICAgICAgICAgICAgICBBKCdSdW4gdXBncmFkZScsIHtvbmNsaWNrOiA9PlxuICAgICAgICAgICAgICAgICAgICAgIEB1cGdyYWRlKHVwc3RyZWFtX3BhY2thZ2UudmVyc2lvbilcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIG13LnN0b3JhZ2Uuc2V0KCdXaWtpTW9ua2V5LWxhc3QtdXBkYXRlLWNoZWNrJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb21lbnQoKS5mb3JtYXQoJ1lZWVktTU0tREQnKSlcblxuICAgIHNob3VsZF9jaGVjazogLT5cbiAgICAgICAgbGFzdHVwZGNoZWNrID0gbXcuc3RvcmFnZS5nZXQoJ1dpa2lNb25rZXktbGFzdC11cGRhdGUtY2hlY2snKVxuICAgICAgICBpZiBub3QgbGFzdHVwZGNoZWNrXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuXG4gICAgICAgIGRpZmYgPSBtb21lbnQoKS5kaWZmKG1vbWVudChsYXN0dXBkY2hlY2spLCAnZGF5cycpXG4gICAgICAgICMgUHJlZmVyYWJseSBjaGVjayBvbiB0aGUgY29uZmlndXJlZCBkYXkgb2YgdGhlIHdlZWssIGJ1dCBkb24ndCBsZXRcbiAgICAgICAgIyBtb3JlIHRoYW4gNyBkYXlzIHBhc3Mgd2l0aG91dCBjaGVja2luZyBpbiBhbnkgY2FzZVxuICAgICAgICBpZiAoZGlmZiA+PSAxIGFuZCBtb21lbnQoKS5kYXkoKSBpblxuICAgICAgICAgICAgICAgIEBXTS5jb25mLnVwZGF0ZV9jaGVja193ZGF5cykgb3IgZGlmZiA+PSA3XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICByZXR1cm4gZmFsc2VcblxuICAgIGRpc3BsYXlfbm90aWZpY2F0aW9uOiAoY29udGVudCwgb3B0aW9uc292ZXJyaWRlKSAtPlxuICAgICAgICBvcHRpb25zID0ge1xuICAgICAgICAgICAgYXV0b0hpZGU6IGZhbHNlXG4gICAgICAgICAgICB0YWc6ICdXaWtpTW9ua2V5LXVwZ3JhZGUnXG4gICAgICAgICAgICB0aXRsZTogJ1dpa2kgTW9ua2V5J1xuICAgICAgICAgICAgdHlwZTogJ2luZm8nXG4gICAgICAgIH1cbiAgICAgICAgJC5leHRlbmQob3B0aW9ucywgb3B0aW9uc292ZXJyaWRlKVxuICAgICAgICBtdy5ub3RpZmljYXRpb24ubm90aWZ5KGNvbnRlbnQsIG9wdGlvbnMpXG5cbiAgICB1cGdyYWRlOiAodXBzdHJlYW1fdmVyc2lvbikgLT5cbiAgICAgICAgcGFnZSA9IFwiVXNlcjoje213LnVzZXIuZ2V0TmFtZSgpfS9jb21tb24uanNcIlxuICAgICAgICBwYWdlbGluayA9IEBXTS5NVy5saW5rQXJ0aWNsZShwYWdlKVxuXG4gICAgICAgIEBkaXNwbGF5X25vdGlmaWNhdGlvbihcIlVwZ3JhZGluZyB0byB2ZXJzaW9uICN7dXBzdHJlYW1fdmVyc2lvbn0uLi5cIilcblxuICAgICAgICAjIFRPRE86IEFsbG93IHByZXZlbnRpbmcgdXBncmFkZXMgcGVyLWxpbmUgd2l0aCAvL25vdXBncmFkZSBjb21tZW50cz9cbiAgICAgICAgIyAgICAgICBEb24ndCB1cGdyYWRlIGNvbW1lbnRlZCBsaW5lcz9cbiAgICAgICAgcmVnZXggPSBuZXcgUmVnRXhwKFwiKFtcXFwiJ11odHRwcz86Ly9bXi9dKy9reW5pa29zL3dpa2ktbW9ua2V5L1wiICtcbiAgICAgICAgICAgIFwidikje213LlJlZ0V4cC5lc2NhcGUodmVyc2lvbil9KC9kaXN0L1wiICtcbiAgICAgICAgICAgIFwiV2lraU1vbmtleS1bXi9dK1xcXFwuanNbXFxcIiddKVwiLCAnZycpXG5cbiAgICAgICAgQFdNLk1XLmFwaS5lZGl0KHBhZ2UsIChyZXZpc2lvbikgPT5cbiAgICAgICAgICAgIG5ld3RleHQgPSByZXZpc2lvbi5jb250ZW50LnJlcGxhY2UocmVnZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiJDEje3Vwc3RyZWFtX3ZlcnNpb259JDJcIilcblxuICAgICAgICAgICAgaWYgbmV3dGV4dCBpcyByZXZpc2lvbi5jb250ZW50XG4gICAgICAgICAgICAgICAgIyBFeGVjdXRpbmcgdGhlIHF1ZXJ5IHdvdWxkIHJldHVybiBhICdub2NoYW5nZTp0cnVlJyByZXN1bHQsXG4gICAgICAgICAgICAgICAgIyBidXQgd2UgY2FuIHRlc3QgaXQgYmVmb3JlIHNlbmRpbmcgaXRcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoXG4gICAgICAgICAgICAgICAgICAgIG5ldyBFcnJvcihcIkNvdWxkIG5vdCBmaW5kIFdpa2kgTW9ua2V5IGxvYWRlciBsaW5lXCIpKVxuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHRleHQ6IG5ld3RleHQsXG4gICAgICAgICAgICAgICAgc3VtbWFyeTogXCJVcGRhdGUgV2lraSBNb25rZXkgdG8gdmVyc2lvbiAje3Vwc3RyZWFtX3ZlcnNpb259XCIsXG4gICAgICAgICAgICAgICAgYm90OiB0cnVlLFxuICAgICAgICAgICAgfVxuICAgICAgICApLmRvbmUoKHJlc3VsdCkgPT5cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHJlc3VsdClcbiAgICAgICAgICAgIEBkaXNwbGF5X25vdGlmaWNhdGlvbihbXG4gICAgICAgICAgICAgICAgXCJVcGdyYWRlIHN1Y2Nlc3NmdWw6IHlvdSBuZWVkIHRvIHJlZnJlc2ggdGhlIG9wZW4gd2lraSBwYWdlKHMpXG4gICAgICAgICAgICAgICAgaW4gb3JkZXIgdG8gdXNlIHRoZSBuZXcgdmVyc2lvbi5cIlxuICAgICAgICAgICAgICAgIEJyKClcbiAgICAgICAgICAgICAgICBBKHtocmVmOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9reW5pa29zL3dpa2ktbW9ua2V5L3dpa2kvQ2hhbmdlbG9nXCJ9XG4gICAgICAgICAgICAgICAgICBcIkNoYW5nZWxvZ1wiKVxuICAgICAgICAgICAgXSlcbiAgICAgICAgKS5mYWlsKChjb2RlLCBlcnJvcikgPT5cbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoY29kZSwgZXJyb3IpXG4gICAgICAgICAgICBAZGlzcGxheV9ub3RpZmljYXRpb24oW1xuICAgICAgICAgICAgICAgIFwiQ291bGQgbm90IGNvbXBsZXRlIHRoZSB1cGdyYWRlIHRvIHZlcnNpb25cbiAgICAgICAgICAgICAgICAje3Vwc3RyZWFtX3ZlcnNpb259OiBcIixcbiAgICAgICAgICAgICAgICBBKHtvbmNsaWNrOiA9PlxuICAgICAgICAgICAgICAgICAgICBAdXBncmFkZSh1cHN0cmVhbV92ZXJzaW9uKVxuICAgICAgICAgICAgICAgIH0sIFwicmV0cnlcIiksXG4gICAgICAgICAgICAgICAgXCIgaW4gY2FzZSBpdCB3YXMgYSB0ZW1wb3JhcnkgcHJvYmxlbTsgaXQgaXMgYWxzbyBwb3NzaWJsZVxuICAgICAgICAgICAgICAgIHRoYXQgV2lraSBNb25rZXkgaXMgaW5zdGFsbGVkIGluIGEgbm9uLXN0YW5kYXJkIHdheSBpbiBcIixcbiAgICAgICAgICAgICAgICBwYWdlbGluaywgXCIgYW5kIHRoZSB1cGdyYWRlIHNob3VsZCBiZSBleGVjdXRlZCBtYW51YWxseTtcbiAgICAgICAgICAgICAgICBmaW5hbGx5LCBpdCBpcyBwb3NzaWJsZSB0aGF0IHRoZSB1cGdyYWRlIHdhcyBhbHJlYWR5IGxhdW5jaGVkXG4gICAgICAgICAgICAgICAgYW5kIGNvbXBsZXRlZCBmcm9tIGFub3RoZXIgcGFnZTogaW4gdGhpcyBjYXNlIHJlZnJlc2ggdGhlIHBhZ2VcbiAgICAgICAgICAgICAgICB0byB2ZXJpZnkuXCJcbiAgICAgICAgICAgIF0sIHt0eXBlOiAnZXJyb3InfSlcbiAgICAgICAgKVxuXG4gICAgY2hlY2tfb2Jzb2xldGVfY29uZmlnOiAtPlxuICAgICAgICAjIFRPRE86IFJlbW92ZSBpbiBhIGxhdGVyIHZlcnNpb25cbiAgICAgICAgb2xkY29uZiA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwiV2lraU1vbmtleVwiKVxuICAgICAgICBpZiBvbGRjb25mIGlzbnQgbnVsbFxuICAgICAgICAgICAgYmxvYiA9IG5ldyBCbG9iKFtvbGRjb25mXSwge3R5cGU6ICdhcHBsaWNhdGlvbi9qc29uJ30pXG4gICAgICAgICAgICBjb25maHJlZiA9IHdpbmRvdy5VUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpXG4gICAgICAgICAgICBAZGlzcGxheV9ub3RpZmljYXRpb24oW1xuICAgICAgICAgICAgICAgIFwiV2lraSBNb25rZXkgNC4wLjAgdXNlcyBhIGNvbXBsZXRlbHkgcmV3cml0dGVuIGNvbmZpZ3VyYXRpb25cbiAgICAgICAgICAgICAgICBzeXN0ZW0uIEFmdGVyIHVwZGF0aW5nLCB5b3VyIG9sZCBjb25maWd1cmF0aW9uIHdhcyBub3RcbiAgICAgICAgICAgICAgICBhdXRvbWF0aWNhbGx5IGltcG9ydGVkLCBidXQgaXQgaXMgc3RpbGwgc2F2ZWQgaW4geW91ciBicm93c2VyJ3NcbiAgICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2UuIFlvdSBjYW4gZGVjaWRlIHRvIGV4cG9ydCBpdCBhbmQgdGhlbiBtZXJnZSBpdFxuICAgICAgICAgICAgICAgIG1hbnVhbGx5LCBvciBzaW1wbHkgcmVtb3ZlIGl0IGFuZCB1c2UgdGhlIGRlZmF1bHQgY29uZmlndXJhdGlvblxuICAgICAgICAgICAgICAgIG9wdGlvbnMuXCJcbiAgICAgICAgICAgICAgICBCcigpXG4gICAgICAgICAgICAgICAgQSh7aHJlZjogXCJodHRwczovL2dpdGh1Yi5jb20va3luaWtvcy93aWtpLW1vbmtleS93aWtpL0NvbmZpZ3VyYXRpb25cIn0gICMgbm9xYVxuICAgICAgICAgICAgICAgICAgXCJOZXcgY29uZmlndXJhdGlvbiBpbnN0cnVjdGlvbnNcIilcbiAgICAgICAgICAgICAgICBCcigpXG4gICAgICAgICAgICAgICAgQSh7aHJlZjogY29uZmhyZWZ9LCBcIlZpZXcgb2xkIGNvbmZpZ3VyYXRpb25cIilcbiAgICAgICAgICAgICAgICBCcigpXG4gICAgICAgICAgICAgICAgQSh7aHJlZjogY29uZmhyZWYsIGRvd25sb2FkOiBcIndpa2ltb25rZXlfb2xkY29uZi5qc29uXCJ9XG4gICAgICAgICAgICAgICAgICBcIkV4cG9ydCBvbGQgY29uZmlndXJhdGlvblwiKVxuICAgICAgICAgICAgICAgIEJyKClcbiAgICAgICAgICAgICAgICBBKHtvbmNsaWNrOiA9PlxuICAgICAgICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShcIldpa2lNb25rZXlcIilcbiAgICAgICAgICAgICAgICAgICAgQGRpc3BsYXlfbm90aWZpY2F0aW9uKFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJUaGUgb2xkIGNvbmZpZ3VyYXRpb24gd2FzIHN1Y2Nlc3NmdWxseSByZW1vdmVkLlwiXG4gICAgICAgICAgICAgICAgICAgICAgICB7YXV0b0hpZGU6IHRydWV9XG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICB9LCBcIkRlbGV0ZSBvbGQgY29uZmlndXJhdGlvblwiKVxuICAgICAgICAgICAgXSlcbiIsIiMgV2lraSBNb25rZXkgLSBNZWRpYVdpa2kgYm90IGFuZCBlZGl0b3ItYXNzaXN0YW50IHVzZXIgc2NyaXB0XG4jIENvcHlyaWdodCAoQykgMjAxMSBEYXJpbyBHaW92YW5uZXR0aSA8ZGV2QGRhcmlvZ2lvdmFubmV0dGkubmV0PlxuI1xuIyBUaGlzIGZpbGUgaXMgcGFydCBvZiBXaWtpIE1vbmtleS5cbiNcbiMgV2lraSBNb25rZXkgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuIyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuIyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuIyAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuI1xuIyBXaWtpIE1vbmtleSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuIyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuIyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4jIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4jXG4jIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4jIGFsb25nIHdpdGggV2lraSBNb25rZXkuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG5cblxuY2xhc3MgbW9kdWxlLmV4cG9ydHNcbiAgICBjb25zdHJ1Y3RvcjogKEBXTSkgLT5cblxuICAgIGlzV2hhdExpbmtzSGVyZVBhZ2U6IC0+XG4gICAgICAgIHJldHVybiBpZiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbXctd2hhdGxpbmtzaGVyZS1saXN0JykgdGhlbiB0cnVlIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlXG5cbiAgICBnZXRUaXRsZTogLT5cbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjb250ZW50U3ViJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdhJylbMF0udGl0bGVcbiIsIiMgV2lraSBNb25rZXkgLSBNZWRpYVdpa2kgYm90IGFuZCBlZGl0b3ItYXNzaXN0YW50IHVzZXIgc2NyaXB0XG4jIENvcHlyaWdodCAoQykgMjAxMSBEYXJpbyBHaW92YW5uZXR0aSA8ZGV2QGRhcmlvZ2lvdmFubmV0dGkubmV0PlxuI1xuIyBUaGlzIGZpbGUgaXMgcGFydCBvZiBXaWtpIE1vbmtleS5cbiNcbiMgV2lraSBNb25rZXkgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuIyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuIyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuIyAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuI1xuIyBXaWtpIE1vbmtleSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuIyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuIyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4jIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4jXG4jIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4jIGFsb25nIHdpdGggV2lraSBNb25rZXkuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG5cbm13bW9kcHJvbWlzZSA9IG13LmxvYWRlci51c2luZyhbJ21lZGlhd2lraS5hcGkuZWRpdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdtZWRpYXdpa2kubm90aWZpY2F0aW9uJ10pXG5cbiMgSW5pdGlhbGl6ZSB0aGUgbGlicmFyaWVzIGltbWVkaWF0ZWx5IChlc3BlY2lhbGx5IGJhYmVsLXBvbHlmaWxsKVxucmVxdWlyZSgnLi9saWJzJylcblxuIyBUaGUgQXJjaFBhY2thZ2VzIG1vZHVsZSBpcyBjdXJyZW50bHkgdW51c2FibGVcbiMgQXJjaFBhY2thZ2VzID0gcmVxdWlyZSgnLi9BcmNoUGFja2FnZXMnKVxuQXJjaFdpa2kgPSByZXF1aXJlKCcuL0FyY2hXaWtpJylcbkJvdCA9IHJlcXVpcmUoJy4vQm90JylcbkNhdCA9IHJlcXVpcmUoJy4vQ2F0JylcbkRpZmYgPSByZXF1aXJlKCcuL0RpZmYnKVxuRWRpdG9yID0gcmVxdWlyZSgnLi9FZGl0b3InKVxuRmlsdGVycyA9IHJlcXVpcmUoJy4vRmlsdGVycycpXG5JbnRlcmxhbmd1YWdlID0gcmVxdWlyZSgnLi9JbnRlcmxhbmd1YWdlJylcbkxvZyA9IHJlcXVpcmUoJy4vTG9nJylcbk1lbnUgPSByZXF1aXJlKCcuL01lbnUnKVxuTW9kcyA9IHJlcXVpcmUoJy4vTW9kcycpXG5NVyA9IHJlcXVpcmUoJy4vTVcnKVxuUGFyc2VyID0gcmVxdWlyZSgnLi9QYXJzZXInKVxuVGFibGVzID0gcmVxdWlyZSgnLi9UYWJsZXMnKVxuVUkgPSByZXF1aXJlKCcuL1VJJylcblVwZ3JhZGUgPSByZXF1aXJlKCcuL1VwZ3JhZGUnKVxuV2hhdExpbmtzSGVyZSA9IHJlcXVpcmUoJy4vV2hhdExpbmtzSGVyZScpXG5cbntQbHVnaW59ID0gcmVxdWlyZSgnLi4vcGx1Z2lucy9fUGx1Z2luJylcblxuXG5jbGFzcyBtb2R1bGUuZXhwb3J0cy5XTVxuICAgIGNvbmY6XG4gICAgICAgIGRlZmF1bHRfYm90X3BsdWdpbjogXCJTaW1wbGVSZXBsYWNlXCJcbiAgICAgICAgZGVmYXVsdF9yZWNlbnRjaGFuZ2VzX3BsdWdpbjogbnVsbFxuICAgICAgICBkZWZhdWx0X25ld3BhZ2VzX3BsdWdpbjogbnVsbFxuICAgICAgICB1cGRhdGVfY2hlY2tfd2RheXM6IFs2XVxuICAgICAgICBoaWRlX3JvbGxiYWNrX2xpbmtzOiB0cnVlXG4gICAgICAgIGRpc2FibGVfZWRpdF9zdW1tYXJ5X3N1Ym1pdF9vbl9lbnRlcjogdHJ1ZVxuICAgICAgICBzY3JvbGxfdG9fZmlyc3RfaGVhZGluZzogZmFsc2VcblxuICAgIGNvbnN0cnVjdG9yOiAoQHdpa2lfbmFtZSwgQGluc3RhbGxlZF9wbHVnaW5zX3RlbXAuLi4pIC0+XG4gICAgICAgIEBzZXR1cCgpXG4gICAgICAgICQud2hlbihtd21vZHByb21pc2UsICQucmVhZHkpLmRvbmUoQGluaXQpXG5cbiAgICBzZXR1cDogLT5cbiAgICAgICAgIyBtdy5sb2FkZXIubG9hZCgpIGRvZXNuJ3QgcmV0dXJuIGEgcHJvbWlzZSBub3Igc3VwcG9ydCBjYWxsYmFja3NcbiAgICAgICAgIyBtdy5sb2FkZXIudXNpbmcoKSBvbmx5IHN1cHBvcnRzIE1XIG1vZHVsZXNcbiAgICAgICAgIyAkLmdldFNjcmlwdCgpIGlnbm9yZXMgdGhlIGNhY2hlIGJ5IGRlZmF1bHRcbiAgICAgICAgIyBJbiB0aGUgZW5kIHVzaW5nICQuYWpheCgpIHdpdGggc2V0dXAgcGFyYW1ldGVycyB3b3VsZCBiZSB0aGUgb25seVxuICAgICAgICAjIG9wdGlvbiB0byBjb25maWd1cmUgV00gaW4gYSBjYWxsYmFjaywgdGhlcmVmb3JlIHVzZSBhIGdsb2JhbFxuICAgICAgICAjIGNvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBzaW1wbGljaXR5XG4gICAgICAgIHVzZXJfY29uZmlnID0gd2luZG93Lndpa2lNb25rZXlDb25maWcgb3Igd2luZG93Lndpa2ltb25rZXlfY29uZmlnIG9yIHt9XG5cbiAgICAgICAgZm9yIG9wdGlvbiwgdmFsdWUgb2YgdXNlcl9jb25maWcgd2hlbiBvcHRpb24gb2YgQGNvbmZcbiAgICAgICAgICAgIEBjb25mW29wdGlvbl0gPSB2YWx1ZVxuICAgICAgICAgICAgZGVsZXRlIHVzZXJfY29uZmlnW29wdGlvbl1cblxuICAgICAgICBAUGx1Z2lucyA9XG4gICAgICAgICAgICBib3Q6IFtdXG4gICAgICAgICAgICBkaWZmOiBbXVxuICAgICAgICAgICAgZWRpdG9yOiBbXVxuICAgICAgICAgICAgbmV3cGFnZXM6IFtdXG4gICAgICAgICAgICByZWNlbnRjaGFuZ2VzOiBbXVxuICAgICAgICAgICAgc3BlY2lhbDogW11cblxuICAgICAgICBmb3IgcG1vZCBpbiBAaW5zdGFsbGVkX3BsdWdpbnNfdGVtcFxuICAgICAgICAgICAgZm9yIHBuYW1lLCBQbHVnaW5TdWIgb2YgcG1vZCBcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hlbiBQbHVnaW5TdWIucHJvdG90eXBlIGluc3RhbmNlb2YgUGx1Z2luXG4gICAgICAgICAgICAgICAgdHJ5XG4gICAgICAgICAgICAgICAgICAgIFBsdWdpblN1Yi5fX2NvbmZpZ3VyZShAd2lraV9uYW1lLCB1c2VyX2NvbmZpZylcbiAgICAgICAgICAgICAgICBjYXRjaCBlcnJvclxuICAgICAgICAgICAgICAgICAgICAjIFRPRE86IFByb3Blcmx5IGV4dGVuZCBFcnJvciwgYnV0IGJld2FyZSB0aGF0IEJhYmVsb1xuICAgICAgICAgICAgICAgICAgICAjICAgICAgIGRvZXNuJ3QgbGlrZSBpdCB3aXRob3V0IHNwZWNpZmljIHBsdWdpbnNcbiAgICAgICAgICAgICAgICAgICAgaWYgZXJyb3IubWVzc2FnZSBpcyBcIlBsdWdpbiBkaXNhYmxlZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvclxuXG4gICAgICAgICAgICAgICAgZm9yIGludGVyZmFjZV8gb2YgQFBsdWdpbnMgXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGVuIFBsdWdpblN1Yjo6W1wibWFpbl8je2ludGVyZmFjZV99XCJdXG4gICAgICAgICAgICAgICAgICAgIEBQbHVnaW5zW2ludGVyZmFjZV9dLnB1c2goUGx1Z2luU3ViKVxuXG4gICAgICAgIGlmIG5vdCAkLmlzRW1wdHlPYmplY3QodXNlcl9jb25maWcpXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJVbmtvd24gY29uZmlndXJhdGlvbiBvcHRpb25zXCIsIHVzZXJfY29uZmlnKVxuXG4gICAgICAgIGRlbGV0ZSBAaW5zdGFsbGVkX3BsdWdpbnNfdGVtcFxuXG4gICAgaW5pdDogPT5cbiAgICAgICAgIyBUaGUgQXJjaFBhY2thZ2VzIG1vZHVsZSBpcyBjdXJyZW50bHkgdW51c2FibGVcbiAgICAgICAgIyBAQXJjaFBhY2thZ2VzID0gbmV3IEFyY2hQYWNrYWdlcyh0aGlzKVxuICAgICAgICBAQXJjaFdpa2kgPSBuZXcgQXJjaFdpa2kodGhpcylcbiAgICAgICAgQEJvdCA9IG5ldyBCb3QodGhpcylcbiAgICAgICAgQENhdCA9IG5ldyBDYXQodGhpcylcbiAgICAgICAgQERpZmYgPSBuZXcgRGlmZih0aGlzKVxuICAgICAgICBARWRpdG9yID0gbmV3IEVkaXRvcih0aGlzKVxuICAgICAgICBARmlsdGVycyA9IG5ldyBGaWx0ZXJzKHRoaXMpXG4gICAgICAgIEBJbnRlcmxhbmd1YWdlID0gbmV3IEludGVybGFuZ3VhZ2UodGhpcylcbiAgICAgICAgQExvZyA9IG5ldyBMb2codGhpcylcbiAgICAgICAgQE1lbnUgPSBuZXcgTWVudSh0aGlzKVxuICAgICAgICBATW9kcyA9IG5ldyBNb2RzKHRoaXMpXG4gICAgICAgIEBNVyA9IG5ldyBNVyh0aGlzKVxuICAgICAgICBAUGFyc2VyID0gbmV3IFBhcnNlcih0aGlzKVxuICAgICAgICBAVGFibGVzID0gbmV3IFRhYmxlcyh0aGlzKVxuICAgICAgICBAVUkgPSBuZXcgVUkodGhpcylcbiAgICAgICAgQFVwZ3JhZGUgPSBuZXcgVXBncmFkZSh0aGlzKVxuICAgICAgICBAV2hhdExpbmtzSGVyZSA9IG5ldyBXaGF0TGlua3NIZXJlKHRoaXMpXG5cbiAgICAgICAgQFVwZ3JhZGUuY2hlY2tfb2Jzb2xldGVfY29uZmlnKClcbiAgICAgICAgaWYgQGNvbmYudXBkYXRlX2NoZWNrX3dkYXlzXG4gICAgICAgICAgICBAVXBncmFkZS5jaGVja19hbmRfbm90aWZ5KClcblxuICAgICAgICBAVUkuX21ha2VVSSgpXG4iLCIjIFdpa2kgTW9ua2V5IC0gTWVkaWFXaWtpIGJvdCBhbmQgZWRpdG9yLWFzc2lzdGFudCB1c2VyIHNjcmlwdFxuIyBDb3B5cmlnaHQgKEMpIDIwMTEgRGFyaW8gR2lvdmFubmV0dGkgPGRldkBkYXJpb2dpb3Zhbm5ldHRpLm5ldD5cbiNcbiMgVGhpcyBmaWxlIGlzIHBhcnQgb2YgV2lraSBNb25rZXkuXG4jXG4jIFdpa2kgTW9ua2V5IGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiMgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiMgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiMgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbiNcbiMgV2lraSBNb25rZXkgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiMgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiMgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuIyBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuI1xuIyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuIyBhbG9uZyB3aXRoIFdpa2kgTW9ua2V5LiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuXG5yZXF1aXJlKCdiYWJlbC1wb2x5ZmlsbCcpXG5cbiMgalF1ZXJ5IGlzIHByb3ZpZGVkIGdsb2JhbGx5IGJ5IE1lZGlhV2lraVxuXG5oaCA9IHJlcXVpcmUoJ2h5cGVyc2NyaXB0LWhlbHBlcnMnKShyZXF1aXJlKCdoeXBlcnNjcmlwdCcpKVxuZm9yIHRhZywgaGVscGVyIG9mIGhoXG4gICAgIyBUT0RPOiBUaGlzIGNhbiBiZSBzaW1wbGlmaWVkIGFmdGVyXG4gICAgIyAgICAgICBodHRwczovL2dpdGh1Yi5jb20vb2hhbmhpL2h5cGVyc2NyaXB0LWhlbHBlcnMvcHVsbC80NiBpcyByZWxlYXNlZFxuICAgIG1vZHVsZS5leHBvcnRzW3RhZy5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHRhZy5zbGljZSgxKV0gPSBoZWxwZXJcblxubW9kdWxlLmV4cG9ydHMubW9tZW50ID0gcmVxdWlyZSgnbW9tZW50JylcblxuanNzID0gcmVxdWlyZSgnanNzJykuZGVmYXVsdFxuanNzLnNldHVwKHJlcXVpcmUoJ2pzcy1wcmVzZXQtZGVmYXVsdCcpLmRlZmF1bHQoKSlcbm1vZHVsZS5leHBvcnRzLmpzcyA9IGpzc1xuIiwiIyBXaWtpIE1vbmtleSAtIE1lZGlhV2lraSBib3QgYW5kIGVkaXRvci1hc3Npc3RhbnQgdXNlciBzY3JpcHRcbiMgQ29weXJpZ2h0IChDKSAyMDExIERhcmlvIEdpb3Zhbm5ldHRpIDxkZXZAZGFyaW9naW92YW5uZXR0aS5uZXQ+XG4jXG4jIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFdpa2kgTW9ua2V5LlxuI1xuIyBXaWtpIE1vbmtleSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4jIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4jIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4jIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4jXG4jIFdpa2kgTW9ua2V5IGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4jIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4jIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiMgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbiNcbiMgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiMgYWxvbmcgd2l0aCBXaWtpIE1vbmtleS4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cblxue1BsdWdpbn0gPSByZXF1aXJlKCcuL19QbHVnaW4nKVxuXG5cbmNsYXNzIG1vZHVsZS5leHBvcnRzLkFyY2hXaWtpRml4SGVhZGVyIGV4dGVuZHMgUGx1Z2luXG4gICAgQGNvbmZfZGVmYXVsdDpcbiAgICAgICAgZW5hYmxlZDogdHJ1ZVxuICAgICAgICBlZGl0b3JfbWVudTogW1wiVGV4dCBwbHVnaW5zXCIsIFwiRml4IGhlYWRlclwiXVxuXG4gICAgbWFpbl9lZGl0b3I6IChjYWxsTmV4dCkgLT5cbiAgICAgICAgc291cmNlID0gQFdNLkVkaXRvci5yZWFkU291cmNlKClcblxuICAgICAgICBsYW5ndWFnZSA9IEBXTS5BcmNoV2lraS5kZXRlY3RMYW5ndWFnZShAV00uRWRpdG9yLmdldFRpdGxlKCkpWzFdXG5cbiAgICAgICAgaGVhZGVyID0gXCJcIlxuICAgICAgICBjb250ZW50ID0gc291cmNlXG5cbiAgICAgICAgIyA8bm9pbmNsdWRlPlxuICAgICAgICBjb250ZW50ID0gY29udGVudC5yZXBsYWNlKC9eXFxzKjxub2luY2x1ZGU+LywgXCJcIilcbiAgICAgICAgaWYgY29udGVudCAhPSBzb3VyY2VcbiAgICAgICAgICAgIGhlYWRlciArPSBcIjxub2luY2x1ZGU+XFxuXCJcblxuICAgICAgICAjIERJU1BMQVlUSVRMRSBhbmQgVGVtcGxhdGU6TG93ZXJjYXNlX3RpdGxlXG4gICAgICAgIGRpc3BsYXl0aXRsZSA9IEBXTS5QYXJzZXIuZmluZFZhcmlhYmxlcyhjb250ZW50LCBcIkRJU1BMQVlUSVRMRVwiKVxuICAgICAgICBsb3dlcmNhc2V0aXRsZSA9IEBXTS5QYXJzZXIuZmluZFRlbXBsYXRlcyhjb250ZW50LCBcIkxvd2VyY2FzZSB0aXRsZVwiKVxuICAgICAgICB0aXRsZW1vZHMgPSBkaXNwbGF5dGl0bGUuY29uY2F0KGxvd2VyY2FzZXRpdGxlKVxuICAgICAgICB0aXRsZW1vZHMuc29ydCggKGEsIGIpIC0+XG4gICAgICAgICAgICByZXR1cm4gYS5pbmRleCAtIGIuaW5kZXhcbiAgICAgICAgKVxuICAgICAgICB0ZW1wY29udGVudCA9IFwiXCJcbiAgICAgICAgY29udGVudElkID0gMFxuICAgICAgICBmb3IgdGl0bGVtb2QgaW4gdGl0bGVtb2RzXG4gICAgICAgICAgICB0ZW1wY29udGVudCArPSBjb250ZW50LnN1YnN0cmluZyhjb250ZW50SWQsIHRpdGxlbW9kLmluZGV4KVxuICAgICAgICAgICAgY29udGVudElkID0gdGl0bGVtb2QuaW5kZXggKyB0aXRsZW1vZC5sZW5ndGhcblxuICAgICAgICB0ZW1wY29udGVudCArPSBjb250ZW50LnN1YnN0cmluZyhjb250ZW50SWQpXG4gICAgICAgIGNvbnRlbnQgPSB0ZW1wY29udGVudFxuICAgICAgICBkdCA9IGRpc3BsYXl0aXRsZS5wb3AoKVxuICAgICAgICBsY3QgPSBsb3dlcmNhc2V0aXRsZS5wb3AoKVxuICAgICAgICBkbGN0ID0gXCJcIlxuICAgICAgICBpZiBkdCBhbmQgbm90IGxjdFxuICAgICAgICAgICAgZGxjdCA9IFwie3tESVNQTEFZVElUTEU6XCIgKyBkdC52YWx1ZSArIFwifX1cIlxuICAgICAgICBlbHNlIGlmIG5vdCBkdCBhbmQgbGN0XG4gICAgICAgICAgICBkbGN0ID0gXCJ7e0xvd2VyY2FzZSB0aXRsZX19XCJcbiAgICAgICAgZWxzZSBpZiBkdCBhbmQgbGN0XG4gICAgICAgICAgICBkbGN0ID0gaWYgZHQuaW5kZXggPCBsY3QuaW5kZXggdGhlbiBcInt7TG93ZXJjYXNlIHRpdGxlfX1cIiBlbHNlIFwie3tESVNQTEFZVElUTEU6I3tkdC52YWx1ZX19fVwiXG4gICAgICAgIGlmIGRpc3BsYXl0aXRsZS5sZW5ndGggb3IgbG93ZXJjYXNldGl0bGUubGVuZ3RoXG4gICAgICAgICAgICBAV00uTG9nLmxvZ1dhcm5pbmcoXCJGb3VuZCBtdWx0aXBsZSBpbnN0YW5jZXMgb2ZcbiAgICAgICAgICAgICAgICB7e0RJU1BMQVlUSVRMRTouLi59fSBvciB7e0xvd2VyY2FzZSB0aXRsZX19OiBvbmx5IHRoZSBsYXN0XG4gICAgICAgICAgICAgICAgb25lIGhhcyBiZWVuIHVzZWQsIHRoZSBvdGhlcnMgaGF2ZSBiZWVuIGRlbGV0ZWRcIilcblxuICAgICAgICAjIEJlaGF2aW9yIHN3aXRjaGVzXG4gICAgICAgIGJlaGF2aW9yc3dpdGNoZXMgPSBAV00uUGFyc2VyLmZpbmRCZWhhdmlvclN3aXRjaGVzKGNvbnRlbnQpXG4gICAgICAgIGJzbGlzdCA9IFtdXG4gICAgICAgIHRlbXBjb250ZW50ID0gXCJcIlxuICAgICAgICBjb250ZW50SWQgPSAwXG4gICAgICAgIGZvciBic3dpdGNoLCBiIGluIGJlaGF2aW9yc3dpdGNoZXNcbiAgICAgICAgICAgIGlmIGJzd2l0Y2gubWF0Y2hbMV0gaW4gW1wiVE9DXCIsIFwiU1RBUlRcIiwgXCJFTkRcIl1cbiAgICAgICAgICAgICAgICBiZWhhdmlvcnN3aXRjaGVzLnNwbGljZShiLCAxKVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGlmIGJzd2l0Y2gubWF0Y2hbMF0gbm90IGluIGJzbGlzdFxuICAgICAgICAgICAgICAgICAgICBic2xpc3QucHVzaChic3dpdGNoLm1hdGNoWzBdKVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgQFdNLkxvZy5sb2dXYXJuaW5nKFwiUmVtb3ZlZCBkdXBsaWNhdGUgb2ZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAje2Jzd2l0Y2gubWF0Y2hbMF19XCIpXG4gICAgICAgICAgICAgICAgdGVtcGNvbnRlbnQgKz0gY29udGVudC5zdWJzdHJpbmcoY29udGVudElkLCBic3dpdGNoLmluZGV4KVxuICAgICAgICAgICAgICAgIGNvbnRlbnRJZCA9IGJzd2l0Y2guaW5kZXggKyBic3dpdGNoLmxlbmd0aFxuXG4gICAgICAgIHRlbXBjb250ZW50ICs9IGNvbnRlbnQuc3Vic3RyaW5nKGNvbnRlbnRJZClcbiAgICAgICAgY29udGVudCA9IHRlbXBjb250ZW50XG5cbiAgICAgICAgaWYgbm90IGRsY3QgYW5kIGJzbGlzdC5sZW5ndGhcbiAgICAgICAgICAgIGhlYWRlciArPSBic2xpc3Quam9pbihcIiBcIikgKyBcIlxcblwiXG4gICAgICAgIGVsc2UgaWYgZGxjdCBhbmQgbm90IGJzbGlzdC5sZW5ndGhcbiAgICAgICAgICAgIGhlYWRlciArPSBkbGN0ICsgXCJcXG5cIlxuICAgICAgICBlbHNlIGlmIGRsY3QgYW5kIGJzbGlzdC5sZW5ndGhcbiAgICAgICAgICAgIGhlYWRlciArPSBkbGN0ICsgXCIgXCIgKyBic2xpc3Quam9pbihcIiBcIikgKyBcIlxcblwiXG5cbiAgICAgICAgIyBDYXRlZ29yaWVzXG4gICAgICAgIGNhdGVnb3JpZXMgPSBAV00uUGFyc2VyLmZpbmRDYXRlZ29yaWVzKGNvbnRlbnQpXG4gICAgICAgIGNhdGxpc3QgPSBbXVxuICAgICAgICBjYXRsaW5rcyA9IFtdXG4gICAgICAgIHRlbXBjb250ZW50ID0gXCJcIlxuICAgICAgICBjb250ZW50SWQgPSAwXG4gICAgICAgIGZvciBjYXQgaW4gY2F0ZWdvcmllc1xuICAgICAgICAgICAgaWYgY2F0LmZyYWdtZW50XG4gICAgICAgICAgICAgICAgQFdNLkxvZy5sb2dXYXJuaW5nKEBXTS5Mb2cubGlua1RvV2lraVBhZ2UoY2F0LmxpbmssXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXQucmF3TGluaykgKyBcIiBjb250YWlucyBhIGZyYWdtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZlcmVuY2UsIGJ1dCBpdCBkb2Vzbid0IG1ha2Ugc2Vuc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluIGNhdGVnb3JpZXMgYW5kIHdpbGwgYmUgcmVtb3ZlZFwiKVxuXG4gICAgICAgICAgICBjbGVhbnRpdGxlID0gQFdNLlBhcnNlci5zcXVhc2hDb250aWd1b3VzV2hpdGVzcGFjZShjYXQudGl0bGUpXG4gICAgICAgICAgICBjYXR0ZXh0ID0gXCJDYXRlZ29yeTpcIiArIGNsZWFudGl0bGVcbiAgICAgICAgICAgICMgRG9uJ3QganVzdCBwYXNzIGNsZWFudGl0bGUgaGVyZSwgb3RoZXJ3aXNlIHRoZSBsYW5ndWFnZSBvZlxuICAgICAgICAgICAgIyAgIHJvb3QgbGFuZ3VhZ2UgY2F0ZWdvcmllcyB3b24ndCBiZSBwcm9wZXJseSBkZXRlY3RlZFxuICAgICAgICAgICAgY2F0bGFuZyA9IEBXTS5BcmNoV2lraS5kZXRlY3RMYW5ndWFnZShjYXR0ZXh0KVsxXVxuICAgICAgICAgICAgY2F0bGluayA9IFwiW1tcIiArIGNhdHRleHQgKyAoaWYgY2F0LmFuY2hvciB0aGVuIFwifFwiICsgY2F0LmFuY2hvciBlbHNlIFwiXCIpICsgXCJdXVwiXG4gICAgICAgICAgICBpZiBsYW5ndWFnZSAhPSBjYXRsYW5nXG4gICAgICAgICAgICAgICAgQFdNLkxvZy5sb2dXYXJuaW5nKEBXTS5Mb2cubGlua1RvV2lraVBhZ2UoY2F0LmxpbmssIGNhdHRleHQpICtcbiAgICAgICAgICAgICAgICAgICAgXCIgYmVsb25ncyB0byBhIGRpZmZlcmVudFxuICAgICAgICAgICAgICAgICAgICBsYW5ndWFnZSB0aGFuIHRoZSBvbmUgb2YgdGhlIHRpdGxlIChcIiArIGxhbmd1YWdlICsgXCIpXCIpXG5cbiAgICAgICAgICAgIGlmIGNhdGxpc3QuaW5kZXhPZihjYXR0ZXh0KSA8IDBcbiAgICAgICAgICAgICAgICBjYXRsaXN0LnB1c2goY2F0dGV4dClcbiAgICAgICAgICAgICAgICBjYXRsaW5rcy5wdXNoKGNhdGxpbmspXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgQFdNLkxvZy5sb2dXYXJuaW5nKFwiUmVtb3ZlZCBkdXBsaWNhdGUgb2YgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQFdNLkxvZy5saW5rVG9XaWtpUGFnZShjYXQubGluaywgY2F0dGV4dCkpXG5cbiAgICAgICAgICAgIHRlbXBjb250ZW50ICs9IGNvbnRlbnQuc3Vic3RyaW5nKGNvbnRlbnRJZCwgY2F0LmluZGV4KVxuICAgICAgICAgICAgY29udGVudElkID0gY2F0LmluZGV4ICsgY2F0Lmxlbmd0aFxuXG4gICAgICAgIGlmIGNhdGxpc3QubGVuZ3RoXG4gICAgICAgICAgICBoZWFkZXIgKz0gY2F0bGlua3Muam9pbihcIlxcblwiKSArIFwiXFxuXCJcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgQFdNLkxvZy5sb2dXYXJuaW5nKFwiVGhlIGFydGljbGUgaXMgbm90IGNhdGVnb3JpemVkXCIpXG4gICAgICAgIHRlbXBjb250ZW50ICs9IGNvbnRlbnQuc3Vic3RyaW5nKGNvbnRlbnRJZClcbiAgICAgICAgY29udGVudCA9IHRlbXBjb250ZW50XG5cbiAgICAgICAgIyBJbnRlcmxhbmd1YWdlIGxpbmtzXG4gICAgICAgIGludGVybGFuZ3VhZ2UgPSBAV00uQXJjaFdpa2kuZmluZEFsbEludGVybGFuZ3VhZ2VMaW5rcyhjb250ZW50KVxuICAgICAgICBpd2xpc3QgPSBbXVxuICAgICAgICBpd2xpbmtzID0gW11cbiAgICAgICAgdGVtcGNvbnRlbnQgPSBcIlwiXG4gICAgICAgIGNvbnRlbnRJZCA9IDBcbiAgICAgICAgZm9yIGxpbmsgaW4gaW50ZXJsYW5ndWFnZVxuICAgICAgICAgICAgaWYgbGluay5hbmNob3JcbiAgICAgICAgICAgICAgICAjIENhbm5vdCB1c2UgQFdNLkxvZy5saW5rVG9XaWtpUGFnZSBiZWNhdXNlIGxvY2FsIGludGVybGFuZ3VhZ2VcbiAgICAgICAgICAgICAgICAjICAgbGlua3Mgd291bGQgbm90IHJlc29sdmVkIGNvcnJlY3RseTsgbGlua1RvUGFnZSB3b3VsZCBuZWVkXG4gICAgICAgICAgICAgICAgIyAgIHRvIGZpbmQgdGhlIFVSTCBpbnN0ZWFkLCB3aGljaCBzZWVtcyB0b28gY29tcGxpY2F0ZWQgZm9yXG4gICAgICAgICAgICAgICAgIyAgIHRoZSBwdXJwb3NlIG9mIHRoaXMgcGx1Z2luXG4gICAgICAgICAgICAgICAgQFdNLkxvZy5sb2dXYXJuaW5nKGxpbmsucmF3TGluayArIFwiIGNvbnRhaW5zIGFuIGFsdGVybmF0aXZlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0LCBidXQgaXQgZG9lc24ndCBtYWtlIHNlbnNlIGluXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcmxhbmd1YWdlIGxpbmtzIGFuZCB3aWxsIGJlIHJlbW92ZWRcIilcblxuICAgICAgICAgICAgIyBBcHBseWluZyBAV00uUGFyc2VyLnNxdWFzaENvbnRpZ3VvdXNXaGl0ZXNwYWNlIGlzIGRhbmdlcm91cyBoZXJlXG4gICAgICAgICAgICAjICAgYmVjYXVzZSB3ZSBkb24ndCBrbm93IGhvdyB0aGUgdGFyZ2V0IHNlcnZlciBoYW5kbGVzIHdoaXRlc3BhY2VcbiAgICAgICAgICAgIGxpbmt0aXRsZSA9IGxpbmsudGl0bGVcbiAgICAgICAgICAgIGxpbmtsYW5nID0gbGluay5uYW1lc3BhY2VcbiAgICAgICAgICAgIGxpbmt0ZXh0ID0gbGlua2xhbmcgKyBcIjpcIiArIGxpbmt0aXRsZVxuICAgICAgICAgICAgZnVsbGxpbmsgPSBcIltbXCIgKyBsaW5rdGV4dCArIChpZiBsaW5rLmZyYWdtZW50IHRoZW4gXCIjXCIgKyBsaW5rLmZyYWdtZW50IGVsc2UgXCJcIikgKyBcIl1dXCJcbiAgICAgICAgICAgIGlmIGl3bGlzdC5pbmRleE9mKGxpbmt0ZXh0KSA8IDBcbiAgICAgICAgICAgICAgICBpd2xpc3QucHVzaChsaW5rdGV4dClcbiAgICAgICAgICAgICAgICBpd2xpbmtzLnB1c2goZnVsbGxpbmspXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgIyBDYW5ub3QgdXNlIEBXTS5Mb2cubGlua1RvV2lraVBhZ2UgYmVjYXVzZSBsb2NhbCBpbnRlcmxhbmd1YWdlXG4gICAgICAgICAgICAgICAgIyAgIGxpbmtzIHdvdWxkIG5vdCByZXNvbHZlZCBjb3JyZWN0bHk7IGxpbmtUb1BhZ2Ugd291bGQgbmVlZFxuICAgICAgICAgICAgICAgICMgICB0byBmaW5kIHRoZSBVUkwgaW5zdGVhZCwgd2hpY2ggc2VlbXMgdG9vIGNvbXBsaWNhdGVkIGZvclxuICAgICAgICAgICAgICAgICMgICB0aGUgcHVycG9zZSBvZiB0aGlzIHBsdWdpblxuICAgICAgICAgICAgICAgIEBXTS5Mb2cubG9nV2FybmluZyhcIlJlbW92ZWQgZHVwbGljYXRlIG9mIFwiICsgbGlua3RleHQpXG5cbiAgICAgICAgICAgIHRlbXBjb250ZW50ICs9IGNvbnRlbnQuc3Vic3RyaW5nKGNvbnRlbnRJZCwgbGluay5pbmRleClcbiAgICAgICAgICAgIGNvbnRlbnRJZCA9IGxpbmsuaW5kZXggKyBsaW5rLmxlbmd0aFxuXG4gICAgICAgIGlmIGl3bGlzdC5sZW5ndGhcbiAgICAgICAgICAgIGl3bGlua3Muc29ydCgpXG4gICAgICAgICAgICBoZWFkZXIgKz0gaXdsaW5rcy5qb2luKFwiXFxuXCIpICsgXCJcXG5cIlxuXG4gICAgICAgIHRlbXBjb250ZW50ICs9IGNvbnRlbnQuc3Vic3RyaW5nKGNvbnRlbnRJZClcbiAgICAgICAgY29udGVudCA9IHRlbXBjb250ZW50XG5cbiAgICAgICAgZmlyc3RDaGFyID0gY29udGVudC5zZWFyY2goL1teXFxzXS8pXG4gICAgICAgIGNvbnRlbnQgPSBjb250ZW50LnN1YnN0cihmaXJzdENoYXIpXG5cbiAgICAgICAgbmV3VGV4dCA9IGhlYWRlciArIGNvbnRlbnRcblxuICAgICAgICBpZiBuZXdUZXh0ICE9IHNvdXJjZVxuICAgICAgICAgICAgQFdNLkVkaXRvci53cml0ZVNvdXJjZShuZXdUZXh0KVxuICAgICAgICAgICAgQFdNLkxvZy5sb2dJbmZvKFwiRml4ZWQgaGVhZGVyXCIpXG5cbiAgICAgICAgaWYgY2FsbE5leHRcbiAgICAgICAgICAgIGNhbGxOZXh0KClcbiIsIiMgV2lraSBNb25rZXkgLSBNZWRpYVdpa2kgYm90IGFuZCBlZGl0b3ItYXNzaXN0YW50IHVzZXIgc2NyaXB0XG4jIENvcHlyaWdodCAoQykgMjAxMSBEYXJpbyBHaW92YW5uZXR0aSA8ZGV2QGRhcmlvZ2lvdmFubmV0dGkubmV0PlxuI1xuIyBUaGlzIGZpbGUgaXMgcGFydCBvZiBXaWtpIE1vbmtleS5cbiNcbiMgV2lraSBNb25rZXkgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuIyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuIyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuIyAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuI1xuIyBXaWtpIE1vbmtleSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuIyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuIyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4jIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4jXG4jIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4jIGFsb25nIHdpdGggV2lraSBNb25rZXkuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG5cbntQbHVnaW59ID0gcmVxdWlyZSgnLi9fUGx1Z2luJylcblxuXG5jbGFzcyBtb2R1bGUuZXhwb3J0cy5BcmNoV2lraUZpeEhlYWRpbmdzIGV4dGVuZHMgUGx1Z2luXG4gICAgQGNvbmZfZGVmYXVsdDpcbiAgICAgICAgZW5hYmxlZDogdHJ1ZVxuICAgICAgICBlZGl0b3JfbWVudTogW1wiVGV4dCBwbHVnaW5zXCIsIFwiRml4IGhlYWRpbmdzXCJdXG5cbiAgICBtYWluX2VkaXRvcjogKGNhbGxOZXh0KSAtPlxuICAgICAgICBzb3VyY2UgPSBAV00uRWRpdG9yLnJlYWRTb3VyY2UoKVxuXG4gICAgICAgIGluZm8gPSBAV00uUGFyc2VyLmZpbmRTZWN0aW9uSGVhZGluZ3Moc291cmNlKVxuXG4gICAgICAgIGlmIEBXTS5FZGl0b3IuaXNTZWN0aW9uKClcbiAgICAgICAgICAgIGluY3JlYXNlTGV2ZWwgPSBpbmZvLm1pbkxldmVsIC0gMVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICBpZiBpbmZvLm1heFRvY0xldmVsIDwgNlxuICAgICAgICAgICAgICAgIGluY3JlYXNlTGV2ZWwgPSAxXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgaW5jcmVhc2VMZXZlbCA9IDBcbiAgICAgICAgICAgICAgICBAV00uTG9nLmxvZ1dhcm5pbmcoXCJUaGVyZSBhcmUgNiBsZXZlbHMgb2YgaGVhZGluZ3MsIGl0IGhhc1xuICAgICAgICAgICAgICAgICAgICBiZWVuIG5lY2Vzc2FyeSB0byBzdGFydCBjcmVhdGluZyB0aGVtIGZyb20gbGV2ZWwgMVxuICAgICAgICAgICAgICAgICAgICBhbHRob3VnaCB1c3VhbGx5IGl0IGlzIHN1Z2dlc3RlZCB0byBzdGFydCBmcm9tIGxldmVsIDJcIilcblxuICAgICAgICBuZXd0ZXh0ID0gXCJcIlxuICAgICAgICBwcmV2SWQgPSAwXG5cbiAgICAgICAgZm9yIHNlY3Rpb24gaW4gaW5mby5zZWN0aW9uc1xuICAgICAgICAgICAgbmV3dGV4dCArPSBzb3VyY2Uuc3Vic3RyaW5nKHByZXZJZCwgc2VjdGlvbi5pbmRleClcbiAgICAgICAgICAgIG5ld3RleHQgKz0gbmV3IEFycmF5KHNlY3Rpb24udG9jTGV2ZWwgKyBpbmNyZWFzZUxldmVsICsgMSkuam9pbihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiPVwiKVxuICAgICAgICAgICAgbmV3dGV4dCArPSBzZWN0aW9uLnJhd2hlYWRpbmdcbiAgICAgICAgICAgIG5ld3RleHQgKz0gbmV3IEFycmF5KHNlY3Rpb24udG9jTGV2ZWwgKyBpbmNyZWFzZUxldmVsICsgMSkuam9pbihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiPVwiKVxuICAgICAgICAgICAgcHJldklkID0gc2VjdGlvbi5pbmRleCArIHNlY3Rpb24ubGVuZ3RoMFxuXG4gICAgICAgIG5ld3RleHQgKz0gc291cmNlLnN1YnN0cihwcmV2SWQpXG5cbiAgICAgICAgaWYgbmV3dGV4dCAhPSBzb3VyY2VcbiAgICAgICAgICAgIEBXTS5FZGl0b3Iud3JpdGVTb3VyY2UobmV3dGV4dClcbiAgICAgICAgICAgIEBXTS5Mb2cubG9nSW5mbyhcIkZpeGVkIHNlY3Rpb24gaGVhZGluZ3NcIilcblxuICAgICAgICBpZiBjYWxsTmV4dFxuICAgICAgICAgICAgY2FsbE5leHQoKVxuIiwiIyBXaWtpIE1vbmtleSAtIE1lZGlhV2lraSBib3QgYW5kIGVkaXRvci1hc3Npc3RhbnQgdXNlciBzY3JpcHRcbiMgQ29weXJpZ2h0IChDKSAyMDExIERhcmlvIEdpb3Zhbm5ldHRpIDxkZXZAZGFyaW9naW92YW5uZXR0aS5uZXQ+XG4jXG4jIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFdpa2kgTW9ua2V5LlxuI1xuIyBXaWtpIE1vbmtleSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4jIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4jIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4jIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4jXG4jIFdpa2kgTW9ua2V5IGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4jIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4jIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiMgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbiNcbiMgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiMgYWxvbmcgd2l0aCBXaWtpIE1vbmtleS4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cblxue1BsdWdpbn0gPSByZXF1aXJlKCcuL19QbHVnaW4nKVxuXG5cbmNsYXNzIG1vZHVsZS5leHBvcnRzLkFyY2hXaWtpRml4TGlua3MgZXh0ZW5kcyBQbHVnaW5cbiAgICBAY29uZl9kZWZhdWx0OlxuICAgICAgICBlbmFibGVkOiB0cnVlXG4gICAgICAgIGVkaXRvcl9tZW51OiBbXCJUZXh0IHBsdWdpbnNcIiwgXCJGaXggZXh0ZXJuYWwgbGlua3NcIl1cblxuICAgIGRvUmVwbGFjZTogKHR4dCkgLT5cbiAgICAgICAgIyBhcmNobGludXgub3JnIEhUVFAgLT4gSFRUUFNcblxuICAgICAgICByZSA9IC9odHRwOlxcL1xcLyhbYS16XStcXC4pP2FyY2hsaW51eFxcLm9yZyg/IVxcLlthLXpdKS9pZ1xuICAgICAgICB0eHQgPSB0eHQucmVwbGFjZShyZSwgJ2h0dHBzOi8vJDFhcmNobGludXgub3JnJylcblxuICAgICAgICAjIHdpa2kuYXJjaGxpbnV4Lm9yZyAtPiBJbnRlcm5hbCBsaW5rXG5cbiAgICAgICAgcmUgPSAvXFxbaHR0cHM/OlxcL1xcL3dpa2lcXC5hcmNobGludXhcXC5vcmdcXC9pbmRleFxcLnBocFxcL0NhdGVnb3J5OihbXlxcXV0rPykgKC4rPylcXF0vaWdcbiAgICAgICAgdHh0ID0gdHh0LnJlcGxhY2UocmUsICdbWzpDYXRlZ29yeTokMXwkMl1dJylcblxuICAgICAgICByZSA9IC9cXFtodHRwcz86XFwvXFwvd2lraVxcLmFyY2hsaW51eFxcLm9yZ1xcL2luZGV4XFwucGhwXFwvQ2F0ZWdvcnk6KC4rPylcXF0vaWdcbiAgICAgICAgdHh0ID0gdHh0LnJlcGxhY2UocmUsICdbWzpDYXRlZ29yeTokMV1dJylcblxuICAgICAgICByZSA9IC9odHRwcz86XFwvXFwvd2lraVxcLmFyY2hsaW51eFxcLm9yZ1xcL2luZGV4XFwucGhwXFwvQ2F0ZWdvcnk6KFteXFxzXSspL2lnXG4gICAgICAgIHR4dCA9IHR4dC5yZXBsYWNlKHJlLCAnW1s6Q2F0ZWdvcnk6JDFdXScpXG5cbiAgICAgICAgcmUgPSAvXFxbaHR0cHM/OlxcL1xcL3dpa2lcXC5hcmNobGludXhcXC5vcmdcXC9pbmRleFxcLnBocFxcLyhbXlxcXV0rPykgKC4rPylcXF0vaWdcbiAgICAgICAgdHh0ID0gdHh0LnJlcGxhY2UocmUsICdbWyQxfCQyXV0nKVxuXG4gICAgICAgIHJlID0gL1xcW2h0dHBzPzpcXC9cXC93aWtpXFwuYXJjaGxpbnV4XFwub3JnXFwvaW5kZXhcXC5waHBcXC8oLis/KVxcXS9pZ1xuICAgICAgICB0eHQgPSB0eHQucmVwbGFjZShyZSwgJ1tbJDFdXScpXG5cbiAgICAgICAgcmUgPSAvaHR0cHM/OlxcL1xcL3dpa2lcXC5hcmNobGludXhcXC5vcmdcXC9pbmRleFxcLnBocFxcLyhbXlxcc10rKS9pZ1xuICAgICAgICB0eHQgPSB0eHQucmVwbGFjZShyZSwgJ1tbJDFdXScpXG5cbiAgICAgICAgcmUgPSAvaHR0cHM/OlxcL1xcL3dpa2lcXC5hcmNobGludXhcXC5vcmcoPyFcXC4pL2lnXG5cbiAgICAgICAgaWYgcmUudGVzdCh0eHQpXG4gICAgICAgICAgICBAV00uTG9nLmxvZ1dhcm5pbmcoXCJJdCBoYXNuJ3QgYmVlbiBwb3NzaWJsZSB0byBjb252ZXJ0IHNvbWUgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJsaW5rcyB0byB3aWtpLmFyY2hsaW51eC5vcmdcIilcblxuICAgICAgICAjIFdpa2lwZWRpYSAtPiB3aWtpcGVkaWE6IGludGVybGlua1xuXG4gICAgICAgIHJlID0gL1xcW2h0dHBzPzpcXC9cXC9lblxcLndpa2lwZWRpYVxcLm9yZ1xcL3dpa2lcXC8oW15cXF1dKz8pICguKz8pXFxdL2lnXG4gICAgICAgIHR4dCA9IHR4dC5yZXBsYWNlKHJlLCAnW1t3aWtpcGVkaWE6JDF8JDJdXScpXG5cbiAgICAgICAgcmUgPSAvXFxbaHR0cHM/OlxcL1xcL2VuXFwud2lraXBlZGlhXFwub3JnXFwvd2lraVxcLyguKz8pXFxdL2lnXG4gICAgICAgIHR4dCA9IHR4dC5yZXBsYWNlKHJlLCAnW1t3aWtpcGVkaWE6JDFdXScpXG5cbiAgICAgICAgcmUgPSAvaHR0cHM/OlxcL1xcL2VuXFwud2lraXBlZGlhXFwub3JnXFwvd2lraVxcLyhbXlxcc10rKS9pZ1xuICAgICAgICB0eHQgPSB0eHQucmVwbGFjZShyZSwgJ1tbd2lraXBlZGlhOiQxXV0nKVxuXG4gICAgICAgIHJlID0gL2h0dHBzPzpcXC9cXC8oW2Etel0rPylcXC53aWtpcGVkaWFcXC5vcmcoPyFcXC4pL2lnXG5cbiAgICAgICAgaWYgcmUudGVzdCh0eHQpXG4gICAgICAgICAgICBAV00uTG9nLmxvZ1dhcm5pbmcoXCJJdCBoYXNuJ3QgYmVlbiBwb3NzaWJsZSB0byBjb252ZXJ0IHNvbWUgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImxpbmtzIHRvIFdpa2lwZWRpYVwiKVxuXG4gICAgICAgICMgT2ZmaWNpYWwgcGFja2FnZSBsaW5rcyAtPiBQa2cgdGVtcGxhdGVcblxuICAgICAgICByZSA9IC9cXFtodHRwcz86XFwvXFwvKD86d3d3XFwuKT9hcmNobGludXhcXC5vcmdcXC9wYWNrYWdlc1xcLyg/OmNvbW11bml0eXxjb21tdW5pdHktdGVzdGluZ3xjb3JlfGV4dHJhfG11bHRpbGlifG11bHRpbGliLXRlc3Rpbmd8dGVzdGluZylcXC8oPzphbnl8aTY4Nnx4ODZfNjQpXFwvKFteXFxzXSs/KVxcLz8gKyguKz8pP1xcXS9pZ1xuICAgICAgICBuZXdUZXh0ID0gJydcbiAgICAgICAgcHJldklkID0gMFxuXG4gICAgICAgIHdoaWxlIHRydWVcbiAgICAgICAgICAgIG1hdGNoID0gcmUuZXhlYyh0eHQpXG5cbiAgICAgICAgICAgIGlmIG1hdGNoXG4gICAgICAgICAgICAgICAgIyBEb24ndCBqb2luIHRoZXNlIHR3byBjb25kaXRpb25zXG4gICAgICAgICAgICAgICAgaWYgbWF0Y2hbMV0gPT0gbWF0Y2hbMl1cbiAgICAgICAgICAgICAgICAgICAgTCA9IG1hdGNoWzBdLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICBuZXdUZXh0ICs9IHR4dC5zdWJzdHJpbmcocHJldklkLCByZS5sYXN0SW5kZXggLSBMKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3t7UGtnfCcgKyBtYXRjaFsxXSArICd9fSdcblxuICAgICAgICAgICAgICAgICAgICBwcmV2SWQgPSByZS5sYXN0SW5kZXhcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBicmVha1xuXG4gICAgICAgIG5ld1RleHQgKz0gdHh0LnN1YnN0cihwcmV2SWQpXG4gICAgICAgIHR4dCA9IG5ld1RleHRcblxuICAgICAgICByZSA9IC9cXFtodHRwcz86XFwvXFwvKD86d3d3XFwuKT9hcmNobGludXhcXC5vcmdcXC9wYWNrYWdlc1xcLyg/OmNvbW11bml0eXxjb21tdW5pdHktdGVzdGluZ3xjb3JlfGV4dHJhfG11bHRpbGlifG11bHRpbGliLXRlc3Rpbmd8dGVzdGluZylcXC8oPzphbnl8aTY4Nnx4ODZfNjQpXFwvKFteXFxzXSs/KVxcLz9cXF0vaWdcbiAgICAgICAgdHh0ID0gdHh0LnJlcGxhY2UocmUsICd7e1BrZ3wkMX19JylcblxuICAgICAgICByZSA9IC8oW15cXFtdKWh0dHBzPzpcXC9cXC8oPzp3d3dcXC4pP2FyY2hsaW51eFxcLm9yZ1xcL3BhY2thZ2VzXFwvKD86Y29tbXVuaXR5fGNvbW11bml0eS10ZXN0aW5nfGNvcmV8ZXh0cmF8bXVsdGlsaWJ8bXVsdGlsaWItdGVzdGluZ3x0ZXN0aW5nKVxcLyg/OmFueXxpNjg2fHg4Nl82NClcXC8oW15cXHNcXC9dKylcXC8/L2lnXG4gICAgICAgIHR4dCA9IHR4dC5yZXBsYWNlKHJlLCAnJDF7e1BrZ3wkMn19JylcblxuICAgICAgICByZSA9IC9odHRwcz86XFwvXFwvKD86d3d3XFwuKT9hcmNobGludXhcXC5vcmdcXC9wYWNrYWdlcyg/IVxcLz9cXHMpL2lnXG5cbiAgICAgICAgaWYgcmUudGVzdCh0eHQpXG4gICAgICAgICAgICBAV00uTG9nLmxvZ1dhcm5pbmcoXCJJdCBoYXNuJ3QgYmVlbiBwb3NzaWJsZSB0byBjb252ZXJ0IHNvbWUgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImxpbmtzIHRvIGFyY2hsaW51eC5vcmcvcGFja2FnZXNcIilcblxuICAgICAgICAjIEFVUiBwYWNrYWdlIGxpbmtzIC0+IEFVUiB0ZW1wbGF0ZVxuXG4gICAgICAgIHJlID0gL1xcW2h0dHBzPzpcXC9cXC9hdXJcXC5hcmNobGludXhcXC5vcmdcXC9wYWNrYWdlc1xcLyhbXlxcc10rPylcXC8/ICsoLis/KT9cXF0vaWdcbiAgICAgICAgbmV3VGV4dCA9ICcnXG4gICAgICAgIHByZXZJZCA9IDBcblxuICAgICAgICB3aGlsZSB0cnVlXG4gICAgICAgICAgICBtYXRjaCA9IHJlLmV4ZWModHh0KVxuXG4gICAgICAgICAgICBpZiBtYXRjaFxuICAgICAgICAgICAgICAgICMgRG9uJ3Qgam9pbiB0aGVzZSB0d28gY29uZGl0aW9uc1xuICAgICAgICAgICAgICAgIGlmIG1hdGNoWzFdID09IG1hdGNoWzJdXG4gICAgICAgICAgICAgICAgICAgIEwgPSBtYXRjaFswXS5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgbmV3VGV4dCArPSB0eHQuc3Vic3RyaW5nKHByZXZJZCwgcmUubGFzdEluZGV4IC0gTCkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICd7e0FVUnwnICsgbWF0Y2hbMV0gKyAnfX0nXG5cbiAgICAgICAgICAgICAgICAgICAgcHJldklkID0gcmUubGFzdEluZGV4XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgYnJlYWtcblxuICAgICAgICBuZXdUZXh0ICs9IHR4dC5zdWJzdHIocHJldklkKVxuICAgICAgICB0eHQgPSBuZXdUZXh0XG5cbiAgICAgICAgcmUgPSAvXFxbaHR0cHM/OlxcL1xcL2F1clxcLmFyY2hsaW51eFxcLm9yZ1xcL3BhY2thZ2VzXFwvKFteXFxzXSs/KVxcLz9cXF0vaWdcbiAgICAgICAgdHh0ID0gdHh0LnJlcGxhY2UocmUsICd7e0FVUnwkMX19JylcblxuICAgICAgICByZSA9IC8oW15cXFtdKWh0dHBzPzpcXC9cXC9hdXJcXC5hcmNobGludXhcXC5vcmdcXC9wYWNrYWdlc1xcLyhbXlxcc1xcL10rKVxcLz8vaWdcbiAgICAgICAgdHh0ID0gdHh0LnJlcGxhY2UocmUsICckMXt7QVVSfCQyfX0nKVxuXG4gICAgICAgIHJlID0gL2h0dHBzPzpcXC9cXC9hdXJcXC5hcmNobGludXhcXC5vcmcoPyEoPzpcXC58KD86XFwvP3BhY2thZ2VzKT9cXC8/XFxzKSkvaWdcblxuICAgICAgICBpZiByZS50ZXN0KHR4dClcbiAgICAgICAgICAgIEBXTS5Mb2cubG9nV2FybmluZyhcIkl0IGhhc24ndCBiZWVuIHBvc3NpYmxlIHRvIGNvbnZlcnQgc29tZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmtzIHRvIGF1ci5hcmNobGludXgub3JnICh0cnkgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxcIkZpeCBvbGQgQVVSIGxpbmtzXFxcIiBmdW5jdGlvbiwgaWYgaW5zdGFsbGVkKVwiKVxuXG4gICAgICAgICMgQnVnIGxpbmtzIC0+IEJ1ZyB0ZW1wbGF0ZVxuXG4gICAgICAgIHJlID0gL1xcW2h0dHBzPzpcXC9cXC9idWdzXFwuYXJjaGxpbnV4XFwub3JnXFwvdGFza1xcLyhbXlxcc10rPylcXC8/ICsoLis/KT9cXF0vaWdcbiAgICAgICAgbmV3VGV4dCA9ICcnXG4gICAgICAgIHByZXZJZCA9IDBcblxuICAgICAgICB3aGlsZSB0cnVlXG4gICAgICAgICAgICBtYXRjaCA9IHJlLmV4ZWModHh0KVxuXG4gICAgICAgICAgICBpZiBtYXRjaFxuICAgICAgICAgICAgICAgICMgRG9uJ3Qgam9pbiB0aGVzZSB0d28gY29uZGl0aW9uc1xuICAgICAgICAgICAgICAgIGlmIG1hdGNoWzFdID09IG1hdGNoWzJdXG4gICAgICAgICAgICAgICAgICAgIEwgPSBtYXRjaFswXS5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgbmV3VGV4dCArPSB0eHQuc3Vic3RyaW5nKHByZXZJZCwgcmUubGFzdEluZGV4IC0gTCkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICd7e0J1Z3wnICsgbWF0Y2hbMV0gKyAnfX0nXG5cbiAgICAgICAgICAgICAgICAgICAgcHJldklkID0gcmUubGFzdEluZGV4XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgYnJlYWtcblxuICAgICAgICBuZXdUZXh0ICs9IHR4dC5zdWJzdHIocHJldklkKVxuICAgICAgICB0eHQgPSBuZXdUZXh0XG5cbiAgICAgICAgcmUgPSAvXFxbaHR0cHM/OlxcL1xcL2J1Z3NcXC5hcmNobGludXhcXC5vcmdcXC90YXNrXFwvKFteXFxzXSs/KVxcLz9cXF0vaWdcbiAgICAgICAgdHh0ID0gdHh0LnJlcGxhY2UocmUsICd7e0J1Z3wkMX19JylcblxuICAgICAgICByZSA9IC8oW15cXFtdKWh0dHBzPzpcXC9cXC9idWdzXFwuYXJjaGxpbnV4XFwub3JnXFwvdGFza1xcLyhbXlxcc1xcL10rKVxcLz8vaWdcbiAgICAgICAgdHh0ID0gdHh0LnJlcGxhY2UocmUsICckMXt7QnVnfCQyfX0nKVxuXG4gICAgICAgIHJlID0gL2h0dHBzPzpcXC9cXC9idWdzXFwuYXJjaGxpbnV4XFwub3JnXFwvdGFzay9pZ1xuXG4gICAgICAgIGlmIHJlLnRlc3QodHh0KVxuICAgICAgICAgICAgQFdNLkxvZy5sb2dXYXJuaW5nKFwiSXQgaGFzbid0IGJlZW4gcG9zc2libGUgdG8gY29udmVydCBzb21lIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImxpbmtzIHRvIGJ1Z3MuYXJjaGxpbnV4Lm9yZy90YXNrXCIpXG5cbiAgICAgICAgcmV0dXJuIHR4dFxuXG4gICAgbWFpbl9lZGl0b3I6IChjYWxsTmV4dCkgLT5cbiAgICAgICAgc291cmNlID0gQFdNLkVkaXRvci5yZWFkU291cmNlKClcbiAgICAgICAgbmV3dGV4dCA9IEBkb1JlcGxhY2Uoc291cmNlKVxuXG4gICAgICAgIGlmIG5ld3RleHQgIT0gc291cmNlXG4gICAgICAgICAgICBAV00uRWRpdG9yLndyaXRlU291cmNlKG5ld3RleHQpXG4gICAgICAgICAgICBAV00uTG9nLmxvZ0luZm8oXCJGaXhlZCBsaW5rc1wiKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICBAV00uTG9nLmxvZ0luZm8oXCJObyBmaXhhYmxlIGxpbmtzIGZvdW5kXCIpXG5cbiAgICAgICAgaWYgY2FsbE5leHRcbiAgICAgICAgICAgIGNhbGxOZXh0KClcblxuICAgICMgTm90ZSB0aGF0IGl0J3MgdG9vIGRhbmdlcm91cyB0byB1c2UgdGhpcyBwbHVnaW4gd2l0aCB0aGUgYm90LCBpbiBmYWN0XG4gICAgIyBzb21lIGZ1bGwgVVJMcyBhcmUgY29ycmVjdGx5IHVzZWQgaW4gY29kZSBibG9ja3MgKGUuZy4gd2dldCBsaW5lcylcbiIsIiMgV2lraSBNb25rZXkgLSBNZWRpYVdpa2kgYm90IGFuZCBlZGl0b3ItYXNzaXN0YW50IHVzZXIgc2NyaXB0XG4jIENvcHlyaWdodCAoQykgMjAxMSBEYXJpbyBHaW92YW5uZXR0aSA8ZGV2QGRhcmlvZ2lvdmFubmV0dGkubmV0PlxuI1xuIyBUaGlzIGZpbGUgaXMgcGFydCBvZiBXaWtpIE1vbmtleS5cbiNcbiMgV2lraSBNb25rZXkgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuIyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuIyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuIyAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuI1xuIyBXaWtpIE1vbmtleSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuIyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuIyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4jIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4jXG4jIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4jIGFsb25nIHdpdGggV2lraSBNb25rZXkuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG5cbntQbHVnaW59ID0gcmVxdWlyZSgnLi9fUGx1Z2luJylcblxuQ1NTID0gcmVxdWlyZSgnQGt5bmlrb3MvbWlzYy9kaXN0L0NTUycpXG5cblxuY2xhc3MgbW9kdWxlLmV4cG9ydHMuQXJjaFdpa2lOUEZpbHRlciBleHRlbmRzIFBsdWdpblxuICAgIEBjb25mX2RlZmF1bHQ6XG4gICAgICAgIGVuYWJsZWQ6IHRydWVcbiAgICAgICAgZmlsdGVyX2xhYmVsOiBcIkRlZmF1bHQgZmlsdGVyXCJcbiAgICAgICAgZGVmYXVsdF9sYW5ndWFnZTogXCJFbmdsaXNoXCJcblxuICAgIG1haW5fbmV3cGFnZXM6IC0+XG4gICAgICAgIENTUy5hZGRTdHlsZUVsZW1lbnQoXCIjbXctY29udGVudC10ZXh0ID4gaDVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7YmFja2dyb3VuZC1jb2xvcjojYWZhO31cIilcblxuICAgICAgICBjb250ZW50RGl2ID0gJCgnI213LWNvbnRlbnQtdGV4dCcpXG4gICAgICAgIHVsID0gY29udGVudERpdi5maW5kKCd1bCcpLmZpcnN0KClcbiAgICAgICAgbGlMaXN0ID0gdWwuY2hpbGRyZW4oJ2xpJylcblxuICAgICAgICBmb3IgbGkgaW4gbGlMaXN0XG4gICAgICAgICAgICBsaW5rID0gJChsaSkuZmluZCgnYS5tdy1uZXdwYWdlcy1wYWdlbmFtZScpLmZpcnN0KClcbiAgICAgICAgICAgIFtwdXJlVGl0bGUsIGxhbmd1YWdlXSA9IEBXTS5BcmNoV2lraS5kZXRlY3RMYW5ndWFnZShsaW5rWzBdLnRpdGxlKVxuICAgICAgICAgICAgaWYgbGFuZ3VhZ2UgIT0gQGNvbmYuZGVmYXVsdF9sYW5ndWFnZVxuICAgICAgICAgICAgICAgIEBtb3ZlQXJ0aWNsZShjb250ZW50RGl2LCBsaSwgbGFuZ3VhZ2UpXG5cbiAgICAgICAgQFdNLkxvZy5sb2dJbmZvKFwiR3JvdXBlZCBhcnRpY2xlcyBieSBsYW5ndWFnZVwiKVxuXG4gICAgbW92ZUFydGljbGU6IChjb250ZW50RGl2LCBsaSwgbGFuZ3VhZ2UpIC0+XG4gICAgICAgIGxhbmdIcyA9IGNvbnRlbnREaXYuY2hpbGRyZW4oJ2g1JylcbiAgICAgICAgbGFuZ0ZvdW5kID0gZmFsc2VcbiAgICAgICAgZm9yIEhMYW5nIGluIGxhbmdIc1xuICAgICAgICAgICAgaWYgSExhbmcuaW5uZXJIVE1MID09IGxhbmd1YWdlXG4gICAgICAgICAgICAgICAgdWwgPSAkKEhMYW5nKS5uZXh0KCkuYXBwZW5kKGxpKVxuICAgICAgICAgICAgICAgIGxhbmdGb3VuZCA9IHRydWVcbiAgICAgICAgICAgICAgICBicmVha1xuXG4gICAgICAgIGlmIG5vdCBsYW5nRm91bmRcbiAgICAgICAgICAgIGNvbnRlbnREaXYuYXBwZW5kKFxuICAgICAgICAgICAgICAgICQoJzxoNT4nKS50ZXh0KGxhbmd1YWdlKSxcbiAgICAgICAgICAgICAgICAkKCc8dWw+JykuYXBwZW5kKGxpKSxcbiAgICAgICAgICAgIClcbiIsIiMgV2lraSBNb25rZXkgLSBNZWRpYVdpa2kgYm90IGFuZCBlZGl0b3ItYXNzaXN0YW50IHVzZXIgc2NyaXB0XG4jIENvcHlyaWdodCAoQykgMjAxMSBEYXJpbyBHaW92YW5uZXR0aSA8ZGV2QGRhcmlvZ2lvdmFubmV0dGkubmV0PlxuI1xuIyBUaGlzIGZpbGUgaXMgcGFydCBvZiBXaWtpIE1vbmtleS5cbiNcbiMgV2lraSBNb25rZXkgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuIyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuIyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuIyAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuI1xuIyBXaWtpIE1vbmtleSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuIyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuIyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4jIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4jXG4jIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4jIGFsb25nIHdpdGggV2lraSBNb25rZXkuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG5cbntQbHVnaW59ID0gcmVxdWlyZSgnLi9fUGx1Z2luJylcblxuXG5jbGFzcyBtb2R1bGUuZXhwb3J0cy5BcmNoV2lraU5ld1RlbXBsYXRlcyBleHRlbmRzIFBsdWdpblxuICAgIEBjb25mX2RlZmF1bHQ6XG4gICAgICAgIGVuYWJsZWQ6IHRydWVcbiAgICAgICAgZWRpdG9yX21lbnU6IFtcIlRleHQgcGx1Z2luc1wiLCBcIlVzZSBjb2RlIHRlbXBsYXRlc1wiXVxuXG4gICAgbWFpbl9lZGl0b3I6IChjYWxsTmV4dCkgLT5cbiAgICAgICAgc291cmNlID0gQFdNLkVkaXRvci5yZWFkU291cmNlKClcbiAgICAgICAgbmV3dGV4dCA9IHNvdXJjZVxuXG4gICAgICAgIHJlOCA9IC88cHJlPigoKD8hPChwcmV8bm93aWtpKT4pW15cXD1cXHxdKSo/KCg/ITwocHJlfG5vd2lraSk+KVteXFw9XFx8XFx9XSkpPFxcL3ByZT4vaWdcbiAgICAgICAgcmU5ID0gLzxwcmU+KCgoPyE8KHByZXxub3dpa2kpPilbXlxcfF0pKj8oKD8hPChwcmV8bm93aWtpKT4pW15cXHxcXH1dKSk8XFwvcHJlPi9pZ1xuICAgICAgICByZTEwID0gLzxwcmU+KFxcbiooKD8hPChwcmV8bm93aWtpKT4pLlxcbiopKz8pPFxcL3ByZT4vaWdcblxuICAgICAgICByZTExID0gLzxjb2RlPigoKD8hPChjb2RlfG5vd2lraSk+KVteXFw9XFx8XFxuXSkqPygoPyE8KGNvZGV8bm93aWtpKT4pW15cXD1cXHxcXH1cXG5dKSk8XFwvY29kZT4vaWdcbiAgICAgICAgcmUxMiA9IC88Y29kZT4oKCg/ITwoY29kZXxub3dpa2kpPilbXlxcfFxcbl0pKj8oKD8hPChjb2RlfG5vd2lraSk+KVteXFx8XFx9XFxuXSkpPFxcL2NvZGU+L2lnXG4gICAgICAgIHJlMTMgPSAvPGNvZGU+KCgoPyE8KGNvZGV8bm93aWtpKT4pW15cXG5dKSs/KTxcXC9jb2RlPi9pZ1xuXG4gICAgICAgIHJlMTQgPSAvPHR0PigoKD8hPCh0dHxub3dpa2kpPilbXlxcPVxcfFxcbl0pKj8oKD8hPCh0dHxub3dpa2kpPilbXlxcPVxcfFxcfVxcbl0pKTxcXC90dD4vaWdcbiAgICAgICAgcmUxNSA9IC88dHQ+KCgoPyE8KHR0fG5vd2lraSk+KVteXFx8XFxuXSkqPygoPyE8KHR0fG5vd2lraSk+KVteXFx8XFx9XFxuXSkpPFxcL3R0Pi9pZ1xuICAgICAgICByZTE2ID0gLzx0dD4oKCg/ITwodHR8bm93aWtpKT4pW15cXG5dKSs/KTxcXC90dD4vaWdcblxuICAgICAgICBuZXd0ZXh0ID0gbmV3dGV4dC5yZXBsYWNlKHJlOCwgJ3t7YmN8JDF9fScpXG4gICAgICAgIG5ld3RleHQgPSBuZXd0ZXh0LnJlcGxhY2UocmU5LCAne3tiY3wxPSQxfX0nKSAgIyBNdXN0IGNvbWUgYWZ0ZXIgcmU4XG4gICAgICAgIG5ld3RleHQgPSBuZXd0ZXh0LnJlcGxhY2UocmUxMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICd7e2JjfDxub3dpa2k+JDE8L25vd2lraT59fScpICAjIE11c3QgY29tZSBhZnRlciByZTlcblxuICAgICAgICBuZXd0ZXh0ID0gbmV3dGV4dC5yZXBsYWNlKHJlMTEsICd7e2ljfCQxfX0nKVxuICAgICAgICBuZXd0ZXh0ID0gbmV3dGV4dC5yZXBsYWNlKHJlMTIsICd7e2ljfDE9JDF9fScpICAjIE11c3QgY29tZSBhZnRlciByZTExXG4gICAgICAgIG5ld3RleHQgPSBuZXd0ZXh0LnJlcGxhY2UocmUxMyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd7e2ljfDxub3dpa2k+JDE8L25vd2lraT59fScpICAjIE11c3QgY29tZSBhZnRlciByZTEyXG5cbiAgICAgICAgbmV3dGV4dCA9IG5ld3RleHQucmVwbGFjZShyZTE0LCAne3tpY3wkMX19JylcbiAgICAgICAgbmV3dGV4dCA9IG5ld3RleHQucmVwbGFjZShyZTE1LCAne3tpY3wxPSQxfX0nKSAgIyBNdXN0IGNvbWUgYWZ0ZXIgcmUxNFxuICAgICAgICBuZXd0ZXh0ID0gbmV3dGV4dC5yZXBsYWNlKHJlMTYsXG4gICAgICAgICAgICAgICAgICAgICAgICAne3tpY3w8bm93aWtpPiQxPC9ub3dpa2k+fX0nKSAgIyBNdXN0IGNvbWUgYWZ0ZXIgcmUxNVxuXG4gICAgICAgIGlmIG5ld3RleHQgIT0gc291cmNlXG4gICAgICAgICAgICBAV00uRWRpdG9yLndyaXRlU291cmNlKG5ld3RleHQpXG4gICAgICAgICAgICBAV00uTG9nLmxvZ0luZm8oXCJUdXJuZWQgSFRNTCB0YWdzIGludG8gcHJvcGVyIHRlbXBsYXRlc1wiKVxuXG4gICAgICAgIHRlc3RzID0gW1xuICAgICAgICAgICAgWycmbHQ7cHJlPicsIG5ld3RleHQubWF0Y2goLzxwcmUvaWcpXSxcbiAgICAgICAgICAgIFsnJmx0O2NvZGU+JywgbmV3dGV4dC5tYXRjaCgvPGNvZGUvaWcpXSxcbiAgICAgICAgICAgIFsnJmx0O3R0PicsIG5ld3RleHQubWF0Y2goLzx0dC9pZyldXG4gICAgICAgIF1cblxuICAgICAgICBmb3IgdGVzdCBpbiB0ZXN0c1xuICAgICAgICAgICAgaWYgdGVzdFsxXVxuICAgICAgICAgICAgICAgIEBXTS5Mb2cubG9nV2FybmluZyh0ZXN0WzFdLmxlbmd0aCArICcgJyArXG4gICAgICAgICAgICAgICAgICAgIHRlc3RbMF0gKyAnIGluc3RhbmNlcyByZXF1aXJlIG1hbnVhbCBpbnRlcnZlbnRpb24nKVxuXG4gICAgICAgIGlmIGNhbGxOZXh0XG4gICAgICAgICAgICBjYWxsTmV4dCgpXG4iLCIjIFdpa2kgTW9ua2V5IC0gTWVkaWFXaWtpIGJvdCBhbmQgZWRpdG9yLWFzc2lzdGFudCB1c2VyIHNjcmlwdFxuIyBDb3B5cmlnaHQgKEMpIDIwMTEgRGFyaW8gR2lvdmFubmV0dGkgPGRldkBkYXJpb2dpb3Zhbm5ldHRpLm5ldD5cbiNcbiMgVGhpcyBmaWxlIGlzIHBhcnQgb2YgV2lraSBNb25rZXkuXG4jXG4jIFdpa2kgTW9ua2V5IGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiMgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiMgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiMgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbiNcbiMgV2lraSBNb25rZXkgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiMgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiMgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuIyBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuI1xuIyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuIyBhbG9uZyB3aXRoIFdpa2kgTW9ua2V5LiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuXG57UGx1Z2lufSA9IHJlcXVpcmUoJy4vX1BsdWdpbicpXG5cbkNTUyA9IHJlcXVpcmUoJ0BreW5pa29zL21pc2MvZGlzdC9DU1MnKVxuXG5cbmNsYXNzIG1vZHVsZS5leHBvcnRzLkFyY2hXaWtpUkNGaWx0ZXIgZXh0ZW5kcyBQbHVnaW5cbiAgICBAY29uZl9kZWZhdWx0OlxuICAgICAgICBlbmFibGVkOiB0cnVlXG4gICAgICAgIGZpbHRlcl9sYWJlbDogXCJEZWZhdWx0IGZpbHRlclwiXG4gICAgICAgIGRlZmF1bHRfbGFuZ3VhZ2U6IFwiRW5nbGlzaFwiXG5cbiAgICBtYWluX3JlY2VudGNoYW5nZXM6IC0+XG4gICAgICAgIGg0cyA9ICQoJyNtdy1jb250ZW50LXRleHQgLm13LWNoYW5nZXNsaXN0ID4gaDQnKVxuXG4gICAgICAgIGlmIGg0cy5lcSgwKS5uZXh0KClbMF0ubG9jYWxOYW1lLnRvTG93ZXJDYXNlKCkgIT0gJ2RpdidcbiAgICAgICAgICAgIEBXTS5Mb2cubG9nRXJyb3IoXCJUaGlzIGZpbHRlciBpcyBkZXNpZ25lZCB0byB3b3JrIG9uIHRvcCBvZlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWVkaWFXaWtpJ3MgZmlsdGVyLCB3aGljaCB5b3UgY2FuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmFibGUgaW4geW91ciB1c2VyIHByZWZlcmVuY2VzLlwiKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICBDU1MuYWRkU3R5bGVFbGVtZW50KFwiI213LWNvbnRlbnQtdGV4dCA+IGRpdiA+IGg0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7YmFja2dyb3VuZC1jb2xvcjojYWFmO31cbiAgICAgICAgICAgICAgICAgICAgI213LWNvbnRlbnQtdGV4dCA+IGRpdiA+IGRpdiA+IGg1IHtiYWNrZ3JvdW5kLWNvbG9yOiNhZmE7fVwiKVxuXG4gICAgICAgICAgICBmb3IgaDQgaW4gaDRzXG4gICAgICAgICAgICAgICAgZ3JvdXBEaXYgPSAkKGg0KS5uZXh0KClcbiAgICAgICAgICAgICAgICBmb3IgYXJ0aWNsZVRhYmxlIGluIGdyb3VwRGl2LmNoaWxkcmVuKCd0YWJsZScpXG4gICAgICAgICAgICAgICAgICAgIGxpbmsgPSAkKGFydGljbGVUYWJsZSkuZmluZCgnYS5tdy1jaGFuZ2VzbGlzdC10aXRsZScpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5maXJzdCgpXG4gICAgICAgICAgICAgICAgICAgIGlmIGxpbmtbMF1cbiAgICAgICAgICAgICAgICAgICAgICAgIFtwdXJlVGl0bGUsIGxhbmd1YWdlXSA9IEBXTS5BcmNoV2lraS5kZXRlY3RMYW5ndWFnZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rWzBdLnRpdGxlKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgbGFuZ3VhZ2UgIT0gQGNvbmYuZGVmYXVsdF9sYW5ndWFnZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEBtb3ZlQXJ0aWNsZShncm91cERpdiwgYXJ0aWNsZVRhYmxlLCBsYW5ndWFnZSlcblxuICAgICAgICAgICAgQFdNLkxvZy5sb2dJbmZvKFwiR3JvdXBlZCBhcnRpY2xlcyBieSBsYW5ndWFnZVwiKVxuXG4gICAgbW92ZUFydGljbGU6IChncm91cERpdiwgYXJ0aWNsZVRhYmxlLCBsYW5ndWFnZSkgLT5cbiAgICAgICAgbGFuZ0hzID0gZ3JvdXBEaXYuY2hpbGRyZW4oJ2g1JylcbiAgICAgICAgbGFuZ0ZvdW5kID0gZmFsc2VcbiAgICAgICAgZm9yIEhMYW5nLCBpIGluIGxhbmdIc1xuICAgICAgICAgICAgaWYgSExhbmcuaW5uZXJIVE1MID09IGxhbmd1YWdlXG4gICAgICAgICAgICAgICAgaWYgaSArIDEgPCBsYW5nSHMubGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgIGxhbmdIcy5lcShpICsgMSkuYmVmb3JlKGFydGljbGVUYWJsZSlcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGdyb3VwRGl2LmFwcGVuZChhcnRpY2xlVGFibGUpXG4gICAgICAgICAgICAgICAgbGFuZ0ZvdW5kID0gdHJ1ZVxuICAgICAgICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgaWYgbm90IGxhbmdGb3VuZFxuICAgICAgICAgICAgZ3JvdXBEaXYuYXBwZW5kKFxuICAgICAgICAgICAgICAgICQoJzxoNT4nKS50ZXh0KGxhbmd1YWdlKSxcbiAgICAgICAgICAgICAgICBhcnRpY2xlVGFibGUsXG4gICAgICAgICAgICApXG4iLCIjIFdpa2kgTW9ua2V5IC0gTWVkaWFXaWtpIGJvdCBhbmQgZWRpdG9yLWFzc2lzdGFudCB1c2VyIHNjcmlwdFxuIyBDb3B5cmlnaHQgKEMpIDIwMTEgRGFyaW8gR2lvdmFubmV0dGkgPGRldkBkYXJpb2dpb3Zhbm5ldHRpLm5ldD5cbiNcbiMgVGhpcyBmaWxlIGlzIHBhcnQgb2YgV2lraSBNb25rZXkuXG4jXG4jIFdpa2kgTW9ua2V5IGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiMgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiMgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiMgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbiNcbiMgV2lraSBNb25rZXkgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiMgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiMgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuIyBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuI1xuIyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuIyBhbG9uZyB3aXRoIFdpa2kgTW9ua2V5LiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuXG57UGx1Z2lufSA9IHJlcXVpcmUoJy4vX1BsdWdpbicpXG5cbkNTUyA9IHJlcXVpcmUoJ0BreW5pa29zL21pc2MvZGlzdC9DU1MnKVxuSFRUUCA9IHJlcXVpcmUoJ0BreW5pa29zL21pc2MvZGlzdC9IVFRQJylcblxuXG5jbGFzcyBtb2R1bGUuZXhwb3J0cy5BcmNoV2lraVNhdmVUYWxrIGV4dGVuZHMgUGx1Z2luXG4gICAgQGNvbmZfZGVmYXVsdDpcbiAgICAgICAgZW5hYmxlZDogZmFsc2VcbiAgICAgICAgZGlmZl9tZW51OiBbXCJTYXZlIGRpc2N1c3Npb25cIl1cbiAgICAgICAgcGFnZTogbnVsbFxuICAgICAgICBlZGl0X3N1bW1hcnk6IFwiYWRkIGRpc2N1c3Npb25cIlxuXG4gICAgbWFrZVVJOiAtPlxuICAgICAgICBDU1MuYWRkU3R5bGVFbGVtZW50KFwiI1dpa2lNb25rZXktQXJjaFdpa2lTYXZlVGFsa1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHttYXJnaW4tbGVmdDowLjMzZW07fVwiKVxuXG4gICAgICAgIGFydGljbGUgPSBAY29uZi5wYWdlXG5cbiAgICAgICAgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKVxuICAgICAgICBsaW5rLmlkID0gXCJXaWtpTW9ua2V5LUFyY2hXaWtpU2F2ZVRhbGtcIlxuICAgICAgICBsaW5rLmhyZWYgPSBcIi9pbmRleC5waHAvXCIgKyBhcnRpY2xlXG4gICAgICAgIGxpbmsuaW5uZXJIVE1MID0gYXJ0aWNsZVxuXG4gICAgICAgIHJldHVybiBsaW5rXG5cbiAgICBtYWluX2RpZmY6IChjYWxsTmV4dCkgLT5cbiAgICAgICAgYXJ0aWNsZSA9IEBjb25mLnBhZ2VcbiAgICAgICAgc3VtbWFyeSA9IEBjb25mLmVkaXRfc3VtbWFyeVxuXG4gICAgICAgIEBXTS5Mb2cubG9nSW5mbygnQXBwZW5kaW5nIGRpZmYgdG8gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQFdNLkxvZy5saW5rVG9XaWtpUGFnZShhcnRpY2xlLCBhcnRpY2xlKSArIFwiIC4uLlwiKVxuXG4gICAgICAgIEBXTS5EaWZmLmdldEVuZFRpbWVzdGFtcChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBAbWFpbkdldEVuZFRpbWVzdGFtcCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbYXJ0aWNsZSwgc3VtbWFyeSwgY2FsbE5leHRdKVxuXG4gICAgbWFpbkdldEVuZFRpbWVzdGFtcDogKGVuZGRhdGUsIGFyZ3MpID0+XG4gICAgICAgIGFydGljbGUgPSBhcmdzWzBdXG4gICAgICAgIHN1bW1hcnkgPSBhcmdzWzFdXG4gICAgICAgIGNhbGxOZXh0ID0gYXJnc1syXVxuXG4gICAgICAgIEBXTS5NVy5jYWxsUXVlcnlFZGl0KGFydGljbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQG1haW5Xcml0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbc3VtbWFyeSwgZW5kZGF0ZSwgY2FsbE5leHRdKVxuXG4gICAgbWFpbldyaXRlOiAoYXJ0aWNsZSwgc291cmNlLCB0aW1lc3RhbXAsIGVkaXR0b2tlbiwgYXJncykgPT5cbiAgICAgICAgc3VtbWFyeSA9IGFyZ3NbMF1cbiAgICAgICAgZW5kZGF0ZSA9IGFyZ3NbMV1cbiAgICAgICAgY2FsbE5leHQgPSBhcmdzWzJdXG5cbiAgICAgICAgdGl0bGUgPSBIVFRQLmdldFVSSVBhcmFtZXRlcihudWxsLCAndGl0bGUnKVxuICAgICAgICBwRW5kZGF0ZSA9IGVuZGRhdGUuc3Vic3RyKDAsIDEwKSArIFwiJm5ic3A7XCIgKyBlbmRkYXRlLnN1YnN0cigxMSwgOClcblxuICAgICAgICBuZXd0ZXh0ID0gQFdNLlRhYmxlcy5hcHBlbmRSb3coc291cmNlLCBcIjwhLS0gUkVQTFkgVEFCTEUgLS0+XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBbXCJbXCIgKyBsb2NhdGlvbi5ocmVmICsgXCIgXCIgKyB0aXRsZSArIFwiXVwiLCBwRW5kZGF0ZV0pXG5cbiAgICAgICAgQFdNLk1XLmNhbGxBUElQb3N0KFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGFjdGlvbjogXCJlZGl0XCIsXG4gICAgICAgICAgICAgICAgYm90OiBcIjFcIixcbiAgICAgICAgICAgICAgICB0aXRsZTogYXJ0aWNsZSxcbiAgICAgICAgICAgICAgICBzdW1tYXJ5OiBzdW1tYXJ5LFxuICAgICAgICAgICAgICAgIHRleHQ6IG5ld3RleHQsXG4gICAgICAgICAgICAgICAgYmFzZXRpbWVzdGFtcDogdGltZXN0YW1wLFxuICAgICAgICAgICAgICAgIHRva2VuOiBlZGl0dG9rZW5cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBAbWFpbkVuZCxcbiAgICAgICAgICAgIFthcnRpY2xlLCBjYWxsTmV4dF0sXG4gICAgICAgICAgICBudWxsXG4gICAgICAgIClcblxuICAgIG1haW5FbmQ6IChyZXMsIGFyZ3MpID0+XG4gICAgICAgIGFydGljbGUgPSBhcmdzWzBdXG4gICAgICAgIGNhbGxOZXh0ID0gYXJnc1sxXVxuXG4gICAgICAgIGlmIHJlcy5lZGl0IGFuZCByZXMuZWRpdC5yZXN1bHQgPT0gJ1N1Y2Nlc3MnXG4gICAgICAgICAgICBAV00uTG9nLmxvZ0luZm8oJ0RpZmYgY29ycmVjdGx5IGFwcGVuZGVkIHRvICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQFdNLkxvZy5saW5rVG9XaWtpUGFnZShhcnRpY2xlLCBhcnRpY2xlKSlcbiAgICAgICAgICAgIGlmIGNhbGxOZXh0XG4gICAgICAgICAgICAgICAgY2FsbE5leHQoKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICBAV00uTG9nLmxvZ0Vycm9yKCdUaGUgZGlmZiBoYXMgbm90IGJlZW4gYXBwZW5kZWQhXFxuJyArXG4gICAgICAgICAgICAgICAgICAgIHJlc1snZXJyb3InXVsnaW5mbyddICsgXCIgKFwiICsgcmVzWydlcnJvciddWydjb2RlJ10gKyBcIilcIilcbiIsIiMgV2lraSBNb25rZXkgLSBNZWRpYVdpa2kgYm90IGFuZCBlZGl0b3ItYXNzaXN0YW50IHVzZXIgc2NyaXB0XG4jIENvcHlyaWdodCAoQykgMjAxMSBEYXJpbyBHaW92YW5uZXR0aSA8ZGV2QGRhcmlvZ2lvdmFubmV0dGkubmV0PlxuI1xuIyBUaGlzIGZpbGUgaXMgcGFydCBvZiBXaWtpIE1vbmtleS5cbiNcbiMgV2lraSBNb25rZXkgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuIyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuIyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuIyAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuI1xuIyBXaWtpIE1vbmtleSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuIyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuIyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4jIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4jXG4jIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4jIGFsb25nIHdpdGggV2lraSBNb25rZXkuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG5cbntQbHVnaW59ID0gcmVxdWlyZSgnLi9fUGx1Z2luJylcblxuXG5jbGFzcyBtb2R1bGUuZXhwb3J0cy5BcmNoV2lraVNvcnRDb250YWN0cyBleHRlbmRzIFBsdWdpblxuICAgICMgVGhpcyBwbHVnaW4gd2FzIG9yaWdpbmFsbHkgYmFzZWQgb24gbGlzdD1hbGx1c2VycywgYnV0IGJlY2F1c2Ugb2YgYnVnXG4gICAgIyAgIzIwOCBpdCBjYW4ndCByZWx5IG9uIHRoYXQgYW55bW9yZSwgc28gaXQgd2FzIHJld3JpdHRlbiB3aXRoXG4gICAgIyAgNjBiYjJhYzJhMmRjZDBiMTViN2FhYzgwNzI1YzgzMTUxMTczZWViM1xuICAgICMgU2VlIGFsc28gaHR0cHM6Ly9iYnMuYXJjaGxpbnV4Lm9yZy92aWV3dG9waWMucGhwP2lkPTE5MjM4OSBhbmRcbiAgICAjICBodHRwczovL2xpc3RzLndpa2ltZWRpYS5vcmcvcGlwZXJtYWlsL21lZGlhd2lraS1sLzIwMTUtSmFudWFyeS8wNDM4NTAuaHRtbFxuXG4gICAgc3RhcnRNYXJrID0gXCJTVEFSVCBBVVRPIExJU1QgLSBETyBOT1QgUkVNT1ZFIE9SIE1PRElGWSBUSElTIE1BUkstLT5cIlxuICAgIGVuZE1hcmsgPSBcIjwhLS1FTkQgQVVUTyBMSVNUIC0gRE8gTk9UIFJFTU9WRSBPUiBNT0RJRlkgVEhJUyBNQVJLXCJcbiAgICAjIERvbid0IGRvIFwiKD86IFxcXFw8IS0tIGFzc29jaWF0ZWQgYm90OiAoLis/KSAtLT4pPy4qJFwiXG4gICAgcmVnRXhwID0gbmV3IFJlZ0V4cChcIl5cXFxcKi4qP1xcXFxbXFxcXFtVc2VyOiguKz8pXFxcXHwuKz9cIiArXG4gICAgICAgICAgICAgICAgICAgIFwiKD86IFxcXFw8IS0tIGFzc29jaWF0ZWQgYm90OiAoLis/KSAtLT4uKik/JFwiLCBcIlwiKVxuXG4gICAgQGNvbmZfZGVmYXVsdDpcbiAgICAgICAgZW5hYmxlZDogZmFsc2VcbiAgICAgICAgc3BlY2lhbF9tZW51OiBbXCJTb3J0IHN0YWZmIGNvbnRhY3RzXCJdXG4gICAgICAgIGVkaXRfc3VtbWFyeTogXCJhdXRvbWF0aWNhbGx5IHNvcnQgbGlzdCBhY2NvcmRpbmcgdG8gcmVjZW50IGFjdGl2aXR5XCJcbiAgICAgICAgcGFnZXM6IFt7XG4gICAgICAgICAgICB0aXRsZTogXCJBcmNoV2lraTpBZG1pbmlzdHJhdG9yc1wiXG4gICAgICAgICAgICByZWNlbnRfZGF5czogMzBcbiAgICAgICAgICAgIGluYWN0aXZlX2xpbWl0OiAzMFxuICAgICAgICAgICAgaW5hY3RpdmVfbWVzc2FnZTogXCJUaGUgZm9sbG93aW5nIEFkbWluaXN0cmF0b3JzIGFyZSBjdXJyZW50bHlcbiAgICAgICAgICAgICAgICBpbmFjdGl2ZSAobGVzcyB0aGFuIDMwIGVkaXRzIGluIHRoZSBsYXN0IDMwIGRheXMpOlwiXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRpdGxlOiBcIkFyY2hXaWtpOk1haW50YWluZXJzXCJcbiAgICAgICAgICAgIHJlY2VudF9kYXlzOiAzMFxuICAgICAgICAgICAgaW5hY3RpdmVfbGltaXQ6IDEwXG4gICAgICAgICAgICBpbmFjdGl2ZV9tZXNzYWdlOiBcIlRoZSBmb2xsb3dpbmcgTWFpbnRhaW5lcnMgYXJlIGN1cnJlbnRseVxuICAgICAgICAgICAgICAgIGluYWN0aXZlIChsZXNzIHRoYW4gMTAgZWRpdHMgaW4gdGhlIGxhc3QgMzAgZGF5cyk6XCJcbiAgICAgICAgfV1cblxuICAgIG1haW5fc3BlY2lhbDogKGNhbGxOZXh0KSAtPlxuICAgICAgICBAaXRlcmF0ZVBhZ2VzKC0xLCBjYWxsTmV4dClcblxuICAgIGl0ZXJhdGVQYWdlczogKHBhZ2VpZCwgY2FsbE5leHQpIC0+XG4gICAgICAgIHBhZ2VpZCsrXG4gICAgICAgIHBjb25mID0gQGNvbmYucGFnZXNbcGFnZWlkXVxuICAgICAgICBpZiBwY29uZlxuICAgICAgICAgICAgcGFnZSA9IHBjb25mLnRpdGxlXG4gICAgICAgICAgICByZWNlbnREYXlzID0gcGNvbmYucmVjZW50X2RheXNcbiAgICAgICAgICAgIGluYWN0aXZlTGltaXQgPSBwY29uZi5pbmFjdGl2ZV9saW1pdFxuICAgICAgICAgICAgaW5hY3RpdmVJbnRybyA9IHBjb25mLmluYWN0aXZlX21lc3NhZ2VcbiAgICAgICAgICAgIHN1bW1hcnkgPSBAY29uZi5lZGl0X3N1bW1hcnlcblxuICAgICAgICAgICAgQFdNLkxvZy5sb2dJbmZvKFwiU29ydGluZyBcIiArIEBXTS5Mb2cubGlua1RvV2lraVBhZ2UocGFnZSwgcGFnZSkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgLi4uXCIpXG5cbiAgICAgICAgICAgIEBXTS5NVy5jYWxsUXVlcnlFZGl0KHBhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEBwYXJzZUxpc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtyZWNlbnREYXlzLCBpbmFjdGl2ZUxpbWl0LCBpbmFjdGl2ZUludHJvLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VtbWFyeSwgY2FsbE5leHQsIHBhZ2VpZF0pXG4gICAgICAgIGVsc2UgaWYgY2FsbE5leHRcbiAgICAgICAgICAgIGNhbGxOZXh0KClcblxuICAgIHBhcnNlTGlzdDogKHRpdGxlLCBzb3VyY2UsIHRpbWVzdGFtcCwgZWRpdHRva2VuLCBhcmdzKSA9PlxuICAgICAgICByZWNlbnREYXlzID0gYXJnc1swXVxuICAgICAgICBpbmFjdGl2ZUxpbWl0ID0gYXJnc1sxXVxuICAgICAgICBpbmFjdGl2ZUludHJvID0gYXJnc1syXVxuICAgICAgICBzdW1tYXJ5ID0gYXJnc1szXVxuICAgICAgICBjYWxsTmV4dCA9IGFyZ3NbNF1cbiAgICAgICAgcGFnZWlkID0gYXJnc1s1XVxuXG4gICAgICAgIHN0YXJ0TGlzdCA9IHNvdXJjZS5pbmRleE9mKHN0YXJ0TWFyaylcbiAgICAgICAgZW5kTGlzdCA9IHNvdXJjZS5pbmRleE9mKGVuZE1hcmspXG5cbiAgICAgICAgaWYgc3RhcnRMaXN0ID4gLTEgYW5kIGVuZExpc3QgPiAtMVxuICAgICAgICAgICAgc3RhcnRMaXN0ICs9IHN0YXJ0TWFyay5sZW5ndGhcbiAgICAgICAgICAgIGRhdGUgPSBuZXcgRGF0ZSgpXG4gICAgICAgICAgICB1Y3N0YXJ0ID0gTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMClcbiAgICAgICAgICAgIHVjZW5kID0gdWNzdGFydCAtIDg2NDAwICogcmVjZW50RGF5c1xuICAgICAgICAgICAgdXNlcnMgPVxuICAgICAgICAgICAgICAgIGFjdGl2ZTogW11cbiAgICAgICAgICAgICAgICBpbmFjdGl2ZTogW11cblxuICAgICAgICAgICAgdXNlcnNBcnJheSA9IHNvdXJjZS5zdWJzdHJpbmcoc3RhcnRMaXN0LCBlbmRMaXN0KS5zcGxpdChcIlxcblwiKVxuICAgICAgICAgICAgQGl0ZXJhdGVVc2Vycyh1c2Vyc0FycmF5LCAtMSwgdWNzdGFydCwgdWNlbmQsIHVzZXJzLCB0aXRsZSwgc291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0TGlzdCwgZW5kTGlzdCwgdGltZXN0YW1wLCBlZGl0dG9rZW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5hY3RpdmVMaW1pdCwgaW5hY3RpdmVJbnRybywgc3VtbWFyeSwgY2FsbE5leHQsIHBhZ2VpZClcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgQFdNLkxvZy5sb2dFcnJvcihcIkNhbm5vdCBmaW5kIHRoZSBuZWVkZWQgbWFya3NcIilcblxuICAgIGl0ZXJhdGVVc2VyczogKHVzZXJzQXJyYXksIGluZGV4LCB1Y3N0YXJ0LCB1Y2VuZCwgdXNlcnMsXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlLCBzb3VyY2UsIHN0YXJ0TGlzdCwgZW5kTGlzdCwgdGltZXN0YW1wLCBlZGl0dG9rZW4sXG4gICAgICAgICAgICAgICAgICAgIGluYWN0aXZlTGltaXQsIGluYWN0aXZlSW50cm8sIHN1bW1hcnksIGNhbGxOZXh0LCBwYWdlaWQpID0+XG4gICAgICAgIGluZGV4KytcblxuICAgICAgICBpZiBpbmRleCA8IHVzZXJzQXJyYXkubGVuZ3RoXG4gICAgICAgICAgICB1c2VyU3RyaW5nID0gdXNlcnNBcnJheVtpbmRleF1cbiAgICAgICAgICAgIG1hdGNoID0gcmVnRXhwLmV4ZWModXNlclN0cmluZylcblxuICAgICAgICAgICAgaWYgbWF0Y2hcbiAgICAgICAgICAgICAgICB1Y3VzZXIgPSBtYXRjaFsxXS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG1hdGNoWzFdLnN1YnN0cigxKVxuXG4gICAgICAgICAgICAgICAgaWYgbWF0Y2hbMl1cbiAgICAgICAgICAgICAgICAgICAgdWN1c2VyICs9IFwifFwiICsgbWF0Y2hbMl0uY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hbMl0uc3Vic3RyKDEpXG5cbiAgICAgICAgICAgICAgICBAV00uTG9nLmxvZ0luZm8oXCJRdWVyeWluZyBcIiArIHVjdXNlciArIFwiIC4uLlwiKVxuXG4gICAgICAgICAgICAgICAgQFdNLk1XLmdldFVzZXJDb250cmlicyh1Y3VzZXIsIHVjc3RhcnQsIHVjZW5kLFxuICAgICAgICAgICAgICAgICAgICBAc3RvcmVVc2VyQ29udHJpYnMsXG4gICAgICAgICAgICAgICAgICAgIFt1c2Vyc0FycmF5LCBpbmRleCwgdWNzdGFydCwgdWNlbmQsIHVzZXJzLCB0aXRsZSwgc291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgc3RhcnRMaXN0LCBlbmRMaXN0LCB0aW1lc3RhbXAsIGVkaXR0b2tlbiwgaW5hY3RpdmVMaW1pdCxcbiAgICAgICAgICAgICAgICAgICAgIGluYWN0aXZlSW50cm8sIHN1bW1hcnksIGNhbGxOZXh0LCBwYWdlaWRdKVxuXG4gICAgICAgICAgICBlbHNlIGlmIHVzZXJTdHJpbmcgIT0gXCJcIiBhbmRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJTdHJpbmcuaW5kZXhPZihpbmFjdGl2ZUludHJvKSAhPSAwXG4gICAgICAgICAgICAgICAgQFdNLkxvZy5sb2dFcnJvcihcIkFuIGVudHJ5IGluIHRoZSBsaXN0IG1heSBub3QgYmUgY29ycmVjdGx5IFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImZvcm1hdHRlZFwiKVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIEBpdGVyYXRlVXNlcnModXNlcnNBcnJheSwgaW5kZXgsIHVjc3RhcnQsIHVjZW5kLCB1c2VycywgdGl0bGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlLCBzdGFydExpc3QsIGVuZExpc3QsIHRpbWVzdGFtcCwgZWRpdHRva2VuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluYWN0aXZlTGltaXQsIGluYWN0aXZlSW50cm8sIHN1bW1hcnksIGNhbGxOZXh0LCBwYWdlaWQpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIEB1cGRhdGVMaXN0KHVzZXJzLCB0aXRsZSwgc291cmNlLCBzdGFydExpc3QsIGVuZExpc3QsIHRpbWVzdGFtcCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWRpdHRva2VuLCBpbmFjdGl2ZUludHJvLCBzdW1tYXJ5LCBjYWxsTmV4dCwgcGFnZWlkKVxuXG4gICAgc3RvcmVVc2VyQ29udHJpYnM6IChyZXN1bHRzLCBhcmdzKSA9PlxuICAgICAgICB1c2Vyc0FycmF5ID0gYXJnc1swXVxuICAgICAgICBpbmRleCA9IGFyZ3NbMV1cbiAgICAgICAgdWNzdGFydCA9IGFyZ3NbMl1cbiAgICAgICAgdWNlbmQgPSBhcmdzWzNdXG4gICAgICAgIHVzZXJzID0gYXJnc1s0XVxuICAgICAgICB0aXRsZSA9IGFyZ3NbNV1cbiAgICAgICAgc291cmNlID0gYXJnc1s2XVxuICAgICAgICBzdGFydExpc3QgPSBhcmdzWzddXG4gICAgICAgIGVuZExpc3QgPSBhcmdzWzhdXG4gICAgICAgIHRpbWVzdGFtcCA9IGFyZ3NbOV1cbiAgICAgICAgZWRpdHRva2VuID0gYXJnc1sxMF1cbiAgICAgICAgaW5hY3RpdmVMaW1pdCA9IGFyZ3NbMTFdXG4gICAgICAgIGluYWN0aXZlSW50cm8gPSBhcmdzWzEyXVxuICAgICAgICBzdW1tYXJ5ID0gYXJnc1sxM11cbiAgICAgICAgY2FsbE5leHQgPSBhcmdzWzE0XVxuICAgICAgICBwYWdlaWQgPSBhcmdzWzE1XVxuXG4gICAgICAgIGVkaXRzID0gcmVzdWx0cy5sZW5ndGhcblxuICAgICAgICBpZiBlZGl0cyA8IGluYWN0aXZlTGltaXRcbiAgICAgICAgICAgIHVzZXJzLmluYWN0aXZlLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ0ZXh0XCI6IHVzZXJzQXJyYXlbaW5kZXhdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImVkaXRzXCI6IGVkaXRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHVzZXJzLmFjdGl2ZS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwidGV4dFwiOiB1c2Vyc0FycmF5W2luZGV4XVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJlZGl0c1wiOiBlZGl0c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcblxuICAgICAgICBAaXRlcmF0ZVVzZXJzKHVzZXJzQXJyYXksIGluZGV4LCB1Y3N0YXJ0LCB1Y2VuZCwgdXNlcnMsIHRpdGxlLCBzb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRMaXN0LCBlbmRMaXN0LCB0aW1lc3RhbXAsIGVkaXR0b2tlbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmFjdGl2ZUxpbWl0LCBpbmFjdGl2ZUludHJvLCBzdW1tYXJ5LCBjYWxsTmV4dCwgcGFnZWlkKVxuXG4gICAgdXBkYXRlTGlzdDogKHVzZXJzLCB0aXRsZSwgc291cmNlLCBzdGFydExpc3QsIGVuZExpc3QsXG4gICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcCwgZWRpdHRva2VuLCBpbmFjdGl2ZUludHJvLCBzdW1tYXJ5LCBjYWxsTmV4dCwgcGFnZWlkKSA9PlxuICAgICAgICBzb3J0ZXIgPSAoYSwgYikgLT5cbiAgICAgICAgICAgICMgVXNlcnMgbXVzdCBiZSBzb3J0ZWQgaW4gZGVzY2VuZGluZyBvcmRlclxuICAgICAgICAgICAgaWYgYS5lZGl0cyA8IGIuZWRpdHNcbiAgICAgICAgICAgICAgICByZXR1cm4gMVxuICAgICAgICAgICAgZWxzZSBpZiBhLmVkaXRzID4gYi5lZGl0c1xuICAgICAgICAgICAgICAgIHJldHVybiAtMVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJldHVybiAwXG5cbiAgICAgICAgdXNlcnMuYWN0aXZlLnNvcnQoc29ydGVyKVxuICAgICAgICB1c2Vycy5pbmFjdGl2ZS5zb3J0KHNvcnRlcilcblxuICAgICAgICBuZXdMaXN0ID0gXCJcXG5cIlxuXG4gICAgICAgIGZvciB1c2VyIGluIHVzZXJzLmFjdGl2ZVxuICAgICAgICAgICAgbmV3TGlzdCArPSB1c2VyLnRleHQgKyBcIlxcblwiXG5cbiAgICAgICAgaWYgdXNlcnMuaW5hY3RpdmUubGVuZ3RoID4gMFxuICAgICAgICAgICAgbmV3TGlzdCArPSBcIlxcblwiICsgaW5hY3RpdmVJbnRybyArIFwiXFxuXFxuXCJcblxuICAgICAgICAgICAgZm9yIHVzZXIgaW4gdXNlcnMuaW5hY3RpdmVcbiAgICAgICAgICAgICAgICBuZXdMaXN0ICs9IHVzZXIudGV4dCArIFwiXFxuXCJcblxuICAgICAgICBuZXdUZXh0ID0gc291cmNlLnN1YnN0cmluZygwLCBzdGFydExpc3QpICsgbmV3TGlzdCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlLnN1YnN0cmluZyhlbmRMaXN0KVxuXG4gICAgICAgIGlmIG5ld1RleHQgIT0gc291cmNlXG4gICAgICAgICAgICBAV00uTVcuY2FsbEFQSVBvc3Qoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcImVkaXRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm90OiBcIjFcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWlub3I6IFwiMVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogdGl0bGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1bW1hcnk6IHN1bW1hcnlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IG5ld1RleHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIxYXNldGltZXN0YW1wOiB0aW1lc3RhbXBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuOiBlZGl0dG9rZW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEB3cml0ZVBhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW3RpdGxlLCBjYWxsTmV4dCwgcGFnZWlkXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBudWxsKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICBAV00uTG9nLmxvZ0luZm8oQFdNLkxvZy5saW5rVG9XaWtpUGFnZSh0aXRsZSwgdGl0bGUpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgd2FzIGFscmVhZHkgdXAgdG8gZGF0ZVwiKVxuICAgICAgICAgICAgQGl0ZXJhdGVQYWdlcyhwYWdlaWQsIGNhbGxOZXh0KVxuXG4gICAgd3JpdGVQYWdlOiAocmVzLCBhcmdzKSA9PlxuICAgICAgICB0aXRsZSA9IGFyZ3NbMF1cbiAgICAgICAgY2FsbE5leHQgPSBhcmdzWzFdXG4gICAgICAgIHBhZ2VpZCA9IGFyZ3NbMl1cblxuICAgICAgICBpZiByZXMuZWRpdCBhbmQgcmVzLmVkaXQucmVzdWx0ID09ICdTdWNjZXNzJ1xuICAgICAgICAgICAgQFdNLkxvZy5sb2dJbmZvKEBXTS5Mb2cubGlua1RvV2lraVBhZ2UodGl0bGUsIHRpdGxlKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgd2FzIGNvcnJlY3RseSB1cGRhdGVkXCIpXG4gICAgICAgICAgICBAaXRlcmF0ZVBhZ2VzKHBhZ2VpZCwgY2FsbE5leHQpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIEBXTS5Mb2cubG9nRXJyb3IocmVzWydlcnJvciddWydpbmZvJ10gK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIiAoXCIgKyByZXNbJ2Vycm9yJ11bJ2NvZGUnXSArIFwiKVwiKVxuIiwiIyBXaWtpIE1vbmtleSAtIE1lZGlhV2lraSBib3QgYW5kIGVkaXRvci1hc3Npc3RhbnQgdXNlciBzY3JpcHRcbiMgQ29weXJpZ2h0IChDKSAyMDExIERhcmlvIEdpb3Zhbm5ldHRpIDxkZXZAZGFyaW9naW92YW5uZXR0aS5uZXQ+XG4jXG4jIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFdpa2kgTW9ua2V5LlxuI1xuIyBXaWtpIE1vbmtleSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4jIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4jIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4jIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4jXG4jIFdpa2kgTW9ua2V5IGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4jIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4jIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiMgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbiNcbiMgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiMgYWxvbmcgd2l0aCBXaWtpIE1vbmtleS4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cblxue1BsdWdpbn0gPSByZXF1aXJlKCcuL19QbHVnaW4nKVxuXG5cbmNsYXNzIG1vZHVsZS5leHBvcnRzLkFyY2hXaWtpV2FudGVkQ2F0ZWdvcmllcyBleHRlbmRzIFBsdWdpblxuICAgIEBjb25mX2RlZmF1bHQ6XG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlXG4gICAgICAgIGJvdF9sYWJlbDogXCJDcmVhdGUgd2FudGVkIGNhdGVnb3JpZXNcIlxuXG4gICAgbWFpbl9ib3Q6ICh0aXRsZSwgY2FsbEJvdCwgY2hhaW5BcmdzKSAtPlxuICAgICAgICB0aXRsZSA9IHRpdGxlLnJlcGxhY2UoXCIgKHBhZ2UgZG9lcyBub3QgZXhpc3QpXCIsIFwiXCIpXG5cbiAgICAgICAgQFdNLk1XLmNhbGxRdWVyeSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcDogXCJpbmZvXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50b2tlbjogXCJlZGl0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGVzOiB0aXRsZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIEBtYWluQXV0b1dyaXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgW3RpdGxlLCBjYWxsQm90XSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bGwpXG5cbiAgICBtYWluQXV0b1dyaXRlOiAocGFnZSwgYXJncykgLT5cbiAgICAgICAgdGl0bGUgPSBhcmdzWzBdXG4gICAgICAgIGNhbGxCb3QgPSBhcmdzWzFdXG5cbiAgICAgICAgZWRpdHRva2VuID0gcGFnZS5lZGl0dG9rZW5cblxuICAgICAgICBsYW5ndWFnZSA9IEBXTS5BcmNoV2lraS5kZXRlY3RMYW5ndWFnZSh0aXRsZSlbMV1cblxuICAgICAgICBpZiBsYW5ndWFnZSAhPSBAV00uQXJjaFdpa2kuZ2V0TG9jYWxMYW5ndWFnZSgpXG4gICAgICAgICAgICB0ZXh0ID0gXCJbW0NhdGVnb3J5OlwiICsgbGFuZ3VhZ2UgKyBcIl1dXCJcbiAgICAgICAgICAgIHN1bW1hcnkgPSBcIndhbnRlZCBjYXRlZ29yeVwiXG5cbiAgICAgICAgICAgIEBXTS5NVy5jYWxsQVBJUG9zdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXCJlZGl0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvdDogXCIxXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiB0aXRsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VtbWFyeTogc3VtbWFyeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogdGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlb25seTogXCIxXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuOiBlZGl0dG9rZW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEBtYWluQXV0b0VuZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsQm90LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bGwpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGNhbGxCb3QoMCwgbnVsbClcblxuICAgIG1haW5BdXRvRW5kOiAocmVzLCBjYWxsQm90KSAtPlxuICAgICAgICBpZiByZXMuZWRpdCBhbmQgcmVzLmVkaXQucmVzdWx0ID09ICdTdWNjZXNzJ1xuICAgICAgICAgICAgY2FsbEJvdCgxLCBudWxsKVxuICAgICAgICBlbHNlIGlmIHJlcy5lcnJvclxuICAgICAgICAgICAgQFdNLkxvZy5sb2dFcnJvcihyZXMuZXJyb3IuaW5mbyArIFwiIChcIiArIHJlcy5lcnJvci5jb2RlICsgXCIpXCIpXG4gICAgICAgICAgICBjYWxsQm90KHJlcy5lcnJvci5jb2RlLCBudWxsKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICBjYWxsQm90KGZhbHNlLCBudWxsKVxuIiwiIyBXaWtpIE1vbmtleSAtIE1lZGlhV2lraSBib3QgYW5kIGVkaXRvci1hc3Npc3RhbnQgdXNlciBzY3JpcHRcbiMgQ29weXJpZ2h0IChDKSAyMDExIERhcmlvIEdpb3Zhbm5ldHRpIDxkZXZAZGFyaW9naW92YW5uZXR0aS5uZXQ+XG4jXG4jIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFdpa2kgTW9ua2V5LlxuI1xuIyBXaWtpIE1vbmtleSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4jIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4jIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4jIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4jXG4jIFdpa2kgTW9ua2V5IGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4jIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4jIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiMgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbiNcbiMgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiMgYWxvbmcgd2l0aCBXaWtpIE1vbmtleS4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cblxue1BsdWdpbn0gPSByZXF1aXJlKCcuL19QbHVnaW4nKVxuXG5cbmNsYXNzIG1vZHVsZS5leHBvcnRzLkRlbGV0ZVBhZ2VzIGV4dGVuZHMgUGx1Z2luXG4gICAgQGNvbmZfZGVmYXVsdDpcbiAgICAgICAgZW5hYmxlZDogZmFsc2VcbiAgICAgICAgYm90X2xhYmVsOiBcIkRlbGV0ZSBwYWdlc1wiXG4gICAgICAgIGVkaXRfc3VtbWFyeTogXCJkZWxldGUgcGFnZVwiXG5cbiAgICBtYWluX2JvdDogKHRpdGxlLCBjYWxsQm90LCBjaGFpbkFyZ3MpIC0+XG4gICAgICAgIHN1bW1hcnkgPSBAY29uZi5lZGl0X3N1bW1hcnlcblxuICAgICAgICBAV00uTVcuY2FsbFF1ZXJ5KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wOiAnaW5mbydcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRva2VuOiAnZGVsZXRlJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlczogdGl0bGVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBAbWFpbkF1dG9Xcml0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFt0aXRsZSwgc3VtbWFyeSwgY2FsbEJvdF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBudWxsKVxuXG4gICAgbWFpbkF1dG9Xcml0ZTogKHBhZ2UsIGFyZ3MpIC0+XG4gICAgICAgIHRpdGxlID0gYXJnc1swXVxuICAgICAgICBzdW1tYXJ5ID0gYXJnc1sxXVxuICAgICAgICBjYWxsQm90ID0gYXJnc1syXVxuXG4gICAgICAgIGRlbGV0ZXRva2VuID0gcGFnZS5kZWxldGV0b2tlblxuXG4gICAgICAgIEBXTS5NVy5jYWxsQVBJUG9zdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiAnZGVsZXRlJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvdDogJzEnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IHRpdGxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW46IGRlbGV0ZXRva2VuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhc29uOiBzdW1tYXJ5XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgQG1haW5BdXRvRW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgW3RpdGxlLCBjYWxsQm90XSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bGwpXG5cbiAgICBtYWluQXV0b0VuZDogKHJlcywgYXJncykgLT5cbiAgICAgICAgdGl0bGUgPSBhcmdzWzBdXG4gICAgICAgIGNhbGxCb3QgPSBhcmdzWzFdXG5cbiAgICAgICAgaWYgbm90IHJlcy5kZWxldGVcbiAgICAgICAgICAgIGlmIHJlcy5lcnJvclxuICAgICAgICAgICAgICAgIEBXTS5Mb2cubG9nRXJyb3IoXCIje0BXTS5Mb2cubGlua1RvV2lraVBhZ2UodGl0bGUsIHRpdGxlKX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzIG5vdCBiZWVuIGRlbGV0ZWQhXFxuI3tyZXMuZXJyb3IuaW5mb31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCN7cmVzLmVycm9yLmNvZGV9KVwiKVxuICAgICAgICAgICAgICAgIGNhbGxCb3QocmVzLmVycm9yLmNvZGUsIG51bGwpXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgY2FsbEJvdChmYWxzZSwgbnVsbClcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgY2FsbEJvdCgxLCBudWxsKVxuIiwiIyBXaWtpIE1vbmtleSAtIE1lZGlhV2lraSBib3QgYW5kIGVkaXRvci1hc3Npc3RhbnQgdXNlciBzY3JpcHRcbiMgQ29weXJpZ2h0IChDKSAyMDExIERhcmlvIEdpb3Zhbm5ldHRpIDxkZXZAZGFyaW9naW92YW5uZXR0aS5uZXQ+XG4jXG4jIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFdpa2kgTW9ua2V5LlxuI1xuIyBXaWtpIE1vbmtleSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4jIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4jIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4jIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4jXG4jIFdpa2kgTW9ua2V5IGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4jIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4jIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiMgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbiNcbiMgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiMgYWxvbmcgd2l0aCBXaWtpIE1vbmtleS4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cblxue1BsdWdpbn0gPSByZXF1aXJlKCcuL19QbHVnaW4nKVxuXG5cbmNsYXNzIG1vZHVsZS5leHBvcnRzLkV4cGFuZENvbnRyYWN0aW9ucyBleHRlbmRzIFBsdWdpblxuICAgIEBjb25mX2RlZmF1bHQ6XG4gICAgICAgIGVuYWJsZWQ6IHRydWVcbiAgICAgICAgZWRpdG9yX21lbnU6IFtcIlRleHQgcGx1Z2luc1wiLCBcIkV4cGFuZCBjb250cmFjdGlvbnNcIl1cblxuICAgIHJlcGxhY2U6IChzb3VyY2UsIHJlZ0V4cCwgbmV3U3RyaW5nLCBjaGVja1N0cmluZywgY2hlY2tTdHJpbmdzKSAtPlxuICAgICAgICBuZXd0ZXh0ID0gc291cmNlLnJlcGxhY2UocmVnRXhwLCBuZXdTdHJpbmcpXG4gICAgICAgIGlmIGNoZWNrU3RyaW5ncy5sZW5ndGggPiAxIGFuZCBuZXd0ZXh0ICE9IHNvdXJjZVxuICAgICAgICAgICAgQFdNLkxvZy5sb2dXYXJuaW5nKFwiUmVwbGFjZWQgc29tZSBcXFwiI3tjaGVja1N0cmluZ31cXFwiIHdpdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXFwiI3tjaGVja1N0cmluZ3NbMF19XFxcIjogY2hlY2sgdGhhdCBpdCBkaWRuJ3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZWFuIFxcXCIje2NoZWNrU3RyaW5ncy5zbGljZSgxKS5qb2luKCdcXFwiIG9yIFxcXCInKX1cXFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGVhZFwiKVxuICAgICAgICByZXR1cm4gbmV3dGV4dFxuXG4gICAgbWFpbl9lZGl0b3I6IChjYWxsTmV4dCkgLT5cbiAgICAgICAgc291cmNlID0gQFdNLkVkaXRvci5yZWFkU291cmNlKClcbiAgICAgICAgbmV3dGV4dCA9IHNvdXJjZVxuXG4gICAgICAgICMgSWdub3JpbmcgXCJJXCIgc2luY2Ugd3JpdGluZyBpbiAxc3QgcGVyc29uIGlzbid0IGZvcm1hbCBhbnl3YXlcbiAgICAgICAgIyBOb3RlIHRoYXQgSmF2YVNjcmlwdCBkb2Vzbid0IHN1cHBvcnQgbG9vayBiZWhpbmQgOihcbiAgICAgICAgIyBQYXkgYXR0ZW50aW9uIHRvIHByZXNlcnZlIHRoZSBvcmlnaW5hbCBjYXBpdGFsaXphdGlvblxuXG4gICAgICAgIG5ld3RleHQgPSBAcmVwbGFjZShuZXd0ZXh0LCAvKFthLXpdKSdyZS9pZywgJyQxIGFyZScsIFwiJ3JlXCIsIFtcImFyZVwiXSlcbiAgICAgICAgbmV3dGV4dCA9IEByZXBsYWNlKG5ld3RleHQsIC8oW2Etel0pJ3ZlL2lnLCAnJDEgaGF2ZScsIFwiJ3ZlXCIsIFtcImhhdmVcIl0pXG4gICAgICAgIG5ld3RleHQgPSBAcmVwbGFjZShuZXd0ZXh0LCAvKFthLXpdKSdsbC9pZywgJyQxIHdpbGwnLCBcIidsbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wid2lsbFwiLCBcInNoYWxsXCJdKVxuICAgICAgICBuZXd0ZXh0ID0gQHJlcGxhY2UobmV3dGV4dCwgLyhbYS16XSknZC9pZywgJyQxIHdvdWxkJywgXCInZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wid291bGRcIiwgXCJoYWRcIl0pXG4gICAgICAgIG5ld3RleHQgPSBAcmVwbGFjZShuZXd0ZXh0LCAvKGMpYW4ndC9pZywgJyQxYW5ub3QnLCBcImNhbid0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wiY2Fubm90XCJdKVxuICAgICAgICBuZXd0ZXh0ID0gQHJlcGxhY2UobmV3dGV4dCwgLyh3KW9uJ3QvaWcsICckMWlsbCBub3QnLCBcIndvbid0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wid2lsbCBub3RcIl0pXG4gICAgICAgIG5ld3RleHQgPSBAcmVwbGFjZShuZXd0ZXh0LCAvKFthLXpdKW4ndC9pZywgJyQxIG5vdCcsIFwibid0XCIsIFtcIm5vdFwiXSlcbiAgICAgICAgbmV3dGV4dCA9IEByZXBsYWNlKG5ld3RleHQsIC8oaGVyZXx0aGVyZSkncy9pZywgJyQxIGlzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImhlcmUvdGhlcmUnc1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcImhlcmUvdGhlcmUgaXNcIiwgXCJoZXJlL3RoZXJlIGhhc1wiXSlcbiAgICAgICAgbmV3dGV4dCA9IEByZXBsYWNlKG5ld3RleHQsIC8oZylvbm5hL2lnLCAnJDFvaW5nIHRvJywgXCJnb25uYVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcImdvaW5nIHRvXCJdKVxuICAgICAgICAjIFJlcGxhY2luZyBoZSdzLCBzaGUncywgdGhhdCdzLCB3aGF0J3MsIHdoZXJlJ3MsIHdobydzIC4uLiBtYXkgYmUgdG9vXG4gICAgICAgICMgICBkYW5nZXJvdXNcbiAgICAgICAgbmV3dGV4dCA9IEByZXBsYWNlKG5ld3RleHQsIC8oW2Etel0pJ3MgKGJlZW4pL2lnLCAnJDEgaGFzICQyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIidzIGJlZW5cIiwgW1wiaGFzIGJlZW5cIl0pXG4gICAgICAgIG5ld3RleHQgPSBAcmVwbGFjZShuZXd0ZXh0LCAvKGxldCkncy9pZywgJyQxIHVzJywgXCJsZXQnc1wiLCBbXCJsZXQgdXNcIl0pXG4gICAgICAgIG5ld3RleHQgPSBAcmVwbGFjZShuZXd0ZXh0LCAvKGl0KScocyBvd24pL2lnLCAnJDEkMicsIFwiaXQncyBvd25cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJpdHMgb3duXCJdKVxuXG4gICAgICAgIHNzID0gbmV3dGV4dC5tYXRjaCgvW2Etel0ncy9naSlcbiAgICAgICAgaWYgc3NcbiAgICAgICAgICAgIEBXTS5Mb2cubG9nV2FybmluZyhcIkZvdW5kIFwiICsgc3MubGVuZ3RoICsgXCIgaW5zdGFuY2VzIG9mIFxcXCInc1xcXCI6IFwiICtcbiAgICAgICAgICAgICAgICAgICAgXCJjaGVjayBpZiB0aGV5IGNhbiBiZSByZXBsYWNlZCB3aXRoIFxcXCJpc1xcXCIsIFxcXCJoYXNcXFwiLCAuLi5cIilcblxuICAgICAgICBpZiBuZXd0ZXh0ICE9IHNvdXJjZVxuICAgICAgICAgICAgQFdNLkVkaXRvci53cml0ZVNvdXJjZShuZXd0ZXh0KVxuICAgICAgICAgICAgQFdNLkxvZy5sb2dJbmZvKFwiRXhwYW5kZWQgY29udHJhY3Rpb25zXCIpXG5cbiAgICAgICAgaWYgY2FsbE5leHRcbiAgICAgICAgICAgIGNhbGxOZXh0KClcbiIsIiMgV2lraSBNb25rZXkgLSBNZWRpYVdpa2kgYm90IGFuZCBlZGl0b3ItYXNzaXN0YW50IHVzZXIgc2NyaXB0XG4jIENvcHlyaWdodCAoQykgMjAxMSBEYXJpbyBHaW92YW5uZXR0aSA8ZGV2QGRhcmlvZ2lvdmFubmV0dGkubmV0PlxuI1xuIyBUaGlzIGZpbGUgaXMgcGFydCBvZiBXaWtpIE1vbmtleS5cbiNcbiMgV2lraSBNb25rZXkgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuIyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuIyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuIyAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuI1xuIyBXaWtpIE1vbmtleSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuIyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuIyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4jIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4jXG4jIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4jIGFsb25nIHdpdGggV2lraSBNb25rZXkuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG5cbntQbHVnaW59ID0gcmVxdWlyZSgnLi9fUGx1Z2luJylcblxuQ1NTID0gcmVxdWlyZSgnQGt5bmlrb3MvbWlzYy9kaXN0L0NTUycpXG5cblxuY2xhc3MgbW9kdWxlLmV4cG9ydHMuRml4QmFja2xpbmtGcmFnbWVudHMgZXh0ZW5kcyBQbHVnaW5cbiAgICBAY29uZl9kZWZhdWx0OlxuICAgICAgICBlbmFibGVkOiB0cnVlXG4gICAgICAgIGJvdF9sYWJlbDogXCJGaXggbGlua3MgdG8gc3BlY2lmaWMgc2VjdGlvbnMgb2YgYSB0YXJnZXQgcGFnZVwiXG4gICAgICAgIGVkaXRfc3VtbWFyeTogXCJmaXggbGlua3MgdG8gc3BlY2lmaWMgc2VjdGlvbnNcIlxuXG4gICAgbWFrZUJvdFVJOiA9PlxuICAgICAgICBDU1MuYWRkU3R5bGVFbGVtZW50KFwiI1dpa2lNb25rZXktRml4QmFja2xpbmtGcmFnbWVudHMgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImlucHV0W3R5cGU9J3RleHQnXSB7bWFyZ2luLWxlZnQ6MC4zM2VtO31cIilcblxuICAgICAgICBkaXZNYWluID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICAgICAgZGl2TWFpbi5pZCA9IFwiV2lraU1vbmtleS1GaXhCYWNrbGlua0ZyYWdtZW50c1wiXG5cbiAgICAgICAgbGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJylcbiAgICAgICAgbGFiZWwuaW5uZXJIVE1MID0gJ1RhcmdldCBwYWdlOidcbiAgICAgICAgZGl2TWFpbi5hcHBlbmRDaGlsZChsYWJlbClcblxuICAgICAgICB0YXJnZXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpXG4gICAgICAgIHRhcmdldC5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAndGV4dCcpXG4gICAgICAgIHRhcmdldC5pZCA9IFwiV2lraU1vbmtleS1GaXhCYWNrbGlua0ZyYWdtZW50cy1UYXJnZXRcIlxuXG4gICAgICAgIGlmIEBXTS5XaGF0TGlua3NIZXJlLmlzV2hhdExpbmtzSGVyZVBhZ2UoKVxuICAgICAgICAgICAgdGFyZ2V0LnZhbHVlID0gQFdNLldoYXRMaW5rc0hlcmUuZ2V0VGl0bGUoKVxuXG4gICAgICAgIGRpdk1haW4uYXBwZW5kQ2hpbGQodGFyZ2V0KVxuXG4gICAgICAgIHJldHVybiBkaXZNYWluXG5cbiAgICByZWFkVGFyZ2V0ID0gLT5cbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiV2lraU1vbmtleS1GaXhCYWNrbGlua0ZyYWdtZW50cy1UYXJnZXRcIikudmFsdWVcblxuICAgIGZpeExpbmtzOiAoc291cmNlLCB0YXJnZXQsIHNlY3Rpb25zKSA9PlxuICAgICAgICAjIE5vdGUgdGhhdCBpdCdzIGltcG9zc2libGUgdG8gcmVjb2duaXplIGFueSBuYW1lc3BhY2VzIGluIHRoZSB0aXRsZVxuICAgICAgICAjICAgd2l0aG91dCBxdWVyeWluZyB0aGUgc2VydmVyXG4gICAgICAgICMgQWx0ZXJuYXRpdmVseSwgYSBsaXN0IG9mIHRoZSBrbm93biBuYW1lc3BhY2VzIGNvdWxkIGJlIG1haW50YWluZWRcbiAgICAgICAgIyAgIGZvciBlYWNoIHdpa2lcbiAgICAgICAgIyBSZWNvZ25pemluZyBuYW1lc3BhY2VzIHdvdWxkIGxldCByZWNvZ25pemUgbW9yZSBsaWJlcmFsIGxpbmtcbiAgICAgICAgIyAgIHN5bnRheGVzIChlLmcuIHNwYWNlcyBhcm91bmQgdGhlIGNvbG9uKVxuICAgICAgICBsaW5rcyA9IEBXTS5QYXJzZXIuZmluZEludGVybmFsTGlua3Moc291cmNlLCBudWxsLCB0YXJnZXQpXG5cbiAgICAgICAgbmV3VGV4dCA9IFwiXCJcbiAgICAgICAgcHJldklkID0gMFxuXG4gICAgICAgIGZvciBsaW5rIGluIGxpbmtzXG4gICAgICAgICAgICBuZXdUZXh0ICs9IHNvdXJjZS5zdWJzdHJpbmcocHJldklkLCBsaW5rLmluZGV4KVxuICAgICAgICAgICAgbmV3bGluayA9IGxpbmsucmF3TGlua1xuXG4gICAgICAgICAgICByYXdmcmFnbWVudCA9IGxpbmsuZnJhZ21lbnRcblxuICAgICAgICAgICAgaWYgcmF3ZnJhZ21lbnRcbiAgICAgICAgICAgICAgICBmaXhlZEZyYWdtZW50ID0gQGZpeEZyYWdtZW50KHJhd2ZyYWdtZW50LCBzZWN0aW9ucylcblxuICAgICAgICAgICAgICAgIGlmIGZpeGVkRnJhZ21lbnQgaXMgdHJ1ZVxuICAgICAgICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICAgICAgZWxzZSBpZiBmaXhlZEZyYWdtZW50XG4gICAgICAgICAgICAgICAgICAgIG9sZGxpbmsgPSBuZXdsaW5rXG4gICAgICAgICAgICAgICAgICAgIG5ld2xpbmsgPSBcIltbXCIgKyB0YXJnZXQgKyBcIiNcIiArIGZpeGVkRnJhZ21lbnQgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKGlmIGxpbmsuYW5jaG9yIHRoZW4gXCJ8XCIgKyBsaW5rLmFuY2hvciBlbHNlIFwiXCIpICsgXCJdXVwiXG4gICAgICAgICAgICAgICAgICAgIEBXTS5Mb2cubG9nSW5mbyhcIkZpeGVkIGJyb2tlbiBsaW5rIGZyYWdtZW50OiBcIiArIG9sZGxpbmsgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCIgLT4gXCIgKyBAV00uTG9nLmxpbmtUb1dpa2lQYWdlKGxpbmsubGluaywgbmV3bGluaykpXG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBAV00uTG9nLmxvZ1dhcm5pbmcoXCJDYW5ub3QgZml4IGJyb2tlbiBsaW5rIGZyYWdtZW50OiBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBAV00uTG9nLmxpbmtUb1dpa2lQYWdlKGxpbmsubGluaywgbmV3bGluaykpXG5cbiAgICAgICAgICAgIG5ld1RleHQgKz0gbmV3bGlua1xuICAgICAgICAgICAgcHJldklkID0gbGluay5pbmRleCArIGxpbmsubGVuZ3RoXG5cbiAgICAgICAgbmV3VGV4dCArPSBzb3VyY2Uuc3Vic3RyKHByZXZJZClcblxuICAgICAgICAjIFdpdGhvdXQgdGhpcyBjaGVjayB0aGlzIHBsdWdpbiB3b3VsZCBiZSBzcGVjaWZpYyB0byBBcmNoV2lraVxuICAgICAgICBpZiBsb2NhdGlvbi5ob3N0bmFtZSA9PSAnd2lraS5hcmNobGludXgub3JnJ1xuICAgICAgICAgICAgbmV3VGV4dCA9IEBmaXhBcmNoV2lraUxpbmtzKG5ld1RleHQsIHRhcmdldCwgc2VjdGlvbnMpXG5cbiAgICAgICAgcmV0dXJuIG5ld1RleHRcblxuICAgIGZpeEFyY2hXaWtpTGlua3M6IChzb3VyY2UsIHRhcmdldCwgc2VjdGlvbnMpID0+XG4gICAgICAgIGxpbmtzID0gQFdNLlBhcnNlci5maW5kVGVtcGxhdGVzKHNvdXJjZSwgJ1JlbGF0ZWQnKVxuXG4gICAgICAgIG5ld1RleHQxID0gXCJcIlxuICAgICAgICBwcmV2SWQgPSAwXG5cbiAgICAgICAgZm9yIGxpbmsgaW4gbGlua3NcbiAgICAgICAgICAgIG5ld1RleHQxICs9IHNvdXJjZS5zdWJzdHJpbmcocHJldklkLCBsaW5rLmluZGV4KVxuICAgICAgICAgICAgbmV3VGV4dDEgKz0gQGZpeEFyY2hXaWtpTGluayh0YXJnZXQsIHNlY3Rpb25zLCBsaW5rLCAxKVxuICAgICAgICAgICAgcHJldklkID0gbGluay5pbmRleCArIGxpbmsubGVuZ3RoXG5cbiAgICAgICAgbmV3VGV4dDEgKz0gc291cmNlLnN1YnN0cihwcmV2SWQpXG5cbiAgICAgICAgbGlua3MyID0gQFdNLlBhcnNlci5maW5kVGVtcGxhdGVzKG5ld1RleHQxLCAnUmVsYXRlZDInKVxuXG4gICAgICAgIG5ld1RleHQyID0gXCJcIlxuICAgICAgICBwcmV2SWQgPSAwXG5cbiAgICAgICAgZm9yIGxpbmsyIGluIGxpbmtzMlxuICAgICAgICAgICAgbmV3VGV4dDIgKz0gbmV3VGV4dDEuc3Vic3RyaW5nKHByZXZJZCwgbGluazIuaW5kZXgpXG4gICAgICAgICAgICBuZXdUZXh0MiArPSBAZml4QXJjaFdpa2lMaW5rKHRhcmdldCwgc2VjdGlvbnMsIGxpbmsyLCAyKVxuICAgICAgICAgICAgcHJldklkID0gbGluazIuaW5kZXggKyBsaW5rMi5sZW5ndGhcblxuICAgICAgICBuZXdUZXh0MiArPSBuZXdUZXh0MS5zdWJzdHIocHJldklkKVxuXG4gICAgICAgIHJldHVybiBuZXdUZXh0MlxuXG4gICAgZml4QXJjaFdpa2lMaW5rOiAodGFyZ2V0LCBzZWN0aW9ucywgdGVtcGxhdGUsIGV4cGVjdGVkQXJncykgPT5cbiAgICAgICAgYXJncyA9IHRlbXBsYXRlLmFyZ3VtZW50c1xuXG4gICAgICAgICMgRG9uJ3QgY3Jhc2ggaW4gY2FzZSBvZiBtYWxmb3JtZWQgdGVtcGxhdGVzXG4gICAgICAgIGlmIGFyZ3MubGVuZ3RoID09IGV4cGVjdGVkQXJnc1xuICAgICAgICAgICAgbGluayA9IGFyZ3NbMF0udmFsdWVcbiAgICAgICAgICAgIGZyYWdJZCA9IGxpbmsuaW5kZXhPZignIycpXG5cbiAgICAgICAgICAgIGlmIGZyYWdJZCA+IC0xXG4gICAgICAgICAgICAgICAgbHRpdGxlID0gbGluay5zdWJzdHJpbmcoMCwgZnJhZ0lkKVxuXG4gICAgICAgICAgICAgICAgIyBOb3RlIHRoYXQgaXQncyBpbXBvc3NpYmxlIHRvIHJlY29nbml6ZSBhbnkgbmFtZXNwYWNlcyBpbiB0aGVcbiAgICAgICAgICAgICAgICAjICAgdGl0bGUgd2l0aG91dCBxdWVyeWluZyB0aGUgc2VydmVyXG4gICAgICAgICAgICAgICAgIyBBbHRlcm5hdGl2ZWx5LCBhIGxpc3Qgb2YgdGhlIGtub3duIG5hbWVzcGFjZXMgY291bGQgYmVcbiAgICAgICAgICAgICAgICAjICAgbWFpbnRhaW5lZCBmb3IgZWFjaCB3aWtpXG4gICAgICAgICAgICAgICAgIyBSZWNvZ25pemluZyBuYW1lc3BhY2VzIHdvdWxkIGxldCByZWNvZ25pemUgbW9yZSBsaWJlcmFsIGxpbmtcbiAgICAgICAgICAgICAgICAjICAgc3ludGF4ZXMgKGUuZy4gc3BhY2VzIGFyb3VuZCB0aGUgY29sb24pXG4gICAgICAgICAgICAgICAgaWYgQFdNLlBhcnNlci5jb21wYXJlQXJ0aWNsZVRpdGxlcyhsdGl0bGUsIHRhcmdldClcbiAgICAgICAgICAgICAgICAgICAgcmF3ZnJhZ21lbnQgPSBsaW5rLnN1YnN0cihmcmFnSWQgKyAxKVxuICAgICAgICAgICAgICAgICAgICBmaXhlZEZyYWdtZW50ID0gQGZpeEZyYWdtZW50KHJhd2ZyYWdtZW50LCBzZWN0aW9ucylcblxuICAgICAgICAgICAgICAgICAgICBpZiBmaXhlZEZyYWdtZW50IGlzIHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiBmaXhlZEZyYWdtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICBhbmNob3IgPSBpZiBhcmdzWzFdIHRoZW4gKFwifFwiICsgYXJnc1sxXS52YWx1ZSkgZWxzZSBcIlwiXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdsaW5rID0gXCJ7e1wiICsgdGVtcGxhdGUudGl0bGUgKyBcInxcIiArIHRhcmdldCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIjXCIgKyBmaXhlZEZyYWdtZW50ICArIGFuY2hvciArIFwifX1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgQFdNLkxvZy5sb2dJbmZvKFwiRml4ZWQgYnJva2VuIGxpbmsgZnJhZ21lbnQ6IFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZS5yYXdUcmFuc2NsdXNpb24gKyBcIiAtPiBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQFdNLkxvZy5saW5rVG9XaWtpUGFnZShsaW5rLCBuZXdsaW5rKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXdsaW5rXG5cbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgQFdNLkxvZy5sb2dXYXJuaW5nKFwiQ2Fubm90IGZpeCBicm9rZW4gbGluayBmcmFnbWVudDogXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEBXTS5Mb2cubGlua1RvV2lraVBhZ2UobGluayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZS5yYXdUcmFuc2NsdXNpb24pKVxuXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIEBXTS5Mb2cubG9nV2FybmluZyhcIlRlbXBsYXRlOlwiICsgdGVtcGxhdGUudGl0bGUgKyBcIiBtdXN0IGhhdmUgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWRBcmdzICsgXCIgYW5kIG9ubHkgXCIgKyBleHBlY3RlZEFyZ3MgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKGlmIGV4cGVjdGVkQXJncyA+IDEgdGhlbiBcIiBhcmd1bWVudHM6IFwiIGVsc2UgXCIgYXJndW1lbnQ6IFwiKSArXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZS5yYXdUcmFuc2NsdXNpb24pXG5cbiAgICAgICAgcmV0dXJuIHRlbXBsYXRlLnJhd1RyYW5zY2x1c2lvblxuXG4gICAgZml4RnJhZ21lbnQ6IChyYXdmcmFnbWVudCwgc2VjdGlvbnMpID0+XG4gICAgICAgIGlmIHJhd2ZyYWdtZW50XG4gICAgICAgICAgICBmcmFnbWVudCA9IEBXTS5QYXJzZXIuc3F1YXNoQ29udGlndW91c1doaXRlc3BhY2UocmF3ZnJhZ21lbnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50cmltKClcblxuICAgICAgICAgICAgaWYgc2VjdGlvbnMuaW5kZXhPZihmcmFnbWVudCkgPCAwXG4gICAgICAgICAgICAgICAgZm9yIHNlY3Rpb24gaW4gc2VjdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgIyBUaGUgRml4RnJhZ21lbnRzIGFuZCBGaXhMaW5rRnJhZ21lbnRzIHBsdWdpbnMgYWxzbyB0cnlcbiAgICAgICAgICAgICAgICAgICAgIyB0byBmaXggZG90LWVuY29kZWQgZnJhZ21lbnRzIGhvd2V2ZXIgaXQncyB0b28gZGFuZ2Vyb3VzXG4gICAgICAgICAgICAgICAgICAgICMgdG8gZG8gaXQgd2l0aCB0aGlzIGJvdCBwbHVnaW4sIGhhdmUgdGhlIHVzZXIgZml4XG4gICAgICAgICAgICAgICAgICAgICMgZnJhZ21lbnRzIG1hbnVhbGx5XG4gICAgICAgICAgICAgICAgICAgIGlmIHNlY3Rpb24udG9Mb3dlckNhc2UoKSA9PSBmcmFnbWVudC50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VjdGlvblxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIHRydWVcblxuICAgIG1haW5fYm90OiAodGl0bGUsIGNhbGxCb3QsIGNoYWluQXJncykgLT5cbiAgICAgICAgc3VtbWFyeSA9IEBjb25mLmVkaXRfc3VtbWFyeVxuXG4gICAgICAgIHRhcmdldCA9IHJlYWRUYXJnZXQoKVxuICAgICAgICBAV00uTG9nLmxvZ0hpZGRlbihcIlRhcmdldCBwYWdlOiBcIiArIHRhcmdldClcblxuICAgICAgICBpZiB0YXJnZXRcbiAgICAgICAgICAgIGlmIGNoYWluQXJncyBpcyBudWxsXG4gICAgICAgICAgICAgICAgcGFyYW1zID1cbiAgICAgICAgICAgICAgICAgICAgJ2FjdGlvbic6ICdwYXJzZSdcbiAgICAgICAgICAgICAgICAgICAgJ3Byb3AnOiAnc2VjdGlvbnMnXG4gICAgICAgICAgICAgICAgICAgICdwYWdlJzogdGFyZ2V0XG4gICAgICAgICAgICAgICAgICAgICdyZWRpcmVjdHMnOiAxXG5cbiAgICAgICAgICAgICAgICBAV00uTG9nLmxvZ1dhcm5pbmcoXCJJZiBzb21lIGFydGljbGVzIGluIHRoZSBsaXN0IGFyZVxuICAgICAgICAgICAgICAgICAgICBsaW5raW5nIHRvIHRoZSB0YXJnZXQgYXJ0aWNsZVxuICAgICAgICAgICAgICAgICAgICB0aHJvdWdoIGEgcmVkaXJlY3QsIHlvdSBzaG91bGQgcHJvY2VzcyB0aGUgYmFja2xpbmtzXG4gICAgICAgICAgICAgICAgICAgIG9mIHRoYXQgcmVkaXJlY3QgcGFnZSBzZXBhcmF0ZWx5IHRocm91Z2ggaXRzXG4gICAgICAgICAgICAgICAgICAgIFNwZWNpYWw6V2hhdExpbmtzSGVyZSBwYWdlLCBhcyB0aGlzIHBsdWdpbiBjYW4gb25seVxuICAgICAgICAgICAgICAgICAgICBmaXggbGlua3MgdGhhdCBleGFjdGx5IG1hdGNoIHRoZSB0aXRsZSBvZiB0aGUgdGFyZ2V0XG4gICAgICAgICAgICAgICAgICAgIGFydGljbGUuXFxuSW4gb3JkZXIgdG8gc2F2ZSB0aW1lIHlvdSBhcmUgYWR2aXNlZCB0b1xuICAgICAgICAgICAgICAgICAgICBoaWRlIHRoZSByZWRpcmVjdHMgaW4gdGhlIHBhZ2UgbGlzdHMgdGhhdCBhbGxvdyB0byBkb1xuICAgICAgICAgICAgICAgICAgICBzby5cIilcblxuICAgICAgICAgICAgICAgIEBXTS5NVy5jYWxsQVBJR2V0KHBhcmFtcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICBAbWFpbkF1dG9GaW5kU2VjdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgW3RpdGxlLCB0YXJnZXQsIHN1bW1hcnksIGNhbGxCb3RdLFxuICAgICAgICAgICAgICAgICAgICAgICAgIG51bGwpXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgQG1haW5BdXRvUmVhZCh0YXJnZXQsIGNoYWluQXJncywgdGl0bGUsIHN1bW1hcnksIGNhbGxCb3QpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIEBXTS5Mb2cubG9nRXJyb3IoJ1RoZSB0YXJnZXQgcGFnZSBjYW5ub3QgYmUgZW1wdHknKVxuICAgICAgICAgICAgY2FsbEJvdChmYWxzZSwgbnVsbClcblxuICAgIG1haW5BdXRvRmluZFNlY3Rpb25zOiAocmVzLCBhcmdzKSA9PlxuICAgICAgICB0aXRsZSA9IGFyZ3NbMF1cbiAgICAgICAgdGFyZ2V0ID0gYXJnc1sxXVxuICAgICAgICBzdW1tYXJ5ID0gYXJnc1syXVxuICAgICAgICBjYWxsQm90ID0gYXJnc1szXVxuICAgICAgICBzZWN0aW9ucyA9IFtdXG5cbiAgICAgICAgaWYgcmVzLnBhcnNlXG4gICAgICAgICAgICBmb3Igc2VjdGlvbiBpbiByZXMucGFyc2Uuc2VjdGlvbnNcbiAgICAgICAgICAgICAgICBzZWN0aW9ucy5wdXNoKEBXTS5QYXJzZXIuc3F1YXNoQ29udGlndW91c1doaXRlc3BhY2UoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VjdGlvbi5saW5lKS50cmltKCkpXG5cbiAgICAgICAgICAgIEBtYWluQXV0b1JlYWQodGFyZ2V0LCBzZWN0aW9ucywgdGl0bGUsIHN1bW1hcnksIGNhbGxCb3QpXG5cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgQFdNLkxvZy5sb2dFcnJvcihcIlRoZSBzZXQgdGFyZ2V0IHBhZ2UsIFwiICsgdGFyZ2V0ICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIiwgc2VlbXMgbm90IHRvIGV4aXN0XCIpXG5cbiAgICAgICAgICAgIGlmIHJlcy5lcnJvclxuICAgICAgICAgICAgICAgIGNhbGxCb3QocmVzLmVycm9yLmNvZGUsIHNlY3Rpb25zKVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGNhbGxCb3QoZmFsc2UsIHNlY3Rpb25zKVxuXG4gICAgbWFpbkF1dG9SZWFkOiAodGFyZ2V0LCBzZWN0aW9ucywgdGl0bGUsIHN1bW1hcnksIGNhbGxCb3QpID0+XG4gICAgICAgIEBXTS5NVy5jYWxsUXVlcnlFZGl0KHRpdGxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEBtYWluQXV0b1dyaXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFt0YXJnZXQsIHN1bW1hcnksIGNhbGxCb3QsIHNlY3Rpb25zXSlcblxuICAgIG1haW5BdXRvV3JpdGU6ICh0aXRsZSwgc291cmNlLCB0aW1lc3RhbXAsIGVkaXR0b2tlbiwgYXJncykgPT5cbiAgICAgICAgdGFyZ2V0ID0gYXJnc1swXVxuICAgICAgICBzdW1tYXJ5ID0gYXJnc1sxXVxuICAgICAgICBjYWxsQm90ID0gYXJnc1syXVxuICAgICAgICBzZWN0aW9ucyA9IGFyZ3NbM11cblxuICAgICAgICBuZXd0ZXh0ID0gQGZpeExpbmtzKHNvdXJjZSwgdGFyZ2V0LCBzZWN0aW9ucylcblxuICAgICAgICBpZiBuZXd0ZXh0ICE9IHNvdXJjZVxuICAgICAgICAgICAgQFdNLk1XLmNhbGxBUElQb3N0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXCJlZGl0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3Q6IFwiMVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IHRpdGxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VtbWFyeTogc3VtbWFyeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IG5ld3RleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYXNldGltZXN0YW1wOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbjogZWRpdHRva2VuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEBtYWluQXV0b0VuZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW2NhbGxCb3QsIHNlY3Rpb25zXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVsbClcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgY2FsbEJvdCgwLCBzZWN0aW9ucylcblxuICAgIG1haW5BdXRvRW5kOiAocmVzLCBhcmdzKSA9PlxuICAgICAgICBjYWxsQm90ID0gYXJnc1swXVxuICAgICAgICBzZWN0aW9ucyA9IGFyZ3NbMV1cblxuICAgICAgICBpZiByZXMuZWRpdCBhbmQgcmVzLmVkaXQucmVzdWx0ID09ICdTdWNjZXNzJ1xuICAgICAgICAgICAgY2FsbEJvdCgxLCBzZWN0aW9ucylcbiAgICAgICAgZWxzZSBpZiByZXMuZXJyb3JcbiAgICAgICAgICAgIEBXTS5Mb2cubG9nRXJyb3IocmVzLmVycm9yLmluZm8gKyBcIiAoXCIgKyByZXMuZXJyb3IuY29kZSArIFwiKVwiKVxuICAgICAgICAgICAgY2FsbEJvdChyZXMuZXJyb3IuY29kZSwgc2VjdGlvbnMpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGNhbGxCb3QoZmFsc2UsIHNlY3Rpb25zKVxuIiwiIyBXaWtpIE1vbmtleSAtIE1lZGlhV2lraSBib3QgYW5kIGVkaXRvci1hc3Npc3RhbnQgdXNlciBzY3JpcHRcbiMgQ29weXJpZ2h0IChDKSAyMDExIERhcmlvIEdpb3Zhbm5ldHRpIDxkZXZAZGFyaW9naW92YW5uZXR0aS5uZXQ+XG4jXG4jIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFdpa2kgTW9ua2V5LlxuI1xuIyBXaWtpIE1vbmtleSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4jIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4jIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4jIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4jXG4jIFdpa2kgTW9ua2V5IGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4jIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4jIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiMgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbiNcbiMgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiMgYWxvbmcgd2l0aCBXaWtpIE1vbmtleS4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cblxue1BsdWdpbn0gPSByZXF1aXJlKCcuL19QbHVnaW4nKVxuXG5TdHIgPSByZXF1aXJlKCdAa3luaWtvcy9taXNjL2Rpc3QvU3RyJylcblxuXG5jbGFzcyBtb2R1bGUuZXhwb3J0cy5GaXhEb3VibGVSZWRpcmVjdHMgZXh0ZW5kcyBQbHVnaW5cbiAgICBAY29uZl9kZWZhdWx0OlxuICAgICAgICBlbmFibGVkOiB0cnVlXG4gICAgICAgIHNwZWNpYWxfbWVudTogW1wiRml4IGRvdWJsZSByZWRpcmVjdHNcIl1cbiAgICAgICAgZWRpdF9zdW1tYXJ5OiBcImZpeCBkb3VibGUgcmVkaXJlY3RcIlxuXG4gICAgbWFpbl9zcGVjaWFsOiAoY2FsbE5leHQpIC0+XG4gICAgICAgIEBXTS5Mb2cubG9nSW5mbyhcIkZpeGluZyBkb3VibGUgcmVkaXJlY3RzIC4uLlwiKVxuXG4gICAgICAgIEBXTS5NVy5nZXRTcGVjaWFsTGlzdChcIkRvdWJsZVJlZGlyZWN0c1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm5hbWVzcGFjZXNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQHJldmVyc2VSZXN1bHRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsTmV4dClcblxuICAgIHJldmVyc2VSZXN1bHRzOiAocmVzdWx0cywgc2l0ZWluZm8sIGNhbGxOZXh0KSA9PlxuICAgICAgICBuYW1lc3BhY2VzID0gc2l0ZWluZm8ubmFtZXNwYWNlc1xuXG4gICAgICAgIHJlc3VsdHMucmV2ZXJzZSgpXG5cbiAgICAgICAgQGl0ZXJhdGVMaXN0KHJlc3VsdHMsIG5hbWVzcGFjZXMsIGNhbGxOZXh0KVxuXG4gICAgaXRlcmF0ZUxpc3Q6IChkb3VibGVSZWRpcmVjdHMsIG5hbWVzcGFjZXMsIGNhbGxOZXh0KSA9PlxuICAgICAgICBkb3VibGVSZWRpcmVjdCA9IGRvdWJsZVJlZGlyZWN0cy5wb3AoKVxuXG4gICAgICAgIGlmIGRvdWJsZVJlZGlyZWN0XG4gICAgICAgICAgICBAV00uTVcuY2FsbFF1ZXJ5RWRpdChkb3VibGVSZWRpcmVjdC50aXRsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBAcmVhZE1pZGRsZVJlZGlyZWN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtkb3VibGVSZWRpcmVjdCwgZG91YmxlUmVkaXJlY3RzLCBuYW1lc3BhY2VzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsTmV4dF0pXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIEBXTS5Mb2cubG9nSW5mbyhcIkZpeGVkIGRvdWJsZSByZWRpcmVjdHNcIilcbiAgICAgICAgICAgIGlmIGNhbGxOZXh0XG4gICAgICAgICAgICAgICAgY2FsbE5leHQoKVxuXG4gICAgcmVhZE1pZGRsZVJlZGlyZWN0OiAoZG91YmxlUmVkaXJlY3RUaXRsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICBkb3VibGVSZWRpcmVjdFNvdXJjZSwgdGltZXN0YW1wLCBlZGl0dG9rZW4sIGFyZ3MpID0+XG4gICAgICAgIGRvdWJsZVJlZGlyZWN0ID0gYXJnc1swXVxuICAgICAgICBkb3VibGVSZWRpcmVjdHMgPSBhcmdzWzFdXG4gICAgICAgIG5hbWVzcGFjZXMgPSBhcmdzWzJdXG4gICAgICAgIGNhbGxOZXh0ID0gYXJnc1szXVxuICAgICAgICBtaWRkbGVSZWRpcmVjdFRpdGxlID0gbmFtZXNwYWNlc1tkb3VibGVSZWRpcmVjdC5kYXRhYmFzZVJlc3VsdC5uc2JdWycqJ10gKyAnOicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3VibGVSZWRpcmVjdC5kYXRhYmFzZVJlc3VsdC50YlxuXG4gICAgICAgIEBXTS5NVy5jYWxsUXVlcnkoe3Byb3A6IFwicmV2aXNpb25zXCIsIHJ2cHJvcDogXCJjb250ZW50XCIsIHRpdGxlczogbWlkZGxlUmVkaXJlY3RUaXRsZX0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgQHByb2Nlc3NEb3VibGVSZWRpcmVjdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICBbZG91YmxlUmVkaXJlY3QsIGRvdWJsZVJlZGlyZWN0VGl0bGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGRvdWJsZVJlZGlyZWN0U291cmNlLCB0aW1lc3RhbXAsIGVkaXR0b2tlbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZG91YmxlUmVkaXJlY3RzLCBuYW1lc3BhY2VzLCBjYWxsTmV4dF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgbnVsbClcblxuICAgIHByb2Nlc3NEb3VibGVSZWRpcmVjdDogKG1pZGRsZVJlZGlyZWN0LCBhcmdzKSA9PlxuICAgICAgICBtaWRkbGVSZWRpcmVjdFNvdXJjZSA9IG1pZGRsZVJlZGlyZWN0LnJldmlzaW9uc1swXVtcIipcIl1cbiAgICAgICAgZG91YmxlUmVkaXJlY3QgPSBhcmdzWzBdXG4gICAgICAgIGRvdWJsZVJlZGlyZWN0VGl0bGUgPSBhcmdzWzFdXG4gICAgICAgIGRvdWJsZVJlZGlyZWN0U291cmNlID0gYXJnc1syXVxuICAgICAgICB0aW1lc3RhbXAgPSBhcmdzWzNdXG4gICAgICAgIGVkaXR0b2tlbiA9IGFyZ3NbNF1cbiAgICAgICAgZG91YmxlUmVkaXJlY3RzID0gYXJnc1s1XVxuICAgICAgICBuYW1lc3BhY2VzID0gYXJnc1s2XVxuICAgICAgICBjYWxsTmV4dCA9IGFyZ3NbN11cblxuICAgICAgICBAV00uTG9nLmxvZ0luZm8oXCJQcm9jZXNzaW5nIFwiICsgQFdNLkxvZy5saW5rVG9XaWtpUGFnZShcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvdWJsZVJlZGlyZWN0VGl0bGUsIGRvdWJsZVJlZGlyZWN0VGl0bGUpICsgXCIgLi4uXCIpXG5cbiAgICAgICAgcmF3T2xkVGFyZ2V0ID0gZG91YmxlUmVkaXJlY3RTb3VyY2UubWF0Y2goL1xccyojcmVkaXJlY3RcXHMqW15cXG5dKy9pKVxuICAgICAgICBvbGRUYXJnZXQgPSBAV00uUGFyc2VyLmZpbmRJbnRlcm5hbExpbmtzKHJhd09sZFRhcmdldFswXSwgbnVsbClbMF1cblxuICAgICAgICByYXdNaWRkbGVUYXJnZXQgPSBtaWRkbGVSZWRpcmVjdFNvdXJjZS5tYXRjaChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvXFxzKiNyZWRpcmVjdFxccypbXlxcbl0rL2kpXG4gICAgICAgIG1pZGRsZVRhcmdldCA9IEBXTS5QYXJzZXIuZmluZEludGVybmFsTGlua3MocmF3TWlkZGxlVGFyZ2V0WzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudWxsKVswXVxuXG4gICAgICAgIGlmIG9sZFRhcmdldC5mcmFnbWVudFxuICAgICAgICAgICAgbmV3VGFyZ2V0RnJhZ21lbnQgPSBcIiNcIiArIG9sZFRhcmdldC5mcmFnbWVudFxuICAgICAgICBlbHNlIGlmIG1pZGRsZVRhcmdldC5mcmFnbWVudFxuICAgICAgICAgICAgbmV3VGFyZ2V0RnJhZ21lbnQgPSBcIiNcIiArIG1pZGRsZVRhcmdldC5mcmFnbWVudFxuICAgICAgICBlbHNlXG4gICAgICAgICAgICBuZXdUYXJnZXRGcmFnbWVudCA9IFwiXCJcblxuICAgICAgICBpZiBvbGRUYXJnZXQuYW5jaG9yXG4gICAgICAgICAgICBuZXdUYXJnZXRBbHRBbmNob3IgPSBcInxcIiArIG9sZFRhcmdldC5hbmNob3JcbiAgICAgICAgZWxzZSBpZiBtaWRkbGVUYXJnZXQuYW5jaG9yXG4gICAgICAgICAgICBuZXdUYXJnZXRBbHRBbmNob3IgPSBcInxcIiArIG1pZGRsZVRhcmdldC5hbmNob3JcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgbmV3VGFyZ2V0QWx0QW5jaG9yID0gXCJcIlxuXG4gICAgICAgIGlmIGRvdWJsZVJlZGlyZWN0LmRhdGFiYXNlUmVzdWx0Lml3Y1xuICAgICAgICAgICAgbmV3VGFyZ2V0SW50ZXJsYW5ndWFnZSA9IGRvdWJsZVJlZGlyZWN0LmRhdGFiYXNlUmVzdWx0Lml3YyArIFwiOlwiXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIG5ld1RhcmdldEludGVybGFuZ3VhZ2UgPSBcIlwiXG5cbiAgICAgICAgaWYgbmFtZXNwYWNlc1tkb3VibGVSZWRpcmVjdC5kYXRhYmFzZVJlc3VsdC5uc2NdW1wiKlwiXVxuICAgICAgICAgICAgbmV3VGFyZ2V0TmFtZXNwYWNlID0gQFdNLlBhcnNlci5zcXVhc2hDb250aWd1b3VzV2hpdGVzcGFjZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZXNwYWNlc1tkb3VibGVSZWRpcmVjdC5kYXRhYmFzZVJlc3VsdC5uc2NdW1wiKlwiXSkgKyBcIjpcIlxuICAgICAgICBlbHNlXG4gICAgICAgICAgICBuZXdUYXJnZXROYW1lc3BhY2UgPSBcIlwiXG5cbiAgICAgICAgbmV3VGFyZ2V0VGl0bGUgPSBAV00uUGFyc2VyLnNxdWFzaENvbnRpZ3VvdXNXaGl0ZXNwYWNlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3VibGVSZWRpcmVjdC5kYXRhYmFzZVJlc3VsdC50YylcblxuICAgICAgICBuZXdUYXJnZXQgPSBcIltbXCIgKyBuZXdUYXJnZXRJbnRlcmxhbmd1YWdlICtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1RhcmdldE5hbWVzcGFjZSArIG5ld1RhcmdldFRpdGxlICtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1RhcmdldEZyYWdtZW50ICsgbmV3VGFyZ2V0QWx0QW5jaG9yICsgXCJdXVwiXG4gICAgICAgIG5ld1RleHQgPSBTdHIub3ZlcndyaXRlRm9yKGRvdWJsZVJlZGlyZWN0U291cmNlLCBuZXdUYXJnZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9sZFRhcmdldC5pbmRleCwgb2xkVGFyZ2V0Lmxlbmd0aClcblxuICAgICAgICBpZiBuZXdUZXh0ICE9IGRvdWJsZVJlZGlyZWN0U291cmNlXG4gICAgICAgICAgICBAV00uTVcuY2FsbEFQSVBvc3QoXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXCJlZGl0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvdDogXCIxXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBkb3VibGVSZWRpcmVjdFRpdGxlXG4gICAgICAgICAgICAgICAgICAgICAgICBzdW1tYXJ5OiBAY29uZi5lZGl0X3N1bW1hcnlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IG5ld1RleHRcbiAgICAgICAgICAgICAgICAgICAgICAgIGIxYXNldGltZXN0YW1wOiB0aW1lc3RhbXBcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuOiBlZGl0dG9rZW5cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgQHByb2Nlc3NEb3VibGVSZWRpcmVjdEVuZCxcbiAgICAgICAgICAgICAgICAgICAgW2RvdWJsZVJlZGlyZWN0cywgbmFtZXNwYWNlcywgY2FsbE5leHRdLFxuICAgICAgICAgICAgICAgICAgICBudWxsKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICBAV00uTG9nLmxvZ1dhcm5pbmcoXCJDb3VsZCBub3QgZml4IFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQFdNLkxvZy5saW5rVG9XaWtpUGFnZShkb3VibGVSZWRpcmVjdFRpdGxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3VibGVSZWRpcmVjdFRpdGxlKSlcbiAgICAgICAgICAgIEBpdGVyYXRlTGlzdChkb3VibGVSZWRpcmVjdHMsIG5hbWVzcGFjZXMsIGNhbGxOZXh0KVxuXG4gICAgcHJvY2Vzc0RvdWJsZVJlZGlyZWN0RW5kOiAocmVzLCBhcmdzKSA9PlxuICAgICAgICBkb3VibGVSZWRpcmVjdHMgPSBhcmdzWzBdXG4gICAgICAgIG5hbWVzcGFjZXMgPSBhcmdzWzFdXG4gICAgICAgIGNhbGxOZXh0ID0gYXJnc1syXVxuXG4gICAgICAgIGlmIHJlcy5lZGl0IGFuZCByZXMuZWRpdC5yZXN1bHQgPT0gJ1N1Y2Nlc3MnXG4gICAgICAgICAgICBAaXRlcmF0ZUxpc3QoZG91YmxlUmVkaXJlY3RzLCBuYW1lc3BhY2VzLCBjYWxsTmV4dClcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgQFdNLkxvZy5sb2dFcnJvcihyZXNbJ2Vycm9yJ11bJ2luZm8nXSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiIChcIiArIHJlc1snZXJyb3InXVsnY29kZSddICsgXCIpXCIpXG4iLCIjIFdpa2kgTW9ua2V5IC0gTWVkaWFXaWtpIGJvdCBhbmQgZWRpdG9yLWFzc2lzdGFudCB1c2VyIHNjcmlwdFxuIyBDb3B5cmlnaHQgKEMpIDIwMTEgRGFyaW8gR2lvdmFubmV0dGkgPGRldkBkYXJpb2dpb3Zhbm5ldHRpLm5ldD5cbiNcbiMgVGhpcyBmaWxlIGlzIHBhcnQgb2YgV2lraSBNb25rZXkuXG4jXG4jIFdpa2kgTW9ua2V5IGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiMgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiMgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiMgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbiNcbiMgV2lraSBNb25rZXkgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiMgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiMgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuIyBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuI1xuIyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuIyBhbG9uZyB3aXRoIFdpa2kgTW9ua2V5LiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuXG57UGx1Z2lufSA9IHJlcXVpcmUoJy4vX1BsdWdpbicpXG5cblxuY2xhc3MgbW9kdWxlLmV4cG9ydHMuRml4RnJhZ21lbnRzIGV4dGVuZHMgUGx1Z2luXG4gICAgQGNvbmZfZGVmYXVsdDpcbiAgICAgICAgZW5hYmxlZDogdHJ1ZVxuICAgICAgICBlZGl0b3JfbWVudTogW1wiVGV4dCBwbHVnaW5zXCIsIFwiRml4IHNlY3Rpb24gbGlua3NcIl1cblxuICAgIGZpeExpbmtzOiAoc291cmNlKSAtPlxuICAgICAgICB0aXRsZSA9IEBXTS5FZGl0b3IuZ2V0VGl0bGUoKVxuICAgICAgICBzZWN0aW9ucyA9IEBXTS5QYXJzZXIuZmluZFNlY3Rpb25IZWFkaW5ncyhzb3VyY2UpLnNlY3Rpb25zXG5cbiAgICAgICAgc2xpbmtzID0gQFdNLlBhcnNlci5maW5kU2VjdGlvbkxpbmtzKHNvdXJjZSlcbiAgICAgICAgbmV3dGV4dDEgPSBcIlwiXG4gICAgICAgIHByZXZJZCA9IDBcblxuICAgICAgICBmb3IgbGluayBpbiBzbGlua3NcbiAgICAgICAgICAgIG5ld3RleHQxICs9IHNvdXJjZS5zdWJzdHJpbmcocHJldklkLCBsaW5rLmluZGV4KVxuICAgICAgICAgICAgbmV3dGV4dDEgKz0gQGZpeExpbmsoc291cmNlLCBzZWN0aW9ucywgbGluay5yYXdMaW5rLCBsaW5rLmZyYWdtZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmsuYW5jaG9yKVxuICAgICAgICAgICAgcHJldklkID0gbGluay5pbmRleCArIGxpbmsubGVuZ3RoXG5cbiAgICAgICAgbmV3dGV4dDEgKz0gc291cmNlLnN1YnN0cihwcmV2SWQpXG5cbiAgICAgICAgIyBOb3RlIHRoYXQgaXQncyBpbXBvc3NpYmxlIHRvIHJlY29nbml6ZSBhbnkgbmFtZXNwYWNlcyBpbiB0aGUgdGl0bGVcbiAgICAgICAgIyAgIHdpdGhvdXQgcXVlcnlpbmcgdGhlIHNlcnZlclxuICAgICAgICAjIEFsdGVybmF0aXZlbHksIGEgbGlzdCBvZiB0aGUga25vd24gbmFtZXNwYWNlcyBjb3VsZCBiZSBtYWludGFpbmVkXG4gICAgICAgICMgICBmb3IgZWFjaCB3aWtpXG4gICAgICAgICMgUmVjb2duaXppbmcgbmFtZXNwYWNlcyB3b3VsZCBsZXQgcmVjb2duaXplIG1vcmUgbGliZXJhbCBsaW5rXG4gICAgICAgICMgICBzeW50YXhlcyAoZS5nLiBzcGFjZXMgYXJvdW5kIHRoZSBjb2xvbilcbiAgICAgICAgaWxpbmtzID0gQFdNLlBhcnNlci5maW5kSW50ZXJuYWxMaW5rcyhuZXd0ZXh0MSwgbnVsbCwgdGl0bGUpXG4gICAgICAgIG5ld3RleHQyID0gXCJcIlxuICAgICAgICBwcmV2SWQgPSAwXG5cbiAgICAgICAgZm9yIGxpbmsgaW4gaWxpbmtzXG4gICAgICAgICAgICBuZXd0ZXh0MiArPSBuZXd0ZXh0MS5zdWJzdHJpbmcocHJldklkLCBsaW5rLmluZGV4KVxuICAgICAgICAgICAgcmF3ZnJhZ21lbnQgPSBsaW5rLmZyYWdtZW50XG5cbiAgICAgICAgICAgIGlmIHJhd2ZyYWdtZW50XG4gICAgICAgICAgICAgICAgbmV3dGV4dDIgKz0gQGZpeExpbmsobmV3dGV4dDEsIHNlY3Rpb25zLCBsaW5rLnJhd0xpbmssXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmF3ZnJhZ21lbnQsIGxpbmsuYW5jaG9yKVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIG5ld3RleHQyICs9IGxpbmsucmF3TGlua1xuXG4gICAgICAgICAgICBwcmV2SWQgPSBsaW5rLmluZGV4ICsgbGluay5sZW5ndGhcblxuICAgICAgICBuZXd0ZXh0MiArPSBuZXd0ZXh0MS5zdWJzdHIocHJldklkKVxuXG4gICAgICAgIHJldHVybiBuZXd0ZXh0MlxuXG4gICAgZml4TGluazogKHNvdXJjZSwgc2VjdGlvbnMsIHJhd2xpbmssIHJhd2ZyYWdtZW50LCBsYWx0KSAtPlxuICAgICAgICBmcmFnbWVudCA9IEBXTS5QYXJzZXIuc3F1YXNoQ29udGlndW91c1doaXRlc3BhY2UocmF3ZnJhZ21lbnQpLnRyaW0oKVxuXG4gICAgICAgIGZvciBzZWN0aW9uIGluIHNlY3Rpb25zXG4gICAgICAgICAgICBoZWFkaW5nID0gc2VjdGlvbi5jbGVhbmhlYWRpbmdcbiAgICAgICAgICAgIGRvdEhlYWRpbmcgPSBAV00uUGFyc2VyLmRvdEVuY29kZShoZWFkaW5nKVxuICAgICAgICAgICAgZG90RnJhZ21lbnQgPSBAV00uUGFyc2VyLmRvdEVuY29kZShmcmFnbWVudClcblxuICAgICAgICAgICAgaWYgZG90SGVhZGluZy50b0xvd2VyQ2FzZSgpID09IGRvdEZyYWdtZW50LnRvTG93ZXJDYXNlKClcbiAgICAgICAgICAgICAgICBpZiBmcmFnbWVudCA9PSBkb3RGcmFnbWVudFxuICAgICAgICAgICAgICAgICAgICAjIElmIHRoZSBmcmFnbWVudCB3YXMgZW5jb2RlZCwgcmUtZW5jb2RlIGl0IGJlY2F1c2UgaXRcbiAgICAgICAgICAgICAgICAgICAgIyBjb3VsZCBjb250YWluIGxpbmstYnJlYWtpbmcgY2hhcmFjdGVycyAoZS5nLiBbXXx7fSlcbiAgICAgICAgICAgICAgICAgICAgIyBUaGUgY29uZGl0aW9uIHdvdWxkIGFsc28gYmUgdHJ1ZSBpZiB0aGUgZnJhZ21lbnQgZG9lc24ndFxuICAgICAgICAgICAgICAgICAgICAjIGNvbnRhaW4gYW55IGVuY29kYWJsZSBjaGFyYWN0ZXJzLCBidXQgc2luY2UgaGVhZGluZyBhbmRcbiAgICAgICAgICAgICAgICAgICAgIyBmcmFnbWVudCBhdCBtb3N0IGRpZmZlciBieSBjYXBpdGFsaXphdGlvbiwgZW5jb2RpbmcgdGhlXG4gICAgICAgICAgICAgICAgICAgICMgaGVhZGluZyB3b24ndCBoYXZlIGFueSBlZmZlY3RcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiW1sjXCIgKyBkb3RIZWFkaW5nICsgKGlmIGxhbHQgdGhlbiBcInxcIiArIGxhbHQgZWxzZSBcIlwiKSArIFwiXV1cIlxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgIyBJZiB0aGUgZnJhZ21lbnQgd2FzIG5vdCBlbmNvZGVkLCBpZiB0aGUgZnJhZ21lbnRcbiAgICAgICAgICAgICAgICAgICAgIyBjb250YWluZWQgbGluay1icmVha2luZyBjaGFyYWN0ZXJzIHRoZSBsaW5rIHdhcyBhbHJlYWR5XG4gICAgICAgICAgICAgICAgICAgICMgYnJva2VuLCBhbmQgcmVwbGFjaW5nIGl0IHdpdGggaGVhZGluZyB3b3VsZG4ndCBtYWtlXG4gICAgICAgICAgICAgICAgICAgICMgdGhpbmdzIHdvcnNlOyBpZiB0aGUgZnJhZ21lbnQgZGlkbid0IGNvbnRhaW5cbiAgICAgICAgICAgICAgICAgICAgIyBsaW5rLWJyZWFraW5nIGNoYXJhY3RlcnMsIHRoZSBoZWFkaW5nIGRvZXNuJ3QgZWl0aGVyLFxuICAgICAgICAgICAgICAgICAgICAjIHNpbmNlIGhlYWRpbmcgYW5kIGZyYWdtZW50IGF0IG1vc3QgZGlmZmVyIGJ5XG4gICAgICAgICAgICAgICAgICAgICMgY2FwaXRhbGl6YXRpb24sIHNvIGl0J3Mgc2FmZSB0byByZXBsYWNlIGl0XG4gICAgICAgICAgICAgICAgICAgICMgSWYgdGhlIGZyYWdtZW50IHdhcyAqcGFydGlhbGx5KiBlbmNvZGVkIGluc3RlYWQsIGFcbiAgICAgICAgICAgICAgICAgICAgIyBsaW5rLWJyZWFraW5nIGNoYXJhY3RlciBtYXkgaGF2ZSBiZWVuIGVuY29kZWQsIHNvIGFsbFxuICAgICAgICAgICAgICAgICAgICAjIGxpbmstYnJlYWtpbmcgY2hhcmFjdGVycyBtdXN0IGJlIHJlLWVuY29kZWQgaGVyZSFcbiAgICAgICAgICAgICAgICAgICAgZXNjSGVhZGluZyA9IEBXTS5QYXJzZXIuZG90RW5jb2RlTGlua0JyZWFraW5nRnJhZ21lbnRDaGFyYWN0ZXJzKGhlYWRpbmcpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIltbI1wiICsgZXNjSGVhZGluZyArIChpZiBsYWx0IHRoZW4gXCJ8XCIgKyBsYWx0IGVsc2UgXCJcIikgKyBcIl1dXCJcblxuICAgICAgICAjIEl0J3Mgbm90IGVhc3kgdG8gdXNlIEBXTS5Mb2cubGlua1RvV2lraVBhZ2UgYmVjYXVzZSBwdXJlIGZyYWdtZW50c1xuICAgICAgICAjICAgYXJlIG5vdCBzdXBwb3J0ZWQgeWV0XG4gICAgICAgIEBXTS5Mb2cubG9nV2FybmluZyhcIkNhbm5vdCBmaXggYnJva2VuIHNlY3Rpb24gbGluazogXCIgKyByYXdsaW5rKVxuICAgICAgICByZXR1cm4gcmF3bGlua1xuXG4gICAgbWFpbl9lZGl0b3I6IChjYWxsTmV4dCkgLT5cbiAgICAgICAgc291cmNlID0gQFdNLkVkaXRvci5yZWFkU291cmNlKClcbiAgICAgICAgbmV3dGV4dCA9IEBmaXhMaW5rcyhzb3VyY2UpXG5cbiAgICAgICAgaWYgbmV3dGV4dCAhPSBzb3VyY2VcbiAgICAgICAgICAgIEBXTS5FZGl0b3Iud3JpdGVTb3VyY2UobmV3dGV4dClcbiAgICAgICAgICAgIEBXTS5Mb2cubG9nSW5mbyhcIkZpeGVkIHNlY3Rpb24gbGlua3NcIilcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgQFdNLkxvZy5sb2dJbmZvKFwiTm8gZml4YWJsZSBzZWN0aW9uIGxpbmtzIGZvdW5kXCIpXG5cbiAgICAgICAgaWYgY2FsbE5leHRcbiAgICAgICAgICAgIGNhbGxOZXh0KClcbiIsIiMgV2lraSBNb25rZXkgLSBNZWRpYVdpa2kgYm90IGFuZCBlZGl0b3ItYXNzaXN0YW50IHVzZXIgc2NyaXB0XG4jIENvcHlyaWdodCAoQykgMjAxMSBEYXJpbyBHaW92YW5uZXR0aSA8ZGV2QGRhcmlvZ2lvdmFubmV0dGkubmV0PlxuI1xuIyBUaGlzIGZpbGUgaXMgcGFydCBvZiBXaWtpIE1vbmtleS5cbiNcbiMgV2lraSBNb25rZXkgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuIyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuIyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuIyAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuI1xuIyBXaWtpIE1vbmtleSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuIyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuIyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4jIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4jXG4jIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4jIGFsb25nIHdpdGggV2lraSBNb25rZXkuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG5cbntQbHVnaW59ID0gcmVxdWlyZSgnLi9fUGx1Z2luJylcblxuXG5jbGFzcyBtb2R1bGUuZXhwb3J0cy5GaXhMaW5rRnJhZ21lbnRzIGV4dGVuZHMgUGx1Z2luXG4gICAgQGNvbmZfZGVmYXVsdDpcbiAgICAgICAgZW5hYmxlZDogdHJ1ZVxuICAgICAgICBlZGl0b3JfbWVudTogW1wiUXVlcnkgcGx1Z2luc1wiLCBcIkZpeCBleHRlcm5hbCBzZWN0aW9uIGxpbmtzXCJdXG5cbiAgICBwcm9jZXNzTGluazogKHRpdGxlLCBpd3ByZWZpeGVzLCBsaW5rcywgaW5kZXgsIHNvdXJjZSwgbmV3VGV4dCwgcHJldklkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbCwgY2FsbEFyZ3MpID0+XG4gICAgICAgIGlmIGxpbmtzW2luZGV4XVxuICAgICAgICAgICAgbGluayA9IGxpbmtzW2luZGV4XVxuICAgICAgICAgICAgcmF3ZnJhZ21lbnQgPSBsaW5rLmZyYWdtZW50XG5cbiAgICAgICAgICAgIGlmIG5vdCAobGluay5uYW1lc3BhY2U/IGFuZCBsaW5rLm5hbWVzcGFjZS50b0xvd2VyQ2FzZSgpIGluIGl3cHJlZml4ZXMpIGFuZCByYXdmcmFnbWVudFxuICAgICAgICAgICAgICAgIEBXTS5Mb2cubG9nSW5mbyhcIlByb2Nlc3NpbmcgXCIgK1xuICAgICAgICAgICAgICAgICAgICBAV00uTG9nLmxpbmtUb1dpa2lQYWdlKGxpbmsubGluaywgbGluay5yYXdMaW5rKSArIFwiIC4uLlwiKVxuXG4gICAgICAgICAgICAgICAgdGFyZ2V0ID0gKGlmIGxpbmsubmFtZXNwYWNlIHRoZW4gbGluay5uYW1lc3BhY2UgKyBcIjpcIiBlbHNlIFwiXCIpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluay50aXRsZVxuXG4gICAgICAgICAgICAgICAgIyBOb3RlIHRoYXQgaXQncyBpbXBvc3NpYmxlIHRvIHJlY29nbml6ZSBhbnkgbmFtZXNwYWNlcyBpbiB0aGVcbiAgICAgICAgICAgICAgICAjICAgdGl0bGUgd2l0aG91dCBxdWVyeWluZyB0aGUgc2VydmVyXG4gICAgICAgICAgICAgICAgIyBBbHRlcm5hdGl2ZWx5LCBhIGxpc3Qgb2YgdGhlIGtub3duIG5hbWVzcGFjZXMgY291bGQgYmVcbiAgICAgICAgICAgICAgICAjICAgbWFpbnRhaW5lZCBmb3IgZWFjaCB3aWtpXG4gICAgICAgICAgICAgICAgIyBSZWNvZ25pemluZyBuYW1lc3BhY2VzIHdvdWxkIGxldCByZWNvZ25pemUgbW9yZSBsaWJlcmFsIGxpbmtcbiAgICAgICAgICAgICAgICAjICAgc3ludGF4ZXMgKGUuZy4gc3BhY2VzIGFyb3VuZCB0aGUgY29sb24pXG4gICAgICAgICAgICAgICAgaWYgbm90IEBXTS5QYXJzZXIuY29tcGFyZUFydGljbGVUaXRsZXModGFyZ2V0LCB0aXRsZSlcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zID1cbiAgICAgICAgICAgICAgICAgICAgICAgICdhY3Rpb24nOiAncGFyc2UnXG4gICAgICAgICAgICAgICAgICAgICAgICAncHJvcCc6ICdzZWN0aW9ucydcbiAgICAgICAgICAgICAgICAgICAgICAgICdwYWdlJzogdGFyZ2V0XG4gICAgICAgICAgICAgICAgICAgICAgICAncmVkaXJlY3RzJzogMVxuXG4gICAgICAgICAgICAgICAgICAgIEBXTS5NVy5jYWxsQVBJR2V0KHBhcmFtcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQHByb2Nlc3NMaW5rQ29udGludWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtsaW5rLCB0YXJnZXQsIHJhd2ZyYWdtZW50LCBpd3ByZWZpeGVzLCBsaW5rcywgaW5kZXgsIHNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1RleHQsIHByZXZJZCwgdGl0bGUsIGNhbGwsIGNhbGxBcmdzXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVsbClcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGluZGV4KytcbiAgICAgICAgICAgICAgICAgICAgQHByb2Nlc3NMaW5rKHRpdGxlLCBpd3ByZWZpeGVzLCBsaW5rcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCwgc291cmNlLCBuZXdUZXh0LCBwcmV2SWQsIGNhbGwsIGNhbGxBcmdzKVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGluZGV4KytcbiAgICAgICAgICAgICAgICBAcHJvY2Vzc0xpbmsodGl0bGUsIGl3cHJlZml4ZXMsIGxpbmtzLCBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZSwgbmV3VGV4dCwgcHJldklkLCBjYWxsLCBjYWxsQXJncylcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgbmV3VGV4dCArPSBzb3VyY2Uuc3Vic3RyKHByZXZJZClcbiAgICAgICAgICAgIGNhbGwobmV3VGV4dCwgaXdwcmVmaXhlcywgY2FsbEFyZ3MpXG5cbiAgICBwcm9jZXNzTGlua0NvbnRpbnVlOiAocmVzLCBhcmdzKSA9PlxuICAgICAgICBsaW5rID0gYXJnc1swXVxuICAgICAgICB0YXJnZXQgPSBhcmdzWzFdXG4gICAgICAgIHJhd2ZyYWdtZW50ID0gYXJnc1syXVxuICAgICAgICBpd3ByZWZpeGVzID0gYXJnc1szXVxuICAgICAgICBsaW5rcyA9IGFyZ3NbNF1cbiAgICAgICAgaW5kZXggPSBhcmdzWzVdXG4gICAgICAgIHNvdXJjZSA9IGFyZ3NbNl1cbiAgICAgICAgbmV3VGV4dCA9IGFyZ3NbN11cbiAgICAgICAgcHJldklkID0gYXJnc1s4XVxuICAgICAgICB0aXRsZSA9IGFyZ3NbOV1cbiAgICAgICAgY2FsbCA9IGFyZ3NbMTBdXG4gICAgICAgIGNhbGxBcmdzID0gYXJnc1sxMV1cblxuICAgICAgICAjIENoZWNrIHRoYXQgdGhlIHBhZ2UgaXMgaW4gdGhlIHdpa2kgKGUuZy4gaXQncyBub3QgYW4gaW50ZXJ3aWtpIGxpbmspXG4gICAgICAgIGlmIHJlcy5wYXJzZVxuICAgICAgICAgICAgc2VjdGlvbnMgPSBbXVxuXG4gICAgICAgICAgICBmb3Igc2VjdGlvbiBpbiByZXMucGFyc2Uuc2VjdGlvbnNcbiAgICAgICAgICAgICAgICBzZWN0aW9ucy5wdXNoKEBXTS5QYXJzZXIuc3F1YXNoQ29udGlndW91c1doaXRlc3BhY2UoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VjdGlvbi5saW5lKS50cmltKCkpXG5cbiAgICAgICAgICAgIGZpeGVkRnJhZ21lbnQgPSBAZml4RnJhZ21lbnQocmF3ZnJhZ21lbnQsIHNlY3Rpb25zKVxuXG4gICAgICAgICAgICBuZXdUZXh0ICs9IHNvdXJjZS5zdWJzdHJpbmcocHJldklkLCBsaW5rLmluZGV4KVxuXG4gICAgICAgICAgICBpZiBmaXhlZEZyYWdtZW50IGlzIHRydWVcbiAgICAgICAgICAgICAgICBuZXdUZXh0ICs9IGxpbmsucmF3TGlua1xuICAgICAgICAgICAgZWxzZSBpZiBmaXhlZEZyYWdtZW50XG4gICAgICAgICAgICAgICAgbmV3VGV4dCArPSBcIltbXCIgKyB0YXJnZXQgKyBcIiNcIiArIGZpeGVkRnJhZ21lbnQgICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoaWYgbGluay5hbmNob3IgdGhlbiBcInxcIiArIGxpbmsuYW5jaG9yIGVsc2UgXCJcIikgKyBcIl1dXCJcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBAV00uTG9nLmxvZ1dhcm5pbmcoXCJDYW5ub3QgZml4IGJyb2tlbiBsaW5rIGZyYWdtZW50OiBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQFdNLkxvZy5saW5rVG9XaWtpUGFnZShsaW5rLmxpbmssIGxpbmsucmF3TGluaykpXG4gICAgICAgICAgICAgICAgbmV3VGV4dCArPSBsaW5rLnJhd0xpbmtcblxuICAgICAgICAgICAgcHJldklkID0gbGluay5pbmRleCArIGxpbmsubGVuZ3RoXG5cbiAgICAgICAgaW5kZXgrK1xuICAgICAgICBAcHJvY2Vzc0xpbmsodGl0bGUsIGl3cHJlZml4ZXMsIGxpbmtzLCBpbmRleCwgc291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdUZXh0LCBwcmV2SWQsIGNhbGwsIGNhbGxBcmdzKVxuXG4gICAgZml4RnJhZ21lbnQ6IChyYXdmcmFnbWVudCwgc2VjdGlvbnMpID0+XG4gICAgICAgIGZyYWdtZW50ID0gQFdNLlBhcnNlci5zcXVhc2hDb250aWd1b3VzV2hpdGVzcGFjZShyYXdmcmFnbWVudCkudHJpbSgpXG5cbiAgICAgICAgaWYgc2VjdGlvbnMuaW5kZXhPZihmcmFnbWVudCkgPCAwXG4gICAgICAgICAgICBmb3Igc2VjdGlvbiBpbiBzZWN0aW9uc1xuICAgICAgICAgICAgICAgIGRvdFNlY3Rpb24gPSBAV00uUGFyc2VyLmRvdEVuY29kZShzZWN0aW9uKVxuICAgICAgICAgICAgICAgIGRvdEZyYWdtZW50ID0gQFdNLlBhcnNlci5kb3RFbmNvZGUoZnJhZ21lbnQpXG5cbiAgICAgICAgICAgICAgICBpZiBkb3RTZWN0aW9uLnRvTG93ZXJDYXNlKCkgPT0gZG90RnJhZ21lbnQudG9Mb3dlckNhc2UoKVxuICAgICAgICAgICAgICAgICAgICBpZiBmcmFnbWVudCA9PSBkb3RGcmFnbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgIyBJZiB0aGUgZnJhZ21lbnQgd2FzIGVuY29kZWQsIHJlLWVuY29kZSBpdCBiZWNhdXNlIGl0XG4gICAgICAgICAgICAgICAgICAgICAgICAjIGNvdWxkIGNvbnRhaW4gbGluay1icmVha2luZyBjaGFyYWN0ZXJzIChlLmcuIFtdfHt9KVxuICAgICAgICAgICAgICAgICAgICAgICAgIyBUaGUgY29uZGl0aW9uIHdvdWxkIGFsc28gYmUgdHJ1ZSBpZiB0aGUgZnJhZ21lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICMgZG9lc24ndCBjb250YWluIGFueSBlbmNvZGFibGUgY2hhcmFjdGVycywgYnV0IHNpbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAjIHNlY3Rpb24gYW5kIGZyYWdtZW50IGF0IG1vc3QgZGlmZmVyIGJ5XG4gICAgICAgICAgICAgICAgICAgICAgICAjIGNhcGl0YWxpemF0aW9uLCBlbmNvZGluZyB0aGUgc2VjdGlvbiB3b24ndCBoYXZlIGFueVxuICAgICAgICAgICAgICAgICAgICAgICAgIyBlZmZlY3RcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkb3RTZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICMgSWYgdGhlIGZyYWdtZW50IHdhcyBub3QgZW5jb2RlZCwgaWYgdGhlIGZyYWdtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAjIGNvbnRhaW5lZCBsaW5rLWJyZWFraW5nIGNoYXJhY3RlcnMgdGhlIGxpbmsgd2FzXG4gICAgICAgICAgICAgICAgICAgICAgICAjIGFscmVhZHkgYnJva2VuLCBhbmQgcmVwbGFjaW5nIGl0IHdpdGggc2VjdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgIyB3b3VsZG4ndCBtYWtlIHRoaW5ncyB3b3JzZTsgaWYgdGhlIGZyYWdtZW50IGRpZG4ndFxuICAgICAgICAgICAgICAgICAgICAgICAgIyBjb250YWluIGxpbmstYnJlYWtpbmcgY2hhcmFjdGVycywgdGhlIHNlY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICMgZG9lc24ndCBlaXRoZXIsIHNpbmNlIHNlY3Rpb24gYW5kIGZyYWdtZW50IGF0IG1vc3RcbiAgICAgICAgICAgICAgICAgICAgICAgICMgZGlmZmVyIGJ5IGNhcGl0YWxpemF0aW9uLCBzbyBpdCdzIHNhZmUgdG8gcmVwbGFjZSBpdFxuICAgICAgICAgICAgICAgICAgICAgICAgIyBJZiB0aGUgZnJhZ21lbnQgd2FzICpwYXJ0aWFsbHkqIGVuY29kZWQgaW5zdGVhZCwgYVxuICAgICAgICAgICAgICAgICAgICAgICAgIyBsaW5rLWJyZWFraW5nIGNoYXJhY3RlciBtYXkgaGF2ZSBiZWVuIGVuY29kZWQsIHNvXG4gICAgICAgICAgICAgICAgICAgICAgICAjIGFsbCBsaW5rLWJyZWFraW5nIGNoYXJhY3RlcnMgbXVzdCBiZSByZS1lbmNvZGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAjIGhlcmUhXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gQFdNLlBhcnNlci5kb3RFbmNvZGVMaW5rQnJlYWtpbmdGcmFnbWVudENoYXJhY3RlcnMoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlY3Rpb24pXG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIHRydWVcblxuICAgIGZpbmRBcmNoV2lraUxpbmtzOiAobmV3VGV4dCwgaXdwcmVmaXhlcywgY2FsbEFyZ3MpID0+XG4gICAgICAgIHRlbXBsYXRlcyA9IEBXTS5QYXJzZXIuZmluZFRlbXBsYXRlcyhuZXdUZXh0LCAnUmVsYXRlZCcpXG4gICAgICAgIHRpdGxlID0gQFdNLkVkaXRvci5nZXRUaXRsZSgpXG4gICAgICAgIEBwcm9jZXNzQXJjaFdpa2lMaW5rKHRpdGxlLCBpd3ByZWZpeGVzLCB0ZW1wbGF0ZXMsIDEsIDAsXG4gICAgICAgICAgICAgICAgICAgIG5ld1RleHQsIFwiXCIsIDAsXG4gICAgICAgICAgICAgICAgICAgIEBmaW5kQXJjaFdpa2lMaW5rczIsIGNhbGxBcmdzKVxuXG4gICAgZmluZEFyY2hXaWtpTGlua3MyOiAobmV3VGV4dCwgaXdwcmVmaXhlcywgY2FsbEFyZ3MpID0+XG4gICAgICAgIHRlbXBsYXRlcyA9IEBXTS5QYXJzZXIuZmluZFRlbXBsYXRlcyhuZXdUZXh0LCAnUmVsYXRlZDInKVxuICAgICAgICB0aXRsZSA9IEBXTS5FZGl0b3IuZ2V0VGl0bGUoKVxuICAgICAgICBAcHJvY2Vzc0FyY2hXaWtpTGluayh0aXRsZSwgaXdwcmVmaXhlcywgdGVtcGxhdGVzLCAyLCAwLFxuICAgICAgICAgICAgICAgIG5ld1RleHQsIFwiXCIsIDAsIEBtYWluRW5kLCBjYWxsQXJncylcblxuICAgIHByb2Nlc3NBcmNoV2lraUxpbms6ICh0aXRsZSwgaXdwcmVmaXhlcywgdGVtcGxhdGVzLCBleHBlY3RlZEFyZ3MsIGluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlLCBuZXdUZXh0LCBwcmV2SWQsIGNhbGwsIGNhbGxBcmdzKSA9PlxuICAgICAgICBpZiB0ZW1wbGF0ZXNbaW5kZXhdXG4gICAgICAgICAgICB0ZW1wbGF0ZSA9IHRlbXBsYXRlc1tpbmRleF1cbiAgICAgICAgICAgIGFyZ3MgPSB0ZW1wbGF0ZS5hcmd1bWVudHNcblxuICAgICAgICAgICAgIyBEb24ndCBjcmFzaCBpbiBjYXNlIG9mIG1hbGZvcm1lZCB0ZW1wbGF0ZXNcbiAgICAgICAgICAgIGlmIGFyZ3MubGVuZ3RoID09IGV4cGVjdGVkQXJnc1xuICAgICAgICAgICAgICAgIGxpbmsgPSBhcmdzWzBdLnZhbHVlXG4gICAgICAgICAgICAgICAgZnJhZ0lkID0gbGluay5pbmRleE9mKCcjJylcblxuICAgICAgICAgICAgICAgIGlmIGZyYWdJZCA+IC0xXG4gICAgICAgICAgICAgICAgICAgIHJhd3RhcmdldCA9IGxpbmsuc3Vic3RyaW5nKDAsIGZyYWdJZClcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0ID0gQFdNLlBhcnNlci5zcXVhc2hDb250aWd1b3VzV2hpdGVzcGFjZShyYXd0YXJnZXQpLnRyaW0oKVxuICAgICAgICAgICAgICAgICAgICByYXdmcmFnbWVudCA9IGxpbmsuc3Vic3RyKGZyYWdJZCArIDEpXG5cbiAgICAgICAgICAgICAgICAgICAgaWYgcmF3ZnJhZ21lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICMgTm90ZSB0aGF0IGl0J3MgaW1wb3NzaWJsZSB0byByZWNvZ25pemUgYW55XG4gICAgICAgICAgICAgICAgICAgICAgICAjICAgbmFtZXNwYWNlcyBpbiB0aGUgdGl0bGUgd2l0aG91dCBxdWVyeWluZyB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgICMgICBzZXJ2ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICMgQWx0ZXJuYXRpdmVseSwgYSBsaXN0IG9mIHRoZSBrbm93biBuYW1lc3BhY2VzIGNvdWxkXG4gICAgICAgICAgICAgICAgICAgICAgICAjICAgYmUgbWFpbnRhaW5lZCBmb3IgZWFjaCB3aWtpXG4gICAgICAgICAgICAgICAgICAgICAgICAjIFJlY29nbml6aW5nIG5hbWVzcGFjZXMgd291bGQgbGV0IHJlY29nbml6ZSBtb3JlXG4gICAgICAgICAgICAgICAgICAgICAgICAjICAgbGliZXJhbCBsaW5rIHN5bnRheGVzIChlLmcuIHNwYWNlcyBhcm91bmQgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAjICAgY29sb24pXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiBub3QgQFdNLlBhcnNlci5jb21wYXJlQXJ0aWNsZVRpdGxlcyh0YXJnZXQsIHRpdGxlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEBXTS5Mb2cubG9nSW5mbyhcIlByb2Nlc3NpbmcgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEBXTS5Mb2cubGlua1RvV2lraVBhZ2UobGluayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZS5yYXdUcmFuc2NsdXNpb24pICsgXCIgLi4uXCIpXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnYWN0aW9uJzogJ3BhcnNlJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAncHJvcCc6ICdzZWN0aW9ucydcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3BhZ2UnOiB0YXJnZXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3JlZGlyZWN0cyc6IDFcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEBXTS5NVy5jYWxsQVBJR2V0KHBhcmFtcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEBwcm9jZXNzQXJjaFdpa2lMaW5rQ29udGludWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbdGVtcGxhdGUsIHRhcmdldCwgcmF3ZnJhZ21lbnQsIGl3cHJlZml4ZXMsIHRlbXBsYXRlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkQXJncywgaW5kZXgsIHNvdXJjZSwgbmV3VGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZJZCwgdGl0bGUsIGNhbGwsIGNhbGxBcmdzXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXgrK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEBwcm9jZXNzQXJjaFdpa2lMaW5rKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGUsIGl3cHJlZml4ZXMsIHRlbXBsYXRlcywgZXhwZWN0ZWRBcmdzLCBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZSwgbmV3VGV4dCwgcHJldklkLCBjYWxsLCBjYWxsQXJncylcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXgrK1xuICAgICAgICAgICAgICAgICAgICAgICAgQHByb2Nlc3NBcmNoV2lraUxpbmsodGl0bGUsIGl3cHJlZml4ZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVzLCBleHBlY3RlZEFyZ3MsIGluZGV4LCBzb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3VGV4dCwgcHJldklkLCBjYWxsLCBjYWxsQXJncylcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGluZGV4KytcbiAgICAgICAgICAgICAgICAgICAgQHByb2Nlc3NBcmNoV2lraUxpbmsodGl0bGUsIGl3cHJlZml4ZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVzLCBleHBlY3RlZEFyZ3MsIGluZGV4LCBzb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3VGV4dCwgcHJldklkLCBjYWxsLCBjYWxsQXJncylcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBAV00uTG9nLmxvZ1dhcm5pbmcoXCJUZW1wbGF0ZTpcIiArIHRlbXBsYXRlLnRpdGxlICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiIG11c3QgaGF2ZSBcIiArIGV4cGVjdGVkQXJncyArIFwiIGFuZCBvbmx5IFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkQXJncyArXG4gICAgICAgICAgICAgICAgICAgICAgICAoaWYgZXhwZWN0ZWRBcmdzID4gMSB0aGVuIFwiIGFyZ3VtZW50czogXCIgZWxzZSBcIiBhcmd1bWVudDogXCIpICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlLnJhd1RyYW5zY2x1c2lvbilcbiAgICAgICAgICAgICAgICBpbmRleCsrXG4gICAgICAgICAgICAgICAgQHByb2Nlc3NBcmNoV2lraUxpbmsodGl0bGUsIGl3cHJlZml4ZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVzLCBleHBlY3RlZEFyZ3MsIGluZGV4LCBzb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3VGV4dCwgcHJldklkLCBjYWxsLCBjYWxsQXJncylcblxuICAgICAgICBlbHNlXG4gICAgICAgICAgICBuZXdUZXh0ICs9IHNvdXJjZS5zdWJzdHIocHJldklkKVxuICAgICAgICAgICAgY2FsbChuZXdUZXh0LCBpd3ByZWZpeGVzLCBjYWxsQXJncylcblxuICAgIHByb2Nlc3NBcmNoV2lraUxpbmtDb250aW51ZTogKHJlcywgYXJncykgPT5cbiAgICAgICAgdGVtcGxhdGUgPSBhcmdzWzBdXG4gICAgICAgIHRhcmdldCA9IGFyZ3NbMV1cbiAgICAgICAgcmF3ZnJhZ21lbnQgPSBhcmdzWzJdXG4gICAgICAgIGl3cHJlZml4ZXMgPSBhcmdzWzNdXG4gICAgICAgIHRlbXBsYXRlcyA9IGFyZ3NbNF1cbiAgICAgICAgZXhwZWN0ZWRBcmdzID0gYXJnc1s1XVxuICAgICAgICBpbmRleCA9IGFyZ3NbNl1cbiAgICAgICAgc291cmNlID0gYXJnc1s3XVxuICAgICAgICBuZXdUZXh0ID0gYXJnc1s4XVxuICAgICAgICBwcmV2SWQgPSBhcmdzWzldXG4gICAgICAgIHRpdGxlID0gYXJnc1sxMF1cbiAgICAgICAgY2FsbCA9IGFyZ3NbMTFdXG4gICAgICAgIGNhbGxBcmdzID0gYXJnc1sxMl1cblxuICAgICAgICAjIENoZWNrIHRoYXQgdGhlIHBhZ2UgaXMgaW4gdGhlIHdpa2kgKGUuZy4gaXQncyBub3QgYW4gaW50ZXJ3aWtpIGxpbmspXG4gICAgICAgIGlmIHJlcy5wYXJzZVxuICAgICAgICAgICAgc2VjdGlvbnMgPSBbXVxuXG4gICAgICAgICAgICBmb3Igc2VjdGlvbiBpbiByZXMucGFyc2Uuc2VjdGlvbnNcbiAgICAgICAgICAgICAgICBzZWN0aW9ucy5wdXNoKEBXTS5QYXJzZXIuc3F1YXNoQ29udGlndW91c1doaXRlc3BhY2UoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VjdGlvbi5saW5lKS50cmltKCkpXG5cbiAgICAgICAgICAgIGZpeGVkRnJhZ21lbnQgPSBAZml4RnJhZ21lbnQocmF3ZnJhZ21lbnQsIHNlY3Rpb25zKVxuXG4gICAgICAgICAgICBuZXdUZXh0ICs9IHNvdXJjZS5zdWJzdHJpbmcocHJldklkLCB0ZW1wbGF0ZS5pbmRleClcblxuICAgICAgICAgICAgaWYgZml4ZWRGcmFnbWVudCBpcyB0cnVlXG4gICAgICAgICAgICAgICAgbmV3VGV4dCArPSB0ZW1wbGF0ZS5yYXdUcmFuc2NsdXNpb25cbiAgICAgICAgICAgIGVsc2UgaWYgZml4ZWRGcmFnbWVudFxuICAgICAgICAgICAgICAgIGFuY2hvciA9IGlmIHRlbXBsYXRlLmFyZ3VtZW50c1sxXSB0aGVuIChcInxcIiArIHRlbXBsYXRlLmFyZ3VtZW50c1sxXS52YWx1ZSkgZWxzZSBcIlwiXG4gICAgICAgICAgICAgICAgbmV3VGV4dCArPSBcInt7XCIgKyB0ZW1wbGF0ZS50aXRsZSArIFwifFwiICsgdGFyZ2V0ICsgXCIjXCIgKyBmaXhlZEZyYWdtZW50ICArIGFuY2hvciArIFwifX1cIlxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIEBXTS5Mb2cubG9nV2FybmluZyhcIkNhbm5vdCBmaXggYnJva2VuIGxpbmsgZnJhZ21lbnQ6IFwiICtcbiAgICAgICAgICAgICAgICAgICAgQFdNLkxvZy5saW5rVG9XaWtpUGFnZSh0YXJnZXQsIHRlbXBsYXRlLnJhd1RyYW5zY2x1c2lvbikpXG4gICAgICAgICAgICAgICAgbmV3VGV4dCArPSB0ZW1wbGF0ZS5yYXdUcmFuc2NsdXNpb25cblxuICAgICAgICAgICAgcHJldklkID0gdGVtcGxhdGUuaW5kZXggKyB0ZW1wbGF0ZS5sZW5ndGhcblxuICAgICAgICBpbmRleCsrXG4gICAgICAgIEBwcm9jZXNzQXJjaFdpa2lMaW5rKHRpdGxlLCBpd3ByZWZpeGVzLCB0ZW1wbGF0ZXMsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWRBcmdzLCBpbmRleCwgc291cmNlLCBuZXdUZXh0LCBwcmV2SWQsIGNhbGwsIGNhbGxBcmdzKVxuXG4gICAgbWFpbl9lZGl0b3I6IChjYWxsTmV4dCkgLT5cbiAgICAgICAgc291cmNlID0gQFdNLkVkaXRvci5yZWFkU291cmNlKClcbiAgICAgICAgQFdNLkxvZy5sb2dJbmZvKFwiRml4aW5nIGxpbmtzIHRvIHNlY3Rpb25zIG9mIG90aGVyIGFydGljbGVzIC4uLlwiKVxuICAgICAgICB0aXRsZSA9IEBXTS5FZGl0b3IuZ2V0VGl0bGUoKVxuICAgICAgICByZXMgPSBhd2FpdCBAV00uTVcuZ2V0SW50ZXJ3aWtpTWFwKHRpdGxlKVxuICAgICAgICBpd3ByZWZpeGVzID0gKGl3LnByZWZpeCBmb3IgaXcgaW4gcmVzLnF1ZXJ5LmludGVyd2lraW1hcClcbiAgICAgICAgbGlua3MgPSBAV00uUGFyc2VyLmZpbmRJbnRlcm5hbExpbmtzKHNvdXJjZSwgbnVsbCwgbnVsbClcbiAgICAgICAgQHByb2Nlc3NMaW5rKHRpdGxlLCBpd3ByZWZpeGVzLCBsaW5rcywgMCwgc291cmNlLCBcIlwiLCAwLFxuICAgICAgICAgICAgICAgICAgICAgQG1haW5Db250aW51ZSwgY2FsbE5leHQpXG5cbiAgICBtYWluQ29udGludWU6IChuZXdUZXh0LCBpd3ByZWZpeGVzLCBjYWxsTmV4dCkgPT5cbiAgICAgICAgIyBXaXRob3V0IHRoaXMgY2hlY2sgdGhpcyBwbHVnaW4gd291bGQgYmUgc3BlY2lmaWMgdG8gQXJjaFdpa2lcbiAgICAgICAgaWYgbG9jYXRpb24uaG9zdG5hbWUgPT0gJ3dpa2kuYXJjaGxpbnV4Lm9yZydcbiAgICAgICAgICAgIHRlbXBsYXRlcyA9IEBmaW5kQXJjaFdpa2lMaW5rcyhuZXdUZXh0LCBpd3ByZWZpeGVzLCBjYWxsTmV4dClcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgQG1haW5FbmQobmV3VGV4dCwgaXdwcmVmaXhlcywgY2FsbE5leHQpXG5cbiAgICBtYWluRW5kOiAobmV3VGV4dCwgaXdwcmVmaXhlcywgY2FsbE5leHQpID0+XG4gICAgICAgIHNvdXJjZSA9IEBXTS5FZGl0b3IucmVhZFNvdXJjZSgpXG5cbiAgICAgICAgaWYgbmV3VGV4dCAhPSBzb3VyY2VcbiAgICAgICAgICAgIEBXTS5FZGl0b3Iud3JpdGVTb3VyY2UobmV3VGV4dClcbiAgICAgICAgICAgIEBXTS5Mb2cubG9nSW5mbyhcIlJlcGxhY2VkIGxpbmtzIHRvIHNlY3Rpb25zIG9mIG90aGVyIGFydGljbGVzXCIpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIEBXTS5Mb2cubG9nSW5mbyhcIk5vIGZpeGFibGUgbGlua3MgdG8gc2VjdGlvbnMgb2Ygb3RoZXIgYXJ0aWNsZXMgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImZvdW5kXCIpXG5cbiAgICAgICAgaWYgY2FsbE5leHRcbiAgICAgICAgICAgIGNhbGxOZXh0KClcbiIsIiMgV2lraSBNb25rZXkgLSBNZWRpYVdpa2kgYm90IGFuZCBlZGl0b3ItYXNzaXN0YW50IHVzZXIgc2NyaXB0XG4jIENvcHlyaWdodCAoQykgMjAxMSBEYXJpbyBHaW92YW5uZXR0aSA8ZGV2QGRhcmlvZ2lvdmFubmV0dGkubmV0PlxuI1xuIyBUaGlzIGZpbGUgaXMgcGFydCBvZiBXaWtpIE1vbmtleS5cbiNcbiMgV2lraSBNb25rZXkgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuIyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuIyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuIyAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuI1xuIyBXaWtpIE1vbmtleSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuIyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuIyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4jIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4jXG4jIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4jIGFsb25nIHdpdGggV2lraSBNb25rZXkuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG5cbntQbHVnaW59ID0gcmVxdWlyZSgnLi9fUGx1Z2luJylcblxuXG5jbGFzcyBtb2R1bGUuZXhwb3J0cy5NdWx0aXBsZUxpbmVCcmVha3MgZXh0ZW5kcyBQbHVnaW5cbiAgICBAY29uZl9kZWZhdWx0OlxuICAgICAgICBlbmFibGVkOiB0cnVlXG4gICAgICAgIGVkaXRvcl9tZW51OiBbXCJUZXh0IHBsdWdpbnNcIiwgXCJTcXVhc2ggbXVsdGlwbGUgbGluZSBicmVha3NcIl1cblxuICAgIG1haW5fZWRpdG9yOiAoY2FsbE5leHQpIC0+XG4gICAgICAgIHNvdXJjZSA9IEBXTS5FZGl0b3IucmVhZFNvdXJjZSgpXG4gICAgICAgIG5ld3RleHQgPSBzb3VyY2VcblxuICAgICAgICBuZXd0ZXh0ID0gbmV3dGV4dC5yZXBsYWNlKC9bXFxuXXszLH0vZywgJ1xcblxcbicpXG5cbiAgICAgICAgaWYgbmV3dGV4dCAhPSBzb3VyY2VcbiAgICAgICAgICAgIEBXTS5FZGl0b3Iud3JpdGVTb3VyY2UobmV3dGV4dClcbiAgICAgICAgICAgIEBXTS5Mb2cubG9nSW5mbyhcIlJlbW92ZWQgbXVsdGlwbGUgbGluZSBicmVha3NcIilcblxuICAgICAgICBpZiBjYWxsTmV4dFxuICAgICAgICAgICAgY2FsbE5leHQoKVxuIiwiIyBXaWtpIE1vbmtleSAtIE1lZGlhV2lraSBib3QgYW5kIGVkaXRvci1hc3Npc3RhbnQgdXNlciBzY3JpcHRcbiMgQ29weXJpZ2h0IChDKSAyMDExIERhcmlvIEdpb3Zhbm5ldHRpIDxkZXZAZGFyaW9naW92YW5uZXR0aS5uZXQ+XG4jXG4jIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFdpa2kgTW9ua2V5LlxuI1xuIyBXaWtpIE1vbmtleSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4jIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4jIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4jIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4jXG4jIFdpa2kgTW9ua2V5IGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4jIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4jIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiMgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbiNcbiMgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiMgYWxvbmcgd2l0aCBXaWtpIE1vbmtleS4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cblxue1BsdWdpbn0gPSByZXF1aXJlKCcuL19QbHVnaW4nKVxuXG5DU1MgPSByZXF1aXJlKCdAa3luaWtvcy9taXNjL2Rpc3QvQ1NTJylcblxuXG5jbGFzcyBtb2R1bGUuZXhwb3J0cy5TaW1wbGVSZXBsYWNlIGV4dGVuZHMgUGx1Z2luXG4gICAgQGNvbmZfZGVmYXVsdDpcbiAgICAgICAgZW5hYmxlZDogdHJ1ZVxuICAgICAgICBlZGl0b3JfbWVudTogW1wiUmVnRXhwIHN1YnN0aXR1dGlvblwiXVxuICAgICAgICBib3RfbGFiZWw6IFwiUmVnRXhwIHN1YnN0aXR1dGlvblwiXG5cbiAgICBtYWtlVUkgPSAtPlxuICAgICAgICBDU1MuYWRkU3R5bGVFbGVtZW50KFwiI1dpa2lNb25rZXktU2ltcGxlUmVwbGFjZSBkaXYgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ7bWFyZ2luLWJvdHRvbTowLjMzZW07fSBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIjV2lraU1vbmtleS1TaW1wbGVSZXBsYWNlIGlucHV0W3R5cGU9J3RleHQnXSBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ7bWFyZ2luLWxlZnQ6MC4zM2VtOyB3aWR0aDo2MCU7fVwiKVxuXG4gICAgICAgIGRpdk1haW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgICAgICBkaXZNYWluLmlkID0gXCJXaWtpTW9ua2V5LVNpbXBsZVJlcGxhY2VcIlxuXG4gICAgICAgIHBhcjEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuXG4gICAgICAgIHJlZ2V4cExhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpXG4gICAgICAgIHJlZ2V4cExhYmVsLmlubmVySFRNTCA9ICdSZWdFeHAgcGF0dGVybjonXG5cbiAgICAgICAgcmVnZXhwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKVxuICAgICAgICByZWdleHAuc2V0QXR0cmlidXRlKCd0eXBlJywgJ3RleHQnKVxuICAgICAgICByZWdleHAuaWQgPSBcIldpa2lNb25rZXktU2ltcGxlUmVwbGFjZS1SZWdFeHBcIlxuXG4gICAgICAgIGlnbm9yZUNhc2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpXG4gICAgICAgIGlnbm9yZUNhc2Uuc2V0QXR0cmlidXRlKCd0eXBlJywgJ2NoZWNrYm94JylcbiAgICAgICAgaWdub3JlQ2FzZS5pZCA9IFwiV2lraU1vbmtleS1TaW1wbGVSZXBsYWNlLUlnbm9yZUNhc2VcIlxuXG4gICAgICAgIGlnbm9yZUNhc2VMYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKVxuICAgICAgICBpZ25vcmVDYXNlTGFiZWwuaW5uZXJIVE1MID0gJ2knXG5cbiAgICAgICAgcGFyMS5hcHBlbmRDaGlsZChyZWdleHBMYWJlbClcbiAgICAgICAgcGFyMS5hcHBlbmRDaGlsZChyZWdleHApXG4gICAgICAgIHBhcjEuYXBwZW5kQ2hpbGQoaWdub3JlQ2FzZSlcbiAgICAgICAgcGFyMS5hcHBlbmRDaGlsZChpZ25vcmVDYXNlTGFiZWwpXG5cbiAgICAgICAgcGFyMiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG5cbiAgICAgICAgbmV3U3RyaW5nTGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJylcbiAgICAgICAgbmV3U3RyaW5nTGFiZWwuaW5uZXJIVE1MID0gJ05ldyBzdHJpbmc6J1xuXG4gICAgICAgIG5ld1N0cmluZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0JylcbiAgICAgICAgbmV3U3RyaW5nLnNldEF0dHJpYnV0ZSgndHlwZScsICd0ZXh0JylcbiAgICAgICAgbmV3U3RyaW5nLmlkID0gXCJXaWtpTW9ua2V5LVNpbXBsZVJlcGxhY2UtTmV3U3RyaW5nXCJcblxuICAgICAgICBwYXIyLmFwcGVuZENoaWxkKG5ld1N0cmluZ0xhYmVsKVxuICAgICAgICBwYXIyLmFwcGVuZENoaWxkKG5ld1N0cmluZylcblxuICAgICAgICBkaXZNYWluLmFwcGVuZENoaWxkKHBhcjEpXG4gICAgICAgIGRpdk1haW4uYXBwZW5kQ2hpbGQocGFyMilcblxuICAgICAgICByZXR1cm4gZGl2TWFpblxuXG4gICAgbWFrZVVJOiAtPlxuICAgICAgICByZXR1cm4gbWFrZVVJKClcblxuICAgIG1ha2VCb3RVSTogLT5cbiAgICAgICAgZGl2TWFpbiA9IG1ha2VVSSgpXG4gICAgICAgIHBhcjMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuXG4gICAgICAgIHN1bW1hcnlMYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKVxuICAgICAgICBzdW1tYXJ5TGFiZWwuaW5uZXJIVE1MID0gJ0VkaXQgc3VtbWFyeTonXG5cbiAgICAgICAgc3VtbWFyeSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0JylcbiAgICAgICAgc3VtbWFyeS5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAndGV4dCcpXG4gICAgICAgIHN1bW1hcnkuaWQgPSBcIldpa2lNb25rZXktU2ltcGxlUmVwbGFjZS1TdW1tYXJ5XCJcblxuICAgICAgICBwYXIzLmFwcGVuZENoaWxkKHN1bW1hcnlMYWJlbClcbiAgICAgICAgcGFyMy5hcHBlbmRDaGlsZChzdW1tYXJ5KVxuXG4gICAgICAgIGRpdk1haW4uYXBwZW5kQ2hpbGQocGFyMylcblxuICAgICAgICByZXR1cm4gZGl2TWFpblxuXG4gICAgY29uZmlndXJhdGlvbiA9IG51bGxcblxuICAgIHN0b3JlQ29uZmlndXJhdGlvbjogPT5cbiAgICAgICAgY29uZmlndXJhdGlvbiA9XG4gICAgICAgICAgICBwYXR0ZXJuOiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJXaWtpTW9ua2V5LVNpbXBsZVJlcGxhY2UtUmVnRXhwXCIpLnZhbHVlXG4gICAgICAgICAgICBpZ25vcmVDYXNlOiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJXaWtpTW9ua2V5LVNpbXBsZVJlcGxhY2UtSWdub3JlQ2FzZVwiKS5jaGVja2VkXG4gICAgICAgICAgICBuZXdTdHJpbmc6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIldpa2lNb25rZXktU2ltcGxlUmVwbGFjZS1OZXdTdHJpbmdcIikudmFsdWVcblxuICAgICAgICBAV00uTG9nLmxvZ0hpZGRlbihcIlBhdHRlcm46IFwiICsgY29uZmlndXJhdGlvbi5wYXR0ZXJuKVxuICAgICAgICBAV00uTG9nLmxvZ0hpZGRlbihcIklnbm9yZSBjYXNlOiBcIiArIGNvbmZpZ3VyYXRpb24uaWdub3JlQ2FzZSlcbiAgICAgICAgQFdNLkxvZy5sb2dIaWRkZW4oXCJOZXcgc3RyaW5nOiBcIiArIGNvbmZpZ3VyYXRpb24ubmV3U3RyaW5nKVxuXG4gICAgc3RvcmVSZWdFeHAgPSAtPlxuICAgICAgICBjb25maWd1cmF0aW9uLnJlZ0V4cCA9IG5ldyBSZWdFeHAoY29uZmlndXJhdGlvbi5wYXR0ZXJuLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJnXCIgKyAoaWYgY29uZmlndXJhdGlvbi5pZ25vcmVDYXNlIHRoZW4gXCJpXCIgZWxzZSBcIlwiKSlcblxuICAgIG1haW5fZWRpdG9yOiAoY2FsbE5leHQpIC0+XG4gICAgICAgIEBzdG9yZUNvbmZpZ3VyYXRpb24oKVxuXG4gICAgICAgIHRyeVxuICAgICAgICAgICAgc3RvcmVSZWdFeHAoKVxuICAgICAgICBjYXRjaCBleGNcbiAgICAgICAgICAgIEBXTS5Mb2cubG9nRXJyb3IoXCJJbnZhbGlkIHBhdHRlcm46IFwiICsgZXhjKVxuICAgICAgICAgICAgIyBCbG9jayB0aGUgZXhlY3V0aW9uIG9mIHRoaXMgZnVuY3Rpb25cbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuXG4gICAgICAgIHNvdXJjZSA9IEBXTS5FZGl0b3IucmVhZFNvdXJjZSgpXG4gICAgICAgIG5ld3RleHQgPSBzb3VyY2UucmVwbGFjZShjb25maWd1cmF0aW9uLnJlZ0V4cCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWd1cmF0aW9uLm5ld1N0cmluZylcblxuICAgICAgICBpZiBuZXd0ZXh0ICE9IHNvdXJjZVxuICAgICAgICAgICAgQFdNLkVkaXRvci53cml0ZVNvdXJjZShuZXd0ZXh0KVxuICAgICAgICAgICAgQFdNLkxvZy5sb2dJbmZvKFwiVGV4dCBzdWJzdGl0dXRlZFwiKVxuXG4gICAgICAgIGlmIGNhbGxOZXh0XG4gICAgICAgICAgICBjYWxsTmV4dCgpXG5cbiAgICBtYWluX2JvdDogKHRpdGxlLCBjYWxsQm90LCBjaGFpbkFyZ3MpIC0+XG4gICAgICAgIEBzdG9yZUNvbmZpZ3VyYXRpb24oKVxuXG4gICAgICAgIHRyeVxuICAgICAgICAgICAgc3RvcmVSZWdFeHAoKVxuICAgICAgICBjYXRjaCBleGNcbiAgICAgICAgICAgIEBXTS5Mb2cubG9nRXJyb3IoXCJJbnZhbGlkIHBhdHRlcm46IFwiICsgZXhjKVxuICAgICAgICAgICAgY2FsbEJvdChmYWxzZSwgbnVsbClcbiAgICAgICAgICAgICMgQmxvY2sgdGhlIGV4ZWN1dGlvbiBvZiB0aGlzIGZ1bmN0aW9uXG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcblxuICAgICAgICBzdW1tYXJ5ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIldpa2lNb25rZXktU2ltcGxlUmVwbGFjZS1TdW1tYXJ5XCIpLnZhbHVlXG5cbiAgICAgICAgaWYgc3VtbWFyeSAhPSBcIlwiXG4gICAgICAgICAgICBAV00uTVcuY2FsbFF1ZXJ5RWRpdCh0aXRsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQG1haW5BdXRvV3JpdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtzdW1tYXJ5LCBjYWxsQm90XSlcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgQFdNLkxvZy5sb2dFcnJvcihcIlRoZSBlZGl0IHN1bW1hcnkgY2Fubm90IGJlIGVtcHR5XCIpXG4gICAgICAgICAgICBjYWxsQm90KGZhbHNlLCBudWxsKVxuXG4gICAgbWFpbkF1dG9Xcml0ZTogKHRpdGxlLCBzb3VyY2UsIHRpbWVzdGFtcCwgZWRpdHRva2VuLCBhcmdzKSA9PlxuICAgICAgICBzdW1tYXJ5ID0gYXJnc1swXVxuICAgICAgICBjYWxsQm90ID0gYXJnc1sxXVxuXG4gICAgICAgIG5ld3RleHQgPSBzb3VyY2UucmVwbGFjZShjb25maWd1cmF0aW9uLnJlZ0V4cCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWd1cmF0aW9uLm5ld1N0cmluZylcblxuICAgICAgICBpZiBuZXd0ZXh0ICE9IHNvdXJjZVxuICAgICAgICAgICAgQFdNLk1XLmNhbGxBUElQb3N0KHthY3Rpb246IFwiZWRpdFwiLCBib3Q6IFwiMVwiLCB0aXRsZTogdGl0bGUsIHN1bW1hcnk6IHN1bW1hcnksIHRleHQ6IG5ld3RleHQsIGJhc2V0aW1lc3RhbXA6IHRpbWVzdGFtcCwgdG9rZW46IGVkaXR0b2tlbn0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQG1haW5BdXRvRW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxCb3QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVsbClcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgY2FsbEJvdCgwLCBudWxsKVxuXG4gICAgbWFpbkF1dG9FbmQ6IChyZXMsIGNhbGxCb3QpID0+XG4gICAgICAgIGlmIHJlcy5lZGl0IGFuZCByZXMuZWRpdC5yZXN1bHQgPT0gJ1N1Y2Nlc3MnXG4gICAgICAgICAgICBjYWxsQm90KDEsIG51bGwpXG4gICAgICAgIGVsc2UgaWYgcmVzLmVycm9yXG4gICAgICAgICAgICBAV00uTG9nLmxvZ0Vycm9yKHJlcy5lcnJvci5pbmZvICsgXCIgKFwiICsgcmVzLmVycm9yLmNvZGUgKyBcIilcIilcbiAgICAgICAgICAgIGNhbGxCb3QocmVzLmVycm9yLmNvZGUsIG51bGwpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGNhbGxCb3QoZmFsc2UsIG51bGwpXG4iLCIjIFdpa2kgTW9ua2V5IC0gTWVkaWFXaWtpIGJvdCBhbmQgZWRpdG9yLWFzc2lzdGFudCB1c2VyIHNjcmlwdFxuIyBDb3B5cmlnaHQgKEMpIDIwMTEgRGFyaW8gR2lvdmFubmV0dGkgPGRldkBkYXJpb2dpb3Zhbm5ldHRpLm5ldD5cbiNcbiMgVGhpcyBmaWxlIGlzIHBhcnQgb2YgV2lraSBNb25rZXkuXG4jXG4jIFdpa2kgTW9ua2V5IGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiMgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiMgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiMgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbiNcbiMgV2lraSBNb25rZXkgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiMgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiMgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuIyBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuI1xuIyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuIyBhbG9uZyB3aXRoIFdpa2kgTW9ua2V5LiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuXG57UGx1Z2lufSA9IHJlcXVpcmUoJy4vX1BsdWdpbicpXG5cblxuY2xhc3MgbW9kdWxlLmV4cG9ydHMuU3luY2hyb25pemVJbnRlcmxhbmd1YWdlTGlua3MgZXh0ZW5kcyBQbHVnaW5cbiAgICBAY29uZl9kZWZhdWx0OlxuICAgICAgICBlbmFibGVkOiB0cnVlXG4gICAgICAgIGVkaXRvcl9tZW51OiBbXCJRdWVyeSBwbHVnaW5zXCIsIFwiU3luYyBpbnRlcmxhbmd1YWdlIGxpbmtzXCJdXG4gICAgICAgIGJvdF9sYWJlbDogXCJTeW5jaHJvbml6ZSBpbnRlcmxhbmd1YWdlIGxpbmtzXCJcbiAgICAgICAgbGFuZ3VhZ2VfdGFnOiBcImVuXCJcbiAgICAgICAgdGFnX3doaXRlbGlzdDogW1wiZW5cIl1cbiAgICAgICAgc3VwcG9ydGVkX3RhZ3M6IFtcImVuXCJdXG4gICAgICAgIGVkaXRfc3VtbWFyeTogXCJzeW5jaHJvbml6ZWQgaW50ZXJsYW5ndWFnZSBsaW5rcyB3aXRoIHRoZSBvdGhlciB3aWtpc1wiXG4gICAgQHdpa2lfdG9fY29uZl9kZWZhdWx0OlxuICAgICAgICBBcmNoV2lraTpcbiAgICAgICAgICAgIGxhbmd1YWdlX3RhZzogXCJBcmNoV2lraVwiXG4gICAgICAgICAgICB0YWdfd2hpdGVsaXN0OiBcIkFyY2hXaWtpXCJcbiAgICAgICAgICAgIHN1cHBvcnRlZF90YWdzOiBcIkFyY2hXaWtpXCJcbiAgICAgICAgV2lraXBlZGlhOlxuICAgICAgICAgICAgZW5hYmxlZDogZmFsc2VcblxuICAgIGRldGVjdExhbmc6ICh0aXRsZSwgdGFnKSA9PlxuICAgICAgICAjIFdpdGhvdXQgdGhpcyBjaGVjayB0aGlzIHBsdWdpbiB3b3VsZCBiZSBzcGVjaWZpYyB0byBBcmNoV2lraVxuICAgICAgICBpZiB0YWcgPT0gXCJBcmNoV2lraVwiXG4gICAgICAgICAgICBkZXRlY3QgPSBAV00uQXJjaFdpa2kuZGV0ZWN0TGFuZ3VhZ2UodGl0bGUpXG4gICAgICAgICAgICBwdXJlVGl0bGUgPSBkZXRlY3RbMF1cbiAgICAgICAgICAgIHRhZyA9IEBXTS5BcmNoV2lraS5nZXRJbnRlcmxhbmd1YWdlVGFnKGRldGVjdFsxXSlcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcHVyZVRpdGxlID0gdGl0bGVcblxuICAgICAgICByZXR1cm4gW3B1cmVUaXRsZSwgdGFnXVxuXG4gICAgY29tcHV0ZVdoaXRlTGlzdDogKHdoaXRlbGlzdCkgPT5cbiAgICAgICAgIyBXaXRob3V0IHRoaXMgY2hlY2sgdGhpcyBwbHVnaW4gd291bGQgYmUgc3BlY2lmaWMgdG8gQXJjaFdpa2lcbiAgICAgICAgaWYgd2hpdGVsaXN0ID09IFwiQXJjaFdpa2lcIlxuICAgICAgICAgICAgcmV0dXJuIEBXTS5BcmNoV2lraS5nZXRJbnRlcm5hbEludGVyd2lraUxhbmd1YWdlcygpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiB3aGl0ZWxpc3RcblxuICAgIGNvbXB1dGVTdXBwb3J0ZWRMYW5nczogKHN1cHBvcnRlZExhbmdzKSA9PlxuICAgICAgICAjIFdpdGhvdXQgdGhpcyBjaGVjayB0aGlzIHBsdWdpbiB3b3VsZCBiZSBzcGVjaWZpYyB0byBBcmNoV2lraVxuICAgICAgICBpZiBzdXBwb3J0ZWRMYW5ncyA9PSBcIkFyY2hXaWtpXCJcbiAgICAgICAgICAgIHJldHVybiBAV00uQXJjaFdpa2kuZ2V0SW50ZXJ3aWtpTGFuZ3VhZ2VzKClcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIHN1cHBvcnRlZExhbmdzXG5cbiAgICBtYWluX2VkaXRvcjogKGNhbGxOZXh0KSAtPlxuICAgICAgICB0aXRsZSA9IEBXTS5FZGl0b3IuZ2V0VGl0bGUoKVxuXG4gICAgICAgIGRldGVjdCA9IEBkZXRlY3RMYW5nKHRpdGxlLCBAY29uZi5sYW5ndWFnZV90YWcpXG4gICAgICAgIHB1cmVUaXRsZSA9IGRldGVjdFswXVxuICAgICAgICB0YWcgPSBkZXRlY3RbMV1cblxuICAgICAgICB3aGl0ZWxpc3QgPSBAY29tcHV0ZVdoaXRlTGlzdChAY29uZi50YWdfd2hpdGVsaXN0KVxuICAgICAgICBzdXBwb3J0ZWRMYW5ncyA9IEBjb21wdXRlU3VwcG9ydGVkTGFuZ3MoQGNvbmYuc3VwcG9ydGVkX3RhZ3MpXG5cbiAgICAgICAgQFdNLkxvZy5sb2dJbmZvKFwiU3luY2hyb25pemluZyBpbnRlcmxhbmd1YWdlIGxpbmtzIC4uLlwiKVxuXG4gICAgICAgIEBXTS5NVy5nZXRMb2NhbEludGVyd2lraU1hcChcbiAgICAgICAgICAgIHRpdGxlLFxuICAgICAgICAgICAgQG1haW5Db250aW51ZSxcbiAgICAgICAgICAgIFt0YWcsIHB1cmVUaXRsZSwgc3VwcG9ydGVkTGFuZ3MsIHdoaXRlbGlzdCwgdGl0bGUsIGNhbGxOZXh0XVxuICAgICAgICApXG5cbiAgICBtYWluQ29udGludWU6IChpd21hcCwgYXJncykgPT5cbiAgICAgICAgdGFnID0gYXJnc1swXVxuICAgICAgICBwdXJlVGl0bGUgPSBhcmdzWzFdXG4gICAgICAgIHN1cHBvcnRlZExhbmdzID0gYXJnc1syXVxuICAgICAgICB3aGl0ZWxpc3QgPSBhcmdzWzNdXG4gICAgICAgIHRpdGxlID0gYXJnc1s0XVxuICAgICAgICBjYWxsTmV4dCA9IGFyZ3NbNV1cblxuICAgICAgICBzb3VyY2UgPSBAV00uRWRpdG9yLnJlYWRTb3VyY2UoKVxuXG4gICAgICAgIGxhbmdsaW5rcyA9IEBXTS5JbnRlcmxhbmd1YWdlLnBhcnNlTGlua3Moc3VwcG9ydGVkTGFuZ3MsIHNvdXJjZSwgaXdtYXApXG5cbiAgICAgICAgd2lraVVybHMgPSBAV00uTVcuZ2V0V2lraVVybHMoKVxuICAgICAgICB1cmwgPSB3aWtpVXJscy5zaG9ydCArIGVuY29kZVVSSUNvbXBvbmVudChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQFdNLlBhcnNlci5zcXVhc2hDb250aWd1b3VzV2hpdGVzcGFjZSh0aXRsZSkpXG5cbiAgICAgICAgdmlzaXRlZGxpbmtzID0ge31cbiAgICAgICAgdmlzaXRlZGxpbmtzW3RhZy50b0xvd2VyQ2FzZSgpXSA9IEBXTS5JbnRlcmxhbmd1YWdlLmNyZWF0ZVZpc2l0ZWRMaW5rKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWcsIHB1cmVUaXRsZSwgdXJsLCBpd21hcCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlLCBudWxsLCBudWxsLCBsYW5nbGlua3MpXG5cbiAgICAgICAgbmV3bGlua3MgPSB7fVxuXG4gICAgICAgIEBXTS5Mb2cubG9nSW5mbyhcIlJlYWRpbmcgXCIgKyBAV00uTG9nLmxpbmtUb1BhZ2UodXJsLCBcImVkaXRlZCBhcnRpY2xlXCIpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgLi4uXCIpXG5cbiAgICAgICAgaWYgbGFuZ2xpbmtzXG4gICAgICAgICAgICBmb3IgbGluayBpbiBsYW5nbGlua3NcbiAgICAgICAgICAgICAgICBubGluayA9IG5ld2xpbmtzW2xpbmsubGFuZy50b0xvd2VyQ2FzZSgpXVxuICAgICAgICAgICAgICAgIHZsaW5rID0gdmlzaXRlZGxpbmtzW2xpbmsubGFuZy50b0xvd2VyQ2FzZSgpXVxuXG4gICAgICAgICAgICAgICAgaWYgbm90IHZsaW5rIGFuZCBub3QgbmxpbmtcbiAgICAgICAgICAgICAgICAgICAgbmV3bGlua3NbbGluay5sYW5nLnRvTG93ZXJDYXNlKCldID0gQFdNLkludGVybGFuZ3VhZ2UuY3JlYXRlTmV3TGluayhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluay5sYW5nLCBsaW5rLnRpdGxlLCBsaW5rLnVybClcbiAgICAgICAgICAgICAgICBlbHNlIGlmIHZsaW5rIGFuZCB2bGluay51cmwgIT0gbGluay51cmxcbiAgICAgICAgICAgICAgICAgICAgIyBKdXN0IGlnbm9yZSBhbnkgY29uZmxpY3RpbmcgbGlua3MgYW5kIHdhcm4gdGhlIHVzZXI6XG4gICAgICAgICAgICAgICAgICAgICMgaWYgaXQncyBhIHJlYWwgY29uZmxpY3QsIHRoZSB1c2VyIHdpbGwgaW52ZXN0aWdhdGUgaXQsXG4gICAgICAgICAgICAgICAgICAgICMgb3RoZXJ3aXNlIHRoZSB1c2VyIHdpbGwgaWdub3JlIGl0XG4gICAgICAgICAgICAgICAgICAgIEBXTS5Mb2cubG9nV2FybmluZyhcIlBvc3NpYmx5IGNvbmZsaWN0aW5nIGludGVybGFuZ3VhZ2UgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJsaW5rczogXCIgKyBAV00uTG9nLmxpbmtUb1BhZ2UobGluay51cmwsIFwiW1tcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rLmxhbmcgKyBcIjpcIiArIGxpbmsudGl0bGUgKyBcIl1dXCIpICsgXCIgYW5kIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIEBXTS5Mb2cubGlua1RvUGFnZSh2bGluay51cmwsIFwiW1tcIiArIGxpbmsubGFuZyArIFwiOlwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpc2l0ZWRsaW5rc1tsaW5rLmxhbmcudG9Mb3dlckNhc2UoKV0udGl0bGUgKyBcIl1dXCIpKVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgbmxpbmsgYW5kIG5saW5rLnVybCAhPSBsaW5rLnVybFxuICAgICAgICAgICAgICAgICAgICAjIEp1c3QgaWdub3JlIGFueSBjb25mbGljdGluZyBsaW5rcyBhbmQgd2FybiB0aGUgdXNlcjpcbiAgICAgICAgICAgICAgICAgICAgIyBpZiBpdCdzIGEgcmVhbCBjb25mbGljdCwgdGhlIHVzZXIgd2lsbCBpbnZlc3RpZ2F0ZSBpdCxcbiAgICAgICAgICAgICAgICAgICAgIyBvdGhlcndpc2UgdGhlIHVzZXIgd2lsbCBpZ25vcmUgaXRcbiAgICAgICAgICAgICAgICAgICAgQFdNLkxvZy5sb2dXYXJuaW5nKFwiUG9zc2libHkgY29uZmxpY3RpbmcgaW50ZXJsYW5ndWFnZSBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICBcImxpbmtzOiBcIiArIEBXTS5Mb2cubGlua1RvUGFnZShsaW5rLnVybCwgXCJbW1wiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmsubGFuZyArIFwiOlwiICsgbGluay50aXRsZSArIFwiXV1cIikgKyBcIiBhbmQgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgQFdNLkxvZy5saW5rVG9QYWdlKG5saW5rLnVybCwgXCJbW1wiICsgbGluay5sYW5nICsgXCI6XCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3bGlua3NbbGluay5sYW5nLnRvTG93ZXJDYXNlKCldLnRpdGxlICsgXCJdXVwiKSlcblxuICAgICAgICAgICAgQFdNLkludGVybGFuZ3VhZ2UuY29sbGVjdExpbmtzKFxuICAgICAgICAgICAgICAgIHZpc2l0ZWRsaW5rcyxcbiAgICAgICAgICAgICAgICBuZXdsaW5rcyxcbiAgICAgICAgICAgICAgICBzdXBwb3J0ZWRMYW5ncyxcbiAgICAgICAgICAgICAgICB3aGl0ZWxpc3QsXG4gICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgQG1haW5FbmQsXG4gICAgICAgICAgICAgICAgW3RhZywgdXJsLCBzb3VyY2UsIGxhbmdsaW5rcywgaXdtYXAsIGNhbGxOZXh0XVxuICAgICAgICAgICAgKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICBAV00uTG9nLmxvZ0luZm8oXCJObyBpbnRlcmxhbmd1YWdlIGxpbmtzIGZvdW5kXCIpXG5cbiAgICAgICAgICAgIGlmIGNhbGxOZXh0XG4gICAgICAgICAgICAgICAgY2FsbE5leHQoKVxuXG4gICAgbWFpbkVuZDogKGxpbmtzLCBhcmdzKSA9PlxuICAgICAgICB0YWcgPSBhcmdzWzBdXG4gICAgICAgIHVybCA9IGFyZ3NbMV1cbiAgICAgICAgc291cmNlID0gYXJnc1syXVxuICAgICAgICBsYW5nbGlua3MgPSBhcmdzWzNdXG4gICAgICAgIGl3bWFwID0gYXJnc1s0XVxuICAgICAgICBjYWxsTmV4dCA9IGFyZ3NbNV1cblxuICAgICAgICBuZXdUZXh0ID0gQFdNLkludGVybGFuZ3VhZ2UudXBkYXRlTGlua3ModGFnLCB1cmwsIGl3bWFwLCBzb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYW5nbGlua3MsIGxpbmtzKVxuXG4gICAgICAgIGlmIG5ld1RleHQgIT0gc291cmNlXG4gICAgICAgICAgICBAV00uRWRpdG9yLndyaXRlU291cmNlKG5ld1RleHQpXG4gICAgICAgICAgICBAV00uTG9nLmxvZ0luZm8oXCJTeW5jaHJvbml6ZWQgaW50ZXJsYW5ndWFnZSBsaW5rc1wiKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICBAV00uTG9nLmxvZ0luZm8oXCJJbnRlcmxhbmd1YWdlIGxpbmtzIHdlcmUgYWxyZWFkeSBzeW5jaHJvbml6ZWRcIilcblxuICAgICAgICBpZiBjYWxsTmV4dFxuICAgICAgICAgICAgY2FsbE5leHQoKVxuXG4gICAgbWFpbl9ib3Q6ICh0aXRsZSwgY2FsbEJvdCwgY2hhaW5BcmdzKSAtPlxuICAgICAgICBkZXRlY3QgPSBAZGV0ZWN0TGFuZyh0aXRsZSwgQGNvbmYubGFuZ3VhZ2VfdGFnKVxuICAgICAgICBwdXJlVGl0bGUgPSBkZXRlY3RbMF1cbiAgICAgICAgdGFnID0gZGV0ZWN0WzFdXG5cbiAgICAgICAgd2hpdGVsaXN0ID0gQGNvbXB1dGVXaGl0ZUxpc3QoQGNvbmYudGFnX3doaXRlbGlzdClcbiAgICAgICAgc3VwcG9ydGVkTGFuZ3MgPSBAY29tcHV0ZVN1cHBvcnRlZExhbmdzKEBjb25mLnN1cHBvcnRlZF90YWdzKVxuXG4gICAgICAgIHN1bW1hcnkgPSBAY29uZi5lZGl0X3N1bW1hcnlcblxuICAgICAgICB3aWtpVXJscyA9IEBXTS5NVy5nZXRXaWtpVXJscygpXG4gICAgICAgIHVybCA9IHdpa2lVcmxzLnNob3J0ICsgZW5jb2RlVVJJQ29tcG9uZW50KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBAV00uUGFyc2VyLnNxdWFzaENvbnRpZ3VvdXNXaGl0ZXNwYWNlKHRpdGxlKSlcblxuICAgICAgICB2aXNpdGVkbGlua3MgPSB7fVxuXG4gICAgICAgIG5ld2xpbmtzID0ge31cbiAgICAgICAgbmV3bGlua3NbdGFnLnRvTG93ZXJDYXNlKCldID0gQFdNLkludGVybGFuZ3VhZ2UuY3JlYXRlTmV3TGluayh0YWcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdXJlVGl0bGUsIHVybClcblxuICAgICAgICBAV00uSW50ZXJsYW5ndWFnZS5jb2xsZWN0TGlua3MoXG4gICAgICAgICAgICB2aXNpdGVkbGlua3MsXG4gICAgICAgICAgICBuZXdsaW5rcyxcbiAgICAgICAgICAgIHN1cHBvcnRlZExhbmdzLFxuICAgICAgICAgICAgd2hpdGVsaXN0LFxuICAgICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgIEBtYWluQXV0b1dyaXRlLFxuICAgICAgICAgICAgW3RpdGxlLCB1cmwsIHRhZywgc3VtbWFyeSwgY2FsbEJvdF1cbiAgICAgICAgKVxuXG4gICAgbWFpbkF1dG9Xcml0ZTogKGxpbmtzLCBhcmdzKSA9PlxuICAgICAgICB0aXRsZSA9IGFyZ3NbMF1cbiAgICAgICAgdXJsID0gYXJnc1sxXVxuICAgICAgICB0YWcgPSBhcmdzWzJdXG4gICAgICAgIHN1bW1hcnkgPSBhcmdzWzNdXG4gICAgICAgIGNhbGxCb3QgPSBhcmdzWzRdXG5cbiAgICAgICAgbGNUYWcgPSB0YWcudG9Mb3dlckNhc2UoKVxuICAgICAgICAjIE5ldyBsaW5rcyB0aGF0IHdlcmUgbm90IGluIHRoZSB3aGl0ZSBsaXN0IHdpbGwgaGF2ZSB0aGUgXCJpd21hcFwiXG4gICAgICAgICMgYXR0cmlidXRlIGZhbHNlLCBcInRpbWVzdGFtcFwiIGFuZCBcImVkaXR0b2tlblwiIG51bGwgYW5kIFwibGlua3NcIiBhcyBhblxuICAgICAgICAjIGVtcHR5IGFycmF5LCBob3dldmVyIGxpbmtzW2xjVGFnXSBzaG91bGQgYWx3YXlzIGJlIHNhZmVcbiAgICAgICAgaXdtYXAgPSBsaW5rc1tsY1RhZ10uaXdtYXBcbiAgICAgICAgc291cmNlID0gbGlua3NbbGNUYWddLnNvdXJjZVxuICAgICAgICBsYW5nbGlua3MgPSBsaW5rc1tsY1RhZ10ubGlua3NcbiAgICAgICAgdGltZXN0YW1wID0gbGlua3NbbGNUYWddLnRpbWVzdGFtcFxuICAgICAgICBlZGl0dG9rZW4gPSBsaW5rc1tsY1RhZ10uZWRpdHRva2VuXG5cbiAgICAgICAgbmV3VGV4dCA9IEBXTS5JbnRlcmxhbmd1YWdlLnVwZGF0ZUxpbmtzKHRhZywgdXJsLCBpd21hcCwgc291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFuZ2xpbmtzLCBsaW5rcylcblxuICAgICAgICBpZiBuZXdUZXh0ICE9IHNvdXJjZVxuICAgICAgICAgICAgQFdNLk1XLmNhbGxBUElQb3N0KHtcbiAgICAgICAgICAgICAgICAgYWN0aW9uOiBcImVkaXRcIlxuICAgICAgICAgICAgICAgICBib3Q6IFwiMVwiXG4gICAgICAgICAgICAgICAgIHRpdGxlOiB0aXRsZVxuICAgICAgICAgICAgICAgICBzdW1tYXJ5OiBzdW1tYXJ5XG4gICAgICAgICAgICAgICAgIHRleHQ6IG5ld1RleHRcbiAgICAgICAgICAgICAgICAgYmFzZXRpbWVzdGFtcDogdGltZXN0YW1wXG4gICAgICAgICAgICAgICAgIHRva2VuOiBlZGl0dG9rZW5cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIEBtYWluQXV0b0VuZCxcbiAgICAgICAgICAgICAgICBjYWxsQm90LFxuICAgICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgIClcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgY2FsbEJvdCgwLCBudWxsKVxuXG4gICAgbWFpbkF1dG9FbmQ6IChyZXMsIGNhbGxCb3QpID0+XG4gICAgICAgIGlmIHJlcy5lZGl0IGFuZCByZXMuZWRpdC5yZXN1bHQgPT0gJ1N1Y2Nlc3MnXG4gICAgICAgICAgICBjYWxsQm90KDEsIG51bGwpXG4gICAgICAgIGVsc2UgaWYgcmVzLmVycm9yXG4gICAgICAgICAgICBAV00uTG9nLmxvZ0Vycm9yKHJlcy5lcnJvci5pbmZvICsgXCIgKFwiICsgcmVzLmVycm9yLmNvZGUgKyBcIilcIilcbiAgICAgICAgICAgIGNhbGxCb3QocmVzLmVycm9yLmNvZGUsIG51bGwpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGNhbGxCb3QoZmFsc2UsIG51bGwpXG4iLCIjIFdpa2kgTW9ua2V5IC0gTWVkaWFXaWtpIGJvdCBhbmQgZWRpdG9yLWFzc2lzdGFudCB1c2VyIHNjcmlwdFxuIyBDb3B5cmlnaHQgKEMpIDIwMTEgRGFyaW8gR2lvdmFubmV0dGkgPGRldkBkYXJpb2dpb3Zhbm5ldHRpLm5ldD5cbiNcbiMgVGhpcyBmaWxlIGlzIHBhcnQgb2YgV2lraSBNb25rZXkuXG4jXG4jIFdpa2kgTW9ua2V5IGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiMgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiMgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiMgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbiNcbiMgV2lraSBNb25rZXkgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiMgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiMgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuIyBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuI1xuIyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuIyBhbG9uZyB3aXRoIFdpa2kgTW9ua2V5LiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuXG57UGx1Z2lufSA9IHJlcXVpcmUoJy4vX1BsdWdpbicpXG5cblN0ciA9IHJlcXVpcmUoJ0BreW5pa29zL21pc2MvZGlzdC9TdHInKVxuXG5cbmNsYXNzIG1vZHVsZS5leHBvcnRzLlVwZGF0ZUNhdGVnb3J5VHJlZSBleHRlbmRzIFBsdWdpblxuICAgIEBjb25mX2RlZmF1bHQ6XG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlXG4gICAgICAgIHNwZWNpYWxfbWVudTogW1wiVXBkYXRlIGNhdGVnb3J5IHRyZWVzXCJdXG4gICAgICAgIGVkaXRfc3VtbWFyeTogXCJhdXRvbWF0aWMgdXBkYXRlXCJcbiAgICAgICAgc2hvd19yb290X2Fsc29faW46IGZhbHNlXG4gICAgICAgIHBhZ2VzOiBbXVxuICAgIEB3aWtpX3RvX2NvbmZfZGVmYXVsdDpcbiAgICAgICAgQXJjaFdpa2k6XG4gICAgICAgICAgICBwYWdlczogW1wiYXJcIiwgXCJjc1wiLCBcImNzXCIsIFwiZGFcIiwgXCJlbFwiLCBcImVuXCIsIFwiZXNcIiwgXCJoZVwiLCBcImhyXCIsIFwiaHVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJpZFwiLCBcIml0XCIsIFwia29cIiwgXCJsdFwiLCBcIm5sXCIsIFwicGxcIiwgXCJwdFwiLCBcInJ1XCIsIFwic2tcIiwgXCJzclwiLFxuICAgICAgICAgICAgICAgICAgICBcInRoXCIsIFwidHJcIiwgXCJ1a1wiLCBcInpoLWhhbnNcIiwgXCJ6aC1oYW50XCJdXG4gICAgICAgIFdpa2lwZWRpYToge31cblxuICAgIG1haW5fc3BlY2lhbDogKGNhbGxOZXh0KSAtPlxuICAgICAgICBAaXRlcmF0ZVBhZ2VzKC0xLCBjYWxsTmV4dClcblxuICAgIGl0ZXJhdGVQYWdlczogKHBhZ2VpZCwgY2FsbE5leHQpIC0+XG4gICAgICAgIHBhZ2VpZCsrXG4gICAgICAgIHN1bW1hcnkgPSBAY29uZi5lZGl0X3N1bW1hcnlcbiAgICAgICAgc2hvd1Jvb3RBbHNvSW4gPSBAY29uZi5zaG93X3Jvb3RfYWxzb19pblxuICAgICAgICBwY29uZiA9IEBjb25mLnBhZ2VzW3BhZ2VpZF1cbiAgICAgICAgaWYgcGNvbmZcbiAgICAgICAgICAgIGlmICQudHlwZShwY29uZikgaXMgXCJzdHJpbmdcIlxuICAgICAgICAgICAgICAgIHBhcmFtcyA9IEBXTS5BcmNoV2lraS5nZXRUYWJsZU9mQ29udGVudHMocGNvbmYpXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgIyBUaGlzIHNob3VsZCBiZSBhIGN1c3RvbSBjb25maWd1cmF0aW9uIG9iamVjdFxuICAgICAgICAgICAgICAgIHBhcmFtcyA9IHBjb25mXG5cbiAgICAgICAgICAgIEBXTS5NVy5pc1VzZXJCb3QodGhpcy5tYWluQ29udGludWUsIFtwYXJhbXMsIHNob3dSb290QWxzb0luLCBzdW1tYXJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxOZXh0LCBwYWdlaWRdKVxuXG4gICAgICAgIGVsc2UgaWYgY2FsbE5leHRcbiAgICAgICAgICAgIGNhbGxOZXh0KClcblxuICAgIG1haW5Db250aW51ZTogKGJvdFRlc3QsIGFyZ3MpID0+XG4gICAgICAgIEByZWFkVG9DKHtcbiAgICAgICAgICAgIHBhcmFtczogYXJnc1swXVxuICAgICAgICAgICAgbWluSW50ZXJ2YWw6IGlmIGJvdFRlc3QgdGhlbiA2MDAwMCBlbHNlIDIxNjAwMDAwXG4gICAgICAgICAgICBlZGl0dG9rZW46IFwiXCJcbiAgICAgICAgICAgIHRpbWVzdGFtcDogXCJcIlxuICAgICAgICAgICAgc291cmNlOiBcIlwiXG4gICAgICAgICAgICBzdGFydElkOiAwXG4gICAgICAgICAgICBlbmRJZDogMFxuICAgICAgICAgICAgdHJlZVRleHQ6IFwiXCJcbiAgICAgICAgICAgIHN0YXJ0TWFyazogXCJTVEFSVCBBVVRPIFRPQyAtIERPIE5PVCBSRU1PVkUgT1IgTU9ESUZZIFRISVMgTUFSSy0tPlwiXG4gICAgICAgICAgICBlbmRNYXJrOiBcIjwhLS1FTkQgQVVUTyBUT0MgLSBETyBOT1QgUkVNT1ZFIE9SIE1PRElGWSBUSElTIE1BUktcIlxuICAgICAgICAgICAgYWx0TmFtZXM6IHt9XG4gICAgICAgICAgICBzaG93Um9vdEFsc29JbjogYXJnc1sxXVxuICAgICAgICAgICAgc3VtbWFyeTogYXJnc1syXVxuICAgICAgICAgICAgY2FsbE5leHQ6IGFyZ3NbM11cbiAgICAgICAgICAgIHBhZ2VpZDogYXJnc1s0XVxuICAgICAgICB9KVxuXG4gICAgcmVhZFRvQzogKGFyZ3MpID0+XG4gICAgICAgIEBXTS5Mb2cubG9nSW5mbygnVXBkYXRpbmcgJyArIEBXTS5Mb2cubGlua1RvV2lraVBhZ2UoYXJncy5wYXJhbXMucGFnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MucGFyYW1zLnBhZ2UpICsgXCIgLi4uXCIpXG4gICAgICAgIEBXTS5NVy5jYWxsUXVlcnlFZGl0KGFyZ3MucGFyYW1zLnBhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQHByb2Nlc3NUb0MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJncylcblxuICAgIHByb2Nlc3NUb0M6ICh0aXRsZSwgc291cmNlLCB0aW1lc3RhbXAsIGVkaXR0b2tlbiwgYXJncykgPT5cbiAgICAgICAgYXJncy5zb3VyY2UgPSBzb3VyY2VcbiAgICAgICAgYXJncy50aW1lc3RhbXAgPSB0aW1lc3RhbXBcbiAgICAgICAgYXJncy5lZGl0dG9rZW4gPSBlZGl0dG9rZW5cblxuICAgICAgICBub3cgPSBuZXcgRGF0ZSgpXG4gICAgICAgIG1zVGltZXN0YW1wID0gRGF0ZS5wYXJzZShhcmdzLnRpbWVzdGFtcClcbiAgICAgICAgaWYgbm93LmdldFRpbWUoKSAtIG1zVGltZXN0YW1wID49IGFyZ3MubWluSW50ZXJ2YWxcbiAgICAgICAgICAgIHN0YXJ0ID0gYXJncy5zb3VyY2UuaW5kZXhPZihhcmdzLnN0YXJ0TWFyaylcbiAgICAgICAgICAgIGVuZCA9IGFyZ3Muc291cmNlLmxhc3RJbmRleE9mKGFyZ3MuZW5kTWFyaylcblxuICAgICAgICAgICAgaWYgc3RhcnQgPiAtMSBhbmQgZW5kID4gLTFcbiAgICAgICAgICAgICAgICBhcmdzLnN0YXJ0SWQgPSBzdGFydCArIGFyZ3Muc3RhcnRNYXJrLmxlbmd0aFxuICAgICAgICAgICAgICAgIGFyZ3MuZW5kSWQgPSBlbmRcbiAgICAgICAgICAgICAgICBhcmdzLnRyZWVUZXh0ID0gXCJcIlxuICAgICAgICAgICAgICAgIGFyZ3MuYWx0TmFtZXMgPSBpZiBhcmdzLnBhcmFtcy5rZWVwQWx0TmFtZSB0aGVuIEBzdG9yZUFsdGVybmF0aXZlTmFtZXMoYXJncy5zb3VyY2UpIGVsc2Uge31cbiAgICAgICAgICAgICAgICBAV00uQ2F0LnJlY3Vyc2VUcmVlKHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZTogYXJncy5wYXJhbXMucm9vdCxcbiAgICAgICAgICAgICAgICAgICAgY2FsbE5vZGU6IEBwcm9jZXNzQ2F0ZWdvcnksXG4gICAgICAgICAgICAgICAgICAgIGNhbGxFbmQ6IEB3cml0ZVRvQyxcbiAgICAgICAgICAgICAgICAgICAgY2FsbEFyZ3M6IGFyZ3NcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIEBXTS5Mb2cubG9nRXJyb3IoXCJDYW5ub3QgZmluZCBpbnNlcnRpb24gbWFya3MgaW4gXCIgK1xuICAgICAgICAgICAgICAgICAgICBAV00uTG9nLmxpbmtUb1dpa2lQYWdlKGFyZ3MucGFyYW1zLnBhZ2UsIGFyZ3MucGFyYW1zLnBhZ2UpKVxuICAgICAgICAgICAgICAgIEBpdGVyYXRlUGFnZXMoYXJncy5wYWdlaWQsIGFyZ3MuY2FsbE5leHQpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIEBXTS5Mb2cubG9nV2FybmluZyhAV00uTG9nLmxpbmtUb1dpa2lQYWdlKGFyZ3MucGFyYW1zLnBhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzLnBhcmFtcy5wYWdlKSArICcgaGFzIGJlZW4gdXBkYXRlZCB0b28gcmVjZW50bHknKVxuICAgICAgICAgICAgQGl0ZXJhdGVQYWdlcyhhcmdzLnBhZ2VpZCwgYXJncy5jYWxsTmV4dClcblxuICAgIHN0b3JlQWx0ZXJuYXRpdmVOYW1lczogKHNvdXJjZSkgPT5cbiAgICAgICAgZGljdCA9IHt9XG4gICAgICAgIHJlZ0V4cCA9IC9cXFtcXFtcXDooW0NjXWF0ZWdvcnlcXDouKz8pXFx8KC4rPylcXF1cXF0vZ21cbiAgICAgICAgd2hpbGUgdHJ1ZVxuICAgICAgICAgICAgbWF0Y2ggPSByZWdFeHAuZXhlYyhzb3VyY2UpXG4gICAgICAgICAgICBpZiBtYXRjaFxuICAgICAgICAgICAgICAgIGRpY3RbbWF0Y2hbMV0udG9Mb3dlckNhc2UoKV0gPSBtYXRjaFsyXVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgIHJldHVybiBkaWN0XG5cbiAgICBwcm9jZXNzQ2F0ZWdvcnk6IChwYXJhbXMpID0+XG4gICAgICAgIGFyZ3MgPSBwYXJhbXMuY2FsbEFyZ3NcblxuICAgICAgICBAV00uTG9nLmxvZ0luZm8oXCJQcm9jZXNzaW5nIFwiICsgQFdNLkxvZy5saW5rVG9XaWtpUGFnZShwYXJhbXMubm9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLm5vZGUpICsgXCIgLi4uXCIpXG5cbiAgICAgICAgdGV4dCA9IFwiXCJcblxuICAgICAgICBmb3IgWzAuLi5wYXJhbXMuYW5jZXN0b3JzLmxlbmd0aF1cbiAgICAgICAgICAgIHRleHQgKz0gYXJncy5wYXJhbXMuaW5kZW50VHlwZVxuXG4gICAgICAgIGlmIGFyZ3MucGFyYW1zLnNob3dJbmRpY2VzXG4gICAgICAgICAgICBpbmRpY2VzID0gW11cbiAgICAgICAgICAgIG5vZGUgPSBwYXJhbXNcbiAgICAgICAgICAgIHdoaWxlIG5vZGUucGFyZW50SW5kZXggIT0gbnVsbFxuICAgICAgICAgICAgICAgIGluZGljZXMucHVzaChub2RlLnNpYmxpbmdJbmRleCArIDEpXG4gICAgICAgICAgICAgICAgbm9kZSA9IHBhcmFtcy5ub2Rlc0xpc3Rbbm9kZS5wYXJlbnRJbmRleF1cbiAgICAgICAgICAgIGlmIGluZGljZXMubGVuZ3RoXG4gICAgICAgICAgICAgICAgdGV4dCArPSBcIjxzbWFsbD5cIiArIGluZGljZXMucmV2ZXJzZSgpLmpvaW4oXCIuXCIpICsgXCIuPC9zbWFsbD4gXCJcblxuICAgICAgICBhbHROYW1lID0gaWYgYXJncy5hbHROYW1lc1twYXJhbXMubm9kZS50b0xvd2VyQ2FzZSgpXSB0aGVuIGFyZ3MuYWx0TmFtZXNbcGFyYW1zLm5vZGUudG9Mb3dlckNhc2UoKV0gZWxzZSBudWxsXG4gICAgICAgIHRleHQgKz0gQGNyZWF0ZUNhdExpbmsocGFyYW1zLm5vZGUsIGFyZ3MucGFyYW1zLnJlcGxhY2UsIGFsdE5hbWUpXG5cbiAgICAgICAgdGV4dCArPSBpZiBhcmdzLnBhcmFtcy5yaWdodFRvTGVmdCB0aGVuIFwiJmxybTsgXCIgZWxzZSBcIiBcIlxuXG4gICAgICAgIGlmIHBhcmFtcy5jaGlsZHJlbiA9PSBcImxvb3BcIlxuICAgICAgICAgICAgdGV4dCArPSBcIicnJ1tMT09QXScnJ1xcblwiXG4gICAgICAgICAgICBAV00uTG9nLmxvZ1dhcm5pbmcoXCJMb29wIGluIFwiICsgQFdNLkxvZy5saW5rVG9XaWtpUGFnZShwYXJhbXMubm9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMubm9kZSkpXG4gICAgICAgICAgICBAcHJvY2Vzc0NhdGVnb3J5RW5kKHBhcmFtcywgYXJncywgdGV4dClcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgQFdNLkNhdC5nZXRQYXJlbnRzQW5kSW5mbyhcbiAgICAgICAgICAgICAgICBwYXJhbXMubm9kZSxcbiAgICAgICAgICAgICAgICBAcHJvY2Vzc0NhdGVnb3J5QWRkU3VmZml4LFxuICAgICAgICAgICAgICAgIFtwYXJhbXMsIGFyZ3MsIHRleHQsIGFsdE5hbWVdXG4gICAgICAgICAgICApXG5cbiAgICBwcm9jZXNzQ2F0ZWdvcnlBZGRTdWZmaXg6IChwYXJlbnRzLCBpbmZvLCBhcmdzXykgPT5cbiAgICAgICAgcGFyYW1zID0gYXJnc19bMF1cbiAgICAgICAgYXJncyA9IGFyZ3NfWzFdXG4gICAgICAgIHRleHQgPSBhcmdzX1syXVxuICAgICAgICBhbHROYW1lID0gYXJnc19bM11cblxuICAgICAgICBjdXJyUGFyZW50ID0gcGFyYW1zLmFuY2VzdG9yc1twYXJhbXMuYW5jZXN0b3JzLmxlbmd0aCAtIDFdXG4gICAgICAgIGFsc29QYXJlbnRzID0gW11cbiAgICAgICAgdGV4dCArPSBcIjxzbWFsbD4oXCIgKyAoaWYgaW5mbyB0aGVuIGluZm8ucGFnZXMgZWxzZSAwKSArIFwiKVwiXG5cbiAgICAgICAgIyBBbGxvdyBoaWRpbmcgdGhlIFwiYWxzbyBpblwiICh3aG9zZSBjdXJyUGFyZW50IGlzIHVuZGVmaW5lZCkgbGlua3MgZm9yXG4gICAgICAgICMgdGhlIHJvb3QgaXRlbSwgc2luY2UgdGhlIHJvb3QncyBwYXJlbnQgY2F0ZWdvcnkgd291bGQgYmUgZGlzcGxheWVkXG4gICAgICAgICMgdGhlcmVcbiAgICAgICAgaWYgY3VyclBhcmVudCBvciBhcmdzLnNob3dSb290QWxzb0luXG4gICAgICAgICAgICBmb3IgcGFyIGluIHBhcmVudHNcbiAgICAgICAgICAgICAgICBpZiBjdXJyUGFyZW50ICE9IHBhci50aXRsZSBhbmQgbm90IChcImhpZGRlblwiIGluIHBhcilcbiAgICAgICAgICAgICAgICAgICAgYWxzb1BhcmVudHMucHVzaChwYXIpXG5cbiAgICAgICAgICAgIGlmIGFsc29QYXJlbnRzLmxlbmd0aFxuICAgICAgICAgICAgICAgIHBhcmVudFRpdGxlcyA9IFtdXG4gICAgICAgICAgICAgICAgZm9yIGkgaW4gYWxzb1BhcmVudHNcbiAgICAgICAgICAgICAgICAgICAgYWx0TmFtZSA9IGlmIGFyZ3MuYWx0TmFtZXNbYWxzb1BhcmVudHNbaV0udGl0bGUudG9Mb3dlckNhc2UoKV0gdGhlbiBhcmdzLmFsdE5hbWVzW2Fsc29QYXJlbnRzW2ldLnRpdGxlLnRvTG93ZXJDYXNlKCldIGVsc2UgbnVsbFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnRUaXRsZXMucHVzaChAY3JlYXRlQ2F0TGluayhhbHNvUGFyZW50c1tpXS50aXRsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MucGFyYW1zLnJlcGxhY2UsIGFsdE5hbWUpKVxuXG4gICAgICAgICAgICAgICAgdGV4dCArPSBcIiAoXCIgKyBhcmdzLnBhcmFtcy5hbHNvSW4gKyBcIiBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRUaXRsZXMuam9pbihcIiwgXCIpICsgXCIpXCJcblxuICAgICAgICB0ZXh0ICs9IFwiPC9zbWFsbD5cXG5cIlxuXG4gICAgICAgIEBwcm9jZXNzQ2F0ZWdvcnlFbmQocGFyYW1zLCBhcmdzLCB0ZXh0KVxuXG4gICAgcHJvY2Vzc0NhdGVnb3J5RW5kOiAocGFyYW1zLCBhcmdzLCB0ZXh0KSA9PlxuICAgICAgICBhcmdzLnRyZWVUZXh0ICs9IHRleHRcblxuICAgICAgICBwYXJhbXMuY2FsbEFyZ3MgPSBhcmdzXG5cbiAgICAgICAgQFdNLkNhdC5yZWN1cnNlVHJlZUNvbnRpbnVlKHBhcmFtcylcblxuICAgIGNyZWF0ZUNhdExpbms6IChjYXQsIHJlcGxhY2UsIGFsdE5hbWUpID0+XG4gICAgICAgIGlmIGFsdE5hbWVcbiAgICAgICAgICAgIGNhdE5hbWUgPSBhbHROYW1lXG4gICAgICAgIGVsc2UgaWYgcmVwbGFjZVxuICAgICAgICAgICAgcmVnRXhwID0gbmV3IFJlZ0V4cChyZXBsYWNlWzBdLCByZXBsYWNlWzFdKVxuICAgICAgICAgICAgY2F0TmFtZSA9IGNhdC5zdWJzdHIoOSkucmVwbGFjZShyZWdFeHAsIHJlcGxhY2VbMl0pXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGNhdE5hbWUgPSBjYXQuc3Vic3RyKDkpXG4gICAgICAgIHJldHVybiBcIltbOlwiICsgY2F0ICsgXCJ8XCIgKyBjYXROYW1lICsgXCJdXVwiXG5cbiAgICB3cml0ZVRvQzogKHBhcmFtcykgPT5cbiAgICAgICAgYXJncyA9IHBhcmFtcy5jYWxsQXJnc1xuXG4gICAgICAgIGFyZ3MudHJlZVRleHQgPSBcIlxcblwiICsgYXJncy50cmVlVGV4dFxuICAgICAgICBuZXd0ZXh0ID0gU3RyLm92ZXJ3cml0ZUJldHdlZW4oYXJncy5zb3VyY2UsIGFyZ3MudHJlZVRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJncy5zdGFydElkLCBhcmdzLmVuZElkKVxuXG4gICAgICAgIGlmIG5ld3RleHQgIT0gYXJncy5zb3VyY2VcbiAgICAgICAgICAgIEBXTS5NVy5jYWxsQVBJUG9zdCh7XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXCJlZGl0XCJcbiAgICAgICAgICAgICAgICAgICAgYm90OiBcIjFcIlxuICAgICAgICAgICAgICAgICAgICBtaW5vcjogXCIxXCJcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IGFyZ3MucGFyYW1zLnBhZ2VcbiAgICAgICAgICAgICAgICAgICAgc3VtbWFyeTogYXJncy5zdW1tYXJ5XG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IG5ld3RleHRcbiAgICAgICAgICAgICAgICAgICAgYmFzZXRpbWVzdGFtcDogYXJncy50aW1lc3RhbXBcbiAgICAgICAgICAgICAgICAgICAgdG9rZW46IGFyZ3MuZWRpdHRva2VuXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBAY2hlY2tXcml0ZSxcbiAgICAgICAgICAgICAgICBhcmdzLFxuICAgICAgICAgICAgICAgIG51bGwpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIEBXTS5Mb2cubG9nSW5mbyhAV00uTG9nLmxpbmtUb1dpa2lQYWdlKGFyZ3MucGFyYW1zLnBhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MucGFyYW1zLnBhZ2UpICsgJyBpcyBhbHJlYWR5IHVwIHRvIGRhdGUnKVxuXG4gICAgICAgICAgICBAaXRlcmF0ZVBhZ2VzKGFyZ3MucGFnZWlkLCBhcmdzLmNhbGxOZXh0KVxuXG4gICAgY2hlY2tXcml0ZTogKHJlcywgYXJncykgPT5cbiAgICAgICAgaWYgcmVzLmVkaXQgYW5kIHJlcy5lZGl0LnJlc3VsdCA9PSAnU3VjY2VzcydcbiAgICAgICAgICAgIEBXTS5Mb2cubG9nSW5mbyhAV00uTG9nLmxpbmtUb1dpa2lQYWdlKGFyZ3MucGFyYW1zLnBhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzLnBhcmFtcy5wYWdlKSArICcgY29ycmVjdGx5IHVwZGF0ZWQnKVxuXG4gICAgICAgICAgICBAaXRlcmF0ZVBhZ2VzKGFyZ3MucGFnZWlkLCBhcmdzLmNhbGxOZXh0KVxuXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIEBXTS5Mb2cubG9nRXJyb3IoQFdNLkxvZy5saW5rVG9XaWtpUGFnZShhcmdzLnBhcmFtcy5wYWdlLFxuICAgICAgICAgICAgICAgICAgICBhcmdzLnBhcmFtcy5wYWdlKSArICcgaGFzIG5vdCBiZWVuIHVwZGF0ZWQhXFxuJyArXG4gICAgICAgICAgICAgICAgICAgIHJlc1snZXJyb3InXVsnaW5mbyddICsgXCIgKFwiICsgcmVzWydlcnJvciddWydjb2RlJ10gKyBcIilcIilcbiIsIiMgV2lraSBNb25rZXkgLSBNZWRpYVdpa2kgYm90IGFuZCBlZGl0b3ItYXNzaXN0YW50IHVzZXIgc2NyaXB0XG4jIENvcHlyaWdodCAoQykgMjAxMSBEYXJpbyBHaW92YW5uZXR0aSA8ZGV2QGRhcmlvZ2lvdmFubmV0dGkubmV0PlxuI1xuIyBUaGlzIGZpbGUgaXMgcGFydCBvZiBXaWtpIE1vbmtleS5cbiNcbiMgV2lraSBNb25rZXkgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuIyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuIyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuIyAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuI1xuIyBXaWtpIE1vbmtleSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuIyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuIyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4jIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4jXG4jIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4jIGFsb25nIHdpdGggV2lraSBNb25rZXkuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG5cblxuY2xhc3MgbW9kdWxlLmV4cG9ydHMuUGx1Z2luXG4gICAgIyBEb24ndCBjcmVhdGUgZGVmYXVsdCBvYmplY3RzIGhlcmUsIG9yIHRoZXknbGwgYmUgc2hhcmVkIGFtb25nIHRoZVxuICAgICMgc3ViY2xhc3NlcyB1bmxlc3Mgb3ZlcnJpZGRlblxuICAgICMgQGNvbmZfZGVmYXVsdDoge31cbiAgICAjIEB3aWtpX3RvX2NvbmZfZGVmYXVsdDoge31cbiAgICAjIGNvbmY6IHt9XG5cbiAgICBAX19jb25maWd1cmU6ICh3aWtpX25hbWUsIHVzZXJfY29uZmlnKSAtPlxuICAgICAgICAjIERvIGdlbmVyYXRlIGEgbmV3IG9iamVjdCBmb3IgZWFjaCBwbHVnaW5cbiAgICAgICAgQDo6Y29uZiA9IHt9XG5cbiAgICAgICAgaWYgQGNvbmZfZGVmYXVsdD9cbiAgICAgICAgICAgICQuZXh0ZW5kKEA6OmNvbmYsIEBjb25mX2RlZmF1bHQpXG5cbiAgICAgICAgaWYgQHdpa2lfdG9fY29uZl9kZWZhdWx0PyBhbmQgd2lraV9uYW1lIG9mIEB3aWtpX3RvX2NvbmZfZGVmYXVsdFxuICAgICAgICAgICAgJC5leHRlbmQoQDo6Y29uZiwgQHdpa2lfdG9fY29uZl9kZWZhdWx0W3dpa2lfbmFtZV0pXG5cbiAgICAgICAgaWYgQG5hbWUgb2YgdXNlcl9jb25maWdcbiAgICAgICAgICAgICMgRG9uJ3QganVzdCB1c2UgJC5leHRlbmQoKSBzbyBpdCdzIHBvc3NpYmxlIHRvIHNlZSBpZiB0aGVyZSBhcmVcbiAgICAgICAgICAgICMgdW5rbm93biBvcHRpb25zIGFuZCBwb3NzaWJseSB3YXJuIHRoZSB1c2VyXG4gICAgICAgICAgICBmb3Igb3B0aW9uLCB2YWx1ZSBvZiB1c2VyX2NvbmZpZ1tAbmFtZV0gd2hlbiBvcHRpb24gb2YgQDo6Y29uZlxuICAgICAgICAgICAgICAgIEA6OmNvbmZbb3B0aW9uXSA9IHZhbHVlXG4gICAgICAgICAgICAgICAgZGVsZXRlIHVzZXJfY29uZmlnW0BuYW1lXVtvcHRpb25dXG5cbiAgICAgICAgaWYgbm90IEA6OmNvbmYuZW5hYmxlZFxuICAgICAgICAgICAgZGVsZXRlIHVzZXJfY29uZmlnW0BuYW1lXVxuICAgICAgICAgICAgIyBUT0RPOiBQcm9wZXJseSBleHRlbmQgRXJyb3IsIGJ1dCBiZXdhcmUgdGhhdCBCYWJlbCBkb2Vzbid0IGxpa2VcbiAgICAgICAgICAgICMgICAgICAgaXQgd2l0aG91dCBzcGVjaWZpYyBwbHVnaW5zXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQbHVnaW4gZGlzYWJsZWRcIilcblxuICAgICAgICBpZiAkLmlzRW1wdHlPYmplY3QodXNlcl9jb25maWdbQG5hbWVdKVxuICAgICAgICAgICAgZGVsZXRlIHVzZXJfY29uZmlnW0BuYW1lXVxuXG4gICAgY29uc3RydWN0b3I6IChAV00pIC0+XG5cbiAgICBtYWluX2JvdDogbnVsbFxuICAgIG1haW5fZGlmZjogbnVsbFxuICAgIG1haW5fZWRpdG9yOiBudWxsXG4gICAgbWFpbl9uZXdwYWdlczogbnVsbFxuICAgIG1haW5fcmVjZW50Y2hhbmdlczogbnVsbFxuICAgIG1haW5fc3BlY2lhbDogbnVsbFxuIl19
