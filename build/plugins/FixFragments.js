// Generated by CoffeeScript 2.0.3
// Wiki Monkey - MediaWiki bot and editor-assistant user script
// Copyright (C) 2011 Dario Giovannetti <dev@dariogiovannetti.net>

// This file is part of Wiki Monkey.

// Wiki Monkey is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// Wiki Monkey is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with Wiki Monkey.  If not, see <http://www.gnu.org/licenses/>.
var Plugin;

({Plugin} = require('./_Plugin'));

module.exports.FixFragments = (function() {
  class FixFragments extends Plugin {
    fixLinks(source) {
      var i, ilinks, j, len, len1, link, newtext1, newtext2, prevId, rawfragment, sections, slinks, title;
      title = this.WM.Editor.getTitle();
      sections = this.WM.Parser.findSectionHeadings(source).sections;
      slinks = this.WM.Parser.findSectionLinks(source);
      newtext1 = "";
      prevId = 0;
      for (i = 0, len = slinks.length; i < len; i++) {
        link = slinks[i];
        newtext1 += source.substring(prevId, link.index);
        newtext1 += this.fixLink(source, sections, link.rawLink, link.fragment, link.anchor);
        prevId = link.index + link.length;
      }
      newtext1 += source.substr(prevId);
      // Note that it's impossible to recognize any namespaces in the title
      //   without querying the server
      // Alternatively, a list of the known namespaces could be maintained
      //   for each wiki
      // Recognizing namespaces would let recognize more liberal link
      //   syntaxes (e.g. spaces around the colon)
      ilinks = this.WM.Parser.findInternalLinks(newtext1, null, title);
      newtext2 = "";
      prevId = 0;
      for (j = 0, len1 = ilinks.length; j < len1; j++) {
        link = ilinks[j];
        newtext2 += newtext1.substring(prevId, link.index);
        rawfragment = link.fragment;
        if (rawfragment) {
          newtext2 += this.fixLink(newtext1, sections, link.rawLink, rawfragment, link.anchor);
        } else {
          newtext2 += link.rawLink;
        }
        prevId = link.index + link.length;
      }
      newtext2 += newtext1.substr(prevId);
      return newtext2;
    }

    fixLink(source, sections, rawlink, rawfragment, lalt) {
      var dotFragment, dotHeading, escHeading, fragment, heading, i, len, section;
      fragment = this.WM.Parser.squashContiguousWhitespace(rawfragment).trim();
      for (i = 0, len = sections.length; i < len; i++) {
        section = sections[i];
        heading = section.cleanheading;
        dotHeading = this.WM.Parser.dotEncode(heading);
        dotFragment = this.WM.Parser.dotEncode(fragment);
        if (dotHeading.toLowerCase() === dotFragment.toLowerCase()) {
          if (fragment === dotFragment) {
            // If the fragment was encoded, re-encode it because it
            // could contain link-breaking characters (e.g. []|{})
            // The condition would also be true if the fragment doesn't
            // contain any encodable characters, but since heading and
            // fragment at most differ by capitalization, encoding the
            // heading won't have any effect
            return "[[#" + dotHeading + (lalt ? "|" + lalt : "") + "]]";
          } else {
            // If the fragment was not encoded, if the fragment
            // contained link-breaking characters the link was already
            // broken, and replacing it with heading wouldn't make
            // things worse; if the fragment didn't contain
            // link-breaking characters, the heading doesn't either,
            // since heading and fragment at most differ by
            // capitalization, so it's safe to replace it
            // If the fragment was *partially* encoded instead, a
            // link-breaking character may have been encoded, so all
            // link-breaking characters must be re-encoded here!
            escHeading = this.WM.Parser.dotEncodeLinkBreakingFragmentCharacters(heading);
            return "[[#" + escHeading + (lalt ? "|" + lalt : "") + "]]";
          }
        }
      }
      // It's not easy to use @WM.Log.linkToWikiPage because pure fragments
      //   are not supported yet
      this.WM.Log.logWarning("Cannot fix broken section link: " + rawlink);
      return rawlink;
    }

    main_editor(callNext) {
      var newtext, source;
      source = this.WM.Editor.readSource();
      newtext = this.fixLinks(source);
      if (newtext !== source) {
        this.WM.Editor.writeSource(newtext);
        this.WM.Log.logInfo("Fixed section links");
      } else {
        this.WM.Log.logInfo("No fixable section links found");
      }
      if (callNext) {
        return callNext();
      }
    }

  };

  FixFragments.conf_default = {
    enabled: true,
    editor_menu: ["Text plugins", "Fix section links"]
  };

  return FixFragments;

})();
