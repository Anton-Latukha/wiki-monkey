// Generated by CoffeeScript 2.0.3
  // Wiki Monkey - MediaWiki bot and editor-assistant user script
  // Copyright (C) 2011 Dario Giovannetti <dev@dariogiovannetti.net>

  // This file is part of Wiki Monkey.

  // Wiki Monkey is free software: you can redistribute it and/or modify
  // it under the terms of the GNU General Public License as published by
  // the Free Software Foundation, either version 3 of the License, or
  // (at your option) any later version.

  // Wiki Monkey is distributed in the hope that it will be useful,
  // but WITHOUT ANY WARRANTY; without even the implied warranty of
  // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  // GNU General Public License for more details.

  // You should have received a copy of the GNU General Public License
  // along with Wiki Monkey.  If not, see <http://www.gnu.org/licenses/>.
var Plugin, Str, ref,
  boundMethodCheck = function(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new Error('Bound instance method accessed before binding'); } };

({Plugin} = require('./_Plugin'));

Str = require('../../auxiliary/lib.js.generic/dist/Str');

ref = module.exports.FixDoubleRedirects = (function() {
  class FixDoubleRedirects extends Plugin {
    constructor() {
      super(...arguments);
      this.reverseResults = this.reverseResults.bind(this);
      this.iterateList = this.iterateList.bind(this);
      this.readMiddleRedirect = this.readMiddleRedirect.bind(this);
      this.processDoubleRedirect = this.processDoubleRedirect.bind(this);
      this.processDoubleRedirectEnd = this.processDoubleRedirectEnd.bind(this);
    }

    main_special(callNext) {
      this.WM.Log.logInfo("Fixing double redirects ...");
      return this.WM.MW.getSpecialList("DoubleRedirects", "namespaces", this.reverseResults, callNext);
    }

    reverseResults(results, siteinfo, callNext) {
      var namespaces;
      boundMethodCheck(this, ref);
      namespaces = siteinfo.namespaces;
      results.reverse();
      return this.iterateList(results, namespaces, callNext);
    }

    iterateList(doubleRedirects, namespaces, callNext) {
      var doubleRedirect;
      boundMethodCheck(this, ref);
      doubleRedirect = doubleRedirects.pop();
      if (doubleRedirect) {
        return this.WM.MW.callQueryEdit(doubleRedirect.title, this.readMiddleRedirect, [doubleRedirect, doubleRedirects, namespaces, callNext]);
      } else {
        this.WM.Log.logInfo("Fixed double redirects");
        if (callNext) {
          return callNext();
        }
      }
    }

    readMiddleRedirect(doubleRedirectTitle, doubleRedirectSource, timestamp, edittoken, args) {
      var callNext, doubleRedirect, doubleRedirects, middleRedirectTitle, namespaces;
      boundMethodCheck(this, ref);
      doubleRedirect = args[0];
      doubleRedirects = args[1];
      namespaces = args[2];
      callNext = args[3];
      middleRedirectTitle = namespaces[doubleRedirect.databaseResult.nsb]['*'] + ':' + doubleRedirect.databaseResult.tb;
      return this.WM.MW.callQuery({
        prop: "revisions",
        rvprop: "content",
        titles: middleRedirectTitle
      }, this.processDoubleRedirect, [doubleRedirect, doubleRedirectTitle, doubleRedirectSource, timestamp, edittoken, doubleRedirects, namespaces, callNext], null);
    }

    processDoubleRedirect(middleRedirect, args) {
      var callNext, doubleRedirect, doubleRedirectSource, doubleRedirectTitle, doubleRedirects, edittoken, middleRedirectSource, middleTarget, namespaces, newTarget, newTargetAltAnchor, newTargetFragment, newTargetInterlanguage, newTargetNamespace, newTargetTitle, newText, oldTarget, rawMiddleTarget, rawOldTarget, timestamp;
      boundMethodCheck(this, ref);
      middleRedirectSource = middleRedirect.revisions[0]["*"];
      doubleRedirect = args[0];
      doubleRedirectTitle = args[1];
      doubleRedirectSource = args[2];
      timestamp = args[3];
      edittoken = args[4];
      doubleRedirects = args[5];
      namespaces = args[6];
      callNext = args[7];
      this.WM.Log.logInfo("Processing " + this.WM.Log.linkToWikiPage(doubleRedirectTitle, doubleRedirectTitle) + " ...");
      rawOldTarget = doubleRedirectSource.match(/\s*#redirect\s*[^\n]+/i);
      oldTarget = this.WM.Parser.findInternalLinks(rawOldTarget[0], null)[0];
      rawMiddleTarget = middleRedirectSource.match(/\s*#redirect\s*[^\n]+/i);
      middleTarget = this.WM.Parser.findInternalLinks(rawMiddleTarget[0], null)[0];
      if (oldTarget.fragment) {
        newTargetFragment = "#" + oldTarget.fragment;
      } else if (middleTarget.fragment) {
        newTargetFragment = "#" + middleTarget.fragment;
      } else {
        newTargetFragment = "";
      }
      if (oldTarget.anchor) {
        newTargetAltAnchor = "|" + oldTarget.anchor;
      } else if (middleTarget.anchor) {
        newTargetAltAnchor = "|" + middleTarget.anchor;
      } else {
        newTargetAltAnchor = "";
      }
      if (doubleRedirect.databaseResult.iwc) {
        newTargetInterlanguage = doubleRedirect.databaseResult.iwc + ":";
      } else {
        newTargetInterlanguage = "";
      }
      if (namespaces[doubleRedirect.databaseResult.nsc]["*"]) {
        newTargetNamespace = this.WM.Parser.squashContiguousWhitespace(namespaces[doubleRedirect.databaseResult.nsc]["*"]) + ":";
      } else {
        newTargetNamespace = "";
      }
      newTargetTitle = this.WM.Parser.squashContiguousWhitespace(doubleRedirect.databaseResult.tc);
      newTarget = "[[" + newTargetInterlanguage + newTargetNamespace + newTargetTitle + newTargetFragment + newTargetAltAnchor + "]]";
      newText = Str.overwriteFor(doubleRedirectSource, newTarget, oldTarget.index, oldTarget.length);
      if (newText !== doubleRedirectSource) {
        return this.WM.MW.callAPIPost({
          action: "edit",
          bot: "1",
          title: doubleRedirectTitle,
          summary: this.conf.edit_summary,
          text: newText,
          b1asetimestamp: timestamp,
          token: edittoken
        }, this.processDoubleRedirectEnd, [doubleRedirects, namespaces, callNext], null);
      } else {
        this.WM.Log.logWarning("Could not fix " + this.WM.Log.linkToWikiPage(doubleRedirectTitle, doubleRedirectTitle));
        return this.iterateList(doubleRedirects, namespaces, callNext);
      }
    }

    processDoubleRedirectEnd(res, args) {
      var callNext, doubleRedirects, namespaces;
      boundMethodCheck(this, ref);
      doubleRedirects = args[0];
      namespaces = args[1];
      callNext = args[2];
      if (res.edit && res.edit.result === 'Success') {
        return this.iterateList(doubleRedirects, namespaces, callNext);
      } else {
        return this.WM.Log.logError(res['error']['info'] + " (" + res['error']['code'] + ")");
      }
    }

  };

  FixDoubleRedirects.conf_default = {
    enabled: true,
    special_menu: ["Fix double redirects"],
    edit_summary: "fix double redirect"
  };

  return FixDoubleRedirects;

})();
