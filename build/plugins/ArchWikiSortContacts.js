// Generated by CoffeeScript 2.0.3
  // Wiki Monkey - MediaWiki bot and editor-assistant user script
  // Copyright (C) 2011 Dario Giovannetti <dev@dariogiovannetti.net>

  // This file is part of Wiki Monkey.

  // Wiki Monkey is free software: you can redistribute it and/or modify
  // it under the terms of the GNU General Public License as published by
  // the Free Software Foundation, either version 3 of the License, or
  // (at your option) any later version.

  // Wiki Monkey is distributed in the hope that it will be useful,
  // but WITHOUT ANY WARRANTY; without even the implied warranty of
  // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  // GNU General Public License for more details.

  // You should have received a copy of the GNU General Public License
  // along with Wiki Monkey.  If not, see <http://www.gnu.org/licenses/>.
var Plugin, ref,
  boundMethodCheck = function(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new Error('Bound instance method accessed before binding'); } };

({Plugin} = require('./_Plugin'));

ref = module.exports.ArchWikiSortContacts = (function() {
  var endMark, regExp, startMark;

  class ArchWikiSortContacts extends Plugin {
    constructor() {
      super(...arguments);
      this.parseList = this.parseList.bind(this);
      this.iterateUsers = this.iterateUsers.bind(this);
      this.storeUserContribs = this.storeUserContribs.bind(this);
      this.updateList = this.updateList.bind(this);
      this.writePage = this.writePage.bind(this);
    }

    main_special(callNext) {
      return this.iteratePages(0, callNext);
    }

    iteratePages(pageid, callNext) {
      var inactiveIntro, inactiveLimit, page, pconf, recentDays, summary;
      pconf = this.conf.pages[pageid];
      if (pconf) {
        page = pconf.title;
        recentDays = pconf.recent_days;
        inactiveLimit = pconf.inactive_limit;
        inactiveIntro = pconf.inactive_message;
        summary = this.conf.edit_summary;
        this.WM.Log.logInfo("Sorting " + this.WM.Log.linkToWikiPage(page, page) + " ...");
        return this.WM.MW.callQueryEdit(page, this.parseList, [recentDays, inactiveLimit, inactiveIntro, summary, callNext, pageid]);
      } else if (callNext) {
        return callNext();
      }
    }

    parseList(title, source, timestamp, edittoken, args) {
      var callNext, date, endList, inactiveIntro, inactiveLimit, pageid, recentDays, startList, summary, ucend, ucstart, users, usersArray;
      boundMethodCheck(this, ref);
      recentDays = args[0];
      inactiveLimit = args[1];
      inactiveIntro = args[2];
      summary = args[3];
      callNext = args[4];
      pageid = args[5];
      startList = source.indexOf(startMark);
      endList = source.indexOf(endMark);
      if (startList > -1 && endList > -1) {
        startList += startMark.length;
        date = new Date();
        ucstart = Math.floor(Date.now() / 1000);
        ucend = ucstart - 86400 * recentDays;
        users = {
          active: [],
          inactive: []
        };
        usersArray = source.substring(startList, endList).split("\n");
        return this.iterateUsers(usersArray, -1, ucstart, ucend, users, title, source, startList, endList, timestamp, edittoken, inactiveLimit, inactiveIntro, summary, callNext, pageid);
      } else {
        return this.WM.Log.logError("Cannot find the needed marks");
      }
    }

    iterateUsers(usersArray, index, ucstart, ucend, users, title, source, startList, endList, timestamp, edittoken, inactiveLimit, inactiveIntro, summary, callNext, pageid) {
      var match, ucuser, userString;
      boundMethodCheck(this, ref);
      index++;
      if (index < usersArray.length) {
        userString = usersArray[index];
        match = regExp.exec(userString);
        if (match) {
          ucuser = match[1].charAt(0).toUpperCase() + match[1].substr(1);
          if (match[2]) {
            ucuser += "|" + match[2].charAt(0).toUpperCase() + match[2].substr(1);
          }
          this.WM.Log.logInfo("Querying " + ucuser + " ...");
          return this.WM.MW.getUserContribs(ucuser, ucstart, ucend, this.storeUserContribs, [usersArray, index, ucstart, ucend, users, title, source, startList, endList, timestamp, edittoken, inactiveLimit, inactiveIntro, summary, callNext, pageid]);
        } else if (userString !== "" && userString.indexOf(inactiveIntro) !== 0) {
          return this.WM.Log.logError("An entry in the list may not be correctly " + "formatted");
        } else {
          return this.iterateUsers(usersArray, index, ucstart, ucend, users, title, source, startList, endList, timestamp, edittoken, inactiveLimit, inactiveIntro, summary, callNext, pageid);
        }
      } else {
        return this.updateList(users, title, source, startList, endList, timestamp, edittoken, inactiveIntro, summary, callNext, pageid);
      }
    }

    storeUserContribs(results, args) {
      var edits, edittoken, endList, inactiveIntro, inactiveLimit, index, pageid, source, startList, summary, timestamp, title, ucend, ucstart, users, usersArray;
      boundMethodCheck(this, ref);
      usersArray = args[0];
      index = args[1];
      ucstart = args[2];
      ucend = args[3];
      users = args[4];
      title = args[5];
      source = args[6];
      startList = args[7];
      endList = args[8];
      timestamp = args[9];
      edittoken = args[10];
      inactiveLimit = args[11];
      inactiveIntro = args[12];
      summary = args[13];
      pageid = args[14];
      edits = results.length;
      if (edits < inactiveLimit) {
        users.inactive.push({
          "text": usersArray[index],
          "edits": edits
        });
      } else {
        users.active.push({
          "text": usersArray[index],
          "edits": edits
        });
      }
      return this.iterateUsers(usersArray, index, ucstart, ucend, users, title, source, startList, endList, timestamp, edittoken, inactiveLimit, inactiveIntro, summary, callNext, pageid);
    }

    updateList(users, title, source, startList, endList, timestamp, edittoken, inactiveIntro, summary, callNext, pageid) {
      var i, j, len, len1, newList, newText, ref1, ref2, sorter, user;
      boundMethodCheck(this, ref);
      sorter = function(a, b) {
        // Users must be sorted in descending order
        if (a.edits < b.edits) {
          return 1;
        } else if (a.edits > b.edits) {
          return -1;
        } else {
          return 0;
        }
      };
      users.active.sort(sorter);
      users.inactive.sort(sorter);
      newList = "\n";
      ref1 = users.active;
      for (i = 0, len = ref1.length; i < len; i++) {
        user = ref1[i];
        newList += user.text + "\n";
      }
      if (users.inactive.length > 0) {
        newList += "\n" + inactiveIntro + "\n\n";
        ref2 = users.inactive;
        for (j = 0, len1 = ref2.length; j < len1; j++) {
          user = ref2[j];
          newList += user.text + "\n";
        }
      }
      newText = source.substring(0, startList) + newList + source.substring(endList);
      if (newText !== source) {
        return this.WM.MW.callAPIPost({
          action: "edit",
          bot: "1",
          minor: "1",
          title: title,
          summary: summary,
          text: newText,
          b1asetimestamp: timestamp,
          token: edittoken
        }, this.writePage, [title, callNext, pageid], null);
      } else {
        this.WM.Log.logInfo(this.WM.Log.linkToWikiPage(title, title) + " was already up to date");
        return this.iteratePages(pageid, callNext);
      }
    }

    writePage(res, args) {
      var callNext, pageid, title;
      boundMethodCheck(this, ref);
      title = args[0];
      callNext = args[1];
      pageid = args[2];
      if (res.edit && res.edit.result === 'Success') {
        this.WM.Log.logInfo(this.WM.Log.linkToWikiPage(title, title) + " was correctly updated");
        return this.iteratePages(pageid, callNext);
      } else {
        return this.WM.Log.logError(res['error']['info'] + " (" + res['error']['code'] + ")");
      }
    }

  };

  // This plugin was originally based on list=allusers, but because of bug
  //  #208 it can't rely on that anymore, so it was rewritten with
  //  60bb2ac2a2dcd0b15b7aac80725c83151173eeb3
  // See also https://bbs.archlinux.org/viewtopic.php?id=192389 and
  //  https://lists.wikimedia.org/pipermail/mediawiki-l/2015-January/043850.html
  startMark = "START AUTO LIST - DO NOT REMOVE OR MODIFY THIS MARK-->";

  endMark = "<!--END AUTO LIST - DO NOT REMOVE OR MODIFY THIS MARK";

  // Don't do "(?: \\<!-- associated bot: (.+?) -->)?.*$"
  regExp = new RegExp("^\\*.*?\\[\\[User:(.+?)\\|.+?" + "(?: \\<!-- associated bot: (.+?) -->.*)?$", "");

  ArchWikiSortContacts.conf_default = {
    special_menu: ["Sort staff contacts"],
    edit_summary: "automatically sort list according to recent activity",
    pages: [
      {
        title: "ArchWiki:Administrators",
        recent_days: 30,
        inactive_limit: 30,
        inactive_message: "The following Administrators are currently inactive (less than 30 edits in the last 30 days):"
      },
      {
        title: "ArchWiki:Maintainers",
        recent_days: 30,
        inactive_limit: 10,
        inactive_message: "The following Maintainers are currently inactive (less than 10 edits in the last 30 days):"
      }
    ]
  };

  return ArchWikiSortContacts;

})();
