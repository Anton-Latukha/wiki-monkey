// Generated by CoffeeScript 2.0.3
// Wiki Monkey - MediaWiki bot and editor-assistant user script
// Copyright (C) 2011 Dario Giovannetti <dev@dariogiovannetti.net>

// This file is part of Wiki Monkey.

// Wiki Monkey is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// Wiki Monkey is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with Wiki Monkey.  If not, see <http://www.gnu.org/licenses/>.
var Obj;

Obj = require('../../lib.js.generic/dist/Obj');

module.exports.Interlanguage = class Interlanguage {
  constructor(WM) {
    this.parseLinks = this.parseLinks.bind(this);
    this.queryLinks = this.queryLinks.bind(this);
    this.createNewLink = this.createNewLink.bind(this);
    this.createVisitedLink = this.createVisitedLink.bind(this);
    this.collectLinks = this.collectLinks.bind(this);
    this._collectLinksContinue = this._collectLinksContinue.bind(this);
    this.updateLinks = this.updateLinks.bind(this);
    this.WM = WM;
  }

  parseLinks(supportedLangs, source, iwmap) {
    var i, iw, j, langlinks, len, len1, link, ltag, ltitle, lurl, parsedLinks;
    parsedLinks = this.WM.Parser.findSpecialLinks(source, supportedLangs.join("|"));
    langlinks = [];
    for (i = 0, len = parsedLinks.length; i < len; i++) {
      link = parsedLinks[i];
      // Do not store the tag lowercased, since it should be kept as
      // original
      ltag = link.namespace;
      ltitle = link.title + (link.fragment ? "#" + link.fragment : "");
      for (j = 0, len1 = iwmap.length; j < len1; j++) {
        iw = iwmap[j];
        if (iw.prefix.toLowerCase() === ltag.toLowerCase()) {
          // Fix the url _before_ replacing $1
          lurl = this.WM.MW.fixInterwikiUrl(iw.url);
          lurl = lurl.replace("$1", encodeURIComponent(this.WM.Parser.squashContiguousWhitespace(ltitle)));
          break;
        }
      }
      langlinks.push({
        lang: ltag,
        title: ltitle,
        url: lurl,
        index: link.index,
        length: link.length
      });
    }
    return langlinks;
  }

  queryLinks(queryTitle, title, supportedLangs, whitelist, firstPage, callEnd, callArgs) {
    var query;
    query = {
      action: "query",
      prop: "info|revisions",
      rvprop: "content|timestamp",
      intoken: "edit",
      titles: queryTitle,
      meta: "siteinfo",
      siprop: "interwikimap",
      sifilteriw: "local"
    };
    // When called by the bot, if the start page is a redirect itself, it
    // shoudln't be resolved
    if (!firstPage) {
      query.redirects = "1";
    }
    return this.WM.MW.callAPIGet(query, (res, args) => {
      var edittoken, error, iwmap, langlinks, page, source, timestamp;
      if (res.query.pages) {
        page = Obj.getFirstItem(res.query.pages);
        if (page.revisions) {
          error = null;
          source = page.revisions[0]["*"];
          timestamp = page.revisions[0].timestamp;
          edittoken = page.edittoken;
          iwmap = res.query.interwikimap;
          langlinks = this.WM.Interlanguage.parseLinks(supportedLangs, source, iwmap);
        } else {
          // The requested article doesn't exist
          error = 'nonexisting';
          source = false;
          timestamp = false;
          edittoken = false;
          iwmap = res.query.interwikimap;
          langlinks = false;
        }
      } else if (res.query.redirects) {
        // The requested article is an unsolved redirect
        // (redirect over interwiki link?)
        error = 'unsolvedredirect';
        source = false;
        timestamp = false;
        edittoken = false;
        iwmap = res.query.interwikimap;
        langlinks = false;
      } else {
        // Unknown error
        error = 'unknown';
        source = false;
        timestamp = false;
        edittoken = false;
        iwmap = res.query.interwikimap;
        langlinks = false;
      }
      return callEnd(title, supportedLangs, whitelist, false, error, langlinks, iwmap, source, timestamp, edittoken, args);
    }, callArgs, function(args) {
      return callEnd(title, supportedLangs, whitelist, false, 'unknown', false, false, false, false, false, args);
    });
  }

  createNewLink(origTag, title, url) {
    return {
      origTag: origTag,
      title: title,
      url: url
    };
  }

  createVisitedLink(origTag, title, url, iwmap, source, timestamp, edittoken, links) {
    var entry, i, len, link;
    entry = {
      origTag: origTag,
      title: title,
      url: url,
      iwmap: iwmap,
      source: source,
      timestamp: timestamp,
      edittoken: edittoken,
      links: []
    };
    for (i = 0, len = links.length; i < len; i++) {
      link = links[i];
      entry.links.push(link);
    }
    return entry;
  }

  collectLinks(visitedlinks, newlinks, supportedLangs, whitelist, firstPage, callEnd, callArgs) {
    var link, origTag, queryTitle, tag, title, url;
    for (tag in newlinks) {
      link = newlinks[tag];
      break;
    }
    if (link) {
      delete newlinks[tag];
      url = link.url;
      // Don't use @WM.MW.getTitleFromWikiUrl(decodeURI(url)) because
      // it wouldn't decode some characters like colons, which are
      // required to be decoded instead when making an API call
      queryTitle = decodeURIComponent(this.WM.MW.getTitleFromWikiUrl(url));
      if (queryTitle) {
        origTag = link.origTag;
        title = link.title;
        // If this is the first processed page, it's local for sure, so
        //   query its links in any case. This e.g. prevents the
        //   application from crashing in case the local page is in a
        //   language whose language tag is not in the white list
        // tag is already lower-cased
        if (firstPage || whitelist.indexOf(tag) > -1) {
          this.WM.Log.logInfo("Reading " + this.WM.Log.linkToPage(url, "[[" + origTag + ":" + title + "]]") + " ...");
          return this.queryLinks(queryTitle, title, supportedLangs, whitelist, firstPage, this.WM.Interlanguage._collectLinksContinue, [url, tag, origTag, visitedlinks, newlinks, callEnd, callArgs]);
        } else {
          return this.WM.Interlanguage._collectLinksContinue(title, supportedLangs, whitelist, firstPage, 'notinwhitelist', [], false, null, null, null, [url, tag, origTag, visitedlinks, newlinks, callEnd, callArgs]);
        }
      } else {
        this.WM.Log.logWarning("Cannot extract the page title from " + this.WM.Log.linkToPage(url, decodeURI(url)) + ", removing it if it was linked from the processed article");
        return this.WM.Interlanguage.collectLinks(visitedlinks, newlinks, supportedLangs, whitelist, firstPage, callEnd, callArgs);
      }
    } else {
      return callEnd(visitedlinks, callArgs);
    }
  }

  _collectLinksContinue(title, supportedLangs, whitelist, firstPage, error, langlinks, iwmap, source, timestamp, edittoken, args) {
    var callArgs, callEnd, i, len, link, newlinks, nlink, origTag, tag, url, visitedlinks, vlink;
    url = args[0];
    tag = args[1];
    origTag = args[2];
    visitedlinks = args[3];
    newlinks = args[4];
    callEnd = args[5];
    callArgs = args[6];
    if (error === 'nonexisting') {
      this.WM.Log.logWarning(this.WM.Log.linkToPage(url, "[[" + origTag + ":" + title + "]]") + " seems to point to a non-existing article: removing it if it was linked from the processed article");
    } else {
      if (error === 'unsolvedredirect') {
        this.WM.Log.logWarning(this.WM.Log.linkToPage(url, "[[" + origTag + ":" + title + "]]") + " will not be checked because it points to an external redirect");
      } else if (error === 'unknown') {
        this.WM.Log.logWarning(this.WM.Log.linkToPage(url, "[[" + origTag + ":" + title + "]]") + " will not be checked because of an unspecified problem");
      } else if (error === 'notinwhitelist') {
        this.WM.Log.logWarning(this.WM.Log.linkToPage(url, "[[" + origTag + ":" + title + "]]") + " will not be checked because " + tag + " is not included in the whitelist defined in the configuration");
      }
      visitedlinks[tag] = this.WM.Interlanguage.createVisitedLink(origTag, title, url, iwmap, source, timestamp, edittoken, langlinks);
      for (i = 0, len = langlinks.length; i < len; i++) {
        link = langlinks[i];
        nlink = newlinks[link.lang.toLowerCase()];
        vlink = visitedlinks[link.lang.toLowerCase()];
        if (!vlink && !nlink) {
          newlinks[link.lang.toLowerCase()] = this.WM.Interlanguage.createNewLink(link.lang, link.title, link.url);
        } else if (vlink && vlink.url !== link.url) {
          // Just ignore any conflicting links and warn the user:
          // if it's a real conflict, the user will investigate it,
          // otherwise the user will ignore it
          this.WM.Log.logWarning("Possibly conflicting interlanguage links: " + this.WM.Log.linkToPage(link.url, "[[" + link.lang + ":" + link.title + "]]") + " and " + this.WM.Log.linkToPage(vlink.url, "[[" + link.lang + ":" + visitedlinks[link.lang.toLowerCase()].title + "]]"));
        } else if (nlink && nlink.url !== link.url) {
          // Just ignore any conflicting links and warn the user:
          // if it's a real conflict, the user will investigate it,
          // otherwise the user will ignore it
          this.WM.Log.logWarning("Possibly conflicting interlanguage links: " + this.WM.Log.linkToPage(link.url, "[[" + link.lang + ":" + link.title + "]]") + " and " + this.WM.Log.linkToPage(nlink.url, "[[" + link.lang + ":" + newlinks[link.lang.toLowerCase()].title + "]]"));
        }
      }
    }
    return this.WM.Interlanguage.collectLinks(visitedlinks, newlinks, supportedLangs, whitelist, firstPage, callEnd, callArgs);
  }

  updateLinks(lang, url, iwmap, source, oldlinks, newlinks) {
    var body, cleanText, firstLink, head, i, iw, j, len, len1, link, linkList, links, parts, tag, tagFound, textId, trailws;
    lang = lang.toLowerCase();
    linkList = [];
    for (tag in newlinks) {
      if (tag !== lang) {
        link = newlinks[tag];
        tagFound = false;
        // New links that were not in the white list will have the
        // "iwmap" attribute false, "timestamp" and "edittoken" null
        // and "links" as an empty array
        // Note the difference between 'iwmap' and 'link.iwmap'
        for (i = 0, len = iwmap.length; i < len; i++) {
          iw = iwmap[i];
          if (iw.prefix.toLowerCase() === tag.toLowerCase()) {
            linkList.push("[[" + link.origTag + ":" + link.title + "]]");
            tagFound = true;
            break;
          }
        }
        if (!tagFound) {
          this.WM.Log.logWarning(tag + " interlanguage links are not supported in " + this.WM.Log.linkToPage(url, "[[" + link.origTag + ":" + link.title + "]]") + " , ignoring them");
        }
      }
    }
    linkList.sort(function(a, b) {
      // Sorting is case sensitive by default
      if (a.toLowerCase() > b.toLowerCase()) {
        return 1;
      }
      if (b.toLowerCase() > a.toLowerCase()) {
        return -1;
      } else {
        return 0;
      }
    });
    cleanText = "";
    textId = 0;
    for (j = 0, len1 = oldlinks.length; j < len1; j++) {
      link = oldlinks[j];
      cleanText += source.substring(textId, link.index);
      textId = link.index + link.length;
    }
    cleanText += source.substring(textId);
    if (oldlinks.length) {
      // Insert the new links at the index of the first previous link
      firstLink = oldlinks[0].index;
    } else {
      firstLink = 0;
    }
    parts = [];
    // Do not add empty strings to parts, otherwise when it's joined
    //   unnecessary line breaks will be added
    head = cleanText.substring(0, firstLink).trim();
    if (head) {
      parts.push(head);
    }
    links = linkList.join("\n");
    if (links) {
      parts.push(links);
    }
    body = cleanText.substr(firstLink).trim();
    if (body) {
      parts.push(body);
    }
    // Make sure to preserve the original white space at the end, otherwise
    //   the final (newText != source) may return true even when no actual
    //   change has been made
    // Note that /\s+$/ would return null in the absence of trailing
    //   whitespace, so a further check should be made, while /\s*$/
    //   safely returns an empty string in that case
    trailws = /\s*$/;
    return parts.join("\n") + trailws.exec(source);
  }

};
