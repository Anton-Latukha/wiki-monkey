// Generated by CoffeeScript 2.0.3
// Wiki Monkey - MediaWiki bot and editor-assistant user script
// Copyright (C) 2011 Dario Giovannetti <dev@dariogiovannetti.net>

// This file is part of Wiki Monkey.

// Wiki Monkey is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// Wiki Monkey is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with Wiki Monkey.  If not, see <http://www.gnu.org/licenses/>.
var A, HTTP, Obj;

HTTP = require('../../lib.js.generic/dist/HTTP');

Obj = require('../../lib.js.generic/dist/Obj');

({A} = require('./libs'));

module.exports = (function() {
  var interwikiFixes, localWikiPaths, localWikiUrls, wikiPaths;

  class exports {
    constructor(WM) {
      var hostname, key, wpaths;
      this.WM = WM;
      this.api = new mw.Api();
      wpaths = this._getWikiPaths(location.href);
      hostname = wpaths[0];
      this.userInfo = null;
      localWikiPaths = wpaths[1];
      localWikiUrls = {};
      for (key in localWikiPaths) {
        localWikiUrls[key] = hostname + localWikiPaths[key];
      }
    }

    _getWikiPaths(href) {
      var hostname, match, p, paths, r, re;
      // It's necessary to keep this function in a private attribute,
      // otherwise localWikiPaths and localWikiUrls cannot be initialized
      for (r in wikiPaths.known) {
        re = new RegExp(r, "i");
        match = re.exec(href);
        if (match) {
          hostname = match[0];
          paths = {};
          for (p in wikiPaths.known[r]) {
            paths[p] = wikiPaths.known[r][p];
          }
          break;
        }
      }
      if (!paths) {
        hostname = HTTP.getUrlLocation(href).hostname;
        paths = {};
        for (p in wikiPaths.default_) {
          paths[p] = wikiPaths.default_[p];
        }
      }
      return [hostname, paths];
    }

    getWikiPaths(href) {
      if (href) {
        return this._getWikiPaths(href)[1];
      } else {
        return localWikiPaths;
      }
    }

    linkArticle(page, label) {
      return A({
        href: mw.util.getUrl(page)
      }, label || page);
    }

    getWikiUrls(href) {
      var hostname, key, paths, urls, wpaths;
      if (href) {
        wpaths = this._getWikiPaths(href);
        hostname = wpaths[0];
        paths = wpaths[1];
        urls = {};
        for (key in paths) {
          urls[key] = hostname + paths[key];
        }
        return urls;
      } else {
        return localWikiUrls;
      }
    }

    getTitleFromWikiUrl(url) {
      var match, pathname, r, re, title;
      title = HTTP.getURIParameters(url).title;
      // Test this *before* the short paths, in fact a short path may just be
      // the full one with the "title" parameter pre-added
      if (!title) {
        pathname = HTTP.getUrlLocation(url).pathname;
        for (r in wikiPaths.known) {
          re = new RegExp(r, "i");
          match = re.exec(url);
          if (match) {
            if (pathname.indexOf(wikiPaths.known[r].short) === 0) {
              title = pathname.substr(wikiPaths.known[r].short.length);
            } else {
              title = false;
            }
            break;
          }
        }
        if (!title) {
          if (pathname.indexOf(wikiPaths.default_.short) === 0) {
            title = pathname.substr(wikiPaths.default_.short.length);
          } else {
            title = false;
          }
        }
      }
      return title;
    }

    failedQueryError(url) {
      if (url) {
        return `Failed query: ${this.WM.Log.linkToPage(url, url)}`;
      }
      return "Failed query";
    }

    callAPIGet(params, call, callArgs, callError) {
      params.format = "json";
      return this.api.get(params).done((data, textStatus, jqXHR) => {
        return call(data, callArgs);
      }).fail((jqXHR, textStatus, errorThrown) => {
        console.error(jqXHR, textStatus, errorThrown);
        this.WM.Log.logError(this.failedQueryError());
        if (confirm("Wiki Monkey error: Failed query\n\nDo you want " + "to retry?")) {
          this.WM.Log.logInfo("Retrying ...");
          return this.callAPIGet(params, call, callArgs, callError);
        } else if (callError) {
          return callError(callArgs);
        }
      });
    }

    callAPIPost(params, call, callArgs, callError) {
      params.format = "json";
      return this.api.post(params).done((data, textStatus, jqXHR) => {
        return call(data, callArgs);
      }).fail((jqXHR, textStatus, errorThrown) => {
        console.error(jqXHR, textStatus, errorThrown);
        this.WM.Log.logError(this.failedQueryError());
        if (confirm("Wiki Monkey error: Failed query\n\nDo you want " + "to retry?")) {
          this.WM.Log.logInfo("Retrying ...");
          return this.callAPIPost(params, call, callArgs, callError);
        } else if (callError) {
          return callError(callArgs);
        }
      });
    }

    callQuery(params, call, callArgs, callError) {
      var callBack;
      params.action = "query";
      callBack = (res, args) => {
        var page;
        page = Obj.getFirstItem(res.query.pages);
        return call(page, args);
      };
      return this.callAPIGet(params, callBack, callArgs, callError);
    }

    callQueryEdit(title, call, callArgs) {
      var callBack, pars;
      callBack = (page, args) => {
        var edittoken, source, timestamp;
        source = page.revisions[0]["*"];
        timestamp = page.revisions[0].timestamp;
        edittoken = page.edittoken;
        return call(title, source, timestamp, edittoken, args);
      };
      pars = {
        prop: "info|revisions",
        rvprop: "content|timestamp",
        intoken: "edit",
        titles: title
      };
      return this.callQuery(pars, callBack, callArgs, null);
    }

    getUserInfo(call) {
      var pars, storeInfo;
      storeInfo = (res, call) => {
        this.userInfo = res;
        return call();
      };
      if (!this.userInfo) {
        pars = {
          action: "query",
          meta: "userinfo",
          uiprop: "groups"
        };
        return this.callAPIGet(pars, storeInfo, call, null);
      } else {
        return call();
      }
    }

    isLoggedIn(call, args) {
      return this.getUserInfo(() => {
        var test;
        test = this.userInfo.query.userinfo.id !== 0;
        return call(test, args);
      });
    }

    getUserName(call, args) {
      return this.getUserInfo(() => {
        return call(this.userInfo.query.userinfo.name, args);
      });
    }

    isUserBot(call, args) {
      return this.getUserInfo(() => {
        var groups, res;
        groups = this.userInfo.query.userinfo.groups;
        res = groups.indexOf("bot") > -1;
        return call(res, args);
      });
    }

    getBacklinks(bltitle, blnamespace, call, callArgs) {
      var query;
      query = {
        action: "query",
        list: "backlinks",
        bltitle: bltitle,
        bllimit: 500
      };
      if (blnamespace) {
        query.blnamespace = blnamespace;
      }
      return this._getBacklinksContinue(query, call, callArgs, []);
    }

    _getBacklinksContinue(query, call, callArgs, backlinks) {
      return this.callAPIGet(query, (res, args) => {
        backlinks = backlinks.concat(res.query.backlinks);
        if (res["query-continue"]) {
          query.blcontinue = res["query-continue"].backlinks.blcontinue;
          return this._getBacklinksContinue(query, call, args, backlinks);
        } else {
          return call(backlinks, args);
        }
      }, callArgs, null);
    }

    getLanglinks(title, iwmap, call, callArgs) {
      var query;
      query = {
        action: "query",
        prop: "langlinks",
        titles: title,
        lllimit: 500,
        llurl: "1",
        redirects: "1"
      };
      if (iwmap) {
        query.meta = "siteinfo";
        query.siprop = "interwikimap";
        query.sifilteriw = "local";
      }
      return this._getLanglinksContinue(query, call, callArgs, [], null);
    }

    _getLanglinksContinue(query, call, callArgs, langlinks, iwmap) {
      return this.callAPIGet(query, (res, args) => {
        var page;
        page = Obj.getFirstItem(res.query.pages);
        langlinks = langlinks.concat(page.langlinks);
        if (res.query.interwikimap) {
          iwmap = res.query.interwikimap;
        }
        if (query.meta) {
          delete query.meta;
          delete query.siprop;
          delete query.sifilteriw;
        }
        if (res["query-continue"]) {
          query.llcontinue = res["query-continue"].langlinks.llcontinue;
          return this._getLanglinksContinue(query, call, args, langlinks, iwmap);
        } else {
          return call(langlinks, iwmap, args);
        }
      }, callArgs, null);
    }

    getInterwikiMap(title, call, callArgs) {
      return this.callAPIGet({
        action: "query",
        meta: "siteinfo",
        siprop: "interwikimap",
        sifilteriw: "local"
      }, (res, args) => {
        return call(res.query.interwikimap, args);
      }, callArgs, null);
    }

    fixInterwikiUrl(url) {
      var f, furl, i, ref;
      for (f = i = 0, ref = interwikiFixes.length; 0 <= ref ? i < ref : i > ref; f = 0 <= ref ? ++i : --i) {
        furl = url.replace(interwikiFixes[f][0], interwikiFixes[f][1]);
        if (furl !== url) {
          return furl;
        }
      }
      // Return the unmodified url if no replacement has been done
      return url;
    }

    getSpecialList(qppage, siprop, call, callArgs) {
      var query;
      query = {
        action: "query",
        list: "querypage",
        qppage: qppage,
        qplimit: 500
      };
      if (siprop) {
        query.meta = "siteinfo";
        query.siprop = siprop;
      }
      return this._getSpecialListContinue(query, call, callArgs, [], {});
    }

    _getSpecialListContinue(query, call, callArgs, results, siteinfo) {
      return this.callAPIGet(query, (res, args) => {
        var key;
        results = results.concat(res.query.querypage.results);
        for (key in res.query) {
          if (key !== "querypage") {
            siteinfo[key] = res.query[key];
          }
        }
        if (query.meta) {
          delete query.meta;
          delete query.siprop;
        }
        if (res["query-continue"]) {
          query.qpoffset = res["query-continue"].querypage.qpoffset;
          return this._getSpecialListContinue(query, call, args, results, siteinfo);
        } else {
          return call(results, siteinfo, args);
        }
      }, callArgs, null);
    }

    getUserContribs(ucuser, ucstart, ucend, call, callArgs) {
      var query;
      query = {
        action: "query",
        list: "usercontribs",
        ucuser: ucuser,
        ucprop: "",
        ucstart: ucstart,
        ucend: ucend,
        uclimit: 500
      };
      return this._getUserContribsContinue(query, call, callArgs, []);
    }

    _getUserContribsContinue(query, call, callArgs, results) {
      return this.callAPIGet(query, (res, args) => {
        results = results.concat(res.query.usercontribs);
        if (res["query-continue"]) {
          query.uccontinue = res["query-continue"].usercontribs.uccontinue;
          return this._getUserContribsContinue(query, call, args, results);
        } else {
          return call(results, args);
        }
      }, callArgs, null);
    }

  };

  localWikiPaths = null;

  localWikiUrls = null;

  wikiPaths = {
    known: {
      "^https?://[^\.]+\.wikipedia\.org": {
        short: "/wiki/",
        full: "/w/index.php",
        api: "/w/api.php"
      },
      "^https?://wiki\.archlinux\.org": {
        short: "/index.php/",
        full: "/index.php",
        api: "/api.php"
      },
      "^https?://wiki\.archlinux\.de": {
        short: "/title/",
        full: "/index.php",
        api: "/api.php"
      },
      "^http://wiki\.archlinux\.fr": {
        short: "/",
        full: "/index.php",
        api: "/api.php"
      },
      "^https?://wiki\.archlinux\.jp": {
        short: "/index.php/",
        full: "/index.php",
        api: "/api.php"
      },
      "^http://wiki\.archlinux\.ro": {
        short: "/index.php/",
        full: "/index.php",
        api: "/api.php"
      },
      "^http://wiki\.archlinux\.ir": {
        short: "/index.php/",
        full: "/index.php",
        api: "/api.php"
      }
    },
    default_: {
      short: "/index.php?title=",
      full: "/index.php",
      api: "/api.php"
    }
  };

  interwikiFixes = [["https://wiki.archlinux.org/index.php/$1_(", "https://wiki.archlinux.org/index.php/$1%20("]];

  return exports;

})();
