// Generated by CoffeeScript 2.0.3
// Wiki Monkey - MediaWiki bot and editor-assistant user script
// Copyright (C) 2011 Dario Giovannetti <dev@dariogiovannetti.net>

// This file is part of Wiki Monkey.

// Wiki Monkey is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// Wiki Monkey is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with Wiki Monkey.  If not, see <http://www.gnu.org/licenses/>.
var CSS;

CSS = require('../../auxiliary/lib.js.generic/dist/CSS');

module.exports = class exports {
  constructor(WM) {
    this._previewFilter = this._previewFilter.bind(this);
    this._startAutomatic = this._startAutomatic.bind(this);
    this._startAutomaticContinue = this._startAutomaticContinue.bind(this);
    this.WM = WM;
    this.configuration = {
      plugin_name: null,
      function_: function() {},
      filters: [],
      list: {
        current: null,
        previous: null
      },
      visited: []
    };
    // localStorage can only store strings
    this.botToken = "0";
  }

  _makeUI(functions, lists) {
    var divContainer, fdiv;
    divContainer = document.createElement('div');
    divContainer.id = 'WikiMonkeyBot';
    CSS.addStyleElement("#WikiMonkeyBot-PluginSelect {width:100%; margin-bottom:1em;} #WikiMonkeyBot-ListSelect {margin-bottom:1em;} #WikiMonkeyBotFilter {height:6em; margin-bottom:1em; resize:vertical;} #WikiMonkeyBotStart, #WikiMonkeyBotStop {margin-right:0.33em; margin-bottom:1em; font-weight:bold;} a.WikiMonkeyBotSelected {background-color:#faa; padding:0.2em 0.4em;} a.WikiMonkeyBotProcessing {background-color:#ff8; padding:0.2em 0.4em;} a.WikiMonkeyBotChanged {background-color:#afa; padding:0.2em 0.4em;} a.WikiMonkeyBotUnchanged {background-color:#aaf; padding:0.2em 0.4em;} a.WikiMonkeyBotBypassed {background-color:orangered; padding:0.2em 0.4em;} a.WikiMonkeyBotFailed {background-color:red; padding:0.2em 0.4em;}");
    fdiv = this.makeFunctionUI(functions);
    if (fdiv) {
      divContainer.appendChild(fdiv);
      divContainer.appendChild(this.makeConfUI(lists));
      return divContainer;
    } else {
      return false;
    }
  }

  makeFunctionUI(functions) {
    var Plugin, divFunction, ffunctions, fieldset, i, legend, len, makeUI, option, plugin, pluginInst, selectFunctions, self;
    self = this;
    fieldset = document.createElement('fieldset');
    legend = document.createElement('legend');
    legend.innerHTML = 'Plugin';
    selectFunctions = document.createElement('select');
    selectFunctions.id = 'WikiMonkeyBot-PluginSelect';
    ffunctions = [];
    for (i = 0, len = functions.length; i < len; i++) {
      Plugin = functions[i];
      plugin = new Plugin(this.WM);
      pluginInst = plugin.conf.option_label;
      // This allows to disable an entry by giving it any second
      // parameter that evaluates to false
      if (!pluginInst || !pluginInst.length) {
        continue;
      }
      ffunctions.push(plugin);
      option = document.createElement('option');
      option.innerHTML = pluginInst;
      if (plugin.constructor.name === this.WM.conf.default_bot_plugin) {
        option.selected = true;
      }
      selectFunctions.appendChild(option);
    }
    if (ffunctions.length) {
      selectFunctions.addEventListener("change", (function(ffunctions) {
        return function() {
          var UI, id, makeUI, select;
          select = document.getElementById('WikiMonkeyBot-PluginSelect');
          id = select.selectedIndex;
          UI = document.getElementById('WikiMonkeyBotFunction');
          plugin = ffunctions[id];
          // [1] Note that this must also be executed immediately,
          //   see [2]
          makeUI = plugin.makeBotUI;
          if (makeUI instanceof Function) {
            UI.replaceChild(makeUI(), UI.firstChild);
          } else {
            // Don't removeChild, otherwise if another plugin with
            // interface is selected, replaceChild won't work
            UI.replaceChild(document.createElement('div'), UI.firstChild);
          }
          self.configuration.plugin_name = plugin.constructor.name;
          return self.configuration.function_ = function(title, callContinue, chainArgs) {
            return plugin.main_bot(title, callContinue, chainArgs);
          };
        };
      })(ffunctions), false);
      divFunction = document.createElement('div');
      divFunction.id = "WikiMonkeyBotFunction";
      plugin = ffunctions[selectFunctions.selectedIndex];
      // [2] Note that this is also executed onchange, see [1]
      makeUI = plugin.makeBotUI;
      if (makeUI instanceof Function) {
        divFunction.appendChild(makeUI());
      } else {
        divFunction.appendChild(document.createElement('div'));
      }
      this.configuration.plugin_name = plugin.constructor.name;
      this.configuration.function_ = function(title, callContinue, chainArgs) {
        return plugin.main_bot(title, callContinue, chainArgs);
      };
      fieldset.appendChild(legend);
      fieldset.appendChild(selectFunctions);
      fieldset.appendChild(divFunction);
      return fieldset;
    } else {
      return false;
    }
  }

  makeListSelector(lists) {
    var i, len, list, option, selectLists, self;
    self = this;
    selectLists = document.createElement('select');
    selectLists.id = 'WikiMonkeyBot-ListSelect';
    for (i = 0, len = lists.length; i < len; i++) {
      list = lists[i];
      if (list[0]) {
        option = document.createElement('option');
        option.innerHTML = list[2];
        selectLists.appendChild(option);
        if (!this.configuration.list.current) {
          // [1] Note that this is also executed onchange, see [2]
          this.configuration.list.current = list;
        }
      }
    }
    selectLists.addEventListener("change", (function(lss) {
      return function() {
        var id, select;
        select = document.getElementById('WikiMonkeyBot-ListSelect');
        id = select.selectedIndex;
        self.configuration.list.previous = self.configuration.list.current;
        // [2] Note that this must also be executed immediately,
        //   see [1]
        return self.configuration.list.current = lss[id];
      };
    })(lists), false);
    return selectLists;
  }

  makeConfUI(lists) {
    var bot, duplicates, duplicatestag, elem, elems, fieldset, filter, forceStart, forceStartCB, forceStartLabel, i, inverse, inversetag, legend, len, listSelect, preview, self, start, startMsg;
    self = this;
    bot = document.createElement('div');
    fieldset = document.createElement('fieldset');
    legend = document.createElement('legend');
    legend.innerHTML = 'Filter';
    listSelect = this.makeListSelector(lists);
    filter = document.createElement('textarea');
    filter.id = 'WikiMonkeyBotFilter';
    preview = document.createElement('input');
    preview.id = 'WikiMonkeyBotPreview';
    preview.type = 'button';
    preview.value = 'Preview';
    duplicates = document.createElement('input');
    duplicates.type = 'checkbox';
    duplicates.id = 'WikiMonkeyBotDuplicates';
    inverse = document.createElement('input');
    inverse.type = 'checkbox';
    inverse.id = 'WikiMonkeyBotInverse';
    elems = [filter, duplicates, inverse];
    for (i = 0, len = elems.length; i < len; i++) {
      elem = elems[i];
      elem.addEventListener("change", function() {
        return self._disableStartBot('Filters have changed, preview the selection');
      }, false);
    }
    duplicatestag = document.createElement('span');
    duplicatestag.innerHTML = 'Duplicates';
    inversetag = document.createElement('span');
    inversetag.innerHTML = 'Inverse';
    preview.addEventListener("click", this._previewFilter, false);
    fieldset.appendChild(legend);
    if (listSelect.length > 1) {
      fieldset.appendChild(listSelect);
    }
    fieldset.appendChild(filter);
    fieldset.appendChild(preview);
    fieldset.appendChild(duplicates);
    fieldset.appendChild(duplicatestag);
    fieldset.appendChild(inverse);
    fieldset.appendChild(inversetag);
    start = document.createElement('input');
    start.type = 'button';
    start.value = 'Start bot';
    start.id = 'WikiMonkeyBotStart';
    start.addEventListener("click", this._startAutomatic, false);
    start.disabled = true;
    startMsg = document.createElement('span');
    startMsg.innerHTML = 'Set and preview the filter first';
    startMsg.id = 'WikiMonkeyBotStartMsg';
    forceStart = document.createElement('span');
    forceStart.id = 'WikiMonkeyBotForceStart';
    forceStartCB = document.createElement('input');
    forceStartCB.type = 'checkbox';
    forceStartCB.disabled = true;
    forceStartLabel = document.createElement('span');
    forceStartLabel.innerHTML = 'Force start, stopping any other currently running bots';
    forceStart.style.display = "none";
    forceStart.appendChild(forceStartCB);
    forceStart.appendChild(forceStartLabel);
    bot.appendChild(fieldset);
    bot.appendChild(start);
    bot.appendChild(startMsg);
    bot.appendChild(forceStart);
    return bot;
  }

  _enableStartBot() {
    document.getElementById('WikiMonkeyBotStartMsg').innerHTML = '';
    return document.getElementById('WikiMonkeyBotStart').disabled = false;
  }

  _disableStartBot(message) {
    document.getElementById('WikiMonkeyBotStartMsg').innerHTML = message;
    return document.getElementById('WikiMonkeyBotStart').disabled = true;
  }

  _enableStopBot(stopId) {
    var self, start, stop;
    self = this;
    stop = document.createElement('input');
    stop.type = 'button';
    stop.value = 'Stop bot';
    stop.id = 'WikiMonkeyBotStop';
    stop.addEventListener("click", (function(id) {
      return function() {
        clearTimeout(id);
        // run _disableStopBot() here, not in _endAutomatic()
        self._disableStopBot();
        self._endAutomatic(true);
        return self.WM.Log.logInfo('Bot stopped manually');
      };
    })(stopId), false);
    start = document.getElementById('WikiMonkeyBotStart');
    start.parentNode.insertBefore(stop, start);
    return start.style.display = 'none';
  }

  _disableStopBot() {
    var stop;
    stop = document.getElementById('WikiMonkeyBotStop');
    stop.parentNode.removeChild(stop);
    return document.getElementById('WikiMonkeyBotStart').style.display = 'inline';
  }

  _disableControls() {
    return this._setEnableControls(true);
  }

  _reEnableControls() {
    return this._setEnableControls(false);
  }

  _setEnableControls(flag) {
    var fset, fsets, i, len, results;
    fsets = document.getElementById('WikiMonkeyBot').getElementsByTagName('fieldset');
    results = [];
    for (i = 0, len = fsets.length; i < len; i++) {
      fset = fsets[i];
      // HTML5-compliant
      results.push(fset.disabled = flag);
    }
    return results;
  }

  _enableForceStart() {
    var force;
    force = document.getElementById('WikiMonkeyBotForceStart');
    force.getElementsByTagName('input')[0].disabled = false;
    return force.style.display = 'inline';
  }

  _disableForceStart() {
    var force;
    force = document.getElementById('WikiMonkeyBotForceStart');
    force.getElementsByTagName('input')[0].checked = false;
    force.getElementsByTagName('input')[0].disabled = true;
    return force.style.display = 'none';
  }

  _canForceStart() {
    return document.getElementById('WikiMonkeyBotForceStart').getElementsByTagName('input')[0].checked;
  }

  makeFilters() {
    var exc, filter, filters, firstSlash, i, lastSlash, len, modifiers, negative, pattern, regexp;
    this.configuration.filters = [];
    filters = document.getElementById('WikiMonkeyBotFilter').value.split('\n');
    for (i = 0, len = filters.length; i < len; i++) {
      filter = filters[i];
      // filter could be an empty string
      if (filter) {
        firstSlash = filter.indexOf('/');
        lastSlash = filter.lastIndexOf('/');
        pattern = filter.substring(firstSlash + 1, lastSlash);
        modifiers = filter.substring(lastSlash + 1);
        negative = filter.charAt(0) === '!';
        try {
          regexp = new RegExp(pattern, modifiers);
        } catch (error) {
          exc = error;
          this.WM.Log.logError('Invalid regexp: ' + exc);
          return false;
        }
        this.configuration.filters.push([regexp, negative]);
      }
    }
    // Do not return nor break, so that if among the filters
    //   there's an invalid regexp the function returns false
    return true;
  }

  canProcessPage(link) {
    var duplicates, filter, filters, i, inverse, len, negative, regexp, test, title;
    // Exclude red links (they can be found in some special pages)
    if (link.className.split(" ").indexOf("new") < 0) {
      // Don't use link.title because for example in Category pages all
      //   subpages would include "Category:", thus always matching
      //   filters like "/a/", "/t/" etc.
      title = link.innerHTML;
      duplicates = document.getElementById('WikiMonkeyBotDuplicates').checked;
      if (duplicates || this.configuration.visited.indexOf(title) < 0) {
        this.configuration.visited.push(title);
        filters = this.configuration.filters;
        inverse = document.getElementById('WikiMonkeyBotInverse').checked;
        if (filters.length > 0) {
          for (i = 0, len = filters.length; i < len; i++) {
            filter = filters[i];
            regexp = filter[0];
            negative = filter[1];
            test = regexp.test(title);
            if (test !== negative) {
              if (inverse) {
                return false;
              } else {
                return true;
              }
            }
          }
          // No (test != negative) condition has been met in the loop
          if (inverse) {
            return true;
          } else {
            return false;
          }
        } else {
          if (inverse) {
            return false;
          } else {
            return true;
          }
        }
      } else {
        return false;
      }
    } else {
      return false;
    }
  }

  changeWikiMonkeyLinkClassName(className, newClass) {
    var classes, cls, i, len, newClasses;
    classes = className.split(" ");
    newClasses = [];
    for (i = 0, len = classes.length; i < len; i++) {
      cls = classes[i];
      if (cls.indexOf("WikiMonkey") < 0) {
        newClasses.push(cls);
      }
    }
    // Don't push in an else block inside the loop, so that if there was
    // no WikiMonkey class set, it will be added
    newClasses.push(newClass);
    return newClasses.join(" ");
  }

  restoreOriginalLinkClassName(className) {
    var classes, cls, i, len, origClasses;
    classes = className.split(" ");
    origClasses = [];
    for (i = 0, len = classes.length; i < len; i++) {
      cls = classes[i];
      if (cls.indexOf("WikiMonkey") < 0) {
        origClasses.push(cls);
      }
    }
    return origClasses.join(" ");
  }

  _previewFilter() {
    var N, enable, i, item, items, j, len, len1, link, linkId;
    this.WM.Log.logInfo('Updating filter preview, please wait ...');
    this._disableStartBot('Updating filter preview ...');
    if (this.configuration.list.previous) {
      if (this.configuration.list.current[0].nodeName === 'TBODY') {
        items = this.configuration.list.previous[0].getElementsByTagName('td');
      } else {
        items = this.configuration.list.previous[0].getElementsByTagName('li');
      }
      linkId = this.configuration.list.previous[1];
      for (i = 0, len = items.length; i < len; i++) {
        item = items[i];
        link = item.getElementsByTagName('a')[linkId];
        // The list item could refer to an invalid title, represented
        // by e.g. <span class="mw-invalidtitle">Invalid title with
        // namespace "Category" and text ""</span>
        if (link) {
          link.className = this.restoreOriginalLinkClassName(link.className);
        }
      }
    }
    this.configuration.visited = [];
    linkId = this.configuration.list.current[1];
    enable = false;
    N = 0;
    if (this.makeFilters()) {
      if (this.configuration.list.current[0].nodeName === 'TBODY') {
        items = this.configuration.list.current[0].getElementsByTagName('td');
      } else {
        items = this.configuration.list.current[0].getElementsByTagName('li');
      }
      for (j = 0, len1 = items.length; j < len1; j++) {
        item = items[j];
        link = item.getElementsByTagName('a')[linkId];
        // Also test 'link' itself, because the list item could refer
        // to an invalid title, represented by e.g.
        // <span class="mw-invalidtitle">Invalid title with namespace
        // "Category" and text ""</span>
        if (link) {
          if (this.canProcessPage(link)) {
            link.className = this.changeWikiMonkeyLinkClassName(link.className, 'WikiMonkeyBotSelected');
            enable = true;
            N++;
          } else {
            link.className = this.restoreOriginalLinkClassName(link.className);
          }
        }
      }
    }
    this.WM.Log.logInfo('Preview updated (' + N + ' pages selected)');
    if (enable) {
      return this._enableStartBot();
    } else {
      return this._disableStartBot('No pages selected, reset and preview the filter');
    }
  }

  _setBotToken() {
    var date, token;
    date = new Date();
    token = date.getTime() + "";
    this.botToken = token;
    return localStorage.setItem('WikiMonkeyBotToken', token);
  }

  _resetBotToken(reset) {
    this.botToken = "0";
    if (reset) {
      return localStorage.setItem('WikiMonkeyBotToken', "0");
    }
  }

  _getBotToken() {
    return this.botToken;
  }

  _checkOtherBotsRunning() {
    var value;
    value = localStorage.getItem('WikiMonkeyBotToken');
    // value may be null if it's never been stored in localStorage
    return value && value !== "0" && value !== this._getBotToken();
  }

  _startAutomatic() {
    var i, item, items, itemsDOM, len, linkId;
    if (this._checkOtherBotsRunning() && !this._canForceStart()) {
      this.WM.Log.logError("It's not possible to start the bot (without forcing it) for one of the following reasons:<br> * another bot instance is currently running<br> * a previously running bot has stopped due to a page processing error<br> * a previously running bot has stopped due to a Javascript error<br> * a previously running bot has been interrupted by a browser page refresh");
      return this._enableForceStart();
    } else if (this.makeFilters()) {
      if (this.configuration.list.current[0].nodeName === 'TBODY') {
        itemsDOM = this.configuration.list.current[0].getElementsByTagName('td');
      } else {
        itemsDOM = this.configuration.list.current[0].getElementsByTagName('li');
      }
      // Passing the live collection with the callback function was
      //   causing it to be lost in an apparently random manner
      items = [];
      for (i = 0, len = itemsDOM.length; i < len; i++) {
        item = itemsDOM[i];
        items.push(item);
      }
      linkId = this.configuration.list.current[1];
      this._disableForceStart();
      this._setBotToken();
      this.WM.Log.logInfo('Starting bot ...');
      this.WM.Log.logHidden("Plugin: " + this.configuration.plugin_name);
      this.WM.Log.logHidden("Filter: " + document.getElementById('WikiMonkeyBotFilter').value);
      this._disableStartBot('Bot is running ...');
      this._disableControls();
      this.configuration.visited = [];
      return this.WM.MW.isUserBot(this._startAutomaticContinue, [items, linkId]);
    }
  }

  _startAutomaticContinue(botTest, args) {
    var items, linkId;
    items = args[0];
    linkId = args[1];
    this.configuration.interval = botTest ? 3000 : 30000;
    return this._processItem(0, items, 0, linkId, null);
  }

  makeCallContinue(lis, id, linkId, ln, article) {
    var self;
    self = this;
    return function(status, resArgs) {
      switch (status) {
        // The article hasn't been saved
        case 0:
          ln.className = self.changeWikiMonkeyLinkClassName(ln.className, 'WikiMonkeyBotUnchanged');
          self.WM.Log.logInfo(self.WM.Log.linkToWikiPage(article, article) + " processed (unchanged)");
          id++;
          self._processItem(status, lis, id, linkId, resArgs);
          break;
        // The article has been saved
        case 1:
          ln.className = self.changeWikiMonkeyLinkClassName(ln.className, 'WikiMonkeyBotChanged');
          self.WM.Log.logInfo(self.WM.Log.linkToWikiPage(article, article) + " processed (changed)");
          id++;
          self._processItem(status, lis, id, linkId, resArgs);
          break;
        // The plugin has encountered a protectedpage error
        case 'protectedpage':
          ln.className = self.changeWikiMonkeyLinkClassName(ln.className, 'WikiMonkeyBotBypassed');
          self.WM.Log.logWarning("This user doesn't have the rights to " + "edit " + self.WM.Log.linkToWikiPage(article, article) + ", bypassing it ...");
          id++;
          // Change status to 0 (page not changed)
          self._processItem(0, lis, id, linkId, resArgs);
          break;
        default:
          // The plugin has encountered a critical error
          ln.className = self.changeWikiMonkeyLinkClassName(ln.className, 'WikiMonkeyBotFailed');
          self.WM.Log.logError("Error processing " + self.WM.Log.linkToWikiPage(article, article) + ", stopping the bot");
          return self._endAutomatic(true);
      }
    };
  }

  _processItem(status, items, index, linkId, chainArgs) {
    var interval, link, self, stopId, title;
    self = this;
    if (items[index]) {
      link = items[index].getElementsByTagName('a')[linkId];
      // Also test 'link' itself, because the list item could refer to an
      // invalid title, represented by e.g.
      // <span class="mw-invalidtitle">Invalid title with namespace
      // "Category" and text ""</span>
      if (link && this.canProcessPage(link)) {
        title = link.title;
        if (status === 0) {
          interval = 1000;
        } else {
          interval = this.configuration.interval;
        }
        this.WM.Log.logInfo('Waiting ' + (interval / 1000) + ' seconds ...');
        stopId = setTimeout((function(lis, id, ln, article, chainArgs) {
          return function() {
            // Stop must be disabled before any check is performed
            self._disableStopBot();
            // Check here if other bots have been started,
            // _not_ before setTimeout!
            if (!self._checkOtherBotsRunning()) {
              ln.className = self.changeWikiMonkeyLinkClassName(ln.className, 'WikiMonkeyBotProcessing');
              self.WM.Log.logInfo("Processing " + self.WM.Log.linkToWikiPage(article, article) + " ...");
              return self.configuration.function_(article, self.makeCallContinue(lis, id, linkId, ln, article), chainArgs);
            } else {
              self.WM.Log.logError('Another bot has been ' + 'force-started, stopping ...');
              return self._endAutomatic(false);
            }
          };
        })(items, index, link, title, chainArgs), interval);
        return this._enableStopBot(stopId);
      } else {
        index++;
        return this._processItem(status, items, index, linkId, chainArgs);
      }
    } else {
      return this._endAutomatic(true);
    }
  }

  _endAutomatic(reset) {
    this._resetBotToken(reset);
    this.WM.Log.logInfo('Bot operations completed (check the log for ' + 'warnings or errors)');
    this._disableStartBot('Bot operations completed, reset and preview ' + 'the filter');
    return this._reEnableControls();
  }

};
